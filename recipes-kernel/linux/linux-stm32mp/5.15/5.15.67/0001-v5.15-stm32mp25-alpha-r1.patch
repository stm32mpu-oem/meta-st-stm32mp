From 5b76942ecb29fc4fe4a8360e7acc4456ca18f84e Mon Sep 17 00:00:00 2001
From: Christophe Priouzeau <christophe.priouzeau@foss.st.com>
Date: Wed, 2 Nov 2022 10:46:59 +0100
Subject: [PATCH] v5.15-stm32mp25-alpha-r1

Signed-off-by: Christophe Priouzeau <christophe.priouzeau@foss.st.com>
---
 CONTRIBUTING.md                               |   30 +
 Documentation/admin-guide/perf/index.rst      |    1 +
 .../admin-guide/perf/stm32-ddr-pmu.rst        |   42 +
 Documentation/arm/index.rst                   |    1 +
 .../arm/stm32/stm32mp13-overview.rst          |   37 +
 .../arm/stm32/stm32mp257-overview.rst         |   19 +
 .../arm/firmware/linaro,optee-tz.yaml         |    8 +
 .../bindings/arm/stm32/st,stm32-syscon.yaml   |    5 +
 .../devicetree/bindings/arm/stm32/stm32.yaml  |   13 +
 .../bindings/cpufreq/stm32-cpufreq.txt        |   61 +
 .../bindings/crypto/st,stm32-cryp.yaml        |    9 +
 .../bindings/crypto/st,stm32-hash.yaml        |    1 +
 .../bindings/display/panel/lvds.yaml          |   10 +-
 .../bindings/display/panel/panel-dpi.yaml     |   10 +
 .../display/panel/rocktech,hx8394.yaml        |   56 +
 .../devicetree/bindings/dma/st,stm32-dma.yaml |   47 +
 .../bindings/dma/st,stm32-dma3.yaml           |  134 +
 .../bindings/dma/st,stm32-mdma.yaml           |   12 +-
 .../devicetree/bindings/hwlock/hwlock.txt     |   27 +-
 .../bindings/hwlock/st,stm32-hwspinlock.yaml  |    4 +-
 .../devicetree/bindings/i2c/st,stm32-i2c.yaml |   35 +-
 .../iio/adc/sigma-delta-modulator.yaml        |    3 +
 .../bindings/iio/adc/st,stm32-adc.yaml        |  240 +-
 .../interrupt-controller/st,stm32-exti.yaml   |   39 +-
 .../leds/backlight/gpio-backlight.yaml        |    9 +
 .../bindings/media/i2c/galaxycore,gc2145.yaml |  115 +
 .../bindings/media/st,stm32-csi2host.yaml     |  114 +
 .../bindings/media/st,stm32-dcmipp.yaml       |  121 +
 .../bindings/media/st,stm32mp25-vdec.yaml     |   56 +
 .../bindings/media/st,stm32mp25-venc.yaml     |   57 +
 .../memory-controllers/st,stm32-fmc2-ebi.yaml |    4 +-
 .../memory-controllers/st,stm32-omi.yaml      |  194 +
 .../bindings/mfd/st,stm32-lptimer.yaml        |   23 +-
 .../bindings/mfd/st,stm32mp1-pwr.txt          |   57 +
 .../bindings/misc/st,stm32-omm.yaml           |  179 +
 .../devicetree/bindings/mmc/arm,pl18x.yaml    |   12 +
 .../bindings/mtd/nand-controller.yaml         |    7 +
 .../bindings/mtd/st,stm32-fmc2-nand.yaml      |   58 +-
 .../devicetree/bindings/net/stm32-dwmac.yaml  |    5 +
 .../devicetree/bindings/net/stm32-ttt.yaml    |   90 +
 .../bindings/nvmem/st,stm32-romem.yaml        |   18 +
 .../bindings/pci/st,stm32-pcie-host.yaml      |  135 +
 .../bindings/perf/stm32-ddr-pmu.yaml          |   55 +
 .../bindings/phy/phy-stm32-usbphyc.yaml       |  133 +
 .../bindings/phy/st,stm32-combophy.yaml       |  121 +
 .../bindings/phy/st,stm32-femtophy.yaml       |  184 +
 .../bindings/pinctrl/st,stm32-pinctrl.yaml    |   60 +-
 .../regulator/protection-consumer.txt         |   23 +
 .../bindings/regulator/st,stm32-vrefbuf.yaml  |    4 +-
 .../bindings/remoteproc/rproc-srm.txt         |   58 +
 .../bindings/remoteproc/st,stm32-rproc.yaml   |   37 +-
 .../devicetree/bindings/rng/st,stm32-rng.yaml |    4 +-
 .../devicetree/bindings/rtc/st,stm32-rtc.yaml |   37 +
 .../devicetree/bindings/serial/rs485.yaml     |   14 +
 .../bindings/serial/st,stm32-uart.yaml        |    5 +
 .../bindings/soc/stm32/st,stm32mp1-hslv.yaml  |   44 +
 .../bindings/soc/stm32/stm32_hdp.txt          |   39 +
 .../bindings/sound/st,stm32-sai.yaml          |   29 +-
 .../bindings/spi/st,stm32-qspi.yaml           |    8 +
 .../devicetree/bindings/spi/st,stm32-spi.yaml |   23 +
 .../devicetree/bindings/usb/dwc2.yaml         |   33 +-
 .../devicetree/bindings/usb/generic-ehci.yaml |    5 +
 .../devicetree/bindings/usb/generic-ohci.yaml |    5 +
 .../bindings/usb/st,typec-stm32g0.yaml        |   83 +
 .../devicetree/bindings/usb/stm32,dwc3.yaml   |   81 +
 .../devicetree/bindings/usb/stm32,usb2h.yaml  |   91 +
 .../devicetree/bindings/vendor-prefixes.yaml  |    4 +
 Documentation/locking/hwspinlock.rst          |   10 +-
 Documentation/staging/remoteproc.rst          |   22 +
 Documentation/staging/tee.rst                 |   30 +
 MAINTAINERS                                   |   25 +
 SECURITY.md                                   |    8 +
 arch/arm/Kconfig.debug                        |    2 +-
 arch/arm/boot/dts/Makefile                    |   60 +
 arch/arm/boot/dts/stm32mp13-pinctrl.dtsi      |  644 +++
 arch/arm/boot/dts/stm32mp131.dtsi             | 1742 ++++++
 arch/arm/boot/dts/stm32mp133.dtsi             |  100 +
 arch/arm/boot/dts/stm32mp135.dtsi             |   32 +
 .../boot/dts/stm32mp135f-dk-a7-examples.dts   |   22 +
 arch/arm/boot/dts/stm32mp135f-dk.dts          |  701 +++
 arch/arm/boot/dts/stm32mp13xa.dtsi            |    5 +
 arch/arm/boot/dts/stm32mp13xc.dtsi            |   21 +
 arch/arm/boot/dts/stm32mp13xd.dtsi            |    5 +
 arch/arm/boot/dts/stm32mp13xf.dtsi            |   21 +
 .../boot/dts/stm32mp15-m4-srm-pinctrl.dtsi    |  524 ++
 arch/arm/boot/dts/stm32mp15-m4-srm.dtsi       |  447 ++
 arch/arm/boot/dts/stm32mp15-pinctrl.dtsi      |  316 +-
 arch/arm/boot/dts/stm32mp151.dtsi             |  657 ++-
 arch/arm/boot/dts/stm32mp153.dtsi             |   15 +-
 arch/arm/boot/dts/stm32mp157.dtsi             |    3 +-
 .../boot/dts/stm32mp157a-dk1-a7-examples.dts  |   95 +
 .../boot/dts/stm32mp157a-dk1-m4-examples.dts  |  128 +
 arch/arm/boot/dts/stm32mp157a-dk1.dts         |    8 +-
 arch/arm/boot/dts/stm32mp157a-ed1.dts         |   32 +
 arch/arm/boot/dts/stm32mp157a-ev1.dts         |  103 +
 .../boot/dts/stm32mp157c-dk2-a7-examples.dts  |   95 +
 .../boot/dts/stm32mp157c-dk2-m4-examples.dts  |  128 +
 arch/arm/boot/dts/stm32mp157c-dk2.dts         |   64 +-
 arch/arm/boot/dts/stm32mp157c-ed1.dts         |  374 +-
 .../boot/dts/stm32mp157c-ev1-a7-examples.dts  |   57 +
 .../boot/dts/stm32mp157c-ev1-m4-examples.dts  |  150 +
 arch/arm/boot/dts/stm32mp157c-ev1.dts         |  326 +-
 .../boot/dts/stm32mp157d-dk1-a7-examples.dts  |   95 +
 .../boot/dts/stm32mp157d-dk1-m4-examples.dts  |  128 +
 arch/arm/boot/dts/stm32mp157d-dk1.dts         |   26 +
 arch/arm/boot/dts/stm32mp157d-ed1.dts         |   32 +
 arch/arm/boot/dts/stm32mp157d-ev1.dts         |  103 +
 .../boot/dts/stm32mp157f-dk2-a7-examples.dts  |   95 +
 .../boot/dts/stm32mp157f-dk2-m4-examples.dts  |  128 +
 arch/arm/boot/dts/stm32mp157f-dk2.dts         |  151 +
 arch/arm/boot/dts/stm32mp157f-ed1.dts         |   36 +
 .../boot/dts/stm32mp157f-ev1-a7-examples.dts  |   57 +
 .../boot/dts/stm32mp157f-ev1-m4-examples.dts  |  151 +
 arch/arm/boot/dts/stm32mp157f-ev1.dts         |   99 +
 arch/arm/boot/dts/stm32mp15xa.dtsi            |   13 +
 arch/arm/boot/dts/stm32mp15xc.dtsi            |    9 +-
 arch/arm/boot/dts/stm32mp15xd.dtsi            |   42 +
 arch/arm/boot/dts/stm32mp15xf.dtsi            |   23 +
 arch/arm/boot/dts/stm32mp15xx-dhcom-som.dtsi  |   12 +-
 .../boot/dts/stm32mp15xx-dhcor-avenger96.dtsi |   28 +-
 arch/arm/boot/dts/stm32mp15xx-dkx.dtsi        |  143 +-
 arch/arm/boot/dts/stm32mp15xx-edx.dtsi        |  429 ++
 arch/arm/boot/dts/stm32mp15xx-evx.dtsi        |  698 +++
 .../fragment-01-multiv7_cleanup.config        |  408 ++
 .../configs/fragment-02-multiv7_addons.config |  426 ++
 arch/arm/configs/multi_v7_defconfig           |    1 +
 arch/arm/mach-stm32/Kconfig                   |   16 +
 arch/arm/mach-stm32/board-dt.c                |    9 +
 arch/arm/mm/proc-v7.S                         |   10 +-
 arch/arm64/Kconfig.platforms                  |   16 +
 arch/arm64/boot/dts/Makefile                  |    1 +
 arch/arm64/boot/dts/st/Makefile               |    6 +
 .../boot/dts/st/stm32mp25-pinctrl-test.dtsi   |  707 +++
 arch/arm64/boot/dts/st/stm32mp25-pinctrl.dtsi |    7 +
 arch/arm64/boot/dts/st/stm32mp251.dtsi        | 1732 ++++++
 arch/arm64/boot/dts/st/stm32mp253.dtsi        |   82 +
 arch/arm64/boot/dts/st/stm32mp255.dtsi        |   44 +
 arch/arm64/boot/dts/st/stm32mp257.dtsi        |   50 +
 arch/arm64/boot/dts/st/stm32mp257f-dk.dts     |   29 +
 arch/arm64/boot/dts/st/stm32mp257f-ev.dts     |   29 +
 .../stm32mp257f-valid3-ca35tdcid-resmem.dtsi  |  193 +
 .../dts/st/stm32mp257f-valid3-daughter.dts    |  303 +
 arch/arm64/boot/dts/st/stm32mp257f-valid3.dts |  485 ++
 arch/arm64/boot/dts/st/stm32mp25xc.dtsi       |    8 +
 arch/arm64/boot/dts/st/stm32mp25xf.dtsi       |    8 +
 .../boot/dts/st/stm32mp25xxai-pinctrl.dtsi    |   83 +
 .../boot/dts/st/stm32mp25xxak-pinctrl.dtsi    |   71 +
 .../boot/dts/st/stm32mp25xxal-pinctrl.dtsi    |   71 +
 .../fragment-01-defconfig-cleanup.config      |   39 +
 .../fragment-02-defconfig-addons.config       |   89 +
 drivers/char/hw_random/stm32-rng.c            |  229 +-
 drivers/clk/Kconfig                           |   10 +
 drivers/clk/Makefile                          |    1 +
 drivers/clk/clk-composite.c                   |   15 +
 drivers/clk/clk-scmi.c                        |   36 +
 drivers/clk/clk-stm32mp1.c                    | 1656 +++++-
 drivers/clk/clk.c                             |    7 +-
 drivers/clk/stm32/Makefile                    |    2 +
 drivers/clk/stm32/clk-stm32-core.c            |  864 +++
 drivers/clk/stm32/clk-stm32-core.h            |  272 +
 drivers/clk/stm32/clk-stm32mp13.c             | 1760 ++++++
 drivers/clk/stm32/clk-stm32mp2.c              | 2036 +++++++
 drivers/clk/stm32/reset-stm32.c               |  161 +
 drivers/clk/stm32/reset-stm32.h               |    7 +
 drivers/clk/stm32/stm32mp13_rcc.h             | 1751 ++++++
 drivers/clk/stm32/stm32mp2_rcc.h              | 4983 +++++++++++++++++
 drivers/clocksource/timer-stm32-lp.c          |    4 +-
 drivers/counter/stm32-lptimer-cnt.c           |    3 +-
 drivers/cpufreq/Kconfig.arm                   |    7 +
 drivers/cpufreq/Makefile                      |    1 +
 drivers/cpufreq/cpufreq-dt-platdev.c          |    1 +
 drivers/cpufreq/stm32-cpufreq.c               |  103 +
 drivers/cpuidle/Kconfig.arm                   |    8 +
 drivers/cpuidle/Makefile                      |    1 +
 drivers/cpuidle/cpuidle-stm32.c               |  276 +
 drivers/crypto/stm32/stm32-cryp.c             |  741 ++-
 drivers/crypto/stm32/stm32-hash.c             |  999 +++-
 drivers/dma/Kconfig                           |   11 +
 drivers/dma/Makefile                          |    1 +
 drivers/dma/stm32-dma.c                       | 1169 +++-
 drivers/dma/stm32-dma3.c                      | 2120 +++++++
 drivers/dma/stm32-dmamux.c                    |    2 +-
 drivers/dma/stm32-mdma.c                      |  147 +-
 drivers/firmware/Kconfig                      |    2 +-
 drivers/firmware/arm_scmi/Makefile            |    1 +
 drivers/firmware/arm_scmi/clock.c             |   78 +
 drivers/firmware/arm_scmi/common.h            |    3 +
 drivers/firmware/arm_scmi/driver.c            |    3 +
 drivers/firmware/arm_scmi/optee.c             |  848 +++
 drivers/gpio/gpiolib.c                        |   20 +-
 drivers/gpu/drm/bridge/sii902x.c              |  100 +-
 drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c |    5 +-
 drivers/gpu/drm/drm_atomic_uapi.c             |    4 +
 drivers/gpu/drm/drm_bridge.c                  |   10 +-
 drivers/gpu/drm/drm_connector.c               |   62 +
 drivers/gpu/drm/panel/Kconfig                 |    9 +
 drivers/gpu/drm/panel/Makefile                |    1 +
 .../gpu/drm/panel/panel-orisetech-otm8009a.c  |  101 +-
 drivers/gpu/drm/panel/panel-raydium-rm68200.c |    7 +-
 drivers/gpu/drm/panel/panel-rocktech-hx8394.c |  397 ++
 drivers/gpu/drm/panel/panel-simple.c          |   16 +
 drivers/gpu/drm/stm/Kconfig                   |    6 +
 drivers/gpu/drm/stm/Makefile                  |    2 +
 drivers/gpu/drm/stm/drv.c                     |    6 +
 drivers/gpu/drm/stm/dw_mipi_dsi-stm.c         |  600 +-
 drivers/gpu/drm/stm/ltdc.c                    | 1203 +++-
 drivers/gpu/drm/stm/ltdc.h                    |   28 +-
 drivers/gpu/drm/stm/lvds.c                    | 1152 ++++
 drivers/hwspinlock/Kconfig                    |    2 +-
 drivers/hwspinlock/hwspinlock_core.c          |   80 +-
 drivers/hwspinlock/hwspinlock_internal.h      |    2 +
 drivers/hwspinlock/stm32_hwspinlock.c         |   58 +-
 drivers/i2c/busses/i2c-stm32f7.c              |  458 +-
 drivers/iio/adc/sd_adc_modulator.c            |   89 +-
 drivers/iio/adc/stm32-adc-core.c              |  292 +-
 drivers/iio/adc/stm32-adc-core.h              |  111 +
 drivers/iio/adc/stm32-adc.c                   | 1111 +++-
 drivers/iio/adc/stm32-dfsdm-adc.c             |  108 +-
 drivers/iio/adc/stm32-dfsdm-core.c            |   91 +-
 drivers/iio/adc/stm32-dfsdm.h                 |   69 +-
 drivers/iio/trigger/stm32-lptimer-trigger.c   |   15 +-
 drivers/input/touchscreen/Kconfig             |    1 +
 drivers/input/touchscreen/edt-ft5x06.c        |   20 +
 drivers/input/touchscreen/goodix.c            |   39 +-
 drivers/input/touchscreen/ili210x.c           |  559 +-
 drivers/irqchip/irq-stm32-exti.c              |  427 +-
 drivers/mailbox/Kconfig                       |    2 +-
 drivers/media/i2c/Kconfig                     |   12 +
 drivers/media/i2c/Makefile                    |    1 +
 drivers/media/i2c/gc2145.c                    | 1949 +++++++
 drivers/media/i2c/imx335.c                    |  109 +-
 drivers/media/i2c/ov5640.c                    |  459 +-
 drivers/media/i2c/st-mipid02.c                |   10 +-
 drivers/media/platform/Kconfig                |   26 +
 drivers/media/platform/stm32/Makefile         |    2 +
 drivers/media/platform/stm32/stm32-csi2host.c | 1144 ++++
 drivers/media/platform/stm32/stm32-dcmi.c     |  129 +-
 .../platform/stm32/stm32-dcmipp/Makefile      |    5 +
 .../stm32/stm32-dcmipp/dcmipp-bytecap.c       | 1112 ++++
 .../stm32/stm32-dcmipp/dcmipp-byteproc.c      |  844 +++
 .../stm32/stm32-dcmipp/dcmipp-colorconv.c     |  362 ++
 .../stm32/stm32-dcmipp/dcmipp-colorconv.h     |   26 +
 .../stm32/stm32-dcmipp/dcmipp-common.c        |  116 +
 .../stm32/stm32-dcmipp/dcmipp-common.h        |  240 +
 .../platform/stm32/stm32-dcmipp/dcmipp-core.c |  816 +++
 .../platform/stm32/stm32-dcmipp/dcmipp-isp.c  | 1005 ++++
 .../stm32/stm32-dcmipp/dcmipp-parallel.c      |  497 ++
 .../stm32/stm32-dcmipp/dcmipp-pixelcap.c      | 1266 +++++
 .../stm32/stm32-dcmipp/dcmipp-pixelproc.c     |  894 +++
 drivers/media/v4l2-core/v4l2-fwnode.c         |    3 +
 drivers/memory/Kconfig                        |   10 +-
 drivers/memory/Makefile                       |    1 +
 drivers/memory/stm32-fmc2-ebi.c               |  405 +-
 drivers/memory/stm32-omi.c                    |  559 ++
 drivers/mfd/Kconfig                           |   10 +
 drivers/mfd/Makefile                          |    1 +
 drivers/mfd/stm32-lptimer.c                   |   37 +-
 drivers/mfd/stm32-pwr.c                       |  423 ++
 drivers/mfd/stmfx.c                           |    2 -
 drivers/mfd/stpmic1.c                         |    6 +
 drivers/mfd/wm8994-core.c                     |    6 +
 drivers/misc/Kconfig                          |   17 +
 drivers/misc/Makefile                         |    1 +
 drivers/misc/stm32_omm.c                      |  516 ++
 drivers/mmc/host/mmci.c                       |   42 +-
 drivers/mmc/host/mmci.h                       |    8 +-
 drivers/mmc/host/mmci_stm32_sdmmc.c           |  261 +-
 drivers/mtd/hyperbus/Kconfig                  |    6 +
 drivers/mtd/hyperbus/Makefile                 |    2 +
 drivers/mtd/hyperbus/hyperbus-stm32.c         |  434 ++
 drivers/mtd/nand/raw/Kconfig                  |    2 +-
 drivers/mtd/nand/raw/stm32_fmc2_nand.c        |  148 +-
 .../net/ethernet/stmicro/stmmac/dwmac-stm32.c |  327 +-
 drivers/net/phy/phy_device.c                  |    2 +-
 drivers/net/phy/realtek.c                     |   22 +-
 drivers/net/phy/smsc.c                        |  102 +
 .../broadcom/brcm80211/brcmfmac/bcmsdh.c      |   39 +-
 drivers/nvmem/stm32-romem.c                   |  658 ++-
 drivers/of/platform.c                         |    4 +
 drivers/pci/controller/dwc/Kconfig            |   13 +
 drivers/pci/controller/dwc/Makefile           |    1 +
 drivers/pci/controller/dwc/pcie-stm32.c       |  368 ++
 drivers/perf/Kconfig                          |    7 +
 drivers/perf/Makefile                         |    1 +
 drivers/perf/stm32_ddr_pmu.c                  |  560 ++
 drivers/phy/st/Kconfig                        |   18 +
 drivers/phy/st/Makefile                       |    2 +
 drivers/phy/st/phy-stm32-combophy.c           |  367 ++
 drivers/phy/st/phy-stm32-usb2femto.c          |  583 ++
 drivers/phy/st/phy-stm32-usbphyc.c            |  233 +-
 drivers/pinctrl/stm32/Kconfig                 |    6 +
 drivers/pinctrl/stm32/Makefile                |    1 +
 drivers/pinctrl/stm32/pinctrl-stm32.c         |  466 +-
 drivers/pinctrl/stm32/pinctrl-stm32.h         |   20 +-
 drivers/pinctrl/stm32/pinctrl-stm32mp135.c    |    3 +-
 drivers/pinctrl/stm32/pinctrl-stm32mp157.c    |    2 +-
 drivers/pinctrl/stm32/pinctrl-stm32mp257.c    | 2583 +++++++++
 drivers/ptp/ptp_chardev.c                     |   23 +
 drivers/ptp/ptp_clock.c                       |   20 +
 drivers/ptp/ptp_private.h                     |    3 +
 drivers/pwm/pwm-stm32-lp.c                    |  223 +-
 drivers/pwm/pwm-stm32.c                       |    4 +
 drivers/regulator/Kconfig                     |   11 +
 drivers/regulator/Makefile                    |    1 +
 drivers/regulator/protection-consumer.c       |  137 +
 drivers/regulator/scmi-regulator.c            |   99 +-
 drivers/regulator/stm32-pwr.c                 |   85 +-
 drivers/regulator/stm32-vrefbuf.c             |   69 +-
 drivers/regulator/stpmic1_regulator.c         |  182 +-
 drivers/remoteproc/Kconfig                    |   29 +
 drivers/remoteproc/Makefile                   |    3 +
 drivers/remoteproc/remoteproc_core.c          |    8 +
 drivers/remoteproc/remoteproc_sysfs.c         |   25 +
 drivers/remoteproc/rproc_srm_core.c           |  303 +
 drivers/remoteproc/rproc_srm_core.h           |   98 +
 drivers/remoteproc/rproc_srm_dev.c            |  744 +++
 drivers/remoteproc/stm32_rproc.c              |  572 +-
 drivers/remoteproc/tee_remoteproc.c           |  385 ++
 drivers/rpmsg/Kconfig                         |    8 +
 drivers/rpmsg/Makefile                        |    1 +
 drivers/rpmsg/qcom_glink_native.c             |    2 +-
 drivers/rpmsg/qcom_smd.c                      |    2 +-
 drivers/rpmsg/rpmsg_char.c                    |  229 +-
 drivers/rpmsg/rpmsg_char.h                    |   46 +
 drivers/rpmsg/rpmsg_core.c                    |   36 +-
 drivers/rpmsg/rpmsg_ctrl.c                    |  243 +
 drivers/rpmsg/rpmsg_internal.h                |   12 +-
 drivers/rpmsg/virtio_rpmsg_bus.c              |   12 +-
 drivers/rtc/Kconfig                           |    1 +
 drivers/rtc/rtc-stm32.c                       |  365 +-
 drivers/soc/Kconfig                           |    1 +
 drivers/soc/Makefile                          |    1 +
 drivers/soc/st/Kconfig                        |   25 +
 drivers/soc/st/Makefile                       |    3 +
 drivers/soc/st/stm32-hslv.c                   |  157 +
 drivers/soc/st/stm32_hdp.c                    |  242 +
 drivers/soc/st/stm32_pm_domain.c              |  212 +
 drivers/spi/Kconfig                           |   12 +
 drivers/spi/Makefile                          |    1 +
 drivers/spi/spi-mem.c                         |    2 +-
 drivers/spi/spi-stm32-ospi.c                  |  615 ++
 drivers/spi/spi-stm32-qspi.c                  |  151 +-
 drivers/spi/spi-stm32.c                       |  455 +-
 drivers/staging/media/hantro/Kconfig          |   14 +-
 drivers/staging/media/hantro/Makefile         |    4 +
 drivers/staging/media/hantro/hantro.h         |    2 +
 drivers/staging/media/hantro/hantro_drv.c     |   24 +-
 .../staging/media/hantro/hantro_g1_h264_dec.c |   24 +-
 .../media/hantro/hantro_g1_mpeg2_dec.c        |    2 +-
 drivers/staging/media/hantro/hantro_g1_regs.h |    1 +
 .../staging/media/hantro/hantro_g1_vp8_dec.c  |    8 +-
 .../staging/media/hantro/hantro_h1_jpeg_enc.c |    2 +-
 drivers/staging/media/hantro/hantro_h1_regs.h |    3 +
 drivers/staging/media/hantro/hantro_hw.h      |    2 +
 .../staging/media/hantro/stm32mp25_vdec_hw.c  |   84 +
 .../staging/media/hantro/stm32mp25_venc_hw.c  |  129 +
 drivers/tee/amdtee/amdtee_private.h           |    8 +-
 drivers/tee/amdtee/core.c                     |   22 +-
 drivers/tee/optee/Makefile                    |    2 +
 drivers/tee/optee/call.c                      |  814 ++-
 drivers/tee/optee/call_queue.c                |   86 +
 drivers/tee/optee/core.c                      |  463 +-
 drivers/tee/optee/notif.c                     |  125 +
 drivers/tee/optee/optee_msg.h                 |  160 +-
 drivers/tee/optee/optee_private.h             |  180 +-
 drivers/tee/optee/optee_rpc_cmd.h             |   31 +-
 drivers/tee/optee/optee_smc.h                 |   94 +-
 drivers/tee/optee/rpc.c                       |   99 +-
 drivers/tee/tee_core.c                        |   73 +-
 drivers/tee/tee_shm.c                         |   13 +-
 drivers/thermal/st/stm_thermal.c              |   30 +-
 drivers/tty/Kconfig                           |   12 +
 drivers/tty/Makefile                          |    1 +
 drivers/tty/rpmsg_tty.c                       |  287 +
 drivers/tty/serial/Kconfig                    |    1 +
 drivers/tty/serial/serial_core.c              |   10 +
 drivers/tty/serial/serial_mctrl_gpio.c        |   38 +
 drivers/tty/serial/serial_mctrl_gpio.h        |   18 +
 drivers/tty/serial/stm32-usart.c              |  759 ++-
 drivers/tty/serial/stm32-usart.h              |   18 +-
 drivers/usb/core/hcd.c                        |    9 +-
 drivers/usb/core/phy.c                        |   22 +-
 drivers/usb/core/phy.h                        |    6 +-
 drivers/usb/dwc2/core.h                       |   22 +-
 drivers/usb/dwc2/core_intr.c                  |    3 +-
 drivers/usb/dwc2/debugfs.c                    |    4 +-
 drivers/usb/dwc2/drd.c                        |   79 +-
 drivers/usb/dwc2/gadget.c                     |    2 +-
 drivers/usb/dwc2/hcd.c                        |   61 +-
 drivers/usb/dwc2/params.c                     |   75 +-
 drivers/usb/dwc2/platform.c                   |   82 +-
 drivers/usb/dwc3/Kconfig                      |   11 +
 drivers/usb/dwc3/Makefile                     |    1 +
 drivers/usb/dwc3/dwc3-stm32.c                 |  197 +
 drivers/usb/host/Kconfig                      |   13 +
 drivers/usb/host/Makefile                     |    1 +
 drivers/usb/host/ehci-platform.c              |   16 +-
 drivers/usb/host/ohci-platform.c              |   14 +-
 drivers/usb/host/usb2h-stm32.c                |  154 +
 drivers/usb/typec/ucsi/Kconfig                |   10 +
 drivers/usb/typec/ucsi/Makefile               |    1 +
 drivers/usb/typec/ucsi/ucsi.c                 |   49 +-
 drivers/usb/typec/ucsi/ucsi.h                 |    2 +
 drivers/usb/typec/ucsi/ucsi_stm32g0.c         |  770 +++
 drivers/video/backlight/gpio_backlight.c      |    7 +-
 drivers/video/fbdev/simplefb.c                |   21 +-
 include/drm/bridge/dw_mipi_dsi.h              |    4 +-
 include/drm/drm_connector.h                   |   14 +
 include/dt-bindings/clock/stm32mp1-clks.h     |   52 +-
 include/dt-bindings/clock/stm32mp13-clks.h    |  235 +
 include/dt-bindings/clock/stm32mp2-clks.h     |  506 ++
 include/dt-bindings/pinctrl/stm32-pinfunc.h   |    4 +
 include/dt-bindings/reset/stm32mp1-resets.h   |   24 +-
 include/dt-bindings/reset/stm32mp13-resets.h  |  100 +
 include/dt-bindings/reset/stm32mp2-resets.h   |  165 +
 include/dt-bindings/rtc/rtc-stm32.h           |   14 +
 include/dt-bindings/soc/stm32-hdp.h           |  108 +
 include/dt-bindings/soc/stm32mp13-hdp.h       |  133 +
 include/dt-bindings/soc/stm32mp25-hdp.h       |  147 +
 include/dt-bindings/spi/spi-stm32.h           |   15 +
 include/linux/iio/timer/stm32-lptim-trigger.h |    2 +
 include/linux/irqdomain.h                     |    4 +
 include/linux/mfd/stm32-lptimer.h             |   32 +-
 include/linux/mfd/stm32-timers.h              |    1 +
 include/linux/ptp_clock_kernel.h              |    5 +
 include/linux/remoteproc.h                    |   13 +
 include/linux/rpmsg.h                         |   10 +
 include/linux/scmi_protocol.h                 |    4 +
 include/linux/smscphy.h                       |   20 +
 include/linux/tee_drv.h                       |   17 +-
 include/linux/tee_remoteproc.h                |  101 +
 include/linux/timekeeping.h                   |    5 +
 include/media/mipi-csi2.h                     |   45 +
 include/media/v4l2-fwnode.h                   |    2 +
 include/memory/stm32-omi.h                    |  196 +
 include/uapi/linux/ethtool.h                  |   10 +-
 include/uapi/linux/ptp_clock.h                |   12 +-
 include/uapi/linux/rpmsg.h                    |   10 +
 include/uapi/linux/serial.h                   |    4 +-
 include/uapi/linux/tee.h                      |   36 +-
 kernel/irq/irqdomain.c                        |    6 +-
 kernel/power/suspend.c                        |    1 -
 net/ethtool/common.c                          |    4 +
 sound/soc/codecs/Kconfig                      |    2 +-
 sound/soc/codecs/wm8994.c                     |   81 +-
 sound/soc/stm/stm32_adfsdm.c                  |   22 +-
 sound/soc/stm/stm32_i2s.c                     |    6 +-
 sound/soc/stm/stm32_sai.c                     |   62 +-
 sound/soc/stm/stm32_sai.h                     |    6 +
 sound/soc/stm/stm32_sai_sub.c                 |  148 +-
 sound/soc/stm/stm32_spdifrx.c                 |    4 +
 451 files changed, 74631 insertions(+), 4459 deletions(-)
 create mode 100644 CONTRIBUTING.md
 create mode 100644 Documentation/admin-guide/perf/stm32-ddr-pmu.rst
 create mode 100644 Documentation/arm/stm32/stm32mp13-overview.rst
 create mode 100644 Documentation/arm/stm32/stm32mp257-overview.rst
 create mode 100644 Documentation/devicetree/bindings/cpufreq/stm32-cpufreq.txt
 create mode 100644 Documentation/devicetree/bindings/display/panel/rocktech,hx8394.yaml
 create mode 100644 Documentation/devicetree/bindings/dma/st,stm32-dma3.yaml
 create mode 100644 Documentation/devicetree/bindings/media/i2c/galaxycore,gc2145.yaml
 create mode 100644 Documentation/devicetree/bindings/media/st,stm32-csi2host.yaml
 create mode 100644 Documentation/devicetree/bindings/media/st,stm32-dcmipp.yaml
 create mode 100644 Documentation/devicetree/bindings/media/st,stm32mp25-vdec.yaml
 create mode 100644 Documentation/devicetree/bindings/media/st,stm32mp25-venc.yaml
 create mode 100644 Documentation/devicetree/bindings/memory-controllers/st,stm32-omi.yaml
 create mode 100644 Documentation/devicetree/bindings/mfd/st,stm32mp1-pwr.txt
 create mode 100644 Documentation/devicetree/bindings/misc/st,stm32-omm.yaml
 create mode 100644 Documentation/devicetree/bindings/net/stm32-ttt.yaml
 create mode 100644 Documentation/devicetree/bindings/pci/st,stm32-pcie-host.yaml
 create mode 100644 Documentation/devicetree/bindings/perf/stm32-ddr-pmu.yaml
 create mode 100644 Documentation/devicetree/bindings/phy/st,stm32-combophy.yaml
 create mode 100644 Documentation/devicetree/bindings/phy/st,stm32-femtophy.yaml
 create mode 100644 Documentation/devicetree/bindings/regulator/protection-consumer.txt
 create mode 100644 Documentation/devicetree/bindings/remoteproc/rproc-srm.txt
 create mode 100644 Documentation/devicetree/bindings/soc/stm32/st,stm32mp1-hslv.yaml
 create mode 100644 Documentation/devicetree/bindings/soc/stm32/stm32_hdp.txt
 create mode 100644 Documentation/devicetree/bindings/usb/st,typec-stm32g0.yaml
 create mode 100644 Documentation/devicetree/bindings/usb/stm32,dwc3.yaml
 create mode 100644 Documentation/devicetree/bindings/usb/stm32,usb2h.yaml
 create mode 100644 SECURITY.md
 create mode 100644 arch/arm/boot/dts/stm32mp13-pinctrl.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp131.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp133.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp135.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp135f-dk-a7-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp135f-dk.dts
 create mode 100644 arch/arm/boot/dts/stm32mp13xa.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp13xc.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp13xd.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp13xf.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp15-m4-srm-pinctrl.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp15-m4-srm.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp157a-dk1-a7-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157a-dk1-m4-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157a-ed1.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157a-ev1.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157c-dk2-a7-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157c-dk2-m4-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157c-ev1-a7-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157c-ev1-m4-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157d-dk1-a7-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157d-dk1-m4-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157d-dk1.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157d-ed1.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157d-ev1.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157f-dk2-a7-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157f-dk2-m4-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157f-dk2.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157f-ed1.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157f-ev1-a7-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157f-ev1-m4-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157f-ev1.dts
 create mode 100644 arch/arm/boot/dts/stm32mp15xa.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp15xd.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp15xf.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp15xx-edx.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp15xx-evx.dtsi
 create mode 100644 arch/arm/configs/fragment-01-multiv7_cleanup.config
 create mode 100644 arch/arm/configs/fragment-02-multiv7_addons.config
 create mode 100644 arch/arm64/boot/dts/st/Makefile
 create mode 100644 arch/arm64/boot/dts/st/stm32mp25-pinctrl-test.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp25-pinctrl.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp251.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp253.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp255.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp257.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp257f-dk.dts
 create mode 100644 arch/arm64/boot/dts/st/stm32mp257f-ev.dts
 create mode 100644 arch/arm64/boot/dts/st/stm32mp257f-valid3-ca35tdcid-resmem.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp257f-valid3-daughter.dts
 create mode 100644 arch/arm64/boot/dts/st/stm32mp257f-valid3.dts
 create mode 100644 arch/arm64/boot/dts/st/stm32mp25xc.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp25xf.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp25xxai-pinctrl.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp25xxak-pinctrl.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp25xxal-pinctrl.dtsi
 create mode 100644 arch/arm64/configs/fragment-01-defconfig-cleanup.config
 create mode 100644 arch/arm64/configs/fragment-02-defconfig-addons.config
 create mode 100644 drivers/clk/stm32/Makefile
 create mode 100644 drivers/clk/stm32/clk-stm32-core.c
 create mode 100644 drivers/clk/stm32/clk-stm32-core.h
 create mode 100644 drivers/clk/stm32/clk-stm32mp13.c
 create mode 100644 drivers/clk/stm32/clk-stm32mp2.c
 create mode 100644 drivers/clk/stm32/reset-stm32.c
 create mode 100644 drivers/clk/stm32/reset-stm32.h
 create mode 100644 drivers/clk/stm32/stm32mp13_rcc.h
 create mode 100644 drivers/clk/stm32/stm32mp2_rcc.h
 create mode 100644 drivers/cpufreq/stm32-cpufreq.c
 create mode 100644 drivers/cpuidle/cpuidle-stm32.c
 create mode 100644 drivers/dma/stm32-dma3.c
 create mode 100644 drivers/firmware/arm_scmi/optee.c
 create mode 100644 drivers/gpu/drm/panel/panel-rocktech-hx8394.c
 create mode 100644 drivers/gpu/drm/stm/lvds.c
 create mode 100644 drivers/media/i2c/gc2145.c
 create mode 100644 drivers/media/platform/stm32/stm32-csi2host.c
 create mode 100644 drivers/media/platform/stm32/stm32-dcmipp/Makefile
 create mode 100644 drivers/media/platform/stm32/stm32-dcmipp/dcmipp-bytecap.c
 create mode 100644 drivers/media/platform/stm32/stm32-dcmipp/dcmipp-byteproc.c
 create mode 100644 drivers/media/platform/stm32/stm32-dcmipp/dcmipp-colorconv.c
 create mode 100644 drivers/media/platform/stm32/stm32-dcmipp/dcmipp-colorconv.h
 create mode 100644 drivers/media/platform/stm32/stm32-dcmipp/dcmipp-common.c
 create mode 100644 drivers/media/platform/stm32/stm32-dcmipp/dcmipp-common.h
 create mode 100644 drivers/media/platform/stm32/stm32-dcmipp/dcmipp-core.c
 create mode 100644 drivers/media/platform/stm32/stm32-dcmipp/dcmipp-isp.c
 create mode 100644 drivers/media/platform/stm32/stm32-dcmipp/dcmipp-parallel.c
 create mode 100644 drivers/media/platform/stm32/stm32-dcmipp/dcmipp-pixelcap.c
 create mode 100644 drivers/media/platform/stm32/stm32-dcmipp/dcmipp-pixelproc.c
 create mode 100644 drivers/memory/stm32-omi.c
 create mode 100644 drivers/mfd/stm32-pwr.c
 create mode 100644 drivers/misc/stm32_omm.c
 create mode 100644 drivers/mtd/hyperbus/hyperbus-stm32.c
 create mode 100644 drivers/pci/controller/dwc/pcie-stm32.c
 create mode 100644 drivers/perf/stm32_ddr_pmu.c
 create mode 100644 drivers/phy/st/phy-stm32-combophy.c
 create mode 100644 drivers/phy/st/phy-stm32-usb2femto.c
 create mode 100644 drivers/pinctrl/stm32/pinctrl-stm32mp257.c
 create mode 100644 drivers/regulator/protection-consumer.c
 create mode 100644 drivers/remoteproc/rproc_srm_core.c
 create mode 100644 drivers/remoteproc/rproc_srm_core.h
 create mode 100644 drivers/remoteproc/rproc_srm_dev.c
 create mode 100644 drivers/remoteproc/tee_remoteproc.c
 create mode 100644 drivers/rpmsg/rpmsg_char.h
 create mode 100644 drivers/rpmsg/rpmsg_ctrl.c
 create mode 100644 drivers/soc/st/Kconfig
 create mode 100644 drivers/soc/st/Makefile
 create mode 100644 drivers/soc/st/stm32-hslv.c
 create mode 100644 drivers/soc/st/stm32_hdp.c
 create mode 100644 drivers/soc/st/stm32_pm_domain.c
 create mode 100644 drivers/spi/spi-stm32-ospi.c
 create mode 100644 drivers/staging/media/hantro/stm32mp25_vdec_hw.c
 create mode 100644 drivers/staging/media/hantro/stm32mp25_venc_hw.c
 create mode 100644 drivers/tee/optee/call_queue.c
 create mode 100644 drivers/tee/optee/notif.c
 create mode 100644 drivers/tty/rpmsg_tty.c
 create mode 100644 drivers/usb/dwc3/dwc3-stm32.c
 create mode 100644 drivers/usb/host/usb2h-stm32.c
 create mode 100644 drivers/usb/typec/ucsi/ucsi_stm32g0.c
 create mode 100644 include/dt-bindings/clock/stm32mp13-clks.h
 create mode 100644 include/dt-bindings/clock/stm32mp2-clks.h
 create mode 100644 include/dt-bindings/reset/stm32mp13-resets.h
 create mode 100644 include/dt-bindings/reset/stm32mp2-resets.h
 create mode 100644 include/dt-bindings/rtc/rtc-stm32.h
 create mode 100644 include/dt-bindings/soc/stm32-hdp.h
 create mode 100644 include/dt-bindings/soc/stm32mp13-hdp.h
 create mode 100644 include/dt-bindings/soc/stm32mp25-hdp.h
 create mode 100644 include/dt-bindings/spi/spi-stm32.h
 create mode 100644 include/linux/tee_remoteproc.h
 create mode 100644 include/media/mipi-csi2.h
 create mode 100644 include/memory/stm32-omi.h

diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 000000000..3d1bacd78
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,30 @@
+﻿# Contributing guide
+
+This document serves as a checklist before contributing to this repository. It includes links to read up on if topics are unclear to you.
+
+This guide mainly focuses on the proper use of Git.
+
+## 1. Issues
+
+STM32MPU projects do not activate "Github issues" feature for the time being. If you need to report an issue or question about this project deliverables, you can report them using [ ST Support Center ](https://my.st.com/ols#/ols/newrequest)  or  [ ST Community MPU Forum ](https://community.st.com/s/topic/0TO0X0000003u2AWAQ/stm32-mpus).
+
+## 2. Pull Requests
+
+STMicrolectronics is happy to receive contributions from the community, based on an initial Contributor License Agreement (CLA) procedure.
+
+* If you are an individual writing original source code and you are sure **you own the intellectual property**, then you need to sign an Individual CLA (https://cla.st.com).
+* If you work for a company that wants also to allow you to contribute with your work, your company needs to provide a Corporate CLA (https://cla.st.com) mentioning your GitHub account name.
+* If you are not sure that a CLA (Individual or Corporate) has been signed for your GitHub account you can check here (https://cla.st.com).
+
+Please note that:
+* The Corporate CLA will always take precedence over the Individual CLA.
+* One CLA submission is sufficient, for any project proposed by STMicroelectronics.
+
+__How to proceed__
+
+* We recommend to fork the project in your GitHub account to further develop your contribution. Please use the latest commit version.
+* Please, submit one Pull Request for one new feature or proposal. This will ease the analysis and final merge if accepted.
+
+__Note__
+
+Merge will not be done directly in GitHub but it will need first to follow internal integration process before public deliver in a standard release. The Pull request will stay open until it is merged and delivered.
diff --git a/Documentation/admin-guide/perf/index.rst b/Documentation/admin-guide/perf/index.rst
index 5a8f2529a..9f68f68be 100644
--- a/Documentation/admin-guide/perf/index.rst
+++ b/Documentation/admin-guide/perf/index.rst
@@ -11,6 +11,7 @@ Performance monitor support
    imx-ddr
    qcom_l2_pmu
    qcom_l3_pmu
+   stm32-ddr-pmu
    arm-ccn
    arm-cmn
    xgene-pmu
diff --git a/Documentation/admin-guide/perf/stm32-ddr-pmu.rst b/Documentation/admin-guide/perf/stm32-ddr-pmu.rst
new file mode 100644
index 000000000..aaaf8619d
--- /dev/null
+++ b/Documentation/admin-guide/perf/stm32-ddr-pmu.rst
@@ -0,0 +1,42 @@
+========================================
+STM32 DDR Performance Monitor (DDRPERFM)
+========================================
+
+The DDRPERFM is the DDR Performance Monitor embedded in STM32MP1 and STM32MP2
+SOCs.
+
+The following counters are supported by stm32-ddr-pmu driver:
+	cnt0: read operations counters		(read_cnt)
+	cnt1: write operations counters		(write_cnt)
+	cnt2: active state counters		(activate_cnt)
+	cnt3: idle state counters		(idle_cnt)    [only in STM32MP1]
+	tcnt: time count, present for all sets	(time_cnt)
+
+The stm32-ddr-pmu driver relies on the perf PMU framework to expose the
+counters via sysfs:
+
+    .. code-block:: bash
+
+	$ ls /sys/bus/event_source/devices/ddrperfm/events
+	activate_cnt  idle_cnt  read_cnt  time_cnt  write_cnt
+
+
+The perf PMU framework is usually invoked via the 'perf stat' tool.
+
+The DDRPERFM is a system monitor that cannot isolate the traffic coming from a
+given thread or CPU, that is why stm32-ddr-pmu driver rejects any 'perf stat'
+call that does not request a system-wide collection: the '-a, --all-cpus'
+option is mandatory!
+
+Example:
+
+    .. code-block:: bash
+
+        $ perf stat -e ddrperfm/read_cnt/,ddrperfm/time_cnt/ -a sleep 20
+	Performance counter stats for 'system wide':
+
+	         342541560      ddrperfm/read_cnt/
+	       10660011400      ddrperfm/time_cnt/
+
+	      20.021068551 seconds time elapsed
+
diff --git a/Documentation/arm/index.rst b/Documentation/arm/index.rst
index d4f34ae9e..2bda5461a 100644
--- a/Documentation/arm/index.rst
+++ b/Documentation/arm/index.rst
@@ -55,6 +55,7 @@ SoC-specific documents
    stm32/stm32h750-overview
    stm32/stm32f769-overview
    stm32/stm32f429-overview
+   stm32/stm32mp13-overview
    stm32/stm32mp157-overview
 
    sunxi
diff --git a/Documentation/arm/stm32/stm32mp13-overview.rst b/Documentation/arm/stm32/stm32mp13-overview.rst
new file mode 100644
index 000000000..3bb9492da
--- /dev/null
+++ b/Documentation/arm/stm32/stm32mp13-overview.rst
@@ -0,0 +1,37 @@
+===================
+STM32MP13 Overview
+===================
+
+Introduction
+------------
+
+The STM32MP131/STM32MP133/STM32MP135 are Cortex-A MPU aimed at various applications.
+They feature:
+
+- One Cortex-A7 application core
+- Standard memories interface support
+- Standard connectivity, widely inherited from the STM32 MCU family
+- Comprehensive security support
+
+More details:
+
+- Cortex-A7 core running up to @900MHz
+- FMC controller to connect SDRAM, NOR and NAND memories
+- QSPI
+- SD/MMC/SDIO support
+- 2*Ethernet controller
+- CAN
+- ADC/DAC
+- USB EHCI/OHCI controllers
+- USB OTG
+- I2C, SPI, CAN busses support
+- Several general purpose timers
+- Serial Audio interface
+- LCD controller
+- DCMIPP
+- SPDIFRX
+- DFSDM
+
+:Authors:
+
+- Alexandre Torgue <alexandre.torgue@foss.st.com>
diff --git a/Documentation/arm/stm32/stm32mp257-overview.rst b/Documentation/arm/stm32/stm32mp257-overview.rst
new file mode 100644
index 000000000..7e20b0d78
--- /dev/null
+++ b/Documentation/arm/stm32/stm32mp257-overview.rst
@@ -0,0 +1,19 @@
+STM32MP257 Overview
+===================
+
+Introduction
+------------
+
+The STM32MP257 is a Cortex-A MPU aimed at various applications.
+It features:
+
+- Dual core Cortex-A35 application core
+- 2D/3D image composition with GPU
+- Standard memories interface support
+- Standard connectivity, widely inherited from the STM32 MCU family
+- Comprehensive security support
+- RIF isolation mechanism
+
+:Authors:
+
+- Alexandre Torgue <alexandre.torgue@st.com>
diff --git a/Documentation/devicetree/bindings/arm/firmware/linaro,optee-tz.yaml b/Documentation/devicetree/bindings/arm/firmware/linaro,optee-tz.yaml
index c24047c1f..9a426110a 100644
--- a/Documentation/devicetree/bindings/arm/firmware/linaro,optee-tz.yaml
+++ b/Documentation/devicetree/bindings/arm/firmware/linaro,optee-tz.yaml
@@ -24,6 +24,12 @@ properties:
   compatible:
     const: linaro,optee-tz
 
+  interrupts:
+    maxItems: 1
+    description: |
+      This interrupt which is used to signal an event by the secure world
+      software is expected to be edge-triggered.
+
   method:
     enum: [smc, hvc]
     description: |
@@ -42,10 +48,12 @@ additionalProperties: false
 
 examples:
   - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
     firmware  {
         optee  {
             compatible = "linaro,optee-tz";
             method = "smc";
+            interrupts = <GIC_SPI 187 IRQ_TYPE_EDGE_RISING>;
         };
     };
 
diff --git a/Documentation/devicetree/bindings/arm/stm32/st,stm32-syscon.yaml b/Documentation/devicetree/bindings/arm/stm32/st,stm32-syscon.yaml
index 149afb5df..4d133812b 100644
--- a/Documentation/devicetree/bindings/arm/stm32/st,stm32-syscon.yaml
+++ b/Documentation/devicetree/bindings/arm/stm32/st,stm32-syscon.yaml
@@ -20,6 +20,11 @@ properties:
               - st,stm32-syscfg
               - st,stm32-power-config
               - st,stm32-tamp
+              - st,stm32mp25-a35ssc-m33
+              - st,stm32mp25-pwr
+              - st,stm32mp25-rifsc
+              - st,stm32mp25-syscfg
+              - st,stm32mp25-tamp
           - const: syscon
       - items:
           - const: st,stm32-tamp
diff --git a/Documentation/devicetree/bindings/arm/stm32/stm32.yaml b/Documentation/devicetree/bindings/arm/stm32/stm32.yaml
index 9a77ab74b..0f5ba3e2a 100644
--- a/Documentation/devicetree/bindings/arm/stm32/stm32.yaml
+++ b/Documentation/devicetree/bindings/arm/stm32/stm32.yaml
@@ -55,6 +55,10 @@ properties:
           - enum:
               - st,stm32h750i-art-pi
           - const: st,stm32h750
+      - items:
+          - enum:
+              - st,stm32mp135f-dk
+          - const: st,stm32mp135
       - items:
           - enum:
               - shiratech,stm32mp157a-iot-box # IoT Box
@@ -64,10 +68,19 @@ properties:
               - st,stm32mp157c-dk2
 
           - const: st,stm32mp157
+      - items:
+          - enum:
+              - st,stm32mp135f-dk
+          - const: st,stm32mp135
       - items:
           - const: st,stm32mp157c-ev1
           - const: st,stm32mp157c-ed1
           - const: st,stm32mp157
+      - items:
+          - enum:
+              - st,stm32mp257f-dk
+              - st,stm32mp257f-ev
+          - const: st,stm32mp257
 
       - description: Engicam i.Core STM32MP1 SoM based Boards
         items:
diff --git a/Documentation/devicetree/bindings/cpufreq/stm32-cpufreq.txt b/Documentation/devicetree/bindings/cpufreq/stm32-cpufreq.txt
new file mode 100644
index 000000000..1292eb261
--- /dev/null
+++ b/Documentation/devicetree/bindings/cpufreq/stm32-cpufreq.txt
@@ -0,0 +1,61 @@
+STM32 CPUFreq and OPP bindings
+==============================
+
+STM32 CPUFreq driver needs to read chip information from the SoC to list
+available OPPs. Then it depends on cpufreq-dt bindings.
+
+Required properties:
+--------------------
+- clocks: Phandle to the cpu clock "cpu".
+- clocks-name: Should contain "cpu".
+- nvmem-cells: Phandle to nvmem cell that contains "part_number".
+- nvmem-cell-names: Must be "part_number".
+- operating-points-v2: Phandle to operating points table. See ../power/opp.txt
+  for more details.
+
+Optional properties:
+--------------------
+See cpufreq-dt.txt for optional properties.
+
+Examples:
+---------
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,cortex-a7";
+			device_type = "cpu";
+			reg = <0>;
+			clocks = <&rcc CK_MPU>;
+			clock-names = "cpu";
+			operating-points-v2 = <&cpu0_opp_table>;
+			nvmem-cells = <&part_number_otp>;
+			nvmem-cell-names = "part_number";
+		};
+
+		cpu1: cpu@1 {
+			compatible = "arm,cortex-a7";
+			device_type = "cpu";
+			reg = <1>;
+			clocks = <&rcc CK_MPU>;
+			clock-names = "cpu";
+			operating-points-v2 = <&cpu0_opp_table>;
+		};
+	};
+
+	cpu0_opp_table: cpu0-opp-table {
+		compatible = "operating-points-v2";
+		opp-shared;
+
+		opp-650000000 {
+			opp-hz = /bits/ 64 <650000000>;
+			opp-microvolt = <1200000>;
+			opp-supported-hw = <0x1>;
+		};
+		opp-800000000 {
+			opp-hz = /bits/ 64 <800000000>;
+			opp-microvolt = <1350000>;
+			opp-supported-hw = <0x2>;
+		};
+	};
diff --git a/Documentation/devicetree/bindings/crypto/st,stm32-cryp.yaml b/Documentation/devicetree/bindings/crypto/st,stm32-cryp.yaml
index a45745525..6c3f8f7bf 100644
--- a/Documentation/devicetree/bindings/crypto/st,stm32-cryp.yaml
+++ b/Documentation/devicetree/bindings/crypto/st,stm32-cryp.yaml
@@ -27,6 +27,15 @@ properties:
   resets:
     maxItems: 1
 
+  dmas:
+    maxItems: 2
+    minItems: 2
+
+  dma-names:
+    items:
+      - const: in
+      - const: out
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/crypto/st,stm32-hash.yaml b/Documentation/devicetree/bindings/crypto/st,stm32-hash.yaml
index 6dd658f09..1a944608d 100644
--- a/Documentation/devicetree/bindings/crypto/st,stm32-hash.yaml
+++ b/Documentation/devicetree/bindings/crypto/st,stm32-hash.yaml
@@ -14,6 +14,7 @@ properties:
     enum:
       - st,stm32f456-hash
       - st,stm32f756-hash
+      - st,stm32mp13-hash
 
   reg:
     maxItems: 1
diff --git a/Documentation/devicetree/bindings/display/panel/lvds.yaml b/Documentation/devicetree/bindings/display/panel/lvds.yaml
index 49460c9dc..8225d7419 100644
--- a/Documentation/devicetree/bindings/display/panel/lvds.yaml
+++ b/Documentation/devicetree/bindings/display/panel/lvds.yaml
@@ -31,8 +31,14 @@ allOf:
 
 properties:
   compatible:
-    contains:
-      const: panel-lvds
+    items:
+    # compatible must be listed in alphabetical order, ordered by compatible.
+    # The description in the comment is mandatory for each compatible.
+      - enum:
+            # EDT ETML0700Z8DHA 7.0" FHD (1920x1080) color TFT LCD panel
+          - edt,etml0700z8dha
+
+      - const: panel-lvds
     description:
       Shall contain "panel-lvds" in addition to a mandatory panel-specific
       compatible string defined in individual panel bindings. The "panel-lvds"
diff --git a/Documentation/devicetree/bindings/display/panel/panel-dpi.yaml b/Documentation/devicetree/bindings/display/panel/panel-dpi.yaml
index dae0676b5..8965b627d 100644
--- a/Documentation/devicetree/bindings/display/panel/panel-dpi.yaml
+++ b/Documentation/devicetree/bindings/display/panel/panel-dpi.yaml
@@ -21,6 +21,15 @@ properties:
       - {}
       - const: panel-dpi
 
+  data-mapping:
+    enum:
+      - rgb24
+      - rgb565
+      - bgr666
+    description: |
+      Describes the media format, how the display panel is connected
+      to the display interface.
+
   backlight: true
   enable-gpios: true
   height-mm: true
@@ -43,6 +52,7 @@ examples:
         compatible = "startek,startek-kd050c", "panel-dpi";
         label = "osddisplay";
         power-supply = <&vcc_supply>;
+        data-mapping = "rgb565";
         backlight = <&backlight>;
 
         port {
diff --git a/Documentation/devicetree/bindings/display/panel/rocktech,hx8394.yaml b/Documentation/devicetree/bindings/display/panel/rocktech,hx8394.yaml
new file mode 100644
index 000000000..db548d94e
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/panel/rocktech,hx8394.yaml
@@ -0,0 +1,56 @@
+# SPDX-License-Identifier: (GPL-2.0-only or BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/panel/rocktech,hx8394.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title:  ROCKTECH DISPLAYS LIMITED HX8394 5.5" 720p MIPI-DSI TFT LCD panel
+
+maintainers:
+  - Yannick Fertre <yannick.fertre@foss.st.com>
+
+description: |
+  The  ROCKTECH DISPLAYS LIMITED HX8394 is a 5.5" 720x1280 TFT LCD
+  panel connected using a MIPI-DSI video interface.
+
+allOf:
+  - $ref: panel-common.yaml#
+
+properties:
+
+  compatible:
+    const: rocktech,hx8394
+
+  reg:
+    maxItems: 1
+    description: DSI virtual channel
+
+  backlight: true
+  enable-gpios: true
+  port: true
+  power-supply: true
+
+  reset-gpios:
+    maxItems: 1
+
+additionalProperties: false
+
+required:
+  - compatible
+  - power-supply
+  - reg
+
+examples:
+  - |
+    dsi {
+      #address-cells = <1>;
+      #size-cells = <0>;
+      panel@0 {
+        compatible = "rocktech,hx8394";
+        reg = <0>;
+        reset-gpios = <&gpiof 15 0>;
+        power-supply = <&v1v8>;
+        backlight = <&pwm_backlight>;
+      };
+    };
+...
diff --git a/Documentation/devicetree/bindings/dma/st,stm32-dma.yaml b/Documentation/devicetree/bindings/dma/st,stm32-dma.yaml
index 4bf676fd2..99351fe0f 100644
--- a/Documentation/devicetree/bindings/dma/st,stm32-dma.yaml
+++ b/Documentation/devicetree/bindings/dma/st,stm32-dma.yaml
@@ -47,6 +47,14 @@ description: |
               not wait for the de-assertion of the REQuest, ACK is only managed
               by transfer completion. This must only be used on channels
               managing transfers for STM32 USART/UART.
+       -bit 30-29: indicated SRAM Buffer size in (2^order)*PAGE_SIZE.
+         Order is given by those 2 bits starting at 0.
+         Valid only whether Intermediate M2M transfer is set.
+         For cyclic, whether Intermediate M2M transfer is chosen, any value can be set:
+         SRAM buffer size will rely on period size and not on this DT value.
+       -bit 31: Intermediate M2M transfer from/to DDR to/from SRAM throughout MDMA
+         0: MDMA not used to generate an intermediate M2M transfer
+         1: MDMA used to generate an intermediate M2M transfer.
 
 
 maintainers:
@@ -82,6 +90,35 @@ properties:
     description: if defined, it indicates that the controller
       supports memory-to-memory transfer
 
+  dmas:
+    description: A list of eight dma specifiers, one for each entry in dma-names.
+      Refer to stm32-mdma.yaml for more details.
+    items:
+      - description: DMA channel 0 connected to the MDMA channel specified
+      - description: DMA channel 1 connected to the MDMA channel specified
+      - description: DMA channel 2 connected to the MDMA channel specified
+      - description: DMA channel 3 connected to the MDMA channel specified
+      - description: DMA channel 4 connected to the MDMA channel specified
+      - description: DMA channel 5 connected to the MDMA channel specified
+      - description: DMA channel 6 connected to the MDMA channel specified
+      - description: DMA channel 7 connected to the MDMA channel specified
+
+  dma-names:
+    description: Represents each STM32 DMA channel connected to a STM32 MDMA one.
+    items:
+      - const: ch0
+      - const: ch1
+      - const: ch2
+      - const: ch3
+      - const: ch4
+      - const: ch5
+      - const: ch6
+      - const: ch7
+
+  memory-region:
+    description: Phandle to a node describing memory to be used for M2M intermediate transfer
+      between DMA and MDMA.
+
 required:
   - compatible
   - reg
@@ -111,6 +148,16 @@ examples:
       st,mem2mem;
       resets = <&rcc 150>;
       dma-requests = <8>;
+      dmas = <&mdma1 8 0x3 0x1200000a 0x40026408 0x00000020 1>,
+             <&mdma1 9 0x3 0x1200000a 0x40026408 0x00000800 1>,
+             <&mdma1 10 0x3 0x1200000a 0x40026408 0x00200000 1>,
+             <&mdma1 11 0x3 0x1200000a 0x40026408 0x08000000 1>,
+             <&mdma1 12 0x3 0x1200000a 0x4002640C 0x00000020 1>,
+             <&mdma1 13 0x3 0x1200000a 0x4002640C 0x00000800 1>,
+             <&mdma1 14 0x3 0x1200000a 0x4002640C 0x00200000 1>,
+             <&mdma1 15 0x3 0x1200000a 0x4002640C 0x08000000 1>;
+      dma-names = "ch0", "ch1", "ch2", "ch3", "ch4", "ch5", "ch6", "ch7";
+      memory-region = <&sram_dmapool>;
     };
 
 ...
diff --git a/Documentation/devicetree/bindings/dma/st,stm32-dma3.yaml b/Documentation/devicetree/bindings/dma/st,stm32-dma3.yaml
new file mode 100644
index 000000000..b7805716d
--- /dev/null
+++ b/Documentation/devicetree/bindings/dma/st,stm32-dma3.yaml
@@ -0,0 +1,134 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/dma/st,stm32-dma3.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STMicroelectronics STM32 DMA3 Controller bindings
+
+description: |
+  The STM32 DMA3 is a direct memory access controller with different features
+  depending on its hardware configuration.
+  It is either called LPDMA (Low Power), GPDMA (General Purpose) or
+  HPDMA (High Performance).
+  Its hardware configuration registers allow to dynamically expose its features.
+  
+  GPDMA and HPDMA support 16 independent DMA channels, while only 4 for LPDMA.
+  GPDMA and HPDMA supports 256 DMA requests from peripherals, 8 for LPDMA.
+  
+  Bindings are generic for the 3 DMA3 configurations.
+  
+  DMA clients connected to the STM32 DMA3 controller must use the format described
+  in the dma.txt file, using a four-cell specifier for each channel.
+  A phandle to the DMA controller plus the following four integer cells:
+    1. The request line number
+    2. A 32-bit mask specifying the DMA channel requirements
+      -bit 0-1: The priority level
+        0x0: low priority, low weight
+        0x1: low priority, mid weight
+        0x2: low priority, high weight
+        0x3: high priority
+      -bit 4-7: The FIFO requirement for queuing source and destination transfers
+        0x0: no FIFO requirement/any channel can fit
+        0x2: FIFO of 8 bytes (2^2+1)
+        0x4: FIFO of 32 bytes (2^4+1)
+        0x6: FIFO of 128 bytes (2^6+1)
+    3. A 32-bit mask specifying the DMA transfer requirements
+      -bit 0: The source incrementing burst
+        0x0: fixed burst
+        0x1: contiguously incremented burst
+      -bit 1: The source allocated port
+        0x0: port 0 is allocated to the source transfer
+        0x1: port 1 is allocated to the source transfer
+      -bit 4: The destination incrementing burst
+        0x0: fixed burst
+        0x1: contiguously incremented burst
+      -bit 5: The destination allocated port
+        0x0: port 0 is allocated to the destination transfer
+        0x1: port 1 is allocated to the destination transfer
+      -bit 8: The type of hardware request
+        0x0: burst
+        0x1: block
+      -bit 9: The control mode
+        0x0: DMA controller control mode
+        0x1: peripheral control mode
+      -bit 12-13: The transfer complete event mode
+        0x0: at block level
+        0x2: at LLI level
+        0x3: at channel level (last LLI)
+    4. A 32-bit mask specifying the DMA transfer extended requirements
+      -bit 0-12: The source address offset increment
+      -bit 13: The source address increment type
+        0x0: source address incremented by adding the source address offset
+        0x1: source address decremented by substracting the source address offset
+      -bit 14-15: The block alignment mode
+        0x0: address offset and block size are programmed in number of bytes
+        0x1: address offset and block size are programmed in multiple of 16 bytes
+        0x2: address offset and block size are programmed in multiple of 256 bytes
+      -bit 16-28: The destination address offset increment
+      -bit 29: The destination address increment type
+        0x0: destination address incremented by adding the destination address offset
+        0x1: destination address decremented by substracting the destination address offset
+
+maintainers:
+  - Amelie Delaunay <amelie.delaunay@foss.st.com>
+
+allOf:
+  - $ref: "dma-controller.yaml#"
+
+properties:
+  "#dma-cells":
+    const: 4
+
+  compatible:
+    const: st,stm32-dma3
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  resets:
+    maxItems: 1
+
+  interrupts:
+    minItems: 4
+    maxItems: 16
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - interrupts
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/stm32mp2-clks.h>
+    dma-controller@40400000 {
+      compatible = "st,stm32-dma3";
+      reg = <0x40400000 0x1000>;
+      interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 39 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 41 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
+      clocks = <&rcc CK_BUS_HPDMA1>;
+      #dma-cells = <4>;
+    };
+...
+
diff --git a/Documentation/devicetree/bindings/dma/st,stm32-mdma.yaml b/Documentation/devicetree/bindings/dma/st,stm32-mdma.yaml
index c30be840b..c4bb58014 100644
--- a/Documentation/devicetree/bindings/dma/st,stm32-mdma.yaml
+++ b/Documentation/devicetree/bindings/dma/st,stm32-mdma.yaml
@@ -10,8 +10,8 @@ description: |
   The STM32 MDMA is a general-purpose direct memory access controller capable of
   supporting 64 independent DMA channels with 256 HW requests.
   DMA clients connected to the STM32 MDMA controller must use the format
-  described in the dma.txt file, using a five-cell specifier for each channel:
-  a phandle to the MDMA controller plus the following five integer cells:
+  described in the dma.txt file, using a six-cell specifier for each channel:
+  a phandle to the MDMA controller plus the following six integer cells:
     1. The request line number
     2. The priority level
       0x0: Low
@@ -48,6 +48,10 @@ description: |
        if no HW ack signal is used by the MDMA client
     5. A 32bit mask specifying the value to be written to acknowledge the request
        if no HW ack signal is used by the MDMA client
+    6. A bitfield value specifying if the MDMA client wants to generate M2M transfer
+       with HW trigger (1) or not (0). This bitfield should be only enabled for
+       M2M transfer triggered by STM32 DMA client. The memory devices involved in this
+       kind of transfer are SRAM and DDR.
 
 maintainers:
   - Amelie Delaunay <amelie.delaunay@st.com>
@@ -57,7 +61,7 @@ allOf:
 
 properties:
   "#dma-cells":
-    const: 5
+    const: 6
 
   compatible:
     const: st,stm32h7-mdma
@@ -97,7 +101,7 @@ examples:
       interrupts = <122>;
       clocks = <&timer_clk>;
       resets = <&rcc 992>;
-      #dma-cells = <5>;
+      #dma-cells = <6>;
       dma-channels = <16>;
       dma-requests = <32>;
       st,ahb-addr-masks = <0x20000000>, <0x00000000>;
diff --git a/Documentation/devicetree/bindings/hwlock/hwlock.txt b/Documentation/devicetree/bindings/hwlock/hwlock.txt
index 085d1f5c9..e98088a40 100644
--- a/Documentation/devicetree/bindings/hwlock/hwlock.txt
+++ b/Documentation/devicetree/bindings/hwlock/hwlock.txt
@@ -13,7 +13,7 @@ hwlock providers:
 
 Required properties:
 - #hwlock-cells:        Specifies the number of cells needed to represent a
-                        specific lock.
+                        specific lock. Shall be 1 or 2 (see hwlocks below).
 
 hwlock users:
 =============
@@ -27,6 +27,11 @@ Required properties:
                         #hwlock-cells. The list can have just a single hwlock
                         or multiple hwlocks, with each hwlock represented by
                         a phandle and a corresponding args specifier.
+                        If #hwlock-cells is 1, all of the locks are exclusive
+                        (cannot be used by several users).
+                        If #hwlock-cells is 2, the value of the second cell
+                        defines whether the lock is for exclusive usage (0) or
+                        shared (1) i.e. can be used by several users.
 
 Optional properties:
 - hwlock-names:         List of hwlock name strings defined in the same order
@@ -46,14 +51,22 @@ of length 1.
 		...
 	};
 
-2. Example of a node using multiple specific hwlocks:
+2. Example of nodes using multiple and shared specific hwlocks:
 
-The following example has a node requesting two hwlocks, a hwlock within
-the hwlock device node 'hwlock1' with #hwlock-cells value of 1, and another
-hwlock within the hwlock device node 'hwlock2' with #hwlock-cells value of 2.
+The following example has a nodeA requesting two hwlocks:
+- an exclusive one (#hwlock-cells = 1) within the hwlock device node 'hwlock1'
+- a shared one (#hwlock-cells = 2, second cell = 1) within the hwlock device
+  node 'hwlock2'.
+The shared lock is also be used by nodeB.
 
-	node {
+	nodeA {
 		...
-		hwlocks = <&hwlock1 2>, <&hwlock2 0 3>;
+		hwlocks = <&hwlock1 2>, <&hwlock2 0 1>;
 		...
 	};
+
+	nodeB {
+		...
+		hwlocks = <&hwlock2 0 1>;
+		...
+	};
\ No newline at end of file
diff --git a/Documentation/devicetree/bindings/hwlock/st,stm32-hwspinlock.yaml b/Documentation/devicetree/bindings/hwlock/st,stm32-hwspinlock.yaml
index 47cf9c8d9..539a1dc05 100644
--- a/Documentation/devicetree/bindings/hwlock/st,stm32-hwspinlock.yaml
+++ b/Documentation/devicetree/bindings/hwlock/st,stm32-hwspinlock.yaml
@@ -12,7 +12,7 @@ maintainers:
 
 properties:
   "#hwlock-cells":
-    const: 1
+    const: 2
 
   compatible:
     const: st,stm32-hwspinlock
@@ -41,7 +41,7 @@ examples:
     #include <dt-bindings/clock/stm32mp1-clks.h>
     hwspinlock@4c000000 {
         compatible = "st,stm32-hwspinlock";
-        #hwlock-cells = <1>;
+        #hwlock-cells = <2>;
         reg = <0x4c000000 0x400>;
         clocks = <&rcc HSEM>;
         clock-names = "hsem";
diff --git a/Documentation/devicetree/bindings/i2c/st,stm32-i2c.yaml b/Documentation/devicetree/bindings/i2c/st,stm32-i2c.yaml
index d747f4990..06e70b730 100644
--- a/Documentation/devicetree/bindings/i2c/st,stm32-i2c.yaml
+++ b/Documentation/devicetree/bindings/i2c/st,stm32-i2c.yaml
@@ -17,7 +17,9 @@ allOf:
           contains:
             enum:
               - st,stm32f7-i2c
+              - st,stm32mp13-i2c
               - st,stm32mp15-i2c
+              - st,stm32mp25-i2c
     then:
       properties:
         i2c-scl-rising-time-ns:
@@ -47,20 +49,45 @@ allOf:
         clock-frequency:
           enum: [100000, 400000]
 
+  - if:
+      properties:
+        compatible:
+          contains:
+            enum:
+              - st,stm32f7-i2c
+              - st,stm32mp13-i2c
+              - st,stm32mp15-i2c
+    then:
+      properties:
+        interrupts:
+          items:
+            - description: interrupt ID for I2C event
+            - description: interrupt ID for I2C error
+
+  - if:
+      properties:
+        compatible:
+          contains:
+            enum:
+              - st,stm32mp25-i2c
+    then:
+      properties:
+        interrupts:
+          items:
+            - description: common interrupt for events and errors
+
 properties:
   compatible:
     enum:
       - st,stm32f4-i2c
       - st,stm32f7-i2c
+      - st,stm32mp13-i2c
       - st,stm32mp15-i2c
+      - st,stm32mp25-i2c
 
   reg:
     maxItems: 1
 
-  interrupts:
-    items:
-      - description: interrupt ID for I2C event
-      - description: interrupt ID for I2C error
 
   resets:
     maxItems: 1
diff --git a/Documentation/devicetree/bindings/iio/adc/sigma-delta-modulator.yaml b/Documentation/devicetree/bindings/iio/adc/sigma-delta-modulator.yaml
index a390343d0..bf5d71fb6 100644
--- a/Documentation/devicetree/bindings/iio/adc/sigma-delta-modulator.yaml
+++ b/Documentation/devicetree/bindings/iio/adc/sigma-delta-modulator.yaml
@@ -21,6 +21,9 @@ properties:
   '#io-channel-cells':
     const: 0
 
+  vref-supply:
+    description: Phandle to the vref input analog reference voltage.
+
 required:
   - compatible
   - '#io-channel-cells'
diff --git a/Documentation/devicetree/bindings/iio/adc/st,stm32-adc.yaml b/Documentation/devicetree/bindings/iio/adc/st,stm32-adc.yaml
index a58334c3b..2bb187acf 100644
--- a/Documentation/devicetree/bindings/iio/adc/st,stm32-adc.yaml
+++ b/Documentation/devicetree/bindings/iio/adc/st,stm32-adc.yaml
@@ -27,6 +27,8 @@ properties:
       - st,stm32f4-adc-core
       - st,stm32h7-adc-core
       - st,stm32mp1-adc-core
+      - st,stm32mp13-adc-core
+      - st,stm32mp25-adc-core
 
   reg:
     maxItems: 1
@@ -37,6 +39,7 @@ properties:
         - stm32f4 and stm32h7 share a common ADC interrupt line.
         - stm32mp1 has two separate interrupt lines, one for each ADC within
           ADC block.
+        - stm32mp13 has an interrupt line per ADC block.
     minItems: 1
     maxItems: 2
 
@@ -182,6 +185,59 @@ allOf:
           maximum: 36000000
           default: 36000000
 
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: st,stm32mp13-adc-core
+
+    then:
+      properties:
+        clocks:
+          minItems: 1
+          maxItems: 2
+
+        clock-names:
+          items:
+            - const: bus
+            - const: adc
+          minItems: 1
+          maxItems: 2
+
+        interrupts:
+          items:
+            - description: ADC interrupt line
+
+        st,max-clk-rate-hz:
+          minimum: 120000
+          maximum: 36000000
+          default: 36000000
+
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: st,stm32mp25-adc-core
+
+    then:
+      properties:
+        clocks:
+          maxItems: 1
+
+        clock-names:
+          const: adc
+
+        interrupts:
+          items:
+            - description: interrupt line for ADC1 or ADC3
+            - description: interrupt line for ADC2
+          minItems: 1
+
+        st,max-clk-rate-hz:
+          minimum: 700000
+          maximum: 70000000
+          default: 70000000
+
 additionalProperties: false
 
 required:
@@ -210,6 +266,8 @@ patternProperties:
           - st,stm32f4-adc
           - st,stm32h7-adc
           - st,stm32mp1-adc
+          - st,stm32mp13-adc
+          - st,stm32mp25-adc
 
       reg:
         description: |
@@ -222,10 +280,16 @@ patternProperties:
       '#io-channel-cells':
         const: 1
 
+      '#address-cells':
+        const: 1
+
+      '#size-cells':
+        const: 0
+
       interrupts:
         description: |
           IRQ Line for the ADC instance. Valid values are:
-            - 0 for adc@0
+            - 0 for adc@0 (single adc for stm32mp13)
             - 1 for adc@100
             - 2 for adc@200 (stm32f4 only)
         maxItems: 1
@@ -246,16 +310,18 @@ patternProperties:
       assigned-resolution-bits:
         description: |
           Resolution (bits) to use for conversions:
-            - can be 6, 8, 10 or 12 on stm32f4
+            - can be 6, 8, 10 or 12 on stm32f4 and stm32mp13
             - can be 8, 10, 12, 14 or 16 on stm32h7 and stm32mp1
 
       st,adc-channels:
         description: |
           List of single-ended channels muxed for this ADC. It can have up to:
             - 16 channels, numbered from 0 to 15 (for in0..in15) on stm32f4
-            - 20 channels, numbered from 0 to 19 (for in0..in19) on stm32h7 and
-              stm32mp1.
+            - 19 channels, numbered from 0 to 18 (for in0..in18) on stm32mp13.
+            - 20 channels, numbered from 0 to 19 (for in0..in19) on stm32h7,
+              stm32mp1 and stm32mp25.
         $ref: /schemas/types.yaml#/definitions/uint32-array
+        deprecated: true
 
       st,adc-diff-channels:
         description: |
@@ -265,7 +331,9 @@ patternProperties:
           <vinp vinn>, <vinp vinn>,... vinp and vinn are numbered from 0 to 19.
 
           Note: At least one of "st,adc-channels" or "st,adc-diff-channels" is
-          required. Both properties can be used together. Some channels can be
+          required if no adc generic channel is defined. These legacy channel
+          properties are exclusive with adc generic channel bindings.
+          Both properties can be used together. Some channels can be
           used as single-ended and some other ones as differential (mixed). But
           channels can't be configured both as single-ended and differential.
         $ref: /schemas/types.yaml#/definitions/uint32-matrix
@@ -279,6 +347,7 @@ patternProperties:
                 "vinn" indicates negative input number
               minimum: 0
               maximum: 19
+        deprecated: true
 
       st,min-sample-time-nsecs:
         description:
@@ -289,6 +358,50 @@ patternProperties:
           list, to set sample time resp. for all channels, or independently for
           each channel.
         $ref: /schemas/types.yaml#/definitions/uint32-array
+        deprecated: true
+
+      nvmem-cells:
+        items:
+          - description: Phandle to the calibration vrefint data provided by otp
+
+      nvmem-cell-names:
+        items:
+          - const: vrefint
+
+    patternProperties:
+      "^channel@([0-9]|1[0-9])$":
+        type: object
+        $ref: "adc.yaml"
+        description: Represents the external channels which are connected to the ADC.
+
+        properties:
+          reg:
+            items:
+              minimum: 0
+              maximum: 19
+
+          label:
+            description: |
+              Unique name to identify which channel this is.
+              Reserved label names "vddcore", "vddcpu", "vddq_ddr", "vrefint" and "vbat"
+              are used to identify internal channels with matching names.
+
+          diff-channels:
+            $ref: /schemas/types.yaml#/definitions/uint32-array
+            items:
+              minimum: 0
+              maximum: 19
+
+          st,min-sample-time-ns:
+            description: |
+              Minimum sampling time in nanoseconds. Depending on hardware (board)
+              e.g. high/low analog input source impedance, fine tune of ADC
+              sampling time may be recommended.
+
+        required:
+          - reg
+
+        additionalProperties: false
 
     allOf:
       - if:
@@ -367,13 +480,72 @@ patternProperties:
               items:
                 minimum: 40
 
-    additionalProperties: false
 
-    anyOf:
-      - required:
-          - st,adc-channels
-      - required:
-          - st,adc-diff-channels
+      - if:
+          properties:
+            compatible:
+              contains:
+                const: st,stm32mp13-adc
+
+        then:
+          properties:
+            reg:
+              const: 0x0
+
+            interrupts:
+              const: 0
+
+            assigned-resolution-bits:
+              enum: [6, 8, 10, 12]
+              default: 12
+
+            st,adc-channels:
+              minItems: 1
+              maxItems: 19
+              items:
+                minimum: 0
+                maximum: 18
+
+            st,min-sample-time-nsecs:
+              minItems: 1
+              maxItems: 19
+              items:
+                minimum: 40
+
+      - if:
+          properties:
+            compatible:
+              contains:
+                const: st,stm32mp25-adc
+
+        then:
+          properties:
+            reg:
+              enum:
+                - 0x0
+                - 0x100
+
+            interrupts:
+              minimum: 0
+              maximum: 1
+
+            assigned-resolution-bits:
+              enum: [6, 8, 10, 12]
+              default: 12
+
+            st,adc-channels:
+              minItems: 1
+              maxItems: 20
+              items:
+                minimum: 0
+                maximum: 19
+
+            st,min-sample-time-nsecs:
+              minItems: 1
+              maxItems: 20
+              items:
+                minimum: 40
+    additionalProperties: false
 
     required:
       - compatible
@@ -451,4 +623,50 @@ examples:
         // other adc child node follow...
       };
 
+  - |
+    // Example 3: with stm32mp157c to setup ADC2 with:
+    // - internal channels 13, 14, 15.
+      #include <dt-bindings/interrupt-controller/arm-gic.h>
+      #include <dt-bindings/clock/stm32mp1-clks.h>
+      adc122: adc@48003000 {
+        compatible = "st,stm32mp1-adc-core";
+        reg = <0x48003000 0x400>;
+        interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>,
+                     <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>;
+        clocks = <&rcc ADC12>, <&rcc ADC12_K>;
+        clock-names = "bus", "adc";
+        booster-supply = <&booster>;
+        vdd-supply = <&vdd>;
+        vdda-supply = <&vdda>;
+        vref-supply = <&vref>;
+        st,syscfg = <&syscfg>;
+        interrupt-controller;
+        #interrupt-cells = <1>;
+        #address-cells = <1>;
+        #size-cells = <0>;
+        adc@100 {
+          compatible = "st,stm32mp1-adc";
+          #io-channel-cells = <1>;
+          reg = <0x100>;
+          interrupts = <1>;
+          #address-cells = <1>;
+          #size-cells = <0>;
+          channel@13 {
+            reg = <13>;
+            label = "vrefint";
+            st,min-sample-time-ns = <9000>;
+          };
+          channel@14 {
+            reg = <14>;
+            label = "vddcore";
+            st,min-sample-time-ns = <9000>;
+          };
+          channel@15 {
+            reg = <15>;
+            label = "vbat";
+            st,min-sample-time-ns = <9000>;
+          };
+        };
+      };
+
 ...
diff --git a/Documentation/devicetree/bindings/interrupt-controller/st,stm32-exti.yaml b/Documentation/devicetree/bindings/interrupt-controller/st,stm32-exti.yaml
index 6d3e68eb2..e3126b712 100644
--- a/Documentation/devicetree/bindings/interrupt-controller/st,stm32-exti.yaml
+++ b/Documentation/devicetree/bindings/interrupt-controller/st,stm32-exti.yaml
@@ -20,6 +20,7 @@ properties:
       - items:
           - enum:
               - st,stm32mp1-exti
+              - st,stm32mp13-exti
           - const: syscon
 
   "#interrupt-cells":
@@ -41,6 +42,24 @@ properties:
     description:
       Interrupts references to primary interrupt controller
 
+  wakeup-parent: true
+
+patternProperties:
+  '^exti-interrupt-map$':
+    type: object
+    properties:
+      interrupt-map: true
+      interrupt-map-mask: true
+      "#interrupt-cells":
+        const: 2
+      "#address-cells":
+        const: 0
+
+    required:
+      - interrupt-map
+      - "#interrupt-cells"
+      - "#address-cells"
+
 required:
   - "#interrupt-cells"
   - compatible
@@ -89,7 +108,25 @@ examples:
     };
 
     //Example 2
-    exti2: interrupt-controller@40013c00 {
+    exti1: interrupt-controller@5000d000 {
+        compatible = "st,stm32mp1-exti", "syscon";
+        interrupt-controller;
+        #interrupt-cells = <2>;
+        reg = <0x5000d000 0x400>;
+        wakeup-parent = <&pwr_irq>;
+        exti-interrupt-map {
+            #address-cells = <0>;
+            #interrupt-cells = <2>;
+            interrupt-map-mask = <0xffffffff 0>;
+            interrupt-map =
+                <0 0 &intc GIC_SPI 6 IRQ_TYPE_LEVEL_HIGH>,
+                <3 0 &intc GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>,
+                <55 0 &pwr_irq 0 IRQ_TYPE_EDGE_FALLING 0>;
+        };
+    };
+
+    //Example 3
+    exti3: interrupt-controller@40013c00 {
         compatible = "st,stm32-exti";
         interrupt-controller;
         #interrupt-cells = <2>;
diff --git a/Documentation/devicetree/bindings/leds/backlight/gpio-backlight.yaml b/Documentation/devicetree/bindings/leds/backlight/gpio-backlight.yaml
index 75cc569b9..3097aa976 100644
--- a/Documentation/devicetree/bindings/leds/backlight/gpio-backlight.yaml
+++ b/Documentation/devicetree/bindings/leds/backlight/gpio-backlight.yaml
@@ -23,6 +23,15 @@ properties:
     description: enable the backlight at boot.
     type: boolean
 
+  default-brightness-level:
+    description:
+      The default brightness level (index into the array defined by the
+      "brightness-levels" property).
+    $ref: /schemas/types.yaml#/definitions/uint32
+
+dependencies:
+  default-brightness-level: [brightness-levels]
+
 required:
   - compatible
   - gpios
diff --git a/Documentation/devicetree/bindings/media/i2c/galaxycore,gc2145.yaml b/Documentation/devicetree/bindings/media/i2c/galaxycore,gc2145.yaml
new file mode 100644
index 000000000..af07250ce
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/i2c/galaxycore,gc2145.yaml
@@ -0,0 +1,115 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/i2c/galaxycore,gc2145.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Galaxy Core 1/5'' UXGA CMOS Image Sensor
+
+maintainers:
+  - Alain Volmat <alain.volmat@foss.st.com>
+
+description: |
+  The Galaxy Core GC2145 is a high quality 2 Mega CMOS image sensor, for mobile phone camera
+  applications and digital camera products. GC2145 incorporates a 1616V x 1232H active pixel
+  array, on-chip 10-bit ADC, and image signal processor. It is programmable through an I2C
+  interface. Image data is sent either through a parallel interface or through MIPI CSI-2.
+
+allOf:
+  - $ref: ../video-interface-devices.yaml#
+
+properties:
+  compatible:
+    const: galaxycore,gc2145
+
+  reg:
+    enum:
+      - 0x3c
+
+  clocks:
+    description: Reference to the xclk clock.
+    maxItems: 1
+
+  powerdown-gpios:
+    description: GPIO descriptor for the powerdown pin.
+    maxItems: 1
+
+  reset-gpios:
+    description: GPIO descriptor for the reset pin.
+    maxItems: 1
+
+  IOVDD-supply:
+    description: Power Supply for I/O circuits (1.7 - 3V).
+
+  AVDD-supply:
+    description: Power for analog circuit/sensor array (2.7 - 3V).
+
+  DVDD-supply:
+    description: Power for digital core (1.7 - 1.9V).
+
+  port:
+    $ref: /schemas/graph.yaml#/$defs/port-base
+    description: |
+      Video output port.
+
+    properties:
+      endpoint:
+        $ref: /schemas/media/video-interfaces.yaml#
+        unevaluatedProperties: false
+
+        properties:
+          data-lanes:
+            anyOf:
+              - items:
+                  - const: 1
+                  - const: 2
+              - items:
+                  - const: 1
+                  - const: 2
+
+        required:
+          - data-lanes
+
+    additionalProperties: false
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - powerdown-gpios
+  - reset-gpios
+  - IOVDD-supply
+  - AVDD-supply
+  - DVDD-supply
+  - port
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/gpio/gpio.h>
+
+    i2c5 {
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        gc2145@3c {
+            compatible = "galaxycore,gc2145";
+            reg = <0x3c>;
+            clocks = <&clk_ext_camera>;
+            IOVDD-supply = <&scmi_v3v3_sw>;
+            AVDD-supply = <&scmi_v3v3_sw>;
+            DVDD-supply = <&scmi_v3v3_sw>;
+            powerdown-gpios = <&mcp23017 3 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+            reset-gpios = <&mcp23017 4 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+
+            port {
+                gc2145_ep: endpoint {
+                    remote-endpoint = <&mipid02_0>;
+                    data-lanes = <1 2>;
+                };
+            };
+        };
+    };
+
+...
diff --git a/Documentation/devicetree/bindings/media/st,stm32-csi2host.yaml b/Documentation/devicetree/bindings/media/st,stm32-csi2host.yaml
new file mode 100644
index 000000000..1b1e38d77
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/st,stm32-csi2host.yaml
@@ -0,0 +1,114 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/st,stm32-csi2host.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STMicroelectronics STM32 CSI2HOST bindings
+
+maintainers:
+  - Alain Volmat <alain.volmat@foss.st.com>
+
+properties:
+  compatible:
+    enum:
+      - st,stm32-csi2host
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    maxItems: 3
+
+  clock-names:
+    items:
+      - const: pclk
+      - const: txesc
+      - const: csi2phy
+
+  resets:
+    maxItems: 1
+
+  ports:
+    $ref: /schemas/graph.yaml#/properties/ports
+
+    properties:
+      port@0:
+        $ref: /schemas/graph.yaml#/$defs/port-base
+        unevaluatedProperties: false
+        description:
+          Input port node
+
+        properties:
+          endpoint:
+            $ref: video-interfaces.yaml#
+            unevaluatedProperties: false
+
+            properties:
+              data-lanes:
+                description:
+                  Indicate the number of data-lanes and their mapping.
+
+                items:
+                  minItems: 1
+                  items:
+                    - const: 1
+                    - const: 2
+
+            required:
+              - data-lanes
+
+      port@1:
+        $ref: /schemas/graph.yaml#/properties/port
+        description:
+          Output port node
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - clocks
+  - clock-names
+  - resets
+  - ports
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/stm32mp2-clks.h>
+    #include <dt-bindings/reset/stm32mp2-resets.h>
+    csi2host: csi2host@48020000 {
+        compatible = "st,stm32-csi2host";
+        reg = <0x48020000 0x2000>;
+        interrupts = <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>;
+        resets = <&rcc CSI_R>;
+        clocks = <&rcc CK_KER_CSI>, <&rcc CK_KER_CSITXESC>, <&rcc CK_KER_CSIPHY>;
+        clock-names = "pclk", "txesc", "csi2phy";
+
+        ports {
+            #address-cells = <1>;
+            #size-cells = <0>;
+            port@0 {
+                reg = <0>;
+                csi2host_sink: endpoint {
+                    remote-endpoint = <&imx219_ep>;
+                    data-lanes = <0 1>;
+                    bus-type = <4>;
+                };
+            };
+
+            port@1 {
+                reg = <1>;
+                csi2host_source: endpoint {
+                    remote-endpoint = <&dcmipp_0>;
+                };
+            };
+        };
+    };
+
+...
diff --git a/Documentation/devicetree/bindings/media/st,stm32-dcmipp.yaml b/Documentation/devicetree/bindings/media/st,stm32-dcmipp.yaml
new file mode 100644
index 000000000..1e07f3a50
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/st,stm32-dcmipp.yaml
@@ -0,0 +1,121 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/st,stm32-dcmipp.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STMicroelectronics STM32 DCMIPP Digital Camera Memory Interface Pixel Processor binding
+
+maintainers:
+  - Hugues Fruchet <hugues.fruchet@foss.st.com>
+  - Alain Volmat <alain.volmat@foss.st.com>
+
+properties:
+  compatible:
+    enum:
+      - st,stm32mp13-dcmipp
+      - st,stm32mp25-dcmipp
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    maxItems: 2
+
+  clock-names:
+    items:
+      - const: kclk
+      - const: mclk
+
+  resets:
+    maxItems: 1
+
+  port:
+    $ref: /schemas/graph.yaml#/$defs/port-base
+    unevaluatedProperties: false
+    description:
+      DCMIPP supports a single port node with parallel bus.
+
+    properties:
+      endpoint:
+        $ref: video-interfaces.yaml#
+        unevaluatedProperties: false
+
+        properties:
+          bus-type:
+            enum: [4, 5, 6]
+            default: 5
+
+          bus-width:
+            enum: [8, 10, 12, 14]
+            default: 8
+
+          pclk-sample: true
+          hsync-active: true
+          vsync-active: true
+
+        required:
+          - pclk-sample
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - clocks
+  - clock-names
+  - resets
+  - port
+
+allOf:
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: st,stm32mp13-dcmipp
+    then:
+      properties:
+        clocks:
+          maxItems: 1
+
+        clock-names:
+          items:
+            - const: kclk
+
+        port:
+          properties:
+            endpoint:
+              properties:
+                bus-type:
+                  enum: [5, 6]
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/stm32mp13-clks.h>
+    #include <dt-bindings/reset/stm32mp13-resets.h>
+    dcmipp: dcmipp@5a000000 {
+        compatible = "st,stm32mp13-dcmipp";
+        reg = <0x5a000000 0x400>;
+        interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
+        resets = <&rcc DCMIPP_R>;
+        clocks = <&rcc DCMIPP_K>;
+        clock-names = "kclk";
+
+        port {
+             dcmipp_0: endpoint {
+                   remote-endpoint = <&mipid02_2>;
+                   bus-width = <8>;
+                   hsync-active = <0>;
+                   vsync-active = <0>;
+                   pclk-sample = <0>;
+                   pclk-max-frequency = <120000000>;
+             };
+        };
+    };
+
+...
diff --git a/Documentation/devicetree/bindings/media/st,stm32mp25-vdec.yaml b/Documentation/devicetree/bindings/media/st,stm32mp25-vdec.yaml
new file mode 100644
index 000000000..96b8dd36c
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/st,stm32mp25-vdec.yaml
@@ -0,0 +1,56 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/media/st,stm32mp25-vdec.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: Hantro G1 VPU codec implemented on STMicroelectronics STM32MP25 SoCs
+
+maintainers:
+  - Hugues Fruchet <hugues.fruchet@foss.st.com>
+
+description:
+  Hantro G1 video decode accelerator present on STMicroelectronics STM32MP25 SoCs.
+
+properties:
+  compatible:
+    const: st,stm32mp25-vdec
+
+  reg:
+    maxItems: 1
+
+  resets:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - resets
+  - interrupts
+  - interrupt-names
+  - clocks
+  - clock-names
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/stm32mp2-clks.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/reset/stm32mp2-resets.h>
+    vdec: vdec@580d0000 {
+        compatible = "st,stm32mp25-vdec";
+        reg = <0x580d0000 0x3c8>;
+        resets = <&rcc VDEC_R>;
+        interrupt-names = "vdec";
+        interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
+        clock-names = "vdec-clk";
+        clocks = <&rcc CK_BUS_VDEC>;
+    };
diff --git a/Documentation/devicetree/bindings/media/st,stm32mp25-venc.yaml b/Documentation/devicetree/bindings/media/st,stm32mp25-venc.yaml
new file mode 100644
index 000000000..c75f5359c
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/st,stm32mp25-venc.yaml
@@ -0,0 +1,57 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/media/st,stm32mp25-venc.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: Hantro H1 VPU codec implemented on STMicroelectronics STM32MP25 SoCs
+
+maintainers:
+  - Hugues Fruchet <hugues.fruchet@foss.st.com>
+
+description:
+  Hantro H1 video encode accelerator present on STMicroelectronics STM32MP25 SoCs.
+
+properties:
+  compatible:
+    const: st,stm32mp25-venc
+
+  reg:
+    maxItems: 1
+
+  resets:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - resets
+  - interrupts
+  - interrupt-names
+  - clocks
+  - clock-names
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/stm32mp2-clks.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/reset/stm32mp2-resets.h>
+    venc: venc@580e0000 {
+        compatible = "st,stm32mp25-venc";
+        reg = <0x580e0000 0x800>;
+        reset-names = "venc-rst";
+        resets = <&rcc VENC_R>;
+        interrupt-names = "venc";
+        interrupts = <GIC_SPI 167 IRQ_TYPE_LEVEL_HIGH>;
+        clock-names = "venc-clk";
+        clocks = <&rcc CK_BUS_VENC>;
+    };
diff --git a/Documentation/devicetree/bindings/memory-controllers/st,stm32-fmc2-ebi.yaml b/Documentation/devicetree/bindings/memory-controllers/st,stm32-fmc2-ebi.yaml
index cba742058..2fae4cfcc 100644
--- a/Documentation/devicetree/bindings/memory-controllers/st,stm32-fmc2-ebi.yaml
+++ b/Documentation/devicetree/bindings/memory-controllers/st,stm32-fmc2-ebi.yaml
@@ -23,7 +23,9 @@ maintainers:
 
 properties:
   compatible:
-    const: st,stm32mp1-fmc2-ebi
+    enum:
+      - st,stm32mp1-fmc2-ebi
+      - st,stm32mp25-fmc2-ebi
 
   reg:
     maxItems: 1
diff --git a/Documentation/devicetree/bindings/memory-controllers/st,stm32-omi.yaml b/Documentation/devicetree/bindings/memory-controllers/st,stm32-omi.yaml
new file mode 100644
index 000000000..f0bff1b79
--- /dev/null
+++ b/Documentation/devicetree/bindings/memory-controllers/st,stm32-omi.yaml
@@ -0,0 +1,194 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/memory-controllers/st,stm32-omi.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STM32 OSPI Memory Interface (OMI) bindings
+
+maintainers:
+  - Patrice Chotard <patrice.chotard@foss.st.com>
+
+description: |
+  STM32 OSPI Memory Interface allows a SPI flash or HyperFlash connected to
+  the SoC to be accessed via the external address space.
+
+  The flash chip itself should be represented by a subnode of the STM32 OSPI
+  Memory Interface node. The flash interface is selected based on the
+  "compatible" property of this subnode:
+  - if it contains "jedec,spi-nor", then SPI is used;
+  - if it contains "spi-nand", then SPI is used.
+  - if it contains "cfi-flash", then HyperFlash is used.
+
+properties:
+  compatible:
+    items:
+      - const: st,stm32mp25-omi
+
+  reg:
+    description: registers
+
+  '#address-cells':
+    enum: [1, 2]
+
+  '#size-cells':
+    enum: [0, 1]
+
+  memory-region:
+    description: Phandle to a node describing memory-map region to be used
+
+  clocks:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  resets:
+    maxItems: 2
+
+  dmas:
+    description: tx and rx DMA channel
+    minItems: 1
+    maxItems: 2
+
+  dma-names:
+    items:
+      enum: [tx, rx]
+    minItems: 1
+    maxItems: 2
+
+  st,syscfg-dlyb:
+    description: |
+      Use to set the OSPI delay block within SYSCFG to:
+        Tune the phase of the RX sampling clock (or DQS) in order
+        to sample the data in their valid window.
+        Tune the phase of the TX launch clock in order to meet setup
+        and hold constraints of TX signals versus the memory clock.
+    $ref: "/schemas/types.yaml#/definitions/phandle-array"
+    items:
+      minItems: 2
+      maxItems: 2
+
+  st,access:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
+  ranges: true
+
+required:
+  - compatible
+  - reg
+  - '#address-cells'
+  - '#size-cells'
+  - clocks
+  - interrupts
+
+patternProperties:
+  "flash@[0-9a-f]+$":
+    type: object
+    properties:
+      compatible:
+        oneOf:
+          - items:
+              - enum:
+                  - cypress,hyperflash
+              - const: cfi-flash
+          - enum:
+              - jedec,spi-nor
+              - spi-nand
+
+      st,max-frequency:
+        $ref: /schemas/types.yaml#/definitions/uint32
+        description:
+          Maximum clocking speed of the device in Hz.
+
+      st,tacc-ns:
+        description:
+          Device initial access time.
+
+      st,wzl:
+        $ref: /schemas/types.yaml#/definitions/string
+        description:
+          Enable write zero latency
+
+anyOf:
+  - if:
+      properties:
+        compatible:
+          enum:
+            - const: jedec,spi-nor
+            - const: spi-nand
+
+    then:
+      $ref: "/schemas/spi/spi-controller.yaml#"
+
+  - if:
+      properties:
+        compatible:
+          contains:
+            enum:
+              - cfi-flash
+
+    then:
+      $ref: "/schemas/mtd/mtd-physmap.yaml#"
+
+      required:
+        - st,max-frequency
+        - st,tacc-ns
+        - st,wzl
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/stm32mp2-clks.h>
+    #include <dt-bindings/reset/stm32mp2-resets.h>
+    ospi1: spi@40430000 {
+      compatible = "st,stm32mp25-omi";
+      reg = <0x40430000 0x400>;
+      memory-region = <&mm_ospi1>;
+      interrupts = <GIC_SPI 163 IRQ_TYPE_LEVEL_HIGH>;
+      dmas = <&hpdma 2 0x22 0x00003121 0x0>,
+             <&hpdma 2 0x22 0x00003112 0x0>;
+      dma-names = "tx", "rx";
+      clocks = <&rcc CK_KER_OSPI1>;
+      resets = <&rcc OSPI1_R>, <&rcc OSPI1DLL_R>;
+
+      #address-cells = <1>;
+      #size-cells = <0>;
+
+      flash@0 {
+        compatible = "jedec,spi-nor";
+        reg = <0>;
+        spi-rx-bus-width = <4>;
+        spi-max-frequency = <108000000>;
+      };
+    };
+
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/stm32mp2-clks.h>
+    #include <dt-bindings/reset/stm32mp2-resets.h>
+    ospi2: omi@40430000 {
+      compatible = "st,stm32mp25-omi";
+      reg = <0x40430000 0x400>;
+      memory-region = <&mm_ospi1>;
+      interrupts = <GIC_SPI 163 IRQ_TYPE_LEVEL_HIGH>;
+      dmas = <&hpdma 2 0x63 0x00003011 0x0>;
+      dma-names = "rx";
+      st,syscfg-dlyb = <&syscfg 0x1000>;
+      clocks = <&rcc CK_KER_OSPI1>;
+      resets = <&rcc OSPI1_R>, <&rcc OSPI1DLL_R>;
+
+      #address-cells = <2>;
+      #size-cells = <1>;
+
+      flash@0 {
+        compatible = "cypress,hyperflash", "cfi-flash";
+        reg = <0x2 0x0 0x4000000>;
+        st,max-frequency = <100000000>;
+        st,tacc-ns = <48>;
+      };
+    };
diff --git a/Documentation/devicetree/bindings/mfd/st,stm32-lptimer.yaml b/Documentation/devicetree/bindings/mfd/st,stm32-lptimer.yaml
index 8bcea8dd7..771f09998 100644
--- a/Documentation/devicetree/bindings/mfd/st,stm32-lptimer.yaml
+++ b/Documentation/devicetree/bindings/mfd/st,stm32-lptimer.yaml
@@ -21,7 +21,9 @@ maintainers:
 
 properties:
   compatible:
-    const: st,stm32-lptimer
+    enum:
+      - st,stm32-lptimer
+      - st,stm32mp25-lptimer
 
   reg:
     maxItems: 1
@@ -44,12 +46,17 @@ properties:
 
   wakeup-source: true
 
+  power-domains:
+    maxItems: 1
+
   pwm:
     type: object
 
     properties:
       compatible:
-        const: st,stm32-pwm-lp
+        enum:
+          - st,stm32-pwm-lp
+          - st,stm32mp25-pwm-lp
 
       "#pwm-cells":
         const: 3
@@ -64,7 +71,9 @@ patternProperties:
 
     properties:
       compatible:
-        const: st,stm32-lptimer-trigger
+        enum:
+          - st,stm32-lptimer-trigger
+          - st,stm32mp25-lptimer-trigger
 
       reg:
         description: Identify trigger hardware block.
@@ -81,7 +90,9 @@ patternProperties:
 
     properties:
       compatible:
-        const: st,stm32-lptimer-counter
+        enum:
+          - st,stm32-lptimer-counter
+          - st,stm32mp25-lptimer-counter
 
     required:
       - compatible
@@ -91,7 +102,9 @@ patternProperties:
 
     properties:
       compatible:
-        const: st,stm32-lptimer-timer
+        enum:
+          - st,stm32-lptimer-timer
+          - st,stm32mp25-lptimer-timer
 
     required:
       - compatible
diff --git a/Documentation/devicetree/bindings/mfd/st,stm32mp1-pwr.txt b/Documentation/devicetree/bindings/mfd/st,stm32mp1-pwr.txt
new file mode 100644
index 000000000..b5f414a19
--- /dev/null
+++ b/Documentation/devicetree/bindings/mfd/st,stm32mp1-pwr.txt
@@ -0,0 +1,57 @@
+STMicroelectronics STM32MP1 Power Management Controller
+=======================================================
+
+The PWR IP is responsible for handling the power related resources such as
+clocks, power supplies and resets. It provides 6 wake-up pins that are handled
+by an interrupt-controller. Wake-up pin can be used to wake-up from STANDBY SoC state.
+
+Required properties:
+- compatible should be: "st,stm32mp1-pwr"
+- reg: should be register base and length as documented in the
+  datasheet
+- interrupts: contains the reference to the gic wake-up pin interrupt
+- interrupt-controller; Enable interrupt controller for wake-up pins.
+- #interrupt-cells = <3>
+- st,wakeup-pins: contains a list of GPIO spec describing each wake-up pin.
+
+Optional Properties:
+- pwr-supply: main soc power supply
+
+Interrupt consumers have to specify 3 cells:
+  - cell 1: wake-up pin id from 0 to 5
+  - cell 2: IRQ_TYPE_EDGE_FALLING or IRQ_TYPE_EDGE_RISING
+  - cell 3: Pull config: 0 = No Pull, 1=Pull Up, 2=Pull Down
+
+
+Example:
+
+	pwr: pwr@50001000 {
+		compatible = "st,stm32mp1-pwr", "simple-mfd";
+		reg = <0x50001000 0x400>;
+		interrupts = <GIC_SPI 149 IRQ_TYPE_NONE>;
+		interrupt-controller;
+		#interrupt-cells = <3>;
+
+		st,wakeup-pins = <&gpioa 0 0>, <&gpioa 2 0>,
+				 <&gpioc 13 0>, <&gpioi 8 0>,
+				 <&gpioi 11 0>, <&gpioc 1 0>;
+
+		pwr-supply = <&vdd>;
+	};
+
+
+Example of interrupt user:
+gpio_keys {
+	compatible = "gpio-keys";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	button@4 {
+		label = "WakeUp4";
+		linux,code = <BTN_4>;
+		interrupt-parent = <&pwr>;
+		interrupts = <3 IRQ_TYPE_EDGE_FALLING 1>;
+		wakeup-source;
+	};
+};
+
diff --git a/Documentation/devicetree/bindings/misc/st,stm32-omm.yaml b/Documentation/devicetree/bindings/misc/st,stm32-omm.yaml
new file mode 100644
index 000000000..6f5351591
--- /dev/null
+++ b/Documentation/devicetree/bindings/misc/st,stm32-omm.yaml
@@ -0,0 +1,179 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/misc/st,stm32-omm.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STM32 Octo Memory Manager (OMM) bindings
+
+maintainers:
+  - Patrice Chotard <patrice.chotard@foss.st.com>
+
+description: |
+  The STM32 Octo Memory Manager is a low-level interface that enables an
+  efficient OCTOSPI pin assignment with a full I/O matrix (before alternate
+  function map) and multiplex of single/dual/quad/octal SPI interfaces over
+  the same bus.
+
+properties:
+  compatible:
+    const: st,stm32mp25-omm
+
+  "#address-cells":
+    const: 2
+
+  "#size-cells":
+    const: 1
+
+  ranges:
+    description: |
+      Reflects the memory layout with four integer values per bank. Format:
+      <bank-number> 0 <address of the bank> <size>
+
+  reg:
+    items:
+      - description: registers
+      - description: memory mapping
+
+  reg-names:
+    items:
+      - const: omm
+      - const: omm_mm
+
+  memory-region:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: Phandle to a node describing memory-map region to be used.
+
+  memory-region-names:
+    items:
+      - const: mm_ospi1
+      - const: mm_ospi2
+
+  clocks:
+    items:
+      - description: Octo Memory Manager clock
+
+  resets:
+    items:
+      - description: Octo Memory Manager reset
+
+  st,access:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
+  st,syscfg-amcr:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      The Address Mapping Control Register (AMCR) is used to split the 256MB
+      memory map area shared between the 2 OSPI Memory Interface (OMI). The Octo
+      Memory Manager sets the AMCR depending of the memory-region configuration.
+      Format is phandle to syscfg / register offset within syscfg / memory split
+      bitmask.
+    items:
+      minItems: 3
+      maxItems: 3
+
+  st,omm-req2ack-ns:
+    description: |
+      In multiplexed mode (MUXEN = 1), this field defines the time in
+      nanoseconds between two transactions.
+
+  st,omm-cssel-ovr:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description: |
+      Configure the chip select selector override for the 2 OCTOSPIs.
+      The 2 bits mask muxing description is:
+        -bit 0: Chip select selector override setting for OCTOSPI1
+          0x0: the chip select signal from OCTOSPI1 is sent to NCS1
+          0x1: the chip select signal from OCTOSPI1 is sent to NCS2
+        -bit 1: Chip select selector override setting for OCTOSPI2
+          0x0: the chip select signal from OCTOSPI2 is sent to NCS1
+          0x1: the chip select signal from OCTOSPI2 is sent to NCS2
+    items:
+      maxItems: 1
+
+  st,omm-mux:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description: |
+      Configure the muxing between the 2 OCTOSPIs busses and the 2 output ports.
+      The muxing 2 bits mask description is:
+        - 0x0: direct mode, default
+        - 0x1: mux OCTOSPI1 and OCTOSPI2 to port 1
+        - 0x2: swapped mode
+        - 0x3: mux OCTOSPI1 and OCTOSPI2 to port 2
+    items:
+      maxItems: 1
+
+patternProperties:
+  "^spi@[a-f0-9]+$":
+    type: object
+
+  "^.+@[a-f0-9]+$":
+    type: object
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - st,syscfg-amcr
+  - ranges
+
+additionalProperties: false
+unevaluatedProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/stm32mp2-clks.h>
+    #include <dt-bindings/reset/stm32mp2-resets.h>
+
+    ommanager: ommanager@40500000 {
+      #address-cells = <2>;
+      #size-cells = <1>;
+      compatible = "st,stm32mp25-omm";
+      reg = <0x40500000 0x400>, <0x60000000 0x10000000>;
+      reg-names = "omm", "omm_mm";
+      memory-region = <&mm_ospi1>, <&mm_ospi2>;
+      memory-region-names = "mm_ospi1", "mm_ospi2";
+      clocks = <&rcc CK_BUS_OSPIIOM>;
+      resets = <&rcc OSPIIOM_R>;
+      st,syscfg-amcr = <&syscfg 0x2c00 0x7>;
+      st,omm-req2ack-ns = <0x0>;
+      st,omm-mux = <0x0>;
+      st,omm-cssel-ovr = <0x0>;
+      st,access = <&rifsc 111>;
+
+      ranges = <0 0 0x40430000 0x400>,
+               <1 0 0x40440000 0x400>;
+
+      ospi1: spi@40430000 {
+        #address-cells = <1>;
+        #size-cells = <0>;
+        compatible = "st,stm32mp25-omi";
+        reg = <0 0 0x400>;
+        interrupts = <GIC_SPI 163 IRQ_TYPE_LEVEL_HIGH>;
+        dmas = <&hpdma 2 0x22 0x00003121 0x0>,
+               <&hpdma 2 0x22 0x00003112 0x0>;
+        dma-names = "tx", "rx";
+        st,syscfg-dlyb = <&syscfg 0x1000>;
+        clocks = <&rcc CK_KER_OSPI1>;
+        resets = <&rcc OSPI1_R>, <&rcc OSPI1DLL_R>;
+        st,access = <&rifsc 74>;
+      };
+
+      ospi2: spi@40440000 {
+        #address-cells = <1>;
+        #size-cells = <0>;
+        compatible = "st,stm32mp25-omi";
+        reg = <1 0 0x400>;
+        interrupts = <GIC_SPI 164 IRQ_TYPE_LEVEL_HIGH>;
+        dmas = <&hpdma 3 0x22 0x00003121 0x0>,
+               <&hpdma 3 0x22 0x00003112 0x0>;
+        dma-names = "tx", "rx";
+        st,syscfg-dlyb = <&syscfg 0x1400>;
+        clocks = <&rcc CK_KER_OSPI2>;
+        resets = <&rcc OSPI2_R>, <&rcc OSPI2DLL_R>;
+        st,access = <&rifsc 75>;
+      };
+    };
diff --git a/Documentation/devicetree/bindings/mmc/arm,pl18x.yaml b/Documentation/devicetree/bindings/mmc/arm,pl18x.yaml
index 47595cb48..69998750a 100644
--- a/Documentation/devicetree/bindings/mmc/arm,pl18x.yaml
+++ b/Documentation/devicetree/bindings/mmc/arm,pl18x.yaml
@@ -53,6 +53,18 @@ properties:
         items:
           - const: arm,pl18x
           - const: arm,primecell
+      - description: Entry for STMicroelectronics variant of PL18x.
+          This dedicated compatible is used by bootloaders.
+        items:
+          - const: st,stm32-sdmmc2
+          - const: arm,pl18x
+          - const: arm,primecell
+      - description: Entry for STMicroelectronics variant of PL18x for
+          STM32MP25. This dedicated compatible is used by bootloaders.
+        items:
+          - const: st,stm32mp25-sdmmc2
+          - const: arm,pl18x
+          - const: arm,primecell
 
   clocks:
     description: One or two clocks, the "apb_pclk" and the "MCLK"
diff --git a/Documentation/devicetree/bindings/mtd/nand-controller.yaml b/Documentation/devicetree/bindings/mtd/nand-controller.yaml
index 5cd144a9e..29c9e5b0b 100644
--- a/Documentation/devicetree/bindings/mtd/nand-controller.yaml
+++ b/Documentation/devicetree/bindings/mtd/nand-controller.yaml
@@ -154,6 +154,13 @@ patternProperties:
           Ready/Busy pins. Active state refers to the NAND ready state and
           should be set to GPIOD_ACTIVE_HIGH unless the signal is inverted.
 
+      wp-gpios:
+        description:
+          Contains one GPIO descriptor for the Write Protect pin.
+          Active state refers to the NAND Write Protect state and should be
+          set to GPIOD_ACTIVE_LOW unless the signal is inverted.
+        maxItems: 1
+
       secure-regions:
         $ref: /schemas/types.yaml#/definitions/uint64-matrix
         description:
diff --git a/Documentation/devicetree/bindings/mtd/st,stm32-fmc2-nand.yaml b/Documentation/devicetree/bindings/mtd/st,stm32-fmc2-nand.yaml
index 29c5ef24a..152b76794 100644
--- a/Documentation/devicetree/bindings/mtd/st,stm32-fmc2-nand.yaml
+++ b/Documentation/devicetree/bindings/mtd/st,stm32-fmc2-nand.yaml
@@ -14,10 +14,12 @@ properties:
     enum:
       - st,stm32mp15-fmc2
       - st,stm32mp1-fmc2-nfc
+      - st,stm32mp25-fmc2
+      - st,stm32mp25-fmc2-nfc
 
   reg:
     minItems: 6
-    maxItems: 7
+    maxItems: 13
 
   interrupts:
     maxItems: 1
@@ -89,6 +91,60 @@ allOf:
             - description: Chip select 1 command
             - description: Chip select 1 address space
 
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: st,stm32mp25-fmc2
+    then:
+      properties:
+        reg:
+          items:
+            - description: Registers
+            - description: Chip select 0 data
+            - description: Chip select 0 command
+            - description: Chip select 0 address space
+            - description: Chip select 1 data
+            - description: Chip select 1 command
+            - description: Chip select 1 address space
+            - description: Chip select 2 data
+            - description: Chip select 2 command
+            - description: Chip select 2 address space
+            - description: Chip select 3 data
+            - description: Chip select 3 command
+            - description: Chip select 3 address space
+
+        clocks:
+          maxItems: 1
+
+        resets:
+          maxItems: 1
+
+      required:
+        - clocks
+
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: st,stm32mp25-fmc2-nfc
+    then:
+      properties:
+        reg:
+          items:
+            - description: Chip select 0 data
+            - description: Chip select 0 command
+            - description: Chip select 0 address space
+            - description: Chip select 1 data
+            - description: Chip select 1 command
+            - description: Chip select 1 address space
+            - description: Chip select 2 data
+            - description: Chip select 2 command
+            - description: Chip select 2 address space
+            - description: Chip select 3 data
+            - description: Chip select 3 command
+            - description: Chip select 3 address space
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/net/stm32-dwmac.yaml b/Documentation/devicetree/bindings/net/stm32-dwmac.yaml
index d3f05d593..94b4dde3c 100644
--- a/Documentation/devicetree/bindings/net/stm32-dwmac.yaml
+++ b/Documentation/devicetree/bindings/net/stm32-dwmac.yaml
@@ -83,6 +83,11 @@ properties:
       select RCC clock instead of ETH_REF_CLK.
     type: boolean
 
+  st,eth-ptp-from-rcc:
+    description:
+      set this property when PTP (IEEE1588) clock selection is from RCC,
+      by default ETHSW ptp ref clock is used
+    type: boolean
 required:
   - compatible
   - clocks
diff --git a/Documentation/devicetree/bindings/net/stm32-ttt.yaml b/Documentation/devicetree/bindings/net/stm32-ttt.yaml
new file mode 100644
index 000000000..452154ce0
--- /dev/null
+++ b/Documentation/devicetree/bindings/net/stm32-ttt.yaml
@@ -0,0 +1,90 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+# Copyright 2019 BayLibre, SAS
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/net/stm32-ttt.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: STMicroelectronics STM32 TSN switch glue layer controller
+
+maintainers:
+  - Alexandre Torgue <alexandre.torgue@foss.st.com>
+
+description:
+  This file documents platform glue layer for the TSN switch.
+
+properties:
+  compatible:
+    contains:
+      enum:
+        - st,stm32-deip
+
+patternProperties:
+  "^deip-sw@[0-9a-f]+$":
+    type: object
+    properties:
+      compatible:
+        enum:
+          - ttt,deip-sw
+    required:
+      - compatible
+
+  "^acm@[0-9a-f]+$":
+    type: object
+    properties:
+      compatible:
+        enum:
+          - ttt,acm-4.0
+    required:
+      - compatible
+
+required:
+  - compatible
+
+additionalProperties: true
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/stm32mp2-clks.h>
+    switch0: ttt-sw@4c000000 {
+        #address-cells  = <1>;
+        #size-cells     = <1>;
+        compatible = "st,stm32-deip";
+        clock-names = "ethsw-bus-clk", "ethsw-clk",
+                      "ethswacmcfg-bus-clk", "ethswacmmsg-bus-clk";
+        clocks = <&rcc CK_BUS_ETHSW>,
+                 <&rcc CK_KER_ETHSW>,
+                 <&rcc CK_BUS_ETHSWACMCFG>,
+                 <&rcc CK_BUS_ETHSWACMMSG>;
+        st,syscon = <&syscfg 0x3800>;
+        ranges = <0x4b000000 0x4b000000 0xc0000>,
+                 <0x4c000000 0x4c000000 0x2000000>;
+        status = "disabled";
+
+        deip_sw0: deip-sw@4c000000 {
+                compatible =  "ttt,deip-sw";
+                reg = <0x4c000000 0x2000000>;
+                interrupts = <GIC_SPI 250 IRQ_TYPE_LEVEL_HIGH>;
+        };
+
+        acm@4b000000 {
+                compatible = "ttt,acm-4.0";
+                reg = <0x4b000000 0x00400>,
+                      <0x4b010000 0x10000>,
+                      <0x4b030000 0x10000>,
+                      <0x4b050000 0x10000>,
+                      <0x4b060000 0x20000>,
+                      <0x4b080000 0x40000>;
+                reg-names = "CommonRegister",
+                            "Bypass1",
+                            "Bypass0",
+                            "Redundancy",
+                            "Scheduler",
+                            "Messagebuffer";
+                buffers = <32>;
+                ptp_worker = <&deip_sw0>;
+        };
+    };
+
+...
diff --git a/Documentation/devicetree/bindings/nvmem/st,stm32-romem.yaml b/Documentation/devicetree/bindings/nvmem/st,stm32-romem.yaml
index 0b80ce22a..b90310a2c 100644
--- a/Documentation/devicetree/bindings/nvmem/st,stm32-romem.yaml
+++ b/Documentation/devicetree/bindings/nvmem/st,stm32-romem.yaml
@@ -22,7 +22,17 @@ properties:
   compatible:
     enum:
       - st,stm32f4-otp
+      - st,stm32mp13-bsec
       - st,stm32mp15-bsec
+      - st,stm32mp25-bsec
+
+  clocks:
+    maxItems: 1
+    description: |
+      - It's not present on stm32f4.
+      - It's not present on stm32mp13.
+      - It's optional on stm32mp15.
+      - It's not present on stm32mp25.
 
 patternProperties:
   "^.*@[0-9a-f]+$":
@@ -36,6 +46,14 @@ patternProperties:
           related area can only be reached by the secure world.
         type: boolean
 
+      st,secure-otp:
+        description: |
+          This property explicits a factory programmed area that only the secure
+          world of the main preocessor can access.
+          It is needed when the related area must be only not reached by the
+          secure world of the coprocessor, it is not shadowed.
+        type: boolean
+
 required:
   - "#address-cells"
   - "#size-cells"
diff --git a/Documentation/devicetree/bindings/pci/st,stm32-pcie-host.yaml b/Documentation/devicetree/bindings/pci/st,stm32-pcie-host.yaml
new file mode 100644
index 000000000..a1cbd7c6c
--- /dev/null
+++ b/Documentation/devicetree/bindings/pci/st,stm32-pcie-host.yaml
@@ -0,0 +1,135 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/pci/st,stm32-pcie-host.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: PCIe RC controller on STM32MP25 SoC
+
+maintainers:
+  - Christian Bruel <christian.bruel@foss.st.com>
+
+description: |+
+  PCIe RC controller based on the Synopsys DesignWare PCIe core.
+
+select:
+  properties:
+    compatible:
+      contains:
+        const: st,stm32mp25-pcie-rc
+  required:
+    - compatible
+
+allOf:
+  - $ref: /schemas/pci/snps,dw-pcie.yaml#
+
+properties:
+  compatible:
+    items:
+      - const: st,stm32mp25-pcie-rc
+      - const: snps,dw-pcie
+
+  reg:
+    items:
+      - description: Data Bus Interface (DBI) registers.
+      - description: PCIe configuration registers.
+
+  reg-names:
+    items:
+      - const: dbi
+      - const: config
+
+  st,syscfg:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: Phandle to the SYSCON entry required for configuring PCIe mode.
+
+  resets:
+    maxItems: 1
+
+  reset-names:
+    const: pcie-rst
+
+  clocks:
+    maxItems: 1
+    description: PCIe system clock
+
+  clock-names:
+    const: pcie-clk
+
+  phys:
+    maxItems: 1
+
+  phy-names:
+    const: pcie-phy
+
+  num-lanes:
+    const: 1
+
+  max-link-speed:
+    enum: [1, 2]
+    default: 2
+
+  max-payload-size:
+    description: Maximum TLP Payload size to use in device control
+    register.
+    enum: [128, 256]
+    default: 128
+
+  max-readreq-size:
+    description: Maximum TLP Read Request size to use in device
+    control register.
+    enum: [128, 256, 512, 1024]
+    default: 512
+
+  msi-parent:
+    maxItems: 1
+
+required:
+  - st,syscfg
+  - interrupt-map
+  - interrupt-map-mask
+  - ranges
+  - resets
+  - reset-names
+  - clocks
+  - clock-names
+  - phys
+  - phy-names
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/phy/phy.h>
+    #include <dt-bindings/clock/stm32mp2-clks.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/reset/stm32mp2-resets.h>
+
+    pcie_rc: pcie@48400000 {
+             compatible = "st,stm32mp25-pcie-rc", "snps,dw-pcie";
+             device_type = "pci";
+             num-lanes = <1>;
+             reg = <0x48400000 0x400000>,
+                   <0x10000000 0x10000>;
+             reg-names = "dbi", "config";
+             st,syscfg = <&syscfg>;
+             #interrupt-cells = <1>;
+             interrupt-map-mask = <0 0 0 7>;
+             interrupt-map = <0 0 0 1 &intc 0 GIC_SPI 264 IRQ_TYPE_LEVEL_HIGH>,
+                             <0 0 0 2 &intc 0 GIC_SPI 265 IRQ_TYPE_LEVEL_HIGH>,
+                             <0 0 0 3 &intc 0 GIC_SPI 266 IRQ_TYPE_LEVEL_HIGH>,
+                             <0 0 0 4 &intc 0 GIC_SPI 267 IRQ_TYPE_LEVEL_HIGH>;
+             #address-cells = <3>;
+             #size-cells = <2>;
+             ranges = <0x01000000 0 0x10010000 0x10010000 0 0x10000>,
+                      <0x02000000 0 0x10020000 0x10020000 0 0x7fe0000>,
+                      <0x42000000 0 0x18000000 0x18000000 0 0x8000000>;
+             bus-range = <0x00 0xff>;
+             clocks = <&rcc CK_BUS_PCIE>;
+             clock-names = "pcie-clk";
+             phys = <&combophy PHY_TYPE_PCIE>;
+             phy-names = "pcie-phy";
+             resets = <&rcc PCIE_R>;
+             reset-names = "pcie-rst";
+             msi-parent = <&v2m0>;
+    };
diff --git a/Documentation/devicetree/bindings/perf/stm32-ddr-pmu.yaml b/Documentation/devicetree/bindings/perf/stm32-ddr-pmu.yaml
new file mode 100644
index 000000000..7b6b949b7
--- /dev/null
+++ b/Documentation/devicetree/bindings/perf/stm32-ddr-pmu.yaml
@@ -0,0 +1,55 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/perf/stm32-ddr-pmu.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+maintainers:
+  - Gerald Baeza <gerald.baeza@st.com>
+
+title: STMicroelectronics STM32 DDR Performance Monitor (DDRPERFM) bindings
+
+properties:
+  compatible:
+    enum:
+      - st,stm32-ddr-pmu
+      - st,stm32mp25-ddr-pmu
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  resets:
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+
+allOf:
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: st,stm32-ddr-pmu
+    then:
+      required:
+        - clocks
+        - resets
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/stm32mp1-clks.h>
+    #include <dt-bindings/reset/stm32mp1-resets.h>
+
+    ddrperfm: perf@5a007000 {
+        compatible = "st,stm32-ddr-pmu";
+        reg = <0x5a007000 0x400>;
+        clocks = <&rcc DDRPERFM>;
+        resets = <&rcc DDRPERFM_R>;
+    };
+...
diff --git a/Documentation/devicetree/bindings/phy/phy-stm32-usbphyc.yaml b/Documentation/devicetree/bindings/phy/phy-stm32-usbphyc.yaml
index 3329f1d33..750ce7074 100644
--- a/Documentation/devicetree/bindings/phy/phy-stm32-usbphyc.yaml
+++ b/Documentation/devicetree/bindings/phy/phy-stm32-usbphyc.yaml
@@ -74,6 +74,10 @@ patternProperties:
       "#phy-cells":
         enum: [ 0x0, 0x1 ]
 
+      interrupts:
+        maxItems: 1
+        description: interrupt used for wakeup when port is used by USBH controller
+
       connector:
         type: object
         allOf:
@@ -81,6 +85,119 @@ patternProperties:
         properties:
           vbus-supply: true
 
+      # It can be necessary to adjust the PHY settings to compensate parasitics, which can be due
+      # to USB connector/receptacle, routing, ESD protection component,... Here is the list of
+      # all optional parameters to tune the interface of the PHY (HS for High-Speed, FS for Full-
+      # Speed, LS for Low-Speed)
+
+      st,current-boost-microamp:
+        description: Current boosting in uA
+        enum: [ 1000, 2000 ]
+
+      st,no-lsfs-fb-cap:
+        description: Disables the LS/FS feedback capacitor
+        type: boolean
+
+      st,decrease-hs-slew-rate:
+        description: Decreases the HS driver slew rate by 10%
+        type: boolean
+
+      st,tune-hs-dc-level:
+        description: |
+          Tunes the HS driver DC level
+          - <0> normal level
+          - <1> increases the level by 5 to 7 mV
+          - <2> increases the level by 10 to 14 mV
+          - <3> decreases the level by 5 to 7 mV
+        $ref: /schemas/types.yaml#/definitions/uint32
+        minimum: 0
+        maximum: 3
+        default: 0
+
+      st,enable-fs-rftime-tuning:
+        description: Enables the FS rise/fall tuning option
+        type: boolean
+
+      st,enable-hs-rftime-reduction:
+        description: Enables the HS rise/fall reduction feature
+        type: boolean
+
+      st,trim-hs-current:
+        description: |
+          Controls HS driver current trimming for choke compensation
+          - <0> = 18.87 mA target current / nominal + 0%
+          - <1> = 19.165 mA target current / nominal + 1.56%
+          - <2> = 19.46 mA target current / nominal + 3.12%
+          - <3> = 19.755 mA target current / nominal + 4.68%
+          - <4> = 20.05 mA target current / nominal + 6.24%
+          - <5> = 20.345 mA target current / nominal + 7.8%
+          - <6> = 20.64 mA target current / nominal + 9.36%
+          - <7> = 20.935 mA target current / nominal + 10.92%
+          - <8> = 21.23 mA target current / nominal + 12.48%
+          - <9> = 21.525 mA target current / nominal + 14.04%
+          - <10> = 21.82 mA target current / nominal + 15.6%
+          - <11> = 22.115 mA target current / nominal + 17.16%
+          - <12> = 22.458 mA target current / nominal + 19.01%
+          - <13> = 22.755 mA target current / nominal + 20.58%
+          - <14> = 23.052 mA target current / nominal + 22.16%
+          - <15> = 23.348 mA target current / nominal + 23.73%
+        $ref: /schemas/types.yaml#/definitions/uint32
+        minimum: 0
+        maximum: 15
+        default: 0
+
+      st,trim-hs-impedance:
+        description: |
+          Controls HS driver impedance tuning for choke compensation
+          - <0> = no impedance offset
+          - <1> = reduce the impedance by 2 ohms
+          - <2> = reduce the impedance by 4 ohms
+          - <3> = reduce the impedance by 6 ohms
+        $ref: /schemas/types.yaml#/definitions/uint32
+        minimum: 0
+        maximum: 3
+        default: 0
+
+      st,tune-squelch-level:
+        description: |
+          Tunes the squelch DC threshold value
+          - <0> = no shift in threshold
+          - <1> = threshold shift by +7 mV
+          - <2> = threshold shift by -5 mV
+          - <3> = threshold shift by +14 mV
+        $ref: /schemas/types.yaml#/definitions/uint32
+        minimum: 0
+        maximum: 3
+        default: 0
+
+      st,enable-hs-rx-gain-eq:
+        description: Enables the HS Rx gain equalizer
+        type: boolean
+
+      st,tune-hs-rx-offset:
+        description: |
+          Adjusts the HS Rx offset
+          - <0> = no offset
+          - <1> = offset of +5 mV
+          - <2> = offset of +10 mV
+          - <3> = offset of -5 mV
+        $ref: /schemas/types.yaml#/definitions/uint32
+        minimum: 0
+        maximum: 3
+        default: 0
+
+      st,no-hs-ftime-ctrl:
+        description: Disables the HS fall time control of single ended signals during pre-emphasis
+        type: boolean
+
+      st,no-lsfs-sc:
+        description: Disables the short circuit protection in LS/FS driver
+        type: boolean
+
+      st,enable-hs-tx-staggering:
+        description: Enables the basic staggering in HS Tx mode
+        type: boolean
+
     allOf:
       - if:
           properties:
@@ -137,6 +254,14 @@ examples:
             reg = <0>;
             phy-supply = <&vdd_usb>;
             #phy-cells = <0>;
+            st,tune-hs-dc-level = <2>;
+            st,enable-fs-rftime-tuning;
+            st,enable-hs-rftime-reduction;
+            st,trim-hs-current = <15>;
+            st,trim-hs-impedance = <1>;
+            st,tune-squelch-level = <3>;
+            st,tune-hs-rx-offset = <2>;
+            st,no-lsfs-sc;
             connector {
                 compatible = "usb-a-connector";
                 vbus-supply = <&vbus_sw>;
@@ -147,6 +272,14 @@ examples:
             reg = <1>;
             phy-supply = <&vdd_usb>;
             #phy-cells = <1>;
+            st,tune-hs-dc-level = <2>;
+            st,enable-fs-rftime-tuning;
+            st,enable-hs-rftime-reduction;
+            st,trim-hs-current = <15>;
+            st,trim-hs-impedance = <1>;
+            st,tune-squelch-level = <3>;
+            st,tune-hs-rx-offset = <2>;
+            st,no-lsfs-sc;
         };
     };
 ...
diff --git a/Documentation/devicetree/bindings/phy/st,stm32-combophy.yaml b/Documentation/devicetree/bindings/phy/st,stm32-combophy.yaml
new file mode 100644
index 000000000..6af9c9eac
--- /dev/null
+++ b/Documentation/devicetree/bindings/phy/st,stm32-combophy.yaml
@@ -0,0 +1,121 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/phy/st,stm32-combophy.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STMicroelectronics STM32MP25 USB3/PCIe ComboPHY binding.
+
+maintainers:
+  - Christian Bruel <christian.bruel@foss.st.com>
+
+description: |
+  Single lane PHY shared (exclusive) between the USB3 and PCIe controllers.
+  Supports 5Gbit/s for USB3 and PCIe gen2 or 2.5Gbit/s for PCIe gen1.
+
+properties:
+  compatible:
+    const: st,stm32mp25-combophy
+
+  reg:
+    maxItems: 1
+
+  st,syscfg:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: Phandle to the SYSCON entry required for configuring PCIe
+      or USB3.
+
+  "#phy-cells":
+    const: 1
+    description: |
+      The cells contain the following arguments.
+
+      - description: The PHY type
+          enum:
+            - PHY_TYPE_USB3
+            - PHY_TYPE_PCIE
+
+  clocks:
+    anyOf:
+      - description: apb-clk Bus clock mandatory to access registers.
+      - description: ker-clk Internal RCC reference clock for USB3 or PCIe
+      - description: pad-clk Optional on board clock input for PCIe only. Typically an
+                     external 100Mhz oscillator wired on dedicated CLKIN pad. Used as reference
+                     clock input instead of the ker-clk
+
+  clock-names:
+    oneOf:
+      - items:
+          - const: apb-clk
+          - const: ker-clk
+
+      - items:
+          - const: apb-clk
+          - const: pad-clk
+
+  resets:
+    maxItems: 1
+
+  reset-names:
+    const: phy-rst
+
+  st,scc-on:
+    type: boolean
+    description:
+      A boolean property whose presence indicates that the SCC for common clock
+      needs to be set.
+
+required:
+  - compatible
+  - reg
+  - st,syscfg
+  - '#phy-cells'
+  - resets
+  - reset-names
+  - clocks
+  - clock-names
+
+additionalProperties: false
+
+examples:
+  - |
+    // Example 1: Combophy configured to use internal reference clock
+    #include <dt-bindings/clock/stm32mp2-clks.h>
+    #include <dt-bindings/reset/stm32mp2-resets.h>
+
+    combophy_internal: phy@480c0000 {
+              compatible = "st,stm32mp25-combophy";
+              reg = <0x480c0000 0x1000>;
+              #phy-cells = <1>;
+              clocks = <&rcc CK_BUS_USB3PCIEPHY>, <&rcc CK_KER_USB3PCIEPHY>;
+              clock-names = "apb-clk", "ker-clk";
+              resets = <&rcc USB3PCIEPHY_R>;
+              reset-names = "phy-rst";
+              st,syscfg = <&syscfg>;
+    };
+
+  - |
+    // Example 2: Combophy configured to use extrenal 100MHz reference clock
+    // on CLKIN pad for PCIe
+    #include <dt-bindings/clock/stm32mp2-clks.h>
+    #include <dt-bindings/reset/stm32mp2-resets.h>
+
+    clocks {
+        pad_clk: pad-clk {
+                #clock-cells = <0>;
+                compatible = "fixed-clock";
+                clock-frequency = <100000000>;
+        };
+    };
+
+    combophy_pad: phy@480c0000 {
+              compatible = "st,stm32mp25-combophy";
+              reg = <0x480c0000 0x1000>;
+              #phy-cells = <1>;
+              clocks = <&rcc CK_BUS_USB3PCIEPHY>, <&pad_clk>;
+              clock-names = "apb-clk", "pad-clk";
+              resets = <&rcc USB3PCIEPHY_R>;
+              reset-names = "phy-rst";
+              st,syscfg = <&syscfg>;
+    };
+...
diff --git a/Documentation/devicetree/bindings/phy/st,stm32-femtophy.yaml b/Documentation/devicetree/bindings/phy/st,stm32-femtophy.yaml
new file mode 100644
index 000000000..1e93ef821
--- /dev/null
+++ b/Documentation/devicetree/bindings/phy/st,stm32-femtophy.yaml
@@ -0,0 +1,184 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/phy/st,stm32-femtophy.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: STMicroelectronics STM32 MPU Femto High-Speed USB PHY
+
+description:
+  USB2 PHY block inside STM32 is used for supporting the HS/FS/LS operation
+  for USB controller. For stm32mp25, it is used by USB2H ctrl in HS/FS/LS mode
+  and by DWC3 ctrl in USB2 LS/FS/HS modes (when host) or USB2 FS/HS modes (when device)
+
+maintainers:
+  - Fabrice Gasnier <fabrice.gasnier@foss.st.com>
+  - Pankaj Dev <pankaj.dev@st.com>
+
+properties:
+  compatible:
+    const: st,stm32mp25-usb2phy
+
+  "#phy-cells":
+    const: 0
+
+  clocks:
+    items:
+      description: PHY ref clock
+
+  resets:
+    items:
+      description: PHY core reset
+
+  vdd33-supply:
+    description: phandle to regulator providing 3V3 power supply to the USB2 HS PHY
+
+  vdda18-supply:
+    description: phandle to regulator providing 1V8 power supply to the USB2 HS PHY
+
+  st,syscfg:
+    $ref: /schemas/types.yaml#/definitions/phandle-array #(arm/stm32/st,stm32-syscon.yaml#)
+    description: Phandle to the STM32-MPU System Controller DT node
+                 <syscon-handle cr-offset>
+
+  st,pll-ipath-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: PLL Integral Path Tune
+                 0->0.5x 1->1.0x 2->1.5x 3->2.0x
+    minimum: 0
+    maximum: 3
+    default: 0
+
+  st,pll-ppath-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: PLL Proportional Path Tune
+                 0->1.0x 1->1.50x 2->2.0x ... 15->5.5x
+    minimum: 0
+    maximum: 15
+    default: 12
+
+  st,comp-dis-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: Disconnect Threshold Adjustment
+                 0->-9% 1->-6% 2->-4% 3->0% 4->3% 5->7% 6->10% 7->12%
+    minimum: 0
+    maximum: 7
+    default: 3
+
+  st,sqrx-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: Squelch Threshold Adjustment
+                 0->15% 1->10% 2->5% 3->0% 4->-5% 5->-10% 6->-15% 7->-20%
+    minimum: 0
+    maximum: 7
+    default: 3
+
+  st,vdatref-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: Data Detect Voltage Adjustment
+                 0->10% 1->0% 2->-10% 3->-20%
+    minimum: 0
+    maximum: 3
+    default: 1
+
+  st,otg-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: VBUS Valid Threshold Adjustment
+                 0->-9% 1->-6% 2->-3% 3->0% 4->3% 5->6% 6->9% 7->12%
+    minimum: 0
+    maximum: 7
+    default: 3
+
+  st,txhsxv-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: Transmitter High Speed Crossover Adjustment
+                 0->Rsvd 1->-15mV 2->15mV 3->0mV
+    minimum: 1
+    maximum: 3
+    default: 3
+
+  st,txfsls-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: FS/LS Source Impedance Adjustment
+                 0->14% 1->6.5% 2->Rsvd 3->0% 7->-5/6% 15->-10.7% other-values->Rsvd
+    enum: [ 0, 1, 3, 7, 15 ]
+    default: 3
+
+  st,txvref-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: HS DC Voltage Level Adjustment
+                 0->-6% 1->-4% 2->-2% 3->0% 4->2% 5->4% 6->6% ... 15->24%
+    minimum: 0
+    maximum: 15
+    default: 3
+
+  st,txrise-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: HS Transmitter Rise/Fall Time Adjustment
+                 0->+5.4% 1->nominal 2->-7.2% 3->-8.1%
+    minimum: 0
+    maximum: 3
+    default: 1
+
+  st,txres-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: USB Source Impedance Adjustment
+                 0->+1.3Ohm 1->0Ohm 2->-3.6Ohm 3->-5.6Ohm
+    minimum: 0
+    maximum: 3
+    default: 1
+
+  st,txpreempamp-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: HS Transmitter Pre Emphasis Current Control
+                 0->Disabled 1->1x 2->2x 3->3x
+    minimum: 0
+    maximum: 3
+    default: 0
+
+  st,txpreemppulse-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: HS Transmitter Pre Emphasis Duration Control
+                 0->2x 1->1x
+    minimum: 0
+    maximum: 1
+    default: 0
+
+required:
+  - compatible
+  - "#phy-cells"
+  - clocks
+  - resets
+  - vdd33-supply
+  - st,syscfg
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/stm32mp2-clks.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/reset/stm32mp2-resets.h>
+
+    usb2_phy2: usb-phy {
+        compatible      = "st,stm32mp25-usb2phy";
+        #phy-cells      = <0>;
+        st,syscfg       = <&syscfg 0x2800>;
+        clocks          = <&rcc CK_KER_USB2PHY2>;
+        resets          = <&rcc USB2PHY2_R>;
+        vdd33-supply    = <&vdd33usb>;
+
+        st,pll-ipath-tune = /bits/ 8 <0>;
+        st,pll-ppath-tune = /bits/ 8 <0>;
+        st,comp-dis-tune = /bits/ 8 <0>;
+        st,sqrx-tune = /bits/ 8 <0>;
+        st,vdatref-tune = /bits/ 8 <0>;
+        st,otg-tune = /bits/ 8 <0>;
+        st,txhsxv-tune = /bits/ 8 <1>;
+        st,txfsls-tune = /bits/ 8 <0>;
+        st,txvref-tune = /bits/ 8 <0>;
+        st,txrise-tune = /bits/ 8 <1>;
+        st,txres-tune = /bits/ 8 <0>;
+        st,txpreempamp-tune = /bits/ 8 <0>;
+        st,txpreemppulse-tune = /bits/ 8 <0>;
+    };
diff --git a/Documentation/devicetree/bindings/pinctrl/st,stm32-pinctrl.yaml b/Documentation/devicetree/bindings/pinctrl/st,stm32-pinctrl.yaml
index dfee6d38a..2f46fc18d 100644
--- a/Documentation/devicetree/bindings/pinctrl/st,stm32-pinctrl.yaml
+++ b/Documentation/devicetree/bindings/pinctrl/st,stm32-pinctrl.yaml
@@ -27,6 +27,8 @@ properties:
       - st,stm32mp135-pinctrl
       - st,stm32mp157-pinctrl
       - st,stm32mp157-z-pinctrl
+      - st,stm32mp257-pinctrl
+      - st,stm32mp257-z-pinctrl
 
   '#address-cells':
     const: 1
@@ -52,7 +54,7 @@ properties:
       Indicates the SOC package used.
       More details in include/dt-bindings/pinctrl/stm32-pinfunc.h
     $ref: /schemas/types.yaml#/definitions/uint32
-    enum: [1, 2, 4, 8]
+    enum: [0x1, 0x2, 0x4, 0x8, 0x100, 0x400, 0x800]
 
 patternProperties:
   '^gpio@[0-9a-f]*$':
@@ -140,9 +142,13 @@ patternProperties:
               * ...
               * 16 : Alternate Function 15
               * 17 : Analog
+              * 18 : Reserved
               To simplify the usage, macro is available to generate "pinmux" field.
               This macro is available here:
                 - include/dt-bindings/pinctrl/stm32-pinfunc.h
+              Setting the pinmux's function to the Reserved (RSVD) value is used to inform
+              the driver that it shall not apply the mux setting. This can be used to
+              reserve some pins, for example to a co-processor not running Linux.
               Some examples of using macro:
                /* GPIO A9 set as alernate function 2 */
                ... {
@@ -156,6 +162,10 @@ patternProperties:
                ... {
                           pinmux = <STM32_PINMUX('A', 9, ANALOG)>;
                };
+               /* GPIO A9 reserved for co-processor */
+               ... {
+                          pinmux = <STM32_PINMUX('A', 9, RSVD)>;
+               };
 
           bias-disable:
             type: boolean
@@ -179,6 +189,54 @@ patternProperties:
               3: High speed
             $ref: /schemas/types.yaml#/definitions/uint32
             enum: [0, 1, 2, 3]
+          st,io-delay-path:
+            description: |
+              IO synchronization delay path location
+              0: Delay switched into the output path
+              1: Delay switched into the input path
+            $ref: /schemas/types.yaml#/definitions/uint32
+            enum: [0, 1]
+          st,io-clk-edge:
+            description: |
+              IO synchronization clock edge
+              0: Data single-edge (changing on rising or falling clock edge)
+              1: Data double-edge (changing on both clock edges)
+            $ref: /schemas/types.yaml#/definitions/uint32
+            enum: [0, 1]
+          st,io-clk-type:
+            description: |
+              IO synchronization clock inversion
+              0: IO clocks not inverted. Data retimed to rising clock edge
+              1: IO clocks inverted. Data retimed to falling clock edge
+            $ref: /schemas/types.yaml#/definitions/uint32
+            enum: [0, 1]
+          st,io-retime:
+            description: |
+              IO synchronization data retime
+              0: Data not synchronized or retimed on clock edges
+              1: Data retimed to either rising or falling clock edge
+            $ref: /schemas/types.yaml#/definitions/uint32
+            enum: [0, 1]
+          st,io-delay:
+            description: |
+              IO synchronization delay applied to the input or output path
+              0: No delay
+              1: Delay 0.30 ns
+              2: Delay 0.50 ns
+              3: Delay 0.75 ns
+              4: Delay 1.00 ns
+              5: Delay 1.25 ns
+              6: Delay 1.50 ns
+              7: Delay 1.75 ns
+              8: Delay 2.00 ns
+              9: Delay 2.25 ns
+              10: Delay 2.50 ns
+              11: Delay 2.75 ns
+              12: Delay 3.00 ns
+              13: Delay 3.25 ns
+            $ref: /schemas/types.yaml#/definitions/uint32
+            minimum: 0
+            maximum: 13
 
         required:
           - pinmux
diff --git a/Documentation/devicetree/bindings/regulator/protection-consumer.txt b/Documentation/devicetree/bindings/regulator/protection-consumer.txt
new file mode 100644
index 000000000..bf8169e00
--- /dev/null
+++ b/Documentation/devicetree/bindings/regulator/protection-consumer.txt
@@ -0,0 +1,23 @@
+regulator protection bindings
+
+
+Required properties:
+	compatible: "protection-consumer"
+	protection-supply: the phandle of the regulator to control
+
+Optional properties:
+--------------------
+	interrupt
+
+
+Example:
+
+	regulator_protection {
+		compatible = "protection-consumer";
+		protection-supply = <&vdd>;
+		status = "okay";
+
+		interrupts = <15 2>;
+		interrupt-parent = <&gpiof>;
+	};
+
diff --git a/Documentation/devicetree/bindings/regulator/st,stm32-vrefbuf.yaml b/Documentation/devicetree/bindings/regulator/st,stm32-vrefbuf.yaml
index 3cd4a254e..fe9c5e83c 100644
--- a/Documentation/devicetree/bindings/regulator/st,stm32-vrefbuf.yaml
+++ b/Documentation/devicetree/bindings/regulator/st,stm32-vrefbuf.yaml
@@ -19,7 +19,9 @@ allOf:
 
 properties:
   compatible:
-    const: st,stm32-vrefbuf
+    enum:
+      - st,stm32-vrefbuf
+      - st,stm32mp13-vrefbuf
 
   reg:
     maxItems: 1
diff --git a/Documentation/devicetree/bindings/remoteproc/rproc-srm.txt b/Documentation/devicetree/bindings/remoteproc/rproc-srm.txt
new file mode 100644
index 000000000..baa6e8e13
--- /dev/null
+++ b/Documentation/devicetree/bindings/remoteproc/rproc-srm.txt
@@ -0,0 +1,58 @@
+Remoteproc System Resource Manager
+----------------------------------
+
+The remoteproc SRM (System Resource Manager) handles resources allocated
+to remote processors.
+This makes it possible for remote proc to reserve and initialize system
+resources for a peripheral assigned to a coprocessor.
+
+The devices are grouped in a core node
+
+Core
+====
+Required properties:
+- compatible: should be "rproc-srm-core"
+
+Dev
+===
+Required properties:
+- compatible: should be "rproc-srm-dev"
+
+Optional properties:
+- reg: register base address and length
+- clocks: clocks required by the coprocessor
+- clock-names: see clock-bindings.txt
+- pinctrl-0: pins configurations required by the coprocessor
+	The SRM reserves the pins for the coprocessor, which prevents the local
+	processor to use them.
+- pinctrl-names: must be "default".
+- x-supply: power supplies required by the coprocessor
+- interrupts: external interrupts configurations required by the coprocessor.
+	This is optional since the configuration is done by the coprocessor.
+	When defined, the SRM (over)writes the configuration which allows the
+	interrupt controller to check for configuration conflicts.
+- interrupt-parent: see interrupts.txt
+- interrupt-names: see interrupts.txt
+
+Example:
+	system_resources {
+		compatible = "rproc-srm-core";
+
+		mmc0: sdhci@09060000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x09060000 0x100>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&m4_pinctrl_mmc0>;
+			clock-names = "mmc", "icn";
+			clocks = <&clk_s_c0_flexgen CLK_MMC_0>,
+				 <&clk_s_c0_flexgen CLK_RX_ICN_HVA>;
+			vdda-supply = <&vdda>;
+		};
+
+		button {
+			compatible = "rproc-srm-dev";
+			interrupt-parent = <&gpioa>;
+			interrupts = <5 1>;
+			interrupt-names = "gpio_key";
+		};
+	};
diff --git a/Documentation/devicetree/bindings/remoteproc/st,stm32-rproc.yaml b/Documentation/devicetree/bindings/remoteproc/st,stm32-rproc.yaml
index 1e6225677..d6bc99451 100644
--- a/Documentation/devicetree/bindings/remoteproc/st,stm32-rproc.yaml
+++ b/Documentation/devicetree/bindings/remoteproc/st,stm32-rproc.yaml
@@ -16,7 +16,9 @@ maintainers:
 
 properties:
   compatible:
-    const: st,stm32mp1-m4
+    enum:
+      - st,stm32mp1-m4
+      - st,stm32mp2-m33
 
   reg:
     description:
@@ -25,21 +27,12 @@ properties:
     maxItems: 3
 
   resets:
-    maxItems: 1
-
-  st,syscfg-holdboot:
-    description: remote processor reset hold boot
-      - Phandle of syscon block.
-      - The offset of the hold boot setting register.
-      - The field mask of the hold boot.
-    $ref: "/schemas/types.yaml#/definitions/phandle-array"
-    maxItems: 1
+    maxItems: 2
 
-  st,syscfg-tz:
-    description:
-      Reference to the system configuration which holds the RCC trust zone mode
-    $ref: "/schemas/types.yaml#/definitions/phandle-array"
-    maxItems: 1
+  reset-names:
+    items:
+      - const: mcu_rst
+      - const: hold_boot
 
   interrupts:
     description: Should contain the WWDG1 watchdog reset interrupt
@@ -95,6 +88,14 @@ properties:
       Reference to the system configuration which holds the remote
     maxItems: 1
 
+  st,syscfg-nsvtor:
+    $ref: "/schemas/types.yaml#/definitions/phandle-array"
+    description: |
+      Reference to the system configuration register which stores the remote processor
+      non-secure vector table pointer.
+      address, used to boot it.
+    maxItems: 1
+
   st,syscfg-m4-state:
     $ref: "/schemas/types.yaml#/definitions/phandle-array"
     description: |
@@ -119,7 +120,6 @@ required:
   - reg
   - resets
   - st,syscfg-holdboot
-  - st,syscfg-tz
 
 additionalProperties: false
 
@@ -131,9 +131,10 @@ examples:
       reg = <0x10000000 0x40000>,
             <0x30000000 0x40000>,
             <0x38000000 0x10000>;
-      resets = <&rcc MCU_R>;
+      resets = <&scmi_reset RST_SCMI_MCU>,
+               <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+      reset-names = "mcu_rst", "hold_boot";
       st,syscfg-holdboot = <&rcc 0x10C 0x1>;
-      st,syscfg-tz = <&rcc 0x000 0x1>;
       st,syscfg-rsc-tbl = <&tamp 0x144 0xFFFFFFFF>;
       st,syscfg-m4-state = <&tamp 0x148 0xFFFFFFFF>;
     };
diff --git a/Documentation/devicetree/bindings/rng/st,stm32-rng.yaml b/Documentation/devicetree/bindings/rng/st,stm32-rng.yaml
index 82bb2e97e..17dd4d826 100644
--- a/Documentation/devicetree/bindings/rng/st,stm32-rng.yaml
+++ b/Documentation/devicetree/bindings/rng/st,stm32-rng.yaml
@@ -15,7 +15,9 @@ maintainers:
 
 properties:
   compatible:
-    const: st,stm32-rng
+    oneOf:
+            - const: st,stm32-rng
+            - const: st,stm32mp13-rng
 
   reg:
     maxItems: 1
diff --git a/Documentation/devicetree/bindings/rtc/st,stm32-rtc.yaml b/Documentation/devicetree/bindings/rtc/st,stm32-rtc.yaml
index 5456604b1..d94e1d13d 100644
--- a/Documentation/devicetree/bindings/rtc/st,stm32-rtc.yaml
+++ b/Documentation/devicetree/bindings/rtc/st,stm32-rtc.yaml
@@ -52,6 +52,20 @@ properties:
       override default rtc_ck parent clock phandle of the new parent clock of rtc_ck
     maxItems: 1
 
+  st,lsco:
+    $ref: "/schemas/types.yaml#/definitions/uint32"
+    description: |
+      To select and enable RTC Low Speed Clock Output.
+      Refer to <include/dt-bindings/rtc/rtc-stm32.h> for the supported values.
+      Pinctrl state named "default" may be defined to reserve pin for RTC output.
+
+  st,alarm:
+    $ref: "/schemas/types.yaml#/definitions/uint32"
+    description: |
+      To select and enable RTC Alarm A output.
+      Refer to <include/dt-bindings/rtc/rtc-stm32.h> for the supported values.
+      Pinctrl state named "default" may be defined to reserve pin for RTC output.
+
 allOf:
   - if:
       properties:
@@ -65,6 +79,12 @@ allOf:
           minItems: 1
           maxItems: 1
 
+        st,lsco:
+          maxItems: 0
+
+        st,alarm:
+          maxItems: 0
+
         clock-names: false
 
       required:
@@ -82,6 +102,12 @@ allOf:
           minItems: 2
           maxItems: 2
 
+        st,lsco:
+          maxItems: 0
+
+        st,alarm:
+          maxItems: 0
+
       required:
         - clock-names
         - st,syscfg
@@ -101,6 +127,12 @@ allOf:
         assigned-clocks: false
         assigned-clock-parents: false
 
+        st,lsco:
+          maxItems: 1
+
+        st,alarm:
+          maxItems: 1
+
       required:
         - clock-names
 
@@ -129,12 +161,17 @@ examples:
 
     #include <dt-bindings/interrupt-controller/arm-gic.h>
     #include <dt-bindings/clock/stm32mp1-clks.h>
+    #include <dt-bindings/rtc/rtc-stm32.h>
     rtc@5c004000 {
       compatible = "st,stm32mp1-rtc";
       reg = <0x5c004000 0x400>;
       clocks = <&rcc RTCAPB>, <&rcc RTC>;
       clock-names = "pclk", "rtc_ck";
       interrupts = <GIC_SPI 3 IRQ_TYPE_LEVEL_HIGH>;
+      st,alarm = <RTC_OUT1>;
+      st,lsco = <RTC_OUT2_RMP>;
+      pinctrl-0 = <&rtc_out1_pins_a &rtc_out2_rmp_pins_a>;
+      pinctrl-names = "default";
     };
 
 ...
diff --git a/Documentation/devicetree/bindings/serial/rs485.yaml b/Documentation/devicetree/bindings/serial/rs485.yaml
index 0c9fa694f..603d74cf2 100644
--- a/Documentation/devicetree/bindings/serial/rs485.yaml
+++ b/Documentation/devicetree/bindings/serial/rs485.yaml
@@ -29,6 +29,20 @@ properties:
           default: 0
           maximum: 1000
 
+  rs485-rts-delay-ns:
+    description: prop-encoded-array <a b>
+    items:
+      items:
+        - description: Delay between rts signal and beginning of data sent in
+            nanoseconds. It corresponds to the delay before sending data.
+          default: 0
+          maximum: 1000
+        - description: Delay between end of data sent and rts signal in nanoseconds.
+            It corresponds to the delay after sending data and actual release
+            of the line.
+          default: 0
+          maximum: 1000
+
   rs485-rts-active-low:
     description: drive RTS low when sending (default is high).
     $ref: /schemas/types.yaml#/definitions/flag
diff --git a/Documentation/devicetree/bindings/serial/st,stm32-uart.yaml b/Documentation/devicetree/bindings/serial/st,stm32-uart.yaml
index f50f4ca89..93ca9aa8f 100644
--- a/Documentation/devicetree/bindings/serial/st,stm32-uart.yaml
+++ b/Documentation/devicetree/bindings/serial/st,stm32-uart.yaml
@@ -61,10 +61,15 @@ properties:
   wakeup-source: true
 
   rs485-rts-delay: true
+  rs485-rts-delay-ns: true
   rs485-rts-active-low: true
   linux,rs485-enabled-at-boot-time: true
   rs485-rx-during-tx: true
 
+  power-domains:
+    $ref: ../power/power-domain.yaml
+    maxItems: 1
+
   rx-threshold:
     description:
       If value is set to 1, RX FIFO threshold is disabled.
diff --git a/Documentation/devicetree/bindings/soc/stm32/st,stm32mp1-hslv.yaml b/Documentation/devicetree/bindings/soc/stm32/st,stm32mp1-hslv.yaml
new file mode 100644
index 000000000..a228a5b26
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/stm32/st,stm32mp1-hslv.yaml
@@ -0,0 +1,44 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/regulator/st,stm32mp1-hslv.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STM32MP1 HSLV IO Speed config assistant
+
+maintainers:
+  - Pascal Paillet <p.paillet@st.com>
+
+description: |
+  Some of the STMicroelectronics's STM32 MP13 IOs can be set to high speed mode
+  if their supply is lower than a 2.7V. The goal of this driver is to
+  automatically set the IOs to high speed mode depending on their supply's
+  regulator voltage value.
+
+properties:
+  compatible:
+    const: st,stm32mp13,hslv
+
+  hslv-supply:
+    description: Input supply phandle(s) for hslv input
+
+  st,syscon:
+    description: hslv sysconf register offset and mask
+
+required:
+  - compatible
+  - hslv-supply
+  - st,syscon
+
+additionalProperties: false
+
+examples:
+  - |
+      hslv@1 {
+            compatible = "st,stm32mp13,hslv";
+
+            /* sdmmc1 hslv = 0x50 + 4 * 4  = 0x60 */
+            st,syscon = <&syscfg 0x60 0x1018>;
+            hslv-supply = <&sdmmc1_regu>;
+      };
+...
diff --git a/Documentation/devicetree/bindings/soc/stm32/stm32_hdp.txt b/Documentation/devicetree/bindings/soc/stm32/stm32_hdp.txt
new file mode 100644
index 000000000..e2bd82f49
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/stm32/stm32_hdp.txt
@@ -0,0 +1,39 @@
+STM32 - STM32MP1- HDP Pin configuration for STM32MP1
+=======================================================
+
+The Hardware Debug Port (HDP) allows the observation of internal signals. By using multiplexers,
+up to 16 signals for each of 8-bit output can be observed.
+
+Required Properties:
+
+  - compatible: Must be "st,stm32mp1-hdp"
+  - muxing-hdp: Indicates for each HDP pins selected which HDP output among the 16 available signals you want
+
+For each HDP pins you can select one of 16 signals which will be described in file : include/dt-bindings/soc/stm32-hdp.h
+
+Example
+-------
+
+In common dtsi file:
+
+hdp: hdp@5002a000 {
+	compatible = "st,stm32mp1-hdp";
+	reg = <0x5002a000 0x400>;
+	clocks = <&rcc HDP>;
+	clock-names = "hdp";
+};
+
+In board-specific file:
+
+In this example I've selected HDP0, HDP6 and HDP7, and for HDP0 the output signal is HDP0_GPOVAL_0,
+for HDP6 is HDP6_GPOVAL_6, and for HDP7 is HDP7_GPOVAL_7.
+
+&hdp {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&hdp0_pins_a &hdp6_pins_a &hdp7_pins_a>;
+	pinctrl-1 = <&hdp0_pins_sleep_a &hdp6_pins_sleep_a &hdp7_pins_sleep_a>;
+
+	muxing-hdp = <(STM32_HDP(0, HDP0_GPOVAL_0) |
+		       STM32_HDP(6, HDP6_GPOVAL_6) |
+		       STM32_HDP(7, HDP7_GPOVAL_7))>;
+};
diff --git a/Documentation/devicetree/bindings/sound/st,stm32-sai.yaml b/Documentation/devicetree/bindings/sound/st,stm32-sai.yaml
index f97132400..bbb4dc864 100644
--- a/Documentation/devicetree/bindings/sound/st,stm32-sai.yaml
+++ b/Documentation/devicetree/bindings/sound/st,stm32-sai.yaml
@@ -20,6 +20,7 @@ properties:
     enum:
       - st,stm32f4-sai
       - st,stm32h7-sai
+      - st,stm32mp25-sai
 
   reg:
     items:
@@ -43,9 +44,11 @@ properties:
     const: 1
 
   clocks:
+    minItems: 1
     maxItems: 3
 
   clock-names:
+    minItems: 1
     maxItems: 3
 
 required:
@@ -136,7 +139,7 @@ allOf:
           contains:
             const: st,stm32f4-sai
 
-  - then:
+    then:
       properties:
         clocks:
           items:
@@ -148,7 +151,13 @@ allOf:
             - const: x8k
             - const: x11k
 
-  - else:
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: st,stm32mph7-sai
+
+    then:
       properties:
         clocks:
           items:
@@ -162,6 +171,22 @@ allOf:
             - const: x8k
             - const: x11k
 
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: st,stm32mp25-sai
+
+    then:
+      properties:
+        clocks:
+          items:
+            - description: pclk feeds the peripheral bus interface.
+
+        clock-names:
+          items:
+            - const: pclk
+
 additionalProperties: false
 
 examples:
diff --git a/Documentation/devicetree/bindings/spi/st,stm32-qspi.yaml b/Documentation/devicetree/bindings/spi/st,stm32-qspi.yaml
index 983c4e54c..a21246712 100644
--- a/Documentation/devicetree/bindings/spi/st,stm32-qspi.yaml
+++ b/Documentation/devicetree/bindings/spi/st,stm32-qspi.yaml
@@ -46,6 +46,14 @@ properties:
       - const: tx
       - const: rx
 
+  st,dual-flash:
+    type: boolean
+    description:
+      Allows to use 8 data lines in case cs-gpios property is defined.
+
+dependencies:
+  st,dual-flash: [ cs-gpios ]
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/spi/st,stm32-spi.yaml b/Documentation/devicetree/bindings/spi/st,stm32-spi.yaml
index 2d9af4c50..8962b2b4d 100644
--- a/Documentation/devicetree/bindings/spi/st,stm32-spi.yaml
+++ b/Documentation/devicetree/bindings/spi/st,stm32-spi.yaml
@@ -27,8 +27,13 @@ allOf:
     then:
       properties:
         st,spi-midi-ns: false
+        spi-slave: false
+        st,spi-slave-underrun: false
 
 properties:
+  "#address-cells": true
+  "#size-cells": true
+
   compatible:
     enum:
       - st,stm32f4-spi
@@ -59,6 +64,24 @@ properties:
       - const: rx
       - const: tx
 
+  spi-slave:
+    description:
+      The SPI controller acts as a slave, instead of a master.
+
+  cs-gpios:
+    description:
+      In case of spi-slave not defined, cs-gpios behave as defined in
+      spi-controller.yaml.
+      In case of spi-slave defined, if <0>, indicate that SS should be
+      detected via the dedicated HW pin
+
+  st,spi-slave-underrun:
+    $ref: /schemas/types.yaml#/definitions/uint32-array
+    description:
+      First parameter enables and selects slave underrun reaction.
+      Refer to "dt-bindings/spi/spi-stm32.h" for the supported values.
+      Second parameter is the pattern in case of SPI_SEND_PATTERN mode.
+
 patternProperties:
   "^[a-zA-Z][a-zA-Z0-9,+\\-._]{0,63}@[0-9a-f]+$":
     type: object
diff --git a/Documentation/devicetree/bindings/usb/dwc2.yaml b/Documentation/devicetree/bindings/usb/dwc2.yaml
index 10c7d9b6c..882a2f1e0 100644
--- a/Documentation/devicetree/bindings/usb/dwc2.yaml
+++ b/Documentation/devicetree/bindings/usb/dwc2.yaml
@@ -9,6 +9,9 @@ title: DesignWare HS OTG USB 2.0 controller Bindings
 maintainers:
   - Rob Herring <robh@kernel.org>
 
+allOf:
+  - $ref: usb-drd.yaml#
+
 properties:
   compatible:
     oneOf:
@@ -101,12 +104,17 @@ properties:
     description: reference to the VBUS and ID sensing comparators supply, in
       order to perform OTG operation, used on STM32MP15 SoCs.
 
-  dr_mode:
-    enum: [host, peripheral, otg]
+  dr_mode: true
 
-  usb-role-switch:
-    $ref: /schemas/types.yaml#/definitions/flag
-    description: Support role switch.
+  otg-rev: true
+
+  hnp-disable: true
+
+  srp-disable: true
+
+  usb-role-switch: true
+
+  role-switch-default-mode: true
 
   g-rx-fifo-size:
     $ref: /schemas/types.yaml#/definitions/uint32
@@ -130,6 +138,21 @@ properties:
     description: If present indicates that we need to reset the PHY when we 
       detect a wakeup. This is due to a hardware errata.
 
+  port:
+    description:
+      Any connector to the data bus of this controller should be modelled
+      using the OF graph bindings specified, if the "usb-role-switch"
+      property is used.
+    $ref: /schemas/graph.yaml#/properties/port
+
+  wakeup-source:
+    $ref: /schemas/types.yaml#/definitions/flag
+    description: If present indicates this device has wakeup capabilities
+
+dependencies:
+  port: [ usb-role-switch ]
+  role-switch-default-mode: [ usb-role-switch ]
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/usb/generic-ehci.yaml b/Documentation/devicetree/bindings/usb/generic-ehci.yaml
index cb5da1df8..0b12acf80 100644
--- a/Documentation/devicetree/bindings/usb/generic-ehci.yaml
+++ b/Documentation/devicetree/bindings/usb/generic-ehci.yaml
@@ -149,6 +149,11 @@ properties:
       - host
       - otg
 
+  wakeup-source:
+    $ref: /schemas/types.yaml#/definitions/flag
+    description:
+      Indicate this device has wakeup capabilities.
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/usb/generic-ohci.yaml b/Documentation/devicetree/bindings/usb/generic-ohci.yaml
index d5fd3aa53..ef237675a 100644
--- a/Documentation/devicetree/bindings/usb/generic-ohci.yaml
+++ b/Documentation/devicetree/bindings/usb/generic-ohci.yaml
@@ -116,6 +116,11 @@ properties:
       - host
       - otg
 
+  wakeup-source:
+    $ref: /schemas/types.yaml#/definitions/flag
+    description:
+      Indicate this device has wakeup capabilities.
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/usb/st,typec-stm32g0.yaml b/Documentation/devicetree/bindings/usb/st,typec-stm32g0.yaml
new file mode 100644
index 000000000..b2729bd01
--- /dev/null
+++ b/Documentation/devicetree/bindings/usb/st,typec-stm32g0.yaml
@@ -0,0 +1,83 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/usb/st,typec-stm32g0.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: STMicroelectronics STM32G0 Type-C controller bindings
+
+description: |
+  The STM32G0 MCU can be programmed to control Type-C connector(s) through I2C
+  typically using the UCSI protocol over I2C, with a dedicated alert
+  (interrupt) pin.
+
+maintainers:
+  - Fabrice Gasnier <fabrice.gasnier@foss.st.com>
+
+properties:
+  compatible:
+    const: st,stm32g0-typec
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  connector:
+    type: object
+    allOf:
+      - $ref: ../connector/usb-connector.yaml#
+
+  firmware-name:
+    description: |
+      Should contain the name of the default firmware image
+      file located on the firmware search path
+
+  wakeup-source: true
+  power-domains: true
+
+required:
+  - compatible
+  - reg
+  - interrupts
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/irq.h>
+    i2c5 {
+      #address-cells = <1>;
+      #size-cells = <0>;
+
+      stm32g0@53 {
+        compatible = "st,stm32g0-typec";
+        reg = <0x53>;
+        /* Alert pin on GPIO PE12 */
+        interrupts = <12 IRQ_TYPE_EDGE_FALLING>;
+        interrupt-parent = <&gpioe>;
+
+        /* Example with one type-C connector */
+        connector {
+          compatible = "usb-c-connector";
+          label = "USB-C";
+
+          port {
+            con_usb_c_ep: endpoint {
+              remote-endpoint = <&usbotg_hs_ep>;
+            };
+          };
+        };
+      };
+    };
+
+    usbotg_hs {
+      usb-role-switch;
+      port {
+        usbotg_hs_ep: endpoint {
+          remote-endpoint = <&con_usb_c_ep>;
+        };
+      };
+    };
+...
diff --git a/Documentation/devicetree/bindings/usb/stm32,dwc3.yaml b/Documentation/devicetree/bindings/usb/stm32,dwc3.yaml
new file mode 100644
index 000000000..25be390b7
--- /dev/null
+++ b/Documentation/devicetree/bindings/usb/stm32,dwc3.yaml
@@ -0,0 +1,81 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/usb/stm32,dwc3.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STMicroelectronics STM32 MPU DWC3 USB SoC controller
+
+description:
+  The STM32 MPU DWC3 USB SoC controller block supports both Host(SS/HS/FS/LS)
+  or Device(SS/HS/FS) mode operation
+
+maintainers:
+  - Fabrice Gasnier <fabrice.gasnier@foss.st.com>
+
+properties:
+  compatible:
+    const: st,stm32mp25-dwc3
+
+  "#address-cells":
+    const: 1
+
+  "#size-cells":
+    const: 1
+
+  ranges: true
+
+  st,syscfg:
+    $ref: /schemas/types.yaml#/definitions/phandle-array #(arm/stm32/st,stm32-syscon.yaml#)
+    description: <Phandle to the STM32-MPU System Controller DT node> <offset-for-usr3drcr-reg>
+
+  st,vbusen-active-low:
+    type: boolean
+    description: VBUS-ENABLE signal polarity is active-low
+
+  st,ovrcur-active-low:
+    type: boolean
+    description: Over-Current signal polarity is active-low
+
+# Required child node:
+
+patternProperties:
+  "^usb@[0-9a-f]+$":
+    $ref: snps,dwc3.yaml#
+
+required:
+  - compatible
+  - "#address-cells"
+  - "#size-cells"
+  - ranges
+  - st,syscfg
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/stm32mp2-clks.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/reset/stm32mp2-resets.h>
+
+    usb3drd: usb@48300000 {
+        compatible      = "st,stm32mp25-dwc3";
+        st,syscfg       = <&syscfg 0x4800>;
+        #address-cells  = <1>;
+        #size-cells     = <1>;
+        ranges = <0x48300000 0x48300000 0x100000>;
+        st,ovrcur-active-low;
+        st,vbusen-active-low;
+
+        dwc3: usb@48300000 {
+            compatible      = "snps,dwc3";
+            reg             = <0x48300000 0x100000>;
+            interrupts      = <GIC_SPI 228 IRQ_TYPE_LEVEL_HIGH>;
+            clock-names     = "ref", "bus_early", "suspend";
+            clocks          = <&rcc CK_KER_USB2PHY2>, <&rcc CK_BUS_USB3DRD>,
+                              <&rcc CK_KER_USB2PHY2>;
+            resets          = <&rcc USB3DRD_R>;
+            phys            = <&usb2_phy>, <&usb3_phy>;
+            phy-names       = "usb2-phy", "usb3-phy";
+        };
+    };
diff --git a/Documentation/devicetree/bindings/usb/stm32,usb2h.yaml b/Documentation/devicetree/bindings/usb/stm32,usb2h.yaml
new file mode 100644
index 000000000..c6d82d011
--- /dev/null
+++ b/Documentation/devicetree/bindings/usb/stm32,usb2h.yaml
@@ -0,0 +1,91 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/usb/stm32,usb2h.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STMicroelectronics STM32 MPU USB2 Host SoC controller
+
+maintainers:
+  - Pankaj Dev <pankaj.dev@st.com>
+
+properties:
+  compatible:
+    const: st,stm32mp25-usb2h
+
+  "#address-cells":
+    const: 1
+
+  "#size-cells":
+    const: 1
+
+  ranges: true
+
+  st,syscfg:
+    $ref: /schemas/types.yaml#/definitions/phandle-array #(arm/stm32/st,stm32-syscon.yaml#)
+    description: Phandle to the STM32-MPU System Controller DT node
+                 <syscon-handle usb2hcr-offset>
+
+  st,vbusen-active-low:
+    type: boolean
+    description: VBUS-ENABLE signal polarity is active-low
+
+  st,ovrcur-active-low:
+    type: boolean
+    description: Over-Current signal polarity is active-low
+
+# Required child node:
+
+patternProperties:
+  "^usb@[0-9a-f]+$":
+    oneOf:
+      - $ref: generic-ohci.yaml#
+      - $ref: generic-ehci.yaml#
+
+required:
+  - compatible
+  - "#address-cells"
+  - "#size-cells"
+  - ranges
+  - st,syscfg
+
+additionalProperties: false
+
+examples:
+  - |
+
+    #include <dt-bindings/clock/stm32mp2-clks.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/reset/stm32mp2-resets.h>
+
+
+    usb2h: usb@482e0000 {
+        compatible      = "st,stm32mp25-usb2h";
+        st,syscfg       = <&syscfg 0x2420>;
+        #address-cells  = <1>;
+        #size-cells     = <1>;
+        ranges = <0x482e0000 0x482e0000 0x2000>;
+        st,ovrcur-active-low;
+        st,vbusen-active-low;
+
+        usbh_ohci: usb@482e0000 {
+            compatible = "generic-ohci";
+            reg = <0x482e0000 0x1000>;
+            clocks = <&rcc CK_BUS_USB2OHCI>;
+            resets = <&rcc USB2_R>;
+            interrupts = <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>;
+            phys = <&usb2_phy1>;
+            phy-names = "usb";
+        };
+
+        usbh_ehci: usb@482f0000 {
+            compatible = "generic-ehci";
+            reg = <0x482f0000 0x1000>;
+            clocks = <&rcc CK_BUS_USB2EHCI>;
+            resets = <&rcc USB2_R>;
+            interrupts = <GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>;
+            companion = <&usbh_ohci>;
+            phys = <&usb2_phy1>;
+            phy-names = "usb";
+        };
+    };
diff --git a/Documentation/devicetree/bindings/vendor-prefixes.yaml b/Documentation/devicetree/bindings/vendor-prefixes.yaml
index a867f7102..add9eac92 100644
--- a/Documentation/devicetree/bindings/vendor-prefixes.yaml
+++ b/Documentation/devicetree/bindings/vendor-prefixes.yaml
@@ -427,6 +427,8 @@ patternProperties:
     description: Freescale Semiconductor
   "^fujitsu,.*":
     description: Fujitsu Ltd.
+  "^galaxycore,.*":
+    description: Galaxy Core Inc.
   "^gardena,.*":
     description: GARDENA GmbH
   "^gateworks,.*":
@@ -1204,6 +1206,8 @@ patternProperties:
     description: TPO
   "^tq,.*":
     description: TQ-Systems GmbH
+  "^ttt,.*":
+    description: TTTech
   "^traverse,.*":
     description: Traverse Technologies Australia Pty Ltd
   "^tronfy,.*":
diff --git a/Documentation/locking/hwspinlock.rst b/Documentation/locking/hwspinlock.rst
index 6f03713b7..605bd2dc8 100644
--- a/Documentation/locking/hwspinlock.rst
+++ b/Documentation/locking/hwspinlock.rst
@@ -54,9 +54,11 @@ Should be called from a process context (might sleep).
   struct hwspinlock *hwspin_lock_request_specific(unsigned int id);
 
 Assign a specific hwspinlock id and return its address, or NULL
-if that hwspinlock is already in use. Usually board code will
-be calling this function in order to reserve specific hwspinlock
-ids for predefined purposes.
+if that hwspinlock is already in use and not shared. If that specific
+hwspinlock is declared as shared, it can be requested and used by
+several users.
+Usually board code will be calling this function in order to reserve
+specific hwspinlock ids for predefined purposes.
 
 Should be called from a process context (might sleep).
 
@@ -449,11 +451,13 @@ of which represents a single hardware lock::
 	* struct hwspinlock - this struct represents a single hwspinlock instance
 	* @bank: the hwspinlock_device structure which owns this lock
 	* @lock: initialized and used by hwspinlock core
+	* @refcount: number of users (when shared)
 	* @priv: private data, owned by the underlying platform-specific hwspinlock drv
 	*/
 	struct hwspinlock {
 		struct hwspinlock_device *bank;
 		spinlock_t lock;
+		unsigned int refcount;
 		void *priv;
 	};
 
diff --git a/Documentation/staging/remoteproc.rst b/Documentation/staging/remoteproc.rst
index 9cccd3dd6..c2367e3c0 100644
--- a/Documentation/staging/remoteproc.rst
+++ b/Documentation/staging/remoteproc.rst
@@ -357,3 +357,25 @@ Of course, RSC_VDEV resource entries are only good enough for static
 allocation of virtio devices. Dynamic allocations will also be made possible
 using the rpmsg bus (similar to how we already do dynamic allocations of
 rpmsg channels; read more about it in rpmsg.txt).
+
+8. System Resource Manager (SRM)
+
+Since some resources are shared (directly or not) between the processors, a
+processor cannot manage such resources without potentially impacting the other
+processors : as an example, if a processor changes the frequency of a clock, the
+frequency of another clock managed by another processor may be updated too.
+
+The System Resource Manager prevents such resource conflicts between the
+processors : it reserves and initializes the system resources of the peripherals
+assigned to a remote processor.
+
+As of today the following resources are controlled by the SRM:
+- clocks
+- regulators (power supplies)
+
+The SRM is implemented as an 'rproc_subdev' and registered to remoteproc_core.
+Unlike the virtio device (vdev), the SRM subdev is probed *before* the rproc
+boots, ensuring the availability of the resources before the remoteproc starts.
+
+The resources handled by the SRM are defined in the DeviceTree: please read
+Documentation/devicetree/bindings/remoteproc/rproc-srm.txt for details.
diff --git a/Documentation/staging/tee.rst b/Documentation/staging/tee.rst
index 4d4b5f889..3c63d8dcd 100644
--- a/Documentation/staging/tee.rst
+++ b/Documentation/staging/tee.rst
@@ -184,6 +184,36 @@ order to support device enumeration. In other words, OP-TEE driver invokes this
 application to retrieve a list of Trusted Applications which can be registered
 as devices on the TEE bus.
 
+OP-TEE notifications
+--------------------
+
+There are two kinds of notifications that secure world can use to make
+normal world aware of some event.
+
+1. Synchronous notifications delivered with ``OPTEE_RPC_CMD_NOTIFICATION``
+   using the ``OPTEE_RPC_NOTIFICATION_SEND`` parameter.
+2. Asynchronous notifications delivered with a combination of a non-secure
+   edge-triggered interrupt and a fast call from the non-secure interrupt
+   handler.
+
+Synchronous notifications are limited by depending on RPC for delivery,
+this is only usable when secure world is entered with a yielding call via
+``OPTEE_SMC_CALL_WITH_ARG``. This excludes such notifications from secure
+world interrupt handlers.
+
+An asynchronous notification is delivered via a non-secure edge-triggered
+interrupt to an interrupt handler registered in the OP-TEE driver. The
+actual notification value are retrieved with the fast call
+``OPTEE_SMC_GET_ASYNC_NOTIF_VALUE``. Note that one interrupt can represent
+multiple notifications.
+
+One notification value ``OPTEE_SMC_ASYNC_NOTIF_VALUE_DO_BOTTOM_HALF`` has a
+special meaning. When this value is received it means that normal world is
+supposed to make a yielding call ``OPTEE_MSG_CMD_DO_BOTTOM_HALF``. This
+call is done from the thread assisting the interrupt handler. This is a
+building block for OP-TEE OS in secure world to implement the top half and
+bottom half style of device drivers.
+
 AMD-TEE driver
 ==============
 
diff --git a/MAINTAINERS b/MAINTAINERS
index edc325758..bfe517423 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -7753,6 +7753,14 @@ F:	kernel/futex.c
 F:	tools/perf/bench/futex*
 F:	tools/testing/selftests/futex/
 
+GALAXYCORE GC2145 SENSOR DRIVER
+M:	Alain Volmat <alain.volmat@foss.st.com>
+L:	linux-media@vger.kernel.org
+S:	Maintained
+T:	git git://linuxtv.org/media_tree.git
+F:	Documentation/devicetree/bindings/media/i2c/galaxycore,gc2145.yaml
+F:	drivers/media/i2c/gc2145.c
+
 GATEWORKS SYSTEM CONTROLLER (GSC) DRIVER
 M:	Tim Harvey <tharvey@gateworks.com>
 M:	Robert Jones <rjones@gateworks.com>
@@ -11724,6 +11732,14 @@ W:	https://linuxtv.org
 T:	git git://linuxtv.org/media_tree.git
 F:	drivers/media/dvb-frontends/stv6111*
 
+MEDIA DRIVERS FOR STM32 - CSI2HOST
+M:	Alain Volmat <alain.volmat@foss.st.com>
+L:	linux-media@vger.kernel.org
+S:	Supported
+T:	git git://linuxtv.org/media_tree.git
+F:	Documentation/devicetree/bindings/media/st,stm32-csi2host.yaml
+F:	drivers/media/platform/stm32/stm32-csi2host.c
+
 MEDIA DRIVERS FOR STM32 - DCMI
 M:	Hugues Fruchet <hugues.fruchet@foss.st.com>
 L:	linux-media@vger.kernel.org
@@ -11732,6 +11748,15 @@ T:	git git://linuxtv.org/media_tree.git
 F:	Documentation/devicetree/bindings/media/st,stm32-dcmi.yaml
 F:	drivers/media/platform/stm32/stm32-dcmi.c
 
+MEDIA DRIVERS FOR STM32 - DCMIPP
+M:	Hugues Fruchet <hugues.fruchet@foss.st.com>
+M:	Alain Volmat <alain.volmat@foss.st.com>
+L:	linux-media@vger.kernel.org
+S:	Supported
+T:	git git://linuxtv.org/media_tree.git
+F:	Documentation/devicetree/bindings/media/st,stm32-dcmipp.yaml
+F:	drivers/media/platform/stm32/stm32-dcmipp/*
+
 MEDIA INPUT INFRASTRUCTURE (V4L/DVB)
 M:	Mauro Carvalho Chehab <mchehab@kernel.org>
 L:	linux-media@vger.kernel.org
diff --git a/SECURITY.md b/SECURITY.md
new file mode 100644
index 000000000..4b3e4e6ba
--- /dev/null
+++ b/SECURITY.md
@@ -0,0 +1,8 @@
+# Report potential product security vulnerabilities
+ST places a high priority on security, and our Product Security Incident Response Team (PSIRT) is committed to rapidly addressing potential security vulnerabilities affecting our products. PSIRT's long history and vast experience in security allows ST to perform clear analyses and provide appropriate guidance on mitigations  and solutions when applicable.
+If you wish to report potential security vulnerabilities regarding our products, **please do not report them through public GitHub issues.** Instead, we encourage you to report them to our ST PSIRT following the process described at: **https://www.st.com/content/st_com/en/security/report-vulnerabilities.html**
+
+### IMPORTANT - READ CAREFULLY:
+STMicroelectronics International N.V., on behalf of itself, its affiliates and  subsidiaries, (collectively “ST”) takes all potential security vulnerability reports or other related communications (“Report(s)”)  seriously. In order to review Your Report (the terms “You” and “Yours”  include your employer, and all affiliates, subsidiaries and related  persons or entities) and take actions as deemed appropriate, ST requires that we have the rights and Your permission to do so.
+As such, by submitting Your Report to ST, You agree that You have the right to do so, and You grant to ST the rights to use the Report for purposes related to security vulnerability analysis, testing, correction, patching, reporting and any other related purpose or function.
+By submitting Your Report, You agree that ST’s [Privacy Policy](https://www.st.com/content/st_com/en/common/privacy-portal.html) applies to all related communications.
diff --git a/arch/arm/Kconfig.debug b/arch/arm/Kconfig.debug
index 644875d73..37b833761 100644
--- a/arch/arm/Kconfig.debug
+++ b/arch/arm/Kconfig.debug
@@ -1244,7 +1244,7 @@ choice
 
 	config STM32MP1_DEBUG_UART
 		bool "Use STM32MP1 UART for low-level debug"
-		depends on MACH_STM32MP157
+		depends on MACH_STM32MP157 || MACH_STM32MP13
 		select DEBUG_STM32_UART
 		help
 		  Say Y here if you want kernel low-level debugging support
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 7a72fc636..1f07bf84c 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -1,4 +1,42 @@
 # SPDX-License-Identifier: GPL-2.0
+
+# board-specific dtc flags
+DTC_FLAGS_stm32mp157c-dk2 += -@
+DTC_FLAGS_stm32f429-disco += -@
+DTC_FLAGS_stm32f469-disco += -@
+DTC_FLAGS_stm32f746-disco += -@
+DTC_FLAGS_stm32f769-disco += -@
+DTC_FLAGS_stm32429i-eval += -@
+DTC_FLAGS_stm32746g-eval += -@
+DTC_FLAGS_stm32h743i-eval += -@
+DTC_FLAGS_stm32h743i-disco += -@
+DTC_FLAGS_stm32mp135f-dk += -@
+DTC_FLAGS_stm32mp135f-dk-a7-examples +=-@
+DTC_FLAGS_stm32mp157a-dk1 += -@
+DTC_FLAGS_stm32mp157a-dk1-a7-examples += -@
+DTC_FLAGS_stm32mp157a-dk1-m4-examples += -@
+DTC_FLAGS_stm32mp157d-dk1 += -@
+DTC_FLAGS_stm32mp157d-dk1-a7-examples += -@
+DTC_FLAGS_stm32mp157d-dk1-m4-examples += -@
+DTC_FLAGS_stm32mp157c-dk2 += -@
+DTC_FLAGS_stm32mp157f-dk2 += -@
+DTC_FLAGS_stm32mp157c-dk2-a7-examples += -@
+DTC_FLAGS_stm32mp157c-dk2-m4-examples += -@
+DTC_FLAGS_stm32mp157f-dk2-a7-examples += -@
+DTC_FLAGS_stm32mp157f-dk2-m4-examples += -@
+DTC_FLAGS_stm32mp157a-ed1 += -@
+DTC_FLAGS_stm32mp157c-ed1 += -@
+DTC_FLAGS_stm32mp157d-ed1 += -@
+DTC_FLAGS_stm32mp157f-ed1 += -@
+DTC_FLAGS_stm32mp157a-ev1 += -@
+DTC_FLAGS_stm32mp157c-ev1 += -@
+DTC_FLAGS_stm32mp157d-ev1 += -@
+DTC_FLAGS_stm32mp157f-ev1 += -@
+DTC_FLAGS_stm32mp157c-ev1-a7-examples += -@
+DTC_FLAGS_stm32mp157c-ev1-m4-examples += -@
+DTC_FLAGS_stm32mp157f-ev1-a7-examples += -@
+DTC_FLAGS_stm32mp157f-ev1-m4-examples += -@
+
 dtb-$(CONFIG_ARCH_ALPINE) += \
 	alpine-db.dtb
 dtb-$(CONFIG_MACH_ARTPEC6) += \
@@ -1115,10 +1153,17 @@ dtb-$(CONFIG_ARCH_STM32) += \
 	stm32h743i-eval.dtb \
 	stm32h743i-disco.dtb \
 	stm32h750i-art-pi.dtb \
+	stm32mp135f-dk.dtb \
+	stm32mp135f-dk-a7-examples.dtb \
 	stm32mp153c-dhcom-drc02.dtb \
 	stm32mp157a-avenger96.dtb \
 	stm32mp157a-dhcor-avenger96.dtb \
 	stm32mp157a-dk1.dtb \
+	stm32mp157a-dk1-a7-examples.dtb \
+	stm32mp157a-dk1-m4-examples.dtb \
+	stm32mp157d-dk1.dtb \
+	stm32mp157d-dk1-a7-examples.dtb \
+	stm32mp157d-dk1-m4-examples.dtb \
 	stm32mp157a-iot-box.dtb \
 	stm32mp157a-microgea-stm32mp1-microdev2.0.dtb \
 	stm32mp157a-microgea-stm32mp1-microdev2.0-of7.dtb \
@@ -1128,8 +1173,23 @@ dtb-$(CONFIG_ARCH_STM32) += \
 	stm32mp157c-dhcom-pdk2.dtb \
 	stm32mp157c-dhcom-picoitx.dtb \
 	stm32mp157c-dk2.dtb \
+	stm32mp157c-dk2-a7-examples.dtb \
+	stm32mp157c-dk2-m4-examples.dtb \
+	stm32mp157f-dk2.dtb \
+	stm32mp157f-dk2-a7-examples.dtb \
+	stm32mp157f-dk2-m4-examples.dtb \
+	stm32mp157a-ed1.dtb \
 	stm32mp157c-ed1.dtb \
+	stm32mp157d-ed1.dtb \
+	stm32mp157f-ed1.dtb \
+	stm32mp157a-ev1.dtb \
 	stm32mp157c-ev1.dtb \
+	stm32mp157c-ev1-a7-examples.dtb \
+	stm32mp157c-ev1-m4-examples.dtb \
+	stm32mp157d-ev1.dtb \
+	stm32mp157f-ev1.dtb \
+	stm32mp157f-ev1-a7-examples.dtb \
+	stm32mp157f-ev1-m4-examples.dtb \
 	stm32mp157c-lxa-mc1.dtb \
 	stm32mp157c-odyssey.dtb
 dtb-$(CONFIG_MACH_SUN4I) += \
diff --git a/arch/arm/boot/dts/stm32mp13-pinctrl.dtsi b/arch/arm/boot/dts/stm32mp13-pinctrl.dtsi
new file mode 100644
index 000000000..b8d53065a
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp13-pinctrl.dtsi
@@ -0,0 +1,644 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com>
+ */
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
+&pinctrl {
+	adc1_usb_cc_pins_a: adc1-usb-cc-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 12, ANALOG)>, /* ADC1 in6 */
+				 <STM32_PINMUX('A', 3, ANALOG)>; /* ADC1 in12 */
+		};
+	};
+
+	dcmipp_pins_a: dcmi-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H',  8,  AF13)>,/* DCMI_HSYNC */
+				 <STM32_PINMUX('G',  9,  AF13)>,/* DCMI_VSYNC */
+				 <STM32_PINMUX('B',  7,  AF14)>,/* DCMI_PIXCLK */
+				 <STM32_PINMUX('A',  9,  AF13)>,/* DCMI_D0 */
+				 <STM32_PINMUX('D',  0,  AF13)>,/* DCMI_D1 */
+				 <STM32_PINMUX('G', 10,  AF13)>,/* DCMI_D2 */
+				 <STM32_PINMUX('E',  4,  AF13)>,/* DCMI_D3 */
+				 <STM32_PINMUX('D', 11,  AF14)>,/* DCMI_D4 */
+				 <STM32_PINMUX('D',  3,  AF13)>,/* DCMI_D5 */
+				 <STM32_PINMUX('B',  8,  AF13)>,/* DCMI_D6 */
+				 <STM32_PINMUX('E', 14,  AF13)>;/* DCMI_D7 */
+			bias-disable;
+		};
+	};
+
+	dcmipp_sleep_pins_a: dcmi-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H',  8,  ANALOG)>,/* DCMI_HSYNC */
+				 <STM32_PINMUX('G',  9,  ANALOG)>,/* DCMI_VSYNC */
+				 <STM32_PINMUX('B',  7,  ANALOG)>,/* DCMI_PIXCLK */
+				 <STM32_PINMUX('A',  9,  ANALOG)>,/* DCMI_D0 */
+				 <STM32_PINMUX('D',  0,  ANALOG)>,/* DCMI_D1 */
+				 <STM32_PINMUX('G', 10,  ANALOG)>,/* DCMI_D2 */
+				 <STM32_PINMUX('E',  4,  ANALOG)>,/* DCMI_D3 */
+				 <STM32_PINMUX('D', 11,  ANALOG)>,/* DCMI_D4 */
+				 <STM32_PINMUX('D',  3,  ANALOG)>,/* DCMI_D5 */
+				 <STM32_PINMUX('B',  8,  ANALOG)>,/* DCMI_D6 */
+				 <STM32_PINMUX('E', 14,  ANALOG)>;/* DCMI_D7 */
+		};
+	};
+
+	dfsdm_clkout_pins_a: dfsdm-clkout-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, AF3)>; /* DFSDM_CKOUT */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	dfsdm_clkout_sleep_pins_a: dfsdm-clkout-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, ANALOG)>; /* DFSDM_CKOUT */
+		};
+	};
+
+	dfsdm_datin1_pins_a: dfsdm-datin1-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 1, AF6)>; /* DFSDM_DATIN1 */
+		};
+	};
+
+	dfsdm_datin1_sleep_pins_a: dfsdm-datin1-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 1, ANALOG)>; /* DFSDM_DATIN1 */
+		};
+	};
+
+	dfsdm_datin3_pins_a: dfsdm-datin3-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, AF6)>; /* DFSDM_DATIN3 */
+		};
+	};
+
+	dfsdm_datin3_sleep_pins_a: dfsdm-datin3-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, ANALOG)>; /* DFSDM_DATIN3 */
+		};
+	};
+
+	eth1_rmii_pins_a: eth1-rmii-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 13, AF11)>, /* ETH_RMII_TXD0 */
+				 <STM32_PINMUX('G', 14, AF11)>, /* ETH_RMII_TXD1 */
+				 <STM32_PINMUX('B', 11, AF11)>, /* ETH_RMII_TX_EN */
+				 <STM32_PINMUX('A', 1, AF11)>, /* ETH_RMII_REF_CLK */
+				 <STM32_PINMUX('A', 2, AF11)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 2, AF11)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 4, AF11)>, /* ETH_RMII_RXD0 */
+				 <STM32_PINMUX('C', 5, AF11)>, /* ETH_RMII_RXD1 */
+				 <STM32_PINMUX('C', 1, AF10)>; /* ETH_RMII_CRS_DV */
+			bias-disable;
+		};
+
+	};
+
+	eth1_rmii_sleep_pins_a: eth1-rmii-sleep-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 13, ANALOG)>, /* ETH_RMII_TXD0 */
+				 <STM32_PINMUX('G', 14, ANALOG)>, /* ETH_RMII_TXD1 */
+				 <STM32_PINMUX('B', 11, ANALOG)>, /* ETH_RMII_TX_EN */
+				 <STM32_PINMUX('A', 1, ANALOG)>, /* ETH_RMII_REF_CLK */
+				 <STM32_PINMUX('A', 2, ANALOG)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 2, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('C', 4, ANALOG)>, /* ETH_RMII_RXD0 */
+				 <STM32_PINMUX('C', 5, ANALOG)>, /* ETH_RMII_RXD1 */
+				 <STM32_PINMUX('C', 1, ANALOG)>; /* ETH_RMII_CRS_DV */
+		};
+	};
+
+	eth2_rmii_pins_a: eth2-rmii-2 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 7, AF11)>, /* ETH_RMII_TXD0 */
+				 <STM32_PINMUX('G', 11, AF10)>, /* ETH_RMII_TXD1 */
+				 <STM32_PINMUX('G', 8, AF13)>, /* ETH_RMII_ETHCK */
+				 <STM32_PINMUX('F', 6, AF11)>, /* ETH_RMII_TX_EN */
+				 <STM32_PINMUX('B', 2, AF11)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 5, AF10)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 4, AF11)>, /* ETH_RMII_RXD0 */
+				 <STM32_PINMUX('E', 2, AF10)>, /* ETH_RMII_RXD1 */
+				 <STM32_PINMUX('A', 12, AF11)>; /* ETH_RMII_CRS_DV */
+			bias-disable;
+		};
+	};
+
+	eth2_rmii_sleep_pins_a: eth2-rmii-sleep-2 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 7, ANALOG)>, /* ETH_RMII_TXD0 */
+				 <STM32_PINMUX('G', 11, ANALOG)>, /* ETH_RMII_TXD1 */
+				 <STM32_PINMUX('G', 8, ANALOG)>, /* ETH_RMII_ETHCK */
+				 <STM32_PINMUX('F', 6, ANALOG)>, /* ETH_RMII_TX_EN */
+				 <STM32_PINMUX('B', 2, ANALOG)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('F', 4, ANALOG)>, /* ETH_RMII_RXD0 */
+				 <STM32_PINMUX('E', 2, ANALOG)>, /* ETH_RMII_RXD1 */
+				 <STM32_PINMUX('A', 12, ANALOG)>; /* ETH_RMII_CRS_DV */
+		};
+	};
+
+	goodix_pins_a: goodix-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 5, GPIO)>;
+			bias-pull-down;
+		};
+	};
+
+	i2c1_pins_a: i2c1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 12, AF5)>, /* I2C1_SCL */
+				 <STM32_PINMUX('E', 8, AF5)>; /* I2C1_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c1_sleep_pins_a: i2c1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 12, ANALOG)>, /* I2C1_SCL */
+				 <STM32_PINMUX('E', 8, ANALOG)>; /* I2C1_SDA */
+		};
+	};
+
+	i2c5_pins_a: i2c5-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 1, AF4)>, /* I2C5_SCL */
+				 <STM32_PINMUX('H', 6, AF4)>; /* I2C5_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c5_sleep_pins_a: i2c5-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 1, ANALOG)>, /* I2C5_SCL */
+				 <STM32_PINMUX('H', 6, ANALOG)>; /* I2C5_SDA */
+		};
+	};
+
+	ltdc_pins_a: ltdc-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D',  9, AF13)>, /* LCD_CLK */
+				 <STM32_PINMUX('C',  6, AF14)>, /* LCD_HSYNC */
+				 <STM32_PINMUX('G',  4, AF11)>, /* LCD_VSYNC */
+				 <STM32_PINMUX('H',  9, AF11)>, /* LCD_DE */
+				 <STM32_PINMUX('G',  7, AF14)>, /* LCD_R2 */
+				 <STM32_PINMUX('B', 12, AF13)>, /* LCD_R3 */
+				 <STM32_PINMUX('D', 14, AF14)>, /* LCD_R4 */
+				 <STM32_PINMUX('E',  7, AF14)>, /* LCD_R5 */
+				 <STM32_PINMUX('E', 13, AF14)>, /* LCD_R6 */
+				 <STM32_PINMUX('E',  9, AF14)>, /* LCD_R7 */
+				 <STM32_PINMUX('H', 13, AF14)>, /* LCD_G2 */
+				 <STM32_PINMUX('F',  3, AF14)>, /* LCD_G3 */
+				 <STM32_PINMUX('D',  5, AF14)>, /* LCD_G4 */
+				 <STM32_PINMUX('G',  0, AF14)>, /* LCD_G5 */
+				 <STM32_PINMUX('C',  7, AF14)>, /* LCD_G6 */
+				 <STM32_PINMUX('A', 15, AF11)>, /* LCD_G7 */
+				 <STM32_PINMUX('D', 10, AF14)>, /* LCD_B2 */
+				 <STM32_PINMUX('F',  2, AF14)>, /* LCD_B3 */
+				 <STM32_PINMUX('H', 14, AF11)>, /* LCD_B4 */
+				 <STM32_PINMUX('E',  0, AF14)>, /* LCD_B5 */
+				 <STM32_PINMUX('B',  6, AF7)>,  /* LCD_B6 */
+				 <STM32_PINMUX('F',  1, AF13)>; /* LCD_B7 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	ltdc_sleep_pins_a: ltdc-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D',  9, ANALOG)>, /* LCD_CLK */
+				 <STM32_PINMUX('C',  6, ANALOG)>, /* LCD_HSYNC */
+				 <STM32_PINMUX('G',  4, ANALOG)>, /* LCD_VSYNC */
+				 <STM32_PINMUX('H',  9, ANALOG)>, /* LCD_DE */
+				 <STM32_PINMUX('G',  7, ANALOG)>, /* LCD_R2 */
+				 <STM32_PINMUX('B', 12, ANALOG)>, /* LCD_R3 */
+				 <STM32_PINMUX('D', 14, ANALOG)>, /* LCD_R4 */
+				 <STM32_PINMUX('E',  7, ANALOG)>, /* LCD_R5 */
+				 <STM32_PINMUX('E', 13, ANALOG)>, /* LCD_R6 */
+				 <STM32_PINMUX('E',  9, ANALOG)>, /* LCD_R7 */
+				 <STM32_PINMUX('H', 13, ANALOG)>, /* LCD_G2 */
+				 <STM32_PINMUX('F',  3, ANALOG)>, /* LCD_G3 */
+				 <STM32_PINMUX('D',  5, ANALOG)>, /* LCD_G4 */
+				 <STM32_PINMUX('G',  0, ANALOG)>, /* LCD_G5 */
+				 <STM32_PINMUX('C',  7, ANALOG)>, /* LCD_G6 */
+				 <STM32_PINMUX('A', 15, ANALOG)>, /* LCD_G7 */
+				 <STM32_PINMUX('D', 10, ANALOG)>, /* LCD_B2 */
+				 <STM32_PINMUX('F',  2, ANALOG)>, /* LCD_B3 */
+				 <STM32_PINMUX('H', 14, ANALOG)>, /* LCD_B4 */
+				 <STM32_PINMUX('E',  0, ANALOG)>, /* LCD_B5 */
+				 <STM32_PINMUX('B',  6, ANALOG)>, /* LCD_B6 */
+				 <STM32_PINMUX('F',  1, ANALOG)>; /* LCD_B7 */
+		};
+	};
+
+	mcp23017_pins_a: mcp23017-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 12, GPIO)>;
+			bias-pull-up;
+		};
+	};
+
+	m_can2_pins_a: m-can2-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 1, AF9)>; /* CAN2_TX */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 3, AF9)>; /* CAN2_RX */
+			bias-disable;
+		};
+	};
+
+	m_can2_sleep_pins_a: m_can2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 1, ANALOG)>, /* CAN2_TX */
+				 <STM32_PINMUX('G', 3, ANALOG)>; /* CAN2_RX */
+		};
+	};
+
+	pwm3_pins_a: pwm3-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 1, AF2)>; /* TIM3_CH4 */
+			bias-pull-down;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	pwm3_sleep_pins_a: pwm3-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 1, ANALOG)>; /* TIM3_CH4 */
+		};
+	};
+
+	pwm4_pins_a: pwm4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 13, AF2)>; /* TIM4_CH2 */
+			bias-pull-down;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	pwm4_sleep_pins_a: pwm4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 13, ANALOG)>; /* TIM4_CH2 */
+		};
+	};
+
+	pwm8_pins_a: pwm8-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 5, AF3)>; /* TIM8_CH3 */
+			bias-pull-down;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	pwm8_sleep_pins_a: pwm8-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 5, ANALOG)>; /* TIM8_CH3 */
+		};
+	};
+
+	pwm14_pins_a: pwm12-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 9, AF9)>; /* TIM14_CH1 */
+			bias-pull-down;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	pwm14_sleep_pins_a: pwm12-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 9, ANALOG)>; /* TIM14_CH1 */
+		};
+	};
+
+	rtc_out2_rmp_pins_a: rtc-out2-rmp-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 1, ANALOG)>; /* RTC_OUT2_RMP */
+		};
+	};
+
+	sai1_pins_a: sai1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, AF12)>, /* SAI1_SCK_A */
+				 <STM32_PINMUX('A', 0, AF6)>, /* SAI1_SD_B */
+				 <STM32_PINMUX('A', 5, AF6)>, /* SAI1_SD_A */
+				 <STM32_PINMUX('F', 11, AF6)>; /* SAI1_FS_A */
+			slew-rate = <0>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	sai1_sleep_pins_a: sai1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, ANALOG)>, /* SAI1_SCK_A */
+				 <STM32_PINMUX('A', 0, ANALOG)>, /* SAI1_SD_B */
+				 <STM32_PINMUX('A', 5, ANALOG)>, /* SAI1_SD_A */
+				 <STM32_PINMUX('F', 11, ANALOG)>; /* SAI1_FS_A */
+		};
+	};
+
+	sdmmc1_b4_pins_a: sdmmc1-b4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('C', 11, AF12)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('D', 2, AF12)>; /* SDMMC1_CMD */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	sdmmc1_b4_od_pins_a: sdmmc1-b4-od-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('C', 11, AF12)>; /* SDMMC1_D3 */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 2, AF12)>; /* SDMMC1_CMD */
+			slew-rate = <1>;
+			drive-open-drain;
+			bias-disable;
+		};
+	};
+
+	sdmmc1_b4_sleep_pins_a: sdmmc1-b4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 8, ANALOG)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('C', 9, ANALOG)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('C', 10, ANALOG)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('C', 11, ANALOG)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('C', 12, ANALOG)>, /* SDMMC1_CK */
+				 <STM32_PINMUX('D', 2, ANALOG)>; /* SDMMC1_CMD */
+		};
+	};
+
+	sdmmc1_clk_pins_a: sdmmc1-clk-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 12, AF12)>; /* SDMMC1_CK */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	sdmmc2_b4_pins_a: sdmmc2-b4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 14, AF10)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('B', 15, AF10)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('B', 3, AF10)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('B', 4, AF10)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('G', 6, AF10)>; /* SDMMC2_CMD */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_b4_od_pins_a: sdmmc2-b4-od-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 14, AF10)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('B', 15, AF10)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('B', 3, AF10)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('B', 4, AF10)>; /* SDMMC2_D3 */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 6, AF10)>; /* SDMMC2_CMD */
+			slew-rate = <1>;
+			drive-open-drain;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_b4_sleep_pins_a: sdmmc2-b4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 14, ANALOG)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('B', 15, ANALOG)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('B', 3, ANALOG)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('B', 4, ANALOG)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('E', 3, ANALOG)>, /* SDMMC2_CK */
+				 <STM32_PINMUX('G', 6, ANALOG)>; /* SDMMC2_CMD */
+		};
+	};
+
+	sdmmc2_clk_pins_a: sdmmc2-clk-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC2_CK */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	spi5_pins_a: spi5-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H', 7, AF6)>, /* SPI5_SCK */
+				 <STM32_PINMUX('H', 3, AF5)>; /* SPI5_MOSI */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 8, AF5)>; /* SPI5_MISO */
+			bias-disable;
+		};
+	};
+
+	spi5_sleep_pins_a: spi5-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 7, ANALOG)>, /* SPI5_SCK */
+				 <STM32_PINMUX('A', 8, ANALOG)>, /* SPI5_MISO */
+				 <STM32_PINMUX('H', 3, ANALOG)>; /* SPI5_MOSI */
+		};
+	};
+
+	stm32g0_intn_pins_a: stm32g0-intn-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 2, GPIO)>;
+			bias-pull-up;
+		};
+	};
+
+	uart4_pins_a: uart4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 6, AF8)>; /* UART4_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 8, AF8)>; /* UART4_RX */
+			bias-disable;
+		};
+	};
+
+	uart4_idle_pins_a: uart4-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 6, ANALOG)>; /* UART4_TX */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 8, AF8)>; /* UART4_RX */
+			bias-disable;
+		};
+	};
+
+	uart4_sleep_pins_a: uart4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 6, ANALOG)>, /* UART4_TX */
+				 <STM32_PINMUX('D', 8, ANALOG)>; /* UART4_RX */
+		};
+	};
+
+	uart8_pins_a: uart8-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 1, AF8)>; /* UART8_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 9, AF8)>; /* UART8_RX */
+			bias-pull-up;
+		};
+	};
+
+	uart8_idle_pins_a: uart8-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 1, ANALOG)>; /* UART8_TX */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 9, AF8)>; /* UART8_RX */
+			bias-pull-up;
+		};
+	};
+
+	uart8_sleep_pins_a: uart8-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 1, ANALOG)>, /* UART8_TX */
+				 <STM32_PINMUX('F', 9, ANALOG)>; /* UART8_RX */
+		};
+	};
+
+	usart1_pins_a: usart1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 0, AF7)>, /* USART1_TX */
+				 <STM32_PINMUX('C', 2, AF7)>; /* USART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 0, AF4)>, /* USART1_RX */
+				 <STM32_PINMUX('A', 7, AF7)>; /* USART1_CTS_NSS */
+			bias-pull-up;
+		};
+	};
+
+	usart1_idle_pins_a: usart1-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 0, ANALOG)>, /* USART1_TX */
+				 <STM32_PINMUX('A', 7, ANALOG)>; /* USART1_CTS_NSS */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 2, AF7)>; /* USART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('B', 0, AF4)>; /* USART1_RX */
+			bias-pull-up;
+		};
+	};
+
+	usart1_sleep_pins_a: usart1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 0, ANALOG)>, /* USART1_TX */
+				 <STM32_PINMUX('C', 2, ANALOG)>, /* USART1_RTS */
+				 <STM32_PINMUX('A', 7, ANALOG)>, /* USART1_CTS_NSS */
+				 <STM32_PINMUX('B', 0, ANALOG)>; /* USART1_RX */
+		};
+	};
+
+	usart2_pins_a: usart2-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H', 12, AF1)>, /* USART2_TX */
+				 <STM32_PINMUX('D', 4, AF3)>; /* USART2_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 15, AF1)>, /* USART2_RX */
+				 <STM32_PINMUX('E', 11, AF2)>; /* USART2_CTS_NSS */
+			bias-disable;
+		};
+	};
+
+	usart2_idle_pins_a: usart2-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H', 12, ANALOG)>, /* USART2_TX */
+				 <STM32_PINMUX('E', 11, ANALOG)>; /* USART2_CTS_NSS */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 4, AF3)>; /* USART2_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('D', 15, AF1)>; /* USART2_RX */
+			bias-disable;
+		};
+	};
+
+	usart2_sleep_pins_a: usart2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 12, ANALOG)>, /* USART2_TX */
+				 <STM32_PINMUX('D', 4, ANALOG)>, /* USART2_RTS */
+				 <STM32_PINMUX('D', 15, ANALOG)>, /* USART2_RX */
+				 <STM32_PINMUX('E', 11, ANALOG)>; /* USART2_CTS_NSS */
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp131.dtsi b/arch/arm/boot/dts/stm32mp131.dtsi
new file mode 100644
index 000000000..8121ddc97
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp131.dtsi
@@ -0,0 +1,1742 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/clock/stm32mp13-clks.h>
+#include <dt-bindings/reset/stm32mp13-resets.h>
+#include <dt-bindings/thermal/thermal.h>
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,cortex-a7";
+			device_type = "cpu";
+			reg = <0>;
+			clocks = <&scmi_perf 0>;
+			clock-names = "cpu";
+			nvmem-cells = <&part_number_otp>;
+			nvmem-cell-names = "part_number";
+			#cooling-cells = <2>;
+		};
+	};
+
+	arm-pmu {
+		compatible = "arm,cortex-a7-pmu";
+		interrupts = <GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&cpu0>;
+		interrupt-parent = <&intc>;
+	};
+
+	scmi_sram: sram@2ffff000 {
+		compatible = "mmio-sram";
+		reg = <0x2ffff000 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0 0x2ffff000 0x1000>;
+
+		scmi_shm: scmi_shm@0 {
+			compatible = "arm,scmi-shmem";
+			reg = <0 0x80>;
+		};
+	};
+
+	firmware {
+		optee: optee {
+			method = "smc";
+			compatible = "linaro,optee-tz";
+			interrupt-parent = <&intc>;
+			interrupts = <GIC_PPI 15 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+		};
+
+		scmi: scmi {
+			compatible = "linaro,scmi-optee";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			linaro,optee-channel-id = <0>;
+			shmem = <&scmi_shm>;
+
+			scmi_perf: protocol@13 {
+				reg = <0x13>;
+				#clock-cells = <1>;
+			};
+
+			scmi_clk: protocol@14 {
+				reg = <0x14>;
+				#clock-cells = <1>;
+			};
+
+			scmi_reset: protocol@16 {
+				reg = <0x16>;
+				#reset-cells = <1>;
+			};
+
+			scmi_voltd: protocol@17 {
+				reg = <0x17>;
+
+				scmi_regu: regulators {
+					scmi_reg11: voltd-reg11 {
+						voltd-name = "reg11";
+						regulator-name = "reg11";
+					};
+					scmi_reg18: voltd-reg18 {
+						voltd-name = "reg18";
+						regulator-name = "reg18";
+					};
+					scmi_usb33: voltd-usb33 {
+						voltd-name = "usb33";
+						regulator-name = "usb33";
+					};
+				};
+			};
+		};
+	};
+
+	intc: interrupt-controller@a0021000 {
+		compatible = "arm,cortex-a7-gic";
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		reg = <0xa0021000 0x1000>,
+		      <0xa0022000 0x2000>;
+	};
+
+	psci {
+		compatible = "arm,psci-1.0";
+		method = "smc";
+	};
+
+	timer {
+		compatible = "arm,armv7-timer";
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+		interrupt-parent = <&intc>;
+		always-on;
+	};
+
+	pm_domain {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "st,stm32mp157c-pd";
+
+		pd_core_ret: core-ret-power-domain@1 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <1>;
+			#power-domain-cells = <0>;
+			label = "CORE-RETENTION";
+
+			pd_core: core-power-domain@2 {
+				reg = <2>;
+				#power-domain-cells = <0>;
+				label = "CORE";
+			};
+		};
+	};
+
+	thermal-zones {
+		cpu_thermal: cpu-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&dts>;
+
+			trips {
+				cpu_alert: cpu-alert0 {
+					temperature = <95000>;
+					hysteresis = <10000>;
+					type = "passive";
+				};
+				cpu_crit: cpu-crit0 {
+					temperature = <120000>;
+					hysteresis = <0>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				map0 {
+					trip = <&cpu_alert>;
+					cooling-device = <&cpu0 1 1>;
+				};
+			};
+		};
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&intc>;
+		ranges;
+
+		sram: sram@30000000 {
+			compatible = "mmio-sram";
+			reg = <0x30000000 0x8000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 0x30000000 0x8000>;
+		};
+
+		timers2: timer@40000000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x40000000 0x400>;
+			clocks = <&rcc TIM2_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 18 0x400 0x80000001>,
+			       <&dmamux1 19 0x400 0x80000001>,
+			       <&dmamux1 20 0x400 0x80000001>,
+			       <&dmamux1 21 0x400 0x80000001>,
+			       <&dmamux1 22 0x400 0x80000001>;
+			dma-names = "ch1", "ch2", "ch3", "ch4", "up";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@1 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <1>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+		};
+
+		timers3: timer@40001000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x40001000 0x400>;
+			clocks = <&rcc TIM3_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 23 0x400 0x80000001>,
+			       <&dmamux1 24 0x400 0x80000001>,
+			       <&dmamux1 25 0x400 0x80000001>,
+			       <&dmamux1 26 0x400 0x80000001>,
+			       <&dmamux1 27 0x400 0x80000001>,
+			       <&dmamux1 28 0x400 0x80000001>;
+			dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@2 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <2>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+		};
+
+		timers4: timer@40002000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x40002000 0x400>;
+			clocks = <&rcc TIM4_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 29 0x400 0x80000001>,
+			       <&dmamux1 30 0x400 0x80000001>,
+			       <&dmamux1 31 0x400 0x80000001>,
+			       <&dmamux1 32 0x400 0x80000001>;
+			dma-names = "ch1", "ch2", "ch3", "up";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@3 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <3>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+		};
+
+		timers5: timer@40003000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x40003000 0x400>;
+			clocks = <&rcc TIM5_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 55 0x400 0x80000001>,
+			       <&dmamux1 56 0x400 0x80000001>,
+			       <&dmamux1 57 0x400 0x80000001>,
+			       <&dmamux1 58 0x400 0x80000001>,
+			       <&dmamux1 59 0x400 0x80000001>,
+			       <&dmamux1 60 0x400 0x80000001>;
+			dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@4 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <4>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+		};
+
+		timers6: timer@40004000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x40004000 0x400>;
+			clocks = <&rcc TIM6_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 69 0x400 0x80000001>;
+			dma-names = "up";
+			status = "disabled";
+
+			timer@5 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <5>;
+				status = "disabled";
+			};
+		};
+
+		timers7: timer@40005000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x40005000 0x400>;
+			clocks = <&rcc TIM7_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 70 0x400 0x80000001>;
+			dma-names = "up";
+			status = "disabled";
+
+			timer@6 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <6>;
+				status = "disabled";
+			};
+		};
+
+		lptimer1: timer@40009000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-lptimer";
+			reg = <0x40009000 0x400>;
+			interrupts-extended = <&exti 47 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc LPTIM1_K>;
+			clock-names = "mux";
+			power-domains = <&pd_core_ret>;
+			wakeup-source;
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm-lp";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			trigger@0 {
+				compatible = "st,stm32-lptimer-trigger";
+				reg = <0>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-lptimer-counter";
+				status = "disabled";
+			};
+
+			timer {
+				compatible = "st,stm32-lptimer-timer";
+				status = "disabled";
+			};
+		};
+
+		i2s2: audio-controller@4000b000 {
+			compatible = "st,stm32h7-i2s";
+			#sound-dai-cells = <0>;
+			reg = <0x4000b000 0x400>;
+			interrupts = <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmamux1 39 0x400 0x01>,
+			       <&dmamux1 40 0x400 0x01>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		spi2: spi@4000b000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32h7-spi";
+			reg = <0x4000b000 0x400>;
+			interrupts = <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc SPI2_K>;
+			resets = <&rcc SPI2_R>;
+			dmas = <&dmamux1 39 0x400 0x01>,
+			       <&dmamux1 40 0x400 0x01>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s3: audio-controller@4000c000 {
+			compatible = "st,stm32h7-i2s";
+			#sound-dai-cells = <0>;
+			reg = <0x4000c000 0x400>;
+			interrupts = <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmamux1 61 0x400 0x01>,
+			       <&dmamux1 62 0x400 0x01>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		spi3: spi@4000c000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32h7-spi";
+			reg = <0x4000c000 0x400>;
+			interrupts = <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc SPI3_K>;
+			resets = <&rcc SPI3_R>;
+			dmas = <&dmamux1 61 0x400 0x01>,
+			       <&dmamux1 62 0x400 0x01>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		spdifrx: audio-controller@4000d000 {
+			compatible = "st,stm32h7-spdifrx";
+			#sound-dai-cells = <0>;
+			reg = <0x4000d000 0x400>;
+			clocks = <&rcc SPDIF_K>;
+			clock-names = "kclk";
+			interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmamux1 93 0x400 0x01>,
+			       <&dmamux1 94 0x400 0x01>;
+			dma-names = "rx", "rx-ctrl";
+			status = "disabled";
+		};
+
+		usart3: serial@4000f000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x4000f000 0x400>;
+			interrupts-extended = <&exti 28 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc USART3_K>;
+			resets = <&rcc USART3_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 45 0x400 0x5>,
+			       <&dmamux1 46 0x400 0x1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		uart4: serial@40010000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40010000 0x400>;
+			interrupts-extended = <&exti 30 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc UART4_K>;
+			resets = <&rcc UART4_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 63 0x400 0x5>,
+			       <&dmamux1 64 0x400 0x1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		uart5: serial@40011000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40011000 0x400>;
+			interrupts-extended = <&exti 31 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc UART5_K>;
+			resets = <&rcc UART5_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 65 0x400 0x5>,
+			       <&dmamux1 66 0x400 0x1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2c1: i2c@40012000 {
+			compatible = "st,stm32mp13-i2c";
+			reg = <0x40012000 0x400>;
+			interrupt-names = "event", "error";
+			interrupts-extended = <&exti 21 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc I2C1_K>;
+			resets = <&rcc I2C1_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dmas = <&dmamux1 33 0x400 0x80000001>,
+			       <&dmamux1 34 0x400 0x80000001>;
+			dma-names = "rx", "tx";
+			st,syscfg-fmp = <&syscfg 0x4 0x1>;
+			i2c-analog-filter;
+			power-domains = <&pd_core_ret>;
+			wakeup-source;
+			status = "disabled";
+		};
+
+		i2c2: i2c@40013000 {
+			compatible = "st,stm32mp13-i2c";
+			reg = <0x40013000 0x400>;
+			interrupt-names = "event", "error";
+			interrupts-extended = <&exti 22 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc I2C2_K>;
+			resets = <&rcc I2C2_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dmas = <&dmamux1 35 0x400 0x80000001>,
+			       <&dmamux1 36 0x400 0x80000001>;
+			dma-names = "rx", "tx";
+			st,syscfg-fmp = <&syscfg 0x4 0x2>;
+			i2c-analog-filter;
+			power-domains = <&pd_core_ret>;
+			wakeup-source;
+			status = "disabled";
+		};
+
+		uart7: serial@40018000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40018000 0x400>;
+			interrupts-extended = <&exti 32 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc UART7_K>;
+			resets = <&rcc UART7_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 79 0x400 0x5>,
+			       <&dmamux1 80 0x400 0x1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		uart8: serial@40019000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40019000 0x400>;
+			interrupts-extended = <&exti 33 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc UART8_K>;
+			resets = <&rcc UART8_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 81 0x400 0x5>,
+			       <&dmamux1 82 0x400 0x1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		timers1: timer@44000000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x44000000 0x400>;
+			clocks = <&rcc TIM1_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 11 0x400 0x80000001>,
+			       <&dmamux1 12 0x400 0x80000001>,
+			       <&dmamux1 13 0x400 0x80000001>,
+			       <&dmamux1 14 0x400 0x80000001>,
+			       <&dmamux1 15 0x400 0x80000001>,
+			       <&dmamux1 16 0x400 0x80000001>,
+			       <&dmamux1 17 0x400 0x80000001>;
+			dma-names = "ch1", "ch2", "ch3", "ch4",
+				    "up", "trig", "com";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@0 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <0>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+		};
+
+		timers8: timer@44001000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x44001000 0x400>;
+			clocks = <&rcc TIM8_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 47 0x400 0x80000001>,
+			       <&dmamux1 48 0x400 0x80000001>,
+			       <&dmamux1 49 0x400 0x80000001>,
+			       <&dmamux1 50 0x400 0x80000001>,
+			       <&dmamux1 51 0x400 0x80000001>,
+			       <&dmamux1 52 0x400 0x80000001>,
+			       <&dmamux1 53 0x400 0x80000001>;
+			dma-names = "ch1", "ch2", "ch3", "ch4",
+				    "up", "trig", "com";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@7 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <7>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+		};
+
+		usart6: serial@44003000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x44003000 0x400>;
+			interrupts-extended = <&exti 29 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc USART6_K>;
+			resets = <&rcc USART6_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 71 0x400 0x5>,
+			       <&dmamux1 72 0x400 0x1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s1: audio-controller@44004000 {
+			compatible = "st,stm32h7-i2s";
+			#sound-dai-cells = <0>;
+			reg = <0x44004000 0x400>;
+			interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmamux1 37 0x400 0x01>,
+			       <&dmamux1 38 0x400 0x01>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		spi1: spi@44004000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32h7-spi";
+			reg = <0x44004000 0x400>;
+			interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc SPI1_K>;
+			resets = <&rcc SPI1_R>;
+			dmas = <&dmamux1 37 0x400 0x01>,
+			       <&dmamux1 38 0x400 0x01>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		sai1: sai@4400a000 {
+			compatible = "st,stm32h7-sai";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 0x4400a000 0x400>;
+			reg = <0x4400a000 0x4>, <0x4400a3f0 0x10>;
+			interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&rcc SAI1_R>;
+			status = "disabled";
+
+			sai1a: audio-controller@4400a004 {
+				#sound-dai-cells = <0>;
+
+				compatible = "st,stm32-sai-sub-a";
+				reg = <0x4 0x20>;
+				clocks = <&rcc SAI1_K>;
+				clock-names = "sai_ck";
+				dmas = <&dmamux1 87 0x400 0x01>;
+				status = "disabled";
+			};
+
+			sai1b: audio-controller@4400a024 {
+				#sound-dai-cells = <0>;
+				compatible = "st,stm32-sai-sub-b";
+				reg = <0x24 0x20>;
+				clocks = <&rcc SAI1_K>;
+				clock-names = "sai_ck";
+				dmas = <&dmamux1 88 0x400 0x01>;
+				status = "disabled";
+			};
+		};
+
+		sai2: sai@4400b000 {
+			compatible = "st,stm32h7-sai";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 0x4400b000 0x400>;
+			reg = <0x4400b000 0x4>, <0x4400b3f0 0x10>;
+			interrupts = <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&rcc SAI2_R>;
+			status = "disabled";
+
+			sai2a: audio-controller@4400b004 {
+				#sound-dai-cells = <0>;
+				compatible = "st,stm32-sai-sub-a";
+				reg = <0x4 0x20>;
+				clocks = <&rcc SAI2_K>;
+				clock-names = "sai_ck";
+				dmas = <&dmamux1 89 0x400 0x01>;
+				status = "disabled";
+			};
+
+			sai2b: audio-controller@4400b024 {
+				#sound-dai-cells = <0>;
+				compatible = "st,stm32-sai-sub-b";
+				reg = <0x24 0x20>;
+				clocks = <&rcc SAI2_K>;
+				clock-names = "sai_ck";
+				dmas = <&dmamux1 90 0x400 0x01>;
+				status = "disabled";
+			};
+		};
+
+		dfsdm: dfsdm@4400d000 {
+			compatible = "st,stm32mp1-dfsdm";
+			reg = <0x4400d000 0x800>;
+			clocks = <&rcc DFSDM_K>;
+			clock-names = "dfsdm";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			dfsdm0: filter@0 {
+				compatible = "st,stm32-dfsdm-adc";
+				#io-channel-cells = <1>;
+				reg = <0>;
+				interrupts = <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 101 0x400 0x01>;
+				dma-names = "rx";
+				status = "disabled";
+			};
+
+			dfsdm1: filter@1 {
+				compatible = "st,stm32-dfsdm-adc";
+				#io-channel-cells = <1>;
+				reg = <1>;
+				interrupts = <GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 102 0x400 0x01>;
+				dma-names = "rx";
+				status = "disabled";
+			};
+		};
+
+		dma1: dma-controller@48000000 {
+			compatible = "st,stm32-dma";
+			reg = <0x48000000 0x400>;
+			interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc DMA1>;
+			resets = <&rcc DMA1_R>;
+			#dma-cells = <4>;
+			st,mem2mem;
+			dma-requests = <8>;
+			dmas = <&mdma 0 0x3 0x1200000a 0x48000008 0x00000020 1>,
+			       <&mdma 1 0x3 0x1200000a 0x48000008 0x00000800 1>,
+			       <&mdma 2 0x3 0x1200000a 0x48000008 0x00200000 1>,
+			       <&mdma 3 0x3 0x1200000a 0x48000008 0x08000000 1>,
+			       <&mdma 4 0x3 0x1200000a 0x4800000C 0x00000020 1>,
+			       <&mdma 5 0x3 0x1200000a 0x4800000C 0x00000800 1>,
+			       <&mdma 6 0x3 0x1200000a 0x4800000C 0x00200000 1>,
+			       <&mdma 7 0x3 0x1200000a 0x4800000C 0x08000000 1>;
+			dma-names = "ch0", "ch1", "ch2", "ch3", "ch4", "ch5", "ch6", "ch7";
+		};
+
+		dma2: dma-controller@48001000 {
+			compatible = "st,stm32-dma";
+			reg = <0x48001000 0x400>;
+			interrupts = <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc DMA2>;
+			resets = <&rcc DMA2_R>;
+			#dma-cells = <4>;
+			st,mem2mem;
+			dma-requests = <8>;
+			dmas = <&mdma 8 0x3 0x1200000a 0x48001008 0x00000020 1>,
+			       <&mdma 9 0x3 0x1200000a 0x48001008 0x00000800 1>,
+			       <&mdma 10 0x3 0x1200000a 0x48001008 0x00200000 1>,
+			       <&mdma 11 0x3 0x1200000a 0x48001008 0x08000000 1>,
+			       <&mdma 12 0x3 0x1200000a 0x4800100C 0x00000020 1>,
+			       <&mdma 13 0x3 0x1200000a 0x4800100C 0x00000800 1>,
+			       <&mdma 14 0x3 0x1200000a 0x4800100C 0x00200000 1>,
+			       <&mdma 15 0x3 0x1200000a 0x4800100C 0x08000000 1>;
+			dma-names = "ch0", "ch1", "ch2", "ch3", "ch4", "ch5", "ch6", "ch7";
+		};
+
+		dmamux1: dma-router@48002000 {
+			compatible = "st,stm32h7-dmamux";
+			reg = <0x48002000 0x40>;
+			clocks = <&rcc DMAMUX1>;
+			resets = <&rcc DMAMUX1_R>;
+			#dma-cells = <3>;
+			dma-masters = <&dma1 &dma2>;
+			dma-requests = <128>;
+			dma-channels = <16>;
+		};
+
+		adc_2: adc@48004000 {
+			reg = <0x48004000 0x400>;
+			compatible = "st,stm32mp13-adc-core";
+			interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc ADC2>, <&rcc ADC2_K>;
+			clock-names = "bus", "adc";
+			interrupt-controller;
+			#interrupt-cells = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			adc2: adc@0 {
+				compatible = "st,stm32mp13-adc";
+				#io-channel-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0x0>;
+				interrupt-parent = <&adc_2>;
+				interrupts = <0>;
+				dmas = <&dmamux1 10 0x400 0x80000001>;
+				dma-names = "rx";
+				nvmem-cells = <&vrefint>;
+				nvmem-cell-names = "vrefint";
+				status = "disabled";
+
+				channel@13 {
+					reg = <13>;
+					label = "vrefint";
+				};
+				channel@14 {
+					reg = <14>;
+					label = "vddcore";
+				};
+				channel@16 {
+					reg = <16>;
+					label = "vddcpu";
+				};
+				channel@17 {
+					reg = <17>;
+					label = "vddq_ddr";
+				};
+			};
+		};
+
+		usbotg_hs: usb-otg@49000000 {
+			compatible = "st,stm32mp15-hsotg", "snps,dwc2";
+			reg = <0x49000000 0x40000>;
+			clocks = <&rcc USBO_K>;
+			clock-names = "otg";
+			resets = <&rcc USBO_R>;
+			reset-names = "dwc2";
+			interrupts-extended = <&exti 44 IRQ_TYPE_LEVEL_HIGH>;
+			g-rx-fifo-size = <512>;
+			g-np-tx-fifo-size = <32>;
+			g-tx-fifo-size = <256 16 16 16 16 16 16 16>;
+			dr_mode = "otg";
+			otg-rev = <0x200>;
+			usb33d-supply = <&scmi_usb33>;
+			power-domains = <&pd_core>;
+			wakeup-source;
+			status = "disabled";
+		};
+
+		usart1: serial@4c000000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x4c000000 0x400>;
+			interrupts-extended = <&exti 26 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc USART1_K>;
+			resets = <&rcc USART1_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 41 0x400 0x5>,
+			       <&dmamux1 42 0x400 0x1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		usart2: serial@4c001000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x4c001000 0x400>;
+			interrupts-extended = <&exti 27 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc USART2_K>;
+			resets = <&rcc USART2_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 43 0x400 0x5>,
+			       <&dmamux1 44 0x400 0x1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s4: audio-controller@4c002000 {
+			compatible = "st,stm32h7-i2s";
+			#sound-dai-cells = <0>;
+			reg = <0x4c002000 0x400>;
+			interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmamux1 83 0x400 0x01>,
+			       <&dmamux1 84 0x400 0x01>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		spi4: spi@4c002000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32h7-spi";
+			reg = <0x4c002000 0x400>;
+			interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc SPI4_K>;
+			resets = <&rcc SPI4_R>;
+			dmas = <&dmamux1 83 0x400 0x01>,
+			       <&dmamux1 84 0x400 0x01>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		spi5: spi@4c003000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32h7-spi";
+			reg = <0x4c003000 0x400>;
+			interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc SPI5_K>;
+			resets = <&rcc SPI5_R>;
+			dmas = <&dmamux1 85 0x400 0x01>,
+			       <&dmamux1 86 0x400 0x01>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2c3: i2c@4c004000 {
+			compatible = "st,stm32mp13-i2c";
+			reg = <0x4c004000 0x400>;
+			interrupt-names = "event", "error";
+			interrupts-extended = <&exti 23 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc I2C3_K>;
+			resets = <&rcc I2C3_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dmas = <&dmamux1 73 0x400 0x80000001>,
+			       <&dmamux1 74 0x400 0x80000001>;
+			dma-names = "rx", "tx";
+			st,syscfg-fmp = <&syscfg 0x4 0x4>;
+			i2c-analog-filter;
+			power-domains = <&pd_core_ret>;
+			wakeup-source;
+			status = "disabled";
+		};
+
+		i2c4: i2c@4c005000 {
+			compatible = "st,stm32mp13-i2c";
+			reg = <0x4c005000 0x400>;
+			interrupt-names = "event", "error";
+			interrupts-extended = <&exti 24 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc I2C4_K>;
+			resets = <&rcc I2C4_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dmas = <&dmamux1 75 0x400 0x80000001>,
+			       <&dmamux1 76 0x400 0x80000001>;
+			dma-names = "rx", "tx";
+			st,syscfg-fmp = <&syscfg 0x4 0x8>;
+			i2c-analog-filter;
+			power-domains = <&pd_core_ret>;
+			wakeup-source;
+			status = "disabled";
+		};
+
+		i2c5: i2c@4c006000 {
+			compatible = "st,stm32mp13-i2c";
+			reg = <0x4c006000 0x400>;
+			interrupt-names = "event", "error";
+			interrupts-extended = <&exti 25 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc I2C5_K>;
+			resets = <&rcc I2C5_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dmas = <&dmamux1 115 0x400 0x80000001>,
+			       <&dmamux1 116 0x400 0x80000001>;
+			dma-names = "rx", "tx";
+			st,syscfg-fmp = <&syscfg 0x4 0x10>;
+			i2c-analog-filter;
+			power-domains = <&pd_core_ret>;
+			wakeup-source;
+			status = "disabled";
+		};
+
+		timers12: timer@4c007000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x4c007000 0x400>;
+			clocks = <&rcc TIM12_K>;
+			clock-names = "int";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@11 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <11>;
+				status = "disabled";
+			};
+		};
+
+		timers13: timer@4c008000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x4c008000 0x400>;
+			clocks = <&rcc TIM13_K>;
+			clock-names = "int";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@12 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <12>;
+				status = "disabled";
+			};
+		};
+
+		timers14: timer@4c009000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x4c009000 0x400>;
+			clocks = <&rcc TIM14_K>;
+			clock-names = "int";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@13 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <13>;
+				status = "disabled";
+			};
+		};
+
+		timers15: timer@4c00a000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x4c00a000 0x400>;
+			clocks = <&rcc TIM15_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 105 0x400 0x80000001>,
+			       <&dmamux1 106 0x400 0x80000001>,
+			       <&dmamux1 107 0x400 0x80000001>,
+			       <&dmamux1 108 0x400 0x80000001>;
+			dma-names = "ch1", "up", "trig", "com";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@14 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <14>;
+				status = "disabled";
+			};
+		};
+
+		timers16: timer@4c00b000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x4c00b000 0x400>;
+			clocks = <&rcc TIM16_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 109 0x400 0x80000001>,
+			       <&dmamux1 110 0x400 0x80000001>;
+			dma-names = "ch1", "up";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@15 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <15>;
+				status = "disabled";
+			};
+		};
+
+		timers17: timer@4c00c000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x4c00c000 0x400>;
+			clocks = <&rcc TIM17_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 111 0x400 0x80000001>,
+			       <&dmamux1 112 0x400 0x80000001>;
+			dma-names = "ch1", "up";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@16 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <16>;
+				status = "disabled";
+			};
+		};
+
+		rcc: rcc@50000000 {
+			compatible = "st,stm32mp13-rcc", "syscon";
+			reg = <0x50000000 0x1000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>;
+
+			clock-names = "hse", "hsi", "csi", "lse", "lsi";
+			clocks = <&scmi_clk CK_SCMI_HSE>,
+				 <&scmi_clk CK_SCMI_HSI>,
+				 <&scmi_clk CK_SCMI_CSI>,
+				 <&scmi_clk CK_SCMI_LSE>,
+				 <&scmi_clk CK_SCMI_LSI>;
+		};
+
+		exti: interrupt-controller@5000d000 {
+			compatible = "st,stm32mp1-exti", "syscon";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			#address-cells = <0>;
+			reg = <0x5000d000 0x400>;
+
+			exti-interrupt-map {
+				#address-cells = <0>;
+				#interrupt-cells = <2>;
+				interrupt-map-mask = <0xffffffff 0>;
+				interrupt-map =
+					<0  0 &intc GIC_SPI 6   IRQ_TYPE_LEVEL_HIGH>,
+					<1  0 &intc GIC_SPI 7   IRQ_TYPE_LEVEL_HIGH>,
+					<2  0 &intc GIC_SPI 8   IRQ_TYPE_LEVEL_HIGH>,
+					<3  0 &intc GIC_SPI 9   IRQ_TYPE_LEVEL_HIGH>,
+					<4  0 &intc GIC_SPI 10  IRQ_TYPE_LEVEL_HIGH>,
+					<5  0 &intc GIC_SPI 24  IRQ_TYPE_LEVEL_HIGH>,
+					<6  0 &intc GIC_SPI 65  IRQ_TYPE_LEVEL_HIGH>,
+					<7  0 &intc GIC_SPI 66  IRQ_TYPE_LEVEL_HIGH>,
+					<8  0 &intc GIC_SPI 67  IRQ_TYPE_LEVEL_HIGH>,
+					<9  0 &intc GIC_SPI 68  IRQ_TYPE_LEVEL_HIGH>,
+					<10 0 &intc GIC_SPI 41  IRQ_TYPE_LEVEL_HIGH>,
+					<11 0 &intc GIC_SPI 43  IRQ_TYPE_LEVEL_HIGH>,
+					<12 0 &intc GIC_SPI 77  IRQ_TYPE_LEVEL_HIGH>,
+					<13 0 &intc GIC_SPI 78  IRQ_TYPE_LEVEL_HIGH>,
+					<14 0 &intc GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>,
+					<15 0 &intc GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>,
+					<16 0 &intc GIC_SPI 1   IRQ_TYPE_LEVEL_HIGH>,
+					<19 0 &intc GIC_SPI 3   IRQ_TYPE_LEVEL_HIGH>,
+					<21 0 &intc GIC_SPI 32  IRQ_TYPE_LEVEL_HIGH>,
+					<22 0 &intc GIC_SPI 34  IRQ_TYPE_LEVEL_HIGH>,
+					<23 0 &intc GIC_SPI 73  IRQ_TYPE_LEVEL_HIGH>,
+					<24 0 &intc GIC_SPI 93  IRQ_TYPE_LEVEL_HIGH>,
+					<25 0 &intc GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>,
+					<26 0 &intc GIC_SPI 38  IRQ_TYPE_LEVEL_HIGH>,
+					<27 0 &intc GIC_SPI 39  IRQ_TYPE_LEVEL_HIGH>,
+					<28 0 &intc GIC_SPI 40  IRQ_TYPE_LEVEL_HIGH>,
+					<29 0 &intc GIC_SPI 72  IRQ_TYPE_LEVEL_HIGH>,
+					<30 0 &intc GIC_SPI 53  IRQ_TYPE_LEVEL_HIGH>,
+					<31 0 &intc GIC_SPI 54  IRQ_TYPE_LEVEL_HIGH>,
+					<32 0 &intc GIC_SPI 83  IRQ_TYPE_LEVEL_HIGH>,
+					<33 0 &intc GIC_SPI 84  IRQ_TYPE_LEVEL_HIGH>,
+					<42 0 &intc GIC_SPI 75  IRQ_TYPE_LEVEL_HIGH>,
+					<43 0 &intc GIC_SPI 75  IRQ_TYPE_LEVEL_HIGH>,
+					<44 0 &intc GIC_SPI 96  IRQ_TYPE_LEVEL_HIGH>,
+					<47 0 &intc GIC_SPI 92  IRQ_TYPE_LEVEL_HIGH>,
+					<48 0 &intc GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>,
+					<50 0 &intc GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>,
+					<52 0 &intc GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>,
+					<53 0 &intc GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>,
+					<68 0 &intc GIC_SPI 63  IRQ_TYPE_LEVEL_HIGH>,
+					<70 0 &intc GIC_SPI 98  IRQ_TYPE_LEVEL_HIGH>;
+			};
+		};
+
+		syscfg: syscon@50020000 {
+			compatible = "st,stm32mp157-syscfg", "syscon";
+			reg = <0x50020000 0x400>;
+			clocks = <&rcc SYSCFG>;
+		};
+
+		lptimer2: timer@50021000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-lptimer";
+			reg = <0x50021000 0x400>;
+			interrupts-extended = <&exti 48 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc LPTIM2_K>;
+			clock-names = "mux";
+			power-domains = <&pd_core_ret>;
+			wakeup-source;
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm-lp";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			trigger@1 {
+				compatible = "st,stm32-lptimer-trigger";
+				reg = <1>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-lptimer-counter";
+				status = "disabled";
+			};
+
+			timer {
+				compatible = "st,stm32-lptimer-timer";
+				status = "disabled";
+			};
+		};
+
+		lptimer3: timer@50022000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-lptimer";
+			reg = <0x50022000 0x400>;
+			interrupts-extended = <&exti 50 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc LPTIM3_K>;
+			clock-names = "mux";
+			power-domains = <&pd_core_ret>;
+			wakeup-source;
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm-lp";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			trigger@2 {
+				compatible = "st,stm32-lptimer-trigger";
+				reg = <2>;
+				status = "disabled";
+			};
+
+			timer {
+				compatible = "st,stm32-lptimer-timer";
+				status = "disabled";
+			};
+		};
+
+		lptimer4: timer@50023000 {
+			compatible = "st,stm32-lptimer";
+			reg = <0x50023000 0x400>;
+			interrupts-extended = <&exti 52 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc LPTIM4_K>;
+			clock-names = "mux";
+			power-domains = <&pd_core_ret>;
+			wakeup-source;
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm-lp";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer {
+				compatible = "st,stm32-lptimer-timer";
+				status = "disabled";
+			};
+		};
+
+		lptimer5: timer@50024000 {
+			compatible = "st,stm32-lptimer";
+			reg = <0x50024000 0x400>;
+			interrupts-extended = <&exti 53 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc LPTIM5_K>;
+			clock-names = "mux";
+			power-domains = <&pd_core_ret>;
+			wakeup-source;
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm-lp";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer {
+				compatible = "st,stm32-lptimer-timer";
+				status = "disabled";
+			};
+		};
+
+		dts: thermal@50028000 {
+			compatible = "st,stm32-thermal";
+			interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc DTS>;
+			clock-names = "pclk";
+			#thermal-sensor-cells = <0>;
+			reg = <0x50028000 0x100>;
+			status = "disabled";
+		};
+
+		hdp: hdp@5002a000 {
+			compatible = "st,stm32mp1-hdp";
+			reg = <0x5002a000 0x400>;
+			clocks = <&rcc HDP>;
+			clock-names = "hdp";
+			status = "disabled";
+		};
+
+		hash: hash@54003000 {
+			compatible = "st,stm32mp13-hash";
+			reg = <0x54003000 0x400>;
+			interrupts = <GIC_SPI 81 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc HASH1>;
+			resets = <&rcc HASH1_R>;
+			dmas = <&mdma 30 0x2 0x1000A02 0x0 0x0 0x0>;
+			dma-names = "in";
+			status = "disabled";
+		};
+
+		rng: rng@54004000 {
+			compatible = "st,stm32mp13-rng";
+			reg = <0x54004000 0x400>;
+			clocks = <&rcc RNG1_K>;
+			resets = <&rcc RNG1_R>;
+			status = "disabled";
+		};
+
+		mdma: dma-controller@58000000 {
+			compatible = "st,stm32h7-mdma";
+			reg = <0x58000000 0x1000>;
+			interrupts = <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc MDMA>;
+			#dma-cells = <6>;
+			dma-channels = <32>;
+			dma-requests = <48>;
+		};
+
+		fmc: memory-controller@58002000 {
+			#address-cells = <2>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp1-fmc2-ebi";
+			reg = <0x58002000 0x1000>;
+			clocks = <&rcc FMC_K>;
+			resets = <&rcc FMC_R>;
+			status = "disabled";
+
+			ranges = <0 0 0x60000000 0x04000000>, /* EBI CS 1 */
+				 <1 0 0x64000000 0x04000000>, /* EBI CS 2 */
+				 <2 0 0x68000000 0x04000000>, /* EBI CS 3 */
+				 <3 0 0x6c000000 0x04000000>, /* EBI CS 4 */
+				 <4 0 0x80000000 0x10000000>; /* NAND */
+
+			nand-controller@4,0 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp1-fmc2-nfc";
+				reg = <4 0x00000000 0x1000>,
+				      <4 0x08010000 0x1000>,
+				      <4 0x08020000 0x1000>,
+				      <4 0x01000000 0x1000>,
+				      <4 0x09010000 0x1000>,
+				      <4 0x09020000 0x1000>;
+				interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&mdma 24 0x2 0x12000a02 0x0 0x0 0x0>,
+				       <&mdma 24 0x2 0x12000a08 0x0 0x0 0x0>,
+				       <&mdma 25 0x2 0x12000a0a 0x0 0x0 0x0>;
+				dma-names = "tx", "rx", "ecc";
+				status = "disabled";
+			};
+		};
+
+		qspi: spi@58003000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32f469-qspi";
+			reg = <0x58003000 0x1000>, <0x70000000 0x10000000>;
+			reg-names = "qspi", "qspi_mm";
+			interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&mdma 26 0x2 0x10100002 0x0 0x0 0x0>,
+			       <&mdma 26 0x2 0x10100008 0x0 0x0 0x0>;
+			dma-names = "tx", "rx";
+			clocks = <&rcc QSPI_K>;
+			resets = <&rcc QSPI_R>;
+			status = "disabled";
+		};
+
+		sdmmc1: mmc@58005000 {
+			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+			arm,primecell-periphid = <0x20253180>;
+			reg = <0x58005000 0x1000>, <0x58006000 0x1000>;
+			interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "cmd_irq";
+			clocks = <&rcc SDMMC1_K>;
+			clock-names = "apb_pclk";
+			resets = <&rcc SDMMC1_R>;
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			max-frequency = <130000000>;
+			status = "disabled";
+		};
+
+		sdmmc2: mmc@58007000 {
+			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+			arm,primecell-periphid = <0x20253180>;
+			reg = <0x58007000 0x1000>, <0x58008000 0x1000>;
+			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "cmd_irq";
+			clocks = <&rcc SDMMC2_K>;
+			clock-names = "apb_pclk";
+			resets = <&rcc SDMMC2_R>;
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			max-frequency = <130000000>;
+			status = "disabled";
+		};
+
+		crc1: crc@58009000 {
+			compatible = "st,stm32f7-crc";
+			reg = <0x58009000 0x400>;
+			clocks = <&rcc CRC1>;
+			status = "disabled";
+		};
+
+		eth1: eth1@5800a000 {
+			compatible = "snps,dwmac-4.20a", "st,stm32mp13-dwmac";
+			reg = <0x5800a000 0x2000>;
+			reg-names = "stmmaceth";
+			interrupts-extended = <&intc GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>,
+					      <&exti 68 1>;
+			interrupt-names = "macirq", "eth_wake_irq";
+			clock-names = "stmmaceth",
+				      "mac-clk-tx",
+				      "mac-clk-rx",
+				      "ethstp",
+				      "eth-ck";
+			clocks = <&rcc ETH1MAC>,
+				 <&rcc ETH1TX>,
+				 <&rcc ETH1RX>,
+				 <&rcc ETH1STP>,
+				 <&rcc ETH1CK_K>;
+			st,syscon = <&syscfg 0x4 0xff0000>;
+			snps,mixed-burst;
+			snps,pbl = <2>;
+			snps,axi-config = <&stmmac_axi_config_1>;
+			snps,tso;
+			status = "disabled";
+
+			stmmac_axi_config_1: stmmac-axi-config {
+				snps,wr_osr_lmt = <0x7>;
+				snps,rd_osr_lmt = <0x7>;
+				snps,blen = <0 0 0 0 16 8 4>;
+			};
+		};
+
+		usbh_ohci: usbh-ohci@5800c000 {
+			compatible = "generic-ohci";
+			reg = <0x5800c000 0x1000>;
+			clocks = <&usbphyc>, <&rcc USBH>;
+			resets = <&rcc USBH_R>;
+			interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&pd_core>;
+			wakeup-source;
+			status = "disabled";
+		};
+
+		usbh_ehci: usbh-ehci@5800d000 {
+			compatible = "generic-ehci";
+			reg = <0x5800d000 0x1000>;
+			clocks = <&usbphyc>, <&rcc USBH>;
+			resets = <&rcc USBH_R>;
+			interrupts = <GIC_SPI 76 IRQ_TYPE_LEVEL_HIGH>;
+			companion = <&usbh_ohci>;
+			power-domains = <&pd_core>;
+			wakeup-source;
+			status = "disabled";
+		};
+
+		iwdg2: watchdog@5a002000 {
+			compatible = "st,stm32mp1-iwdg";
+			reg = <0x5a002000 0x400>;
+			clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
+			clock-names = "pclk", "lsi";
+			status = "disabled";
+		};
+
+		usbphyc: usbphyc@5a006000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			#clock-cells = <0>;
+			compatible = "st,stm32mp1-usbphyc";
+			reg = <0x5a006000 0x1000>;
+			clocks = <&rcc USBPHY_K>;
+			resets = <&rcc USBPHY_R>;
+			vdda1v1-supply = <&scmi_reg11>;
+			vdda1v8-supply = <&scmi_reg18>;
+			status = "disabled";
+
+			usbphyc_port0: usb-phy@0 {
+				#phy-cells = <0>;
+				reg = <0>;
+				interrupts-extended = <&exti 42 IRQ_TYPE_LEVEL_HIGH>;
+			};
+
+			usbphyc_port1: usb-phy@1 {
+				#phy-cells = <1>;
+				reg = <1>;
+				interrupts-extended = <&exti 43 IRQ_TYPE_LEVEL_HIGH>;
+			};
+		};
+
+		ddrperfm: perf@5a007000 {
+			compatible = "st,stm32-ddr-pmu";
+			reg = <0x5a007000 0x400>;
+			clocks = <&rcc DDRPERFM>;
+			resets = <&rcc DDRPERFM_R>;
+			status = "disabled";
+		};
+
+		rtc: rtc@5c004000 {
+			compatible = "st,stm32mp1-rtc";
+			reg = <0x5c004000 0x400>;
+			clocks = <&scmi_clk CK_SCMI_RTCAPB>,
+				 <&scmi_clk CK_SCMI_RTC>;
+			clock-names = "pclk", "rtc_ck";
+			interrupts-extended = <&exti 19 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		bsec: efuse@5c005000 {
+			compatible = "st,stm32mp13-bsec";
+			reg = <0x5c005000 0x400>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			part_number_otp: part_number_otp@4 {
+				reg = <0x4 0x2>;
+			};
+			vrefint: vrefin_cal@52 {
+				reg = <0x52 0x2>;
+			};
+			ts_cal1: calib@5c {
+				reg = <0x5c 0x2>;
+			};
+			ts_cal2: calib@5e {
+				reg = <0x5e 0x2>;
+			};
+			ethernet_mac1_address: mac1@e4 {
+				reg = <0xe4 0x6>;
+			};
+			ethernet_mac2_address: mac2@ea {
+				reg = <0xea 0x6>;
+			};
+		};
+
+		/*
+		 * Break node order to solve dependency probe issue between
+		 * pinctrl and exti.
+		 */
+		pinctrl: pinctrl@50002000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp135-pinctrl";
+			ranges = <0 0x50002000 0x8400>;
+			interrupt-parent = <&exti>;
+			st,syscfg = <&exti 0x60 0xff>;
+			pins-are-numbered;
+
+			gpioa: gpio@50002000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x0 0x400>;
+				clocks = <&rcc GPIOA>;
+				st,bank-name = "GPIOA";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 0 16>;
+			};
+
+			gpiob: gpio@50003000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x1000 0x400>;
+				clocks = <&rcc GPIOB>;
+				st,bank-name = "GPIOB";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 16 16>;
+			};
+
+			gpioc: gpio@50004000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x2000 0x400>;
+				clocks = <&rcc GPIOC>;
+				st,bank-name = "GPIOC";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 32 16>;
+			};
+
+			gpiod: gpio@50005000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x3000 0x400>;
+				clocks = <&rcc GPIOD>;
+				st,bank-name = "GPIOD";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 48 16>;
+			};
+
+			gpioe: gpio@50006000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x4000 0x400>;
+				clocks = <&rcc GPIOE>;
+				st,bank-name = "GPIOE";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 64 16>;
+			};
+
+			gpiof: gpio@50007000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x5000 0x400>;
+				clocks = <&rcc GPIOF>;
+				st,bank-name = "GPIOF";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 80 16>;
+			};
+
+			gpiog: gpio@50008000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x6000 0x400>;
+				clocks = <&rcc GPIOG>;
+				st,bank-name = "GPIOG";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 96 16>;
+			};
+
+			gpioh: gpio@50009000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x7000 0x400>;
+				clocks = <&rcc GPIOH>;
+				st,bank-name = "GPIOH";
+				ngpios = <15>;
+				gpio-ranges = <&pinctrl 0 112 15>;
+			};
+
+			gpioi: gpio@5000a000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x8000 0x400>;
+				clocks = <&rcc GPIOI>;
+				st,bank-name = "GPIOI";
+				ngpios = <8>;
+				gpio-ranges = <&pinctrl 0 128 8>;
+			};
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp133.dtsi b/arch/arm/boot/dts/stm32mp133.dtsi
new file mode 100644
index 000000000..b46e38913
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp133.dtsi
@@ -0,0 +1,100 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+#include "stm32mp131.dtsi"
+
+/ {
+	soc {
+		adc_1: adc@48003000 {
+			compatible = "st,stm32mp13-adc-core";
+			reg = <0x48003000 0x400>;
+			interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc ADC1>, <&rcc ADC1_K>;
+			clock-names = "bus", "adc";
+			interrupt-controller;
+			#interrupt-cells = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			adc1: adc@0 {
+				compatible = "st,stm32mp13-adc";
+				#io-channel-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0x0>;
+				interrupt-parent = <&adc_1>;
+				interrupts = <0>;
+				dmas = <&dmamux1 9 0x400 0x80000001>;
+				dma-names = "rx";
+				nvmem-cells = <&vrefint>;
+				nvmem-cell-names = "vrefint";
+				status = "disabled";
+
+				channel@18 {
+					reg = <18>;
+					label = "vrefint";
+				};
+			};
+		};
+
+		m_can1: can@4400e000 {
+			compatible = "bosch,m_can";
+			reg = <0x4400e000 0x400>, <0x44011000 0x1400>;
+			reg-names = "m_can", "message_ram";
+			interrupts = <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "int0", "int1";
+			clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
+			clock-names = "hclk", "cclk";
+			bosch,mram-cfg = <0x0 0 0 32 0 0 2 2>;
+			status = "disabled";
+		};
+
+		m_can2: can@4400f000 {
+			compatible = "bosch,m_can";
+			reg = <0x4400f000 0x400>, <0x44011000 0x2800>;
+			reg-names = "m_can", "message_ram";
+			interrupts = <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 23 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "int0", "int1";
+			clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
+			clock-names = "hclk", "cclk";
+			bosch,mram-cfg = <0x1400 0 0 32 0 0 2 2>;
+			status = "disabled";
+		};
+
+		eth2: eth2@5800e000 {
+			compatible = "snps,dwmac-4.20a", "st,stm32mp13-dwmac";
+			reg = <0x5800e000 0x2000>;
+			reg-names = "stmmaceth";
+			interrupts-extended = <&intc GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			clock-names = "stmmaceth",
+				      "mac-clk-tx",
+				      "mac-clk-rx",
+				      "ethstp",
+				      "eth-ck";
+			clocks = <&rcc ETH2MAC>,
+				 <&rcc ETH2TX>,
+				 <&rcc ETH2RX>,
+				 <&rcc ETH2STP>,
+				 <&rcc ETH2CK_K>;
+			st,syscon = <&syscfg 0x4 0xff000000>;
+			snps,mixed-burst;
+			snps,pbl = <2>;
+			snps,axi-config = <&stmmac_axi_config_2>;
+			snps,tso;
+			status = "disabled";
+
+			stmmac_axi_config_2: stmmac-axi-config {
+				snps,wr_osr_lmt = <0x7>;
+				snps,rd_osr_lmt = <0x7>;
+				snps,blen = <0 0 0 0 16 8 4>;
+			};
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp135.dtsi b/arch/arm/boot/dts/stm32mp135.dtsi
new file mode 100644
index 000000000..61052a87d
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp135.dtsi
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+#include "stm32mp133.dtsi"
+
+/ {
+	soc {
+		dcmipp: dcmipp@5a000000 {
+			compatible = "st,stm32mp13-dcmipp";
+			reg = <0x5a000000 0x400>;
+			interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&rcc DCMIPP_R>;
+			clocks = <&rcc DCMIPP_K>;
+			clock-names = "kclk";
+			status = "disabled";
+		};
+
+		ltdc: display-controller@5a001000 {
+			compatible = "st,stm32-ltdc";
+			reg = <0x5a001000 0x400>;
+			interrupts = <GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc LTDC_PX>;
+			clock-names = "lcd";
+			resets = <&scmi_reset RST_SCMI_LTDC>;
+			status = "disabled";
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp135f-dk-a7-examples.dts b/arch/arm/boot/dts/stm32mp135f-dk-a7-examples.dts
new file mode 100644
index 000000000..e7c39aa5b
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp135f-dk-a7-examples.dts
@@ -0,0 +1,22 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp135f-dk.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP135F-DK configured to run Linux A7 examples";
+	compatible = "st,stm32mp135f-dk-a7-examples", "st,stm32mp135f-dk", "st,stm32mp135";
+};
+
+&timers4 {
+	status = "okay";
+};
+
+&timers8 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/stm32mp135f-dk.dts b/arch/arm/boot/dts/stm32mp135f-dk.dts
new file mode 100644
index 000000000..a27355712
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp135f-dk.dts
@@ -0,0 +1,701 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/rtc/rtc-stm32.h>
+#include "stm32mp135.dtsi"
+#include "stm32mp13xf.dtsi"
+#include "stm32mp13-pinctrl.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP135F-DK Discovery Board";
+	compatible = "st,stm32mp135f-dk", "st,stm32mp135";
+
+	aliases {
+		ethernet0 = &eth1;
+		ethernet1 = &eth2;
+		serial0 = &uart4;
+		serial1 = &usart1;
+		serial2 = &uart8;
+		serial3 = &usart2;
+	};
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>;
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+
+		clk_mco1: clk-mco1 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+	};
+
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xc0000000 0x20000000>;
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		user-pa13 {
+			label = "User-PA13";
+			linux,code = <BTN_1>;
+			gpios = <&gpioa 13 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		led-blue {
+			function = LED_FUNCTION_HEARTBEAT;
+			color = <LED_COLOR_ID_BLUE>;
+			gpios = <&gpioa 14 GPIO_ACTIVE_LOW>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		optee_framebuffer@dd000000 {
+			reg = <0xdd000000 0x1000000>;
+			no-map;
+		};
+
+		optee@de000000 {
+			reg = <0xde000000 0x2000000>;
+			no-map;
+		};
+	};
+
+	v3v3_ao: v3v3_ao {
+		compatible = "regulator-fixed";
+		regulator-name = "v3v3_ao";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+	};
+
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpioe 12 GPIO_ACTIVE_HIGH>;
+		default-on;
+		default-brightness-level = <0>;
+		status = "okay";
+	};
+
+	panel_rgb: panel-rgb {
+		compatible = "rocktech,rk043fn48h", "panel-dpi";
+		enable-gpios = <&gpioi 7 GPIO_ACTIVE_HIGH>;
+		backlight = <&panel_backlight>;
+		power-supply = <&scmi_v3v3_sw>;
+		data-mapping = "bgr666";
+		status = "okay";
+
+		width-mm = <105>;
+		height-mm = <67>;
+
+		port {
+			panel_in_rgb: endpoint {
+				remote-endpoint = <&ltdc_out_rgb>;
+			};
+		};
+
+		panel-timing {
+			clock-frequency = <10000000>;
+			hactive = <480>;
+			vactive = <272>;
+			hsync-len = <52>;
+			hfront-porch = <10>;
+			hback-porch = <10>;
+			vsync-len = <10>;
+			vfront-porch = <10>;
+			vback-porch = <10>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			de-active = <1>;
+			pixelclk-active = <1>;
+		};
+	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&mcp23017 11 GPIO_ACTIVE_LOW>;
+	};
+
+	wake_up {
+		compatible = "gpio-keys";
+		status = "okay";
+
+		button {
+			label = "wake-up";
+			linux,code = <KEY_WAKEUP>;
+			interrupts-extended = <&optee 0>;
+			status = "okay";
+		};
+	};
+};
+
+&adc_1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&adc1_usb_cc_pins_a>;
+	vdda-supply = <&scmi_vdd_adc>;
+	vref-supply = <&scmi_vdd_adc>;
+	status = "okay";
+	adc1: adc@0 {
+		status = "okay";
+		/*
+		 * Type-C USB_PWR_CC1 & USB_PWR_CC2 on in6 & in12.
+		 * Use at least 5 * RC time, e.g. 5 * (Rp + Rd) * C:
+		 * 5 * (5.1 + 47kOhms) * 5pF => 1.3us.
+		 * Use arbitrary margin here (e.g. 5us).
+		 */
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@12 {
+			reg = <12>;
+			st,min-sample-time-ns = <5000>;
+		};
+	};
+};
+
+&crc1 {
+	status = "okay";
+};
+
+&cryp {
+	status = "okay";
+};
+
+&dcmipp {
+	status = "okay";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dcmipp_pins_a>;
+	pinctrl-1 = <&dcmipp_sleep_pins_a>;
+	port {
+		dcmipp_0: endpoint {
+			remote-endpoint = <&mipid02_2>;
+			bus-width = <8>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			pclk-sample = <0>;
+			pclk-max-frequency = <120000000>;
+		};
+	};
+};
+
+&dma1 {
+	sram = <&dma_pool>;
+};
+
+&dma2 {
+	sram = <&dma_pool>;
+};
+
+&dts {
+	status = "okay";
+};
+
+&eth1 {
+	status = "okay";
+	pinctrl-0 = <&eth1_rmii_pins_a>;
+	pinctrl-1 = <&eth1_rmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rmii";
+	max-speed = <100>;
+	phy-handle = <&phy0_eth1>;
+	nvmem-cells = <&ethernet_mac1_address>;
+	nvmem-cell-names = "mac-address";
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+
+		phy0_eth1: ethernet-phy@0 {
+			compatible = "ethernet-phy-id0007.c131";
+			reset-gpios =  <&mcp23017 9 GPIO_ACTIVE_LOW>;
+			reg = <0>;
+			wakeup-source;
+		};
+	};
+};
+
+&eth2 {
+	status = "okay";
+	pinctrl-0 = <&eth2_rmii_pins_a>;
+	pinctrl-1 = <&eth2_rmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rmii";
+	max-speed = <100>;
+	phy-handle = <&phy0_eth2>;
+	st,ext-phyclk;
+	phy-supply = <&scmi_v3v3_sw>;
+	nvmem-cells = <&ethernet_mac2_address>;
+	nvmem-cell-names = "mac-address";
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy0_eth2: ethernet-phy@0 {
+			compatible = "ethernet-phy-id0007.c131";
+			reset-gpios = <&mcp23017 10 GPIO_ACTIVE_LOW>;
+			reg = <0>;
+		};
+	};
+};
+
+&i2c1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c1_pins_a>;
+	pinctrl-1 = <&i2c1_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <96>;
+	i2c-scl-falling-time-ns = <3>;
+	clock-frequency = <1000000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	mcp23017: pinctrl@21 {
+		compatible = "microchip,mcp23017";
+		reg = <0x21>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		interrupts = <12 IRQ_TYPE_LEVEL_LOW>;
+		interrupt-parent = <&gpiog>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&mcp23017_pins_a>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		microchip,irq-mirror;
+	};
+
+	stm32g0@53 {
+		compatible = "st,stm32g0-typec";
+		reg = <0x53>;
+		/* Alert pin on PI2 (PWR wakeup pin), managed by optee */
+		interrupts-extended = <&optee 1>;
+		firmware-name = "stm32g0-ucsi.mp135f-dk.fw";
+		wakeup-source;
+		connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+
+			port {
+				con_usb_c_g0_ep: endpoint {
+					remote-endpoint = <&usbotg_hs_ep>;
+				};
+			};
+		};
+	};
+};
+
+&i2c5 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c5_pins_a>;
+	pinctrl-1 = <&i2c5_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <170>;
+	i2c-scl-falling-time-ns = <5>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	gc2145: gc2145@3c {
+		compatible = "galaxycore,gc2145";
+		reg = <0x3c>;
+		clocks = <&clk_ext_camera>;
+		IOVDD-supply = <&scmi_v3v3_sw>;
+		AVDD-supply = <&scmi_v3v3_sw>;
+		DVDD-supply = <&scmi_v3v3_sw>;
+		powerdown-gpios = <&mcp23017 3 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		reset-gpios = <&mcp23017 4 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		status = "okay";
+
+		port {
+			gc2145_ep: endpoint {
+				remote-endpoint = <&mipid02_0>;
+				clock-lanes = <0>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+
+	goodix: goodix_ts@5d {
+		compatible = "goodix,gt911";
+		reg = <0x5d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&goodix_pins_a>;
+		interrupt-parent = <&gpiof>;
+		interrupts = <5 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpioh 2 GPIO_ACTIVE_LOW>;
+		AVDD28-supply = <&scmi_v3v3_sw>;
+		VDDIO-supply = <&scmi_v3v3_sw>;
+		touchscreen-size-x = <480>;
+		touchscreen-size-y = <272>;
+		status = "okay";
+	};
+
+	ov5640: camera@3c {
+		compatible = "ovti,ov5640";
+		reg = <0x3c>;
+		clocks = <&clk_ext_camera>;
+		clock-names = "xclk";
+		DOVDD-supply = <&scmi_v3v3_sw>;
+		status = "disabled";
+		powerdown-gpios = <&mcp23017 3 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		reset-gpios = <&mcp23017 4 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+
+		port {
+			ov5640_0: endpoint {
+				clock-lanes = <0>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+
+	stmipi: stmipi@14 {
+		compatible = "st,st-mipid02";
+		reg = <0x14>;
+		status = "okay";
+		clocks = <&clk_mco1>;
+		clock-names = "xclk";
+		VDDE-supply = <&scmi_v1v8_periph>;
+		VDDIN-supply = <&scmi_v1v8_periph>;
+		reset-gpios = <&mcp23017 2 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port@0 {
+				reg = <0>;
+
+				mipid02_0: endpoint {
+					data-lanes = <1 2>;
+					lane-polarities = <0 0 0>;
+					remote-endpoint = <&gc2145_ep>;
+				};
+			};
+			port@2 {
+				reg = <2>;
+
+				mipid02_2: endpoint {
+					bus-width = <8>;
+					hsync-active = <0>;
+					vsync-active = <0>;
+					pclk-sample = <0>;
+					remote-endpoint = <&dcmipp_0>;
+				};
+			};
+		};
+	};
+};
+
+&iwdg2 {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&ltdc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&ltdc_pins_a>;
+	pinctrl-1 = <&ltdc_sleep_pins_a>;
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ltdc_out_rgb: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&panel_in_rgb>;
+		};
+	};
+};
+
+&rtc {
+	st,lsco = <RTC_OUT2_RMP>;
+	pinctrl-0 = <&rtc_out2_rmp_pins_a>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&scmi_regu {
+	scmi_vddcpu: voltd-vddcpu {
+		voltd-name = "vddcpu";
+		regulator-name = "vddcpu";
+	};
+	scmi_vdd: voltd-vdd {
+		voltd-name = "vdd";
+		regulator-name = "vdd";
+	};
+	scmi_vddcore: voltd-vddcore {
+		voltd-name = "vddcore";
+		regulator-name = "vddcore";
+	};
+	scmi_vdd_adc: voltd-vdd_adc {
+		voltd-name = "vdd_adc";
+		regulator-name = "vdd_adc";
+	};
+	scmi_vdd_usb: voltd-vdd_usb {
+		voltd-name = "vdd_usb";
+		regulator-name = "vdd_usb";
+	};
+	scmi_vdd_sd: voltd-vdd_sd {
+		voltd-name = "vdd_sd";
+		regulator-name = "vdd_sd";
+	};
+	scmi_v1v8_periph: voltd-v1v8_periph {
+		voltd-name = "v1v8_periph";
+		regulator-name = "v1v8_periph";
+	};
+	scmi_v3v3_sw: voltd-v3v3_sw {
+		voltd-name = "v3v3_sw";
+		regulator-name = "v3v3_sw";
+	};
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_clk_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a &sdmmc1_clk_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a>;
+	cd-gpios = <&gpioh 4 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&scmi_vdd_sd>;
+	status = "okay";
+};
+
+/* Wifi */
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_clk_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_clk_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a>;
+	non-removable;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3_ao>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+	};
+};
+
+&spi5 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi5_pins_a>;
+	pinctrl-1 = <&spi5_sleep_pins_a>;
+	status = "disabled";
+};
+
+&sram {
+	dma_pool: dma-sram@0 {
+		reg = <0x0 0x4000>;
+		pool;
+	};
+};
+
+&timers3 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm3_pins_a>;
+		pinctrl-1 = <&pwm3_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@2 {
+		status = "okay";
+	};
+};
+
+&timers4 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm4_pins_a>;
+		pinctrl-1 = <&pwm4_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@3 {
+		status = "okay";
+	};
+};
+
+&timers8 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm8_pins_a>;
+		pinctrl-1 = <&pwm8_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@7 {
+		status = "okay";
+	};
+};
+
+&timers14 {
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm14_pins_a>;
+		pinctrl-1 = <&pwm14_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@13 {
+		status = "okay";
+	};
+};
+
+&uart4 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&uart4_pins_a>;
+	pinctrl-1 = <&uart4_sleep_pins_a>;
+	pinctrl-2 = <&uart4_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&uart8 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&uart8_pins_a>;
+	pinctrl-1 = <&uart8_sleep_pins_a>;
+	pinctrl-2 = <&uart8_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+};
+
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+/* Bluetooth */
+&usart2 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart2_pins_a>;
+	pinctrl-1 = <&usart2_sleep_pins_a>;
+	pinctrl-2 = <&usart2_idle_pins_a>;
+	uart-has-rtscts;
+	status = "okay";
+
+	bluetooth {
+		shutdown-gpios = <&mcp23017 13 GPIO_ACTIVE_HIGH>;
+		compatible = "brcm,bcm43438-bt";
+		max-speed = <3000000>;
+		vbat-supply = <&v3v3_ao>;
+		vddio-supply = <&v3v3_ao>;
+	};
+};
+
+&usbh_ehci {
+	phys = <&usbphyc_port0>;
+	status = "okay";
+};
+
+&usbotg_hs {
+	phys = <&usbphyc_port1 0>;
+	phy-names = "usb2-phy";
+	usb-role-switch;
+	status = "okay";
+	port {
+		usbotg_hs_ep: endpoint {
+			remote-endpoint = <&con_usb_c_g0_ep>;
+		};
+	};
+};
+
+&usbphyc {
+	status = "okay";
+};
+
+&usbphyc_port0 {
+	phy-supply = <&scmi_vdd_usb>;
+	st,current-boost-microamp = <1000>;
+	st,decrease-hs-slew-rate;
+	st,tune-hs-dc-level = <2>;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <11>;
+	st,trim-hs-impedance = <2>;
+	st,tune-squelch-level = <1>;
+	st,enable-hs-rx-gain-eq;
+	st,no-hs-ftime-ctrl;
+	st,no-lsfs-sc;
+
+	/*
+	 * Hack to keep hub active if wakeup source is enabled
+	 * otherwise the hub will wakeup the port0 as soon as the v3v3_sw is disabled
+	 */
+	connector {
+		compatible = "usb-a-connector";
+		vbus-supply = <&scmi_v3v3_sw>;
+	};
+};
+
+&usbphyc_port1 {
+	phy-supply = <&scmi_vdd_usb>;
+	st,current-boost-microamp = <1000>;
+	st,decrease-hs-slew-rate;
+	st,tune-hs-dc-level = <2>;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <11>;
+	st,trim-hs-impedance = <2>;
+	st,tune-squelch-level = <1>;
+	st,enable-hs-rx-gain-eq;
+	st,no-hs-ftime-ctrl;
+	st,no-lsfs-sc;
+};
diff --git a/arch/arm/boot/dts/stm32mp13xa.dtsi b/arch/arm/boot/dts/stm32mp13xa.dtsi
new file mode 100644
index 000000000..20e52cd27
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp13xa.dtsi
@@ -0,0 +1,5 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
diff --git a/arch/arm/boot/dts/stm32mp13xc.dtsi b/arch/arm/boot/dts/stm32mp13xc.dtsi
new file mode 100644
index 000000000..fc4ba53fe
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp13xc.dtsi
@@ -0,0 +1,21 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/ {
+	soc {
+		cryp: crypto@54002000 {
+			compatible = "st,stm32mp1-cryp";
+			reg = <0x54002000 0x400>;
+			interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CRYP1>;
+			resets = <&rcc CRYP1_R>;
+			dmas = <&mdma 28 0x0 0x400202 0x0 0x0 0x0>,
+			       <&mdma 29 0x3 0x400808 0x0 0x0 0x0>;
+			dma-names = "in", "out";
+			status = "disabled";
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp13xd.dtsi b/arch/arm/boot/dts/stm32mp13xd.dtsi
new file mode 100644
index 000000000..aa8e23568
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp13xd.dtsi
@@ -0,0 +1,5 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
diff --git a/arch/arm/boot/dts/stm32mp13xf.dtsi b/arch/arm/boot/dts/stm32mp13xf.dtsi
new file mode 100644
index 000000000..fc4ba53fe
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp13xf.dtsi
@@ -0,0 +1,21 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/ {
+	soc {
+		cryp: crypto@54002000 {
+			compatible = "st,stm32mp1-cryp";
+			reg = <0x54002000 0x400>;
+			interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CRYP1>;
+			resets = <&rcc CRYP1_R>;
+			dmas = <&mdma 28 0x0 0x400202 0x0 0x0 0x0>,
+			       <&mdma 29 0x3 0x400808 0x0 0x0 0x0>;
+			dma-names = "in", "out";
+			status = "disabled";
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp15-m4-srm-pinctrl.dtsi b/arch/arm/boot/dts/stm32mp15-m4-srm-pinctrl.dtsi
new file mode 100644
index 000000000..bfa78e50b
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp15-m4-srm-pinctrl.dtsi
@@ -0,0 +1,524 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Fabien Dessenne <fabien.dessenne@st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	m4_adc1_in6_pins_a: m4-adc1-in6 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 12, RSVD)>;
+		};
+	};
+
+	m4_adc12_ain_pins_a: m4-adc12-ain-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, RSVD)>, /* ADC1 in13 */
+				 <STM32_PINMUX('F', 12, RSVD)>, /* ADC1 in6 */
+				 <STM32_PINMUX('F', 13, RSVD)>, /* ADC2 in2 */
+				 <STM32_PINMUX('F', 14, RSVD)>; /* ADC2 in6 */
+		};
+	};
+
+	m4_adc12_usb_pwr_pins_a: m4-adc12-usb-pwr-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, RSVD)>, /* ADC12 in18 */
+				 <STM32_PINMUX('A', 5, RSVD)>; /* ADC12 in19 */
+		};
+	};
+
+	m4_cec_pins_a: m4-cec-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 15, RSVD)>;
+		};
+	};
+
+	m4_cec_pins_b: m4-cec-1 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 6, RSVD)>;
+		};
+	};
+
+	m4_dac_ch1_pins_a: m4-dac-ch1 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, RSVD)>;
+		};
+	};
+
+	m4_dac_ch2_pins_a: m4-dac-ch2 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 5, RSVD)>;
+		};
+	};
+
+	m4_dcmi_pins_a: m4-dcmi-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 8,  RSVD)>,/* DCMI_HSYNC */
+				 <STM32_PINMUX('B', 7,  RSVD)>,/* DCMI_VSYNC */
+				 <STM32_PINMUX('A', 6,  RSVD)>,/* DCMI_PIXCLK */
+				 <STM32_PINMUX('H', 9,  RSVD)>,/* DCMI_D0 */
+				 <STM32_PINMUX('H', 10, RSVD)>,/* DCMI_D1 */
+				 <STM32_PINMUX('H', 11, RSVD)>,/* DCMI_D2 */
+				 <STM32_PINMUX('H', 12, RSVD)>,/* DCMI_D3 */
+				 <STM32_PINMUX('H', 14, RSVD)>,/* DCMI_D4 */
+				 <STM32_PINMUX('I', 4,  RSVD)>,/* DCMI_D5 */
+				 <STM32_PINMUX('B', 8,  RSVD)>,/* DCMI_D6 */
+				 <STM32_PINMUX('E', 6,  RSVD)>,/* DCMI_D7 */
+				 <STM32_PINMUX('I', 1,  RSVD)>,/* DCMI_D8 */
+				 <STM32_PINMUX('H', 7,  RSVD)>,/* DCMI_D9 */
+				 <STM32_PINMUX('I', 3,  RSVD)>,/* DCMI_D10 */
+				 <STM32_PINMUX('H', 15, RSVD)>;/* DCMI_D11 */
+		};
+	};
+
+	m4_dfsdm_clkout_pins_a: m4-dfsdm-clkout-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 13, RSVD)>; /* DFSDM_CKOUT */
+		};
+	};
+
+	m4_dfsdm_data1_pins_a: m4-dfsdm-data1-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, RSVD)>; /* DFSDM_DATA1 */
+		};
+	};
+
+	m4_dfsdm_data3_pins_a: m4-dfsdm-data3-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, RSVD)>; /* DFSDM_DATA3 */
+		};
+	};
+
+	m4_ethernet0_rgmii_pins_a: m4-ethernet0-rgmii-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 5, RSVD)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('G', 4, RSVD)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('G', 13, RSVD)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('G', 14, RSVD)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('C', 2, RSVD)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('E', 2, RSVD)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('B', 11, RSVD)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('C', 1, RSVD)>, /* ETH_MDC */
+				 <STM32_PINMUX('A', 2, RSVD)>, /* ETH_MDIO */
+				 <STM32_PINMUX('C', 4, RSVD)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 5, RSVD)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('B', 0, RSVD)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('B', 1, RSVD)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 1, RSVD)>, /* ETH_RGMII_RX_CLK */
+				 <STM32_PINMUX('A', 7, RSVD)>; /* ETH_RGMII_RX_CTL */
+		};
+	};
+
+	m4_fmc_pins_a: m4-fmc-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, RSVD)>, /* FMC_NOE */
+				 <STM32_PINMUX('D', 5, RSVD)>, /* FMC_NWE */
+				 <STM32_PINMUX('D', 11, RSVD)>, /* FMC_A16_FMC_CLE */
+				 <STM32_PINMUX('D', 12, RSVD)>, /* FMC_A17_FMC_ALE */
+				 <STM32_PINMUX('D', 14, RSVD)>, /* FMC_D0 */
+				 <STM32_PINMUX('D', 15, RSVD)>, /* FMC_D1 */
+				 <STM32_PINMUX('D', 0, RSVD)>, /* FMC_D2 */
+				 <STM32_PINMUX('D', 1, RSVD)>, /* FMC_D3 */
+				 <STM32_PINMUX('E', 7, RSVD)>, /* FMC_D4 */
+				 <STM32_PINMUX('E', 8, RSVD)>, /* FMC_D5 */
+				 <STM32_PINMUX('E', 9, RSVD)>, /* FMC_D6 */
+				 <STM32_PINMUX('E', 10, RSVD)>, /* FMC_D7 */
+				 <STM32_PINMUX('G', 9, RSVD)>, /* FMC_NE2_FMC_NCE */
+				 <STM32_PINMUX('D', 6, RSVD)>; /* FMC_NWAIT */
+		};
+	};
+
+	m4_hdp0_pins_a: m4-hdp0-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 12, RSVD)>; /* HDP0 */
+		};
+	};
+
+	m4_hdp6_pins_a: m4-hdp6-0 {
+		pins {
+			pinmux = <STM32_PINMUX('K', 5, RSVD)>; /* HDP6 */
+		};
+	};
+
+	m4_hdp7_pins_a: m4-hdp7-0 {
+		pins {
+			pinmux = <STM32_PINMUX('K', 6, RSVD)>; /* HDP7 */
+		};
+	};
+
+	m4_i2c1_pins_a: m4-i2c1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 12, RSVD)>, /* I2C1_SCL */
+				 <STM32_PINMUX('F', 15, RSVD)>; /* I2C1_SDA */
+		};
+	};
+
+	m4_i2c2_pins_a: m4-i2c2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 4, RSVD)>, /* I2C2_SCL */
+				 <STM32_PINMUX('H', 5, RSVD)>; /* I2C2_SDA */
+		};
+	};
+
+	m4_i2c5_pins_a: m4-i2c5-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 11, RSVD)>, /* I2C5_SCL */
+				 <STM32_PINMUX('A', 12, RSVD)>; /* I2C5_SDA */
+		};
+	};
+
+	m4_i2s2_pins_a: m4-i2s2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 3, RSVD)>, /* I2S2_SDO */
+				 <STM32_PINMUX('B', 9, RSVD)>, /* I2S2_WS */
+				 <STM32_PINMUX('A', 9, RSVD)>; /* I2S2_CK */
+		};
+	};
+
+	m4_ltdc_pins_a: m4-ltdc-a-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G',  7, RSVD)>, /* LCD_CLK */
+				 <STM32_PINMUX('I', 10, RSVD)>, /* LCD_HSYNC */
+				 <STM32_PINMUX('I',  9, RSVD)>, /* LCD_VSYNC */
+				 <STM32_PINMUX('F', 10, RSVD)>, /* LCD_DE */
+				 <STM32_PINMUX('H',  2, RSVD)>, /* LCD_R0 */
+				 <STM32_PINMUX('H',  3, RSVD)>, /* LCD_R1 */
+				 <STM32_PINMUX('H',  8, RSVD)>, /* LCD_R2 */
+				 <STM32_PINMUX('H',  9, RSVD)>, /* LCD_R3 */
+				 <STM32_PINMUX('H', 10, RSVD)>, /* LCD_R4 */
+				 <STM32_PINMUX('C',  0, RSVD)>, /* LCD_R5 */
+				 <STM32_PINMUX('H', 12, RSVD)>, /* LCD_R6 */
+				 <STM32_PINMUX('E', 15, RSVD)>, /* LCD_R7 */
+				 <STM32_PINMUX('E',  5, RSVD)>, /* LCD_G0 */
+				 <STM32_PINMUX('E',  6, RSVD)>, /* LCD_G1 */
+				 <STM32_PINMUX('H', 13, RSVD)>, /* LCD_G2 */
+				 <STM32_PINMUX('H', 14, RSVD)>, /* LCD_G3 */
+				 <STM32_PINMUX('H', 15, RSVD)>, /* LCD_G4 */
+				 <STM32_PINMUX('I',  0, RSVD)>, /* LCD_G5 */
+				 <STM32_PINMUX('I',  1, RSVD)>, /* LCD_G6 */
+				 <STM32_PINMUX('I',  2, RSVD)>, /* LCD_G7 */
+				 <STM32_PINMUX('D',  9, RSVD)>, /* LCD_B0 */
+				 <STM32_PINMUX('G', 12, RSVD)>, /* LCD_B1 */
+				 <STM32_PINMUX('G', 10, RSVD)>, /* LCD_B2 */
+				 <STM32_PINMUX('D', 10, RSVD)>, /* LCD_B3 */
+				 <STM32_PINMUX('I',  4, RSVD)>, /* LCD_B4 */
+				 <STM32_PINMUX('A',  3, RSVD)>, /* LCD_B5 */
+				 <STM32_PINMUX('B',  8, RSVD)>, /* LCD_B6 */
+				 <STM32_PINMUX('D',  8, RSVD)>; /* LCD_B7 */
+		};
+	};
+
+	m4_ltdc_pins_b: m4-ltdc-b-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 14, RSVD)>, /* LCD_CLK */
+				 <STM32_PINMUX('I', 12, RSVD)>, /* LCD_HSYNC */
+				 <STM32_PINMUX('I', 13, RSVD)>, /* LCD_VSYNC */
+				 <STM32_PINMUX('K',  7, RSVD)>, /* LCD_DE */
+				 <STM32_PINMUX('I', 15, RSVD)>, /* LCD_R0 */
+				 <STM32_PINMUX('J',  0, RSVD)>, /* LCD_R1 */
+				 <STM32_PINMUX('J',  1, RSVD)>, /* LCD_R2 */
+				 <STM32_PINMUX('J',  2, RSVD)>, /* LCD_R3 */
+				 <STM32_PINMUX('J',  3, RSVD)>, /* LCD_R4 */
+				 <STM32_PINMUX('J',  4, RSVD)>, /* LCD_R5 */
+				 <STM32_PINMUX('J',  5, RSVD)>, /* LCD_R6 */
+				 <STM32_PINMUX('J',  6, RSVD)>, /* LCD_R7 */
+				 <STM32_PINMUX('J',  7, RSVD)>, /* LCD_G0 */
+				 <STM32_PINMUX('J',  8, RSVD)>, /* LCD_G1 */
+				 <STM32_PINMUX('J',  9, RSVD)>, /* LCD_G2 */
+				 <STM32_PINMUX('J', 10, RSVD)>, /* LCD_G3 */
+				 <STM32_PINMUX('J', 11, RSVD)>, /* LCD_G4 */
+				 <STM32_PINMUX('K',  0, RSVD)>, /* LCD_G5 */
+				 <STM32_PINMUX('K',  1, RSVD)>, /* LCD_G6 */
+				 <STM32_PINMUX('K',  2, RSVD)>, /* LCD_G7 */
+				 <STM32_PINMUX('J', 12, RSVD)>, /* LCD_B0 */
+				 <STM32_PINMUX('J', 13, RSVD)>, /* LCD_B1 */
+				 <STM32_PINMUX('J', 14, RSVD)>, /* LCD_B2 */
+				 <STM32_PINMUX('J', 15, RSVD)>, /* LCD_B3 */
+				 <STM32_PINMUX('K',  3, RSVD)>, /* LCD_B4 */
+				 <STM32_PINMUX('K',  4, RSVD)>, /* LCD_B5 */
+				 <STM32_PINMUX('K',  5, RSVD)>, /* LCD_B6 */
+				 <STM32_PINMUX('K',  6, RSVD)>; /* LCD_B7 */
+		};
+	};
+
+	m4_m_can1_pins_a: m4-m-can1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 13, RSVD)>, /* CAN1_TX */
+				 <STM32_PINMUX('I', 9, RSVD)>; /* CAN1_RX */
+		};
+	};
+
+	m4_pwm1_pins_a: m4-pwm1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 9, RSVD)>, /* TIM1_CH1 */
+				 <STM32_PINMUX('E', 11, RSVD)>, /* TIM1_CH2 */
+				 <STM32_PINMUX('E', 14, RSVD)>; /* TIM1_CH4 */
+		};
+	};
+
+	m4_pwm2_pins_a: m4-pwm2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 3, RSVD)>; /* TIM2_CH4 */
+		};
+	};
+
+	m4_pwm3_pins_a: m4-pwm3-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 7, RSVD)>; /* TIM3_CH2 */
+		};
+	};
+
+	m4_pwm4_pins_a: m4-pwm4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 14, RSVD)>, /* TIM4_CH3 */
+				 <STM32_PINMUX('D', 15, RSVD)>; /* TIM4_CH4 */
+		};
+	};
+
+	m4_pwm4_pins_b: m4-pwm4-1 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 13, RSVD)>; /* TIM4_CH2 */
+		};
+	};
+
+	m4_pwm5_pins_a: m4-pwm5-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 11, RSVD)>; /* TIM5_CH2 */
+		};
+	};
+
+	m4_pwm8_pins_a: m4-pwm8-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 2, RSVD)>; /* TIM8_CH4 */
+		};
+	};
+
+	m4_pwm12_pins_a: m4-pwm12-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 6, RSVD)>; /* TIM12_CH1 */
+		};
+	};
+
+	m4_qspi_bk1_pins_a: m4-qspi-bk1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 8, RSVD)>, /* QSPI_BK1_IO0 */
+				 <STM32_PINMUX('F', 9, RSVD)>, /* QSPI_BK1_IO1 */
+				 <STM32_PINMUX('F', 7, RSVD)>, /* QSPI_BK1_IO2 */
+				 <STM32_PINMUX('F', 6, RSVD)>, /* QSPI_BK1_IO3 */
+				 <STM32_PINMUX('B', 6, RSVD)>; /* QSPI_BK1_NCS */
+		};
+	};
+
+	m4_qspi_bk2_pins_a: m4-qspi-bk2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 2, RSVD)>, /* QSPI_BK2_IO0 */
+				 <STM32_PINMUX('H', 3, RSVD)>, /* QSPI_BK2_IO1 */
+				 <STM32_PINMUX('G', 10, RSVD)>, /* QSPI_BK2_IO2 */
+				 <STM32_PINMUX('G', 7, RSVD)>, /* QSPI_BK2_IO3 */
+				 <STM32_PINMUX('C', 0, RSVD)>; /* QSPI_BK2_NCS */
+		};
+	};
+
+	m4_qspi_clk_pins_a: m4-qspi-clk-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 10, RSVD)>; /* QSPI_CLK */
+		};
+	};
+
+	m4_rtc_out2_rmp_pins_a: m4-rtc-out2-rmp-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 8, RSVD)>; /* RTC_OUT2_RMP */
+		};
+	};
+
+	m4_sai2a_pins_a: m4-sai2a-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 5, RSVD)>, /* SAI2_SCK_A */
+				 <STM32_PINMUX('I', 6, RSVD)>, /* SAI2_SD_A */
+				 <STM32_PINMUX('I', 7, RSVD)>, /* SAI2_FS_A */
+				 <STM32_PINMUX('E', 0, RSVD)>; /* SAI2_MCLK_A */
+		};
+	};
+
+	m4_sai2b_pins_a: m4-sai2b-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 12, RSVD)>, /* SAI2_SCK_B */
+				 <STM32_PINMUX('E', 13, RSVD)>, /* SAI2_FS_B */
+				 <STM32_PINMUX('E', 14, RSVD)>, /* SAI2_MCLK_B */
+				 <STM32_PINMUX('F', 11, RSVD)>; /* SAI2_SD_B */
+		};
+	};
+
+	m4_sai2b_pins_b: m4-sai2b-2 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 11, RSVD)>; /* SAI2_SD_B */
+		};
+	};
+
+	m4_sai4a_pins_a: m4-sai4a-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 5, RSVD)>; /* SAI4_SD_A */
+		};
+	};
+
+	m4_sdmmc1_b4_pins_a: m4-sdmmc1-b4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 8, RSVD)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('C', 9, RSVD)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('C', 10, RSVD)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('C', 11, RSVD)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('D', 2, RSVD)>, /* SDMMC1_CMD */
+				 <STM32_PINMUX('C', 12, RSVD)>; /* SDMMC1_CK */
+		};
+	};
+
+	m4_sdmmc1_dir_pins_a: m4-sdmmc1-dir-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 2, RSVD)>, /* SDMMC1_D0DIR */
+				 <STM32_PINMUX('C', 7, RSVD)>, /* SDMMC1_D123DIR */
+				 <STM32_PINMUX('B', 9, RSVD)>, /* SDMMC1_CDIR */
+				 <STM32_PINMUX('E', 4, RSVD)>; /* SDMMC1_CKIN */
+		};
+	};
+
+	m4_sdmmc2_b4_pins_a: m4-sdmmc2-b4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 14, RSVD)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('B', 15, RSVD)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('B', 3, RSVD)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('B', 4, RSVD)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('G', 6, RSVD)>, /* SDMMC2_CMD */
+				 <STM32_PINMUX('E', 3, RSVD)>; /* SDMMC2_CK */
+		};
+	};
+
+	m4_sdmmc2_b4_pins_b: m4-sdmmc2-b4-1 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 14, RSVD)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('B', 15, RSVD)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('B', 3, RSVD)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('B', 4, RSVD)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('G', 6, RSVD)>, /* SDMMC2_CMD */
+				 <STM32_PINMUX('E', 3, RSVD)>; /* SDMMC2_CK */
+		};
+	};
+
+	m4_sdmmc2_d47_pins_a: m4-sdmmc2-d47-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 8, RSVD)>, /* SDMMC2_D4 */
+				 <STM32_PINMUX('A', 9, RSVD)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('E', 5, RSVD)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('D', 3, RSVD)>; /* SDMMC2_D7 */
+		};
+	};
+
+	m4_sdmmc3_b4_pins_a: m4-sdmmc3-b4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 0, RSVD)>, /* SDMMC3_D0 */
+				 <STM32_PINMUX('F', 4, RSVD)>, /* SDMMC3_D1 */
+				 <STM32_PINMUX('F', 5, RSVD)>, /* SDMMC3_D2 */
+				 <STM32_PINMUX('D', 7, RSVD)>, /* SDMMC3_D3 */
+				 <STM32_PINMUX('F', 1, RSVD)>, /* SDMMC3_CMD */
+				 <STM32_PINMUX('G', 15, RSVD)>; /* SDMMC3_CK */
+		};
+	};
+
+	m4_spdifrx_pins_a: m4-spdifrx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 12, RSVD)>; /* SPDIF_IN1 */
+		};
+	};
+
+	m4_spi4_pins_a: m4-spi4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 12, RSVD)>, /* SPI4_SCK */
+				 <STM32_PINMUX('E', 14, RSVD)>, /* SPI4_MOSI */
+				 <STM32_PINMUX('E', 13, RSVD)>; /* SPI4_MISO */
+		};
+	};
+
+	m4_spi5_pins_a: m4-spi5-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 7, RSVD)>, /* SPI5_SCK */
+				 <STM32_PINMUX('F', 9, RSVD)>, /* SPI5_MOSI */
+				 <STM32_PINMUX('F', 8, RSVD)>; /* SPI5_MISO */
+		};
+	};
+
+	m4_stusb1600_pins_a: m4-stusb1600-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 11, RSVD)>;
+		};
+	};
+
+	m4_uart4_pins_a: m4-uart4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 11, RSVD)>, /* UART4_TX */
+				 <STM32_PINMUX('B', 2, RSVD)>; /* UART4_RX */
+		};
+	};
+
+	m4_uart7_pins_a: m4-uart7-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 8, RSVD)>, /* USART7_TX */
+				 <STM32_PINMUX('E', 7, RSVD)>; /* USART7_RX */
+		};
+	};
+
+	m4_usart2_pins_a: m4-usart2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 5, RSVD)>, /* USART2_TX */
+				 <STM32_PINMUX('D', 4, RSVD)>, /* USART2_RTS */
+				 <STM32_PINMUX('D', 6, RSVD)>, /* USART2_RX */
+				 <STM32_PINMUX('D', 3, RSVD)>; /* USART2_CTS_NSS */
+		};
+	};
+
+	m4_usart3_pins_a: m4-usart3-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 10, RSVD)>, /* USART3_TX */
+				 <STM32_PINMUX('G', 8, RSVD)>, /* USART3_RTS */
+				 <STM32_PINMUX('B', 12, RSVD)>, /* USART3_RX */
+				 <STM32_PINMUX('I', 10, RSVD)>; /* USART3_CTS_NSS */
+		};
+	};
+
+	m4_usart3_pins_b: m4-usart3-1 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 10, RSVD)>, /* USART3_TX */
+				 <STM32_PINMUX('G', 8, RSVD)>, /* USART3_RTS */
+				 <STM32_PINMUX('B', 12, RSVD)>, /* USART3_RX */
+				 <STM32_PINMUX('B', 13, RSVD)>; /* USART3_CTS_NSS */
+		};
+	};
+
+	m4_usbotg_fs_dp_dm_pins_a: m4-usbotg-fs-dp-dm-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 11, RSVD)>, /* OTG_FS_DM */
+				 <STM32_PINMUX('A', 12, RSVD)>; /* OTG_FS_DP */
+		};
+	};
+
+	m4_usbotg_hs_pins_a: m4-usbotg_hs-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 10, RSVD)>; /* OTG_ID */
+		};
+	};
+};
+
+&pinctrl_z {
+	m4_i2c4_pins_a: m4-i2c4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, RSVD)>, /* I2C4_SCL */
+				 <STM32_PINMUX('Z', 5, RSVD)>; /* I2C4_SDA */
+		};
+	};
+
+	m4_spi1_pins_a: m4-spi1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 0, RSVD)>, /* SPI1_SCK */
+				 <STM32_PINMUX('Z', 2, RSVD)>, /* SPI1_MOSI */
+				 <STM32_PINMUX('Z', 1, RSVD)>; /* SPI1_MISO */
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp15-m4-srm.dtsi b/arch/arm/boot/dts/stm32mp15-m4-srm.dtsi
new file mode 100644
index 000000000..7fa3ca411
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp15-m4-srm.dtsi
@@ -0,0 +1,447 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Fabien Dessenne <fabien.dessenne@st.com> for STMicroelectronics.
+ */
+
+&m4_rproc {
+	m4_system_resources {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		m4_timers2: timer@40000000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40000000 0x400>;
+			clocks = <&rcc TIM2_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers3: timer@40001000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40001000 0x400>;
+			clocks = <&rcc TIM3_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers4: timer@40002000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40002000 0x400>;
+			clocks = <&rcc TIM4_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers5: timer@40003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40003000 0x400>;
+			clocks = <&rcc TIM5_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers6: timer@40004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40004000 0x400>;
+			clocks = <&rcc TIM6_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers7: timer@40005000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40005000 0x400>;
+			clocks = <&rcc TIM7_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers12: timer@40006000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40006000 0x400>;
+			clocks = <&rcc TIM12_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers13: timer@40007000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40007000 0x400>;
+			clocks = <&rcc TIM13_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers14: timer@40008000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40008000 0x400>;
+			clocks = <&rcc TIM14_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_lptimer1: timer@40009000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40009000 0x400>;
+			clocks = <&rcc LPTIM1_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_spi2: spi@4000b000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000b000 0x400>;
+			clocks = <&rcc SPI2_K>;
+			status = "disabled";
+		};
+		m4_i2s2: audio-controller@4000b000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000b000 0x400>;
+			status = "disabled";
+		};
+		m4_spi3: spi@4000c000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000c000 0x400>;
+			clocks = <&rcc SPI3_K>;
+			status = "disabled";
+		};
+		m4_i2s3: audio-controller@4000c000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000c000 0x400>;
+			status = "disabled";
+		};
+		m4_spdifrx: audio-controller@4000d000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000d000 0x400>;
+			clocks = <&rcc SPDIF_K>;
+			clock-names = "kclk";
+			status = "disabled";
+		};
+		m4_usart2: serial@4000e000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000e000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <27 1>;
+			clocks = <&rcc USART2_K>;
+			status = "disabled";
+		};
+		m4_usart3: serial@4000f000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000f000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <28 1>;
+			clocks = <&rcc USART3_K>;
+			status = "disabled";
+		};
+		m4_uart4: serial@40010000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40010000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <30 1>;
+			clocks = <&rcc UART4_K>;
+			status = "disabled";
+		};
+		m4_uart5: serial@40011000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40011000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <31 1>;
+			clocks = <&rcc UART5_K>;
+			status = "disabled";
+		};
+		m4_i2c1: i2c@40012000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40012000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <21 1>;
+			clocks = <&rcc I2C1_K>;
+			status = "disabled";
+		};
+		m4_i2c2: i2c@40013000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40013000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <22 1>;
+			clocks = <&rcc I2C2_K>;
+			status = "disabled";
+		};
+		m4_i2c3: i2c@40014000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40014000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <23 1>;
+			clocks = <&rcc I2C3_K>;
+			status = "disabled";
+		};
+		m4_i2c5: i2c@40015000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40015000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <25 1>;
+			clocks = <&rcc I2C5_K>;
+			status = "disabled";
+		};
+		m4_cec: cec@40016000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40016000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <69 1>;
+			clocks = <&rcc CEC_K>, <&rcc CEC>;
+			clock-names = "cec", "hdmi-cec";
+			status = "disabled";
+		};
+		m4_dac: dac@40017000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40017000 0x400>;
+			clocks = <&rcc DAC12>;
+			clock-names = "pclk";
+			status = "disabled";
+		};
+		m4_uart7: serial@40018000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40018000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <32 1>;
+			clocks = <&rcc UART7_K>;
+			status = "disabled";
+		};
+		m4_uart8: serial@40019000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40019000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <33 1>;
+			clocks = <&rcc UART8_K>;
+			status = "disabled";
+		};
+		m4_timers1: timer@44000000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44000000 0x400>;
+			clocks = <&rcc TIM1_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers8: timer@44001000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44001000 0x400>;
+			clocks = <&rcc TIM8_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_usart6: serial@44003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44003000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <29 1>;
+			clocks = <&rcc USART6_K>;
+			status = "disabled";
+		};
+		m4_spi1: spi@44004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44004000 0x400>;
+			clocks = <&rcc SPI1_K>;
+			status = "disabled";
+		};
+		m4_i2s1: audio-controller@44004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44004000 0x400>;
+			status = "disabled";
+		};
+		m4_spi4: spi@44005000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44005000 0x400>;
+			clocks = <&rcc SPI4_K>;
+			status = "disabled";
+		};
+		m4_timers15: timer@44006000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44006000 0x400>;
+			clocks = <&rcc TIM15_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers16: timer@44007000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44007000 0x400>;
+			clocks = <&rcc TIM16_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers17: timer@44008000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44008000 0x400>;
+			clocks = <&rcc TIM17_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_spi5: spi@44009000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44009000 0x400>;
+			clocks = <&rcc SPI5_K>;
+			status = "disabled";
+		};
+		m4_sai1: sai@4400a000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400a000 0x4>;
+			clocks = <&rcc SAI1_K>;
+			clock-names = "sai_ck";
+			status = "disabled";
+		};
+		m4_sai2: sai@4400b000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400b000 0x4>;
+			clocks = <&rcc SAI2_K>;
+			clock-names = "sai_ck";
+			status = "disabled";
+		};
+		m4_sai3: sai@4400c000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400c000 0x4>;
+			clocks = <&rcc SAI3_K>;
+			clock-names = "sai_ck";
+			status = "disabled";
+		};
+		m4_dfsdm: dfsdm@4400d000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400d000 0x800>;
+			clocks = <&rcc DFSDM_K>, <&rcc ADFSDM_K>;
+			clock-names = "dfsdm", "audio";
+			status = "disabled";
+		};
+		m4_m_can1: can@4400e000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400e000 0x400>, <0x44011000 0x2800>;
+			clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
+			clock-names = "hclk", "cclk";
+			status = "disabled";
+		};
+		m4_m_can2: can@4400f000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400f000 0x400>, <0x44011000 0x2800>;
+			clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
+			clock-names = "hclk", "cclk";
+			status = "disabled";
+		};
+		m4_dma1: dma@48000000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48000000 0x400>;
+			clocks = <&rcc DMA1>;
+			status = "disabled";
+		};
+		m4_dma2: dma@48001000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48001000 0x400>;
+			clocks = <&rcc DMA2>;
+			status = "disabled";
+		};
+		m4_dmamux1: dma-router@48002000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48002000 0x1c>;
+			clocks = <&rcc DMAMUX>;
+			status = "disabled";
+		};
+		m4_adc: adc@48003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48003000 0x400>;
+			clocks = <&rcc ADC12>, <&rcc ADC12_K>;
+			clock-names = "bus", "adc";
+			status = "disabled";
+		};
+		m4_sdmmc3: sdmmc@48004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48004000 0x400>, <0x48005000 0x400>;
+			clocks = <&rcc SDMMC3_K>;
+			status = "disabled";
+		};
+		m4_usbotg_hs: usb-otg@49000000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x49000000 0x10000>;
+			clocks = <&rcc USBO_K>;
+			clock-names = "otg";
+			status = "disabled";
+		};
+		m4_hash2: hash@4c002000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c002000 0x400>;
+			clocks = <&rcc HASH2>;
+			status = "disabled";
+		};
+		m4_rng2: rng@4c003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c003000 0x400>;
+			clocks = <&rcc RNG2_K>;
+			status = "disabled";
+		};
+		m4_crc2: crc@4c004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c004000 0x400>;
+			clocks = <&rcc CRC2>;
+			status = "disabled";
+		};
+		m4_cryp2: cryp@4c005000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c005000 0x400>;
+			clocks = <&rcc CRYP2>;
+			status = "disabled";
+		};
+		m4_dcmi: dcmi@4c006000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c006000 0x400>;
+			clocks = <&rcc DCMI>;
+			clock-names = "mclk";
+			status = "disabled";
+		};
+		m4_lptimer2: timer@50021000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50021000 0x400>;
+			clocks = <&rcc LPTIM2_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_lptimer3: timer@50022000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50022000 0x400>;
+			clocks = <&rcc LPTIM3_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_lptimer4: timer@50023000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50023000 0x400>;
+			clocks = <&rcc LPTIM4_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_lptimer5: timer@50024000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50024000 0x400>;
+			clocks = <&rcc LPTIM5_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_sai4: sai@50027000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50027000 0x4>;
+			clocks = <&rcc SAI4_K>;
+			clock-names = "sai_ck";
+			status = "disabled";
+			};
+		m4_fmc: memory-controller@58002000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x5800200 0x1000>;
+			clocks = <&rcc FMC_K>;
+			status = "disabled";
+		};
+		m4_qspi: qspi@58003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x58003000 0x1000>, <0x70000000 0x10000000>;
+			clocks = <&rcc QSPI_K>;
+			status = "disabled";
+		};
+		m4_ethernet0: ethernet@5800a000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x5800a000 0x2000>;
+			clock-names = "stmmaceth",
+				      "mac-clk-tx",
+				      "mac-clk-rx",
+				      "ethstp",
+				      "syscfg-clk";
+			clocks = <&rcc ETHMAC>,
+				 <&rcc ETHTX>,
+				 <&rcc ETHRX>,
+				 <&rcc ETHSTP>,
+				 <&rcc SYSCFG>;
+			status = "disabled";
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp15-pinctrl.dtsi b/arch/arm/boot/dts/stm32mp15-pinctrl.dtsi
index 2ebafe27a..43eb55cb1 100644
--- a/arch/arm/boot/dts/stm32mp15-pinctrl.dtsi
+++ b/arch/arm/boot/dts/stm32mp15-pinctrl.dtsi
@@ -151,7 +151,46 @@ pins {
 		};
 	};
 
-	ethernet0_rgmii_pins_a: rgmii-0 {
+	dfsdm_clkout_pins_a: dfsdm-clkout-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 13, AF3)>; /* DFSDM_CKOUT */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	dfsdm_clkout_sleep_pins_a: dfsdm-clkout-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 13, ANALOG)>; /* DFSDM_CKOUT */
+		};
+	};
+
+	dfsdm_data1_pins_a: dfsdm-data1-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, AF3)>; /* DFSDM_DATA1 */
+		};
+	};
+
+	dfsdm_data1_sleep_pins_a: dfsdm-data1-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, ANALOG)>; /* DFSDM_DATA1 */
+		};
+	};
+
+	dfsdm_data3_pins_a: dfsdm-data3-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, AF6)>; /* DFSDM_DATA3 */
+		};
+	};
+
+	dfsdm_data3_sleep_pins_a: dfsdm-data3-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, ANALOG)>; /* DFSDM_DATA3 */
+		};
+	};
+
+	ethernet0_rgmii_pins_a: ethernet0-rgmii-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, AF11)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, AF11)>, /* ETH_RGMII_GTX_CLK */
@@ -182,7 +221,7 @@ pins3 {
 		};
 	};
 
-	ethernet0_rgmii_sleep_pins_a: rgmii-sleep-0 {
+	ethernet0_rgmii_sleep_pins_a: ethernet0-rgmii-sleep-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, ANALOG)>, /* ETH_RGMII_GTX_CLK */
@@ -202,7 +241,7 @@ pins1 {
 		};
 	};
 
-	ethernet0_rgmii_pins_b: rgmii-1 {
+	ethernet0_rgmii_pins_b: ethernet0-rgmii-1 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, AF11)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, AF11)>, /* ETH_RGMII_GTX_CLK */
@@ -233,7 +272,7 @@ pins3 {
 		};
 	};
 
-	ethernet0_rgmii_sleep_pins_b: rgmii-sleep-1 {
+	ethernet0_rgmii_sleep_pins_b: ethernet0-rgmii-sleep-1 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, ANALOG)>, /* ETH_RGMII_GTX_CLK */
@@ -253,7 +292,7 @@ pins1 {
 		 };
 	};
 
-	ethernet0_rgmii_pins_c: rgmii-2 {
+	ethernet0_rgmii_pins_c: ethernet0-rgmii-2 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, AF11)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, AF11)>, /* ETH_RGMII_GTX_CLK */
@@ -284,7 +323,7 @@ pins3 {
 		};
 	};
 
-	ethernet0_rgmii_sleep_pins_c: rgmii-sleep-2 {
+	ethernet0_rgmii_sleep_pins_c: ethernet0-rgmii-sleep-2 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, ANALOG)>, /* ETH_RGMII_GTX_CLK */
@@ -304,7 +343,7 @@ pins1 {
 		};
 	};
 
-	ethernet0_rmii_pins_a: rmii-0 {
+	ethernet0_rmii_pins_a: ethernet0-rmii-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 13, AF11)>, /* ETH1_RMII_TXD0 */
 				 <STM32_PINMUX('G', 14, AF11)>, /* ETH1_RMII_TXD1 */
@@ -324,7 +363,7 @@ pins2 {
 		};
 	};
 
-	ethernet0_rmii_sleep_pins_a: rmii-sleep-0 {
+	ethernet0_rmii_sleep_pins_a: ethernet0-rmii-sleep-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 13, ANALOG)>, /* ETH1_RMII_TXD0 */
 				 <STM32_PINMUX('G', 14, ANALOG)>, /* ETH1_RMII_TXD1 */
@@ -437,6 +476,51 @@ pins {
 		};
 	};
 
+	hdp0_pins_a: hdp0-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 12, AF2)>; /* HDP0 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	hdp0_pins_sleep_a: hdp0-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 12, ANALOG)>; /* HDP0 */
+		};
+	};
+
+	hdp6_pins_a: hdp6-0 {
+		pins {
+			pinmux = <STM32_PINMUX('K', 5, AF2)>; /* HDP6 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	hdp6_pins_sleep_a: hdp6-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('K', 5, ANALOG)>; /* HDP6 */
+		};
+	};
+
+	hdp7_pins_a: hdp7-0 {
+		pins {
+			pinmux = <STM32_PINMUX('K', 6, AF2)>; /* HDP7 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	hdp7_pins_sleep_a: hdp7-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('K', 6, ANALOG)>; /* HDP7 */
+		};
+	};
+
 	i2c1_pins_a: i2c1-0 {
 		pins {
 			pinmux = <STM32_PINMUX('D', 12, AF5)>, /* I2C1_SCL */
@@ -861,7 +945,7 @@ pins2 {
 		};
 	};
 
-	m_can1_sleep_pins_a: m_can1-sleep-0 {
+	m_can1_sleep_pins_a: m-can1-sleep-0 {
 		pins {
 			pinmux = <STM32_PINMUX('H', 13, ANALOG)>, /* CAN1_TX */
 				 <STM32_PINMUX('I', 9, ANALOG)>; /* CAN1_RX */
@@ -881,7 +965,7 @@ pins2 {
 		};
 	};
 
-	m_can1_sleep_pins_b: m_can1-sleep-1 {
+	m_can1_sleep_pins_b: m-can1-sleep-1 {
 		pins {
 			pinmux = <STM32_PINMUX('A', 12, ANALOG)>, /* CAN1_TX */
 				 <STM32_PINMUX('A', 11, ANALOG)>; /* CAN1_RX */
@@ -901,7 +985,7 @@ pins2 {
 		};
 	};
 
-	m_can2_sleep_pins_a: m_can2-sleep-0 {
+	m_can2_sleep_pins_a: m-can2-sleep-0 {
 		pins {
 			pinmux = <STM32_PINMUX('B', 13, ANALOG)>, /* CAN2_TX */
 				 <STM32_PINMUX('B', 5, ANALOG)>; /* CAN2_RX */
@@ -1068,23 +1152,8 @@ pins {
 		};
 	};
 
-	qspi_clk_pins_a: qspi-clk-0 {
-		pins {
-			pinmux = <STM32_PINMUX('F', 10, AF9)>; /* QSPI_CLK */
-			bias-disable;
-			drive-push-pull;
-			slew-rate = <3>;
-		};
-	};
-
-	qspi_clk_sleep_pins_a: qspi-clk-sleep-0 {
-		pins {
-			pinmux = <STM32_PINMUX('F', 10, ANALOG)>; /* QSPI_CLK */
-		};
-	};
-
 	qspi_bk1_pins_a: qspi-bk1-0 {
-		pins1 {
+		pins {
 			pinmux = <STM32_PINMUX('F', 8, AF10)>, /* QSPI_BK1_IO0 */
 				 <STM32_PINMUX('F', 9, AF10)>, /* QSPI_BK1_IO1 */
 				 <STM32_PINMUX('F', 7, AF9)>, /* QSPI_BK1_IO2 */
@@ -1093,12 +1162,6 @@ pins1 {
 			drive-push-pull;
 			slew-rate = <1>;
 		};
-		pins2 {
-			pinmux = <STM32_PINMUX('B', 6, AF10)>; /* QSPI_BK1_NCS */
-			bias-pull-up;
-			drive-push-pull;
-			slew-rate = <1>;
-		};
 	};
 
 	qspi_bk1_sleep_pins_a: qspi-bk1-sleep-0 {
@@ -1106,13 +1169,12 @@ pins {
 			pinmux = <STM32_PINMUX('F', 8, ANALOG)>, /* QSPI_BK1_IO0 */
 				 <STM32_PINMUX('F', 9, ANALOG)>, /* QSPI_BK1_IO1 */
 				 <STM32_PINMUX('F', 7, ANALOG)>, /* QSPI_BK1_IO2 */
-				 <STM32_PINMUX('F', 6, ANALOG)>, /* QSPI_BK1_IO3 */
-				 <STM32_PINMUX('B', 6, ANALOG)>; /* QSPI_BK1_NCS */
+				 <STM32_PINMUX('F', 6, ANALOG)>; /* QSPI_BK1_IO3 */
 		};
 	};
 
 	qspi_bk2_pins_a: qspi-bk2-0 {
-		pins1 {
+		pins {
 			pinmux = <STM32_PINMUX('H', 2, AF9)>, /* QSPI_BK2_IO0 */
 				 <STM32_PINMUX('H', 3, AF9)>, /* QSPI_BK2_IO1 */
 				 <STM32_PINMUX('G', 10, AF11)>, /* QSPI_BK2_IO2 */
@@ -1121,7 +1183,49 @@ pins1 {
 			drive-push-pull;
 			slew-rate = <1>;
 		};
-		pins2 {
+	};
+
+	qspi_bk2_sleep_pins_a: qspi-bk2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 2, ANALOG)>, /* QSPI_BK2_IO0 */
+				 <STM32_PINMUX('H', 3, ANALOG)>, /* QSPI_BK2_IO1 */
+				 <STM32_PINMUX('G', 10, ANALOG)>, /* QSPI_BK2_IO2 */
+				 <STM32_PINMUX('G', 7, ANALOG)>; /* QSPI_BK2_IO3 */
+		};
+	};
+
+	qspi_clk_pins_a: qspi-clk-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 10, AF9)>; /* QSPI_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+	};
+
+	qspi_clk_sleep_pins_a: qspi-clk-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 10, ANALOG)>; /* QSPI_CLK */
+		};
+	};
+
+	qspi_cs1_pins_a: qspi-cs1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 6, AF10)>; /* QSPI_BK1_NCS */
+			bias-pull-up;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+	};
+
+	qspi_cs1_sleep_pins_a: qspi-cs1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 6, ANALOG)>; /* QSPI_BK1_NCS */
+		};
+	};
+
+	qspi_cs2_pins_a: qspi-cs2-0 {
+		pins {
 			pinmux = <STM32_PINMUX('C', 0, AF10)>; /* QSPI_BK2_NCS */
 			bias-pull-up;
 			drive-push-pull;
@@ -1129,13 +1233,15 @@ pins2 {
 		};
 	};
 
-	qspi_bk2_sleep_pins_a: qspi-bk2-sleep-0 {
+	qspi_cs2_sleep_pins_a: qspi-cs2-sleep-0 {
 		pins {
-			pinmux = <STM32_PINMUX('H', 2, ANALOG)>, /* QSPI_BK2_IO0 */
-				 <STM32_PINMUX('H', 3, ANALOG)>, /* QSPI_BK2_IO1 */
-				 <STM32_PINMUX('G', 10, ANALOG)>, /* QSPI_BK2_IO2 */
-				 <STM32_PINMUX('G', 7, ANALOG)>, /* QSPI_BK2_IO3 */
-				 <STM32_PINMUX('C', 0, ANALOG)>; /* QSPI_BK2_NCS */
+			pinmux = <STM32_PINMUX('C', 0, ANALOG)>; /* QSPI_BK2_NCS */
+		};
+	};
+
+	rtc_out2_rmp_pins_a: rtc-out2-rmp-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 8, ANALOG)>; /* RTC_OUT2_RMP */
 		};
 	};
 
@@ -1190,7 +1296,7 @@ pins {
 		};
 	};
 
-	sai2a_sleep_pins_c: sai2a-2 {
+	sai2a_sleep_pins_c: sai2a-sleep-2 {
 		pins {
 			pinmux = <STM32_PINMUX('D', 13, ANALOG)>, /* SAI2_SCK_A */
 				 <STM32_PINMUX('D', 11, ANALOG)>, /* SAI2_SD_A */
@@ -1282,6 +1388,18 @@ pins2 {
 		};
 	};
 
+	sdmmc1_b4_init_pins_a: sdmmc1-b4-init-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('C', 11, AF12)>; /* SDMMC1_D3 */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
 	sdmmc1_b4_od_pins_a: sdmmc1-b4-od-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
@@ -1306,18 +1424,6 @@ pins3 {
 		};
 	};
 
-	sdmmc1_b4_init_pins_a: sdmmc1-b4-init-0 {
-		pins1 {
-			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
-				 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
-				 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
-				 <STM32_PINMUX('C', 11, AF12)>; /* SDMMC1_D3 */
-			slew-rate = <1>;
-			drive-push-pull;
-			bias-disable;
-		};
-	};
-
 	sdmmc1_b4_sleep_pins_a: sdmmc1-b4-sleep-0 {
 		pins {
 			pinmux = <STM32_PINMUX('C', 8, ANALOG)>, /* SDMMC1_D0 */
@@ -1716,9 +1822,55 @@ pins2 {
 		};
 	};
 
+	spi4_pins_b: spi4-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 12, AF5)>, /* SPI4_SCK */
+				 <STM32_PINMUX('E', 14, AF5)>; /* SPI4_MOSI */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 13, AF5)>; /* SPI4_MISO */
+			bias-disable;
+		};
+	};
+
+	spi4_sleep_pins_b: spi4-sleep-1 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 12, ANALOG)>, /* SPI4_SCK */
+				 <STM32_PINMUX('E', 13, ANALOG)>, /* SPI4_MISO */
+				 <STM32_PINMUX('E', 14, ANALOG)>; /* SPI4_MOSI */
+		};
+	};
+
+	spi5_pins_a: spi5-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 7, AF5)>, /* SPI5_SCK */
+				 <STM32_PINMUX('F', 9, AF5)>; /* SPI5_MOSI */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 8, AF5)>; /* SPI5_MISO */
+			bias-disable;
+		};
+	};
+
+	spi5_sleep_pins_a: spi5-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 7, ANALOG)>, /* SPI5_SCK */
+				 <STM32_PINMUX('F', 8, ANALOG)>, /* SPI5_MISO */
+				 <STM32_PINMUX('F', 9, ANALOG)>; /* SPI5_MOSI */
+		};
+	};
+
 	stusb1600_pins_a: stusb1600-0 {
 		pins {
-			pinmux = <STM32_PINMUX('I', 11, ANALOG)>;
+			pinmux = <STM32_PINMUX('I', 11, GPIO)>;
 			bias-pull-up;
 		};
 	};
@@ -1737,20 +1889,20 @@ pins2 {
 	};
 
 	uart4_idle_pins_a: uart4-idle-0 {
-		   pins1 {
-			 pinmux = <STM32_PINMUX('G', 11, ANALOG)>; /* UART4_TX */
-		   };
-		   pins2 {
-			 pinmux = <STM32_PINMUX('B', 2, AF8)>; /* UART4_RX */
-			 bias-disable;
-		   };
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 11, ANALOG)>; /* UART4_TX */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 2, AF8)>; /* UART4_RX */
+			bias-disable;
+		};
 	};
 
 	uart4_sleep_pins_a: uart4-sleep-0 {
-		   pins {
+		pins {
 			pinmux = <STM32_PINMUX('G', 11, ANALOG)>, /* UART4_TX */
 				 <STM32_PINMUX('B', 2, ANALOG)>; /* UART4_RX */
-		    };
+		};
 	};
 
 	uart4_pins_b: uart4-1 {
@@ -1816,7 +1968,7 @@ pins1 {
 		};
 		pins2 {
 			pinmux = <STM32_PINMUX('E', 7, AF7)>; /* UART7_RX */
-			bias-disable;
+			bias-pull-up;
 		};
 	};
 
@@ -1826,7 +1978,7 @@ pins1 {
 		};
 		pins2 {
 			pinmux = <STM32_PINMUX('E', 7, AF7)>; /* UART7_RX */
-			bias-disable;
+			bias-pull-up;
 		};
 	};
 
@@ -1850,7 +2002,7 @@ pins2 {
 		};
 	};
 
-	uart8_rtscts_pins_a: uart8rtscts-0 {
+	uart8_rtscts_pins_a: uart8-rtscts-0 {
 		pins {
 			pinmux = <STM32_PINMUX('G', 7, AF8)>, /* UART8_RTS */
 				 <STM32_PINMUX('G', 10, AF8)>; /* UART8_CTS */
@@ -1912,7 +2064,7 @@ pins1 {
 				 <STM32_PINMUX('D', 4, AF7)>; /* USART2_RTS */
 			bias-disable;
 			drive-push-pull;
-			slew-rate = <3>;
+			slew-rate = <0>;
 		};
 		pins2 {
 			pinmux = <STM32_PINMUX('D', 6, AF7)>, /* USART2_RX */
@@ -1930,7 +2082,7 @@ pins2 {
 			pinmux = <STM32_PINMUX('D', 4, AF7)>; /* USART2_RTS */
 			bias-disable;
 			drive-push-pull;
-			slew-rate = <3>;
+			slew-rate = <0>;
 		};
 		pins3 {
 			pinmux = <STM32_PINMUX('D', 6, AF7)>; /* USART2_RX */
@@ -2012,7 +2164,7 @@ pins1 {
 		pins2 {
 			pinmux = <STM32_PINMUX('B', 12, AF8)>, /* USART3_RX */
 				 <STM32_PINMUX('B', 13, AF7)>; /* USART3_CTS_NSS */
-			bias-disable;
+			bias-pull-up;
 		};
 	};
 
@@ -2029,7 +2181,7 @@ pins2 {
 		};
 		pins3 {
 			pinmux = <STM32_PINMUX('B', 12, AF8)>; /* USART3_RX */
-			bias-disable;
+			bias-pull-up;
 		};
 	};
 
@@ -2042,16 +2194,16 @@ pins {
 		};
 	};
 
-	usbotg_hs_pins_a: usbotg-hs-0 {
+	usbotg_fs_dp_dm_pins_a: usbotg-fs-dp-dm-0 {
 		pins {
-			pinmux = <STM32_PINMUX('A', 10, ANALOG)>; /* OTG_ID */
+			pinmux = <STM32_PINMUX('A', 11, ANALOG)>, /* OTG_FS_DM */
+				 <STM32_PINMUX('A', 12, ANALOG)>; /* OTG_FS_DP */
 		};
 	};
 
-	usbotg_fs_dp_dm_pins_a: usbotg-fs-dp-dm-0 {
+	usbotg_hs_pins_a: usbotg-hs-0 {
 		pins {
-			pinmux = <STM32_PINMUX('A', 11, ANALOG)>, /* OTG_FS_DM */
-				 <STM32_PINMUX('A', 12, ANALOG)>; /* OTG_FS_DP */
+			pinmux = <STM32_PINMUX('A', 10, ANALOG)>; /* OTG_ID */
 		};
 	};
 };
@@ -2120,4 +2272,12 @@ pins2 {
 			bias-disable;
 		};
 	};
+
+	spi1_sleep_pins_a: spi1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 0, ANALOG)>, /* SPI1_SCK */
+				 <STM32_PINMUX('Z', 1, ANALOG)>, /* SPI1_MISO */
+				 <STM32_PINMUX('Z', 2, ANALOG)>; /* SPI1_MOSI */
+		};
+	};
 };
diff --git a/arch/arm/boot/dts/stm32mp151.dtsi b/arch/arm/boot/dts/stm32mp151.dtsi
index e0d483318..4a7d413d1 100644
--- a/arch/arm/boot/dts/stm32mp151.dtsi
+++ b/arch/arm/boot/dts/stm32mp151.dtsi
@@ -5,6 +5,7 @@
  */
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 #include <dt-bindings/clock/stm32mp1-clks.h>
+#include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/reset/stm32mp1-resets.h>
 
 / {
@@ -17,9 +18,14 @@ cpus {
 
 		cpu0: cpu@0 {
 			compatible = "arm,cortex-a7";
-			clock-frequency = <650000000>;
 			device_type = "cpu";
 			reg = <0>;
+			clocks = <&scmi_clk CK_SCMI_MPU>;
+			clock-names = "cpu";
+			operating-points-v2 = <&cpu0_opp_table>;
+			nvmem-cells = <&part_number_otp>;
+			nvmem-cell-names = "part_number";
+			#cooling-cells = <2>;
 		};
 	};
 
@@ -30,6 +36,49 @@ arm-pmu {
 		interrupt-parent = <&intc>;
 	};
 
+	cpu0_opp_table: cpu0-opp-table {
+		compatible = "operating-points-v2";
+		opp-shared;
+	};
+
+	scmi_sram: sram@2ffff000 {
+		compatible = "mmio-sram";
+		reg = <0x2ffff000 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0 0x2ffff000 0x1000>;
+
+		scmi_shm: scmi_shm@0 {
+			compatible = "arm,scmi-shmem";
+			reg = <0 0x80>;
+		};
+	};
+
+	firmware {
+		optee {
+			compatible = "linaro,optee-tz";
+			method = "smc";
+		};
+
+		scmi: scmi {
+			compatible = "linaro,scmi-optee";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			linaro,optee-channel-id = <0>;
+			shmem = <&scmi_shm>;
+
+			scmi_clk: protocol@14 {
+				reg = <0x14>;
+				#clock-cells = <1>;
+			};
+
+			scmi_reset: protocol@16 {
+				reg = <0x16>;
+				#reset-cells = <1>;
+			};
+		};
+	};
+
 	psci {
 		compatible = "arm,psci-1.0";
 		method = "smc";
@@ -45,45 +94,13 @@ intc: interrupt-controller@a0021000 {
 
 	timer {
 		compatible = "arm,armv7-timer";
-		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
-			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
-			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
-			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>;
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
 		interrupt-parent = <&intc>;
 	};
 
-	clocks {
-		clk_hse: clk-hse {
-			#clock-cells = <0>;
-			compatible = "fixed-clock";
-			clock-frequency = <24000000>;
-		};
-
-		clk_hsi: clk-hsi {
-			#clock-cells = <0>;
-			compatible = "fixed-clock";
-			clock-frequency = <64000000>;
-		};
-
-		clk_lse: clk-lse {
-			#clock-cells = <0>;
-			compatible = "fixed-clock";
-			clock-frequency = <32768>;
-		};
-
-		clk_lsi: clk-lsi {
-			#clock-cells = <0>;
-			compatible = "fixed-clock";
-			clock-frequency = <32000>;
-		};
-
-		clk_csi: clk-csi {
-			#clock-cells = <0>;
-			compatible = "fixed-clock";
-			clock-frequency = <4000000>;
-		};
-	};
-
 	thermal-zones {
 		cpu_thermal: cpu-thermal {
 			polling-delay-passive = <0>;
@@ -91,12 +108,6 @@ cpu_thermal: cpu-thermal {
 			thermal-sensors = <&dts>;
 
 			trips {
-				cpu_alert1: cpu-alert1 {
-					temperature = <85000>;
-					hysteresis = <0>;
-					type = "passive";
-				};
-
 				cpu-crit {
 					temperature = <120000>;
 					hysteresis = <0>;
@@ -115,6 +126,26 @@ booster: regulator-booster {
 		status = "disabled";
 	};
 
+	pm_domain {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "st,stm32mp157c-pd";
+
+		pd_core_ret: core-ret-power-domain@1 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <1>;
+			#power-domain-cells = <0>;
+			label = "CORE-RETENTION";
+
+			pd_core: core-power-domain@2 {
+				reg = <2>;
+				#power-domain-cells = <0>;
+				label = "CORE";
+			};
+		};
+	};
+
 	soc {
 		compatible = "simple-bus";
 		#address-cells = <1>;
@@ -122,6 +153,14 @@ soc {
 		interrupt-parent = <&intc>;
 		ranges;
 
+		sram: sram@10000000 {
+			compatible = "mmio-sram";
+			reg = <0x10000000 0x60000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 0x10000000 0x60000>;
+		};
+
 		timers2: timer@40000000 {
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -129,11 +168,11 @@ timers2: timer@40000000 {
 			reg = <0x40000000 0x400>;
 			clocks = <&rcc TIM2_K>;
 			clock-names = "int";
-			dmas = <&dmamux1 18 0x400 0x1>,
-			       <&dmamux1 19 0x400 0x1>,
-			       <&dmamux1 20 0x400 0x1>,
-			       <&dmamux1 21 0x400 0x1>,
-			       <&dmamux1 22 0x400 0x1>;
+			dmas = <&dmamux1 18 0x400 0x80000001>,
+			       <&dmamux1 19 0x400 0x80000001>,
+			       <&dmamux1 20 0x400 0x80000001>,
+			       <&dmamux1 21 0x400 0x80000001>,
+			       <&dmamux1 22 0x400 0x80000001>;
 			dma-names = "ch1", "ch2", "ch3", "ch4", "up";
 			status = "disabled";
 
@@ -162,12 +201,12 @@ timers3: timer@40001000 {
 			reg = <0x40001000 0x400>;
 			clocks = <&rcc TIM3_K>;
 			clock-names = "int";
-			dmas = <&dmamux1 23 0x400 0x1>,
-			       <&dmamux1 24 0x400 0x1>,
-			       <&dmamux1 25 0x400 0x1>,
-			       <&dmamux1 26 0x400 0x1>,
-			       <&dmamux1 27 0x400 0x1>,
-			       <&dmamux1 28 0x400 0x1>;
+			dmas = <&dmamux1 23 0x400 0x80000001>,
+			       <&dmamux1 24 0x400 0x80000001>,
+			       <&dmamux1 25 0x400 0x80000001>,
+			       <&dmamux1 26 0x400 0x80000001>,
+			       <&dmamux1 27 0x400 0x80000001>,
+			       <&dmamux1 28 0x400 0x80000001>;
 			dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
 			status = "disabled";
 
@@ -196,10 +235,10 @@ timers4: timer@40002000 {
 			reg = <0x40002000 0x400>;
 			clocks = <&rcc TIM4_K>;
 			clock-names = "int";
-			dmas = <&dmamux1 29 0x400 0x1>,
-			       <&dmamux1 30 0x400 0x1>,
-			       <&dmamux1 31 0x400 0x1>,
-			       <&dmamux1 32 0x400 0x1>;
+			dmas = <&dmamux1 29 0x400 0x80000001>,
+			       <&dmamux1 30 0x400 0x80000001>,
+			       <&dmamux1 31 0x400 0x80000001>,
+			       <&dmamux1 32 0x400 0x80000001>;
 			dma-names = "ch1", "ch2", "ch3", "ch4";
 			status = "disabled";
 
@@ -228,12 +267,12 @@ timers5: timer@40003000 {
 			reg = <0x40003000 0x400>;
 			clocks = <&rcc TIM5_K>;
 			clock-names = "int";
-			dmas = <&dmamux1 55 0x400 0x1>,
-			       <&dmamux1 56 0x400 0x1>,
-			       <&dmamux1 57 0x400 0x1>,
-			       <&dmamux1 58 0x400 0x1>,
-			       <&dmamux1 59 0x400 0x1>,
-			       <&dmamux1 60 0x400 0x1>;
+			dmas = <&dmamux1 55 0x400 0x80000001>,
+			       <&dmamux1 56 0x400 0x80000001>,
+			       <&dmamux1 57 0x400 0x80000001>,
+			       <&dmamux1 58 0x400 0x80000001>,
+			       <&dmamux1 59 0x400 0x80000001>,
+			       <&dmamux1 60 0x400 0x80000001>;
 			dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
 			status = "disabled";
 
@@ -262,7 +301,7 @@ timers6: timer@40004000 {
 			reg = <0x40004000 0x400>;
 			clocks = <&rcc TIM6_K>;
 			clock-names = "int";
-			dmas = <&dmamux1 69 0x400 0x1>;
+			dmas = <&dmamux1 69 0x400 0x80000001>;
 			dma-names = "up";
 			status = "disabled";
 
@@ -280,7 +319,7 @@ timers7: timer@40005000 {
 			reg = <0x40005000 0x400>;
 			clocks = <&rcc TIM7_K>;
 			clock-names = "int";
-			dmas = <&dmamux1 70 0x400 0x1>;
+			dmas = <&dmamux1 70 0x400 0x80000001>;
 			dma-names = "up";
 			status = "disabled";
 
@@ -365,6 +404,7 @@ lptimer1: timer@40009000 {
 			interrupts-extended = <&exti 47 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc LPTIM1_K>;
 			clock-names = "mux";
+			power-domains = <&pd_core>;
 			wakeup-source;
 			status = "disabled";
 
@@ -384,6 +424,22 @@ counter {
 				compatible = "st,stm32-lptimer-counter";
 				status = "disabled";
 			};
+
+			timer {
+				compatible = "st,stm32-lptimer-timer";
+				status = "disabled";
+			};
+		};
+
+		i2s2: audio-controller@4000b000 {
+			compatible = "st,stm32h7-i2s";
+			#sound-dai-cells = <0>;
+			reg = <0x4000b000 0x400>;
+			interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmamux1 39 0x400 0x01>,
+			       <&dmamux1 40 0x400 0x01>;
+			dma-names = "rx", "tx";
+			status = "disabled";
 		};
 
 		spi2: spi@4000b000 {
@@ -394,19 +450,19 @@ spi2: spi@4000b000 {
 			interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc SPI2_K>;
 			resets = <&rcc SPI2_R>;
-			dmas = <&dmamux1 39 0x400 0x05>,
-			       <&dmamux1 40 0x400 0x05>;
+			dmas = <&dmamux1 39 0x400 0x01>,
+			       <&dmamux1 40 0x400 0x01>;
 			dma-names = "rx", "tx";
 			status = "disabled";
 		};
 
-		i2s2: audio-controller@4000b000 {
+		i2s3: audio-controller@4000c000 {
 			compatible = "st,stm32h7-i2s";
 			#sound-dai-cells = <0>;
-			reg = <0x4000b000 0x400>;
-			interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
-			dmas = <&dmamux1 39 0x400 0x01>,
-			       <&dmamux1 40 0x400 0x01>;
+			reg = <0x4000c000 0x400>;
+			interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmamux1 61 0x400 0x01>,
+			       <&dmamux1 62 0x400 0x01>;
 			dma-names = "rx", "tx";
 			status = "disabled";
 		};
@@ -419,17 +475,6 @@ spi3: spi@4000c000 {
 			interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc SPI3_K>;
 			resets = <&rcc SPI3_R>;
-			dmas = <&dmamux1 61 0x400 0x05>,
-			       <&dmamux1 62 0x400 0x05>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
-
-		i2s3: audio-controller@4000c000 {
-			compatible = "st,stm32h7-i2s";
-			#sound-dai-cells = <0>;
-			reg = <0x4000c000 0x400>;
-			interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
 			dmas = <&dmamux1 61 0x400 0x01>,
 			       <&dmamux1 62 0x400 0x01>;
 			dma-names = "rx", "tx";
@@ -455,6 +500,10 @@ usart2: serial@4000e000 {
 			interrupts-extended = <&exti 27 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc USART2_K>;
 			wakeup-source;
+			power-domains = <&pd_core>;
+			dmas = <&dmamux1 43 0x400 0x15>,
+			       <&dmamux1 44 0x400 0x11>;
+			dma-names = "rx", "tx";
 			status = "disabled";
 		};
 
@@ -464,6 +513,10 @@ usart3: serial@4000f000 {
 			interrupts-extended = <&exti 28 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc USART3_K>;
 			wakeup-source;
+			power-domains = <&pd_core>;
+			dmas = <&dmamux1 45 0x400 0x15>,
+			       <&dmamux1 46 0x400 0x11>;
+			dma-names = "rx", "tx";
 			status = "disabled";
 		};
 
@@ -473,6 +526,10 @@ uart4: serial@40010000 {
 			interrupts-extended = <&exti 30 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc UART4_K>;
 			wakeup-source;
+			power-domains = <&pd_core>;
+			dmas = <&dmamux1 63 0x400 0x15>,
+			       <&dmamux1 64 0x400 0x11>;
+			dma-names = "rx", "tx";
 			status = "disabled";
 		};
 
@@ -482,6 +539,10 @@ uart5: serial@40011000 {
 			interrupts-extended = <&exti 31 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc UART5_K>;
 			wakeup-source;
+			power-domains = <&pd_core>;
+			dmas = <&dmamux1 65 0x400 0x15>,
+			       <&dmamux1 66 0x400 0x11>;
+			dma-names = "rx", "tx";
 			status = "disabled";
 		};
 
@@ -489,12 +550,16 @@ i2c1: i2c@40012000 {
 			compatible = "st,stm32mp15-i2c";
 			reg = <0x40012000 0x400>;
 			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts-extended = <&exti 21 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc I2C1_K>;
 			resets = <&rcc I2C1_R>;
 			#address-cells = <1>;
 			#size-cells = <0>;
+			dmas = <&dmamux1 33 0x400 0x80000001>,
+			       <&dmamux1 34 0x400 0x80000001>;
+			dma-names = "rx", "tx";
+			power-domains = <&pd_core>;
 			st,syscfg-fmp = <&syscfg 0x4 0x1>;
 			wakeup-source;
 			i2c-analog-filter;
@@ -505,12 +570,16 @@ i2c2: i2c@40013000 {
 			compatible = "st,stm32mp15-i2c";
 			reg = <0x40013000 0x400>;
 			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts-extended = <&exti 22 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc I2C2_K>;
 			resets = <&rcc I2C2_R>;
 			#address-cells = <1>;
 			#size-cells = <0>;
+			dmas = <&dmamux1 35 0x400 0x80000001>,
+			       <&dmamux1 36 0x400 0x80000001>;
+			dma-names = "rx", "tx";
+			power-domains = <&pd_core>;
 			st,syscfg-fmp = <&syscfg 0x4 0x2>;
 			wakeup-source;
 			i2c-analog-filter;
@@ -521,12 +590,16 @@ i2c3: i2c@40014000 {
 			compatible = "st,stm32mp15-i2c";
 			reg = <0x40014000 0x400>;
 			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts-extended = <&exti 23 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc I2C3_K>;
 			resets = <&rcc I2C3_R>;
 			#address-cells = <1>;
 			#size-cells = <0>;
+			dmas = <&dmamux1 73 0x400 0x80000001>,
+			       <&dmamux1 74 0x400 0x80000001>;
+			dma-names = "rx", "tx";
+			power-domains = <&pd_core>;
 			st,syscfg-fmp = <&syscfg 0x4 0x4>;
 			wakeup-source;
 			i2c-analog-filter;
@@ -537,12 +610,16 @@ i2c5: i2c@40015000 {
 			compatible = "st,stm32mp15-i2c";
 			reg = <0x40015000 0x400>;
 			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts-extended = <&exti 25 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc I2C5_K>;
 			resets = <&rcc I2C5_R>;
 			#address-cells = <1>;
 			#size-cells = <0>;
+			dmas = <&dmamux1 115 0x400 0x80000001>,
+			       <&dmamux1 116 0x400 0x80000001>;
+			dma-names = "rx", "tx";
+			power-domains = <&pd_core>;
 			st,syscfg-fmp = <&syscfg 0x4 0x10>;
 			wakeup-source;
 			i2c-analog-filter;
@@ -588,6 +665,10 @@ uart7: serial@40018000 {
 			interrupts-extended = <&exti 32 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc UART7_K>;
 			wakeup-source;
+			power-domains = <&pd_core>;
+			dmas = <&dmamux1 79 0x400 0x15>,
+			       <&dmamux1 80 0x400 0x11>;
+			dma-names = "rx", "tx";
 			status = "disabled";
 		};
 
@@ -597,6 +678,10 @@ uart8: serial@40019000 {
 			interrupts-extended = <&exti 33 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc UART8_K>;
 			wakeup-source;
+			power-domains = <&pd_core>;
+			dmas = <&dmamux1 81 0x400 0x15>,
+			       <&dmamux1 82 0x400 0x11>;
+			dma-names = "rx", "tx";
 			status = "disabled";
 		};
 
@@ -607,13 +692,13 @@ timers1: timer@44000000 {
 			reg = <0x44000000 0x400>;
 			clocks = <&rcc TIM1_K>;
 			clock-names = "int";
-			dmas = <&dmamux1 11 0x400 0x1>,
-			       <&dmamux1 12 0x400 0x1>,
-			       <&dmamux1 13 0x400 0x1>,
-			       <&dmamux1 14 0x400 0x1>,
-			       <&dmamux1 15 0x400 0x1>,
-			       <&dmamux1 16 0x400 0x1>,
-			       <&dmamux1 17 0x400 0x1>;
+			dmas = <&dmamux1 11 0x400 0x80000001>,
+			       <&dmamux1 12 0x400 0x80000001>,
+			       <&dmamux1 13 0x400 0x80000001>,
+			       <&dmamux1 14 0x400 0x80000001>,
+			       <&dmamux1 15 0x400 0x80000001>,
+			       <&dmamux1 16 0x400 0x80000001>,
+			       <&dmamux1 17 0x400 0x80000001>;
 			dma-names = "ch1", "ch2", "ch3", "ch4",
 				    "up", "trig", "com";
 			status = "disabled";
@@ -643,13 +728,13 @@ timers8: timer@44001000 {
 			reg = <0x44001000 0x400>;
 			clocks = <&rcc TIM8_K>;
 			clock-names = "int";
-			dmas = <&dmamux1 47 0x400 0x1>,
-			       <&dmamux1 48 0x400 0x1>,
-			       <&dmamux1 49 0x400 0x1>,
-			       <&dmamux1 50 0x400 0x1>,
-			       <&dmamux1 51 0x400 0x1>,
-			       <&dmamux1 52 0x400 0x1>,
-			       <&dmamux1 53 0x400 0x1>;
+			dmas = <&dmamux1 47 0x400 0x80000001>,
+			       <&dmamux1 48 0x400 0x80000001>,
+			       <&dmamux1 49 0x400 0x80000001>,
+			       <&dmamux1 50 0x400 0x80000001>,
+			       <&dmamux1 51 0x400 0x80000001>,
+			       <&dmamux1 52 0x400 0x80000001>,
+			       <&dmamux1 53 0x400 0x80000001>;
 			dma-names = "ch1", "ch2", "ch3", "ch4",
 				    "up", "trig", "com";
 			status = "disabled";
@@ -678,28 +763,32 @@ usart6: serial@44003000 {
 			interrupts-extended = <&exti 29 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc USART6_K>;
 			wakeup-source;
+			power-domains = <&pd_core>;
+			dmas = <&dmamux1 71 0x400 0x15>,
+			       <&dmamux1 72 0x400 0x11>;
+			dma-names = "rx", "tx";
 			status = "disabled";
 		};
 
-		spi1: spi@44004000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32h7-spi";
+		i2s1: audio-controller@44004000 {
+			compatible = "st,stm32h7-i2s";
+			#sound-dai-cells = <0>;
 			reg = <0x44004000 0x400>;
 			interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI1_K>;
-			resets = <&rcc SPI1_R>;
-			dmas = <&dmamux1 37 0x400 0x05>,
-			       <&dmamux1 38 0x400 0x05>;
+			dmas = <&dmamux1 37 0x400 0x01>,
+			       <&dmamux1 38 0x400 0x01>;
 			dma-names = "rx", "tx";
 			status = "disabled";
 		};
 
-		i2s1: audio-controller@44004000 {
-			compatible = "st,stm32h7-i2s";
-			#sound-dai-cells = <0>;
+		spi1: spi@44004000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32h7-spi";
 			reg = <0x44004000 0x400>;
 			interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc SPI1_K>;
+			resets = <&rcc SPI1_R>;
 			dmas = <&dmamux1 37 0x400 0x01>,
 			       <&dmamux1 38 0x400 0x01>;
 			dma-names = "rx", "tx";
@@ -714,8 +803,8 @@ spi4: spi@44005000 {
 			interrupts = <GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc SPI4_K>;
 			resets = <&rcc SPI4_R>;
-			dmas = <&dmamux1 83 0x400 0x05>,
-			       <&dmamux1 84 0x400 0x05>;
+			dmas = <&dmamux1 83 0x400 0x01>,
+			       <&dmamux1 84 0x400 0x01>;
 			dma-names = "rx", "tx";
 			status = "disabled";
 		};
@@ -727,10 +816,10 @@ timers15: timer@44006000 {
 			reg = <0x44006000 0x400>;
 			clocks = <&rcc TIM15_K>;
 			clock-names = "int";
-			dmas = <&dmamux1 105 0x400 0x1>,
-			       <&dmamux1 106 0x400 0x1>,
-			       <&dmamux1 107 0x400 0x1>,
-			       <&dmamux1 108 0x400 0x1>;
+			dmas = <&dmamux1 105 0x400 0x80000001>,
+			       <&dmamux1 106 0x400 0x80000001>,
+			       <&dmamux1 107 0x400 0x80000001>,
+			       <&dmamux1 108 0x400 0x80000001>;
 			dma-names = "ch1", "up", "trig", "com";
 			status = "disabled";
 
@@ -754,8 +843,8 @@ timers16: timer@44007000 {
 			reg = <0x44007000 0x400>;
 			clocks = <&rcc TIM16_K>;
 			clock-names = "int";
-			dmas = <&dmamux1 109 0x400 0x1>,
-			       <&dmamux1 110 0x400 0x1>;
+			dmas = <&dmamux1 109 0x400 0x80000001>,
+			       <&dmamux1 110 0x400 0x80000001>;
 			dma-names = "ch1", "up";
 			status = "disabled";
 
@@ -778,8 +867,8 @@ timers17: timer@44008000 {
 			reg = <0x44008000 0x400>;
 			clocks = <&rcc TIM17_K>;
 			clock-names = "int";
-			dmas = <&dmamux1 111 0x400 0x1>,
-			       <&dmamux1 112 0x400 0x1>;
+			dmas = <&dmamux1 111 0x400 0x80000001>,
+			       <&dmamux1 112 0x400 0x80000001>;
 			dma-names = "ch1", "up";
 			status = "disabled";
 
@@ -804,8 +893,8 @@ spi5: spi@44009000 {
 			interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc SPI5_K>;
 			resets = <&rcc SPI5_R>;
-			dmas = <&dmamux1 85 0x400 0x05>,
-			       <&dmamux1 86 0x400 0x05>;
+			dmas = <&dmamux1 85 0x400 0x01>,
+			       <&dmamux1 86 0x400 0x01>;
 			dma-names = "rx", "tx";
 			status = "disabled";
 		};
@@ -990,6 +1079,15 @@ dma1: dma-controller@48000000 {
 			#dma-cells = <4>;
 			st,mem2mem;
 			dma-requests = <8>;
+			dmas = <&mdma1 0 0x3 0x1200000a 0x48000008 0x00000020 1>,
+			       <&mdma1 1 0x3 0x1200000a 0x48000008 0x00000800 1>,
+			       <&mdma1 2 0x3 0x1200000a 0x48000008 0x00200000 1>,
+			       <&mdma1 3 0x3 0x1200000a 0x48000008 0x08000000 1>,
+			       <&mdma1 4 0x3 0x1200000a 0x4800000C 0x00000020 1>,
+			       <&mdma1 5 0x3 0x1200000a 0x4800000C 0x00000800 1>,
+			       <&mdma1 6 0x3 0x1200000a 0x4800000C 0x00200000 1>,
+			       <&mdma1 7 0x3 0x1200000a 0x4800000C 0x08000000 1>;
+			dma-names = "ch0", "ch1", "ch2", "ch3", "ch4", "ch5", "ch6", "ch7";
 		};
 
 		dma2: dma-controller@48001000 {
@@ -1008,6 +1106,15 @@ dma2: dma-controller@48001000 {
 			#dma-cells = <4>;
 			st,mem2mem;
 			dma-requests = <8>;
+			dmas = <&mdma1 8 0x3 0x1200000a 0x48001008 0x00000020 1>,
+			       <&mdma1 9 0x3 0x1200000a 0x48001008 0x00000800 1>,
+			       <&mdma1 10 0x3 0x1200000a 0x48001008 0x00200000 1>,
+			       <&mdma1 11 0x3 0x1200000a 0x48001008 0x08000000 1>,
+			       <&mdma1 12 0x3 0x1200000a 0x4800100C 0x00000020 1>,
+			       <&mdma1 13 0x3 0x1200000a 0x4800100C 0x00000800 1>,
+			       <&mdma1 14 0x3 0x1200000a 0x4800100C 0x00200000 1>,
+			       <&mdma1 15 0x3 0x1200000a 0x4800100C 0x08000000 1>;
+			dma-names = "ch0", "ch1", "ch2", "ch3", "ch4", "ch5", "ch6", "ch7";
 		};
 
 		dmamux1: dma-router@48002000 {
@@ -1038,10 +1145,12 @@ adc: adc@48003000 {
 			adc1: adc@0 {
 				compatible = "st,stm32mp1-adc";
 				#io-channel-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
 				reg = <0x0>;
 				interrupt-parent = <&adc>;
 				interrupts = <0>;
-				dmas = <&dmamux1 9 0x400 0x01>;
+				dmas = <&dmamux1 9 0x400 0x80000001>;
 				dma-names = "rx";
 				status = "disabled";
 			};
@@ -1049,17 +1158,29 @@ adc1: adc@0 {
 			adc2: adc@100 {
 				compatible = "st,stm32mp1-adc";
 				#io-channel-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
 				reg = <0x100>;
 				interrupt-parent = <&adc>;
 				interrupts = <1>;
-				dmas = <&dmamux1 10 0x400 0x01>;
+				dmas = <&dmamux1 10 0x400 0x80000001>;
 				dma-names = "rx";
+				nvmem-cells = <&vrefint>;
+				nvmem-cell-names = "vrefint";
 				status = "disabled";
+				channel@13 {
+					reg = <13>;
+					label = "vrefint";
+				};
+				channel@14 {
+					reg = <14>;
+					label = "vddcore";
+				};
 			};
 		};
 
 		sdmmc3: mmc@48004000 {
-			compatible = "arm,pl18x", "arm,primecell";
+			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
 			arm,primecell-periphid = <0x00253180>;
 			reg = <0x48004000 0x400>;
 			interrupts = <GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>;
@@ -1080,27 +1201,38 @@ usbotg_hs: usb-otg@49000000 {
 			clock-names = "otg";
 			resets = <&rcc USBO_R>;
 			reset-names = "dwc2";
-			interrupts = <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts-extended = <&exti 44 IRQ_TYPE_LEVEL_HIGH>;
 			g-rx-fifo-size = <512>;
 			g-np-tx-fifo-size = <32>;
 			g-tx-fifo-size = <256 16 16 16 16 16 16 16>;
 			dr_mode = "otg";
+			otg-rev = <0x200>;
 			usb33d-supply = <&usb33>;
+			power-domains = <&pd_core>;
+			wakeup-source;
 			status = "disabled";
 		};
 
+		hsem: hwspinlock@4c000000 {
+			compatible = "st,stm32-hwspinlock";
+			#hwlock-cells = <2>;
+			reg = <0x4c000000 0x400>;
+			clocks = <&rcc HSEM>;
+			clock-names = "hsem";
+		};
+
 		ipcc: mailbox@4c001000 {
 			compatible = "st,stm32mp1-ipcc";
 			#mbox-cells = <1>;
 			reg = <0x4c001000 0x400>;
 			st,proc-id = <0>;
 			interrupts-extended =
-				<&intc GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>,
-				<&intc GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>,
-				<&exti 61 1>;
-			interrupt-names = "rx", "tx", "wakeup";
+				<&exti 61 1>,
+				<&intc GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "rx", "tx";
 			clocks = <&rcc IPCC>;
 			wakeup-source;
+			power-domains = <&pd_core>;
 			status = "disabled";
 		};
 
@@ -1111,21 +1243,29 @@ dcmi: dcmi@4c006000 {
 			resets = <&rcc CAMITF_R>;
 			clocks = <&rcc DCMI>;
 			clock-names = "mclk";
-			dmas = <&dmamux1 75 0x400 0x01>;
+			dmas = <&dmamux1 75 0x400 0xe0000001>;
 			dma-names = "tx";
 			status = "disabled";
 		};
 
 		rcc: rcc@50000000 {
-			compatible = "st,stm32mp1-rcc", "syscon";
+			compatible = "st,stm32mp1-rcc-secure", "st,stm32mp1-rcc", "syscon";
 			reg = <0x50000000 0x1000>;
 			#clock-cells = <1>;
 			#reset-cells = <1>;
+
+			clock-names = "hse", "hsi", "csi", "lse", "lsi";
+			clocks = <&scmi_clk CK_SCMI_HSE>,
+				 <&scmi_clk CK_SCMI_HSI>,
+				 <&scmi_clk CK_SCMI_CSI>,
+				 <&scmi_clk CK_SCMI_LSE>,
+				 <&scmi_clk CK_SCMI_LSI>;
 		};
 
 		pwr_regulators: pwr@50001000 {
 			compatible = "st,stm32mp1,pwr-reg";
 			reg = <0x50001000 0x10>;
+			st,tzcr = <&rcc 0x0 0x1>;
 
 			reg11: reg11 {
 				regulator-name = "reg11";
@@ -1151,11 +1291,87 @@ pwr_mcu: pwr_mcu@50001014 {
 			reg = <0x50001014 0x4>;
 		};
 
+		pwr_irq: pwr@50001020 {
+			compatible = "st,stm32mp1-pwr";
+			reg = <0x50001020 0x100>;
+			interrupts = <GIC_SPI 149 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-controller;
+			#interrupt-cells = <3>;
+
+			st,wakeup-pins = <&gpioa 0 GPIO_ACTIVE_HIGH>,
+					 <&gpioa 2 GPIO_ACTIVE_HIGH>,
+					 <&gpioc 13 GPIO_ACTIVE_HIGH>,
+					 <&gpioi 8 GPIO_ACTIVE_HIGH>,
+					 <&gpioi 11 GPIO_ACTIVE_HIGH>,
+					 <&gpioc 1 GPIO_ACTIVE_HIGH>;
+		};
+
 		exti: interrupt-controller@5000d000 {
 			compatible = "st,stm32mp1-exti", "syscon";
 			interrupt-controller;
 			#interrupt-cells = <2>;
+			#address-cells = <0>;
 			reg = <0x5000d000 0x400>;
+			hwlocks = <&hsem 1 1>;
+			wakeup-parent = <&pwr_irq>;
+
+			exti-interrupt-map {
+				#address-cells = <0>;
+				#interrupt-cells = <2>;
+				interrupt-map-mask = <0xffffffff 0>;
+				interrupt-map =
+					<0  0 &intc GIC_SPI 6   IRQ_TYPE_LEVEL_HIGH>,
+					<1  0 &intc GIC_SPI 7   IRQ_TYPE_LEVEL_HIGH>,
+					<2  0 &intc GIC_SPI 8   IRQ_TYPE_LEVEL_HIGH>,
+					<3  0 &intc GIC_SPI 9   IRQ_TYPE_LEVEL_HIGH>,
+					<4  0 &intc GIC_SPI 10  IRQ_TYPE_LEVEL_HIGH>,
+					<5  0 &intc GIC_SPI 23  IRQ_TYPE_LEVEL_HIGH>,
+					<6  0 &intc GIC_SPI 64  IRQ_TYPE_LEVEL_HIGH>,
+					<7  0 &intc GIC_SPI 65  IRQ_TYPE_LEVEL_HIGH>,
+					<8  0 &intc GIC_SPI 66  IRQ_TYPE_LEVEL_HIGH>,
+					<9  0 &intc GIC_SPI 67  IRQ_TYPE_LEVEL_HIGH>,
+					<10 0 &intc GIC_SPI 40  IRQ_TYPE_LEVEL_HIGH>,
+					<11 0 &intc GIC_SPI 42  IRQ_TYPE_LEVEL_HIGH>,
+					<12 0 &intc GIC_SPI 76  IRQ_TYPE_LEVEL_HIGH>,
+					<13 0 &intc GIC_SPI 77  IRQ_TYPE_LEVEL_HIGH>,
+					<14 0 &intc GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>,
+					<15 0 &intc GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>,
+					<16 0 &intc GIC_SPI 1   IRQ_TYPE_LEVEL_HIGH>,
+					<19 0 &intc GIC_SPI 3   IRQ_TYPE_LEVEL_HIGH>,
+					<21 0 &intc GIC_SPI 31  IRQ_TYPE_LEVEL_HIGH>,
+					<22 0 &intc GIC_SPI 33  IRQ_TYPE_LEVEL_HIGH>,
+					<23 0 &intc GIC_SPI 72  IRQ_TYPE_LEVEL_HIGH>,
+					<24 0 &intc GIC_SPI 95  IRQ_TYPE_LEVEL_HIGH>,
+					<25 0 &intc GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>,
+					<26 0 &intc GIC_SPI 37  IRQ_TYPE_LEVEL_HIGH>,
+					<27 0 &intc GIC_SPI 38  IRQ_TYPE_LEVEL_HIGH>,
+					<28 0 &intc GIC_SPI 39  IRQ_TYPE_LEVEL_HIGH>,
+					<29 0 &intc GIC_SPI 71  IRQ_TYPE_LEVEL_HIGH>,
+					<30 0 &intc GIC_SPI 52  IRQ_TYPE_LEVEL_HIGH>,
+					<31 0 &intc GIC_SPI 53  IRQ_TYPE_LEVEL_HIGH>,
+					<32 0 &intc GIC_SPI 82  IRQ_TYPE_LEVEL_HIGH>,
+					<33 0 &intc GIC_SPI 83  IRQ_TYPE_LEVEL_HIGH>,
+					<43 0 &intc GIC_SPI 75  IRQ_TYPE_LEVEL_HIGH>,
+					<44 0 &intc GIC_SPI 98  IRQ_TYPE_LEVEL_HIGH>,
+					<47 0 &intc GIC_SPI 93  IRQ_TYPE_LEVEL_HIGH>,
+					<48 0 &intc GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>,
+					<50 0 &intc GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>,
+					<52 0 &intc GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>,
+					<53 0 &intc GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>,
+					<54 0 &intc GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>,
+					<55 0 &pwr_irq 0 IRQ_TYPE_EDGE_FALLING 0>,
+					<56 0 &pwr_irq 1 IRQ_TYPE_EDGE_FALLING 0>,
+					<57 0 &pwr_irq 2 IRQ_TYPE_EDGE_FALLING 0>,
+					<58 0 &pwr_irq 3 IRQ_TYPE_EDGE_FALLING 0>,
+					<59 0 &pwr_irq 4 IRQ_TYPE_EDGE_FALLING 0>,
+					<60 0 &pwr_irq 5 IRQ_TYPE_EDGE_FALLING 0>,
+					<61 0 &intc GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>,
+					<65 0 &intc GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH>,
+					<68 0 &intc GIC_SPI 143 IRQ_TYPE_LEVEL_HIGH>,
+					<69 0 &intc GIC_SPI 94  IRQ_TYPE_LEVEL_HIGH>,
+					<70 0 &intc GIC_SPI 62  IRQ_TYPE_LEVEL_HIGH>,
+					<73 0 &intc GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>;
+			};
 		};
 
 		syscfg: syscon@50020000 {
@@ -1172,6 +1388,7 @@ lptimer2: timer@50021000 {
 			interrupts-extended = <&exti 48 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc LPTIM2_K>;
 			clock-names = "mux";
+			power-domains = <&pd_core>;
 			wakeup-source;
 			status = "disabled";
 
@@ -1191,6 +1408,11 @@ counter {
 				compatible = "st,stm32-lptimer-counter";
 				status = "disabled";
 			};
+
+			timer {
+				compatible = "st,stm32-lptimer-timer";
+				status = "disabled";
+			};
 		};
 
 		lptimer3: timer@50022000 {
@@ -1201,6 +1423,7 @@ lptimer3: timer@50022000 {
 			interrupts-extended = <&exti 50 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc LPTIM3_K>;
 			clock-names = "mux";
+			power-domains = <&pd_core>;
 			wakeup-source;
 			status = "disabled";
 
@@ -1215,6 +1438,11 @@ trigger@2 {
 				reg = <2>;
 				status = "disabled";
 			};
+
+			timer {
+				compatible = "st,stm32-lptimer-timer";
+				status = "disabled";
+			};
 		};
 
 		lptimer4: timer@50023000 {
@@ -1223,6 +1451,7 @@ lptimer4: timer@50023000 {
 			interrupts-extended = <&exti 52 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc LPTIM4_K>;
 			clock-names = "mux";
+			power-domains = <&pd_core>;
 			wakeup-source;
 			status = "disabled";
 
@@ -1231,6 +1460,11 @@ pwm {
 				#pwm-cells = <3>;
 				status = "disabled";
 			};
+
+			timer {
+				compatible = "st,stm32-lptimer-timer";
+				status = "disabled";
+			};
 		};
 
 		lptimer5: timer@50024000 {
@@ -1239,6 +1473,7 @@ lptimer5: timer@50024000 {
 			interrupts-extended = <&exti 53 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc LPTIM5_K>;
 			clock-names = "mux";
+			power-domains = <&pd_core>;
 			wakeup-source;
 			status = "disabled";
 
@@ -1247,6 +1482,11 @@ pwm {
 				#pwm-cells = <3>;
 				status = "disabled";
 			};
+
+			timer {
+				compatible = "st,stm32-lptimer-timer";
+				status = "disabled";
+			};
 		};
 
 		vrefbuf: vrefbuf@50025000 {
@@ -1299,13 +1539,21 @@ dts: thermal@50028000 {
 			status = "disabled";
 		};
 
+		hdp: hdp@5002a000 {
+			compatible = "st,stm32mp1-hdp";
+			reg = <0x5002a000 0x400>;
+			clocks = <&rcc HDP>;
+			clock-names = "hdp";
+			status = "disabled";
+		};
+
 		hash1: hash@54002000 {
 			compatible = "st,stm32f756-hash";
 			reg = <0x54002000 0x400>;
 			interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc HASH1>;
-			resets = <&rcc HASH1_R>;
-			dmas = <&mdma1 31 0x2 0x1000A02 0x0 0x0>;
+			clocks = <&scmi_clk CK_SCMI_HASH1>;
+			resets = <&scmi_reset RST_SCMI_HASH1>;
+			dmas = <&mdma1 31 0x2 0x1000A02 0x0 0x0 0x0>;
 			dma-names = "in";
 			dma-maxburst = <2>;
 			status = "disabled";
@@ -1314,8 +1562,8 @@ hash1: hash@54002000 {
 		rng1: rng@54003000 {
 			compatible = "st,stm32-rng";
 			reg = <0x54003000 0x400>;
-			clocks = <&rcc RNG1_K>;
-			resets = <&rcc RNG1_R>;
+			clocks = <&scmi_clk CK_SCMI_RNG1>;
+			resets = <&scmi_reset RST_SCMI_RNG1>;
 			status = "disabled";
 		};
 
@@ -1324,8 +1572,8 @@ mdma1: dma-controller@58000000 {
 			reg = <0x58000000 0x1000>;
 			interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc MDMA>;
-			resets = <&rcc MDMA_R>;
-			#dma-cells = <5>;
+			resets = <&scmi_reset RST_SCMI_MDMA>;
+			#dma-cells = <6>;
 			dma-channels = <32>;
 			dma-requests = <48>;
 		};
@@ -1356,9 +1604,9 @@ nand-controller@4,0 {
 				      <4 0x09010000 0x1000>,
 				      <4 0x09020000 0x1000>;
 				interrupts = <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&mdma1 20 0x2 0x12000a02 0x0 0x0>,
-				       <&mdma1 20 0x2 0x12000a08 0x0 0x0>,
-				       <&mdma1 21 0x2 0x12000a0a 0x0 0x0>;
+				dmas = <&mdma1 20 0x2 0x12000a02 0x0 0x0 0x0>,
+				       <&mdma1 20 0x2 0x12000a08 0x0 0x0 0x0>,
+				       <&mdma1 21 0x2 0x12000a0a 0x0 0x0 0x0>;
 				dma-names = "tx", "rx", "ecc";
 				status = "disabled";
 			};
@@ -1369,8 +1617,8 @@ qspi: spi@58003000 {
 			reg = <0x58003000 0x1000>, <0x70000000 0x10000000>;
 			reg-names = "qspi", "qspi_mm";
 			interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
-			dmas = <&mdma1 22 0x2 0x10100002 0x0 0x0>,
-			       <&mdma1 22 0x2 0x10100008 0x0 0x0>;
+			dmas = <&mdma1 22 0x2 0x10100002 0x0 0x0 0x0>,
+			       <&mdma1 22 0x2 0x10100008 0x0 0x0 0x0>;
 			dma-names = "tx", "rx";
 			clocks = <&rcc QSPI_K>;
 			resets = <&rcc QSPI_R>;
@@ -1380,7 +1628,7 @@ qspi: spi@58003000 {
 		};
 
 		sdmmc1: mmc@58005000 {
-			compatible = "arm,pl18x", "arm,primecell";
+			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
 			arm,primecell-periphid = <0x00253180>;
 			reg = <0x58005000 0x1000>;
 			interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
@@ -1395,7 +1643,7 @@ sdmmc1: mmc@58005000 {
 		};
 
 		sdmmc2: mmc@58007000 {
-			compatible = "arm,pl18x", "arm,primecell";
+			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
 			arm,primecell-periphid = <0x00253180>;
 			reg = <0x58007000 0x1000>;
 			interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
@@ -1420,8 +1668,10 @@ ethernet0: ethernet@5800a000 {
 			compatible = "st,stm32mp1-dwmac", "snps,dwmac-4.20a";
 			reg = <0x5800a000 0x2000>;
 			reg-names = "stmmaceth";
-			interrupts-extended = <&intc GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "macirq";
+			interrupts-extended = <&intc GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>,
+					      <&exti 70 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq",
+					  "eth_wake_irq";
 			clock-names = "stmmaceth",
 				      "mac-clk-tx",
 				      "mac-clk-rx",
@@ -1441,6 +1691,7 @@ ethernet0: ethernet@5800a000 {
 			snps,axi-config = <&stmmac_axi_config_0>;
 			snps,tso;
 			status = "disabled";
+			power-domains = <&pd_core>;
 
 			stmmac_axi_config_0: stmmac-axi-config {
 				snps,wr_osr_lmt = <0x7>;
@@ -1463,8 +1714,10 @@ usbh_ehci: usb@5800d000 {
 			reg = <0x5800d000 0x1000>;
 			clocks = <&usbphyc>, <&rcc USBH>;
 			resets = <&rcc USBH_R>;
-			interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts-extended = <&exti 43 IRQ_TYPE_LEVEL_HIGH>;
 			companion = <&usbh_ohci>;
+			power-domains = <&pd_core>;
+			wakeup-source;
 			status = "disabled";
 		};
 
@@ -1487,7 +1740,7 @@ port {
 		iwdg2: watchdog@5a002000 {
 			compatible = "st,stm32mp1-iwdg";
 			reg = <0x5a002000 0x400>;
-			clocks = <&rcc IWDG2>, <&rcc CK_LSI>;
+			clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
 			clock-names = "pclk", "lsi";
 			status = "disabled";
 		};
@@ -1515,12 +1768,21 @@ usbphyc_port1: usb-phy@1 {
 			};
 		};
 
+		ddrperfm: perf@5a007000 {
+			compatible = "st,stm32-ddr-pmu";
+			reg = <0x5a007000 0x400>;
+			clocks = <&rcc DDRPERFM>;
+			resets = <&rcc DDRPERFM_R>;
+			status = "disabled";
+		};
+
 		usart1: serial@5c000000 {
 			compatible = "st,stm32h7-uart";
 			reg = <0x5c000000 0x400>;
 			interrupts-extended = <&exti 26 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc USART1_K>;
+			clocks = <&scmi_clk CK_SCMI_USART1>;
 			wakeup-source;
+			power-domains = <&pd_core>;
 			status = "disabled";
 		};
 
@@ -1530,10 +1792,10 @@ spi6: spi@5c001000 {
 			compatible = "st,stm32h7-spi";
 			reg = <0x5c001000 0x400>;
 			interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI6_K>;
-			resets = <&rcc SPI6_R>;
-			dmas = <&mdma1 34 0x0 0x40008 0x0 0x0>,
-			       <&mdma1 35 0x0 0x40002 0x0 0x0>;
+			clocks = <&scmi_clk CK_SCMI_SPI6>;
+			resets = <&scmi_reset RST_SCMI_SPI6>;
+			dmas = <&mdma1 34 0x0 0x40008 0x0 0x0 0x0>,
+			       <&mdma1 35 0x0 0x40002 0x0 0x0 0x0>;
 			dma-names = "rx", "tx";
 			status = "disabled";
 		};
@@ -1542,12 +1804,16 @@ i2c4: i2c@5c002000 {
 			compatible = "st,stm32mp15-i2c";
 			reg = <0x5c002000 0x400>;
 			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C4_K>;
-			resets = <&rcc I2C4_R>;
+			interrupts-extended = <&exti 24 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_I2C4>;
+			resets = <&scmi_reset RST_SCMI_I2C4>;
 			#address-cells = <1>;
 			#size-cells = <0>;
+			dmas = <&mdma1 36 0x0 0x40008 0x0 0x0 0>,
+			       <&mdma1 37 0x0 0x40002 0x0 0x0 0>;
+			dma-names = "rx", "tx";
+			power-domains = <&pd_core>;
 			st,syscfg-fmp = <&syscfg 0x4 0x8>;
 			wakeup-source;
 			i2c-analog-filter;
@@ -1557,35 +1823,50 @@ i2c4: i2c@5c002000 {
 		rtc: rtc@5c004000 {
 			compatible = "st,stm32mp1-rtc";
 			reg = <0x5c004000 0x400>;
-			clocks = <&rcc RTCAPB>, <&rcc RTC>;
+			clocks = <&scmi_clk CK_SCMI_RTCAPB>,
+				 <&scmi_clk CK_SCMI_RTC>;
 			clock-names = "pclk", "rtc_ck";
-			interrupts = <GIC_SPI 3 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts-extended = <&exti 19 IRQ_TYPE_LEVEL_HIGH>;
 			status = "disabled";
 		};
 
 		bsec: efuse@5c005000 {
 			compatible = "st,stm32mp15-bsec";
 			reg = <0x5c005000 0x400>;
+			clocks = <&scmi_clk CK_SCMI_BSEC>;
 			#address-cells = <1>;
 			#size-cells = <1>;
+			part_number_otp: part_number_otp@4 {
+				reg = <0x4 0x1>;
+			};
+			vrefint: calib@52 {
+				reg = <0x52 0x2>;
+			};
 			ts_cal1: calib@5c {
 				reg = <0x5c 0x2>;
 			};
 			ts_cal2: calib@5e {
 				reg = <0x5e 0x2>;
 			};
+			ethernet_mac_address: mac@e4 {
+				reg = <0xe4 0x6>;
+			};
 		};
 
 		i2c6: i2c@5c009000 {
 			compatible = "st,stm32mp15-i2c";
 			reg = <0x5c009000 0x400>;
 			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C6_K>;
-			resets = <&rcc I2C6_R>;
+			interrupts-extended = <&exti 54 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_I2C6>;
+			resets = <&scmi_reset RST_SCMI_I2C6>;
 			#address-cells = <1>;
 			#size-cells = <0>;
+			dmas = <&mdma1 38 0x0 0x40008 0x0 0x0 0>,
+			       <&mdma1 39 0x0 0x40002 0x0 0x0 0>;
+			dma-names = "rx", "tx";
+			power-domains = <&pd_core>;
 			st,syscfg-fmp = <&syscfg 0x4 0x20>;
 			wakeup-source;
 			i2c-analog-filter;
@@ -1595,19 +1876,33 @@ i2c6: i2c@5c009000 {
 		tamp: tamp@5c00a000 {
 			compatible = "st,stm32-tamp", "syscon", "simple-mfd";
 			reg = <0x5c00a000 0x400>;
+
+			reboot-mode {
+				compatible = "syscon-reboot-mode";
+				offset = <0x150>; /* reg20 */
+				mask = <0xff>;
+				mode-normal = <0>;
+				mode-fastboot = <0x1>;
+				mode-recovery = <0x2>;
+				mode-stm32cubeprogrammer = <0x3>;
+				mode-ums_mmc0 = <0x10>;
+				mode-ums_mmc1 = <0x11>;
+				mode-ums_mmc2 = <0x12>;
+			};
 		};
 
 		/*
 		 * Break node order to solve dependency probe issue between
 		 * pinctrl and exti.
 		 */
-		pinctrl: pin-controller@50002000 {
+		pinctrl: pinctrl@50002000 {
 			#address-cells = <1>;
 			#size-cells = <1>;
 			compatible = "st,stm32mp157-pinctrl";
 			ranges = <0 0x50002000 0xa400>;
 			interrupt-parent = <&exti>;
 			st,syscfg = <&exti 0x60 0xff>;
+			hwlocks = <&hsem 0 1>;
 			pins-are-numbered;
 
 			gpioa: gpio@50002000 {
@@ -1732,7 +2027,7 @@ gpiok: gpio@5000c000 {
 			};
 		};
 
-		pinctrl_z: pin-controller-z@54004000 {
+		pinctrl_z: pinctrl@54004000 {
 			#address-cells = <1>;
 			#size-cells = <1>;
 			compatible = "st,stm32mp157-z-pinctrl";
@@ -1740,6 +2035,7 @@ pinctrl_z: pin-controller-z@54004000 {
 			pins-are-numbered;
 			interrupt-parent = <&exti>;
 			st,syscfg = <&exti 0x60 0xff>;
+			hwlocks = <&hsem 0 1>;
 
 			gpioz: gpio@54004000 {
 				gpio-controller;
@@ -1747,7 +2043,7 @@ gpioz: gpio@54004000 {
 				interrupt-controller;
 				#interrupt-cells = <2>;
 				reg = <0 0x400>;
-				clocks = <&rcc GPIOZ>;
+				clocks = <&scmi_clk CK_SCMI_GPIOZ>;
 				st,bank-name = "GPIOZ";
 				st,bank-ioport = <11>;
 				status = "disabled";
@@ -1769,13 +2065,18 @@ m4_rproc: m4@10000000 {
 			reg = <0x10000000 0x40000>,
 			      <0x30000000 0x40000>,
 			      <0x38000000 0x10000>;
-			resets = <&rcc MCU_R>;
-			st,syscfg-holdboot = <&rcc 0x10C 0x1>;
-			st,syscfg-tz = <&rcc 0x000 0x1>;
+			resets = <&scmi_reset RST_SCMI_MCU>,
+				 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+			reset-names = "mcu_rst", "hold_boot";
 			st,syscfg-pdds = <&pwr_mcu 0x0 0x1>;
 			st,syscfg-rsc-tbl = <&tamp 0x144 0xFFFFFFFF>;
 			st,syscfg-m4-state = <&tamp 0x148 0xFFFFFFFF>;
 			status = "disabled";
+
+			m4_system_resources {
+				compatible = "rproc-srm-core";
+				status = "disabled";
+			};
 		};
 	};
 };
diff --git a/arch/arm/boot/dts/stm32mp153.dtsi b/arch/arm/boot/dts/stm32mp153.dtsi
index 1c1889b19..56ff32b4a 100644
--- a/arch/arm/boot/dts/stm32mp153.dtsi
+++ b/arch/arm/boot/dts/stm32mp153.dtsi
@@ -10,9 +10,11 @@ / {
 	cpus {
 		cpu1: cpu@1 {
 			compatible = "arm,cortex-a7";
-			clock-frequency = <650000000>;
 			device_type = "cpu";
 			reg = <1>;
+			clocks = <&scmi_clk CK_SCMI_MPU>;
+			clock-names = "cpu";
+			operating-points-v2 = <&cpu0_opp_table>;
 		};
 	};
 
@@ -22,6 +24,13 @@ arm-pmu {
 		interrupt-affinity = <&cpu0>, <&cpu1>;
 	};
 
+	timer {
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>;
+	};
+
 	soc {
 		m_can1: can@4400e000 {
 			compatible = "bosch,m_can";
@@ -30,7 +39,7 @@ m_can1: can@4400e000 {
 			interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
 			interrupt-names = "int0", "int1";
-			clocks = <&rcc CK_HSE>, <&rcc FDCAN_K>;
+			clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
 			clock-names = "hclk", "cclk";
 			bosch,mram-cfg = <0x0 0 0 32 0 0 2 2>;
 			status = "disabled";
@@ -43,7 +52,7 @@ m_can2: can@4400f000 {
 			interrupts = <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>;
 			interrupt-names = "int0", "int1";
-			clocks = <&rcc CK_HSE>, <&rcc FDCAN_K>;
+			clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
 			clock-names = "hclk", "cclk";
 			bosch,mram-cfg = <0x1400 0 0 32 0 0 2 2>;
 			status = "disabled";
diff --git a/arch/arm/boot/dts/stm32mp157.dtsi b/arch/arm/boot/dts/stm32mp157.dtsi
index 54e73ccea..1d82868f3 100644
--- a/arch/arm/boot/dts/stm32mp157.dtsi
+++ b/arch/arm/boot/dts/stm32mp157.dtsi
@@ -20,7 +20,8 @@ gpu: gpu@59000000 {
 		dsi: dsi@5a000000 {
 			compatible = "st,stm32-dsi";
 			reg = <0x5a000000 0x800>;
-			clocks = <&rcc DSI_K>, <&clk_hse>, <&rcc DSI_PX>;
+			phy-dsi-supply = <&reg18>;
+			clocks = <&rcc DSI_K>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
 			clock-names = "pclk", "ref", "px_clk";
 			resets = <&rcc DSI_R>;
 			reset-names = "apb";
diff --git a/arch/arm/boot/dts/stm32mp157a-dk1-a7-examples.dts b/arch/arm/boot/dts/stm32mp157a-dk1-a7-examples.dts
new file mode 100644
index 000000000..f58b679ef
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157a-dk1-a7-examples.dts
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Amelie Delaunay <amelie.delaunay@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157a-dk1.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157A-DK1 configured to run Linux A7 examples";
+	compatible = "st,stm32mp157a-dk1-a7-examples", "st,stm32mp157a-dk1", "st,stm32mp157";
+};
+
+&adc {
+	pinctrl-0 = <&adc12_ain_pins_a>, <&adc12_usb_cc_pins_a>;
+
+	adc1: adc@0 {
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@13 {
+			reg = <13>;
+			st,min-sample-time-ns = <5000>;
+		};
+	};
+
+	adc2: adc@100 {
+		/* Set IRQ mode as example. DMA is the preferred mode, yet. */
+		/delete-property/dmas;
+		/delete-property/dma-names;
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@2 {
+			reg = <2>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <5000>;
+		};
+	};
+};
+
+&i2c5 {
+	status = "okay";
+};
+
+&timers1 {
+	status = "okay";
+};
+
+&timers3 {
+	status = "okay";
+};
+
+&timers4 {
+	status = "okay";
+};
+
+&timers5 {
+	status = "okay";
+};
+
+&timers6 {
+	status = "okay";
+};
+
+&timers12 {
+	status = "okay";
+};
+
+&uart7 {
+	status = "okay";
+};
+
+&usart3 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/stm32mp157a-dk1-m4-examples.dts b/arch/arm/boot/dts/stm32mp157a-dk1-m4-examples.dts
new file mode 100644
index 000000000..a6e9e1af9
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157a-dk1-m4-examples.dts
@@ -0,0 +1,128 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Amelie Delaunay <amelie.delaunay@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157a-dk1.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157A-DK1 configured to run M4 examples";
+	compatible = "st,stm32mp157a-dk1-m4-examples", "st,stm32mp157a-dk1", "st,stm32mp157";
+};
+
+&adc {
+	status = "disabled";
+};
+
+&dac {
+	status = "disabled";
+};
+
+&dma2 {
+	status = "disabled";
+};
+
+&dmamux1 {
+	dma-masters = <&dma1>;
+	dma-channels = <8>;
+};
+
+&m4_adc {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_crc2 {
+	status = "okay";
+};
+
+&m4_cryp2 {
+	status = "okay";
+};
+
+&m4_dac {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_dma2 {
+	status = "okay";
+};
+
+&m4_hash2 {
+	status = "okay";
+};
+
+&m4_i2c5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_i2c5_pins_a>;
+	status = "okay";
+};
+
+&m4_rng2 {
+	status = "okay";
+};
+
+&m4_rproc {
+	m4_system_resources {
+		status = "okay";
+
+		button {
+			compatible = "rproc-srm-dev";
+			interrupt-parent = <&gpioa>;
+			interrupts = <14 2>;
+			interrupt-names = "irq";
+			status = "okay";
+		};
+
+		m4_led: m4_led {
+			compatible = "rproc-srm-dev";
+			pinctrl-names = "default";
+			pinctrl-0 = <&m4_leds_orange_pins>;
+			status = "okay";
+		};
+	};
+};
+
+&m4_spi4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_spi4_pins_a>;
+	status = "okay";
+};
+
+&m4_timers1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_pwm1_pins_a_ch1>;
+	status = "okay";
+};
+
+&m4_timers2 {
+	status = "okay";
+};
+
+&m4_uart7 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_uart7_pins_a>;
+	status = "okay";
+};
+
+&pinctrl {
+	m4_leds_orange_pins: m4-leds-orange-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 7, RSVD)>;
+		};
+	};
+
+	m4_pwm1_pins_a_ch1: m4-pwm1-0-ch1 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 9, RSVD)>;
+		};
+	};
+};
+
+&timers1 {
+	status = "disabled";
+};
diff --git a/arch/arm/boot/dts/stm32mp157a-dk1.dts b/arch/arm/boot/dts/stm32mp157a-dk1.dts
index 4c8be9c8e..f48207dad 100644
--- a/arch/arm/boot/dts/stm32mp157a-dk1.dts
+++ b/arch/arm/boot/dts/stm32mp157a-dk1.dts
@@ -7,6 +7,7 @@
 /dts-v1/;
 
 #include "stm32mp157.dtsi"
+#include "stm32mp15xa.dtsi"
 #include "stm32mp15-pinctrl.dtsi"
 #include "stm32mp15xxac-pinctrl.dtsi"
 #include "stm32mp15xx-dkx.dtsi"
@@ -15,13 +16,6 @@ / {
 	model = "STMicroelectronics STM32MP157A-DK1 Discovery Board";
 	compatible = "st,stm32mp157a-dk1", "st,stm32mp157";
 
-	aliases {
-		ethernet0 = &ethernet0;
-		serial0 = &uart4;
-		serial1 = &usart3;
-		serial2 = &uart7;
-	};
-
 	chosen {
 		stdout-path = "serial0:115200n8";
 	};
diff --git a/arch/arm/boot/dts/stm32mp157a-ed1.dts b/arch/arm/boot/dts/stm32mp157a-ed1.dts
new file mode 100644
index 000000000..0213ca5c1
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157a-ed1.dts
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xa.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxaa-pinctrl.dtsi"
+#include "stm32mp15xx-edx.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP157A eval daughter";
+	compatible = "st,stm32mp157a-ed1", "st,stm32mp157";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	reserved-memory {
+		gpu_reserved: gpu@f6000000 {
+			reg = <0xf6000000 0x8000000>;
+			no-map;
+		};
+	};
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+};
diff --git a/arch/arm/boot/dts/stm32mp157a-ev1.dts b/arch/arm/boot/dts/stm32mp157a-ev1.dts
new file mode 100644
index 000000000..a96fbc840
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157a-ev1.dts
@@ -0,0 +1,103 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157a-ed1.dts"
+#include "stm32mp15xx-evx.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP157A eval daughter on eval mother";
+	compatible = "st,stm32mp157a-ev1", "st,stm32mp157a-ed1", "st,stm32mp157";
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>;
+			status = "disabled";
+		};
+	};
+
+	aliases {
+		ethernet0 = &ethernet0;
+	};
+
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpiod 13 GPIO_ACTIVE_LOW>;
+		default-on;
+		status = "okay";
+	};
+};
+
+&dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out: endpoint {
+				remote-endpoint = <&dsi_panel_in>;
+			};
+		};
+	};
+
+	panel_dsi: panel-dsi@0 {
+		compatible = "raydium,rm68200";
+		reg = <0>;
+		reset-gpios = <&gpiof 15 GPIO_ACTIVE_LOW>;
+		backlight = <&panel_backlight>;
+		power-supply = <&v3v3>;
+		status = "okay";
+
+		port {
+			dsi_panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&i2c2 {
+	gt9147: goodix_ts@5d {
+		compatible = "goodix,gt9147";
+		reg = <0x5d>;
+		panel = <&panel_dsi>;
+		pinctrl-0 = <&goodix_pins>;
+		pinctrl-names = "default";
+		status = "okay";
+
+		interrupts = <14 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&stmfx_pinctrl>;
+	};
+};
+
+&ltdc {
+	status = "okay";
+
+	port {
+		ltdc_ep0_out: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&dsi_in>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp157c-dk2-a7-examples.dts b/arch/arm/boot/dts/stm32mp157c-dk2-a7-examples.dts
new file mode 100644
index 000000000..6c7608fc4
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157c-dk2-a7-examples.dts
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157c-dk2.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157C-DK2 configured to run Linux A7 examples";
+	compatible = "st,stm32mp157c-dk2-a7-examples", "st,stm32mp157c-dk2", "st,stm32mp157";
+};
+
+&adc {
+	pinctrl-0 = <&adc12_ain_pins_a>, <&adc12_usb_cc_pins_a>;
+
+	adc1: adc@0 {
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@13 {
+			reg = <13>;
+			st,min-sample-time-ns = <5000>;
+		};
+	};
+
+	adc2: adc@100 {
+		/* Set IRQ mode as example. DMA is the preferred mode, yet. */
+		/delete-property/dmas;
+		/delete-property/dma-names;
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@2 {
+			reg = <2>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <5000>;
+		};
+	};
+};
+
+&i2c5 {
+	status = "okay";
+};
+
+&timers1 {
+	status = "okay";
+};
+
+&timers3 {
+	status = "okay";
+};
+
+&timers4 {
+	status = "okay";
+};
+
+&timers5 {
+	status = "okay";
+};
+
+&timers6 {
+	status = "okay";
+};
+
+&timers12 {
+	status = "okay";
+};
+
+&uart7 {
+	status = "okay";
+};
+
+&usart3 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/stm32mp157c-dk2-m4-examples.dts b/arch/arm/boot/dts/stm32mp157c-dk2-m4-examples.dts
new file mode 100644
index 000000000..e770942e8
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157c-dk2-m4-examples.dts
@@ -0,0 +1,128 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157c-dk2.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157C-DK2 configured to run M4 examples";
+	compatible = "st,stm32mp157c-dk2-m4-examples", "st,stm32mp157c-dk2", "st,stm32mp157";
+};
+
+&adc {
+	status = "disabled";
+};
+
+&dac {
+	status = "disabled";
+};
+
+&dma2 {
+	status = "disabled";
+};
+
+&dmamux1 {
+	dma-masters = <&dma1>;
+	dma-channels = <8>;
+};
+
+&m4_adc {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_crc2 {
+	status = "okay";
+};
+
+&m4_cryp2 {
+	status = "okay";
+};
+
+&m4_dac {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_dma2 {
+	status = "okay";
+};
+
+&m4_hash2 {
+	status = "okay";
+};
+
+&m4_i2c5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_i2c5_pins_a>;
+	status = "okay";
+};
+
+&m4_rng2 {
+	status = "okay";
+};
+
+&m4_rproc {
+	m4_system_resources {
+		status = "okay";
+
+		button {
+			compatible = "rproc-srm-dev";
+			interrupt-parent = <&gpioa>;
+			interrupts = <14 2>;
+			interrupt-names = "irq";
+			status = "okay";
+		};
+
+		m4_led: m4_led {
+			compatible = "rproc-srm-dev";
+			pinctrl-names = "default";
+			pinctrl-0 = <&m4_leds_orange_pins>;
+			status = "okay";
+		};
+	};
+};
+
+&m4_spi4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_spi4_pins_a>;
+	status = "okay";
+};
+
+&m4_timers1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_pwm1_pins_a_ch1>;
+	status = "okay";
+};
+
+&m4_timers2 {
+	status = "okay";
+};
+
+&m4_uart7 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_uart7_pins_a>;
+	status = "okay";
+};
+
+&pinctrl {
+	m4_leds_orange_pins: m4-leds-orange-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 7, RSVD)>;
+		};
+	};
+
+	m4_pwm1_pins_a_ch1: m4-pwm1-0-ch1 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 9, RSVD)>;
+		};
+	};
+};
+
+&timers1 {
+	status = "disabled";
+};
diff --git a/arch/arm/boot/dts/stm32mp157c-dk2.dts b/arch/arm/boot/dts/stm32mp157c-dk2.dts
index 2bc92ef3a..0190bd17d 100644
--- a/arch/arm/boot/dts/stm32mp157c-dk2.dts
+++ b/arch/arm/boot/dts/stm32mp157c-dk2.dts
@@ -11,21 +11,32 @@
 #include "stm32mp15-pinctrl.dtsi"
 #include "stm32mp15xxac-pinctrl.dtsi"
 #include "stm32mp15xx-dkx.dtsi"
+#include <dt-bindings/rtc/rtc-stm32.h>
 
 / {
 	model = "STMicroelectronics STM32MP157C-DK2 Discovery Board";
 	compatible = "st,stm32mp157c-dk2", "st,stm32mp157";
 
 	aliases {
-		ethernet0 = &ethernet0;
-		serial0 = &uart4;
-		serial1 = &usart3;
-		serial2 = &uart7;
 		serial3 = &usart2;
 	};
 
 	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
 		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>;
+			status = "disabled";
+		};
+	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpioh 4 GPIO_ACTIVE_LOW>;
 	};
 };
 
@@ -35,7 +46,6 @@ &cryp1 {
 
 &dsi {
 	status = "okay";
-	phy-dsi-supply = <&reg18>;
 
 	ports {
 		port@0 {
@@ -53,7 +63,7 @@ dsi_out: endpoint {
 		};
 	};
 
-	panel@0 {
+	panel_otm8009a: panel-otm8009a@0 {
 		compatible = "orisetech,otm8009a";
 		reg = <0>;
 		reset-gpios = <&gpioe 4 GPIO_ACTIVE_LOW>;
@@ -77,6 +87,9 @@ touchscreen@38 {
 		interrupt-controller;
 		touchscreen-size-x = <480>;
 		touchscreen-size-y = <800>;
+		panel = <&panel_otm8009a>;
+		vcc-supply = <&v3v3>;
+		iovcc-supply = <&v3v3>;
 		status = "okay";
 	};
 };
@@ -92,10 +105,47 @@ ltdc_ep1_out: endpoint@1 {
 	};
 };
 
+&rtc {
+	st,lsco = <RTC_OUT2_RMP>;
+	pinctrl-0 = <&rtc_out2_rmp_pins_a>;
+	pinctrl-names = "default";
+};
+
+/* Wifi */
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a>;
+	non-removable;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+	};
+};
+
+/* Bluetooth */
 &usart2 {
 	pinctrl-names = "default", "sleep", "idle";
 	pinctrl-0 = <&usart2_pins_c>;
 	pinctrl-1 = <&usart2_sleep_pins_c>;
 	pinctrl-2 = <&usart2_idle_pins_c>;
-	status = "disabled";
+	uart-has-rtscts;
+	status = "okay";
+
+	bluetooth {
+		shutdown-gpios = <&gpioz 6 GPIO_ACTIVE_HIGH>;
+		compatible = "brcm,bcm43438-bt";
+		max-speed = <3000000>;
+		vbat-supply = <&v3v3>;
+		vddio-supply = <&v3v3>;
+	};
 };
diff --git a/arch/arm/boot/dts/stm32mp157c-ed1.dts b/arch/arm/boot/dts/stm32mp157c-ed1.dts
index 46b471d09..d2c24803b 100644
--- a/arch/arm/boot/dts/stm32mp157c-ed1.dts
+++ b/arch/arm/boot/dts/stm32mp157c-ed1.dts
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
 /*
- * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
- * Author: Ludovic Barre <ludovic.barre@st.com> for STMicroelectronics.
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
  */
 /dts-v1/;
 
@@ -9,8 +9,7 @@
 #include "stm32mp15xc.dtsi"
 #include "stm32mp15-pinctrl.dtsi"
 #include "stm32mp15xxaa-pinctrl.dtsi"
-#include <dt-bindings/gpio/gpio.h>
-#include <dt-bindings/mfd/st,stpmic1.h>
+#include "stm32mp15xx-edx.dtsi"
 
 / {
 	model = "STMicroelectronics STM32MP157C eval daughter";
@@ -20,381 +19,18 @@ chosen {
 		stdout-path = "serial0:115200n8";
 	};
 
-	memory@c0000000 {
-		device_type = "memory";
-		reg = <0xC0000000 0x40000000>;
-	};
-
 	reserved-memory {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		ranges;
-
-		mcuram2: mcuram2@10000000 {
-			compatible = "shared-dma-pool";
-			reg = <0x10000000 0x40000>;
-			no-map;
-		};
-
-		vdev0vring0: vdev0vring0@10040000 {
-			compatible = "shared-dma-pool";
-			reg = <0x10040000 0x1000>;
-			no-map;
-		};
-
-		vdev0vring1: vdev0vring1@10041000 {
-			compatible = "shared-dma-pool";
-			reg = <0x10041000 0x1000>;
-			no-map;
-		};
-
-		vdev0buffer: vdev0buffer@10042000 {
-			compatible = "shared-dma-pool";
-			reg = <0x10042000 0x4000>;
-			no-map;
-		};
-
-		mcuram: mcuram@30000000 {
-			compatible = "shared-dma-pool";
-			reg = <0x30000000 0x40000>;
-			no-map;
-		};
-
-		retram: retram@38000000 {
-			compatible = "shared-dma-pool";
-			reg = <0x38000000 0x10000>;
-			no-map;
-		};
-
-		gpu_reserved: gpu@e8000000 {
-			reg = <0xe8000000 0x8000000>;
+		gpu_reserved: gpu@f6000000 {
+			reg = <0xf6000000 0x8000000>;
 			no-map;
 		};
 	};
-
-	aliases {
-		serial0 = &uart4;
-	};
-
-	sd_switch: regulator-sd_switch {
-		compatible = "regulator-gpio";
-		regulator-name = "sd_switch";
-		regulator-min-microvolt = <1800000>;
-		regulator-max-microvolt = <2900000>;
-		regulator-type = "voltage";
-		regulator-always-on;
-
-		gpios = <&gpiof 14 GPIO_ACTIVE_HIGH>;
-		gpios-states = <0>;
-		states = <1800000 0x1>,
-			 <2900000 0x0>;
-	};
-
-	vin: vin {
-		compatible = "regulator-fixed";
-		regulator-name = "vin";
-		regulator-min-microvolt = <5000000>;
-		regulator-max-microvolt = <5000000>;
-		regulator-always-on;
-	};
-};
-
-&adc {
-	/* ANA0, ANA1 are dedicated pins and don't need pinctrl: only in6. */
-	pinctrl-0 = <&adc1_in6_pins_a>;
-	pinctrl-names = "default";
-	vdd-supply = <&vdd>;
-	vdda-supply = <&vdda>;
-	vref-supply = <&vdda>;
-	status = "disabled";
-	adc1: adc@0 {
-		st,adc-channels = <0 1 6>;
-		/* 16.5 ck_cycles sampling time */
-		st,min-sample-time-nsecs = <400>;
-		status = "okay";
-	};
-};
-
-&crc1 {
-	status = "okay";
 };
 
 &cryp1 {
 	status = "okay";
 };
 
-&dac {
-	pinctrl-names = "default";
-	pinctrl-0 = <&dac_ch1_pins_a &dac_ch2_pins_a>;
-	vref-supply = <&vdda>;
-	status = "disabled";
-	dac1: dac@1 {
-		status = "okay";
-	};
-	dac2: dac@2 {
-		status = "okay";
-	};
-};
-
-&dts {
-	status = "okay";
-};
-
 &gpu {
 	contiguous-area = <&gpu_reserved>;
 };
-
-&hash1 {
-	status = "okay";
-};
-
-&i2c4 {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&i2c4_pins_a>;
-	pinctrl-1 = <&i2c4_sleep_pins_a>;
-	i2c-scl-rising-time-ns = <185>;
-	i2c-scl-falling-time-ns = <20>;
-	clock-frequency = <400000>;
-	status = "okay";
-	/* spare dmas for other usage */
-	/delete-property/dmas;
-	/delete-property/dma-names;
-
-	pmic: stpmic@33 {
-		compatible = "st,stpmic1";
-		reg = <0x33>;
-		interrupts-extended = <&gpioa 0 IRQ_TYPE_EDGE_FALLING>;
-		interrupt-controller;
-		#interrupt-cells = <2>;
-		status = "okay";
-
-		regulators {
-			compatible = "st,stpmic1-regulators";
-			buck1-supply = <&vin>;
-			buck2-supply = <&vin>;
-			buck3-supply = <&vin>;
-			buck4-supply = <&vin>;
-			ldo1-supply = <&v3v3>;
-			ldo2-supply = <&v3v3>;
-			ldo3-supply = <&vdd_ddr>;
-			ldo4-supply = <&vin>;
-			ldo5-supply = <&v3v3>;
-			ldo6-supply = <&v3v3>;
-			vref_ddr-supply = <&vin>;
-			boost-supply = <&vin>;
-			pwr_sw1-supply = <&bst_out>;
-			pwr_sw2-supply = <&bst_out>;
-
-			vddcore: buck1 {
-				regulator-name = "vddcore";
-				regulator-min-microvolt = <1200000>;
-				regulator-max-microvolt = <1350000>;
-				regulator-always-on;
-				regulator-initial-mode = <0>;
-				regulator-over-current-protection;
-			};
-
-			vdd_ddr: buck2 {
-				regulator-name = "vdd_ddr";
-				regulator-min-microvolt = <1350000>;
-				regulator-max-microvolt = <1350000>;
-				regulator-always-on;
-				regulator-initial-mode = <0>;
-				regulator-over-current-protection;
-			};
-
-			vdd: buck3 {
-				regulator-name = "vdd";
-				regulator-min-microvolt = <3300000>;
-				regulator-max-microvolt = <3300000>;
-				regulator-always-on;
-				st,mask-reset;
-				regulator-initial-mode = <0>;
-				regulator-over-current-protection;
-			};
-
-			v3v3: buck4 {
-				regulator-name = "v3v3";
-				regulator-min-microvolt = <3300000>;
-				regulator-max-microvolt = <3300000>;
-				regulator-always-on;
-				regulator-over-current-protection;
-				regulator-initial-mode = <0>;
-			};
-
-			vdda: ldo1 {
-				regulator-name = "vdda";
-				regulator-min-microvolt = <2900000>;
-				regulator-max-microvolt = <2900000>;
-				interrupts = <IT_CURLIM_LDO1 0>;
-			};
-
-			v2v8: ldo2 {
-				regulator-name = "v2v8";
-				regulator-min-microvolt = <2800000>;
-				regulator-max-microvolt = <2800000>;
-				interrupts = <IT_CURLIM_LDO2 0>;
-			};
-
-			vtt_ddr: ldo3 {
-				regulator-name = "vtt_ddr";
-				regulator-min-microvolt = <500000>;
-				regulator-max-microvolt = <750000>;
-				regulator-always-on;
-				regulator-over-current-protection;
-			};
-
-			vdd_usb: ldo4 {
-				regulator-name = "vdd_usb";
-				interrupts = <IT_CURLIM_LDO4 0>;
-			};
-
-			vdd_sd: ldo5 {
-				regulator-name = "vdd_sd";
-				regulator-min-microvolt = <2900000>;
-				regulator-max-microvolt = <2900000>;
-				interrupts = <IT_CURLIM_LDO5 0>;
-				regulator-boot-on;
-			};
-
-			v1v8: ldo6 {
-				regulator-name = "v1v8";
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <1800000>;
-				interrupts = <IT_CURLIM_LDO6 0>;
-			};
-
-			vref_ddr: vref_ddr {
-				regulator-name = "vref_ddr";
-				regulator-always-on;
-			};
-
-			bst_out: boost {
-				regulator-name = "bst_out";
-				interrupts = <IT_OCP_BOOST 0>;
-			};
-
-			vbus_otg: pwr_sw1 {
-				regulator-name = "vbus_otg";
-				interrupts = <IT_OCP_OTG 0>;
-			 };
-
-			 vbus_sw: pwr_sw2 {
-				regulator-name = "vbus_sw";
-				interrupts = <IT_OCP_SWOUT 0>;
-				regulator-active-discharge = <1>;
-			 };
-		};
-
-		onkey {
-			compatible = "st,stpmic1-onkey";
-			interrupts = <IT_PONKEY_F 0>, <IT_PONKEY_R 0>;
-			interrupt-names = "onkey-falling", "onkey-rising";
-			power-off-time-sec = <10>;
-			status = "okay";
-		};
-
-		watchdog {
-			compatible = "st,stpmic1-wdt";
-			status = "disabled";
-		};
-	};
-};
-
-&ipcc {
-	status = "okay";
-};
-
-&iwdg2 {
-	timeout-sec = <32>;
-	status = "okay";
-};
-
-&m4_rproc {
-	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
-			<&vdev0vring1>, <&vdev0buffer>;
-	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
-	mbox-names = "vq0", "vq1", "shutdown", "detach";
-	interrupt-parent = <&exti>;
-	interrupts = <68 1>;
-	status = "okay";
-};
-
-&pwr_regulators {
-	vdd-supply = <&vdd>;
-	vdd_3v3_usbfs-supply = <&vdd_usb>;
-};
-
-&rng1 {
-	status = "okay";
-};
-
-&rtc {
-	status = "okay";
-};
-
-&sdmmc1 {
-	pinctrl-names = "default", "opendrain", "sleep";
-	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_dir_pins_a>;
-	pinctrl-1 = <&sdmmc1_b4_od_pins_a &sdmmc1_dir_pins_a>;
-	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a &sdmmc1_dir_sleep_pins_a>;
-	cd-gpios = <&gpiog 1 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
-	disable-wp;
-	st,sig-dir;
-	st,neg-edge;
-	st,use-ckin;
-	bus-width = <4>;
-	vmmc-supply = <&vdd_sd>;
-	vqmmc-supply = <&sd_switch>;
-	sd-uhs-sdr12;
-	sd-uhs-sdr25;
-	sd-uhs-sdr50;
-	sd-uhs-ddr50;
-	status = "okay";
-};
-
-&sdmmc2 {
-	pinctrl-names = "default", "opendrain", "sleep";
-	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
-	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
-	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
-	non-removable;
-	no-sd;
-	no-sdio;
-	st,neg-edge;
-	bus-width = <8>;
-	vmmc-supply = <&v3v3>;
-	vqmmc-supply = <&vdd>;
-	mmc-ddr-3_3v;
-	status = "okay";
-};
-
-&timers6 {
-	status = "okay";
-	/* spare dmas for other usage */
-	/delete-property/dmas;
-	/delete-property/dma-names;
-	timer@5 {
-		status = "okay";
-	};
-};
-
-&uart4 {
-	pinctrl-names = "default", "sleep", "idle";
-	pinctrl-0 = <&uart4_pins_a>;
-	pinctrl-1 = <&uart4_sleep_pins_a>;
-	pinctrl-2 = <&uart4_idle_pins_a>;
-	status = "okay";
-};
-
-&usbotg_hs {
-	vbus-supply = <&vbus_otg>;
-};
-
-&usbphyc_port0 {
-	phy-supply = <&vdd_usb>;
-};
-
-&usbphyc_port1 {
-	phy-supply = <&vdd_usb>;
-};
diff --git a/arch/arm/boot/dts/stm32mp157c-ev1-a7-examples.dts b/arch/arm/boot/dts/stm32mp157c-ev1-a7-examples.dts
new file mode 100644
index 000000000..9f516309c
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157c-ev1-a7-examples.dts
@@ -0,0 +1,57 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157c-ev1.dts"
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157C-EV1 configured to run Linux A7 examples";
+	compatible = "st,stm32mp157c-ev1-a7-examples", "st,stm32mp157c-ev1", "st,stm32mp157c-ed1", "st,stm32mp157";
+
+	test_keys {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		autorepeat;
+		status = "okay";
+		/* gpio needs vdd core in retention for wakeup */
+		power-domains = <&pd_core_ret>;
+
+		button-1 {
+			label = "PA13";
+			linux,code = <BTN_1>;
+			gpios = <&gpioa 13 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+			status = "okay";
+			wakeup-source;
+		};
+	};
+};
+
+&adc {
+	status = "okay";
+};
+
+&dac {
+	status = "okay";
+};
+
+&timers2 {
+	status = "okay";
+};
+
+&timers8 {
+	status = "okay";
+};
+
+&timers12 {
+	status = "okay";
+};
+
+&usart3 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/stm32mp157c-ev1-m4-examples.dts b/arch/arm/boot/dts/stm32mp157c-ev1-m4-examples.dts
new file mode 100644
index 000000000..07684f340
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157c-ev1-m4-examples.dts
@@ -0,0 +1,150 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157c-ev1.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157C-EV1 configured to run M4 examples";
+	compatible = "st,stm32mp157c-ev1-m4-examples", "st,stm32mp157c-ev1", "st,stm32mp157c-ed1", "st,stm32mp157";
+};
+
+&adc {
+	status = "disabled";
+};
+
+&dac {
+	status = "disabled";
+};
+
+&dcmi {
+	status = "disabled";
+};
+
+&dma2 {
+	status = "disabled";
+};
+
+&dmamux1 {
+	dma-masters = <&dma1>;
+	dma-channels = <8>;
+};
+
+&fmc {
+	status = "disabled";
+};
+
+&i2c5 {
+	status = "disabled";
+};
+
+&m4_adc {
+	vref-supply = <&vdda>;
+	status = "okay";
+};
+
+&m4_crc2 {
+	status = "okay";
+};
+
+&m4_cryp2 {
+	status = "okay";
+};
+
+&m4_dac {
+	vref-supply = <&vdda>;
+	status = "okay";
+};
+
+&m4_dma2 {
+	status = "okay";
+};
+
+&m4_hash2 {
+	status = "okay";
+};
+
+&m4_i2c5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_i2c5_pins_a>;
+	status = "okay";
+};
+
+&m4_qspi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_qspi_clk_pins_a &m4_qspi_bk1_pins_a
+		     &m4_qspi_bk2_pins_a>;
+	status = "okay";
+};
+
+&m4_rng2 {
+	status = "okay";
+};
+
+&m4_rproc {
+	m4_system_resources {
+		status = "okay";
+
+	/*	button {
+			compatible = "rproc-srm-dev";
+			interrupt-parent = <&gpioa>;
+			interrupts = <14 2>;
+			interrupt-names = "irq";
+			status = "okay";
+		};
+	*/
+
+		m4_led: m4_led {
+			compatible = "rproc-srm-dev";
+			pinctrl-names = "default";
+			pinctrl-0 = <&m4_leds_orange_pins>;
+			status = "okay";
+		};
+	};
+};
+
+&m4_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_spi1_pins_a>;
+	status = "okay";
+};
+
+&m4_timers2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_pwm2_pins_a>;
+	status = "okay";
+};
+
+&m4_usart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_usart3_pins_a>;
+	status = "okay";
+};
+
+&pinctrl {
+	m4_leds_orange_pins: m4-leds-orange-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 8, RSVD)>;
+		};
+	};
+};
+
+&qspi {
+	status = "disabled";
+};
+
+&sai2b {
+	status = "disabled";
+};
+
+&sound {
+	status = "disabled";
+};
+
+&timers2 {
+	status = "disabled";
+};
diff --git a/arch/arm/boot/dts/stm32mp157c-ev1.dts b/arch/arm/boot/dts/stm32mp157c-ev1.dts
index 5c5b1ddf7..17434d903 100644
--- a/arch/arm/boot/dts/stm32mp157c-ev1.dts
+++ b/arch/arm/boot/dts/stm32mp157c-ev1.dts
@@ -1,69 +1,27 @@
 // SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
 /*
- * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
- * Author: Ludovic Barre <ludovic.barre@st.com> for STMicroelectronics.
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
  */
 /dts-v1/;
 
 #include "stm32mp157c-ed1.dts"
-#include <dt-bindings/gpio/gpio.h>
-#include <dt-bindings/input/input.h>
+#include "stm32mp15xx-evx.dtsi"
 
 / {
 	model = "STMicroelectronics STM32MP157C eval daughter on eval mother";
 	compatible = "st,stm32mp157c-ev1", "st,stm32mp157c-ed1", "st,stm32mp157";
 
 	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
 		stdout-path = "serial0:115200n8";
-	};
-
-	aliases {
-		serial0 = &uart4;
-		serial1 = &usart3;
-		ethernet0 = &ethernet0;
-	};
-
-	clocks {
-		clk_ext_camera: clk-ext-camera {
-			#clock-cells = <0>;
-			compatible = "fixed-clock";
-			clock-frequency = <24000000>;
-		};
-	};
 
-	joystick {
-		compatible = "gpio-keys";
-		pinctrl-0 = <&joystick_pins>;
-		pinctrl-names = "default";
-		button-0 {
-			label = "JoySel";
-			linux,code = <KEY_ENTER>;
-			interrupt-parent = <&stmfx_pinctrl>;
-			interrupts = <0 IRQ_TYPE_EDGE_RISING>;
-		};
-		button-1 {
-			label = "JoyDown";
-			linux,code = <KEY_DOWN>;
-			interrupt-parent = <&stmfx_pinctrl>;
-			interrupts = <1 IRQ_TYPE_EDGE_RISING>;
-		};
-		button-2 {
-			label = "JoyLeft";
-			linux,code = <KEY_LEFT>;
-			interrupt-parent = <&stmfx_pinctrl>;
-			interrupts = <2 IRQ_TYPE_EDGE_RISING>;
-		};
-		button-3 {
-			label = "JoyRight";
-			linux,code = <KEY_RIGHT>;
-			interrupt-parent = <&stmfx_pinctrl>;
-			interrupts = <3 IRQ_TYPE_EDGE_RISING>;
-		};
-		button-4 {
-			label = "JoyUp";
-			linux,code = <KEY_UP>;
-			interrupt-parent = <&stmfx_pinctrl>;
-			interrupts = <4 IRQ_TYPE_EDGE_RISING>;
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>;
+			status = "disabled";
 		};
 	};
 
@@ -75,35 +33,15 @@ panel_backlight: panel-backlight {
 	};
 };
 
-&cec {
-	pinctrl-names = "default";
-	pinctrl-0 = <&cec_pins_a>;
-	status = "okay";
-};
-
-&dcmi {
-	status = "okay";
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&dcmi_pins_a>;
-	pinctrl-1 = <&dcmi_sleep_pins_a>;
-
-	port {
-		dcmi_0: endpoint {
-			remote-endpoint = <&ov5640_0>;
-			bus-type = <5>;
-			bus-width = <8>;
-			hsync-active = <0>;
-			vsync-active = <0>;
-			pclk-sample = <1>;
-		};
-	};
-};
-
 &dsi {
-	phy-dsi-supply = <&reg18>;
+	#address-cells = <1>;
+	#size-cells = <0>;
 	status = "okay";
 
 	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
 		port@0 {
 			reg = <0>;
 			dsi_in: endpoint {
@@ -119,7 +57,7 @@ dsi_out: endpoint {
 		};
 	};
 
-	panel-dsi@0 {
+	panel_dsi: panel-dsi@0 {
 		compatible = "raydium,rm68200";
 		reg = <0>;
 		reset-gpios = <&gpiof 15 GPIO_ACTIVE_LOW>;
@@ -135,106 +73,20 @@ dsi_panel_in: endpoint {
 	};
 };
 
-&ethernet0 {
-	status = "okay";
-	pinctrl-0 = <&ethernet0_rgmii_pins_a>;
-	pinctrl-1 = <&ethernet0_rgmii_sleep_pins_a>;
-	pinctrl-names = "default", "sleep";
-	phy-mode = "rgmii-id";
-	max-speed = <1000>;
-	phy-handle = <&phy0>;
-
-	mdio0 {
-		#address-cells = <1>;
-		#size-cells = <0>;
-		compatible = "snps,dwmac-mdio";
-		phy0: ethernet-phy@0 {
-			reg = <0>;
-		};
-	};
-};
-
-&fmc {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&fmc_pins_a>;
-	pinctrl-1 = <&fmc_sleep_pins_a>;
-	status = "okay";
-
-	nand-controller@4,0 {
-		status = "okay";
-
-		nand@0 {
-			reg = <0>;
-			nand-on-flash-bbt;
-			#address-cells = <1>;
-			#size-cells = <1>;
-		};
-	};
-};
-
 &i2c2 {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&i2c2_pins_a>;
-	pinctrl-1 = <&i2c2_sleep_pins_a>;
-	i2c-scl-rising-time-ns = <185>;
-	i2c-scl-falling-time-ns = <20>;
-	status = "okay";
-
-	ov5640: camera@3c {
-		compatible = "ovti,ov5640";
-		reg = <0x3c>;
-		clocks = <&clk_ext_camera>;
-		clock-names = "xclk";
-		DOVDD-supply = <&v2v8>;
-		powerdown-gpios = <&stmfx_pinctrl 18 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
-		reset-gpios = <&stmfx_pinctrl 19 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
-		rotation = <180>;
+	gt9147: goodix_ts@5d {
+		compatible = "goodix,gt9147";
+		reg = <0x5d>;
+		panel = <&panel_dsi>;
+		pinctrl-0 = <&goodix_pins>;
+		pinctrl-names = "default";
 		status = "okay";
 
-		port {
-			ov5640_0: endpoint {
-				remote-endpoint = <&dcmi_0>;
-				bus-width = <8>;
-				data-shift = <2>; /* lines 9:2 are used */
-				hsync-active = <0>;
-				vsync-active = <0>;
-				pclk-sample = <1>;
-			};
-		};
-	};
-
-	stmfx: stmfx@42 {
-		compatible = "st,stmfx-0300";
-		reg = <0x42>;
-		interrupts = <8 IRQ_TYPE_EDGE_RISING>;
-		interrupt-parent = <&gpioi>;
-		vdd-supply = <&v3v3>;
-
-		stmfx_pinctrl: pinctrl {
-			compatible = "st,stmfx-0300-pinctrl";
-			gpio-controller;
-			#gpio-cells = <2>;
-			interrupt-controller;
-			#interrupt-cells = <2>;
-			gpio-ranges = <&stmfx_pinctrl 0 0 24>;
-
-			joystick_pins: joystick-pins {
-				pins = "gpio0", "gpio1", "gpio2", "gpio3", "gpio4";
-				bias-pull-down;
-			};
-		};
+		interrupts = <14 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&stmfx_pinctrl>;
 	};
 };
 
-&i2c5 {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&i2c5_pins_a>;
-	pinctrl-1 = <&i2c5_sleep_pins_a>;
-	i2c-scl-rising-time-ns = <185>;
-	i2c-scl-falling-time-ns = <20>;
-	status = "okay";
-};
-
 &ltdc {
 	status = "okay";
 
@@ -245,133 +97,3 @@ ltdc_ep0_out: endpoint@0 {
 		};
 	};
 };
-
-&m_can1 {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&m_can1_pins_a>;
-	pinctrl-1 = <&m_can1_sleep_pins_a>;
-	status = "okay";
-};
-
-&qspi {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&qspi_clk_pins_a &qspi_bk1_pins_a &qspi_bk2_pins_a>;
-	pinctrl-1 = <&qspi_clk_sleep_pins_a &qspi_bk1_sleep_pins_a &qspi_bk2_sleep_pins_a>;
-	reg = <0x58003000 0x1000>, <0x70000000 0x4000000>;
-	#address-cells = <1>;
-	#size-cells = <0>;
-	status = "okay";
-
-	flash0: mx66l51235l@0 {
-		compatible = "jedec,spi-nor";
-		reg = <0>;
-		spi-rx-bus-width = <4>;
-		spi-max-frequency = <108000000>;
-		#address-cells = <1>;
-		#size-cells = <1>;
-	};
-
-	flash1: mx66l51235l@1 {
-		compatible = "jedec,spi-nor";
-		reg = <1>;
-		spi-rx-bus-width = <4>;
-		spi-max-frequency = <108000000>;
-		#address-cells = <1>;
-		#size-cells = <1>;
-	};
-};
-
-&sdmmc3 {
-	pinctrl-names = "default", "opendrain", "sleep";
-	pinctrl-0 = <&sdmmc3_b4_pins_a>;
-	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
-	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
-	broken-cd;
-	st,neg-edge;
-	bus-width = <4>;
-	vmmc-supply = <&v3v3>;
-	status = "disabled";
-};
-
-&spi1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&spi1_pins_a>;
-	status = "disabled";
-};
-
-&timers2 {
-	/* spare dmas for other usage (un-delete to enable pwm capture) */
-	/delete-property/dmas;
-	/delete-property/dma-names;
-	status = "disabled";
-	pwm {
-		pinctrl-0 = <&pwm2_pins_a>;
-		pinctrl-1 = <&pwm2_sleep_pins_a>;
-		pinctrl-names = "default", "sleep";
-		status = "okay";
-	};
-	timer@1 {
-		status = "okay";
-	};
-};
-
-&timers8 {
-	/delete-property/dmas;
-	/delete-property/dma-names;
-	status = "disabled";
-	pwm {
-		pinctrl-0 = <&pwm8_pins_a>;
-		pinctrl-1 = <&pwm8_sleep_pins_a>;
-		pinctrl-names = "default", "sleep";
-		status = "okay";
-	};
-	timer@7 {
-		status = "okay";
-	};
-};
-
-&timers12 {
-	/delete-property/dmas;
-	/delete-property/dma-names;
-	status = "disabled";
-	pwm {
-		pinctrl-0 = <&pwm12_pins_a>;
-		pinctrl-1 = <&pwm12_sleep_pins_a>;
-		pinctrl-names = "default", "sleep";
-		status = "okay";
-	};
-	timer@11 {
-		status = "okay";
-	};
-};
-
-&usart3 {
-	pinctrl-names = "default", "sleep", "idle";
-	pinctrl-0 = <&usart3_pins_b>;
-	pinctrl-1 = <&usart3_sleep_pins_b>;
-	pinctrl-2 = <&usart3_idle_pins_b>;
-	/*
-	 * HW flow control USART3_RTS is optional, and isn't default wired to
-	 * the connector. SB23 needs to be soldered in order to use it, and R77
-	 * (ETH_CLK) should be removed.
-	 */
-	uart-has-rtscts;
-	status = "disabled";
-};
-
-&usbh_ehci {
-	phys = <&usbphyc_port0>;
-	status = "okay";
-};
-
-&usbotg_hs {
-	pinctrl-0 = <&usbotg_hs_pins_a>;
-	pinctrl-names = "default";
-	phys = <&usbphyc_port1 0>;
-	phy-names = "usb2-phy";
-	status = "okay";
-};
-
-&usbphyc {
-	status = "okay";
-};
diff --git a/arch/arm/boot/dts/stm32mp157d-dk1-a7-examples.dts b/arch/arm/boot/dts/stm32mp157d-dk1-a7-examples.dts
new file mode 100644
index 000000000..745cec886
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157d-dk1-a7-examples.dts
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Amelie Delaunay <amelie.delaunay@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157d-dk1.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157D-DK1 configured to run Linux A7 examples";
+	compatible = "st,stm32mp157d-dk1-a7-examples", "st,stm32mp157d-dk1", "st,stm32mp157";
+};
+
+&adc {
+	pinctrl-0 = <&adc12_ain_pins_a>, <&adc12_usb_cc_pins_a>;
+
+	adc1: adc@0 {
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@13 {
+			reg = <13>;
+			st,min-sample-time-ns = <5000>;
+		};
+	};
+
+	adc2: adc@100 {
+		/* Set IRQ mode as example. DMA is the preferred mode, yet. */
+		/delete-property/dmas;
+		/delete-property/dma-names;
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@2 {
+			reg = <2>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <5000>;
+		};
+	};
+};
+
+&i2c5 {
+	status = "okay";
+};
+
+&timers1 {
+	status = "okay";
+};
+
+&timers3 {
+	status = "okay";
+};
+
+&timers4 {
+	status = "okay";
+};
+
+&timers5 {
+	status = "okay";
+};
+
+&timers6 {
+	status = "okay";
+};
+
+&timers12 {
+	status = "okay";
+};
+
+&uart7 {
+	status = "okay";
+};
+
+&usart3 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/stm32mp157d-dk1-m4-examples.dts b/arch/arm/boot/dts/stm32mp157d-dk1-m4-examples.dts
new file mode 100644
index 000000000..d1088b95f
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157d-dk1-m4-examples.dts
@@ -0,0 +1,128 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Amelie Delaunay <amelie.delaunay@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157d-dk1.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157D-DK1 configured to run M4 examples";
+	compatible = "st,stm32mp157d-dk1-m4-examples", "st,stm32mp157d-dk1", "st,stm32mp157";
+};
+
+&adc {
+	status = "disabled";
+};
+
+&dac {
+	status = "disabled";
+};
+
+&dma2 {
+	status = "disabled";
+};
+
+&dmamux1 {
+	dma-masters = <&dma1>;
+	dma-channels = <8>;
+};
+
+&m4_adc {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_crc2 {
+	status = "okay";
+};
+
+&m4_cryp2 {
+	status = "okay";
+};
+
+&m4_dac {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_dma2 {
+	status = "okay";
+};
+
+&m4_hash2 {
+	status = "okay";
+};
+
+&m4_i2c5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_i2c5_pins_a>;
+	status = "okay";
+};
+
+&m4_rng2 {
+	status = "okay";
+};
+
+&m4_rproc {
+	m4_system_resources {
+		status = "okay";
+
+		button {
+			compatible = "rproc-srm-dev";
+			interrupt-parent = <&gpioa>;
+			interrupts = <14 2>;
+			interrupt-names = "irq";
+			status = "okay";
+		};
+
+		m4_led: m4_led {
+			compatible = "rproc-srm-dev";
+			pinctrl-names = "default";
+			pinctrl-0 = <&m4_leds_orange_pins>;
+			status = "okay";
+		};
+	};
+};
+
+&m4_spi4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_spi4_pins_a>;
+	status = "okay";
+};
+
+&m4_timers1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_pwm1_pins_a_ch1>;
+	status = "okay";
+};
+
+&m4_timers2 {
+	status = "okay";
+};
+
+&m4_uart7 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_uart7_pins_a>;
+	status = "okay";
+};
+
+&pinctrl {
+	m4_leds_orange_pins: m4-leds-orange-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 7, RSVD)>;
+		};
+	};
+
+	m4_pwm1_pins_a_ch1: m4-pwm1-0-ch1 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 9, RSVD)>;
+		};
+	};
+};
+
+&timers1 {
+	status = "disabled";
+};
diff --git a/arch/arm/boot/dts/stm32mp157d-dk1.dts b/arch/arm/boot/dts/stm32mp157d-dk1.dts
new file mode 100644
index 000000000..99a4e0f9c
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157d-dk1.dts
@@ -0,0 +1,26 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xd.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxac-pinctrl.dtsi"
+#include "stm32mp15xx-dkx.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP157D-DK1 Discovery Board";
+	compatible = "st,stm32mp157d-dk1", "st,stm32mp157";
+
+	aliases {
+		ethernet0 = &ethernet0;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp157d-ed1.dts b/arch/arm/boot/dts/stm32mp157d-ed1.dts
new file mode 100644
index 000000000..18d807437
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157d-ed1.dts
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xd.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxaa-pinctrl.dtsi"
+#include "stm32mp15xx-edx.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP157D eval daughter";
+	compatible = "st,stm32mp157d-ed1", "st,stm32mp157";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	reserved-memory {
+		gpu_reserved: gpu@f6000000 {
+			reg = <0xf6000000 0x8000000>;
+			no-map;
+		};
+	};
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+};
diff --git a/arch/arm/boot/dts/stm32mp157d-ev1.dts b/arch/arm/boot/dts/stm32mp157d-ev1.dts
new file mode 100644
index 000000000..f19ca6ada
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157d-ev1.dts
@@ -0,0 +1,103 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157d-ed1.dts"
+#include "stm32mp15xx-evx.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP157D eval daughter on eval mother";
+	compatible = "st,stm32mp157d-ev1", "st,stm32mp157d-ed1", "st,stm32mp157";
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>;
+			status = "disabled";
+		};
+	};
+
+	aliases {
+		ethernet0 = &ethernet0;
+	};
+
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpiod 13 GPIO_ACTIVE_LOW>;
+		default-on;
+		status = "okay";
+	};
+};
+
+&dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out: endpoint {
+				remote-endpoint = <&dsi_panel_in>;
+			};
+		};
+	};
+
+	panel_dsi: panel-dsi@0 {
+		compatible = "raydium,rm68200";
+		reg = <0>;
+		reset-gpios = <&gpiof 15 GPIO_ACTIVE_LOW>;
+		backlight = <&panel_backlight>;
+		power-supply = <&v3v3>;
+		status = "okay";
+
+		port {
+			dsi_panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&i2c2 {
+	gt9147: goodix_ts@5d {
+		compatible = "goodix,gt9147";
+		reg = <0x5d>;
+		panel = <&panel_dsi>;
+		pinctrl-0 = <&goodix_pins>;
+		pinctrl-names = "default";
+		status = "okay";
+
+		interrupts = <14 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&stmfx_pinctrl>;
+	};
+};
+
+&ltdc {
+	status = "okay";
+
+	port {
+		ltdc_ep0_out: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&dsi_in>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp157f-dk2-a7-examples.dts b/arch/arm/boot/dts/stm32mp157f-dk2-a7-examples.dts
new file mode 100644
index 000000000..99dc3ed59
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157f-dk2-a7-examples.dts
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157f-dk2.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157F-DK2 configured to run Linux A7 examples";
+	compatible = "st,stm32mp157f-dk2-a7-examples", "st,stm32mp157f-dk2", "st,stm32mp157";
+};
+
+&adc {
+	pinctrl-0 = <&adc12_ain_pins_a>, <&adc12_usb_cc_pins_a>;
+
+	adc1: adc@0 {
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@13 {
+			reg = <13>;
+			st,min-sample-time-ns = <5000>;
+		};
+	};
+
+	adc2: adc@100 {
+		/* Set IRQ mode as example. DMA is the preferred mode, yet. */
+		/delete-property/dmas;
+		/delete-property/dma-names;
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@2 {
+			reg = <2>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <5000>;
+		};
+	};
+};
+
+&i2c5 {
+	status = "okay";
+};
+
+&timers1 {
+	status = "okay";
+};
+
+&timers3 {
+	status = "okay";
+};
+
+&timers4 {
+	status = "okay";
+};
+
+&timers5 {
+	status = "okay";
+};
+
+&timers6 {
+	status = "okay";
+};
+
+&timers12 {
+	status = "okay";
+};
+
+&uart7 {
+	status = "okay";
+};
+
+&usart3 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/stm32mp157f-dk2-m4-examples.dts b/arch/arm/boot/dts/stm32mp157f-dk2-m4-examples.dts
new file mode 100644
index 000000000..38f8a1bbb
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157f-dk2-m4-examples.dts
@@ -0,0 +1,128 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157f-dk2.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157F-DK2 configured to run M4 examples";
+	compatible = "st,stm32mp157f-dk2-m4-examples", "st,stm32mp157f-dk2", "st,stm32mp157";
+};
+
+&adc {
+	status = "disabled";
+};
+
+&dac {
+	status = "disabled";
+};
+
+&dma2 {
+	status = "disabled";
+};
+
+&dmamux1 {
+	dma-masters = <&dma1>;
+	dma-channels = <8>;
+};
+
+&m4_adc {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_crc2 {
+	status = "okay";
+};
+
+&m4_cryp2 {
+	status = "okay";
+};
+
+&m4_dac {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_dma2 {
+	status = "okay";
+};
+
+&m4_hash2 {
+	status = "okay";
+};
+
+&m4_i2c5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_i2c5_pins_a>;
+	status = "okay";
+};
+
+&m4_rng2 {
+	status = "okay";
+};
+
+&m4_rproc {
+	m4_system_resources {
+		status = "okay";
+
+		button {
+			compatible = "rproc-srm-dev";
+			interrupt-parent = <&gpioa>;
+			interrupts = <14 2>;
+			interrupt-names = "irq";
+			status = "okay";
+		};
+
+		m4_led: m4_led {
+			compatible = "rproc-srm-dev";
+			pinctrl-names = "default";
+			pinctrl-0 = <&m4_leds_orange_pins>;
+			status = "okay";
+		};
+	};
+};
+
+&m4_spi4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_spi4_pins_a>;
+	status = "okay";
+};
+
+&m4_timers1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_pwm1_pins_a_ch1>;
+	status = "okay";
+};
+
+&m4_timers2 {
+	status = "okay";
+};
+
+&m4_uart7 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_uart7_pins_a>;
+	status = "okay";
+};
+
+&pinctrl {
+	m4_leds_orange_pins: m4-leds-orange-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 7, RSVD)>;
+		};
+	};
+
+	m4_pwm1_pins_a_ch1: m4-pwm1-0-ch1 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 9, RSVD)>;
+		};
+	};
+};
+
+&timers1 {
+	status = "disabled";
+};
diff --git a/arch/arm/boot/dts/stm32mp157f-dk2.dts b/arch/arm/boot/dts/stm32mp157f-dk2.dts
new file mode 100644
index 000000000..d854ed0ac
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157f-dk2.dts
@@ -0,0 +1,151 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xf.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxac-pinctrl.dtsi"
+#include "stm32mp15xx-dkx.dtsi"
+#include <dt-bindings/rtc/rtc-stm32.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157F-DK2 Discovery Board";
+	compatible = "st,stm32mp157f-dk2", "st,stm32mp157";
+
+	aliases {
+		serial3 = &usart2;
+	};
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>;
+			status = "disabled";
+		};
+	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpioh 4 GPIO_ACTIVE_LOW>;
+	};
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&dsi {
+	status = "okay";
+
+	ports {
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep1_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out: endpoint {
+				remote-endpoint = <&panel_in>;
+			};
+		};
+	};
+
+	panel_otm8009a: panel-otm8009a@0 {
+		compatible = "orisetech,otm8009a";
+		reg = <0>;
+		reset-gpios = <&gpioe 4 GPIO_ACTIVE_LOW>;
+		power-supply = <&v3v3>;
+		status = "okay";
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&i2c1 {
+	touchscreen@38 {
+		compatible = "focaltech,ft6236";
+		reg = <0x38>;
+		interrupts = <2 2>;
+		interrupt-parent = <&gpiof>;
+		interrupt-controller;
+		touchscreen-size-x = <480>;
+		touchscreen-size-y = <800>;
+		panel = <&panel_otm8009a>;
+		vcc-supply = <&v3v3>;
+		iovcc-supply = <&v3v3>;
+		status = "okay";
+	};
+};
+
+&ltdc {
+	status = "okay";
+
+	port {
+		ltdc_ep1_out: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dsi_in>;
+		};
+	};
+};
+
+&rtc {
+	st,lsco = <RTC_OUT2_RMP>;
+	pinctrl-0 = <&rtc_out2_rmp_pins_a>;
+	pinctrl-names = "default";
+};
+
+/* Wifi */
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a>;
+	non-removable;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+	};
+};
+
+/* Bluetooth */
+&usart2 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart2_pins_c>;
+	pinctrl-1 = <&usart2_sleep_pins_c>;
+	pinctrl-2 = <&usart2_idle_pins_c>;
+	uart-has-rtscts;
+	status = "okay";
+
+	bluetooth {
+		shutdown-gpios = <&gpioz 6 GPIO_ACTIVE_HIGH>;
+		compatible = "brcm,bcm43438-bt";
+		max-speed = <3000000>;
+		vbat-supply = <&v3v3>;
+		vddio-supply = <&v3v3>;
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp157f-ed1.dts b/arch/arm/boot/dts/stm32mp157f-ed1.dts
new file mode 100644
index 000000000..bb3f8dfdc
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157f-ed1.dts
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xf.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxaa-pinctrl.dtsi"
+#include "stm32mp15xx-edx.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP157F eval daughter";
+	compatible = "st,stm32mp157f-ed1", "st,stm32mp157";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	reserved-memory {
+		gpu_reserved: gpu@f6000000 {
+			reg = <0xf6000000 0x8000000>;
+			no-map;
+		};
+	};
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+};
diff --git a/arch/arm/boot/dts/stm32mp157f-ev1-a7-examples.dts b/arch/arm/boot/dts/stm32mp157f-ev1-a7-examples.dts
new file mode 100644
index 000000000..373307ff6
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157f-ev1-a7-examples.dts
@@ -0,0 +1,57 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157f-ev1.dts"
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157F-EV1 configured to run Linux A7 examples";
+	compatible = "st,stm32mp157f-ev1-a7-examples", "st,stm32mp157f-ev1", "st,stm32mp157f-ed1", "st,stm32mp157";
+
+	test_keys {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		autorepeat;
+		status = "okay";
+		/* gpio needs vdd core in retention for wakeup */
+		power-domains = <&pd_core_ret>;
+
+		button-1 {
+			label = "PA13";
+			linux,code = <BTN_1>;
+			gpios = <&gpioa 13 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+			status = "okay";
+			wakeup-source;
+		};
+	};
+};
+
+&adc {
+	status = "okay";
+};
+
+&dac {
+	status = "okay";
+};
+
+&timers2 {
+	status = "okay";
+};
+
+&timers8 {
+	status = "okay";
+};
+
+&timers12 {
+	status = "okay";
+};
+
+&usart3 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/stm32mp157f-ev1-m4-examples.dts b/arch/arm/boot/dts/stm32mp157f-ev1-m4-examples.dts
new file mode 100644
index 000000000..fd7be9c73
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157f-ev1-m4-examples.dts
@@ -0,0 +1,151 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157f-ev1.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157F-EV1 configured to run M4 examples";
+	compatible = "st,stm32mp157f-ev1-m4-examples", "st,stm32mp157f-ev1", "st,stm32mp157f-ed1", "st,stm32mp157";
+};
+
+&adc {
+	status = "disabled";
+};
+
+&dac {
+	status = "disabled";
+};
+
+&dcmi {
+	status = "disabled";
+};
+
+&dma2 {
+	status = "disabled";
+};
+
+&dmamux1 {
+	dma-masters = <&dma1>;
+	dma-channels = <8>;
+};
+
+&fmc {
+	status = "disabled";
+};
+
+&i2c5 {
+	status = "disabled";
+};
+
+&m4_adc {
+	vref-supply = <&vdda>;
+	status = "okay";
+};
+
+&m4_crc2 {
+	status = "okay";
+};
+
+&m4_cryp2 {
+	status = "okay";
+};
+
+&m4_dac {
+	vref-supply = <&vdda>;
+	status = "okay";
+};
+
+&m4_dma2 {
+	status = "okay";
+};
+
+&m4_hash2 {
+	status = "okay";
+};
+
+&m4_i2c5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_i2c5_pins_a>;
+	status = "okay";
+};
+
+&m4_qspi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_qspi_clk_pins_a &m4_qspi_bk1_pins_a
+		     &m4_qspi_bk2_pins_a>;
+	status = "okay";
+};
+
+&m4_rng2 {
+	status = "okay";
+};
+
+&m4_rproc {
+	m4_system_resources {
+		status = "okay";
+
+	/*
+		button {
+			compatible = "rproc-srm-dev";
+			interrupt-parent = <&gpioa>;
+			interrupts = <14 2>;
+			interrupt-names = "irq";
+			status = "okay";
+		};
+	*/
+
+		m4_led: m4_led {
+			compatible = "rproc-srm-dev";
+			pinctrl-names = "default";
+			pinctrl-0 = <&m4_leds_orange_pins>;
+			status = "okay";
+		};
+	};
+};
+
+&m4_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_spi1_pins_a>;
+	status = "okay";
+};
+
+&m4_timers2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_pwm2_pins_a>;
+	status = "okay";
+};
+
+&m4_usart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_usart3_pins_a>;
+	status = "okay";
+};
+
+&pinctrl {
+	m4_leds_orange_pins: m4-leds-orange-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 8, RSVD)>;
+		};
+	};
+};
+
+&qspi {
+	status = "disabled";
+};
+
+&sai2b {
+	status = "disabled";
+};
+
+&sound {
+	status = "disabled";
+};
+
+&timers2 {
+	status = "disabled";
+};
diff --git a/arch/arm/boot/dts/stm32mp157f-ev1.dts b/arch/arm/boot/dts/stm32mp157f-ev1.dts
new file mode 100644
index 000000000..b831f0453
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157f-ev1.dts
@@ -0,0 +1,99 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157f-ed1.dts"
+#include "stm32mp15xx-evx.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP157F eval daughter on eval mother";
+	compatible = "st,stm32mp157f-ev1", "st,stm32mp157f-ed1", "st,stm32mp157";
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>;
+			status = "disabled";
+		};
+	};
+
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpiod 13 GPIO_ACTIVE_LOW>;
+		default-on;
+		status = "okay";
+	};
+};
+
+&dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out: endpoint {
+				remote-endpoint = <&dsi_panel_in>;
+			};
+		};
+	};
+
+	panel_dsi: panel-dsi@0 {
+		compatible = "raydium,rm68200";
+		reg = <0>;
+		reset-gpios = <&gpiof 15 GPIO_ACTIVE_LOW>;
+		backlight = <&panel_backlight>;
+		power-supply = <&v3v3>;
+		status = "okay";
+
+		port {
+			dsi_panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&i2c2 {
+	gt9147: goodix_ts@5d {
+		compatible = "goodix,gt9147";
+		reg = <0x5d>;
+		panel = <&panel_dsi>;
+		pinctrl-0 = <&goodix_pins>;
+		pinctrl-names = "default";
+		status = "okay";
+
+		interrupts = <14 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&stmfx_pinctrl>;
+	};
+};
+
+&ltdc {
+	status = "okay";
+
+	port {
+		ltdc_ep0_out: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&dsi_in>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp15xa.dtsi b/arch/arm/boot/dts/stm32mp15xa.dtsi
new file mode 100644
index 000000000..5ed7e594f
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp15xa.dtsi
@@ -0,0 +1,13 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+&cpu0_opp_table {
+		opp-650000000 {
+			opp-hz = /bits/ 64 <650000000>;
+			opp-microvolt = <1200000>;
+			opp-supported-hw = <0x1>;
+		};
+};
diff --git a/arch/arm/boot/dts/stm32mp15xc.dtsi b/arch/arm/boot/dts/stm32mp15xc.dtsi
index b06a55a2f..71787e804 100644
--- a/arch/arm/boot/dts/stm32mp15xc.dtsi
+++ b/arch/arm/boot/dts/stm32mp15xc.dtsi
@@ -4,14 +4,19 @@
  * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
  */
 
+#include "stm32mp15xa.dtsi"
+
 / {
 	soc {
 		cryp1: cryp@54001000 {
 			compatible = "st,stm32mp1-cryp";
 			reg = <0x54001000 0x400>;
 			interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc CRYP1>;
-			resets = <&rcc CRYP1_R>;
+			clocks = <&scmi_clk CK_SCMI_CRYP1>;
+			resets = <&scmi_reset RST_SCMI_CRYP1>;
+			dmas = <&mdma1 29 0x0 0x400202 0x0 0x0 0x0>,
+			       <&mdma1 30 0x3 0x400808 0x0 0x0 0x0>;
+			dma-names = "in", "out";
 			status = "disabled";
 		};
 	};
diff --git a/arch/arm/boot/dts/stm32mp15xd.dtsi b/arch/arm/boot/dts/stm32mp15xd.dtsi
new file mode 100644
index 000000000..e2f8b1297
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp15xd.dtsi
@@ -0,0 +1,42 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+&cpu0_opp_table {
+		opp-800000000 {
+			opp-hz = /bits/ 64 <800000000>;
+			opp-microvolt = <1350000>;
+			opp-supported-hw = <0x2>;
+		};
+		opp-400000000 {
+			opp-hz = /bits/ 64 <400000000>;
+			opp-microvolt = <1200000>;
+			opp-supported-hw = <0x2>;
+			opp-suspend;
+		};
+};
+
+&cpu_thermal {
+	trips {
+		cpu-crit {
+			temperature = <105000>;
+			hysteresis = <0>;
+			type = "critical";
+		};
+
+		cpu_alert: cpu-alert {
+			temperature = <95000>;
+			hysteresis = <10000>;
+			type = "passive";
+		};
+	};
+
+	cooling-maps {
+		map0 {
+			trip = <&cpu_alert>;
+			cooling-device = <&cpu0 1 1>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp15xf.dtsi b/arch/arm/boot/dts/stm32mp15xf.dtsi
new file mode 100644
index 000000000..26989fae4
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp15xf.dtsi
@@ -0,0 +1,23 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+#include "stm32mp15xd.dtsi"
+
+/ {
+	soc {
+		cryp1: cryp@54001000 {
+			compatible = "st,stm32mp1-cryp";
+			reg = <0x54001000 0x400>;
+			interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_CRYP1>;
+			resets = <&scmi_reset RST_SCMI_CRYP1>;
+			dmas = <&mdma1 29 0x0 0x400202 0x0 0x0 0x0>,
+			       <&mdma1 30 0x3 0x400808 0x0 0x0 0x0>;
+			dma-names = "in", "out";
+			status = "disabled";
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp15xx-dhcom-som.dtsi b/arch/arm/boot/dts/stm32mp15xx-dhcom-som.dtsi
index 8c41f819f..dfaf71b9a 100644
--- a/arch/arm/boot/dts/stm32mp15xx-dhcom-som.dtsi
+++ b/arch/arm/boot/dts/stm32mp15xx-dhcom-som.dtsi
@@ -82,15 +82,19 @@ &adc {
 	status = "okay";
 
 	adc1: adc@0 {
-		st,min-sample-time-nsecs = <5000>;
-		st,adc-channels = <0>;
 		status = "okay";
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 
 	adc2: adc@100 {
-		st,adc-channels = <1>;
-		st,min-sample-time-nsecs = <5000>;
 		status = "okay";
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 };
 
diff --git a/arch/arm/boot/dts/stm32mp15xx-dhcor-avenger96.dtsi b/arch/arm/boot/dts/stm32mp15xx-dhcor-avenger96.dtsi
index 8eb51d84b..9ae521097 100644
--- a/arch/arm/boot/dts/stm32mp15xx-dhcor-avenger96.dtsi
+++ b/arch/arm/boot/dts/stm32mp15xx-dhcor-avenger96.dtsi
@@ -114,15 +114,35 @@ &adc {
 	status = "okay";
 
 	adc1: adc@0 {
-		st,adc-channels = <0 1 6>;
-		st,min-sample-time-nsecs = <5000>;
 		status = "okay";
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 
 	adc2: adc@100 {
-		st,adc-channels = <0 1 2>;
-		st,min-sample-time-nsecs = <5000>;
 		status = "okay";
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@2 {
+			reg = <2>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 };
 
diff --git a/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi b/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
index 48beed0f1..58bb9eca8 100644
--- a/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
+++ b/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
@@ -4,10 +4,19 @@
  * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
  */
 
+#include "stm32mp15-m4-srm.dtsi"
+#include "stm32mp15-m4-srm-pinctrl.dtsi"
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/mfd/st,stpmic1.h>
 
 / {
+	aliases {
+		ethernet0 = &ethernet0;
+		serial0 = &uart4;
+		serial1 = &usart3;
+		serial2 = &uart7;
+	};
+
 	memory@c0000000 {
 		device_type = "memory";
 		reg = <0xc0000000 0x20000000>;
@@ -42,6 +51,12 @@ vdev0buffer: vdev0buffer@10042000 {
 			no-map;
 		};
 
+		mcu_rsc_table: mcu_rsc_table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
 		mcuram: mcuram@30000000 {
 			compatible = "shared-dma-pool";
 			reg = <0x30000000 0x40000>;
@@ -58,6 +73,11 @@ gpu_reserved: gpu@d4000000 {
 			reg = <0xd4000000 0x4000000>;
 			no-map;
 		};
+
+		optee@de000000 {
+			reg = <0xde000000 0x2000000>;
+			no-map;
+		};
 	};
 
 	led {
@@ -70,9 +90,9 @@ led-blue {
 		};
 	};
 
-	sound {
+	sound: sound {
 		compatible = "audio-graph-card";
-		label = "STM32MP1-DK";
+		label = "STM32MP15-DK";
 		routing =
 			"Playback" , "MCLK",
 			"Capture" , "MCLK",
@@ -92,28 +112,39 @@ vin: vin {
 
 &adc {
 	pinctrl-names = "default";
-	pinctrl-0 = <&adc12_ain_pins_a>, <&adc12_usb_cc_pins_a>;
+	pinctrl-0 = <&adc12_usb_cc_pins_a>;
 	vdd-supply = <&vdd>;
 	vdda-supply = <&vdd>;
 	vref-supply = <&vrefbuf>;
-	status = "disabled";
+	status = "okay";
 	adc1: adc@0 {
+		status = "okay";
 		/*
 		 * Type-C USB_PWR_CC1 & USB_PWR_CC2 on in18 & in19.
 		 * Use at least 5 * RC time, e.g. 5 * (Rp + Rd) * C:
 		 * 5 * (56 + 47kOhms) * 5pF => 2.5us.
 		 * Use arbitrary margin here (e.g. 5us).
 		 */
-		st,min-sample-time-nsecs = <5000>;
-		/* AIN connector, USB Type-C CC1 & CC2 */
-		st,adc-channels = <0 1 6 13 18 19>;
-		status = "okay";
+		channel@18 {
+			reg = <18>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@19 {
+			reg = <19>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 	adc2: adc@100 {
-		/* AIN connector, USB Type-C CC1 & CC2 */
-		st,adc-channels = <0 1 2 6 18 19>;
-		st,min-sample-time-nsecs = <5000>;
 		status = "okay";
+		/* USB Type-C CC1 & CC2 */
+		channel@18 {
+			reg = <18>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@19 {
+			reg = <19>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 };
 
@@ -124,10 +155,26 @@ &cec {
 	status = "okay";
 };
 
+&cpu0{
+	cpu-supply = <&vddcore>;
+};
+
+&cpu1{
+	cpu-supply = <&vddcore>;
+};
+
 &crc1 {
 	status = "okay";
 };
 
+&dma1 {
+	sram = <&dma_pool>;
+};
+
+&dma2 {
+	sram = <&dma_pool>;
+};
+
 &dts {
 	status = "okay";
 };
@@ -140,6 +187,8 @@ &ethernet0 {
 	phy-mode = "rgmii-id";
 	max-speed = <1000>;
 	phy-handle = <&phy0>;
+	nvmem-cells = <&ethernet_mac_address>;
+	nvmem-cell-names = "mac-address";
 
 	mdio0 {
 		#address-cells = <1>;
@@ -273,7 +322,7 @@ con_usbotg_hs_ep: endpoint {
 	pmic: stpmic@33 {
 		compatible = "st,stpmic1";
 		reg = <0x33>;
-		interrupts-extended = <&gpioa 0 IRQ_TYPE_EDGE_FALLING>;
+		interrupts-extended = <&exti 55 IRQ_TYPE_EDGE_FALLING>;
 		interrupt-controller;
 		#interrupt-cells = <2>;
 		status = "okay";
@@ -382,21 +431,21 @@ vref_ddr: vref_ddr {
 				regulator-always-on;
 			};
 
-			 bst_out: boost {
+			bst_out: boost {
 				regulator-name = "bst_out";
 				interrupts = <IT_OCP_BOOST 0>;
-			 };
+			};
 
 			vbus_otg: pwr_sw1 {
 				regulator-name = "vbus_otg";
 				interrupts = <IT_OCP_OTG 0>;
-			 };
+			};
 
-			 vbus_sw: pwr_sw2 {
+			vbus_sw: pwr_sw2 {
 				regulator-name = "vbus_sw";
 				interrupts = <IT_OCP_SWOUT 0>;
 				regulator-active-discharge = <1>;
-			 };
+			};
 		};
 
 		onkey {
@@ -469,11 +518,12 @@ ltdc_ep0_out: endpoint@0 {
 
 &m4_rproc {
 	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
-			<&vdev0vring1>, <&vdev0buffer>;
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
 	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
 	mbox-names = "vq0", "vq1", "shutdown", "detach";
 	interrupt-parent = <&exti>;
 	interrupts = <68 1>;
+	wakeup-source;
 	status = "okay";
 };
 
@@ -482,10 +532,6 @@ &pwr_regulators {
 	vdd_3v3_usbfs-supply = <&vdd_usb>;
 };
 
-&rng1 {
-	status = "okay";
-};
-
 &rtc {
 	status = "okay";
 };
@@ -501,8 +547,6 @@ &sai2 {
 	sai2a: audio-controller@4400b004 {
 		#clock-cells = <0>;
 		dma-names = "tx";
-		clocks = <&rcc SAI2_K>;
-		clock-names = "sai_ck";
 		status = "okay";
 
 		sai2a_port: port {
@@ -560,6 +604,27 @@ &sdmmc3 {
 	status = "disabled";
 };
 
+&spi4 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi4_pins_b>;
+	pinctrl-1 = <&spi4_sleep_pins_b>;
+	status = "disabled";
+};
+
+&spi5 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi5_pins_a>;
+	pinctrl-1 = <&spi5_sleep_pins_a>;
+	status = "disabled";
+};
+
+&sram {
+	dma_pool: dma_pool@0 {
+		reg = <0x50000 0x10000>;
+		pool;
+	};
+};
+
 &timers1 {
 	/* spare dmas for other usage */
 	/delete-property/dmas;
@@ -650,6 +715,8 @@ &uart4 {
 	pinctrl-0 = <&uart4_pins_a>;
 	pinctrl-1 = <&uart4_sleep_pins_a>;
 	pinctrl-2 = <&uart4_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
 	status = "okay";
 };
 
@@ -658,6 +725,8 @@ &uart7 {
 	pinctrl-0 = <&uart7_pins_c>;
 	pinctrl-1 = <&uart7_sleep_pins_c>;
 	pinctrl-2 = <&uart7_idle_pins_c>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
 	status = "disabled";
 };
 
@@ -694,10 +763,36 @@ &usbphyc {
 
 &usbphyc_port0 {
 	phy-supply = <&vdd_usb>;
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+
+	/*
+	 * Hack to keep hub active until all connected devices are suspended
+	 * otherwise the hub will be powered off as soon as the v3v3 is disabled
+	 * and it can disturb connected devices.
+	 */
+	connector {
+		compatible = "usb-a-connector";
+		vbus-supply = <&v3v3>;
+	};
 };
 
 &usbphyc_port1 {
 	phy-supply = <&vdd_usb>;
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
 };
 
 &vrefbuf {
diff --git a/arch/arm/boot/dts/stm32mp15xx-edx.dtsi b/arch/arm/boot/dts/stm32mp15xx-edx.dtsi
new file mode 100644
index 000000000..014ce3863
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp15xx-edx.dtsi
@@ -0,0 +1,429 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
+ * Author: Ludovic Barre <ludovic.barre@st.com> for STMicroelectronics.
+ */
+
+#include "stm32mp15-m4-srm.dtsi"
+#include "stm32mp15-m4-srm-pinctrl.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/mfd/st,stpmic1.h>
+
+/ {
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xC0000000 0x40000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		mcuram2: mcuram2@10000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10000000 0x40000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@10040000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10040000 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@10041000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10041000 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@10042000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10042000 0x4000>;
+			no-map;
+		};
+
+		mcu_rsc_table: mcu_rsc_table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
+		mcuram: mcuram@30000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x30000000 0x40000>;
+			no-map;
+		};
+
+		retram: retram@38000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x38000000 0x10000>;
+			no-map;
+		};
+
+		optee@fe000000 {
+			reg = <0xfe000000 0x2000000>;
+			no-map;
+		};
+	};
+
+	aliases {
+		serial0 = &uart4;
+	};
+
+	led {
+		compatible = "gpio-leds";
+		led-blue {
+			label = "heartbeat";
+			gpios = <&gpiod 9 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	sd_switch: regulator-sd_switch {
+		compatible = "regulator-gpio";
+		regulator-name = "sd_switch";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2900000>;
+		regulator-type = "voltage";
+		regulator-always-on;
+
+		gpios = <&gpiof 14 GPIO_ACTIVE_HIGH>;
+		gpios-states = <0>;
+		states = <1800000 0x1>,
+			 <2900000 0x0>;
+	};
+
+	vin: vin {
+		compatible = "regulator-fixed";
+		regulator-name = "vin";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+};
+
+&adc {
+	/* ANA0, ANA1 are dedicated pins and don't need pinctrl: only in6. */
+	pinctrl-0 = <&adc1_in6_pins_a>;
+	pinctrl-names = "default";
+	vdd-supply = <&vdd>;
+	vdda-supply = <&vdda>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	adc1: adc@0 {
+		status = "okay";
+		channel@0 {
+			reg = <0>;
+			/* 16.5 ck_cycles sampling time */
+			st,min-sample-time-ns = <400>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <400>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <400>;
+		};
+	};
+};
+
+&cpu0{
+	cpu-supply = <&vddcore>;
+};
+
+&cpu1{
+	cpu-supply = <&vddcore>;
+};
+
+&crc1 {
+	status = "okay";
+};
+
+&dac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&dac_ch1_pins_a &dac_ch2_pins_a>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	dac1: dac@1 {
+		status = "okay";
+	};
+	dac2: dac@2 {
+		status = "okay";
+	};
+};
+
+&dma1 {
+	sram = <&dma_pool>;
+};
+
+&dma2 {
+	sram = <&dma_pool>;
+};
+
+&dts {
+	status = "okay";
+};
+
+&hash1 {
+	status = "okay";
+};
+
+&i2c4 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c4_pins_a>;
+	pinctrl-1 = <&i2c4_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+		interrupts-extended = <&exti 55 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		status = "okay";
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			buck1-supply = <&vin>;
+			buck2-supply = <&vin>;
+			buck3-supply = <&vin>;
+			buck4-supply = <&vin>;
+			ldo1-supply = <&v3v3>;
+			ldo2-supply = <&v3v3>;
+			ldo3-supply = <&vdd_ddr>;
+			ldo4-supply = <&vin>;
+			ldo5-supply = <&v3v3>;
+			ldo6-supply = <&v3v3>;
+			vref_ddr-supply = <&vin>;
+			boost-supply = <&vin>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&bst_out>;
+
+			vddcore: buck1 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			v3v3: buck4 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+				regulator-initial-mode = <0>;
+			};
+
+			vdda: ldo1 {
+				regulator-name = "vdda";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO1 0>;
+			};
+
+			v2v8: ldo2 {
+				regulator-name = "v2v8";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				interrupts = <IT_CURLIM_LDO2 0>;
+			};
+
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <750000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				interrupts = <IT_CURLIM_LDO4 0>;
+			};
+
+			vdd_sd: ldo5 {
+				regulator-name = "vdd_sd";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO5 0>;
+				regulator-boot-on;
+			};
+
+			v1v8: ldo6 {
+				regulator-name = "v1v8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				interrupts = <IT_CURLIM_LDO6 0>;
+			};
+
+			vref_ddr: vref_ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+				interrupts = <IT_OCP_BOOST 0>;
+			};
+
+			vbus_otg: pwr_sw1 {
+				regulator-name = "vbus_otg";
+				interrupts = <IT_OCP_OTG 0>;
+			};
+
+			vbus_sw: pwr_sw2 {
+				regulator-name = "vbus_sw";
+				interrupts = <IT_OCP_SWOUT 0>;
+				regulator-active-discharge = <1>;
+			};
+		};
+
+		onkey {
+			compatible = "st,stpmic1-onkey";
+			interrupts = <IT_PONKEY_F 0>, <IT_PONKEY_R 0>;
+			interrupt-names = "onkey-falling", "onkey-rising";
+			power-off-time-sec = <10>;
+			status = "okay";
+		};
+
+		watchdog {
+			compatible = "st,stpmic1-wdt";
+			status = "disabled";
+		};
+	};
+};
+
+&ipcc {
+	status = "okay";
+};
+
+&iwdg2 {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&m4_rproc {
+	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
+	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
+	mbox-names = "vq0", "vq1", "shutdown", "detach";
+	interrupt-parent = <&exti>;
+	interrupts = <68 1>;
+	wakeup-source;
+	status = "okay";
+};
+
+&pwr_regulators {
+	vdd-supply = <&vdd>;
+	vdd_3v3_usbfs-supply = <&vdd_usb>;
+};
+
+&rtc {
+	status = "okay";
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a &sdmmc1_dir_sleep_pins_a>;
+	cd-gpios = <&gpiog 1 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,sig-dir;
+	st,neg-edge;
+	st,use-ckin;
+	bus-width = <4>;
+	vmmc-supply = <&vdd_sd>;
+	vqmmc-supply = <&sd_switch>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&v3v3>;
+	vqmmc-supply = <&vdd>;
+	mmc-ddr-3_3v;
+	status = "okay";
+};
+
+&sram {
+	dma_pool: dma_pool@0 {
+		reg = <0x50000 0x10000>;
+		pool;
+	};
+};
+
+&timers6 {
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	timer@5 {
+		status = "okay";
+	};
+};
+
+&uart4 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&uart4_pins_a>;
+	pinctrl-1 = <&uart4_sleep_pins_a>;
+	pinctrl-2 = <&uart4_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usbotg_hs {
+	vbus-supply = <&vbus_otg>;
+};
+
+&usbphyc_port0 {
+	phy-supply = <&vdd_usb>;
+};
+
+&usbphyc_port1 {
+	phy-supply = <&vdd_usb>;
+};
diff --git a/arch/arm/boot/dts/stm32mp15xx-evx.dtsi b/arch/arm/boot/dts/stm32mp15xx-evx.dtsi
new file mode 100644
index 000000000..fe8a8dfc4
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp15xx-evx.dtsi
@@ -0,0 +1,698 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
+ * Author: Ludovic Barre <ludovic.barre@st.com> for STMicroelectronics.
+ */
+
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/soc/stm32-hdp.h>
+
+/ {
+	aliases {
+		ethernet0 = &ethernet0;
+		serial1 = &usart3;
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+	};
+
+	joystick {
+		compatible = "gpio-keys";
+		pinctrl-0 = <&joystick_pins>;
+		pinctrl-names = "default";
+		button-0 {
+			label = "JoySel";
+			linux,code = <KEY_ENTER>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <0 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-1 {
+			label = "JoyDown";
+			linux,code = <KEY_DOWN>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <1 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-2 {
+			label = "JoyLeft";
+			linux,code = <KEY_LEFT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <2 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-3 {
+			label = "JoyRight";
+			linux,code = <KEY_RIGHT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <3 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-4 {
+			label = "JoyUp";
+			linux,code = <KEY_UP>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <4 IRQ_TYPE_EDGE_RISING>;
+		};
+	};
+
+	spdif_out: spdif-out {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dit";
+		status = "okay";
+
+		spdif_out_port: port {
+			spdif_out_endpoint: endpoint {
+				remote-endpoint = <&sai4a_endpoint>;
+			};
+		};
+	};
+
+	spdif_in: spdif-in {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dir";
+		status = "okay";
+
+		spdif_in_port: port {
+			spdif_in_endpoint: endpoint {
+				remote-endpoint = <&spdifrx_endpoint>;
+			};
+		};
+	};
+
+	sound: sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP15-EV";
+		routing =
+			"AIF1CLK" , "MCLK1",
+			"AIF2CLK" , "MCLK1",
+			"IN1LN" , "MICBIAS2",
+			"DMIC2DAT" , "MICBIAS1",
+			"DMIC1DAT" , "MICBIAS1";
+		dais = <&sai2a_port &sai2b_port &sai4a_port &spdifrx_port
+			&dfsdm0_port &dfsdm1_port &dfsdm2_port &dfsdm3_port>;
+		status = "okay";
+	};
+
+	dmic0: dmic-0 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic0";
+		status = "okay";
+
+		port {
+			dmic0_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint0>;
+			};
+		};
+	};
+
+	dmic1: dmic-1 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic1";
+		status = "okay";
+
+		port {
+			dmic1_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint1>;
+			};
+		};
+	};
+
+	dmic2: dmic-2 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic2";
+		status = "okay";
+
+		port {
+			dmic2_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint2>;
+			};
+		};
+	};
+
+	dmic3: dmic-3 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic3";
+		status = "okay";
+
+		port {
+			dmic3_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint3>;
+			};
+		};
+	};
+
+};
+
+&cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cec_pins_a>;
+	status = "okay";
+};
+
+&dcmi {
+	status = "okay";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dcmi_pins_a>;
+	pinctrl-1 = <&dcmi_sleep_pins_a>;
+
+	port {
+		dcmi_0: endpoint {
+			remote-endpoint = <&ov5640_0>;
+			bus-type = <5>;
+			bus-width = <8>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			pclk-sample = <1>;
+			pclk-max-frequency = <77000000>;
+		};
+	};
+};
+
+&dfsdm {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dfsdm_clkout_pins_a
+		     &dfsdm_data1_pins_a &dfsdm_data3_pins_a>;
+	pinctrl-1 = <&dfsdm_clkout_sleep_pins_a
+		     &dfsdm_data1_sleep_pins_a &dfsdm_data3_sleep_pins_a>;
+	spi-max-frequency = <2048000>;
+
+	clocks = <&rcc DFSDM_K>, <&rcc ADFSDM_K>;
+	clock-names = "dfsdm", "audio";
+	status = "okay";
+
+	dfsdm0: filter@0 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <3>;
+		st,adc-channel-names = "dmic_u1";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm0: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm0 0>;
+			status = "okay";
+
+			dfsdm0_port: port {
+				dfsdm_endpoint0: endpoint {
+					remote-endpoint = <&dmic0_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm1: filter@1 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <0>;
+		st,adc-channel-names = "dmic_u2";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		st,adc-alt-channel = <1>;
+		status = "okay";
+
+		asoc_pdm1: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm1 0>;
+			status = "okay";
+
+			dfsdm1_port: port {
+				dfsdm_endpoint1: endpoint {
+					remote-endpoint = <&dmic1_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm2: filter@2 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <2>;
+		st,adc-channel-names = "dmic_u3";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,adc-alt-channel = <1>;
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm2: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm2 0>;
+			status = "okay";
+
+			dfsdm2_port: port {
+				dfsdm_endpoint2: endpoint {
+					remote-endpoint = <&dmic2_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm3: filter@3 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <1>;
+		st,adc-channel-names = "dmic_u4";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm3: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm3 0>;
+			status = "okay";
+
+			dfsdm3_port: port {
+				dfsdm_endpoint3: endpoint {
+					remote-endpoint = <&dmic3_endpoint>;
+				};
+			};
+		};
+	};
+};
+
+&ethernet0 {
+	status = "okay";
+	pinctrl-0 = <&ethernet0_rgmii_pins_a>;
+	pinctrl-1 = <&ethernet0_rgmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy0>;
+
+	mdio0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy0: ethernet-phy@0 {
+			reg = <0>;
+		};
+	};
+};
+
+&fmc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&fmc_pins_a>;
+	pinctrl-1 = <&fmc_sleep_pins_a>;
+	status = "okay";
+
+	nand-controller@4,0 {
+		status = "okay";
+
+		nand@0 {
+			reg = <0>;
+			nand-on-flash-bbt;
+			#address-cells = <1>;
+			#size-cells = <1>;
+		};
+	};
+};
+
+&hdp {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&hdp0_pins_a &hdp6_pins_a &hdp7_pins_a>;
+	pinctrl-1 = <&hdp0_pins_sleep_a &hdp6_pins_sleep_a &hdp7_pins_sleep_a>;
+	status = "disabled";
+
+	muxing-hdp = <(STM32_HDP(0, HDP0_GPOVAL_0) |
+		       STM32_HDP(6, HDP6_GPOVAL_6) |
+		       STM32_HDP(7, HDP7_GPOVAL_7))>;
+};
+
+&i2c2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c2_pins_a>;
+	pinctrl-1 = <&i2c2_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	status = "okay";
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	wm8994: wm8994@1b {
+		compatible = "wlf,wm8994";
+		#sound-dai-cells = <0>;
+		reg = <0x1b>;
+		status = "okay";
+
+		gpio-controller;
+		#gpio-cells = <2>;
+
+		DBVDD-supply = <&vdd>;
+		SPKVDD1-supply = <&vdd>;
+		SPKVDD2-supply = <&vdd>;
+		AVDD2-supply = <&v1v8>;
+		CPVDD-supply = <&v1v8>;
+
+		wlf,ldoena-always-driven;
+
+		clocks = <&sai2a>;
+		clock-names = "MCLK1";
+
+		wlf,gpio-cfg = <0x8101 0xa100 0xa100 0xa100 0xa101 0xa101 0xa100 0xa101 0xa101 0xa101 0xa101>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			wm8994_tx_port: port@0 {
+				reg = <0>;
+				wm8994_tx_endpoint: endpoint {
+					remote-endpoint = <&sai2a_endpoint>;
+				};
+			};
+
+			wm8994_rx_port: port@1 {
+				reg = <1>;
+				wm8994_rx_endpoint: endpoint {
+					remote-endpoint = <&sai2b_endpoint>;
+				};
+			};
+		};
+	};
+
+	ov5640: camera@3c {
+		compatible = "ovti,ov5640";
+		reg = <0x3c>;
+		clocks = <&clk_ext_camera>;
+		clock-names = "xclk";
+		DOVDD-supply = <&v2v8>;
+		powerdown-gpios = <&stmfx_pinctrl 18 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		reset-gpios = <&stmfx_pinctrl 19 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		rotation = <180>;
+		status = "okay";
+
+		port {
+			ov5640_0: endpoint {
+				remote-endpoint = <&dcmi_0>;
+				bus-width = <8>;
+				data-shift = <2>; /* lines 9:2 are used */
+				hsync-active = <0>;
+				vsync-active = <0>;
+				pclk-sample = <1>;
+				pclk-max-frequency = <77000000>;
+			};
+		};
+	};
+
+	stmfx: stmfx@42 {
+		compatible = "st,stmfx-0300";
+		reg = <0x42>;
+		interrupts = <8 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&gpioi>;
+		vdd-supply = <&v3v3>;
+
+		stmfx_pinctrl: pinctrl {
+			compatible = "st,stmfx-0300-pinctrl";
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			gpio-ranges = <&stmfx_pinctrl 0 0 24>;
+
+			goodix_pins: goodix {
+				pins = "gpio14";
+				bias-pull-down;
+			};
+
+			joystick_pins: joystick-pins {
+				pins = "gpio0", "gpio1", "gpio2", "gpio3", "gpio4";
+				bias-pull-down;
+			};
+		};
+	};
+};
+
+&i2c4 {
+	pmic: stpmic@33 {
+		regulators {
+			v1v8: ldo6 {
+				regulator-enable-ramp-delay = <300000>;
+			};
+		};
+	};
+};
+
+&i2c5 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c5_pins_a>;
+	pinctrl-1 = <&i2c5_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&m_can1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&m_can1_pins_a>;
+	pinctrl-1 = <&m_can1_sleep_pins_a>;
+	status = "okay";
+};
+
+&qspi {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&qspi_clk_pins_a
+		     &qspi_bk1_pins_a
+		     &qspi_cs1_pins_a
+		     &qspi_bk2_pins_a
+		     &qspi_cs2_pins_a>;
+	pinctrl-1 = <&qspi_clk_sleep_pins_a
+		     &qspi_bk1_sleep_pins_a
+		     &qspi_cs1_sleep_pins_a
+		     &qspi_bk2_sleep_pins_a
+		     &qspi_cs2_sleep_pins_a>;
+	reg = <0x58003000 0x1000>, <0x70000000 0x4000000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	flash0: mx66l51235l@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+
+	flash1: mx66l51235l@1 {
+		compatible = "jedec,spi-nor";
+		reg = <1>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&sai2 {
+	clocks = <&rcc SAI2>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sai2a_pins_a>, <&sai2b_pins_a>;
+	pinctrl-1 = <&sai2a_sleep_pins_a>, <&sai2b_sleep_pins_a>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai2a: audio-controller@4400b004 {
+		#clock-cells = <0>;
+		dma-names = "tx";
+		status = "okay";
+
+		sai2a_port: port {
+			sai2a_endpoint: endpoint {
+				remote-endpoint = <&wm8994_tx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+
+	sai2b: audio-controller@4400b024 {
+		dma-names = "rx";
+		clocks = <&rcc SAI2_K>, <&sai2a>;
+		clock-names = "sai_ck", "MCLK";
+		status = "okay";
+
+		sai2b_port: port {
+			sai2b_endpoint: endpoint {
+				remote-endpoint = <&wm8994_rx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+};
+
+&sai4 {
+	clocks = <&rcc SAI4>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai4a: audio-controller@50027004 {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&sai4a_pins_a>;
+		pinctrl-1 = <&sai4a_sleep_pins_a>;
+		dma-names = "tx";
+		st,iec60958;
+		status = "okay";
+
+		sai4a_port: port {
+			sai4a_endpoint: endpoint {
+				remote-endpoint = <&spdif_out_endpoint>;
+			};
+		};
+	};
+};
+
+&sdmmc3 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc3_b4_pins_a>;
+	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+	broken-cd;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	status = "disabled";
+};
+
+&spdifrx {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spdifrx_pins_a>;
+	pinctrl-1 = <&spdifrx_sleep_pins_a>;
+	status = "okay";
+
+	spdifrx_port: port {
+		spdifrx_endpoint: endpoint {
+			remote-endpoint = <&spdif_in_endpoint>;
+		};
+	};
+};
+
+&spi1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi1_pins_a>;
+	pinctrl-1 = <&spi1_sleep_pins_a>;
+	status = "disabled";
+};
+
+&timers2 {
+	/* spare dmas for other usage (un-delete to enable pwm capture) */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm2_pins_a>;
+		pinctrl-1 = <&pwm2_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@1 {
+		status = "okay";
+	};
+};
+
+&timers8 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm8_pins_a>;
+		pinctrl-1 = <&pwm8_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@7 {
+		status = "okay";
+	};
+};
+
+&timers12 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm12_pins_a>;
+		pinctrl-1 = <&pwm12_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@11 {
+		status = "okay";
+	};
+};
+
+&usart3 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart3_pins_b>;
+	pinctrl-1 = <&usart3_sleep_pins_b>;
+	pinctrl-2 = <&usart3_idle_pins_b>;
+	/*
+	 * HW flow control USART3_RTS is optional, and isn't default wired to
+	 * the connector. SB23 needs to be soldered in order to use it, and R77
+	 * (ETH_CLK) should be removed.
+	 */
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usbh_ehci {
+	phys = <&usbphyc_port0>;
+	status = "okay";
+};
+
+&usbotg_hs {
+	pinctrl-0 = <&usbotg_hs_pins_a>;
+	pinctrl-names = "default";
+	phys = <&usbphyc_port1 0>;
+	phy-names = "usb2-phy";
+	status = "okay";
+};
+
+&usbphyc {
+	status = "okay";
+};
+
+&usbphyc_port0 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+
+	/*
+	 * Hack to keep hub active until all connected devices are suspended
+	 * otherwise the hub will be powered off as soon as the v3v3 is disabled
+	 * and it can disturb connected devices.
+	 */
+	connector {
+		compatible = "usb-a-connector";
+		vbus-supply = <&v3v3>;
+	};
+};
+
+&usbphyc_port1 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+};
diff --git a/arch/arm/configs/fragment-01-multiv7_cleanup.config b/arch/arm/configs/fragment-01-multiv7_cleanup.config
new file mode 100644
index 000000000..52f28a765
--- /dev/null
+++ b/arch/arm/configs/fragment-01-multiv7_cleanup.config
@@ -0,0 +1,408 @@
+#
+# CPU Core family selection
+#
+# CONFIG_ARCH_VIRT is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_ALPINE is not set
+# CONFIG_ARCH_ARTPEC is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCM is not set
+# CONFIG_ARCH_BERLIN is not set
+# CONFIG_ARCH_DIGICOLOR is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_HISI is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MEDIATEK is not set
+# CONFIG_ARCH_ACTIONS is not set
+# CONFIG_ARCH_ASPEED is not set
+# CONFIG_ARCH_ARCH_MILBEAU is not set
+# CONFIG_ARCH_INTEL_SOCFPGA is not set
+
+# Generic Pulse-Width Modulation (PWM) support
+# CONFIG_PWM_ATMEL_TCB is not set
+
+# network driver
+# CONFIG_NET_VENDOR_ACTIONS is not set
+
+# clock driver
+# CONFIG_CLK_ACTIONS is not set
+
+#
+# TI OMAP/AM/DM/DRA Family
+#
+# CONFIG_ARCH_OMAP3 is not set
+# CONFIG_ARCH_OMAP4 is not set
+# CONFIG_SOC_OMAP5 is not set
+# CONFIG_SOC_AM33XX is not set
+# CONFIG_SOC_AM43XX is not set
+# CONFIG_SOC_DRA7XX is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_QCOM is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_STI is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_RENESAS is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_SIRF is not set
+# CONFIG_ARCH_TANGO is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_WM8850 is not set
+# CONFIG_ARCH_ZX is not set
+# CONFIG_ARCH_ZYNQ is not set
+
+# CONFIG_CAN_RCAR is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_STAGING is not set
+# CONFIG_CHROME_PLATFORMS is not set
+# CONFIG_SOC_BRCMSTB is not set
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+# CONFIG_SECTION_MISMATCH_WARN_ONLY is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+
+#
+# Processor Features
+#
+# CONFIG_CACHE_L2X0 is not set
+#
+# Bus support
+#
+# CONFIG_PCI is not set
+# CONFIG_PCI_DOMAINS_GENERIC is not set
+# CONFIG_PCI_SYSCALL is not set
+
+#
+# Kernel Features
+#
+# CONFIG_PREEMPT_NONE is not set
+
+#
+# Boot options
+#
+# CONFIG_ATAGS is not set
+# CONFIG_KEXEC is not set
+# CONFIG_EFI is not set
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MICROCHIP_PHY is not set
+# CONFIG_USB_LAN78XX is not set
+#
+# CAN SPI interfaces
+#
+# CONFIG_CAN_MCP251X is not set
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_ST_ASC is not set
+# CONFIG_VIRTIO_CONSOLE is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_SLAVE_EEPROM is not set
+
+#
+# STMicroelectronics STMPE Interface Drivers
+#
+# CONFIG_REGULATOR_WM8994 is not set
+
+#
+# Media ancillary drivers (tuners, sensors, i2c, spi, frontends)
+#
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+
+#
+# MII PHY device drivers
+#
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_DWC3 is not set
+
+#
+# USB GPIO expanders
+#
+# CONFIG_POWER_AVS is not set
+# CONFIG_POWER_SUPPLY is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_SCHED_DEBUG is not set
+
+# SPI NOR device support
+# CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
+
+# parallel NAND support
+# CONFIG_MTD_NAND_PL35X is not set
+
+#
+# Media core support
+#
+# CONFIG_DVB_CORE is not set
+# CONFIG_MEDIA_TUNER is not set
+# CONFIG_MEDIA_CONTROLLER_REQUEST_API is not set
+
+# Digital TV options
+#
+# CONFIG_DVB_NET is not set
+# CONFIG_DVB_MAX_ADAPTERS is not set
+# CONFIG_DVB_DYNAMIC_MINORS is not set
+# end of Digital TV options
+
+#
+# Media SPI Adapters
+#
+# CONFIG_CXD2880_SPI_DRV is not set
+# end of Media SPI Adapters
+
+#
+# Customize TV tuners
+#
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA18250 is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MSI001 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2063 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_XC4000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_FC0011 is not set
+# CONFIG_MEDIA_TUNER_FC0012 is not set
+# CONFIG_MEDIA_TUNER_FC0013 is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+# CONFIG_MEDIA_TUNER_E4000 is not set
+# CONFIG_MEDIA_TUNER_FC2580 is not set
+# CONFIG_MEDIA_TUNER_M88RS6000T is not set
+# CONFIG_MEDIA_TUNER_TUA9001 is not set
+# CONFIG_MEDIA_TUNER_SI2157 is not set
+# CONFIG_MEDIA_TUNER_IT913X is not set
+# CONFIG_MEDIA_TUNER_R820T is not set
+# CONFIG_MEDIA_TUNER_MXL301RF is not set
+# CONFIG_MEDIA_TUNER_QM1D1C0042 is not set
+# CONFIG_MEDIA_TUNER_QM1D1B0004 is not set
+# end of Customize TV tuners
+#
+# Customise DVB Frontends
+#
+
+#
+# Multistandard (satellite) frontends
+#
+# CONFIG_DVB_STB0899 is not set
+# CONFIG_DVB_STB6100 is not set
+# CONFIG_DVB_STV090x is not set
+# CONFIG_DVB_STV0910 is not set
+# CONFIG_DVB_STV6110x is not set
+# CONFIG_DVB_STV6111 is not set
+# CONFIG_DVB_MXL5XX is not set
+# CONFIG_DVB_M88DS3103 is not set
+
+#
+# Multistandard (cable + terrestrial) frontends
+#
+# CONFIG_DVB_DRXK is not set
+# CONFIG_DVB_TDA18271C2DD is not set
+# CONFIG_DVB_SI2165 is not set
+# CONFIG_DVB_MN88472 is not set
+# CONFIG_DVB_MN88473 is not set
+
+#
+# DVB-S (satellite) frontends
+#
+# CONFIG_DVB_CX24110 is not set
+# CONFIG_DVB_CX24123 is not set
+# CONFIG_DVB_MT312 is not set
+# CONFIG_DVB_ZL10036 is not set
+# CONFIG_DVB_ZL10039 is not set
+# CONFIG_DVB_S5H1420 is not set
+# CONFIG_DVB_STV0288 is not set
+# CONFIG_DVB_STB6000 is not set
+# CONFIG_DVB_STV0299 is not set
+# CONFIG_DVB_STV6110 is not set
+# CONFIG_DVB_STV0900 is not set
+# CONFIG_DVB_TDA8083 is not set
+# CONFIG_DVB_TDA10086 is not set
+# CONFIG_DVB_TDA8261 is not set
+# CONFIG_DVB_VES1X93 is not set
+# CONFIG_DVB_TUNER_ITD1000 is not set
+# CONFIG_DVB_TUNER_CX24113 is not set
+# CONFIG_DVB_TDA826X is not set
+# CONFIG_DVB_TUA6100 is not set
+# CONFIG_DVB_CX24116 is not set
+# CONFIG_DVB_CX24117 is not set
+# CONFIG_DVB_CX24120 is not set
+# CONFIG_DVB_SI21XX is not set
+# CONFIG_DVB_TS2020 is not set
+# CONFIG_DVB_DS3000 is not set
+# CONFIG_DVB_MB86A16 is not set
+# CONFIG_DVB_TDA10071 is not set
+
+#
+# DVB-T (terrestrial) frontends
+#
+# CONFIG_DVB_SP8870 is not set
+# CONFIG_DVB_SP887X is not set
+# CONFIG_DVB_CX22700 is not set
+# CONFIG_DVB_CX22702 is not set
+# CONFIG_DVB_S5H1432 is not set
+# CONFIG_DVB_DRXD is not set
+# CONFIG_DVB_L64781 is not set
+# CONFIG_DVB_TDA1004X is not set
+# CONFIG_DVB_NXT6000 is not set
+# CONFIG_DVB_MT352 is not set
+# CONFIG_DVB_ZL10353 is not set
+# CONFIG_DVB_DIB3000MB is not set
+# CONFIG_DVB_DIB3000MC is not set
+# CONFIG_DVB_DIB7000M is not set
+# CONFIG_DVB_DIB7000P is not set
+# CONFIG_DVB_DIB9000 is not set
+# CONFIG_DVB_TDA10048 is not set
+# CONFIG_DVB_AF9013 is not set
+# CONFIG_DVB_EC100 is not set
+# CONFIG_DVB_STV0367 is not set
+# CONFIG_DVB_CXD2820R is not set
+# CONFIG_DVB_CXD2841ER is not set
+# CONFIG_DVB_RTL2830 is not set
+# CONFIG_DVB_RTL2832 is not set
+# CONFIG_DVB_RTL2832_SDR is not set
+# CONFIG_DVB_SI2168 is not set
+# CONFIG_DVB_ZD1301_DEMOD is not set
+# CONFIG_DVB_CXD2880 is not set
+
+#
+# DVB-C (cable) frontends
+#
+# CONFIG_DVB_VES1820 is not set
+# CONFIG_DVB_TDA10021 is not set
+# CONFIG_DVB_TDA10023 is not set
+# CONFIG_DVB_STV0297 is not set
+
+#
+# ATSC (North American/Korean Terrestrial/Cable DTV) frontends
+#
+# CONFIG_DVB_NXT200X is not set
+# CONFIG_DVB_OR51211 is not set
+# CONFIG_DVB_OR51132 is not set
+# CONFIG_DVB_BCM3510 is not set
+# CONFIG_DVB_LGDT330X is not set
+# CONFIG_DVB_LGDT3305 is not set
+# CONFIG_DVB_LGDT3306A is not set
+# CONFIG_DVB_LG2160 is not set
+# CONFIG_DVB_S5H1409 is not set
+# CONFIG_DVB_AU8522 is not set
+# CONFIG_DVB_AU8522_DTV is not set
+# CONFIG_DVB_AU8522_V4L is not set
+# CONFIG_DVB_S5H1411 is not set
+# CONFIG_DVB_MXL692 is not set
+
+#
+# ISDB-T (terrestrial) frontends
+#
+# CONFIG_DVB_S921 is not set
+# CONFIG_DVB_DIB8000 is not set
+# CONFIG_DVB_MB86A20S is not set
+
+#
+# ISDB-S (satellite) & ISDB-T (terrestrial) frontends
+#
+# CONFIG_DVB_TC90522 is not set
+# CONFIG_DVB_MN88443X is not set
+
+#
+# Digital terrestrial only tuners/PLL
+#
+# CONFIG_DVB_PLL is not set
+# CONFIG_DVB_TUNER_DIB0070 is not set
+# CONFIG_DVB_TUNER_DIB0090 is not set
+
+#
+# SEC control devices for DVB-S
+#
+# CONFIG_DVB_DRX39XYJ is not set
+# CONFIG_DVB_LNBH25 is not set
+# CONFIG_DVB_LNBH29 is not set
+# CONFIG_DVB_LNBP21 is not set
+# CONFIG_DVB_LNBP22 is not set
+# CONFIG_DVB_ISL6405 is not set
+# CONFIG_DVB_ISL6421 is not set
+# CONFIG_DVB_ISL6423 is not set
+# CONFIG_DVB_A8293 is not set
+# CONFIG_DVB_LGS8GL5 is not set
+# CONFIG_DVB_LGS8GXX is not set
+# CONFIG_DVB_ATBM8830 is not set
+# CONFIG_DVB_TDA665x is not set
+# CONFIG_DVB_IX2505V is not set
+# CONFIG_DVB_M88RS2000 is not set
+# CONFIG_DVB_AF9033 is not set
+# CONFIG_DVB_HORUS3A is not set
+# CONFIG_DVB_ASCOT2E is not set
+# CONFIG_DVB_HELENE is not set
+
+#
+# Common Interface (EN50221) controller drivers
+#
+# CONFIG_DVB_CXD2099 is not set
+# CONFIG_DVB_SP2 is not set
+# end of Customise DVB Frontends
+
+
+# Remove GCC plugins as not supported by GCC9.x
+# To enable on GCC10
+#
+# CONFIG_GCC_PLUGINS is not set
+
+# Remove Console display driver support
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
diff --git a/arch/arm/configs/fragment-02-multiv7_addons.config b/arch/arm/configs/fragment-02-multiv7_addons.config
new file mode 100644
index 000000000..7b5ffd562
--- /dev/null
+++ b/arch/arm/configs/fragment-02-multiv7_addons.config
@@ -0,0 +1,426 @@
+#
+# General setup
+#
+CONFIG_POSIX_MQUEUE=y
+CONFIG_USELIB=y
+CONFIG_FUTEX=y
+
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+
+#
+# RCU Subsystem
+#
+# allow user to access kernel config through /proc/config.gz
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_MEMCG=y
+CONFIG_NAMESPACES=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PROFILING=y
+
+#
+# Kernel Features
+#
+CONFIG_SCHED_MC=y
+CONFIG_MCPM=y
+CONFIG_NR_CPUS=2
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_FORCE_MAX_ZONEORDER=12
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+
+#
+# CPU Power Management
+#
+
+#
+# Floating point emulation
+#
+CONFIG_VFP=y
+
+#
+# Networking options
+#
+CONFIG_DNS_RESOLVER=y
+
+#
+# CAN Device Drivers
+#
+CONFIG_CAN_M_CAN=y
+CONFIG_CAN_M_CAN_PLATFORM=y
+
+#
+# CAN USB interfaces
+#
+
+#
+# Bluetooth device drivers
+#
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
+
+#
+# Disk-On-Chip Device Drivers
+#
+
+#
+# LPDDR & LPDDR2 PCM memory drivers
+#
+
+#
+# Misc devices
+#
+CONFIG_SRAM=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_CHR_DEV_SG=y
+
+#
+# MII PHY device drivers
+#
+
+#
+# Input Device Drivers
+#
+
+#
+# Touchscreen drivers
+#
+CONFIG_TOUCHSCREEN_EDT_FT5X06=y
+CONFIG_TOUCHSCREEN_GOODIX=y
+
+#
+# Character devices
+#
+CONFIG_LEGACY_PTY_COUNT=8
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_NONSTANDARD=y
+
+#
+# SPI Master Controller Drivers
+#
+
+#
+# Pin controllers
+#
+CONFIG_PINCTRL_MCP23S08=y
+
+#
+# Memory mapped GPIO drivers
+#
+
+#
+# Memory Technology Device (MTD) support
+#
+
+CONFIG_MTD_SPI_NAND=y
+CONFIG_MTD_MCHP23K256=m
+
+#
+# Multiple devices driver support
+#
+
+CONFIG_MD=y
+#
+#Device mapper support
+#
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+
+#
+# USB GPIO expanders
+#
+CONFIG_POWER_RESET=y
+CONFIG_POWER_RESET_SYSCON=y
+
+#
+# Native drivers
+#
+CONFIG_SENSORS_IIO_HWMON=y
+CONFIG_THERMAL=y
+
+#
+# STMicroelectronics thermal drivers
+#
+
+#
+# Watchdog Device Drivers
+#
+CONFIG_WATCHDOG_NOWAYOUT=y
+CONFIG_WATCHDOG_SYSFS=y
+
+#
+# Sonics Silicon Backplane
+#
+
+#
+# Multifunction device drivers
+#
+CONFIG_PROTECTION_CONSUMER=y
+
+#
+# Multimedia core support
+#
+
+#
+# USB HDMI CEC adapters
+#
+CONFIG_CEC_STM32=m
+
+#
+# Camera sensor devices
+#
+CONFIG_VIDEO_GC2145=m
+CONFIG_VIDEO_OV5640=m
+CONFIG_VIDEO_ST_MIPID02=m
+
+#
+# Graphics support
+#
+# to solve issue on DK2 screen
+# CONFIG_DRM_FBDEV_EMULATION is not set
+# CONFIG_DRM_LOAD_EDID_FIRMWARE is not set
+
+#
+# Sub-drivers
+#
+
+#
+# Display Panels
+#
+CONFIG_DRM_PANEL_ORISETECH_OTM8009A=y
+CONFIG_DRM_PANEL_RAYDIUM_RM68200=y
+CONFIG_DRM_PANEL_ROCKTECH_HX8394=y
+
+#
+# Display Interface Bridges
+#
+CONFIG_DRM_I2C_ADV7511=y
+CONFIG_DRM_SII902X=y
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_DRM_SIMPLEDRM=y
+
+#
+# Console display driver support
+#
+CONFIG_DRM_STM=y
+CONFIG_DRM_STM_DSI=y
+
+#
+# Backlight support
+#
+CONFIG_BACKLIGHT_GPIO=y
+
+#
+# HD-Audio
+#
+
+#
+# STMicroelectronics STM32 SOC audio support
+#
+
+CONFIG_SND_SOC_STM32_SPDIFRX=m
+CONFIG_SND_SOC_STM32_DFSDM=m
+
+#
+# CODEC drivers
+#
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=m
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+
+#
+# Gadget/Dual-role mode requires USB Gadget support to be enabled
+#
+
+#
+# USB Physical Layer drivers
+#
+
+#
+# USB UCSI with STM32G07 over I2C
+#
+CONFIG_TYPEC_UCSI=m
+CONFIG_UCSI_STM32G0=m
+
+#
+# Platform Support
+#
+
+#
+# Virtio drivers
+#
+
+#
+# STM32 HSEM
+#
+CONFIG_HWSPINLOCK=y
+CONFIG_HWSPINLOCK_STM32=y
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKSRC_STM32_LP=y
+
+#
+# Regulators
+#
+CONFIG_REGULATOR_STM32_VREFBUF=y
+
+#
+# Remoteproc drivers
+#
+CONFIG_REMOTEPROC=y
+CONFIG_STM32_RPROC=y
+CONFIG_REMOTEPROC_SRM_CORE=y
+CONFIG_REMOTEPROC_SRM_DEV=y
+
+#
+# Rpmsg drivers
+#
+CONFIG_RPMSG_VIRTIO=y
+CONFIG_RPMSG_TTY=m
+
+#
+# NVMEM drivers
+#
+CONFIG_NVMEM_STM32_ROMEM=y
+
+
+CONFIG_TEE=y
+
+#
+# TEE drivers
+#
+CONFIG_OPTEE=y
+# end of TEE drivers
+
+#
+# File systems
+#
+CONFIG_OVERLAY_FS=y
+CONFIG_JFFS2_FS=y
+
+#
+# Pseudo filesystems
+#
+CONFIG_TMPFS=y
+
+# Security options
+#
+CONFIG_KEYS=y
+
+#
+# Library routines
+#
+CONFIG_CRC_ITU_T=m
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=128
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+CONFIG_DEBUG_INFO=y
+CONFIG_GDB_SCRIPTS=y
+CONFIG_DEBUG_SECTION_MISMATCH=y
+
+#
+# Debug Oops, Lockups and Hangs
+#
+
+#
+# Scheduler Debugging
+#
+CONFIG_DEBUG_PREEMPT=y
+
+#
+# Runtime Testing
+#
+
+#
+# STM32 DFSDM
+#
+CONFIG_SD_ADC_MODULATOR=y
+
+#
+# STM32 IPCC
+#
+CONFIG_STM32_IPCC=y
+
+#
+# SCMI
+#
+CONFIG_ARM_SCMI_PROTOCOL=y
+CONFIG_COMMON_CLK_SCMI=y
+CONFIG_ARM_SMC_MBOX=y
+CONFIG_REGULATOR_ARM_SCMI=y
+CONFIG_ARM_SCMI_CPUFREQ=y
+
+#
+# STM32 CPUIDLE
+#
+CONFIG_CPU_IDLE=y
+CONFIG_ARM_STM32_CPUIDLE=y
+CONFIG_ARM_CPUIDLE=n
+
+#
+# REBOOT
+#
+CONFIG_REBOOT_MODE=y
+CONFIG_SYSCON_REBOOT_MODE=y
+
+#
+# RPMSG client sample
+#
+CONFIG_SAMPLES=y
+CONFIG_SAMPLE_RPMSG_CLIENT=m
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CFB=m
+CONFIG_CRYPTO_LRW=m
+CONFIG_CRYPTO_OFB=m
diff --git a/arch/arm/configs/multi_v7_defconfig b/arch/arm/configs/multi_v7_defconfig
index 33572998d..afb97c505 100644
--- a/arch/arm/configs/multi_v7_defconfig
+++ b/arch/arm/configs/multi_v7_defconfig
@@ -646,6 +646,7 @@ CONFIG_V4L_PLATFORM_DRIVERS=y
 CONFIG_VIDEO_MMP_CAMERA=m
 CONFIG_VIDEO_ASPEED=m
 CONFIG_VIDEO_STM32_DCMI=m
+CONFIG_VIDEO_STM32_DCMIPP=m
 CONFIG_VIDEO_RENESAS_CEU=m
 CONFIG_VIDEO_SAMSUNG_EXYNOS4_IS=m
 CONFIG_VIDEO_S5P_FIMC=m
diff --git a/arch/arm/mach-stm32/Kconfig b/arch/arm/mach-stm32/Kconfig
index 57699bd8f..bfa6aa54b 100644
--- a/arch/arm/mach-stm32/Kconfig
+++ b/arch/arm/mach-stm32/Kconfig
@@ -46,8 +46,24 @@ if ARCH_MULTI_V7
 config MACH_STM32MP157
 	bool "STMicroelectronics STM32MP157"
 	select ARM_ERRATA_814220
+	select REGULATOR
 	default y
 
+config MACH_STM32MP13
+	bool "STMicroelectronics STM32MP13x"
+	select ARM_ERRATA_814220
+	default y
+	help
+	  Support for STM32MP13 SoCs:
+	  STM32MP131, STM32MP133, STM32MP135
+
+config MACH_STM32MP25
+	bool "STMicroelectronics STM32MP25x"
+	default y
+	help
+	  Support for STM32MP25 SoCs:
+	  STM32MP251, STM32MP253, STM32MP255, STM32MP257
+
 endif # ARMv7-A
 
 endif
diff --git a/arch/arm/mach-stm32/board-dt.c b/arch/arm/mach-stm32/board-dt.c
index a766310d8..d1663c891 100644
--- a/arch/arm/mach-stm32/board-dt.c
+++ b/arch/arm/mach-stm32/board-dt.c
@@ -18,7 +18,16 @@ static const char *const stm32_compat[] __initconst = {
 	"st,stm32f769",
 	"st,stm32h743",
 	"st,stm32h750",
+	"st,stm32mp131",
+	"st,stm32mp133",
+	"st,stm32mp135",
+	"st,stm32mp151",
+	"st,stm32mp153",
 	"st,stm32mp157",
+	"st,stm32mp251",
+	"st,stm32mp253",
+	"st,stm32mp255",
+	"st,stm32mp257",
 	NULL
 };
 
diff --git a/arch/arm/mm/proc-v7.S b/arch/arm/mm/proc-v7.S
index 26d726a08..ae9eed042 100644
--- a/arch/arm/mm/proc-v7.S
+++ b/arch/arm/mm/proc-v7.S
@@ -299,6 +299,7 @@ __v7_ca12mp_setup:
 __v7_ca15mp_setup:
 __v7_b15mp_setup:
 __v7_ca17mp_setup:
+__v7_ca35mp_setup:
 	do_invalidate_l1
 	mov	r10, #0
 1:
@@ -517,7 +518,6 @@ __v7_setup_cont:
 	ldr	r10, =0x00000c0f		@ Cortex-A15 primary part number
 	teq	r0, r10
 	beq	__ca15_errata
-
 __errata_finish:
 	mov	r10, #0
 	mcr	p15, 0, r10, c7, c5, 0		@ I+BTB cache invalidate
@@ -780,6 +780,14 @@ __v7_ca17mp_proc_info:
 	__v7_proc __v7_ca17mp_proc_info, __v7_ca17mp_setup, proc_fns = HARDENED_BPIALL_PROCESSOR_FUNCTIONS
 	.size	__v7_ca17mp_proc_info, . - __v7_ca17mp_proc_info
 
+	/* ARM Ltd. Cortex A35 processor */
+	.type	__v7_ca35_proc_info, #object
+__v7_ca35_proc_info:
+	.long	0x410fd040
+	.long	0xff0ffff0
+	__v7_proc __v7_ca35_proc_info, __v7_ca35mp_setup
+	.size	__v7_ca35_proc_info, . - __v7_ca35_proc_info
+
 	/* ARM Ltd. Cortex A73 processor */
 	.type	__v7_ca73_proc_info, #object
 __v7_ca73_proc_info:
diff --git a/arch/arm64/Kconfig.platforms b/arch/arm64/Kconfig.platforms
index d7772a4c3..d222cd4ea 100644
--- a/arch/arm64/Kconfig.platforms
+++ b/arch/arm64/Kconfig.platforms
@@ -257,6 +257,22 @@ config ARCH_INTEL_SOCFPGA
 	  This enables support for Intel's SoCFPGA ARMv8 families:
 	  Stratix 10 (ex. Altera), Agilex and eASIC N5X.
 
+config ARCH_STM32
+	bool "STMicroelectronics STM32 SoC Family"
+	select ARCH_HAS_RESET_CONTROLLER
+	select GPIOLIB
+	select PINCTRL
+	select RESET_CONTROLLER
+	select STM32_EXTI
+	select PINCTRL_STM32MP257
+	select COMMON_CLK_STM32MP257
+	select RESET_STM32MP1
+	select ARM_SMC_MBOX
+	select ARM_SCMI_PROTOCOL
+	select COMMON_CLK_SCMI
+	help
+	  This enables support for ARMv8 based STMicroelectronics STM32 family.
+
 config ARCH_SYNQUACER
 	bool "Socionext SynQuacer SoC Family"
 	select IRQ_FASTEOI_HIERARCHY_HANDLERS
diff --git a/arch/arm64/boot/dts/Makefile b/arch/arm64/boot/dts/Makefile
index 639e01a4d..e43bfd391 100644
--- a/arch/arm64/boot/dts/Makefile
+++ b/arch/arm64/boot/dts/Makefile
@@ -26,6 +26,7 @@ subdir-y += renesas
 subdir-y += rockchip
 subdir-y += socionext
 subdir-y += sprd
+subdir-y += st
 subdir-y += synaptics
 subdir-y += ti
 subdir-y += toshiba
diff --git a/arch/arm64/boot/dts/st/Makefile b/arch/arm64/boot/dts/st/Makefile
new file mode 100644
index 000000000..b9ee905dc
--- /dev/null
+++ b/arch/arm64/boot/dts/st/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0
+dtb-$(CONFIG_ARCH_STM32) += \
+	stm32mp257f-dk.dtb \
+	stm32mp257f-ev.dtb \
+	stm32mp257f-valid3.dtb \
+	stm32mp257f-valid3-daughter.dtb
diff --git a/arch/arm64/boot/dts/st/stm32mp25-pinctrl-test.dtsi b/arch/arm64/boot/dts/st/stm32mp25-pinctrl-test.dtsi
new file mode 100644
index 000000000..7e42d95da
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp25-pinctrl-test.dtsi
@@ -0,0 +1,707 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com>
+ */
+#include "stm32mp25-pinctrl.dtsi"
+
+&pinctrl {
+	eth1_mdio_test_pins_b: eth1-mdio-test-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 0, AF10)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 2, AF10)>; /* ETH_MDIO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	eth1_rgmii_test_pins_a: eth1-rgmii-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H', 9, AF10)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('C', 0, AF12)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('A', 15, AF10)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 1, AF10)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 10, AF10)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 11, AF10)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 13, AF10)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('F', 5, AF8)>, /* ETH_MDIO */
+				 <STM32_PINMUX('F', 4, AF8)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 1, AF10)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 2, AF10)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 12, AF10)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 13, AF10)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('C', 3, AF11)>, /* ETH_RGMII_RXER */
+				 <STM32_PINMUX('C', 5, AF11)>, /* ETH_RGMII_COL */
+				 <STM32_PINMUX('C', 6, AF11)>, /* ETH_RGMII_CRS_DV */
+				 <STM32_PINMUX('A', 14, AF10)>, /* ETH_RGMII_RX_CLK */
+				 <STM32_PINMUX('A', 11, AF10)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+		};
+	};
+
+	eth1_rgmii_test_pins_b: eth1-rgmii-test-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 15, AF10)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 1, AF10)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 10, AF10)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 11, AF10)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 13, AF10)>; /* ETH_RGMII_TX_CTL */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('H', 9, AF10)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('C', 0, AF12)>; /* ETH_RGMII_GTX_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('F', 1, AF10)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 2, AF10)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 12, AF10)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 13, AF10)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 11, AF10)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins4 {
+			pinmux = <STM32_PINMUX('A', 14, AF10)>; /* ETH_RGMII_RX_CLK */
+			bias-disable;
+		};
+	};
+
+	eth2_rgmii_test_pins_a: eth2-rgmii-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 2, AF11)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('F', 7, AF10)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('C', 7, AF10)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 8, AF10)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('C', 9, AF10)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('C', 10, AF10)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('C', 4, AF10)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('F', 9, AF11)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 4, AF11)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 0, AF10)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 12, AF10)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('A', 0, AF10)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('C', 11, AF10)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('G', 1, AF10)>, /* ETH_RGMII_RXER */
+				 <STM32_PINMUX('F', 2, AF11)>, /* ETH_RGMII_COL */
+				 <STM32_PINMUX('F', 0, AF11)>, /* ETH_RGMII_CRS */
+				 <STM32_PINMUX('F', 6, AF10)>, /* ETH_RGMII_RX_CLK */
+				 <STM32_PINMUX('F', 8, AF12)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+		};
+	};
+
+	eth2_rgmii_test_pins_b: eth2-rgmii-test-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 7, AF10)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 8, AF10)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('C', 9, AF10)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('C', 10, AF10)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('C', 4, AF10)>; /* ETH_RGMII_TX_CTL */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 8, AF10)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('F', 7, AF10)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('C', 6, AF10)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('C', 5, AF10)>; /* ETH_MDIO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins4 {
+			pinmux = <STM32_PINMUX('G', 0, AF10)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 12, AF10)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('F', 9, AF10)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('C', 11, AF10)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('C', 3, AF10)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins5 {
+			pinmux = <STM32_PINMUX('F', 6, AF10)>; /* ETH_RGMII_RX_CLK */
+			bias-disable;
+		};
+	};
+
+	eth3_rgmii_test_pins_a: eth3-rgmii-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 6, AF14)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('A', 7, AF14)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 6, AF14)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 3, AF14)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 3, AF14)>; /* ETH_RGMII_TX_CTL */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('H', 2, AF14)>; /* ETH_RGMII_GTX_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+			st,io-delay = <2>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('A', 9, AF14)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('A', 10, AF14)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 7, AF14)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 8, AF14)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 2, AF14)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins4 {
+			pinmux = <STM32_PINMUX('A', 5, AF14)>; /* ETH_RGMII_RX_CLK */
+			bias-disable;
+		};
+	};
+
+	hdp0_pins_a: hdp0-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, AF1)>; /* HDP0 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	hdp0_pins_sleep_a: hdp0-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, ANALOG)>; /* HDP0 */
+		};
+	};
+
+	hdp6_pins_a: hdp6-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 8, AF1)>; /* HDP6 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	hdp6_pins_sleep_a: hdp6-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 8, ANALOG)>; /* HDP6 */
+		};
+	};
+
+	hdp7_pins_a: hdp7-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 1, AF1)>; /* HDP7 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	hdp7_pins_sleep_a: hdp7-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 1, ANALOG)>; /* HDP7 */
+		};
+	};
+
+	i2c2_test_pins_a: i2c2-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('J', 12, AF9)>, /* I2C2_SCL */
+				 <STM32_PINMUX('J', 13, AF9)>; /* I2C2_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c2_test_sleep_pins_a: i2c2-test-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('J', 12, ANALOG)>, /* I2C2_SCL */
+				 <STM32_PINMUX('J', 13, ANALOG)>; /* I2C2_SDA */
+		};
+	};
+
+	i2c2_test_pins_b: i2c2-test-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 2, AF9)>, /* I2C2_SCL */
+				 <STM32_PINMUX('F', 0, AF9)>; /* I2C2_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c2_test_sleep_pins_b: i2c2-test-sleep-1 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 2, ANALOG)>, /* I2C2_SCL */
+				 <STM32_PINMUX('F', 0, ANALOG)>; /* I2C2_SDA */
+		};
+	};
+
+	pcie_pins_a: pcie-0 {
+		pins {
+			pinmux = <STM32_PINMUX('J', 0, AF4)>;
+		};
+	};
+
+	pcie_init_pins_a: pcie-init-0 {
+		pins {
+			pinmux = <STM32_PINMUX('J', 0, GPIO)>;
+			output-low;
+		};
+	};
+
+	sai2a_test_pins_a: sai2a-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 11, AF4)>, /* SAI2_SCK_A */
+				 <STM32_PINMUX('G', 1, AF4)>, /* SAI2_SD_A */
+				 <STM32_PINMUX('J', 3, AF3)>; /* SAI2_FS_A */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 10, AF4)>; /* SAI2_MCLK_A */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	sai2a_test_sleep_pins_a: sai2a-test-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 11, ANALOG)>, /* SAI2_SCK_A */
+				 <STM32_PINMUX('G', 1, ANALOG)>, /* SAI2_SD_A */
+				 <STM32_PINMUX('J', 3, ANALOG)>, /* SAI2_FS_A */
+				 <STM32_PINMUX('F', 10, ANALOG)>; /* SAI2_MCLK_A */
+		};
+	};
+
+	sai2b_test_pins_a: sai2b-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('J', 5, AF3)>, /* SAI2_SCK_B */
+				 <STM32_PINMUX('J', 4, AF3)>; /* SAI2_FS_B */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('J', 7, AF4)>; /* SAI2_MCLK_B */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('J', 2, AF4)>; /* SAI2_SD_B */
+			bias-disable;
+		};
+	};
+
+	sai2b_test_sleep_pins_a: sai2b-test-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('J', 5, ANALOG)>, /* SAI2_SCK_B */
+				 <STM32_PINMUX('J', 4, ANALOG)>, /* SAI2_FS_B */
+				 <STM32_PINMUX('J', 7, ANALOG)>, /* SAI2_MCLK_B */
+				 <STM32_PINMUX('J', 2, ANALOG)>; /* SAI2_SD_B */
+		};
+	};
+
+	sai4a_test_pins_a: sai4a-test-0 {
+		pins {
+			pinmux = <STM32_PINMUX('J', 6, AF4)>; /* SAI4_SD_A */
+			slew-rate = <0>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	sai4a_test_sleep_pins_a: sai4a-test-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('J', 6, ANALOG)>; /* SAI4_SD_A */
+		};
+	};
+
+	sdmmc1_b4_test_pins_a: sdmmc1-b4-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 4, AF10)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('E', 5, AF10)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 0, AF10)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 1, AF10)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('E', 2, AF10)>; /* SDMMC1_CMD */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC1_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc1_b4_od_test_pins_a: sdmmc1-b4-od-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 4, AF10)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('E', 5, AF10)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 0, AF10)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 1, AF10)>; /* SDMMC1_D3 */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC1_CK */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('E', 2, AF10)>; /* SDMMC1_CMD */
+			slew-rate = <1>;
+			drive-open-drain;
+			bias-disable;
+		};
+	};
+
+	sdmmc1_b4_test_sleep_pins_a: sdmmc1-b4-test-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 4, ANALOG)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('E', 5, ANALOG)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 0, ANALOG)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 1, ANALOG)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('E', 3, ANALOG)>, /* SDMMC1_CK */
+				 <STM32_PINMUX('E', 2, ANALOG)>; /* SDMMC1_CMD */
+
+		};
+	};
+
+	sdmmc1_dir_test_pins_a: sdmmc1-dir-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 9, AF12)>, /* SDMMC1_D0DIR */
+				 <STM32_PINMUX('D', 8, AF12)>, /* SDMMC1_D123DIR */
+				 <STM32_PINMUX('D', 10, AF12)>; /* SDMMC1_CDIR */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 11, AF12)>; /* SDMMC1_CKIN */
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_b4_test_pins_a: sdmmc2-b4-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 13, AF12)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('E', 11, AF12)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('E', 8, AF12)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('E', 12, AF12)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('E', 15, AF12)>; /* SDMMC2_CMD */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 14, AF12)>; /* SDMMC2_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_b4_od_test_pins_a: sdmmc2-b4-od-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 13, AF12)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('E', 11, AF12)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('E', 8, AF12)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('E', 12, AF12)>; /* SDMMC2_D3 */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 14, AF12)>; /* SDMMC2_CK */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('E', 15, AF12)>; /* SDMMC2_CMD */
+			slew-rate = <1>;
+			drive-open-drain;
+			bias-disable;
+		};
+	};
+
+	sdmmc2_d47_test_pins_a: sdmmc2-d47-test-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 10, AF12)>, /* SDMMC2_D4 */
+				 <STM32_PINMUX('E', 9, AF12)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('E', 6, AF12)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('E', 7, AF12)>; /* SDMMC2_D7 */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_dir_test_pins_a: sdmmc2-dir-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 6, AF13)>, /* SDMMC2_D0DIR */
+				 <STM32_PINMUX('E', 7, AF13)>, /* SDMMC2_D123DIR */
+				 <STM32_PINMUX('E', 9, AF13)>; /* SDMMC2_CDIR */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2{
+			pinmux = <STM32_PINMUX('E', 10, AF13)>; /* SDMMC2_CKIN */
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_test_sleep_pins_a: sdmmc2-test-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 13, ANALOG)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('E', 11, ANALOG)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('E', 8, ANALOG)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('E', 12, ANALOG)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('E', 10, ANALOG)>, /* SDMMC2_D4 */
+				 <STM32_PINMUX('E', 9, ANALOG)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('E', 6, ANALOG)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('E', 7, ANALOG)>, /* SDMMC2_D7 */
+				 <STM32_PINMUX('E', 14, ANALOG)>, /* SDMMC2_CK */
+				 <STM32_PINMUX('E', 15, ANALOG)>; /* SDMMC2_CMD */
+		};
+	};
+
+	sdmmc3_b4_test_pins_a: sdmmc3-b4-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 14, AF10)>, /* SDMMC3_D0 */
+				 <STM32_PINMUX('D', 13, AF10)>, /* SDMMC3_D1 */
+				 <STM32_PINMUX('B', 12, AF10)>, /* SDMMC3_D2 */
+				 <STM32_PINMUX('I', 11, AF10)>, /* SDMMC3_D3 */
+				 <STM32_PINMUX('D', 12, AF10)>; /* SDMMC3_CMD */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 13, AF10)>; /* SDMMC3_CK */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc3_b4_od_test_pins_a: sdmmc3-b4-od-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 14, AF10)>, /* SDMMC3_D0 */
+				 <STM32_PINMUX('D', 13, AF10)>, /* SDMMC3_D1 */
+				 <STM32_PINMUX('B', 12, AF10)>, /* SDMMC3_D2 */
+				 <STM32_PINMUX('I', 11, AF10)>; /* SDMMC3_D3 */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 13, AF10)>; /* SDMMC3_CK */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('D', 12, AF10)>; /* SDMMC3_CMD */
+			slew-rate = <1>;
+			drive-open-drain;
+			bias-disable;
+		};
+	};
+
+	sdmmc3_dir_test_pins_a: sdmmc3-dir-test-0 {
+		pins {
+			pinmux = <STM32_PINMUX('K', 1, AF10)>, /* SDMMC3_D0DIR */
+				 <STM32_PINMUX('K', 0, AF10)>, /* SDMMC3_D123DIR */
+				 <STM32_PINMUX('I', 15, AF10)>; /* SDMMC3_CDIR */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	spdifrx_test_pins_a: spdifrx-test-0 {
+		pins {
+			pinmux = <STM32_PINMUX('K', 0, AF3)>; /* SPDIF_IN2 */
+			bias-disable;
+		};
+	};
+
+	spdifrx_test_sleep_pins_a: spdifrx-test-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('K', 0, ANALOG)>; /* SPDIF_IN2 */
+		};
+	};
+
+	usart2_test_pins_a: usart2-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 4, AF6)>; /* USART2_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 8, AF8)>; /* USART2_RX */
+			bias-disable;
+		};
+	};
+
+	usart2_test_idle_pins_a: usart2-test-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 4, ANALOG)>; /* USART2_TX */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 8, AF8)>; /* USART2_RX */
+			bias-disable;
+		};
+	};
+
+	usart2_test_sleep_pins_a: usart2-test-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, ANALOG)>, /* USART2_TX */
+				 <STM32_PINMUX('A', 8, ANALOG)>; /* USART2_RX */
+		};
+	};
+
+	usart6_test_pins_a: usart6-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 13, AF3)>, /* USART6_TX */
+				 <STM32_PINMUX('G', 5, AF3)>;  /* USART6_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 14, AF3)>, /* USART6_RX */
+				 <STM32_PINMUX('F', 15, AF3)>; /* USART6_CTS_NSS */
+			bias-pull-up;
+		};
+	};
+
+	usart6_test_idle_pins_a: usart6-test-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 13, ANALOG)>, /* USART6_TX */
+				 <STM32_PINMUX('F', 15, ANALOG)>; /* USART6_CTS_NSS */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 5, AF3)>; /* USART6_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('F', 14, AF3)>; /* USART6_RX */
+			bias-pull-up;
+		};
+	};
+
+	usart6_test_sleep_pins_a: usart6-test-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, ANALOG)>, /* USART6_TX */
+				 <STM32_PINMUX('G', 5, ANALOG)>,  /* USART6_RTS */
+				 <STM32_PINMUX('F', 15, ANALOG)>, /* USART6_CTS_NSS */
+				 <STM32_PINMUX('F', 14, ANALOG)>; /* USART6_RX */
+		};
+	};
+
+	usb2h_test_pins_a: usb2h-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('J', 0, AF9)>; /* VBUSEN */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('J', 2, AF9)>; /* OVRCUR */
+			bias-pull-up;
+			drive-open-drain;
+			slew-rate = <1>;
+		};
+	};
+};
+
+&pinctrl_z {
+	i2c8_test_pins_a: i2c8-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 4, AF8)>, /* I2C8_SCL */
+				 <STM32_PINMUX('Z', 3, AF8)>; /* I2C8_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c8_test_sleep_pins_a: i2c8-test-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, ANALOG)>, /* I2C8_SCL */
+				 <STM32_PINMUX('Z', 3, ANALOG)>; /* I2C8_SDA */
+		};
+	};
+
+	spi8_test_pins_a: spi8-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 5, AF3)>, /* SPI8_SCK */
+				 <STM32_PINMUX('Z', 7, AF3)>; /* SPI8_MOSI */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 8, AF3)>; /* SPI8_MISO */
+			bias-disable;
+		};
+	};
+
+	spi8_test_sleep_pins_a: spi8-test-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 5, ANALOG)>, /* SPI8_SCK */
+				 <STM32_PINMUX('Z', 7, ANALOG)>, /* SPI8_MOSI */
+				 <STM32_PINMUX('Z', 8, ANALOG)>; /* SPI8_MISO */
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp25-pinctrl.dtsi b/arch/arm64/boot/dts/st/stm32mp25-pinctrl.dtsi
new file mode 100644
index 000000000..a2489acc3
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp25-pinctrl.dtsi
@@ -0,0 +1,7 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
diff --git a/arch/arm64/boot/dts/st/stm32mp251.dtsi b/arch/arm64/boot/dts/st/stm32mp251.dtsi
new file mode 100644
index 000000000..b585d3300
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp251.dtsi
@@ -0,0 +1,1732 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+#include <dt-bindings/clock/stm32mp2-clks.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/phy/phy.h>
+#include <dt-bindings/reset/stm32mp2-resets.h>
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	arm-pmu {
+		compatible = "arm,cortex-a35-pmu";
+		interrupts = <GIC_SPI 368 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&cpu0>;
+		interrupt-parent = <&intc>;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,cortex-a35";
+			device_type = "cpu";
+			reg = <0>;
+			enable-method = "psci";
+			clocks = <&scmi0_perf 0>;
+			clock-names = "cpu";
+		};
+	};
+
+	firmware {
+		optee {
+			compatible = "linaro,optee-tz";
+			method = "smc";
+		};
+
+		scmi0: scmi-0 {
+			compatible = "linaro,scmi-optee";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			linaro,optee-channel-id = <0>;
+			shmem = <&scmi0_shm>;
+
+			scmi0_perf: protocol@13 {
+				reg = <0x13>;
+				#clock-cells = <1>;
+			};
+
+			scmi0_clk: protocol@14 {
+				reg = <0x14>;
+				#clock-cells = <1>;
+			};
+
+			scmi0_reset: protocol@16 {
+				reg = <0x16>;
+				#reset-cells = <1>;
+			};
+
+			scmi0_voltd: protocol@17 {
+				reg = <0x17>;
+
+				scmi_regu: regulators {
+					scmi_vddio1: voltd-vddio1 {
+						voltd-name = "vddio1";
+						regulator-name = "vddio1";
+					};
+					scmi_vddio2: voltd-vddio2 {
+						voltd-name = "vddio2";
+						regulator-name = "vddio2";
+					};
+					scmi_vddio3: voltd-vddio3 {
+						voltd-name = "vddio3";
+						regulator-name = "vddio3";
+					};
+					scmi_vddio4: voltd-vddio4 {
+						voltd-name = "vddio4";
+						regulator-name = "vddio4";
+					};
+					scmi_vdd33ucpd: voltd-vdd33ucpd {
+						voltd-name = "vdd33ucpd";
+						regulator-name = "vdd33ucpd";
+					};
+					scmi_vdd33usb: voltd-vdd33usb {
+						voltd-name = "vdd33usb";
+						regulator-name = "vdd33usb";
+					};
+					scmi_vdda18adc: voltd-vdda18adc {
+						voltd-name = "vdda18adc";
+						regulator-name = "vdda18adc";
+					};
+					scmi_vddgpu: voltd-vddgpu {
+						voltd-name = "vddgpu";
+						regulator-name = "vddgpu";
+					};
+				};
+			};
+		};
+	};
+
+	intc: interrupt-controller@4ac00000 {
+		compatible = "arm,cortex-a7-gic";
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		reg = <0x4ac10000 0x1000>,
+		      <0x4ac20000 0x2000>,
+		      <0x4ac40000 0x2000>,
+		      <0x4ac60000 0x2000>;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		v2m0: v2m@48090000 {
+			compatible = "arm,gic-v2m-frame";
+			reg = <0x48090000 0x1000>;
+			msi-controller;
+		};
+	};
+
+	psci {
+		compatible = "arm,psci-1.0";
+		method = "smc";
+	};
+
+	scmi_sram: sram@2003f000 {
+		compatible = "mmio-sram";
+		reg = <0x2003f000 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0 0x2003f000 0x1000>;
+
+		scmi0_shm: scmi-shm@0 {
+			compatible = "arm,scmi-shmem";
+			reg = <0 0x80>;
+		};
+	};
+
+	thermal-zones {
+		cpu0-thermal {
+			polling-delay-passive = <250>;
+			polling-delay = <1000>;
+			thermal-sensors = <&dts 0>;
+
+			trips {
+				cpu0_crit {
+					temperature = <95000>;
+					hysteresis = <1000>;
+					type = "critical";
+				};
+			};
+
+		};
+
+		cpu1-thermal {
+			polling-delay-passive = <250>;
+			polling-delay = <1000>;
+			thermal-sensors = <&dts 1>;
+
+			trips {
+				cpu1_crit {
+					temperature = <95000>;
+					hysteresis = <1000>;
+					type = "critical";
+				};
+			};
+		};
+	};
+
+	timer: timer {
+		compatible = "arm,armv8-timer";
+		interrupt-parent = <&intc>;
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>;
+		always-on;
+	};
+
+	usb2_phy1: usb2-phy1 {
+		compatible      = "st,stm32mp25-usb2phy";
+		#phy-cells      = <0>;
+		st,syscfg       = <&syscfg 0x2400>;
+		clocks          = <&rcc CK_KER_USB2PHY1>;
+		resets          = <&rcc USB2PHY1_R>;
+		vdd33-supply    = <&scmi_vdd33usb>;
+		status          = "disabled";
+	};
+
+	usb2_phy2: usb2-phy2 {
+		compatible      = "st,stm32mp25-usb2phy";
+		#phy-cells      = <0>;
+		st,syscfg       = <&syscfg 0x2800>;
+		clocks          = <&rcc CK_KER_USB2PHY2EN>;
+		resets          = <&rcc USB2PHY2_R>;
+		vdd33-supply    = <&scmi_vdd33usb>;
+		status          = "disabled";
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&intc>;
+		ranges;
+
+		lptimer1: timer@40090000 {
+			compatible = "st,stm32mp25-lptimer";
+			reg = <0x40090000 0x400>;
+			interrupts = <GIC_SPI 166 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_LPTIM1>;
+			clock-names = "mux";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32mp25-pwm-lp";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			trigger@0 {
+				compatible = "st,stm32mp25-lptimer-trigger";
+				reg = <0>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-lptimer-counter";
+				status = "disabled";
+			};
+
+			timer {
+				compatible = "st,stm32mp25-lptimer-timer";
+				status = "disabled";
+			};
+		};
+
+		lptimer2: timer@400a0000 {
+			compatible = "st,stm32mp25-lptimer";
+			reg = <0x400a0000 0x400>;
+			interrupts = <GIC_SPI 215 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_LPTIM2>;
+			clock-names = "mux";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32mp25-pwm-lp";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			trigger@1 {
+				compatible = "st,stm32mp25-lptimer-trigger";
+				reg = <1>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-lptimer-counter";
+				status = "disabled";
+			};
+
+			timer {
+				compatible = "st,stm32mp25-lptimer-timer";
+				status = "disabled";
+			};
+		};
+
+		spi2: spi@400b0000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32mp2-spi";
+			reg = <0x400b0000 0x400>;
+			interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_SPI2>;
+			resets = <&rcc SPI2_R>;
+			dmas = <&hpdma 51 0x20 0x00003012 0>,
+			       <&hpdma 52 0x20 0x00003021 0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		spi3: spi@400c0000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32mp2-spi";
+			reg = <0x400c0000 0x400>;
+			interrupts = <GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_SPI3>;
+			resets = <&rcc SPI3_R>;
+			dmas = <&hpdma 53 0x20 0x00003012 0>,
+			       <&hpdma 54 0x20 0x00003021 0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		usart2: serial@400e0000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x400e0000 0x400>;
+			interrupts = <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_USART2>;
+			dmas = <&hpdma 11 0x20 0x12 0x0>,
+			       <&hpdma 12 0x20 0x3021 0x0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		usart3: serial@400f0000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x400f0000 0x400>;
+			interrupts = <GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_USART3>;
+			dmas = <&hpdma 13 0x20 0x12 0x0>,
+			       <&hpdma 14 0x20 0x3021 0x0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		uart4: serial@40100000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40100000 0x400>;
+			interrupts = <GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_UART4>;
+			dmas = <&hpdma 15 0x20 0x12 0x0>,
+			       <&hpdma 16 0x20 0x3021 0x0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		uart5: serial@40110000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40110000 0x400>;
+			interrupts = <GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_UART5>;
+			dmas = <&hpdma 17 0x20 0x12 0x0>,
+			       <&hpdma 18 0x20 0x3021 0x0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2c1: i2c@40120000 {
+			compatible = "st,stm32mp25-i2c";
+			reg = <0x40120000 0x400>;
+			interrupt-names = "event";
+			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_I2C1>;
+			resets = <&rcc I2C1_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dmas = <&hpdma 27 0x20 0x00003012 0>,
+			       <&hpdma 28 0x20 0x00003021 0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2c2: i2c@40130000 {
+			compatible = "st,stm32mp25-i2c";
+			reg = <0x40130000 0x400>;
+			interrupt-names = "event";
+			interrupts = <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_I2C2>;
+			resets = <&rcc I2C2_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dmas = <&hpdma 30 0x20 0x00003012 0>,
+			       <&hpdma 31 0x20 0x00003021 0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2c3: i2c@40140000 {
+			compatible = "st,stm32mp25-i2c";
+			reg = <0x40140000 0x400>;
+			interrupt-names = "event";
+			interrupts = <GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_I2C3>;
+			resets = <&rcc I2C3_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dmas = <&hpdma 33 0x20 0x00003012 0>,
+			       <&hpdma 34 0x20 0x00003021 0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2c4: i2c@40150000 {
+			compatible = "st,stm32mp25-i2c";
+			reg = <0x40150000 0x400>;
+			interrupt-names = "event";
+			interrupts = <GIC_SPI 168 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_I2C4>;
+			resets = <&rcc I2C4_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dmas = <&hpdma 36 0x20 0x00003012 0>,
+			       <&hpdma 37 0x20 0x00003021 0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2c5: i2c@40160000 {
+			compatible = "st,stm32mp25-i2c";
+			reg = <0x40160000 0x400>;
+			interrupt-names = "event";
+			interrupts = <GIC_SPI 181 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_I2C5>;
+			resets = <&rcc I2C5_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dmas = <&hpdma 39 0x20 0x00003012 0>,
+			       <&hpdma 40 0x20 0x00003021 0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2c6: i2c@40170000 {
+			compatible = "st,stm32mp25-i2c";
+			reg = <0x40170000 0x400>;
+			interrupt-names = "event";
+			interrupts = <GIC_SPI 208 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_I2C6>;
+			resets = <&rcc I2C6_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dmas = <&hpdma 42 0x20 0x00003012 0>,
+			       <&hpdma 43 0x20 0x00003021 0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2c7: i2c@40180000 {
+			compatible = "st,stm32mp25-i2c";
+			reg = <0x40180000 0x400>;
+			interrupt-names = "event";
+			interrupts = <GIC_SPI 210 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_I2C7>;
+			resets = <&rcc I2C7_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dmas = <&hpdma 45 0x20 0x00003012 0>,
+			       <&hpdma 46 0x20 0x00003021 0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		usart6: serial@40220000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40220000 0x400>;
+			interrupts = <GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_USART6>;
+			dmas = <&hpdma 19 0x20 0x12 0x0>,
+			       <&hpdma 20 0x20 0x3021 0x0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		spi1: spi@40230000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32mp2-spi";
+			reg = <0x40230000 0x400>;
+			interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_SPI1>;
+			resets = <&rcc SPI1_R>;
+			dmas = <&hpdma 49 0x20 0x00003012 0>,
+			       <&hpdma 50 0x20 0x00003021 0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		spi4: spi@40240000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32mp2-spi";
+			reg = <0x40240000 0x400>;
+			interrupts = <GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_SPI4>;
+			resets = <&rcc SPI4_R>;
+			dmas = <&hpdma 55 0x20 0x00003012 0>,
+			       <&hpdma 56 0x20 0x00003021 0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		spi5: spi@40280000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32mp2-spi";
+			reg = <0x40280000 0x400>;
+			interrupts = <GIC_SPI 153 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_SPI5>;
+			resets = <&rcc SPI5_R>;
+			dmas = <&hpdma 57 0x20 0x00003012 0>,
+			       <&hpdma 58 0x20 0x00003021 0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		sai2: sai@402a0000 {
+			compatible = "st,stm32mp25-sai";
+			reg = <0x402a0000 0x4>, <0x402aa3f0 0x10>;
+			ranges = <0 0x402a0000 0x400>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			clocks = <&rcc CK_BUS_SAI2>;
+			clock-names = "pclk";
+			interrupts = <GIC_SPI 162 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&rcc SAI2_R>;
+			status = "disabled";
+
+			sai2a: audio-controller@402a0004 {
+				compatible = "st,stm32-sai-sub-a";
+				reg = <0x4 0x20>;
+				#sound-dai-cells = <0>;
+				clocks = <&rcc CK_KER_SAI2>;
+				clock-names = "sai_ck";
+				dmas = <&hpdma 75 0x43 0x21 0>;
+				status = "disabled";
+			};
+
+			sai2b: audio-controller@402a0024 {
+				compatible = "st,stm32-sai-sub-b";
+				reg = <0x24 0x20>;
+				#sound-dai-cells = <0>;
+				clocks = <&rcc CK_KER_SAI2>;
+				clock-names = "sai_ck";
+				dmas = <&hpdma 76 0x43 0x12 0>;
+				status = "disabled";
+			};
+		};
+
+		uart9: serial@402c0000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x402c0000 0x400>;
+			interrupts = <GIC_SPI 150 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_UART9>;
+			dmas = <&hpdma 25 0x20 0x12 0x0>,
+			       <&hpdma 26 0x20 0x3021 0x0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		usart1: serial@40330000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40330000 0x400>;
+			interrupts = <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_USART1>;
+			dmas = <&hpdma 9 0x20 0x12 0x0>,
+			       <&hpdma 10 0x20 0x3021 0x0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		sai4: sai@40340000 {
+			compatible = "st,stm32mp25-sai";
+			reg = <0x40340000 0x4>, <0x4034a3f0 0x10>;
+			ranges = <0 0x40340000 0x400>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			clocks = <&rcc CK_BUS_SAI4>;
+			clock-names = "pclk";
+			interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&rcc SAI4_R>;
+			status = "disabled";
+
+			sai4a: audio-controller@40340004 {
+				compatible = "st,stm32-sai-sub-a";
+				reg = <0x4 0x20>;
+				#sound-dai-cells = <0>;
+				clocks = <&rcc CK_KER_SAI4>;
+				clock-names = "sai_ck";
+				dmas = <&hpdma 79 0x43 0x21 0>;
+				status = "disabled";
+			};
+
+			sai4b: audio-controller@40340024 {
+				compatible = "st,stm32-sai-sub-b";
+				reg = <0x24 0x20>;
+				#sound-dai-cells = <0>;
+				clocks = <&rcc CK_KER_SAI4>;
+				clock-names = "sai_ck";
+				dmas = <&hpdma 80 0x43 0x12 0>;
+				status = "disabled";
+			};
+		};
+
+		spi6: spi@40350000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32mp2-spi";
+			reg = <0x40350000 0x400>;
+			interrupts = <GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_SPI6>;
+			resets = <&rcc SPI6_R>;
+			dmas = <&hpdma 59 0x20 0x00003012 0>,
+			       <&hpdma 60 0x20 0x00003021 0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		spi7: spi@40360000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32mp2-spi";
+			reg = <0x40360000 0x400>;
+			interrupts = <GIC_SPI 155 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_SPI7>;
+			resets = <&rcc SPI7_R>;
+			dmas = <&hpdma 61 0x20 0x00003012 0>,
+			       <&hpdma 62 0x20 0x00003021 0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		uart7: serial@40370000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40370000 0x400>;
+			interrupts = <GIC_SPI 148 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_UART7>;
+			dmas = <&hpdma 21 0x20 0x12 0x0>,
+			       <&hpdma 22 0x20 0x3021 0x0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		uart8: serial@40380000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40380000 0x400>;
+			interrupts = <GIC_SPI 149 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_UART8>;
+			dmas = <&hpdma 23 0x20 0x12 0x0>,
+			       <&hpdma 24 0x20 0x3021 0x0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		hpdma: dma-controller@40400000 {
+			compatible = "st,stm32-dma3";
+			reg = <0x40400000 0x1000>;
+			interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 39 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 41 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi0_clk CK_SCMI0_HPDMA1>;
+			#dma-cells = <4>;
+		};
+
+		hpdma2: dma-controller@40410000 {
+			compatible = "st,stm32-dma3";
+			reg = <0x40410000 0x1000>;
+			interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 63 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 64 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi0_clk CK_SCMI0_HPDMA2>;
+			#dma-cells = <4>;
+		};
+
+		hpdma3: dma-controller@40420000 {
+			compatible = "st,stm32-dma3";
+			reg = <0x40420000 0x1000>;
+			interrupts = <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 68 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 76 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi0_clk CK_SCMI0_HPDMA3>;
+			#dma-cells = <4>;
+		};
+
+		ipcc1: mailbox@40490000 {
+			compatible = "st,stm32mp1-ipcc";
+			#mbox-cells = <1>;
+			reg = <0x40490000 0x400>;
+			st,proc-id = <0>;
+			interrupts = <GIC_SPI 171 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 172 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "rx", "tx";
+			clocks = <&scmi0_clk CK_SCMI0_IPCC1>;
+			status = "disabled";
+		};
+
+		dcmi: dcmi@404a0000 {
+			compatible = "st,stm32-dcmi";
+			reg = <0x404a0000 0x400>;
+			interrupts = <GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&rcc CCI_R>;
+			clocks = <&rcc CK_BUS_CCI>;
+			clock-names = "mclk";
+			dmas = <&hpdma 137 0x40 0x00003012 0>;
+			dma-names = "tx";
+			status = "disabled";
+		};
+
+		adc_12: adc@404e0000 {
+			compatible = "st,stm32mp25-adc-core";
+			reg = <0x404e0000 0x400>;
+			interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_ADC12>;
+			clock-names = "adc";
+			interrupt-controller;
+			#interrupt-cells = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			adc1: adc@0 {
+				compatible = "st,stm32mp25-adc";
+				reg = <0x0>;
+				interrupt-parent = <&adc_12>;
+				interrupts = <0>;
+				dmas = <&hpdma 81 0x20 0x12 0x0>;
+				dma-names = "rx";
+				#io-channel-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				status = "disabled";
+				channel@14 {
+					reg = <14>;
+					label = "vrefint";
+				};
+			};
+
+			adc2: adc@100 {
+				compatible = "st,stm32mp25-adc";
+				reg = <0x100>;
+				interrupt-parent = <&adc_12>;
+				interrupts = <1>;
+				dmas = <&hpdma 82 0x20 0x12 0>;
+				dma-names = "rx";
+				#io-channel-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				status = "disabled";
+				channel@14 {
+					reg = <14>;
+					label = "vrefint";
+				};
+				channel@15 {
+					reg = <15>;
+					label = "vddcore";
+				};
+			};
+		};
+
+		adc_3: adc@404f0000 {
+			compatible = "st,stm32mp25-adc-core";
+			reg = <0x404f0000 0x400>;
+			interrupts = <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_ADC3>;
+			clock-names = "adc";
+			interrupt-controller;
+			#interrupt-cells = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			adc3: adc@0 {
+				compatible = "st,stm32mp25-adc";
+				reg = <0x0>;
+				interrupt-parent = <&adc_3>;
+				interrupts = <0>;
+				dmas = <&hpdma 83 0x20 0x12 0>;
+				dma-names = "rx";
+				#io-channel-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				status = "disabled";
+				channel@14 {
+					reg = <14>;
+					label = "vrefint";
+				};
+				channel@15 {
+					reg = <15>;
+					label = "vddcore";
+				};
+			};
+		};
+
+		ommanager: ommanager@40500000 {
+			#address-cells = <2>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp25-omm";
+			reg = <0x40500000 0x400>, <0x60000000 0x10000000>;
+			reg-names = "omm", "omm_mm";
+			clocks = <&rcc CK_BUS_OSPIIOM>;
+			resets = <&rcc OSPIIOM_R>;
+			st,syscfg-amcr = <&syscfg 0x2c00 0x7>;
+			st,access = <&rifsc 111>;
+			status = "disabled";
+
+			ranges = <0 0 0x40430000 0x400>,
+				 <1 0 0x40440000 0x400>;
+
+			ospi1: spi@40430000 {
+				compatible = "st,stm32mp25-omi";
+				reg = <0 0 0x400>;
+				interrupts = <GIC_SPI 163 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 2 0x22 0x00003121 0x0>,
+				       <&hpdma 2 0x22 0x00003112 0x0>;
+				dma-names = "tx", "rx";
+				st,syscfg-dlyb = <&syscfg 0x1000>;
+				clocks = <&rcc CK_KER_OSPI1>;
+				resets = <&rcc OSPI1_R>, <&rcc OSPI1DLL_R>;
+				st,access = <&rifsc 74>;
+				status = "disabled";
+			};
+
+			ospi2: spi@40440000 {
+				compatible = "st,stm32mp25-omi";
+				reg = <1 0 0x400>;
+				interrupts = <GIC_SPI 164 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 3 0x22 0x00003121 0x0>,
+				       <&hpdma 3 0x22 0x00003112 0x0>;
+				dma-names = "tx", "rx";
+				st,syscfg-dlyb = <&syscfg 0x1400>;
+				clocks = <&rcc CK_KER_OSPI2>;
+				resets = <&rcc OSPI2_R>, <&rcc OSPI2DLL_R>;
+				st,access = <&rifsc 75>;
+				status = "disabled";
+			};
+		};
+
+		rifsc: rifsc@42080000 {
+			compatible = "st,stm32mp25-rifsc", "syscon";
+			reg = <0x42080000 0x1000>;
+		};
+
+		bsec: efuse@44000000 {
+			compatible = "st,stm32mp25-bsec";
+			reg = <0x44000000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			part_number_otp@24 {
+				reg = <0x24 0x4>;
+			};
+
+			package_otp@1e8 {
+				reg = <0x1e8 0x1>;
+				bits = <0 3>;
+			};
+		};
+
+		iwdg1: watchdog@44010000 {
+			compatible = "st,stm32mp1-iwdg";
+			reg = <0x44010000 0x400>;
+			clocks = <&rcc CK_BUS_IWDG1>, <&scmi0_clk CK_SCMI0_LSI>;
+			clock-names = "pclk", "lsi";
+			status = "disabled";
+		};
+
+		dts: dts@44070000 {
+			compatible = "moortec,mr75203";
+			reg = <0x44070000 0x80>,
+			      <0x44070080 0x180>,
+			      <0x44070200 0x200>,
+			      <0x44070400 0xc00>;
+			reg-names = "common", "ts", "pd", "vm";
+			clocks = <&rcc CK_KER_DTS>;
+			resets = <&rcc DTS_R>;
+			#thermal-sensor-cells = <1>;
+		};
+
+		hdp: hdp@44090000 {
+			compatible = "st,stm32mp1-hdp";
+			reg = <0x44090000 0x400>;
+			clocks = <&rcc CK_BUS_HDP>;
+			clock-names = "hdp";
+			status = "disabled";
+		};
+
+		rcc: rcc@44200000 {
+			compatible = "st,stm32mp2-rcc";
+			reg = <0x44200000 0x10000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			clock-names = "hse", "hsi", "msi", "lse", "lsi";
+			clocks = <&scmi0_clk CK_SCMI0_HSE>,
+				 <&scmi0_clk CK_SCMI0_HSI>,
+				 <&scmi0_clk CK_SCMI0_MSI>,
+				 <&scmi0_clk CK_SCMI0_LSE>,
+				 <&scmi0_clk CK_SCMI0_LSI>;
+		};
+
+		power: syscon@44210000 {
+			compatible = "st,stm32mp25-pwr", "syscon";
+			reg = <0x44210000 0x0400>;
+		};
+
+		syscfg: syscon@44230000 {
+			compatible = "st,stm32mp25-syscfg", "syscon";
+			reg = <0x44230000 0x10000>;
+		};
+
+		tamp: tamp@46010000 {
+			compatible = "st,stm32mp25-tamp", "syscon";
+			reg = <0x46010000 0x400>;
+		};
+
+		i2c8: i2c@46040000 {
+			compatible = "st,stm32mp25-i2c";
+			reg = <0x46040000 0x400>;
+			interrupt-names = "event";
+			interrupts = <GIC_SPI 212 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_I2C8>;
+			resets = <&rcc I2C8_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		spi8: spi@46020000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32mp2-spi";
+			reg = <0x46020000 0x400>;
+			interrupts = <GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_SPI8>;
+			resets = <&rcc SPI8_R>;
+			status = "disabled";
+		};
+
+		lptimer3: timer@46050000 {
+			compatible = "st,stm32mp25-lptimer";
+			reg = <0x46050000 0x400>;
+			interrupts = <GIC_SPI 216 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_LPTIM3>;
+			clock-names = "mux";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32mp25-pwm-lp";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			trigger@2 {
+				compatible = "st,stm32mp25-lptimer-trigger";
+				reg = <2>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-lptimer-counter";
+				status = "disabled";
+			};
+
+			timer {
+				compatible = "st,stm32mp25-lptimer-timer";
+				status = "disabled";
+			};
+		};
+
+		lptimer4: timer@46060000 {
+			compatible = "st,stm32mp25-lptimer";
+			reg = <0x46060000 0x400>;
+			interrupts = <GIC_SPI 217 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_LPTIM4>;
+			clock-names = "mux";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32mp25-pwm-lp";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			trigger@3 {
+				compatible = "st,stm32mp25-lptimer-trigger";
+				reg = <3>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-lptimer-counter";
+				status = "disabled";
+			};
+
+			timer {
+				compatible = "st,stm32mp25-lptimer-timer";
+				status = "disabled";
+			};
+		};
+
+		lptimer5: timer@46070000 {
+			compatible = "st,stm32mp25-lptimer";
+			reg = <0x46070000 0x400>;
+			interrupts = <GIC_SPI 218 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_LPTIM5>;
+			clock-names = "mux";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32mp25-pwm-lp";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			trigger@4 {
+				compatible = "st,stm32mp25-lptimer-trigger";
+				reg = <4>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-lptimer-counter";
+				status = "disabled";
+			};
+
+			timer {
+				compatible = "st,stm32mp25-lptimer-timer";
+				status = "disabled";
+			};
+		};
+
+		dsi: dsi@48000000 {
+			compatible = "st,stm32-dsi";
+			reg = <0x48000000 0x800>;
+			clocks = <&rcc CK_BUS_DSI>, <&rcc CK_KER_DSIPHY>, <&rcc CK_KER_LTDC>;
+			clock-names = "pclk", "ref", "px_clk";
+			resets = <&rcc DSI_R>;
+			reset-names = "apb";
+			status = "disabled";
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+		};
+
+		ltdc: display-controller@48010000 {
+			compatible = "st,stm32-ltdc";
+			reg = <0x48010000 0x400>;
+			st,syscon = <&syscfg>;
+			interrupts = <GIC_SPI 158 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 159 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_BUS_LTDC>, <&rcc CK_KER_LTDC>;
+			clock-names = "bus", "lcd";
+			resets = <&rcc LTDC_R>;
+			status = "disabled";
+		};
+
+		ddrperfm: perf@48041000 {
+			compatible = "st,stm32mp25-ddr-pmu";
+			reg = <0x48041000 0x400>;
+			status = "disabled";
+		};
+
+		combophy: phy@480c0000 {
+			compatible = "st,stm32mp25-combophy";
+			reg = <0x480c0000 0x1000>;
+			#phy-cells = <1>;
+			clocks = <&rcc CK_BUS_USB3PCIEPHY>, <&rcc CK_KER_USB3PCIEPHY>;
+			clock-names = "apb-clk", "ker-clk";
+			resets = <&rcc USB3PCIEPHY_R>;
+			reset-names = "phy-rst";
+			st,syscfg = <&syscfg>;
+			status = "disabled";
+		};
+
+		fmc: memory-controller@48200000 {
+			#address-cells = <2>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp25-fmc2-ebi";
+			reg = <0x48200000 0x400>;
+			clocks = <&scmi0_clk CK_SCMI0_FMC>;
+			resets = <&scmi0_reset RST_SCMI0_FMC>;
+			status = "disabled";
+
+			ranges = <0 0 0x70000000 0x04000000>, /* EBI CS 1 */
+				 <1 0 0x74000000 0x04000000>, /* EBI CS 2 */
+				 <2 0 0x78000000 0x04000000>, /* EBI CS 3 */
+				 <3 0 0x7c000000 0x04000000>, /* EBI CS 4 */
+				 <4 0 0x48810000 0x00001000>; /* NAND */
+
+			nand-controller@4,0 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-fmc2-nfc";
+				reg = <4 0x0000 0x10>,
+				      <4 0x0090 0x10>,
+				      <4 0x00a0 0x10>,
+				      <4 0x0400 0x10>,
+				      <4 0x0490 0x10>,
+				      <4 0x04a0 0x10>,
+				      <4 0x0800 0x10>,
+				      <4 0x0890 0x10>,
+				      <4 0x08a0 0x10>,
+				      <4 0x0c00 0x10>,
+				      <4 0x0c90 0x10>,
+				      <4 0x0ca0 0x10>;
+				interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 0 0x62 0x00003101 0x0>,
+				       <&hpdma 0 0x62 0x00003110 0x0>,
+				       <&hpdma 1 0x22 0x00003111 0x0>;
+				dma-names = "tx", "rx", "ecc";
+				status = "disabled";
+			};
+		};
+
+		sdmmc1: mmc@48220000 {
+			compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+			arm,primecell-periphid = <0x00353180>;
+			reg = <0x48220000 0x400>, <0x44230400 0x8>;
+			interrupts = <GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_SDMMC1>;
+			clock-names = "apb_pclk";
+			resets = <&rcc SDMMC1_R>;
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			max-frequency = <120000000>;
+			status = "disabled";
+		};
+
+		sdmmc2: mmc@48230000 {
+			compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+			arm,primecell-periphid = <0x00353180>;
+			reg = <0x48230000 0x400>, <0x44230800 0x8>;
+			interrupts = <GIC_SPI 197 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_SDMMC2>;
+			clock-names = "apb_pclk";
+			resets = <&rcc SDMMC2_R>;
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			max-frequency = <120000000>;
+			status = "disabled";
+		};
+
+		sdmmc3: mmc@48240000 {
+			compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+			arm,primecell-periphid = <0x00353180>;
+			reg = <0x48240000 0x400>, <0x44230c00 0x8>;
+			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CK_KER_SDMMC3>;
+			clock-names = "apb_pclk";
+			resets = <&rcc SDMMC3_R>;
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			max-frequency = <120000000>;
+			status = "disabled";
+		};
+
+		eth1: eth1@482c0000 {
+			compatible = "st,stm32mp25-dwmac", "snps,dwmac-5.10a";
+			reg = <0x482c0000 0x4000>;
+			reg-names = "stmmaceth";
+			interrupts-extended = <&intc GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			clock-names = "stmmaceth",
+				      "mac-clk-tx",
+				      "mac-clk-rx",
+				      "ethstp",
+				      "eth-ck";
+			clocks = <&rcc CK_ETH1_MAC>,
+				 <&rcc CK_ETH1_TX>,
+				 <&rcc CK_ETH1_RX>,
+				 <&rcc CK_ETH1_STP>,
+				 <&rcc CK_KER_ETH1>;
+			st,syscon = <&syscfg 0x3000 0xffffffff>;
+			snps,fixed-burst;
+			snps,pbl = <2>;
+			snps,axi-config = <&stmmac_axi_config_1>;
+			snps,tso;
+			status = "disabled";
+			snps,mtl-rx-config = <&mtl_rx_setup_1>;
+			snps,mtl-tx-config = <&mtl_tx_setup_1>;
+
+			stmmac_axi_config_1: stmmac-axi-config {
+				snps,wr_osr_lmt = <0x7>;
+				snps,rd_osr_lmt = <0x7>;
+				snps,blen = <0 0 0 0 0 0 4>;
+			};
+
+			mtl_rx_setup_1: rx-queues-config {
+				snps,rx-queues-to-use = <1>;
+				queue0 {};
+			};
+
+			mtl_tx_setup_1: tx-queues-config {
+				snps,tx-queues-to-use = <2>;
+				queue0 {};
+				queue1 {};
+			};
+		};
+
+		usb2h: usb@482e0000 {
+			compatible      = "st,stm32mp25-usb2h";
+			st,syscfg       = <&syscfg 0x2420>;
+			#address-cells  = <1>;
+			#size-cells     = <1>;
+			ranges = <0x482e0000 0x482e0000 0x20000>;
+			status = "disabled";
+
+			usb2h_ohci: usb@482e0000 {
+				compatible = "generic-ohci";
+				reg = <0x482e0000 0x1000>;
+				clocks = <&rcc CK_BUS_USB2OHCI>;
+				resets = <&rcc USB2_R>;
+				interrupts = <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>;
+				phys = <&usb2_phy1>;
+				phy-names = "usb";
+			};
+
+			usb2h_ehci: usb@482f0000 {
+				compatible = "generic-ehci";
+				reg = <0x482f0000 0x1000>;
+				clocks = <&rcc CK_BUS_USB2EHCI>;
+				resets = <&rcc USB2_R>;
+				interrupts = <GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>;
+				companion = <&usb2h_ohci>;
+				phys = <&usb2_phy1>;
+				phy-names = "usb";
+			};
+		};
+
+		usb3drd: usb@48300000 {
+			compatible      = "st,stm32mp25-dwc3";
+			st,syscfg       = <&syscfg 0x4800>;
+			#address-cells  = <1>;
+			#size-cells     = <1>;
+			ranges = <0x48300000 0x48300000 0x100000>;
+			status = "disabled";
+
+			dwc3: usb@48300000 {
+				compatible      = "snps,dwc3";
+				reg             = <0x48300000 0x100000>;
+				interrupts      = <GIC_SPI 228 IRQ_TYPE_LEVEL_HIGH>;
+				clock-names     = "ref", "bus_early", "suspend";
+				clocks          = <&rcc CK_KER_USB2PHY2>, <&rcc CK_BUS_USB3DRD>,
+						  <&rcc CK_KER_USB2PHY2>;
+				resets          = <&rcc USB3DRD_R>;
+				phys            = <&usb2_phy2>;
+				phy-names       = "usb2-phy";
+			};
+		};
+
+		pcie_rc: pcie@48400000 {
+			compatible = "st,stm32mp25-pcie-rc", "snps,dw-pcie";
+			device_type = "pci";
+			num-lanes = <1>;
+			reg = <0x48400000 0x400000>,
+			      <0x10000000 0x1000>;
+			reg-names = "dbi", "config";
+			st,syscfg = <&syscfg>;
+			#interrupt-cells = <1>;
+			interrupt-map-mask = <0 0 0 7>;
+			interrupt-map = <0 0 0 1 &intc 0 GIC_SPI 264 IRQ_TYPE_LEVEL_HIGH>,
+					<0 0 0 2 &intc 0 GIC_SPI 265 IRQ_TYPE_LEVEL_HIGH>,
+					<0 0 0 3 &intc 0 GIC_SPI 266 IRQ_TYPE_LEVEL_HIGH>,
+					<0 0 0 4 &intc 0 GIC_SPI 267 IRQ_TYPE_LEVEL_HIGH>;
+			#address-cells = <3>;
+			#size-cells = <2>;
+			ranges = <0x01000000 0 0x10001000 0x10001000 0 0x10000>,
+				 <0x02000000 0 0x10011000 0x10011000 0 0x7fef000>,
+				 <0x42000000 0 0x18000000 0x18000000 0 0x8000000>;
+			bus-range = <0x00 0xff>;
+			clocks = <&rcc CK_BUS_PCIE>;
+			clock-names = "pcie-clk";
+			resets = <&scmi0_reset RST_SCMI0_PCIE>;
+			reset-names = "pcie-rst";
+			phys = <&combophy PHY_TYPE_PCIE>;
+			phy-names = "pcie-phy";
+
+			msi-parent = <&v2m0>;
+			status = "disabled";
+		};
+
+		a35ssc_m33: syscon@488020a0 {
+			compatible = "st,stm32mp25-a35ssc-m33", "syscon";
+			reg = <0x488020a0 0x0C>;
+			status = "disabled";
+		};
+
+		exti1: interrupt-controller@44220000 {
+			compatible = "st,stm32mp1-exti", "syscon";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			#address-cells = <0>;
+			reg = <0x44220000 0x400>;
+
+			exti-interrupt-map {
+				#address-cells = <0>;
+				#interrupt-cells = <2>;
+				interrupt-map-mask = <0xffffffff 0>;
+				interrupt-map =
+					<0  0 &intc 0 GIC_SPI 268 IRQ_TYPE_LEVEL_HIGH>,
+					<1  0 &intc 0 GIC_SPI 269 IRQ_TYPE_LEVEL_HIGH>,
+					<2  0 &intc 0 GIC_SPI 270 IRQ_TYPE_LEVEL_HIGH>,
+					<3  0 &intc 0 GIC_SPI 271 IRQ_TYPE_LEVEL_HIGH>,
+					<4  0 &intc 0 GIC_SPI 272 IRQ_TYPE_LEVEL_HIGH>,
+					<5  0 &intc 0 GIC_SPI 273 IRQ_TYPE_LEVEL_HIGH>,
+					<6  0 &intc 0 GIC_SPI 274 IRQ_TYPE_LEVEL_HIGH>,
+					<7  0 &intc 0 GIC_SPI 275 IRQ_TYPE_LEVEL_HIGH>,
+					<8  0 &intc 0 GIC_SPI 276 IRQ_TYPE_LEVEL_HIGH>,
+					<9  0 &intc 0 GIC_SPI 277 IRQ_TYPE_LEVEL_HIGH>,
+					<10 0 &intc 0 GIC_SPI 278 IRQ_TYPE_LEVEL_HIGH>,
+					<11 0 &intc 0 GIC_SPI 279 IRQ_TYPE_LEVEL_HIGH>,
+					<12 0 &intc 0 GIC_SPI 280 IRQ_TYPE_LEVEL_HIGH>,
+					<13 0 &intc 0 GIC_SPI 281 IRQ_TYPE_LEVEL_HIGH>,
+					<14 0 &intc 0 GIC_SPI 282 IRQ_TYPE_LEVEL_HIGH>,
+					<15 0 &intc 0 GIC_SPI 283 IRQ_TYPE_LEVEL_HIGH>,
+					<16 0 &intc 0 GIC_SPI 0   IRQ_TYPE_LEVEL_HIGH>,
+					<17 0 &intc 0 GIC_SPI 1   IRQ_TYPE_LEVEL_HIGH>,
+					<18 0 &intc 0 GIC_SPI 260 IRQ_TYPE_LEVEL_HIGH>,
+					<19 0 &intc 0 GIC_SPI 259 IRQ_TYPE_LEVEL_HIGH>,
+					<21 0 &intc 0 GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>,
+					<22 0 &intc 0 GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>,
+					<23 0 &intc 0 GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>,
+					<24 0 &intc 0 GIC_SPI 168 IRQ_TYPE_LEVEL_HIGH>,
+					<25 0 &intc 0 GIC_SPI 181 IRQ_TYPE_LEVEL_HIGH>,
+					<26 0 &intc 0 GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>,
+					<27 0 &intc 0 GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>,
+					<28 0 &intc 0 GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>,
+					<29 0 &intc 0 GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>,
+					<30 0 &intc 0 GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>,
+					<31 0 &intc 0 GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>,
+					<32 0 &intc 0 GIC_SPI 148 IRQ_TYPE_LEVEL_HIGH>,
+					<33 0 &intc 0 GIC_SPI 149 IRQ_TYPE_LEVEL_HIGH>,
+					<34 0 &intc 0 GIC_SPI 150 IRQ_TYPE_LEVEL_HIGH>,
+					<36 0 &intc 0 GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>,
+					<37 0 &intc 0 GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>,
+					<38 0 &intc 0 GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>,
+					<39 0 &intc 0 GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH>,
+					<40 0 &intc 0 GIC_SPI 153 IRQ_TYPE_LEVEL_HIGH>,
+					<41 0 &intc 0 GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>,
+					<42 0 &intc 0 GIC_SPI 155 IRQ_TYPE_LEVEL_HIGH>,
+					<43 0 &intc 0 GIC_SPI 169 IRQ_TYPE_LEVEL_HIGH>,
+					<44 0 &intc 0 GIC_SPI 182 IRQ_TYPE_LEVEL_HIGH>,
+					<45 0 &intc 0 GIC_SPI 209 IRQ_TYPE_LEVEL_HIGH>,
+					<46 0 &intc 0 GIC_SPI 229 IRQ_TYPE_LEVEL_HIGH>,
+					<47 0 &intc 0 GIC_SPI 166 IRQ_TYPE_LEVEL_HIGH>,
+					<48 0 &intc 0 GIC_SPI 215 IRQ_TYPE_LEVEL_HIGH>,
+					<49 0 &intc 0 GIC_SPI 208 IRQ_TYPE_LEVEL_HIGH>,
+					<50 0 &intc 0 GIC_SPI 210 IRQ_TYPE_LEVEL_HIGH>,
+					<59 0 &intc 0 GIC_SPI 171 IRQ_TYPE_LEVEL_HIGH>,
+					//	<59 0 &intc 0 GIC_SPI 172 IRQ_TYPE_LEVEL_HIGH>,
+					<61 0 &intc 0 GIC_SPI 173 IRQ_TYPE_LEVEL_HIGH>,
+					//	<61 0 &intc 0 GIC_SPI 174 IRQ_TYPE_LEVEL_HIGH>,
+					<64 0 &intc 0 GIC_SPI 220 IRQ_TYPE_LEVEL_HIGH>,
+					<67 0 &intc 0 GIC_SPI 10  IRQ_TYPE_LEVEL_HIGH>,
+					<68 0 &intc 0 GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>,
+					<70 0 &intc 0 GIC_SPI 134 IRQ_TYPE_LEVEL_HIGH>,
+					<72 0 &intc 0 GIC_SPI 224 IRQ_TYPE_LEVEL_HIGH>,
+					<73 0 &intc 0 GIC_SPI 202 IRQ_TYPE_LEVEL_HIGH>,
+					<74 0 &intc 0 GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>,
+					<75 0 &intc 0 GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>,
+					<76 0 &intc 0 GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>,
+					<77 0 &intc 0 GIC_SPI 253 IRQ_TYPE_LEVEL_HIGH>,
+					<78 0 &intc 0 GIC_SPI 254 IRQ_TYPE_LEVEL_HIGH>,
+					<79 0 &intc 0 GIC_SPI 255 IRQ_TYPE_LEVEL_HIGH>,
+					<83 0 &intc 0 GIC_SPI 257 IRQ_TYPE_LEVEL_HIGH>,
+					<84 0 &intc 0 GIC_SPI 258 IRQ_TYPE_LEVEL_HIGH>;
+			};
+		};
+
+		exti2: interrupt-controller@46230000 {
+			compatible = "st,stm32mp1-exti", "syscon";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			#address-cells = <0>;
+			reg = <0x46230000 0x400>;
+
+			exti-interrupt-map {
+				#address-cells = <0>;
+				#interrupt-cells = <2>;
+				interrupt-map-mask = <0xffffffff 0>;
+				interrupt-map =
+					<16 0 &intc 0 GIC_SPI 12  IRQ_TYPE_LEVEL_HIGH>,
+					<17 0 &intc 0 GIC_SPI 13  IRQ_TYPE_LEVEL_HIGH>,
+					<21 0 &intc 0 GIC_SPI 14  IRQ_TYPE_LEVEL_HIGH>,
+					<22 0 &intc 0 GIC_SPI 15  IRQ_TYPE_LEVEL_HIGH>,
+					<25 0 &intc 0 GIC_SPI 212 IRQ_TYPE_LEVEL_HIGH>,
+					<26 0 &intc 0 GIC_SPI 151 IRQ_TYPE_LEVEL_HIGH>,
+					<27 0 &intc 0 GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH>,
+					<29 0 &intc 0 GIC_SPI 216 IRQ_TYPE_LEVEL_HIGH>,
+					<30 0 &intc 0 GIC_SPI 217 IRQ_TYPE_LEVEL_HIGH>,
+					<31 0 &intc 0 GIC_SPI 218 IRQ_TYPE_LEVEL_HIGH>,
+					<33 0 &intc 0 GIC_SPI 207 IRQ_TYPE_LEVEL_HIGH>,
+					<34 0 &intc 0 GIC_SPI 175 IRQ_TYPE_LEVEL_HIGH>,
+					//	<34 0 &intc 0 GIC_SPI 176 IRQ_TYPE_LEVEL_HIGH>,
+					<37 0 &intc 0 GIC_SPI 177 IRQ_TYPE_LEVEL_HIGH>,
+					//	<37 0 &intc 0 GIC_SPI 178 IRQ_TYPE_LEVEL_HIGH>,
+					<40 0 &intc 0 GIC_SPI 199 IRQ_TYPE_LEVEL_HIGH>,
+					<43 0 &intc 0 GIC_SPI 200 IRQ_TYPE_LEVEL_HIGH>,
+					<46 0 &intc 0 GIC_SPI 11  IRQ_TYPE_LEVEL_HIGH>,
+					<48 0 &intc 0 GIC_SPI 5   IRQ_TYPE_LEVEL_HIGH>,
+					<49 0 &intc 0 GIC_SPI 4   IRQ_TYPE_LEVEL_HIGH>,
+					<50 0 &intc 0 GIC_SPI 6   IRQ_TYPE_LEVEL_HIGH>,
+					<51 0 &intc 0 GIC_SPI 7   IRQ_TYPE_LEVEL_HIGH>,
+					<52 0 &intc 0 GIC_SPI 2   IRQ_TYPE_LEVEL_HIGH>,
+					<53 0 &intc 0 GIC_SPI 3   IRQ_TYPE_LEVEL_HIGH>,
+					<61 0 &intc 0 GIC_SPI 221 IRQ_TYPE_LEVEL_HIGH>,
+					<62 0 &intc 0 GIC_SPI 246 IRQ_TYPE_LEVEL_HIGH>,
+					<64 0 &intc 0 GIC_SPI 247 IRQ_TYPE_LEVEL_HIGH>,
+					<65 0 &intc 0 GIC_SPI 248 IRQ_TYPE_LEVEL_HIGH>,
+					<66 0 &intc 0 GIC_SPI 249 IRQ_TYPE_LEVEL_HIGH>,
+					<67 0 &intc 0 GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH>,
+					<70 0 &intc 0 GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>;
+			};
+		};
+
+		/*
+		 * Break node order to solve dependency probe issue between
+		 * pinctrl and exti.
+		 */
+		pinctrl: pinctrl@44240000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp257-pinctrl";
+			ranges = <0 0x44240000 0xa0400>;
+			interrupt-parent = <&exti1>;
+			st,syscfg = <&exti1 0x60 0xff>;
+			pins-are-numbered;
+
+			gpioa: gpio@44240000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x0 0x400>;
+				clocks = <&scmi0_clk CK_SCMI0_GPIOA>;
+				st,bank-name = "GPIOA";
+				status = "disabled";
+			};
+
+			gpiob: gpio@44250000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x10000 0x400>;
+				clocks = <&scmi0_clk CK_SCMI0_GPIOB>;
+				st,bank-name = "GPIOB";
+				status = "disabled";
+			};
+
+			gpioc: gpio@44260000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x20000 0x400>;
+				clocks = <&scmi0_clk CK_SCMI0_GPIOC>;
+				st,bank-name = "GPIOC";
+				status = "disabled";
+			};
+
+			gpiod: gpio@44270000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x30000 0x400>;
+				clocks = <&scmi0_clk CK_SCMI0_GPIOD>;
+				st,bank-name = "GPIOD";
+				status = "disabled";
+			};
+
+			gpioe: gpio@44280000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x40000 0x400>;
+				clocks = <&scmi0_clk CK_SCMI0_GPIOE>;
+				st,bank-name = "GPIOE";
+				status = "disabled";
+			};
+
+			gpiof: gpio@44290000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x50000 0x400>;
+				clocks = <&scmi0_clk CK_SCMI0_GPIOF>;
+				st,bank-name = "GPIOF";
+				status = "disabled";
+			};
+
+			gpiog: gpio@442a0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x60000 0x400>;
+				clocks = <&scmi0_clk CK_SCMI0_GPIOG>;
+				st,bank-name = "GPIOG";
+				status = "disabled";
+			};
+
+			gpioh: gpio@442b0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x70000 0x400>;
+				clocks = <&scmi0_clk CK_SCMI0_GPIOH>;
+				st,bank-name = "GPIOH";
+				status = "disabled";
+			};
+
+			gpioi: gpio@442c0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x80000 0x400>;
+				clocks = <&scmi0_clk CK_SCMI0_GPIOI>;
+				st,bank-name = "GPIOI";
+				status = "disabled";
+			};
+
+			gpioj: gpio@442d0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x90000 0x400>;
+				clocks = <&scmi0_clk CK_SCMI0_GPIOJ>;
+				st,bank-name = "GPIOJ";
+				status = "disabled";
+			};
+
+			gpiok: gpio@442e0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0xa0000 0x400>;
+				clocks = <&scmi0_clk CK_SCMI0_GPIOK>;
+				st,bank-name = "GPIOK";
+				status = "disabled";
+			};
+		};
+
+		pinctrl_z: pinctrl@46200000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp257-z-pinctrl";
+			ranges = <0 0x46200000 0x400>;
+			interrupt-parent = <&exti1>;
+			st,syscfg = <&exti1 0x60 0xff>;
+			pins-are-numbered;
+
+			gpioz: gpio@46200000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0 0x400>;
+				clocks = <&scmi0_clk CK_SCMI0_GPIOZ>;
+				st,bank-name = "GPIOZ";
+				st,bank-ioport = <11>;
+				status = "disabled";
+			};
+
+		};
+
+		csi2host: csi2host@48020000 {
+			compatible = "st,stm32-csi2host";
+			reg = <0x48020000 0x2000>;
+			interrupts = <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&rcc CSI_R>;
+			clocks = <&rcc CK_KER_CSI>, <&rcc CK_KER_CSITXESC>, <&rcc CK_KER_CSIPHY>;
+			clock-names = "pclk", "txesc", "csi2phy";
+			status = "disabled";
+		};
+
+		dcmipp: dcmipp@48030000 {
+			compatible = "st,stm32mp25-dcmipp";
+			reg = <0x48030000 0x1000>;
+			interrupts = <GIC_SPI 198 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&rcc DCMIPP_R>;
+			clocks = <&rcc CK_BUS_DCMIPP>, <&rcc CK_KER_CSI>;
+			clock-names = "kclk", "mclk";
+			status = "disabled";
+		};
+
+		spdifrx: audio-controller@500d0000 {
+			compatible = "st,stm32h7-spdifrx";
+			#sound-dai-cells = <0>;
+			reg = <0x500d0000 0x400>;
+			clocks = <&rcc CK_KER_SPDIFRX>;
+			clock-names = "kclk";
+			interrupts = <GIC_SPI 170 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&hpdma 71 0x43 0x212 0>,
+			       <&hpdma 72 0x43 0x212 0>;
+			dma-names = "rx", "rx-ctrl";
+			status = "disabled";
+		};
+
+		sai1: sai@50290000 {
+			compatible = "st,stm32mp25-sai";
+			reg = <0x50290000 0x4>, <0x5029a3f0 0x10>;
+			ranges = <0 0x50290000 0x400>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			clocks = <&rcc CK_BUS_SAI1>;
+			clock-names = "pclk";
+			interrupts = <GIC_SPI 157 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&rcc SAI1_R>;
+			status = "disabled";
+
+			sai1a: audio-controller@50290004 {
+				compatible = "st,stm32-sai-sub-a";
+				reg = <0x4 0x20>;
+				#sound-dai-cells = <0>;
+				clocks = <&rcc CK_KER_SAI1>;
+				clock-names = "sai_ck";
+				dmas = <&hpdma 73 0x43 0x21 0>;
+				status = "disabled";
+			};
+
+			sai1b: audio-controller@50290024 {
+				compatible = "st,stm32-sai-sub-b";
+				reg = <0x24 0x20>;
+				#sound-dai-cells = <0>;
+				clocks = <&rcc CK_KER_SAI1>;
+				clock-names = "sai_ck";
+				dmas = <&hpdma 74 0x43 0x12 0>;
+				status = "disabled";
+			};
+		};
+
+		sai3: sai@502b0000 {
+			compatible = "st,stm32mp25-sai";
+			reg = <0x502b0000 0x4>, <0x502ba3f0 0x10>;
+			ranges = <0 0x502b0000 0x400>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			clocks = <&rcc CK_BUS_SAI3>;
+			clock-names = "pclk";
+			interrupts = <GIC_SPI 192 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&rcc SAI3_R>;
+			status = "disabled";
+
+			sai3a: audio-controller@502b0004 {
+				compatible = "st,stm32-sai-sub-a";
+				reg = <0x4 0x20>;
+				#sound-dai-cells = <0>;
+				clocks = <&rcc CK_KER_SAI3>;
+				clock-names = "sai_ck";
+				dmas = <&hpdma 77 0x43 0x21 0>;
+				status = "disabled";
+			};
+
+			sai3b: audio-controller@502b0024 {
+				compatible = "st,stm32-sai-sub-b";
+				reg = <0x24 0x20>;
+				#sound-dai-cells = <0>;
+				clocks = <&rcc CK_KER_SAI3>;
+				clock-names = "sai_ck";
+				dmas = <&hpdma 78 0x43 0x12 0>;
+				status = "disabled";
+			};
+		};
+	};
+
+	mlahb: ahb {
+		compatible = "st,mlahb", "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		dma-ranges;
+
+		m33_rproc: m33@a040000 {
+			compatible = "st,stm32mp2-m33";
+			reg = <0x0a040000 0x60000>;
+			resets = <&scmi0_reset RST_SCMI0_C2_R>,
+				 <&scmi0_reset RST_SCMI0_C2_HOLDBOOT_R>;
+			reset-names = "mcu_rst", "hold_boot";
+			st,syscfg-cm-state = <&power 0x204 0x0000000c>;
+			st,syscfg-rsc-tbl = <&tamp 0x284 0xffffffff>;
+			interrupt-parent = <&intc>;
+			interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+
+			status = "disabled";
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp253.dtsi b/arch/arm64/boot/dts/st/stm32mp253.dtsi
new file mode 100644
index 000000000..1803e3d8f
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp253.dtsi
@@ -0,0 +1,82 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include "stm32mp251.dtsi"
+
+/ {
+	arm-pmu {
+		interrupts = <GIC_SPI 368 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 369 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&cpu0>, <&cpu1>;
+	};
+
+	cpus {
+		cpu1: cpu@1 {
+			compatible = "arm,cortex-a35";
+			device_type = "cpu";
+			reg = <1>;
+			enable-method = "psci";
+			clocks = <&scmi0_perf 0>;
+			clock-names = "cpu";
+		};
+	};
+
+	soc {
+		lvds: lvds@48060000 {
+			#clock-cells = <0>;
+			compatible = "st,stm32-lvds";
+			reg = <0x48060000 0x2000>;
+			clocks = <&rcc CK_KER_LVDSPHY>, <&scmi0_clk CK_SCMI0_FLEXGEN_32>;
+			clock-names = "pclk", "ref";
+			resets = <&rcc LVDS_R>;
+			status = "disabled";
+		};
+
+		eth2: eth2@482d0000 {
+			compatible = "st,stm32mp25-dwmac", "snps,dwmac-5.10a";
+			reg = <0x482d0000 0x4000>;
+			reg-names = "stmmaceth";
+			interrupts-extended = <&intc GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			clock-names = "stmmaceth",
+				      "mac-clk-tx",
+				      "mac-clk-rx",
+				      "ptp_ref",
+				      "ethstp",
+				      "eth-ck";
+			clocks = <&rcc CK_ETH2_MAC>,
+				 <&rcc CK_ETH2_TX>,
+				 <&rcc CK_ETH2_RX>,
+				 <&rcc CK_KER_ETH2PTP>,
+				 <&rcc CK_ETH2_STP>,
+				 <&rcc CK_KER_ETH2>;
+			st,syscon = <&syscfg 0x3400 0xffffffff>;
+			snps,fixed-burst;
+			snps,pbl = <2>;
+			snps,axi-config = <&stmmac_axi_config_2>;
+			snps,tso;
+			status = "disabled";
+			snps,mtl-rx-config = <&mtl_rx_setup_2>;
+			snps,mtl-tx-config = <&mtl_tx_setup_2>;
+
+			stmmac_axi_config_2: stmmac-axi-config {
+				snps,wr_osr_lmt = <0x7>;
+				snps,rd_osr_lmt = <0x7>;
+				snps,blen = <0 0 0 0 0 0 4>;
+			};
+
+			mtl_rx_setup_2: rx-queues-config {
+				snps,rx-queues-to-use = <1>;
+				queue0 {};
+			};
+
+			mtl_tx_setup_2: tx-queues-config {
+				snps,tx-queues-to-use = <2>;
+				queue0 {};
+				queue1 {};
+			};
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp255.dtsi b/arch/arm64/boot/dts/st/stm32mp255.dtsi
new file mode 100644
index 000000000..a58301e9f
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp255.dtsi
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include "stm32mp253.dtsi"
+
+/ {
+	soc {
+		vdec: vdec@580d0000 {
+			compatible = "st,stm32mp25-vdec";
+			reg = <0x580d0000 0x3c8>;
+			resets = <&rcc VDEC_R>;
+			interrupt-names = "vdec";
+			interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "vdec-clk";
+			clocks = <&rcc CK_BUS_VDEC>;
+			status = "disabled";
+		};
+
+		venc: venc@580e0000 {
+			compatible = "st,stm32mp25-venc";
+			reg = <0x580e0000 0x800>;
+			reset-names = "venc-rst";
+			resets = <&rcc VENC_R>;
+			interrupt-names = "venc";
+			interrupts = <GIC_SPI 167 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "venc-clk";
+			clocks = <&rcc CK_BUS_VENC>;
+			status = "disabled";
+		};
+
+		gpu: gpu@58280000 {
+			compatible = "vivante,gc";
+			reg = <0x58280000 0x800>;
+			interrupts = <GIC_SPI 183 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&rcc GPU_R>;
+			clock-names = "axi", "core";
+			clocks = <&rcc CK_BUS_GPU>, <&scmi0_clk CK_SCMI0_GPU>;
+			gpu-supply =  <&scmi_vddgpu>;
+			status = "disabled";
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp257.dtsi b/arch/arm64/boot/dts/st/stm32mp257.dtsi
new file mode 100644
index 000000000..5eaea6ea8
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp257.dtsi
@@ -0,0 +1,50 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include "stm32mp255.dtsi"
+
+/ {
+	soc {
+		switch0: ttt-sw@4c000000 {
+			#address-cells  = <1>;
+			#size-cells     = <1>;
+			compatible = "st,stm32-deip";
+			clock-names = "ethsw-bus-clk", "ethsw-clk",
+				      "ethswacmcfg-bus-clk", "ethswacmmsg-bus-clk";
+			clocks = <&rcc CK_BUS_ETHSW>,
+				 <&rcc CK_KER_ETHSW>,
+				 <&rcc CK_BUS_ETHSWACMCFG>,
+				 <&rcc CK_BUS_ETHSWACMMSG>;
+			st,syscon = <&syscfg 0x3800>;
+			ranges = <0x4c000000 0x4c000000 0x2000000>,
+				 <0x4b000000 0x4b000000 0xc0000>;
+			status = "disabled";
+
+			deip_sw0: deip-sw@4c000000 {
+				compatible =  "ttt,deip-sw";
+				reg = <0x4c000000 0x2000000>;
+				interrupts = <GIC_SPI 250 IRQ_TYPE_LEVEL_HIGH>;
+			};
+
+			acm@4b000000 {
+				compatible = "ttt,acm-4.0";
+				reg = <0x4b000000 0x00400>,
+				      <0x4b010000 0x10000>,
+				      <0x4b030000 0x10000>,
+				      <0x4b050000 0x10000>,
+				      <0x4b060000 0x20000>,
+				      <0x4b080000 0x40000>;
+				reg-names = "CommonRegister",
+					    "Bypass1",
+					    "Bypass0",
+					    "Redundancy",
+					    "Scheduler",
+					    "Messagebuffer";
+				buffers = <32>;
+				ptp_worker = <&deip_sw0>;
+			};
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp257f-dk.dts b/arch/arm64/boot/dts/st/stm32mp257f-dk.dts
new file mode 100644
index 000000000..a6615e26e
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp257f-dk.dts
@@ -0,0 +1,29 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp257.dtsi"
+#include "stm32mp25xf.dtsi"
+#include "stm32mp25-pinctrl.dtsi"
+#include "stm32mp25xxal-pinctrl.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP257F-DK Discovery Board";
+	compatible = "st,stm32mp257f-dk", "st,stm32mp257";
+
+	aliases {
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x80000000 0x80000000>;
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp257f-ev.dts b/arch/arm64/boot/dts/st/stm32mp257f-ev.dts
new file mode 100644
index 000000000..b9d57a4ee
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp257f-ev.dts
@@ -0,0 +1,29 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp257.dtsi"
+#include "stm32mp25xf.dtsi"
+#include "stm32mp25-pinctrl.dtsi"
+#include "stm32mp25xxai-pinctrl.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP257F-EV Evaluation Board";
+	compatible = "st,stm32mp257f-ev", "st,stm32mp257";
+
+	aliases {
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x80000000 0x80000000>;
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp257f-valid3-ca35tdcid-resmem.dtsi b/arch/arm64/boot/dts/st/stm32mp257f-valid3-ca35tdcid-resmem.dtsi
new file mode 100644
index 000000000..c9259e4b4
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp257f-valid3-ca35tdcid-resmem.dtsi
@@ -0,0 +1,193 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ */
+
+/*
+ * STM32MP25 reserved memory device tree configuration
+ * Project : valid3-bu
+ * Generated by XLmx tool version 2.2 - 8/23/2022 3:30:11 PM
+ */
+
+/ {
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		/* Internal RAM reserved memory declaration */
+		sysram1: sysram1@a000000 {
+			compatible = "shared-dma-pool";
+			reg = <0xa000000 0x20000>;
+			no-map;
+		};
+
+		sysram2: sysram2@a020000 {
+			compatible = "shared-dma-pool";
+			reg = <0xa020000 0x1f000>;
+			no-map;
+		};
+
+		scmi_mailbox: scmi-mailbox@a03f000 {
+			compatible = "shared-dma-pool";
+			reg = <0xa03f000 0x1000>;
+			no-map;
+		};
+
+		bsec_mirror: bsec-mirror@a040000 {
+			compatible = "shared-dma-pool";
+			reg = <0xa040000 0x1000>;
+			no-map;
+		};
+
+		mcuram1: mcuram1@a041000 {
+			compatible = "shared-dma-pool";
+			reg = <0xa041000 0x1f000>;
+			no-map;
+		};
+
+		mcuram2: mcuram2@a060000 {
+			compatible = "shared-dma-pool";
+			reg = <0xa060000 0x20000>;
+			no-map;
+		};
+
+		retram: retram@a080000 {
+			compatible = "shared-dma-pool";
+			reg = <0xa080000 0x20000>;
+			no-map;
+		};
+
+		vderam: vderam@a0a0000 {
+			compatible = "shared-dma-pool";
+			reg = <0xa0a0000 0x20000>;
+			no-map;
+		};
+
+		/* PCIe reserved memory declaration */
+		pcie_device: pcie-device@10000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10000000 0x10000000>;
+			no-map;
+		};
+
+		/* Backup RAM reserved memory declaration */
+		bkpspram1: bkpspram1@42000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x42000000 0x2000>;
+			no-map;
+		};
+
+		/* DDR reserved memory declaration */
+		tfm_code: tfm-code@80000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x80000000 0x100000>;
+			no-map;
+		};
+
+		cm33_cube_fw: cm33-cube-fw@80100000 {
+			compatible = "shared-dma-pool";
+			reg = <0x80100000 0x800000>;
+			no-map;
+		};
+
+		tfm_data: tfm-data@80900000 {
+			compatible = "shared-dma-pool";
+			reg = <0x80900000 0x100000>;
+			no-map;
+		};
+
+		cm33_cube_data: cm33-cube-data@80a00000 {
+			compatible = "shared-dma-pool";
+			reg = <0x80a00000 0x800000>;
+			no-map;
+		};
+
+		ipc_shmem_1: ipc-shmem-1@81200000 {
+			compatible = "shared-dma-pool";
+			reg = <0x81200000 0xf8000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@812f8000 {
+			compatible = "shared-dma-pool";
+			reg = <0x812f8000 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@812f9000 {
+			compatible = "shared-dma-pool";
+			reg = <0x812f9000 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@812fa000 {
+			compatible = "shared-dma-pool";
+			reg = <0x812fa000 0x6000>;
+			no-map;
+		};
+
+		spare1: spare1@81300000 {
+			compatible = "shared-dma-pool";
+			reg = <0x81300000 0xd00000>;
+			no-map;
+		};
+
+		op_tee: op-tee@82000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x82000000 0x2000000>;
+			no-map;
+		};
+
+		ddr_test2: ddr-test2@f9700000 {
+			compatible = "shared-dma-pool";
+			reg = <0xf9700000 0x100000>;
+			no-map;
+		};
+
+		gpu_reserved: gpu-reserved@f9800000 {
+			compatible = "shared-dma-pool";
+			reg = <0xf9800000 0x4000000>;
+			no-map;
+		};
+
+		pcie_reserved: pcie-reserved@fd800000 {
+			compatible = "shared-dma-pool";
+			reg = <0xfd800000 0x800000>;
+			no-map;
+		};
+
+		vdec_reserved: vdec-reserved@fe000000 {
+			compatible = "shared-dma-pool";
+			reg = <0xfe000000 0x800000>;
+			no-map;
+		};
+
+		venc_reserved: venc-reserved@fe800000 {
+			compatible = "shared-dma-pool";
+			reg = <0xfe800000 0x800000>;
+			no-map;
+		};
+
+		ltdc_sec_layer: ltdc-sec-layer@ff000000 {
+			compatible = "shared-dma-pool";
+			reg = <0xff000000 0x800000>;
+			no-map;
+		};
+
+		ltdc_sec_rotation: ltdc-sec-rotation@ff800000 {
+			compatible = "shared-dma-pool";
+			reg = <0xff800000 0x800000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x8000000>;
+			alignment = <0x2000>;
+			linux,cma-default;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp257f-valid3-daughter.dts b/arch/arm64/boot/dts/st/stm32mp257f-valid3-daughter.dts
new file mode 100644
index 000000000..4a7834c3b
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp257f-valid3-daughter.dts
@@ -0,0 +1,303 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/soc/stm32mp25-hdp.h>
+#include "stm32mp257.dtsi"
+#include "stm32mp25xf.dtsi"
+#include "stm32mp25-pinctrl-test.dtsi"
+#include "stm32mp25xxai-pinctrl.dtsi"
+#include "stm32mp257f-valid3-ca35tdcid-resmem.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP257F VALID3 DAUGHTER / MB1706 (DDR4 Power discrete)";
+	compatible = "st,stm32mp257f-valid3-daughter", "st,stm32mp257";
+
+	aliases {
+		serial0 = &usart2;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	clocks {
+		pad_clk: pad-clk {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <100000000>;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		user-2 {
+			label = "User-2";
+			linux,code = <BTN_2>;
+			gpios = <&gpiod 14 GPIO_ACTIVE_HIGH>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		led-blue {
+			function = LED_FUNCTION_HEARTBEAT;
+			color = <LED_COLOR_ID_BLUE>;
+			gpios = <&gpioi 4 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x80000000 0x80000000>;
+	};
+
+	reserved-memory {
+		vdev0vring0: vdev0vring0@812f8000 {
+			compatible = "shared-dma-pool";
+			reg = <0x812f8000 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@812f9000 {
+			compatible = "shared-dma-pool";
+			reg = <0x812f9000 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@812fa000 {
+			compatible = "shared-dma-pool";
+			reg = <0x812fa000 0x6000>;
+			no-map;
+		};
+	};
+
+	v1v8: v1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "v1v8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-always-on;
+	};
+
+	v2v8: v2v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "v2v8";
+		regulator-min-microvolt = <2800000>;
+		regulator-max-microvolt = <2800000>;
+		regulator-always-on;
+	};
+
+	v3v3: v3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "v3v3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+	};
+
+	vdd: vdd {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+	};
+
+	vddcore: vddcore {
+		compatible = "regulator-fixed";
+		regulator-name = "vddcore";
+		regulator-min-microvolt = <820000>;
+		regulator-max-microvolt = <820000>;
+		regulator-always-on;
+	};
+};
+
+&adc_3 {
+	vdda-supply = <&scmi_vdda18adc>;
+	vref-supply = <&scmi_vdda18adc>;
+	status = "disabled";
+
+	adc3: adc@0 {
+		status = "okay";
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
+	};
+};
+
+&combophy {
+	clocks = <&rcc CK_BUS_USB3PCIEPHY>, <&pad_clk>;
+	clock-names = "apb-clk", "pad-clk";
+};
+
+&ddrperfm {
+	status = "okay";
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+	status = "okay";
+};
+
+&hdp {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&hdp0_pins_a &hdp6_pins_a &hdp7_pins_a>;
+	pinctrl-1 = <&hdp0_pins_sleep_a &hdp6_pins_sleep_a &hdp7_pins_sleep_a>;
+	status = "disabled";
+
+	muxing-hdp = <(STM32_HDP(0, HDP0_GPOVAL_0) |
+		       STM32_HDP(6, HDP6_GPOVAL_6) |
+		       STM32_HDP(7, HDP7_GPOVAL_7))>;
+};
+
+&i2c2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c2_test_pins_a>;
+	pinctrl-1 = <&i2c2_test_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <100000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+};
+
+&i2c8 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c8_test_pins_a>;
+	pinctrl-1 = <&i2c8_test_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <100000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+};
+
+&ipcc1 {
+	status = "okay";
+};
+
+&iwdg1 {
+	timeout-sec = <32>;
+	status = "disabled";
+};
+
+&m33_rproc {
+	mboxes = <&ipcc1 0>, <&ipcc1 1>, <&ipcc1 2>;
+	mbox-names = "vq0", "vq1", "shutdown";
+	memory-region = <&ipc_shmem_1>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>;
+	status = "okay";
+};
+
+&pcie_rc {
+	pinctrl-names = "default", "init";
+	pinctrl-0 = <&pcie_pins_a>;
+	pinctrl-1 = <&pcie_init_pins_a>;
+	max-link-speed = <1>;
+	max-payload-size = <128>;
+	max-readreq-size = <128>;
+};
+
+&scmi_regu {
+	scmi_vddio1: voltd-vddio1 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+	scmi_vdd_sdcard: voltd-vdd-sdcard {
+		voltd-name = "vdd_sdcard";
+		regulator-name = "vdd_sdcard";
+	};
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_test_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_test_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_test_sleep_pins_a>;
+	cd-gpios = <&gpiok 5 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&scmi_vdd_sdcard>;
+	vqmmc-supply = <&scmi_vddio1>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	sd-uhs-sdr104;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_test_pins_a &sdmmc2_d47_test_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_test_pins_a &sdmmc2_d47_test_pins_a>;
+	pinctrl-2 = <&sdmmc2_test_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&v3v3>;
+	vqmmc-supply = <&scmi_vddio2>;
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	status = "okay";
+};
+
+&usart2 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&usart2_test_pins_a>;
+	pinctrl-1 = <&usart2_test_idle_pins_a>;
+	pinctrl-2 = <&usart2_test_sleep_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usb2_phy1 {
+	status = "okay";
+};
+
+&usb2_phy2 {
+	status = "okay";
+};
+
+&usb2h {
+	status = "okay";
+
+	usb2h_ohci: usb@482e0000 {
+		status = "disabled";
+	};
+};
+
+&usb3drd {
+	status = "okay";
+
+	dwc3: usb@48300000 {
+		maximum-speed = "high-speed";
+		dr_mode = "peripheral";
+		snps,incr-burst-type-adjustment = <4>;
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp257f-valid3.dts b/arch/arm64/boot/dts/st/stm32mp257f-valid3.dts
new file mode 100644
index 000000000..cf1e6e129
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp257f-valid3.dts
@@ -0,0 +1,485 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp257f-valid3-daughter.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP257F VALID3 / MB1706 (DDR4 Power discrete) + MB1703";
+	compatible = "st,stm32mp257f-valid3", "st,stm32mp257";
+
+	aliases {
+		ethernet0 = &eth2;
+		ethernet1 = &eth1;
+		serial1 = &usart6;
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+	};
+
+	lvds_panel_4dl: lvds-panel-etml0700z8dha {
+		compatible = "edt,etml0700z8dha", "panel-lvds";
+		enable-gpios = <&gpioi 9 GPIO_ACTIVE_HIGH>;
+		backlight = <&panel_backlight>;
+		status = "okay";
+
+		width-mm = <156>;
+		height-mm = <88>;
+		data-mapping = "vesa-24";
+
+		panel-timing {
+			clock-frequency = <148437500>;
+			hactive = <1920>;
+			vactive = <1080>;
+			hsync-len = <20>;
+			hfront-porch = <130>;
+			hback-porch = <130>;
+			vfront-porch = <5>;
+			vback-porch = <20>;
+			vsync-len = <20>;
+		};
+
+		port {
+			lvds_panel_4dl_in: endpoint {
+				remote-endpoint = <&lvds_out0>;
+			};
+		};
+	};
+
+	ov5640_2v8: ov5640-2v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "camera_vana";
+		regulator-min-microvolt = <2800000>;
+		regulator-max-microvolt = <2800000>;
+		regulator-always-on;
+	};
+
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpiod 13 GPIO_ACTIVE_LOW>;
+		default-on;
+		default-brightness-level = <0>;
+		status = "okay";
+	};
+
+	sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP25-VALID3";
+		routing =
+			"AIF1CLK" , "MCLK1",
+			"AIF2CLK" , "MCLK1",
+			"IN1LN" , "MICBIAS2",
+			"DMIC2DAT" , "MICBIAS1",
+			"DMIC1DAT" , "MICBIAS1";
+		dais = <&sai2a_port &sai2b_port &sai4a_port &spdifrx_port>;
+	};
+
+	spdif_in: spdif-in {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dir";
+
+		spdif_in_port: port {
+			spdif_in_endpoint: endpoint {
+				remote-endpoint = <&spdifrx_endpoint>;
+			};
+		};
+	};
+
+	spdif_out: spdif-out {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dit";
+
+		spdif_out_port: port {
+			spdif_out_endpoint: endpoint {
+				remote-endpoint = <&sai4a_endpoint>;
+			};
+		};
+	};
+};
+
+&combophy {
+	status = "okay";
+};
+
+&csi2host {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			csi2host_sink: endpoint {
+				remote-endpoint = <&ov5640_0>;
+				data-lanes = <0 1>;
+				bus-type = <4>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			csi2host_source: endpoint {
+				remote-endpoint = <&dcmipp_0>;
+			};
+		};
+	};
+};
+
+&dcmipp {
+	status = "okay";
+
+	port {
+		dcmipp_0: endpoint {
+			remote-endpoint = <&csi2host_source>;
+			bus-type = <4>;
+		};
+	};
+};
+
+&dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "disabled";
+
+	ports {
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out1: endpoint {
+				remote-endpoint = <&panel_in_dsi>;
+			};
+		};
+	};
+
+	panel_dsi: panel-dsi@0 {
+		compatible = "raydium,rm68200";
+		reg = <0>;
+		reset-gpios = <&gpiod 12 GPIO_ACTIVE_LOW>;
+		power-supply = <&v3v3>;
+		backlight = <&panel_backlight>;
+		status = "disabled";
+
+		port {
+			panel_in_dsi: endpoint {
+				remote-endpoint = <&dsi_out1>;
+			};
+		};
+	};
+};
+
+&eth1 {
+	status = "okay";
+	pinctrl-0 = <&eth1_mdio_test_pins_b>;
+	pinctrl-names = "default";
+	phy-mode = "rgmii";
+	max-speed = <1000>;
+	st,eth-clk-sel;
+
+	fixed_link: fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+
+		phy1_eth1: ethernet-phy@5 {
+			compatible = "ethernet-phy-id001c.c916",
+				     "ethernet-phy-ieee802.3-c22";
+			reset-gpios =  <&gpioj 9 GPIO_ACTIVE_LOW>;
+			reset-assert-us = <10000>;
+			reset-deassert-us = <300>;
+			realtek,eee-disable;
+			reg = <5>;
+		};
+
+		phy2_eth1: ethernet-phy@4 {
+			compatible = "ethernet-phy-id001c.c916",
+				     "ethernet-phy-ieee802.3-c22";
+			realtek,eee-disable;
+			reg = <4>;
+		};
+	};
+};
+
+&eth2 {
+	status = "okay";
+	pinctrl-0 = <&eth2_rgmii_test_pins_b>;
+	pinctrl-names = "default";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy1_eth2>;
+	st,eth-ptp-from-rcc;
+	st,eth-clk-sel;
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy1_eth2: ethernet-phy@1 {
+			compatible = "ethernet-phy-id001c.c916";
+			realtek,eee-disable;
+			reg = <1>;
+		};
+	};
+};
+
+&hpdma {
+	st,burstlen = <32>;
+};
+
+&hpdma2 {
+	st,burstlen = <32>;
+};
+
+&hpdma3 {
+	st,burstlen = <32>;
+};
+
+&i2c2 {
+	wm8994: wm8994@1b {
+		compatible = "wlf,wm8994";
+		#sound-dai-cells = <0>;
+		reg = <0x1b>;
+		status = "okay";
+
+		gpio-controller;
+		#gpio-cells = <2>;
+
+		DBVDD-supply = <&vdd>;
+		SPKVDD1-supply = <&vdd>;
+		SPKVDD2-supply = <&vdd>;
+		AVDD2-supply = <&v1v8>;
+		CPVDD-supply = <&v1v8>;
+
+		wlf,ldoena-always-driven;
+
+		clocks = <&sai2a>;
+		clock-names = "MCLK1";
+
+		wlf,gpio-cfg = <0x8101 0xa100 0xa100 0xa100 0xa101 0xa101\
+						0xa100 0xa101 0xa101 0xa101 0xa101>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			wm8994_tx_port: port@0 {
+				reg = <0>;
+				wm8994_tx_endpoint: endpoint {
+					remote-endpoint = <&sai2a_endpoint>;
+				};
+			};
+
+			wm8994_rx_port: port@1 {
+				reg = <1>;
+				wm8994_rx_endpoint: endpoint {
+					remote-endpoint = <&sai2b_endpoint>;
+				};
+			};
+		};
+	};
+
+	ov5640: camera@3c {
+		compatible = "ovti,ov5640";
+		reg = <0x3c>;
+		clocks = <&clk_ext_camera>;
+		clock-names = "xclk";
+		DOVDD-supply = <&ov5640_2v8>;
+		reset-gpios = <&gpioi 3 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		powerdown-gpios = <&gpioi 2 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		rotation = <180>;
+		status = "okay";
+
+		port {
+			ov5640_0: endpoint {
+				remote-endpoint = <&csi2host_sink>;
+				data-lanes = <0 1>;
+				link-frequencies = /bits/ 64 <456000000>;
+			};
+		};
+	};
+
+	ili2511: ili2511@41 {
+		compatible = "ilitek,ili251x";
+		reg = <0x41>;
+		interrupt-parent = <&gpioi>;
+		interrupts = <11 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpiod 12 GPIO_ACTIVE_LOW>;
+		status = "okay";
+	};
+};
+
+&ltdc {
+	status = "okay";
+	st,burstlen = <32>;
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ltdc_ep0_out: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&dsi_in>;
+		};
+
+		ltdc_ep1_out: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&lvds_in>;
+		};
+	};
+};
+
+&lvds {
+	status = "okay";
+
+	ports {
+		/* Do not forget to update lvds_out0/1 endpoints
+		 * and panel endpoint accordingly
+		 * when enabling or disabling a panel.
+		 * Dual link panel needs an additional port@2.
+		 */
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			lvds_in: endpoint {
+				remote-endpoint = <&ltdc_ep1_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			lvds_out0: endpoint {
+				remote-endpoint = <&lvds_panel_4dl_in>;
+			};
+		};
+	};
+};
+
+&pcie_rc {
+	reset-gpios = <&gpioj 8 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&sai2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sai2a_test_pins_a>, <&sai2b_test_pins_a>;
+	pinctrl-1 = <&sai2a_test_sleep_pins_a>, <&sai2b_test_sleep_pins_a>;
+	status = "okay";
+
+	sai2a: audio-controller@402a0004 {
+		#clock-cells = <0>;
+		dma-names = "tx";
+		status = "okay";
+
+		sai2a_port: port {
+			sai2a_endpoint: endpoint {
+				remote-endpoint = <&wm8994_tx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+
+	sai2b: audio-controller@402a0024 {
+		dma-names = "rx";
+		clocks = <&rcc CK_KER_SAI2>, <&sai2a>;
+		clock-names = "sai_ck", "MCLK";
+		status = "okay";
+
+		sai2b_port: port {
+			sai2b_endpoint: endpoint {
+				remote-endpoint = <&wm8994_rx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+};
+
+&sai4 {
+	status = "okay";
+
+	sai4a: audio-controller@40340004 {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&sai4a_test_pins_a>;
+		pinctrl-1 = <&sai4a_test_sleep_pins_a>;
+		dma-names = "tx";
+		st,iec60958;
+		status = "okay";
+
+		sai4a_port: port {
+			sai4a_endpoint: endpoint {
+				remote-endpoint = <&spdif_out_endpoint>;
+			};
+		};
+	};
+};
+
+&spdifrx {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spdifrx_test_pins_a>;
+	pinctrl-1 = <&spdifrx_test_sleep_pins_a>;
+	status = "okay";
+
+	spdifrx_port: port {
+		spdifrx_endpoint: endpoint {
+			remote-endpoint = <&spdif_in_endpoint>;
+		};
+	};
+};
+
+&spi8 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi8_test_pins_a>;
+	pinctrl-1 = <&spi8_test_sleep_pins_a>;
+	status = "disabled";
+};
+
+&switch0 {
+	status = "okay";
+	pinctrl-0 = <&eth1_rgmii_test_pins_b>, <&eth3_rgmii_test_pins_a>;
+	pinctrl-names = "default";
+	phy-mode = "rgmii";
+	st,ethsw-internal-125;
+};
+
+&usart6 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&usart6_test_pins_a>;
+	pinctrl-1 = <&usart6_test_idle_pins_a>;
+	pinctrl-2 = <&usart6_test_sleep_pins_a>;
+	/delete-property/dma-names;
+	/delete-property/dmas;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&vdec {
+	maxburstlen = <24>;
+	status = "okay";
+};
+
+&venc {
+	maxburstlen = <24>;
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp25xc.dtsi b/arch/arm64/boot/dts/st/stm32mp25xc.dtsi
new file mode 100644
index 000000000..8a83e3235
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp25xc.dtsi
@@ -0,0 +1,8 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/ {
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp25xf.dtsi b/arch/arm64/boot/dts/st/stm32mp25xf.dtsi
new file mode 100644
index 000000000..8a83e3235
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp25xf.dtsi
@@ -0,0 +1,8 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/ {
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp25xxai-pinctrl.dtsi b/arch/arm64/boot/dts/st/stm32mp25xxai-pinctrl.dtsi
new file mode 100644
index 000000000..9e9a2ca0c
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp25xxai-pinctrl.dtsi
@@ -0,0 +1,83 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	st,package = <STM32MP_PKG_AI>;
+
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 2 114 12>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 128 16>;
+	};
+
+	gpioj: gpio@442d0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 144 16>;
+	};
+
+	gpiok: gpio@442e0000 {
+		status = "okay";
+		ngpios = <8>;
+		gpio-ranges = <&pinctrl 0 160 8>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <10>;
+		gpio-ranges = <&pinctrl_z 0 400 10>;
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp25xxak-pinctrl.dtsi b/arch/arm64/boot/dts/st/stm32mp25xxak-pinctrl.dtsi
new file mode 100644
index 000000000..905b90818
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp25xxak-pinctrl.dtsi
@@ -0,0 +1,71 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	st,package = <STM32MP_PKG_AK>;
+
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 2 114 12>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 0 128 12>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <10>;
+		gpio-ranges = <&pinctrl_z 0 400 10>;
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp25xxal-pinctrl.dtsi b/arch/arm64/boot/dts/st/stm32mp25xxal-pinctrl.dtsi
new file mode 100644
index 000000000..e08c8909f
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp25xxal-pinctrl.dtsi
@@ -0,0 +1,71 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	st,package = <STM32MP_PKG_AL>;
+
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 2 114 12>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 0 128 12>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <10>;
+		gpio-ranges = <&pinctrl_z 0 400 10>;
+	};
+};
diff --git a/arch/arm64/configs/fragment-01-defconfig-cleanup.config b/arch/arm64/configs/fragment-01-defconfig-cleanup.config
new file mode 100644
index 000000000..cbeb870d6
--- /dev/null
+++ b/arch/arm64/configs/fragment-01-defconfig-cleanup.config
@@ -0,0 +1,39 @@
+#
+# Platform selection
+#
+# CONFIG_ARCH_ACTIONS is not set
+# CONFIG_ARCH_AGILEX is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_ALPINE is not set
+# CONFIG_ARCH_BCM2835 is not set
+# CONFIG_ARCH_BCM_IPROC is not set
+# CONFIG_ARCH_BERLIN is not set
+# CONFIG_ARCH_BRCMSTB is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_K3 is not set
+# CONFIG_ARCH_LAYERSCAPE is not set
+# CONFIG_ARCH_LG1K is not set
+# CONFIG_ARCH_HISI is not set
+# CONFIG_ARCH_MEDIATEK is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_QCOM is not set
+# CONFIG_ARCH_RENESAS is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_ARCH_S32 is not set
+# CONFIG_ARCH_SEATTLE is not set
+# CONFIG_ARCH_STRATIX10 is not set
+# CONFIG_ARCH_SYNQUACER is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_SPRD is not set
+# CONFIG_ARCH_THUNDER is not set
+# CONFIG_ARCH_THUNDER2 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_VISCONTI is not set
+# CONFIG_ARCH_XGENE is not set
+# CONFIG_ARCH_ZX is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_MTD_PHYSMAP is not set
diff --git a/arch/arm64/configs/fragment-02-defconfig-addons.config b/arch/arm64/configs/fragment-02-defconfig-addons.config
new file mode 100644
index 000000000..14235dfe3
--- /dev/null
+++ b/arch/arm64/configs/fragment-02-defconfig-addons.config
@@ -0,0 +1,89 @@
+CONFIG_ARCH_STM32=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_GDB_SCRIPTS=y
+CONFIG_MTD_HYPERBUS=y
+CONFIG_MTD_NAND_STM32_FMC2=y
+CONFIG_MTD_SPI_NAND=y
+CONFIG_MTD_UBI=y
+CONFIG_I2C_STM32F7=y
+CONFIG_REGULATOR_ARM_SCMI=y
+CONFIG_SERIAL_STM32=y
+CONFIG_SERIAL_STM32_CONSOLE=y
+CONFIG_SPI_STM32=m
+CONFIG_SPI_STM32_OSPI=y
+CONFIG_STM32_DMA3=y
+CONFIG_STM32_FMC2_EBI=y
+CONFIG_STM32_HYPERBUS=y
+CONFIG_STM32_IPCC=y
+CONFIG_STM32_RPROC=y
+CONFIG_RPMSG_TTY=y
+CONFIG_RPMSG_VIRTIO=y
+CONFIG_STM32_OMI=y
+CONFIG_STM32_OMM=y
+# CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
+CONFIG_STMMAC_ETH=y
+# CONFIG_STMMAC_SELFTESTS is not set
+CONFIG_STMMAC_PLATFORM=y
+CONFIG_DWMAC_GENERIC=y
+CONFIG_DWMAC_STM32=y
+CONFIG_SENSORS_MR75203=y
+CONFIG_UBIFS_FS=y
+CONFIG_JFFS2_FS=y
+CONFIG_VIDEO_STM32_CSI2HOST=m
+CONFIG_VIDEO_STM32_DCMIPP=m
+CONFIG_VIDEO_OV5640=m
+# CONFIG_PCI_DEBUG is not set
+CONFIG_PCIE_STM32_HOST=y
+CONFIG_PHY_STM32_COMBOPHY=y
+CONFIG_PCI_DOMAINS_GENERIC=y
+CONFIG_PCI_MSI=y
+CONFIG_PCI_MSI_IRQ_DOMAIN=y
+CONFIG_USB_STM32_USB2H=y
+CONFIG_USB_DWC3_STM32=y
+CONFIG_PHY_STM32_USB2FEMTO=y
+CONFIG_ARM_SCMI_CPUFREQ=y
+CONFIG_VIDEO_HANTRO=m
+CONFIG_VIDEO_HANTRO_STM32MP25=y
+CONFIG_DRM_MIPI_DSI=y
+CONFIG_DRM_KMS_HELPER=y
+CONFIG_SND_SOC_STM32_SAI=m
+CONFIG_SND_SOC_STM32_I2S=m
+CONFIG_SND_SOC_STM32_SPDIFRX=m
+CONFIG_SND_SOC_WM8994=m
+CONFIG_MFD_WM8994=m
+CONFIG_NET_CLS_U32=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_MULTIQ=m
+CONFIG_NET_SCH_SKBPRIO=m
+CONFIG_NET_ACT_POLICE=m
+CONFIG_NET_ACT_SKBEDIT=m
+CONFIG_NET_ACT_VLAN=m
+# CONFIG_DRM_FBDEV_EMULATION is not set
+CONFIG_DRM=y
+CONFIG_DRM_SIMPLEDRM=y
+CONFIG_DRM_STM=y
+CONFIG_DRM_STM_DSI=y
+CONFIG_DRM_STM_LVDS=y
+CONFIG_DRM_PANEL=y
+CONFIG_DRM_PANEL_LVDS=y
+CONFIG_DRM_PANEL_SIMPLE=y
+CONFIG_DRM_PANEL_RAYDIUM_RM67191=y
+CONFIG_DRM_BRIDGE=y
+CONFIG_DRM_PANEL_BRIDGE=y
+CONFIG_DRM_DW_MIPI_DSI=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GPIO=y
+CONFIG_VIDEOMODE_HELPERS=y
+CONFIG_HDMI=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_GOODIX=y
+CONFIG_TOUCHSCREEN_ILI210X=y
+CONFIG_DRM_PANEL_RAYDIUM_RM68200=y
+CONFIG_NVMEM_STM32_ROMEM=y
+CONFIG_COUNTER=m
+CONFIG_MFD_STM32_LPTIMER=m
+CONFIG_STM32_LPTIMER_CNT=m
+CONFIG_IIO_STM32_LPTIMER_TRIGGER=m
+CONFIG_PWM_STM32_LP=m
+CONFIG_STM32_ADC=m
+CONFIG_STM32_ADC_CORE=m
diff --git a/drivers/char/hw_random/stm32-rng.c b/drivers/char/hw_random/stm32-rng.c
index bc22178f8..e0a8025b4 100644
--- a/drivers/char/hw_random/stm32-rng.c
+++ b/drivers/char/hw_random/stm32-rng.c
@@ -16,22 +16,36 @@
 #include <linux/reset.h>
 #include <linux/slab.h>
 
-#define RNG_CR 0x00
-#define RNG_CR_RNGEN BIT(2)
-#define RNG_CR_CED BIT(5)
+#define RNG_CR		0x00
+#define RNG_CR_RNGEN	BIT(2)
+#define RNG_CR_CED	BIT(5)
+#define RNG_CR_CONDRST	BIT(30)
+#define RNG_CR_CONFLOCK	BIT(31)
 
-#define RNG_SR 0x04
-#define RNG_SR_SEIS BIT(6)
-#define RNG_SR_CEIS BIT(5)
-#define RNG_SR_DRDY BIT(0)
+#define RNG_SR		0x04
+#define RNG_SR_SEIS	BIT(6)
+#define RNG_SR_CEIS	BIT(5)
+#define RNG_SR_DRDY	BIT(0)
 
-#define RNG_DR 0x08
+#define RNG_DR		0x08
+
+#define RNG_NIST_CONFIG_A	0x0F00D00
+#define RNG_NIST_CONFIG_B	0x1801000
+#define RNG_NIST_CONFIG_MASK	GENMASK(25, 8)
+
+#define RNG_MAX_NOISE_CLK_FREQ	3000000
+
+struct stm32_rng_data {
+	bool	has_cond_reset;
+};
 
 struct stm32_rng_private {
 	struct hwrng rng;
 	void __iomem *base;
 	struct clk *clk;
 	struct reset_control *rst;
+	const struct stm32_rng_data *data;
+	u32 pm_cr;
 	bool ced;
 };
 
@@ -79,39 +93,168 @@ static int stm32_rng_read(struct hwrng *rng, void *data, size_t max, bool wait)
 	return retval || !wait ? retval : -EIO;
 }
 
+static uint stm32_rng_clock_freq_restrain(struct hwrng *rng)
+{
+	struct stm32_rng_private *priv =
+	    container_of(rng, struct stm32_rng_private, rng);
+	unsigned long clock_rate = 0;
+	uint clock_div = 0;
+
+	clock_rate = clk_get_rate(priv->clk);
+
+	/*
+	 * Get the exponent to apply on the CLKDIV field in RNG_CR register
+	 * No need to handle the case when clock-div > 0xF as it is physically
+	 * impossible
+	 */
+	while ((clock_rate >> clock_div) > RNG_MAX_NOISE_CLK_FREQ)
+		clock_div++;
+
+	pr_debug("RNG clk rate : %lu\n", clk_get_rate(priv->clk) >> clock_div);
+
+	return clock_div;
+}
+
 static int stm32_rng_init(struct hwrng *rng)
 {
 	struct stm32_rng_private *priv =
 	    container_of(rng, struct stm32_rng_private, rng);
 	int err;
+	u32 reg;
 
 	err = clk_prepare_enable(priv->clk);
 	if (err)
 		return err;
 
-	if (priv->ced)
-		writel_relaxed(RNG_CR_RNGEN, priv->base + RNG_CR);
-	else
-		writel_relaxed(RNG_CR_RNGEN | RNG_CR_CED,
-			       priv->base + RNG_CR);
+	reg = readl_relaxed(priv->base + RNG_CR);
+
+	if (!priv->ced)
+		reg |= RNG_CR_CED;
+
+	if (priv->data->has_cond_reset) {
+		uint clock_div = stm32_rng_clock_freq_restrain(rng);
+
+		reg &= ~RNG_NIST_CONFIG_MASK;
+		reg |= RNG_CR_CONDRST | RNG_NIST_CONFIG_B | clock_div;
+		writel_relaxed(reg, priv->base + RNG_CR);
+		reg &= ~RNG_CR_CONDRST;
+		reg |= RNG_CR_CONFLOCK;
+		writel_relaxed(reg, priv->base + RNG_CR);
+		err = readl_relaxed_poll_timeout_atomic(priv->base + RNG_CR, reg,
+							(!(reg & RNG_CR_CONDRST)),
+							10, 50000);
+		if (err) {
+			dev_err((struct device *)priv->rng.priv,
+				"%s: timeout %x!\n", __func__, reg);
+			return -EINVAL;
+		}
+	}
 
 	/* clear error indicators */
 	writel_relaxed(0, priv->base + RNG_SR);
 
+	reg |= RNG_CR_RNGEN;
+	writel_relaxed(reg, priv->base + RNG_CR);
+
+	err = readl_relaxed_poll_timeout_atomic(priv->base + RNG_SR, reg,
+						reg & RNG_SR_DRDY,
+						10, 100000);
+	if (err | (reg & ~RNG_SR_DRDY)) {
+		clk_disable_unprepare(priv->clk);
+		dev_err((struct device *)priv->rng.priv,
+			"%s: timeout:%x SR: %x!\n", __func__, err, reg);
+		return -EINVAL;
+	}
+
 	return 0;
 }
 
-static void stm32_rng_cleanup(struct hwrng *rng)
+static int stm32_rng_remove(struct platform_device *ofdev)
 {
-	struct stm32_rng_private *priv =
-	    container_of(rng, struct stm32_rng_private, rng);
+	pm_runtime_disable(&ofdev->dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int stm32_rng_runtime_suspend(struct device *dev)
+{
+	u32 reg;
+	struct stm32_rng_private *priv = dev_get_drvdata(dev);
 
-	writel_relaxed(0, priv->base + RNG_CR);
+	reg = readl_relaxed(priv->base + RNG_CR);
+	reg &= ~RNG_CR_RNGEN;
+	priv->pm_cr = reg;
+	writel_relaxed(reg, priv->base + RNG_CR);
 	clk_disable_unprepare(priv->clk);
+
+	return 0;
 }
 
+static int stm32_rng_runtime_resume(struct device *dev)
+{
+	u32 reg;
+	struct stm32_rng_private *priv = dev_get_drvdata(dev);
+
+	clk_prepare_enable(priv->clk);
+
+	/* Clean error indications */
+	writel_relaxed(0, priv->base + RNG_SR);
+
+	if (priv->data->has_cond_reset) {
+		/*
+		 * Correct configuration in bits [29:4] must be set in the same
+		 * access that set RNG_CR_CONDRST bit. Else config setting is
+		 * not taken into account. CONFIGLOCK bit must also be unset but
+		 * it is not handled at the moment.
+		 */
+		writel_relaxed(priv->pm_cr | RNG_CR_CONDRST, priv->base + RNG_CR);
+
+		reg = readl_relaxed(priv->base + RNG_CR);
+		reg |= RNG_CR_RNGEN;
+		reg &= ~RNG_CR_CONDRST;
+		writel_relaxed(reg, priv->base + RNG_CR);
+	} else {
+		reg = readl_relaxed(priv->base + RNG_CR);
+		reg |= RNG_CR_RNGEN;
+		writel_relaxed(reg, priv->base + RNG_CR);
+	}
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops stm32_rng_pm_ops = {
+	SET_RUNTIME_PM_OPS(stm32_rng_runtime_suspend,
+			   stm32_rng_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+};
+
+static const struct stm32_rng_data stm32mp13_rng_data = {
+	.has_cond_reset = true,
+};
+
+static const struct stm32_rng_data stm32_rng_data = {
+	.has_cond_reset = false,
+};
+
+static const struct of_device_id stm32_rng_match[] = {
+	{
+		.compatible = "st,stm32mp13-rng",
+		.data = &stm32mp13_rng_data,
+	},
+	{
+		.compatible = "st,stm32-rng",
+		.data = &stm32_rng_data,
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, stm32_rng_match);
+
 static int stm32_rng_probe(struct platform_device *ofdev)
 {
+	const struct of_device_id *match;
 	struct device *dev = &ofdev->dev;
 	struct device_node *np = ofdev->dev.of_node;
 	struct stm32_rng_private *priv;
@@ -143,13 +286,18 @@ static int stm32_rng_probe(struct platform_device *ofdev)
 
 	priv->ced = of_property_read_bool(np, "clock-error-detect");
 
+	match = of_match_device(of_match_ptr(stm32_rng_match), dev);
+	if (!match) {
+		dev_err(dev, "no compatible OF match\n");
+		return -EINVAL;
+	}
+
+	priv->data = match->data;
+
 	dev_set_drvdata(dev, priv);
 
 	priv->rng.name = dev_driver_string(dev);
-#ifndef CONFIG_PM
 	priv->rng.init = stm32_rng_init;
-	priv->rng.cleanup = stm32_rng_cleanup;
-#endif
 	priv->rng.read = stm32_rng_read;
 	priv->rng.priv = (unsigned long) dev;
 	priv->rng.quality = 900;
@@ -161,47 +309,6 @@ static int stm32_rng_probe(struct platform_device *ofdev)
 	return devm_hwrng_register(dev, &priv->rng);
 }
 
-static int stm32_rng_remove(struct platform_device *ofdev)
-{
-	pm_runtime_disable(&ofdev->dev);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int stm32_rng_runtime_suspend(struct device *dev)
-{
-	struct stm32_rng_private *priv = dev_get_drvdata(dev);
-
-	stm32_rng_cleanup(&priv->rng);
-
-	return 0;
-}
-
-static int stm32_rng_runtime_resume(struct device *dev)
-{
-	struct stm32_rng_private *priv = dev_get_drvdata(dev);
-
-	return stm32_rng_init(&priv->rng);
-}
-#endif
-
-static const struct dev_pm_ops stm32_rng_pm_ops = {
-	SET_RUNTIME_PM_OPS(stm32_rng_runtime_suspend,
-			   stm32_rng_runtime_resume, NULL)
-	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
-				pm_runtime_force_resume)
-};
-
-
-static const struct of_device_id stm32_rng_match[] = {
-	{
-		.compatible = "st,stm32-rng",
-	},
-	{},
-};
-MODULE_DEVICE_TABLE(of, stm32_rng_match);
-
 static struct platform_driver stm32_rng_driver = {
 	.driver = {
 		.name = "stm32-rng",
diff --git a/drivers/clk/Kconfig b/drivers/clk/Kconfig
index c5b3dc973..664782314 100644
--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -334,6 +334,11 @@ config COMMON_CLK_VC5
 	  This driver supports the IDT VersaClock 5 and VersaClock 6
 	  programmable clock generators.
 
+config COMMON_CLK_STM32MP135
+	def_bool COMMON_CLK && MACH_STM32MP13
+	help
+	  Support for stm32mp135 SoC family clocks
+
 config COMMON_CLK_STM32MP157
 	def_bool COMMON_CLK && MACH_STM32MP157
 	help
@@ -349,6 +354,11 @@ config COMMON_CLK_STM32MP157_SCMI
 	  Support for stm32mp157 SoC family clocks with Trusted Firmware using
 	  SCMI protocol.
 
+config COMMON_CLK_STM32MP257
+	def_bool COMMON_CLK && MACH_STM32MP25
+	help
+	  Support for stm32mp25x SoC family clocks
+
 config COMMON_CLK_STM32F
 	def_bool COMMON_CLK && (MACH_STM32F429 || MACH_STM32F469 || MACH_STM32F746)
 	help
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index e42312121..6172bc25b 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -109,6 +109,7 @@ obj-y					+= socfpga/
 obj-$(CONFIG_PLAT_SPEAR)		+= spear/
 obj-y					+= sprd/
 obj-$(CONFIG_ARCH_STI)			+= st/
+obj-$(CONFIG_ARCH_STM32)		+= stm32/
 obj-$(CONFIG_ARCH_SUNXI)		+= sunxi/
 obj-$(CONFIG_SUNXI_CCU)			+= sunxi-ng/
 obj-$(CONFIG_ARCH_TEGRA)		+= tegra/
diff --git a/drivers/clk/clk-composite.c b/drivers/clk/clk-composite.c
index 510a99656..8fcbb34de 100644
--- a/drivers/clk/clk-composite.c
+++ b/drivers/clk/clk-composite.c
@@ -42,6 +42,18 @@ static unsigned long clk_composite_recalc_rate(struct clk_hw *hw,
 	return rate_ops->recalc_rate(rate_hw, parent_rate);
 }
 
+static int clk_composite_get_duty_cycle(struct clk_hw *hw,
+					struct clk_duty *duty)
+{
+	struct clk_composite *composite = to_clk_composite(hw);
+	const struct clk_ops *rate_ops = composite->rate_ops;
+	struct clk_hw *rate_hw = composite->rate_hw;
+
+	__clk_hw_set_clk(rate_hw, hw);
+
+	return rate_ops->get_duty_cycle(rate_hw, duty);
+}
+
 static int clk_composite_determine_rate(struct clk_hw *hw,
 					struct clk_rate_request *req)
 {
@@ -251,6 +263,9 @@ static struct clk_hw *__clk_hw_register_composite(struct device *dev,
 		}
 		clk_composite_ops->recalc_rate = clk_composite_recalc_rate;
 
+		if (rate_ops->get_duty_cycle)
+			clk_composite_ops->get_duty_cycle = clk_composite_get_duty_cycle;
+
 		if (rate_ops->determine_rate)
 			clk_composite_ops->determine_rate =
 				clk_composite_determine_rate;
diff --git a/drivers/clk/clk-scmi.c b/drivers/clk/clk-scmi.c
index 1e357d364..3e87eefa8 100644
--- a/drivers/clk/clk-scmi.c
+++ b/drivers/clk/clk-scmi.c
@@ -9,6 +9,7 @@
 #include <linux/device.h>
 #include <linux/err.h>
 #include <linux/of.h>
+#include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/scmi_protocol.h>
 #include <asm/div64.h>
@@ -37,6 +38,37 @@ static unsigned long scmi_clk_recalc_rate(struct clk_hw *hw,
 	return rate;
 }
 
+static unsigned long scmi_clk_round_rate_get(struct clk_hw *hw,
+					     unsigned long rate,
+					     unsigned long *parent_rate)
+{
+	int ret;
+	u64 round_rate = rate;
+	struct scmi_clk *clk = to_scmi_clk(hw);
+
+	ret = scmi_proto_clk_ops->round_rate_get(clk->ph, clk->id, &round_rate);
+	if (ret)
+		return 0;
+
+	return round_rate;
+}
+
+static int scmi_clk_get_duty_cycle(struct clk_hw *hw, struct clk_duty *duty)
+{
+	struct scmi_clk *clk = to_scmi_clk(hw);
+	int ret;
+
+	ret = scmi_proto_clk_ops->get_duty_cycle(clk->ph, clk->id,
+						 &duty->num, &duty->den);
+	if (ret) {
+		/* Assume a default value of 50% */
+		duty->num = 1;
+		duty->den = 2;
+	}
+
+	return 0;
+}
+
 static long scmi_clk_round_rate(struct clk_hw *hw, unsigned long rate,
 				unsigned long *parent_rate)
 {
@@ -59,6 +91,9 @@ static long scmi_clk_round_rate(struct clk_hw *hw, unsigned long rate,
 	else if (rate >= fmax)
 		return fmax;
 
+	if (clk->info->range.step_size == 0)
+		return scmi_clk_round_rate_get(hw, rate, parent_rate);
+
 	ftmp = rate - fmin;
 	ftmp += clk->info->range.step_size - 1; /* to round up */
 	do_div(ftmp, clk->info->range.step_size);
@@ -100,6 +135,7 @@ static const struct clk_ops scmi_clk_ops = {
 	 */
 	.prepare = scmi_clk_enable,
 	.unprepare = scmi_clk_disable,
+	.get_duty_cycle = scmi_clk_get_duty_cycle,
 };
 
 static int scmi_clk_ops_init(struct device *dev, struct scmi_clk *sclk)
diff --git a/drivers/clk/clk-stm32mp1.c b/drivers/clk/clk-stm32mp1.c
index 4bd1fe7d8..e50d27ccd 100644
--- a/drivers/clk/clk-stm32mp1.c
+++ b/drivers/clk/clk-stm32mp1.c
@@ -116,11 +116,11 @@ static const char * const ref3_parents[] = {
 };
 
 static const char * const ref4_parents[] = {
-	"ck_hsi", "ck_hse", "ck_csi"
+	"ck_hsi", "ck_hse", "ck_csi", "i2s_ckin"
 };
 
 static const char * const cpu_src[] = {
-	"ck_hsi", "ck_hse", "pll1_p"
+	"ck_hsi", "ck_hse", "pll1_p", "pll1_p_div"
 };
 
 static const char * const axi_src[] = {
@@ -294,6 +294,7 @@ static const struct clk_div_table ck_trace_div_table[] = {
 struct stm32_mmux {
 	u8 nbr_clk;
 	struct clk_hw *hws[MAX_MUX_CLK];
+	u8 saved_parent;
 };
 
 struct stm32_clk_mmux {
@@ -717,7 +718,7 @@ static int clk_mmux_set_parent(struct clk_hw *hw, u8 index)
 
 	for (n = 0; n < clk_mmux->mmux->nbr_clk; n++)
 		if (clk_mmux->mmux->hws[n] != hw)
-			clk_hw_reparent(clk_mmux->mmux->hws[n], hwp);
+			clk_hw_set_parent(clk_mmux->mmux->hws[n], hwp);
 
 	return 0;
 }
@@ -728,156 +729,212 @@ static const struct clk_ops clk_mmux_ops = {
 	.determine_rate	= __clk_mux_determine_rate,
 };
 
-/* STM32 PLL */
-struct stm32_pll_obj {
-	/* lock pll enable/disable registers */
-	spinlock_t *lock;
-	void __iomem *reg;
-	struct clk_hw hw;
-	struct clk_mux mux;
-};
+static bool is_all_clk_on_switch_are_off(struct clk_hw *hw)
+{
+	struct clk_composite *composite = to_clk_composite(hw);
+	struct clk_hw *mux_hw = composite->mux_hw;
+	struct clk_mux *mux = to_clk_mux(mux_hw);
+	struct stm32_clk_mmux *clk_mmux = to_clk_mmux(mux);
+	int i = 0;
 
-#define to_pll(_hw) container_of(_hw, struct stm32_pll_obj, hw)
+	for (i = 0; i < clk_mmux->mmux->nbr_clk; i++)
+		if (__clk_is_enabled(clk_mmux->mmux->hws[i]->clk))
+			return false;
 
-#define PLL_ON		BIT(0)
-#define PLL_RDY		BIT(1)
-#define DIVN_MASK	0x1FF
-#define DIVM_MASK	0x3F
-#define DIVM_SHIFT	16
-#define DIVN_SHIFT	0
-#define FRAC_OFFSET	0xC
-#define FRAC_MASK	0x1FFF
-#define FRAC_SHIFT	3
-#define FRACLE		BIT(16)
-#define PLL_MUX_SHIFT	0
-#define PLL_MUX_MASK	3
+	return true;
+}
 
-static int __pll_is_enabled(struct clk_hw *hw)
+#define MMUX_SAFE_POSITION 0
+
+static int clk_mmux_set_safe_position(struct clk_hw *hw)
 {
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
+	struct clk_composite *composite = to_clk_composite(hw);
+	struct clk_hw *mux_hw = composite->mux_hw;
+	struct clk_mux *mux = to_clk_mux(mux_hw);
+	struct stm32_clk_mmux *clk_mmux = to_clk_mmux(mux);
 
-	return readl_relaxed(clk_elem->reg) & PLL_ON;
-}
+	clk_mmux->mmux->saved_parent = clk_mmux_get_parent(mux_hw);
+	clk_mux_ops.set_parent(mux_hw, MMUX_SAFE_POSITION);
 
-#define TIMEOUT 5
+	return 0;
+}
 
-static int pll_enable(struct clk_hw *hw)
+static int clk_mmux_restore_parent(struct clk_hw *hw)
 {
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
-	u32 reg;
-	unsigned long flags = 0;
-	unsigned int timeout = TIMEOUT;
-	int bit_status = 0;
+	struct clk_composite *composite = to_clk_composite(hw);
+	struct clk_hw *mux_hw = composite->mux_hw;
+	struct clk_mux *mux = to_clk_mux(mux_hw);
+	struct stm32_clk_mmux *clk_mmux = to_clk_mmux(mux);
 
-	spin_lock_irqsave(clk_elem->lock, flags);
+	clk_mux_ops.set_parent(mux_hw, clk_mmux->mmux->saved_parent);
 
-	if (__pll_is_enabled(hw))
-		goto unlock;
+	return 0;
+}
 
-	reg = readl_relaxed(clk_elem->reg);
-	reg |= PLL_ON;
-	writel_relaxed(reg, clk_elem->reg);
+static u8 clk_mmux_get_parent_safe(struct clk_hw *hw)
+{
+	struct clk_mux *mux = to_clk_mux(hw);
+	struct stm32_clk_mmux *clk_mmux = to_clk_mmux(mux);
 
-	/* We can't use readl_poll_timeout() because we can be blocked if
-	 * someone enables this clock before clocksource changes.
-	 * Only jiffies counter is available. Jiffies are incremented by
-	 * interruptions and enable op does not allow to be interrupted.
-	 */
-	do {
-		bit_status = !(readl_relaxed(clk_elem->reg) & PLL_RDY);
+	clk_mmux->mmux->saved_parent = clk_mmux_get_parent(hw);
 
-		if (bit_status)
-			udelay(120);
+	return clk_mmux->mmux->saved_parent;
+}
 
-	} while (bit_status && --timeout);
+static int clk_mmux_set_parent_safe(struct clk_hw *hw, u8 index)
+{
+	struct clk_mux *mux = to_clk_mux(hw);
+	struct stm32_clk_mmux *clk_mmux = to_clk_mmux(mux);
 
-unlock:
-	spin_unlock_irqrestore(clk_elem->lock, flags);
+	clk_mmux_set_parent(hw, index);
+	clk_mmux->mmux->saved_parent = index;
 
-	return bit_status;
+	return 0;
 }
 
-static void pll_disable(struct clk_hw *hw)
-{
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
-	u32 reg;
-	unsigned long flags = 0;
+static const struct clk_ops clk_mmux_safe_ops = {
+	.get_parent	= clk_mmux_get_parent_safe,
+	.set_parent	= clk_mmux_set_parent_safe,
+	.determine_rate	= __clk_mux_determine_rate,
+};
 
-	spin_lock_irqsave(clk_elem->lock, flags);
+static int mp1_mgate_clk_enable_safe(struct clk_hw *hw)
+{
+	struct clk_hw *composite_hw = __clk_get_hw(hw->clk);
 
-	reg = readl_relaxed(clk_elem->reg);
-	reg &= ~PLL_ON;
-	writel_relaxed(reg, clk_elem->reg);
+	clk_mmux_restore_parent(composite_hw);
+	mp1_mgate_clk_enable(hw);
 
-	spin_unlock_irqrestore(clk_elem->lock, flags);
+	return  0;
 }
 
-static u32 pll_frac_val(struct clk_hw *hw)
+static void mp1_mgate_clk_disable_safe(struct clk_hw *hw)
 {
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
-	u32 reg, frac = 0;
+	struct clk_hw *composite_hw = __clk_get_hw(hw->clk);
 
-	reg = readl_relaxed(clk_elem->reg + FRAC_OFFSET);
-	if (reg & FRACLE)
-		frac = (reg >> FRAC_SHIFT) & FRAC_MASK;
+	mp1_mgate_clk_disable(hw);
 
-	return frac;
+	if (is_all_clk_on_switch_are_off(composite_hw))
+		clk_mmux_set_safe_position(composite_hw);
 }
 
-static unsigned long pll_recalc_rate(struct clk_hw *hw,
-				     unsigned long parent_rate)
-{
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
-	u32 reg;
-	u32 frac, divm, divn;
-	u64 rate, rate_frac = 0;
+static const struct clk_ops mp1_mgate_clk_safe_ops = {
+	.enable		= mp1_mgate_clk_enable_safe,
+	.disable	= mp1_mgate_clk_disable_safe,
+	.is_enabled	= clk_gate_is_enabled,
+};
+
+/* STM32 PLL */
+struct clk_pll_fractional_divider {
+	struct clk_hw hw;
+	void __iomem *mreg;
+	u8 mshift;
+	u8 mwidth;
+	u8 mflags;
+	void __iomem *nreg;
+	u8 nshift;
+	u8 nwidth;
+	u8 nflags;
+	void __iomem *freg;
+	u8 fshift;
+	u8 fwidth;
+
+	/* lock pll enable/disable registers */
+	spinlock_t *lock;
+};
 
-	reg = readl_relaxed(clk_elem->reg + 4);
+#define to_pll_fractional_divider(_hw)\
+	container_of(_hw, struct clk_pll_fractional_divider, hw)
 
-	divm = ((reg >> DIVM_SHIFT) & DIVM_MASK) + 1;
-	divn = ((reg >> DIVN_SHIFT) & DIVN_MASK) + 1;
-	rate = (u64)parent_rate * divn;
+static unsigned long clk_pll_frac_div_recalc_rate(struct clk_hw *hw,
+						  unsigned long parent_rate)
+{
+	struct clk_pll_fractional_divider *fd = to_pll_fractional_divider(hw);
+	u32 mmask = GENMASK(fd->mwidth - 1, 0) << fd->mshift;
+	u32 nmask = GENMASK(fd->nwidth - 1, 0) << fd->nshift;
+	u32 fmask = GENMASK(fd->fwidth - 1, 0) << fd->fshift;
+	unsigned long m, n, f;
+	u64 rate, frate = 0;
+	u32 val;
+
+	val = readl(fd->mreg);
+	m = (val & mmask) >> fd->mshift;
+	if (fd->mflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		m++;
+
+	val = readl(fd->nreg);
+	n = (val & nmask) >> fd->nshift;
+	if (fd->nflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		n++;
+
+	if (!n || !m)
+		return parent_rate;
 
-	do_div(rate, divm);
+	rate = (u64)parent_rate * n;
+	do_div(rate, m);
 
-	frac = pll_frac_val(hw);
-	if (frac) {
-		rate_frac = (u64)parent_rate * (u64)frac;
-		do_div(rate_frac, (divm * 8192));
+	val = readl(fd->freg);
+	f = (val & fmask) >> fd->fshift;
+	if (f) {
+		frate = (u64)parent_rate * (u64)f;
+		do_div(frate, (m * (1 << fd->fwidth)));
 	}
-
-	return rate + rate_frac;
+	return rate + frate;
 }
 
-static int pll_is_enabled(struct clk_hw *hw)
+static const struct clk_ops clk_pll_frac_div_ops = {
+	.recalc_rate	= clk_pll_frac_div_recalc_rate,
+};
+
+#define PLL_BIT_ON		0
+#define PLL_BIT_RDY		1
+#define PLL_MUX_SHIFT		0
+#define PLL_MUX_MASK		3
+#define PLL_DIVMN_OFFSET	4
+#define PLL_DIVM_SHIFT		16
+#define PLL_DIVM_WIDTH		6
+#define PLL_DIVN_SHIFT		0
+#define PLL_DIVN_WIDTH		9
+#define PLL_FRAC_OFFSET		0xC
+#define PLL_FRAC_SHIFT		3
+#define PLL_FRAC_WIDTH		13
+
+#define TIMEOUT 5
+
+static int pll_enable(struct clk_hw *hw)
 {
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
-	unsigned long flags = 0;
-	int ret;
+	struct clk_gate *gate = to_clk_gate(hw);
+	u32 timeout = TIMEOUT;
+	int bit_status = 0;
 
-	spin_lock_irqsave(clk_elem->lock, flags);
-	ret = __pll_is_enabled(hw);
-	spin_unlock_irqrestore(clk_elem->lock, flags);
+	if (clk_gate_ops.is_enabled(hw))
+		return 0;
 
-	return ret;
+	clk_gate_ops.enable(hw);
+
+	do {
+		bit_status = !(readl_relaxed(gate->reg) & BIT(PLL_BIT_RDY));
+
+		if (bit_status)
+			udelay(120);
+
+	} while (bit_status && --timeout);
+
+	return bit_status;
 }
 
-static u8 pll_get_parent(struct clk_hw *hw)
+static void pll_disable(struct clk_hw *hw)
 {
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
-	struct clk_hw *mux_hw = &clk_elem->mux.hw;
-
-	__clk_hw_set_clk(mux_hw, hw);
+	if (!clk_gate_ops.is_enabled(hw))
+		return;
 
-	return clk_mux_ops.get_parent(mux_hw);
+	clk_gate_ops.disable(hw);
 }
 
-static const struct clk_ops pll_ops = {
+const struct clk_ops pll_gate_ops = {
 	.enable		= pll_enable,
 	.disable	= pll_disable,
-	.recalc_rate	= pll_recalc_rate,
-	.is_enabled	= pll_is_enabled,
-	.get_parent	= pll_get_parent,
+	.is_enabled	= clk_gate_is_enabled,
 };
 
 static struct clk_hw *clk_register_pll(struct device *dev, const char *name,
@@ -888,39 +945,50 @@ static struct clk_hw *clk_register_pll(struct device *dev, const char *name,
 				       unsigned long flags,
 				       spinlock_t *lock)
 {
-	struct stm32_pll_obj *element;
-	struct clk_init_data init;
-	struct clk_hw *hw;
-	int err;
+	struct clk_pll_fractional_divider *frac_div;
+	struct clk_gate *gate;
+	struct clk_mux *mux;
 
-	element = devm_kzalloc(dev, sizeof(*element), GFP_KERNEL);
-	if (!element)
+	mux = devm_kzalloc(dev, sizeof(*mux), GFP_KERNEL);
+	if (!mux)
 		return ERR_PTR(-ENOMEM);
 
-	init.name = name;
-	init.ops = &pll_ops;
-	init.flags = flags;
-	init.parent_names = parent_names;
-	init.num_parents = num_parents;
+	mux->reg = mux_reg;
+	mux->shift = PLL_MUX_SHIFT;
+	mux->mask = PLL_MUX_MASK;
+	mux->flags = CLK_MUX_READ_ONLY;
+	mux->table = NULL;
+	mux->lock = lock;
 
-	element->mux.lock = lock;
-	element->mux.reg =  mux_reg;
-	element->mux.shift = PLL_MUX_SHIFT;
-	element->mux.mask =  PLL_MUX_MASK;
-	element->mux.flags =  CLK_MUX_READ_ONLY;
-	element->mux.reg =  mux_reg;
+	gate = devm_kzalloc(dev, sizeof(*gate), GFP_KERNEL);
+	if (!gate)
+		return ERR_PTR(-ENOMEM);
 
-	element->hw.init = &init;
-	element->reg = reg;
-	element->lock = lock;
+	gate->reg = reg;
+	gate->bit_idx = PLL_BIT_ON;
+	gate->flags = 0;
+	gate->lock = lock;
 
-	hw = &element->hw;
-	err = clk_hw_register(dev, hw);
+	frac_div = devm_kzalloc(dev, sizeof(*frac_div), GFP_KERNEL);
+	if (!frac_div)
+		return ERR_PTR(-ENOMEM);
 
-	if (err)
-		return ERR_PTR(err);
+	frac_div->mreg = reg + PLL_DIVMN_OFFSET;
+	frac_div->mshift = PLL_DIVM_SHIFT;
+	frac_div->mwidth = PLL_DIVM_WIDTH;
+	frac_div->mflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	frac_div->nreg = reg + PLL_DIVMN_OFFSET;
+	frac_div->nshift = PLL_DIVN_SHIFT;
+	frac_div->nwidth = PLL_DIVN_WIDTH;
+	frac_div->nflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	frac_div->freg = reg + PLL_FRAC_OFFSET;
+	frac_div->fshift = PLL_FRAC_SHIFT;
+	frac_div->fwidth = PLL_FRAC_WIDTH;
 
-	return hw;
+	return clk_hw_register_composite(dev, name, parent_names, num_parents,
+					 &mux->hw, &clk_mux_ops,
+					 &frac_div->hw, &clk_pll_frac_div_ops,
+					 &gate->hw, &pll_gate_ops, flags);
 }
 
 /* Kernel Timer */
@@ -1090,9 +1158,49 @@ static const struct clk_ops rtc_div_clk_ops = {
 	.determine_rate = clk_divider_rtc_determine_rate
 };
 
+static int clk_div_get_duty_cycle(struct clk_hw *hw, struct clk_duty *duty)
+{
+	struct clk_divider *divider = to_clk_divider(hw);
+	unsigned int val;
+
+	val = readl(divider->reg) >> divider->shift;
+	val &= clk_div_mask(divider->width);
+
+	duty->num = (val + 1) / 2;
+	duty->den = (val + 1);
+
+	return 0;
+}
+
+static unsigned long clk_div_duty_cycle_recalc_rate(struct clk_hw *hw,
+						    unsigned long parent_rate)
+{
+	return clk_divider_ops.recalc_rate(hw, parent_rate);
+}
+
+static long clk_div_duty_cycle_round_rate(struct clk_hw *hw, unsigned long rate,
+					  unsigned long *prate)
+{
+	return clk_divider_ops.round_rate(hw, rate, prate);
+}
+
+static int clk_div_duty_cycle_set_rate(struct clk_hw *hw, unsigned long rate,
+				       unsigned long parent_rate)
+{
+	return clk_divider_ops.set_rate(hw, rate, parent_rate);
+}
+
+static const struct clk_ops div_dc_clk_ops = {
+	.recalc_rate	= clk_div_duty_cycle_recalc_rate,
+	.round_rate	= clk_div_duty_cycle_round_rate,
+	.set_rate	= clk_div_duty_cycle_set_rate,
+	.get_duty_cycle = clk_div_get_duty_cycle,
+};
+
 struct stm32_pll_cfg {
 	u32 offset;
 	u32 muxoff;
+	const struct clk_ops *ops;
 };
 
 static struct clk_hw *_clk_register_pll(struct device *dev,
@@ -1281,7 +1389,7 @@ _clk_stm32_register_composite(struct device *dev,
 		    NULL, &mp1_gate_clk_ops)\
 
 #define _MGATE_MP1(_mgate)\
-	.gate = &per_gate_cfg[_mgate]
+	&per_gate_cfg[_mgate]
 
 #define GATE_MP1(_id, _name, _parent, _flags, _offset, _bit_idx, _gate_flags)\
 	STM32_GATE(_id, _name, _parent, _flags,\
@@ -1293,7 +1401,7 @@ _clk_stm32_register_composite(struct device *dev,
 
 #define _STM32_DIV(_div_offset, _div_shift, _div_width,\
 		   _div_flags, _div_table, _ops)\
-	.div = &(struct stm32_div_cfg) {\
+	(&(struct stm32_div_cfg) {\
 		&(struct div_cfg) {\
 			.reg_off	= _div_offset,\
 			.shift		= _div_shift,\
@@ -1302,18 +1410,23 @@ _clk_stm32_register_composite(struct device *dev,
 			.table		= _div_table,\
 		},\
 		.ops		= _ops,\
-	}
+	})
 
 #define _DIV(_div_offset, _div_shift, _div_width, _div_flags, _div_table)\
 	_STM32_DIV(_div_offset, _div_shift, _div_width,\
-		   _div_flags, _div_table, NULL)\
+		   _div_flags, _div_table, NULL)
+
+#define _DIV_DUTY_CYCLE(_div_offset, _div_shift, _div_width, _div_flags,\
+			_div_table)\
+	_STM32_DIV(_div_offset, _div_shift, _div_width,\
+		   _div_flags, _div_table, &div_dc_clk_ops)
 
 #define _DIV_RTC(_div_offset, _div_shift, _div_width, _div_flags, _div_table)\
 	_STM32_DIV(_div_offset, _div_shift, _div_width,\
 		   _div_flags, _div_table, &rtc_div_clk_ops)
 
 #define _STM32_MUX(_offset, _shift, _width, _mux_flags, _mmux, _ops)\
-	.mux = &(struct stm32_mux_cfg) {\
+	(&(struct stm32_mux_cfg) {\
 		&(struct mux_cfg) {\
 			.reg_off	= _offset,\
 			.shift		= _shift,\
@@ -1323,18 +1436,18 @@ _clk_stm32_register_composite(struct device *dev,
 		},\
 		.mmux		= _mmux,\
 		.ops		= _ops,\
-	}
+	})
 
 #define _MUX(_offset, _shift, _width, _mux_flags)\
-	_STM32_MUX(_offset, _shift, _width, _mux_flags, NULL, NULL)\
+	_STM32_MUX(_offset, _shift, _width, _mux_flags, NULL, NULL)
 
-#define _MMUX(_mmux) .mux = &ker_mux_cfg[_mmux]
+#define _MMUX(_mmux)		&ker_mux_cfg[_mmux]
 
-#define PARENT(_parent) ((const char *[]) { _parent})
+#define PARENT(_parent)		((const char *[]) { _parent})
 
-#define _NO_MUX .mux = NULL
-#define _NO_DIV .div = NULL
-#define _NO_GATE .gate = NULL
+#define _NO_MUX			NULL
+#define _NO_DIV			NULL
+#define _NO_GATE		NULL
 
 #define COMPOSITE(_id, _name, _parents, _flags, _gate, _mux, _div)\
 {\
@@ -1344,9 +1457,9 @@ _clk_stm32_register_composite(struct device *dev,
 	.num_parents	= ARRAY_SIZE(_parents),\
 	.flags		= _flags,\
 	.cfg		= &(struct stm32_composite_cfg) {\
-		_gate,\
-		_mux,\
-		_div,\
+		.gate = (_gate),\
+		.mux = (_mux),\
+		.div = (_div),\
 	},\
 	.func		= _clk_stm32_register_composite,\
 }
@@ -1498,6 +1611,10 @@ static struct stm32_mgate mp1_mgate[G_LAST];
 	_K_GATE(_id, _gate_offset, _gate_bit_idx, _gate_flags,\
 	       &mp1_mgate[_id], &mp1_mgate_clk_ops)
 
+#define K_MGATE_SAFE(_id, _gate_offset, _gate_bit_idx, _gate_flags)\
+	_K_GATE(_id, _gate_offset, _gate_bit_idx, _gate_flags,\
+		&mp1_mgate[_id], &mp1_mgate_clk_safe_ops)
+
 /* Peripheral gates */
 static struct stm32_gate_cfg per_gate_cfg[G_LAST] = {
 	/* Multi gates */
@@ -1609,10 +1726,10 @@ static struct stm32_gate_cfg per_gate_cfg[G_LAST] = {
 
 	K_GATE(G_USBH,		RCC_AHB6ENSETR, 24, 0),
 	K_GATE(G_CRC1,		RCC_AHB6ENSETR, 20, 0),
-	K_MGATE(G_SDMMC2,	RCC_AHB6ENSETR, 17, 0),
-	K_MGATE(G_SDMMC1,	RCC_AHB6ENSETR, 16, 0),
-	K_MGATE(G_QSPI,		RCC_AHB6ENSETR, 14, 0),
-	K_MGATE(G_FMC,		RCC_AHB6ENSETR, 12, 0),
+	K_MGATE_SAFE(G_SDMMC2,	RCC_AHB6ENSETR, 17, 0),
+	K_MGATE_SAFE(G_SDMMC1,	RCC_AHB6ENSETR, 16, 0),
+	K_MGATE_SAFE(G_QSPI,	RCC_AHB6ENSETR, 14, 0),
+	K_MGATE_SAFE(G_FMC,	RCC_AHB6ENSETR, 12, 0),
 	K_GATE(G_ETHMAC,	RCC_AHB6ENSETR, 10, 0),
 	K_GATE(G_ETHRX,		RCC_AHB6ENSETR, 9, 0),
 	K_GATE(G_ETHTX,		RCC_AHB6ENSETR, 8, 0),
@@ -1684,9 +1801,13 @@ static struct stm32_mmux ker_mux[M_LAST];
 	_K_MUX(_id, _offset, _shift, _width, _mux_flags,\
 			&ker_mux[_id], &clk_mmux_ops)
 
+#define K_MMUX_SAFE(_id, _offset, _shift, _width, _mux_flags)\
+	_K_MUX(_id, _offset, _shift, _width, _mux_flags,\
+			&ker_mux[_id], &clk_mmux_safe_ops)
+
 static const struct stm32_mux_cfg ker_mux_cfg[M_LAST] = {
 	/* Kernel multi mux */
-	K_MMUX(M_SDMMC12, RCC_SDMMC12CKSELR, 0, 3, 0),
+	K_MMUX_SAFE(M_SDMMC12, RCC_SDMMC12CKSELR, 0, 3, 0),
 	K_MMUX(M_SPI23, RCC_SPI2S23CKSELR, 0, 3, 0),
 	K_MMUX(M_SPI45, RCC_SPI2S45CKSELR, 0, 3, 0),
 	K_MMUX(M_I2C12, RCC_I2C12CKSELR, 0, 3, 0),
@@ -1703,8 +1824,8 @@ static const struct stm32_mux_cfg ker_mux_cfg[M_LAST] = {
 	/*  Kernel simple mux */
 	K_MUX(M_RNG2, RCC_RNG2CKSELR, 0, 2, 0),
 	K_MUX(M_SDMMC3, RCC_SDMMC3CKSELR, 0, 3, 0),
-	K_MUX(M_FMC, RCC_FMCCKSELR, 0, 2, 0),
-	K_MUX(M_QSPI, RCC_QSPICKSELR, 0, 2, 0),
+	K_MMUX_SAFE(M_FMC, RCC_FMCCKSELR, 0, 2, 0),
+	K_MMUX_SAFE(M_QSPI, RCC_QSPICKSELR, 0, 2, 0),
 	K_MUX(M_USBPHY, RCC_USBCKSELR, 0, 2, 0),
 	K_MUX(M_USBO, RCC_USBCKSELR, 4, 1, 0),
 	K_MUX(M_SPDIF, RCC_SPDIFCKSELR, 0, 2, 0),
@@ -1748,7 +1869,7 @@ static const struct clock_config stm32mp1_clock_cfg[] = {
 	PLL(PLL4, "pll4", ref4_parents, 0, RCC_PLL4CR, RCC_RCK4SELR),
 
 	/* ODF */
-	COMPOSITE(PLL1_P, "pll1_p", PARENT("pll1"), 0,
+	COMPOSITE(PLL1_P, "pll1_p", PARENT("pll1"), CLK_SET_RATE_PARENT,
 		  _GATE(RCC_PLL1CR, 4, 0),
 		  _NO_MUX,
 		  _DIV(RCC_PLL1CFGR2, 0, 7, 0, NULL)),
@@ -1776,7 +1897,7 @@ static const struct clock_config stm32mp1_clock_cfg[] = {
 	COMPOSITE(PLL3_Q, "pll3_q", PARENT("pll3"), 0,
 		  _GATE(RCC_PLL3CR, 5, 0),
 		  _NO_MUX,
-		  _DIV(RCC_PLL3CFGR2, 8, 7, 0, NULL)),
+		  _DIV_DUTY_CYCLE(RCC_PLL3CFGR2, 8, 7, 0, NULL)),
 
 	COMPOSITE(PLL3_R, "pll3_r", PARENT("pll3"), 0,
 		  _GATE(RCC_PLL3CR, 6, 0),
@@ -1796,40 +1917,40 @@ static const struct clock_config stm32mp1_clock_cfg[] = {
 	COMPOSITE(PLL4_R, "pll4_r", PARENT("pll4"), 0,
 		  _GATE(RCC_PLL4CR, 6, 0),
 		  _NO_MUX,
-		  _DIV(RCC_PLL4CFGR2, 16, 7, 0, NULL)),
+		  _DIV_DUTY_CYCLE(RCC_PLL4CFGR2, 16, 7, 0, NULL)),
 
 	/* MUX system clocks */
 	MUX(CK_PER, "ck_per", per_src, CLK_OPS_PARENT_ENABLE,
 	    RCC_CPERCKSELR, 0, 2, 0),
 
 	MUX(CK_MPU, "ck_mpu", cpu_src, CLK_OPS_PARENT_ENABLE |
-	     CLK_IS_CRITICAL, RCC_MPCKSELR, 0, 2, 0),
+	    CLK_SET_RATE_PARENT | CLK_IS_CRITICAL, RCC_MPCKSELR, 0, 2, 0),
 
 	COMPOSITE(CK_AXI, "ck_axi", axi_src, CLK_IS_CRITICAL |
-		   CLK_OPS_PARENT_ENABLE,
-		   _NO_GATE,
-		   _MUX(RCC_ASSCKSELR, 0, 2, 0),
-		   _DIV(RCC_AXIDIVR, 0, 3, 0, axi_div_table)),
+		  CLK_OPS_PARENT_ENABLE,
+		  _NO_GATE,
+		  _MUX(RCC_ASSCKSELR, 0, 2, 0),
+		  _DIV(RCC_AXIDIVR, 0, 3, 0, axi_div_table)),
 
 	COMPOSITE(CK_MCU, "ck_mcu", mcu_src, CLK_IS_CRITICAL |
-		   CLK_OPS_PARENT_ENABLE,
-		   _NO_GATE,
-		   _MUX(RCC_MSSCKSELR, 0, 2, 0),
-		   _DIV(RCC_MCUDIVR, 0, 4, 0, mcu_div_table)),
+		  CLK_OPS_PARENT_ENABLE,
+		  _NO_GATE,
+		  _MUX(RCC_MSSCKSELR, 0, 2, 0),
+		  _DIV(RCC_MCUDIVR, 0, 4, 0, mcu_div_table)),
 
-	DIV_TABLE(NO_ID, "pclk1", "ck_mcu", CLK_IGNORE_UNUSED, RCC_APB1DIVR, 0,
+	DIV_TABLE(PCLK1, "pclk1", "ck_mcu", CLK_IGNORE_UNUSED, RCC_APB1DIVR, 0,
 		  3, CLK_DIVIDER_READ_ONLY, apb_div_table),
 
-	DIV_TABLE(NO_ID, "pclk2", "ck_mcu", CLK_IGNORE_UNUSED, RCC_APB2DIVR, 0,
+	DIV_TABLE(PCLK2, "pclk2", "ck_mcu", CLK_IGNORE_UNUSED, RCC_APB2DIVR, 0,
 		  3, CLK_DIVIDER_READ_ONLY, apb_div_table),
 
-	DIV_TABLE(NO_ID, "pclk3", "ck_mcu", CLK_IGNORE_UNUSED, RCC_APB3DIVR, 0,
+	DIV_TABLE(PCLK3, "pclk3", "ck_mcu", CLK_IGNORE_UNUSED, RCC_APB3DIVR, 0,
 		  3, CLK_DIVIDER_READ_ONLY, apb_div_table),
 
-	DIV_TABLE(NO_ID, "pclk4", "ck_axi", CLK_IGNORE_UNUSED, RCC_APB4DIVR, 0,
+	DIV_TABLE(PCLK4, "pclk4", "ck_axi", CLK_IGNORE_UNUSED, RCC_APB4DIVR, 0,
 		  3, CLK_DIVIDER_READ_ONLY, apb_div_table),
 
-	DIV_TABLE(NO_ID, "pclk5", "ck_axi", CLK_IGNORE_UNUSED, RCC_APB5DIVR, 0,
+	DIV_TABLE(PCLK5, "pclk5", "ck_axi", CLK_IGNORE_UNUSED, RCC_APB5DIVR, 0,
 		  3, CLK_DIVIDER_READ_ONLY, apb_div_table),
 
 	/* Kernel Timers */
@@ -1911,8 +2032,7 @@ static const struct clock_config stm32mp1_clock_cfg[] = {
 	PCLK(I2C4, "i2c4", "pclk5", 0, G_I2C4),
 	PCLK(I2C6, "i2c6", "pclk5", 0, G_I2C6),
 	PCLK(USART1, "usart1", "pclk5", 0, G_USART1),
-	PCLK(RTCAPB, "rtcapb", "pclk5", CLK_IGNORE_UNUSED |
-	     CLK_IS_CRITICAL, G_RTCAPB),
+	PCLK(RTCAPB, "rtcapb", "pclk5", CLK_IS_CRITICAL, G_RTCAPB),
 	PCLK(TZC1, "tzc1", "ck_axi", CLK_IGNORE_UNUSED, G_TZC1),
 	PCLK(TZC2, "tzc2", "ck_axi", CLK_IGNORE_UNUSED, G_TZC2),
 	PCLK(TZPC, "tzpc", "pclk5", CLK_IGNORE_UNUSED, G_TZPC),
@@ -1953,10 +2073,6 @@ static const struct clock_config stm32mp1_clock_cfg[] = {
 	PCLK(ETHTX, "ethtx", "ck_axi", 0, G_ETHTX),
 	PCLK(ETHRX, "ethrx", "ck_axi", 0, G_ETHRX),
 	PCLK(ETHMAC, "ethmac", "ck_axi", 0, G_ETHMAC),
-	PCLK(FMC, "fmc", "ck_axi", CLK_IGNORE_UNUSED, G_FMC),
-	PCLK(QSPI, "qspi", "ck_axi", CLK_IGNORE_UNUSED, G_QSPI),
-	PCLK(SDMMC1, "sdmmc1", "ck_axi", 0, G_SDMMC1),
-	PCLK(SDMMC2, "sdmmc2", "ck_axi", 0, G_SDMMC2),
 	PCLK(CRC1, "crc1", "ck_axi", 0, G_CRC1),
 	PCLK(USBH, "usbh", "ck_axi", 0, G_USBH),
 	PCLK(ETHSTP, "ethstp", "ck_axi", 0, G_ETHSTP),
@@ -2046,7 +2162,8 @@ static const struct clock_config stm32mp1_clock_cfg[] = {
 	GATE(CK_DBG, "ck_sys_dbg", "ck_axi", CLK_IGNORE_UNUSED,
 	     RCC_DBGCFGR, 8, 0),
 
-	COMPOSITE(CK_TRACE, "ck_trace", ck_trace_src, CLK_OPS_PARENT_ENABLE,
+	COMPOSITE(CK_TRACE, "ck_trace", ck_trace_src,
+		  CLK_OPS_PARENT_ENABLE | CLK_IGNORE_UNUSED,
 		  _GATE(RCC_DBGCFGR, 9, 0),
 		  _NO_MUX,
 		  _DIV(RCC_DBGCFGR, 0, 3, 0, ck_trace_div_table)),
@@ -2338,6 +2455,8 @@ static int stm32_rcc_init(struct device *dev, void __iomem *base,
 	return 0;
 }
 
+static void stm32_clk_summary_debugfs_create(struct device *dev, void __iomem *base);
+
 static int stm32mp1_rcc_init(struct device *dev)
 {
 	void __iomem *base;
@@ -2358,6 +2477,8 @@ static int stm32mp1_rcc_init(struct device *dev)
 			iounmap(base);
 
 		of_node_put(dev_of_node(dev));
+	} else {
+		stm32_clk_summary_debugfs_create(dev, base);
 	}
 
 	return ret;
@@ -2429,3 +2550,1182 @@ static int __init stm32mp1_clocks_init(void)
 	return platform_driver_register(&stm32mp1_rcc_clocks_driver);
 }
 core_initcall(stm32mp1_clocks_init);
+
+#ifdef CONFIG_DEBUG_FS
+
+#include <linux/debugfs.h>
+
+#define NO_STM32_MUX		0xFFFF
+#define NO_STM32_DIV		0xFFFF
+#define NO_STM32_GATE		0xFFFF
+
+enum enum_gate_cfg {
+	GATE_HSI,
+	GATE_CSI,
+	GATE_LSI,
+	GATE_HSE,
+	GATE_LSE,
+	GATE_PLL1,
+	GATE_PLL2,
+	GATE_PLL3,
+	GATE_PLL4,
+	GATE_PLL1_DIVP,
+	GATE_PLL1_DIVQ,
+	GATE_PLL1_DIVR,
+	GATE_PLL2_DIVP,
+	GATE_PLL2_DIVQ,
+	GATE_PLL2_DIVR,
+	GATE_PLL3_DIVP,
+	GATE_PLL3_DIVQ,
+	GATE_PLL3_DIVR,
+	GATE_PLL4_DIVP,
+	GATE_PLL4_DIVQ,
+	GATE_PLL4_DIVR,
+	GATE_RTCCK,
+	GATE_MCO1,
+	GATE_MCO2,
+	GATE_DBGCK,
+	GATE_TRACECK,
+	GATE_SAI1,
+	GATE_SAI2,
+	GATE_SAI3,
+	GATE_SAI4,
+	GATE_SPI1,
+	GATE_SPI2,
+	GATE_SPI3,
+	GATE_SPI4,
+	GATE_SPI5,
+	GATE_SPI6,
+	GATE_SPDIF,
+	GATE_I2C1,
+	GATE_I2C2,
+	GATE_I2C3,
+	GATE_I2C4,
+	GATE_I2C5,
+	GATE_I2C6,
+	GATE_USART2,
+	GATE_UART4,
+	GATE_USART3,
+	GATE_UART5,
+	GATE_USART1,
+	GATE_USART6,
+	GATE_UART7,
+	GATE_UART8,
+	GATE_LPTIM1,
+	GATE_LPTIM2,
+	GATE_LPTIM3,
+	GATE_LPTIM4,
+	GATE_LPTIM5,
+	GATE_LTDC,
+	GATE_DSI,
+	GATE_QSPI,
+	GATE_FMC,
+	GATE_SDMMC1,
+	GATE_SDMMC2,
+	GATE_SDMMC3,
+	GATE_USBO,
+	GATE_USBPHY,
+	GATE_RNG1,
+	GATE_RNG2,
+	GATE_FDCAN,
+	GATE_DAC12,
+	GATE_CEC,
+	GATE_ADC12,
+	GATE_GPU,
+	GATE_STGEN,
+	GATE_DFSDM,
+	GATE_ADFSDM,
+	GATE_TIM2,
+	GATE_TIM3,
+	GATE_TIM4,
+	GATE_TIM5,
+	GATE_TIM6,
+	GATE_TIM7,
+	GATE_TIM12,
+	GATE_TIM13,
+	GATE_TIM14,
+	GATE_MDIO,
+	GATE_TIM1,
+	GATE_TIM8,
+	GATE_TIM15,
+	GATE_TIM16,
+	GATE_TIM17,
+	GATE_SYSCFG,
+	GATE_VREF,
+	GATE_TMPSENS,
+	GATE_PMBCTRL,
+	GATE_HDP,
+	GATE_IWDG2,
+	GATE_STGENRO,
+	GATE_DMA1,
+	GATE_DMA2,
+	GATE_DMAMUX,
+	GATE_DCMI,
+	GATE_CRYP2,
+	GATE_HASH2,
+	GATE_CRC2,
+	GATE_HSEM,
+	GATE_IPCC,
+	GATE_GPIOA,
+	GATE_GPIOB,
+	GATE_GPIOC,
+	GATE_GPIOD,
+	GATE_GPIOE,
+	GATE_GPIOF,
+	GATE_GPIOG,
+	GATE_GPIOH,
+	GATE_GPIOI,
+	GATE_GPIOJ,
+	GATE_GPIOK,
+	GATE_MDMA,
+	GATE_ETHCK,
+	GATE_ETHTX,
+	GATE_ETHRX,
+	GATE_ETHMAC,
+	GATE_CRC1,
+	GATE_USBH,
+	GATE_ETHSTP,
+	GATE_RTCAPB,
+	GATE_TZC1,
+	GATE_TZC2,
+	GATE_TZPC,
+	GATE_IWDG1,
+	GATE_BSEC,
+	GATE_GPIOZ,
+	GATE_CRYP1,
+	GATE_HASH1,
+	GATE_BKPSRAM,
+	GATE_DDRPERFM,
+
+	GATE_NB
+};
+
+struct cs_gate_cfg {
+	u16	offset;
+	u8	bit_idx;
+};
+
+#define CFG_GATE(_id, _offset, _bit_idx)\
+	[(_id)] = {\
+		.offset = (_offset),\
+		.bit_idx = (_bit_idx),\
+	}
+
+static struct cs_gate_cfg stm32mp15_gates[] = {
+	CFG_GATE(GATE_HSI,		RCC_OCENSETR,	0),
+	CFG_GATE(GATE_CSI,		RCC_OCENSETR,	4),
+	CFG_GATE(GATE_LSI,		RCC_RDLSICR,	0),
+	CFG_GATE(GATE_HSE,		RCC_OCENSETR,	8),
+	CFG_GATE(GATE_LSE,		RCC_BDCR,	0),
+	CFG_GATE(GATE_RTCCK,		RCC_BDCR,	20),
+	CFG_GATE(GATE_PLL1,		RCC_PLL1CR,	0),
+	CFG_GATE(GATE_PLL1_DIVP,	RCC_PLL1CR,	4),
+	CFG_GATE(GATE_PLL1_DIVQ,	RCC_PLL1CR,	5),
+	CFG_GATE(GATE_PLL1_DIVR,	RCC_PLL1CR,	6),
+	CFG_GATE(GATE_PLL2,		RCC_PLL2CR,	0),
+	CFG_GATE(GATE_PLL2_DIVP,	RCC_PLL2CR,	4),
+	CFG_GATE(GATE_PLL2_DIVQ,	RCC_PLL2CR,	5),
+	CFG_GATE(GATE_PLL2_DIVR,	RCC_PLL2CR,	6),
+	CFG_GATE(GATE_PLL3,		RCC_PLL3CR,	0),
+	CFG_GATE(GATE_PLL3_DIVP,	RCC_PLL3CR,	4),
+	CFG_GATE(GATE_PLL3_DIVQ,	RCC_PLL3CR,	5),
+	CFG_GATE(GATE_PLL3_DIVR,	RCC_PLL3CR,	6),
+	CFG_GATE(GATE_PLL4,		RCC_PLL4CR,	0),
+	CFG_GATE(GATE_PLL4_DIVP,	RCC_PLL4CR,	4),
+	CFG_GATE(GATE_PLL4_DIVQ,	RCC_PLL4CR,	5),
+	CFG_GATE(GATE_PLL4_DIVR,	RCC_PLL4CR,	6),
+	CFG_GATE(GATE_MCO1,		RCC_MCO1CFGR,	12),
+	CFG_GATE(GATE_MCO2,		RCC_MCO2CFGR,	12),
+	CFG_GATE(GATE_DBGCK,		RCC_DBGCFGR,	8),
+	CFG_GATE(GATE_TRACECK,		RCC_DBGCFGR,	9),
+	CFG_GATE(GATE_MDIO,		RCC_APB1ENSETR, 31),
+	CFG_GATE(GATE_DAC12,		RCC_APB1ENSETR, 29),
+	CFG_GATE(GATE_CEC,		RCC_APB1ENSETR, 27),
+	CFG_GATE(GATE_SPDIF,		RCC_APB1ENSETR, 26),
+	CFG_GATE(GATE_I2C5,		RCC_APB1ENSETR, 24),
+	CFG_GATE(GATE_I2C3,		RCC_APB1ENSETR, 23),
+	CFG_GATE(GATE_I2C2,		RCC_APB1ENSETR, 22),
+	CFG_GATE(GATE_I2C1,		RCC_APB1ENSETR, 21),
+	CFG_GATE(GATE_UART8,		RCC_APB1ENSETR, 19),
+	CFG_GATE(GATE_UART7,		RCC_APB1ENSETR, 18),
+	CFG_GATE(GATE_UART5,		RCC_APB1ENSETR, 17),
+	CFG_GATE(GATE_UART4,		RCC_APB1ENSETR, 16),
+	CFG_GATE(GATE_USART3,		RCC_APB1ENSETR, 15),
+	CFG_GATE(GATE_USART2,		RCC_APB1ENSETR, 14),
+	CFG_GATE(GATE_SPI3,		RCC_APB1ENSETR, 12),
+	CFG_GATE(GATE_SPI2,		RCC_APB1ENSETR, 11),
+	CFG_GATE(GATE_LPTIM1,		RCC_APB1ENSETR, 9),
+	CFG_GATE(GATE_TIM14,		RCC_APB1ENSETR, 8),
+	CFG_GATE(GATE_TIM13,		RCC_APB1ENSETR, 7),
+	CFG_GATE(GATE_TIM12,		RCC_APB1ENSETR, 6),
+	CFG_GATE(GATE_TIM7,		RCC_APB1ENSETR, 5),
+	CFG_GATE(GATE_TIM6,		RCC_APB1ENSETR, 4),
+	CFG_GATE(GATE_TIM5,		RCC_APB1ENSETR, 3),
+	CFG_GATE(GATE_TIM4,		RCC_APB1ENSETR, 2),
+	CFG_GATE(GATE_TIM3,		RCC_APB1ENSETR, 1),
+	CFG_GATE(GATE_TIM2,		RCC_APB1ENSETR, 0),
+	CFG_GATE(GATE_FDCAN,		RCC_APB2ENSETR, 24),
+	CFG_GATE(GATE_ADFSDM,		RCC_APB2ENSETR, 21),
+	CFG_GATE(GATE_DFSDM,		RCC_APB2ENSETR, 20),
+	CFG_GATE(GATE_SAI3,		RCC_APB2ENSETR, 18),
+	CFG_GATE(GATE_SAI2,		RCC_APB2ENSETR, 17),
+	CFG_GATE(GATE_SAI1,		RCC_APB2ENSETR, 16),
+	CFG_GATE(GATE_USART6,		RCC_APB2ENSETR, 13),
+	CFG_GATE(GATE_SPI5,		RCC_APB2ENSETR, 10),
+	CFG_GATE(GATE_SPI4,		RCC_APB2ENSETR, 9),
+	CFG_GATE(GATE_SPI1,		RCC_APB2ENSETR, 8),
+	CFG_GATE(GATE_TIM17,		RCC_APB2ENSETR, 4),
+	CFG_GATE(GATE_TIM16,		RCC_APB2ENSETR, 3),
+	CFG_GATE(GATE_TIM15,		RCC_APB2ENSETR, 2),
+	CFG_GATE(GATE_TIM8,		RCC_APB2ENSETR, 1),
+	CFG_GATE(GATE_TIM1,		RCC_APB2ENSETR, 0),
+	CFG_GATE(GATE_HDP,		RCC_APB3ENSETR, 20),
+	CFG_GATE(GATE_PMBCTRL,		RCC_APB3ENSETR, 17),
+	CFG_GATE(GATE_TMPSENS,		RCC_APB3ENSETR, 16),
+	CFG_GATE(GATE_VREF,		RCC_APB3ENSETR, 13),
+	CFG_GATE(GATE_SYSCFG,		RCC_APB3ENSETR, 11),
+	CFG_GATE(GATE_SAI4,		RCC_APB3ENSETR, 8),
+	CFG_GATE(GATE_LPTIM5,		RCC_APB3ENSETR, 3),
+	CFG_GATE(GATE_LPTIM4,		RCC_APB3ENSETR, 2),
+	CFG_GATE(GATE_LPTIM3,		RCC_APB3ENSETR, 1),
+	CFG_GATE(GATE_LPTIM2,		RCC_APB3ENSETR, 0),
+	CFG_GATE(GATE_STGENRO,		RCC_APB4ENSETR, 20),
+	CFG_GATE(GATE_USBPHY,		RCC_APB4ENSETR, 16),
+	CFG_GATE(GATE_IWDG2,		RCC_APB4ENSETR, 15),
+	CFG_GATE(GATE_DDRPERFM,		RCC_APB4ENSETR, 8),
+	CFG_GATE(GATE_DSI,		RCC_APB4ENSETR, 4),
+	CFG_GATE(GATE_LTDC,		RCC_APB4ENSETR, 0),
+	CFG_GATE(GATE_STGEN,		RCC_APB5ENSETR, 20),
+	CFG_GATE(GATE_BSEC,		RCC_APB5ENSETR, 16),
+	CFG_GATE(GATE_IWDG1,		RCC_APB5ENSETR, 15),
+	CFG_GATE(GATE_TZPC,		RCC_APB5ENSETR, 13),
+	CFG_GATE(GATE_TZC2,		RCC_APB5ENSETR, 12),
+	CFG_GATE(GATE_TZC1,		RCC_APB5ENSETR, 11),
+	CFG_GATE(GATE_RTCAPB,		RCC_APB5ENSETR, 8),
+	CFG_GATE(GATE_USART1,		RCC_APB5ENSETR, 4),
+	CFG_GATE(GATE_I2C6,		RCC_APB5ENSETR, 3),
+	CFG_GATE(GATE_I2C4,		RCC_APB5ENSETR, 2),
+	CFG_GATE(GATE_SPI6,		RCC_APB5ENSETR, 0),
+	CFG_GATE(GATE_SDMMC3,		RCC_AHB2ENSETR, 16),
+	CFG_GATE(GATE_USBO,		RCC_AHB2ENSETR, 8),
+	CFG_GATE(GATE_ADC12,		RCC_AHB2ENSETR, 5),
+	CFG_GATE(GATE_DMAMUX,		RCC_AHB2ENSETR, 2),
+	CFG_GATE(GATE_DMA2,		RCC_AHB2ENSETR, 1),
+	CFG_GATE(GATE_DMA1,		RCC_AHB2ENSETR, 0),
+	CFG_GATE(GATE_IPCC,		RCC_AHB3ENSETR, 12),
+	CFG_GATE(GATE_HSEM,		RCC_AHB3ENSETR, 11),
+	CFG_GATE(GATE_CRC2,		RCC_AHB3ENSETR, 7),
+	CFG_GATE(GATE_RNG2,		RCC_AHB3ENSETR, 6),
+	CFG_GATE(GATE_HASH2,		RCC_AHB3ENSETR, 5),
+	CFG_GATE(GATE_CRYP2,		RCC_AHB3ENSETR, 4),
+	CFG_GATE(GATE_DCMI,		RCC_AHB3ENSETR, 0),
+	CFG_GATE(GATE_GPIOK,		RCC_AHB4ENSETR, 10),
+	CFG_GATE(GATE_GPIOJ,		RCC_AHB4ENSETR, 9),
+	CFG_GATE(GATE_GPIOI,		RCC_AHB4ENSETR, 8),
+	CFG_GATE(GATE_GPIOH,		RCC_AHB4ENSETR, 7),
+	CFG_GATE(GATE_GPIOG,		RCC_AHB4ENSETR, 6),
+	CFG_GATE(GATE_GPIOF,		RCC_AHB4ENSETR, 5),
+	CFG_GATE(GATE_GPIOE,		RCC_AHB4ENSETR, 4),
+	CFG_GATE(GATE_GPIOD,		RCC_AHB4ENSETR, 3),
+	CFG_GATE(GATE_GPIOC,		RCC_AHB4ENSETR, 2),
+	CFG_GATE(GATE_GPIOB,		RCC_AHB4ENSETR, 1),
+	CFG_GATE(GATE_GPIOA,		RCC_AHB4ENSETR, 0),
+	CFG_GATE(GATE_BKPSRAM,		RCC_AHB5ENSETR, 8),
+	CFG_GATE(GATE_RNG1,		RCC_AHB5ENSETR, 6),
+	CFG_GATE(GATE_HASH1,		RCC_AHB5ENSETR, 5),
+	CFG_GATE(GATE_CRYP1,		RCC_AHB5ENSETR, 4),
+	CFG_GATE(GATE_GPIOZ,		RCC_AHB5ENSETR, 0),
+	CFG_GATE(GATE_USBH,		RCC_AHB6ENSETR, 24),
+	CFG_GATE(GATE_CRC1,		RCC_AHB6ENSETR, 20),
+	CFG_GATE(GATE_SDMMC2,		RCC_AHB6ENSETR, 17),
+	CFG_GATE(GATE_SDMMC1,		RCC_AHB6ENSETR, 16),
+	CFG_GATE(GATE_QSPI,		RCC_AHB6ENSETR, 14),
+	CFG_GATE(GATE_FMC,		RCC_AHB6ENSETR, 12),
+	CFG_GATE(GATE_ETHMAC,		RCC_AHB6ENSETR, 10),
+	CFG_GATE(GATE_ETHRX,		RCC_AHB6ENSETR, 9),
+	CFG_GATE(GATE_ETHTX,		RCC_AHB6ENSETR, 8),
+	CFG_GATE(GATE_ETHCK,		RCC_AHB6ENSETR, 7),
+	CFG_GATE(GATE_GPU,		RCC_AHB6ENSETR, 5),
+	CFG_GATE(GATE_MDMA,		RCC_AHB6ENSETR, 0),
+	CFG_GATE(GATE_ETHSTP,		RCC_AHB6LPENSETR, 11),
+};
+
+enum enum_mux_cfg {
+	MUX_MPU,
+	MUX_AXI,
+	MUX_MCU,
+	MUX_PLL12,
+	MUX_PLL3,
+	MUX_PLL4,
+	MUX_CKPER,
+	MUX_RTC,
+	MUX_SDMMC12,
+	MUX_SDMMC3,
+	MUX_FMC,
+	MUX_QSPI,
+	MUX_RNG1,
+	MUX_RNG2,
+	MUX_USBPHY,
+	MUX_USBO,
+	MUX_STGEN,
+	MUX_SPDIF,
+	MUX_SPI1,
+	MUX_SPI23,
+	MUX_SPI45,
+	MUX_SPI6,
+	MUX_CEC,
+	MUX_I2C12,
+	MUX_I2C35,
+	MUX_I2C46,
+	MUX_LPTIM1,
+	MUX_LPTIM23,
+	MUX_LPTIM45,
+	MUX_USART1,
+	MUX_UART24,
+	MUX_UART35,
+	MUX_USART6,
+	MUX_UART78,
+	MUX_SAI1,
+	MUX_SAI2,
+	MUX_SAI3,
+	MUX_SAI4,
+	MUX_DSI,
+	MUX_FDCAN,
+	MUX_ADC12,
+	MUX_ETHCK,
+	MUX_MCO1,
+	MUX_MCO2,
+};
+
+struct cs_mux_cfg {
+	u16	offset;
+	u8	shift;
+	u8	width;
+	u8	flags;
+	u32	*table;
+};
+
+#define CFG_MUX(_id, _offset, _shift, _witdh, _flags)\
+	[_id] = {\
+		.offset = (_offset),\
+		.shift = (_shift),\
+		.width = (_witdh),\
+		.flags = (_flags),\
+	}
+
+static const struct cs_mux_cfg stm32mp15_muxes[] = {
+	CFG_MUX(MUX_PLL12,	RCC_RCK12SELR, 0, 2, 0),
+	CFG_MUX(MUX_PLL3,	RCC_RCK3SELR, 0, 2, 0),
+	CFG_MUX(MUX_PLL4,	RCC_RCK4SELR, 0, 2, 0),
+	CFG_MUX(MUX_CKPER,	RCC_CPERCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_MPU,	RCC_MPCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_AXI,	RCC_ASSCKSELR, 0, 3, 0),
+	CFG_MUX(MUX_MCU,	RCC_MSSCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_RTC,	RCC_BDCR, 16, 2, 0),
+	CFG_MUX(MUX_SDMMC12,	RCC_SDMMC12CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_SPI23,	RCC_SPI2S23CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_SPI45,	RCC_SPI2S45CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_I2C12,	RCC_I2C12CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_I2C35,	RCC_I2C35CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_LPTIM23,	RCC_LPTIM23CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_LPTIM45,	RCC_LPTIM45CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_UART24,	RCC_UART24CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_UART35,	RCC_UART35CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_UART78,	RCC_UART78CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_SAI1,	RCC_SAI1CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_ETHCK,	RCC_ETHCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_I2C46,	RCC_I2C46CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_RNG2,	RCC_RNG2CKSELR, 0, 2, 0),
+	CFG_MUX(MUX_SDMMC3,	RCC_SDMMC3CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_FMC,	RCC_FMCCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_QSPI,	RCC_QSPICKSELR, 0, 2, 0),
+	CFG_MUX(MUX_USBPHY,	RCC_USBCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_USBO,	RCC_USBCKSELR, 4, 1, 0),
+	CFG_MUX(MUX_SPDIF,	RCC_SPDIFCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_SPI1,	RCC_SPI2S1CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_CEC,	RCC_CECCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_LPTIM1,	RCC_LPTIM1CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_USART6,	RCC_UART6CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_FDCAN,	RCC_FDCANCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_SAI2,	RCC_SAI2CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_SAI3,	RCC_SAI3CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_SAI4,	RCC_SAI4CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_ADC12,	RCC_ADCCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_DSI,	RCC_DSICKSELR, 0, 1, 0),
+	CFG_MUX(MUX_RNG1,	RCC_RNG1CKSELR, 0, 2, 0),
+	CFG_MUX(MUX_STGEN,	RCC_STGENCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_USART1,	RCC_UART1CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_SPI6,	RCC_SPI6CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_MCO1,	RCC_MCO1CFGR, 0, 3, 0),
+	CFG_MUX(MUX_MCO2,	RCC_MCO2CFGR, 0, 3, 0),
+};
+
+enum enum_div_cfg {
+	DIV_PLL1DIVP,
+	DIV_PLL2DIVP,
+	DIV_PLL2DIVQ,
+	DIV_PLL2DIVR,
+	DIV_PLL3DIVP,
+	DIV_PLL3DIVQ,
+	DIV_PLL3DIVR,
+	DIV_PLL4DIVP,
+	DIV_PLL4DIVQ,
+	DIV_PLL4DIVR,
+	DIV_MPU,
+	DIV_AXI,
+	DIV_MCU,
+	DIV_APB1,
+	DIV_APB2,
+	DIV_APB3,
+	DIV_APB4,
+	DIV_APB5,
+	DIV_RTC,
+	DIV_HSI,
+	DIV_MCO1,
+	DIV_MCO2,
+	DIV_TRACE,
+	DIV_ETHPTP,
+	DIV_NB
+};
+
+struct cs_div_cfg {
+	u16	offset;
+	u8	shift;
+	u8	width;
+	u8	flags;
+	const struct clk_div_table *table;
+};
+
+#define CFG_DIV(_id, _offset, _shift, _width, _flags, _table)\
+	[(_id)] = {\
+		.offset = (_offset),\
+		.shift = (_shift),\
+		.width = (_width),\
+		.flags = (_flags),\
+		.table = (_table),\
+	}
+
+static const struct cs_div_cfg stm32mp15_dividers[DIV_NB] = {
+	CFG_DIV(DIV_MPU,	RCC_MPCKDIVR, 0, 4, 0, NULL),
+	CFG_DIV(DIV_AXI,	RCC_AXIDIVR, 0, 3, 0, axi_div_table),
+	CFG_DIV(DIV_MCU,	RCC_MCUDIVR, 0, 4, 0, mcu_div_table),
+	CFG_DIV(DIV_APB1,	RCC_APB1DIVR, 0, 3, 0, apb_div_table),
+	CFG_DIV(DIV_APB2,	RCC_APB2DIVR, 0, 3, 0, apb_div_table),
+	CFG_DIV(DIV_APB3,	RCC_APB3DIVR, 0, 3, 0, apb_div_table),
+	CFG_DIV(DIV_APB4,	RCC_APB4DIVR, 0, 3, 0, apb_div_table),
+	CFG_DIV(DIV_APB5,	RCC_APB5DIVR, 0, 3, 0, apb_div_table),
+	CFG_DIV(DIV_HSI,	RCC_HSICFGR, 0, 2, CLK_DIVIDER_POWER_OF_TWO, NULL),
+	CFG_DIV(DIV_PLL1DIVP,	RCC_PLL1CFGR2, 0, 7, 0, NULL),
+	CFG_DIV(DIV_PLL2DIVP,	RCC_PLL2CFGR2, 0, 7, 0, NULL),
+	CFG_DIV(DIV_PLL2DIVQ,	RCC_PLL2CFGR2, 8, 7, 0, NULL),
+	CFG_DIV(DIV_PLL2DIVR,	RCC_PLL2CFGR2, 16, 7, 0, NULL),
+	CFG_DIV(DIV_PLL3DIVP,	RCC_PLL3CFGR2, 0, 7, 0, NULL),
+	CFG_DIV(DIV_PLL3DIVQ,	RCC_PLL3CFGR2, 8, 7, 0, NULL),
+	CFG_DIV(DIV_PLL3DIVR,	RCC_PLL3CFGR2, 16, 7, 0, NULL),
+	CFG_DIV(DIV_PLL4DIVP,	RCC_PLL4CFGR2, 0, 7, 0, NULL),
+	CFG_DIV(DIV_PLL4DIVQ,	RCC_PLL4CFGR2, 8, 7, 0, NULL),
+	CFG_DIV(DIV_PLL4DIVR,	RCC_PLL4CFGR2, 16, 7, 0, NULL),
+	CFG_DIV(DIV_RTC,	RCC_RTCDIVR, 0, 6, 0, NULL),
+	CFG_DIV(DIV_MCO1,	RCC_MCO1CFGR, 4, 4, 0, NULL),
+	CFG_DIV(DIV_MCO2,	RCC_MCO2CFGR, 4, 4, 0, NULL),
+	CFG_DIV(DIV_TRACE,	RCC_DBGCFGR, 0, 3, 0, ck_trace_div_table),
+	CFG_DIV(DIV_ETHPTP,	RCC_ETHCKSELR, 4, 4, 0, NULL),
+};
+
+struct clk_stm32_clock_data {
+	const struct cs_gate_cfg *gates;
+	const struct cs_mux_cfg *muxes;
+	const struct cs_div_cfg *dividers;
+};
+
+struct clock_summary {
+	struct clk_summary *clocks;
+	int nb_clocks;
+	void __iomem *base;
+	struct clk_stm32_clock_data *clock_data;
+};
+
+struct clk_summary {
+	const char *name;
+	unsigned long rate;
+	int enabled;
+	int nb_parents;
+	int gate_id;
+	int mux_id;
+	int div_id;
+	void *data;
+	unsigned long (*get_rate)(struct clock_summary *cs,
+				  struct clk_summary *c,
+				  unsigned long parent_rate);
+	const char * const *parent_names;
+};
+
+static u8 clk_stm32_get_parent_mux(void __iomem *base,
+				   struct clk_stm32_clock_data *data,
+				   u16 mux_id)
+{
+	const struct cs_mux_cfg *mux = &data->muxes[mux_id];
+	u32 mask = BIT(mux->width) - 1;
+	u32 val;
+
+	val = readl(base + mux->offset) >> mux->shift;
+	val &= mask;
+
+	return val;
+}
+
+static int clk_stm32_is_enabled_gate(void __iomem *base,
+				     struct clk_stm32_clock_data *data,
+				     u16 gate_id)
+{
+	const struct cs_gate_cfg *gate = &data->gates[gate_id];
+
+	return (readl(base + gate->offset) & BIT(gate->bit_idx)) != 0;
+}
+
+static unsigned int _get_table_div(const struct clk_div_table *table,
+				   unsigned int val)
+{
+	const struct clk_div_table *clkt;
+
+	for (clkt = table; clkt->div; clkt++)
+		if (clkt->val == val)
+			return clkt->div;
+	return 0;
+}
+
+static unsigned int _get_div(const struct clk_div_table *table,
+			     unsigned int val, unsigned long flags, u8 width)
+{
+	if (flags & CLK_DIVIDER_ONE_BASED)
+		return val;
+	if (flags & CLK_DIVIDER_POWER_OF_TWO)
+		return 1 << val;
+	if (table)
+		return _get_table_div(table, val);
+	return val + 1;
+}
+
+static unsigned long clk_stm32_get_rate_divider(void __iomem *base,
+						struct clk_stm32_clock_data *data,
+						u16 div_id,
+						unsigned long parent_rate)
+{
+	const struct cs_div_cfg *divider = &data->dividers[div_id];
+	unsigned int val;
+	unsigned int div;
+
+	val =  readl(base + divider->offset) >> divider->shift;
+	val &= clk_div_mask(divider->width);
+	div = _get_div(divider->table, val, divider->flags, divider->width);
+
+	if (!div) {
+		WARN(!(divider->flags & CLK_DIVIDER_ALLOW_ZERO),
+		     "%d: Zero divisor and CLK_DIVIDER_ALLOW_ZERO not set\n", div_id);
+		return parent_rate;
+	}
+
+	return DIV_ROUND_UP_ULL((u64)parent_rate, div);
+}
+
+struct cs_pll {
+	u32 offset;
+};
+
+static unsigned long clk_summary_pll_frac_div_recalc_rate(struct clock_summary *cs,
+							  struct clk_summary *c,
+							  unsigned long parent_rate)
+{
+	struct cs_pll *pll = (struct cs_pll *)c->data;
+	struct clk_pll_fractional_divider fracdiv;
+	struct clk_pll_fractional_divider *fd = &fracdiv;
+	void __iomem *reg;
+	u32 mmask;
+	u32 nmask;
+	u32 fmask;
+	unsigned long m, n, f;
+	u64 rate, frate = 0;
+	u32 val;
+
+	reg = cs->base + pll->offset;
+	fd->mreg = reg + PLL_DIVMN_OFFSET;
+	fd->mshift = PLL_DIVM_SHIFT;
+	fd->mwidth = PLL_DIVM_WIDTH;
+	fd->mflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	fd->nreg = reg + PLL_DIVMN_OFFSET;
+	fd->nshift = PLL_DIVN_SHIFT;
+	fd->nwidth = PLL_DIVN_WIDTH;
+	fd->nflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	fd->freg = reg + PLL_FRAC_OFFSET;
+	fd->fshift = PLL_FRAC_SHIFT;
+	fd->fwidth = PLL_FRAC_WIDTH;
+
+	mmask = GENMASK(fd->mwidth - 1, 0) << fd->mshift;
+	nmask = GENMASK(fd->nwidth - 1, 0) << fd->nshift;
+	fmask = GENMASK(fd->fwidth - 1, 0) << fd->fshift;
+
+	val = readl(fd->mreg);
+	m = (val & mmask) >> fd->mshift;
+	if (fd->mflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		m++;
+
+	val = readl(fd->nreg);
+	n = (val & nmask) >> fd->nshift;
+	if (fd->nflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		n++;
+
+	if (!n || !m)
+		return parent_rate;
+
+	rate = (u64)parent_rate * n;
+	do_div(rate, m);
+
+	val = readl(fd->freg);
+	f = (val & fmask) >> fd->fshift;
+	if (f) {
+		frate = (u64)parent_rate * (u64)f;
+		do_div(frate, (m * (1 << fd->fwidth)));
+	}
+
+	return rate + frate;
+}
+
+static unsigned long clk_summary_hsediv2_recalc_rate(struct clock_summary *cs,
+						     struct clk_summary *c,
+						     unsigned long parent_rate)
+{
+	return parent_rate / 2;
+}
+
+static unsigned long clk_summary_osc_recalc_rate(struct clock_summary *cs,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	struct clk *clk = __clk_lookup(c->name);
+
+	if (clk)
+		return clk_get_rate(clk);
+
+	return 0;
+}
+
+static unsigned long clk_summary_div_recalc_rate(struct clock_summary *cs,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	return clk_stm32_get_rate_divider(cs->base, cs->clock_data, c->div_id, parent_rate);
+}
+
+static unsigned long clk_summary_rtc_recalc_rate(struct clock_summary *cs,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	u8 parent;
+
+	parent = clk_stm32_get_parent_mux(cs->base, cs->clock_data, c->mux_id);
+	if (parent == HSE_RTC)
+		return clk_summary_div_recalc_rate(cs, c, parent_rate);
+
+	return parent_rate;
+}
+
+struct cs_stm32_timer {
+	u32 apbdiv;
+	u32 timpre;
+};
+
+static unsigned long clk_stm32_timer_recalc_rate(struct clock_summary *cs,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	struct cs_stm32_timer *tim = (struct cs_stm32_timer *)c->data;
+	void __iomem *rcc_base = cs->base;
+	u32 prescaler, timpre;
+
+	prescaler = readl(rcc_base + tim->apbdiv) & APB_DIV_MASK;
+
+	timpre = readl(rcc_base + tim->timpre) & TIM_PRE_MASK;
+
+	if (prescaler == 0U)
+		return parent_rate;
+
+	return parent_rate * (timpre + 1U) * 2U;
+}
+
+#define CS_OSC(_name, _gate) \
+{\
+	.name		= _name,\
+	.nb_parents	= 0,\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+	.get_rate	= clk_summary_osc_recalc_rate,\
+}
+
+#define CS_DIV2(_name, _parent) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+	.get_rate	= clk_summary_hsediv2_recalc_rate,\
+}
+
+#define CS_PLL(_name, _parents, _gate, _mux, _offset)\
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= NO_STM32_DIV,\
+	.data		=  &(struct cs_pll) {\
+		.offset		= _offset,\
+	},\
+	.get_rate	= clk_summary_pll_frac_div_recalc_rate,\
+}
+
+#define CS_DIV(_name, _parent, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.div_id		= _div,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_MUX(_name, _parents, _mux) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.mux_id		= _mux,\
+	.gate_id	= NO_STM32_GATE,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_GATE(_name, _parent, _gate) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_GATEDIV(_name, _parent, _gate, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= _div,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_GATEMUX(_name, _parents, _gate, _mux) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_COMPOSITE(_name, _parents, _gate, _mux, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= _div,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_RTC(_name, _parents, _gate, _mux, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= _div,\
+	.get_rate	= clk_summary_rtc_recalc_rate,\
+}
+
+#define CS_STM32_TIMER(_name, _parent, _apbdiv, _timpre) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.div_id		= NO_STM32_DIV,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.data		=  &(struct cs_stm32_timer) {\
+		.apbdiv		= _apbdiv,\
+		.timpre		= _timpre,\
+	},\
+	.get_rate	= clk_stm32_timer_recalc_rate,\
+}
+
+static struct clk_summary stm32mp15_clock_summary[] = {
+	CS_OSC("ck_hsi", GATE_HSI),
+	CS_OSC("ck_csi", GATE_CSI),
+	CS_OSC("ck_lsi", GATE_LSI),
+	CS_OSC("ck_hse", GATE_HSE),
+	CS_OSC("ck_lse", GATE_LSE),
+	CS_OSC("ck_usbo_48m", NO_STM32_GATE),
+	CS_DIV2("clk-hse-div2", "ck_hse"),
+	CS_MUX("ck_per", per_src, MUX_CKPER),
+
+	CS_PLL("pll1", ref12_parents, GATE_PLL1, MUX_PLL12, RCC_PLL1CR),
+	CS_GATEDIV("pll1_p", "pll1", GATE_PLL1_DIVP, DIV_PLL1DIVP),
+
+	CS_DIV("pll1_p_div", "pll1_p", DIV_MPU),
+
+	CS_PLL("pll2", ref12_parents, GATE_PLL2, MUX_PLL12, RCC_PLL2CR),
+	CS_GATEDIV("pll2_p", "pll2", GATE_PLL2_DIVP, DIV_PLL2DIVP),
+	CS_GATEDIV("pll2_q", "pll2", GATE_PLL2_DIVQ, DIV_PLL2DIVQ),
+	CS_GATEDIV("pll2_r", "pll2", GATE_PLL2_DIVR, DIV_PLL2DIVR),
+
+	CS_PLL("pll3", ref3_parents, GATE_PLL3, MUX_PLL3, RCC_PLL3CR),
+	CS_GATEDIV("pll3_p", "pll3", GATE_PLL3_DIVP, DIV_PLL3DIVP),
+	CS_GATEDIV("pll3_q", "pll3", GATE_PLL3_DIVQ, DIV_PLL3DIVQ),
+	CS_GATEDIV("pll3_r", "pll3", GATE_PLL3_DIVR, DIV_PLL3DIVR),
+
+	CS_PLL("pll4", ref4_parents, GATE_PLL4, MUX_PLL4, RCC_PLL4CR),
+	CS_GATEDIV("pll4_p", "pll4", GATE_PLL4_DIVP, DIV_PLL4DIVP),
+	CS_GATEDIV("pll4_q", "pll4", GATE_PLL4_DIVQ, DIV_PLL4DIVQ),
+	CS_GATEDIV("pll4_r", "pll4", GATE_PLL4_DIVR, DIV_PLL4DIVR),
+
+	CS_MUX("ck_mpu", cpu_src, MUX_MPU),
+	CS_MUX("ck_axi", axi_src, MUX_AXI),
+	CS_MUX("ck_mcu", mcu_src, MUX_MCU),
+
+	CS_DIV("pclk1", "ck_mcu", DIV_APB1),
+	CS_DIV("pclk2", "ck_mcu", DIV_APB2),
+	CS_DIV("pclk3", "ck_mcu", DIV_APB3),
+	CS_DIV("pclk4", "ck_axi", DIV_APB4),
+	CS_DIV("pclk5", "ck_axi", DIV_APB5),
+
+	CS_STM32_TIMER("ck1_tim", "pclk1", RCC_APB1DIVR, RCC_TIMG1PRER),
+	CS_STM32_TIMER("ck2_tim", "pclk2", RCC_APB2DIVR, RCC_TIMG2PRER),
+
+	CS_GATE("tim2_k", "ck1_tim", GATE_TIM2),
+	CS_GATE("tim3_k", "ck1_tim", GATE_TIM3),
+	CS_GATE("tim4_k", "ck1_tim", GATE_TIM4),
+	CS_GATE("tim5_k", "ck1_tim", GATE_TIM5),
+	CS_GATE("tim6_k", "ck1_tim", GATE_TIM6),
+	CS_GATE("tim7_k", "ck1_tim", GATE_TIM7),
+	CS_GATE("tim12_k", "ck1_tim", GATE_TIM12),
+	CS_GATE("tim13_k", "ck1_tim", GATE_TIM13),
+	CS_GATE("tim14_k", "ck1_tim", GATE_TIM14),
+	CS_GATE("tim1_k", "ck2_tim", GATE_TIM1),
+	CS_GATE("tim8_k", "ck2_tim", GATE_TIM8),
+	CS_GATE("tim15_k", "ck2_tim", GATE_TIM15),
+	CS_GATE("tim16_k", "ck2_tim", GATE_TIM16),
+	CS_GATE("tim17_k", "ck2_tim", GATE_TIM17),
+
+	CS_GATE("tim2", "pclk1", GATE_TIM2),
+	CS_GATE("tim3", "pclk1", GATE_TIM3),
+	CS_GATE("tim4", "pclk1", GATE_TIM4),
+	CS_GATE("tim5", "pclk1", GATE_TIM5),
+	CS_GATE("tim6", "pclk1", GATE_TIM6),
+	CS_GATE("tim7", "pclk1", GATE_TIM7),
+	CS_GATE("tim12", "pclk1", GATE_TIM12),
+	CS_GATE("tim13", "pclk1", GATE_TIM13),
+	CS_GATE("tim14", "pclk1", GATE_TIM14),
+	CS_GATE("lptim1", "pclk1", GATE_LPTIM1),
+	CS_GATE("spi2", "pclk1", GATE_SPI2),
+	CS_GATE("spi3", "pclk1", GATE_SPI3),
+	CS_GATE("usart2", "pclk1", GATE_USART2),
+	CS_GATE("usart3", "pclk1", GATE_USART3),
+	CS_GATE("uart4", "pclk1", GATE_UART4),
+	CS_GATE("uart5", "pclk1", GATE_UART5),
+	CS_GATE("uart7", "pclk1", GATE_UART7),
+	CS_GATE("uart8", "pclk1", GATE_UART8),
+	CS_GATE("i2c1", "pclk1", GATE_I2C1),
+	CS_GATE("i2c2", "pclk1", GATE_I2C2),
+	CS_GATE("i2c3", "pclk1", GATE_I2C3),
+	CS_GATE("i2c5", "pclk1", GATE_I2C5),
+	CS_GATE("spdif", "pclk1", GATE_SPDIF),
+	CS_GATE("cec", "pclk1", GATE_CEC),
+	CS_GATE("dac12", "pclk1", GATE_DAC12),
+	CS_GATE("mdio", "pclk1", GATE_MDIO),
+	CS_GATE("tim1", "pclk2", GATE_TIM1),
+	CS_GATE("tim8", "pclk2", GATE_TIM8),
+	CS_GATE("tim15", "pclk2", GATE_TIM15),
+	CS_GATE("tim16", "pclk2", GATE_TIM16),
+	CS_GATE("tim17", "pclk2", GATE_TIM17),
+	CS_GATE("spi1", "pclk2", GATE_SPI1),
+	CS_GATE("spi4", "pclk2", GATE_SPI4),
+	CS_GATE("spi5", "pclk2", GATE_SPI5),
+	CS_GATE("usart6", "pclk2", GATE_USART6),
+	CS_GATE("sai1", "pclk2", GATE_SAI1),
+	CS_GATE("sai2", "pclk2", GATE_SAI2),
+	CS_GATE("sai3", "pclk2", GATE_SAI3),
+	CS_GATE("dfsdm", "pclk2", GATE_DFSDM),
+	CS_GATE("fdcan", "pclk2", GATE_FDCAN),
+	CS_GATE("lptim2", "pclk3", GATE_LPTIM2),
+	CS_GATE("lptim3", "pclk3", GATE_LPTIM3),
+	CS_GATE("lptim4", "pclk3", GATE_LPTIM4),
+	CS_GATE("lptim5", "pclk3", GATE_LPTIM5),
+	CS_GATE("sai4", "pclk3", GATE_SAI4),
+	CS_GATE("syscfg", "pclk3", GATE_SYSCFG),
+	CS_GATE("vref", "pclk3", GATE_VREF),
+	CS_GATE("tmpsens", "pclk3", GATE_TMPSENS),
+	CS_GATE("pmbctrl", "pclk3", GATE_PMBCTRL),
+	CS_GATE("hdp", "pclk3", GATE_HDP),
+	CS_GATE("ltdc", "pclk4", GATE_LTDC),
+	CS_GATE("dsi", "pclk4", GATE_DSI),
+	CS_GATE("iwdg2", "pclk4", GATE_IWDG2),
+	CS_GATE("usbphy", "pclk4", GATE_USBPHY),
+	CS_GATE("stgenro", "pclk4", GATE_STGENRO),
+	CS_GATE("spi6", "pclk5", GATE_SPI6),
+	CS_GATE("i2c4", "pclk5", GATE_I2C4),
+	CS_GATE("i2c6", "pclk5", GATE_I2C6),
+	CS_GATE("usart1", "pclk5", GATE_USART1),
+	CS_GATE("rtcapb", "pclk5", GATE_RTCAPB),
+	CS_GATE("tzc1", "ck_axi", GATE_TZC1),
+	CS_GATE("tzc2", "ck_axi", GATE_TZC2),
+	CS_GATE("tzpc", "pclk5", GATE_TZPC),
+	CS_GATE("iwdg1", "pclk5", GATE_IWDG1),
+	CS_GATE("bsec", "pclk5", GATE_BSEC),
+	CS_GATE("stgen", "pclk5", GATE_STGEN),
+	CS_GATE("dma1", "ck_mcu", GATE_DMA1),
+	CS_GATE("dma2", "ck_mcu", GATE_DMA2),
+	CS_GATE("dmamux", "ck_mcu", GATE_DMAMUX),
+	CS_GATE("adc12", "ck_mcu", GATE_ADC12),
+	CS_GATE("usbo", "ck_mcu", GATE_USBO),
+	CS_GATE("sdmmc3", "ck_mcu", GATE_SDMMC3),
+	CS_GATE("dcmi", "ck_mcu", GATE_DCMI),
+	CS_GATE("cryp2", "ck_mcu", GATE_CRYP2),
+	CS_GATE("hash2", "ck_mcu", GATE_HASH2),
+	CS_GATE("rng2", "ck_mcu", GATE_RNG2),
+	CS_GATE("crc2", "ck_mcu", GATE_CRC2),
+	CS_GATE("hsem", "ck_mcu", GATE_HSEM),
+	CS_GATE("ipcc", "ck_mcu", GATE_IPCC),
+	CS_GATE("gpioa", "ck_mcu", GATE_GPIOA),
+	CS_GATE("gpiob", "ck_mcu", GATE_GPIOB),
+	CS_GATE("gpioc", "ck_mcu", GATE_GPIOC),
+	CS_GATE("gpiod", "ck_mcu", GATE_GPIOD),
+	CS_GATE("gpioe", "ck_mcu", GATE_GPIOE),
+	CS_GATE("gpiof", "ck_mcu", GATE_GPIOF),
+	CS_GATE("gpiog", "ck_mcu", GATE_GPIOG),
+	CS_GATE("gpioh", "ck_mcu", GATE_GPIOH),
+	CS_GATE("gpioi", "ck_mcu", GATE_GPIOI),
+	CS_GATE("gpioj", "ck_mcu", GATE_GPIOJ),
+	CS_GATE("gpiok", "ck_mcu", GATE_GPIOK),
+	CS_GATE("gpioz", "ck_axi", GATE_GPIOZ),
+	CS_GATE("cryp1", "ck_axi", GATE_CRYP1),
+	CS_GATE("hash1", "ck_axi", GATE_HASH1),
+	CS_GATE("rng1", "ck_axi", GATE_RNG1),
+	CS_GATE("bkpsram", "ck_axi", GATE_BKPSRAM),
+	CS_GATE("mdma", "ck_axi", GATE_MDMA),
+	CS_GATE("gpu", "ck_axi", GATE_GPU),
+	CS_GATE("ethtx", "ck_axi", GATE_ETHTX),
+	CS_GATE("ethrx", "ck_axi", GATE_ETHRX),
+	CS_GATE("ethmac", "ck_axi", GATE_ETHMAC),
+	CS_GATE("crc1", "ck_axi", GATE_CRC1),
+	CS_GATE("usbh", "ck_axi", GATE_USBH),
+	CS_GATE("ethstp", "ck_axi", GATE_ETHSTP),
+	CS_GATE("ddrperfm", "pclk4", GATE_DDRPERFM),
+
+	CS_GATEMUX("sdmmc1_k", sdmmc12_src, GATE_SDMMC1, MUX_SDMMC12),
+	CS_GATEMUX("sdmmc2_k", sdmmc12_src, GATE_SDMMC2, MUX_SDMMC12),
+	CS_GATEMUX("sdmmc3_k", sdmmc3_src, GATE_SDMMC3, MUX_SDMMC3),
+	CS_GATEMUX("fmc_k", fmc_src, GATE_FMC, MUX_FMC),
+	CS_GATEMUX("qspi_k", qspi_src, GATE_QSPI, MUX_QSPI),
+	CS_GATEMUX("rng1_k", rng_src, GATE_RNG1, MUX_RNG1),
+	CS_GATEMUX("rng2_k", rng_src, GATE_RNG2, MUX_RNG2),
+	CS_GATEMUX("usbphy_k", usbphy_src, GATE_USBPHY, MUX_USBPHY),
+	CS_GATEMUX("stgen_k", stgen_src, GATE_STGEN, MUX_STGEN),
+	CS_GATEMUX("spdif_k", spdif_src, GATE_SPDIF, MUX_SPDIF),
+	CS_GATEMUX("spi1_k", spi123_src, GATE_SPI1, MUX_SPI1),
+	CS_GATEMUX("spi2_k", spi123_src, GATE_SPI2, MUX_SPI23),
+	CS_GATEMUX("spi3_k", spi123_src, GATE_SPI3, MUX_SPI23),
+	CS_GATEMUX("spi4_k", spi45_src, GATE_SPI4, MUX_SPI45),
+	CS_GATEMUX("spi5_k", spi45_src, GATE_SPI5, MUX_SPI45),
+	CS_GATEMUX("spi6_k", spi6_src, GATE_SPI6, MUX_SPI6),
+	CS_GATEMUX("cec_k", cec_src, GATE_CEC, MUX_CEC),
+	CS_GATEMUX("i2c1_k", i2c12_src, GATE_I2C1, MUX_I2C12),
+	CS_GATEMUX("i2c2_k", i2c12_src, GATE_I2C2, MUX_I2C12),
+	CS_GATEMUX("i2c3_k", i2c35_src, GATE_I2C3, MUX_I2C35),
+	CS_GATEMUX("i2c5_k", i2c35_src, GATE_I2C5, MUX_I2C35),
+	CS_GATEMUX("i2c4_k", i2c46_src, GATE_I2C4, MUX_I2C46),
+	CS_GATEMUX("i2c6_k", i2c46_src, GATE_I2C6, MUX_I2C46),
+	CS_GATEMUX("lptim1_k", lptim1_src, GATE_LPTIM1, MUX_LPTIM1),
+	CS_GATEMUX("lptim2_k", lptim23_src, GATE_LPTIM2, MUX_LPTIM23),
+	CS_GATEMUX("lptim3_k", lptim23_src, GATE_LPTIM3, MUX_LPTIM23),
+	CS_GATEMUX("lptim4_k", lptim45_src, GATE_LPTIM4, MUX_LPTIM45),
+	CS_GATEMUX("lptim5_k", lptim45_src, GATE_LPTIM5, MUX_LPTIM45),
+	CS_GATEMUX("usart1_k", usart1_src, GATE_USART1, MUX_USART1),
+	CS_GATEMUX("usart2_k", usart234578_src, GATE_USART2, MUX_UART24),
+	CS_GATEMUX("usart3_k", usart234578_src, GATE_USART3, MUX_UART35),
+	CS_GATEMUX("uart4_k", usart234578_src, GATE_UART4, MUX_UART24),
+	CS_GATEMUX("uart5_k", usart234578_src, GATE_UART5, MUX_UART35),
+	CS_GATEMUX("uart6_k", usart6_src, GATE_USART6, MUX_USART6),
+	CS_GATEMUX("uart7_k", usart234578_src, GATE_UART7, MUX_UART78),
+	CS_GATEMUX("uart8_k", usart234578_src, GATE_UART8, MUX_UART78),
+	CS_GATEMUX("fdcan_k", fdcan_src, GATE_FDCAN, MUX_FDCAN),
+	CS_GATEMUX("sai1_k", sai_src, GATE_SAI1, MUX_SAI1),
+	CS_GATEMUX("sai2_k", sai2_src, GATE_SAI2, MUX_SAI2),
+	CS_GATEMUX("sai3_k", sai_src, GATE_SAI3, MUX_SAI3),
+	CS_GATEMUX("sai4_k", sai_src, GATE_SAI4, MUX_SAI4),
+	CS_GATEMUX("adc12_k", adc12_src, GATE_ADC12, MUX_ADC12),
+	CS_GATEMUX("dsi_k", dsi_src, GATE_DSI, MUX_DSI),
+	CS_GATEMUX("adfsdm_k", sai_src, GATE_ADFSDM, MUX_SAI1),
+	CS_GATEMUX("usbo_k", usbo_src, GATE_USBO, MUX_USBO),
+	CS_GATEMUX("ethck_k", eth_src, GATE_ETHCK, MUX_ETHCK),
+
+	CS_GATE("dfsdm_k", "ck_mcu", GATE_DFSDM),
+	CS_GATE("dsi_px", "pll4_q", GATE_DSI),
+	CS_GATE("ltdc_px", "pll4_q", GATE_LTDC),
+	CS_GATE("gpu_k", "pll2_q", GATE_GPU),
+	CS_GATE("dac12_k", "ck_lsi", GATE_DAC12),
+
+	CS_COMPOSITE("ck_mco1", mco1_src, GATE_MCO1, MUX_MCO1, DIV_MCO1),
+	CS_COMPOSITE("ck_mco2", mco2_src, GATE_MCO2, MUX_MCO2, DIV_MCO2),
+	CS_GATE("ck_sys_dbg", "ck_axi", GATE_DBGCK),
+
+	CS_COMPOSITE("ethptp_k", eth_src, NO_STM32_GATE, MUX_ETHCK, DIV_ETHPTP),
+
+	CS_RTC("ck_rtc", rtc_src, GATE_RTCCK, MUX_RTC, DIV_RTC),
+
+	CS_GATEDIV("ck_trace", "ck_axi", GATE_TRACECK, DIV_TRACE),
+};
+
+static void rcc_summary_show_one(struct seq_file *s, struct clk_summary *c,
+				 int level)
+{
+	char enabled;
+
+	seq_printf(s, "%*s%-*s %11lu ",
+		   level * 3 + 1, "",
+		   30 - level * 3,
+		   c->name,
+		   c->rate
+		);
+
+	switch (c->enabled) {
+	case 0:
+		enabled = 'N';
+		break;
+	case 1:
+		enabled = 'Y';
+		break;
+	default:
+		enabled = '?';
+		break;
+	}
+
+	seq_printf(s, " %9c\n", enabled);
+}
+
+static int clock_summary_clk_is_enabled(struct clock_summary *cs,
+					struct clk_summary *c)
+{
+	return clk_stm32_is_enabled_gate(cs->base, cs->clock_data, c->gate_id);
+}
+
+static const char *clock_summary_get_parent_name(struct clock_summary *cs,
+						 struct clk_summary *c)
+{
+	int id = 0;
+
+	if (c->nb_parents == 0)
+		return NULL;
+
+	if (c->nb_parents > 1)
+		id = clk_stm32_get_parent_mux(cs->base, cs->clock_data, c->mux_id);
+
+	return c->parent_names[id];
+}
+
+static void rcc_summary_show_subtree(struct seq_file *s, struct clk_summary *c,
+				     unsigned long parent_rate, int level)
+{
+	struct clock_summary *cs = (struct clock_summary *)s->private;
+	int i;
+
+	if (c->get_rate)
+		c->rate = c->get_rate(cs, c, parent_rate);
+	else
+		c->rate = parent_rate;
+
+	c->enabled = -1;
+	if (c->gate_id != NO_STM32_GATE)
+		c->enabled = clock_summary_clk_is_enabled(cs, c);
+
+	rcc_summary_show_one(s, c, level);
+
+	for (i = 0; i < cs->nb_clocks; i++) {
+		struct clk_summary *child = &cs->clocks[i];
+		const char *parent_name = clock_summary_get_parent_name(cs, child);
+
+		if (!parent_name)
+			continue;
+
+		if (!strcmp(c->name, parent_name))
+			rcc_summary_show_subtree(s, child, c->rate, level + 1);
+	}
+}
+
+static int rcc_summary_show(struct seq_file *s, void *data)
+{
+	struct clock_summary *cs = (struct clock_summary *)s->private;
+	int i;
+
+	seq_puts(s, "                                              hardware\n");
+	seq_puts(s, "   clock                               rate     enable\n");
+	seq_puts(s, "------------------------------------------------------\n");
+
+	for (i = 0; i < cs->nb_clocks; i++) {
+		struct clk_summary *c = &cs->clocks[i];
+
+		if (c->nb_parents == 0)
+			rcc_summary_show_subtree(s, c, 0, 0);
+	}
+
+	return 0;
+}
+
+DEFINE_SHOW_ATTRIBUTE(rcc_summary);
+
+struct clk_stm32_clock_data stm32mp15_clock_data = {
+	.gates		= stm32mp15_gates,
+	.muxes		= stm32mp15_muxes,
+	.dividers	= stm32mp15_dividers,
+};
+
+static struct clock_summary clock_summary_mp15 = {
+	.clocks		= stm32mp15_clock_summary,
+	.nb_clocks	= ARRAY_SIZE(stm32mp15_clock_summary),
+	.clock_data	= &stm32mp15_clock_data,
+};
+
+static void stm32_clk_summary_debugfs_create(struct device *dev, void __iomem *base)
+{
+	struct dentry *rootdir = debugfs_lookup("clk", NULL);
+
+	clock_summary_mp15.base = base;
+
+	debugfs_create_file("stm32_clk_summary", 0444, rootdir,
+			    &clock_summary_mp15, &rcc_summary_fops);
+}
+
+#else
+
+static void stm32_clk_summary_debugfs_create(struct device *dev, void __iomem *base)
+{
+}
+
+#endif
diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 0674dbc62..a4ef50666 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1781,6 +1781,7 @@ static void clk_reparent(struct clk_core *core, struct clk_core *new_parent)
 	core->parent = new_parent;
 }
 
+static const struct clk_ops clk_nodrv_ops;
 static struct clk_core *__clk_set_parent_before(struct clk_core *core,
 					   struct clk_core *parent)
 {
@@ -1809,7 +1810,8 @@ static struct clk_core *__clk_set_parent_before(struct clk_core *core,
 
 	/* enable old_parent & parent if CLK_OPS_PARENT_ENABLE is set */
 	if (core->flags & CLK_OPS_PARENT_ENABLE) {
-		clk_core_prepare_enable(old_parent);
+		if (old_parent && old_parent->ops != &clk_nodrv_ops)
+			clk_core_prepare_enable(old_parent);
 		clk_core_prepare_enable(parent);
 	}
 
@@ -1843,7 +1845,8 @@ static void __clk_set_parent_after(struct clk_core *core,
 	/* re-balance ref counting if CLK_OPS_PARENT_ENABLE is set */
 	if (core->flags & CLK_OPS_PARENT_ENABLE) {
 		clk_core_disable_unprepare(parent);
-		clk_core_disable_unprepare(old_parent);
+		if (old_parent && old_parent->ops != &clk_nodrv_ops)
+			clk_core_disable_unprepare(old_parent);
 	}
 }
 
diff --git a/drivers/clk/stm32/Makefile b/drivers/clk/stm32/Makefile
new file mode 100644
index 000000000..e5aa0ef30
--- /dev/null
+++ b/drivers/clk/stm32/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_COMMON_CLK_STM32MP135)	+= clk-stm32mp13.o clk-stm32-core.o reset-stm32.o
+obj-$(CONFIG_COMMON_CLK_STM32MP257)	+= clk-stm32mp2.o clk-stm32-core.o reset-stm32.o
diff --git a/drivers/clk/stm32/clk-stm32-core.c b/drivers/clk/stm32/clk-stm32-core.c
new file mode 100644
index 000000000..e1467cfeb
--- /dev/null
+++ b/drivers/clk/stm32/clk-stm32-core.c
@@ -0,0 +1,864 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@foss.st.com> for STMicroelectronics.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+
+#include "clk-stm32-core.h"
+#include "reset-stm32.h"
+
+static DEFINE_SPINLOCK(rlock);
+
+static void stm32_clk_summary_debugfs_create(struct device *dev,
+					     const struct stm32_rcc_match_data *data);
+
+static int stm32_rcc_clock_init(struct device *dev,
+				const struct of_device_id *match,
+				void __iomem *base)
+{
+	const struct stm32_rcc_match_data *data = match->data;
+	struct clk_hw_onecell_data *clk_data = data->hw_clks;
+	struct clk_hw **hws;
+	int n, max_binding;
+	int ret;
+
+	max_binding =  data->maxbinding;
+
+	clk_data = devm_kzalloc(dev, struct_size(clk_data, hws, max_binding),
+				GFP_KERNEL);
+	if (!clk_data)
+		return -ENOMEM;
+
+	data->clock_data->base = base;
+
+	clk_data->num = max_binding;
+
+	hws = clk_data->hws;
+
+	for (n = 0; n < max_binding; n++)
+		hws[n] = ERR_PTR(-ENOENT);
+
+	for (n = 0; n < data->num_clocks; n++) {
+		const struct clock_config *cfg_clock = &data->tab_clocks[n];
+		struct clk_hw *hw = ERR_PTR(-ENOENT);
+
+		if (data->check_security &&
+		    data->check_security(base, cfg_clock))
+			continue;
+
+		if (cfg_clock->func)
+			hw = (*cfg_clock->func)(dev, data, base, &rlock,
+						cfg_clock);
+
+		if (IS_ERR(hw)) {
+			dev_err(dev, "Can't register clk %d: %ld\n", n,
+				PTR_ERR(hw));
+			return PTR_ERR(hw);
+		}
+
+		if (cfg_clock->id < NO_ID)
+			hws[cfg_clock->id] = hw;
+	}
+
+	ret = of_clk_add_hw_provider(dev_of_node(dev), of_clk_hw_onecell_get, clk_data);
+	if (ret)
+		return ret;
+
+	if (data->clock_summary)
+		stm32_clk_summary_debugfs_create(dev, data);
+
+	return ret;
+}
+
+int stm32_rcc_init(struct device *dev, const struct of_device_id *match_data,
+		   void __iomem *base)
+{
+	const struct of_device_id *match;
+	int err;
+
+	match = of_match_node(match_data, dev_of_node(dev));
+	if (!match) {
+		dev_err(dev, "match data not found\n");
+		return -ENODEV;
+	}
+
+	/* RCC Reset Configuration */
+	err = stm32_rcc_reset_init(dev, match, base);
+	if (err) {
+		pr_err("stm32mp1 reset failed to initialize\n");
+		return err;
+	}
+
+	/* RCC Clock Configuration */
+	err = stm32_rcc_clock_init(dev, match, base);
+	if (err) {
+		pr_err("stm32mp1 clock failed to initialize\n");
+		return err;
+	}
+
+	return 0;
+}
+
+void clk_stm32_endisable_gate(void __iomem *base,
+			      struct clk_stm32_clock_data *data,
+			      u16 gate_id, int enable)
+{
+	const struct stm32_gate_cfg *gate = &data->gates[gate_id];
+	void __iomem *addr = base + gate->offset;
+
+	if (enable) {
+		if (data->gate_cpt[gate_id]++ > 0)
+			return;
+
+		if (gate->set_clr != 0)
+			writel(BIT(gate->bit_idx), addr);
+		else
+			writel(readl(addr) | BIT(gate->bit_idx), addr);
+	} else {
+		if (--data->gate_cpt[gate_id] > 0)
+			return;
+
+		if (gate->set_clr != 0)
+			writel(BIT(gate->bit_idx), addr + gate->set_clr);
+		else
+			writel(readl(addr) & ~BIT(gate->bit_idx), addr);
+	}
+}
+
+static void clk_stm32_disable_unused_gate(void __iomem *base,
+					  struct clk_stm32_clock_data *data,
+					  u16 gate_id)
+{
+	const struct stm32_gate_cfg *gate = &data->gates[gate_id];
+	void __iomem *addr = base + gate->offset;
+
+	if (data->gate_cpt[gate_id] > 0)
+		return;
+
+	if (gate->set_clr != 0)
+		writel(BIT(gate->bit_idx), addr + gate->set_clr);
+	else
+		writel(readl(addr) & ~BIT(gate->bit_idx), addr);
+}
+
+int clk_stm32_is_enabled_gate(void __iomem *base,
+			      struct clk_stm32_clock_data *data,
+			      u16 gate_id)
+{
+	const struct stm32_gate_cfg *gate = &data->gates[gate_id];
+
+	return (readl(base + gate->offset) & BIT(gate->bit_idx)) != 0;
+}
+
+void clk_stm32_gate_endisable(struct clk_hw *hw, int enable)
+{
+	struct clk_stm32_gate *gate = to_clk_stm32_gate(hw);
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(gate->lock, flags);
+
+	clk_stm32_endisable_gate(gate->base, gate->clock_data,
+				 gate->gate_id, enable);
+
+	spin_unlock_irqrestore(gate->lock, flags);
+}
+
+int clk_stm32_gate_enable(struct clk_hw *hw)
+{
+	clk_stm32_gate_endisable(hw, 1);
+
+	return 0;
+}
+
+void clk_stm32_gate_disable(struct clk_hw *hw)
+{
+	clk_stm32_gate_endisable(hw, 0);
+}
+
+int clk_stm32_gate_is_enabled(struct clk_hw *hw)
+{
+	struct clk_stm32_gate *gate = to_clk_stm32_gate(hw);
+
+	return clk_stm32_is_enabled_gate(gate->base, gate->clock_data,
+					 gate->gate_id);
+}
+
+static void clk_stm32_gate_disable_unused(struct clk_hw *hw)
+{
+	struct clk_stm32_gate *gate = to_clk_stm32_gate(hw);
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(gate->lock, flags);
+
+	clk_stm32_disable_unused_gate(gate->base, gate->clock_data, gate->gate_id);
+
+	spin_unlock_irqrestore(gate->lock, flags);
+}
+
+const struct clk_ops clk_stm32_gate_ops = {
+	.enable		= clk_stm32_gate_enable,
+	.disable	= clk_stm32_gate_disable,
+	.is_enabled	= clk_stm32_gate_is_enabled,
+	.disable_unused	= clk_stm32_gate_disable_unused,
+};
+
+#define MUX_SAFE_POSITION 0
+
+static int clk_stm32_has_safe_mux(struct clk_hw *hw)
+{
+	struct clk_stm32_composite *composite = to_clk_stm32_composite(hw);
+	const struct stm32_mux_cfg *mux = &composite->clock_data->muxes[composite->mux_id];
+
+	return !!(mux->flags & MUX_SAFE);
+}
+
+static void clk_stm32_set_safe_position_mux(struct clk_hw *hw)
+{
+	struct clk_stm32_composite *composite = to_clk_stm32_composite(hw);
+
+	if (!clk_stm32_composite_is_enabled(hw)) {
+		unsigned long flags = 0;
+
+		if (composite->clock_data->is_multi_mux) {
+			struct clk_hw *other_mux_hw = NULL;
+
+			other_mux_hw = composite->clock_data->is_multi_mux(hw);
+
+			if (!other_mux_hw || clk_stm32_composite_is_enabled(other_mux_hw))
+				return;
+		}
+
+		spin_lock_irqsave(composite->lock, flags);
+
+		clk_stm32_set_parent_mux(composite->base, composite->clock_data,
+					 composite->mux_id, MUX_SAFE_POSITION);
+
+		spin_unlock_irqrestore(composite->lock, flags);
+	}
+}
+
+static void clk_stm32_safe_restore_position_mux(struct clk_hw *hw)
+{
+	struct clk_stm32_composite *composite = to_clk_stm32_composite(hw);
+	int sel = clk_hw_get_parent_index(hw);
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(composite->lock, flags);
+
+	clk_stm32_set_parent_mux(composite->base, composite->clock_data,
+				 composite->mux_id, sel);
+
+	spin_unlock_irqrestore(composite->lock, flags);
+}
+
+void clk_stm32_composite_gate_endisable(struct clk_hw *hw, int enable)
+{
+	struct clk_stm32_composite *composite = to_clk_stm32_composite(hw);
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(composite->lock, flags);
+
+	clk_stm32_endisable_gate(composite->base, composite->clock_data,
+				 composite->gate_id, enable);
+
+	spin_unlock_irqrestore(composite->lock, flags);
+}
+
+int clk_stm32_composite_gate_enable(struct clk_hw *hw)
+{
+	struct clk_stm32_composite *composite = to_clk_stm32_composite(hw);
+
+	if (composite->gate_id == NO_STM32_GATE)
+		return 0;
+
+	clk_stm32_composite_gate_endisable(hw, 1);
+
+	if (composite->mux_id != NO_STM32_MUX && clk_stm32_has_safe_mux(hw))
+		clk_stm32_safe_restore_position_mux(hw);
+
+	return 0;
+}
+
+void clk_stm32_composite_gate_disable(struct clk_hw *hw)
+{
+	struct clk_stm32_composite *composite = to_clk_stm32_composite(hw);
+
+	if (composite->gate_id == NO_STM32_GATE)
+		return;
+
+	clk_stm32_composite_gate_endisable(hw, 0);
+
+	if (composite->mux_id != NO_STM32_MUX && clk_stm32_has_safe_mux(hw))
+		clk_stm32_set_safe_position_mux(hw);
+}
+
+int clk_stm32_composite_is_enabled(struct clk_hw *hw)
+{
+	struct clk_stm32_composite *composite = to_clk_stm32_composite(hw);
+
+	if (composite->gate_id == NO_STM32_GATE)
+		return (__clk_get_enable_count(hw->clk) > 0);
+
+	return clk_stm32_is_enabled_gate(composite->base, composite->clock_data,
+					 composite->gate_id);
+}
+
+static void clk_stm32_composite_disable_unused(struct clk_hw *hw)
+{
+	struct clk_stm32_composite *composite = to_clk_stm32_composite(hw);
+	unsigned long flags = 0;
+
+	if (composite->gate_id == NO_STM32_GATE)
+		return;
+
+	spin_lock_irqsave(composite->lock, flags);
+
+	clk_stm32_disable_unused_gate(composite->base, composite->clock_data,
+				      composite->gate_id);
+
+	spin_unlock_irqrestore(composite->lock, flags);
+}
+
+u8 clk_stm32_get_parent_mux(void __iomem *base,
+			    struct clk_stm32_clock_data *data, u16 mux_id)
+{
+	const struct stm32_mux_cfg *mux = &data->muxes[mux_id];
+	u32 mask = BIT(mux->width) - 1;
+	u32 val;
+
+	val = readl(base + mux->offset) >> mux->shift;
+	val &= mask;
+
+	return val;
+}
+
+int clk_stm32_set_parent_mux(void __iomem *base,
+			     struct clk_stm32_clock_data *data,
+			     u16 mux_id, u8 index)
+{
+	const struct stm32_mux_cfg *mux = &data->muxes[mux_id];
+
+	u32 mask = BIT(mux->width) - 1;
+	u32 reg = readl(base + mux->offset);
+	u32 val = index << mux->shift;
+
+	reg &= ~(mask << mux->shift);
+	reg |= val;
+
+	writel(reg, base + mux->offset);
+
+	return 0;
+}
+
+u8 clk_stm32_composite_get_parent(struct clk_hw *hw)
+{
+	struct clk_stm32_composite *composite = to_clk_stm32_composite(hw);
+
+	return clk_stm32_get_parent_mux(composite->base, composite->clock_data,
+					composite->mux_id);
+}
+
+int clk_stm32_composite_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct clk_stm32_composite *composite = to_clk_stm32_composite(hw);
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(composite->lock, flags);
+
+	clk_stm32_set_parent_mux(composite->base, composite->clock_data,
+				 composite->mux_id, index);
+
+	spin_unlock_irqrestore(composite->lock, flags);
+
+	if (composite->clock_data->is_multi_mux) {
+		struct clk_hw *other_mux_hw = composite->clock_data->is_multi_mux(hw);
+
+		if (other_mux_hw) {
+			struct clk_hw *hwp = clk_hw_get_parent_by_index(hw, index);
+
+			clk_hw_reparent(other_mux_hw, hwp);
+		}
+	}
+	return 0;
+}
+
+static unsigned int _get_table_div(const struct clk_div_table *table,
+				   unsigned int val)
+{
+	const struct clk_div_table *clkt;
+
+	for (clkt = table; clkt->div; clkt++)
+		if (clkt->val == val)
+			return clkt->div;
+	return 0;
+}
+
+static unsigned int _get_div(const struct clk_div_table *table,
+			     unsigned int val, unsigned long flags, u8 width)
+{
+	if (flags & CLK_DIVIDER_ONE_BASED)
+		return val;
+	if (flags & CLK_DIVIDER_POWER_OF_TWO)
+		return 1 << val;
+	if (table)
+		return _get_table_div(table, val);
+	return val + 1;
+}
+
+unsigned long clk_stm32_get_rate_divider(void __iomem *base,
+					 struct clk_stm32_clock_data *data,
+					 u16 div_id, unsigned long parent_rate)
+{
+	const struct stm32_div_cfg *divider = &data->dividers[div_id];
+	unsigned int val;
+	unsigned int div;
+
+	val =  readl(base + divider->offset) >> divider->shift;
+	val &= clk_div_mask(divider->width);
+	div = _get_div(divider->table, val, divider->flags, divider->width);
+
+	if (!div) {
+		WARN(!(divider->flags & CLK_DIVIDER_ALLOW_ZERO),
+		     "%d: Zero divisor and CLK_DIVIDER_ALLOW_ZERO not set\n",
+		     div_id);
+		return parent_rate;
+	}
+
+	return DIV_ROUND_UP_ULL((u64)parent_rate, div);
+}
+
+unsigned long clk_stm32_composite_recalc_rate(struct clk_hw *hw,
+					      unsigned long parent_rate)
+{
+	struct clk_stm32_composite *composite = to_clk_stm32_composite(hw);
+
+	if (composite->div_id == NO_STM32_DIV)
+		return parent_rate;
+
+	return clk_stm32_get_rate_divider(composite->base,
+					  composite->clock_data,
+					  composite->div_id,
+					  parent_rate);
+}
+
+int clk_stm32_set_rate_divider(void __iomem *base,
+			       struct clk_stm32_clock_data *data,
+			       u16 div_id,
+			       unsigned long rate,
+			       unsigned long parent_rate)
+{
+	const struct stm32_div_cfg *divider = &data->dividers[div_id];
+	int value;
+	u32 val;
+
+	value = divider_get_val(rate, parent_rate, divider->table,
+				divider->width, divider->flags);
+	if (value < 0)
+		return value;
+
+	if (divider->flags & CLK_DIVIDER_HIWORD_MASK) {
+		val = clk_div_mask(divider->width) << (divider->shift + 16);
+	} else {
+		val = readl(base + divider->offset);
+		val &= ~(clk_div_mask(divider->width) << divider->shift);
+	}
+
+	val |= (u32)value << divider->shift;
+
+	writel(val, base + divider->offset);
+
+	return 0;
+}
+
+int clk_stm32_composite_set_rate(struct clk_hw *hw, unsigned long rate,
+				 unsigned long parent_rate)
+{
+	struct clk_stm32_composite *composite = to_clk_stm32_composite(hw);
+	unsigned long flags = 0;
+	int ret;
+
+	if (composite->div_id == NO_STM32_DIV)
+		return rate;
+
+	spin_lock_irqsave(composite->lock, flags);
+
+	ret = clk_stm32_set_rate_divider(composite->base, composite->clock_data,
+					 composite->div_id, rate, parent_rate);
+
+	spin_unlock_irqrestore(composite->lock, flags);
+
+	return ret;
+}
+
+long clk_stm32_composite_round_rate(struct clk_hw *hw, unsigned long rate,
+				    unsigned long *prate)
+{
+	struct clk_stm32_composite *composite = to_clk_stm32_composite(hw);
+
+	const struct stm32_div_cfg *divider;
+
+	if (composite->div_id == NO_STM32_DIV)
+		return rate;
+
+	divider = &composite->clock_data->dividers[composite->div_id];
+
+	/* if read only, just return current value */
+	if (divider->flags & CLK_DIVIDER_READ_ONLY) {
+		u32 val;
+
+		val =  readl(composite->base + divider->offset) >> divider->shift;
+		val &= clk_div_mask(divider->width);
+
+		return divider_ro_round_rate(hw, rate, prate, divider->table,
+				divider->width, divider->flags,
+				val);
+	}
+
+	return divider_round_rate_parent(hw, clk_hw_get_parent(hw),
+					 rate, prate, divider->table,
+					 divider->width, divider->flags);
+}
+
+const struct clk_ops clk_stm32_composite_ops = {
+	.set_rate	= clk_stm32_composite_set_rate,
+	.recalc_rate	= clk_stm32_composite_recalc_rate,
+	.round_rate	= clk_stm32_composite_round_rate,
+	.get_parent	= clk_stm32_composite_get_parent,
+	.set_parent	= clk_stm32_composite_set_parent,
+	.enable		= clk_stm32_composite_gate_enable,
+	.disable	= clk_stm32_composite_gate_disable,
+	.is_enabled	= clk_stm32_composite_is_enabled,
+	.disable_unused	= clk_stm32_composite_disable_unused,
+};
+
+u8 clk_stm32_mux_get_parent(struct clk_hw *hw)
+{
+	struct clk_stm32_mux *mux = to_clk_stm32_mux(hw);
+
+	return clk_stm32_get_parent_mux(mux->base, mux->clock_data,
+					mux->mux_id);
+}
+
+int clk_stm32_mux_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct clk_stm32_mux *mux = to_clk_stm32_mux(hw);
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(mux->lock, flags);
+
+	clk_stm32_set_parent_mux(mux->base, mux->clock_data,
+				 mux->mux_id, index);
+
+	spin_unlock_irqrestore(mux->lock, flags);
+
+	return 0;
+}
+
+const struct clk_ops clk_stm32_mux_ops = {
+	.get_parent	= clk_stm32_mux_get_parent,
+	.set_parent	= clk_stm32_mux_set_parent,
+};
+
+static int clk_stm32_divider_set_rate(struct clk_hw *hw, unsigned long rate,
+				      unsigned long parent_rate)
+{
+	struct clk_stm32_div *div = to_clk_stm32_divider(hw);
+	unsigned long flags = 0;
+	int ret;
+
+	if (div->div_id == NO_STM32_DIV)
+		return rate;
+
+	spin_lock_irqsave(div->lock, flags);
+
+	ret = clk_stm32_set_rate_divider(div->base, div->clock_data, div->div_id,
+					 rate, parent_rate);
+
+	spin_unlock_irqrestore(div->lock, flags);
+
+	return ret;
+
+}
+
+static long clk_stm32_divider_round_rate(struct clk_hw *hw, unsigned long rate,
+					 unsigned long *prate)
+{
+	struct clk_stm32_div *div = to_clk_stm32_divider(hw);
+	const struct stm32_div_cfg *divider;
+
+	if (div->div_id == NO_STM32_DIV)
+		return rate;
+
+	divider = &div->clock_data->dividers[div->div_id];
+
+	/* if read only, just return current value */
+	if (divider->flags & CLK_DIVIDER_READ_ONLY) {
+		u32 val;
+
+		val =  readl(div->base + divider->offset) >> divider->shift;
+		val &= clk_div_mask(divider->width);
+
+		return divider_ro_round_rate(hw, rate, prate, divider->table,
+				divider->width, divider->flags,
+				val);
+	}
+
+	return divider_round_rate_parent(hw, clk_hw_get_parent(hw),
+					 rate, prate, divider->table,
+					 divider->width, divider->flags);
+}
+
+static unsigned long clk_stm32_divider_recalc_rate(struct clk_hw *hw,
+						   unsigned long parent_rate)
+{
+	struct clk_stm32_div *div = to_clk_stm32_divider(hw);
+
+	if (div->div_id == NO_STM32_DIV)
+		return parent_rate;
+
+	return clk_stm32_get_rate_divider(div->base, div->clock_data,
+					  div->div_id, parent_rate);
+}
+
+const struct clk_ops clk_stm32_divider_ops = {
+	.recalc_rate	= clk_stm32_divider_recalc_rate,
+	.round_rate	= clk_stm32_divider_round_rate,
+	.set_rate	= clk_stm32_divider_set_rate,
+};
+
+/* Clock register function */
+struct clk_hw *clk_stm32_gate_register(struct device *dev,
+				       const struct stm32_rcc_match_data *data,
+				       void __iomem *base,
+				       spinlock_t *lock,
+				       const struct clock_config *cfg)
+{
+	struct clk_stm32_gate *gate = cfg->clock_cfg;
+	struct clk_hw *hw = &gate->hw;
+	const struct clk_init_data *init_data = hw->init;
+	int err;
+
+	gate->base = base;
+	gate->lock = lock;
+	gate->clock_data = data->clock_data;
+
+	err = clk_hw_register(dev, hw);
+	if (err) {
+		dev_err(dev, "Can't register clk %s: %ld\n", init_data->name,  PTR_ERR(hw));
+		return ERR_PTR(err);
+	}
+
+	return hw;
+}
+
+struct clk_hw *clk_stm32_div_register(struct device *dev,
+				      const struct stm32_rcc_match_data *data,
+				      void __iomem *base,
+				      spinlock_t *lock,
+				      const struct clock_config *cfg)
+{
+	struct clk_stm32_div *div = cfg->clock_cfg;
+	struct clk_hw *hw = &div->hw;
+	const struct clk_init_data *init_data = hw->init;
+	int err;
+
+	div->base = base;
+	div->lock = lock;
+	div->clock_data = data->clock_data;
+
+	err = clk_hw_register(dev, hw);
+	if (err) {
+		dev_err(dev, "Can't register clk %s: %ld\n", init_data->name,  PTR_ERR(hw));
+		return ERR_PTR(err);
+	}
+
+	return hw;
+}
+
+struct clk_hw *clk_stm32_mux_register(struct device *dev,
+				      const struct stm32_rcc_match_data *data,
+				      void __iomem *base,
+				      spinlock_t *lock,
+				      const struct clock_config *cfg)
+{
+	struct clk_stm32_mux *mux = cfg->clock_cfg;
+	struct clk_hw *hw = &mux->hw;
+	const struct clk_init_data *init_data = hw->init;
+	int err;
+
+	mux->base = base;
+	mux->lock = lock;
+	mux->clock_data = data->clock_data;
+
+	err = clk_hw_register(dev, hw);
+	if (err) {
+		dev_err(dev, "Can't register clk %s: %ld\n", init_data->name,  PTR_ERR(hw));
+		return ERR_PTR(err);
+	}
+
+	return hw;
+}
+
+struct clk_hw *clk_stm32_composite_register(struct device *dev,
+					    const struct stm32_rcc_match_data *data,
+					    void __iomem *base,
+					    spinlock_t *lock,
+					    const struct clock_config *cfg)
+{
+	struct clk_stm32_composite *composite = cfg->clock_cfg;
+	struct clk_hw *hw = &composite->hw;
+	const struct clk_init_data *init_data = hw->init;
+	int err;
+
+	composite->base = base;
+	composite->lock = lock;
+	composite->clock_data = data->clock_data;
+
+	err = clk_hw_register(dev, hw);
+	if (err) {
+		dev_err(dev, "Can't register clk %s: %ld\n", init_data->name,  PTR_ERR(hw));
+		return ERR_PTR(err);
+	}
+
+	return hw;
+}
+
+#ifdef CONFIG_DEBUG_FS
+
+#include <linux/debugfs.h>
+
+static void rcc_summary_show_one(struct seq_file *s, struct clk_summary *c,
+				 int level)
+{
+	char enabled;
+
+	seq_printf(s, "%*s%-*s %11lu ",
+		   level * 3 + 1, "",
+		   30 - level * 3,
+		   c->name,
+		   c->rate
+		);
+
+	switch (c->enabled) {
+	case 0:
+		enabled = 'N';
+		break;
+	case 1:
+		enabled = 'Y';
+		break;
+	default:
+		enabled = '?';
+		break;
+	}
+
+	seq_printf(s, " %9c\n", enabled);
+}
+
+static int clock_summary_clk_is_enabled(struct clk_stm32_clock_data *data,
+					struct clk_summary *c)
+{
+	return clk_stm32_is_enabled_gate(data->base, data, c->gate_id);
+}
+
+static const char *clock_summary_get_parent_name(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c)
+{
+	int id = 0;
+
+	if (c->nb_parents == 0)
+		return NULL;
+
+	if (c->nb_parents > 1) {
+		if (c->get_parent)
+			id = c->get_parent(data, c);
+		else
+			id = clk_stm32_get_parent_mux(data->base, data, c->mux_id);
+	}
+
+	return c->parent_names[id];
+}
+
+static void rcc_summary_show_subtree(struct seq_file *s, struct clk_summary *c,
+				     unsigned long parent_rate, int level)
+{
+	struct stm32_rcc_match_data *match_data = (struct stm32_rcc_match_data *)s->private;
+	struct clk_stm32_clock_data *data = match_data->clock_data;
+	struct clock_summary *cs = match_data->clock_summary;
+	int i;
+
+	if (c->get_rate)
+		c->rate = c->get_rate(data, c, parent_rate);
+	else
+		c->rate = parent_rate;
+
+	c->enabled = -1;
+
+	if (c->is_enabled)
+		c->enabled = c->is_enabled(data, c);
+
+	else if (c->gate_id != NO_STM32_GATE)
+		c->enabled = clock_summary_clk_is_enabled(data, c);
+
+	rcc_summary_show_one(s, c, level);
+
+	for (i = 0; i < cs->nb_clocks; i++) {
+		struct clk_summary *child = &cs->clocks[i];
+		const char *parent_name = clock_summary_get_parent_name(data, child);
+
+		if (!parent_name)
+			continue;
+
+		if (!strcmp(c->name, parent_name))
+			rcc_summary_show_subtree(s, child, c->rate, level + 1);
+	}
+}
+
+static int rcc_summary_show(struct seq_file *s, void *data)
+{
+	struct stm32_rcc_match_data *match_data = (struct stm32_rcc_match_data *)s->private;
+	struct clock_summary *cs = match_data->clock_summary;
+
+	int i;
+
+	seq_puts(s, "                                              hardware\n");
+	seq_puts(s, "   clock                               rate     enable\n");
+	seq_puts(s, "------------------------------------------------------\n");
+
+	for (i = 0; i < cs->nb_clocks; i++) {
+		struct clk_summary *c = &cs->clocks[i];
+
+		if (c->nb_parents == 0)
+			rcc_summary_show_subtree(s, c, 0, 0);
+	}
+
+	return 0;
+}
+
+DEFINE_SHOW_ATTRIBUTE(rcc_summary);
+
+static void stm32_clk_summary_debugfs_create(struct device *dev,
+					     const struct stm32_rcc_match_data *data)
+{
+	struct dentry *rootdir = debugfs_lookup("clk", NULL);
+
+	debugfs_create_file("stm32_clk_summary", 0444, rootdir, (void *)data, &rcc_summary_fops);
+}
+
+#else
+
+static void stm32_clk_summary_debugfs_create(struct device *dev,
+					     const struct stm32_rcc_match_data *data)
+
+{
+}
+#endif
diff --git a/drivers/clk/stm32/clk-stm32-core.h b/drivers/clk/stm32/clk-stm32-core.h
new file mode 100644
index 000000000..2e0a73d27
--- /dev/null
+++ b/drivers/clk/stm32/clk-stm32-core.h
@@ -0,0 +1,272 @@
+/* SPDX-License-Identifier: GPL-2.0  */
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@foss.st.com> for STMicroelectronics.
+ */
+
+#include <linux/clk-provider.h>
+
+struct stm32_rcc_match_data;
+
+struct stm32_mux_cfg {
+	u16	offset;
+	u8	shift;
+	u8	width;
+	u8	flags;
+	u32	*table;
+	u8	ready;
+};
+
+struct stm32_gate_cfg {
+	u16	offset;
+	u8	bit_idx;
+	u8	set_clr;
+};
+
+struct stm32_div_cfg {
+	u16	offset;
+	u8	shift;
+	u8	width;
+	u8	flags;
+	u8	ready;
+	const struct clk_div_table *table;
+};
+
+struct stm32_composite_cfg {
+	int	mux;
+	int	gate;
+	int	div;
+};
+
+#define NO_ID 0xFFFF0000
+
+#define NO_STM32_MUX		0xFFFF
+#define NO_STM32_DIV		0xFFFF
+#define NO_STM32_GATE		0xFFFF
+
+struct clock_config {
+	unsigned long	id;
+	int		sec_id;
+	void		*clock_cfg;
+
+	struct clk_hw *(*func)(struct device *dev,
+			       const struct stm32_rcc_match_data *data,
+			       void __iomem *base,
+			       spinlock_t *lock,
+			       const struct clock_config *cfg);
+};
+
+struct clk_stm32_clock_data {
+	void __iomem			*base;
+	u16 *gate_cpt;
+	const struct stm32_gate_cfg	*gates;
+	const struct stm32_mux_cfg	*muxes;
+	const struct stm32_div_cfg	*dividers;
+	struct clk_hw *(*is_multi_mux)(struct clk_hw *hw);
+};
+
+struct clock_summary {
+	struct clk_summary *clocks;
+	int nb_clocks;
+};
+
+struct clk_summary {
+	const char *name;
+	unsigned long rate;
+	int enabled;
+	int nb_parents;
+	int gate_id;
+	int mux_id;
+	int div_id;
+	void *data;
+
+	bool (*is_enabled)(struct clk_stm32_clock_data *data,
+			   struct clk_summary *c);
+	u8 (*get_parent)(struct clk_stm32_clock_data *data,
+			 struct clk_summary *c);
+	unsigned long (*get_rate)(struct clk_stm32_clock_data *data,
+				  struct clk_summary *c,
+				  unsigned long parent_rate);
+	const char * const *parent_names;
+};
+
+struct stm32_rcc_match_data {
+	struct clk_hw_onecell_data	*hw_clks;
+	unsigned int			num_clocks;
+	const struct clock_config	*tab_clocks;
+	unsigned int			maxbinding;
+	struct clk_stm32_clock_data	*clock_data;
+	int (*multi_mux)(void __iomem *base, const struct clock_config *cfg);
+	int (*check_security)(void __iomem *base, const struct clock_config *cfg);
+	u32 clear_offset;
+	u32				reset_us;
+
+	struct clock_summary		*clock_summary;
+};
+
+int stm32_rcc_reset_init(struct device *dev, const struct of_device_id *match,
+			 void __iomem *base);
+
+int stm32_rcc_init(struct device *dev, const struct of_device_id *match_data,
+		   void __iomem *base);
+
+/* MUX define */
+#define MUX_NO_RDY		0xFF
+#define MUX_SAFE		BIT(7)
+
+/* DIV define */
+#define DIV_NO_RDY		0xFF
+
+struct clk_stm32_gate {
+	u16 gate_id;
+	struct clk_hw hw;
+	void __iomem *base;
+	struct clk_stm32_clock_data *clock_data;
+	spinlock_t *lock; /* spin lock */
+};
+
+#define to_clk_stm32_gate(_hw) container_of(_hw, struct clk_stm32_gate, hw)
+
+struct clk_stm32_mux {
+	u16 mux_id;
+	struct clk_hw hw;
+	void __iomem *base;
+	struct clk_stm32_clock_data *clock_data;
+	spinlock_t *lock; /* spin lock */
+};
+
+#define to_clk_stm32_mux(_hw) container_of(_hw, struct clk_stm32_mux, hw)
+
+struct clk_stm32_div {
+	u16 div_id;
+	struct clk_hw hw;
+	void __iomem *base;
+	struct clk_stm32_clock_data *clock_data;
+	spinlock_t *lock; /* spin lock */
+};
+
+#define to_clk_stm32_divider(_hw) container_of(_hw, struct clk_stm32_div, hw)
+
+struct clk_stm32_composite {
+	u16 gate_id;
+	u16 mux_id;
+	u16 div_id;
+	struct clk_hw hw;
+	void __iomem *base;
+	struct clk_stm32_clock_data *clock_data;
+	spinlock_t *lock; /* spin lock */
+};
+
+#define to_clk_stm32_composite(_hw) container_of(_hw, struct clk_stm32_composite, hw)
+
+void clk_stm32_endisable_gate(void __iomem *base,
+			      struct clk_stm32_clock_data *data, u16 gate_id,
+			      int enable);
+int clk_stm32_is_enabled_gate(void __iomem *base,
+			      struct clk_stm32_clock_data *data, u16 gate_id);
+u8 clk_stm32_get_parent_mux(void __iomem *base,
+			    struct clk_stm32_clock_data *data, u16 mux_id);
+int clk_stm32_set_parent_mux(void __iomem *base,
+			     struct clk_stm32_clock_data *data, u16 mux_id,
+			     u8 index);
+int clk_stm32_set_rate_divider(void __iomem *base,
+			       struct clk_stm32_clock_data *data,
+			       u16 div_id, unsigned long rate,
+			       unsigned long parent_rate);
+unsigned long clk_stm32_get_rate_divider(void __iomem *base,
+					 struct clk_stm32_clock_data *data,
+					 u16 div_id, unsigned long parent_rate);
+
+void clk_stm32_gate_endisable(struct clk_hw *hw, int enable);
+int clk_stm32_gate_enable(struct clk_hw *hw);
+void clk_stm32_gate_disable(struct clk_hw *hw);
+int clk_stm32_gate_is_enabled(struct clk_hw *hw);
+
+u8 clk_stm32_mux_get_parent(struct clk_hw *hw);
+int clk_stm32_mux_set_parent(struct clk_hw *hw, u8 index);
+
+void clk_stm32_composite_gate_endisable(struct clk_hw *hw, int enable);
+int clk_stm32_composite_gate_enable(struct clk_hw *hw);
+void clk_stm32_composite_gate_disable(struct clk_hw *hw);
+int clk_stm32_composite_is_enabled(struct clk_hw *hw);
+u8 clk_stm32_composite_get_parent(struct clk_hw *hw);
+int clk_stm32_composite_set_parent(struct clk_hw *hw, u8 index);
+unsigned long clk_stm32_composite_recalc_rate(struct clk_hw *hw,
+					      unsigned long parent_rate);
+long clk_stm32_composite_round_rate(struct clk_hw *hw, unsigned long rate,
+				    unsigned long *prate);
+int clk_stm32_composite_set_rate(struct clk_hw *hw, unsigned long rate,
+				 unsigned long parent_rate);
+
+struct clk_hw *clk_stm32_gate_register(struct device *dev,
+				       const struct stm32_rcc_match_data *data,
+				       void __iomem *base,
+				       spinlock_t *lock,
+				       const struct clock_config *cfg);
+
+struct clk_hw *clk_stm32_div_register(struct device *dev,
+				      const struct stm32_rcc_match_data *data,
+				      void __iomem *base,
+				      spinlock_t *lock,
+				      const struct clock_config *cfg);
+
+struct clk_hw *clk_stm32_mux_register(struct device *dev,
+				      const struct stm32_rcc_match_data *data,
+				      void __iomem *base,
+				      spinlock_t *lock,
+				      const struct clock_config *cfg);
+
+struct clk_hw *clk_stm32_composite_register(struct device *dev,
+					    const struct stm32_rcc_match_data *data,
+					    void __iomem *base,
+					    spinlock_t *lock,
+					    const struct clock_config *cfg);
+
+extern const struct clk_ops clk_stm32_gate_ops;
+extern const struct clk_ops clk_stm32_divider_ops;
+extern const struct clk_ops clk_stm32_mux_ops;
+extern const struct clk_ops clk_stm32_composite_ops;
+
+#define PARENT(_parent)	((const char *[]) { _parent})
+
+#define CLK_STM32_GATE(_name, _parent, _flags, _gate_id)\
+struct clk_stm32_gate _name = {\
+	.gate_id = _gate_id,\
+	.hw.init = CLK_HW_INIT(#_name, _parent, &clk_stm32_gate_ops, _flags),\
+}
+
+#define CLK_STM32_MUX(_name, _parents, _flags, _mux_id)\
+struct clk_stm32_mux _name = {\
+	.mux_id = _mux_id,\
+	.hw.init = CLK_HW_INIT_PARENTS(#_name, _parents, &clk_stm32_mux_ops, _flags),\
+}
+
+#define CLK_STM32_DIV(_name, _parent, _flags, _div_id)\
+struct clk_stm32_div _name = {\
+	.div_id = _div_id,\
+	.hw.init = CLK_HW_INIT(#_name, _parent, &clk_stm32_divider_ops, _flags),\
+}
+
+#define CLK_STM32_COMPOSITE(_name, _parents, _flags, _gate_id, _mux_id, _div_id)\
+struct clk_stm32_composite _name = {\
+	.gate_id = _gate_id,\
+	.mux_id = _mux_id,\
+	.div_id = _div_id,\
+	.hw.init = CLK_HW_INIT_PARENTS(#_name, _parents, &clk_stm32_composite_ops, _flags),\
+}
+
+#define STM32_CLOCK_CFG(_binding, _clk, _sec_id, _struct, _register)\
+{\
+	.id		= (_binding),\
+	.sec_id		= (_sec_id),\
+	.clock_cfg	= (_struct) {_clk},\
+	.func		= (_register),\
+}
+
+#define STM32_GATE_CFG(_binding, _clk, _sec_id)\
+	STM32_CLOCK_CFG(_binding, &(_clk), _sec_id, struct clk_stm32_gate *,\
+			&clk_stm32_gate_register)
+
+#define STM32_COMPOSITE_CFG(_binding, _clk, _sec_id)\
+	STM32_CLOCK_CFG(_binding, &(_clk), _sec_id, struct clk_stm32_composite *,\
+			&clk_stm32_composite_register)
diff --git a/drivers/clk/stm32/clk-stm32mp13.c b/drivers/clk/stm32/clk-stm32mp13.c
new file mode 100644
index 000000000..15ee05df8
--- /dev/null
+++ b/drivers/clk/stm32/clk-stm32mp13.c
@@ -0,0 +1,1760 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@foss.st.com> for STMicroelectronics.
+ */
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+
+#include <dt-bindings/clock/stm32mp13-clks.h>
+
+#include "clk-stm32-core.h"
+#include "stm32mp13_rcc.h"
+
+#define RCC_CLR		0x4
+
+static const char * const adc12_src[] = {
+	"pll4_r", "ck_per", "pll3_q"
+};
+
+static const char * const dcmipp_src[] = {
+	"ck_axi", "pll2_q", "pll4_p", "ck_per",
+};
+
+static const char * const eth12_src[] = {
+	"pll4_p", "pll3_q"
+};
+
+static const char * const fdcan_src[] = {
+	"ck_hse", "pll3_q", "pll4_q", "pll4_r"
+};
+
+static const char * const fmc_src[] = {
+	"ck_axi", "pll3_r", "pll4_p", "ck_per"
+};
+
+static const char * const i2c12_src[] = {
+	"pclk1", "pll4_r", "ck_hsi", "ck_csi"
+};
+
+static const char * const i2c345_src[] = {
+	"pclk6", "pll4_r", "ck_hsi", "ck_csi"
+};
+
+static const char * const lptim1_src[] = {
+	"pclk1", "pll4_p", "pll3_q", "ck_lse", "ck_lsi", "ck_per"
+};
+
+static const char * const lptim23_src[] = {
+	"pclk3", "pll4_q", "ck_per", "ck_lse", "ck_lsi"
+};
+
+static const char * const lptim45_src[] = {
+	"pclk3", "pll4_p", "pll3_q", "ck_lse", "ck_lsi", "ck_per"
+};
+
+static const char * const mco1_src[] = {
+	"ck_hsi", "ck_hse", "ck_csi", "ck_lsi", "ck_lse"
+};
+
+static const char * const mco2_src[] = {
+	"ck_mpu", "ck_axi", "ck_mlahb", "pll4_p", "ck_hse", "ck_hsi"
+};
+
+static const char * const qspi_src[] = {
+	"ck_axi", "pll3_r", "pll4_p", "ck_per"
+};
+
+static const char * const rng1_src[] = {
+	"ck_csi", "pll4_r", "reserved", "ck_lsi"
+};
+
+static const char * const saes_src[] = {
+	"ck_axi", "ck_per", "pll4_r", "ck_lsi"
+};
+
+static const char * const sai1_src[] = {
+	"pll4_q", "pll3_q", "i2s_ckin", "ck_per", "pll3_r"
+};
+
+static const char * const sai2_src[] = {
+	"pll4_q", "pll3_q", "i2s_ckin", "ck_per", "spdif_ck_symb", "pll3_r"
+};
+
+static const char * const sdmmc12_src[] = {
+	"ck_axi", "pll3_r", "pll4_p", "ck_hsi"
+};
+
+static const char * const spdif_src[] = {
+	"pll4_p", "pll3_q", "ck_hsi"
+};
+
+static const char * const spi123_src[] = {
+	"pll4_p", "pll3_q", "i2s_ckin", "ck_per", "pll3_r"
+};
+
+static const char * const spi4_src[] = {
+	"pclk6", "pll4_q", "ck_hsi", "ck_csi", "ck_hse", "i2s_ckin"
+};
+
+static const char * const spi5_src[] = {
+	"pclk6", "pll4_q", "ck_hsi", "ck_csi", "ck_hse"
+};
+
+static const char * const stgen_src[] = {
+	"ck_hsi", "ck_hse"
+};
+
+static const char * const usart12_src[] = {
+	"pclk6", "pll3_q", "ck_hsi", "ck_csi", "pll4_q", "ck_hse"
+};
+
+static const char * const usart34578_src[] = {
+	"pclk1", "pll4_q", "ck_hsi", "ck_csi", "ck_hse"
+};
+
+static const char * const usart6_src[] = {
+	"pclk2", "pll4_q", "ck_hsi", "ck_csi", "ck_hse"
+};
+
+static const char * const usbo_src[] = {
+	"pll4_r", "ck_usbo_48m"
+};
+
+static const char * const usbphy_src[] = {
+	"ck_hse", "pll4_r", "clk-hse-div2"
+};
+
+enum enum_gate_cfg {
+	GATE_LSE,
+	GATE_LSE_RDY,
+	GATE_LSI,
+	GATE_LSI_RDY,
+	GATE_HSI,
+	GATE_HSI_RDY,
+	GATE_CSI,
+	GATE_CSI_RDY,
+	GATE_HSE,
+	GATE_HSE_RDY,
+	GATE_PLL1,
+	GATE_PLL1_RDY,
+	GATE_PLL2,
+	GATE_PLL2_RDY,
+	GATE_PLL3,
+	GATE_PLL3_RDY,
+	GATE_PLL4,
+	GATE_PLL4_RDY,
+	GATE_HSIDIVRDY,
+	GATE_MPUSRCRDY,
+	GATE_AXISSRCRDY,
+	GATE_MCUSSRCRDY,
+	GATE_PLL12SRCRDY,
+	GATE_PLL3SRCRDY,
+	GATE_PLL4SRCRDY,
+	GATE_MPUDIVRDY,
+	GATE_AXIDIVRDY,
+	GATE_MLAHBDIVRDY,
+	GATE_APB1DIVRDY,
+	GATE_APB2DIVRDY,
+	GATE_APB3DIVRDY,
+	GATE_APB4DIVRDY,
+	GATE_APB5DIVRDY,
+	GATE_APB6DIVRDY,
+	GATE_RTCCK,
+	GATE_RTCAPB,
+	GATE_PLL1_DIVP,
+	GATE_PLL1_DIVQ,
+	GATE_PLL1_DIVR,
+	GATE_PLL2_DIVP,
+	GATE_PLL2_DIVQ,
+	GATE_PLL2_DIVR,
+	GATE_PLL3_DIVP,
+	GATE_PLL3_DIVQ,
+	GATE_PLL3_DIVR,
+	GATE_PLL4_DIVP,
+	GATE_PLL4_DIVQ,
+	GATE_PLL4_DIVR,
+	GATE_MCO1,
+	GATE_MCO2,
+	GATE_DBGCK,
+	GATE_TRACECK,
+	GATE_DDRC1,
+	GATE_DDRC1LP,
+	GATE_DDRPHYC,
+	GATE_DDRPHYCLP,
+	GATE_DDRCAPB,
+	GATE_DDRCAPBLP,
+	GATE_AXIDCG,
+	GATE_DDRPHYCAPB,
+	GATE_DDRPHYCAPBLP,
+	GATE_TIM2,
+	GATE_TIM3,
+	GATE_TIM4,
+	GATE_TIM5,
+	GATE_TIM6,
+	GATE_TIM7,
+	GATE_LPTIM1,
+	GATE_SPI2,
+	GATE_SPI3,
+	GATE_USART3,
+	GATE_UART4,
+	GATE_UART5,
+	GATE_UART7,
+	GATE_UART8,
+	GATE_I2C1,
+	GATE_I2C2,
+	GATE_SPDIF,
+	GATE_TIM1,
+	GATE_TIM8,
+	GATE_SPI1,
+	GATE_USART6,
+	GATE_SAI1,
+	GATE_SAI2,
+	GATE_DFSDM,
+	GATE_ADFSDM,
+	GATE_FDCAN,
+	GATE_LPTIM2,
+	GATE_LPTIM3,
+	GATE_LPTIM4,
+	GATE_LPTIM5,
+	GATE_VREF,
+	GATE_DTS,
+	GATE_PMBCTRL,
+	GATE_HDP,
+	GATE_SYSCFG,
+	GATE_DCMIPP,
+	GATE_DDRPERFM,
+	GATE_IWDG2APB,
+	GATE_USBPHY,
+	GATE_STGENRO,
+	GATE_LTDC,
+	GATE_TZC,
+	GATE_ETZPC,
+	GATE_IWDG1APB,
+	GATE_BSEC,
+	GATE_STGENC,
+	GATE_USART1,
+	GATE_USART2,
+	GATE_SPI4,
+	GATE_SPI5,
+	GATE_I2C3,
+	GATE_I2C4,
+	GATE_I2C5,
+	GATE_TIM12,
+	GATE_TIM13,
+	GATE_TIM14,
+	GATE_TIM15,
+	GATE_TIM16,
+	GATE_TIM17,
+	GATE_DMA1,
+	GATE_DMA2,
+	GATE_DMAMUX1,
+	GATE_DMA3,
+	GATE_DMAMUX2,
+	GATE_ADC1,
+	GATE_ADC2,
+	GATE_USBO,
+	GATE_TSC,
+	GATE_GPIOA,
+	GATE_GPIOB,
+	GATE_GPIOC,
+	GATE_GPIOD,
+	GATE_GPIOE,
+	GATE_GPIOF,
+	GATE_GPIOG,
+	GATE_GPIOH,
+	GATE_GPIOI,
+	GATE_PKA,
+	GATE_SAES,
+	GATE_CRYP1,
+	GATE_HASH1,
+	GATE_RNG1,
+	GATE_BKPSRAM,
+	GATE_AXIMC,
+	GATE_MCE,
+	GATE_ETH1CK,
+	GATE_ETH1TX,
+	GATE_ETH1RX,
+	GATE_ETH1MAC,
+	GATE_FMC,
+	GATE_QSPI,
+	GATE_SDMMC1,
+	GATE_SDMMC2,
+	GATE_CRC1,
+	GATE_USBH,
+	GATE_ETH2CK,
+	GATE_ETH2TX,
+	GATE_ETH2RX,
+	GATE_ETH2MAC,
+	GATE_ETH1STP,
+	GATE_ETH2STP,
+	GATE_MDMA,
+	GATE_NB
+};
+
+#define _CFG_GATE(_id, _offset, _bit_idx, _offset_clr)\
+	[(_id)] = {\
+		.offset		= (_offset),\
+		.bit_idx	= (_bit_idx),\
+		.set_clr	= (_offset_clr),\
+	}
+
+#define CFG_GATE(_id, _offset, _bit_idx)\
+	_CFG_GATE(_id, _offset, _bit_idx, 0)
+
+#define CFG_GATE_SETCLR(_id, _offset, _bit_idx)\
+	_CFG_GATE(_id, _offset, _bit_idx, RCC_CLR)
+
+static struct stm32_gate_cfg stm32mp13_gates[] = {
+	CFG_GATE(GATE_LSE,		RCC_BDCR,	0),
+	CFG_GATE(GATE_LSE_RDY,		RCC_BDCR,	2),
+	CFG_GATE(GATE_RTCCK,		RCC_BDCR,	20),
+	CFG_GATE(GATE_LSI,		RCC_RDLSICR,	0),
+	CFG_GATE(GATE_LSI_RDY,		RCC_RDLSICR,	1),
+	CFG_GATE_SETCLR(GATE_HSI,	RCC_OCENSETR,	0),
+	CFG_GATE(GATE_HSI_RDY,		RCC_OCRDYR,	0),
+	CFG_GATE_SETCLR(GATE_CSI,	RCC_OCENSETR,	4),
+	CFG_GATE(GATE_CSI_RDY,		RCC_OCRDYR,	4),
+	CFG_GATE_SETCLR(GATE_HSE,	RCC_OCENSETR,	8),
+	CFG_GATE(GATE_HSE_RDY,		RCC_OCRDYR,	8),
+	CFG_GATE(GATE_HSIDIVRDY,	RCC_OCRDYR,	2),
+	CFG_GATE(GATE_MPUSRCRDY,	RCC_MPCKSELR,	31),
+	CFG_GATE(GATE_AXISSRCRDY,	RCC_ASSCKSELR,	31),
+	CFG_GATE(GATE_MCUSSRCRDY,	RCC_MSSCKSELR,	31),
+	CFG_GATE(GATE_PLL12SRCRDY,	RCC_RCK12SELR,	31),
+	CFG_GATE(GATE_PLL3SRCRDY,	RCC_RCK3SELR,	31),
+	CFG_GATE(GATE_PLL4SRCRDY,	RCC_RCK4SELR,	31),
+	CFG_GATE(GATE_MPUDIVRDY,	RCC_MPCKDIVR,	31),
+	CFG_GATE(GATE_AXIDIVRDY,	RCC_AXIDIVR,	31),
+	CFG_GATE(GATE_MLAHBDIVRDY,	RCC_MLAHBDIVR,	31),
+	CFG_GATE(GATE_APB1DIVRDY,	RCC_APB1DIVR,	31),
+	CFG_GATE(GATE_APB2DIVRDY,	RCC_APB2DIVR,	31),
+	CFG_GATE(GATE_APB3DIVRDY,	RCC_APB3DIVR,	31),
+	CFG_GATE(GATE_APB4DIVRDY,	RCC_APB4DIVR,	31),
+	CFG_GATE(GATE_APB5DIVRDY,	RCC_APB5DIVR,	31),
+	CFG_GATE(GATE_APB6DIVRDY,	RCC_APB6DIVR,	31),
+	CFG_GATE(GATE_PLL1,		RCC_PLL1CR,	0),
+	CFG_GATE(GATE_PLL1_RDY,		RCC_PLL1CR,	1),
+	CFG_GATE(GATE_PLL1_DIVP,	RCC_PLL1CR,	4),
+	CFG_GATE(GATE_PLL1_DIVQ,	RCC_PLL1CR,	5),
+	CFG_GATE(GATE_PLL1_DIVR,	RCC_PLL1CR,	6),
+	CFG_GATE(GATE_PLL2,		RCC_PLL2CR,	0),
+	CFG_GATE(GATE_PLL2_RDY,		RCC_PLL2CR,	1),
+	CFG_GATE(GATE_PLL2_DIVP,	RCC_PLL2CR,	4),
+	CFG_GATE(GATE_PLL2_DIVQ,	RCC_PLL2CR,	5),
+	CFG_GATE(GATE_PLL2_DIVR,	RCC_PLL2CR,	6),
+	CFG_GATE(GATE_PLL3,		RCC_PLL3CR,	0),
+	CFG_GATE(GATE_PLL3_RDY,		RCC_PLL3CR,	1),
+	CFG_GATE(GATE_PLL3_DIVP,	RCC_PLL3CR,	4),
+	CFG_GATE(GATE_PLL3_DIVQ,	RCC_PLL3CR,	5),
+	CFG_GATE(GATE_PLL3_DIVR,	RCC_PLL3CR,	6),
+	CFG_GATE(GATE_PLL4,		RCC_PLL4CR,	0),
+	CFG_GATE(GATE_PLL4_RDY,		RCC_PLL4CR,	1),
+	CFG_GATE(GATE_PLL4_DIVP,	RCC_PLL4CR,	4),
+	CFG_GATE(GATE_PLL4_DIVQ,	RCC_PLL4CR,	5),
+	CFG_GATE(GATE_PLL4_DIVR,	RCC_PLL4CR,	6),
+	CFG_GATE(GATE_MCO1,		RCC_MCO1CFGR,	12),
+	CFG_GATE(GATE_MCO2,		RCC_MCO2CFGR,	12),
+	CFG_GATE(GATE_DBGCK,		RCC_DBGCFGR,	8),
+	CFG_GATE(GATE_TRACECK,		RCC_DBGCFGR,	9),
+	CFG_GATE(GATE_DDRC1,		RCC_DDRITFCR,	0),
+	CFG_GATE(GATE_DDRC1LP,		RCC_DDRITFCR,	1),
+	CFG_GATE(GATE_DDRPHYC,		RCC_DDRITFCR,	4),
+	CFG_GATE(GATE_DDRPHYCLP,	RCC_DDRITFCR,	5),
+	CFG_GATE(GATE_DDRCAPB,		RCC_DDRITFCR,	6),
+	CFG_GATE(GATE_DDRCAPBLP,	RCC_DDRITFCR,	7),
+	CFG_GATE(GATE_AXIDCG,		RCC_DDRITFCR,	8),
+	CFG_GATE(GATE_DDRPHYCAPB,	RCC_DDRITFCR,	9),
+	CFG_GATE(GATE_DDRPHYCAPBLP,	RCC_DDRITFCR,	10),
+	CFG_GATE_SETCLR(GATE_TIM2,	RCC_MP_APB1ENSETR,	0),
+	CFG_GATE_SETCLR(GATE_TIM3,	RCC_MP_APB1ENSETR,	1),
+	CFG_GATE_SETCLR(GATE_TIM4,	RCC_MP_APB1ENSETR,	2),
+	CFG_GATE_SETCLR(GATE_TIM5,	RCC_MP_APB1ENSETR,	3),
+	CFG_GATE_SETCLR(GATE_TIM6,	RCC_MP_APB1ENSETR,	4),
+	CFG_GATE_SETCLR(GATE_TIM7,	RCC_MP_APB1ENSETR,	5),
+	CFG_GATE_SETCLR(GATE_LPTIM1,	RCC_MP_APB1ENSETR,	9),
+	CFG_GATE_SETCLR(GATE_SPI2,	RCC_MP_APB1ENSETR,	11),
+	CFG_GATE_SETCLR(GATE_SPI3,	RCC_MP_APB1ENSETR,	12),
+	CFG_GATE_SETCLR(GATE_USART3,	RCC_MP_APB1ENSETR,	15),
+	CFG_GATE_SETCLR(GATE_UART4,	RCC_MP_APB1ENSETR,	16),
+	CFG_GATE_SETCLR(GATE_UART5,	RCC_MP_APB1ENSETR,	17),
+	CFG_GATE_SETCLR(GATE_UART7,	RCC_MP_APB1ENSETR,	18),
+	CFG_GATE_SETCLR(GATE_UART8,	RCC_MP_APB1ENSETR,	19),
+	CFG_GATE_SETCLR(GATE_I2C1,	RCC_MP_APB1ENSETR,	21),
+	CFG_GATE_SETCLR(GATE_I2C2,	RCC_MP_APB1ENSETR,	22),
+	CFG_GATE_SETCLR(GATE_SPDIF,	RCC_MP_APB1ENSETR,	26),
+	CFG_GATE_SETCLR(GATE_TIM1,	RCC_MP_APB2ENSETR,	0),
+	CFG_GATE_SETCLR(GATE_TIM8,	RCC_MP_APB2ENSETR,	1),
+	CFG_GATE_SETCLR(GATE_SPI1,	RCC_MP_APB2ENSETR,	8),
+	CFG_GATE_SETCLR(GATE_USART6,	RCC_MP_APB2ENSETR,	13),
+	CFG_GATE_SETCLR(GATE_SAI1,	RCC_MP_APB2ENSETR,	16),
+	CFG_GATE_SETCLR(GATE_SAI2,	RCC_MP_APB2ENSETR,	17),
+	CFG_GATE_SETCLR(GATE_DFSDM,	RCC_MP_APB2ENSETR,	20),
+	CFG_GATE_SETCLR(GATE_ADFSDM,	RCC_MP_APB2ENSETR,	21),
+	CFG_GATE_SETCLR(GATE_FDCAN,	RCC_MP_APB2ENSETR,	24),
+	CFG_GATE_SETCLR(GATE_LPTIM2,	RCC_MP_APB3ENSETR,	0),
+	CFG_GATE_SETCLR(GATE_LPTIM3,	RCC_MP_APB3ENSETR,	1),
+	CFG_GATE_SETCLR(GATE_LPTIM4,	RCC_MP_APB3ENSETR,	2),
+	CFG_GATE_SETCLR(GATE_LPTIM5,	RCC_MP_APB3ENSETR,	3),
+	CFG_GATE_SETCLR(GATE_VREF,	RCC_MP_APB3ENSETR,	13),
+	CFG_GATE_SETCLR(GATE_DTS,	RCC_MP_APB3ENSETR,	16),
+	CFG_GATE_SETCLR(GATE_PMBCTRL,	RCC_MP_APB3ENSETR,	17),
+	CFG_GATE_SETCLR(GATE_HDP,	RCC_MP_APB3ENSETR,	20),
+	CFG_GATE_SETCLR(GATE_SYSCFG,	RCC_MP_NS_APB3ENSETR,	0),
+	CFG_GATE_SETCLR(GATE_DCMIPP,	RCC_MP_APB4ENSETR,	1),
+	CFG_GATE_SETCLR(GATE_DDRPERFM,	RCC_MP_APB4ENSETR,	8),
+	CFG_GATE_SETCLR(GATE_IWDG2APB,	RCC_MP_APB4ENSETR,	15),
+	CFG_GATE_SETCLR(GATE_USBPHY,	RCC_MP_APB4ENSETR,	16),
+	CFG_GATE_SETCLR(GATE_STGENRO,	RCC_MP_APB4ENSETR,	20),
+	CFG_GATE_SETCLR(GATE_LTDC,	RCC_MP_NS_APB4ENSETR,	0),
+	CFG_GATE(GATE_RTCAPB,		RCC_MP_APB5ENSETR,	8),
+	CFG_GATE_SETCLR(GATE_TZC,	RCC_MP_APB5ENSETR,	11),
+	CFG_GATE_SETCLR(GATE_ETZPC,	RCC_MP_APB5ENSETR,	13),
+	CFG_GATE_SETCLR(GATE_IWDG1APB,	RCC_MP_APB5ENSETR,	15),
+	CFG_GATE_SETCLR(GATE_BSEC,	RCC_MP_APB5ENSETR,	16),
+	CFG_GATE_SETCLR(GATE_STGENC,	RCC_MP_APB5ENSETR,	20),
+	CFG_GATE_SETCLR(GATE_USART1,	RCC_MP_APB6ENSETR,	0),
+	CFG_GATE_SETCLR(GATE_USART2,	RCC_MP_APB6ENSETR,	1),
+	CFG_GATE_SETCLR(GATE_SPI4,	RCC_MP_APB6ENSETR,	2),
+	CFG_GATE_SETCLR(GATE_SPI5,	RCC_MP_APB6ENSETR,	3),
+	CFG_GATE_SETCLR(GATE_I2C3,	RCC_MP_APB6ENSETR,	4),
+	CFG_GATE_SETCLR(GATE_I2C4,	RCC_MP_APB6ENSETR,	5),
+	CFG_GATE_SETCLR(GATE_I2C5,	RCC_MP_APB6ENSETR,	6),
+	CFG_GATE_SETCLR(GATE_TIM12,	RCC_MP_APB6ENSETR,	7),
+	CFG_GATE_SETCLR(GATE_TIM13,	RCC_MP_APB6ENSETR,	8),
+	CFG_GATE_SETCLR(GATE_TIM14,	RCC_MP_APB6ENSETR,	9),
+	CFG_GATE_SETCLR(GATE_TIM15,	RCC_MP_APB6ENSETR,	10),
+	CFG_GATE_SETCLR(GATE_TIM16,	RCC_MP_APB6ENSETR,	11),
+	CFG_GATE_SETCLR(GATE_TIM17,	RCC_MP_APB6ENSETR,	12),
+	CFG_GATE_SETCLR(GATE_DMA1,	RCC_MP_AHB2ENSETR,	0),
+	CFG_GATE_SETCLR(GATE_DMA2,	RCC_MP_AHB2ENSETR,	1),
+	CFG_GATE_SETCLR(GATE_DMAMUX1,	RCC_MP_AHB2ENSETR,	2),
+	CFG_GATE_SETCLR(GATE_DMA3,	RCC_MP_AHB2ENSETR,	3),
+	CFG_GATE_SETCLR(GATE_DMAMUX2,	RCC_MP_AHB2ENSETR,	4),
+	CFG_GATE_SETCLR(GATE_ADC1,	RCC_MP_AHB2ENSETR,	5),
+	CFG_GATE_SETCLR(GATE_ADC2,	RCC_MP_AHB2ENSETR,	6),
+	CFG_GATE_SETCLR(GATE_USBO,	RCC_MP_AHB2ENSETR,	8),
+	CFG_GATE_SETCLR(GATE_TSC,	RCC_MP_AHB4ENSETR,	15),
+	CFG_GATE_SETCLR(GATE_GPIOA,	RCC_MP_NS_AHB4ENSETR,	0),
+	CFG_GATE_SETCLR(GATE_GPIOB,	RCC_MP_NS_AHB4ENSETR,	1),
+	CFG_GATE_SETCLR(GATE_GPIOC,	RCC_MP_NS_AHB4ENSETR,	2),
+	CFG_GATE_SETCLR(GATE_GPIOD,	RCC_MP_NS_AHB4ENSETR,	3),
+	CFG_GATE_SETCLR(GATE_GPIOE,	RCC_MP_NS_AHB4ENSETR,	4),
+	CFG_GATE_SETCLR(GATE_GPIOF,	RCC_MP_NS_AHB4ENSETR,	5),
+	CFG_GATE_SETCLR(GATE_GPIOG,	RCC_MP_NS_AHB4ENSETR,	6),
+	CFG_GATE_SETCLR(GATE_GPIOH,	RCC_MP_NS_AHB4ENSETR,	7),
+	CFG_GATE_SETCLR(GATE_GPIOI,	RCC_MP_NS_AHB4ENSETR,	8),
+	CFG_GATE_SETCLR(GATE_PKA,	RCC_MP_AHB5ENSETR,	2),
+	CFG_GATE_SETCLR(GATE_SAES,	RCC_MP_AHB5ENSETR,	3),
+	CFG_GATE_SETCLR(GATE_CRYP1,	RCC_MP_AHB5ENSETR,	4),
+	CFG_GATE_SETCLR(GATE_HASH1,	RCC_MP_AHB5ENSETR,	5),
+	CFG_GATE_SETCLR(GATE_RNG1,	RCC_MP_AHB5ENSETR,	6),
+	CFG_GATE_SETCLR(GATE_BKPSRAM,	RCC_MP_AHB5ENSETR,	8),
+	CFG_GATE_SETCLR(GATE_AXIMC,	RCC_MP_AHB5ENSETR,	16),
+	CFG_GATE_SETCLR(GATE_MCE,	RCC_MP_AHB6ENSETR,	1),
+	CFG_GATE_SETCLR(GATE_ETH1CK,	RCC_MP_AHB6ENSETR,	7),
+	CFG_GATE_SETCLR(GATE_ETH1TX,	RCC_MP_AHB6ENSETR,	8),
+	CFG_GATE_SETCLR(GATE_ETH1RX,	RCC_MP_AHB6ENSETR,	9),
+	CFG_GATE_SETCLR(GATE_ETH1MAC,	RCC_MP_AHB6ENSETR,	10),
+	CFG_GATE_SETCLR(GATE_FMC,	RCC_MP_AHB6ENSETR,	12),
+	CFG_GATE_SETCLR(GATE_QSPI,	RCC_MP_AHB6ENSETR,	14),
+	CFG_GATE_SETCLR(GATE_SDMMC1,	RCC_MP_AHB6ENSETR,	16),
+	CFG_GATE_SETCLR(GATE_SDMMC2,	RCC_MP_AHB6ENSETR,	17),
+	CFG_GATE_SETCLR(GATE_CRC1,	RCC_MP_AHB6ENSETR,	20),
+	CFG_GATE_SETCLR(GATE_USBH,	RCC_MP_AHB6ENSETR,	24),
+	CFG_GATE_SETCLR(GATE_ETH2CK,	RCC_MP_AHB6ENSETR,	27),
+	CFG_GATE_SETCLR(GATE_ETH2TX,	RCC_MP_AHB6ENSETR,	28),
+	CFG_GATE_SETCLR(GATE_ETH2RX,	RCC_MP_AHB6ENSETR,	29),
+	CFG_GATE_SETCLR(GATE_ETH2MAC,	RCC_MP_AHB6ENSETR,	30),
+	CFG_GATE_SETCLR(GATE_ETH1STP,	RCC_MP_AHB6LPENSETR,	11),
+	CFG_GATE_SETCLR(GATE_ETH2STP,	RCC_MP_AHB6LPENSETR,	31),
+	CFG_GATE_SETCLR(GATE_MDMA,	RCC_MP_NS_AHB6ENSETR,	0),
+};
+
+enum enum_mux_cfg {
+	MUX_MPU,
+	MUX_AXI,
+	MUX_MLAHB,
+	MUX_PLL12,
+	MUX_PLL3,
+	MUX_PLL4,
+	MUX_RTC,
+	MUX_CKPER,
+	MUX_I2C12,
+	MUX_LPTIM45,
+	MUX_SPI23,
+	MUX_UART35,
+	MUX_UART78,
+	MUX_ADC1,
+	MUX_ADC2,
+	MUX_DCMIPP,
+	MUX_ETH1,
+	MUX_ETH2,
+	MUX_FDCAN,
+	MUX_FMC,
+	MUX_I2C3,
+	MUX_I2C4,
+	MUX_I2C5,
+	MUX_LPTIM1,
+	MUX_LPTIM2,
+	MUX_LPTIM3,
+	MUX_QSPI,
+	MUX_RNG1,
+	MUX_SAES,
+	MUX_SAI1,
+	MUX_SAI2,
+	MUX_SDMMC1,
+	MUX_SDMMC2,
+	MUX_SPDIF,
+	MUX_SPI1,
+	MUX_SPI4,
+	MUX_SPI5,
+	MUX_STGEN,
+	MUX_UART1,
+	MUX_UART2,
+	MUX_UART4,
+	MUX_UART6,
+	MUX_USBO,
+	MUX_USBPHY,
+	MUX_MCO1,
+	MUX_MCO2,
+	MUX_NB
+};
+
+#define _CFG_MUX(_id, _offset, _shift, _witdh, _ready, _flags)\
+	[_id] = {\
+		.offset		= (_offset),\
+		.shift		= (_shift),\
+		.width		= (_witdh),\
+		.ready		= (_ready),\
+		.flags		= (_flags),\
+	}
+
+#define CFG_MUX(_id, _offset, _shift, _witdh)\
+	_CFG_MUX(_id, _offset, _shift, _witdh, MUX_NO_RDY, 0)
+
+#define CFG_MUX_RDY(_id, _offset, _shift, _witdh, _ready)\
+	_CFG_MUX(_id, _offset, _shift, _witdh, _ready, 0)
+
+#define CFG_MUX_SAFE(_id, _offset, _shift, _witdh)\
+	_CFG_MUX(_id, _offset, _shift, _witdh, MUX_NO_RDY, MUX_SAFE)
+
+static const struct stm32_mux_cfg stm32mp13_muxes[] = {
+	CFG_MUX(MUX_MPU,	RCC_MPCKSELR,		0, 2),
+	CFG_MUX(MUX_AXI,	RCC_ASSCKSELR,		0, 3),
+	CFG_MUX(MUX_MLAHB,	RCC_MSSCKSELR,		0, 2),
+	CFG_MUX(MUX_PLL12,	RCC_RCK12SELR,		0, 2),
+	CFG_MUX(MUX_PLL3,	RCC_RCK3SELR,		0, 2),
+	CFG_MUX(MUX_PLL4,	RCC_RCK4SELR,		0, 2),
+	CFG_MUX(MUX_CKPER,	RCC_CPERCKSELR,		0, 2),
+	CFG_MUX(MUX_RTC,	RCC_BDCR,		16, 2),
+	CFG_MUX(MUX_I2C12,	RCC_I2C12CKSELR,	0, 3),
+	CFG_MUX(MUX_LPTIM45,	RCC_LPTIM45CKSELR,	0, 3),
+	CFG_MUX(MUX_SPI23,	RCC_SPI2S23CKSELR,	0, 3),
+	CFG_MUX(MUX_UART35,	RCC_UART35CKSELR,	0, 3),
+	CFG_MUX(MUX_UART78,	RCC_UART78CKSELR,	0, 3),
+	CFG_MUX(MUX_ADC1,	RCC_ADC12CKSELR,	0, 2),
+	CFG_MUX(MUX_ADC2,	RCC_ADC12CKSELR,	2, 2),
+	CFG_MUX(MUX_DCMIPP,	RCC_DCMIPPCKSELR,	0, 2),
+	CFG_MUX(MUX_ETH1,	RCC_ETH12CKSELR,	0, 2),
+	CFG_MUX(MUX_ETH2,	RCC_ETH12CKSELR,	8, 2),
+	CFG_MUX(MUX_FDCAN,	RCC_FDCANCKSELR,	0, 2),
+	CFG_MUX(MUX_I2C3,	RCC_I2C345CKSELR,	0, 3),
+	CFG_MUX(MUX_I2C4,	RCC_I2C345CKSELR,	3, 3),
+	CFG_MUX(MUX_I2C5,	RCC_I2C345CKSELR,	6, 3),
+	CFG_MUX(MUX_LPTIM1,	RCC_LPTIM1CKSELR,	0, 3),
+	CFG_MUX(MUX_LPTIM2,	RCC_LPTIM23CKSELR,	0, 3),
+	CFG_MUX(MUX_LPTIM3,	RCC_LPTIM23CKSELR,	3, 3),
+	CFG_MUX(MUX_MCO1,	RCC_MCO1CFGR,		0, 3),
+	CFG_MUX(MUX_MCO2,	RCC_MCO2CFGR,		0, 3),
+	CFG_MUX(MUX_RNG1,	RCC_RNG1CKSELR,		0, 2),
+	CFG_MUX(MUX_SAES,	RCC_SAESCKSELR,		0, 2),
+	CFG_MUX(MUX_SAI1,	RCC_SAI1CKSELR,		0, 3),
+	CFG_MUX(MUX_SAI2,	RCC_SAI2CKSELR,		0, 3),
+	CFG_MUX(MUX_SPDIF,	RCC_SPDIFCKSELR,	0, 2),
+	CFG_MUX(MUX_SPI1,	RCC_SPI2S1CKSELR,	0, 3),
+	CFG_MUX(MUX_SPI4,	RCC_SPI45CKSELR,	0, 3),
+	CFG_MUX(MUX_SPI5,	RCC_SPI45CKSELR,	3, 3),
+	CFG_MUX(MUX_STGEN,	RCC_STGENCKSELR,	0, 2),
+	CFG_MUX(MUX_UART1,	RCC_UART12CKSELR,	0, 3),
+	CFG_MUX(MUX_UART2,	RCC_UART12CKSELR,	3, 3),
+	CFG_MUX(MUX_UART4,	RCC_UART4CKSELR,	0, 3),
+	CFG_MUX(MUX_UART6,	RCC_UART6CKSELR,	0, 3),
+	CFG_MUX(MUX_USBO,	RCC_USBCKSELR,		4, 1),
+	CFG_MUX(MUX_USBPHY,	RCC_USBCKSELR,		0, 2),
+
+	CFG_MUX_SAFE(MUX_FMC,	RCC_FMCCKSELR,		0, 2),
+	CFG_MUX_SAFE(MUX_QSPI,	RCC_QSPICKSELR,		0, 2),
+	CFG_MUX_SAFE(MUX_SDMMC1, RCC_SDMMC12CKSELR,	0, 3),
+	CFG_MUX_SAFE(MUX_SDMMC2, RCC_SDMMC12CKSELR,	3, 3),
+};
+
+enum enum_div_cfg {
+	DIV_PLL1DIVP,
+	DIV_PLL2DIVP,
+	DIV_PLL2DIVQ,
+	DIV_PLL2DIVR,
+	DIV_PLL3DIVP,
+	DIV_PLL3DIVQ,
+	DIV_PLL3DIVR,
+	DIV_PLL4DIVP,
+	DIV_PLL4DIVQ,
+	DIV_PLL4DIVR,
+	DIV_MPU,
+	DIV_AXI,
+	DIV_MLAHB,
+	DIV_APB1,
+	DIV_APB2,
+	DIV_APB3,
+	DIV_APB4,
+	DIV_APB5,
+	DIV_APB6,
+	DIV_RTC,
+	DIV_HSI,
+	DIV_MCO1,
+	DIV_MCO2,
+	DIV_TRACE,
+	DIV_ETH1PTP,
+	DIV_ETH2PTP,
+	DIV_NB
+};
+
+static const struct clk_div_table ck_trace_div_table[] = {
+	{ 0, 1 }, { 1, 2 }, { 2, 4 }, { 3, 8 },
+	{ 4, 16 }, { 5, 16 }, { 6, 16 }, { 7, 16 },
+	{ 0 },
+};
+
+#define CFG_DIV(_id, _offset, _shift, _width, _flags, _table, _ready)\
+	[(_id)] = {\
+		.offset	= (_offset),\
+		.shift	= (_shift),\
+		.width	= (_width),\
+		.flags	= (_flags),\
+		.table	= (_table),\
+		.ready	= (_ready),\
+	}
+
+static const struct clk_div_table axi_div_table[] = {
+	{ 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 4 },
+	{ 4, 4 }, { 5, 4 }, { 6, 4 }, { 7, 4 },
+	{ 0 },
+};
+
+static const struct clk_div_table mlahb_div_table[] = {
+	{ 0, 1 }, { 1, 2 }, { 2, 4 }, { 3, 8 },
+	{ 4, 16 }, { 5, 32 }, { 6, 64 }, { 7, 128 },
+	{ 8, 256 }, { 9, 512 }, { 10, 512}, { 11, 512 },
+	{ 12, 512 }, { 13, 512 }, { 14, 512}, { 15, 512 },
+	{ 0 },
+};
+
+static const struct clk_div_table apb_div_table[] = {
+	{ 0, 1 }, { 1, 2 }, { 2, 4 }, { 3, 8 },
+	{ 4, 16 }, { 5, 16 }, { 6, 16 }, { 7, 16 },
+	{ 0 },
+};
+
+static const struct stm32_div_cfg stm32mp13_dividers[DIV_NB] = {
+	CFG_DIV(DIV_MPU, RCC_MPCKDIVR, 0, 4, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_AXI, RCC_AXIDIVR, 0, 3, 0, axi_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_MLAHB, RCC_MLAHBDIVR, 0, 4, 0, mlahb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB1, RCC_APB1DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB2, RCC_APB2DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB3, RCC_APB3DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB4, RCC_APB4DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB5, RCC_APB5DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB6, RCC_APB6DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_HSI, RCC_HSICFGR, 0, 2, CLK_DIVIDER_POWER_OF_TWO, NULL, DIV_NO_RDY),
+
+	CFG_DIV(DIV_PLL1DIVP, RCC_PLL1CFGR2, 0, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL2DIVP, RCC_PLL2CFGR2, 0, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL2DIVQ, RCC_PLL2CFGR2, 8, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL2DIVR, RCC_PLL2CFGR2, 16, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL3DIVP, RCC_PLL3CFGR2, 0, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL3DIVQ, RCC_PLL3CFGR2, 8, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL3DIVR, RCC_PLL3CFGR2, 16, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL4DIVP, RCC_PLL4CFGR2, 0, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL4DIVQ, RCC_PLL4CFGR2, 8, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL4DIVR, RCC_PLL4CFGR2, 16, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_RTC, RCC_RTCDIVR, 0, 6, 0, NULL, DIV_NO_RDY),
+
+	CFG_DIV(DIV_MCO1, RCC_MCO1CFGR, 4, 4, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_MCO2, RCC_MCO2CFGR, 4, 4, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_TRACE, RCC_DBGCFGR, 0, 3, 0, ck_trace_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_ETH1PTP, RCC_ETH12CKSELR, 4, 4, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_ETH2PTP, RCC_ETH12CKSELR, 12, 4, 0, NULL, DIV_NO_RDY),
+};
+
+struct clk_stm32_securiy {
+	u16	offset;
+	u8	bit_idx;
+};
+
+enum securit_clk {
+	SECF_NONE,
+	SECF_LPTIM2,
+	SECF_LPTIM3,
+	SECF_VREF,
+	SECF_DCMIPP,
+	SECF_USBPHY,
+	SECF_RTC,
+	SECF_TZC,
+	SECF_ETZPC,
+	SECF_IWDG1,
+	SECF_BSEC,
+	SECF_STGENC,
+	SECF_STGENRO,
+	SECF_USART1,
+	SECF_USART2,
+	SECF_SPI4,
+	SECF_SPI5,
+	SECF_I2C3,
+	SECF_I2C4,
+	SECF_I2C5,
+	SECF_TIM12,
+	SECF_TIM13,
+	SECF_TIM14,
+	SECF_TIM15,
+	SECF_TIM16,
+	SECF_TIM17,
+	SECF_DMA3,
+	SECF_DMAMUX2,
+	SECF_ADC1,
+	SECF_ADC2,
+	SECF_USBO,
+	SECF_TSC,
+	SECF_PKA,
+	SECF_SAES,
+	SECF_CRYP1,
+	SECF_HASH1,
+	SECF_RNG1,
+	SECF_BKPSRAM,
+	SECF_MCE,
+	SECF_FMC,
+	SECF_QSPI,
+	SECF_SDMMC1,
+	SECF_SDMMC2,
+	SECF_ETH1CK,
+	SECF_ETH1TX,
+	SECF_ETH1RX,
+	SECF_ETH1MAC,
+	SECF_ETH1STP,
+	SECF_ETH2CK,
+	SECF_ETH2TX,
+	SECF_ETH2RX,
+	SECF_ETH2MAC,
+	SECF_ETH2STP,
+	SECF_MCO1,
+	SECF_MCO2
+};
+
+#define SECF(_sec_id, _offset, _bit_idx)[_sec_id] = {\
+	.offset	= _offset,\
+	.bit_idx	= _bit_idx,\
+}
+
+static const struct clk_stm32_securiy stm32mp13_security[] = {
+	SECF(SECF_LPTIM2, RCC_APB3SECSR, RCC_APB3SECSR_LPTIM2SECF),
+	SECF(SECF_LPTIM3, RCC_APB3SECSR, RCC_APB3SECSR_LPTIM3SECF),
+	SECF(SECF_VREF, RCC_APB3SECSR, RCC_APB3SECSR_VREFSECF),
+	SECF(SECF_DCMIPP, RCC_APB4SECSR, RCC_APB4SECSR_DCMIPPSECF),
+	SECF(SECF_USBPHY, RCC_APB4SECSR, RCC_APB4SECSR_USBPHYSECF),
+	SECF(SECF_RTC, RCC_APB5SECSR, RCC_APB5SECSR_RTCSECF),
+	SECF(SECF_TZC, RCC_APB5SECSR, RCC_APB5SECSR_TZCSECF),
+	SECF(SECF_ETZPC, RCC_APB5SECSR, RCC_APB5SECSR_ETZPCSECF),
+	SECF(SECF_IWDG1, RCC_APB5SECSR, RCC_APB5SECSR_IWDG1SECF),
+	SECF(SECF_BSEC, RCC_APB5SECSR, RCC_APB5SECSR_BSECSECF),
+	SECF(SECF_STGENC, RCC_APB5SECSR, RCC_APB5SECSR_STGENCSECF),
+	SECF(SECF_STGENRO, RCC_APB5SECSR, RCC_APB5SECSR_STGENROSECF),
+	SECF(SECF_USART1, RCC_APB6SECSR, RCC_APB6SECSR_USART1SECF),
+	SECF(SECF_USART2, RCC_APB6SECSR, RCC_APB6SECSR_USART2SECF),
+	SECF(SECF_SPI4, RCC_APB6SECSR, RCC_APB6SECSR_SPI4SECF),
+	SECF(SECF_SPI5, RCC_APB6SECSR, RCC_APB6SECSR_SPI5SECF),
+	SECF(SECF_I2C3, RCC_APB6SECSR, RCC_APB6SECSR_I2C3SECF),
+	SECF(SECF_I2C4, RCC_APB6SECSR, RCC_APB6SECSR_I2C4SECF),
+	SECF(SECF_I2C5, RCC_APB6SECSR, RCC_APB6SECSR_I2C5SECF),
+	SECF(SECF_TIM12, RCC_APB6SECSR, RCC_APB6SECSR_TIM12SECF),
+	SECF(SECF_TIM13, RCC_APB6SECSR, RCC_APB6SECSR_TIM13SECF),
+	SECF(SECF_TIM14, RCC_APB6SECSR, RCC_APB6SECSR_TIM14SECF),
+	SECF(SECF_TIM15, RCC_APB6SECSR, RCC_APB6SECSR_TIM15SECF),
+	SECF(SECF_TIM16, RCC_APB6SECSR, RCC_APB6SECSR_TIM16SECF),
+	SECF(SECF_TIM17, RCC_APB6SECSR, RCC_APB6SECSR_TIM17SECF),
+	SECF(SECF_DMA3, RCC_AHB2SECSR, RCC_AHB2SECSR_DMA3SECF),
+	SECF(SECF_DMAMUX2, RCC_AHB2SECSR, RCC_AHB2SECSR_DMAMUX2SECF),
+	SECF(SECF_ADC1, RCC_AHB2SECSR, RCC_AHB2SECSR_ADC1SECF),
+	SECF(SECF_ADC2, RCC_AHB2SECSR, RCC_AHB2SECSR_ADC2SECF),
+	SECF(SECF_USBO, RCC_AHB2SECSR, RCC_AHB2SECSR_USBOSECF),
+	SECF(SECF_TSC, RCC_AHB4SECSR, RCC_AHB4SECSR_TSCSECF),
+	SECF(SECF_PKA, RCC_AHB5SECSR, RCC_AHB5SECSR_PKASECF),
+	SECF(SECF_SAES, RCC_AHB5SECSR, RCC_AHB5SECSR_SAESSECF),
+	SECF(SECF_CRYP1, RCC_AHB5SECSR, RCC_AHB5SECSR_CRYP1SECF),
+	SECF(SECF_HASH1, RCC_AHB5SECSR, RCC_AHB5SECSR_HASH1SECF),
+	SECF(SECF_RNG1, RCC_AHB5SECSR, RCC_AHB5SECSR_RNG1SECF),
+	SECF(SECF_BKPSRAM, RCC_AHB5SECSR, RCC_AHB5SECSR_BKPSRAMSECF),
+	SECF(SECF_MCE, RCC_AHB6SECSR, RCC_AHB6SECSR_MCESECF),
+	SECF(SECF_FMC, RCC_AHB6SECSR, RCC_AHB6SECSR_FMCSECF),
+	SECF(SECF_QSPI, RCC_AHB6SECSR, RCC_AHB6SECSR_QSPISECF),
+	SECF(SECF_SDMMC1, RCC_AHB6SECSR, RCC_AHB6SECSR_SDMMC1SECF),
+	SECF(SECF_SDMMC2, RCC_AHB6SECSR, RCC_AHB6SECSR_SDMMC2SECF),
+	SECF(SECF_ETH1CK, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH1CKSECF),
+	SECF(SECF_ETH1TX, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH1TXSECF),
+	SECF(SECF_ETH1RX, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH1RXSECF),
+	SECF(SECF_ETH1MAC, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH1MACSECF),
+	SECF(SECF_ETH1STP, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH1STPSECF),
+	SECF(SECF_ETH2CK, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH2CKSECF),
+	SECF(SECF_ETH2TX, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH2TXSECF),
+	SECF(SECF_ETH2RX, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH2RXSECF),
+	SECF(SECF_ETH2MAC, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH2MACSECF),
+	SECF(SECF_ETH2STP, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH2STPSECF),
+	SECF(SECF_MCO1, RCC_SECCFGR, RCC_SECCFGR_MCO1SECF),
+	SECF(SECF_MCO2, RCC_SECCFGR, RCC_SECCFGR_MCO2SECF),
+};
+
+#define CLK_KER(_name, _parents, _flags, _gate_id, _mux_id)\
+	CLK_STM32_COMPOSITE(_name, _parents, ((_flags) | CLK_OPS_PARENT_ENABLE |\
+			    CLK_SET_RATE_NO_REPARENT), _gate_id, _mux_id, NO_STM32_DIV)
+
+static CLK_STM32_GATE(tim2_k, "timg1_ck", CLK_SET_RATE_PARENT, GATE_TIM2);
+static CLK_STM32_GATE(tim3_k, "timg1_ck", CLK_SET_RATE_PARENT, GATE_TIM3);
+static CLK_STM32_GATE(tim4_k, "timg1_ck", CLK_SET_RATE_PARENT, GATE_TIM4);
+static CLK_STM32_GATE(tim5_k, "timg1_ck", CLK_SET_RATE_PARENT, GATE_TIM5);
+static CLK_STM32_GATE(tim6_k, "timg1_ck", CLK_SET_RATE_PARENT, GATE_TIM6);
+static CLK_STM32_GATE(tim7_k, "timg1_ck", CLK_SET_RATE_PARENT, GATE_TIM7);
+static CLK_STM32_GATE(tim1_k, "timg2_ck", CLK_SET_RATE_PARENT, GATE_TIM1);
+static CLK_STM32_GATE(tim8_k, "timg2_ck", CLK_SET_RATE_PARENT, GATE_TIM8);
+static CLK_STM32_GATE(tim12_k, "timg3_ck", CLK_SET_RATE_PARENT, GATE_TIM12);
+static CLK_STM32_GATE(tim13_k, "timg3_ck", CLK_SET_RATE_PARENT, GATE_TIM13);
+static CLK_STM32_GATE(tim14_k, "timg3_ck", CLK_SET_RATE_PARENT, GATE_TIM14);
+static CLK_STM32_GATE(tim15_k, "timg3_ck", CLK_SET_RATE_PARENT, GATE_TIM15);
+static CLK_STM32_GATE(tim16_k, "timg3_ck", CLK_SET_RATE_PARENT, GATE_TIM16);
+static CLK_STM32_GATE(tim17_k, "timg3_ck", CLK_SET_RATE_PARENT, GATE_TIM17);
+
+static CLK_STM32_GATE(spi2, "pclk1", 0, GATE_SPI2);
+static CLK_STM32_GATE(spi3, "pclk1", 0, GATE_SPI3);
+
+static CLK_STM32_GATE(sai1, "pclk2", 0, GATE_SAI1);
+static CLK_STM32_GATE(sai2, "pclk2", 0, GATE_SAI2);
+static CLK_STM32_GATE(spi1, "pclk2", 0, GATE_SPI1);
+
+static CLK_STM32_GATE(syscfg, "pclk3", 0, GATE_SYSCFG);
+static CLK_STM32_GATE(vref, "pclk3", 0, GATE_VREF);
+static CLK_STM32_GATE(dts, "pclk3", 0, GATE_DTS);
+static CLK_STM32_GATE(pmbctrl, "pclk3", 0, GATE_PMBCTRL);
+static CLK_STM32_GATE(hdp, "pclk3", 0, GATE_HDP);
+
+static CLK_STM32_GATE(iwdg2, "pclk4", 0, GATE_IWDG2APB);
+static CLK_STM32_GATE(stgenro, "pclk4", 0, GATE_STGENRO);
+static CLK_STM32_GATE(gpioa, "pclk4", 0, GATE_GPIOA);
+static CLK_STM32_GATE(gpiob, "pclk4", 0, GATE_GPIOB);
+static CLK_STM32_GATE(gpioc, "pclk4", 0, GATE_GPIOC);
+static CLK_STM32_GATE(gpiod, "pclk4", 0, GATE_GPIOD);
+static CLK_STM32_GATE(gpioe, "pclk4", 0, GATE_GPIOE);
+static CLK_STM32_GATE(gpiof, "pclk4", 0, GATE_GPIOF);
+static CLK_STM32_GATE(gpiog, "pclk4", 0, GATE_GPIOG);
+static CLK_STM32_GATE(gpioh, "pclk4", 0, GATE_GPIOH);
+static CLK_STM32_GATE(gpioi, "pclk4", 0, GATE_GPIOI);
+static CLK_STM32_GATE(tsc, "pclk4", 0, GATE_TSC);
+static CLK_STM32_GATE(ddrperfm, "pclk4", 0, GATE_DDRPERFM);
+
+static CLK_STM32_GATE(tzpc, "pclk5", 0, GATE_TZC);
+static CLK_STM32_GATE(iwdg1, "pclk5", 0, GATE_IWDG1APB);
+static CLK_STM32_GATE(bsec, "pclk5", 0, GATE_BSEC);
+
+static CLK_STM32_GATE(spi4, "pclk6", 0, GATE_SPI4);
+static CLK_STM32_GATE(spi5, "pclk6", 0, GATE_SPI5);
+
+static CLK_STM32_GATE(dma1, "ck_mlahb", 0, GATE_DMA1);
+static CLK_STM32_GATE(dma2, "ck_mlahb",  0, GATE_DMA2);
+static CLK_STM32_GATE(dmamux1, "ck_mlahb", 0, GATE_DMAMUX1);
+static CLK_STM32_GATE(dma3, "ck_mlahb", 0, GATE_DMA3);
+static CLK_STM32_GATE(dmamux2, "ck_mlahb", 0, GATE_DMAMUX2);
+static CLK_STM32_GATE(adc1, "ck_mlahb", 0, GATE_ADC1);
+static CLK_STM32_GATE(adc2, "ck_mlahb", 0, GATE_ADC2);
+
+static CLK_STM32_GATE(pka, "ck_axi", 0, GATE_PKA);
+static CLK_STM32_GATE(cryp1, "ck_axi", 0, GATE_CRYP1);
+static CLK_STM32_GATE(hash1, "ck_axi", 0, GATE_HASH1);
+static CLK_STM32_GATE(bkpsram, "ck_axi", 0, GATE_BKPSRAM);
+static CLK_STM32_GATE(mdma, "ck_axi", 0, GATE_MDMA);
+static CLK_STM32_GATE(eth1tx, "ck_axi", 0, GATE_ETH1TX);
+static CLK_STM32_GATE(eth1rx, "ck_axi", 0, GATE_ETH1RX);
+static CLK_STM32_GATE(eth1mac, "ck_axi", 0, GATE_ETH1MAC);
+static CLK_STM32_GATE(eth2tx, "ck_axi", 0, GATE_ETH2TX);
+static CLK_STM32_GATE(eth2rx, "ck_axi", 0, GATE_ETH2RX);
+static CLK_STM32_GATE(eth2mac, "ck_axi", 0, GATE_ETH2MAC);
+static CLK_STM32_GATE(crc1, "ck_axi", 0, GATE_CRC1);
+static CLK_STM32_GATE(usbh, "ck_axi", 0, GATE_USBH);
+static CLK_STM32_GATE(eth1stp, "ck_axi", 0, GATE_ETH1STP);
+static CLK_STM32_GATE(eth2stp, "ck_axi", 0, GATE_ETH2STP);
+
+static CLK_KER(sdmmc1_k, sdmmc12_src, 0, GATE_SDMMC1, MUX_SDMMC1);
+static CLK_KER(sdmmc2_k, sdmmc12_src, 0, GATE_SDMMC2, MUX_SDMMC2);
+static CLK_KER(fmc_k, fmc_src, 0, GATE_FMC, MUX_FMC);
+static CLK_KER(qspi_k, qspi_src, 0, GATE_QSPI, MUX_QSPI);
+static CLK_KER(spi2_k, spi123_src, 0, GATE_SPI2, MUX_SPI23);
+static CLK_KER(spi3_k, spi123_src, 0, GATE_SPI3, MUX_SPI23);
+static CLK_KER(i2c1_k, i2c12_src, 0, GATE_I2C1, MUX_I2C12);
+static CLK_KER(i2c2_k, i2c12_src, 0, GATE_I2C2, MUX_I2C12);
+static CLK_KER(lptim4_k, lptim45_src, 0, GATE_LPTIM4, MUX_LPTIM45);
+static CLK_KER(lptim5_k, lptim45_src, 0, GATE_LPTIM5, MUX_LPTIM45);
+static CLK_KER(usart3_k, usart34578_src, 0, GATE_USART3, MUX_UART35);
+static CLK_KER(uart5_k, usart34578_src, 0, GATE_UART5, MUX_UART35);
+static CLK_KER(uart7_k, usart34578_src, 0, GATE_UART7, MUX_UART78);
+static CLK_KER(uart8_k, usart34578_src, 0, GATE_UART8, MUX_UART78);
+static CLK_KER(sai1_k, sai1_src, 0, GATE_SAI1, MUX_SAI1);
+static CLK_KER(adfsdm_k, sai1_src, 0, GATE_ADFSDM, MUX_SAI1);
+static CLK_KER(sai2_k, sai2_src, 0, GATE_SAI2, MUX_SAI2);
+static CLK_KER(adc1_k, adc12_src, 0, GATE_ADC1, MUX_ADC1);
+static CLK_KER(adc2_k, adc12_src, 0, GATE_ADC2, MUX_ADC2);
+static CLK_KER(rng1_k, rng1_src, 0, GATE_RNG1, MUX_RNG1);
+static CLK_KER(usbphy_k, usbphy_src, 0, GATE_USBPHY, MUX_USBPHY);
+static CLK_KER(stgen_k, stgen_src, 0, GATE_STGENC, MUX_STGEN);
+static CLK_KER(spdif_k, spdif_src, 0, GATE_SPDIF, MUX_SPDIF);
+static CLK_KER(spi1_k, spi123_src, 0, GATE_SPI1, MUX_SPI1);
+static CLK_KER(spi4_k, spi4_src, 0, GATE_SPI4, MUX_SPI4);
+static CLK_KER(spi5_k, spi5_src, 0, GATE_SPI5, MUX_SPI5);
+static CLK_KER(i2c3_k, i2c345_src, 0, GATE_I2C3, MUX_I2C3);
+static CLK_KER(i2c4_k, i2c345_src, 0, GATE_I2C4, MUX_I2C4);
+static CLK_KER(i2c5_k, i2c345_src, 0, GATE_I2C5, MUX_I2C5);
+static CLK_KER(lptim1_k, lptim1_src, 0, GATE_LPTIM1, MUX_LPTIM1);
+static CLK_KER(lptim2_k, lptim23_src, 0, GATE_LPTIM2, MUX_LPTIM2);
+static CLK_KER(lptim3_k, lptim23_src, 0, GATE_LPTIM3, MUX_LPTIM3);
+static CLK_KER(usart1_k, usart12_src, 0, GATE_USART1, MUX_UART1);
+static CLK_KER(usart2_k, usart12_src, 0, GATE_USART2, MUX_UART2);
+static CLK_KER(uart4_k, usart34578_src, 0, GATE_UART4, MUX_UART4);
+static CLK_KER(uart6_k, usart6_src, 0, GATE_USART6, MUX_UART6);
+static CLK_KER(fdcan_k, fdcan_src, 0, GATE_FDCAN, MUX_FDCAN);
+static CLK_KER(dcmipp_k, dcmipp_src, 0, GATE_DCMIPP, MUX_DCMIPP);
+static CLK_KER(usbo_k, usbo_src, 0, GATE_USBO, MUX_USBO);
+static CLK_KER(eth1ck_k, eth12_src, 0, GATE_ETH1CK, MUX_ETH1);
+static CLK_KER(eth2ck_k, eth12_src, 0, GATE_ETH2CK, MUX_ETH2);
+static CLK_KER(saes_k, saes_src, 0, GATE_SAES, MUX_SAES);
+
+static CLK_STM32_GATE(dfsdm_k, "ck_mlahb", 0, GATE_DFSDM);
+static CLK_STM32_GATE(ltdc_px, "pll4_q", CLK_SET_RATE_PARENT, GATE_LTDC);
+
+static CLK_STM32_COMPOSITE(eth1ptp_k, eth12_src, CLK_OPS_PARENT_ENABLE |
+			   CLK_SET_RATE_NO_REPARENT,
+			   NO_STM32_GATE, MUX_ETH1, DIV_ETH1PTP);
+
+static CLK_STM32_COMPOSITE(eth2ptp_k, eth12_src, CLK_OPS_PARENT_ENABLE |
+			   CLK_SET_RATE_NO_REPARENT,
+			   NO_STM32_GATE, MUX_ETH2, DIV_ETH2PTP);
+
+/* MCO clocks */
+static CLK_STM32_COMPOSITE(ck_mco1, mco1_src, CLK_OPS_PARENT_ENABLE |
+			   CLK_SET_RATE_NO_REPARENT | CLK_IGNORE_UNUSED,
+			   GATE_MCO1, MUX_MCO1, DIV_MCO1);
+
+static CLK_STM32_COMPOSITE(ck_mco2, mco2_src, CLK_OPS_PARENT_ENABLE |
+			   CLK_SET_RATE_NO_REPARENT | CLK_IGNORE_UNUSED,
+			   GATE_MCO2, MUX_MCO2, DIV_MCO2);
+
+/* Debug clocks */
+static CLK_STM32_GATE(ck_sys_dbg, "ck_axi", CLK_IS_CRITICAL, GATE_DBGCK);
+
+static CLK_STM32_COMPOSITE(ck_trace, PARENT("ck_axi"), CLK_IGNORE_UNUSED,
+			   GATE_TRACECK, NO_STM32_MUX, DIV_TRACE);
+
+static const struct clock_config stm32mp13_clock_cfg[] = {
+	/* Timer clocks */
+	STM32_GATE_CFG(TIM2_K, tim2_k, SECF_NONE),
+	STM32_GATE_CFG(TIM3_K, tim3_k, SECF_NONE),
+	STM32_GATE_CFG(TIM4_K, tim4_k, SECF_NONE),
+	STM32_GATE_CFG(TIM5_K, tim5_k, SECF_NONE),
+	STM32_GATE_CFG(TIM6_K, tim6_k, SECF_NONE),
+	STM32_GATE_CFG(TIM7_K, tim7_k, SECF_NONE),
+	STM32_GATE_CFG(TIM1_K, tim1_k, SECF_NONE),
+	STM32_GATE_CFG(TIM8_K, tim8_k, SECF_NONE),
+	STM32_GATE_CFG(TIM12_K, tim12_k, SECF_TIM12),
+	STM32_GATE_CFG(TIM13_K, tim13_k, SECF_TIM13),
+	STM32_GATE_CFG(TIM14_K, tim14_k, SECF_TIM14),
+	STM32_GATE_CFG(TIM15_K, tim15_k, SECF_TIM15),
+	STM32_GATE_CFG(TIM16_K, tim16_k, SECF_TIM16),
+	STM32_GATE_CFG(TIM17_K, tim17_k, SECF_TIM17),
+
+	/* Peripheral clocks */
+	STM32_GATE_CFG(SPI1, spi1, SECF_NONE),
+	STM32_GATE_CFG(SPI2, spi2, SECF_NONE),
+	STM32_GATE_CFG(SPI3, spi3, SECF_NONE),
+	STM32_GATE_CFG(SPI4, spi4, SECF_SPI4),
+	STM32_GATE_CFG(SPI5, spi5, SECF_SPI5),
+	STM32_GATE_CFG(SAI1, sai1, SECF_NONE),
+	STM32_GATE_CFG(SAI2, sai2, SECF_NONE),
+	STM32_GATE_CFG(SYSCFG, syscfg, SECF_NONE),
+	STM32_GATE_CFG(VREF, vref, SECF_VREF),
+	STM32_GATE_CFG(DTS, dts, SECF_NONE),
+	STM32_GATE_CFG(PMBCTRL, pmbctrl, SECF_NONE),
+	STM32_GATE_CFG(HDP, hdp, SECF_NONE),
+	STM32_GATE_CFG(IWDG2, iwdg2, SECF_NONE),
+	STM32_GATE_CFG(STGENRO, stgenro, SECF_STGENRO),
+	STM32_GATE_CFG(TZPC, tzpc, SECF_TZC),
+	STM32_GATE_CFG(IWDG1, iwdg1, SECF_IWDG1),
+	STM32_GATE_CFG(BSEC, bsec, SECF_BSEC),
+	STM32_GATE_CFG(DMA1, dma1, SECF_NONE),
+	STM32_GATE_CFG(DMA2, dma2, SECF_NONE),
+	STM32_GATE_CFG(DMAMUX1, dmamux1, SECF_NONE),
+	STM32_GATE_CFG(DMA3, dma3, SECF_DMA3),
+	STM32_GATE_CFG(DMAMUX2, dmamux2, SECF_DMAMUX2),
+	STM32_GATE_CFG(ADC1, adc1, SECF_ADC1),
+	STM32_GATE_CFG(ADC2, adc2, SECF_ADC2),
+	STM32_GATE_CFG(GPIOA, gpioa, SECF_NONE),
+	STM32_GATE_CFG(GPIOB, gpiob, SECF_NONE),
+	STM32_GATE_CFG(GPIOC, gpioc, SECF_NONE),
+	STM32_GATE_CFG(GPIOD, gpiod, SECF_NONE),
+	STM32_GATE_CFG(GPIOE, gpioe, SECF_NONE),
+	STM32_GATE_CFG(GPIOF, gpiof, SECF_NONE),
+	STM32_GATE_CFG(GPIOG, gpiog, SECF_NONE),
+	STM32_GATE_CFG(GPIOH, gpioh, SECF_NONE),
+	STM32_GATE_CFG(GPIOI, gpioi, SECF_NONE),
+	STM32_GATE_CFG(TSC, tsc, SECF_TZC),
+	STM32_GATE_CFG(PKA, pka, SECF_PKA),
+	STM32_GATE_CFG(CRYP1, cryp1, SECF_CRYP1),
+	STM32_GATE_CFG(HASH1, hash1, SECF_HASH1),
+	STM32_GATE_CFG(BKPSRAM, bkpsram, SECF_BKPSRAM),
+	STM32_GATE_CFG(MDMA, mdma, SECF_NONE),
+	STM32_GATE_CFG(ETH1TX, eth1tx, SECF_ETH1TX),
+	STM32_GATE_CFG(ETH1RX, eth1rx, SECF_ETH1RX),
+	STM32_GATE_CFG(ETH1MAC, eth1mac, SECF_ETH1MAC),
+	STM32_GATE_CFG(ETH2TX, eth2tx, SECF_ETH2TX),
+	STM32_GATE_CFG(ETH2RX, eth2rx, SECF_ETH2RX),
+	STM32_GATE_CFG(ETH2MAC, eth2mac, SECF_ETH2MAC),
+	STM32_GATE_CFG(CRC1, crc1, SECF_NONE),
+	STM32_GATE_CFG(USBH, usbh, SECF_NONE),
+	STM32_GATE_CFG(DDRPERFM, ddrperfm, SECF_NONE),
+	STM32_GATE_CFG(ETH1STP, eth1stp, SECF_ETH1STP),
+	STM32_GATE_CFG(ETH2STP, eth2stp, SECF_ETH2STP),
+
+	/* Kernel clocks */
+	STM32_COMPOSITE_CFG(SDMMC1_K, sdmmc1_k, SECF_SDMMC1),
+	STM32_COMPOSITE_CFG(SDMMC2_K, sdmmc2_k, SECF_SDMMC2),
+	STM32_COMPOSITE_CFG(FMC_K, fmc_k, SECF_FMC),
+	STM32_COMPOSITE_CFG(QSPI_K, qspi_k, SECF_QSPI),
+	STM32_COMPOSITE_CFG(SPI2_K, spi2_k, SECF_NONE),
+	STM32_COMPOSITE_CFG(SPI3_K, spi3_k, SECF_NONE),
+	STM32_COMPOSITE_CFG(I2C1_K, i2c1_k, SECF_NONE),
+	STM32_COMPOSITE_CFG(I2C2_K, i2c2_k, SECF_NONE),
+	STM32_COMPOSITE_CFG(LPTIM4_K, lptim4_k, SECF_NONE),
+	STM32_COMPOSITE_CFG(LPTIM5_K, lptim5_k, SECF_NONE),
+	STM32_COMPOSITE_CFG(USART3_K, usart3_k, SECF_NONE),
+	STM32_COMPOSITE_CFG(UART5_K, uart5_k, SECF_NONE),
+	STM32_COMPOSITE_CFG(UART7_K, uart7_k, SECF_NONE),
+	STM32_COMPOSITE_CFG(UART8_K, uart8_k, SECF_NONE),
+	STM32_COMPOSITE_CFG(SAI1_K, sai1_k, SECF_NONE),
+	STM32_COMPOSITE_CFG(SAI2_K, sai2_k, SECF_NONE),
+	STM32_COMPOSITE_CFG(ADFSDM_K, adfsdm_k, SECF_NONE),
+	STM32_COMPOSITE_CFG(ADC1_K, adc1_k, SECF_ADC1),
+	STM32_COMPOSITE_CFG(ADC2_K, adc2_k, SECF_ADC2),
+	STM32_COMPOSITE_CFG(RNG1_K, rng1_k, SECF_RNG1),
+	STM32_COMPOSITE_CFG(USBPHY_K, usbphy_k, SECF_USBPHY),
+	STM32_COMPOSITE_CFG(STGEN_K, stgen_k, SECF_STGENC),
+	STM32_COMPOSITE_CFG(SPDIF_K, spdif_k, SECF_NONE),
+	STM32_COMPOSITE_CFG(SPI1_K, spi1_k, SECF_NONE),
+	STM32_COMPOSITE_CFG(SPI4_K, spi4_k, SECF_SPI4),
+	STM32_COMPOSITE_CFG(SPI5_K, spi5_k, SECF_SPI5),
+	STM32_COMPOSITE_CFG(I2C3_K, i2c3_k, SECF_I2C3),
+	STM32_COMPOSITE_CFG(I2C4_K, i2c4_k, SECF_I2C4),
+	STM32_COMPOSITE_CFG(I2C5_K, i2c5_k, SECF_I2C5),
+	STM32_COMPOSITE_CFG(LPTIM1_K, lptim1_k, SECF_NONE),
+	STM32_COMPOSITE_CFG(LPTIM2_K, lptim2_k, SECF_LPTIM2),
+	STM32_COMPOSITE_CFG(LPTIM3_K, lptim3_k, SECF_LPTIM3),
+	STM32_COMPOSITE_CFG(USART1_K, usart1_k, SECF_USART1),
+	STM32_COMPOSITE_CFG(USART2_K, usart2_k, SECF_USART2),
+	STM32_COMPOSITE_CFG(UART4_K, uart4_k, SECF_NONE),
+	STM32_COMPOSITE_CFG(USART6_K, uart6_k, SECF_NONE),
+	STM32_COMPOSITE_CFG(FDCAN_K, fdcan_k, SECF_NONE),
+	STM32_COMPOSITE_CFG(DCMIPP_K, dcmipp_k, SECF_DCMIPP),
+	STM32_COMPOSITE_CFG(USBO_K, usbo_k, SECF_USBO),
+	STM32_COMPOSITE_CFG(ETH1CK_K, eth1ck_k, SECF_ETH1CK),
+	STM32_COMPOSITE_CFG(ETH2CK_K, eth2ck_k, SECF_ETH2CK),
+	STM32_COMPOSITE_CFG(SAES_K, saes_k, SECF_SAES),
+
+	STM32_GATE_CFG(DFSDM_K, dfsdm_k, SECF_NONE),
+	STM32_GATE_CFG(LTDC_PX, ltdc_px, SECF_NONE),
+
+	STM32_COMPOSITE_CFG(ETH1PTP_K, eth1ptp_k, SECF_ETH1CK),
+	STM32_COMPOSITE_CFG(ETH2PTP_K, eth2ptp_k, SECF_ETH2CK),
+	STM32_COMPOSITE_CFG(CK_MCO1, ck_mco1, SECF_MCO1),
+	STM32_COMPOSITE_CFG(CK_MCO2, ck_mco2, SECF_MCO2),
+
+	STM32_GATE_CFG(CK_DBG, ck_sys_dbg, SECF_NONE),
+
+	STM32_COMPOSITE_CFG(CK_TRACE, ck_trace, SECF_NONE),
+};
+
+static int stm32mp13_check_security(void __iomem *base,
+				    const struct clock_config *cfg)
+{
+	int sec_id = cfg->sec_id;
+	int secured = 0;
+
+	if (sec_id != SECF_NONE) {
+		const struct clk_stm32_securiy *secf;
+
+		secf = &stm32mp13_security[sec_id];
+		secured = !!(readl(base + secf->offset) & BIT(secf->bit_idx));
+	}
+
+	return secured;
+}
+
+struct multi_mux {
+	struct clk_hw *hw1;
+	struct clk_hw *hw2;
+};
+
+static struct multi_mux *stm32_mp13_multi_mux[MUX_NB] = {
+	[MUX_SPI23]	= &(struct multi_mux){ &spi2_k.hw,	&spi3_k.hw },
+	[MUX_I2C12]	= &(struct multi_mux){ &i2c1_k.hw,	&i2c2_k.hw },
+	[MUX_LPTIM45]	= &(struct multi_mux){ &lptim4_k.hw,	&lptim5_k.hw },
+	[MUX_UART35]	= &(struct multi_mux){ &usart3_k.hw,	&uart5_k.hw },
+	[MUX_UART78]	= &(struct multi_mux){ &uart7_k.hw,	&uart8_k.hw },
+	[MUX_SAI1]	= &(struct multi_mux){ &sai1_k.hw,	&adfsdm_k.hw },
+};
+
+static struct clk_hw *clk_stm32_is_multi_mux(struct clk_hw *hw)
+{
+	struct clk_stm32_composite *composite = to_clk_stm32_composite(hw);
+	struct multi_mux *mmux = stm32_mp13_multi_mux[composite->mux_id];
+
+	if (mmux) {
+		if (!(mmux->hw1 == hw))
+			return mmux->hw1;
+		else
+			return mmux->hw2;
+	}
+
+	return NULL;
+}
+
+u16 stm32mp13_cpt_gate[GATE_NB];
+
+#ifdef CONFIG_DEBUG_FS
+static struct clock_summary clock_summary_mp13;
+#endif
+
+struct clk_stm32_clock_data stm32mp13_clock_data = {
+	.gate_cpt	= stm32mp13_cpt_gate,
+	.gates		= stm32mp13_gates,
+	.muxes		= stm32mp13_muxes,
+	.dividers	= stm32mp13_dividers,
+	.is_multi_mux	= clk_stm32_is_multi_mux,
+};
+
+static const struct stm32_rcc_match_data stm32mp13_data = {
+	.tab_clocks	= stm32mp13_clock_cfg,
+	.num_clocks	= ARRAY_SIZE(stm32mp13_clock_cfg),
+	.clock_data	= &stm32mp13_clock_data,
+	.check_security = &stm32mp13_check_security,
+	.maxbinding	= STM32MP1_LAST_CLK,
+	.clear_offset	= RCC_CLR,
+	.reset_us	= 2,
+#ifdef CONFIG_DEBUG_FS
+	.clock_summary	= &clock_summary_mp13,
+#endif
+};
+
+static const struct of_device_id stm32mp13_match_data[] = {
+	{
+		.compatible = "st,stm32mp13-rcc",
+		.data = &stm32mp13_data,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, stm32mp13_match_data);
+
+
+static int stm32mp1_rcc_init(struct device *dev)
+{
+	void __iomem *rcc_base;
+	int ret = -ENOMEM;
+
+	rcc_base = of_iomap(dev_of_node(dev), 0);
+	if (!rcc_base) {
+		dev_err(dev, "%pOFn: unable to map resource", dev_of_node(dev));
+		goto out;
+	}
+
+	ret = stm32_rcc_init(dev, stm32mp13_match_data, rcc_base);
+out:
+	if (ret) {
+		if (rcc_base)
+			iounmap(rcc_base);
+
+		of_node_put(dev_of_node(dev));
+	}
+
+	return ret;
+}
+
+static int get_clock_deps(struct device *dev)
+{
+	static const char * const clock_deps_name[] = {
+		"hsi", "hse", "csi", "lsi", "lse",
+	};
+	size_t deps_size = sizeof(struct clk *) * ARRAY_SIZE(clock_deps_name);
+	struct clk **clk_deps;
+	int i;
+
+	clk_deps = devm_kzalloc(dev, deps_size, GFP_KERNEL);
+	if (!clk_deps)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(clock_deps_name); i++) {
+		struct clk *clk = of_clk_get_by_name(dev_of_node(dev),
+						     clock_deps_name[i]);
+
+		if (IS_ERR(clk)) {
+			if (PTR_ERR(clk) != -EINVAL && PTR_ERR(clk) != -ENOENT)
+				return PTR_ERR(clk);
+		} else {
+			/* Device gets a reference count on the clock */
+			clk_deps[i] = devm_clk_get(dev, __clk_get_name(clk));
+			clk_put(clk);
+		}
+	}
+
+	return 0;
+}
+
+static int stm32mp1_rcc_clocks_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	int ret = get_clock_deps(dev);
+
+	if (!ret)
+		ret = stm32mp1_rcc_init(dev);
+
+	return ret;
+}
+
+static int stm32mp1_rcc_clocks_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *child, *np = dev_of_node(dev);
+
+	for_each_available_child_of_node(np, child)
+		of_clk_del_provider(child);
+
+	return 0;
+}
+
+static struct platform_driver stm32mp13_rcc_clocks_driver = {
+	.driver	= {
+		.name = "stm32mp13_rcc",
+		.of_match_table = stm32mp13_match_data,
+	},
+	.probe = stm32mp1_rcc_clocks_probe,
+	.remove = stm32mp1_rcc_clocks_remove,
+};
+
+static int __init stm32mp13_clocks_init(void)
+{
+	return platform_driver_register(&stm32mp13_rcc_clocks_driver);
+}
+core_initcall(stm32mp13_clocks_init);
+
+#ifdef CONFIG_DEBUG_FS
+
+/* STM32 PLL */
+struct clk_pll_fractional_divider {
+	struct clk_hw hw;
+	void __iomem *mreg;
+	u8 mshift;
+	u8 mwidth;
+	u8 mflags;
+	void __iomem *nreg;
+	u8 nshift;
+	u8 nwidth;
+	u8 nflags;
+	void __iomem *freg;
+	u8 fshift;
+	u8 fwidth;
+
+	/* lock pll enable/disable registers */
+	spinlock_t *lock;
+};
+
+struct cs_pll {
+	u32 offset;
+};
+
+#define PLL_BIT_ON		0
+#define PLL_BIT_RDY		1
+#define PLL_MUX_SHIFT		0
+#define PLL_MUX_MASK		3
+#define PLL_DIVMN_OFFSET	4
+#define PLL_DIVM_SHIFT		16
+#define PLL_DIVM_WIDTH		6
+#define PLL_DIVN_SHIFT		0
+#define PLL_DIVN_WIDTH		9
+#define PLL_FRAC_OFFSET		0xC
+#define PLL_FRAC_SHIFT		3
+#define PLL_FRAC_WIDTH		13
+
+static unsigned long clk_summary_pll_frac_div_recalc_rate(struct clk_stm32_clock_data *data,
+							  struct clk_summary *c,
+							  unsigned long parent_rate)
+{
+	struct cs_pll *pll = (struct cs_pll *)c->data;
+	struct clk_pll_fractional_divider fracdiv;
+	struct clk_pll_fractional_divider *fd = &fracdiv;
+	void __iomem *reg;
+	u32 mmask;
+	u32 nmask;
+	u32 fmask;
+	unsigned long m, n, f;
+	u64 rate, frate = 0;
+	u32 val;
+
+	reg = data->base + pll->offset;
+	fd->mreg = reg + PLL_DIVMN_OFFSET;
+	fd->mshift = PLL_DIVM_SHIFT;
+	fd->mwidth = PLL_DIVM_WIDTH;
+	fd->mflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	fd->nreg = reg + PLL_DIVMN_OFFSET;
+	fd->nshift = PLL_DIVN_SHIFT;
+	fd->nwidth = PLL_DIVN_WIDTH;
+	fd->nflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	fd->freg = reg + PLL_FRAC_OFFSET;
+	fd->fshift = PLL_FRAC_SHIFT;
+	fd->fwidth = PLL_FRAC_WIDTH;
+
+	mmask = GENMASK(fd->mwidth - 1, 0) << fd->mshift;
+	nmask = GENMASK(fd->nwidth - 1, 0) << fd->nshift;
+	fmask = GENMASK(fd->fwidth - 1, 0) << fd->fshift;
+
+	val = readl(fd->mreg);
+	m = (val & mmask) >> fd->mshift;
+	if (fd->mflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		m++;
+
+	val = readl(fd->nreg);
+	n = (val & nmask) >> fd->nshift;
+	if (fd->nflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		n++;
+
+	if (!n || !m)
+		return parent_rate;
+
+	rate = (u64)parent_rate * n;
+	do_div(rate, m);
+
+	val = readl(fd->freg);
+	f = (val & fmask) >> fd->fshift;
+	if (f) {
+		frate = (u64)parent_rate * (u64)f;
+		do_div(frate, (m * (1 << fd->fwidth)));
+	}
+
+	return rate + frate;
+}
+
+static unsigned long clk_summary_hsediv2_recalc_rate(struct clk_stm32_clock_data *data,
+						     struct clk_summary *c,
+						     unsigned long parent_rate)
+{
+	return parent_rate / 2;
+}
+
+static unsigned long clk_summary_osc_recalc_rate(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	struct clk *clk = __clk_lookup(c->name);
+
+	if (clk)
+		return clk_get_rate(clk);
+
+	return 0;
+}
+
+static unsigned long clk_summary_div_recalc_rate(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	return clk_stm32_get_rate_divider(data->base, data, c->div_id, parent_rate);
+}
+
+/* The divider of RTC clock concerns only ck_hse clock */
+#define HSE_RTC 3
+
+static unsigned long clk_summary_rtc_recalc_rate(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	u8 parent;
+
+	parent = clk_stm32_get_parent_mux(data->base, data, c->mux_id);
+	if (parent == HSE_RTC)
+		return clk_summary_div_recalc_rate(data, c, parent_rate);
+
+	return parent_rate;
+}
+
+struct cs_stm32_timer {
+	u32 apbdiv;
+	u32 timpre;
+};
+
+#define APB_DIV_MASK 0x07
+#define TIM_PRE_MASK 0x01
+
+static unsigned long clk_stm32_timer_recalc_rate(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	struct cs_stm32_timer *tim = (struct cs_stm32_timer *)c->data;
+	void __iomem *rcc_base = data->base;
+	u32 prescaler, timpre;
+
+	prescaler = readl(rcc_base + tim->apbdiv) & APB_DIV_MASK;
+
+	timpre = readl(rcc_base + tim->timpre) & TIM_PRE_MASK;
+
+	if (prescaler == 0U)
+		return parent_rate;
+
+	return parent_rate * (timpre + 1U) * 2U;
+}
+
+#define CS_OSC(_name, _gate) \
+{\
+	.name		= _name,\
+	.nb_parents	= 0,\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+	.get_rate	= clk_summary_osc_recalc_rate,\
+}
+#define CS_DIV2(_name, _parent) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+	.get_rate	= clk_summary_hsediv2_recalc_rate,\
+}
+
+#define CS_PLL(_name, _parents, _gate, _mux, _offset)\
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= NO_STM32_DIV,\
+	.data		=  &(struct cs_pll) {\
+		.offset		= _offset,\
+	},\
+	.get_rate	= clk_summary_pll_frac_div_recalc_rate,\
+}
+
+#define CS_DIV(_name, _parent, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.div_id		= _div,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_MUX(_name, _parents, _mux) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.mux_id		= _mux,\
+	.gate_id	= NO_STM32_GATE,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_GATE(_name, _parent, _gate) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_GATEDIV(_name, _parent, _gate, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= _div,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_GATEMUX(_name, _parents, _gate, _mux) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_COMPOSITE(_name, _parents, _gate, _mux, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= _div,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_RTC(_name, _parents, _gate, _mux, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= 4,\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= _div,\
+	.get_rate	= clk_summary_rtc_recalc_rate,\
+}
+
+#define CS_STM32_TIMER(_name, _parent, _apbdiv, _timpre) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.div_id		= NO_STM32_DIV,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.data		=  &(struct cs_stm32_timer) {\
+		.apbdiv		= _apbdiv,\
+		.timpre		= _timpre,\
+	},\
+	.get_rate	= clk_stm32_timer_recalc_rate,\
+}
+
+static const char * const ref12_parents[] = {
+	"ck_hsi", "ck_hse"
+};
+
+static const char * const ref3_parents[] = {
+	"ck_hsi", "ck_hse", "ck_csi"
+};
+
+static const char * const ref4_parents[] = {
+	"ck_hsi", "ck_hse", "ck_csi", "i2s_ckin"
+};
+
+static const char * const cpu_src[] = {
+	"ck_hsi", "ck_hse", "pll1_p", "pll1_p_div"
+};
+
+static const char * const axi_src[] = {
+	"ck_hsi", "ck_hse", "pll2_p"
+};
+
+static const char * const mlahb_src[] = {
+	"ck_hsi", "ck_hse", "ck_csi", "pll3_p"
+};
+
+static const char * const per_src[] = {
+	"ck_hsi", "ck_csi", "ck_hse"
+};
+
+static const char * const rtc_src[] = {
+	"off", "ck_lse", "ck_lsi", "ck_hse"
+};
+
+static struct clk_summary stm32mp13_clock_summary[] = {
+	CS_OSC("ck_hsi", GATE_HSI),
+	CS_OSC("ck_csi", GATE_CSI),
+	CS_OSC("ck_lsi", GATE_LSI),
+	CS_OSC("ck_hse", GATE_HSE),
+	CS_OSC("ck_lse", GATE_LSE),
+
+	CS_OSC("ck_usbo_48m", NO_STM32_GATE),
+	CS_DIV2("clk-hse-div2", "ck_hse"),
+
+	CS_PLL("pll1", ref12_parents, GATE_PLL1, MUX_PLL12, RCC_PLL1CR),
+
+	CS_GATEDIV("pll1_p", "pll1", GATE_PLL1_DIVP, DIV_PLL1DIVP),
+
+	CS_DIV("pll1_p_div", "pll1_p", DIV_MPU),
+
+	CS_PLL("pll2", ref12_parents, GATE_PLL2, MUX_PLL12, RCC_PLL2CR),
+	CS_GATEDIV("pll2_p", "pll2", GATE_PLL2_DIVP, DIV_PLL2DIVP),
+	CS_GATEDIV("pll2_q", "pll2", GATE_PLL2_DIVQ, DIV_PLL2DIVQ),
+	CS_GATEDIV("pll2_r", "pll2", GATE_PLL2_DIVR, DIV_PLL2DIVR),
+
+	CS_PLL("pll3", ref3_parents, GATE_PLL3, MUX_PLL3, RCC_PLL3CR),
+	CS_GATEDIV("pll3_p", "pll3", GATE_PLL3_DIVP, DIV_PLL3DIVP),
+	CS_GATEDIV("pll3_q", "pll3", GATE_PLL3_DIVQ, DIV_PLL3DIVQ),
+	CS_GATEDIV("pll3_r", "pll3", GATE_PLL3_DIVR, DIV_PLL3DIVR),
+
+	CS_PLL("pll4", ref4_parents, GATE_PLL4, MUX_PLL4, RCC_PLL4CR),
+	CS_GATEDIV("pll4_p", "pll4", GATE_PLL4_DIVP, DIV_PLL4DIVP),
+	CS_GATEDIV("pll4_q", "pll4", GATE_PLL4_DIVQ, DIV_PLL4DIVQ),
+	CS_GATEDIV("pll4_r", "pll4", GATE_PLL4_DIVR, DIV_PLL4DIVR),
+
+	CS_MUX("ck_mpu", cpu_src, MUX_MPU),
+	CS_MUX("ck_axi", axi_src, MUX_AXI),
+	CS_MUX("ck_mlahb", mlahb_src, MUX_MLAHB),
+	CS_MUX("ck_per", per_src, MUX_CKPER),
+
+	CS_DIV("pclk1", "ck_mlahb", DIV_APB1),
+	CS_DIV("pclk2", "ck_mlahb", DIV_APB2),
+	CS_DIV("pclk3", "ck_mlahb", DIV_APB3),
+	CS_DIV("pclk4", "ck_axi", DIV_APB4),
+	CS_DIV("pclk5", "ck_axi", DIV_APB5),
+	CS_DIV("pclk6", "ck_mlahb", DIV_APB6),
+
+	CS_STM32_TIMER("timg1_ck", "pclk1", RCC_APB1DIVR, RCC_TIMG1PRER),
+	CS_STM32_TIMER("timg2_ck", "pclk2", RCC_APB2DIVR, RCC_TIMG2PRER),
+	CS_STM32_TIMER("timg3_ck", "pclk1", RCC_APB6DIVR, RCC_TIMG3PRER),
+
+	CS_GATE("tim2_k", "timg1_ck", GATE_TIM2),
+	CS_GATE("tim3_k", "timg1_ck", GATE_TIM3),
+	CS_GATE("tim4_k", "timg1_ck", GATE_TIM4),
+	CS_GATE("tim5_k", "timg1_ck", GATE_TIM5),
+	CS_GATE("tim6_k", "timg1_ck", GATE_TIM6),
+	CS_GATE("tim7_k", "timg1_ck", GATE_TIM7),
+	CS_GATE("tim1_k", "timg2_ck", GATE_TIM1),
+	CS_GATE("tim8_k", "timg2_ck", GATE_TIM8),
+	CS_GATE("tim12_k", "timg3_ck", GATE_TIM12),
+	CS_GATE("tim13_k", "timg3_ck", GATE_TIM13),
+	CS_GATE("tim14_k", "timg3_ck", GATE_TIM14),
+	CS_GATE("tim15_k", "timg3_ck", GATE_TIM15),
+	CS_GATE("tim16_k", "timg3_ck", GATE_TIM16),
+	CS_GATE("tim17_k", "timg3_ck", GATE_TIM17),
+
+	CS_GATE("spi2", "pclk1", GATE_SPI2),
+	CS_GATE("spi3", "pclk1", GATE_SPI3),
+
+	CS_GATE("sai1", "pclk2", GATE_SAI1),
+	CS_GATE("sai2", "pclk2", GATE_SAI2),
+	CS_GATE("spi1", "pclk2", GATE_SPI1),
+
+	CS_GATE("syscfg", "pclk3", GATE_SYSCFG),
+	CS_GATE("vref", "pclk3", GATE_VREF),
+	CS_GATE("dts", "pclk3", GATE_DTS),
+	CS_GATE("pmbctrl", "pclk3", GATE_PMBCTRL),
+	CS_GATE("hdp", "pclk3", GATE_HDP),
+
+	CS_GATE("iwdg2", "pclk4", GATE_IWDG2APB),
+	CS_GATE("stgenro", "pclk4", GATE_STGENRO),
+	CS_GATE("gpioa", "pclk4", GATE_GPIOA),
+	CS_GATE("gpiob", "pclk4", GATE_GPIOB),
+	CS_GATE("gpioc", "pclk4", GATE_GPIOC),
+	CS_GATE("gpiod", "pclk4", GATE_GPIOD),
+	CS_GATE("gpioe", "pclk4", GATE_GPIOE),
+	CS_GATE("gpiof", "pclk4", GATE_GPIOF),
+	CS_GATE("gpiog", "pclk4", GATE_GPIOG),
+	CS_GATE("gpioh", "pclk4", GATE_GPIOH),
+	CS_GATE("gpioi", "pclk4", GATE_GPIOI),
+	CS_GATE("tsc", "pclk4", GATE_TSC),
+	CS_GATE("ddrperfm", "pclk4", GATE_DDRPERFM),
+
+	CS_GATE("tzpc", "pclk5", GATE_TZC),
+	CS_GATE("iwdg1", "pclk5", GATE_IWDG1APB),
+	CS_GATE("bsec", "pclk5", GATE_BSEC),
+
+	CS_GATE("spi4", "pclk6", GATE_SPI4),
+	CS_GATE("spi5", "pclk6", GATE_SPI5),
+
+	CS_GATE("dma1", "ck_mlahb", GATE_DMA1),
+	CS_GATE("dma2", "ck_mlahb", GATE_DMA2),
+	CS_GATE("dmamux1", "ck_mlahb", GATE_DMAMUX1),
+	CS_GATE("dma3", "ck_mlahb", GATE_DMA3),
+	CS_GATE("dmamux2", "ck_mlahb", GATE_DMAMUX2),
+	CS_GATE("adc1", "ck_mlahb", GATE_ADC1),
+	CS_GATE("adc2", "ck_mlahb", GATE_ADC2),
+
+	CS_GATE("pka", "ck_axi", GATE_PKA),
+	CS_GATE("cryp1", "ck_axi", GATE_CRYP1),
+	CS_GATE("hash1", "ck_axi", GATE_HASH1),
+	CS_GATE("bkpsram", "ck_axi", GATE_BKPSRAM),
+	CS_GATE("mdma", "ck_axi", GATE_MDMA),
+	CS_GATE("eth1tx", "ck_axi", GATE_ETH1TX),
+	CS_GATE("eth1rx", "ck_axi", GATE_ETH1RX),
+	CS_GATE("eth1mac", "ck_axi", GATE_ETH1MAC),
+	CS_GATE("eth2tx", "ck_axi", GATE_ETH2TX),
+	CS_GATE("eth2rx", "ck_axi", GATE_ETH2RX),
+	CS_GATE("eth2mac", "ck_axi", GATE_ETH2MAC),
+	CS_GATE("crc1", "ck_axi", GATE_CRC1),
+	CS_GATE("usbh", "ck_axi", GATE_USBH),
+	CS_GATE("eth1stp", "ck_axi", GATE_ETH1STP),
+	CS_GATE("eth2stp", "ck_axi", GATE_ETH2STP),
+
+	CS_GATEMUX("sdmmc1_k", sdmmc12_src, GATE_SDMMC1, MUX_SDMMC1),
+	CS_GATEMUX("sdmmc2_k", sdmmc12_src, GATE_SDMMC2, MUX_SDMMC2),
+	CS_GATEMUX("fmc_k", fmc_src, GATE_FMC, MUX_FMC),
+	CS_GATEMUX("qspi_k", qspi_src, GATE_QSPI, MUX_QSPI),
+	CS_GATEMUX("spi2_k", spi123_src, GATE_SPI2, MUX_SPI23),
+	CS_GATEMUX("spi3_k", spi123_src, GATE_SPI3, MUX_SPI23),
+	CS_GATEMUX("i2c1_k", i2c12_src, GATE_I2C1, MUX_I2C12),
+	CS_GATEMUX("i2c2_k", i2c12_src, GATE_I2C2, MUX_I2C12),
+	CS_GATEMUX("lptim4_k", lptim45_src, GATE_LPTIM4, MUX_LPTIM45),
+	CS_GATEMUX("lptim5_k", lptim45_src, GATE_LPTIM5, MUX_LPTIM45),
+	CS_GATEMUX("usart3_k", usart34578_src, GATE_USART3, MUX_UART35),
+	CS_GATEMUX("uart5_k", usart34578_src, GATE_UART5, MUX_UART35),
+	CS_GATEMUX("uart7_k", usart34578_src, GATE_UART7, MUX_UART78),
+	CS_GATEMUX("uart8_k", usart34578_src, GATE_UART8, MUX_UART78),
+	CS_GATEMUX("sai1_k", sai1_src, GATE_SAI1, MUX_SAI1),
+	CS_GATEMUX("adfsdm_k", sai1_src, GATE_ADFSDM, MUX_SAI1),
+	CS_GATEMUX("sai2_k", sai2_src, GATE_SAI2, MUX_SAI2),
+	CS_GATEMUX("adc1_k", adc12_src, GATE_ADC1, MUX_ADC1),
+	CS_GATEMUX("adc2_k", adc12_src, GATE_ADC2, MUX_ADC2),
+	CS_GATEMUX("rng1_k", rng1_src, GATE_RNG1, MUX_RNG1),
+	CS_GATEMUX("usbphy_k", usbphy_src, GATE_USBPHY, MUX_USBPHY),
+	CS_GATEMUX("stgen_k", stgen_src, GATE_STGENC, MUX_STGEN),
+	CS_GATEMUX("spdif_k", spdif_src, GATE_SPDIF, MUX_SPDIF),
+	CS_GATEMUX("spi1_k", spi123_src, GATE_SPI1, MUX_SPI1),
+	CS_GATEMUX("spi4_k", spi4_src, GATE_SPI4, MUX_SPI4),
+	CS_GATEMUX("spi5_k", spi5_src, GATE_SPI5, MUX_SPI5),
+	CS_GATEMUX("i2c3_k", i2c345_src, GATE_I2C3, MUX_I2C3),
+	CS_GATEMUX("i2c4_k", i2c345_src, GATE_I2C4, MUX_I2C4),
+	CS_GATEMUX("i2c5_k", i2c345_src, GATE_I2C5, MUX_I2C5),
+	CS_GATEMUX("lptim1_k", lptim1_src, GATE_LPTIM1, MUX_LPTIM1),
+	CS_GATEMUX("lptim2_k", lptim23_src, GATE_LPTIM2, MUX_LPTIM2),
+	CS_GATEMUX("lptim3_k", lptim23_src, GATE_LPTIM3, MUX_LPTIM3),
+	CS_GATEMUX("usart1_k", usart12_src, GATE_USART1, MUX_UART1),
+	CS_GATEMUX("usart2_k", usart12_src, GATE_USART2, MUX_UART2),
+	CS_GATEMUX("uart4_k", usart34578_src, GATE_UART4, MUX_UART4),
+	CS_GATEMUX("uart6_k", usart6_src, GATE_USART6, MUX_UART6),
+	CS_GATEMUX("fdcan_k", fdcan_src, GATE_FDCAN, MUX_FDCAN),
+	CS_GATEMUX("dcmipp_k", dcmipp_src, GATE_DCMIPP, MUX_DCMIPP),
+	CS_GATEMUX("usbo_k", usbo_src, GATE_USBO, MUX_USBO),
+	CS_GATEMUX("eth1ck_k", eth12_src, GATE_ETH1CK, MUX_ETH1),
+	CS_GATEMUX("eth2ck_k", eth12_src, GATE_ETH2CK, MUX_ETH2),
+	CS_GATEMUX("saes_k", saes_src, GATE_SAES, MUX_SAES),
+	CS_GATE("dfsdm_k", "ck_mlahb", GATE_DFSDM),
+	CS_GATE("ltdc_px", "pll4_q", GATE_LTDC),
+	CS_COMPOSITE("eth1ptp_k", eth12_src, NO_STM32_GATE, MUX_ETH1, DIV_ETH1PTP),
+	CS_COMPOSITE("eth2ptp_k", eth12_src, NO_STM32_GATE, MUX_ETH2, DIV_ETH2PTP),
+	CS_COMPOSITE("ck_mco1", mco1_src, GATE_MCO1, MUX_MCO1, DIV_MCO1),
+	CS_COMPOSITE("ck_mco2", mco2_src, GATE_MCO2, MUX_MCO2, DIV_MCO2),
+	CS_GATE("ck_sys_dbg", "ck_axi", GATE_DBGCK),
+	CS_GATEDIV("ck_trace", "ck_axi", GATE_TRACECK, DIV_TRACE),
+	CS_GATE("rtcapb", "pclk5", GATE_RTCAPB),
+	CS_RTC("ck_rtc", rtc_src, GATE_RTCCK, MUX_RTC, DIV_RTC),
+};
+
+static struct clock_summary clock_summary_mp13 = {
+	.clocks		= stm32mp13_clock_summary,
+	.nb_clocks	= ARRAY_SIZE(stm32mp13_clock_summary),
+};
+
+
+#endif
diff --git a/drivers/clk/stm32/clk-stm32mp2.c b/drivers/clk/stm32/clk-stm32mp2.c
new file mode 100644
index 000000000..0428e1462
--- /dev/null
+++ b/drivers/clk/stm32/clk-stm32mp2.c
@@ -0,0 +1,2036 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+
+#include "clk-stm32-core.h"
+
+#include <dt-bindings/clock/stm32mp2-clks.h>
+
+#include "stm32mp2_rcc.h"
+
+static void __iomem *rcc_base;
+
+static const char * const adc12_src[] = {
+	"ck_flexgen_46", "ck_icn_ls_mcu"
+};
+
+static const char * const adc3_src[] = {
+	"ck_flexgen_47", "ck_icn_ls_mcu", "ck_flexgen_46"
+};
+
+static const char * const usb2phy1_src[] = {
+	"ck_flexgen_57", "hse_div2_ck"
+};
+
+static const char * const usb2phy2_src[] = {
+	"ck_flexgen_58", "hse_div2_ck"
+};
+
+static const char * const usb3pciphy_src[] = {
+	"ck_flexgen_34", "hse_div2_ck"
+};
+
+static const char * const dsiblane_src[] = {
+	"ck_dsi_phy", "ck_flexgen_27"
+};
+
+static const char * const dsiphy_src[] = {
+	"ck_flexgen_28", "hse_ck"
+};
+
+static const char * const lvdsphy_src[] = {
+	"ck_flexgen_32", "hse_ck"
+};
+
+static const char * const dts_src[] = {
+	"hsi_ck", "hse_ck", "msi_ck"
+};
+
+static const char * const mco1_src[] = {
+	"ck_flexgen_61", "ck_obs0"
+};
+
+static const char * const mco2_src[] = {
+	"ck_flexgen_62", "ck_obs1"
+};
+
+enum enum_mux_cfg {
+	MUX_MCO1,
+	MUX_MCO2,
+	MUX_ADC12,
+	MUX_ADC3,
+	MUX_USB2PHY1,
+	MUX_USB2PHY2,
+	MUX_USB3PCIEPHY,
+	MUX_DSIBLANE,
+	MUX_DSIPHY,
+	MUX_LVDSPHY,
+	MUX_DTS,
+
+#ifdef CONFIG_DEBUG_FS
+	MUX_MUXSEL0,
+	MUX_MUXSEL1,
+	MUX_MUXSEL2,
+	MUX_MUXSEL3,
+	MUX_MUXSEL4,
+	MUX_MUXSEL5,
+	MUX_MUXSEL6,
+	MUX_MUXSEL7,
+	MUX_XBARSEL,
+	MUX_RTC,
+	MUX_CPU1,
+	MUX_D3PER,
+#endif
+	MUX_NB
+};
+
+#define MUX_CFG(id, _offset, _shift, _witdh)\
+	[id] = {\
+		.offset		= (_offset),\
+		.shift		= (_shift),\
+		.width		= (_witdh),\
+	}
+
+static const struct stm32_mux_cfg stm32mp25_muxes[MUX_NB] = {
+	MUX_CFG(MUX_MCO1,		RCC_MCO1CFGR,		0,	1),
+	MUX_CFG(MUX_MCO2,		RCC_MCO2CFGR,		0,	1),
+	MUX_CFG(MUX_ADC12,		RCC_ADC12CFGR,		12,	1),
+	MUX_CFG(MUX_ADC3,		RCC_ADC3CFGR,		12,	2),
+	MUX_CFG(MUX_USB2PHY1,		RCC_USB2PHY1CFGR,	15,	1),
+	MUX_CFG(MUX_USB2PHY2,		RCC_USB2PHY2CFGR,	15,	1),
+	MUX_CFG(MUX_USB3PCIEPHY,	RCC_USB3PCIEPHYCFGR,	15,	1),
+	MUX_CFG(MUX_DSIBLANE,		RCC_DSICFGR,		12,	1),
+	MUX_CFG(MUX_DSIPHY,		RCC_DSICFGR,		15,	1),
+	MUX_CFG(MUX_LVDSPHY,		RCC_LVDSCFGR,		15,	1),
+	MUX_CFG(MUX_DTS,		RCC_DTSCFGR,		12,	2),
+
+#ifdef CONFIG_DEBUG_FS
+	MUX_CFG(MUX_MUXSEL0,		RCC_MUXSELCFGR,		0,	2),
+	MUX_CFG(MUX_MUXSEL1,		RCC_MUXSELCFGR,		4,	2),
+	MUX_CFG(MUX_MUXSEL2,		RCC_MUXSELCFGR,		8,	2),
+	MUX_CFG(MUX_MUXSEL3,		RCC_MUXSELCFGR,		12,	2),
+	MUX_CFG(MUX_MUXSEL4,		RCC_MUXSELCFGR,		16,	2),
+	MUX_CFG(MUX_MUXSEL5,		RCC_MUXSELCFGR,		20,	2),
+	MUX_CFG(MUX_MUXSEL6,		RCC_MUXSELCFGR,		24,	2),
+	MUX_CFG(MUX_MUXSEL7,		RCC_MUXSELCFGR,		28,	2),
+	MUX_CFG(MUX_XBARSEL,		RCC_XBAR0CFGR,		0,	4),
+	MUX_CFG(MUX_RTC,		RCC_BDCR,		16,	2),
+	MUX_CFG(MUX_D3PER,		RCC_D3DCR,		16,	2),
+#endif
+};
+
+enum enum_gate_cfg {
+	GATE_MCO1,
+	GATE_MCO2,
+	GATE_OSPI1,
+	GATE_OSPI2,
+	GATE_DBG,
+	GATE_TRACE,
+	GATE_STM500,
+	GATE_IS2M,
+	GATE_TIM1,
+	GATE_TIM2,
+	GATE_TIM3,
+	GATE_TIM4,
+	GATE_TIM5,
+	GATE_TIM6,
+	GATE_TIM7,
+	GATE_TIM8,
+	GATE_TIM10,
+	GATE_TIM11,
+	GATE_TIM12,
+	GATE_TIM13,
+	GATE_TIM14,
+	GATE_TIM15,
+	GATE_TIM16,
+	GATE_TIM17,
+	GATE_TIM20,
+	GATE_LPTIM1,
+	GATE_LPTIM2,
+	GATE_LPTIM3,
+	GATE_LPTIM4,
+	GATE_LPTIM5,
+	GATE_SPI1,
+	GATE_SPI2,
+	GATE_SPI3,
+	GATE_SPI4,
+	GATE_SPI5,
+	GATE_SPI6,
+	GATE_SPI7,
+	GATE_SPI8,
+	GATE_SPDIFRX,
+	GATE_USART1,
+	GATE_USART2,
+	GATE_USART3,
+	GATE_UART4,
+	GATE_UART5,
+	GATE_USART6,
+	GATE_UART7,
+	GATE_UART8,
+	GATE_UART9,
+	GATE_LPUART1,
+	GATE_I2C1,
+	GATE_I2C2,
+	GATE_I2C3,
+	GATE_I2C4,
+	GATE_I2C5,
+	GATE_I2C6,
+	GATE_I2C7,
+	GATE_I2C8,
+	GATE_SAI1,
+	GATE_SAI2,
+	GATE_SAI3,
+	GATE_SAI4,
+	GATE_MDF1,
+	GATE_ADF1,
+	GATE_FDCAN,
+	GATE_HDP,
+	GATE_ADC12,
+	GATE_ADC3,
+	GATE_ETH1MAC,
+	GATE_ETH1,
+	GATE_ETH1TX,
+	GATE_ETH1RX,
+	GATE_ETH1STP,
+	GATE_ETH2MAC,
+	GATE_ETH2,
+	GATE_ETH2STP,
+	GATE_ETH2TX,
+	GATE_ETH2RX,
+	GATE_USB2,
+	GATE_USB2PHY1,
+	GATE_USB2PHY2,
+	GATE_USB3DRD,
+	GATE_USB3PCIEPHY,
+	GATE_PCIE,
+	GATE_USBTC,
+	GATE_ETHSWMAC,
+	GATE_ETHSW,
+	GATE_ETHSWREF,
+	GATE_ETHSWACMCFG,
+	GATE_ETHSWACMMSG,
+	GATE_STGEN,
+	GATE_SDMMC1,
+	GATE_SDMMC2,
+	GATE_SDMMC3,
+	GATE_GPU,
+	GATE_LTDC,
+	GATE_DSI,
+	GATE_LVDS,
+	GATE_CSI,
+	GATE_DCMIPP,
+	GATE_CCI,
+	GATE_VDEC,
+	GATE_VENC,
+	GATE_RNG,
+	GATE_PKA,
+	GATE_SAES,
+	GATE_HASH,
+	GATE_CRYP1,
+	GATE_CRYP2,
+	GATE_IWDG1,
+	GATE_IWDG2,
+	GATE_IWDG3,
+	GATE_IWDG4,
+	GATE_IWDG5,
+	GATE_WWDG1,
+	GATE_WWDG2,
+	GATE_VREF,
+	GATE_DTS,
+	GATE_CRC,
+	GATE_SERC,
+	GATE_OSPIIOM,
+	GATE_GICV2M,
+	GATE_I3C1,
+	GATE_I3C2,
+	GATE_I3C3,
+	GATE_I3C4,
+
+#ifdef CONFIG_DEBUG_FS
+	GATE_HSI,
+	GATE_HSE,
+	GATE_LSE,
+	GATE_LSI,
+	GATE_MSI,
+	GATE_HSEDIV2,
+	GATE_PLL1,
+	GATE_PLL2,
+	GATE_PLL3,
+	GATE_PLL4,
+	GATE_PLL5,
+	GATE_PLL6,
+	GATE_PLL7,
+	GATE_PLL8,
+	GATE_RTCCK,
+	GATE_C3,
+	GATE_LPTIM3C3,
+	GATE_LPTIM4C3,
+	GATE_LPTIM5C3,
+	GATE_SPI8C3,
+	GATE_LPUART1C3,
+	GATE_I2C8C3,
+	GATE_ADF1C3,
+	GATE_GPIOZC3,
+	GATE_LPDMAC3,
+	GATE_RTCC3,
+	GATE_I3C4C3,
+	GATE_DDRCP,
+	GATE_DDRCAPB,
+	GATE_DDRPHYCAPB,
+	GATE_DDRPHYC,
+	GATE_DDRCFG,
+	GATE_SYSRAM,
+	GATE_VDERAM,
+	GATE_SRAM1,
+	GATE_SRAM2,
+	GATE_RETRAM,
+	GATE_BKPSRAM,
+	GATE_LPSRAM1,
+	GATE_LPSRAM2,
+	GATE_LPSRAM3,
+	GATE_FMC,
+	GATE_ETR,
+	GATE_GPIOA,
+	GATE_GPIOB,
+	GATE_GPIOC,
+	GATE_GPIOD,
+	GATE_GPIOE,
+	GATE_GPIOF,
+	GATE_GPIOG,
+	GATE_GPIOH,
+	GATE_GPIOI,
+	GATE_GPIOJ,
+	GATE_GPIOK,
+	GATE_GPIOZ,
+	GATE_HPDMA1,
+	GATE_HPDMA2,
+	GATE_HPDMA3,
+	GATE_LPDMA,
+	GATE_HSEM,
+	GATE_IPCC1,
+	GATE_IPCC2,
+	GATE_RTC,
+	GATE_SYSCPU1,
+	GATE_BSEC,
+	GATE_BUSPERFM,
+#endif
+	GATE_NB
+};
+
+#define GATE_CFG(id, _offset, _bit_idx, _offset_clr)\
+	[id] = {\
+		.offset		= (_offset),\
+		.bit_idx	= (_bit_idx),\
+		.set_clr	= (_offset_clr),\
+	}
+
+static const struct stm32_gate_cfg stm32mp25_gates[GATE_NB] = {
+	GATE_CFG(GATE_MCO1,		RCC_MCO1CFGR,		8,	0),
+	GATE_CFG(GATE_MCO2,		RCC_MCO2CFGR,		8,	0),
+	GATE_CFG(GATE_OSPI1,		RCC_OSPI1CFGR,		1,	0),
+	GATE_CFG(GATE_OSPI2,		RCC_OSPI2CFGR,		1,	0),
+	GATE_CFG(GATE_DBG,		RCC_DBGCFGR,		8,	0),
+	GATE_CFG(GATE_TRACE,		RCC_DBGCFGR,		9,	0),
+	GATE_CFG(GATE_STM500,		RCC_STM500CFGR,		1,	0),
+	GATE_CFG(GATE_IS2M,		RCC_IS2MCFGR,		1,	0),
+	GATE_CFG(GATE_TIM1,		RCC_TIM1CFGR,		1,	0),
+	GATE_CFG(GATE_TIM2,		RCC_TIM2CFGR,		1,	0),
+	GATE_CFG(GATE_TIM3,		RCC_TIM3CFGR,		1,	0),
+	GATE_CFG(GATE_TIM4,		RCC_TIM4CFGR,		1,	0),
+	GATE_CFG(GATE_TIM5,		RCC_TIM5CFGR,		1,	0),
+	GATE_CFG(GATE_TIM6,		RCC_TIM6CFGR,		1,	0),
+	GATE_CFG(GATE_TIM7,		RCC_TIM7CFGR,		1,	0),
+	GATE_CFG(GATE_TIM8,		RCC_TIM8CFGR,		1,	0),
+	GATE_CFG(GATE_TIM10,		RCC_TIM10CFGR,		1,	0),
+	GATE_CFG(GATE_TIM11,		RCC_TIM11CFGR,		1,	0),
+	GATE_CFG(GATE_TIM12,		RCC_TIM12CFGR,		1,	0),
+	GATE_CFG(GATE_TIM13,		RCC_TIM13CFGR,		1,	0),
+	GATE_CFG(GATE_TIM14,		RCC_TIM14CFGR,		1,	0),
+	GATE_CFG(GATE_TIM15,		RCC_TIM15CFGR,		1,	0),
+	GATE_CFG(GATE_TIM16,		RCC_TIM16CFGR,		1,	0),
+	GATE_CFG(GATE_TIM17,		RCC_TIM17CFGR,		1,	0),
+	GATE_CFG(GATE_TIM20,		RCC_TIM20CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM1,		RCC_LPTIM1CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM2,		RCC_LPTIM2CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM3,		RCC_LPTIM3CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM4,		RCC_LPTIM4CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM5,		RCC_LPTIM5CFGR,		1,	0),
+	GATE_CFG(GATE_SPI1,		RCC_SPI1CFGR,		1,	0),
+	GATE_CFG(GATE_SPI2,		RCC_SPI2CFGR,		1,	0),
+	GATE_CFG(GATE_SPI3,		RCC_SPI3CFGR,		1,	0),
+	GATE_CFG(GATE_SPI4,		RCC_SPI4CFGR,		1,	0),
+	GATE_CFG(GATE_SPI5,		RCC_SPI5CFGR,		1,	0),
+	GATE_CFG(GATE_SPI6,		RCC_SPI6CFGR,		1,	0),
+	GATE_CFG(GATE_SPI7,		RCC_SPI7CFGR,		1,	0),
+	GATE_CFG(GATE_SPI8,		RCC_SPI8CFGR,		1,	0),
+	GATE_CFG(GATE_SPDIFRX,		RCC_SPDIFRXCFGR,	1,	0),
+	GATE_CFG(GATE_USART1,		RCC_USART1CFGR,		1,	0),
+	GATE_CFG(GATE_USART2,		RCC_USART2CFGR,		1,	0),
+	GATE_CFG(GATE_USART3,		RCC_USART3CFGR,		1,	0),
+	GATE_CFG(GATE_UART4,		RCC_UART4CFGR,		1,	0),
+	GATE_CFG(GATE_UART5,		RCC_UART5CFGR,		1,	0),
+	GATE_CFG(GATE_USART6,		RCC_USART6CFGR,		1,	0),
+	GATE_CFG(GATE_UART7,		RCC_UART7CFGR,		1,	0),
+	GATE_CFG(GATE_UART8,		RCC_UART8CFGR,		1,	0),
+	GATE_CFG(GATE_UART9,		RCC_UART9CFGR,		1,	0),
+	GATE_CFG(GATE_LPUART1,		RCC_LPUART1CFGR,	1,	0),
+	GATE_CFG(GATE_I2C1,		RCC_I2C1CFGR,		1,	0),
+	GATE_CFG(GATE_I2C2,		RCC_I2C2CFGR,		1,	0),
+	GATE_CFG(GATE_I2C3,		RCC_I2C3CFGR,		1,	0),
+	GATE_CFG(GATE_I2C4,		RCC_I2C4CFGR,		1,	0),
+	GATE_CFG(GATE_I2C5,		RCC_I2C5CFGR,		1,	0),
+	GATE_CFG(GATE_I2C6,		RCC_I2C6CFGR,		1,	0),
+	GATE_CFG(GATE_I2C7,		RCC_I2C7CFGR,		1,	0),
+	GATE_CFG(GATE_I2C8,		RCC_I2C8CFGR,		1,	0),
+	GATE_CFG(GATE_SAI1,		RCC_SAI1CFGR,		1,	0),
+	GATE_CFG(GATE_SAI2,		RCC_SAI2CFGR,		1,	0),
+	GATE_CFG(GATE_SAI3,		RCC_SAI3CFGR,		1,	0),
+	GATE_CFG(GATE_SAI4,		RCC_SAI4CFGR,		1,	0),
+	GATE_CFG(GATE_MDF1,		RCC_MDF1CFGR,		1,	0),
+	GATE_CFG(GATE_ADF1,		RCC_ADF1CFGR,		1,	0),
+	GATE_CFG(GATE_FDCAN,		RCC_FDCANCFGR,		1,	0),
+	GATE_CFG(GATE_HDP,		RCC_HDPCFGR,		1,	0),
+	GATE_CFG(GATE_ADC12,		RCC_ADC12CFGR,		1,	0),
+	GATE_CFG(GATE_ADC3,		RCC_ADC3CFGR,		1,	0),
+	GATE_CFG(GATE_ETH1MAC,		RCC_ETH1CFGR,		1,	0),
+	GATE_CFG(GATE_ETH1STP,		RCC_ETH1CFGR,		4,	0),
+	GATE_CFG(GATE_ETH1,		RCC_ETH1CFGR,		5,	0),
+	GATE_CFG(GATE_ETH1TX,		RCC_ETH1CFGR,		8,	0),
+	GATE_CFG(GATE_ETH1RX,		RCC_ETH1CFGR,		10,	0),
+	GATE_CFG(GATE_ETH2MAC,		RCC_ETH2CFGR,		1,	0),
+	GATE_CFG(GATE_ETH2STP,		RCC_ETH2CFGR,		4,	0),
+	GATE_CFG(GATE_ETH2,		RCC_ETH2CFGR,		5,	0),
+	GATE_CFG(GATE_ETH2TX,		RCC_ETH2CFGR,		8,	0),
+	GATE_CFG(GATE_ETH2RX,		RCC_ETH2CFGR,		10,	0),
+	GATE_CFG(GATE_USB2,		RCC_USB2CFGR,		1,	0),
+	GATE_CFG(GATE_USB2PHY1,		RCC_USB2PHY1CFGR,	1,	0),
+	GATE_CFG(GATE_USB2PHY2,		RCC_USB2PHY2CFGR,	1,	0),
+	GATE_CFG(GATE_USB3DRD,		RCC_USB3DRDCFGR,	1,	0),
+	GATE_CFG(GATE_USB3PCIEPHY,	RCC_USB3PCIEPHYCFGR,	1,	0),
+	GATE_CFG(GATE_PCIE,		RCC_PCIECFGR,		1,	0),
+	GATE_CFG(GATE_USBTC,		RCC_USBTCCFGR,		1,	0),
+	GATE_CFG(GATE_ETHSWMAC,		RCC_ETHSWCFGR,		1,	0),
+	GATE_CFG(GATE_ETHSW,		RCC_ETHSWCFGR,		5,	0),
+	GATE_CFG(GATE_ETHSWREF,		RCC_ETHSWCFGR,		21,	0),
+	GATE_CFG(GATE_ETHSWACMCFG,	RCC_ETHSWACMCFGR,	1,	0),
+	GATE_CFG(GATE_ETHSWACMMSG,	RCC_ETHSWACMMSGCFGR,	1,	0),
+	GATE_CFG(GATE_STGEN,		RCC_STGENCFGR,		1,	0),
+	GATE_CFG(GATE_SDMMC1,		RCC_SDMMC1CFGR,		1,	0),
+	GATE_CFG(GATE_SDMMC2,		RCC_SDMMC2CFGR,		1,	0),
+	GATE_CFG(GATE_SDMMC3,		RCC_SDMMC3CFGR,		1,	0),
+	GATE_CFG(GATE_GPU,		RCC_GPUCFGR,		1,	0),
+	GATE_CFG(GATE_LTDC,		RCC_LTDCCFGR,		1,	0),
+	GATE_CFG(GATE_DSI,		RCC_DSICFGR,		1,	0),
+	GATE_CFG(GATE_LVDS,		RCC_LVDSCFGR,		1,	0),
+	GATE_CFG(GATE_CSI,		RCC_CSICFGR,		1,	0),
+	GATE_CFG(GATE_DCMIPP,		RCC_DCMIPPCFGR,		1,	0),
+	GATE_CFG(GATE_CCI,		RCC_CCICFGR,		1,	0),
+	GATE_CFG(GATE_VDEC,		RCC_VDECCFGR,		1,	0),
+	GATE_CFG(GATE_VENC,		RCC_VENCCFGR,		1,	0),
+	GATE_CFG(GATE_RNG,		RCC_RNGCFGR,		1,	0),
+	GATE_CFG(GATE_PKA,		RCC_PKACFGR,		1,	0),
+	GATE_CFG(GATE_SAES,		RCC_SAESCFGR,		1,	0),
+	GATE_CFG(GATE_HASH,		RCC_HASHCFGR,		1,	0),
+	GATE_CFG(GATE_CRYP1,		RCC_CRYP1CFGR,		1,	0),
+	GATE_CFG(GATE_CRYP2,		RCC_CRYP2CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG1,		RCC_IWDG1CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG2,		RCC_IWDG2CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG3,		RCC_IWDG3CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG4,		RCC_IWDG4CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG5,		RCC_IWDG5CFGR,		1,	0),
+	GATE_CFG(GATE_WWDG1,		RCC_WWDG1CFGR,		1,	0),
+	GATE_CFG(GATE_WWDG2,		RCC_WWDG2CFGR,		1,	0),
+	GATE_CFG(GATE_VREF,		RCC_VREFCFGR,		1,	0),
+	GATE_CFG(GATE_DTS,		RCC_DTSCFGR,		1,	0),
+	GATE_CFG(GATE_CRC,		RCC_CRCCFGR,		1,	0),
+	GATE_CFG(GATE_SERC,		RCC_SERCCFGR,		1,	0),
+	GATE_CFG(GATE_OSPIIOM,		RCC_OSPIIOMCFGR,	1,	0),
+	GATE_CFG(GATE_GICV2M,		RCC_GICV2MCFGR,		1,	0),
+	GATE_CFG(GATE_I3C1,		RCC_I3C1CFGR,		1,	0),
+	GATE_CFG(GATE_I3C2,		RCC_I3C2CFGR,		1,	0),
+	GATE_CFG(GATE_I3C3,		RCC_I3C3CFGR,		1,	0),
+	GATE_CFG(GATE_I3C4,		RCC_I3C4CFGR,		1,	0),
+
+#ifdef CONFIG_DEBUG_FS
+	GATE_CFG(GATE_LSE,		RCC_BDCR,		0,	0),
+	GATE_CFG(GATE_LSI,		RCC_BDCR,		9,	0),
+	GATE_CFG(GATE_RTCCK,		RCC_BDCR,		20,	0),
+	GATE_CFG(GATE_MSI,		RCC_D3DCR,		0,	0),
+	GATE_CFG(GATE_PLL1,		RCC_PLL2CFGR1,		8,	0),
+	GATE_CFG(GATE_PLL2,		RCC_PLL2CFGR1,		8,	0),
+	GATE_CFG(GATE_PLL3,		RCC_PLL3CFGR1,		8,	0),
+	GATE_CFG(GATE_PLL4,		RCC_PLL4CFGR1,		8,	0),
+	GATE_CFG(GATE_PLL5,		RCC_PLL5CFGR1,		8,	0),
+	GATE_CFG(GATE_PLL6,		RCC_PLL6CFGR1,		8,	0),
+	GATE_CFG(GATE_PLL7,		RCC_PLL7CFGR1,		8,	0),
+	GATE_CFG(GATE_PLL8,		RCC_PLL8CFGR1,		8,	0),
+	GATE_CFG(GATE_C3,		RCC_C3CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM3C3,		RCC_C3CFGR,		16,	0),
+	GATE_CFG(GATE_LPTIM4C3,		RCC_C3CFGR,		17,	0),
+	GATE_CFG(GATE_LPTIM5C3,		RCC_C3CFGR,		18,	0),
+	GATE_CFG(GATE_SPI8C3,		RCC_C3CFGR,		19,	0),
+	GATE_CFG(GATE_LPUART1C3,	RCC_C3CFGR,		20,	0),
+	GATE_CFG(GATE_I2C8C3,		RCC_C3CFGR,		21,	0),
+	GATE_CFG(GATE_ADF1C3,		RCC_C3CFGR,		23,	0),
+	GATE_CFG(GATE_GPIOZC3,		RCC_C3CFGR,		24,	0),
+	GATE_CFG(GATE_LPDMAC3,		RCC_C3CFGR,		25,	0),
+	GATE_CFG(GATE_RTCC3,		RCC_C3CFGR,		26,	0),
+	GATE_CFG(GATE_I3C4C3,		RCC_C3CFGR,		27,	0),
+	GATE_CFG(GATE_HSI,		RCC_OCENSETR,		0,	1),
+	GATE_CFG(GATE_HSEDIV2,		RCC_OCENSETR,		5,	1),
+	GATE_CFG(GATE_HSE,		RCC_OCENSETR,		8,	1),
+	GATE_CFG(GATE_DDRCP,		RCC_DDRCPCFGR,		1,	0),
+	GATE_CFG(GATE_DDRCAPB,		RCC_DDRCAPBCFGR,	1,	0),
+	GATE_CFG(GATE_DDRPHYCAPB,	RCC_DDRPHYCAPBCFGR,	1,	0),
+	GATE_CFG(GATE_DDRPHYC,		RCC_DDRPHYCCFGR,	1,	0),
+	GATE_CFG(GATE_DDRCFG,		RCC_DDRCFGR,		1,	0),
+	GATE_CFG(GATE_SYSRAM,		RCC_SYSRAMCFGR,		1,	0),
+	GATE_CFG(GATE_VDERAM,		RCC_VDERAMCFGR,		1,	0),
+	GATE_CFG(GATE_SRAM1,		RCC_SRAM1CFGR,		1,	0),
+	GATE_CFG(GATE_SRAM2,		RCC_SRAM2CFGR,		1,	0),
+	GATE_CFG(GATE_RETRAM,		RCC_RETRAMCFGR,		1,	0),
+	GATE_CFG(GATE_BKPSRAM,		RCC_BKPSRAMCFGR,	1,	0),
+	GATE_CFG(GATE_LPSRAM1,		RCC_LPSRAM1CFGR,	1,	0),
+	GATE_CFG(GATE_LPSRAM2,		RCC_LPSRAM2CFGR,	1,	0),
+	GATE_CFG(GATE_LPSRAM3,		RCC_LPSRAM3CFGR,	1,	0),
+	GATE_CFG(GATE_FMC,		RCC_FMCCFGR,		1,	0),
+	GATE_CFG(GATE_ETR,		RCC_ETRCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOA,		RCC_GPIOACFGR,		1,	0),
+	GATE_CFG(GATE_GPIOB,		RCC_GPIOBCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOC,		RCC_GPIOCCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOD,		RCC_GPIODCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOE,		RCC_GPIOECFGR,		1,	0),
+	GATE_CFG(GATE_GPIOF,		RCC_GPIOFCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOG,		RCC_GPIOGCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOH,		RCC_GPIOHCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOI,		RCC_GPIOICFGR,		1,	0),
+	GATE_CFG(GATE_GPIOJ,		RCC_GPIOJCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOK,		RCC_GPIOKCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOZ,		RCC_GPIOZCFGR,		1,	0),
+	GATE_CFG(GATE_HPDMA1,		RCC_HPDMA1CFGR,		1,	0),
+	GATE_CFG(GATE_HPDMA2,		RCC_HPDMA2CFGR,		1,	0),
+	GATE_CFG(GATE_HPDMA3,		RCC_HPDMA3CFGR,		1,	0),
+	GATE_CFG(GATE_LPDMA,		RCC_LPDMACFGR,		1,	0),
+	GATE_CFG(GATE_HSEM,		RCC_HSEMCFGR,		1,	0),
+	GATE_CFG(GATE_IPCC1,		RCC_IPCC1CFGR,		1,	0),
+	GATE_CFG(GATE_IPCC2,		RCC_IPCC2CFGR,		1,	0),
+	GATE_CFG(GATE_RTC,		RCC_RTCCFGR,		1,	0),
+	GATE_CFG(GATE_SYSCPU1,		RCC_SYSCPU1CFGR,	1,	0),
+	GATE_CFG(GATE_BSEC,		RCC_BSECCFGR,		1,	0),
+	GATE_CFG(GATE_BUSPERFM,		RCC_BUSPERFMCFGR,	1,	0),
+#endif
+};
+
+#ifdef CONFIG_DEBUG_FS
+enum enum_div_cfg {
+	DIV_LSMCU,
+	DIV_APB1,
+	DIV_APB2,
+	DIV_APB3,
+	DIV_APB4,
+	DIV_APBDBG,
+	DIV_RTC,
+	DIV_NB
+};
+
+static const struct clk_div_table apb_div_table[] = {
+	{ 0, 1 },  { 1, 2 },  { 2, 4 },  { 3, 8 }, { 4, 16 },
+	{ 5, 16 }, { 6, 16 }, { 7, 16 }, { 0 },
+};
+
+#define DIV_CFG(_id, _offset, _shift, _width, _table)\
+	[(_id)] = {\
+		.offset	= (_offset),\
+		.shift	= (_shift),\
+		.width	= (_width),\
+		.table	= (_table),\
+	}
+
+static const struct stm32_div_cfg stm32mp25_dividers[DIV_NB] = {
+	DIV_CFG(DIV_RTC,	RCC_RTCDIVR,	0, 6, NULL),
+	DIV_CFG(DIV_APB1,	RCC_APB1DIVR,	0, 3, apb_div_table),
+	DIV_CFG(DIV_APB2,	RCC_APB2DIVR,	0, 3, apb_div_table),
+	DIV_CFG(DIV_APB3,	RCC_APB3DIVR,	0, 3, apb_div_table),
+	DIV_CFG(DIV_APB4,	RCC_APB4DIVR,	0, 3, apb_div_table),
+	DIV_CFG(DIV_APBDBG,	RCC_APBDBGDIVR,	0, 3, apb_div_table),
+	DIV_CFG(DIV_LSMCU,	RCC_LSMCUDIVR,	0, 1, NULL),
+};
+#endif
+
+static CLK_STM32_GATE(ck_icn_p_adc12, "ck_icn_ls_mcu", 0, GATE_ADC12);
+
+static CLK_STM32_COMPOSITE(ck_ker_adc12, adc12_src, 0, GATE_ADC12, MUX_ADC12, NO_STM32_DIV);
+
+static CLK_STM32_GATE(ck_icn_p_adc3, "ck_icn_ls_mcu", 0, GATE_ADC3);
+
+static CLK_STM32_COMPOSITE(ck_ker_adc3, adc3_src, 0, GATE_ADC3, MUX_ADC3, NO_STM32_DIV);
+
+/* ADF */
+static CLK_STM32_GATE(ck_icn_p_adf1, "ck_icn_ls_mcu", 0, GATE_ADF1);
+static CLK_STM32_GATE(ck_ker_adf1, "ck_flexgen_42", 0, GATE_ADF1);
+
+/* Camera */
+/* DCMI */
+static CLK_STM32_GATE(ck_icn_p_cci, "ck_icn_ls_mcu", 0, GATE_CCI);
+
+/* CSI-HOST */
+static CLK_STM32_GATE(ck_icn_p_csi, "ck_icn_apb4", 0, GATE_CSI);
+static CLK_STM32_GATE(ck_ker_csi, "ck_flexgen_29", 0, GATE_CSI);
+static CLK_STM32_GATE(ck_ker_csitxesc, "ck_flexgen_30", 0, GATE_CSI);
+
+/* CSI-PHY */
+static CLK_STM32_GATE(ck_ker_csiphy, "ck_flexgen_31", 0, GATE_CSI);
+
+/* DCMIPP */
+static CLK_STM32_GATE(ck_icn_p_dcmipp, "ck_icn_apb4", 0, GATE_DCMIPP);
+
+/* CRC */
+static CLK_STM32_GATE(ck_icn_p_crc, "ck_icn_ls_mcu", 0, GATE_CRC);
+
+/* CRYP */
+static CLK_STM32_GATE(ck_icn_p_cryp1, "ck_icn_ls_mcu", 0, GATE_CRYP1);
+static CLK_STM32_GATE(ck_icn_p_cryp2, "ck_icn_ls_mcu", 0, GATE_CRYP2);
+
+/* DBG & TRACE*/
+static CLK_STM32_GATE(ck_sys_dbg, "ck_icn_apbdbg", 0, GATE_DBG);
+static CLK_STM32_GATE(ck_ker_tsdbg, "ck_flexgen_43", 0, GATE_DBG);
+static CLK_STM32_GATE(ck_ker_tpiu, "ck_flexgen_44", 0, GATE_DBG);
+static CLK_STM32_GATE(ck_sys_atb, "ck_flexgen_45", 0, GATE_DBG);
+
+/* Display subsystem */
+/* LTDC */
+static CLK_STM32_GATE(ck_icn_p_ltdc, "ck_icn_apb4", 0, GATE_LTDC);
+static CLK_STM32_GATE(ck_ker_ltdc, "ck_flexgen_27", CLK_SET_RATE_PARENT, GATE_LTDC);
+
+/* DSI */
+static CLK_STM32_GATE(ck_icn_p_dsi, "ck_icn_apb4", 0, GATE_DSI);
+static CLK_STM32_COMPOSITE(ck_ker_dsiblane, dsiblane_src, 0, GATE_DSI, MUX_DSIBLANE, NO_STM32_DIV);
+
+/* LVDS */
+static CLK_STM32_GATE(ck_icn_p_lvds, "ck_icn_apb4", 0, GATE_LVDS);
+
+/* DSI PHY */
+static CLK_STM32_COMPOSITE(ck_ker_dsiphy, dsiphy_src, CLK_IGNORE_UNUSED,
+			   GATE_DSI, MUX_DSIPHY, NO_STM32_DIV);
+/* LVDS PHY */
+static CLK_STM32_COMPOSITE(ck_ker_lvdsphy, lvdsphy_src, 0, GATE_LVDS, MUX_LVDSPHY, NO_STM32_DIV);
+
+/* DTS */
+static CLK_STM32_COMPOSITE(ck_ker_dts, dts_src, 0, GATE_DTS, MUX_DTS, NO_STM32_DIV);
+
+/* ETHERNET */
+static CLK_STM32_GATE(ck_icn_p_eth1, "ck_icn_ls_mcu", 0, GATE_ETH1);
+static CLK_STM32_GATE(ck_ker_eth1stp, "ck_icn_ls_mcu", 0, GATE_ETH1STP);
+static CLK_STM32_GATE(ck_ker_eth1, "ck_flexgen_54", 0, GATE_ETH1);
+static CLK_STM32_GATE(ck_ker_eth1ptp, "ck_flexgen_56", 0, GATE_ETH1);
+static CLK_STM32_GATE(ck_ker_eth1mac, "ck_icn_ls_mcu", 0, GATE_ETH1MAC);
+static CLK_STM32_GATE(ck_ker_eth1tx, "ck_icn_ls_mcu", 0, GATE_ETH1TX);
+static CLK_STM32_GATE(ck_ker_eth1rx, "ck_icn_ls_mcu", 0, GATE_ETH1RX);
+
+static CLK_STM32_GATE(ck_icn_p_eth2, "ck_icn_ls_mcu", 0, GATE_ETH2);
+static CLK_STM32_GATE(ck_ker_eth2stp, "ck_icn_ls_mcu", 0, GATE_ETH2STP);
+static CLK_STM32_GATE(ck_ker_eth2, "ck_flexgen_55", 0, GATE_ETH2);
+static CLK_STM32_GATE(ck_ker_eth2ptp, "ck_flexgen_56", 0, GATE_ETH2);
+static CLK_STM32_GATE(ck_ker_eth2mac, "ck_icn_ls_mcu", 0, GATE_ETH2MAC);
+static CLK_STM32_GATE(ck_ker_eth2tx, "ck_icn_ls_mcu", 0, GATE_ETH2TX);
+static CLK_STM32_GATE(ck_ker_eth2rx, "ck_icn_ls_mcu", 0, GATE_ETH2RX);
+
+static CLK_STM32_GATE(ck_icn_p_ethsw, "ck_icn_ls_mcu", 0, GATE_ETHSWMAC);
+static CLK_STM32_GATE(ck_ker_ethsw, "ck_flexgen_54", 0, GATE_ETHSW);
+static CLK_STM32_GATE(ck_ker_ethswref, "ck_flexgen_60", 0, GATE_ETHSWREF);
+
+static CLK_STM32_GATE(ck_icn_p_ethsw_acm_cfg, "ck_icn_ls_mcu", 0, GATE_ETHSWACMCFG);
+static CLK_STM32_GATE(ck_icn_p_ethsw_acm_msg, "ck_icn_ls_mcu", 0, GATE_ETHSWACMMSG);
+
+/* FDCAN */
+static CLK_STM32_GATE(ck_icn_p_fdcan, "ck_icn_apb2", 0, GATE_FDCAN);
+static CLK_STM32_GATE(ck_ker_fdcan, "ck_flexgen_26", 0, GATE_FDCAN);
+
+/* GICV2M */
+static CLK_STM32_GATE(ck_icn_p_gicv2m, "ck_icn_apb4", 0, GATE_GICV2M);
+
+/* GPU */
+static CLK_STM32_GATE(ck_icn_m_gpu, "ck_flexgen_59", 0, GATE_GPU);
+
+/* HASH */
+static CLK_STM32_GATE(ck_icn_p_hash, "ck_icn_ls_mcu", 0, GATE_HASH);
+
+/* HDP */
+static CLK_STM32_GATE(ck_icn_p_hdp, "ck_icn_apb3", 0, GATE_HDP);
+
+/* I2C */
+static CLK_STM32_GATE(ck_icn_p_i2c8, "ck_icn_ls_mcu", 0, GATE_I2C8);
+static CLK_STM32_GATE(ck_icn_p_i2c1, "ck_icn_apb1", 0, GATE_I2C1);
+static CLK_STM32_GATE(ck_icn_p_i2c2, "ck_icn_apb1", 0, GATE_I2C2);
+static CLK_STM32_GATE(ck_icn_p_i2c3, "ck_icn_apb1", 0, GATE_I2C3);
+static CLK_STM32_GATE(ck_icn_p_i2c4, "ck_icn_apb1", 0, GATE_I2C4);
+static CLK_STM32_GATE(ck_icn_p_i2c5, "ck_icn_apb1", 0, GATE_I2C5);
+static CLK_STM32_GATE(ck_icn_p_i2c6, "ck_icn_apb1", 0, GATE_I2C6);
+static CLK_STM32_GATE(ck_icn_p_i2c7, "ck_icn_apb1", 0, GATE_I2C7);
+
+static CLK_STM32_GATE(ck_ker_i2c1, "ck_flexgen_12", 0, GATE_I2C1);
+static CLK_STM32_GATE(ck_ker_i2c2, "ck_flexgen_12", 0, GATE_I2C2);
+static CLK_STM32_GATE(ck_ker_i2c3, "ck_flexgen_13", 0, GATE_I2C3);
+static CLK_STM32_GATE(ck_ker_i2c5, "ck_flexgen_13", 0, GATE_I2C5);
+static CLK_STM32_GATE(ck_ker_i2c4, "ck_flexgen_14", 0, GATE_I2C4);
+static CLK_STM32_GATE(ck_ker_i2c6, "ck_flexgen_14", 0, GATE_I2C6);
+static CLK_STM32_GATE(ck_ker_i2c7, "ck_flexgen_15", 0, GATE_I2C7);
+static CLK_STM32_GATE(ck_ker_i2c8, "ck_flexgen_38", 0, GATE_I2C8);
+
+/* I3C */
+static CLK_STM32_GATE(ck_icn_p_i3c1, "ck_icn_apb1", 0, GATE_I3C1);
+static CLK_STM32_GATE(ck_icn_p_i3c2, "ck_icn_apb1", 0, GATE_I3C2);
+static CLK_STM32_GATE(ck_icn_p_i3c3, "ck_icn_apb1", 0, GATE_I3C3);
+static CLK_STM32_GATE(ck_icn_p_i3c4, "ck_icn_ls_mcu", 0, GATE_I3C4);
+
+static CLK_STM32_GATE(ck_ker_i3c1, "ck_flexgen_12", 0, GATE_I3C1);
+static CLK_STM32_GATE(ck_ker_i3c2, "ck_flexgen_12", 0, GATE_I3C2);
+static CLK_STM32_GATE(ck_ker_i3c3, "ck_flexgen_13", 0, GATE_I3C3);
+static CLK_STM32_GATE(ck_ker_i3c4, "ck_flexgen_36", 0, GATE_I3C4);
+
+/* I2S */
+static CLK_STM32_GATE(ck_icn_p_is2m, "ck_icn_apb3", 0, GATE_IS2M);
+
+/* IWDG */
+static CLK_STM32_GATE(ck_icn_p_iwdg1, "ck_icn_apb3", 0, GATE_IWDG1);
+static CLK_STM32_GATE(ck_icn_p_iwdg2, "ck_icn_apb3", 0, GATE_IWDG2);
+static CLK_STM32_GATE(ck_icn_p_iwdg3, "ck_icn_apb3", 0, GATE_IWDG3);
+static CLK_STM32_GATE(ck_icn_p_iwdg4, "ck_icn_apb3", 0, GATE_IWDG4);
+static CLK_STM32_GATE(ck_icn_p_iwdg5, "ck_icn_ls_mcu", 0, GATE_IWDG5);
+
+/* LPTIM */
+static CLK_STM32_GATE(ck_icn_p_lptim1, "ck_icn_apb1", 0, GATE_LPTIM1);
+static CLK_STM32_GATE(ck_icn_p_lptim2, "ck_icn_apb1", 0, GATE_LPTIM2);
+static CLK_STM32_GATE(ck_icn_p_lptim3, "ck_icn_ls_mcu", 0, GATE_LPTIM3);
+static CLK_STM32_GATE(ck_icn_p_lptim4, "ck_icn_ls_mcu", 0, GATE_LPTIM4);
+static CLK_STM32_GATE(ck_icn_p_lptim5, "ck_icn_ls_mcu", 0, GATE_LPTIM5);
+
+static CLK_STM32_GATE(ck_ker_lptim1, "ck_flexgen_07", 0, GATE_LPTIM1);
+static CLK_STM32_GATE(ck_ker_lptim2, "ck_flexgen_07", 0, GATE_LPTIM2);
+static CLK_STM32_GATE(ck_ker_lptim3, "ck_flexgen_40", 0, GATE_LPTIM3);
+static CLK_STM32_GATE(ck_ker_lptim4, "ck_flexgen_41", 0, GATE_LPTIM4);
+static CLK_STM32_GATE(ck_ker_lptim5, "ck_flexgen_41", 0, GATE_LPTIM5);
+
+/* LPUART */
+static CLK_STM32_GATE(ck_icn_p_lpuart1, "ck_icn_ls_mcu", 0, GATE_LPUART1);
+static CLK_STM32_GATE(ck_ker_lpuart1, "ck_flexgen_39", 0, GATE_LPUART1);
+
+/* MCO1 & MCO2 */
+static CLK_STM32_COMPOSITE(ck_mco1, mco1_src, 0, GATE_MCO1, MUX_MCO1, NO_STM32_DIV);
+static CLK_STM32_COMPOSITE(ck_mco2, mco2_src, 0, GATE_MCO2, MUX_MCO2, NO_STM32_DIV);
+
+/* MDF */
+static CLK_STM32_GATE(ck_icn_p_mdf1, "ck_icn_ls_mcu", 0, GATE_MDF1);
+static CLK_STM32_GATE(ck_ker_mdf1, "ck_flexgen_23", 0, GATE_MDF1);
+
+/* OSPI */
+static CLK_STM32_GATE(ck_icn_s_ospi1, "ck_icn_hs_mcu", 0, GATE_OSPI1);
+static CLK_STM32_GATE(ck_icn_s_ospi2, "ck_icn_hs_mcu", 0, GATE_OSPI2);
+static CLK_STM32_GATE(ck_icn_p_otfd1, "ck_icn_hs_mcu", 0, GATE_OSPI1);
+static CLK_STM32_GATE(ck_icn_p_otfd2, "ck_icn_hs_mcu", 0, GATE_OSPI2);
+static CLK_STM32_GATE(ck_ker_ospi1, "ck_flexgen_48", 0, GATE_OSPI1);
+static CLK_STM32_GATE(ck_ker_ospi2, "ck_flexgen_49", 0, GATE_OSPI2);
+static CLK_STM32_GATE(ck_icn_p_ospiiom, "ck_icn_ls_mcu", 0, GATE_OSPIIOM);
+
+/* PCIE */
+static CLK_STM32_GATE(ck_icn_p_pcie, "ck_icn_ls_mcu", 0, GATE_PCIE);
+
+/* PKA */
+static CLK_STM32_GATE(ck_icn_p_pka, "ck_icn_ls_mcu", 0, GATE_PKA);
+
+/* RNG */
+static CLK_STM32_GATE(ck_icn_p_rng, "ck_icn_ls_mcu", CLK_IGNORE_UNUSED, GATE_RNG);
+
+/* SAES */
+static CLK_STM32_GATE(ck_icn_p_saes, "ck_icn_ls_mcu", 0, GATE_SAES);
+
+/* SAI */
+static CLK_STM32_GATE(ck_icn_p_sai1, "ck_icn_apb2", 0, GATE_SAI1);
+static CLK_STM32_GATE(ck_icn_p_sai2, "ck_icn_apb2", 0, GATE_SAI2);
+static CLK_STM32_GATE(ck_icn_p_sai3, "ck_icn_apb2", 0, GATE_SAI3);
+static CLK_STM32_GATE(ck_icn_p_sai4, "ck_icn_apb2", 0, GATE_SAI4);
+static CLK_STM32_GATE(ck_ker_sai1, "ck_flexgen_23", CLK_SET_RATE_PARENT, GATE_SAI1);
+static CLK_STM32_GATE(ck_ker_sai2, "ck_flexgen_24", CLK_SET_RATE_PARENT, GATE_SAI2);
+static CLK_STM32_GATE(ck_ker_sai3, "ck_flexgen_25", CLK_SET_RATE_PARENT, GATE_SAI3);
+static CLK_STM32_GATE(ck_ker_sai4, "ck_flexgen_25", CLK_SET_RATE_PARENT, GATE_SAI4);
+
+/* SDMMC */
+static CLK_STM32_GATE(ck_icn_m_sdmmc1, "ck_icn_sdmmc", 0, GATE_SDMMC1);
+static CLK_STM32_GATE(ck_icn_m_sdmmc2, "ck_icn_sdmmc", 0, GATE_SDMMC2);
+static CLK_STM32_GATE(ck_icn_m_sdmmc3, "ck_icn_sdmmc", 0, GATE_SDMMC3);
+static CLK_STM32_GATE(ck_ker_sdmmc1, "ck_flexgen_51", 0, GATE_SDMMC1);
+static CLK_STM32_GATE(ck_ker_sdmmc2, "ck_flexgen_52", 0, GATE_SDMMC2);
+static CLK_STM32_GATE(ck_ker_sdmmc3, "ck_flexgen_53", 0, GATE_SDMMC3);
+
+/* SERC */
+static CLK_STM32_GATE(ck_icn_p_serc, "ck_icn_apb3", CLK_IGNORE_UNUSED, GATE_SERC);
+
+/* SPDIF */
+static CLK_STM32_GATE(ck_icn_p_spdifrx, "ck_icn_apb1", 0, GATE_SPDIFRX);
+static CLK_STM32_GATE(ck_ker_spdifrx, "ck_flexgen_11", 0, GATE_SPDIFRX);
+
+/* SPI */
+static CLK_STM32_GATE(ck_icn_p_spi1, "ck_icn_apb2", 0, GATE_SPI1);
+static CLK_STM32_GATE(ck_icn_p_spi2, "ck_icn_apb1", 0, GATE_SPI2);
+static CLK_STM32_GATE(ck_icn_p_spi3, "ck_icn_apb1", 0, GATE_SPI3);
+static CLK_STM32_GATE(ck_icn_p_spi4, "ck_icn_apb2", 0, GATE_SPI4);
+static CLK_STM32_GATE(ck_icn_p_spi5, "ck_icn_apb2", 0, GATE_SPI5);
+static CLK_STM32_GATE(ck_icn_p_spi6, "ck_icn_apb2", 0, GATE_SPI6);
+static CLK_STM32_GATE(ck_icn_p_spi7, "ck_icn_apb2", 0, GATE_SPI7);
+static CLK_STM32_GATE(ck_icn_p_spi8, "ck_icn_ls_mcu", 0, GATE_SPI8);
+
+static CLK_STM32_GATE(ck_ker_spi1, "ck_flexgen_16", 0, GATE_SPI1);
+static CLK_STM32_GATE(ck_ker_spi2, "ck_flexgen_10", 0, GATE_SPI2);
+static CLK_STM32_GATE(ck_ker_spi3, "ck_flexgen_10", 0, GATE_SPI3);
+static CLK_STM32_GATE(ck_ker_spi4, "ck_flexgen_17", 0, GATE_SPI4);
+static CLK_STM32_GATE(ck_ker_spi5, "ck_flexgen_17", 0, GATE_SPI5);
+static CLK_STM32_GATE(ck_ker_spi6, "ck_flexgen_18", 0, GATE_SPI6);
+static CLK_STM32_GATE(ck_ker_spi7, "ck_flexgen_18", 0, GATE_SPI7);
+static CLK_STM32_GATE(ck_ker_spi8, "ck_flexgen_37", 0, GATE_SPI8);
+
+/* STGEN */
+static CLK_STM32_GATE(ck_icn_p_stgen, "ck_icn_apb4", CLK_IGNORE_UNUSED, GATE_STGEN);
+static CLK_STM32_GATE(ck_ker_stgen, "ck_flexgen_33", CLK_IGNORE_UNUSED, GATE_STGEN);
+
+/* STM500 */
+static CLK_STM32_GATE(ck_icn_s_stm500, "ck_icn_ls_mcu", 0, GATE_STM500);
+
+/* Timers */
+static CLK_STM32_GATE(ck_icn_p_tim2, "ck_icn_apb1", 0, GATE_TIM2);
+static CLK_STM32_GATE(ck_icn_p_tim3, "ck_icn_apb1", 0, GATE_TIM3);
+static CLK_STM32_GATE(ck_icn_p_tim4, "ck_icn_apb1", 0, GATE_TIM4);
+static CLK_STM32_GATE(ck_icn_p_tim5, "ck_icn_apb1", 0, GATE_TIM5);
+static CLK_STM32_GATE(ck_icn_p_tim6, "ck_icn_apb1", 0, GATE_TIM6);
+static CLK_STM32_GATE(ck_icn_p_tim7, "ck_icn_apb1", 0, GATE_TIM7);
+static CLK_STM32_GATE(ck_icn_p_tim10, "ck_icn_apb1", 0, GATE_TIM10);
+static CLK_STM32_GATE(ck_icn_p_tim11, "ck_icn_apb1", 0, GATE_TIM11);
+static CLK_STM32_GATE(ck_icn_p_tim12, "ck_icn_apb1", 0, GATE_TIM12);
+static CLK_STM32_GATE(ck_icn_p_tim13, "ck_icn_apb1", 0, GATE_TIM13);
+static CLK_STM32_GATE(ck_icn_p_tim14, "ck_icn_apb1", 0, GATE_TIM14);
+
+static CLK_STM32_GATE(ck_icn_p_tim1, "ck_icn_apb2", 0, GATE_TIM1);
+static CLK_STM32_GATE(ck_icn_p_tim8, "ck_icn_apb2", 0, GATE_TIM8);
+static CLK_STM32_GATE(ck_icn_p_tim15, "ck_icn_apb2", 0, GATE_TIM15);
+static CLK_STM32_GATE(ck_icn_p_tim16, "ck_icn_apb2", 0, GATE_TIM16);
+static CLK_STM32_GATE(ck_icn_p_tim17, "ck_icn_apb2", 0, GATE_TIM17);
+static CLK_STM32_GATE(ck_icn_p_tim20, "ck_icn_apb2", 0, GATE_TIM20);
+
+static CLK_STM32_GATE(ck_ker_tim2, "timg1_ck", 0, GATE_TIM2);
+static CLK_STM32_GATE(ck_ker_tim3, "timg1_ck", 0, GATE_TIM3);
+static CLK_STM32_GATE(ck_ker_tim4, "timg1_ck", 0, GATE_TIM4);
+static CLK_STM32_GATE(ck_ker_tim5, "timg1_ck", 0, GATE_TIM5);
+static CLK_STM32_GATE(ck_ker_tim6, "timg1_ck", 0, GATE_TIM6);
+static CLK_STM32_GATE(ck_ker_tim7, "timg1_ck", 0, GATE_TIM7);
+static CLK_STM32_GATE(ck_ker_tim10, "timg1_ck", 0, GATE_TIM10);
+static CLK_STM32_GATE(ck_ker_tim11, "timg1_ck", 0, GATE_TIM11);
+static CLK_STM32_GATE(ck_ker_tim12, "timg1_ck", 0, GATE_TIM12);
+static CLK_STM32_GATE(ck_ker_tim13, "timg1_ck", 0, GATE_TIM13);
+static CLK_STM32_GATE(ck_ker_tim14, "timg1_ck", 0, GATE_TIM14);
+
+static CLK_STM32_GATE(ck_ker_tim1, "timg2_ck", 0, GATE_TIM1);
+static CLK_STM32_GATE(ck_ker_tim8, "timg2_ck", 0, GATE_TIM8);
+static CLK_STM32_GATE(ck_ker_tim15, "timg2_ck", 0, GATE_TIM15);
+static CLK_STM32_GATE(ck_ker_tim16, "timg2_ck", 0, GATE_TIM16);
+static CLK_STM32_GATE(ck_ker_tim17, "timg2_ck", 0, GATE_TIM17);
+static CLK_STM32_GATE(ck_ker_tim20, "timg2_ck", 0, GATE_TIM20);
+
+/* UART/USART */
+static CLK_STM32_GATE(ck_icn_p_usart2, "ck_icn_apb1", 0, GATE_USART2);
+static CLK_STM32_GATE(ck_icn_p_usart3, "ck_icn_apb1", 0, GATE_USART3);
+static CLK_STM32_GATE(ck_icn_p_uart4, "ck_icn_apb1", 0, GATE_UART4);
+static CLK_STM32_GATE(ck_icn_p_uart5, "ck_icn_apb1", 0, GATE_UART5);
+static CLK_STM32_GATE(ck_icn_p_usart1, "ck_icn_apb2", 0, GATE_USART1);
+static CLK_STM32_GATE(ck_icn_p_usart6, "ck_icn_apb2", 0, GATE_USART6);
+static CLK_STM32_GATE(ck_icn_p_uart7, "ck_icn_apb2", 0, GATE_UART7);
+static CLK_STM32_GATE(ck_icn_p_uart8, "ck_icn_apb2", 0, GATE_UART8);
+static CLK_STM32_GATE(ck_icn_p_uart9, "ck_icn_apb2", 0, GATE_UART9);
+
+static CLK_STM32_GATE(ck_ker_usart2, "ck_flexgen_08", 0, GATE_USART2);
+static CLK_STM32_GATE(ck_ker_uart4, "ck_flexgen_08", 0, GATE_UART4);
+static CLK_STM32_GATE(ck_ker_usart3, "ck_flexgen_09", 0, GATE_USART3);
+static CLK_STM32_GATE(ck_ker_uart5, "ck_flexgen_09", 0, GATE_UART5);
+static CLK_STM32_GATE(ck_ker_usart1, "ck_flexgen_19", 0, GATE_USART1);
+static CLK_STM32_GATE(ck_ker_usart6, "ck_flexgen_20", 0, GATE_USART6);
+static CLK_STM32_GATE(ck_ker_uart7, "ck_flexgen_21", 0, GATE_UART7);
+static CLK_STM32_GATE(ck_ker_uart8, "ck_flexgen_21", 0, GATE_UART8);
+static CLK_STM32_GATE(ck_ker_uart9, "ck_flexgen_22", 0, GATE_UART9);
+
+/* USB2PHY1 */
+static CLK_STM32_COMPOSITE(ck_ker_usb2phy1, usb2phy1_src, 0,
+			   GATE_USB2PHY1, MUX_USB2PHY1, NO_STM32_DIV);
+
+/* USB2H */
+static CLK_STM32_GATE(ck_icn_m_usb2ehci, "ck_icn_hsl", 0, GATE_USB2);
+static CLK_STM32_GATE(ck_icn_m_usb2ohci, "ck_icn_hsl", 0, GATE_USB2);
+
+/* USB2PHY2 */
+static CLK_STM32_COMPOSITE(ck_ker_usb2phy2_en, usb2phy2_src, 0,
+			   GATE_USB2PHY2, MUX_USB2PHY2, NO_STM32_DIV);
+
+/* USB3 PCIe COMBOPHY */
+static CLK_STM32_GATE(ck_icn_p_usb3pciephy, "ck_icn_apb4", 0, GATE_USB3PCIEPHY);
+
+static CLK_STM32_COMPOSITE(ck_ker_usb3pciephy, usb3pciphy_src, 0,
+			   GATE_USB3PCIEPHY, MUX_USB3PCIEPHY, NO_STM32_DIV);
+
+/* USB3 DRD */
+static CLK_STM32_GATE(ck_icn_m_usb3drd, "ck_icn_hsl", 0, GATE_USB3DRD);
+static CLK_STM32_GATE(ck_ker_usb2phy2, "ck_flexgen_58", 0, GATE_USB3DRD);
+
+/* USBTC */
+static CLK_STM32_GATE(ck_icn_p_usbtc, "ck_icn_apb4", 0, GATE_USBTC);
+static CLK_STM32_GATE(ck_ker_usbtc, "ck_flexgen_35", 0, GATE_USBTC);
+
+/* VDEC / VENC */
+static CLK_STM32_GATE(ck_icn_p_vdec, "ck_icn_apb4", 0, GATE_VDEC);
+static CLK_STM32_GATE(ck_icn_p_venc, "ck_icn_apb4", 0, GATE_VENC);
+
+/* VREF */
+static CLK_STM32_GATE(ck_icn_p_vref, "ck_icn_apb3", 0, GATE_VREF);
+
+/* WWDG */
+static CLK_STM32_GATE(ck_icn_p_wwdg1, "ck_icn_apb3", 0, GATE_WWDG1);
+static CLK_STM32_GATE(ck_icn_p_wwdg2, "ck_icn_ls_mcu", 0, GATE_WWDG2);
+
+enum security_clk {
+	SECF_NONE,
+};
+
+static const struct clock_config stm32mp25_clock_cfg[] = {
+	STM32_GATE_CFG(CK_BUS_OSPI1, ck_icn_s_ospi1, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_OSPI2, ck_icn_s_ospi2, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_OTFD1, ck_icn_p_otfd1, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_OTFD2, ck_icn_p_otfd2, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_STM500, ck_icn_s_stm500, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_ETH1, ck_icn_p_eth1, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_ETH2, ck_icn_p_eth2, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_PCIE, ck_icn_p_pcie, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_ETHSW, ck_icn_p_ethsw, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_ADC12, ck_icn_p_adc12, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_ADC3, ck_icn_p_adc3, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_CCI, ck_icn_p_cci, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_CRC, ck_icn_p_crc, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_MDF1, ck_icn_p_mdf1, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_OSPIIOM, ck_icn_p_ospiiom, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_HASH, ck_icn_p_hash, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_RNG, ck_icn_p_rng, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_CRYP1, ck_icn_p_cryp1, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_CRYP2, ck_icn_p_cryp2, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_SAES, ck_icn_p_saes, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_PKA, ck_icn_p_pka, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_ADF1, ck_icn_p_adf1, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_SPI8, ck_icn_p_spi8, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_LPUART1, ck_icn_p_lpuart1, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_I2C8, ck_icn_p_i2c8, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_LPTIM3, ck_icn_p_lptim3, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_LPTIM4, ck_icn_p_lptim4, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_LPTIM5, ck_icn_p_lptim5, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_IWDG5, ck_icn_p_iwdg5, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_WWDG2, ck_icn_p_wwdg2, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_I3C4, ck_icn_p_i3c4, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_SDMMC1, ck_icn_m_sdmmc1, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_SDMMC2, ck_icn_m_sdmmc2, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_SDMMC3, ck_icn_m_sdmmc3, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_USB2OHCI, ck_icn_m_usb2ohci, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_USB2EHCI, ck_icn_m_usb2ehci, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_USB3DRD, ck_icn_m_usb3drd, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_TIM2, ck_icn_p_tim2, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_TIM3, ck_icn_p_tim3, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_TIM4, ck_icn_p_tim4, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_TIM5, ck_icn_p_tim5, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_TIM6, ck_icn_p_tim6, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_TIM7, ck_icn_p_tim7, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_TIM10, ck_icn_p_tim10, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_TIM11, ck_icn_p_tim11, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_TIM12, ck_icn_p_tim12, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_TIM13, ck_icn_p_tim13, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_TIM14, ck_icn_p_tim14, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_LPTIM1, ck_icn_p_lptim1, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_LPTIM2, ck_icn_p_lptim2, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_SPI2, ck_icn_p_spi2, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_SPI3, ck_icn_p_spi3, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_SPDIFRX, ck_icn_p_spdifrx, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_USART2, ck_icn_p_usart2, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_USART3, ck_icn_p_usart3, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_UART4, ck_icn_p_uart4, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_UART5, ck_icn_p_uart5, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_I2C1, ck_icn_p_i2c1, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_I2C2, ck_icn_p_i2c2, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_I2C3, ck_icn_p_i2c3, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_I2C4, ck_icn_p_i2c4, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_I2C5, ck_icn_p_i2c5, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_I2C6, ck_icn_p_i2c6, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_I2C7, ck_icn_p_i2c7, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_I3C1, ck_icn_p_i3c1, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_I3C2, ck_icn_p_i3c2, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_I3C3, ck_icn_p_i3c3, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_TIM1, ck_icn_p_tim1, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_TIM8, ck_icn_p_tim8, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_TIM15, ck_icn_p_tim15, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_TIM16, ck_icn_p_tim16, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_TIM17, ck_icn_p_tim17, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_TIM20, ck_icn_p_tim20, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_SAI1, ck_icn_p_sai1, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_SAI2, ck_icn_p_sai2, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_SAI3, ck_icn_p_sai3, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_SAI4, ck_icn_p_sai4, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_USART1, ck_icn_p_usart1, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_USART6, ck_icn_p_usart6, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_UART7, ck_icn_p_uart7, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_UART8, ck_icn_p_uart8, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_UART9, ck_icn_p_uart9, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_FDCAN, ck_icn_p_fdcan, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_SPI1, ck_icn_p_spi1, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_SPI4, ck_icn_p_spi4, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_SPI5, ck_icn_p_spi5, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_SPI6, ck_icn_p_spi6, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_SPI7, ck_icn_p_spi7, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_IWDG1, ck_icn_p_iwdg1, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_IWDG2, ck_icn_p_iwdg2, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_IWDG3, ck_icn_p_iwdg3, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_IWDG4, ck_icn_p_iwdg4, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_WWDG1, ck_icn_p_wwdg1, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_VREF, ck_icn_p_vref, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_SERC, ck_icn_p_serc, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_HDP, ck_icn_p_hdp, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_IS2M, ck_icn_p_is2m, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_DSI, ck_icn_p_dsi, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_LTDC, ck_icn_p_ltdc, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_CSI, ck_icn_p_csi, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_DCMIPP, ck_icn_p_dcmipp, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_LVDS, ck_icn_p_lvds, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_GICV2M, ck_icn_p_gicv2m, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_USBTC, ck_icn_p_usbtc, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_USB3PCIEPHY, ck_icn_p_usb3pciephy, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_STGEN, ck_icn_p_stgen, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_VDEC, ck_icn_p_vdec, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_VENC, ck_icn_p_venc, SECF_NONE),
+	STM32_GATE_CFG(CK_SYSDBG, ck_sys_dbg, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_TIM2, ck_ker_tim2, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_TIM3, ck_ker_tim3, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_TIM4, ck_ker_tim4, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_TIM5, ck_ker_tim5, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_TIM6, ck_ker_tim6, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_TIM7, ck_ker_tim7, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_TIM10, ck_ker_tim10, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_TIM11, ck_ker_tim11, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_TIM12, ck_ker_tim12, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_TIM13, ck_ker_tim13, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_TIM14, ck_ker_tim14, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_TIM1, ck_ker_tim1, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_TIM8, ck_ker_tim8, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_TIM15, ck_ker_tim15, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_TIM16, ck_ker_tim16, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_TIM17, ck_ker_tim17, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_TIM20, ck_ker_tim20, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_LPTIM1, ck_ker_lptim1, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_LPTIM2, ck_ker_lptim2, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_USART2, ck_ker_usart2, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_UART4, ck_ker_uart4, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_USART3, ck_ker_usart3, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_UART5, ck_ker_uart5, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_SPI2, ck_ker_spi2, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_SPI3, ck_ker_spi3, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_SPDIFRX, ck_ker_spdifrx, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_I2C1, ck_ker_i2c1, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_I2C2, ck_ker_i2c2, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_I3C1, ck_ker_i3c1, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_I3C2, ck_ker_i3c2, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_I2C3, ck_ker_i2c3, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_I2C5, ck_ker_i2c5, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_I3C3, ck_ker_i3c3, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_I2C4, ck_ker_i2c4, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_I2C6, ck_ker_i2c6, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_I2C7, ck_ker_i2c7, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_SPI1, ck_ker_spi1, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_SPI4, ck_ker_spi4, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_SPI5, ck_ker_spi5, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_SPI6, ck_ker_spi6, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_SPI7, ck_ker_spi7, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_USART1, ck_ker_usart1, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_USART6, ck_ker_usart6, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_UART7, ck_ker_uart7, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_UART8, ck_ker_uart8, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_UART9, ck_ker_uart9, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_MDF1, ck_ker_mdf1, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_SAI1, ck_ker_sai1, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_SAI2, ck_ker_sai2, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_SAI3, ck_ker_sai3, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_SAI4, ck_ker_sai4, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_FDCAN, ck_ker_fdcan, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_CSI, ck_ker_csi, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_CSITXESC, ck_ker_csitxesc, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_CSIPHY, ck_ker_csiphy, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_STGEN, ck_ker_stgen, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_USBTC, ck_ker_usbtc, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_I3C4, ck_ker_i3c4, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_SPI8, ck_ker_spi8, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_I2C8, ck_ker_i2c8, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_LPUART1, ck_ker_lpuart1, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_LPTIM3, ck_ker_lptim3, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_LPTIM4, ck_ker_lptim4, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_LPTIM5, ck_ker_lptim5, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_ADF1, ck_ker_adf1, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_TSDBG, ck_ker_tsdbg, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_TPIU, ck_ker_tpiu, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_SYSATB, ck_sys_atb, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_OSPI1, ck_ker_ospi1, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_OSPI2, ck_ker_ospi2, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_SDMMC1, ck_ker_sdmmc1, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_SDMMC2, ck_ker_sdmmc2, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_SDMMC3, ck_ker_sdmmc3, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_ETH1, ck_ker_eth1, SECF_NONE),
+	STM32_GATE_CFG(CK_ETH1_STP, ck_ker_eth1stp, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_ETHSW, ck_ker_ethsw, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_ETH2, ck_ker_eth2, SECF_NONE),
+	STM32_GATE_CFG(CK_ETH2_STP, ck_ker_eth2stp, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_ETH1PTP, ck_ker_eth1ptp, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_ETH2PTP, ck_ker_eth2ptp, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_GPU, ck_icn_m_gpu, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_ETHSWREF, ck_ker_ethswref, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_ETHSWACMCFG, ck_icn_p_ethsw_acm_cfg, SECF_NONE),
+	STM32_GATE_CFG(CK_BUS_ETHSWACMMSG, ck_icn_p_ethsw_acm_msg, SECF_NONE),
+	STM32_GATE_CFG(CK_ETH1_MAC, ck_ker_eth1mac, SECF_NONE),
+	STM32_GATE_CFG(CK_ETH1_TX, ck_ker_eth1tx, SECF_NONE),
+	STM32_GATE_CFG(CK_ETH1_RX, ck_ker_eth1rx, SECF_NONE),
+	STM32_GATE_CFG(CK_ETH2_MAC, ck_ker_eth2mac, SECF_NONE),
+	STM32_GATE_CFG(CK_ETH2_TX, ck_ker_eth2tx, SECF_NONE),
+	STM32_GATE_CFG(CK_ETH2_RX, ck_ker_eth2rx, SECF_NONE),
+	STM32_COMPOSITE_CFG(CK_MCO1, ck_mco1, SECF_NONE),
+	STM32_COMPOSITE_CFG(CK_MCO2, ck_mco2, SECF_NONE),
+	STM32_COMPOSITE_CFG(CK_KER_ADC12, ck_ker_adc12, SECF_NONE),
+	STM32_COMPOSITE_CFG(CK_KER_ADC3, ck_ker_adc3, SECF_NONE),
+	STM32_COMPOSITE_CFG(CK_KER_USB2PHY1, ck_ker_usb2phy1, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_USB2PHY2, ck_ker_usb2phy2, SECF_NONE),
+	STM32_COMPOSITE_CFG(CK_KER_USB2PHY2EN, ck_ker_usb2phy2_en, SECF_NONE),
+	STM32_COMPOSITE_CFG(CK_KER_USB3PCIEPHY, ck_ker_usb3pciephy, SECF_NONE),
+	STM32_COMPOSITE_CFG(CK_KER_DSIBLANE, ck_ker_dsiblane, SECF_NONE),
+	STM32_COMPOSITE_CFG(CK_KER_DSIPHY, ck_ker_dsiphy, SECF_NONE),
+	STM32_COMPOSITE_CFG(CK_KER_LVDSPHY, ck_ker_lvdsphy, SECF_NONE),
+	STM32_COMPOSITE_CFG(CK_KER_DTS, ck_ker_dts, SECF_NONE),
+	STM32_GATE_CFG(CK_KER_LTDC, ck_ker_ltdc, SECF_NONE),
+};
+
+u16 stm32mp25_cpt_gate[GATE_NB];
+
+#ifdef CONFIG_DEBUG_FS
+static struct clock_summary clock_summary_mp25;
+#endif
+
+struct clk_stm32_clock_data stm32mp25_clock_data = {
+	.gate_cpt	= stm32mp25_cpt_gate,
+	.gates		= stm32mp25_gates,
+	.muxes		= stm32mp25_muxes,
+#ifdef CONFIG_DEBUG_FS
+	.dividers	= stm32mp25_dividers,
+#endif
+};
+
+static struct stm32_rcc_match_data stm32mp25_data = {
+	.tab_clocks	= stm32mp25_clock_cfg,
+	.num_clocks	= ARRAY_SIZE(stm32mp25_clock_cfg),
+	.maxbinding	= STM32MP2_LAST_CLK,
+	.clock_data	= &stm32mp25_clock_data,
+	.reset_us	= 2,
+#ifdef CONFIG_DEBUG_FS
+	.clock_summary	= &clock_summary_mp25,
+#endif
+};
+
+static const struct of_device_id stm32mp2_match_data[] = {
+	{
+		.compatible = "st,stm32mp2-rcc",
+		.data = &stm32mp25_data,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, stm32mp2_match_data);
+
+#ifdef CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+
+struct clk_obs_data {
+	const char *name;
+	u8 shift;
+	u8 width;
+};
+
+struct clk_obs {
+	void __iomem *base;
+	const struct clk_obs_data *data;
+};
+
+static const struct clk_obs_data ck_obs[] = {
+	{ "outsel",	27, 3 },
+	{ "obsdiv",	22, 3 },
+	{ "obsinv",	18, 1 },
+	{ "obsextsel",	16, 1 },
+	{ "extsel",	8, 3 },
+	{ "intsel",	0, 8 },
+};
+
+static int stm32_ck_obs_fops_set(void *data, u64 val)
+{
+	struct clk_obs *obs = (struct clk_obs *)data;
+	u32 mask = ((1 << (obs->data->width)) - 1);
+	u32 reg;
+
+	reg = readl_relaxed(obs->base) & ~mask;
+
+	val = reg | (val << obs->data->shift);
+
+	writel_relaxed(val, obs->base);
+
+	return 0;
+}
+
+static int stm32_ck_obs_fops_get(void *data, u64 *val)
+{
+	struct clk_obs *obs = (struct clk_obs *)data;
+	u32 mask;
+	u32 shift;
+
+	mask = ((1 << (obs->data->width)) - 1);
+	shift = obs->data->shift;
+	*val = (readl_relaxed(obs->base) & mask) >> shift;
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(stm32_ck_obs_fops, stm32_ck_obs_fops_get,
+			stm32_ck_obs_fops_set, "0x%llx\n");
+
+static int __init stm32_debugfs_create_obsx(const char *name,
+					    struct dentry *rootdir,
+					    void __iomem *base)
+{
+	struct clk_obs *obs;
+	int i;
+
+	rootdir = debugfs_lookup(name, rootdir);
+	if (!rootdir) {
+		if (IS_ERR(rootdir))
+			return -ENOMEM;
+	}
+
+	rootdir = debugfs_create_dir("obsctrl", rootdir);
+	if (IS_ERR(rootdir))
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(ck_obs); i++) {
+		obs = kzalloc(sizeof(*obs), GFP_KERNEL);
+		if (!obs)
+			return -ENOMEM;
+		obs->base = base;
+		obs->data = &ck_obs[i];
+
+		debugfs_create_file(ck_obs[i].name, 0644, rootdir, obs,
+				    &stm32_ck_obs_fops);
+	}
+
+	return 0;
+}
+
+static int __init stm32mp1_mco_debug_init(void)
+{
+	struct dentry *rootdir;
+
+	rootdir = debugfs_lookup("clk", NULL);
+	if (!rootdir) {
+		if (IS_ERR(rootdir))
+			return -1;
+	}
+
+	stm32_debugfs_create_obsx("ck_obs0", rootdir, rcc_base + RCC_MCO1CFGR);
+	stm32_debugfs_create_obsx("ck_obs1", rootdir, rcc_base + RCC_MCO2CFGR);
+
+	return 0;
+}
+late_initcall(stm32mp1_mco_debug_init);
+#endif
+
+static int stm32mp2_rcc_init(struct device *dev)
+{
+	void __iomem *base;
+	int ret;
+
+	base = of_iomap(dev_of_node(dev), 0);
+	if (!base) {
+		dev_err(dev, "%pOFn: unable to map resource", dev_of_node(dev));
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = stm32_rcc_init(dev, stm32mp2_match_data, base);
+
+out:
+	if (ret) {
+		if (base)
+			iounmap(base);
+
+		of_node_put(dev_of_node(dev));
+	}
+
+	return ret;
+}
+
+static int get_clock_deps(struct device *dev)
+{
+	const char *clock_deps_name[] = {
+		"hsi", "hse", "msi", "lsi", "lse",
+	};
+
+	size_t deps_size = sizeof(struct clk *) * ARRAY_SIZE(clock_deps_name);
+	struct clk **clk_deps;
+	int i;
+
+	clk_deps = devm_kzalloc(dev, deps_size, GFP_KERNEL);
+	if (!clk_deps)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(clock_deps_name); i++) {
+		struct clk *clk;
+
+		clk = of_clk_get_by_name(dev_of_node(dev), clock_deps_name[i]);
+
+		if (IS_ERR(clk)) {
+			if (PTR_ERR(clk) != -EINVAL && PTR_ERR(clk) != -ENOENT) {
+				return PTR_ERR(clk);
+			}
+
+		} else {
+			/* Device gets a reference count on the clock */
+			clk_deps[i] = devm_clk_get(dev, __clk_get_name(clk));
+			clk_put(clk);
+		}
+	}
+
+	return 0;
+}
+
+static int stm32mp2_rcc_clocks_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	int ret = get_clock_deps(dev);
+
+	if (!ret)
+		ret = stm32mp2_rcc_init(dev);
+
+	return ret;
+}
+
+static int stm32mp2_rcc_clocks_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *child, *np = dev_of_node(dev);
+
+	for_each_available_child_of_node(np, child)
+		of_clk_del_provider(child);
+
+	return 0;
+}
+
+static struct platform_driver stm32mp2_rcc_clocks_driver = {
+	.driver	= {
+		.name = "stm32mp2_rcc",
+		.of_match_table = stm32mp2_match_data,
+	},
+	.probe = stm32mp2_rcc_clocks_probe,
+	.remove = stm32mp2_rcc_clocks_remove,
+};
+
+static int __init stm32mp2_clocks_init(void)
+{
+	return platform_driver_register(&stm32mp2_rcc_clocks_driver);
+}
+
+core_initcall(stm32mp2_clocks_init);
+
+#ifdef CONFIG_DEBUG_FS
+
+#include <linux/debugfs.h>
+
+static const char * const pll_src[] = {
+	"hsi_ck", "hse_ck", "msi_ck"
+};
+
+static const char * const flexgen_src[] = {
+	"ck_pll4", "ck_pll5", "ck_pll6", "ck_pll7", "ck_pll8",
+	"hsi_ck", "hse_ck", "msi_ck", "hsi_ck", "hse_ck", "msi_ck",
+	"spdifsymb", "i2sckin", "lsi_ck", "lse_ck"
+};
+
+static unsigned long clk_summary_div_recalc_rate(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	return clk_stm32_get_rate_divider(data->base, data, c->div_id, parent_rate);
+}
+
+#define CS_DIV(_name, _parent, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.div_id		= _div,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_GATE(_name, _parent, _gate) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_GATEMUX(_name, _parents, _gate, _mux) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+static unsigned long clk_summary_clk_recalc_rate(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	struct clk *clk = __clk_lookup(c->name);
+
+	if (clk)
+		return clk_get_rate(clk);
+
+	return 0;
+}
+
+#define CS_OSC(_name, _gate) \
+{\
+	.name		= _name,\
+	.nb_parents	= 0,\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+	.get_rate	= clk_summary_clk_recalc_rate,\
+}
+
+static unsigned long clk_summary_hsediv2_recalc_rate(struct clk_stm32_clock_data *data,
+						     struct clk_summary *c,
+						     unsigned long parent_rate)
+{
+	void __iomem *addr = data->base + RCC_OCENSETR;
+
+	if ((readl(addr) & RCC_OCENSETR_HSEDIV2BYP) != 0U)
+		return parent_rate;
+
+	return parent_rate / 2;
+}
+
+#define CS_HSE_DIV2(_name, _parent, _gate) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+	.get_rate	= clk_summary_hsediv2_recalc_rate,\
+}
+
+static bool clk_summary_cpu1_is_enabled(struct clk_stm32_clock_data *data,
+					struct clk_summary *c)
+{
+	return true;
+}
+
+#define CS_CPU1(_name) \
+{\
+	.name		= _name,\
+	.nb_parents	= 0,\
+	.div_id		= NO_STM32_DIV,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.get_rate	= clk_summary_clk_recalc_rate,\
+	.is_enabled	= clk_summary_cpu1_is_enabled,\
+}
+
+/* PLL configuration registers offsets from RCC_PLLxCFGR1 */
+#define RCC_OFFSET_PLLXCFGR1	0x00
+#define RCC_OFFSET_PLLXCFGR2	0x04
+#define RCC_OFFSET_PLLXCFGR3	0x08
+#define RCC_OFFSET_PLLXCFGR4	0x0C
+#define RCC_OFFSET_PLLXCFGR5	0x10
+#define RCC_OFFSET_PLLXCFGR6	0x18
+#define RCC_OFFSET_PLLXCFGR7	0x1C
+
+struct cs_pll {
+	u32 offset;
+};
+
+static unsigned long clk_get_pll_fvco(struct clk_stm32_clock_data *data, u32 offset_base,
+				      unsigned long prate)
+{
+	void __iomem *pllxcfgr1 = data->base + offset_base;
+	void __iomem *pllxcfgr2 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR2;
+	void __iomem *pllxcfgr3 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR3;
+	unsigned long fvco = 0UL;
+	u32 fracin, fbdiv, refdiv;
+
+	fracin = readl(pllxcfgr3) & RCC_PLLxCFGR3_FRACIN_MASK;
+	fbdiv = (readl(pllxcfgr2) & RCC_PLLxCFGR2_FBDIV_MASK) >>
+		RCC_PLLxCFGR2_FBDIV_SHIFT;
+
+	refdiv = readl(pllxcfgr2) & RCC_PLLxCFGR2_FREFDIV_MASK;
+
+	if (fracin != 0U) {
+		unsigned long long numerator, denominator;
+
+		numerator = ((unsigned long long)fbdiv << 24) + fracin;
+		fvco = prate * numerator;
+		denominator = (unsigned long long)refdiv << 24;
+		do_div(fvco, denominator);
+
+	} else {
+		fvco = (u64)prate * fbdiv;
+		do_div(fvco, refdiv);
+	}
+
+	return fvco;
+}
+
+static unsigned long clk_summary_pll_frac_div_recalc_rate(struct clk_stm32_clock_data *data,
+							  struct clk_summary *c,
+							  unsigned long prate)
+{
+	struct cs_pll *cfg = c->data;
+	void __iomem *pllxcfgr1 = data->base + cfg->offset;
+	void __iomem *pllxcfgr4 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR4;
+	void __iomem *pllxcfgr6 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR6;
+	void __iomem *pllxcfgr7 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR7;
+	unsigned long dfout;
+	u32 postdiv1, postdiv2;
+
+	postdiv1 = readl(pllxcfgr6) & RCC_PLLxCFGR6_POSTDIV1_MASK;
+	postdiv2 = readl(pllxcfgr7) & RCC_PLLxCFGR7_POSTDIV2_MASK;
+
+	if ((readl(pllxcfgr4) & RCC_PLLxCFGR4_BYPASS) != 0U) {
+		dfout = prate;
+	} else {
+		if (postdiv1 == 0U || postdiv2 == 0U)
+			dfout = prate;
+		else
+			dfout = clk_get_pll_fvco(data, cfg->offset, prate) /
+						 (postdiv1 * postdiv2);
+	}
+
+	return dfout;
+}
+
+#define CS_PLL(_name, _parents, _gate, _mux, _offset)\
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= NO_STM32_DIV,\
+	.data		=  &(struct cs_pll) {\
+		.offset		= _offset,\
+	},\
+	.get_rate	= clk_summary_pll_frac_div_recalc_rate,\
+}
+
+struct cs_flexgen {
+	u32 channel;
+};
+
+static bool clk_summary_flexgen_is_enabled(struct clk_stm32_clock_data *data,
+					   struct clk_summary *c)
+{
+	struct cs_flexgen *cfg = c->data;
+
+	return !!(readl(data->base + RCC_FINDIV0CFGR + (0x4 * cfg->channel)) &
+		RCC_FINDIVxCFGR_FINDIVxEN);
+}
+
+static u8 clk_summary_flexgen_get_parent(struct clk_stm32_clock_data *data,
+					 struct clk_summary *c)
+{
+	struct cs_flexgen *cfg = c->data;
+	void __iomem *address = data->base + RCC_XBAR0CFGR + (cfg->channel * 4);
+
+	return readl(address) & RCC_XBARxCFGR_XBARxSEL_MASK;
+}
+
+static unsigned long clk_summary_flexgen_recalc_rate(struct clk_stm32_clock_data *data,
+						     struct clk_summary *c,
+						     unsigned long prate)
+{
+	struct cs_flexgen *cfg = c->data;
+	u8 channel = cfg->channel;
+	u32 prediv, findiv;
+	unsigned long freq = prate;
+
+	prediv = readl(data->base + RCC_PREDIV0CFGR + (0x4 * channel)) &
+		       RCC_PREDIVxCFGR_PREDIVx_MASK;
+
+	findiv = readl(data->base + RCC_FINDIV0CFGR + (0x4 * channel)) &
+		       RCC_FINDIVxCFGR_FINDIVx_MASK;
+
+	if (freq == 0)
+		return 0;
+
+	switch (prediv) {
+	case 0x0:
+		break;
+
+	case 0x1:
+		freq /= 2;
+		break;
+
+	case 0x3:
+		freq /= 4;
+		break;
+
+	case 0x3FF:
+		freq /= 1024;
+		break;
+	}
+
+	freq /= (findiv + 1);
+
+	return freq;
+}
+
+#define CS_FLEXGEN(_name, _channel)\
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(flexgen_src),\
+	.parent_names	= flexgen_src,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+	.data		=  &(struct cs_flexgen) {\
+		.channel		= _channel,\
+	},\
+	.is_enabled	= clk_summary_flexgen_is_enabled,\
+	.get_parent	= clk_summary_flexgen_get_parent,\
+	.get_rate	= clk_summary_flexgen_recalc_rate,\
+}
+
+struct cs_stm32_timer {
+	u32 apbdiv;
+	u32 timpre;
+};
+
+#define APB_DIV_MASK 0x07
+#define TIM_PRE_MASK 0x01
+
+static unsigned long clk_stm32_timer_recalc_rate(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	struct cs_stm32_timer *tim = c->data;
+	u32 prescaler, timpre;
+
+	prescaler = readl(data->base + tim->apbdiv) & APB_DIV_MASK;
+
+	timpre = readl(data->base + tim->timpre) & TIM_PRE_MASK;
+
+	if (prescaler == 0U)
+		return parent_rate;
+
+	return parent_rate * (timpre + 1U) * 2U;
+}
+
+#define CS_STM32_TIMER(_name, _parent, _apbdiv, _timpre) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.div_id		= NO_STM32_DIV,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.data		=  &(struct cs_stm32_timer) {\
+		.apbdiv		= _apbdiv,\
+		.timpre		= _timpre,\
+	},\
+	.get_rate	= clk_stm32_timer_recalc_rate,\
+}
+
+static const char * const rtc_src[] = {
+	"off", "hse_ck", "lsi_ck", "ck_hse_rtc"
+};
+
+static struct clk_summary stm32mp25_clock_summary[] = {
+	CS_OSC("hsi_ck", GATE_HSI),
+	CS_OSC("lsi_ck", GATE_LSI),
+	CS_OSC("msi_ck", GATE_MSI),
+	CS_OSC("hse_ck", GATE_HSE),
+	CS_OSC("lse_ck", GATE_LSE),
+
+	CS_HSE_DIV2("hse_div2_ck", "hse_ck", GATE_HSEDIV2),
+	CS_DIV("ck_hse_rtc", "hse_ck", DIV_RTC),
+
+	CS_PLL("ck_pll2", pll_src, GATE_PLL2, MUX_MUXSEL6, RCC_PLL2CFGR1),
+	CS_PLL("ck_pll3", pll_src, GATE_PLL3, MUX_MUXSEL7, RCC_PLL3CFGR1),
+	CS_PLL("ck_pll4", pll_src, GATE_PLL4, MUX_MUXSEL0, RCC_PLL4CFGR1),
+	CS_PLL("ck_pll5", pll_src, GATE_PLL5, MUX_MUXSEL1, RCC_PLL5CFGR1),
+	CS_PLL("ck_pll6", pll_src, GATE_PLL6, MUX_MUXSEL2, RCC_PLL6CFGR1),
+	CS_PLL("ck_pll7", pll_src, GATE_PLL7, MUX_MUXSEL3, RCC_PLL7CFGR1),
+	CS_PLL("ck_pll8", pll_src, GATE_PLL8, MUX_MUXSEL4, RCC_PLL8CFGR1),
+
+	CS_CPU1("ck_cpu1"),
+
+	CS_FLEXGEN("ck_icn_hs_mcu", 0),
+
+	CS_DIV("ck_icn_ls_mcu", "ck_icn_hs_mcu", DIV_LSMCU),
+
+	CS_FLEXGEN("ck_icn_sdmmc", 1),
+	CS_FLEXGEN("ck_icn_ddr", 2),
+	CS_FLEXGEN("ck_icn_display", 3),
+	CS_FLEXGEN("ck_icn_hsl", 4),
+	CS_FLEXGEN("ck_icn_nic", 5),
+	CS_FLEXGEN("ck_icn_vid", 6),
+	CS_FLEXGEN("ck_flexgen_07", 7),
+	CS_FLEXGEN("ck_flexgen_08", 8),
+	CS_FLEXGEN("ck_flexgen_09", 9),
+	CS_FLEXGEN("ck_flexgen_10", 10),
+	CS_FLEXGEN("ck_flexgen_11", 11),
+	CS_FLEXGEN("ck_flexgen_12", 12),
+	CS_FLEXGEN("ck_flexgen_13", 13),
+	CS_FLEXGEN("ck_flexgen_14", 14),
+	CS_FLEXGEN("ck_flexgen_15", 15),
+	CS_FLEXGEN("ck_flexgen_16", 16),
+	CS_FLEXGEN("ck_flexgen_17", 17),
+	CS_FLEXGEN("ck_flexgen_18", 18),
+	CS_FLEXGEN("ck_flexgen_19", 19),
+	CS_FLEXGEN("ck_flexgen_20", 20),
+	CS_FLEXGEN("ck_flexgen_21", 21),
+	CS_FLEXGEN("ck_flexgen_22", 22),
+	CS_FLEXGEN("ck_flexgen_23", 23),
+	CS_FLEXGEN("ck_flexgen_24", 24),
+	CS_FLEXGEN("ck_flexgen_25", 25),
+	CS_FLEXGEN("ck_flexgen_26", 26),
+	CS_FLEXGEN("ck_flexgen_27", 27),
+	CS_FLEXGEN("ck_flexgen_28", 28),
+	CS_FLEXGEN("ck_flexgen_29", 29),
+	CS_FLEXGEN("ck_flexgen_30", 30),
+	CS_FLEXGEN("ck_flexgen_31", 31),
+	CS_FLEXGEN("ck_flexgen_32", 32),
+	CS_FLEXGEN("ck_flexgen_33", 33),
+	CS_FLEXGEN("ck_flexgen_34", 34),
+	CS_FLEXGEN("ck_flexgen_35", 35),
+	CS_FLEXGEN("ck_flexgen_36", 36),
+	CS_FLEXGEN("ck_flexgen_37", 37),
+	CS_FLEXGEN("ck_flexgen_38", 38),
+	CS_FLEXGEN("ck_flexgen_39", 39),
+	CS_FLEXGEN("ck_flexgen_40", 40),
+	CS_FLEXGEN("ck_flexgen_41", 41),
+	CS_FLEXGEN("ck_flexgen_42", 42),
+	CS_FLEXGEN("ck_flexgen_43", 43),
+	CS_FLEXGEN("ck_flexgen_44", 44),
+	CS_FLEXGEN("ck_flexgen_45", 45),
+	CS_FLEXGEN("ck_flexgen_46", 46),
+	CS_FLEXGEN("ck_flexgen_47", 47),
+	CS_FLEXGEN("ck_flexgen_48", 48),
+	CS_FLEXGEN("ck_flexgen_49", 49),
+	CS_FLEXGEN("ck_flexgen_50", 50),
+	CS_FLEXGEN("ck_flexgen_51", 51),
+	CS_FLEXGEN("ck_flexgen_52", 52),
+	CS_FLEXGEN("ck_flexgen_53", 53),
+	CS_FLEXGEN("ck_flexgen_54", 54),
+	CS_FLEXGEN("ck_flexgen_55", 55),
+	CS_FLEXGEN("ck_flexgen_56", 56),
+	CS_FLEXGEN("ck_flexgen_57", 57),
+	CS_FLEXGEN("ck_flexgen_58", 58),
+	CS_FLEXGEN("ck_flexgen_59", 59),
+	CS_FLEXGEN("ck_flexgen_60", 60),
+	CS_FLEXGEN("ck_flexgen_61", 61),
+	CS_FLEXGEN("ck_flexgen_62", 62),
+	CS_FLEXGEN("ck_flexgen_63", 63),
+
+	CS_DIV("ck_icn_apb1", "ck_icn_ls_mcu", DIV_APB1),
+	CS_DIV("ck_icn_apb2", "ck_icn_ls_mcu", DIV_APB2),
+	CS_DIV("ck_icn_apb3", "ck_icn_ls_mcu", DIV_APB3),
+	CS_DIV("ck_icn_apb4", "ck_icn_ls_mcu", DIV_APB4),
+	CS_DIV("ck_icn_apbdbg", "ck_icn_ls_mcu", DIV_APBDBG),
+
+	CS_STM32_TIMER("ck_timg1", "ck_icn_apb1", RCC_APB1DIVR, RCC_TIMG1PRER),
+	CS_STM32_TIMER("ck_timg2", "ck_icn_apb2", RCC_APB2DIVR, RCC_TIMG2PRER),
+
+	CS_GATE("ck_icn_s_sysram", "ck_icn_hs_mcu", GATE_SYSRAM),
+	CS_GATE("ck_icn_s_vderam", "ck_icn_hs_mcu", GATE_VDERAM),
+	CS_GATE("ck_icn_s_retram", "ck_icn_hs_mcu", GATE_RETRAM),
+	CS_GATE("ck_icn_s_sram1", "ck_icn_hs_mcu", GATE_SRAM1),
+	CS_GATE("ck_icn_s_sram2", "ck_icn_hs_mcu", GATE_SRAM2),
+	CS_GATE("ck_icn_s_ospi1", "ck_icn_hs_mcu", GATE_OSPI1),
+	CS_GATE("ck_icn_s_ospi2", "ck_icn_hs_mcu", GATE_OSPI2),
+	CS_GATE("ck_icn_s_bkpsram", "ck_icn_ls_mcu", GATE_BKPSRAM),
+	CS_GATE("ck_icn_p_ddrphyc", "ck_icn_ls_mcu", GATE_DDRPHYCAPB),
+	CS_GATE("ck_icn_p_syscpu1", "ck_icn_ls_mcu", GATE_SYSCPU1),
+	CS_GATE("ck_icn_p_hpdma1", "ck_icn_ls_mcu", GATE_HPDMA1),
+	CS_GATE("ck_icn_p_hpdma2", "ck_icn_ls_mcu", GATE_HPDMA2),
+	CS_GATE("ck_icn_p_hpdma3", "ck_icn_ls_mcu", GATE_HPDMA3),
+	CS_GATE("ck_icn_p_ipcc1", "ck_icn_ls_mcu", GATE_IPCC1),
+	CS_GATE("ck_icn_p_ipcc2", "ck_icn_ls_mcu", GATE_IPCC2),
+	CS_GATE("ck_icn_p_cci", "ck_icn_ls_mcu", GATE_CCI),
+	CS_GATE("ck_icn_p_crc", "ck_icn_ls_mcu", GATE_CRC),
+	CS_GATE("ck_icn_p_ospiiom", "ck_icn_ls_mcu", GATE_OSPIIOM),
+	CS_GATE("ck_icn_p_hash", "ck_icn_ls_mcu", GATE_HASH),
+	CS_GATE("ck_icn_p_rng", "ck_icn_ls_mcu", GATE_RNG),
+	CS_GATE("ck_icn_p_cryp1", "ck_icn_ls_mcu", GATE_CRYP1),
+	CS_GATE("ck_icn_p_cryp2", "ck_icn_ls_mcu", GATE_CRYP2),
+	CS_GATE("ck_icn_p_saes", "ck_icn_ls_mcu", GATE_SAES),
+	CS_GATE("ck_icn_p_pka", "ck_icn_ls_mcu", GATE_PKA),
+	CS_GATE("ck_icn_p_gpioa", "ck_icn_ls_mcu", GATE_GPIOA),
+	CS_GATE("ck_icn_p_gpiob", "ck_icn_ls_mcu", GATE_GPIOB),
+	CS_GATE("ck_icn_p_gpioc", "ck_icn_ls_mcu", GATE_GPIOC),
+	CS_GATE("ck_icn_p_gpiod", "ck_icn_ls_mcu", GATE_GPIOD),
+	CS_GATE("ck_icn_p_gpioe", "ck_icn_ls_mcu", GATE_GPIOE),
+	CS_GATE("ck_icn_p_gpiof", "ck_icn_ls_mcu", GATE_GPIOF),
+	CS_GATE("ck_icn_p_gpiog", "ck_icn_ls_mcu", GATE_GPIOG),
+	CS_GATE("ck_icn_p_gpioh", "ck_icn_ls_mcu", GATE_GPIOH),
+	CS_GATE("ck_icn_p_gpioi", "ck_icn_ls_mcu", GATE_GPIOI),
+	CS_GATE("ck_icn_p_gpioj", "ck_icn_ls_mcu", GATE_GPIOJ),
+	CS_GATE("ck_icn_p_gpiok", "ck_icn_ls_mcu", GATE_GPIOK),
+	CS_GATE("ck_icn_s_lpsram1", "ck_icn_ls_mcu", GATE_LPSRAM1),
+	CS_GATE("ck_icn_s_lpsram2", "ck_icn_ls_mcu", GATE_LPSRAM2),
+	CS_GATE("ck_icn_s_lpsram3", "ck_icn_ls_mcu", GATE_LPSRAM3),
+	CS_GATE("ck_icn_p_gpioz", "ck_icn_ls_mcu", GATE_GPIOZ),
+	CS_GATE("ck_icn_p_lpdma", "ck_icn_ls_mcu", GATE_LPDMA),
+	CS_GATE("ck_icn_p_adf1", "ck_icn_ls_mcu", GATE_ADF1),
+	CS_GATE("ck_icn_p_hsem", "ck_icn_ls_mcu", GATE_HSEM),
+	CS_GATE("ck_icn_p_rtc", "ck_icn_ls_mcu", GATE_RTC),
+	CS_GATE("ck_icn_p_iwdg5", "ck_icn_ls_mcu", GATE_IWDG5),
+	CS_GATE("ck_icn_p_wwdg2", "ck_icn_ls_mcu", GATE_WWDG2),
+	CS_GATE("ck_icn_s_stm500", "ck_icn_ls_mcu", GATE_STM500),
+	CS_GATE("ck_icn_p_fmc", "ck_icn_ls_mcu", GATE_FMC),
+	CS_GATE("ck_icn_p_eth1", "ck_icn_ls_mcu", GATE_ETH1),
+	CS_GATE("ck_icn_p_ethsw", "ck_icn_ls_mcu", GATE_ETHSWMAC),
+	CS_GATE("ck_icn_p_eth2", "ck_icn_ls_mcu", GATE_ETH2),
+	CS_GATE("ck_icn_p_pcie", "ck_icn_ls_mcu", GATE_PCIE),
+	CS_GATE("ck_icn_p_adc12", "ck_icn_ls_mcu", GATE_ADC12),
+	CS_GATE("ck_icn_p_adc3", "ck_icn_ls_mcu", GATE_ADC3),
+	CS_GATE("ck_icn_p_mdf1", "ck_icn_ls_mcu", GATE_MDF1),
+	CS_GATE("ck_icn_p_spi8", "ck_icn_ls_mcu", GATE_SPI8),
+	CS_GATE("ck_icn_p_lpuart1", "ck_icn_ls_mcu", GATE_LPUART1),
+	CS_GATE("ck_icn_p_i2c8", "ck_icn_ls_mcu", GATE_I2C8),
+	CS_GATE("ck_icn_p_lptim3", "ck_icn_ls_mcu", GATE_LPTIM3),
+	CS_GATE("ck_icn_p_lptim4", "ck_icn_ls_mcu", GATE_LPTIM4),
+	CS_GATE("ck_icn_p_lptim5", "ck_icn_ls_mcu", GATE_LPTIM5),
+	CS_GATE("ck_icn_p_risaf4", "ck_icn_ls_mcu", GATE_DDRCP),
+	CS_GATE("ck_icn_m_sdmmc1", "ck_icn_sdmmc", GATE_SDMMC1),
+	CS_GATE("ck_icn_m_sdmmc2", "ck_icn_sdmmc", GATE_SDMMC2),
+	CS_GATE("ck_icn_m_sdmmc3", "ck_icn_sdmmc", GATE_SDMMC3),
+	CS_GATE("ck_icn_s_ddr", "ck_icn_ddr", GATE_DDRCP),
+	CS_GATE("ck_icn_m_usb2ohci", "ck_icn_hsl", GATE_USB2),
+	CS_GATE("ck_icn_m_usb2ehci", "ck_icn_hsl", GATE_USB2),
+	CS_GATE("ck_icn_m_usb3drd", "ck_icn_hsl", GATE_USB3DRD),
+	CS_GATE("ck_icn_p_tim2", "ck_icn_apb1", GATE_TIM2),
+	CS_GATE("ck_icn_p_tim3", "ck_icn_apb1", GATE_TIM3),
+	CS_GATE("ck_icn_p_tim4", "ck_icn_apb1", GATE_TIM4),
+	CS_GATE("ck_icn_p_tim5", "ck_icn_apb1", GATE_TIM5),
+	CS_GATE("ck_icn_p_tim6", "ck_icn_apb1", GATE_TIM6),
+	CS_GATE("ck_icn_p_tim7", "ck_icn_apb1", GATE_TIM7),
+	CS_GATE("ck_icn_p_tim10", "ck_icn_apb1", GATE_TIM10),
+	CS_GATE("ck_icn_p_tim11", "ck_icn_apb1", GATE_TIM11),
+	CS_GATE("ck_icn_p_tim12", "ck_icn_apb1", GATE_TIM12),
+	CS_GATE("ck_icn_p_tim13", "ck_icn_apb1", GATE_TIM13),
+	CS_GATE("ck_icn_p_tim14", "ck_icn_apb1", GATE_TIM14),
+	CS_GATE("ck_icn_p_lptim1", "ck_icn_apb1", GATE_LPTIM1),
+	CS_GATE("ck_icn_p_lptim2", "ck_icn_apb1", GATE_LPTIM2),
+	CS_GATE("ck_icn_p_spi2", "ck_icn_apb1", GATE_SPI2),
+	CS_GATE("ck_icn_p_spi3", "ck_icn_apb1", GATE_SPI3),
+	CS_GATE("ck_icn_p_spdifrx", "ck_icn_apb1", GATE_SPDIFRX),
+	CS_GATE("ck_icn_p_usart2", "ck_icn_apb1", GATE_USART2),
+	CS_GATE("ck_icn_p_usart3", "ck_icn_apb1", GATE_USART3),
+	CS_GATE("ck_icn_p_uart4", "ck_icn_apb1", GATE_UART4),
+	CS_GATE("ck_icn_p_uart5", "ck_icn_apb1", GATE_UART5),
+	CS_GATE("ck_icn_p_i2c1", "ck_icn_apb1", GATE_I2C1),
+	CS_GATE("ck_icn_p_i2c2", "ck_icn_apb1", GATE_I2C2),
+	CS_GATE("ck_icn_p_i2c3", "ck_icn_apb1", GATE_I2C3),
+	CS_GATE("ck_icn_p_i2c4", "ck_icn_apb1", GATE_I2C4),
+	CS_GATE("ck_icn_p_i2c5", "ck_icn_apb1", GATE_I2C5),
+	CS_GATE("ck_icn_p_i2c6", "ck_icn_apb1", GATE_I2C6),
+	CS_GATE("ck_icn_p_i2c7", "ck_icn_apb1", GATE_I2C7),
+	CS_GATE("ck_icn_p_i3c1", "ck_icn_apb1", GATE_I3C1),
+	CS_GATE("ck_icn_p_i3c2", "ck_icn_apb1", GATE_I3C2),
+	CS_GATE("ck_icn_p_i3c3", "ck_icn_apb1", GATE_I3C3),
+	CS_GATE("ck_icn_p_i3c4", "ck_icn_ls_mcu", GATE_I3C4),
+	CS_GATE("ck_icn_p_tim1", "ck_icn_apb2", GATE_TIM1),
+	CS_GATE("ck_icn_p_tim8", "ck_icn_apb2", GATE_TIM8),
+	CS_GATE("ck_icn_p_tim15", "ck_icn_apb2", GATE_TIM15),
+	CS_GATE("ck_icn_p_tim16", "ck_icn_apb2", GATE_TIM16),
+	CS_GATE("ck_icn_p_tim17", "ck_icn_apb2", GATE_TIM17),
+	CS_GATE("ck_icn_p_tim20", "ck_icn_apb2", GATE_TIM20),
+	CS_GATE("ck_icn_p_sai1", "ck_icn_apb2", GATE_SAI1),
+	CS_GATE("ck_icn_p_sai2", "ck_icn_apb2", GATE_SAI2),
+	CS_GATE("ck_icn_p_sai3", "ck_icn_apb2", GATE_SAI3),
+	CS_GATE("ck_icn_p_sai4", "ck_icn_apb2", GATE_SAI4),
+	CS_GATE("ck_icn_p_usart1", "ck_icn_apb2", GATE_USART1),
+	CS_GATE("ck_icn_p_usart6", "ck_icn_apb2", GATE_USART6),
+	CS_GATE("ck_icn_p_uart7", "ck_icn_apb2", GATE_UART7),
+	CS_GATE("ck_icn_p_uart8", "ck_icn_apb2", GATE_UART8),
+	CS_GATE("ck_icn_p_uart9", "ck_icn_apb2", GATE_UART9),
+	CS_GATE("ck_icn_p_fdcan", "ck_icn_apb2", GATE_FDCAN),
+	CS_GATE("ck_icn_p_spi1", "ck_icn_apb2", GATE_SPI1),
+	CS_GATE("ck_icn_p_spi4", "ck_icn_apb2", GATE_SPI4),
+	CS_GATE("ck_icn_p_spi5", "ck_icn_apb2", GATE_SPI5),
+	CS_GATE("ck_icn_p_spi6", "ck_icn_apb2", GATE_SPI6),
+	CS_GATE("ck_icn_p_spi7", "ck_icn_apb2", GATE_SPI7),
+	CS_GATE("ck_icn_p_bsec", "ck_icn_apb3", GATE_BSEC),
+	CS_GATE("ck_icn_p_iwdg1", "ck_icn_apb3", GATE_IWDG1),
+	CS_GATE("ck_icn_p_iwdg2", "ck_icn_apb3", GATE_IWDG2),
+	CS_GATE("ck_icn_p_iwdg3", "ck_icn_apb3", GATE_IWDG3),
+	CS_GATE("ck_icn_p_iwdg4", "ck_icn_apb3", GATE_IWDG4),
+	CS_GATE("ck_icn_p_wwdg1", "ck_icn_apb3", GATE_WWDG1),
+	CS_GATE("ck_icn_p_vref", "ck_icn_apb3", GATE_VREF),
+	CS_GATE("ck_icn_p_dts", "ck_icn_apb3", GATE_DTS),
+	CS_GATE("ck_icn_p_serc", "ck_icn_apb3", GATE_SERC),
+	CS_GATE("ck_icn_p_hdp", "ck_icn_apb3", GATE_HDP),
+	CS_GATE("ck_icn_p_is2m", "ck_icn_apb3", GATE_IS2M),
+	CS_GATE("ck_icn_p_dsi", "ck_icn_apb4", GATE_DSI),
+	CS_GATE("ck_icn_p_ltdc", "ck_icn_apb4", GATE_LTDC),
+	CS_GATE("ck_icn_p_csi2", "ck_icn_apb4", GATE_CSI),
+	CS_GATE("ck_icn_p_dcmipp", "ck_icn_apb4", GATE_DCMIPP),
+	CS_GATE("ck_icn_p_ddrc", "ck_icn_apb4", GATE_DDRCAPB),
+	CS_GATE("ck_icn_p_ddrcfg", "ck_icn_apb4", GATE_DDRCFG),
+	CS_GATE("ck_icn_p_lvds", "ck_icn_apb4", GATE_LVDS),
+	CS_GATE("ck_icn_p_gicv2m", "ck_icn_apb4", GATE_GICV2M),
+	CS_GATE("ck_icn_p_usbtc", "ck_icn_apb4", GATE_USBTC),
+	CS_GATE("ck_icn_p_busperfm", "ck_icn_apb4", GATE_BUSPERFM),
+	CS_GATE("ck_icn_p_usb3pciephy", "ck_icn_apb4", GATE_USB3PCIEPHY),
+	CS_GATE("ck_icn_p_stgen", "ck_icn_apb4", GATE_STGEN),
+	CS_GATE("ck_icn_p_vdec", "ck_icn_apb4", GATE_VDEC),
+	CS_GATE("ck_icn_p_venc", "ck_icn_apb4", GATE_VENC),
+	CS_GATE("ck_sys_dbg", "ck_icn_apbdbg", GATE_DBG),
+	CS_GATE("ck_ker_tim2", "ck_timg1", GATE_TIM2),
+	CS_GATE("ck_ker_tim3", "ck_timg1", GATE_TIM3),
+	CS_GATE("ck_ker_tim4", "ck_timg1", GATE_TIM4),
+	CS_GATE("ck_ker_tim5", "ck_timg1", GATE_TIM5),
+	CS_GATE("ck_ker_tim6", "ck_timg1", GATE_TIM6),
+	CS_GATE("ck_ker_tim7", "ck_timg1", GATE_TIM7),
+	CS_GATE("ck_ker_tim10", "ck_timg1", GATE_TIM10),
+	CS_GATE("ck_ker_tim11", "ck_timg1", GATE_TIM11),
+	CS_GATE("ck_ker_tim12", "ck_timg1", GATE_TIM12),
+	CS_GATE("ck_ker_tim13", "ck_timg1", GATE_TIM13),
+	CS_GATE("ck_ker_tim14", "ck_timg1", GATE_TIM14),
+	CS_GATE("ck_ker_tim1", "ck_timg2", GATE_TIM1),
+	CS_GATE("ck_ker_tim8", "ck_timg2", GATE_TIM8),
+	CS_GATE("ck_ker_tim15", "ck_timg2", GATE_TIM15),
+	CS_GATE("ck_ker_tim16", "ck_timg2", GATE_TIM16),
+	CS_GATE("ck_ker_tim17", "ck_timg2", GATE_TIM17),
+	CS_GATE("ck_ker_tim20", "ck_timg2", GATE_TIM20),
+	CS_GATE("ck_ker_lptim1", "ck_flexgen_07", GATE_LPTIM1),
+	CS_GATE("ck_ker_lptim2", "ck_flexgen_07", GATE_LPTIM2),
+	CS_GATE("ck_ker_usart2", "ck_flexgen_08", GATE_USART2),
+	CS_GATE("ck_ker_uart4", "ck_flexgen_08", GATE_UART4),
+	CS_GATE("ck_ker_usart3", "ck_flexgen_09", GATE_USART3),
+	CS_GATE("ck_ker_uart5", "ck_flexgen_09", GATE_UART5),
+	CS_GATE("ck_ker_spi2", "ck_flexgen_10", GATE_SPI2),
+	CS_GATE("ck_ker_spi3", "ck_flexgen_10", GATE_SPI3),
+	CS_GATE("ck_ker_spdifrx", "ck_flexgen_11", GATE_SPDIFRX),
+	CS_GATE("ck_ker_i2c1", "ck_flexgen_12", GATE_I2C1),
+	CS_GATE("ck_ker_i2c2", "ck_flexgen_12", GATE_I2C2),
+	CS_GATE("ck_ker_i3c1", "ck_flexgen_12", GATE_I3C1),
+	CS_GATE("ck_ker_i3c2", "ck_flexgen_12", GATE_I3C2),
+	CS_GATE("ck_ker_i2c3", "ck_flexgen_13", GATE_I2C3),
+	CS_GATE("ck_ker_i2c5", "ck_flexgen_13", GATE_I2C5),
+	CS_GATE("ck_ker_i3c3", "ck_flexgen_13", GATE_I3C3),
+	CS_GATE("ck_ker_i2c4", "ck_flexgen_14", GATE_I2C4),
+	CS_GATE("ck_ker_i2c6", "ck_flexgen_14", GATE_I2C6),
+	CS_GATE("ck_ker_i2c7", "ck_flexgen_15", GATE_I2C7),
+	CS_GATE("ck_ker_spi1", "ck_flexgen_16", GATE_SPI1),
+	CS_GATE("ck_ker_spi4", "ck_flexgen_17", GATE_SPI4),
+	CS_GATE("ck_ker_spi5", "ck_flexgen_17", GATE_SPI5),
+	CS_GATE("ck_ker_spi6", "ck_flexgen_18", GATE_SPI6),
+	CS_GATE("ck_ker_spi7", "ck_flexgen_18", GATE_SPI7),
+	CS_GATE("ck_ker_usart1", "ck_flexgen_19", GATE_USART1),
+	CS_GATE("ck_ker_usart6", "ck_flexgen_20", GATE_USART6),
+	CS_GATE("ck_ker_uart7", "ck_flexgen_21", GATE_UART7),
+	CS_GATE("ck_ker_uart8", "ck_flexgen_21", GATE_UART8),
+	CS_GATE("ck_ker_uart9", "ck_flexgen_22", GATE_UART9),
+	CS_GATE("ck_ker_mdf1", "ck_flexgen_23", GATE_MDF1),
+	CS_GATE("ck_ker_sai1", "ck_flexgen_23", GATE_SAI1),
+	CS_GATE("ck_ker_sai2", "ck_flexgen_24", GATE_SAI2),
+	CS_GATE("ck_ker_sai3", "ck_flexgen_25", GATE_SAI3),
+	CS_GATE("ck_ker_sai4", "ck_flexgen_25", GATE_SAI4),
+	CS_GATE("ck_ker_fdcan", "ck_flexgen_26", GATE_FDCAN),
+	CS_GATE("ck_ker_csi2", "ck_flexgen_29", GATE_CSI),
+	CS_GATE("ck_ker_csi2txesc", "ck_flexgen_30", GATE_CSI),
+	CS_GATE("ck_ker_csi2phy", "ck_flexgen_31", GATE_CSI),
+	CS_GATE("ck_ker_stgen", "ck_flexgen_33", GATE_STGEN),
+	CS_GATE("ck_ker_usbtc", "ck_flexgen_35", GATE_USBTC),
+	CS_GATE("ck_ker_i3c4", "ck_flexgen_36", GATE_I3C4),
+	CS_GATE("ck_ker_spi8", "ck_flexgen_37", GATE_SPI8),
+	CS_GATE("ck_ker_i2c8", "ck_flexgen_38", GATE_I2C8),
+	CS_GATE("ck_ker_lpuart1", "ck_flexgen_39", GATE_LPUART1),
+	CS_GATE("ck_ker_lptim3", "ck_flexgen_40", GATE_LPTIM3),
+	CS_GATE("ck_ker_lptim4", "ck_flexgen_41", GATE_LPTIM4),
+	CS_GATE("ck_ker_lptim5", "ck_flexgen_41", GATE_LPTIM5),
+	CS_GATE("ck_ker_adf1", "ck_flexgen_42", GATE_ADF1),
+	CS_GATE("ck_ker_tsdbg", "ck_flexgen_43", GATE_DBG),
+	CS_GATE("ck_ker_tpiu", "ck_flexgen_44", GATE_DBG),
+	CS_GATE("ck_icn_m_etr", "ck_flexgen_45", GATE_ETR),
+	CS_GATE("ck_sys_atb", "ck_flexgen_45", GATE_DBG),
+	CS_GATE("ck_ker_ospi1", "ck_flexgen_48", GATE_OSPI1),
+	CS_GATE("ck_ker_ospi2", "ck_flexgen_49", GATE_OSPI2),
+	CS_GATE("ck_ker_fmc", "ck_flexgen_50", GATE_FMC),
+	CS_GATE("ck_ker_sdmmc1", "ck_flexgen_51", GATE_SDMMC1),
+	CS_GATE("ck_ker_sdmmc2", "ck_flexgen_52", GATE_SDMMC2),
+	CS_GATE("ck_ker_sdmmc3", "ck_flexgen_53", GATE_SDMMC3),
+	CS_GATE("ck_ker_eth1", "ck_flexgen_54", GATE_ETH1),
+	CS_GATE("ck_ker_ethsw", "ck_flexgen_54", GATE_ETHSW),
+	CS_GATE("ck_ker_eth2", "ck_flexgen_55", GATE_ETH2),
+	CS_GATE("ck_ker_eth1ptp", "ck_flexgen_56", GATE_ETH1),
+	CS_GATE("ck_ker_eth2ptp", "ck_flexgen_56", GATE_ETH2),
+	CS_GATE("ck_ker_usb2phy2", "ck_flexgen_58", GATE_USB3DRD),
+	CS_GATE("ck_icn_m_gpu", "ck_flexgen_59", GATE_GPU),
+	CS_GATE("ck_ker_gpu", "ck_pll3", GATE_GPU),
+	CS_GATE("ck_ker_ethswref", "ck_flexgen_60", GATE_ETHSWREF),
+	CS_GATE("ck_ker_eth1stp", "ck_icn_ls_mcu", GATE_ETH1STP),
+	CS_GATE("ck_ker_eth2stp", "ck_icn_ls_mcu", GATE_ETH2STP),
+	CS_GATE("ck_ker_ltdc", "ck_flexgen_27", GATE_LTDC),
+
+	CS_GATEMUX("ck_mco1", mco1_src, GATE_MCO1, MUX_MCO1),
+	CS_GATEMUX("ck_mco2", mco2_src, GATE_MCO2, MUX_MCO2),
+	CS_GATEMUX("ck_ker_adc12", adc12_src, GATE_ADC12, MUX_ADC12),
+	CS_GATEMUX("ck_ker_adc3", adc3_src, GATE_ADC3, MUX_ADC3),
+	CS_GATEMUX("ck_ker_usb2phy1", usb2phy1_src, GATE_USB2PHY1, MUX_USB2PHY1),
+	CS_GATEMUX("ck_ker_usb2phy2_en", usb2phy2_src, GATE_USB2PHY2, MUX_USB2PHY2),
+	CS_GATEMUX("ck_ker_usb3pciephy", usb3pciphy_src, GATE_USB3PCIEPHY, MUX_USB3PCIEPHY),
+	CS_GATEMUX("ck_ker_dsiblane", dsiblane_src, GATE_DSI, MUX_DSIBLANE),
+	CS_GATEMUX("ck_ker_dsiphy", dsiphy_src, GATE_DSI, MUX_DSIPHY),
+	CS_GATEMUX("ck_ker_lvdsphy", lvdsphy_src, GATE_LVDS, MUX_LVDSPHY),
+	CS_GATEMUX("ck_ker_dts", dts_src, GATE_DTS, MUX_DTS),
+	CS_GATEMUX("ck_rtc", rtc_src, GATE_RTCCK, MUX_RTC),
+};
+
+static struct clock_summary clock_summary_mp25 = {
+	.clocks		= stm32mp25_clock_summary,
+	.nb_clocks	= ARRAY_SIZE(stm32mp25_clock_summary),
+};
+
+#endif
diff --git a/drivers/clk/stm32/reset-stm32.c b/drivers/clk/stm32/reset-stm32.c
new file mode 100644
index 000000000..8239b154a
--- /dev/null
+++ b/drivers/clk/stm32/reset-stm32.c
@@ -0,0 +1,161 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
+ */
+
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/reset-controller.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+
+#include "clk-stm32-core.h"
+
+#define STM32_RESET_ID_MASK GENMASK(15, 0)
+
+struct stm32_reset_data {
+	/* reset lock */
+	spinlock_t			lock;
+	struct reset_controller_dev	rcdev;
+	void __iomem			*membase;
+	u32				clear_offset;
+	unsigned int			reset_us;
+};
+
+static inline struct stm32_reset_data *
+to_stm32_reset_data(struct reset_controller_dev *rcdev)
+{
+	return container_of(rcdev, struct stm32_reset_data, rcdev);
+}
+
+static int stm32_reset_update(struct reset_controller_dev *rcdev,
+			      unsigned long id, bool assert)
+{
+	struct stm32_reset_data *data = to_stm32_reset_data(rcdev);
+	int reg_width = sizeof(u32);
+	int bank = id / (reg_width * BITS_PER_BYTE);
+	int offset = id % (reg_width * BITS_PER_BYTE);
+
+	if (data->clear_offset) {
+		void __iomem *addr;
+
+		addr = data->membase + (bank * reg_width);
+		if (!assert)
+			addr += data->clear_offset;
+
+		writel(BIT(offset), addr);
+
+	} else {
+		unsigned long flags;
+		u32 reg;
+
+		spin_lock_irqsave(&data->lock, flags);
+
+		reg = readl(data->membase + (bank * reg_width));
+
+		if (assert)
+			reg |= BIT(offset);
+		else
+			reg &= ~BIT(offset);
+
+		writel(reg, data->membase + (bank * reg_width));
+
+		spin_unlock_irqrestore(&data->lock, flags);
+	}
+
+	return 0;
+}
+
+static int stm32_reset_assert(struct reset_controller_dev *rcdev,
+			      unsigned long id)
+{
+	return stm32_reset_update(rcdev, id, true);
+}
+
+static int stm32_reset_deassert(struct reset_controller_dev *rcdev,
+				unsigned long id)
+{
+	return stm32_reset_update(rcdev, id, false);
+}
+
+static int stm32_reset_status(struct reset_controller_dev *rcdev,
+			      unsigned long id)
+{
+	struct stm32_reset_data *data = to_stm32_reset_data(rcdev);
+	int reg_width = sizeof(u32);
+	int bank = id / (reg_width * BITS_PER_BYTE);
+	int offset = id % (reg_width * BITS_PER_BYTE);
+	u32 reg;
+
+	reg = readl(data->membase + (bank * reg_width));
+
+	return !!(reg & BIT(offset));
+}
+
+static int stm32_check_deassert(struct reset_controller_dev *rcdev,
+				unsigned long id)
+{
+	struct stm32_reset_data *data = to_stm32_reset_data(rcdev);
+	int reg_width = sizeof(u32);
+	int bank = id / (reg_width * BITS_PER_BYTE);
+	int offset = id % (reg_width * BITS_PER_BYTE);
+	u32 reg;
+
+	return readl_poll_timeout(data->membase + (bank * reg_width), reg,
+				  !(reg & BIT(offset)), 10, 10 * USEC_PER_MSEC);
+}
+
+static int stm32_reset(struct reset_controller_dev *rcdev, unsigned long id)
+{
+	struct stm32_reset_data *data = to_stm32_reset_data(rcdev);
+	int ret;
+
+	ret = stm32_reset_assert(rcdev, id);
+	if (ret)
+		return ret;
+
+	if (!data->reset_us)
+		usleep_range(data->reset_us, data->reset_us * 2);
+
+	ret = stm32_reset_deassert(rcdev, id);
+	if (ret)
+		return ret;
+
+	ret = stm32_check_deassert(rcdev, id);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static const struct reset_control_ops stm32_reset_ops = {
+	.assert		= stm32_reset_assert,
+	.deassert	= stm32_reset_deassert,
+	.reset		= stm32_reset,
+	.status		= stm32_reset_status,
+};
+
+int stm32_rcc_reset_init(struct device *dev, const struct of_device_id *match,
+			 void __iomem *base)
+{
+	const struct stm32_rcc_match_data *data = match->data;
+	struct stm32_reset_data *reset_data = NULL;
+
+	data = match->data;
+
+	reset_data = kzalloc(sizeof(*reset_data), GFP_KERNEL);
+	if (!reset_data)
+		return -ENOMEM;
+
+	reset_data->membase = base;
+	reset_data->rcdev.owner = THIS_MODULE;
+	reset_data->rcdev.ops = &stm32_reset_ops;
+	reset_data->rcdev.of_node = dev_of_node(dev);
+	reset_data->rcdev.nr_resets = STM32_RESET_ID_MASK;
+	reset_data->clear_offset = data->clear_offset;
+	reset_data->reset_us = data->reset_us;
+
+	return reset_controller_register(&reset_data->rcdev);
+}
diff --git a/drivers/clk/stm32/reset-stm32.h b/drivers/clk/stm32/reset-stm32.h
new file mode 100644
index 000000000..63a4a35b5
--- /dev/null
+++ b/drivers/clk/stm32/reset-stm32.h
@@ -0,0 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0  */
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
+ */
+
+int stm32_rcc_reset_init(struct device *dev, const struct of_device_id *match, void __iomem *base);
diff --git a/drivers/clk/stm32/stm32mp13_rcc.h b/drivers/clk/stm32/stm32mp13_rcc.h
new file mode 100644
index 000000000..f01a98c85
--- /dev/null
+++ b/drivers/clk/stm32/stm32mp13_rcc.h
@@ -0,0 +1,1751 @@
+/* SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause */
+/*
+ * Copyright (C) 2020, STMicroelectronics - All Rights Reserved
+ *
+ * Configuration settings for the STM32MP13x CPU
+ */
+
+#ifndef STM32MP13_RCC_H
+#define STM32MP13_RCC_H
+/* RCC registers */
+#define RCC_SECCFGR			0x0
+#define RCC_MP_SREQSETR			0x100
+#define RCC_MP_SREQCLRR			0x104
+#define RCC_MP_APRSTCR			0x108
+#define RCC_MP_APRSTSR			0x10c
+#define RCC_PWRLPDLYCR			0x110
+#define RCC_MP_GRSTCSETR		0x114
+#define RCC_BR_RSTSCLRR			0x118
+#define RCC_MP_RSTSSETR			0x11c
+#define RCC_MP_RSTSCLRR			0x120
+#define RCC_MP_IWDGFZSETR		0x124
+#define RCC_MP_IWDGFZCLRR		0x128
+#define RCC_MP_CIER			0x200
+#define RCC_MP_CIFR			0x204
+#define RCC_BDCR			0x400
+#define RCC_RDLSICR			0x404
+#define RCC_OCENSETR			0x420
+#define RCC_OCENCLRR			0x424
+#define RCC_OCRDYR			0x428
+#define RCC_HSICFGR			0x440
+#define RCC_CSICFGR			0x444
+#define RCC_MCO1CFGR			0x460
+#define RCC_MCO2CFGR			0x464
+#define RCC_DBGCFGR			0x468
+#define RCC_RCK12SELR			0x480
+#define RCC_RCK3SELR			0x484
+#define RCC_RCK4SELR			0x488
+#define RCC_PLL1CR			0x4a0
+#define RCC_PLL1CFGR1			0x4a4
+#define RCC_PLL1CFGR2			0x4a8
+#define RCC_PLL1FRACR			0x4ac
+#define RCC_PLL1CSGR			0x4b0
+#define RCC_PLL2CR			0x4d0
+#define RCC_PLL2CFGR1			0x4d4
+#define RCC_PLL2CFGR2			0x4d8
+#define RCC_PLL2FRACR			0x4dc
+#define RCC_PLL2CSGR			0x4e0
+#define RCC_PLL3CR			0x500
+#define RCC_PLL3CFGR1			0x504
+#define RCC_PLL3CFGR2			0x508
+#define RCC_PLL3FRACR			0x50c
+#define RCC_PLL3CSGR			0x510
+#define RCC_PLL4CR			0x520
+#define RCC_PLL4CFGR1			0x524
+#define RCC_PLL4CFGR2			0x528
+#define RCC_PLL4FRACR			0x52c
+#define RCC_PLL4CSGR			0x530
+#define RCC_MPCKSELR			0x540
+#define RCC_ASSCKSELR			0x544
+#define RCC_MSSCKSELR			0x548
+#define RCC_CPERCKSELR			0x54c
+#define RCC_RTCDIVR			0x560
+#define RCC_MPCKDIVR			0x564
+#define RCC_AXIDIVR			0x568
+#define RCC_MLAHBDIVR			0x56c
+#define RCC_APB1DIVR			0x570
+#define RCC_APB2DIVR			0x574
+#define RCC_APB3DIVR			0x578
+#define RCC_APB4DIVR			0x57c
+#define RCC_APB5DIVR			0x580
+#define RCC_APB6DIVR			0x584
+#define RCC_TIMG1PRER			0x5a0
+#define RCC_TIMG2PRER			0x5a4
+#define RCC_TIMG3PRER			0x5a8
+#define RCC_DDRITFCR			0x5c0
+#define RCC_I2C12CKSELR			0x600
+#define RCC_I2C345CKSELR		0x604
+#define RCC_SPI2S1CKSELR		0x608
+#define RCC_SPI2S23CKSELR		0x60c
+#define RCC_SPI45CKSELR			0x610
+#define RCC_UART12CKSELR		0x614
+#define RCC_UART35CKSELR		0x618
+#define RCC_UART4CKSELR			0x61c
+#define RCC_UART6CKSELR			0x620
+#define RCC_UART78CKSELR		0x624
+#define RCC_LPTIM1CKSELR		0x628
+#define RCC_LPTIM23CKSELR		0x62c
+#define RCC_LPTIM45CKSELR		0x630
+#define RCC_SAI1CKSELR			0x634
+#define RCC_SAI2CKSELR			0x638
+#define RCC_FDCANCKSELR			0x63c
+#define RCC_SPDIFCKSELR			0x640
+#define RCC_ADC12CKSELR			0x644
+#define RCC_SDMMC12CKSELR		0x648
+#define RCC_ETH12CKSELR			0x64c
+#define RCC_USBCKSELR			0x650
+#define RCC_QSPICKSELR			0x654
+#define RCC_FMCCKSELR			0x658
+#define RCC_RNG1CKSELR			0x65c
+#define RCC_STGENCKSELR			0x660
+#define RCC_DCMIPPCKSELR		0x664
+#define RCC_SAESCKSELR			0x668
+#define RCC_APB1RSTSETR			0x6a0
+#define RCC_APB1RSTCLRR			0x6a4
+#define RCC_APB2RSTSETR			0x6a8
+#define RCC_APB2RSTCLRR			0x6ac
+#define RCC_APB3RSTSETR			0x6b0
+#define RCC_APB3RSTCLRR			0x6b4
+#define RCC_APB4RSTSETR			0x6b8
+#define RCC_APB4RSTCLRR			0x6bc
+#define RCC_APB5RSTSETR			0x6c0
+#define RCC_APB5RSTCLRR			0x6c4
+#define RCC_APB6RSTSETR			0x6c8
+#define RCC_APB6RSTCLRR			0x6cc
+#define RCC_AHB2RSTSETR			0x6d0
+#define RCC_AHB2RSTCLRR			0x6d4
+#define RCC_AHB4RSTSETR			0x6e0
+#define RCC_AHB4RSTCLRR			0x6e4
+#define RCC_AHB5RSTSETR			0x6e8
+#define RCC_AHB5RSTCLRR			0x6ec
+#define RCC_AHB6RSTSETR			0x6f0
+#define RCC_AHB6RSTCLRR			0x6f4
+#define RCC_MP_APB1ENSETR		0x700
+#define RCC_MP_APB1ENCLRR		0x704
+#define RCC_MP_APB2ENSETR		0x708
+#define RCC_MP_APB2ENCLRR		0x70c
+#define RCC_MP_APB3ENSETR		0x710
+#define RCC_MP_APB3ENCLRR		0x714
+#define RCC_MP_S_APB3ENSETR		0x718
+#define RCC_MP_S_APB3ENCLRR		0x71c
+#define RCC_MP_NS_APB3ENSETR		0x720
+#define RCC_MP_NS_APB3ENCLRR		0x724
+#define RCC_MP_APB4ENSETR		0x728
+#define RCC_MP_APB4ENCLRR		0x72c
+#define RCC_MP_S_APB4ENSETR		0x730
+#define RCC_MP_S_APB4ENCLRR		0x734
+#define RCC_MP_NS_APB4ENSETR		0x738
+#define RCC_MP_NS_APB4ENCLRR		0x73c
+#define RCC_MP_APB5ENSETR		0x740
+#define RCC_MP_APB5ENCLRR		0x744
+#define RCC_MP_APB6ENSETR		0x748
+#define RCC_MP_APB6ENCLRR		0x74c
+#define RCC_MP_AHB2ENSETR		0x750
+#define RCC_MP_AHB2ENCLRR		0x754
+#define RCC_MP_AHB4ENSETR		0x760
+#define RCC_MP_AHB4ENCLRR		0x764
+#define RCC_MP_S_AHB4ENSETR		0x768
+#define RCC_MP_S_AHB4ENCLRR		0x76c
+#define RCC_MP_NS_AHB4ENSETR		0x770
+#define RCC_MP_NS_AHB4ENCLRR		0x774
+#define RCC_MP_AHB5ENSETR		0x778
+#define RCC_MP_AHB5ENCLRR		0x77c
+#define RCC_MP_AHB6ENSETR		0x780
+#define RCC_MP_AHB6ENCLRR		0x784
+#define RCC_MP_S_AHB6ENSETR		0x788
+#define RCC_MP_S_AHB6ENCLRR		0x78c
+#define RCC_MP_NS_AHB6ENSETR		0x790
+#define RCC_MP_NS_AHB6ENCLRR		0x794
+#define RCC_MP_APB1LPENSETR		0x800
+#define RCC_MP_APB1LPENCLRR		0x804
+#define RCC_MP_APB2LPENSETR		0x808
+#define RCC_MP_APB2LPENCLRR		0x80c
+#define RCC_MP_APB3LPENSETR		0x810
+#define RCC_MP_APB3LPENCLRR		0x814
+#define RCC_MP_S_APB3LPENSETR		0x818
+#define RCC_MP_S_APB3LPENCLRR		0x81c
+#define RCC_MP_NS_APB3LPENSETR		0x820
+#define RCC_MP_NS_APB3LPENCLRR		0x824
+#define RCC_MP_APB4LPENSETR		0x828
+#define RCC_MP_APB4LPENCLRR		0x82c
+#define RCC_MP_S_APB4LPENSETR		0x830
+#define RCC_MP_S_APB4LPENCLRR		0x834
+#define RCC_MP_NS_APB4LPENSETR		0x838
+#define RCC_MP_NS_APB4LPENCLRR		0x83c
+#define RCC_MP_APB5LPENSETR		0x840
+#define RCC_MP_APB5LPENCLRR		0x844
+#define RCC_MP_APB6LPENSETR		0x848
+#define RCC_MP_APB6LPENCLRR		0x84c
+#define RCC_MP_AHB2LPENSETR		0x850
+#define RCC_MP_AHB2LPENCLRR		0x854
+#define RCC_MP_AHB4LPENSETR		0x858
+#define RCC_MP_AHB4LPENCLRR		0x85c
+#define RCC_MP_S_AHB4LPENSETR		0x868
+#define RCC_MP_S_AHB4LPENCLRR		0x86c
+#define RCC_MP_NS_AHB4LPENSETR		0x870
+#define RCC_MP_NS_AHB4LPENCLRR		0x874
+#define RCC_MP_AHB5LPENSETR		0x878
+#define RCC_MP_AHB5LPENCLRR		0x87c
+#define RCC_MP_AHB6LPENSETR		0x880
+#define RCC_MP_AHB6LPENCLRR		0x884
+#define RCC_MP_S_AHB6LPENSETR		0x888
+#define RCC_MP_S_AHB6LPENCLRR		0x88c
+#define RCC_MP_NS_AHB6LPENSETR		0x890
+#define RCC_MP_NS_AHB6LPENCLRR		0x894
+#define RCC_MP_S_AXIMLPENSETR		0x898
+#define RCC_MP_S_AXIMLPENCLRR		0x89c
+#define RCC_MP_NS_AXIMLPENSETR		0x8a0
+#define RCC_MP_NS_AXIMLPENCLRR		0x8a4
+#define RCC_MP_MLAHBLPENSETR		0x8a8
+#define RCC_MP_MLAHBLPENCLRR		0x8ac
+#define RCC_APB3SECSR			0x8c0
+#define RCC_APB4SECSR			0x8c4
+#define RCC_APB5SECSR			0x8c8
+#define RCC_APB6SECSR			0x8cc
+#define RCC_AHB2SECSR			0x8d0
+#define RCC_AHB4SECSR			0x8d4
+#define RCC_AHB5SECSR			0x8d8
+#define RCC_AHB6SECSR			0x8dc
+#define RCC_VERR			0xff4
+#define RCC_IDR				0xff8
+#define RCC_SIDR			0xffc
+
+/* RCC_SECCFGR register fields */
+#define RCC_SECCFGR_HSISEC		BIT(0)
+#define RCC_SECCFGR_CSISEC		BIT(1)
+#define RCC_SECCFGR_HSESEC		BIT(2)
+#define RCC_SECCFGR_LSISEC		BIT(3)
+#define RCC_SECCFGR_LSESEC		BIT(4)
+#define RCC_SECCFGR_PLL12SEC		BIT(8)
+#define RCC_SECCFGR_PLL3SEC		BIT(9)
+#define RCC_SECCFGR_PLL4SEC		BIT(10)
+#define RCC_SECCFGR_MPUSEC		BIT(11)
+#define RCC_SECCFGR_AXISEC		BIT(12)
+#define RCC_SECCFGR_MLAHBSEC		BIT(13)
+#define RCC_SECCFGR_APB3DIVSEC		BIT(16)
+#define RCC_SECCFGR_APB4DIVSEC		BIT(17)
+#define RCC_SECCFGR_APB5DIVSEC		BIT(18)
+#define RCC_SECCFGR_APB6DIVSEC		BIT(19)
+#define RCC_SECCFGR_TIMG3SEC		BIT(20)
+#define RCC_SECCFGR_CPERSEC		BIT(21)
+#define RCC_SECCFGR_MCO1SEC		BIT(22)
+#define RCC_SECCFGR_MCO2SEC		BIT(23)
+#define RCC_SECCFGR_STPSEC		BIT(24)
+#define RCC_SECCFGR_RSTSEC		BIT(25)
+#define RCC_SECCFGR_PWRSEC		BIT(31)
+
+#define RCC_SECCFGR_MCO1SECF		22
+#define RCC_SECCFGR_MCO2SECF		23
+
+/* RCC_MP_SREQSETR register fields */
+#define RCC_MP_SREQSETR_STPREQ_P0	BIT(0)
+
+/* RCC_MP_SREQCLRR register fields */
+#define RCC_MP_SREQCLRR_STPREQ_P0	BIT(0)
+
+/* RCC_MP_APRSTCR register fields */
+#define RCC_MP_APRSTCR_RDCTLEN		BIT(0)
+#define RCC_MP_APRSTCR_RSTTO_MASK	GENMASK(14, 8)
+#define RCC_MP_APRSTCR_RSTTO_SHIFT	8
+
+/* RCC_MP_APRSTSR register fields */
+#define RCC_MP_APRSTSR_RSTTOV_MASK	GENMASK(14, 8)
+#define RCC_MP_APRSTSR_RSTTOV_SHIFT	8
+
+/* RCC_PWRLPDLYCR register fields */
+#define RCC_PWRLPDLYCR_PWRLP_DLY_MASK	GENMASK(21, 0)
+#define RCC_PWRLPDLYCR_PWRLP_DLY_SHIFT	0
+
+/* RCC_MP_GRSTCSETR register fields */
+#define RCC_MP_GRSTCSETR_MPSYSRST	BIT(0)
+#define RCC_MP_GRSTCSETR_MPUP0RST	BIT(4)
+
+/* RCC_BR_RSTSCLRR register fields */
+#define RCC_BR_RSTSCLRR_PORRSTF		BIT(0)
+#define RCC_BR_RSTSCLRR_BORRSTF		BIT(1)
+#define RCC_BR_RSTSCLRR_PADRSTF		BIT(2)
+#define RCC_BR_RSTSCLRR_HCSSRSTF	BIT(3)
+#define RCC_BR_RSTSCLRR_VCORERSTF	BIT(4)
+#define RCC_BR_RSTSCLRR_VCPURSTF	BIT(5)
+#define RCC_BR_RSTSCLRR_MPSYSRSTF	BIT(6)
+#define RCC_BR_RSTSCLRR_IWDG1RSTF	BIT(8)
+#define RCC_BR_RSTSCLRR_IWDG2RSTF	BIT(9)
+#define RCC_BR_RSTSCLRR_MPUP0RSTF	BIT(13)
+
+/* RCC_MP_RSTSSETR register fields */
+#define RCC_MP_RSTSSETR_PORRSTF		BIT(0)
+#define RCC_MP_RSTSSETR_BORRSTF		BIT(1)
+#define RCC_MP_RSTSSETR_PADRSTF		BIT(2)
+#define RCC_MP_RSTSSETR_HCSSRSTF	BIT(3)
+#define RCC_MP_RSTSSETR_VCORERSTF	BIT(4)
+#define RCC_MP_RSTSSETR_VCPURSTF	BIT(5)
+#define RCC_MP_RSTSSETR_MPSYSRSTF	BIT(6)
+#define RCC_MP_RSTSSETR_IWDG1RSTF	BIT(8)
+#define RCC_MP_RSTSSETR_IWDG2RSTF	BIT(9)
+#define RCC_MP_RSTSSETR_STP2RSTF	BIT(10)
+#define RCC_MP_RSTSSETR_STDBYRSTF	BIT(11)
+#define RCC_MP_RSTSSETR_CSTDBYRSTF	BIT(12)
+#define RCC_MP_RSTSSETR_MPUP0RSTF	BIT(13)
+#define RCC_MP_RSTSSETR_SPARE		BIT(15)
+
+/* RCC_MP_RSTSCLRR register fields */
+#define RCC_MP_RSTSCLRR_PORRSTF		BIT(0)
+#define RCC_MP_RSTSCLRR_BORRSTF		BIT(1)
+#define RCC_MP_RSTSCLRR_PADRSTF		BIT(2)
+#define RCC_MP_RSTSCLRR_HCSSRSTF	BIT(3)
+#define RCC_MP_RSTSCLRR_VCORERSTF	BIT(4)
+#define RCC_MP_RSTSCLRR_VCPURSTF	BIT(5)
+#define RCC_MP_RSTSCLRR_MPSYSRSTF	BIT(6)
+#define RCC_MP_RSTSCLRR_IWDG1RSTF	BIT(8)
+#define RCC_MP_RSTSCLRR_IWDG2RSTF	BIT(9)
+#define RCC_MP_RSTSCLRR_STP2RSTF	BIT(10)
+#define RCC_MP_RSTSCLRR_STDBYRSTF	BIT(11)
+#define RCC_MP_RSTSCLRR_CSTDBYRSTF	BIT(12)
+#define RCC_MP_RSTSCLRR_MPUP0RSTF	BIT(13)
+#define RCC_MP_RSTSCLRR_SPARE		BIT(15)
+
+/* RCC_MP_IWDGFZSETR register fields */
+#define RCC_MP_IWDGFZSETR_FZ_IWDG1	BIT(0)
+#define RCC_MP_IWDGFZSETR_FZ_IWDG2	BIT(1)
+
+/* RCC_MP_IWDGFZCLRR register fields */
+#define RCC_MP_IWDGFZCLRR_FZ_IWDG1	BIT(0)
+#define RCC_MP_IWDGFZCLRR_FZ_IWDG2	BIT(1)
+
+/* RCC_MP_CIER register fields */
+#define RCC_MP_CIER_LSIRDYIE		BIT(0)
+#define RCC_MP_CIER_LSERDYIE		BIT(1)
+#define RCC_MP_CIER_HSIRDYIE		BIT(2)
+#define RCC_MP_CIER_HSERDYIE		BIT(3)
+#define RCC_MP_CIER_CSIRDYIE		BIT(4)
+#define RCC_MP_CIER_PLL1DYIE		BIT(8)
+#define RCC_MP_CIER_PLL2DYIE		BIT(9)
+#define RCC_MP_CIER_PLL3DYIE		BIT(10)
+#define RCC_MP_CIER_PLL4DYIE		BIT(11)
+#define RCC_MP_CIER_LSECSSIE		BIT(16)
+#define RCC_MP_CIER_WKUPIE		BIT(20)
+
+/* RCC_MP_CIFR register fields */
+#define RCC_MP_CIFR_LSIRDYF		BIT(0)
+#define RCC_MP_CIFR_LSERDYF		BIT(1)
+#define RCC_MP_CIFR_HSIRDYF		BIT(2)
+#define RCC_MP_CIFR_HSERDYF		BIT(3)
+#define RCC_MP_CIFR_CSIRDYF		BIT(4)
+#define RCC_MP_CIFR_PLL1DYF		BIT(8)
+#define RCC_MP_CIFR_PLL2DYF		BIT(9)
+#define RCC_MP_CIFR_PLL3DYF		BIT(10)
+#define RCC_MP_CIFR_PLL4DYF		BIT(11)
+#define RCC_MP_CIFR_LSECSSF		BIT(16)
+#define RCC_MP_CIFR_WKUPF		BIT(20)
+
+/* RCC_BDCR register fields */
+#define RCC_BDCR_LSEON			BIT(0)
+#define RCC_BDCR_LSEBYP			BIT(1)
+#define RCC_BDCR_LSERDY			BIT(2)
+#define RCC_BDCR_DIGBYP			BIT(3)
+#define RCC_BDCR_LSEDRV_MASK		GENMASK(5, 4)
+#define RCC_BDCR_LSECSSON		BIT(8)
+#define RCC_BDCR_LSECSSD		BIT(9)
+#define RCC_BDCR_RTCSRC_MASK		GENMASK(17, 16)
+#define RCC_BDCR_RTCCKEN		BIT(20)
+#define RCC_BDCR_VSWRST			BIT(31)
+#define RCC_BDCR_LSEDRV_SHIFT		4
+#define RCC_BDCR_RTCSRC_SHIFT		16
+
+/* RCC_RDLSICR register fields */
+#define RCC_RDLSICR_LSION		BIT(0)
+#define RCC_RDLSICR_LSIRDY		BIT(1)
+#define RCC_RDLSICR_MRD_MASK		GENMASK(20, 16)
+#define RCC_RDLSICR_EADLY_MASK		GENMASK(26, 24)
+#define RCC_RDLSICR_SPARE_MASK		GENMASK(31, 27)
+#define RCC_RDLSICR_MRD_SHIFT		16
+#define RCC_RDLSICR_EADLY_SHIFT		24
+#define RCC_RDLSICR_SPARE_SHIFT		27
+
+/* RCC_OCENSETR register fields */
+#define RCC_OCENSETR_HSION		BIT(0)
+#define RCC_OCENSETR_HSIKERON		BIT(1)
+#define RCC_OCENSETR_CSION		BIT(4)
+#define RCC_OCENSETR_CSIKERON		BIT(5)
+#define RCC_OCENSETR_DIGBYP		BIT(7)
+#define RCC_OCENSETR_HSEON		BIT(8)
+#define RCC_OCENSETR_HSEKERON		BIT(9)
+#define RCC_OCENSETR_HSEBYP		BIT(10)
+#define RCC_OCENSETR_HSECSSON		BIT(11)
+
+/* RCC_OCENCLRR register fields */
+#define RCC_OCENCLRR_HSION		BIT(0)
+#define RCC_OCENCLRR_HSIKERON		BIT(1)
+#define RCC_OCENCLRR_CSION		BIT(4)
+#define RCC_OCENCLRR_CSIKERON		BIT(5)
+#define RCC_OCENCLRR_DIGBYP		BIT(7)
+#define RCC_OCENCLRR_HSEON		BIT(8)
+#define RCC_OCENCLRR_HSEKERON		BIT(9)
+#define RCC_OCENCLRR_HSEBYP		BIT(10)
+
+/* RCC_OCRDYR register fields */
+#define RCC_OCRDYR_HSIRDY		BIT(0)
+#define RCC_OCRDYR_HSIDIVRDY		BIT(2)
+#define RCC_OCRDYR_CSIRDY		BIT(4)
+#define RCC_OCRDYR_HSERDY		BIT(8)
+#define RCC_OCRDYR_MPUCKRDY		BIT(23)
+#define RCC_OCRDYR_AXICKRDY		BIT(24)
+
+/* RCC_HSICFGR register fields */
+#define RCC_HSICFGR_HSIDIV_MASK		GENMASK(1, 0)
+#define RCC_HSICFGR_HSITRIM_MASK	GENMASK(14, 8)
+#define RCC_HSICFGR_HSICAL_MASK		GENMASK(27, 16)
+#define RCC_HSICFGR_HSIDIV_SHIFT	0
+#define RCC_HSICFGR_HSITRIM_SHIFT	8
+#define RCC_HSICFGR_HSICAL_SHIFT	16
+
+/* RCC_CSICFGR register fields */
+#define RCC_CSICFGR_CSITRIM_MASK	GENMASK(12, 8)
+#define RCC_CSICFGR_CSICAL_MASK		GENMASK(23, 16)
+#define RCC_CSICFGR_CSITRIM_SHIFT	8
+#define RCC_CSICFGR_CSICAL_SHIFT	16
+
+/* RCC_MCO1CFGR register fields */
+#define RCC_MCO1CFGR_MCO1SEL_MASK	GENMASK(2, 0)
+#define RCC_MCO1CFGR_MCO1DIV_MASK	GENMASK(7, 4)
+#define RCC_MCO1CFGR_MCO1ON		BIT(12)
+#define RCC_MCO1CFGR_MCO1SEL_SHIFT	0
+#define RCC_MCO1CFGR_MCO1DIV_SHIFT	4
+
+/* RCC_MCO2CFGR register fields */
+#define RCC_MCO2CFGR_MCO2SEL_MASK	GENMASK(2, 0)
+#define RCC_MCO2CFGR_MCO2DIV_MASK	GENMASK(7, 4)
+#define RCC_MCO2CFGR_MCO2ON		BIT(12)
+#define RCC_MCO2CFGR_MCO2SEL_SHIFT	0
+#define RCC_MCO2CFGR_MCO2DIV_SHIFT	4
+
+/* RCC_DBGCFGR register fields */
+#define RCC_DBGCFGR_TRACEDIV_MASK	GENMASK(2, 0)
+#define RCC_DBGCFGR_DBGCKEN		BIT(8)
+#define RCC_DBGCFGR_TRACECKEN		BIT(9)
+#define RCC_DBGCFGR_DBGRST		BIT(12)
+#define RCC_DBGCFGR_TRACEDIV_SHIFT	0
+
+/* RCC_RCK12SELR register fields */
+#define RCC_RCK12SELR_PLL12SRC_MASK	GENMASK(1, 0)
+#define RCC_RCK12SELR_PLL12SRCRDY	BIT(31)
+#define RCC_RCK12SELR_PLL12SRC_SHIFT	0
+
+/* RCC_RCK3SELR register fields */
+#define RCC_RCK3SELR_PLL3SRC_MASK	GENMASK(1, 0)
+#define RCC_RCK3SELR_PLL3SRCRDY		BIT(31)
+#define RCC_RCK3SELR_PLL3SRC_SHIFT	0
+
+/* RCC_RCK4SELR register fields */
+#define RCC_RCK4SELR_PLL4SRC_MASK	GENMASK(1, 0)
+#define RCC_RCK4SELR_PLL4SRCRDY		BIT(31)
+#define RCC_RCK4SELR_PLL4SRC_SHIFT	0
+
+/* RCC_PLL1CR register fields */
+#define RCC_PLL1CR_PLLON		BIT(0)
+#define RCC_PLL1CR_PLL1RDY		BIT(1)
+#define RCC_PLL1CR_SSCG_CTRL		BIT(2)
+#define RCC_PLL1CR_DIVPEN		BIT(4)
+#define RCC_PLL1CR_DIVQEN		BIT(5)
+#define RCC_PLL1CR_DIVREN		BIT(6)
+
+/* RCC_PLL1CFGR1 register fields */
+#define RCC_PLL1CFGR1_DIVN_MASK		GENMASK(8, 0)
+#define RCC_PLL1CFGR1_DIVM1_MASK	GENMASK(21, 16)
+#define RCC_PLL1CFGR1_DIVN_SHIFT	0
+#define RCC_PLL1CFGR1_DIVM1_SHIFT	16
+
+/* RCC_PLL1CFGR2 register fields */
+#define RCC_PLL1CFGR2_DIVP_MASK		GENMASK(6, 0)
+#define RCC_PLL1CFGR2_DIVQ_MASK		GENMASK(14, 8)
+#define RCC_PLL1CFGR2_DIVR_MASK		GENMASK(22, 16)
+#define RCC_PLL1CFGR2_DIVP_SHIFT	0
+#define RCC_PLL1CFGR2_DIVQ_SHIFT	8
+#define RCC_PLL1CFGR2_DIVR_SHIFT	16
+
+/* RCC_PLL1FRACR register fields */
+#define RCC_PLL1FRACR_FRACV_MASK	GENMASK(15, 3)
+#define RCC_PLL1FRACR_FRACLE		BIT(16)
+#define RCC_PLL1FRACR_FRACV_SHIFT	3
+
+/* RCC_PLL1CSGR register fields */
+#define RCC_PLL1CSGR_MOD_PER_MASK	GENMASK(12, 0)
+#define RCC_PLL1CSGR_TPDFN_DIS		BIT(13)
+#define RCC_PLL1CSGR_RPDFN_DIS		BIT(14)
+#define RCC_PLL1CSGR_SSCG_MODE		BIT(15)
+#define RCC_PLL1CSGR_INC_STEP_MASK	GENMASK(30, 16)
+#define RCC_PLL1CSGR_MOD_PER_SHIFT	0
+#define RCC_PLL1CSGR_INC_STEP_SHIFT	16
+
+/* RCC_PLL2CR register fields */
+#define RCC_PLL2CR_PLLON		BIT(0)
+#define RCC_PLL2CR_PLL2RDY		BIT(1)
+#define RCC_PLL2CR_SSCG_CTRL		BIT(2)
+#define RCC_PLL2CR_DIVPEN		BIT(4)
+#define RCC_PLL2CR_DIVQEN		BIT(5)
+#define RCC_PLL2CR_DIVREN		BIT(6)
+
+/* RCC_PLL2CFGR1 register fields */
+#define RCC_PLL2CFGR1_DIVN_MASK		GENMASK(8, 0)
+#define RCC_PLL2CFGR1_DIVM2_MASK	GENMASK(21, 16)
+#define RCC_PLL2CFGR1_DIVN_SHIFT	0
+#define RCC_PLL2CFGR1_DIVM2_SHIFT	16
+
+/* RCC_PLL2CFGR2 register fields */
+#define RCC_PLL2CFGR2_DIVP_MASK		GENMASK(6, 0)
+#define RCC_PLL2CFGR2_DIVQ_MASK		GENMASK(14, 8)
+#define RCC_PLL2CFGR2_DIVR_MASK		GENMASK(22, 16)
+#define RCC_PLL2CFGR2_DIVP_SHIFT	0
+#define RCC_PLL2CFGR2_DIVQ_SHIFT	8
+#define RCC_PLL2CFGR2_DIVR_SHIFT	16
+
+/* RCC_PLL2FRACR register fields */
+#define RCC_PLL2FRACR_FRACV_MASK	GENMASK(15, 3)
+#define RCC_PLL2FRACR_FRACLE		BIT(16)
+#define RCC_PLL2FRACR_FRACV_SHIFT	3
+
+/* RCC_PLL2CSGR register fields */
+#define RCC_PLL2CSGR_MOD_PER_MASK	GENMASK(12, 0)
+#define RCC_PLL2CSGR_TPDFN_DIS		BIT(13)
+#define RCC_PLL2CSGR_RPDFN_DIS		BIT(14)
+#define RCC_PLL2CSGR_SSCG_MODE		BIT(15)
+#define RCC_PLL2CSGR_INC_STEP_MASK	GENMASK(30, 16)
+#define RCC_PLL2CSGR_MOD_PER_SHIFT	0
+#define RCC_PLL2CSGR_INC_STEP_SHIFT	16
+
+/* RCC_PLL3CR register fields */
+#define RCC_PLL3CR_PLLON		BIT(0)
+#define RCC_PLL3CR_PLL3RDY		BIT(1)
+#define RCC_PLL3CR_SSCG_CTRL		BIT(2)
+#define RCC_PLL3CR_DIVPEN		BIT(4)
+#define RCC_PLL3CR_DIVQEN		BIT(5)
+#define RCC_PLL3CR_DIVREN		BIT(6)
+
+/* RCC_PLL3CFGR1 register fields */
+#define RCC_PLL3CFGR1_DIVN_MASK		GENMASK(8, 0)
+#define RCC_PLL3CFGR1_DIVM3_MASK	GENMASK(21, 16)
+#define RCC_PLL3CFGR1_IFRGE_MASK	GENMASK(25, 24)
+#define RCC_PLL3CFGR1_DIVN_SHIFT	0
+#define RCC_PLL3CFGR1_DIVM3_SHIFT	16
+#define RCC_PLL3CFGR1_IFRGE_SHIFT	24
+
+/* RCC_PLL3CFGR2 register fields */
+#define RCC_PLL3CFGR2_DIVP_MASK		GENMASK(6, 0)
+#define RCC_PLL3CFGR2_DIVQ_MASK		GENMASK(14, 8)
+#define RCC_PLL3CFGR2_DIVR_MASK		GENMASK(22, 16)
+#define RCC_PLL3CFGR2_DIVP_SHIFT	0
+#define RCC_PLL3CFGR2_DIVQ_SHIFT	8
+#define RCC_PLL3CFGR2_DIVR_SHIFT	16
+
+/* RCC_PLL3FRACR register fields */
+#define RCC_PLL3FRACR_FRACV_MASK	GENMASK(15, 3)
+#define RCC_PLL3FRACR_FRACLE		BIT(16)
+#define RCC_PLL3FRACR_FRACV_SHIFT	3
+
+/* RCC_PLL3CSGR register fields */
+#define RCC_PLL3CSGR_MOD_PER_MASK	GENMASK(12, 0)
+#define RCC_PLL3CSGR_TPDFN_DIS		BIT(13)
+#define RCC_PLL3CSGR_RPDFN_DIS		BIT(14)
+#define RCC_PLL3CSGR_SSCG_MODE		BIT(15)
+#define RCC_PLL3CSGR_INC_STEP_MASK	GENMASK(30, 16)
+#define RCC_PLL3CSGR_MOD_PER_SHIFT	0
+#define RCC_PLL3CSGR_INC_STEP_SHIFT	16
+
+/* RCC_PLL4CR register fields */
+#define RCC_PLL4CR_PLLON		BIT(0)
+#define RCC_PLL4CR_PLL4RDY		BIT(1)
+#define RCC_PLL4CR_SSCG_CTRL		BIT(2)
+#define RCC_PLL4CR_DIVPEN		BIT(4)
+#define RCC_PLL4CR_DIVQEN		BIT(5)
+#define RCC_PLL4CR_DIVREN		BIT(6)
+
+/* RCC_PLL4CFGR1 register fields */
+#define RCC_PLL4CFGR1_DIVN_MASK		GENMASK(8, 0)
+#define RCC_PLL4CFGR1_DIVM4_MASK	GENMASK(21, 16)
+#define RCC_PLL4CFGR1_IFRGE_MASK	GENMASK(25, 24)
+#define RCC_PLL4CFGR1_DIVN_SHIFT	0
+#define RCC_PLL4CFGR1_DIVM4_SHIFT	16
+#define RCC_PLL4CFGR1_IFRGE_SHIFT	24
+
+/* RCC_PLL4CFGR2 register fields */
+#define RCC_PLL4CFGR2_DIVP_MASK		GENMASK(6, 0)
+#define RCC_PLL4CFGR2_DIVQ_MASK		GENMASK(14, 8)
+#define RCC_PLL4CFGR2_DIVR_MASK		GENMASK(22, 16)
+#define RCC_PLL4CFGR2_DIVP_SHIFT	0
+#define RCC_PLL4CFGR2_DIVQ_SHIFT	8
+#define RCC_PLL4CFGR2_DIVR_SHIFT	16
+
+/* RCC_PLL4FRACR register fields */
+#define RCC_PLL4FRACR_FRACV_MASK	GENMASK(15, 3)
+#define RCC_PLL4FRACR_FRACLE		BIT(16)
+#define RCC_PLL4FRACR_FRACV_SHIFT	3
+
+/* RCC_PLL4CSGR register fields */
+#define RCC_PLL4CSGR_MOD_PER_MASK	GENMASK(12, 0)
+#define RCC_PLL4CSGR_TPDFN_DIS		BIT(13)
+#define RCC_PLL4CSGR_RPDFN_DIS		BIT(14)
+#define RCC_PLL4CSGR_SSCG_MODE		BIT(15)
+#define RCC_PLL4CSGR_INC_STEP_MASK	GENMASK(30, 16)
+#define RCC_PLL4CSGR_MOD_PER_SHIFT	0
+#define RCC_PLL4CSGR_INC_STEP_SHIFT	16
+
+/* RCC_MPCKSELR register fields */
+#define RCC_MPCKSELR_MPUSRC_MASK	GENMASK(1, 0)
+#define RCC_MPCKSELR_MPUSRCRDY		BIT(31)
+#define RCC_MPCKSELR_MPUSRC_SHIFT	0
+
+/* RCC_ASSCKSELR register fields */
+#define RCC_ASSCKSELR_AXISSRC_MASK	GENMASK(2, 0)
+#define RCC_ASSCKSELR_AXISSRCRDY	BIT(31)
+#define RCC_ASSCKSELR_AXISSRC_SHIFT	0
+
+/* RCC_MSSCKSELR register fields */
+#define RCC_MSSCKSELR_MLAHBSSRC_MASK	GENMASK(1, 0)
+#define RCC_MSSCKSELR_MLAHBSSRCRDY	BIT(31)
+#define RCC_MSSCKSELR_MLAHBSSRC_SHIFT	0
+
+/* RCC_CPERCKSELR register fields */
+#define RCC_CPERCKSELR_CKPERSRC_MASK	GENMASK(1, 0)
+#define RCC_CPERCKSELR_CKPERSRC_SHIFT	0
+
+/* RCC_RTCDIVR register fields */
+#define RCC_RTCDIVR_RTCDIV_MASK		GENMASK(5, 0)
+#define RCC_RTCDIVR_RTCDIV_SHIFT	0
+
+/* RCC_MPCKDIVR register fields */
+#define RCC_MPCKDIVR_MPUDIV_MASK	GENMASK(3, 0)
+#define RCC_MPCKDIVR_MPUDIVRDY		BIT(31)
+#define RCC_MPCKDIVR_MPUDIV_SHIFT	0
+
+/* RCC_AXIDIVR register fields */
+#define RCC_AXIDIVR_AXIDIV_MASK		GENMASK(2, 0)
+#define RCC_AXIDIVR_AXIDIVRDY		BIT(31)
+#define RCC_AXIDIVR_AXIDIV_SHIFT	0
+
+/* RCC_MLAHBDIVR register fields */
+#define RCC_MLAHBDIVR_MLAHBDIV_MASK	GENMASK(3, 0)
+#define RCC_MLAHBDIVR_MLAHBDIVRDY	BIT(31)
+#define RCC_MLAHBDIVR_MLAHBDIV_SHIFT	0
+
+/* RCC_APB1DIVR register fields */
+#define RCC_APB1DIVR_APB1DIV_MASK	GENMASK(2, 0)
+#define RCC_APB1DIVR_APB1DIVRDY		BIT(31)
+#define RCC_APB1DIVR_APB1DIV_SHIFT	0
+
+/* RCC_APB2DIVR register fields */
+#define RCC_APB2DIVR_APB2DIV_MASK	GENMASK(2, 0)
+#define RCC_APB2DIVR_APB2DIVRDY		BIT(31)
+#define RCC_APB2DIVR_APB2DIV_SHIFT	0
+
+/* RCC_APB3DIVR register fields */
+#define RCC_APB3DIVR_APB3DIV_MASK	GENMASK(2, 0)
+#define RCC_APB3DIVR_APB3DIVRDY		BIT(31)
+#define RCC_APB3DIVR_APB3DIV_SHIFT	0
+
+/* RCC_APB4DIVR register fields */
+#define RCC_APB4DIVR_APB4DIV_MASK	GENMASK(2, 0)
+#define RCC_APB4DIVR_APB4DIVRDY		BIT(31)
+#define RCC_APB4DIVR_APB4DIV_SHIFT	0
+
+/* RCC_APB5DIVR register fields */
+#define RCC_APB5DIVR_APB5DIV_MASK	GENMASK(2, 0)
+#define RCC_APB5DIVR_APB5DIVRDY		BIT(31)
+#define RCC_APB5DIVR_APB5DIV_SHIFT	0
+
+/* RCC_APB6DIVR register fields */
+#define RCC_APB6DIVR_APB6DIV_MASK	GENMASK(2, 0)
+#define RCC_APB6DIVR_APB6DIVRDY		BIT(31)
+#define RCC_APB6DIVR_APB6DIV_SHIFT	0
+
+/* RCC_TIMG1PRER register fields */
+#define RCC_TIMG1PRER_TIMG1PRE		BIT(0)
+#define RCC_TIMG1PRER_TIMG1PRERDY	BIT(31)
+
+/* RCC_TIMG2PRER register fields */
+#define RCC_TIMG2PRER_TIMG2PRE		BIT(0)
+#define RCC_TIMG2PRER_TIMG2PRERDY	BIT(31)
+
+/* RCC_TIMG3PRER register fields */
+#define RCC_TIMG3PRER_TIMG3PRE		BIT(0)
+#define RCC_TIMG3PRER_TIMG3PRERDY	BIT(31)
+
+/* RCC_DDRITFCR register fields */
+#define RCC_DDRITFCR_DDRC1EN		BIT(0)
+#define RCC_DDRITFCR_DDRC1LPEN		BIT(1)
+#define RCC_DDRITFCR_DDRPHYCEN		BIT(4)
+#define RCC_DDRITFCR_DDRPHYCLPEN	BIT(5)
+#define RCC_DDRITFCR_DDRCAPBEN		BIT(6)
+#define RCC_DDRITFCR_DDRCAPBLPEN	BIT(7)
+#define RCC_DDRITFCR_AXIDCGEN		BIT(8)
+#define RCC_DDRITFCR_DDRPHYCAPBEN	BIT(9)
+#define RCC_DDRITFCR_DDRPHYCAPBLPEN	BIT(10)
+#define RCC_DDRITFCR_KERDCG_DLY_MASK	GENMASK(13, 11)
+#define RCC_DDRITFCR_DDRCAPBRST		BIT(14)
+#define RCC_DDRITFCR_DDRCAXIRST		BIT(15)
+#define RCC_DDRITFCR_DDRCORERST		BIT(16)
+#define RCC_DDRITFCR_DPHYAPBRST		BIT(17)
+#define RCC_DDRITFCR_DPHYRST		BIT(18)
+#define RCC_DDRITFCR_DPHYCTLRST		BIT(19)
+#define RCC_DDRITFCR_DDRCKMOD_MASK	GENMASK(22, 20)
+#define RCC_DDRITFCR_GSKPMOD		BIT(23)
+#define RCC_DDRITFCR_GSKPCTRL		BIT(24)
+#define RCC_DDRITFCR_DFILP_WIDTH_MASK	GENMASK(27, 25)
+#define RCC_DDRITFCR_GSKP_DUR_MASK	GENMASK(31, 28)
+#define RCC_DDRITFCR_KERDCG_DLY_SHIFT	11
+#define RCC_DDRITFCR_DDRCKMOD_SHIFT	20
+#define RCC_DDRITFCR_DFILP_WIDTH_SHIFT	25
+#define RCC_DDRITFCR_GSKP_DUR_SHIFT	28
+
+/* RCC_I2C12CKSELR register fields */
+#define RCC_I2C12CKSELR_I2C12SRC_MASK	GENMASK(2, 0)
+#define RCC_I2C12CKSELR_I2C12SRC_SHIFT	0
+
+/* RCC_I2C345CKSELR register fields */
+#define RCC_I2C345CKSELR_I2C3SRC_MASK	GENMASK(2, 0)
+#define RCC_I2C345CKSELR_I2C4SRC_MASK	GENMASK(5, 3)
+#define RCC_I2C345CKSELR_I2C5SRC_MASK	GENMASK(8, 6)
+#define RCC_I2C345CKSELR_I2C3SRC_SHIFT	0
+#define RCC_I2C345CKSELR_I2C4SRC_SHIFT	3
+#define RCC_I2C345CKSELR_I2C5SRC_SHIFT	6
+
+/* RCC_SPI2S1CKSELR register fields */
+#define RCC_SPI2S1CKSELR_SPI1SRC_MASK	GENMASK(2, 0)
+#define RCC_SPI2S1CKSELR_SPI1SRC_SHIFT	0
+
+/* RCC_SPI2S23CKSELR register fields */
+#define RCC_SPI2S23CKSELR_SPI23SRC_MASK	GENMASK(2, 0)
+#define RCC_SPI2S23CKSELR_SPI23SRC_SHIFT	0
+
+/* RCC_SPI45CKSELR register fields */
+#define RCC_SPI45CKSELR_SPI4SRC_MASK	GENMASK(2, 0)
+#define RCC_SPI45CKSELR_SPI5SRC_MASK	GENMASK(5, 3)
+#define RCC_SPI45CKSELR_SPI4SRC_SHIFT	0
+#define RCC_SPI45CKSELR_SPI5SRC_SHIFT	3
+
+/* RCC_UART12CKSELR register fields */
+#define RCC_UART12CKSELR_UART1SRC_MASK	GENMASK(2, 0)
+#define RCC_UART12CKSELR_UART2SRC_MASK	GENMASK(5, 3)
+#define RCC_UART12CKSELR_UART1SRC_SHIFT	0
+#define RCC_UART12CKSELR_UART2SRC_SHIFT	3
+
+/* RCC_UART35CKSELR register fields */
+#define RCC_UART35CKSELR_UART35SRC_MASK	GENMASK(2, 0)
+#define RCC_UART35CKSELR_UART35SRC_SHIFT	0
+
+/* RCC_UART4CKSELR register fields */
+#define RCC_UART4CKSELR_UART4SRC_MASK	GENMASK(2, 0)
+#define RCC_UART4CKSELR_UART4SRC_SHIFT	0
+
+/* RCC_UART6CKSELR register fields */
+#define RCC_UART6CKSELR_UART6SRC_MASK	GENMASK(2, 0)
+#define RCC_UART6CKSELR_UART6SRC_SHIFT	0
+
+/* RCC_UART78CKSELR register fields */
+#define RCC_UART78CKSELR_UART78SRC_MASK	GENMASK(2, 0)
+#define RCC_UART78CKSELR_UART78SRC_SHIFT	0
+
+/* RCC_LPTIM1CKSELR register fields */
+#define RCC_LPTIM1CKSELR_LPTIM1SRC_MASK	GENMASK(2, 0)
+#define RCC_LPTIM1CKSELR_LPTIM1SRC_SHIFT	0
+
+/* RCC_LPTIM23CKSELR register fields */
+#define RCC_LPTIM23CKSELR_LPTIM2SRC_MASK	GENMASK(2, 0)
+#define RCC_LPTIM23CKSELR_LPTIM3SRC_MASK	GENMASK(5, 3)
+#define RCC_LPTIM23CKSELR_LPTIM2SRC_SHIFT	0
+#define RCC_LPTIM23CKSELR_LPTIM3SRC_SHIFT	3
+
+/* RCC_LPTIM45CKSELR register fields */
+#define RCC_LPTIM45CKSELR_LPTIM45SRC_MASK	GENMASK(2, 0)
+#define RCC_LPTIM45CKSELR_LPTIM45SRC_SHIFT	0
+
+/* RCC_SAI1CKSELR register fields */
+#define RCC_SAI1CKSELR_SAI1SRC_MASK	GENMASK(2, 0)
+#define RCC_SAI1CKSELR_SAI1SRC_SHIFT	0
+
+/* RCC_SAI2CKSELR register fields */
+#define RCC_SAI2CKSELR_SAI2SRC_MASK	GENMASK(2, 0)
+#define RCC_SAI2CKSELR_SAI2SRC_SHIFT	0
+
+/* RCC_FDCANCKSELR register fields */
+#define RCC_FDCANCKSELR_FDCANSRC_MASK	GENMASK(1, 0)
+#define RCC_FDCANCKSELR_FDCANSRC_SHIFT	0
+
+/* RCC_SPDIFCKSELR register fields */
+#define RCC_SPDIFCKSELR_SPDIFSRC_MASK	GENMASK(1, 0)
+#define RCC_SPDIFCKSELR_SPDIFSRC_SHIFT	0
+
+/* RCC_ADC12CKSELR register fields */
+#define RCC_ADC12CKSELR_ADC1SRC_MASK	GENMASK(1, 0)
+#define RCC_ADC12CKSELR_ADC2SRC_MASK	GENMASK(3, 2)
+#define RCC_ADC12CKSELR_ADC1SRC_SHIFT	0
+#define RCC_ADC12CKSELR_ADC2SRC_SHIFT	2
+
+/* RCC_SDMMC12CKSELR register fields */
+#define RCC_SDMMC12CKSELR_SDMMC1SRC_MASK	GENMASK(2, 0)
+#define RCC_SDMMC12CKSELR_SDMMC2SRC_MASK	GENMASK(5, 3)
+#define RCC_SDMMC12CKSELR_SDMMC1SRC_SHIFT	0
+#define RCC_SDMMC12CKSELR_SDMMC2SRC_SHIFT	3
+
+/* RCC_ETH12CKSELR register fields */
+#define RCC_ETH12CKSELR_ETH1SRC_MASK	GENMASK(1, 0)
+#define RCC_ETH12CKSELR_ETH1PTPDIV_MASK	GENMASK(7, 4)
+#define RCC_ETH12CKSELR_ETH2SRC_MASK	GENMASK(9, 8)
+#define RCC_ETH12CKSELR_ETH2PTPDIV_MASK	GENMASK(15, 12)
+#define RCC_ETH12CKSELR_ETH1SRC_SHIFT	0
+#define RCC_ETH12CKSELR_ETH1PTPDIV_SHIFT	4
+#define RCC_ETH12CKSELR_ETH2SRC_SHIFT	8
+#define RCC_ETH12CKSELR_ETH2PTPDIV_SHIFT	12
+
+/* RCC_USBCKSELR register fields */
+#define RCC_USBCKSELR_USBPHYSRC_MASK	GENMASK(1, 0)
+#define RCC_USBCKSELR_USBOSRC		BIT(4)
+#define RCC_USBCKSELR_USBPHYSRC_SHIFT	0
+
+/* RCC_QSPICKSELR register fields */
+#define RCC_QSPICKSELR_QSPISRC_MASK	GENMASK(1, 0)
+#define RCC_QSPICKSELR_QSPISRC_SHIFT	0
+
+/* RCC_FMCCKSELR register fields */
+#define RCC_FMCCKSELR_FMCSRC_MASK	GENMASK(1, 0)
+#define RCC_FMCCKSELR_FMCSRC_SHIFT	0
+
+/* RCC_RNG1CKSELR register fields */
+#define RCC_RNG1CKSELR_RNG1SRC_MASK	GENMASK(1, 0)
+#define RCC_RNG1CKSELR_RNG1SRC_SHIFT	0
+
+/* RCC_STGENCKSELR register fields */
+#define RCC_STGENCKSELR_STGENSRC_MASK	GENMASK(1, 0)
+#define RCC_STGENCKSELR_STGENSRC_SHIFT	0
+
+/* RCC_DCMIPPCKSELR register fields */
+#define RCC_DCMIPPCKSELR_DCMIPPSRC_MASK	GENMASK(1, 0)
+#define RCC_DCMIPPCKSELR_DCMIPPSRC_SHIFT	0
+
+/* RCC_SAESCKSELR register fields */
+#define RCC_SAESCKSELR_SAESSRC_MASK	GENMASK(1, 0)
+#define RCC_SAESCKSELR_SAESSRC_SHIFT	0
+
+/* RCC_APB1RSTSETR register fields */
+#define RCC_APB1RSTSETR_TIM2RST		BIT(0)
+#define RCC_APB1RSTSETR_TIM3RST		BIT(1)
+#define RCC_APB1RSTSETR_TIM4RST		BIT(2)
+#define RCC_APB1RSTSETR_TIM5RST		BIT(3)
+#define RCC_APB1RSTSETR_TIM6RST		BIT(4)
+#define RCC_APB1RSTSETR_TIM7RST		BIT(5)
+#define RCC_APB1RSTSETR_LPTIM1RST	BIT(9)
+#define RCC_APB1RSTSETR_SPI2RST		BIT(11)
+#define RCC_APB1RSTSETR_SPI3RST		BIT(12)
+#define RCC_APB1RSTSETR_USART3RST	BIT(15)
+#define RCC_APB1RSTSETR_UART4RST	BIT(16)
+#define RCC_APB1RSTSETR_UART5RST	BIT(17)
+#define RCC_APB1RSTSETR_UART7RST	BIT(18)
+#define RCC_APB1RSTSETR_UART8RST	BIT(19)
+#define RCC_APB1RSTSETR_I2C1RST		BIT(21)
+#define RCC_APB1RSTSETR_I2C2RST		BIT(22)
+#define RCC_APB1RSTSETR_SPDIFRST	BIT(26)
+
+/* RCC_APB1RSTCLRR register fields */
+#define RCC_APB1RSTCLRR_TIM2RST		BIT(0)
+#define RCC_APB1RSTCLRR_TIM3RST		BIT(1)
+#define RCC_APB1RSTCLRR_TIM4RST		BIT(2)
+#define RCC_APB1RSTCLRR_TIM5RST		BIT(3)
+#define RCC_APB1RSTCLRR_TIM6RST		BIT(4)
+#define RCC_APB1RSTCLRR_TIM7RST		BIT(5)
+#define RCC_APB1RSTCLRR_LPTIM1RST	BIT(9)
+#define RCC_APB1RSTCLRR_SPI2RST		BIT(11)
+#define RCC_APB1RSTCLRR_SPI3RST		BIT(12)
+#define RCC_APB1RSTCLRR_USART3RST	BIT(15)
+#define RCC_APB1RSTCLRR_UART4RST	BIT(16)
+#define RCC_APB1RSTCLRR_UART5RST	BIT(17)
+#define RCC_APB1RSTCLRR_UART7RST	BIT(18)
+#define RCC_APB1RSTCLRR_UART8RST	BIT(19)
+#define RCC_APB1RSTCLRR_I2C1RST		BIT(21)
+#define RCC_APB1RSTCLRR_I2C2RST		BIT(22)
+#define RCC_APB1RSTCLRR_SPDIFRST	BIT(26)
+
+/* RCC_APB2RSTSETR register fields */
+#define RCC_APB2RSTSETR_TIM1RST		BIT(0)
+#define RCC_APB2RSTSETR_TIM8RST		BIT(1)
+#define RCC_APB2RSTSETR_SPI1RST		BIT(8)
+#define RCC_APB2RSTSETR_USART6RST	BIT(13)
+#define RCC_APB2RSTSETR_SAI1RST		BIT(16)
+#define RCC_APB2RSTSETR_SAI2RST		BIT(17)
+#define RCC_APB2RSTSETR_DFSDMRST	BIT(20)
+#define RCC_APB2RSTSETR_FDCANRST	BIT(24)
+
+/* RCC_APB2RSTCLRR register fields */
+#define RCC_APB2RSTCLRR_TIM1RST		BIT(0)
+#define RCC_APB2RSTCLRR_TIM8RST		BIT(1)
+#define RCC_APB2RSTCLRR_SPI1RST		BIT(8)
+#define RCC_APB2RSTCLRR_USART6RST	BIT(13)
+#define RCC_APB2RSTCLRR_SAI1RST		BIT(16)
+#define RCC_APB2RSTCLRR_SAI2RST		BIT(17)
+#define RCC_APB2RSTCLRR_DFSDMRST	BIT(20)
+#define RCC_APB2RSTCLRR_FDCANRST	BIT(24)
+
+/* RCC_APB3RSTSETR register fields */
+#define RCC_APB3RSTSETR_LPTIM2RST	BIT(0)
+#define RCC_APB3RSTSETR_LPTIM3RST	BIT(1)
+#define RCC_APB3RSTSETR_LPTIM4RST	BIT(2)
+#define RCC_APB3RSTSETR_LPTIM5RST	BIT(3)
+#define RCC_APB3RSTSETR_SYSCFGRST	BIT(11)
+#define RCC_APB3RSTSETR_VREFRST		BIT(13)
+#define RCC_APB3RSTSETR_DTSRST		BIT(16)
+#define RCC_APB3RSTSETR_PMBCTRLRST	BIT(17)
+
+/* RCC_APB3RSTCLRR register fields */
+#define RCC_APB3RSTCLRR_LPTIM2RST	BIT(0)
+#define RCC_APB3RSTCLRR_LPTIM3RST	BIT(1)
+#define RCC_APB3RSTCLRR_LPTIM4RST	BIT(2)
+#define RCC_APB3RSTCLRR_LPTIM5RST	BIT(3)
+#define RCC_APB3RSTCLRR_SYSCFGRST	BIT(11)
+#define RCC_APB3RSTCLRR_VREFRST		BIT(13)
+#define RCC_APB3RSTCLRR_DTSRST		BIT(16)
+#define RCC_APB3RSTCLRR_PMBCTRLRST	BIT(17)
+
+/* RCC_APB4RSTSETR register fields */
+#define RCC_APB4RSTSETR_LTDCRST		BIT(0)
+#define RCC_APB4RSTSETR_DCMIPPRST	BIT(1)
+#define RCC_APB4RSTSETR_DDRPERFMRST	BIT(8)
+#define RCC_APB4RSTSETR_USBPHYRST	BIT(16)
+
+/* RCC_APB4RSTCLRR register fields */
+#define RCC_APB4RSTCLRR_LTDCRST		BIT(0)
+#define RCC_APB4RSTCLRR_DCMIPPRST	BIT(1)
+#define RCC_APB4RSTCLRR_DDRPERFMRST	BIT(8)
+#define RCC_APB4RSTCLRR_USBPHYRST	BIT(16)
+
+/* RCC_APB5RSTSETR register fields */
+#define RCC_APB5RSTSETR_STGENRST	BIT(20)
+
+/* RCC_APB5RSTCLRR register fields */
+#define RCC_APB5RSTCLRR_STGENRST	BIT(20)
+
+/* RCC_APB6RSTSETR register fields */
+#define RCC_APB6RSTSETR_USART1RST	BIT(0)
+#define RCC_APB6RSTSETR_USART2RST	BIT(1)
+#define RCC_APB6RSTSETR_SPI4RST		BIT(2)
+#define RCC_APB6RSTSETR_SPI5RST		BIT(3)
+#define RCC_APB6RSTSETR_I2C3RST		BIT(4)
+#define RCC_APB6RSTSETR_I2C4RST		BIT(5)
+#define RCC_APB6RSTSETR_I2C5RST		BIT(6)
+#define RCC_APB6RSTSETR_TIM12RST	BIT(7)
+#define RCC_APB6RSTSETR_TIM13RST	BIT(8)
+#define RCC_APB6RSTSETR_TIM14RST	BIT(9)
+#define RCC_APB6RSTSETR_TIM15RST	BIT(10)
+#define RCC_APB6RSTSETR_TIM16RST	BIT(11)
+#define RCC_APB6RSTSETR_TIM17RST	BIT(12)
+
+/* RCC_APB6RSTCLRR register fields */
+#define RCC_APB6RSTCLRR_USART1RST	BIT(0)
+#define RCC_APB6RSTCLRR_USART2RST	BIT(1)
+#define RCC_APB6RSTCLRR_SPI4RST		BIT(2)
+#define RCC_APB6RSTCLRR_SPI5RST		BIT(3)
+#define RCC_APB6RSTCLRR_I2C3RST		BIT(4)
+#define RCC_APB6RSTCLRR_I2C4RST		BIT(5)
+#define RCC_APB6RSTCLRR_I2C5RST		BIT(6)
+#define RCC_APB6RSTCLRR_TIM12RST	BIT(7)
+#define RCC_APB6RSTCLRR_TIM13RST	BIT(8)
+#define RCC_APB6RSTCLRR_TIM14RST	BIT(9)
+#define RCC_APB6RSTCLRR_TIM15RST	BIT(10)
+#define RCC_APB6RSTCLRR_TIM16RST	BIT(11)
+#define RCC_APB6RSTCLRR_TIM17RST	BIT(12)
+
+/* RCC_AHB2RSTSETR register fields */
+#define RCC_AHB2RSTSETR_DMA1RST		BIT(0)
+#define RCC_AHB2RSTSETR_DMA2RST		BIT(1)
+#define RCC_AHB2RSTSETR_DMAMUX1RST	BIT(2)
+#define RCC_AHB2RSTSETR_DMA3RST		BIT(3)
+#define RCC_AHB2RSTSETR_DMAMUX2RST	BIT(4)
+#define RCC_AHB2RSTSETR_ADC1RST		BIT(5)
+#define RCC_AHB2RSTSETR_ADC2RST		BIT(6)
+#define RCC_AHB2RSTSETR_USBORST		BIT(8)
+
+/* RCC_AHB2RSTCLRR register fields */
+#define RCC_AHB2RSTCLRR_DMA1RST		BIT(0)
+#define RCC_AHB2RSTCLRR_DMA2RST		BIT(1)
+#define RCC_AHB2RSTCLRR_DMAMUX1RST	BIT(2)
+#define RCC_AHB2RSTCLRR_DMA3RST		BIT(3)
+#define RCC_AHB2RSTCLRR_DMAMUX2RST	BIT(4)
+#define RCC_AHB2RSTCLRR_ADC1RST		BIT(5)
+#define RCC_AHB2RSTCLRR_ADC2RST		BIT(6)
+#define RCC_AHB2RSTCLRR_USBORST		BIT(8)
+
+/* RCC_AHB4RSTSETR register fields */
+#define RCC_AHB4RSTSETR_GPIOARST	BIT(0)
+#define RCC_AHB4RSTSETR_GPIOBRST	BIT(1)
+#define RCC_AHB4RSTSETR_GPIOCRST	BIT(2)
+#define RCC_AHB4RSTSETR_GPIODRST	BIT(3)
+#define RCC_AHB4RSTSETR_GPIOERST	BIT(4)
+#define RCC_AHB4RSTSETR_GPIOFRST	BIT(5)
+#define RCC_AHB4RSTSETR_GPIOGRST	BIT(6)
+#define RCC_AHB4RSTSETR_GPIOHRST	BIT(7)
+#define RCC_AHB4RSTSETR_GPIOIRST	BIT(8)
+#define RCC_AHB4RSTSETR_TSCRST		BIT(15)
+
+/* RCC_AHB4RSTCLRR register fields */
+#define RCC_AHB4RSTCLRR_GPIOARST	BIT(0)
+#define RCC_AHB4RSTCLRR_GPIOBRST	BIT(1)
+#define RCC_AHB4RSTCLRR_GPIOCRST	BIT(2)
+#define RCC_AHB4RSTCLRR_GPIODRST	BIT(3)
+#define RCC_AHB4RSTCLRR_GPIOERST	BIT(4)
+#define RCC_AHB4RSTCLRR_GPIOFRST	BIT(5)
+#define RCC_AHB4RSTCLRR_GPIOGRST	BIT(6)
+#define RCC_AHB4RSTCLRR_GPIOHRST	BIT(7)
+#define RCC_AHB4RSTCLRR_GPIOIRST	BIT(8)
+#define RCC_AHB4RSTCLRR_TSCRST		BIT(15)
+
+/* RCC_AHB5RSTSETR register fields */
+#define RCC_AHB5RSTSETR_PKARST		BIT(2)
+#define RCC_AHB5RSTSETR_SAESRST		BIT(3)
+#define RCC_AHB5RSTSETR_CRYP1RST	BIT(4)
+#define RCC_AHB5RSTSETR_HASH1RST	BIT(5)
+#define RCC_AHB5RSTSETR_RNG1RST		BIT(6)
+#define RCC_AHB5RSTSETR_AXIMCRST	BIT(16)
+
+/* RCC_AHB5RSTCLRR register fields */
+#define RCC_AHB5RSTCLRR_PKARST		BIT(2)
+#define RCC_AHB5RSTCLRR_SAESRST		BIT(3)
+#define RCC_AHB5RSTCLRR_CRYP1RST	BIT(4)
+#define RCC_AHB5RSTCLRR_HASH1RST	BIT(5)
+#define RCC_AHB5RSTCLRR_RNG1RST		BIT(6)
+#define RCC_AHB5RSTCLRR_AXIMCRST	BIT(16)
+
+/* RCC_AHB6RSTSETR register fields */
+#define RCC_AHB6RSTSETR_MDMARST		BIT(0)
+#define RCC_AHB6RSTSETR_MCERST		BIT(1)
+#define RCC_AHB6RSTSETR_ETH1MACRST	BIT(10)
+#define RCC_AHB6RSTSETR_FMCRST		BIT(12)
+#define RCC_AHB6RSTSETR_QSPIRST		BIT(14)
+#define RCC_AHB6RSTSETR_SDMMC1RST	BIT(16)
+#define RCC_AHB6RSTSETR_SDMMC2RST	BIT(17)
+#define RCC_AHB6RSTSETR_CRC1RST		BIT(20)
+#define RCC_AHB6RSTSETR_USBHRST		BIT(24)
+#define RCC_AHB6RSTSETR_ETH2MACRST	BIT(30)
+
+/* RCC_AHB6RSTCLRR register fields */
+#define RCC_AHB6RSTCLRR_MDMARST		BIT(0)
+#define RCC_AHB6RSTCLRR_MCERST		BIT(1)
+#define RCC_AHB6RSTCLRR_ETH1MACRST	BIT(10)
+#define RCC_AHB6RSTCLRR_FMCRST		BIT(12)
+#define RCC_AHB6RSTCLRR_QSPIRST		BIT(14)
+#define RCC_AHB6RSTCLRR_SDMMC1RST	BIT(16)
+#define RCC_AHB6RSTCLRR_SDMMC2RST	BIT(17)
+#define RCC_AHB6RSTCLRR_CRC1RST		BIT(20)
+#define RCC_AHB6RSTCLRR_USBHRST		BIT(24)
+#define RCC_AHB6RSTCLRR_ETH2MACRST	BIT(30)
+
+/* RCC_MP_APB1ENSETR register fields */
+#define RCC_MP_APB1ENSETR_TIM2EN	BIT(0)
+#define RCC_MP_APB1ENSETR_TIM3EN	BIT(1)
+#define RCC_MP_APB1ENSETR_TIM4EN	BIT(2)
+#define RCC_MP_APB1ENSETR_TIM5EN	BIT(3)
+#define RCC_MP_APB1ENSETR_TIM6EN	BIT(4)
+#define RCC_MP_APB1ENSETR_TIM7EN	BIT(5)
+#define RCC_MP_APB1ENSETR_LPTIM1EN	BIT(9)
+#define RCC_MP_APB1ENSETR_SPI2EN	BIT(11)
+#define RCC_MP_APB1ENSETR_SPI3EN	BIT(12)
+#define RCC_MP_APB1ENSETR_USART3EN	BIT(15)
+#define RCC_MP_APB1ENSETR_UART4EN	BIT(16)
+#define RCC_MP_APB1ENSETR_UART5EN	BIT(17)
+#define RCC_MP_APB1ENSETR_UART7EN	BIT(18)
+#define RCC_MP_APB1ENSETR_UART8EN	BIT(19)
+#define RCC_MP_APB1ENSETR_I2C1EN	BIT(21)
+#define RCC_MP_APB1ENSETR_I2C2EN	BIT(22)
+#define RCC_MP_APB1ENSETR_SPDIFEN	BIT(26)
+
+/* RCC_MP_APB1ENCLRR register fields */
+#define RCC_MP_APB1ENCLRR_TIM2EN	BIT(0)
+#define RCC_MP_APB1ENCLRR_TIM3EN	BIT(1)
+#define RCC_MP_APB1ENCLRR_TIM4EN	BIT(2)
+#define RCC_MP_APB1ENCLRR_TIM5EN	BIT(3)
+#define RCC_MP_APB1ENCLRR_TIM6EN	BIT(4)
+#define RCC_MP_APB1ENCLRR_TIM7EN	BIT(5)
+#define RCC_MP_APB1ENCLRR_LPTIM1EN	BIT(9)
+#define RCC_MP_APB1ENCLRR_SPI2EN	BIT(11)
+#define RCC_MP_APB1ENCLRR_SPI3EN	BIT(12)
+#define RCC_MP_APB1ENCLRR_USART3EN	BIT(15)
+#define RCC_MP_APB1ENCLRR_UART4EN	BIT(16)
+#define RCC_MP_APB1ENCLRR_UART5EN	BIT(17)
+#define RCC_MP_APB1ENCLRR_UART7EN	BIT(18)
+#define RCC_MP_APB1ENCLRR_UART8EN	BIT(19)
+#define RCC_MP_APB1ENCLRR_I2C1EN	BIT(21)
+#define RCC_MP_APB1ENCLRR_I2C2EN	BIT(22)
+#define RCC_MP_APB1ENCLRR_SPDIFEN	BIT(26)
+
+/* RCC_MP_APB2ENSETR register fields */
+#define RCC_MP_APB2ENSETR_TIM1EN	BIT(0)
+#define RCC_MP_APB2ENSETR_TIM8EN	BIT(1)
+#define RCC_MP_APB2ENSETR_SPI1EN	BIT(8)
+#define RCC_MP_APB2ENSETR_USART6EN	BIT(13)
+#define RCC_MP_APB2ENSETR_SAI1EN	BIT(16)
+#define RCC_MP_APB2ENSETR_SAI2EN	BIT(17)
+#define RCC_MP_APB2ENSETR_DFSDMEN	BIT(20)
+#define RCC_MP_APB2ENSETR_ADFSDMEN	BIT(21)
+#define RCC_MP_APB2ENSETR_FDCANEN	BIT(24)
+
+/* RCC_MP_APB2ENCLRR register fields */
+#define RCC_MP_APB2ENCLRR_TIM1EN	BIT(0)
+#define RCC_MP_APB2ENCLRR_TIM8EN	BIT(1)
+#define RCC_MP_APB2ENCLRR_SPI1EN	BIT(8)
+#define RCC_MP_APB2ENCLRR_USART6EN	BIT(13)
+#define RCC_MP_APB2ENCLRR_SAI1EN	BIT(16)
+#define RCC_MP_APB2ENCLRR_SAI2EN	BIT(17)
+#define RCC_MP_APB2ENCLRR_DFSDMEN	BIT(20)
+#define RCC_MP_APB2ENCLRR_ADFSDMEN	BIT(21)
+#define RCC_MP_APB2ENCLRR_FDCANEN	BIT(24)
+
+/* RCC_MP_APB3ENSETR register fields */
+#define RCC_MP_APB3ENSETR_LPTIM2EN	BIT(0)
+#define RCC_MP_APB3ENSETR_LPTIM3EN	BIT(1)
+#define RCC_MP_APB3ENSETR_LPTIM4EN	BIT(2)
+#define RCC_MP_APB3ENSETR_LPTIM5EN	BIT(3)
+#define RCC_MP_APB3ENSETR_VREFEN	BIT(13)
+#define RCC_MP_APB3ENSETR_DTSEN		BIT(16)
+#define RCC_MP_APB3ENSETR_PMBCTRLEN	BIT(17)
+#define RCC_MP_APB3ENSETR_HDPEN		BIT(20)
+
+/* RCC_MP_APB3ENCLRR register fields */
+#define RCC_MP_APB3ENCLRR_LPTIM2EN	BIT(0)
+#define RCC_MP_APB3ENCLRR_LPTIM3EN	BIT(1)
+#define RCC_MP_APB3ENCLRR_LPTIM4EN	BIT(2)
+#define RCC_MP_APB3ENCLRR_LPTIM5EN	BIT(3)
+#define RCC_MP_APB3ENCLRR_VREFEN	BIT(13)
+#define RCC_MP_APB3ENCLRR_DTSEN		BIT(16)
+#define RCC_MP_APB3ENCLRR_PMBCTRLEN	BIT(17)
+#define RCC_MP_APB3ENCLRR_HDPEN		BIT(20)
+
+/* RCC_MP_S_APB3ENSETR register fields */
+#define RCC_MP_S_APB3ENSETR_SYSCFGEN	BIT(0)
+
+/* RCC_MP_S_APB3ENCLRR register fields */
+#define RCC_MP_S_APB3ENCLRR_SYSCFGEN	BIT(0)
+
+/* RCC_MP_NS_APB3ENSETR register fields */
+#define RCC_MP_NS_APB3ENSETR_SYSCFGEN	BIT(0)
+
+/* RCC_MP_NS_APB3ENCLRR register fields */
+#define RCC_MP_NS_APB3ENCLRR_SYSCFGEN	BIT(0)
+
+/* RCC_MP_APB4ENSETR register fields */
+#define RCC_MP_APB4ENSETR_DCMIPPEN	BIT(1)
+#define RCC_MP_APB4ENSETR_DDRPERFMEN	BIT(8)
+#define RCC_MP_APB4ENSETR_IWDG2APBEN	BIT(15)
+#define RCC_MP_APB4ENSETR_USBPHYEN	BIT(16)
+#define RCC_MP_APB4ENSETR_STGENROEN	BIT(20)
+
+/* RCC_MP_APB4ENCLRR register fields */
+#define RCC_MP_APB4ENCLRR_DCMIPPEN	BIT(1)
+#define RCC_MP_APB4ENCLRR_DDRPERFMEN	BIT(8)
+#define RCC_MP_APB4ENCLRR_IWDG2APBEN	BIT(15)
+#define RCC_MP_APB4ENCLRR_USBPHYEN	BIT(16)
+#define RCC_MP_APB4ENCLRR_STGENROEN	BIT(20)
+
+/* RCC_MP_S_APB4ENSETR register fields */
+#define RCC_MP_S_APB4ENSETR_LTDCEN	BIT(0)
+
+/* RCC_MP_S_APB4ENCLRR register fields */
+#define RCC_MP_S_APB4ENCLRR_LTDCEN	BIT(0)
+
+/* RCC_MP_NS_APB4ENSETR register fields */
+#define RCC_MP_NS_APB4ENSETR_LTDCEN	BIT(0)
+
+/* RCC_MP_NS_APB4ENCLRR register fields */
+#define RCC_MP_NS_APB4ENCLRR_LTDCEN	BIT(0)
+
+/* RCC_MP_APB5ENSETR register fields */
+#define RCC_MP_APB5ENSETR_RTCAPBEN	BIT(8)
+#define RCC_MP_APB5ENSETR_TZCEN		BIT(11)
+#define RCC_MP_APB5ENSETR_ETZPCEN	BIT(13)
+#define RCC_MP_APB5ENSETR_IWDG1APBEN	BIT(15)
+#define RCC_MP_APB5ENSETR_BSECEN	BIT(16)
+#define RCC_MP_APB5ENSETR_STGENCEN	BIT(20)
+
+/* RCC_MP_APB5ENCLRR register fields */
+#define RCC_MP_APB5ENCLRR_RTCAPBEN	BIT(8)
+#define RCC_MP_APB5ENCLRR_TZCEN		BIT(11)
+#define RCC_MP_APB5ENCLRR_ETZPCEN	BIT(13)
+#define RCC_MP_APB5ENCLRR_IWDG1APBEN	BIT(15)
+#define RCC_MP_APB5ENCLRR_BSECEN	BIT(16)
+#define RCC_MP_APB5ENCLRR_STGENCEN	BIT(20)
+
+/* RCC_MP_APB6ENSETR register fields */
+#define RCC_MP_APB6ENSETR_USART1EN	BIT(0)
+#define RCC_MP_APB6ENSETR_USART2EN	BIT(1)
+#define RCC_MP_APB6ENSETR_SPI4EN	BIT(2)
+#define RCC_MP_APB6ENSETR_SPI5EN	BIT(3)
+#define RCC_MP_APB6ENSETR_I2C3EN	BIT(4)
+#define RCC_MP_APB6ENSETR_I2C4EN	BIT(5)
+#define RCC_MP_APB6ENSETR_I2C5EN	BIT(6)
+#define RCC_MP_APB6ENSETR_TIM12EN	BIT(7)
+#define RCC_MP_APB6ENSETR_TIM13EN	BIT(8)
+#define RCC_MP_APB6ENSETR_TIM14EN	BIT(9)
+#define RCC_MP_APB6ENSETR_TIM15EN	BIT(10)
+#define RCC_MP_APB6ENSETR_TIM16EN	BIT(11)
+#define RCC_MP_APB6ENSETR_TIM17EN	BIT(12)
+
+/* RCC_MP_APB6ENCLRR register fields */
+#define RCC_MP_APB6ENCLRR_USART1EN	BIT(0)
+#define RCC_MP_APB6ENCLRR_USART2EN	BIT(1)
+#define RCC_MP_APB6ENCLRR_SPI4EN	BIT(2)
+#define RCC_MP_APB6ENCLRR_SPI5EN	BIT(3)
+#define RCC_MP_APB6ENCLRR_I2C3EN	BIT(4)
+#define RCC_MP_APB6ENCLRR_I2C4EN	BIT(5)
+#define RCC_MP_APB6ENCLRR_I2C5EN	BIT(6)
+#define RCC_MP_APB6ENCLRR_TIM12EN	BIT(7)
+#define RCC_MP_APB6ENCLRR_TIM13EN	BIT(8)
+#define RCC_MP_APB6ENCLRR_TIM14EN	BIT(9)
+#define RCC_MP_APB6ENCLRR_TIM15EN	BIT(10)
+#define RCC_MP_APB6ENCLRR_TIM16EN	BIT(11)
+#define RCC_MP_APB6ENCLRR_TIM17EN	BIT(12)
+
+/* RCC_MP_AHB2ENSETR register fields */
+#define RCC_MP_AHB2ENSETR_DMA1EN	BIT(0)
+#define RCC_MP_AHB2ENSETR_DMA2EN	BIT(1)
+#define RCC_MP_AHB2ENSETR_DMAMUX1EN	BIT(2)
+#define RCC_MP_AHB2ENSETR_DMA3EN	BIT(3)
+#define RCC_MP_AHB2ENSETR_DMAMUX2EN	BIT(4)
+#define RCC_MP_AHB2ENSETR_ADC1EN	BIT(5)
+#define RCC_MP_AHB2ENSETR_ADC2EN	BIT(6)
+#define RCC_MP_AHB2ENSETR_USBOEN	BIT(8)
+
+/* RCC_MP_AHB2ENCLRR register fields */
+#define RCC_MP_AHB2ENCLRR_DMA1EN	BIT(0)
+#define RCC_MP_AHB2ENCLRR_DMA2EN	BIT(1)
+#define RCC_MP_AHB2ENCLRR_DMAMUX1EN	BIT(2)
+#define RCC_MP_AHB2ENCLRR_DMA3EN	BIT(3)
+#define RCC_MP_AHB2ENCLRR_DMAMUX2EN	BIT(4)
+#define RCC_MP_AHB2ENCLRR_ADC1EN	BIT(5)
+#define RCC_MP_AHB2ENCLRR_ADC2EN	BIT(6)
+#define RCC_MP_AHB2ENCLRR_USBOEN	BIT(8)
+
+/* RCC_MP_AHB4ENSETR register fields */
+#define RCC_MP_AHB4ENSETR_TSCEN		BIT(15)
+
+/* RCC_MP_AHB4ENCLRR register fields */
+#define RCC_MP_AHB4ENCLRR_TSCEN		BIT(15)
+
+/* RCC_MP_S_AHB4ENSETR register fields */
+#define RCC_MP_S_AHB4ENSETR_GPIOAEN	BIT(0)
+#define RCC_MP_S_AHB4ENSETR_GPIOBEN	BIT(1)
+#define RCC_MP_S_AHB4ENSETR_GPIOCEN	BIT(2)
+#define RCC_MP_S_AHB4ENSETR_GPIODEN	BIT(3)
+#define RCC_MP_S_AHB4ENSETR_GPIOEEN	BIT(4)
+#define RCC_MP_S_AHB4ENSETR_GPIOFEN	BIT(5)
+#define RCC_MP_S_AHB4ENSETR_GPIOGEN	BIT(6)
+#define RCC_MP_S_AHB4ENSETR_GPIOHEN	BIT(7)
+#define RCC_MP_S_AHB4ENSETR_GPIOIEN	BIT(8)
+
+/* RCC_MP_S_AHB4ENCLRR register fields */
+#define RCC_MP_S_AHB4ENCLRR_GPIOAEN	BIT(0)
+#define RCC_MP_S_AHB4ENCLRR_GPIOBEN	BIT(1)
+#define RCC_MP_S_AHB4ENCLRR_GPIOCEN	BIT(2)
+#define RCC_MP_S_AHB4ENCLRR_GPIODEN	BIT(3)
+#define RCC_MP_S_AHB4ENCLRR_GPIOEEN	BIT(4)
+#define RCC_MP_S_AHB4ENCLRR_GPIOFEN	BIT(5)
+#define RCC_MP_S_AHB4ENCLRR_GPIOGEN	BIT(6)
+#define RCC_MP_S_AHB4ENCLRR_GPIOHEN	BIT(7)
+#define RCC_MP_S_AHB4ENCLRR_GPIOIEN	BIT(8)
+
+/* RCC_MP_NS_AHB4ENSETR register fields */
+#define RCC_MP_NS_AHB4ENSETR_GPIOAEN	BIT(0)
+#define RCC_MP_NS_AHB4ENSETR_GPIOBEN	BIT(1)
+#define RCC_MP_NS_AHB4ENSETR_GPIOCEN	BIT(2)
+#define RCC_MP_NS_AHB4ENSETR_GPIODEN	BIT(3)
+#define RCC_MP_NS_AHB4ENSETR_GPIOEEN	BIT(4)
+#define RCC_MP_NS_AHB4ENSETR_GPIOFEN	BIT(5)
+#define RCC_MP_NS_AHB4ENSETR_GPIOGEN	BIT(6)
+#define RCC_MP_NS_AHB4ENSETR_GPIOHEN	BIT(7)
+#define RCC_MP_NS_AHB4ENSETR_GPIOIEN	BIT(8)
+
+/* RCC_MP_NS_AHB4ENCLRR register fields */
+#define RCC_MP_NS_AHB4ENCLRR_GPIOAEN	BIT(0)
+#define RCC_MP_NS_AHB4ENCLRR_GPIOBEN	BIT(1)
+#define RCC_MP_NS_AHB4ENCLRR_GPIOCEN	BIT(2)
+#define RCC_MP_NS_AHB4ENCLRR_GPIODEN	BIT(3)
+#define RCC_MP_NS_AHB4ENCLRR_GPIOEEN	BIT(4)
+#define RCC_MP_NS_AHB4ENCLRR_GPIOFEN	BIT(5)
+#define RCC_MP_NS_AHB4ENCLRR_GPIOGEN	BIT(6)
+#define RCC_MP_NS_AHB4ENCLRR_GPIOHEN	BIT(7)
+#define RCC_MP_NS_AHB4ENCLRR_GPIOIEN	BIT(8)
+
+/* RCC_MP_AHB5ENSETR register fields */
+#define RCC_MP_AHB5ENSETR_PKAEN		BIT(2)
+#define RCC_MP_AHB5ENSETR_SAESEN	BIT(3)
+#define RCC_MP_AHB5ENSETR_CRYP1EN	BIT(4)
+#define RCC_MP_AHB5ENSETR_HASH1EN	BIT(5)
+#define RCC_MP_AHB5ENSETR_RNG1EN	BIT(6)
+#define RCC_MP_AHB5ENSETR_BKPSRAMEN	BIT(8)
+#define RCC_MP_AHB5ENSETR_AXIMCEN	BIT(16)
+
+/* RCC_MP_AHB5ENCLRR register fields */
+#define RCC_MP_AHB5ENCLRR_PKAEN		BIT(2)
+#define RCC_MP_AHB5ENCLRR_SAESEN	BIT(3)
+#define RCC_MP_AHB5ENCLRR_CRYP1EN	BIT(4)
+#define RCC_MP_AHB5ENCLRR_HASH1EN	BIT(5)
+#define RCC_MP_AHB5ENCLRR_RNG1EN	BIT(6)
+#define RCC_MP_AHB5ENCLRR_BKPSRAMEN	BIT(8)
+#define RCC_MP_AHB5ENCLRR_AXIMCEN	BIT(16)
+
+/* RCC_MP_AHB6ENSETR register fields */
+#define RCC_MP_AHB6ENSETR_MCEEN		BIT(1)
+#define RCC_MP_AHB6ENSETR_ETH1CKEN	BIT(7)
+#define RCC_MP_AHB6ENSETR_ETH1TXEN	BIT(8)
+#define RCC_MP_AHB6ENSETR_ETH1RXEN	BIT(9)
+#define RCC_MP_AHB6ENSETR_ETH1MACEN	BIT(10)
+#define RCC_MP_AHB6ENSETR_FMCEN		BIT(12)
+#define RCC_MP_AHB6ENSETR_QSPIEN	BIT(14)
+#define RCC_MP_AHB6ENSETR_SDMMC1EN	BIT(16)
+#define RCC_MP_AHB6ENSETR_SDMMC2EN	BIT(17)
+#define RCC_MP_AHB6ENSETR_CRC1EN	BIT(20)
+#define RCC_MP_AHB6ENSETR_USBHEN	BIT(24)
+#define RCC_MP_AHB6ENSETR_ETH2CKEN	BIT(27)
+#define RCC_MP_AHB6ENSETR_ETH2TXEN	BIT(28)
+#define RCC_MP_AHB6ENSETR_ETH2RXEN	BIT(29)
+#define RCC_MP_AHB6ENSETR_ETH2MACEN	BIT(30)
+
+/* RCC_MP_AHB6ENCLRR register fields */
+#define RCC_MP_AHB6ENCLRR_MCEEN		BIT(1)
+#define RCC_MP_AHB6ENCLRR_ETH1CKEN	BIT(7)
+#define RCC_MP_AHB6ENCLRR_ETH1TXEN	BIT(8)
+#define RCC_MP_AHB6ENCLRR_ETH1RXEN	BIT(9)
+#define RCC_MP_AHB6ENCLRR_ETH1MACEN	BIT(10)
+#define RCC_MP_AHB6ENCLRR_FMCEN		BIT(12)
+#define RCC_MP_AHB6ENCLRR_QSPIEN	BIT(14)
+#define RCC_MP_AHB6ENCLRR_SDMMC1EN	BIT(16)
+#define RCC_MP_AHB6ENCLRR_SDMMC2EN	BIT(17)
+#define RCC_MP_AHB6ENCLRR_CRC1EN	BIT(20)
+#define RCC_MP_AHB6ENCLRR_USBHEN	BIT(24)
+#define RCC_MP_AHB6ENCLRR_ETH2CKEN	BIT(27)
+#define RCC_MP_AHB6ENCLRR_ETH2TXEN	BIT(28)
+#define RCC_MP_AHB6ENCLRR_ETH2RXEN	BIT(29)
+#define RCC_MP_AHB6ENCLRR_ETH2MACEN	BIT(30)
+
+/* RCC_MP_S_AHB6ENSETR register fields */
+#define RCC_MP_S_AHB6ENSETR_MDMAEN	BIT(0)
+
+/* RCC_MP_S_AHB6ENCLRR register fields */
+#define RCC_MP_S_AHB6ENCLRR_MDMAEN	BIT(0)
+
+/* RCC_MP_NS_AHB6ENSETR register fields */
+#define RCC_MP_NS_AHB6ENSETR_MDMAEN	BIT(0)
+
+/* RCC_MP_NS_AHB6ENCLRR register fields */
+#define RCC_MP_NS_AHB6ENCLRR_MDMAEN	BIT(0)
+
+/* RCC_MP_APB1LPENSETR register fields */
+#define RCC_MP_APB1LPENSETR_TIM2LPEN	BIT(0)
+#define RCC_MP_APB1LPENSETR_TIM3LPEN	BIT(1)
+#define RCC_MP_APB1LPENSETR_TIM4LPEN	BIT(2)
+#define RCC_MP_APB1LPENSETR_TIM5LPEN	BIT(3)
+#define RCC_MP_APB1LPENSETR_TIM6LPEN	BIT(4)
+#define RCC_MP_APB1LPENSETR_TIM7LPEN	BIT(5)
+#define RCC_MP_APB1LPENSETR_LPTIM1LPEN	BIT(9)
+#define RCC_MP_APB1LPENSETR_SPI2LPEN	BIT(11)
+#define RCC_MP_APB1LPENSETR_SPI3LPEN	BIT(12)
+#define RCC_MP_APB1LPENSETR_USART3LPEN	BIT(15)
+#define RCC_MP_APB1LPENSETR_UART4LPEN	BIT(16)
+#define RCC_MP_APB1LPENSETR_UART5LPEN	BIT(17)
+#define RCC_MP_APB1LPENSETR_UART7LPEN	BIT(18)
+#define RCC_MP_APB1LPENSETR_UART8LPEN	BIT(19)
+#define RCC_MP_APB1LPENSETR_I2C1LPEN	BIT(21)
+#define RCC_MP_APB1LPENSETR_I2C2LPEN	BIT(22)
+#define RCC_MP_APB1LPENSETR_SPDIFLPEN	BIT(26)
+
+/* RCC_MP_APB1LPENCLRR register fields */
+#define RCC_MP_APB1LPENCLRR_TIM2LPEN	BIT(0)
+#define RCC_MP_APB1LPENCLRR_TIM3LPEN	BIT(1)
+#define RCC_MP_APB1LPENCLRR_TIM4LPEN	BIT(2)
+#define RCC_MP_APB1LPENCLRR_TIM5LPEN	BIT(3)
+#define RCC_MP_APB1LPENCLRR_TIM6LPEN	BIT(4)
+#define RCC_MP_APB1LPENCLRR_TIM7LPEN	BIT(5)
+#define RCC_MP_APB1LPENCLRR_LPTIM1LPEN	BIT(9)
+#define RCC_MP_APB1LPENCLRR_SPI2LPEN	BIT(11)
+#define RCC_MP_APB1LPENCLRR_SPI3LPEN	BIT(12)
+#define RCC_MP_APB1LPENCLRR_USART3LPEN	BIT(15)
+#define RCC_MP_APB1LPENCLRR_UART4LPEN	BIT(16)
+#define RCC_MP_APB1LPENCLRR_UART5LPEN	BIT(17)
+#define RCC_MP_APB1LPENCLRR_UART7LPEN	BIT(18)
+#define RCC_MP_APB1LPENCLRR_UART8LPEN	BIT(19)
+#define RCC_MP_APB1LPENCLRR_I2C1LPEN	BIT(21)
+#define RCC_MP_APB1LPENCLRR_I2C2LPEN	BIT(22)
+#define RCC_MP_APB1LPENCLRR_SPDIFLPEN	BIT(26)
+
+/* RCC_MP_APB2LPENSETR register fields */
+#define RCC_MP_APB2LPENSETR_TIM1LPEN	BIT(0)
+#define RCC_MP_APB2LPENSETR_TIM8LPEN	BIT(1)
+#define RCC_MP_APB2LPENSETR_SPI1LPEN	BIT(8)
+#define RCC_MP_APB2LPENSETR_USART6LPEN	BIT(13)
+#define RCC_MP_APB2LPENSETR_SAI1LPEN	BIT(16)
+#define RCC_MP_APB2LPENSETR_SAI2LPEN	BIT(17)
+#define RCC_MP_APB2LPENSETR_DFSDMLPEN	BIT(20)
+#define RCC_MP_APB2LPENSETR_ADFSDMLPEN	BIT(21)
+#define RCC_MP_APB2LPENSETR_FDCANLPEN	BIT(24)
+
+/* RCC_MP_APB2LPENCLRR register fields */
+#define RCC_MP_APB2LPENCLRR_TIM1LPEN	BIT(0)
+#define RCC_MP_APB2LPENCLRR_TIM8LPEN	BIT(1)
+#define RCC_MP_APB2LPENCLRR_SPI1LPEN	BIT(8)
+#define RCC_MP_APB2LPENCLRR_USART6LPEN	BIT(13)
+#define RCC_MP_APB2LPENCLRR_SAI1LPEN	BIT(16)
+#define RCC_MP_APB2LPENCLRR_SAI2LPEN	BIT(17)
+#define RCC_MP_APB2LPENCLRR_DFSDMLPEN	BIT(20)
+#define RCC_MP_APB2LPENCLRR_ADFSDMLPEN	BIT(21)
+#define RCC_MP_APB2LPENCLRR_FDCANLPEN	BIT(24)
+
+/* RCC_MP_APB3LPENSETR register fields */
+#define RCC_MP_APB3LPENSETR_LPTIM2LPEN	BIT(0)
+#define RCC_MP_APB3LPENSETR_LPTIM3LPEN	BIT(1)
+#define RCC_MP_APB3LPENSETR_LPTIM4LPEN	BIT(2)
+#define RCC_MP_APB3LPENSETR_LPTIM5LPEN	BIT(3)
+#define RCC_MP_APB3LPENSETR_VREFLPEN	BIT(13)
+#define RCC_MP_APB3LPENSETR_DTSLPEN	BIT(16)
+#define RCC_MP_APB3LPENSETR_PMBCTRLLPEN	BIT(17)
+
+/* RCC_MP_APB3LPENCLRR register fields */
+#define RCC_MP_APB3LPENCLRR_LPTIM2LPEN	BIT(0)
+#define RCC_MP_APB3LPENCLRR_LPTIM3LPEN	BIT(1)
+#define RCC_MP_APB3LPENCLRR_LPTIM4LPEN	BIT(2)
+#define RCC_MP_APB3LPENCLRR_LPTIM5LPEN	BIT(3)
+#define RCC_MP_APB3LPENCLRR_VREFLPEN	BIT(13)
+#define RCC_MP_APB3LPENCLRR_DTSLPEN	BIT(16)
+#define RCC_MP_APB3LPENCLRR_PMBCTRLLPEN	BIT(17)
+
+/* RCC_MP_S_APB3LPENSETR register fields */
+#define RCC_MP_S_APB3LPENSETR_SYSCFGLPEN	BIT(0)
+
+/* RCC_MP_S_APB3LPENCLRR register fields */
+#define RCC_MP_S_APB3LPENCLRR_SYSCFGLPEN	BIT(0)
+
+/* RCC_MP_NS_APB3LPENSETR register fields */
+#define RCC_MP_NS_APB3LPENSETR_SYSCFGLPEN	BIT(0)
+
+/* RCC_MP_NS_APB3LPENCLRR register fields */
+#define RCC_MP_NS_APB3LPENCLRR_SYSCFGLPEN	BIT(0)
+
+/* RCC_MP_APB4LPENSETR register fields */
+#define RCC_MP_APB4LPENSETR_DCMIPPLPEN		BIT(1)
+#define RCC_MP_APB4LPENSETR_DDRPERFMLPEN	BIT(8)
+#define RCC_MP_APB4LPENSETR_IWDG2APBLPEN	BIT(15)
+#define RCC_MP_APB4LPENSETR_USBPHYLPEN		BIT(16)
+#define RCC_MP_APB4LPENSETR_STGENROLPEN		BIT(20)
+#define RCC_MP_APB4LPENSETR_STGENROSTPEN	BIT(21)
+
+/* RCC_MP_APB4LPENCLRR register fields */
+#define RCC_MP_APB4LPENCLRR_DCMIPPLPEN		BIT(1)
+#define RCC_MP_APB4LPENCLRR_DDRPERFMLPEN	BIT(8)
+#define RCC_MP_APB4LPENCLRR_IWDG2APBLPEN	BIT(15)
+#define RCC_MP_APB4LPENCLRR_USBPHYLPEN		BIT(16)
+#define RCC_MP_APB4LPENCLRR_STGENROLPEN		BIT(20)
+#define RCC_MP_APB4LPENCLRR_STGENROSTPEN	BIT(21)
+
+/* RCC_MP_S_APB4LPENSETR register fields */
+#define RCC_MP_S_APB4LPENSETR_LTDCLPEN	BIT(0)
+
+/* RCC_MP_S_APB4LPENCLRR register fields */
+#define RCC_MP_S_APB4LPENCLRR_LTDCLPEN	BIT(0)
+
+/* RCC_MP_NS_APB4LPENSETR register fields */
+#define RCC_MP_NS_APB4LPENSETR_LTDCLPEN	BIT(0)
+
+/* RCC_MP_NS_APB4LPENCLRR register fields */
+#define RCC_MP_NS_APB4LPENCLRR_LTDCLPEN	BIT(0)
+
+/* RCC_MP_APB5LPENSETR register fields */
+#define RCC_MP_APB5LPENSETR_RTCAPBLPEN		BIT(8)
+#define RCC_MP_APB5LPENSETR_TZCLPEN		BIT(11)
+#define RCC_MP_APB5LPENSETR_ETZPCLPEN		BIT(13)
+#define RCC_MP_APB5LPENSETR_IWDG1APBLPEN	BIT(15)
+#define RCC_MP_APB5LPENSETR_BSECLPEN		BIT(16)
+#define RCC_MP_APB5LPENSETR_STGENCLPEN		BIT(20)
+#define RCC_MP_APB5LPENSETR_STGENCSTPEN		BIT(21)
+
+/* RCC_MP_APB5LPENCLRR register fields */
+#define RCC_MP_APB5LPENCLRR_RTCAPBLPEN		BIT(8)
+#define RCC_MP_APB5LPENCLRR_TZCLPEN		BIT(11)
+#define RCC_MP_APB5LPENCLRR_ETZPCLPEN		BIT(13)
+#define RCC_MP_APB5LPENCLRR_IWDG1APBLPEN	BIT(15)
+#define RCC_MP_APB5LPENCLRR_BSECLPEN		BIT(16)
+#define RCC_MP_APB5LPENCLRR_STGENCLPEN		BIT(20)
+#define RCC_MP_APB5LPENCLRR_STGENCSTPEN		BIT(21)
+
+/* RCC_MP_APB6LPENSETR register fields */
+#define RCC_MP_APB6LPENSETR_USART1LPEN	BIT(0)
+#define RCC_MP_APB6LPENSETR_USART2LPEN	BIT(1)
+#define RCC_MP_APB6LPENSETR_SPI4LPEN	BIT(2)
+#define RCC_MP_APB6LPENSETR_SPI5LPEN	BIT(3)
+#define RCC_MP_APB6LPENSETR_I2C3LPEN	BIT(4)
+#define RCC_MP_APB6LPENSETR_I2C4LPEN	BIT(5)
+#define RCC_MP_APB6LPENSETR_I2C5LPEN	BIT(6)
+#define RCC_MP_APB6LPENSETR_TIM12LPEN	BIT(7)
+#define RCC_MP_APB6LPENSETR_TIM13LPEN	BIT(8)
+#define RCC_MP_APB6LPENSETR_TIM14LPEN	BIT(9)
+#define RCC_MP_APB6LPENSETR_TIM15LPEN	BIT(10)
+#define RCC_MP_APB6LPENSETR_TIM16LPEN	BIT(11)
+#define RCC_MP_APB6LPENSETR_TIM17LPEN	BIT(12)
+
+/* RCC_MP_APB6LPENCLRR register fields */
+#define RCC_MP_APB6LPENCLRR_USART1LPEN	BIT(0)
+#define RCC_MP_APB6LPENCLRR_USART2LPEN	BIT(1)
+#define RCC_MP_APB6LPENCLRR_SPI4LPEN	BIT(2)
+#define RCC_MP_APB6LPENCLRR_SPI5LPEN	BIT(3)
+#define RCC_MP_APB6LPENCLRR_I2C3LPEN	BIT(4)
+#define RCC_MP_APB6LPENCLRR_I2C4LPEN	BIT(5)
+#define RCC_MP_APB6LPENCLRR_I2C5LPEN	BIT(6)
+#define RCC_MP_APB6LPENCLRR_TIM12LPEN	BIT(7)
+#define RCC_MP_APB6LPENCLRR_TIM13LPEN	BIT(8)
+#define RCC_MP_APB6LPENCLRR_TIM14LPEN	BIT(9)
+#define RCC_MP_APB6LPENCLRR_TIM15LPEN	BIT(10)
+#define RCC_MP_APB6LPENCLRR_TIM16LPEN	BIT(11)
+#define RCC_MP_APB6LPENCLRR_TIM17LPEN	BIT(12)
+
+/* RCC_MP_AHB2LPENSETR register fields */
+#define RCC_MP_AHB2LPENSETR_DMA1LPEN	BIT(0)
+#define RCC_MP_AHB2LPENSETR_DMA2LPEN	BIT(1)
+#define RCC_MP_AHB2LPENSETR_DMAMUX1LPEN	BIT(2)
+#define RCC_MP_AHB2LPENSETR_DMA3LPEN	BIT(3)
+#define RCC_MP_AHB2LPENSETR_DMAMUX2LPEN	BIT(4)
+#define RCC_MP_AHB2LPENSETR_ADC1LPEN	BIT(5)
+#define RCC_MP_AHB2LPENSETR_ADC2LPEN	BIT(6)
+#define RCC_MP_AHB2LPENSETR_USBOLPEN	BIT(8)
+
+/* RCC_MP_AHB2LPENCLRR register fields */
+#define RCC_MP_AHB2LPENCLRR_DMA1LPEN	BIT(0)
+#define RCC_MP_AHB2LPENCLRR_DMA2LPEN	BIT(1)
+#define RCC_MP_AHB2LPENCLRR_DMAMUX1LPEN	BIT(2)
+#define RCC_MP_AHB2LPENCLRR_DMA3LPEN	BIT(3)
+#define RCC_MP_AHB2LPENCLRR_DMAMUX2LPEN	BIT(4)
+#define RCC_MP_AHB2LPENCLRR_ADC1LPEN	BIT(5)
+#define RCC_MP_AHB2LPENCLRR_ADC2LPEN	BIT(6)
+#define RCC_MP_AHB2LPENCLRR_USBOLPEN	BIT(8)
+
+/* RCC_MP_AHB4LPENSETR register fields */
+#define RCC_MP_AHB4LPENSETR_TSCLPEN	BIT(15)
+
+/* RCC_MP_AHB4LPENCLRR register fields */
+#define RCC_MP_AHB4LPENCLRR_TSCLPEN	BIT(15)
+
+/* RCC_MP_S_AHB4LPENSETR register fields */
+#define RCC_MP_S_AHB4LPENSETR_GPIOALPEN	BIT(0)
+#define RCC_MP_S_AHB4LPENSETR_GPIOBLPEN	BIT(1)
+#define RCC_MP_S_AHB4LPENSETR_GPIOCLPEN	BIT(2)
+#define RCC_MP_S_AHB4LPENSETR_GPIODLPEN	BIT(3)
+#define RCC_MP_S_AHB4LPENSETR_GPIOELPEN	BIT(4)
+#define RCC_MP_S_AHB4LPENSETR_GPIOFLPEN	BIT(5)
+#define RCC_MP_S_AHB4LPENSETR_GPIOGLPEN	BIT(6)
+#define RCC_MP_S_AHB4LPENSETR_GPIOHLPEN	BIT(7)
+#define RCC_MP_S_AHB4LPENSETR_GPIOILPEN	BIT(8)
+
+/* RCC_MP_S_AHB4LPENCLRR register fields */
+#define RCC_MP_S_AHB4LPENCLRR_GPIOALPEN	BIT(0)
+#define RCC_MP_S_AHB4LPENCLRR_GPIOBLPEN	BIT(1)
+#define RCC_MP_S_AHB4LPENCLRR_GPIOCLPEN	BIT(2)
+#define RCC_MP_S_AHB4LPENCLRR_GPIODLPEN	BIT(3)
+#define RCC_MP_S_AHB4LPENCLRR_GPIOELPEN	BIT(4)
+#define RCC_MP_S_AHB4LPENCLRR_GPIOFLPEN	BIT(5)
+#define RCC_MP_S_AHB4LPENCLRR_GPIOGLPEN	BIT(6)
+#define RCC_MP_S_AHB4LPENCLRR_GPIOHLPEN	BIT(7)
+#define RCC_MP_S_AHB4LPENCLRR_GPIOILPEN	BIT(8)
+
+/* RCC_MP_NS_AHB4LPENSETR register fields */
+#define RCC_MP_NS_AHB4LPENSETR_GPIOALPEN BIT(0)
+#define RCC_MP_NS_AHB4LPENSETR_GPIOBLPEN BIT(1)
+#define RCC_MP_NS_AHB4LPENSETR_GPIOCLPEN BIT(2)
+#define RCC_MP_NS_AHB4LPENSETR_GPIODLPEN BIT(3)
+#define RCC_MP_NS_AHB4LPENSETR_GPIOELPEN BIT(4)
+#define RCC_MP_NS_AHB4LPENSETR_GPIOFLPEN BIT(5)
+#define RCC_MP_NS_AHB4LPENSETR_GPIOGLPEN BIT(6)
+#define RCC_MP_NS_AHB4LPENSETR_GPIOHLPEN BIT(7)
+#define RCC_MP_NS_AHB4LPENSETR_GPIOILPEN BIT(8)
+
+/* RCC_MP_NS_AHB4LPENCLRR register fields */
+#define RCC_MP_NS_AHB4LPENCLRR_GPIOALPEN BIT(0)
+#define RCC_MP_NS_AHB4LPENCLRR_GPIOBLPEN BIT(1)
+#define RCC_MP_NS_AHB4LPENCLRR_GPIOCLPEN BIT(2)
+#define RCC_MP_NS_AHB4LPENCLRR_GPIODLPEN BIT(3)
+#define RCC_MP_NS_AHB4LPENCLRR_GPIOELPEN BIT(4)
+#define RCC_MP_NS_AHB4LPENCLRR_GPIOFLPEN BIT(5)
+#define RCC_MP_NS_AHB4LPENCLRR_GPIOGLPEN BIT(6)
+#define RCC_MP_NS_AHB4LPENCLRR_GPIOHLPEN BIT(7)
+#define RCC_MP_NS_AHB4LPENCLRR_GPIOILPEN BIT(8)
+
+/* RCC_MP_AHB5LPENSETR register fields */
+#define RCC_MP_AHB5LPENSETR_PKALPEN	BIT(2)
+#define RCC_MP_AHB5LPENSETR_SAESLPEN	BIT(3)
+#define RCC_MP_AHB5LPENSETR_CRYP1LPEN	BIT(4)
+#define RCC_MP_AHB5LPENSETR_HASH1LPEN	BIT(5)
+#define RCC_MP_AHB5LPENSETR_RNG1LPEN	BIT(6)
+#define RCC_MP_AHB5LPENSETR_BKPSRAMLPEN	BIT(8)
+
+/* RCC_MP_AHB5LPENCLRR register fields */
+#define RCC_MP_AHB5LPENCLRR_PKALPEN	BIT(2)
+#define RCC_MP_AHB5LPENCLRR_SAESLPEN	BIT(3)
+#define RCC_MP_AHB5LPENCLRR_CRYP1LPEN	BIT(4)
+#define RCC_MP_AHB5LPENCLRR_HASH1LPEN	BIT(5)
+#define RCC_MP_AHB5LPENCLRR_RNG1LPEN	BIT(6)
+#define RCC_MP_AHB5LPENCLRR_BKPSRAMLPEN	BIT(8)
+
+/* RCC_MP_AHB6LPENSETR register fields */
+#define RCC_MP_AHB6LPENSETR_MCELPEN	BIT(1)
+#define RCC_MP_AHB6LPENSETR_ETH1CKLPEN	BIT(7)
+#define RCC_MP_AHB6LPENSETR_ETH1TXLPEN	BIT(8)
+#define RCC_MP_AHB6LPENSETR_ETH1RXLPEN	BIT(9)
+#define RCC_MP_AHB6LPENSETR_ETH1MACLPEN	BIT(10)
+#define RCC_MP_AHB6LPENSETR_ETH1STPEN	BIT(11)
+#define RCC_MP_AHB6LPENSETR_FMCLPEN	BIT(12)
+#define RCC_MP_AHB6LPENSETR_QSPILPEN	BIT(14)
+#define RCC_MP_AHB6LPENSETR_SDMMC1LPEN	BIT(16)
+#define RCC_MP_AHB6LPENSETR_SDMMC2LPEN	BIT(17)
+#define RCC_MP_AHB6LPENSETR_CRC1LPEN	BIT(20)
+#define RCC_MP_AHB6LPENSETR_USBHLPEN	BIT(24)
+#define RCC_MP_AHB6LPENSETR_ETH2CKLPEN	BIT(27)
+#define RCC_MP_AHB6LPENSETR_ETH2TXLPEN	BIT(28)
+#define RCC_MP_AHB6LPENSETR_ETH2RXLPEN	BIT(29)
+#define RCC_MP_AHB6LPENSETR_ETH2MACLPEN	BIT(30)
+#define RCC_MP_AHB6LPENSETR_ETH2STPEN	BIT(31)
+
+/* RCC_MP_AHB6LPENCLRR register fields */
+#define RCC_MP_AHB6LPENCLRR_MCELPEN	BIT(1)
+#define RCC_MP_AHB6LPENCLRR_ETH1CKLPEN	BIT(7)
+#define RCC_MP_AHB6LPENCLRR_ETH1TXLPEN	BIT(8)
+#define RCC_MP_AHB6LPENCLRR_ETH1RXLPEN	BIT(9)
+#define RCC_MP_AHB6LPENCLRR_ETH1MACLPEN	BIT(10)
+#define RCC_MP_AHB6LPENCLRR_ETH1STPEN	BIT(11)
+#define RCC_MP_AHB6LPENCLRR_FMCLPEN	BIT(12)
+#define RCC_MP_AHB6LPENCLRR_QSPILPEN	BIT(14)
+#define RCC_MP_AHB6LPENCLRR_SDMMC1LPEN	BIT(16)
+#define RCC_MP_AHB6LPENCLRR_SDMMC2LPEN	BIT(17)
+#define RCC_MP_AHB6LPENCLRR_CRC1LPEN	BIT(20)
+#define RCC_MP_AHB6LPENCLRR_USBHLPEN	BIT(24)
+#define RCC_MP_AHB6LPENCLRR_ETH2CKLPEN	BIT(27)
+#define RCC_MP_AHB6LPENCLRR_ETH2TXLPEN	BIT(28)
+#define RCC_MP_AHB6LPENCLRR_ETH2RXLPEN	BIT(29)
+#define RCC_MP_AHB6LPENCLRR_ETH2MACLPEN	BIT(30)
+#define RCC_MP_AHB6LPENCLRR_ETH2STPEN	BIT(31)
+
+/* RCC_MP_S_AHB6LPENSETR register fields */
+#define RCC_MP_S_AHB6LPENSETR_MDMALPEN	BIT(0)
+
+/* RCC_MP_S_AHB6LPENCLRR register fields */
+#define RCC_MP_S_AHB6LPENCLRR_MDMALPEN	BIT(0)
+
+/* RCC_MP_NS_AHB6LPENSETR register fields */
+#define RCC_MP_NS_AHB6LPENSETR_MDMALPEN	BIT(0)
+
+/* RCC_MP_NS_AHB6LPENCLRR register fields */
+#define RCC_MP_NS_AHB6LPENCLRR_MDMALPEN	BIT(0)
+
+/* RCC_MP_S_AXIMLPENSETR register fields */
+#define RCC_MP_S_AXIMLPENSETR_SYSRAMLPEN BIT(0)
+
+/* RCC_MP_S_AXIMLPENCLRR register fields */
+#define RCC_MP_S_AXIMLPENCLRR_SYSRAMLPEN BIT(0)
+
+/* RCC_MP_NS_AXIMLPENSETR register fields */
+#define RCC_MP_NS_AXIMLPENSETR_SYSRAMLPEN BIT(0)
+
+/* RCC_MP_NS_AXIMLPENCLRR register fields */
+#define RCC_MP_NS_AXIMLPENCLRR_SYSRAMLPEN BIT(0)
+
+/* RCC_MP_MLAHBLPENSETR register fields */
+#define RCC_MP_MLAHBLPENSETR_SRAM1LPEN	BIT(0)
+#define RCC_MP_MLAHBLPENSETR_SRAM2LPEN	BIT(1)
+#define RCC_MP_MLAHBLPENSETR_SRAM3LPEN	BIT(2)
+
+/* RCC_MP_MLAHBLPENCLRR register fields */
+#define RCC_MP_MLAHBLPENCLRR_SRAM1LPEN	BIT(0)
+#define RCC_MP_MLAHBLPENCLRR_SRAM2LPEN	BIT(1)
+#define RCC_MP_MLAHBLPENCLRR_SRAM3LPEN	BIT(2)
+
+/* RCC_APB3SECSR register fields */
+#define RCC_APB3SECSR_LPTIM2SECF	0
+#define RCC_APB3SECSR_LPTIM3SECF	1
+#define RCC_APB3SECSR_VREFSECF		13
+
+/* RCC_APB4SECSR register fields */
+#define RCC_APB4SECSR_DCMIPPSECF	1
+#define RCC_APB4SECSR_USBPHYSECF	16
+
+/* RCC_APB5SECSR register fields */
+#define RCC_APB5SECSR_RTCSECF		8
+#define RCC_APB5SECSR_TZCSECF		11
+#define RCC_APB5SECSR_ETZPCSECF		13
+#define RCC_APB5SECSR_IWDG1SECF		15
+#define RCC_APB5SECSR_BSECSECF		16
+#define RCC_APB5SECSR_STGENCSECF_MASK	GENMASK(21, 20)
+#define RCC_APB5SECSR_STGENCSECF	20
+#define RCC_APB5SECSR_STGENROSECF	21
+
+/* RCC_APB6SECSR register fields */
+#define RCC_APB6SECSR_USART1SECF        0
+#define RCC_APB6SECSR_USART2SECF	1
+#define RCC_APB6SECSR_SPI4SECF		2
+#define RCC_APB6SECSR_SPI5SECF		3
+#define RCC_APB6SECSR_I2C3SECF		4
+#define RCC_APB6SECSR_I2C4SECF		5
+#define RCC_APB6SECSR_I2C5SECF		6
+#define RCC_APB6SECSR_TIM12SECF		7
+#define RCC_APB6SECSR_TIM13SECF		8
+#define RCC_APB6SECSR_TIM14SECF		9
+#define RCC_APB6SECSR_TIM15SECF		10
+#define RCC_APB6SECSR_TIM16SECF		11
+#define RCC_APB6SECSR_TIM17SECF		12
+
+/* RCC_AHB2SECSR register fields */
+#define RCC_AHB2SECSR_DMA3SECF		3
+#define RCC_AHB2SECSR_DMAMUX2SECF	4
+#define RCC_AHB2SECSR_ADC1SECF		5
+#define RCC_AHB2SECSR_ADC2SECF		6
+#define RCC_AHB2SECSR_USBOSECF		8
+
+/* RCC_AHB4SECSR register fields */
+#define RCC_AHB4SECSR_TSCSECF		15
+
+/* RCC_AHB5SECSR register fields */
+#define RCC_AHB5SECSR_PKASECF		2
+#define RCC_AHB5SECSR_SAESSECF		3
+#define RCC_AHB5SECSR_CRYP1SECF		4
+#define RCC_AHB5SECSR_HASH1SECF		5
+#define RCC_AHB5SECSR_RNG1SECF		6
+#define RCC_AHB5SECSR_BKPSRAMSECF	8
+
+/* RCC_AHB6SECSR register fields */
+#define RCC_AHB6SECSR_MCESECF		1
+#define RCC_AHB6SECSR_FMCSECF		12
+#define RCC_AHB6SECSR_QSPISECF		14
+#define RCC_AHB6SECSR_SDMMC1SECF	16
+#define RCC_AHB6SECSR_SDMMC2SECF	17
+
+#define RCC_AHB6SECSR_ETH1SECF_MASK	GENMASK(11, 7)
+#define RCC_AHB6SECSR_ETH2SECF_MASK	GENMASK(31, 27)
+#define RCC_AHB6SECSR_ETH1SECF_SHIFT	7
+#define RCC_AHB6SECSR_ETH2SECF_SHIFT	27
+
+#define RCC_AHB6SECSR_ETH1CKSECF	7
+#define RCC_AHB6SECSR_ETH1TXSECF	8
+#define RCC_AHB6SECSR_ETH1RXSECF	9
+#define RCC_AHB6SECSR_ETH1MACSECF	10
+#define RCC_AHB6SECSR_ETH1STPSECF	11
+
+#define RCC_AHB6SECSR_ETH2CKSECF	27
+#define RCC_AHB6SECSR_ETH2TXSECF	28
+#define RCC_AHB6SECSR_ETH2RXSECF	29
+#define RCC_AHB6SECSR_ETH2MACSECF	30
+#define RCC_AHB6SECSR_ETH2STPSECF	31
+
+/* RCC_VERR register fields */
+#define RCC_VERR_MINREV_MASK		GENMASK(3, 0)
+#define RCC_VERR_MAJREV_MASK		GENMASK(7, 4)
+#define RCC_VERR_MINREV_SHIFT		0
+#define RCC_VERR_MAJREV_SHIFT		4
+
+/* RCC_IDR register fields */
+#define RCC_IDR_ID_MASK			GENMASK(31, 0)
+#define RCC_IDR_ID_SHIFT		0
+
+/* RCC_SIDR register fields */
+#define RCC_SIDR_SID_MASK		GENMASK(31, 0)
+#define RCC_SIDR_SID_SHIFT		0
+
+#endif /* STM32MP13_RCC_H */
+
diff --git a/drivers/clk/stm32/stm32mp2_rcc.h b/drivers/clk/stm32/stm32mp2_rcc.h
new file mode 100644
index 000000000..12d3420ee
--- /dev/null
+++ b/drivers/clk/stm32/stm32mp2_rcc.h
@@ -0,0 +1,4983 @@
+/*
+ * Copyright (c) 2018-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_RCC_H
+#define STM32MP2_RCC_H
+
+#define RCC_SECCFGR0				0x0
+#define RCC_SECCFGR1				0x4
+#define RCC_SECCFGR2				0x8
+#define RCC_SECCFGR3				0xC
+#define RCC_PRIVCFGR0				0x10
+#define RCC_PRIVCFGR1				0x14
+#define RCC_PRIVCFGR2				0x18
+#define RCC_PRIVCFGR3				0x1C
+#define RCC_RCFGLOCKR0				0x20
+#define RCC_RCFGLOCKR1				0x24
+#define RCC_RCFGLOCKR2				0x28
+#define RCC_RCFGLOCKR3				0x2C
+#define RCC_R0CIDCFGR				0x30
+#define RCC_R0SEMCR				0x34
+#define RCC_R1CIDCFGR				0x38
+#define RCC_R1SEMCR				0x3C
+#define RCC_R2CIDCFGR				0x40
+#define RCC_R2SEMCR				0x44
+#define RCC_R3CIDCFGR				0x48
+#define RCC_R3SEMCR				0x4C
+#define RCC_R4CIDCFGR				0x50
+#define RCC_R4SEMCR				0x54
+#define RCC_R5CIDCFGR				0x58
+#define RCC_R5SEMCR				0x5C
+#define RCC_R6CIDCFGR				0x60
+#define RCC_R6SEMCR				0x64
+#define RCC_R7CIDCFGR				0x68
+#define RCC_R7SEMCR				0x6C
+#define RCC_R8CIDCFGR				0x70
+#define RCC_R8SEMCR				0x74
+#define RCC_R9CIDCFGR				0x78
+#define RCC_R9SEMCR				0x7C
+#define RCC_R10CIDCFGR				0x80
+#define RCC_R10SEMCR				0x84
+#define RCC_R11CIDCFGR				0x88
+#define RCC_R11SEMCR				0x8C
+#define RCC_R12CIDCFGR				0x90
+#define RCC_R12SEMCR				0x94
+#define RCC_R13CIDCFGR				0x98
+#define RCC_R13SEMCR				0x9C
+#define RCC_R14CIDCFGR				0xA0
+#define RCC_R14SEMCR				0xA4
+#define RCC_R15CIDCFGR				0xA8
+#define RCC_R15SEMCR				0xAC
+#define RCC_R16CIDCFGR				0xB0
+#define RCC_R16SEMCR				0xB4
+#define RCC_R17CIDCFGR				0xB8
+#define RCC_R17SEMCR				0xBC
+#define RCC_R18CIDCFGR				0xC0
+#define RCC_R18SEMCR				0xC4
+#define RCC_R19CIDCFGR				0xC8
+#define RCC_R19SEMCR				0xCC
+#define RCC_R20CIDCFGR				0xD0
+#define RCC_R20SEMCR				0xD4
+#define RCC_R21CIDCFGR				0xD8
+#define RCC_R21SEMCR				0xDC
+#define RCC_R22CIDCFGR				0xE0
+#define RCC_R22SEMCR				0xE4
+#define RCC_R23CIDCFGR				0xE8
+#define RCC_R23SEMCR				0xEC
+#define RCC_R24CIDCFGR				0xF0
+#define RCC_R24SEMCR				0xF4
+#define RCC_R25CIDCFGR				0xF8
+#define RCC_R25SEMCR				0xFC
+#define RCC_R26CIDCFGR				0x100
+#define RCC_R26SEMCR				0x104
+#define RCC_R27CIDCFGR				0x108
+#define RCC_R27SEMCR				0x10C
+#define RCC_R28CIDCFGR				0x110
+#define RCC_R28SEMCR				0x114
+#define RCC_R29CIDCFGR				0x118
+#define RCC_R29SEMCR				0x11C
+#define RCC_R30CIDCFGR				0x120
+#define RCC_R30SEMCR				0x124
+#define RCC_R31CIDCFGR				0x128
+#define RCC_R31SEMCR				0x12C
+#define RCC_R32CIDCFGR				0x130
+#define RCC_R32SEMCR				0x134
+#define RCC_R33CIDCFGR				0x138
+#define RCC_R33SEMCR				0x13C
+#define RCC_R34CIDCFGR				0x140
+#define RCC_R34SEMCR				0x144
+#define RCC_R35CIDCFGR				0x148
+#define RCC_R35SEMCR				0x14C
+#define RCC_R36CIDCFGR				0x150
+#define RCC_R36SEMCR				0x154
+#define RCC_R37CIDCFGR				0x158
+#define RCC_R37SEMCR				0x15C
+#define RCC_R38CIDCFGR				0x160
+#define RCC_R38SEMCR				0x164
+#define RCC_R39CIDCFGR				0x168
+#define RCC_R39SEMCR				0x16C
+#define RCC_R40CIDCFGR				0x170
+#define RCC_R40SEMCR				0x174
+#define RCC_R41CIDCFGR				0x178
+#define RCC_R41SEMCR				0x17C
+#define RCC_R42CIDCFGR				0x180
+#define RCC_R42SEMCR				0x184
+#define RCC_R43CIDCFGR				0x188
+#define RCC_R43SEMCR				0x18C
+#define RCC_R44CIDCFGR				0x190
+#define RCC_R44SEMCR				0x194
+#define RCC_R45CIDCFGR				0x198
+#define RCC_R45SEMCR				0x19C
+#define RCC_R46CIDCFGR				0x1A0
+#define RCC_R46SEMCR				0x1A4
+#define RCC_R47CIDCFGR				0x1A8
+#define RCC_R47SEMCR				0x1AC
+#define RCC_R48CIDCFGR				0x1B0
+#define RCC_R48SEMCR				0x1B4
+#define RCC_R49CIDCFGR				0x1B8
+#define RCC_R49SEMCR				0x1BC
+#define RCC_R50CIDCFGR				0x1C0
+#define RCC_R50SEMCR				0x1C4
+#define RCC_R51CIDCFGR				0x1C8
+#define RCC_R51SEMCR				0x1CC
+#define RCC_R52CIDCFGR				0x1D0
+#define RCC_R52SEMCR				0x1D4
+#define RCC_R53CIDCFGR				0x1D8
+#define RCC_R53SEMCR				0x1DC
+#define RCC_R54CIDCFGR				0x1E0
+#define RCC_R54SEMCR				0x1E4
+#define RCC_R55CIDCFGR				0x1E8
+#define RCC_R55SEMCR				0x1EC
+#define RCC_R56CIDCFGR				0x1F0
+#define RCC_R56SEMCR				0x1F4
+#define RCC_R57CIDCFGR				0x1F8
+#define RCC_R57SEMCR				0x1FC
+#define RCC_R58CIDCFGR				0x200
+#define RCC_R58SEMCR				0x204
+#define RCC_R59CIDCFGR				0x208
+#define RCC_R59SEMCR				0x20C
+#define RCC_R60CIDCFGR				0x210
+#define RCC_R60SEMCR				0x214
+#define RCC_R61CIDCFGR				0x218
+#define RCC_R61SEMCR				0x21C
+#define RCC_R62CIDCFGR				0x220
+#define RCC_R62SEMCR				0x224
+#define RCC_R63CIDCFGR				0x228
+#define RCC_R63SEMCR				0x22C
+#define RCC_R64CIDCFGR				0x230
+#define RCC_R64SEMCR				0x234
+#define RCC_R65CIDCFGR				0x238
+#define RCC_R65SEMCR				0x23C
+#define RCC_R66CIDCFGR				0x240
+#define RCC_R66SEMCR				0x244
+#define RCC_R67CIDCFGR				0x248
+#define RCC_R67SEMCR				0x24C
+#define RCC_R68CIDCFGR				0x250
+#define RCC_R68SEMCR				0x254
+#define RCC_R69CIDCFGR				0x258
+#define RCC_R69SEMCR				0x25C
+#define RCC_R70CIDCFGR				0x260
+#define RCC_R70SEMCR				0x264
+#define RCC_R71CIDCFGR				0x268
+#define RCC_R71SEMCR				0x26C
+#define RCC_R72CIDCFGR				0x270
+#define RCC_R72SEMCR				0x274
+#define RCC_R73CIDCFGR				0x278
+#define RCC_R73SEMCR				0x27C
+#define RCC_R74CIDCFGR				0x280
+#define RCC_R74SEMCR				0x284
+#define RCC_R75CIDCFGR				0x288
+#define RCC_R75SEMCR				0x28C
+#define RCC_R76CIDCFGR				0x290
+#define RCC_R76SEMCR				0x294
+#define RCC_R77CIDCFGR				0x298
+#define RCC_R77SEMCR				0x29C
+#define RCC_R78CIDCFGR				0x2A0
+#define RCC_R78SEMCR				0x2A4
+#define RCC_R79CIDCFGR				0x2A8
+#define RCC_R79SEMCR				0x2AC
+#define RCC_R80CIDCFGR				0x2B0
+#define RCC_R80SEMCR				0x2B4
+#define RCC_R81CIDCFGR				0x2B8
+#define RCC_R81SEMCR				0x2BC
+#define RCC_R82CIDCFGR				0x2C0
+#define RCC_R82SEMCR				0x2C4
+#define RCC_R83CIDCFGR				0x2C8
+#define RCC_R83SEMCR				0x2CC
+#define RCC_R84CIDCFGR				0x2D0
+#define RCC_R84SEMCR				0x2D4
+#define RCC_R85CIDCFGR				0x2D8
+#define RCC_R85SEMCR				0x2DC
+#define RCC_R86CIDCFGR				0x2E0
+#define RCC_R86SEMCR				0x2E4
+#define RCC_R87CIDCFGR				0x2E8
+#define RCC_R87SEMCR				0x2EC
+#define RCC_R88CIDCFGR				0x2F0
+#define RCC_R88SEMCR				0x2F4
+#define RCC_R89CIDCFGR				0x2F8
+#define RCC_R89SEMCR				0x2FC
+#define RCC_R90CIDCFGR				0x300
+#define RCC_R90SEMCR				0x304
+#define RCC_R91CIDCFGR				0x308
+#define RCC_R91SEMCR				0x30C
+#define RCC_R92CIDCFGR				0x310
+#define RCC_R92SEMCR				0x314
+#define RCC_R93CIDCFGR				0x318
+#define RCC_R93SEMCR				0x31C
+#define RCC_R94CIDCFGR				0x320
+#define RCC_R94SEMCR				0x324
+#define RCC_R95CIDCFGR				0x328
+#define RCC_R95SEMCR				0x32C
+#define RCC_R96CIDCFGR				0x330
+#define RCC_R96SEMCR				0x334
+#define RCC_R97CIDCFGR				0x338
+#define RCC_R97SEMCR				0x33C
+#define RCC_R98CIDCFGR				0x340
+#define RCC_R98SEMCR				0x344
+#define RCC_R99CIDCFGR				0x348
+#define RCC_R99SEMCR				0x34C
+#define RCC_R100CIDCFGR				0x350
+#define RCC_R100SEMCR				0x354
+#define RCC_R101CIDCFGR				0x358
+#define RCC_R101SEMCR				0x35C
+#define RCC_R102CIDCFGR				0x360
+#define RCC_R102SEMCR				0x364
+#define RCC_R103CIDCFGR				0x368
+#define RCC_R103SEMCR				0x36C
+#define RCC_R104CIDCFGR				0x370
+#define RCC_R104SEMCR				0x374
+#define RCC_R105CIDCFGR				0x378
+#define RCC_R105SEMCR				0x37C
+#define RCC_R106CIDCFGR				0x380
+#define RCC_R106SEMCR				0x384
+#define RCC_R107CIDCFGR				0x388
+#define RCC_R107SEMCR				0x38C
+#define RCC_R108CIDCFGR				0x390
+#define RCC_R108SEMCR				0x394
+#define RCC_R109CIDCFGR				0x398
+#define RCC_R109SEMCR				0x39C
+#define RCC_R110CIDCFGR				0x3A0
+#define RCC_R110SEMCR				0x3A4
+#define RCC_R111CIDCFGR				0x3A8
+#define RCC_R111SEMCR				0x3AC
+#define RCC_R112CIDCFGR				0x3B0
+#define RCC_R112SEMCR				0x3B4
+#define RCC_R113CIDCFGR				0x3B8
+#define RCC_R113SEMCR				0x3BC
+#define RCC_GRSTCSETR				0x400
+#define RCC_C1RSTCSETR				0x404
+#define RCC_C1P1RSTCSETR			0x408
+#define RCC_C2RSTCSETR				0x40C
+#define RCC_HWRSTSCLRR				0x410
+#define RCC_C1HWRSTSCLRR			0x414
+#define RCC_C2HWRSTSCLRR			0x418
+#define RCC_C1BOOTRSTSSETR			0x41C
+#define RCC_C1BOOTRSTSCLRR			0x420
+#define RCC_C2BOOTRSTSSETR			0x424
+#define RCC_C2BOOTRSTSCLRR			0x428
+#define RCC_C1SREQSETR				0x42C
+#define RCC_C1SREQCLRR				0x430
+#define RCC_CPUBOOTCR				0x434
+#define RCC_STBYBOOTCR				0x438
+#define RCC_LEGBOOTCR				0x43C
+#define RCC_BDCR				0x440
+#define RCC_D3DCR				0x444
+#define RCC_D3DSR				0x448
+#define RCC_RDCR				0x44C
+#define RCC_C1MSRDCR				0x450
+#define RCC_PWRLPDLYCR				0x454
+#define RCC_C1CIESETR				0x458
+#define RCC_C1CIFCLRR				0x45C
+#define RCC_C2CIESETR				0x460
+#define RCC_C2CIFCLRR				0x464
+#define RCC_IWDGC1FZSETR			0x468
+#define RCC_IWDGC1FZCLRR			0x46C
+#define RCC_IWDGC1CFGSETR			0x470
+#define RCC_IWDGC1CFGCLRR			0x474
+#define RCC_IWDGC2FZSETR			0x478
+#define RCC_IWDGC2FZCLRR			0x47C
+#define RCC_IWDGC2CFGSETR			0x480
+#define RCC_IWDGC2CFGCLRR			0x484
+#define RCC_IWDGC3CFGSETR			0x488
+#define RCC_IWDGC3CFGCLRR			0x48C
+#define RCC_C3CFGR				0x490
+#define RCC_MCO1CFGR				0x494
+#define RCC_MCO2CFGR				0x498
+#define RCC_OCENSETR				0x49C
+#define RCC_OCENCLRR				0x4A0
+#define RCC_OCRDYR				0x4A4
+#define RCC_HSICFGR				0x4A8
+#define RCC_MSICFGR				0x4AC
+#define RCC_RTCDIVR				0x4B0
+#define RCC_APB1DIVR				0x4B4
+#define RCC_APB2DIVR				0x4B8
+#define RCC_APB3DIVR				0x4BC
+#define RCC_APB4DIVR				0x4C0
+#define RCC_APBDBGDIVR				0x4C4
+#define RCC_TIMG1PRER				0x4C8
+#define RCC_TIMG2PRER				0x4CC
+#define RCC_LSMCUDIVR				0x4D0
+#define RCC_DDRCPCFGR				0x4D4
+#define RCC_DDRCAPBCFGR				0x4D8
+#define RCC_DDRPHYCAPBCFGR			0x4DC
+#define RCC_DDRPHYCCFGR				0x4E0
+#define RCC_DDRCFGR				0x4E4
+#define RCC_DDRITFCFGR				0x4E8
+#define RCC_SYSRAMCFGR				0x4F0
+#define RCC_VDERAMCFGR				0x4F4
+#define RCC_SRAM1CFGR				0x4F8
+#define RCC_SRAM2CFGR				0x4FC
+#define RCC_RETRAMCFGR				0x500
+#define RCC_BKPSRAMCFGR				0x504
+#define RCC_LPSRAM1CFGR				0x508
+#define RCC_LPSRAM2CFGR				0x50C
+#define RCC_LPSRAM3CFGR				0x510
+#define RCC_OSPI1CFGR				0x514
+#define RCC_OSPI2CFGR				0x518
+#define RCC_FMCCFGR				0x51C
+#define RCC_DBGCFGR				0x520
+#define RCC_STM500CFGR				0x524
+#define RCC_ETRCFGR				0x528
+#define RCC_GPIOACFGR				0x52C
+#define RCC_GPIOBCFGR				0x530
+#define RCC_GPIOCCFGR				0x534
+#define RCC_GPIODCFGR				0x538
+#define RCC_GPIOECFGR				0x53C
+#define RCC_GPIOFCFGR				0x540
+#define RCC_GPIOGCFGR				0x544
+#define RCC_GPIOHCFGR				0x548
+#define RCC_GPIOICFGR				0x54C
+#define RCC_GPIOJCFGR				0x550
+#define RCC_GPIOKCFGR				0x554
+#define RCC_GPIOZCFGR				0x558
+#define RCC_HPDMA1CFGR				0x55C
+#define RCC_HPDMA2CFGR				0x560
+#define RCC_HPDMA3CFGR				0x564
+#define RCC_LPDMACFGR				0x568
+#define RCC_HSEMCFGR				0x56C
+#define RCC_IPCC1CFGR				0x570
+#define RCC_IPCC2CFGR				0x574
+#define RCC_RTCCFGR				0x578
+#define RCC_SYSCPU1CFGR				0x580
+#define RCC_BSECCFGR				0x584
+#define RCC_IS2MCFGR				0x58C
+#define RCC_PLL2CFGR1				0x590
+#define RCC_PLL2CFGR2				0x594
+#define RCC_PLL2CFGR3				0x598
+#define RCC_PLL2CFGR4				0x59C
+#define RCC_PLL2CFGR5				0x5A0
+#define RCC_PLL2CFGR6				0x5A8
+#define RCC_PLL2CFGR7				0x5AC
+#define RCC_PLL3CFGR1				0x5B8
+#define RCC_PLL3CFGR2				0x5BC
+#define RCC_PLL3CFGR3				0x5C0
+#define RCC_PLL3CFGR4				0x5C4
+#define RCC_PLL3CFGR5				0x5C8
+#define RCC_PLL3CFGR6				0x5D0
+#define RCC_PLL3CFGR7				0x5D4
+#define RCC_HSIFMONCR				0x5E0
+#define RCC_HSIFVALR				0x5E4
+#define RCC_TIM1CFGR				0x700
+#define RCC_TIM2CFGR				0x704
+#define RCC_TIM3CFGR				0x708
+#define RCC_TIM4CFGR				0x70C
+#define RCC_TIM5CFGR				0x710
+#define RCC_TIM6CFGR				0x714
+#define RCC_TIM7CFGR				0x718
+#define RCC_TIM8CFGR				0x71C
+#define RCC_TIM10CFGR				0x720
+#define RCC_TIM11CFGR				0x724
+#define RCC_TIM12CFGR				0x728
+#define RCC_TIM13CFGR				0x72C
+#define RCC_TIM14CFGR				0x730
+#define RCC_TIM15CFGR				0x734
+#define RCC_TIM16CFGR				0x738
+#define RCC_TIM17CFGR				0x73C
+#define RCC_TIM20CFGR				0x740
+#define RCC_LPTIM1CFGR				0x744
+#define RCC_LPTIM2CFGR				0x748
+#define RCC_LPTIM3CFGR				0x74C
+#define RCC_LPTIM4CFGR				0x750
+#define RCC_LPTIM5CFGR				0x754
+#define RCC_SPI1CFGR				0x758
+#define RCC_SPI2CFGR				0x75C
+#define RCC_SPI3CFGR				0x760
+#define RCC_SPI4CFGR				0x764
+#define RCC_SPI5CFGR				0x768
+#define RCC_SPI6CFGR				0x76C
+#define RCC_SPI7CFGR				0x770
+#define RCC_SPI8CFGR				0x774
+#define RCC_SPDIFRXCFGR				0x778
+#define RCC_USART1CFGR				0x77C
+#define RCC_USART2CFGR				0x780
+#define RCC_USART3CFGR				0x784
+#define RCC_UART4CFGR				0x788
+#define RCC_UART5CFGR				0x78C
+#define RCC_USART6CFGR				0x790
+#define RCC_UART7CFGR				0x794
+#define RCC_UART8CFGR				0x798
+#define RCC_UART9CFGR				0x79C
+#define RCC_LPUART1CFGR				0x7A0
+#define RCC_I2C1CFGR				0x7A4
+#define RCC_I2C2CFGR				0x7A8
+#define RCC_I2C3CFGR				0x7AC
+#define RCC_I2C4CFGR				0x7B0
+#define RCC_I2C5CFGR				0x7B4
+#define RCC_I2C6CFGR				0x7B8
+#define RCC_I2C7CFGR				0x7BC
+#define RCC_I2C8CFGR				0x7C0
+#define RCC_SAI1CFGR				0x7C4
+#define RCC_SAI2CFGR				0x7C8
+#define RCC_SAI3CFGR				0x7CC
+#define RCC_SAI4CFGR				0x7D0
+#define RCC_MDF1CFGR				0x7D8
+#define RCC_ADF1CFGR				0x7DC
+#define RCC_FDCANCFGR				0x7E0
+#define RCC_HDPCFGR				0x7E4
+#define RCC_ADC12CFGR				0x7E8
+#define RCC_ADC3CFGR				0x7EC
+#define RCC_ETH1CFGR				0x7F0
+#define RCC_ETH2CFGR				0x7F4
+#define RCC_USB2CFGR				0x7FC
+#define RCC_USB2PHY1CFGR			0x800
+#define RCC_USB2PHY2CFGR			0x804
+#define RCC_USB3DRDCFGR				0x808
+#define RCC_USB3PCIEPHYCFGR			0x80C
+#define RCC_PCIECFGR				0x810
+#define RCC_USBTCCFGR				0x814
+#define RCC_ETHSWCFGR				0x818
+#define RCC_ETHSWACMCFGR			0x81C
+#define RCC_ETHSWACMMSGCFGR			0x820
+#define RCC_STGENCFGR				0x824
+#define RCC_SDMMC1CFGR				0x830
+#define RCC_SDMMC2CFGR				0x834
+#define RCC_SDMMC3CFGR				0x838
+#define RCC_GPUCFGR				0x83C
+#define RCC_LTDCCFGR				0x840
+#define RCC_DSICFGR				0x844
+#define RCC_LVDSCFGR				0x850
+#define RCC_CSICFGR				0x858
+#define RCC_DCMIPPCFGR				0x85C
+#define RCC_CCICFGR				0x860
+#define RCC_VDECCFGR				0x864
+#define RCC_VENCCFGR				0x868
+#define RCC_RNGCFGR				0x870
+#define RCC_PKACFGR				0x874
+#define RCC_SAESCFGR				0x878
+#define RCC_HASHCFGR				0x87C
+#define RCC_CRYP1CFGR				0x880
+#define RCC_CRYP2CFGR				0x884
+#define RCC_IWDG1CFGR				0x888
+#define RCC_IWDG2CFGR				0x88C
+#define RCC_IWDG3CFGR				0x890
+#define RCC_IWDG4CFGR				0x894
+#define RCC_IWDG5CFGR				0x898
+#define RCC_WWDG1CFGR				0x89C
+#define RCC_WWDG2CFGR				0x8A0
+#define RCC_BUSPERFMCFGR			0x8A4
+#define RCC_VREFCFGR				0x8A8
+#define RCC_DTSCFGR				0x8AC
+#define RCC_CRCCFGR				0x8B4
+#define RCC_SERCCFGR				0x8B8
+#define RCC_OSPIIOMCFGR				0x8BC
+#define RCC_GICV2MCFGR				0x8C0
+#define RCC_I3C1CFGR				0x8C8
+#define RCC_I3C2CFGR				0x8CC
+#define RCC_I3C3CFGR				0x8D0
+#define RCC_I3C4CFGR				0x8D4
+#define RCC_MUXSELCFGR				0x1000
+#define RCC_XBAR0CFGR				0x1018
+#define RCC_XBAR1CFGR				0x101C
+#define RCC_XBAR2CFGR				0x1020
+#define RCC_XBAR3CFGR				0x1024
+#define RCC_XBAR4CFGR				0x1028
+#define RCC_XBAR5CFGR				0x102C
+#define RCC_XBAR6CFGR				0x1030
+#define RCC_XBAR7CFGR				0x1034
+#define RCC_XBAR8CFGR				0x1038
+#define RCC_XBAR9CFGR				0x103C
+#define RCC_XBAR10CFGR				0x1040
+#define RCC_XBAR11CFGR				0x1044
+#define RCC_XBAR12CFGR				0x1048
+#define RCC_XBAR13CFGR				0x104C
+#define RCC_XBAR14CFGR				0x1050
+#define RCC_XBAR15CFGR				0x1054
+#define RCC_XBAR16CFGR				0x1058
+#define RCC_XBAR17CFGR				0x105C
+#define RCC_XBAR18CFGR				0x1060
+#define RCC_XBAR19CFGR				0x1064
+#define RCC_XBAR20CFGR				0x1068
+#define RCC_XBAR21CFGR				0x106C
+#define RCC_XBAR22CFGR				0x1070
+#define RCC_XBAR23CFGR				0x1074
+#define RCC_XBAR24CFGR				0x1078
+#define RCC_XBAR25CFGR				0x107C
+#define RCC_XBAR26CFGR				0x1080
+#define RCC_XBAR27CFGR				0x1084
+#define RCC_XBAR28CFGR				0x1088
+#define RCC_XBAR29CFGR				0x108C
+#define RCC_XBAR30CFGR				0x1090
+#define RCC_XBAR31CFGR				0x1094
+#define RCC_XBAR32CFGR				0x1098
+#define RCC_XBAR33CFGR				0x109C
+#define RCC_XBAR34CFGR				0x10A0
+#define RCC_XBAR35CFGR				0x10A4
+#define RCC_XBAR36CFGR				0x10A8
+#define RCC_XBAR37CFGR				0x10AC
+#define RCC_XBAR38CFGR				0x10B0
+#define RCC_XBAR39CFGR				0x10B4
+#define RCC_XBAR40CFGR				0x10B8
+#define RCC_XBAR41CFGR				0x10BC
+#define RCC_XBAR42CFGR				0x10C0
+#define RCC_XBAR43CFGR				0x10C4
+#define RCC_XBAR44CFGR				0x10C8
+#define RCC_XBAR45CFGR				0x10CC
+#define RCC_XBAR46CFGR				0x10D0
+#define RCC_XBAR47CFGR				0x10D4
+#define RCC_XBAR48CFGR				0x10D8
+#define RCC_XBAR49CFGR				0x10DC
+#define RCC_XBAR50CFGR				0x10E0
+#define RCC_XBAR51CFGR				0x10E4
+#define RCC_XBAR52CFGR				0x10E8
+#define RCC_XBAR53CFGR				0x10EC
+#define RCC_XBAR54CFGR				0x10F0
+#define RCC_XBAR55CFGR				0x10F4
+#define RCC_XBAR56CFGR				0x10F8
+#define RCC_XBAR57CFGR				0x10FC
+#define RCC_XBAR58CFGR				0x1100
+#define RCC_XBAR59CFGR				0x1104
+#define RCC_XBAR60CFGR				0x1108
+#define RCC_XBAR61CFGR				0x110C
+#define RCC_XBAR62CFGR				0x1110
+#define RCC_XBAR63CFGR				0x1114
+#define RCC_PREDIV0CFGR				0x1118
+#define RCC_PREDIV1CFGR				0x111C
+#define RCC_PREDIV2CFGR				0x1120
+#define RCC_PREDIV3CFGR				0x1124
+#define RCC_PREDIV4CFGR				0x1128
+#define RCC_PREDIV5CFGR				0x112C
+#define RCC_PREDIV6CFGR				0x1130
+#define RCC_PREDIV7CFGR				0x1134
+#define RCC_PREDIV8CFGR				0x1138
+#define RCC_PREDIV9CFGR				0x113C
+#define RCC_PREDIV10CFGR			0x1140
+#define RCC_PREDIV11CFGR			0x1144
+#define RCC_PREDIV12CFGR			0x1148
+#define RCC_PREDIV13CFGR			0x114C
+#define RCC_PREDIV14CFGR			0x1150
+#define RCC_PREDIV15CFGR			0x1154
+#define RCC_PREDIV16CFGR			0x1158
+#define RCC_PREDIV17CFGR			0x115C
+#define RCC_PREDIV18CFGR			0x1160
+#define RCC_PREDIV19CFGR			0x1164
+#define RCC_PREDIV20CFGR			0x1168
+#define RCC_PREDIV21CFGR			0x116C
+#define RCC_PREDIV22CFGR			0x1170
+#define RCC_PREDIV23CFGR			0x1174
+#define RCC_PREDIV24CFGR			0x1178
+#define RCC_PREDIV25CFGR			0x117C
+#define RCC_PREDIV26CFGR			0x1180
+#define RCC_PREDIV27CFGR			0x1184
+#define RCC_PREDIV28CFGR			0x1188
+#define RCC_PREDIV29CFGR			0x118C
+#define RCC_PREDIV30CFGR			0x1190
+#define RCC_PREDIV31CFGR			0x1194
+#define RCC_PREDIV32CFGR			0x1198
+#define RCC_PREDIV33CFGR			0x119C
+#define RCC_PREDIV34CFGR			0x11A0
+#define RCC_PREDIV35CFGR			0x11A4
+#define RCC_PREDIV36CFGR			0x11A8
+#define RCC_PREDIV37CFGR			0x11AC
+#define RCC_PREDIV38CFGR			0x11B0
+#define RCC_PREDIV39CFGR			0x11B4
+#define RCC_PREDIV40CFGR			0x11B8
+#define RCC_PREDIV41CFGR			0x11BC
+#define RCC_PREDIV42CFGR			0x11C0
+#define RCC_PREDIV43CFGR			0x11C4
+#define RCC_PREDIV44CFGR			0x11C8
+#define RCC_PREDIV45CFGR			0x11CC
+#define RCC_PREDIV46CFGR			0x11D0
+#define RCC_PREDIV47CFGR			0x11D4
+#define RCC_PREDIV48CFGR			0x11D8
+#define RCC_PREDIV49CFGR			0x11DC
+#define RCC_PREDIV50CFGR			0x11E0
+#define RCC_PREDIV51CFGR			0x11E4
+#define RCC_PREDIV52CFGR			0x11E8
+#define RCC_PREDIV53CFGR			0x11EC
+#define RCC_PREDIV54CFGR			0x11F0
+#define RCC_PREDIV55CFGR			0x11F4
+#define RCC_PREDIV56CFGR			0x11F8
+#define RCC_PREDIV57CFGR			0x11FC
+#define RCC_PREDIV58CFGR			0x1200
+#define RCC_PREDIV59CFGR			0x1204
+#define RCC_PREDIV60CFGR			0x1208
+#define RCC_PREDIV61CFGR			0x120C
+#define RCC_PREDIV62CFGR			0x1210
+#define RCC_PREDIV63CFGR			0x1214
+#define RCC_PREDIVSR1				0x1218
+#define RCC_PREDIVSR2				0x121C
+#define RCC_FINDIV0CFGR				0x1224
+#define RCC_FINDIV1CFGR				0x1228
+#define RCC_FINDIV2CFGR				0x122C
+#define RCC_FINDIV3CFGR				0x1230
+#define RCC_FINDIV4CFGR				0x1234
+#define RCC_FINDIV5CFGR				0x1238
+#define RCC_FINDIV6CFGR				0x123C
+#define RCC_FINDIV7CFGR				0x1240
+#define RCC_FINDIV8CFGR				0x1244
+#define RCC_FINDIV9CFGR				0x1248
+#define RCC_FINDIV10CFGR			0x124C
+#define RCC_FINDIV11CFGR			0x1250
+#define RCC_FINDIV12CFGR			0x1254
+#define RCC_FINDIV13CFGR			0x1258
+#define RCC_FINDIV14CFGR			0x125C
+#define RCC_FINDIV15CFGR			0x1260
+#define RCC_FINDIV16CFGR			0x1264
+#define RCC_FINDIV17CFGR			0x1268
+#define RCC_FINDIV18CFGR			0x126C
+#define RCC_FINDIV19CFGR			0x1270
+#define RCC_FINDIV20CFGR			0x1274
+#define RCC_FINDIV21CFGR			0x1278
+#define RCC_FINDIV22CFGR			0x127C
+#define RCC_FINDIV23CFGR			0x1280
+#define RCC_FINDIV24CFGR			0x1284
+#define RCC_FINDIV25CFGR			0x1288
+#define RCC_FINDIV26CFGR			0x128C
+#define RCC_FINDIV27CFGR			0x1290
+#define RCC_FINDIV28CFGR			0x1294
+#define RCC_FINDIV29CFGR			0x1298
+#define RCC_FINDIV30CFGR			0x129C
+#define RCC_FINDIV31CFGR			0x12A0
+#define RCC_FINDIV32CFGR			0x12A4
+#define RCC_FINDIV33CFGR			0x12A8
+#define RCC_FINDIV34CFGR			0x12AC
+#define RCC_FINDIV35CFGR			0x12B0
+#define RCC_FINDIV36CFGR			0x12B4
+#define RCC_FINDIV37CFGR			0x12B8
+#define RCC_FINDIV38CFGR			0x12BC
+#define RCC_FINDIV39CFGR			0x12C0
+#define RCC_FINDIV40CFGR			0x12C4
+#define RCC_FINDIV41CFGR			0x12C8
+#define RCC_FINDIV42CFGR			0x12CC
+#define RCC_FINDIV43CFGR			0x12D0
+#define RCC_FINDIV44CFGR			0x12D4
+#define RCC_FINDIV45CFGR			0x12D8
+#define RCC_FINDIV46CFGR			0x12DC
+#define RCC_FINDIV47CFGR			0x12E0
+#define RCC_FINDIV48CFGR			0x12E4
+#define RCC_FINDIV49CFGR			0x12E8
+#define RCC_FINDIV50CFGR			0x12EC
+#define RCC_FINDIV51CFGR			0x12F0
+#define RCC_FINDIV52CFGR			0x12F4
+#define RCC_FINDIV53CFGR			0x12F8
+#define RCC_FINDIV54CFGR			0x12FC
+#define RCC_FINDIV55CFGR			0x1300
+#define RCC_FINDIV56CFGR			0x1304
+#define RCC_FINDIV57CFGR			0x1308
+#define RCC_FINDIV58CFGR			0x130C
+#define RCC_FINDIV59CFGR			0x1310
+#define RCC_FINDIV60CFGR			0x1314
+#define RCC_FINDIV61CFGR			0x1318
+#define RCC_FINDIV62CFGR			0x131C
+#define RCC_FINDIV63CFGR			0x1320
+#define RCC_FINDIVSR1				0x1324
+#define RCC_FINDIVSR2				0x1328
+#define RCC_FCALCOBS0CFGR			0x1340
+#define RCC_FCALCOBS1CFGR			0x1344
+#define RCC_FCALCREFCFGR			0x1348
+#define RCC_FCALCCR1				0x134C
+#define RCC_FCALCCR2				0x1354
+#define RCC_FCALCSR				0x1358
+#define RCC_PLL4CFGR1				0x1360
+#define RCC_PLL4CFGR2				0x1364
+#define RCC_PLL4CFGR3				0x1368
+#define RCC_PLL4CFGR4				0x136C
+#define RCC_PLL4CFGR5				0x1370
+#define RCC_PLL4CFGR6				0x1378
+#define RCC_PLL4CFGR7				0x137C
+#define RCC_PLL5CFGR1				0x1388
+#define RCC_PLL5CFGR2				0x138C
+#define RCC_PLL5CFGR3				0x1390
+#define RCC_PLL5CFGR4				0x1394
+#define RCC_PLL5CFGR5				0x1398
+#define RCC_PLL5CFGR6				0x13A0
+#define RCC_PLL5CFGR7				0x13A4
+#define RCC_PLL6CFGR1				0x13B0
+#define RCC_PLL6CFGR2				0x13B4
+#define RCC_PLL6CFGR3				0x13B8
+#define RCC_PLL6CFGR4				0x13BC
+#define RCC_PLL6CFGR5				0x13C0
+#define RCC_PLL6CFGR6				0x13C8
+#define RCC_PLL6CFGR7				0x13CC
+#define RCC_PLL7CFGR1				0x13D8
+#define RCC_PLL7CFGR2				0x13DC
+#define RCC_PLL7CFGR3				0x13E0
+#define RCC_PLL7CFGR4				0x13E4
+#define RCC_PLL7CFGR5				0x13E8
+#define RCC_PLL7CFGR6				0x13F0
+#define RCC_PLL7CFGR7				0x13F4
+#define RCC_PLL8CFGR1				0x1400
+#define RCC_PLL8CFGR2				0x1404
+#define RCC_PLL8CFGR3				0x1408
+#define RCC_PLL8CFGR4				0x140C
+#define RCC_PLL8CFGR5				0x1410
+#define RCC_PLL8CFGR6				0x1418
+#define RCC_PLL8CFGR7				0x141C
+#define RCC_VERR				0xFFF4
+#define RCC_IDR					0xFFF8
+#define RCC_SIDR				0xFFFC
+
+/* Offset between RCC_MP_xxxENSETR and RCC_MP_xxxENCLRR registers */
+#define RCC_MP_ENCLRR_OFFSET			4
+
+/* RCC_SECCFGR3 register fields */
+#define RCC_SECCFGR3_SEC_MASK			GENMASK(17, 0)
+#define RCC_SECCFGR3_SEC_SHIFT			0
+
+/* RCC_PRIVCFGR3 register fields */
+#define RCC_PRIVCFGR3_PRIV_MASK			GENMASK(17, 0)
+#define RCC_PRIVCFGR3_PRIV_SHIFT		0
+
+/* RCC_RCFGLOCKR3 register fields */
+#define RCC_RCFGLOCKR3_RLOCK_MASK		GENMASK(17, 0)
+#define RCC_RCFGLOCKR3_RLOCK_SHIFT		0
+
+/* RCC_R0CIDCFGR register fields */
+#define RCC_R0CIDCFGR_CFEN			BIT(0)
+#define RCC_R0CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R0CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R0CIDCFGR_SCID_SHIFT		4
+#define RCC_R0CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R0CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R0SEMCR register fields */
+#define RCC_R0SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R0SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R0SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R1CIDCFGR register fields */
+#define RCC_R1CIDCFGR_CFEN			BIT(0)
+#define RCC_R1CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R1CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R1CIDCFGR_SCID_SHIFT		4
+#define RCC_R1CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R1CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R1SEMCR register fields */
+#define RCC_R1SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R1SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R1SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R2CIDCFGR register fields */
+#define RCC_R2CIDCFGR_CFEN			BIT(0)
+#define RCC_R2CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R2CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R2CIDCFGR_SCID_SHIFT		4
+#define RCC_R2CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R2CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R2SEMCR register fields */
+#define RCC_R2SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R2SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R2SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R3CIDCFGR register fields */
+#define RCC_R3CIDCFGR_CFEN			BIT(0)
+#define RCC_R3CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R3CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R3CIDCFGR_SCID_SHIFT		4
+#define RCC_R3CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R3CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R3SEMCR register fields */
+#define RCC_R3SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R3SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R3SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R4CIDCFGR register fields */
+#define RCC_R4CIDCFGR_CFEN			BIT(0)
+#define RCC_R4CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R4CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R4CIDCFGR_SCID_SHIFT		4
+#define RCC_R4CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R4CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R4SEMCR register fields */
+#define RCC_R4SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R4SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R4SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R5CIDCFGR register fields */
+#define RCC_R5CIDCFGR_CFEN			BIT(0)
+#define RCC_R5CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R5CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R5CIDCFGR_SCID_SHIFT		4
+#define RCC_R5CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R5CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R5SEMCR register fields */
+#define RCC_R5SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R5SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R5SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R6CIDCFGR register fields */
+#define RCC_R6CIDCFGR_CFEN			BIT(0)
+#define RCC_R6CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R6CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R6CIDCFGR_SCID_SHIFT		4
+#define RCC_R6CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R6CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R6SEMCR register fields */
+#define RCC_R6SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R6SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R6SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R7CIDCFGR register fields */
+#define RCC_R7CIDCFGR_CFEN			BIT(0)
+#define RCC_R7CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R7CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R7CIDCFGR_SCID_SHIFT		4
+#define RCC_R7CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R7CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R7SEMCR register fields */
+#define RCC_R7SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R7SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R7SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R8CIDCFGR register fields */
+#define RCC_R8CIDCFGR_CFEN			BIT(0)
+#define RCC_R8CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R8CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R8CIDCFGR_SCID_SHIFT		4
+#define RCC_R8CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R8CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R8SEMCR register fields */
+#define RCC_R8SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R8SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R8SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R9CIDCFGR register fields */
+#define RCC_R9CIDCFGR_CFEN			BIT(0)
+#define RCC_R9CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R9CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R9CIDCFGR_SCID_SHIFT		4
+#define RCC_R9CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R9CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R9SEMCR register fields */
+#define RCC_R9SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R9SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R9SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R10CIDCFGR register fields */
+#define RCC_R10CIDCFGR_CFEN			BIT(0)
+#define RCC_R10CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R10CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R10CIDCFGR_SCID_SHIFT		4
+#define RCC_R10CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R10CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R10SEMCR register fields */
+#define RCC_R10SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R10SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R10SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R11CIDCFGR register fields */
+#define RCC_R11CIDCFGR_CFEN			BIT(0)
+#define RCC_R11CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R11CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R11CIDCFGR_SCID_SHIFT		4
+#define RCC_R11CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R11CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R11SEMCR register fields */
+#define RCC_R11SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R11SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R11SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R12CIDCFGR register fields */
+#define RCC_R12CIDCFGR_CFEN			BIT(0)
+#define RCC_R12CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R12CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R12CIDCFGR_SCID_SHIFT		4
+#define RCC_R12CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R12CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R12SEMCR register fields */
+#define RCC_R12SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R12SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R12SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R13CIDCFGR register fields */
+#define RCC_R13CIDCFGR_CFEN			BIT(0)
+#define RCC_R13CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R13CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R13CIDCFGR_SCID_SHIFT		4
+#define RCC_R13CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R13CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R13SEMCR register fields */
+#define RCC_R13SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R13SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R13SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R14CIDCFGR register fields */
+#define RCC_R14CIDCFGR_CFEN			BIT(0)
+#define RCC_R14CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R14CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R14CIDCFGR_SCID_SHIFT		4
+#define RCC_R14CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R14CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R14SEMCR register fields */
+#define RCC_R14SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R14SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R14SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R15CIDCFGR register fields */
+#define RCC_R15CIDCFGR_CFEN			BIT(0)
+#define RCC_R15CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R15CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R15CIDCFGR_SCID_SHIFT		4
+#define RCC_R15CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R15CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R15SEMCR register fields */
+#define RCC_R15SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R15SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R15SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R16CIDCFGR register fields */
+#define RCC_R16CIDCFGR_CFEN			BIT(0)
+#define RCC_R16CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R16CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R16CIDCFGR_SCID_SHIFT		4
+#define RCC_R16CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R16CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R16SEMCR register fields */
+#define RCC_R16SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R16SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R16SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R17CIDCFGR register fields */
+#define RCC_R17CIDCFGR_CFEN			BIT(0)
+#define RCC_R17CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R17CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R17CIDCFGR_SCID_SHIFT		4
+#define RCC_R17CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R17CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R17SEMCR register fields */
+#define RCC_R17SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R17SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R17SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R18CIDCFGR register fields */
+#define RCC_R18CIDCFGR_CFEN			BIT(0)
+#define RCC_R18CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R18CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R18CIDCFGR_SCID_SHIFT		4
+#define RCC_R18CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R18CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R18SEMCR register fields */
+#define RCC_R18SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R18SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R18SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R19CIDCFGR register fields */
+#define RCC_R19CIDCFGR_CFEN			BIT(0)
+#define RCC_R19CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R19CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R19CIDCFGR_SCID_SHIFT		4
+#define RCC_R19CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R19CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R19SEMCR register fields */
+#define RCC_R19SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R19SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R19SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R20CIDCFGR register fields */
+#define RCC_R20CIDCFGR_CFEN			BIT(0)
+#define RCC_R20CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R20CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R20CIDCFGR_SCID_SHIFT		4
+#define RCC_R20CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R20CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R20SEMCR register fields */
+#define RCC_R20SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R20SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R20SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R21CIDCFGR register fields */
+#define RCC_R21CIDCFGR_CFEN			BIT(0)
+#define RCC_R21CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R21CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R21CIDCFGR_SCID_SHIFT		4
+#define RCC_R21CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R21CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R21SEMCR register fields */
+#define RCC_R21SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R21SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R21SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R22CIDCFGR register fields */
+#define RCC_R22CIDCFGR_CFEN			BIT(0)
+#define RCC_R22CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R22CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R22CIDCFGR_SCID_SHIFT		4
+#define RCC_R22CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R22CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R22SEMCR register fields */
+#define RCC_R22SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R22SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R22SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R23CIDCFGR register fields */
+#define RCC_R23CIDCFGR_CFEN			BIT(0)
+#define RCC_R23CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R23CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R23CIDCFGR_SCID_SHIFT		4
+#define RCC_R23CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R23CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R23SEMCR register fields */
+#define RCC_R23SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R23SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R23SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R24CIDCFGR register fields */
+#define RCC_R24CIDCFGR_CFEN			BIT(0)
+#define RCC_R24CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R24CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R24CIDCFGR_SCID_SHIFT		4
+#define RCC_R24CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R24CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R24SEMCR register fields */
+#define RCC_R24SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R24SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R24SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R25CIDCFGR register fields */
+#define RCC_R25CIDCFGR_CFEN			BIT(0)
+#define RCC_R25CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R25CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R25CIDCFGR_SCID_SHIFT		4
+#define RCC_R25CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R25CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R25SEMCR register fields */
+#define RCC_R25SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R25SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R25SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R26CIDCFGR register fields */
+#define RCC_R26CIDCFGR_CFEN			BIT(0)
+#define RCC_R26CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R26CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R26CIDCFGR_SCID_SHIFT		4
+#define RCC_R26CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R26CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R26SEMCR register fields */
+#define RCC_R26SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R26SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R26SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R27CIDCFGR register fields */
+#define RCC_R27CIDCFGR_CFEN			BIT(0)
+#define RCC_R27CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R27CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R27CIDCFGR_SCID_SHIFT		4
+#define RCC_R27CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R27CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R27SEMCR register fields */
+#define RCC_R27SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R27SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R27SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R28CIDCFGR register fields */
+#define RCC_R28CIDCFGR_CFEN			BIT(0)
+#define RCC_R28CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R28CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R28CIDCFGR_SCID_SHIFT		4
+#define RCC_R28CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R28CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R28SEMCR register fields */
+#define RCC_R28SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R28SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R28SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R29CIDCFGR register fields */
+#define RCC_R29CIDCFGR_CFEN			BIT(0)
+#define RCC_R29CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R29CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R29CIDCFGR_SCID_SHIFT		4
+#define RCC_R29CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R29CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R29SEMCR register fields */
+#define RCC_R29SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R29SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R29SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R30CIDCFGR register fields */
+#define RCC_R30CIDCFGR_CFEN			BIT(0)
+#define RCC_R30CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R30CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R30CIDCFGR_SCID_SHIFT		4
+#define RCC_R30CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R30CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R30SEMCR register fields */
+#define RCC_R30SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R30SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R30SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R31CIDCFGR register fields */
+#define RCC_R31CIDCFGR_CFEN			BIT(0)
+#define RCC_R31CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R31CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R31CIDCFGR_SCID_SHIFT		4
+#define RCC_R31CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R31CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R31SEMCR register fields */
+#define RCC_R31SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R31SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R31SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R32CIDCFGR register fields */
+#define RCC_R32CIDCFGR_CFEN			BIT(0)
+#define RCC_R32CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R32CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R32CIDCFGR_SCID_SHIFT		4
+#define RCC_R32CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R32CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R32SEMCR register fields */
+#define RCC_R32SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R32SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R32SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R33CIDCFGR register fields */
+#define RCC_R33CIDCFGR_CFEN			BIT(0)
+#define RCC_R33CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R33CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R33CIDCFGR_SCID_SHIFT		4
+#define RCC_R33CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R33CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R33SEMCR register fields */
+#define RCC_R33SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R33SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R33SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R34CIDCFGR register fields */
+#define RCC_R34CIDCFGR_CFEN			BIT(0)
+#define RCC_R34CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R34CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R34CIDCFGR_SCID_SHIFT		4
+#define RCC_R34CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R34CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R34SEMCR register fields */
+#define RCC_R34SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R34SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R34SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R35CIDCFGR register fields */
+#define RCC_R35CIDCFGR_CFEN			BIT(0)
+#define RCC_R35CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R35CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R35CIDCFGR_SCID_SHIFT		4
+#define RCC_R35CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R35CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R35SEMCR register fields */
+#define RCC_R35SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R35SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R35SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R36CIDCFGR register fields */
+#define RCC_R36CIDCFGR_CFEN			BIT(0)
+#define RCC_R36CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R36CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R36CIDCFGR_SCID_SHIFT		4
+#define RCC_R36CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R36CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R36SEMCR register fields */
+#define RCC_R36SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R36SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R36SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R37CIDCFGR register fields */
+#define RCC_R37CIDCFGR_CFEN			BIT(0)
+#define RCC_R37CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R37CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R37CIDCFGR_SCID_SHIFT		4
+#define RCC_R37CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R37CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R37SEMCR register fields */
+#define RCC_R37SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R37SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R37SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R38CIDCFGR register fields */
+#define RCC_R38CIDCFGR_CFEN			BIT(0)
+#define RCC_R38CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R38CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R38CIDCFGR_SCID_SHIFT		4
+#define RCC_R38CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R38CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R38SEMCR register fields */
+#define RCC_R38SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R38SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R38SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R39CIDCFGR register fields */
+#define RCC_R39CIDCFGR_CFEN			BIT(0)
+#define RCC_R39CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R39CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R39CIDCFGR_SCID_SHIFT		4
+#define RCC_R39CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R39CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R39SEMCR register fields */
+#define RCC_R39SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R39SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R39SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R40CIDCFGR register fields */
+#define RCC_R40CIDCFGR_CFEN			BIT(0)
+#define RCC_R40CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R40CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R40CIDCFGR_SCID_SHIFT		4
+#define RCC_R40CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R40CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R40SEMCR register fields */
+#define RCC_R40SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R40SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R40SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R41CIDCFGR register fields */
+#define RCC_R41CIDCFGR_CFEN			BIT(0)
+#define RCC_R41CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R41CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R41CIDCFGR_SCID_SHIFT		4
+#define RCC_R41CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R41CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R41SEMCR register fields */
+#define RCC_R41SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R41SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R41SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R42CIDCFGR register fields */
+#define RCC_R42CIDCFGR_CFEN			BIT(0)
+#define RCC_R42CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R42CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R42CIDCFGR_SCID_SHIFT		4
+#define RCC_R42CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R42CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R42SEMCR register fields */
+#define RCC_R42SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R42SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R42SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R43CIDCFGR register fields */
+#define RCC_R43CIDCFGR_CFEN			BIT(0)
+#define RCC_R43CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R43CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R43CIDCFGR_SCID_SHIFT		4
+#define RCC_R43CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R43CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R43SEMCR register fields */
+#define RCC_R43SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R43SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R43SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R44CIDCFGR register fields */
+#define RCC_R44CIDCFGR_CFEN			BIT(0)
+#define RCC_R44CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R44CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R44CIDCFGR_SCID_SHIFT		4
+#define RCC_R44CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R44CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R44SEMCR register fields */
+#define RCC_R44SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R44SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R44SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R45CIDCFGR register fields */
+#define RCC_R45CIDCFGR_CFEN			BIT(0)
+#define RCC_R45CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R45CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R45CIDCFGR_SCID_SHIFT		4
+#define RCC_R45CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R45CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R45SEMCR register fields */
+#define RCC_R45SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R45SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R45SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R46CIDCFGR register fields */
+#define RCC_R46CIDCFGR_CFEN			BIT(0)
+#define RCC_R46CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R46CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R46CIDCFGR_SCID_SHIFT		4
+#define RCC_R46CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R46CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R46SEMCR register fields */
+#define RCC_R46SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R46SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R46SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R47CIDCFGR register fields */
+#define RCC_R47CIDCFGR_CFEN			BIT(0)
+#define RCC_R47CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R47CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R47CIDCFGR_SCID_SHIFT		4
+#define RCC_R47CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R47CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R47SEMCR register fields */
+#define RCC_R47SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R47SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R47SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R48CIDCFGR register fields */
+#define RCC_R48CIDCFGR_CFEN			BIT(0)
+#define RCC_R48CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R48CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R48CIDCFGR_SCID_SHIFT		4
+#define RCC_R48CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R48CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R48SEMCR register fields */
+#define RCC_R48SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R48SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R48SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R49CIDCFGR register fields */
+#define RCC_R49CIDCFGR_CFEN			BIT(0)
+#define RCC_R49CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R49CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R49CIDCFGR_SCID_SHIFT		4
+#define RCC_R49CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R49CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R49SEMCR register fields */
+#define RCC_R49SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R49SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R49SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R50CIDCFGR register fields */
+#define RCC_R50CIDCFGR_CFEN			BIT(0)
+#define RCC_R50CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R50CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R50CIDCFGR_SCID_SHIFT		4
+#define RCC_R50CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R50CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R50SEMCR register fields */
+#define RCC_R50SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R50SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R50SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R51CIDCFGR register fields */
+#define RCC_R51CIDCFGR_CFEN			BIT(0)
+#define RCC_R51CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R51CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R51CIDCFGR_SCID_SHIFT		4
+#define RCC_R51CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R51CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R51SEMCR register fields */
+#define RCC_R51SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R51SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R51SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R52CIDCFGR register fields */
+#define RCC_R52CIDCFGR_CFEN			BIT(0)
+#define RCC_R52CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R52CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R52CIDCFGR_SCID_SHIFT		4
+#define RCC_R52CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R52CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R52SEMCR register fields */
+#define RCC_R52SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R52SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R52SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R53CIDCFGR register fields */
+#define RCC_R53CIDCFGR_CFEN			BIT(0)
+#define RCC_R53CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R53CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R53CIDCFGR_SCID_SHIFT		4
+#define RCC_R53CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R53CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R53SEMCR register fields */
+#define RCC_R53SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R53SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R53SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R54CIDCFGR register fields */
+#define RCC_R54CIDCFGR_CFEN			BIT(0)
+#define RCC_R54CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R54CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R54CIDCFGR_SCID_SHIFT		4
+#define RCC_R54CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R54CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R54SEMCR register fields */
+#define RCC_R54SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R54SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R54SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R55CIDCFGR register fields */
+#define RCC_R55CIDCFGR_CFEN			BIT(0)
+#define RCC_R55CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R55CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R55CIDCFGR_SCID_SHIFT		4
+#define RCC_R55CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R55CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R55SEMCR register fields */
+#define RCC_R55SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R55SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R55SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R56CIDCFGR register fields */
+#define RCC_R56CIDCFGR_CFEN			BIT(0)
+#define RCC_R56CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R56CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R56CIDCFGR_SCID_SHIFT		4
+#define RCC_R56CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R56CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R56SEMCR register fields */
+#define RCC_R56SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R56SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R56SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R57CIDCFGR register fields */
+#define RCC_R57CIDCFGR_CFEN			BIT(0)
+#define RCC_R57CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R57CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R57CIDCFGR_SCID_SHIFT		4
+#define RCC_R57CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R57CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R57SEMCR register fields */
+#define RCC_R57SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R57SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R57SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R58CIDCFGR register fields */
+#define RCC_R58CIDCFGR_CFEN			BIT(0)
+#define RCC_R58CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R58CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R58CIDCFGR_SCID_SHIFT		4
+#define RCC_R58CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R58CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R58SEMCR register fields */
+#define RCC_R58SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R58SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R58SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R59CIDCFGR register fields */
+#define RCC_R59CIDCFGR_CFEN			BIT(0)
+#define RCC_R59CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R59CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R59CIDCFGR_SCID_SHIFT		4
+#define RCC_R59CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R59CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R59SEMCR register fields */
+#define RCC_R59SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R59SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R59SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R60CIDCFGR register fields */
+#define RCC_R60CIDCFGR_CFEN			BIT(0)
+#define RCC_R60CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R60CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R60CIDCFGR_SCID_SHIFT		4
+#define RCC_R60CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R60CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R60SEMCR register fields */
+#define RCC_R60SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R60SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R60SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R61CIDCFGR register fields */
+#define RCC_R61CIDCFGR_CFEN			BIT(0)
+#define RCC_R61CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R61CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R61CIDCFGR_SCID_SHIFT		4
+#define RCC_R61CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R61CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R61SEMCR register fields */
+#define RCC_R61SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R61SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R61SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R62CIDCFGR register fields */
+#define RCC_R62CIDCFGR_CFEN			BIT(0)
+#define RCC_R62CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R62CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R62CIDCFGR_SCID_SHIFT		4
+#define RCC_R62CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R62CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R62SEMCR register fields */
+#define RCC_R62SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R62SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R62SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R63CIDCFGR register fields */
+#define RCC_R63CIDCFGR_CFEN			BIT(0)
+#define RCC_R63CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R63CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R63CIDCFGR_SCID_SHIFT		4
+#define RCC_R63CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R63CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R63SEMCR register fields */
+#define RCC_R63SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R63SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R63SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R64CIDCFGR register fields */
+#define RCC_R64CIDCFGR_CFEN			BIT(0)
+#define RCC_R64CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R64CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R64CIDCFGR_SCID_SHIFT		4
+#define RCC_R64CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R64CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R64SEMCR register fields */
+#define RCC_R64SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R64SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R64SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R65CIDCFGR register fields */
+#define RCC_R65CIDCFGR_CFEN			BIT(0)
+#define RCC_R65CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R65CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R65CIDCFGR_SCID_SHIFT		4
+#define RCC_R65CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R65CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R65SEMCR register fields */
+#define RCC_R65SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R65SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R65SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R66CIDCFGR register fields */
+#define RCC_R66CIDCFGR_CFEN			BIT(0)
+#define RCC_R66CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R66CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R66CIDCFGR_SCID_SHIFT		4
+#define RCC_R66CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R66CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R66SEMCR register fields */
+#define RCC_R66SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R66SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R66SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R67CIDCFGR register fields */
+#define RCC_R67CIDCFGR_CFEN			BIT(0)
+#define RCC_R67CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R67CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R67CIDCFGR_SCID_SHIFT		4
+#define RCC_R67CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R67CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R67SEMCR register fields */
+#define RCC_R67SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R67SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R67SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R68CIDCFGR register fields */
+#define RCC_R68CIDCFGR_CFEN			BIT(0)
+#define RCC_R68CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R68CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R68CIDCFGR_SCID_SHIFT		4
+#define RCC_R68CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R68CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R68SEMCR register fields */
+#define RCC_R68SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R68SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R68SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R69CIDCFGR register fields */
+#define RCC_R69CIDCFGR_CFEN			BIT(0)
+#define RCC_R69CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R69CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R69CIDCFGR_SCID_SHIFT		4
+#define RCC_R69CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R69CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R69SEMCR register fields */
+#define RCC_R69SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R69SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R69SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R70CIDCFGR register fields */
+#define RCC_R70CIDCFGR_CFEN			BIT(0)
+#define RCC_R70CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R70CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R70CIDCFGR_SCID_SHIFT		4
+#define RCC_R70CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R70CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R70SEMCR register fields */
+#define RCC_R70SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R70SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R70SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R71CIDCFGR register fields */
+#define RCC_R71CIDCFGR_CFEN			BIT(0)
+#define RCC_R71CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R71CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R71CIDCFGR_SCID_SHIFT		4
+#define RCC_R71CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R71CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R71SEMCR register fields */
+#define RCC_R71SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R71SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R71SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R72CIDCFGR register fields */
+#define RCC_R72CIDCFGR_CFEN			BIT(0)
+#define RCC_R72CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R72CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R72CIDCFGR_SCID_SHIFT		4
+#define RCC_R72CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R72CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R72SEMCR register fields */
+#define RCC_R72SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R72SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R72SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R73CIDCFGR register fields */
+#define RCC_R73CIDCFGR_CFEN			BIT(0)
+#define RCC_R73CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R73CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R73CIDCFGR_SCID_SHIFT		4
+#define RCC_R73CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R73CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R73SEMCR register fields */
+#define RCC_R73SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R73SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R73SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R74CIDCFGR register fields */
+#define RCC_R74CIDCFGR_CFEN			BIT(0)
+#define RCC_R74CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R74CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R74CIDCFGR_SCID_SHIFT		4
+#define RCC_R74CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R74CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R74SEMCR register fields */
+#define RCC_R74SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R74SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R74SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R75CIDCFGR register fields */
+#define RCC_R75CIDCFGR_CFEN			BIT(0)
+#define RCC_R75CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R75CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R75CIDCFGR_SCID_SHIFT		4
+#define RCC_R75CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R75CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R75SEMCR register fields */
+#define RCC_R75SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R75SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R75SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R76CIDCFGR register fields */
+#define RCC_R76CIDCFGR_CFEN			BIT(0)
+#define RCC_R76CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R76CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R76CIDCFGR_SCID_SHIFT		4
+#define RCC_R76CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R76CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R76SEMCR register fields */
+#define RCC_R76SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R76SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R76SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R77CIDCFGR register fields */
+#define RCC_R77CIDCFGR_CFEN			BIT(0)
+#define RCC_R77CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R77CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R77CIDCFGR_SCID_SHIFT		4
+#define RCC_R77CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R77CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R77SEMCR register fields */
+#define RCC_R77SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R77SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R77SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R78CIDCFGR register fields */
+#define RCC_R78CIDCFGR_CFEN			BIT(0)
+#define RCC_R78CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R78CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R78CIDCFGR_SCID_SHIFT		4
+#define RCC_R78CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R78CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R78SEMCR register fields */
+#define RCC_R78SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R78SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R78SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R79CIDCFGR register fields */
+#define RCC_R79CIDCFGR_CFEN			BIT(0)
+#define RCC_R79CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R79CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R79CIDCFGR_SCID_SHIFT		4
+#define RCC_R79CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R79CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R79SEMCR register fields */
+#define RCC_R79SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R79SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R79SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R80CIDCFGR register fields */
+#define RCC_R80CIDCFGR_CFEN			BIT(0)
+#define RCC_R80CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R80CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R80CIDCFGR_SCID_SHIFT		4
+#define RCC_R80CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R80CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R80SEMCR register fields */
+#define RCC_R80SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R80SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R80SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R81CIDCFGR register fields */
+#define RCC_R81CIDCFGR_CFEN			BIT(0)
+#define RCC_R81CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R81CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R81CIDCFGR_SCID_SHIFT		4
+#define RCC_R81CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R81CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R81SEMCR register fields */
+#define RCC_R81SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R81SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R81SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R82CIDCFGR register fields */
+#define RCC_R82CIDCFGR_CFEN			BIT(0)
+#define RCC_R82CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R82CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R82CIDCFGR_SCID_SHIFT		4
+#define RCC_R82CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R82CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R82SEMCR register fields */
+#define RCC_R82SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R82SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R82SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R83CIDCFGR register fields */
+#define RCC_R83CIDCFGR_CFEN			BIT(0)
+#define RCC_R83CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R83CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R83CIDCFGR_SCID_SHIFT		4
+#define RCC_R83CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R83CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R83SEMCR register fields */
+#define RCC_R83SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R83SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R83SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R84CIDCFGR register fields */
+#define RCC_R84CIDCFGR_CFEN			BIT(0)
+#define RCC_R84CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R84CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R84CIDCFGR_SCID_SHIFT		4
+#define RCC_R84CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R84CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R84SEMCR register fields */
+#define RCC_R84SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R84SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R84SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R85CIDCFGR register fields */
+#define RCC_R85CIDCFGR_CFEN			BIT(0)
+#define RCC_R85CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R85CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R85CIDCFGR_SCID_SHIFT		4
+#define RCC_R85CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R85CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R85SEMCR register fields */
+#define RCC_R85SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R85SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R85SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R86CIDCFGR register fields */
+#define RCC_R86CIDCFGR_CFEN			BIT(0)
+#define RCC_R86CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R86CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R86CIDCFGR_SCID_SHIFT		4
+#define RCC_R86CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R86CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R86SEMCR register fields */
+#define RCC_R86SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R86SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R86SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R87CIDCFGR register fields */
+#define RCC_R87CIDCFGR_CFEN			BIT(0)
+#define RCC_R87CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R87CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R87CIDCFGR_SCID_SHIFT		4
+#define RCC_R87CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R87CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R87SEMCR register fields */
+#define RCC_R87SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R87SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R87SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R88CIDCFGR register fields */
+#define RCC_R88CIDCFGR_CFEN			BIT(0)
+#define RCC_R88CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R88CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R88CIDCFGR_SCID_SHIFT		4
+#define RCC_R88CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R88CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R88SEMCR register fields */
+#define RCC_R88SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R88SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R88SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R89CIDCFGR register fields */
+#define RCC_R89CIDCFGR_CFEN			BIT(0)
+#define RCC_R89CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R89CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R89CIDCFGR_SCID_SHIFT		4
+#define RCC_R89CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R89CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R89SEMCR register fields */
+#define RCC_R89SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R89SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R89SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R90CIDCFGR register fields */
+#define RCC_R90CIDCFGR_CFEN			BIT(0)
+#define RCC_R90CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R90CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R90CIDCFGR_SCID_SHIFT		4
+#define RCC_R90CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R90CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R90SEMCR register fields */
+#define RCC_R90SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R90SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R90SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R91CIDCFGR register fields */
+#define RCC_R91CIDCFGR_CFEN			BIT(0)
+#define RCC_R91CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R91CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R91CIDCFGR_SCID_SHIFT		4
+#define RCC_R91CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R91CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R91SEMCR register fields */
+#define RCC_R91SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R91SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R91SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R92CIDCFGR register fields */
+#define RCC_R92CIDCFGR_CFEN			BIT(0)
+#define RCC_R92CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R92CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R92CIDCFGR_SCID_SHIFT		4
+#define RCC_R92CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R92CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R92SEMCR register fields */
+#define RCC_R92SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R92SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R92SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R93CIDCFGR register fields */
+#define RCC_R93CIDCFGR_CFEN			BIT(0)
+#define RCC_R93CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R93CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R93CIDCFGR_SCID_SHIFT		4
+#define RCC_R93CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R93CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R93SEMCR register fields */
+#define RCC_R93SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R93SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R93SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R94CIDCFGR register fields */
+#define RCC_R94CIDCFGR_CFEN			BIT(0)
+#define RCC_R94CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R94CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R94CIDCFGR_SCID_SHIFT		4
+#define RCC_R94CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R94CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R94SEMCR register fields */
+#define RCC_R94SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R94SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R94SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R95CIDCFGR register fields */
+#define RCC_R95CIDCFGR_CFEN			BIT(0)
+#define RCC_R95CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R95CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R95CIDCFGR_SCID_SHIFT		4
+#define RCC_R95CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R95CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R95SEMCR register fields */
+#define RCC_R95SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R95SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R95SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R96CIDCFGR register fields */
+#define RCC_R96CIDCFGR_CFEN			BIT(0)
+#define RCC_R96CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R96CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R96CIDCFGR_SCID_SHIFT		4
+#define RCC_R96CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R96CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R96SEMCR register fields */
+#define RCC_R96SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R96SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R96SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R97CIDCFGR register fields */
+#define RCC_R97CIDCFGR_CFEN			BIT(0)
+#define RCC_R97CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R97CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R97CIDCFGR_SCID_SHIFT		4
+#define RCC_R97CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R97CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R97SEMCR register fields */
+#define RCC_R97SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R97SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R97SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R98CIDCFGR register fields */
+#define RCC_R98CIDCFGR_CFEN			BIT(0)
+#define RCC_R98CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R98CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R98CIDCFGR_SCID_SHIFT		4
+#define RCC_R98CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R98CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R98SEMCR register fields */
+#define RCC_R98SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R98SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R98SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R99CIDCFGR register fields */
+#define RCC_R99CIDCFGR_CFEN			BIT(0)
+#define RCC_R99CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R99CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R99CIDCFGR_SCID_SHIFT		4
+#define RCC_R99CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R99CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R99SEMCR register fields */
+#define RCC_R99SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R99SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R99SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R100CIDCFGR register fields */
+#define RCC_R100CIDCFGR_CFEN			BIT(0)
+#define RCC_R100CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R100CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R100CIDCFGR_SCID_SHIFT		4
+#define RCC_R100CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R100CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R100SEMCR register fields */
+#define RCC_R100SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R100SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R100SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R101CIDCFGR register fields */
+#define RCC_R101CIDCFGR_CFEN			BIT(0)
+#define RCC_R101CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R101CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R101CIDCFGR_SCID_SHIFT		4
+#define RCC_R101CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R101CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R101SEMCR register fields */
+#define RCC_R101SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R101SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R101SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R102CIDCFGR register fields */
+#define RCC_R102CIDCFGR_CFEN			BIT(0)
+#define RCC_R102CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R102CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R102CIDCFGR_SCID_SHIFT		4
+#define RCC_R102CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R102CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R102SEMCR register fields */
+#define RCC_R102SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R102SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R102SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R103CIDCFGR register fields */
+#define RCC_R103CIDCFGR_CFEN			BIT(0)
+#define RCC_R103CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R103CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R103CIDCFGR_SCID_SHIFT		4
+#define RCC_R103CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R103CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R103SEMCR register fields */
+#define RCC_R103SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R103SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R103SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R104CIDCFGR register fields */
+#define RCC_R104CIDCFGR_CFEN			BIT(0)
+#define RCC_R104CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R104CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R104CIDCFGR_SCID_SHIFT		4
+#define RCC_R104CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R104CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R104SEMCR register fields */
+#define RCC_R104SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R104SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R104SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R105CIDCFGR register fields */
+#define RCC_R105CIDCFGR_CFEN			BIT(0)
+#define RCC_R105CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R105CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R105CIDCFGR_SCID_SHIFT		4
+#define RCC_R105CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R105CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R105SEMCR register fields */
+#define RCC_R105SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R105SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R105SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R106CIDCFGR register fields */
+#define RCC_R106CIDCFGR_CFEN			BIT(0)
+#define RCC_R106CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R106CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R106CIDCFGR_SCID_SHIFT		4
+#define RCC_R106CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R106CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R106SEMCR register fields */
+#define RCC_R106SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R106SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R106SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R107CIDCFGR register fields */
+#define RCC_R107CIDCFGR_CFEN			BIT(0)
+#define RCC_R107CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R107CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R107CIDCFGR_SCID_SHIFT		4
+#define RCC_R107CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R107CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R107SEMCR register fields */
+#define RCC_R107SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R107SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R107SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R108CIDCFGR register fields */
+#define RCC_R108CIDCFGR_CFEN			BIT(0)
+#define RCC_R108CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R108CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R108CIDCFGR_SCID_SHIFT		4
+#define RCC_R108CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R108CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R108SEMCR register fields */
+#define RCC_R108SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R108SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R108SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R109CIDCFGR register fields */
+#define RCC_R109CIDCFGR_CFEN			BIT(0)
+#define RCC_R109CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R109CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R109CIDCFGR_SCID_SHIFT		4
+#define RCC_R109CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R109CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R109SEMCR register fields */
+#define RCC_R109SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R109SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R109SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R110CIDCFGR register fields */
+#define RCC_R110CIDCFGR_CFEN			BIT(0)
+#define RCC_R110CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R110CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R110CIDCFGR_SCID_SHIFT		4
+#define RCC_R110CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R110CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R110SEMCR register fields */
+#define RCC_R110SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R110SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R110SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R111CIDCFGR register fields */
+#define RCC_R111CIDCFGR_CFEN			BIT(0)
+#define RCC_R111CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R111CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R111CIDCFGR_SCID_SHIFT		4
+#define RCC_R111CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R111CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R111SEMCR register fields */
+#define RCC_R111SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R111SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R111SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R112CIDCFGR register fields */
+#define RCC_R112CIDCFGR_CFEN			BIT(0)
+#define RCC_R112CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R112CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R112CIDCFGR_SCID_SHIFT		4
+#define RCC_R112CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R112CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R112SEMCR register fields */
+#define RCC_R112SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R112SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R112SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R113CIDCFGR register fields */
+#define RCC_R113CIDCFGR_CFEN			BIT(0)
+#define RCC_R113CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R113CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R113CIDCFGR_SCID_SHIFT		4
+#define RCC_R113CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R113CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R113SEMCR register fields */
+#define RCC_R113SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R113SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R113SEMCR_SEMCID_SHIFT		4
+
+/* RCC_RxCIDCFGR register fields */
+#define RCC_RxCIDCFGR_CFEN			BIT(0)
+#define RCC_RxCIDCFGR_SEM_EN			BIT(1)
+#define RCC_RxCIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_RxCIDCFGR_SCID_SHIFT		4
+#define RCC_RxCIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_RxCIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_RxSEMCR register fields */
+#define RCC_RxSEMCR_SEM_MUTEX			BIT(0)
+#define RCC_RxSEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_RxSEMCR_SEMCID_SHIFT		4
+
+/* RCC_GRSTCSETR register fields */
+#define RCC_GRSTCSETR_SYSRST			BIT(0)
+
+/* RCC_C1RSTCSETR register fields */
+#define RCC_C1RSTCSETR_C1RST			BIT(0)
+
+/* RCC_C1P1RSTCSETR register fields */
+#define RCC_C1P1RSTCSETR_C1P1PORRST		BIT(0)
+#define RCC_C1P1RSTCSETR_C1P1RST		BIT(1)
+
+/* RCC_C2RSTCSETR register fields */
+#define RCC_C2RSTCSETR_C2RST			BIT(0)
+
+/* RCC_CxRSTCSETR register fields */
+#define RCC_CxRSTCSETR_CxRST			BIT(0)
+
+/* RCC_HWRSTSCLRR register fields */
+#define RCC_HWRSTSCLRR_PORRSTF			BIT(0)
+#define RCC_HWRSTSCLRR_BORRSTF			BIT(1)
+#define RCC_HWRSTSCLRR_PADRSTF			BIT(2)
+#define RCC_HWRSTSCLRR_HCSSRSTF			BIT(3)
+#define RCC_HWRSTSCLRR_VCORERSTF		BIT(4)
+#define RCC_HWRSTSCLRR_SYSC1RSTF		BIT(5)
+#define RCC_HWRSTSCLRR_SYSC2RSTF		BIT(6)
+#define RCC_HWRSTSCLRR_IWDG1SYSRSTF		BIT(7)
+#define RCC_HWRSTSCLRR_IWDG2SYSRSTF		BIT(8)
+#define RCC_HWRSTSCLRR_IWDG3SYSRSTF		BIT(9)
+#define RCC_HWRSTSCLRR_IWDG4SYSRSTF		BIT(10)
+#define RCC_HWRSTSCLRR_IWDG5SYSRSTF		BIT(11)
+#define RCC_HWRSTSCLRR_RETCRCERRRSTF		BIT(12)
+#define RCC_HWRSTSCLRR_RETECCFAILCRCRSTF	BIT(13)
+#define RCC_HWRSTSCLRR_RETECCFAILRESTRSTF	BIT(14)
+
+/* RCC_C1HWRSTSCLRR register fields */
+#define RCC_C1HWRSTSCLRR_VCPURSTF		BIT(0)
+#define RCC_C1HWRSTSCLRR_C1RSTF			BIT(1)
+#define RCC_C1HWRSTSCLRR_C1P1RSTF		BIT(2)
+
+/* RCC_C2HWRSTSCLRR register fields */
+#define RCC_C2HWRSTSCLRR_C2RSTF			BIT(0)
+
+/* RCC_C1BOOTRSTSSETR register fields */
+#define RCC_C1BOOTRSTSSETR_PORRSTF		BIT(0)
+#define RCC_C1BOOTRSTSSETR_BORRSTF		BIT(1)
+#define RCC_C1BOOTRSTSSETR_PADRSTF		BIT(2)
+#define RCC_C1BOOTRSTSSETR_HCSSRSTF		BIT(3)
+#define RCC_C1BOOTRSTSSETR_VCORERSTF		BIT(4)
+#define RCC_C1BOOTRSTSSETR_VCPURSTF		BIT(5)
+#define RCC_C1BOOTRSTSSETR_SYSC1RSTF		BIT(6)
+#define RCC_C1BOOTRSTSSETR_SYSC2RSTF		BIT(7)
+#define RCC_C1BOOTRSTSSETR_IWDG1SYSRSTF		BIT(8)
+#define RCC_C1BOOTRSTSSETR_IWDG2SYSRSTF		BIT(9)
+#define RCC_C1BOOTRSTSSETR_IWDG3SYSRSTF		BIT(10)
+#define RCC_C1BOOTRSTSSETR_IWDG4SYSRSTF		BIT(11)
+#define RCC_C1BOOTRSTSSETR_IWDG5SYSRSTF		BIT(12)
+#define RCC_C1BOOTRSTSSETR_C1RSTF		BIT(13)
+#define RCC_C1BOOTRSTSSETR_C1P1RSTF		BIT(16)
+#define RCC_C1BOOTRSTSSETR_RETCRCERRRSTF	BIT(17)
+#define RCC_C1BOOTRSTSSETR_RETECCFAILCRCRSTF	BIT(18)
+#define RCC_C1BOOTRSTSSETR_RETECCFAILRESTRSTF	BIT(19)
+#define RCC_C1BOOTRSTSSETR_STBYC1RSTF		BIT(20)
+#define RCC_C1BOOTRSTSSETR_D1STBYRSTF		BIT(22)
+#define RCC_C1BOOTRSTSSETR_D2STBYRSTF		BIT(23)
+
+/* RCC_C1BOOTRSTSCLRR register fields */
+#define RCC_C1BOOTRSTSCLRR_PORRSTF		BIT(0)
+#define RCC_C1BOOTRSTSCLRR_BORRSTF		BIT(1)
+#define RCC_C1BOOTRSTSCLRR_PADRSTF		BIT(2)
+#define RCC_C1BOOTRSTSCLRR_HCSSRSTF		BIT(3)
+#define RCC_C1BOOTRSTSCLRR_VCORERSTF		BIT(4)
+#define RCC_C1BOOTRSTSCLRR_VCPURSTF		BIT(5)
+#define RCC_C1BOOTRSTSCLRR_SYSC1RSTF		BIT(6)
+#define RCC_C1BOOTRSTSCLRR_SYSC2RSTF		BIT(7)
+#define RCC_C1BOOTRSTSCLRR_IWDG1SYSRSTF		BIT(8)
+#define RCC_C1BOOTRSTSCLRR_IWDG2SYSRSTF		BIT(9)
+#define RCC_C1BOOTRSTSCLRR_IWDG3SYSRSTF		BIT(10)
+#define RCC_C1BOOTRSTSCLRR_IWDG4SYSRSTF		BIT(11)
+#define RCC_C1BOOTRSTSCLRR_IWDG5SYSRSTF		BIT(12)
+#define RCC_C1BOOTRSTSCLRR_C1RSTF		BIT(13)
+#define RCC_C1BOOTRSTSCLRR_C1P1RSTF		BIT(16)
+#define RCC_C1BOOTRSTSCLRR_RETCRCERRRSTF	BIT(17)
+#define RCC_C1BOOTRSTSCLRR_RETECCFAILCRCRSTF	BIT(18)
+#define RCC_C1BOOTRSTSCLRR_RETECCFAILRESTRSTF	BIT(19)
+#define RCC_C1BOOTRSTSCLRR_STBYC1RSTF		BIT(20)
+#define RCC_C1BOOTRSTSCLRR_D1STBYRSTF		BIT(22)
+#define RCC_C1BOOTRSTSCLRR_D2STBYRSTF		BIT(23)
+
+/* RCC_C2BOOTRSTSSETR register fields */
+#define RCC_C2BOOTRSTSSETR_PORRSTF		BIT(0)
+#define RCC_C2BOOTRSTSSETR_BORRSTF		BIT(1)
+#define RCC_C2BOOTRSTSSETR_PADRSTF		BIT(2)
+#define RCC_C2BOOTRSTSSETR_HCSSRSTF		BIT(3)
+#define RCC_C2BOOTRSTSSETR_VCORERSTF		BIT(4)
+#define RCC_C2BOOTRSTSSETR_SYSC1RSTF		BIT(6)
+#define RCC_C2BOOTRSTSSETR_SYSC2RSTF		BIT(7)
+#define RCC_C2BOOTRSTSSETR_IWDG1SYSRSTF		BIT(8)
+#define RCC_C2BOOTRSTSSETR_IWDG2SYSRSTF		BIT(9)
+#define RCC_C2BOOTRSTSSETR_IWDG3SYSRSTF		BIT(10)
+#define RCC_C2BOOTRSTSSETR_IWDG4SYSRSTF		BIT(11)
+#define RCC_C2BOOTRSTSSETR_IWDG5SYSRSTF		BIT(12)
+#define RCC_C2BOOTRSTSSETR_C2RSTF		BIT(14)
+#define RCC_C2BOOTRSTSSETR_RETCRCERRRSTF	BIT(17)
+#define RCC_C2BOOTRSTSSETR_RETECCFAILCRCRSTF	BIT(18)
+#define RCC_C2BOOTRSTSSETR_RETECCFAILRESTRSTF	BIT(19)
+#define RCC_C2BOOTRSTSSETR_STBYC2RSTF		BIT(21)
+#define RCC_C2BOOTRSTSSETR_D2STBYRSTF		BIT(23)
+
+/* RCC_C2BOOTRSTSCLRR register fields */
+#define RCC_C2BOOTRSTSCLRR_PORRSTF		BIT(0)
+#define RCC_C2BOOTRSTSCLRR_BORRSTF		BIT(1)
+#define RCC_C2BOOTRSTSCLRR_PADRSTF		BIT(2)
+#define RCC_C2BOOTRSTSCLRR_HCSSRSTF		BIT(3)
+#define RCC_C2BOOTRSTSCLRR_VCORERSTF		BIT(4)
+#define RCC_C2BOOTRSTSCLRR_SYSC1RSTF		BIT(6)
+#define RCC_C2BOOTRSTSCLRR_SYSC2RSTF		BIT(7)
+#define RCC_C2BOOTRSTSCLRR_IWDG1SYSRSTF		BIT(8)
+#define RCC_C2BOOTRSTSCLRR_IWDG2SYSRSTF		BIT(9)
+#define RCC_C2BOOTRSTSCLRR_IWDG3SYSRSTF		BIT(10)
+#define RCC_C2BOOTRSTSCLRR_IWDG4SYSRSTF		BIT(11)
+#define RCC_C2BOOTRSTSCLRR_IWDG5SYSRSTF		BIT(12)
+#define RCC_C2BOOTRSTSCLRR_C2RSTF		BIT(14)
+#define RCC_C2BOOTRSTSCLRR_RETCRCERRRSTF	BIT(17)
+#define RCC_C2BOOTRSTSCLRR_RETECCFAILCRCRSTF	BIT(18)
+#define RCC_C2BOOTRSTSCLRR_RETECCFAILRESTRSTF	BIT(19)
+#define RCC_C2BOOTRSTSCLRR_STBYC2RSTF		BIT(21)
+#define RCC_C2BOOTRSTSCLRR_D2STBYRSTF		BIT(23)
+
+/* RCC_C1SREQSETR register fields */
+#define RCC_C1SREQSETR_STPREQ_P0		BIT(0)
+#define RCC_C1SREQSETR_STPREQ_P1		BIT(1)
+#define RCC_C1SREQSETR_ESLPREQ			BIT(16)
+
+/* RCC_C1SREQCLRR register fields */
+#define RCC_C1SREQCLRR_STPREQ_P0		BIT(0)
+#define RCC_C1SREQCLRR_STPREQ_P1		BIT(1)
+#define RCC_C1SREQCLRR_ESLPREQ			BIT(16)
+
+/* RCC_CPUBOOTCR register fields */
+#define RCC_CPUBOOTCR_BOOT_CPU2			BIT(0)
+#define RCC_CPUBOOTCR_BOOT_CPU1			BIT(1)
+
+/* RCC_STBYBOOTCR register fields */
+#define RCC_STBYBOOTCR_CPU_BEN_SEL		BIT(1)
+#define RCC_STBYBOOTCR_COLD_CPU2		BIT(2)
+#define RCC_STBYBOOTCR_CPU2_HW_BEN		BIT(4)
+#define RCC_STBYBOOTCR_CPU1_HW_BEN		BIT(5)
+#define RCC_STBYBOOTCR_RET_CRCERR_RSTEN		BIT(8)
+
+/* RCC_LEGBOOTCR register fields */
+#define RCC_LEGBOOTCR_LEGACY_BEN		BIT(0)
+
+/* RCC_BDCR register fields */
+#define RCC_BDCR_LSEON				BIT(0)
+#define RCC_BDCR_LSEBYP				BIT(1)
+#define RCC_BDCR_LSERDY				BIT(2)
+#define RCC_BDCR_LSEDIGBYP			BIT(3)
+#define RCC_BDCR_LSEDRV_MASK			GENMASK(5, 4)
+#define RCC_BDCR_LSEDRV_SHIFT			4
+#define RCC_BDCR_LSECSSON			BIT(6)
+#define RCC_BDCR_LSEGFON			BIT(7)
+#define RCC_BDCR_LSECSSD			BIT(8)
+#define RCC_BDCR_LSION				BIT(9)
+#define RCC_BDCR_LSIRDY				BIT(10)
+#define RCC_BDCR_RTCSRC_MASK			GENMASK(17, 16)
+#define RCC_BDCR_RTCSRC_SHIFT			16
+#define RCC_BDCR_RTCCKEN			BIT(20)
+#define RCC_BDCR_MSIFREQSEL			BIT(24)
+#define RCC_BDCR_C3SYSTICKSEL			BIT(25)
+#define RCC_BDCR_VSWRST				BIT(31)
+#define RCC_BDCR_LSEBYP_BIT			1
+#define RCC_BDCR_LSEDIGBYP_BIT			3
+#define RCC_BDCR_LSECSSON_BIT			6
+#define RCC_BDCR_LSERDY_BIT			2
+#define RCC_BDCR_LSIRDY_BIT			10
+
+#define RCC_BDCR_LSEDRV_SHIFT			4
+#define RCC_BDCR_LSEDRV_WIDTH			2
+
+/* RCC_D3DCR register fields */
+#define RCC_D3DCR_MSION				BIT(0)
+#define RCC_D3DCR_MSIKERON			BIT(1)
+#define RCC_D3DCR_MSIRDY			BIT(2)
+#define RCC_D3DCR_D3PERCKSEL_MASK		GENMASK(17, 16)
+#define RCC_D3DCR_D3PERCKSEL_SHIFT		16
+#define RCC_D3DCR_MSIRDY_BIT			2
+
+/* RCC_D3DSR register fields */
+#define RCC_D3DSR_D3STATE_MASK			GENMASK(1, 0)
+#define RCC_D3DSR_D3STATE_SHIFT			0
+
+/* RCC_RDCR register fields */
+#define RCC_RDCR_MRD_MASK			GENMASK(20, 16)
+#define RCC_RDCR_MRD_SHIFT			16
+#define RCC_RDCR_EADLY_MASK			GENMASK(27, 24)
+#define RCC_RDCR_EADLY_SHIFT			24
+
+/* RCC_C1MSRDCR register fields */
+#define RCC_C1MSRDCR_C1MSRD_MASK		GENMASK(4, 0)
+#define RCC_C1MSRDCR_C1MSRD_SHIFT		0
+#define RCC_C1MSRDCR_C1MSRST			BIT(8)
+
+/* RCC_PWRLPDLYCR register fields */
+#define RCC_PWRLPDLYCR_PWRLP_DLY_MASK		GENMASK(21, 0)
+#define RCC_PWRLPDLYCR_PWRLP_DLY_SHIFT		0
+#define RCC_PWRLPDLYCR_CPU2TMPSKP		BIT(24)
+
+/* RCC_C1CIESETR register fields */
+#define RCC_C1CIESETR_LSIRDYIE			BIT(0)
+#define RCC_C1CIESETR_LSERDYIE			BIT(1)
+#define RCC_C1CIESETR_HSIRDYIE			BIT(2)
+#define RCC_C1CIESETR_HSERDYIE			BIT(3)
+#define RCC_C1CIESETR_MSIRDYIE			BIT(4)
+#define RCC_C1CIESETR_PLL1RDYIE			BIT(5)
+#define RCC_C1CIESETR_PLL2RDYIE			BIT(6)
+#define RCC_C1CIESETR_PLL3RDYIE			BIT(7)
+#define RCC_C1CIESETR_PLL4RDYIE			BIT(8)
+#define RCC_C1CIESETR_PLL5RDYIE			BIT(9)
+#define RCC_C1CIESETR_PLL6RDYIE			BIT(10)
+#define RCC_C1CIESETR_PLL7RDYIE			BIT(11)
+#define RCC_C1CIESETR_PLL8RDYIE			BIT(12)
+#define RCC_C1CIESETR_LSECSSIE			BIT(16)
+#define RCC_C1CIESETR_WKUPIE			BIT(20)
+
+/* RCC_C1CIFCLRR register fields */
+#define RCC_C1CIFCLRR_LSIRDYF			BIT(0)
+#define RCC_C1CIFCLRR_LSERDYF			BIT(1)
+#define RCC_C1CIFCLRR_HSIRDYF			BIT(2)
+#define RCC_C1CIFCLRR_HSERDYF			BIT(3)
+#define RCC_C1CIFCLRR_MSIRDYF			BIT(4)
+#define RCC_C1CIFCLRR_PLL1RDYF			BIT(5)
+#define RCC_C1CIFCLRR_PLL2RDYF			BIT(6)
+#define RCC_C1CIFCLRR_PLL3RDYF			BIT(7)
+#define RCC_C1CIFCLRR_PLL4RDYF			BIT(8)
+#define RCC_C1CIFCLRR_PLL5RDYF			BIT(9)
+#define RCC_C1CIFCLRR_PLL6RDYF			BIT(10)
+#define RCC_C1CIFCLRR_PLL7RDYF			BIT(11)
+#define RCC_C1CIFCLRR_PLL8RDYF			BIT(12)
+#define RCC_C1CIFCLRR_LSECSSF			BIT(16)
+#define RCC_C1CIFCLRR_WKUPF			BIT(20)
+
+/* RCC_C2CIESETR register fields */
+#define RCC_C2CIESETR_LSIRDYIE			BIT(0)
+#define RCC_C2CIESETR_LSERDYIE			BIT(1)
+#define RCC_C2CIESETR_HSIRDYIE			BIT(2)
+#define RCC_C2CIESETR_HSERDYIE			BIT(3)
+#define RCC_C2CIESETR_MSIRDYIE			BIT(4)
+#define RCC_C2CIESETR_PLL1RDYIE			BIT(5)
+#define RCC_C2CIESETR_PLL2RDYIE			BIT(6)
+#define RCC_C2CIESETR_PLL3RDYIE			BIT(7)
+#define RCC_C2CIESETR_PLL4RDYIE			BIT(8)
+#define RCC_C2CIESETR_PLL5RDYIE			BIT(9)
+#define RCC_C2CIESETR_PLL6RDYIE			BIT(10)
+#define RCC_C2CIESETR_PLL7RDYIE			BIT(11)
+#define RCC_C2CIESETR_PLL8RDYIE			BIT(12)
+#define RCC_C2CIESETR_LSECSSIE			BIT(16)
+#define RCC_C2CIESETR_WKUPIE			BIT(20)
+
+/* RCC_C2CIFCLRR register fields */
+#define RCC_C2CIFCLRR_LSIRDYF			BIT(0)
+#define RCC_C2CIFCLRR_LSERDYF			BIT(1)
+#define RCC_C2CIFCLRR_HSIRDYF			BIT(2)
+#define RCC_C2CIFCLRR_HSERDYF			BIT(3)
+#define RCC_C2CIFCLRR_MSIRDYF			BIT(4)
+#define RCC_C2CIFCLRR_PLL1RDYF			BIT(5)
+#define RCC_C2CIFCLRR_PLL2RDYF			BIT(6)
+#define RCC_C2CIFCLRR_PLL3RDYF			BIT(7)
+#define RCC_C2CIFCLRR_PLL4RDYF			BIT(8)
+#define RCC_C2CIFCLRR_PLL5RDYF			BIT(9)
+#define RCC_C2CIFCLRR_PLL6RDYF			BIT(10)
+#define RCC_C2CIFCLRR_PLL7RDYF			BIT(11)
+#define RCC_C2CIFCLRR_PLL8RDYF			BIT(12)
+#define RCC_C2CIFCLRR_LSECSSF			BIT(16)
+#define RCC_C2CIFCLRR_WKUPF			BIT(20)
+
+/* RCC_CxCIESETR register fields */
+#define RCC_CxCIESETR_LSIRDYIE			BIT(0)
+#define RCC_CxCIESETR_LSERDYIE			BIT(1)
+#define RCC_CxCIESETR_HSIRDYIE			BIT(2)
+#define RCC_CxCIESETR_HSERDYIE			BIT(3)
+#define RCC_CxCIESETR_MSIRDYIE			BIT(4)
+#define RCC_CxCIESETR_SHSIRDYIE			BIT(5)
+#define RCC_CxCIESETR_PLL1RDYIE			BIT(6)
+#define RCC_CxCIESETR_PLL2RDYIE			BIT(7)
+#define RCC_CxCIESETR_PLL3RDYIE			BIT(8)
+#define RCC_CxCIESETR_PLL4RDYIE			BIT(9)
+#define RCC_CxCIESETR_PLL5RDYIE			BIT(10)
+#define RCC_CxCIESETR_PLL6RDYIE			BIT(11)
+#define RCC_CxCIESETR_PLL7RDYIE			BIT(12)
+#define RCC_CxCIESETR_PLL8RDYIE			BIT(13)
+#define RCC_CxCIESETR_LSECSSIE			BIT(16)
+#define RCC_CxCIESETR_WKUPIE			BIT(20)
+
+/* RCC_CxCIFCLRR register fields */
+#define RCC_CxCIFCLRR_LSIRDYF			BIT(0)
+#define RCC_CxCIFCLRR_LSERDYF			BIT(1)
+#define RCC_CxCIFCLRR_HSIRDYF			BIT(2)
+#define RCC_CxCIFCLRR_HSERDYF			BIT(3)
+#define RCC_CxCIFCLRR_MSIRDYF			BIT(4)
+#define RCC_CxCIFCLRR_SHSIRDYF			BIT(5)
+#define RCC_CxCIFCLRR_PLL1RDYF			BIT(6)
+#define RCC_CxCIFCLRR_PLL2RDYF			BIT(7)
+#define RCC_CxCIFCLRR_PLL3RDYF			BIT(8)
+#define RCC_CxCIFCLRR_PLL4RDYF			BIT(9)
+#define RCC_CxCIFCLRR_PLL5RDYF			BIT(10)
+#define RCC_CxCIFCLRR_PLL6RDYF			BIT(11)
+#define RCC_CxCIFCLRR_PLL7RDYF			BIT(12)
+#define RCC_CxCIFCLRR_PLL8RDYF			BIT(13)
+#define RCC_CxCIFCLRR_LSECSSF			BIT(16)
+#define RCC_CxCIFCLRR_WKUPF			BIT(20)
+
+/* RCC_IWDGC1FZSETR register fields */
+#define RCC_IWDGC1FZSETR_FZ_IWDG1		BIT(0)
+#define RCC_IWDGC1FZSETR_FZ_IWDG2		BIT(1)
+
+/* RCC_IWDGC1FZCLRR register fields */
+#define RCC_IWDGC1FZCLRR_FZ_IWDG1		BIT(0)
+#define RCC_IWDGC1FZCLRR_FZ_IWDG2		BIT(1)
+
+/* RCC_IWDGC1CFGSETR register fields */
+#define RCC_IWDGC1CFGSETR_IWDG1_SYSRSTEN	BIT(0)
+#define RCC_IWDGC1CFGSETR_IWDG2_SYSRSTEN	BIT(2)
+#define RCC_IWDGC1CFGSETR_IWDG2_KERRST		BIT(18)
+
+/* RCC_IWDGC1CFGCLRR register fields */
+#define RCC_IWDGC1CFGCLRR_IWDG1_SYSRSTEN	BIT(0)
+#define RCC_IWDGC1CFGCLRR_IWDG2_SYSRSTEN	BIT(2)
+#define RCC_IWDGC1CFGCLRR_IWDG2_KERRST		BIT(18)
+
+/* RCC_IWDGC2FZSETR register fields */
+#define RCC_IWDGC2FZSETR_FZ_IWDG3		BIT(0)
+#define RCC_IWDGC2FZSETR_FZ_IWDG4		BIT(1)
+
+/* RCC_IWDGC2FZCLRR register fields */
+#define RCC_IWDGC2FZCLRR_FZ_IWDG3		BIT(0)
+#define RCC_IWDGC2FZCLRR_FZ_IWDG4		BIT(1)
+
+/* RCC_IWDGC2CFGSETR register fields */
+#define RCC_IWDGC2CFGSETR_IWDG3_SYSRSTEN	BIT(0)
+#define RCC_IWDGC2CFGSETR_IWDG4_SYSRSTEN	BIT(2)
+#define RCC_IWDGC2CFGSETR_IWDG4_KERRST		BIT(18)
+
+/* RCC_IWDGC2CFGCLRR register fields */
+#define RCC_IWDGC2CFGCLRR_IWDG3_SYSRSTEN	BIT(0)
+#define RCC_IWDGC2CFGCLRR_IWDG4_SYSRSTEN	BIT(2)
+#define RCC_IWDGC2CFGCLRR_IWDG4_KERRST		BIT(18)
+
+/* RCC_IWDGC3CFGSETR register fields */
+#define RCC_IWDGC3CFGSETR_IWDG5_SYSRSTEN	BIT(0)
+
+/* RCC_IWDGC3CFGCLRR register fields */
+#define RCC_IWDGC3CFGCLRR_IWDG5_SYSRSTEN	BIT(0)
+
+/* RCC_C3CFGR register fields */
+#define RCC_C3CFGR_C3RST			BIT(0)
+#define RCC_C3CFGR_C3EN				BIT(1)
+#define RCC_C3CFGR_C3LPEN			BIT(2)
+#define RCC_C3CFGR_C3AMEN			BIT(3)
+#define RCC_C3CFGR_LPTIM3C3EN			BIT(16)
+#define RCC_C3CFGR_LPTIM4C3EN			BIT(17)
+#define RCC_C3CFGR_LPTIM5C3EN			BIT(18)
+#define RCC_C3CFGR_SPI8C3EN			BIT(19)
+#define RCC_C3CFGR_LPUART1C3EN			BIT(20)
+#define RCC_C3CFGR_I2C8C3EN			BIT(21)
+#define RCC_C3CFGR_ADF1C3EN			BIT(23)
+#define RCC_C3CFGR_GPIOZC3EN			BIT(24)
+#define RCC_C3CFGR_LPDMAC3EN			BIT(25)
+#define RCC_C3CFGR_RTCC3EN			BIT(26)
+#define RCC_C3CFGR_I3C4C3EN			BIT(27)
+
+/* RCC_MCO1CFGR register fields */
+#define RCC_MCO1CFGR_MCO1SEL			BIT(0)
+#define RCC_MCO1CFGR_MCO1ON			BIT(8)
+
+/* RCC_MCO2CFGR register fields */
+#define RCC_MCO2CFGR_MCO2SEL			BIT(0)
+#define RCC_MCO2CFGR_MCO2ON			BIT(8)
+
+/* RCC_MCOxCFGR register fields */
+#define RCC_MCOxCFGR_MCOxSEL			BIT(0)
+#define RCC_MCOxCFGR_MCOxON			BIT(8)
+
+/* RCC_OCENSETR register fields */
+#define RCC_OCENSETR_HSION			BIT(0)
+#define RCC_OCENSETR_HSIKERON			BIT(1)
+#define RCC_OCENSETR_HSEDIV2ON			BIT(5)
+#define RCC_OCENSETR_HSEDIV2BYP			BIT(6)
+#define RCC_OCENSETR_HSEDIGBYP			BIT(7)
+#define RCC_OCENSETR_HSEON			BIT(8)
+#define RCC_OCENSETR_HSEKERON			BIT(9)
+#define RCC_OCENSETR_HSEBYP			BIT(10)
+#define RCC_OCENSETR_HSECSSON			BIT(11)
+
+/* RCC_OCENCLRR register fields */
+#define RCC_OCENCLRR_HSION			BIT(0)
+#define RCC_OCENCLRR_HSIKERON			BIT(1)
+#define RCC_OCENCLRR_HSEDIV2ON			BIT(5)
+#define RCC_OCENCLRR_HSEDIV2BYP			BIT(6)
+#define RCC_OCENCLRR_HSEDIGBYP			BIT(7)
+#define RCC_OCENCLRR_HSEON			BIT(8)
+#define RCC_OCENCLRR_HSEKERON			BIT(9)
+#define RCC_OCENCLRR_HSEBYP			BIT(10)
+
+/* RCC_OCRDYR register fields */
+#define RCC_OCRDYR_HSIRDY			BIT(0)
+#define RCC_OCRDYR_HSERDY			BIT(8)
+#define RCC_OCRDYR_CKREST			BIT(25)
+
+#define RCC_OCRDYR_HSIRDY_BIT			0
+#define RCC_OCRDYR_HSERDY_BIT			8
+
+/* RCC_HSICFGR register fields */
+#define RCC_HSICFGR_HSITRIM_MASK		GENMASK(14, 8)
+#define RCC_HSICFGR_HSITRIM_SHIFT		8
+#define RCC_HSICFGR_HSICAL_MASK			GENMASK(24, 16)
+#define RCC_HSICFGR_HSICAL_SHIFT		16
+
+/* osc_data register fields */
+#define RCC_MSICFGR_MSITRIM_MASK		GENMASK(12, 8)
+#define RCC_MSICFGR_MSITRIM_SHIFT		8
+#define RCC_MSICFGR_MSICAL_MASK			GENMASK(23, 16)
+#define RCC_MSICFGR_MSICAL_SHIFT		16
+
+/* RCC_RTCDIVR register fields */
+#define RCC_RTCDIVR_RTCDIV_MASK			GENMASK(5, 0)
+#define RCC_RTCDIVR_RTCDIV_SHIFT		0
+
+/* RCC_APB1DIVR register fields */
+#define RCC_APB1DIVR_APB1DIV_MASK		GENMASK(2, 0)
+#define RCC_APB1DIVR_APB1DIV_SHIFT		0
+#define RCC_APB1DIVR_APB1DIVRDY			BIT(31)
+
+/* RCC_APB2DIVR register fields */
+#define RCC_APB2DIVR_APB2DIV_MASK		GENMASK(2, 0)
+#define RCC_APB2DIVR_APB2DIV_SHIFT		0
+#define RCC_APB2DIVR_APB2DIVRDY			BIT(31)
+
+/* RCC_APB3DIVR register fields */
+#define RCC_APB3DIVR_APB3DIV_MASK		GENMASK(2, 0)
+#define RCC_APB3DIVR_APB3DIV_SHIFT		0
+#define RCC_APB3DIVR_APB3DIVRDY			BIT(31)
+
+/* RCC_APB4DIVR register fields */
+#define RCC_APB4DIVR_APB4DIV_MASK		GENMASK(2, 0)
+#define RCC_APB4DIVR_APB4DIV_SHIFT		0
+#define RCC_APB4DIVR_APB4DIVRDY			BIT(31)
+
+/* RCC_APBDBGDIVR register fields */
+#define RCC_APBDBGDIVR_APBDBGDIV_MASK		GENMASK(2, 0)
+#define RCC_APBDBGDIVR_APBDBGDIV_SHIFT		0
+#define RCC_APBDBGDIVR_APBDBGDIVRDY		BIT(31)
+
+/* RCC_APBxDIVR register fields */
+#define RCC_APBxDIVR_APBxDIV_MASK		GENMASK(2, 0)
+#define RCC_APBxDIVR_APBxDIV_SHIFT		0
+#define RCC_APBxDIVR_APBxDIVRDY			BIT(31)
+
+/* RCC_TIMG1PRER register fields */
+#define RCC_TIMG1PRER_TIMG1PRE			BIT(0)
+#define RCC_TIMG1PRER_TIMG1PRERDY		BIT(31)
+
+/* RCC_TIMG2PRER register fields */
+#define RCC_TIMG2PRER_TIMG2PRE			BIT(0)
+#define RCC_TIMG2PRER_TIMG2PRERDY		BIT(31)
+
+/* RCC_TIMGxPRER register fields */
+#define RCC_TIMGxPRER_TIMGxPRE			BIT(0)
+#define RCC_TIMGxPRER_TIMGxPRERDY		BIT(31)
+
+/* RCC_LSMCUDIVR register fields */
+#define RCC_LSMCUDIVR_LSMCUDIV			BIT(0)
+#define RCC_LSMCUDIVR_LSMCUDIVRDY		BIT(31)
+
+/* RCC_DDRCPCFGR register fields */
+#define RCC_DDRCPCFGR_DDRCPRST			BIT(0)
+#define RCC_DDRCPCFGR_DDRCPEN			BIT(1)
+#define RCC_DDRCPCFGR_DDRCPLPEN			BIT(2)
+
+/* RCC_DDRCAPBCFGR register fields */
+#define RCC_DDRCAPBCFGR_DDRCAPBRST		BIT(0)
+#define RCC_DDRCAPBCFGR_DDRCAPBEN		BIT(1)
+#define RCC_DDRCAPBCFGR_DDRCAPBLPEN		BIT(2)
+
+/* RCC_DDRPHYCAPBCFGR register fields */
+#define RCC_DDRPHYCAPBCFGR_DDRPHYCAPBRST	BIT(0)
+#define RCC_DDRPHYCAPBCFGR_DDRPHYCAPBEN		BIT(1)
+#define RCC_DDRPHYCAPBCFGR_DDRPHYCAPBLPEN	BIT(2)
+
+/* RCC_DDRPHYCCFGR register fields */
+#define RCC_DDRPHYCCFGR_DDRPHYCEN		BIT(1)
+
+/* RCC_DDRCFGR register fields */
+#define RCC_DDRCFGR_DDRCFGRST			BIT(0)
+#define RCC_DDRCFGR_DDRCFGEN			BIT(1)
+#define RCC_DDRCFGR_DDRCFGLPEN			BIT(2)
+
+/* RCC_DDRITFCFGR register fields */
+#define RCC_DDRITFCFGR_DDRRST			BIT(0)
+#define RCC_DDRITFCFGR_DDRCKMOD_MASK		GENMASK(5, 4)
+#define RCC_DDRITFCFGR_DDRCKMOD_SHIFT		4
+#define RCC_DDRITFCFGR_DDRSHR			BIT(8)
+#define RCC_DDRITFCFGR_DDRPHYDLP		BIT(16)
+
+/* RCC_SYSRAMCFGR register fields */
+#define RCC_SYSRAMCFGR_SYSRAMEN			BIT(1)
+#define RCC_SYSRAMCFGR_SYSRAMLPEN		BIT(2)
+
+/* RCC_VDERAMCFGR register fields */
+#define RCC_VDERAMCFGR_VDERAMEN			BIT(1)
+#define RCC_VDERAMCFGR_VDERAMLPEN		BIT(2)
+
+/* RCC_SRAM1CFGR register fields */
+#define RCC_SRAM1CFGR_SRAM1EN			BIT(1)
+#define RCC_SRAM1CFGR_SRAM1LPEN			BIT(2)
+
+/* RCC_SRAM2CFGR register fields */
+#define RCC_SRAM2CFGR_SRAM2EN			BIT(1)
+#define RCC_SRAM2CFGR_SRAM2LPEN			BIT(2)
+
+/* RCC_RETRAMCFGR register fields */
+#define RCC_RETRAMCFGR_RETRAMEN			BIT(1)
+#define RCC_RETRAMCFGR_RETRAMLPEN		BIT(2)
+
+/* RCC_BKPSRAMCFGR register fields */
+#define RCC_BKPSRAMCFGR_BKPSRAMEN		BIT(1)
+#define RCC_BKPSRAMCFGR_BKPSRAMLPEN		BIT(2)
+
+/* RCC_LPSRAM1CFGR register fields */
+#define RCC_LPSRAM1CFGR_LPSRAM1EN		BIT(1)
+#define RCC_LPSRAM1CFGR_LPSRAM1LPEN		BIT(2)
+#define RCC_LPSRAM1CFGR_LPSRAM1AMEN		BIT(3)
+
+/* RCC_LPSRAM2CFGR register fields */
+#define RCC_LPSRAM2CFGR_LPSRAM2EN		BIT(1)
+#define RCC_LPSRAM2CFGR_LPSRAM2LPEN		BIT(2)
+#define RCC_LPSRAM2CFGR_LPSRAM2AMEN		BIT(3)
+
+/* RCC_LPSRAM3CFGR register fields */
+#define RCC_LPSRAM3CFGR_LPSRAM3EN		BIT(1)
+#define RCC_LPSRAM3CFGR_LPSRAM3LPEN		BIT(2)
+#define RCC_LPSRAM3CFGR_LPSRAM3AMEN		BIT(3)
+
+/* RCC_OSPI1CFGR register fields */
+#define RCC_OSPI1CFGR_OSPI1RST			BIT(0)
+#define RCC_OSPI1CFGR_OSPI1EN			BIT(1)
+#define RCC_OSPI1CFGR_OSPI1LPEN			BIT(2)
+#define RCC_OSPI1CFGR_OTFDEC1RST		BIT(8)
+#define RCC_OSPI1CFGR_OSPI1DLLRST		BIT(16)
+
+/* RCC_OSPI2CFGR register fields */
+#define RCC_OSPI2CFGR_OSPI2RST			BIT(0)
+#define RCC_OSPI2CFGR_OSPI2EN			BIT(1)
+#define RCC_OSPI2CFGR_OSPI2LPEN			BIT(2)
+#define RCC_OSPI2CFGR_OTFDEC2RST		BIT(8)
+#define RCC_OSPI2CFGR_OSPI2DLLRST		BIT(16)
+
+/* RCC_OSPIxCFGR register fields */
+#define RCC_OSPIxCFGR_OSPIxRST			BIT(0)
+#define RCC_OSPIxCFGR_OSPIxEN			BIT(1)
+#define RCC_OSPIxCFGR_OSPIxLPEN			BIT(2)
+#define RCC_OSPIxCFGR_OTFDECxRST		BIT(8)
+#define RCC_OSPIxCFGR_OSPIxDLLRST		BIT(16)
+
+/* RCC_FMCCFGR register fields */
+#define RCC_FMCCFGR_FMCRST			BIT(0)
+#define RCC_FMCCFGR_FMCEN			BIT(1)
+#define RCC_FMCCFGR_FMCLPEN			BIT(2)
+
+/* RCC_DBGCFGR register fields */
+#define RCC_DBGCFGR_DBGEN			BIT(8)
+#define RCC_DBGCFGR_TRACEEN			BIT(9)
+#define RCC_DBGCFGR_DBGRST			BIT(12)
+
+/* RCC_STM500CFGR register fields */
+#define RCC_STM500CFGR_STM500EN			BIT(1)
+#define RCC_STM500CFGR_STM500LPEN		BIT(2)
+
+/* RCC_ETRCFGR register fields */
+#define RCC_ETRCFGR_ETREN			BIT(1)
+#define RCC_ETRCFGR_ETRLPEN			BIT(2)
+
+/* RCC_GPIOACFGR register fields */
+#define RCC_GPIOACFGR_GPIOARST			BIT(0)
+#define RCC_GPIOACFGR_GPIOAEN			BIT(1)
+#define RCC_GPIOACFGR_GPIOALPEN			BIT(2)
+
+/* RCC_GPIOBCFGR register fields */
+#define RCC_GPIOBCFGR_GPIOBRST			BIT(0)
+#define RCC_GPIOBCFGR_GPIOBEN			BIT(1)
+#define RCC_GPIOBCFGR_GPIOBLPEN			BIT(2)
+
+/* RCC_GPIOCCFGR register fields */
+#define RCC_GPIOCCFGR_GPIOCRST			BIT(0)
+#define RCC_GPIOCCFGR_GPIOCEN			BIT(1)
+#define RCC_GPIOCCFGR_GPIOCLPEN			BIT(2)
+
+/* RCC_GPIODCFGR register fields */
+#define RCC_GPIODCFGR_GPIODRST			BIT(0)
+#define RCC_GPIODCFGR_GPIODEN			BIT(1)
+#define RCC_GPIODCFGR_GPIODLPEN			BIT(2)
+
+/* RCC_GPIOECFGR register fields */
+#define RCC_GPIOECFGR_GPIOERST			BIT(0)
+#define RCC_GPIOECFGR_GPIOEEN			BIT(1)
+#define RCC_GPIOECFGR_GPIOELPEN			BIT(2)
+
+/* RCC_GPIOFCFGR register fields */
+#define RCC_GPIOFCFGR_GPIOFRST			BIT(0)
+#define RCC_GPIOFCFGR_GPIOFEN			BIT(1)
+#define RCC_GPIOFCFGR_GPIOFLPEN			BIT(2)
+
+/* RCC_GPIOGCFGR register fields */
+#define RCC_GPIOGCFGR_GPIOGRST			BIT(0)
+#define RCC_GPIOGCFGR_GPIOGEN			BIT(1)
+#define RCC_GPIOGCFGR_GPIOGLPEN			BIT(2)
+
+/* RCC_GPIOHCFGR register fields */
+#define RCC_GPIOHCFGR_GPIOHRST			BIT(0)
+#define RCC_GPIOHCFGR_GPIOHEN			BIT(1)
+#define RCC_GPIOHCFGR_GPIOHLPEN			BIT(2)
+
+/* RCC_GPIOICFGR register fields */
+#define RCC_GPIOICFGR_GPIOIRST			BIT(0)
+#define RCC_GPIOICFGR_GPIOIEN			BIT(1)
+#define RCC_GPIOICFGR_GPIOILPEN			BIT(2)
+
+/* RCC_GPIOJCFGR register fields */
+#define RCC_GPIOJCFGR_GPIOJRST			BIT(0)
+#define RCC_GPIOJCFGR_GPIOJEN			BIT(1)
+#define RCC_GPIOJCFGR_GPIOJLPEN			BIT(2)
+
+/* RCC_GPIOKCFGR register fields */
+#define RCC_GPIOKCFGR_GPIOKRST			BIT(0)
+#define RCC_GPIOKCFGR_GPIOKEN			BIT(1)
+#define RCC_GPIOKCFGR_GPIOKLPEN			BIT(2)
+
+/* RCC_GPIOZCFGR register fields */
+#define RCC_GPIOZCFGR_GPIOZRST			BIT(0)
+#define RCC_GPIOZCFGR_GPIOZEN			BIT(1)
+#define RCC_GPIOZCFGR_GPIOZLPEN			BIT(2)
+#define RCC_GPIOZCFGR_GPIOZAMEN			BIT(3)
+
+/* RCC_GPIOxCFGR register fields */
+#define RCC_GPIOxCFGR_GPIOxRST			BIT(0)
+#define RCC_GPIOxCFGR_GPIOxEN			BIT(1)
+#define RCC_GPIOxCFGR_GPIOxLPEN			BIT(2)
+#define RCC_GPIOxCFGR_GPIOxAMEN			BIT(3)
+
+/* RCC_HPDMA1CFGR register fields */
+#define RCC_HPDMA1CFGR_HPDMA1RST		BIT(0)
+#define RCC_HPDMA1CFGR_HPDMA1EN			BIT(1)
+#define RCC_HPDMA1CFGR_HPDMA1LPEN		BIT(2)
+
+/* RCC_HPDMA2CFGR register fields */
+#define RCC_HPDMA2CFGR_HPDMA2RST		BIT(0)
+#define RCC_HPDMA2CFGR_HPDMA2EN			BIT(1)
+#define RCC_HPDMA2CFGR_HPDMA2LPEN		BIT(2)
+
+/* RCC_HPDMA3CFGR register fields */
+#define RCC_HPDMA3CFGR_HPDMA3RST		BIT(0)
+#define RCC_HPDMA3CFGR_HPDMA3EN			BIT(1)
+#define RCC_HPDMA3CFGR_HPDMA3LPEN		BIT(2)
+
+/* RCC_HPDMAxCFGR register fields */
+#define RCC_HPDMAxCFGR_HPDMAxRST		BIT(0)
+#define RCC_HPDMAxCFGR_HPDMAxEN			BIT(1)
+#define RCC_HPDMAxCFGR_HPDMAxLPEN		BIT(2)
+
+/* RCC_LPDMACFGR register fields */
+#define RCC_LPDMACFGR_LPDMARST			BIT(0)
+#define RCC_LPDMACFGR_LPDMAEN			BIT(1)
+#define RCC_LPDMACFGR_LPDMALPEN			BIT(2)
+#define RCC_LPDMACFGR_LPDMAAMEN			BIT(3)
+
+/* RCC_HSEMCFGR register fields */
+#define RCC_HSEMCFGR_HSEMRST			BIT(0)
+#define RCC_HSEMCFGR_HSEMEN			BIT(1)
+#define RCC_HSEMCFGR_HSEMLPEN			BIT(2)
+#define RCC_HSEMCFGR_HSEMAMEN			BIT(3)
+
+/* RCC_IPCC1CFGR register fields */
+#define RCC_IPCC1CFGR_IPCC1RST			BIT(0)
+#define RCC_IPCC1CFGR_IPCC1EN			BIT(1)
+#define RCC_IPCC1CFGR_IPCC1LPEN			BIT(2)
+
+/* RCC_IPCC2CFGR register fields */
+#define RCC_IPCC2CFGR_IPCC2RST			BIT(0)
+#define RCC_IPCC2CFGR_IPCC2EN			BIT(1)
+#define RCC_IPCC2CFGR_IPCC2LPEN			BIT(2)
+#define RCC_IPCC2CFGR_IPCC2AMEN			BIT(3)
+
+/* RCC_RTCCFGR register fields */
+#define RCC_RTCCFGR_RTCEN			BIT(1)
+#define RCC_RTCCFGR_RTCLPEN			BIT(2)
+#define RCC_RTCCFGR_RTCAMEN			BIT(3)
+
+/* RCC_SYSCPU1CFGR register fields */
+#define RCC_SYSCPU1CFGR_SYSCPU1EN		BIT(1)
+#define RCC_SYSCPU1CFGR_SYSCPU1LPEN		BIT(2)
+
+/* RCC_BSECCFGR register fields */
+#define RCC_BSECCFGR_BSECEN			BIT(1)
+#define RCC_BSECCFGR_BSECLPEN			BIT(2)
+
+/* RCC_IS2MCFGR register fields */
+#define RCC_IS2MCFGR_IS2MRST			BIT(0)
+#define RCC_IS2MCFGR_IS2MEN			BIT(1)
+#define RCC_IS2MCFGR_IS2MLPEN			BIT(2)
+
+/* RCC_PLL2CFGR1 register fields */
+#define RCC_PLL2CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL2CFGR1_PLLEN			BIT(8)
+#define RCC_PLL2CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL2CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL2CFGR2 register fields */
+#define RCC_PLL2CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL2CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL2CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL2CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL2CFGR3 register fields */
+#define RCC_PLL2CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL2CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL2CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL2CFGR3_DACEN			BIT(25)
+#define RCC_PLL2CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL2CFGR4 register fields */
+#define RCC_PLL2CFGR4_DSMEN			BIT(8)
+#define RCC_PLL2CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL2CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL2CFGR5 register fields */
+#define RCC_PLL2CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL2CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL2CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL2CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL2CFGR6 register fields */
+#define RCC_PLL2CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL2CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL2CFGR7 register fields */
+#define RCC_PLL2CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL2CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL3CFGR1 register fields */
+#define RCC_PLL3CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL3CFGR1_PLLEN			BIT(8)
+#define RCC_PLL3CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL3CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL3CFGR2 register fields */
+#define RCC_PLL3CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL3CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL3CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL3CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL3CFGR3 register fields */
+#define RCC_PLL3CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL3CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL3CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL3CFGR3_DACEN			BIT(25)
+#define RCC_PLL3CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL3CFGR4 register fields */
+#define RCC_PLL3CFGR4_DSMEN			BIT(8)
+#define RCC_PLL3CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL3CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL3CFGR5 register fields */
+#define RCC_PLL3CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL3CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL3CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL3CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL3CFGR6 register fields */
+#define RCC_PLL3CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL3CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL3CFGR7 register fields */
+#define RCC_PLL3CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL3CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLLxCFGR1 register fields */
+#define RCC_PLLxCFGR1_SSMODRST			BIT(0)
+#define RCC_PLLxCFGR1_PLLEN			BIT(8)
+#define RCC_PLLxCFGR1_PLLRDY			BIT(24)
+#define RCC_PLLxCFGR1_CKREFST			BIT(28)
+
+/* RCC_PLLxCFGR2 register fields */
+#define RCC_PLLxCFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLLxCFGR2_FREFDIV_SHIFT		0
+#define RCC_PLLxCFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLLxCFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLLxCFGR3 register fields */
+#define RCC_PLLxCFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLLxCFGR3_FRACIN_SHIFT		0
+#define RCC_PLLxCFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLLxCFGR3_DACEN			BIT(25)
+#define RCC_PLLxCFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLLxCFGR4 register fields */
+#define RCC_PLLxCFGR4_DSMEN			BIT(8)
+#define RCC_PLLxCFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLLxCFGR4_BYPASS			BIT(10)
+
+/* RCC_PLLxCFGR5 register fields */
+#define RCC_PLLxCFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLLxCFGR5_DIVVAL_SHIFT		0
+#define RCC_PLLxCFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLLxCFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLLxCFGR6 register fields */
+#define RCC_PLLxCFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLLxCFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLLxCFGR7 register fields */
+#define RCC_PLLxCFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLLxCFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_HSIFMONCR register fields */
+#define RCC_HSIFMONCR_HSIREF_MASK		GENMASK(10, 0)
+#define RCC_HSIFMONCR_HSIREF_SHIFT		0
+#define RCC_HSIFMONCR_HSIMONEN			BIT(15)
+#define RCC_HSIFMONCR_HSIDEV_MASK		GENMASK(21, 16)
+#define RCC_HSIFMONCR_HSIDEV_SHIFT		16
+#define RCC_HSIFMONCR_HSIMONIE			BIT(30)
+#define RCC_HSIFMONCR_HSIMONF			BIT(31)
+
+/* RCC_HSIFVALR register fields */
+#define RCC_HSIFVALR_HSIVAL_MASK		GENMASK(10, 0)
+#define RCC_HSIFVALR_HSIVAL_SHIFT		0
+
+/* RCC_TIM1CFGR register fields */
+#define RCC_TIM1CFGR_TIM1RST			BIT(0)
+#define RCC_TIM1CFGR_TIM1EN			BIT(1)
+#define RCC_TIM1CFGR_TIM1LPEN			BIT(2)
+
+/* RCC_TIM2CFGR register fields */
+#define RCC_TIM2CFGR_TIM2RST			BIT(0)
+#define RCC_TIM2CFGR_TIM2EN			BIT(1)
+#define RCC_TIM2CFGR_TIM2LPEN			BIT(2)
+
+/* RCC_TIM3CFGR register fields */
+#define RCC_TIM3CFGR_TIM3RST			BIT(0)
+#define RCC_TIM3CFGR_TIM3EN			BIT(1)
+#define RCC_TIM3CFGR_TIM3LPEN			BIT(2)
+
+/* RCC_TIM4CFGR register fields */
+#define RCC_TIM4CFGR_TIM4RST			BIT(0)
+#define RCC_TIM4CFGR_TIM4EN			BIT(1)
+#define RCC_TIM4CFGR_TIM4LPEN			BIT(2)
+
+/* RCC_TIM5CFGR register fields */
+#define RCC_TIM5CFGR_TIM5RST			BIT(0)
+#define RCC_TIM5CFGR_TIM5EN			BIT(1)
+#define RCC_TIM5CFGR_TIM5LPEN			BIT(2)
+
+/* RCC_TIM6CFGR register fields */
+#define RCC_TIM6CFGR_TIM6RST			BIT(0)
+#define RCC_TIM6CFGR_TIM6EN			BIT(1)
+#define RCC_TIM6CFGR_TIM6LPEN			BIT(2)
+
+/* RCC_TIM7CFGR register fields */
+#define RCC_TIM7CFGR_TIM7RST			BIT(0)
+#define RCC_TIM7CFGR_TIM7EN			BIT(1)
+#define RCC_TIM7CFGR_TIM7LPEN			BIT(2)
+
+/* RCC_TIM8CFGR register fields */
+#define RCC_TIM8CFGR_TIM8RST			BIT(0)
+#define RCC_TIM8CFGR_TIM8EN			BIT(1)
+#define RCC_TIM8CFGR_TIM8LPEN			BIT(2)
+
+/* RCC_TIM10CFGR register fields */
+#define RCC_TIM10CFGR_TIM10RST			BIT(0)
+#define RCC_TIM10CFGR_TIM10EN			BIT(1)
+#define RCC_TIM10CFGR_TIM10LPEN			BIT(2)
+
+/* RCC_TIM11CFGR register fields */
+#define RCC_TIM11CFGR_TIM11RST			BIT(0)
+#define RCC_TIM11CFGR_TIM11EN			BIT(1)
+#define RCC_TIM11CFGR_TIM11LPEN			BIT(2)
+
+/* RCC_TIM12CFGR register fields */
+#define RCC_TIM12CFGR_TIM12RST			BIT(0)
+#define RCC_TIM12CFGR_TIM12EN			BIT(1)
+#define RCC_TIM12CFGR_TIM12LPEN			BIT(2)
+
+/* RCC_TIM13CFGR register fields */
+#define RCC_TIM13CFGR_TIM13RST			BIT(0)
+#define RCC_TIM13CFGR_TIM13EN			BIT(1)
+#define RCC_TIM13CFGR_TIM13LPEN			BIT(2)
+
+/* RCC_TIM14CFGR register fields */
+#define RCC_TIM14CFGR_TIM14RST			BIT(0)
+#define RCC_TIM14CFGR_TIM14EN			BIT(1)
+#define RCC_TIM14CFGR_TIM14LPEN			BIT(2)
+
+/* RCC_TIM15CFGR register fields */
+#define RCC_TIM15CFGR_TIM15RST			BIT(0)
+#define RCC_TIM15CFGR_TIM15EN			BIT(1)
+#define RCC_TIM15CFGR_TIM15LPEN			BIT(2)
+
+/* RCC_TIM16CFGR register fields */
+#define RCC_TIM16CFGR_TIM16RST			BIT(0)
+#define RCC_TIM16CFGR_TIM16EN			BIT(1)
+#define RCC_TIM16CFGR_TIM16LPEN			BIT(2)
+
+/* RCC_TIM17CFGR register fields */
+#define RCC_TIM17CFGR_TIM17RST			BIT(0)
+#define RCC_TIM17CFGR_TIM17EN			BIT(1)
+#define RCC_TIM17CFGR_TIM17LPEN			BIT(2)
+
+/* RCC_TIM20CFGR register fields */
+#define RCC_TIM20CFGR_TIM20RST			BIT(0)
+#define RCC_TIM20CFGR_TIM20EN			BIT(1)
+#define RCC_TIM20CFGR_TIM20LPEN			BIT(2)
+
+/* RCC_LPTIM1CFGR register fields */
+#define RCC_LPTIM1CFGR_LPTIM1RST		BIT(0)
+#define RCC_LPTIM1CFGR_LPTIM1EN			BIT(1)
+#define RCC_LPTIM1CFGR_LPTIM1LPEN		BIT(2)
+
+/* RCC_LPTIM2CFGR register fields */
+#define RCC_LPTIM2CFGR_LPTIM2RST		BIT(0)
+#define RCC_LPTIM2CFGR_LPTIM2EN			BIT(1)
+#define RCC_LPTIM2CFGR_LPTIM2LPEN		BIT(2)
+
+/* RCC_LPTIM3CFGR register fields */
+#define RCC_LPTIM3CFGR_LPTIM3RST		BIT(0)
+#define RCC_LPTIM3CFGR_LPTIM3EN			BIT(1)
+#define RCC_LPTIM3CFGR_LPTIM3LPEN		BIT(2)
+#define RCC_LPTIM3CFGR_LPTIM3AMEN		BIT(3)
+
+/* RCC_LPTIM4CFGR register fields */
+#define RCC_LPTIM4CFGR_LPTIM4RST		BIT(0)
+#define RCC_LPTIM4CFGR_LPTIM4EN			BIT(1)
+#define RCC_LPTIM4CFGR_LPTIM4LPEN		BIT(2)
+#define RCC_LPTIM4CFGR_LPTIM4AMEN		BIT(3)
+
+/* RCC_LPTIM5CFGR register fields */
+#define RCC_LPTIM5CFGR_LPTIM5RST		BIT(0)
+#define RCC_LPTIM5CFGR_LPTIM5EN			BIT(1)
+#define RCC_LPTIM5CFGR_LPTIM5LPEN		BIT(2)
+#define RCC_LPTIM5CFGR_LPTIM5AMEN		BIT(3)
+
+/* RCC_LPTIMxCFGR register fields */
+#define RCC_LPTIMxCFGR_LPTIMxRST		BIT(0)
+#define RCC_LPTIMxCFGR_LPTIMxEN			BIT(1)
+#define RCC_LPTIMxCFGR_LPTIMxLPEN		BIT(2)
+#define RCC_LPTIMxCFGR_LPTIMxAMEN		BIT(3)
+
+/* RCC_SPI1CFGR register fields */
+#define RCC_SPI1CFGR_SPI1RST			BIT(0)
+#define RCC_SPI1CFGR_SPI1EN			BIT(1)
+#define RCC_SPI1CFGR_SPI1LPEN			BIT(2)
+
+/* RCC_SPI2CFGR register fields */
+#define RCC_SPI2CFGR_SPI2RST			BIT(0)
+#define RCC_SPI2CFGR_SPI2EN			BIT(1)
+#define RCC_SPI2CFGR_SPI2LPEN			BIT(2)
+
+/* RCC_SPI3CFGR register fields */
+#define RCC_SPI3CFGR_SPI3RST			BIT(0)
+#define RCC_SPI3CFGR_SPI3EN			BIT(1)
+#define RCC_SPI3CFGR_SPI3LPEN			BIT(2)
+
+/* RCC_SPI4CFGR register fields */
+#define RCC_SPI4CFGR_SPI4RST			BIT(0)
+#define RCC_SPI4CFGR_SPI4EN			BIT(1)
+#define RCC_SPI4CFGR_SPI4LPEN			BIT(2)
+
+/* RCC_SPI5CFGR register fields */
+#define RCC_SPI5CFGR_SPI5RST			BIT(0)
+#define RCC_SPI5CFGR_SPI5EN			BIT(1)
+#define RCC_SPI5CFGR_SPI5LPEN			BIT(2)
+
+/* RCC_SPI6CFGR register fields */
+#define RCC_SPI6CFGR_SPI6RST			BIT(0)
+#define RCC_SPI6CFGR_SPI6EN			BIT(1)
+#define RCC_SPI6CFGR_SPI6LPEN			BIT(2)
+
+/* RCC_SPI7CFGR register fields */
+#define RCC_SPI7CFGR_SPI7RST			BIT(0)
+#define RCC_SPI7CFGR_SPI7EN			BIT(1)
+#define RCC_SPI7CFGR_SPI7LPEN			BIT(2)
+
+/* RCC_SPI8CFGR register fields */
+#define RCC_SPI8CFGR_SPI8RST			BIT(0)
+#define RCC_SPI8CFGR_SPI8EN			BIT(1)
+#define RCC_SPI8CFGR_SPI8LPEN			BIT(2)
+#define RCC_SPI8CFGR_SPI8AMEN			BIT(3)
+
+/* RCC_SPIxCFGR register fields */
+#define RCC_SPIxCFGR_SPIxRST			BIT(0)
+#define RCC_SPIxCFGR_SPIxEN			BIT(1)
+#define RCC_SPIxCFGR_SPIxLPEN			BIT(2)
+#define RCC_SPIxCFGR_SPIxAMEN			BIT(3)
+
+/* RCC_SPDIFRXCFGR register fields */
+#define RCC_SPDIFRXCFGR_SPDIFRXRST		BIT(0)
+#define RCC_SPDIFRXCFGR_SPDIFRXEN		BIT(1)
+#define RCC_SPDIFRXCFGR_SPDIFRXLPEN		BIT(2)
+
+/* RCC_USART1CFGR register fields */
+#define RCC_USART1CFGR_USART1RST		BIT(0)
+#define RCC_USART1CFGR_USART1EN			BIT(1)
+#define RCC_USART1CFGR_USART1LPEN		BIT(2)
+
+/* RCC_USART2CFGR register fields */
+#define RCC_USART2CFGR_USART2RST		BIT(0)
+#define RCC_USART2CFGR_USART2EN			BIT(1)
+#define RCC_USART2CFGR_USART2LPEN		BIT(2)
+
+/* RCC_USART3CFGR register fields */
+#define RCC_USART3CFGR_USART3RST		BIT(0)
+#define RCC_USART3CFGR_USART3EN			BIT(1)
+#define RCC_USART3CFGR_USART3LPEN		BIT(2)
+
+/* RCC_UART4CFGR register fields */
+#define RCC_UART4CFGR_UART4RST			BIT(0)
+#define RCC_UART4CFGR_UART4EN			BIT(1)
+#define RCC_UART4CFGR_UART4LPEN			BIT(2)
+
+/* RCC_UART5CFGR register fields */
+#define RCC_UART5CFGR_UART5RST			BIT(0)
+#define RCC_UART5CFGR_UART5EN			BIT(1)
+#define RCC_UART5CFGR_UART5LPEN			BIT(2)
+
+/* RCC_USART6CFGR register fields */
+#define RCC_USART6CFGR_USART6RST		BIT(0)
+#define RCC_USART6CFGR_USART6EN			BIT(1)
+#define RCC_USART6CFGR_USART6LPEN		BIT(2)
+
+/* RCC_UART7CFGR register fields */
+#define RCC_UART7CFGR_UART7RST			BIT(0)
+#define RCC_UART7CFGR_UART7EN			BIT(1)
+#define RCC_UART7CFGR_UART7LPEN			BIT(2)
+
+/* RCC_UART8CFGR register fields */
+#define RCC_UART8CFGR_UART8RST			BIT(0)
+#define RCC_UART8CFGR_UART8EN			BIT(1)
+#define RCC_UART8CFGR_UART8LPEN			BIT(2)
+
+/* RCC_UART9CFGR register fields */
+#define RCC_UART9CFGR_UART9RST			BIT(0)
+#define RCC_UART9CFGR_UART9EN			BIT(1)
+#define RCC_UART9CFGR_UART9LPEN			BIT(2)
+
+/* RCC_USARTxCFGR register fields */
+#define RCC_USARTxCFGR_USARTxRST		BIT(0)
+#define RCC_USARTxCFGR_USARTxEN			BIT(1)
+#define RCC_USARTxCFGR_USARTxLPEN		BIT(2)
+
+/* RCC_UARTxCFGR register fields */
+#define RCC_UARTxCFGR_UARTxRST			BIT(0)
+#define RCC_UARTxCFGR_UARTxEN			BIT(1)
+#define RCC_UARTxCFGR_UARTxLPEN			BIT(2)
+
+/* RCC_LPUART1CFGR register fields */
+#define RCC_LPUART1CFGR_LPUART1RST		BIT(0)
+#define RCC_LPUART1CFGR_LPUART1EN		BIT(1)
+#define RCC_LPUART1CFGR_LPUART1LPEN		BIT(2)
+#define RCC_LPUART1CFGR_LPUART1AMEN		BIT(3)
+
+/* RCC_I2C1CFGR register fields */
+#define RCC_I2C1CFGR_I2C1RST			BIT(0)
+#define RCC_I2C1CFGR_I2C1EN			BIT(1)
+#define RCC_I2C1CFGR_I2C1LPEN			BIT(2)
+
+/* RCC_I2C2CFGR register fields */
+#define RCC_I2C2CFGR_I2C2RST			BIT(0)
+#define RCC_I2C2CFGR_I2C2EN			BIT(1)
+#define RCC_I2C2CFGR_I2C2LPEN			BIT(2)
+
+/* RCC_I2C3CFGR register fields */
+#define RCC_I2C3CFGR_I2C3RST			BIT(0)
+#define RCC_I2C3CFGR_I2C3EN			BIT(1)
+#define RCC_I2C3CFGR_I2C3LPEN			BIT(2)
+
+/* RCC_I2C4CFGR register fields */
+#define RCC_I2C4CFGR_I2C4RST			BIT(0)
+#define RCC_I2C4CFGR_I2C4EN			BIT(1)
+#define RCC_I2C4CFGR_I2C4LPEN			BIT(2)
+
+/* RCC_I2C5CFGR register fields */
+#define RCC_I2C5CFGR_I2C5RST			BIT(0)
+#define RCC_I2C5CFGR_I2C5EN			BIT(1)
+#define RCC_I2C5CFGR_I2C5LPEN			BIT(2)
+
+/* RCC_I2C6CFGR register fields */
+#define RCC_I2C6CFGR_I2C6RST			BIT(0)
+#define RCC_I2C6CFGR_I2C6EN			BIT(1)
+#define RCC_I2C6CFGR_I2C6LPEN			BIT(2)
+
+/* RCC_I2C7CFGR register fields */
+#define RCC_I2C7CFGR_I2C7RST			BIT(0)
+#define RCC_I2C7CFGR_I2C7EN			BIT(1)
+#define RCC_I2C7CFGR_I2C7LPEN			BIT(2)
+
+/* RCC_I2C8CFGR register fields */
+#define RCC_I2C8CFGR_I2C8RST			BIT(0)
+#define RCC_I2C8CFGR_I2C8EN			BIT(1)
+#define RCC_I2C8CFGR_I2C8LPEN			BIT(2)
+#define RCC_I2C8CFGR_I2C8AMEN			BIT(3)
+
+/* RCC_I2CxCFGR register fields */
+#define RCC_I2CxCFGR_I2CxRST			BIT(0)
+#define RCC_I2CxCFGR_I2CxEN			BIT(1)
+#define RCC_I2CxCFGR_I2CxLPEN			BIT(2)
+#define RCC_I2CxCFGR_I2CxAMEN			BIT(3)
+
+/* RCC_SAI1CFGR register fields */
+#define RCC_SAI1CFGR_SAI1RST			BIT(0)
+#define RCC_SAI1CFGR_SAI1EN			BIT(1)
+#define RCC_SAI1CFGR_SAI1LPEN			BIT(2)
+
+/* RCC_SAI2CFGR register fields */
+#define RCC_SAI2CFGR_SAI2RST			BIT(0)
+#define RCC_SAI2CFGR_SAI2EN			BIT(1)
+#define RCC_SAI2CFGR_SAI2LPEN			BIT(2)
+
+/* RCC_SAI3CFGR register fields */
+#define RCC_SAI3CFGR_SAI3RST			BIT(0)
+#define RCC_SAI3CFGR_SAI3EN			BIT(1)
+#define RCC_SAI3CFGR_SAI3LPEN			BIT(2)
+
+/* RCC_SAI4CFGR register fields */
+#define RCC_SAI4CFGR_SAI4RST			BIT(0)
+#define RCC_SAI4CFGR_SAI4EN			BIT(1)
+#define RCC_SAI4CFGR_SAI4LPEN			BIT(2)
+
+/* RCC_SAIxCFGR register fields */
+#define RCC_SAIxCFGR_SAIxRST			BIT(0)
+#define RCC_SAIxCFGR_SAIxEN			BIT(1)
+#define RCC_SAIxCFGR_SAIxLPEN			BIT(2)
+
+/* RCC_MDF1CFGR register fields */
+#define RCC_MDF1CFGR_MDF1RST			BIT(0)
+#define RCC_MDF1CFGR_MDF1EN			BIT(1)
+#define RCC_MDF1CFGR_MDF1LPEN			BIT(2)
+
+/* RCC_ADF1CFGR register fields */
+#define RCC_ADF1CFGR_ADF1RST			BIT(0)
+#define RCC_ADF1CFGR_ADF1EN			BIT(1)
+#define RCC_ADF1CFGR_ADF1LPEN			BIT(2)
+#define RCC_ADF1CFGR_ADF1AMEN			BIT(3)
+
+/* RCC_FDCANCFGR register fields */
+#define RCC_FDCANCFGR_FDCANRST			BIT(0)
+#define RCC_FDCANCFGR_FDCANEN			BIT(1)
+#define RCC_FDCANCFGR_FDCANLPEN			BIT(2)
+
+/* RCC_HDPCFGR register fields */
+#define RCC_HDPCFGR_HDPRST			BIT(0)
+#define RCC_HDPCFGR_HDPEN			BIT(1)
+
+/* RCC_ADC12CFGR register fields */
+#define RCC_ADC12CFGR_ADC12RST			BIT(0)
+#define RCC_ADC12CFGR_ADC12EN			BIT(1)
+#define RCC_ADC12CFGR_ADC12LPEN			BIT(2)
+#define RCC_ADC12CFGR_ADC12KERSEL		BIT(12)
+
+/* RCC_ADC3CFGR register fields */
+#define RCC_ADC3CFGR_ADC3RST			BIT(0)
+#define RCC_ADC3CFGR_ADC3EN			BIT(1)
+#define RCC_ADC3CFGR_ADC3LPEN			BIT(2)
+#define RCC_ADC3CFGR_ADC3KERSEL_MASK		GENMASK(13, 12)
+#define RCC_ADC3CFGR_ADC3KERSEL_SHIFT		12
+
+/* RCC_ETH1CFGR register fields */
+#define RCC_ETH1CFGR_ETH1RST			BIT(0)
+#define RCC_ETH1CFGR_ETH1MACEN			BIT(1)
+#define RCC_ETH1CFGR_ETH1MACLPEN		BIT(2)
+#define RCC_ETH1CFGR_ETH1STPEN			BIT(4)
+#define RCC_ETH1CFGR_ETH1EN			BIT(5)
+#define RCC_ETH1CFGR_ETH1LPEN			BIT(6)
+#define RCC_ETH1CFGR_ETH1TXEN			BIT(8)
+#define RCC_ETH1CFGR_ETH1TXLPEN			BIT(9)
+#define RCC_ETH1CFGR_ETH1RXEN			BIT(10)
+#define RCC_ETH1CFGR_ETH1RXLPEN			BIT(11)
+
+/* RCC_ETH2CFGR register fields */
+#define RCC_ETH2CFGR_ETH2RST			BIT(0)
+#define RCC_ETH2CFGR_ETH2MACEN			BIT(1)
+#define RCC_ETH2CFGR_ETH2MACLPEN		BIT(2)
+#define RCC_ETH2CFGR_ETH2STPEN			BIT(4)
+#define RCC_ETH2CFGR_ETH2EN			BIT(5)
+#define RCC_ETH2CFGR_ETH2LPEN			BIT(6)
+#define RCC_ETH2CFGR_ETH2TXEN			BIT(8)
+#define RCC_ETH2CFGR_ETH2TXLPEN			BIT(9)
+#define RCC_ETH2CFGR_ETH2RXEN			BIT(10)
+#define RCC_ETH2CFGR_ETH2RXLPEN			BIT(11)
+
+/* RCC_ETHxCFGR register fields */
+#define RCC_ETHxCFGR_ETHxRST			BIT(0)
+#define RCC_ETHxCFGR_ETHxMACEN			BIT(1)
+#define RCC_ETHxCFGR_ETHxMACLPEN		BIT(2)
+#define RCC_ETHxCFGR_ETHxSTPEN			BIT(4)
+#define RCC_ETHxCFGR_ETHxEN			BIT(5)
+#define RCC_ETHxCFGR_ETHxLPEN			BIT(6)
+#define RCC_ETHxCFGR_ETHxTXEN			BIT(8)
+#define RCC_ETHxCFGR_ETHxTXLPEN			BIT(9)
+#define RCC_ETHxCFGR_ETHxRXEN			BIT(10)
+#define RCC_ETHxCFGR_ETHxRXLPEN			BIT(11)
+
+/* RCC_USB2CFGR register fields */
+#define RCC_USB2CFGR_USB2RST			BIT(0)
+#define RCC_USB2CFGR_USB2EN			BIT(1)
+#define RCC_USB2CFGR_USB2LPEN			BIT(2)
+#define RCC_USB2CFGR_USB2STPEN			BIT(4)
+
+/* RCC_USB2PHY1CFGR register fields */
+#define RCC_USB2PHY1CFGR_USB2PHY1RST		BIT(0)
+#define RCC_USB2PHY1CFGR_USB2PHY1EN		BIT(1)
+#define RCC_USB2PHY1CFGR_USB2PHY1LPEN		BIT(2)
+#define RCC_USB2PHY1CFGR_USB2PHY1STPEN		BIT(4)
+#define RCC_USB2PHY1CFGR_USB2PHY1CKREFSEL	BIT(15)
+
+/* RCC_USB2PHY2CFGR register fields */
+#define RCC_USB2PHY2CFGR_USB2PHY2RST		BIT(0)
+#define RCC_USB2PHY2CFGR_USB2PHY2EN		BIT(1)
+#define RCC_USB2PHY2CFGR_USB2PHY2LPEN		BIT(2)
+#define RCC_USB2PHY2CFGR_USB2PHY2STPEN		BIT(4)
+#define RCC_USB2PHY2CFGR_USB2PHY2CKREFSEL	BIT(15)
+
+/* RCC_USB2PHYxCFGR register fields */
+#define RCC_USB2PHYxCFGR_USB2PHY1RST		BIT(0)
+#define RCC_USB2PHYxCFGR_USB2PHY1EN		BIT(1)
+#define RCC_USB2PHYxCFGR_USB2PHY1LPEN		BIT(2)
+#define RCC_USB2PHYxCFGR_USB2PHY1STPEN		BIT(4)
+#define RCC_USB2PHYxCFGR_USB2PHY1CKREFSEL	BIT(15)
+
+/* RCC_USB3DRDCFGR register fields */
+#define RCC_USB3DRDCFGR_USB3DRDRST		BIT(0)
+#define RCC_USB3DRDCFGR_USB3DRDEN		BIT(1)
+#define RCC_USB3DRDCFGR_USB3DRDLPEN		BIT(2)
+#define RCC_USB3DRDCFGR_USB3DRDSTPEN		BIT(4)
+
+/* RCC_USB3PCIEPHYCFGR register fields */
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYRST	BIT(0)
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYEN	BIT(1)
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYLPEN	BIT(2)
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYSTPEN	BIT(4)
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYCKREFSEL	BIT(15)
+
+/* RCC_PCIECFGR register fields */
+#define RCC_PCIECFGR_PCIERST			BIT(0)
+#define RCC_PCIECFGR_PCIEEN			BIT(1)
+#define RCC_PCIECFGR_PCIELPEN			BIT(2)
+#define RCC_PCIECFGR_PCIESTPEN			BIT(4)
+
+/* RCC_USBTCCFGR register fields */
+#define RCC_USBTCCFGR_USBTCRST			BIT(0)
+#define RCC_USBTCCFGR_USBTCEN			BIT(1)
+#define RCC_USBTCCFGR_USBTCLPEN			BIT(2)
+
+/* RCC_ETHSWCFGR register fields */
+#define RCC_ETHSWCFGR_ETHSWRST			BIT(0)
+#define RCC_ETHSWCFGR_ETHSWMACEN		BIT(1)
+#define RCC_ETHSWCFGR_ETHSWMACLPEN		BIT(2)
+#define RCC_ETHSWCFGR_ETHSWEN			BIT(5)
+#define RCC_ETHSWCFGR_ETHSWLPEN			BIT(6)
+#define RCC_ETHSWCFGR_ETHSWREFEN		BIT(21)
+#define RCC_ETHSWCFGR_ETHSWREFLPEN		BIT(22)
+
+/* RCC_ETHSWACMCFGR register fields */
+#define RCC_ETHSWACMCFGR_ETHSWACMEN		BIT(1)
+#define RCC_ETHSWACMCFGR_ETHSWACMLPEN		BIT(2)
+
+/* RCC_ETHSWACMMSGCFGR register fields */
+#define RCC_ETHSWACMMSGCFGR_ETHSWACMMSGEN	BIT(1)
+#define RCC_ETHSWACMMSGCFGR_ETHSWACMMSGLPEN	BIT(2)
+
+/* RCC_STGENCFGR register fields */
+#define RCC_STGENCFGR_STGENEN			BIT(1)
+#define RCC_STGENCFGR_STGENLPEN			BIT(2)
+#define RCC_STGENCFGR_STGENSTPEN		BIT(4)
+
+/* RCC_SDMMC1CFGR register fields */
+#define RCC_SDMMC1CFGR_SDMMC1RST		BIT(0)
+#define RCC_SDMMC1CFGR_SDMMC1EN			BIT(1)
+#define RCC_SDMMC1CFGR_SDMMC1LPEN		BIT(2)
+#define RCC_SDMMC1CFGR_SDMMC1DLLRST		BIT(16)
+
+/* RCC_SDMMC2CFGR register fields */
+#define RCC_SDMMC2CFGR_SDMMC2RST		BIT(0)
+#define RCC_SDMMC2CFGR_SDMMC2EN			BIT(1)
+#define RCC_SDMMC2CFGR_SDMMC2LPEN		BIT(2)
+#define RCC_SDMMC2CFGR_SDMMC2DLLRST		BIT(16)
+
+/* RCC_SDMMC3CFGR register fields */
+#define RCC_SDMMC3CFGR_SDMMC3RST		BIT(0)
+#define RCC_SDMMC3CFGR_SDMMC3EN			BIT(1)
+#define RCC_SDMMC3CFGR_SDMMC3LPEN		BIT(2)
+#define RCC_SDMMC3CFGR_SDMMC3DLLRST		BIT(16)
+
+/* RCC_SDMMCxCFGR register fields */
+#define RCC_SDMMCxCFGR_SDMMC1RST		BIT(0)
+#define RCC_SDMMCxCFGR_SDMMC1EN			BIT(1)
+#define RCC_SDMMCxCFGR_SDMMC1LPEN		BIT(2)
+#define RCC_SDMMCxCFGR_SDMMC1DLLRST		BIT(16)
+
+/* RCC_GPUCFGR register fields */
+#define RCC_GPUCFGR_GPURST			BIT(0)
+#define RCC_GPUCFGR_GPUEN			BIT(1)
+#define RCC_GPUCFGR_GPULPEN			BIT(2)
+
+/* RCC_LTDCCFGR register fields */
+#define RCC_LTDCCFGR_LTDCRST			BIT(0)
+#define RCC_LTDCCFGR_LTDCEN			BIT(1)
+#define RCC_LTDCCFGR_LTDCLPEN			BIT(2)
+
+/* RCC_DSICFGR register fields */
+#define RCC_DSICFGR_DSIRST			BIT(0)
+#define RCC_DSICFGR_DSIEN			BIT(1)
+#define RCC_DSICFGR_DSILPEN			BIT(2)
+#define RCC_DSICFGR_DSIBLSEL			BIT(12)
+#define RCC_DSICFGR_DSIPHYCKREFSEL		BIT(15)
+
+/* RCC_LVDSCFGR register fields */
+#define RCC_LVDSCFGR_LVDSRST			BIT(0)
+#define RCC_LVDSCFGR_LVDSEN			BIT(1)
+#define RCC_LVDSCFGR_LVDSLPEN			BIT(2)
+#define RCC_LVDSCFGR_LVDSPHYCKREFSEL		BIT(15)
+
+/* RCC_CSICFGR register fields */
+#define RCC_CSICFGR_CSIRST			BIT(0)
+#define RCC_CSICFGR_CSIEN			BIT(1)
+#define RCC_CSICFGR_CSILPEN			BIT(2)
+
+/* RCC_DCMIPPCFGR register fields */
+#define RCC_DCMIPPCFGR_DCMIPPRST		BIT(0)
+#define RCC_DCMIPPCFGR_DCMIPPEN			BIT(1)
+#define RCC_DCMIPPCFGR_DCMIPPLPEN		BIT(2)
+
+/* RCC_CCICFGR register fields */
+#define RCC_CCICFGR_CCIRST			BIT(0)
+#define RCC_CCICFGR_CCIEN			BIT(1)
+#define RCC_CCICFGR_CCILPEN			BIT(2)
+
+/* RCC_VDECCFGR register fields */
+#define RCC_VDECCFGR_VDECRST			BIT(0)
+#define RCC_VDECCFGR_VDECEN			BIT(1)
+#define RCC_VDECCFGR_VDECLPEN			BIT(2)
+
+/* RCC_VENCCFGR register fields */
+#define RCC_VENCCFGR_VENCRST			BIT(0)
+#define RCC_VENCCFGR_VENCEN			BIT(1)
+#define RCC_VENCCFGR_VENCLPEN			BIT(2)
+
+/* RCC_RNGCFGR register fields */
+#define RCC_RNGCFGR_RNGRST			BIT(0)
+#define RCC_RNGCFGR_RNGEN			BIT(1)
+#define RCC_RNGCFGR_RNGLPEN			BIT(2)
+
+/* RCC_PKACFGR register fields */
+#define RCC_PKACFGR_PKARST			BIT(0)
+#define RCC_PKACFGR_PKAEN			BIT(1)
+#define RCC_PKACFGR_PKALPEN			BIT(2)
+
+/* RCC_SAESCFGR register fields */
+#define RCC_SAESCFGR_SAESRST			BIT(0)
+#define RCC_SAESCFGR_SAESEN			BIT(1)
+#define RCC_SAESCFGR_SAESLPEN			BIT(2)
+
+/* RCC_HASHCFGR register fields */
+#define RCC_HASHCFGR_HASHRST			BIT(0)
+#define RCC_HASHCFGR_HASHEN			BIT(1)
+#define RCC_HASHCFGR_HASHLPEN			BIT(2)
+
+/* RCC_CRYP1CFGR register fields */
+#define RCC_CRYP1CFGR_CRYP1RST			BIT(0)
+#define RCC_CRYP1CFGR_CRYP1EN			BIT(1)
+#define RCC_CRYP1CFGR_CRYP1LPEN			BIT(2)
+
+/* RCC_CRYP2CFGR register fields */
+#define RCC_CRYP2CFGR_CRYP2RST			BIT(0)
+#define RCC_CRYP2CFGR_CRYP2EN			BIT(1)
+#define RCC_CRYP2CFGR_CRYP2LPEN			BIT(2)
+
+/* RCC_CRYPxCFGR register fields */
+#define RCC_CRYPxCFGR_CRYPxRST			BIT(0)
+#define RCC_CRYPxCFGR_CRYPxEN			BIT(1)
+#define RCC_CRYPxCFGR_CRYPxLPEN			BIT(2)
+
+/* RCC_IWDG1CFGR register fields */
+#define RCC_IWDG1CFGR_IWDG1EN			BIT(1)
+#define RCC_IWDG1CFGR_IWDG1LPEN			BIT(2)
+
+/* RCC_IWDG2CFGR register fields */
+#define RCC_IWDG2CFGR_IWDG2EN			BIT(1)
+#define RCC_IWDG2CFGR_IWDG2LPEN			BIT(2)
+
+/* RCC_IWDG3CFGR register fields */
+#define RCC_IWDG3CFGR_IWDG3EN			BIT(1)
+#define RCC_IWDG3CFGR_IWDG3LPEN			BIT(2)
+
+/* RCC_IWDG4CFGR register fields */
+#define RCC_IWDG4CFGR_IWDG4EN			BIT(1)
+#define RCC_IWDG4CFGR_IWDG4LPEN			BIT(2)
+
+/* RCC_IWDGxCFGR register fields */
+#define RCC_IWDGxCFGR_IWDGxEN			BIT(1)
+#define RCC_IWDGxCFGR_IWDGxLPEN			BIT(2)
+
+/* RCC_IWDG5CFGR register fields */
+#define RCC_IWDG5CFGR_IWDG5EN			BIT(1)
+#define RCC_IWDG5CFGR_IWDG5LPEN			BIT(2)
+#define RCC_IWDG5CFGR_IWDG5AMEN			BIT(3)
+
+/* RCC_WWDG1CFGR register fields */
+#define RCC_WWDG1CFGR_WWDG1RST			BIT(0)
+#define RCC_WWDG1CFGR_WWDG1EN			BIT(1)
+#define RCC_WWDG1CFGR_WWDG1LPEN			BIT(2)
+
+/* RCC_WWDG2CFGR register fields */
+#define RCC_WWDG2CFGR_WWDG2RST			BIT(0)
+#define RCC_WWDG2CFGR_WWDG2EN			BIT(1)
+#define RCC_WWDG2CFGR_WWDG2LPEN			BIT(2)
+#define RCC_WWDG2CFGR_WWDG2AMEN			BIT(3)
+
+/* RCC_BUSPERFMCFGR register fields */
+#define RCC_BUSPERFMCFGR_BUSPERFMRST		BIT(0)
+#define RCC_BUSPERFMCFGR_BUSPERFMEN		BIT(1)
+#define RCC_BUSPERFMCFGR_BUSPERFMLPEN		BIT(2)
+
+/* RCC_VREFCFGR register fields */
+#define RCC_VREFCFGR_VREFRST			BIT(0)
+#define RCC_VREFCFGR_VREFEN			BIT(1)
+#define RCC_VREFCFGR_VREFLPEN			BIT(2)
+
+/* RCC_DTSCFGR register fields */
+#define RCC_DTSCFGR_DTSRST			BIT(0)
+#define RCC_DTSCFGR_DTSEN			BIT(1)
+#define RCC_DTSCFGR_DTSLPEN			BIT(2)
+#define RCC_DTSCFGR_DTSKERSEL_MASK		GENMASK(13, 12)
+#define RCC_DTSCFGR_DTSKERSEL_SHIFT		12
+
+/* RCC_CRCCFGR register fields */
+#define RCC_CRCCFGR_CRCRST			BIT(0)
+#define RCC_CRCCFGR_CRCEN			BIT(1)
+#define RCC_CRCCFGR_CRCLPEN			BIT(2)
+
+/* RCC_SERCCFGR register fields */
+#define RCC_SERCCFGR_SERCRST			BIT(0)
+#define RCC_SERCCFGR_SERCEN			BIT(1)
+#define RCC_SERCCFGR_SERCLPEN			BIT(2)
+
+/* RCC_OSPIIOMCFGR register fields */
+#define RCC_OSPIIOMCFGR_OSPIIOMRST		BIT(0)
+#define RCC_OSPIIOMCFGR_OSPIIOMEN		BIT(1)
+#define RCC_OSPIIOMCFGR_OSPIIOMLPEN		BIT(2)
+
+/* RCC_GICV2MCFGR register fields */
+#define RCC_GICV2MCFGR_GICV2MEN			BIT(1)
+#define RCC_GICV2MCFGR_GICV2MLPEN		BIT(2)
+
+/* RCC_I3C1CFGR register fields */
+#define RCC_I3C1CFGR_I3C1RST			BIT(0)
+#define RCC_I3C1CFGR_I3C1EN			BIT(1)
+#define RCC_I3C1CFGR_I3C1LPEN			BIT(2)
+
+/* RCC_I3C2CFGR register fields */
+#define RCC_I3C2CFGR_I3C2RST			BIT(0)
+#define RCC_I3C2CFGR_I3C2EN			BIT(1)
+#define RCC_I3C2CFGR_I3C2LPEN			BIT(2)
+
+/* RCC_I3C3CFGR register fields */
+#define RCC_I3C3CFGR_I3C3RST			BIT(0)
+#define RCC_I3C3CFGR_I3C3EN			BIT(1)
+#define RCC_I3C3CFGR_I3C3LPEN			BIT(2)
+
+/* RCC_I3C4CFGR register fields */
+#define RCC_I3C4CFGR_I3C4RST			BIT(0)
+#define RCC_I3C4CFGR_I3C4EN			BIT(1)
+#define RCC_I3C4CFGR_I3C4LPEN			BIT(2)
+#define RCC_I3C4CFGR_I3C4AMEN			BIT(3)
+
+/* RCC_I3CxCFGR register fields */
+#define RCC_I3CxCFGR_I3CxRST			BIT(0)
+#define RCC_I3CxCFGR_I3CxEN			BIT(1)
+#define RCC_I3CxCFGR_I3CxLPEN			BIT(2)
+#define RCC_I3CxCFGR_I3CxAMEN			BIT(3)
+
+/* RCC_MUXSELCFGR register fields */
+#define RCC_MUXSELCFGR_MUXSEL0_MASK		GENMASK(1, 0)
+#define RCC_MUXSELCFGR_MUXSEL0_SHIFT		0
+#define RCC_MUXSELCFGR_MUXSEL1_MASK		GENMASK(5, 4)
+#define RCC_MUXSELCFGR_MUXSEL1_SHIFT		4
+#define RCC_MUXSELCFGR_MUXSEL2_MASK		GENMASK(9, 8)
+#define RCC_MUXSELCFGR_MUXSEL2_SHIFT		8
+#define RCC_MUXSELCFGR_MUXSEL3_MASK		GENMASK(13, 12)
+#define RCC_MUXSELCFGR_MUXSEL3_SHIFT		12
+#define RCC_MUXSELCFGR_MUXSEL4_MASK		GENMASK(17, 16)
+#define RCC_MUXSELCFGR_MUXSEL4_SHIFT		16
+#define RCC_MUXSELCFGR_MUXSEL5_MASK		GENMASK(21, 20)
+#define RCC_MUXSELCFGR_MUXSEL5_SHIFT		20
+#define RCC_MUXSELCFGR_MUXSEL6_MASK		GENMASK(25, 24)
+#define RCC_MUXSELCFGR_MUXSEL6_SHIFT		24
+#define RCC_MUXSELCFGR_MUXSEL7_MASK		GENMASK(29, 28)
+#define RCC_MUXSELCFGR_MUXSEL7_SHIFT		28
+
+/* RCC_XBAR0CFGR register fields */
+#define RCC_XBAR0CFGR_XBAR0SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR0CFGR_XBAR0SEL_SHIFT		0
+#define RCC_XBAR0CFGR_XBAR0EN			BIT(6)
+#define RCC_XBAR0CFGR_XBAR0STS			BIT(7)
+
+/* RCC_XBAR1CFGR register fields */
+#define RCC_XBAR1CFGR_XBAR1SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR1CFGR_XBAR1SEL_SHIFT		0
+#define RCC_XBAR1CFGR_XBAR1EN			BIT(6)
+#define RCC_XBAR1CFGR_XBAR1STS			BIT(7)
+
+/* RCC_XBAR2CFGR register fields */
+#define RCC_XBAR2CFGR_XBAR2SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR2CFGR_XBAR2SEL_SHIFT		0
+#define RCC_XBAR2CFGR_XBAR2EN			BIT(6)
+#define RCC_XBAR2CFGR_XBAR2STS			BIT(7)
+
+/* RCC_XBAR3CFGR register fields */
+#define RCC_XBAR3CFGR_XBAR3SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR3CFGR_XBAR3SEL_SHIFT		0
+#define RCC_XBAR3CFGR_XBAR3EN			BIT(6)
+#define RCC_XBAR3CFGR_XBAR3STS			BIT(7)
+
+/* RCC_XBAR4CFGR register fields */
+#define RCC_XBAR4CFGR_XBAR4SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR4CFGR_XBAR4SEL_SHIFT		0
+#define RCC_XBAR4CFGR_XBAR4EN			BIT(6)
+#define RCC_XBAR4CFGR_XBAR4STS			BIT(7)
+
+/* RCC_XBAR5CFGR register fields */
+#define RCC_XBAR5CFGR_XBAR5SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR5CFGR_XBAR5SEL_SHIFT		0
+#define RCC_XBAR5CFGR_XBAR5EN			BIT(6)
+#define RCC_XBAR5CFGR_XBAR5STS			BIT(7)
+
+/* RCC_XBAR6CFGR register fields */
+#define RCC_XBAR6CFGR_XBAR6SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR6CFGR_XBAR6SEL_SHIFT		0
+#define RCC_XBAR6CFGR_XBAR6EN			BIT(6)
+#define RCC_XBAR6CFGR_XBAR6STS			BIT(7)
+
+/* RCC_XBAR7CFGR register fields */
+#define RCC_XBAR7CFGR_XBAR7SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR7CFGR_XBAR7SEL_SHIFT		0
+#define RCC_XBAR7CFGR_XBAR7EN			BIT(6)
+#define RCC_XBAR7CFGR_XBAR7STS			BIT(7)
+
+/* RCC_XBAR8CFGR register fields */
+#define RCC_XBAR8CFGR_XBAR8SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR8CFGR_XBAR8SEL_SHIFT		0
+#define RCC_XBAR8CFGR_XBAR8EN			BIT(6)
+#define RCC_XBAR8CFGR_XBAR8STS			BIT(7)
+
+/* RCC_XBAR9CFGR register fields */
+#define RCC_XBAR9CFGR_XBAR9SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR9CFGR_XBAR9SEL_SHIFT		0
+#define RCC_XBAR9CFGR_XBAR9EN			BIT(6)
+#define RCC_XBAR9CFGR_XBAR9STS			BIT(7)
+
+/* RCC_XBAR10CFGR register fields */
+#define RCC_XBAR10CFGR_XBAR10SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR10CFGR_XBAR10SEL_SHIFT		0
+#define RCC_XBAR10CFGR_XBAR10EN			BIT(6)
+#define RCC_XBAR10CFGR_XBAR10STS		BIT(7)
+
+/* RCC_XBAR11CFGR register fields */
+#define RCC_XBAR11CFGR_XBAR11SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR11CFGR_XBAR11SEL_SHIFT		0
+#define RCC_XBAR11CFGR_XBAR11EN			BIT(6)
+#define RCC_XBAR11CFGR_XBAR11STS		BIT(7)
+
+/* RCC_XBAR12CFGR register fields */
+#define RCC_XBAR12CFGR_XBAR12SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR12CFGR_XBAR12SEL_SHIFT		0
+#define RCC_XBAR12CFGR_XBAR12EN			BIT(6)
+#define RCC_XBAR12CFGR_XBAR12STS		BIT(7)
+
+/* RCC_XBAR13CFGR register fields */
+#define RCC_XBAR13CFGR_XBAR13SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR13CFGR_XBAR13SEL_SHIFT		0
+#define RCC_XBAR13CFGR_XBAR13EN			BIT(6)
+#define RCC_XBAR13CFGR_XBAR13STS		BIT(7)
+
+/* RCC_XBAR14CFGR register fields */
+#define RCC_XBAR14CFGR_XBAR14SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR14CFGR_XBAR14SEL_SHIFT		0
+#define RCC_XBAR14CFGR_XBAR14EN			BIT(6)
+#define RCC_XBAR14CFGR_XBAR14STS		BIT(7)
+
+/* RCC_XBAR15CFGR register fields */
+#define RCC_XBAR15CFGR_XBAR15SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR15CFGR_XBAR15SEL_SHIFT		0
+#define RCC_XBAR15CFGR_XBAR15EN			BIT(6)
+#define RCC_XBAR15CFGR_XBAR15STS		BIT(7)
+
+/* RCC_XBAR16CFGR register fields */
+#define RCC_XBAR16CFGR_XBAR16SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR16CFGR_XBAR16SEL_SHIFT		0
+#define RCC_XBAR16CFGR_XBAR16EN			BIT(6)
+#define RCC_XBAR16CFGR_XBAR16STS		BIT(7)
+
+/* RCC_XBAR17CFGR register fields */
+#define RCC_XBAR17CFGR_XBAR17SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR17CFGR_XBAR17SEL_SHIFT		0
+#define RCC_XBAR17CFGR_XBAR17EN			BIT(6)
+#define RCC_XBAR17CFGR_XBAR17STS		BIT(7)
+
+/* RCC_XBAR18CFGR register fields */
+#define RCC_XBAR18CFGR_XBAR18SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR18CFGR_XBAR18SEL_SHIFT		0
+#define RCC_XBAR18CFGR_XBAR18EN			BIT(6)
+#define RCC_XBAR18CFGR_XBAR18STS		BIT(7)
+
+/* RCC_XBAR19CFGR register fields */
+#define RCC_XBAR19CFGR_XBAR19SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR19CFGR_XBAR19SEL_SHIFT		0
+#define RCC_XBAR19CFGR_XBAR19EN			BIT(6)
+#define RCC_XBAR19CFGR_XBAR19STS		BIT(7)
+
+/* RCC_XBAR20CFGR register fields */
+#define RCC_XBAR20CFGR_XBAR20SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR20CFGR_XBAR20SEL_SHIFT		0
+#define RCC_XBAR20CFGR_XBAR20EN			BIT(6)
+#define RCC_XBAR20CFGR_XBAR20STS		BIT(7)
+
+/* RCC_XBAR21CFGR register fields */
+#define RCC_XBAR21CFGR_XBAR21SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR21CFGR_XBAR21SEL_SHIFT		0
+#define RCC_XBAR21CFGR_XBAR21EN			BIT(6)
+#define RCC_XBAR21CFGR_XBAR21STS		BIT(7)
+
+/* RCC_XBAR22CFGR register fields */
+#define RCC_XBAR22CFGR_XBAR22SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR22CFGR_XBAR22SEL_SHIFT		0
+#define RCC_XBAR22CFGR_XBAR22EN			BIT(6)
+#define RCC_XBAR22CFGR_XBAR22STS		BIT(7)
+
+/* RCC_XBAR23CFGR register fields */
+#define RCC_XBAR23CFGR_XBAR23SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR23CFGR_XBAR23SEL_SHIFT		0
+#define RCC_XBAR23CFGR_XBAR23EN			BIT(6)
+#define RCC_XBAR23CFGR_XBAR23STS		BIT(7)
+
+/* RCC_XBAR24CFGR register fields */
+#define RCC_XBAR24CFGR_XBAR24SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR24CFGR_XBAR24SEL_SHIFT		0
+#define RCC_XBAR24CFGR_XBAR24EN			BIT(6)
+#define RCC_XBAR24CFGR_XBAR24STS		BIT(7)
+
+/* RCC_XBAR25CFGR register fields */
+#define RCC_XBAR25CFGR_XBAR25SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR25CFGR_XBAR25SEL_SHIFT		0
+#define RCC_XBAR25CFGR_XBAR25EN			BIT(6)
+#define RCC_XBAR25CFGR_XBAR25STS		BIT(7)
+
+/* RCC_XBAR26CFGR register fields */
+#define RCC_XBAR26CFGR_XBAR26SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR26CFGR_XBAR26SEL_SHIFT		0
+#define RCC_XBAR26CFGR_XBAR26EN			BIT(6)
+#define RCC_XBAR26CFGR_XBAR26STS		BIT(7)
+
+/* RCC_XBAR27CFGR register fields */
+#define RCC_XBAR27CFGR_XBAR27SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR27CFGR_XBAR27SEL_SHIFT		0
+#define RCC_XBAR27CFGR_XBAR27EN			BIT(6)
+#define RCC_XBAR27CFGR_XBAR27STS		BIT(7)
+
+/* RCC_XBAR28CFGR register fields */
+#define RCC_XBAR28CFGR_XBAR28SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR28CFGR_XBAR28SEL_SHIFT		0
+#define RCC_XBAR28CFGR_XBAR28EN			BIT(6)
+#define RCC_XBAR28CFGR_XBAR28STS		BIT(7)
+
+/* RCC_XBAR29CFGR register fields */
+#define RCC_XBAR29CFGR_XBAR29SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR29CFGR_XBAR29SEL_SHIFT		0
+#define RCC_XBAR29CFGR_XBAR29EN			BIT(6)
+#define RCC_XBAR29CFGR_XBAR29STS		BIT(7)
+
+/* RCC_XBAR30CFGR register fields */
+#define RCC_XBAR30CFGR_XBAR30SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR30CFGR_XBAR30SEL_SHIFT		0
+#define RCC_XBAR30CFGR_XBAR30EN			BIT(6)
+#define RCC_XBAR30CFGR_XBAR30STS		BIT(7)
+
+/* RCC_XBAR31CFGR register fields */
+#define RCC_XBAR31CFGR_XBAR31SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR31CFGR_XBAR31SEL_SHIFT		0
+#define RCC_XBAR31CFGR_XBAR31EN			BIT(6)
+#define RCC_XBAR31CFGR_XBAR31STS		BIT(7)
+
+/* RCC_XBAR32CFGR register fields */
+#define RCC_XBAR32CFGR_XBAR32SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR32CFGR_XBAR32SEL_SHIFT		0
+#define RCC_XBAR32CFGR_XBAR32EN			BIT(6)
+#define RCC_XBAR32CFGR_XBAR32STS		BIT(7)
+
+/* RCC_XBAR33CFGR register fields */
+#define RCC_XBAR33CFGR_XBAR33SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR33CFGR_XBAR33SEL_SHIFT		0
+#define RCC_XBAR33CFGR_XBAR33EN			BIT(6)
+#define RCC_XBAR33CFGR_XBAR33STS		BIT(7)
+
+/* RCC_XBAR34CFGR register fields */
+#define RCC_XBAR34CFGR_XBAR34SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR34CFGR_XBAR34SEL_SHIFT		0
+#define RCC_XBAR34CFGR_XBAR34EN			BIT(6)
+#define RCC_XBAR34CFGR_XBAR34STS		BIT(7)
+
+/* RCC_XBAR35CFGR register fields */
+#define RCC_XBAR35CFGR_XBAR35SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR35CFGR_XBAR35SEL_SHIFT		0
+#define RCC_XBAR35CFGR_XBAR35EN			BIT(6)
+#define RCC_XBAR35CFGR_XBAR35STS		BIT(7)
+
+/* RCC_XBAR36CFGR register fields */
+#define RCC_XBAR36CFGR_XBAR36SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR36CFGR_XBAR36SEL_SHIFT		0
+#define RCC_XBAR36CFGR_XBAR36EN			BIT(6)
+#define RCC_XBAR36CFGR_XBAR36STS		BIT(7)
+
+/* RCC_XBAR37CFGR register fields */
+#define RCC_XBAR37CFGR_XBAR37SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR37CFGR_XBAR37SEL_SHIFT		0
+#define RCC_XBAR37CFGR_XBAR37EN			BIT(6)
+#define RCC_XBAR37CFGR_XBAR37STS		BIT(7)
+
+/* RCC_XBAR38CFGR register fields */
+#define RCC_XBAR38CFGR_XBAR38SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR38CFGR_XBAR38SEL_SHIFT		0
+#define RCC_XBAR38CFGR_XBAR38EN			BIT(6)
+#define RCC_XBAR38CFGR_XBAR38STS		BIT(7)
+
+/* RCC_XBAR39CFGR register fields */
+#define RCC_XBAR39CFGR_XBAR39SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR39CFGR_XBAR39SEL_SHIFT		0
+#define RCC_XBAR39CFGR_XBAR39EN			BIT(6)
+#define RCC_XBAR39CFGR_XBAR39STS		BIT(7)
+
+/* RCC_XBAR40CFGR register fields */
+#define RCC_XBAR40CFGR_XBAR40SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR40CFGR_XBAR40SEL_SHIFT		0
+#define RCC_XBAR40CFGR_XBAR40EN			BIT(6)
+#define RCC_XBAR40CFGR_XBAR40STS		BIT(7)
+
+/* RCC_XBAR41CFGR register fields */
+#define RCC_XBAR41CFGR_XBAR41SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR41CFGR_XBAR41SEL_SHIFT		0
+#define RCC_XBAR41CFGR_XBAR41EN			BIT(6)
+#define RCC_XBAR41CFGR_XBAR41STS		BIT(7)
+
+/* RCC_XBAR42CFGR register fields */
+#define RCC_XBAR42CFGR_XBAR42SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR42CFGR_XBAR42SEL_SHIFT		0
+#define RCC_XBAR42CFGR_XBAR42EN			BIT(6)
+#define RCC_XBAR42CFGR_XBAR42STS		BIT(7)
+
+/* RCC_XBAR43CFGR register fields */
+#define RCC_XBAR43CFGR_XBAR43SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR43CFGR_XBAR43SEL_SHIFT		0
+#define RCC_XBAR43CFGR_XBAR43EN			BIT(6)
+#define RCC_XBAR43CFGR_XBAR43STS		BIT(7)
+
+/* RCC_XBAR44CFGR register fields */
+#define RCC_XBAR44CFGR_XBAR44SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR44CFGR_XBAR44SEL_SHIFT		0
+#define RCC_XBAR44CFGR_XBAR44EN			BIT(6)
+#define RCC_XBAR44CFGR_XBAR44STS		BIT(7)
+
+/* RCC_XBAR45CFGR register fields */
+#define RCC_XBAR45CFGR_XBAR45SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR45CFGR_XBAR45SEL_SHIFT		0
+#define RCC_XBAR45CFGR_XBAR45EN			BIT(6)
+#define RCC_XBAR45CFGR_XBAR45STS		BIT(7)
+
+/* RCC_XBAR46CFGR register fields */
+#define RCC_XBAR46CFGR_XBAR46SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR46CFGR_XBAR46SEL_SHIFT		0
+#define RCC_XBAR46CFGR_XBAR46EN			BIT(6)
+#define RCC_XBAR46CFGR_XBAR46STS		BIT(7)
+
+/* RCC_XBAR47CFGR register fields */
+#define RCC_XBAR47CFGR_XBAR47SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR47CFGR_XBAR47SEL_SHIFT		0
+#define RCC_XBAR47CFGR_XBAR47EN			BIT(6)
+#define RCC_XBAR47CFGR_XBAR47STS		BIT(7)
+
+/* RCC_XBAR48CFGR register fields */
+#define RCC_XBAR48CFGR_XBAR48SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR48CFGR_XBAR48SEL_SHIFT		0
+#define RCC_XBAR48CFGR_XBAR48EN			BIT(6)
+#define RCC_XBAR48CFGR_XBAR48STS		BIT(7)
+
+/* RCC_XBAR49CFGR register fields */
+#define RCC_XBAR49CFGR_XBAR49SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR49CFGR_XBAR49SEL_SHIFT		0
+#define RCC_XBAR49CFGR_XBAR49EN			BIT(6)
+#define RCC_XBAR49CFGR_XBAR49STS		BIT(7)
+
+/* RCC_XBAR50CFGR register fields */
+#define RCC_XBAR50CFGR_XBAR50SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR50CFGR_XBAR50SEL_SHIFT		0
+#define RCC_XBAR50CFGR_XBAR50EN			BIT(6)
+#define RCC_XBAR50CFGR_XBAR50STS		BIT(7)
+
+/* RCC_XBAR51CFGR register fields */
+#define RCC_XBAR51CFGR_XBAR51SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR51CFGR_XBAR51SEL_SHIFT		0
+#define RCC_XBAR51CFGR_XBAR51EN			BIT(6)
+#define RCC_XBAR51CFGR_XBAR51STS		BIT(7)
+
+/* RCC_XBAR52CFGR register fields */
+#define RCC_XBAR52CFGR_XBAR52SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR52CFGR_XBAR52SEL_SHIFT		0
+#define RCC_XBAR52CFGR_XBAR52EN			BIT(6)
+#define RCC_XBAR52CFGR_XBAR52STS		BIT(7)
+
+/* RCC_XBAR53CFGR register fields */
+#define RCC_XBAR53CFGR_XBAR53SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR53CFGR_XBAR53SEL_SHIFT		0
+#define RCC_XBAR53CFGR_XBAR53EN			BIT(6)
+#define RCC_XBAR53CFGR_XBAR53STS		BIT(7)
+
+/* RCC_XBAR54CFGR register fields */
+#define RCC_XBAR54CFGR_XBAR54SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR54CFGR_XBAR54SEL_SHIFT		0
+#define RCC_XBAR54CFGR_XBAR54EN			BIT(6)
+#define RCC_XBAR54CFGR_XBAR54STS		BIT(7)
+
+/* RCC_XBAR55CFGR register fields */
+#define RCC_XBAR55CFGR_XBAR55SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR55CFGR_XBAR55SEL_SHIFT		0
+#define RCC_XBAR55CFGR_XBAR55EN			BIT(6)
+#define RCC_XBAR55CFGR_XBAR55STS		BIT(7)
+
+/* RCC_XBAR56CFGR register fields */
+#define RCC_XBAR56CFGR_XBAR56SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR56CFGR_XBAR56SEL_SHIFT		0
+#define RCC_XBAR56CFGR_XBAR56EN			BIT(6)
+#define RCC_XBAR56CFGR_XBAR56STS		BIT(7)
+
+/* RCC_XBAR57CFGR register fields */
+#define RCC_XBAR57CFGR_XBAR57SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR57CFGR_XBAR57SEL_SHIFT		0
+#define RCC_XBAR57CFGR_XBAR57EN			BIT(6)
+#define RCC_XBAR57CFGR_XBAR57STS		BIT(7)
+
+/* RCC_XBAR58CFGR register fields */
+#define RCC_XBAR58CFGR_XBAR58SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR58CFGR_XBAR58SEL_SHIFT		0
+#define RCC_XBAR58CFGR_XBAR58EN			BIT(6)
+#define RCC_XBAR58CFGR_XBAR58STS		BIT(7)
+
+/* RCC_XBAR59CFGR register fields */
+#define RCC_XBAR59CFGR_XBAR59SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR59CFGR_XBAR59SEL_SHIFT		0
+#define RCC_XBAR59CFGR_XBAR59EN			BIT(6)
+#define RCC_XBAR59CFGR_XBAR59STS		BIT(7)
+
+/* RCC_XBAR60CFGR register fields */
+#define RCC_XBAR60CFGR_XBAR60SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR60CFGR_XBAR60SEL_SHIFT		0
+#define RCC_XBAR60CFGR_XBAR60EN			BIT(6)
+#define RCC_XBAR60CFGR_XBAR60STS		BIT(7)
+
+/* RCC_XBAR61CFGR register fields */
+#define RCC_XBAR61CFGR_XBAR61SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR61CFGR_XBAR61SEL_SHIFT		0
+#define RCC_XBAR61CFGR_XBAR61EN			BIT(6)
+#define RCC_XBAR61CFGR_XBAR61STS		BIT(7)
+
+/* RCC_XBAR62CFGR register fields */
+#define RCC_XBAR62CFGR_XBAR62SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR62CFGR_XBAR62SEL_SHIFT		0
+#define RCC_XBAR62CFGR_XBAR62EN			BIT(6)
+#define RCC_XBAR62CFGR_XBAR62STS		BIT(7)
+
+/* RCC_XBAR63CFGR register fields */
+#define RCC_XBAR63CFGR_XBAR63SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR63CFGR_XBAR63SEL_SHIFT		0
+#define RCC_XBAR63CFGR_XBAR63EN			BIT(6)
+#define RCC_XBAR63CFGR_XBAR63STS		BIT(7)
+
+/* RCC_XBARxCFGR register fields */
+#define RCC_XBARxCFGR_XBARxSEL_MASK		GENMASK(3, 0)
+#define RCC_XBARxCFGR_XBARxSEL_SHIFT		0
+#define RCC_XBARxCFGR_XBARxEN			BIT(6)
+#define RCC_XBARxCFGR_XBARxSTS			BIT(7)
+
+/* RCC_PREDIV0CFGR register fields */
+#define RCC_PREDIV0CFGR_PREDIV0_MASK		GENMASK(9, 0)
+#define RCC_PREDIV0CFGR_PREDIV0_SHIFT		0
+
+/* RCC_PREDIV1CFGR register fields */
+#define RCC_PREDIV1CFGR_PREDIV1_MASK		GENMASK(9, 0)
+#define RCC_PREDIV1CFGR_PREDIV1_SHIFT		0
+
+/* RCC_PREDIV2CFGR register fields */
+#define RCC_PREDIV2CFGR_PREDIV2_MASK		GENMASK(9, 0)
+#define RCC_PREDIV2CFGR_PREDIV2_SHIFT		0
+
+/* RCC_PREDIV3CFGR register fields */
+#define RCC_PREDIV3CFGR_PREDIV3_MASK		GENMASK(9, 0)
+#define RCC_PREDIV3CFGR_PREDIV3_SHIFT		0
+
+/* RCC_PREDIV4CFGR register fields */
+#define RCC_PREDIV4CFGR_PREDIV4_MASK		GENMASK(9, 0)
+#define RCC_PREDIV4CFGR_PREDIV4_SHIFT		0
+
+/* RCC_PREDIV5CFGR register fields */
+#define RCC_PREDIV5CFGR_PREDIV5_MASK		GENMASK(9, 0)
+#define RCC_PREDIV5CFGR_PREDIV5_SHIFT		0
+
+/* RCC_PREDIV6CFGR register fields */
+#define RCC_PREDIV6CFGR_PREDIV6_MASK		GENMASK(9, 0)
+#define RCC_PREDIV6CFGR_PREDIV6_SHIFT		0
+
+/* RCC_PREDIV7CFGR register fields */
+#define RCC_PREDIV7CFGR_PREDIV7_MASK		GENMASK(9, 0)
+#define RCC_PREDIV7CFGR_PREDIV7_SHIFT		0
+
+/* RCC_PREDIV8CFGR register fields */
+#define RCC_PREDIV8CFGR_PREDIV8_MASK		GENMASK(9, 0)
+#define RCC_PREDIV8CFGR_PREDIV8_SHIFT		0
+
+/* RCC_PREDIV9CFGR register fields */
+#define RCC_PREDIV9CFGR_PREDIV9_MASK		GENMASK(9, 0)
+#define RCC_PREDIV9CFGR_PREDIV9_SHIFT		0
+
+/* RCC_PREDIV10CFGR register fields */
+#define RCC_PREDIV10CFGR_PREDIV10_MASK		GENMASK(9, 0)
+#define RCC_PREDIV10CFGR_PREDIV10_SHIFT		0
+
+/* RCC_PREDIV11CFGR register fields */
+#define RCC_PREDIV11CFGR_PREDIV11_MASK		GENMASK(9, 0)
+#define RCC_PREDIV11CFGR_PREDIV11_SHIFT		0
+
+/* RCC_PREDIV12CFGR register fields */
+#define RCC_PREDIV12CFGR_PREDIV12_MASK		GENMASK(9, 0)
+#define RCC_PREDIV12CFGR_PREDIV12_SHIFT		0
+
+/* RCC_PREDIV13CFGR register fields */
+#define RCC_PREDIV13CFGR_PREDIV13_MASK		GENMASK(9, 0)
+#define RCC_PREDIV13CFGR_PREDIV13_SHIFT		0
+
+/* RCC_PREDIV14CFGR register fields */
+#define RCC_PREDIV14CFGR_PREDIV14_MASK		GENMASK(9, 0)
+#define RCC_PREDIV14CFGR_PREDIV14_SHIFT		0
+
+/* RCC_PREDIV15CFGR register fields */
+#define RCC_PREDIV15CFGR_PREDIV15_MASK		GENMASK(9, 0)
+#define RCC_PREDIV15CFGR_PREDIV15_SHIFT		0
+
+/* RCC_PREDIV16CFGR register fields */
+#define RCC_PREDIV16CFGR_PREDIV16_MASK		GENMASK(9, 0)
+#define RCC_PREDIV16CFGR_PREDIV16_SHIFT		0
+
+/* RCC_PREDIV17CFGR register fields */
+#define RCC_PREDIV17CFGR_PREDIV17_MASK		GENMASK(9, 0)
+#define RCC_PREDIV17CFGR_PREDIV17_SHIFT		0
+
+/* RCC_PREDIV18CFGR register fields */
+#define RCC_PREDIV18CFGR_PREDIV18_MASK		GENMASK(9, 0)
+#define RCC_PREDIV18CFGR_PREDIV18_SHIFT		0
+
+/* RCC_PREDIV19CFGR register fields */
+#define RCC_PREDIV19CFGR_PREDIV19_MASK		GENMASK(9, 0)
+#define RCC_PREDIV19CFGR_PREDIV19_SHIFT		0
+
+/* RCC_PREDIV20CFGR register fields */
+#define RCC_PREDIV20CFGR_PREDIV20_MASK		GENMASK(9, 0)
+#define RCC_PREDIV20CFGR_PREDIV20_SHIFT		0
+
+/* RCC_PREDIV21CFGR register fields */
+#define RCC_PREDIV21CFGR_PREDIV21_MASK		GENMASK(9, 0)
+#define RCC_PREDIV21CFGR_PREDIV21_SHIFT		0
+
+/* RCC_PREDIV22CFGR register fields */
+#define RCC_PREDIV22CFGR_PREDIV22_MASK		GENMASK(9, 0)
+#define RCC_PREDIV22CFGR_PREDIV22_SHIFT		0
+
+/* RCC_PREDIV23CFGR register fields */
+#define RCC_PREDIV23CFGR_PREDIV23_MASK		GENMASK(9, 0)
+#define RCC_PREDIV23CFGR_PREDIV23_SHIFT		0
+
+/* RCC_PREDIV24CFGR register fields */
+#define RCC_PREDIV24CFGR_PREDIV24_MASK		GENMASK(9, 0)
+#define RCC_PREDIV24CFGR_PREDIV24_SHIFT		0
+
+/* RCC_PREDIV25CFGR register fields */
+#define RCC_PREDIV25CFGR_PREDIV25_MASK		GENMASK(9, 0)
+#define RCC_PREDIV25CFGR_PREDIV25_SHIFT		0
+
+/* RCC_PREDIV26CFGR register fields */
+#define RCC_PREDIV26CFGR_PREDIV26_MASK		GENMASK(9, 0)
+#define RCC_PREDIV26CFGR_PREDIV26_SHIFT		0
+
+/* RCC_PREDIV27CFGR register fields */
+#define RCC_PREDIV27CFGR_PREDIV27_MASK		GENMASK(9, 0)
+#define RCC_PREDIV27CFGR_PREDIV27_SHIFT		0
+
+/* RCC_PREDIV28CFGR register fields */
+#define RCC_PREDIV28CFGR_PREDIV28_MASK		GENMASK(9, 0)
+#define RCC_PREDIV28CFGR_PREDIV28_SHIFT		0
+
+/* RCC_PREDIV29CFGR register fields */
+#define RCC_PREDIV29CFGR_PREDIV29_MASK		GENMASK(9, 0)
+#define RCC_PREDIV29CFGR_PREDIV29_SHIFT		0
+
+/* RCC_PREDIV30CFGR register fields */
+#define RCC_PREDIV30CFGR_PREDIV30_MASK		GENMASK(9, 0)
+#define RCC_PREDIV30CFGR_PREDIV30_SHIFT		0
+
+/* RCC_PREDIV31CFGR register fields */
+#define RCC_PREDIV31CFGR_PREDIV31_MASK		GENMASK(9, 0)
+#define RCC_PREDIV31CFGR_PREDIV31_SHIFT		0
+
+/* RCC_PREDIV32CFGR register fields */
+#define RCC_PREDIV32CFGR_PREDIV32_MASK		GENMASK(9, 0)
+#define RCC_PREDIV32CFGR_PREDIV32_SHIFT		0
+
+/* RCC_PREDIV33CFGR register fields */
+#define RCC_PREDIV33CFGR_PREDIV33_MASK		GENMASK(9, 0)
+#define RCC_PREDIV33CFGR_PREDIV33_SHIFT		0
+
+/* RCC_PREDIV34CFGR register fields */
+#define RCC_PREDIV34CFGR_PREDIV34_MASK		GENMASK(9, 0)
+#define RCC_PREDIV34CFGR_PREDIV34_SHIFT		0
+
+/* RCC_PREDIV35CFGR register fields */
+#define RCC_PREDIV35CFGR_PREDIV35_MASK		GENMASK(9, 0)
+#define RCC_PREDIV35CFGR_PREDIV35_SHIFT		0
+
+/* RCC_PREDIV36CFGR register fields */
+#define RCC_PREDIV36CFGR_PREDIV36_MASK		GENMASK(9, 0)
+#define RCC_PREDIV36CFGR_PREDIV36_SHIFT		0
+
+/* RCC_PREDIV37CFGR register fields */
+#define RCC_PREDIV37CFGR_PREDIV37_MASK		GENMASK(9, 0)
+#define RCC_PREDIV37CFGR_PREDIV37_SHIFT		0
+
+/* RCC_PREDIV38CFGR register fields */
+#define RCC_PREDIV38CFGR_PREDIV38_MASK		GENMASK(9, 0)
+#define RCC_PREDIV38CFGR_PREDIV38_SHIFT		0
+
+/* RCC_PREDIV39CFGR register fields */
+#define RCC_PREDIV39CFGR_PREDIV39_MASK		GENMASK(9, 0)
+#define RCC_PREDIV39CFGR_PREDIV39_SHIFT		0
+
+/* RCC_PREDIV40CFGR register fields */
+#define RCC_PREDIV40CFGR_PREDIV40_MASK		GENMASK(9, 0)
+#define RCC_PREDIV40CFGR_PREDIV40_SHIFT		0
+
+/* RCC_PREDIV41CFGR register fields */
+#define RCC_PREDIV41CFGR_PREDIV41_MASK		GENMASK(9, 0)
+#define RCC_PREDIV41CFGR_PREDIV41_SHIFT		0
+
+/* RCC_PREDIV42CFGR register fields */
+#define RCC_PREDIV42CFGR_PREDIV42_MASK		GENMASK(9, 0)
+#define RCC_PREDIV42CFGR_PREDIV42_SHIFT		0
+
+/* RCC_PREDIV43CFGR register fields */
+#define RCC_PREDIV43CFGR_PREDIV43_MASK		GENMASK(9, 0)
+#define RCC_PREDIV43CFGR_PREDIV43_SHIFT		0
+
+/* RCC_PREDIV44CFGR register fields */
+#define RCC_PREDIV44CFGR_PREDIV44_MASK		GENMASK(9, 0)
+#define RCC_PREDIV44CFGR_PREDIV44_SHIFT		0
+
+/* RCC_PREDIV45CFGR register fields */
+#define RCC_PREDIV45CFGR_PREDIV45_MASK		GENMASK(9, 0)
+#define RCC_PREDIV45CFGR_PREDIV45_SHIFT		0
+
+/* RCC_PREDIV46CFGR register fields */
+#define RCC_PREDIV46CFGR_PREDIV46_MASK		GENMASK(9, 0)
+#define RCC_PREDIV46CFGR_PREDIV46_SHIFT		0
+
+/* RCC_PREDIV47CFGR register fields */
+#define RCC_PREDIV47CFGR_PREDIV47_MASK		GENMASK(9, 0)
+#define RCC_PREDIV47CFGR_PREDIV47_SHIFT		0
+
+/* RCC_PREDIV48CFGR register fields */
+#define RCC_PREDIV48CFGR_PREDIV48_MASK		GENMASK(9, 0)
+#define RCC_PREDIV48CFGR_PREDIV48_SHIFT		0
+
+/* RCC_PREDIV49CFGR register fields */
+#define RCC_PREDIV49CFGR_PREDIV49_MASK		GENMASK(9, 0)
+#define RCC_PREDIV49CFGR_PREDIV49_SHIFT		0
+
+/* RCC_PREDIV50CFGR register fields */
+#define RCC_PREDIV50CFGR_PREDIV50_MASK		GENMASK(9, 0)
+#define RCC_PREDIV50CFGR_PREDIV50_SHIFT		0
+
+/* RCC_PREDIV51CFGR register fields */
+#define RCC_PREDIV51CFGR_PREDIV51_MASK		GENMASK(9, 0)
+#define RCC_PREDIV51CFGR_PREDIV51_SHIFT		0
+
+/* RCC_PREDIV52CFGR register fields */
+#define RCC_PREDIV52CFGR_PREDIV52_MASK		GENMASK(9, 0)
+#define RCC_PREDIV52CFGR_PREDIV52_SHIFT		0
+
+/* RCC_PREDIV53CFGR register fields */
+#define RCC_PREDIV53CFGR_PREDIV53_MASK		GENMASK(9, 0)
+#define RCC_PREDIV53CFGR_PREDIV53_SHIFT		0
+
+/* RCC_PREDIV54CFGR register fields */
+#define RCC_PREDIV54CFGR_PREDIV54_MASK		GENMASK(9, 0)
+#define RCC_PREDIV54CFGR_PREDIV54_SHIFT		0
+
+/* RCC_PREDIV55CFGR register fields */
+#define RCC_PREDIV55CFGR_PREDIV55_MASK		GENMASK(9, 0)
+#define RCC_PREDIV55CFGR_PREDIV55_SHIFT		0
+
+/* RCC_PREDIV56CFGR register fields */
+#define RCC_PREDIV56CFGR_PREDIV56_MASK		GENMASK(9, 0)
+#define RCC_PREDIV56CFGR_PREDIV56_SHIFT		0
+
+/* RCC_PREDIV57CFGR register fields */
+#define RCC_PREDIV57CFGR_PREDIV57_MASK		GENMASK(9, 0)
+#define RCC_PREDIV57CFGR_PREDIV57_SHIFT		0
+
+/* RCC_PREDIV58CFGR register fields */
+#define RCC_PREDIV58CFGR_PREDIV58_MASK		GENMASK(9, 0)
+#define RCC_PREDIV58CFGR_PREDIV58_SHIFT		0
+
+/* RCC_PREDIV59CFGR register fields */
+#define RCC_PREDIV59CFGR_PREDIV59_MASK		GENMASK(9, 0)
+#define RCC_PREDIV59CFGR_PREDIV59_SHIFT		0
+
+/* RCC_PREDIV60CFGR register fields */
+#define RCC_PREDIV60CFGR_PREDIV60_MASK		GENMASK(9, 0)
+#define RCC_PREDIV60CFGR_PREDIV60_SHIFT		0
+
+/* RCC_PREDIV61CFGR register fields */
+#define RCC_PREDIV61CFGR_PREDIV61_MASK		GENMASK(9, 0)
+#define RCC_PREDIV61CFGR_PREDIV61_SHIFT		0
+
+/* RCC_PREDIV62CFGR register fields */
+#define RCC_PREDIV62CFGR_PREDIV62_MASK		GENMASK(9, 0)
+#define RCC_PREDIV62CFGR_PREDIV62_SHIFT		0
+
+/* RCC_PREDIV63CFGR register fields */
+#define RCC_PREDIV63CFGR_PREDIV63_MASK		GENMASK(9, 0)
+#define RCC_PREDIV63CFGR_PREDIV63_SHIFT		0
+
+/* RCC_PREDIVxCFGR register fields */
+#define RCC_PREDIVxCFGR_PREDIVx_MASK		GENMASK(9, 0)
+#define RCC_PREDIVxCFGR_PREDIVx_SHIFT		0
+
+/* RCC_FINDIV0CFGR register fields */
+#define RCC_FINDIV0CFGR_FINDIV0_MASK		GENMASK(5, 0)
+#define RCC_FINDIV0CFGR_FINDIV0_SHIFT		0
+#define RCC_FINDIV0CFGR_FINDIV0EN		BIT(6)
+
+/* RCC_FINDIV1CFGR register fields */
+#define RCC_FINDIV1CFGR_FINDIV1_MASK		GENMASK(5, 0)
+#define RCC_FINDIV1CFGR_FINDIV1_SHIFT		0
+#define RCC_FINDIV1CFGR_FINDIV1EN		BIT(6)
+
+/* RCC_FINDIV2CFGR register fields */
+#define RCC_FINDIV2CFGR_FINDIV2_MASK		GENMASK(5, 0)
+#define RCC_FINDIV2CFGR_FINDIV2_SHIFT		0
+#define RCC_FINDIV2CFGR_FINDIV2EN		BIT(6)
+
+/* RCC_FINDIV3CFGR register fields */
+#define RCC_FINDIV3CFGR_FINDIV3_MASK		GENMASK(5, 0)
+#define RCC_FINDIV3CFGR_FINDIV3_SHIFT		0
+#define RCC_FINDIV3CFGR_FINDIV3EN		BIT(6)
+
+/* RCC_FINDIV4CFGR register fields */
+#define RCC_FINDIV4CFGR_FINDIV4_MASK		GENMASK(5, 0)
+#define RCC_FINDIV4CFGR_FINDIV4_SHIFT		0
+#define RCC_FINDIV4CFGR_FINDIV4EN		BIT(6)
+
+/* RCC_FINDIV5CFGR register fields */
+#define RCC_FINDIV5CFGR_FINDIV5_MASK		GENMASK(5, 0)
+#define RCC_FINDIV5CFGR_FINDIV5_SHIFT		0
+#define RCC_FINDIV5CFGR_FINDIV5EN		BIT(6)
+
+/* RCC_FINDIV6CFGR register fields */
+#define RCC_FINDIV6CFGR_FINDIV6_MASK		GENMASK(5, 0)
+#define RCC_FINDIV6CFGR_FINDIV6_SHIFT		0
+#define RCC_FINDIV6CFGR_FINDIV6EN		BIT(6)
+
+/* RCC_FINDIV7CFGR register fields */
+#define RCC_FINDIV7CFGR_FINDIV7_MASK		GENMASK(5, 0)
+#define RCC_FINDIV7CFGR_FINDIV7_SHIFT		0
+#define RCC_FINDIV7CFGR_FINDIV7EN		BIT(6)
+
+/* RCC_FINDIV8CFGR register fields */
+#define RCC_FINDIV8CFGR_FINDIV8_MASK		GENMASK(5, 0)
+#define RCC_FINDIV8CFGR_FINDIV8_SHIFT		0
+#define RCC_FINDIV8CFGR_FINDIV8EN		BIT(6)
+
+/* RCC_FINDIV9CFGR register fields */
+#define RCC_FINDIV9CFGR_FINDIV9_MASK		GENMASK(5, 0)
+#define RCC_FINDIV9CFGR_FINDIV9_SHIFT		0
+#define RCC_FINDIV9CFGR_FINDIV9EN		BIT(6)
+
+/* RCC_FINDIV10CFGR register fields */
+#define RCC_FINDIV10CFGR_FINDIV10_MASK		GENMASK(5, 0)
+#define RCC_FINDIV10CFGR_FINDIV10_SHIFT		0
+#define RCC_FINDIV10CFGR_FINDIV10EN		BIT(6)
+
+/* RCC_FINDIV11CFGR register fields */
+#define RCC_FINDIV11CFGR_FINDIV11_MASK		GENMASK(5, 0)
+#define RCC_FINDIV11CFGR_FINDIV11_SHIFT		0
+#define RCC_FINDIV11CFGR_FINDIV11EN		BIT(6)
+
+/* RCC_FINDIV12CFGR register fields */
+#define RCC_FINDIV12CFGR_FINDIV12_MASK		GENMASK(5, 0)
+#define RCC_FINDIV12CFGR_FINDIV12_SHIFT		0
+#define RCC_FINDIV12CFGR_FINDIV12EN		BIT(6)
+
+/* RCC_FINDIV13CFGR register fields */
+#define RCC_FINDIV13CFGR_FINDIV13_MASK		GENMASK(5, 0)
+#define RCC_FINDIV13CFGR_FINDIV13_SHIFT		0
+#define RCC_FINDIV13CFGR_FINDIV13EN		BIT(6)
+
+/* RCC_FINDIV14CFGR register fields */
+#define RCC_FINDIV14CFGR_FINDIV14_MASK		GENMASK(5, 0)
+#define RCC_FINDIV14CFGR_FINDIV14_SHIFT		0
+#define RCC_FINDIV14CFGR_FINDIV14EN		BIT(6)
+
+/* RCC_FINDIV15CFGR register fields */
+#define RCC_FINDIV15CFGR_FINDIV15_MASK		GENMASK(5, 0)
+#define RCC_FINDIV15CFGR_FINDIV15_SHIFT		0
+#define RCC_FINDIV15CFGR_FINDIV15EN		BIT(6)
+
+/* RCC_FINDIV16CFGR register fields */
+#define RCC_FINDIV16CFGR_FINDIV16_MASK		GENMASK(5, 0)
+#define RCC_FINDIV16CFGR_FINDIV16_SHIFT		0
+#define RCC_FINDIV16CFGR_FINDIV16EN		BIT(6)
+
+/* RCC_FINDIV17CFGR register fields */
+#define RCC_FINDIV17CFGR_FINDIV17_MASK		GENMASK(5, 0)
+#define RCC_FINDIV17CFGR_FINDIV17_SHIFT		0
+#define RCC_FINDIV17CFGR_FINDIV17EN		BIT(6)
+
+/* RCC_FINDIV18CFGR register fields */
+#define RCC_FINDIV18CFGR_FINDIV18_MASK		GENMASK(5, 0)
+#define RCC_FINDIV18CFGR_FINDIV18_SHIFT		0
+#define RCC_FINDIV18CFGR_FINDIV18EN		BIT(6)
+
+/* RCC_FINDIV19CFGR register fields */
+#define RCC_FINDIV19CFGR_FINDIV19_MASK		GENMASK(5, 0)
+#define RCC_FINDIV19CFGR_FINDIV19_SHIFT		0
+#define RCC_FINDIV19CFGR_FINDIV19EN		BIT(6)
+
+/* RCC_FINDIV20CFGR register fields */
+#define RCC_FINDIV20CFGR_FINDIV20_MASK		GENMASK(5, 0)
+#define RCC_FINDIV20CFGR_FINDIV20_SHIFT		0
+#define RCC_FINDIV20CFGR_FINDIV20EN		BIT(6)
+
+/* RCC_FINDIV21CFGR register fields */
+#define RCC_FINDIV21CFGR_FINDIV21_MASK		GENMASK(5, 0)
+#define RCC_FINDIV21CFGR_FINDIV21_SHIFT		0
+#define RCC_FINDIV21CFGR_FINDIV21EN		BIT(6)
+
+/* RCC_FINDIV22CFGR register fields */
+#define RCC_FINDIV22CFGR_FINDIV22_MASK		GENMASK(5, 0)
+#define RCC_FINDIV22CFGR_FINDIV22_SHIFT		0
+#define RCC_FINDIV22CFGR_FINDIV22EN		BIT(6)
+
+/* RCC_FINDIV23CFGR register fields */
+#define RCC_FINDIV23CFGR_FINDIV23_MASK		GENMASK(5, 0)
+#define RCC_FINDIV23CFGR_FINDIV23_SHIFT		0
+#define RCC_FINDIV23CFGR_FINDIV23EN		BIT(6)
+
+/* RCC_FINDIV24CFGR register fields */
+#define RCC_FINDIV24CFGR_FINDIV24_MASK		GENMASK(5, 0)
+#define RCC_FINDIV24CFGR_FINDIV24_SHIFT		0
+#define RCC_FINDIV24CFGR_FINDIV24EN		BIT(6)
+
+/* RCC_FINDIV25CFGR register fields */
+#define RCC_FINDIV25CFGR_FINDIV25_MASK		GENMASK(5, 0)
+#define RCC_FINDIV25CFGR_FINDIV25_SHIFT		0
+#define RCC_FINDIV25CFGR_FINDIV25EN		BIT(6)
+
+/* RCC_FINDIV26CFGR register fields */
+#define RCC_FINDIV26CFGR_FINDIV26_MASK		GENMASK(5, 0)
+#define RCC_FINDIV26CFGR_FINDIV26_SHIFT		0
+#define RCC_FINDIV26CFGR_FINDIV26EN		BIT(6)
+
+/* RCC_FINDIV27CFGR register fields */
+#define RCC_FINDIV27CFGR_FINDIV27_MASK		GENMASK(5, 0)
+#define RCC_FINDIV27CFGR_FINDIV27_SHIFT		0
+#define RCC_FINDIV27CFGR_FINDIV27EN		BIT(6)
+
+/* RCC_FINDIV28CFGR register fields */
+#define RCC_FINDIV28CFGR_FINDIV28_MASK		GENMASK(5, 0)
+#define RCC_FINDIV28CFGR_FINDIV28_SHIFT		0
+#define RCC_FINDIV28CFGR_FINDIV28EN		BIT(6)
+
+/* RCC_FINDIV29CFGR register fields */
+#define RCC_FINDIV29CFGR_FINDIV29_MASK		GENMASK(5, 0)
+#define RCC_FINDIV29CFGR_FINDIV29_SHIFT		0
+#define RCC_FINDIV29CFGR_FINDIV29EN		BIT(6)
+
+/* RCC_FINDIV30CFGR register fields */
+#define RCC_FINDIV30CFGR_FINDIV30_MASK		GENMASK(5, 0)
+#define RCC_FINDIV30CFGR_FINDIV30_SHIFT		0
+#define RCC_FINDIV30CFGR_FINDIV30EN		BIT(6)
+
+/* RCC_FINDIV31CFGR register fields */
+#define RCC_FINDIV31CFGR_FINDIV31_MASK		GENMASK(5, 0)
+#define RCC_FINDIV31CFGR_FINDIV31_SHIFT		0
+#define RCC_FINDIV31CFGR_FINDIV31EN		BIT(6)
+
+/* RCC_FINDIV32CFGR register fields */
+#define RCC_FINDIV32CFGR_FINDIV32_MASK		GENMASK(5, 0)
+#define RCC_FINDIV32CFGR_FINDIV32_SHIFT		0
+#define RCC_FINDIV32CFGR_FINDIV32EN		BIT(6)
+
+/* RCC_FINDIV33CFGR register fields */
+#define RCC_FINDIV33CFGR_FINDIV33_MASK		GENMASK(5, 0)
+#define RCC_FINDIV33CFGR_FINDIV33_SHIFT		0
+#define RCC_FINDIV33CFGR_FINDIV33EN		BIT(6)
+
+/* RCC_FINDIV34CFGR register fields */
+#define RCC_FINDIV34CFGR_FINDIV34_MASK		GENMASK(5, 0)
+#define RCC_FINDIV34CFGR_FINDIV34_SHIFT		0
+#define RCC_FINDIV34CFGR_FINDIV34EN		BIT(6)
+
+/* RCC_FINDIV35CFGR register fields */
+#define RCC_FINDIV35CFGR_FINDIV35_MASK		GENMASK(5, 0)
+#define RCC_FINDIV35CFGR_FINDIV35_SHIFT		0
+#define RCC_FINDIV35CFGR_FINDIV35EN		BIT(6)
+
+/* RCC_FINDIV36CFGR register fields */
+#define RCC_FINDIV36CFGR_FINDIV36_MASK		GENMASK(5, 0)
+#define RCC_FINDIV36CFGR_FINDIV36_SHIFT		0
+#define RCC_FINDIV36CFGR_FINDIV36EN		BIT(6)
+
+/* RCC_FINDIV37CFGR register fields */
+#define RCC_FINDIV37CFGR_FINDIV37_MASK		GENMASK(5, 0)
+#define RCC_FINDIV37CFGR_FINDIV37_SHIFT		0
+#define RCC_FINDIV37CFGR_FINDIV37EN		BIT(6)
+
+/* RCC_FINDIV38CFGR register fields */
+#define RCC_FINDIV38CFGR_FINDIV38_MASK		GENMASK(5, 0)
+#define RCC_FINDIV38CFGR_FINDIV38_SHIFT		0
+#define RCC_FINDIV38CFGR_FINDIV38EN		BIT(6)
+
+/* RCC_FINDIV39CFGR register fields */
+#define RCC_FINDIV39CFGR_FINDIV39_MASK		GENMASK(5, 0)
+#define RCC_FINDIV39CFGR_FINDIV39_SHIFT		0
+#define RCC_FINDIV39CFGR_FINDIV39EN		BIT(6)
+
+/* RCC_FINDIV40CFGR register fields */
+#define RCC_FINDIV40CFGR_FINDIV40_MASK		GENMASK(5, 0)
+#define RCC_FINDIV40CFGR_FINDIV40_SHIFT		0
+#define RCC_FINDIV40CFGR_FINDIV40EN		BIT(6)
+
+/* RCC_FINDIV41CFGR register fields */
+#define RCC_FINDIV41CFGR_FINDIV41_MASK		GENMASK(5, 0)
+#define RCC_FINDIV41CFGR_FINDIV41_SHIFT		0
+#define RCC_FINDIV41CFGR_FINDIV41EN		BIT(6)
+
+/* RCC_FINDIV42CFGR register fields */
+#define RCC_FINDIV42CFGR_FINDIV42_MASK		GENMASK(5, 0)
+#define RCC_FINDIV42CFGR_FINDIV42_SHIFT		0
+#define RCC_FINDIV42CFGR_FINDIV42EN		BIT(6)
+
+/* RCC_FINDIV43CFGR register fields */
+#define RCC_FINDIV43CFGR_FINDIV43_MASK		GENMASK(5, 0)
+#define RCC_FINDIV43CFGR_FINDIV43_SHIFT		0
+#define RCC_FINDIV43CFGR_FINDIV43EN		BIT(6)
+
+/* RCC_FINDIV44CFGR register fields */
+#define RCC_FINDIV44CFGR_FINDIV44_MASK		GENMASK(5, 0)
+#define RCC_FINDIV44CFGR_FINDIV44_SHIFT		0
+#define RCC_FINDIV44CFGR_FINDIV44EN		BIT(6)
+
+/* RCC_FINDIV45CFGR register fields */
+#define RCC_FINDIV45CFGR_FINDIV45_MASK		GENMASK(5, 0)
+#define RCC_FINDIV45CFGR_FINDIV45_SHIFT		0
+#define RCC_FINDIV45CFGR_FINDIV45EN		BIT(6)
+
+/* RCC_FINDIV46CFGR register fields */
+#define RCC_FINDIV46CFGR_FINDIV46_MASK		GENMASK(5, 0)
+#define RCC_FINDIV46CFGR_FINDIV46_SHIFT		0
+#define RCC_FINDIV46CFGR_FINDIV46EN		BIT(6)
+
+/* RCC_FINDIV47CFGR register fields */
+#define RCC_FINDIV47CFGR_FINDIV47_MASK		GENMASK(5, 0)
+#define RCC_FINDIV47CFGR_FINDIV47_SHIFT		0
+#define RCC_FINDIV47CFGR_FINDIV47EN		BIT(6)
+
+/* RCC_FINDIV48CFGR register fields */
+#define RCC_FINDIV48CFGR_FINDIV48_MASK		GENMASK(5, 0)
+#define RCC_FINDIV48CFGR_FINDIV48_SHIFT		0
+#define RCC_FINDIV48CFGR_FINDIV48EN		BIT(6)
+
+/* RCC_FINDIV49CFGR register fields */
+#define RCC_FINDIV49CFGR_FINDIV49_MASK		GENMASK(5, 0)
+#define RCC_FINDIV49CFGR_FINDIV49_SHIFT		0
+#define RCC_FINDIV49CFGR_FINDIV49EN		BIT(6)
+
+/* RCC_FINDIV50CFGR register fields */
+#define RCC_FINDIV50CFGR_FINDIV50_MASK		GENMASK(5, 0)
+#define RCC_FINDIV50CFGR_FINDIV50_SHIFT		0
+#define RCC_FINDIV50CFGR_FINDIV50EN		BIT(6)
+
+/* RCC_FINDIV51CFGR register fields */
+#define RCC_FINDIV51CFGR_FINDIV51_MASK		GENMASK(5, 0)
+#define RCC_FINDIV51CFGR_FINDIV51_SHIFT		0
+#define RCC_FINDIV51CFGR_FINDIV51EN		BIT(6)
+
+/* RCC_FINDIV52CFGR register fields */
+#define RCC_FINDIV52CFGR_FINDIV52_MASK		GENMASK(5, 0)
+#define RCC_FINDIV52CFGR_FINDIV52_SHIFT		0
+#define RCC_FINDIV52CFGR_FINDIV52EN		BIT(6)
+
+/* RCC_FINDIV53CFGR register fields */
+#define RCC_FINDIV53CFGR_FINDIV53_MASK		GENMASK(5, 0)
+#define RCC_FINDIV53CFGR_FINDIV53_SHIFT		0
+#define RCC_FINDIV53CFGR_FINDIV53EN		BIT(6)
+
+/* RCC_FINDIV54CFGR register fields */
+#define RCC_FINDIV54CFGR_FINDIV54_MASK		GENMASK(5, 0)
+#define RCC_FINDIV54CFGR_FINDIV54_SHIFT		0
+#define RCC_FINDIV54CFGR_FINDIV54EN		BIT(6)
+
+/* RCC_FINDIV55CFGR register fields */
+#define RCC_FINDIV55CFGR_FINDIV55_MASK		GENMASK(5, 0)
+#define RCC_FINDIV55CFGR_FINDIV55_SHIFT		0
+#define RCC_FINDIV55CFGR_FINDIV55EN		BIT(6)
+
+/* RCC_FINDIV56CFGR register fields */
+#define RCC_FINDIV56CFGR_FINDIV56_MASK		GENMASK(5, 0)
+#define RCC_FINDIV56CFGR_FINDIV56_SHIFT		0
+#define RCC_FINDIV56CFGR_FINDIV56EN		BIT(6)
+
+/* RCC_FINDIV57CFGR register fields */
+#define RCC_FINDIV57CFGR_FINDIV57_MASK		GENMASK(5, 0)
+#define RCC_FINDIV57CFGR_FINDIV57_SHIFT		0
+#define RCC_FINDIV57CFGR_FINDIV57EN		BIT(6)
+
+/* RCC_FINDIV58CFGR register fields */
+#define RCC_FINDIV58CFGR_FINDIV58_MASK		GENMASK(5, 0)
+#define RCC_FINDIV58CFGR_FINDIV58_SHIFT		0
+#define RCC_FINDIV58CFGR_FINDIV58EN		BIT(6)
+
+/* RCC_FINDIV59CFGR register fields */
+#define RCC_FINDIV59CFGR_FINDIV59_MASK		GENMASK(5, 0)
+#define RCC_FINDIV59CFGR_FINDIV59_SHIFT		0
+#define RCC_FINDIV59CFGR_FINDIV59EN		BIT(6)
+
+/* RCC_FINDIV60CFGR register fields */
+#define RCC_FINDIV60CFGR_FINDIV60_MASK		GENMASK(5, 0)
+#define RCC_FINDIV60CFGR_FINDIV60_SHIFT		0
+#define RCC_FINDIV60CFGR_FINDIV60EN		BIT(6)
+
+/* RCC_FINDIV61CFGR register fields */
+#define RCC_FINDIV61CFGR_FINDIV61_MASK		GENMASK(5, 0)
+#define RCC_FINDIV61CFGR_FINDIV61_SHIFT		0
+#define RCC_FINDIV61CFGR_FINDIV61EN		BIT(6)
+
+/* RCC_FINDIV62CFGR register fields */
+#define RCC_FINDIV62CFGR_FINDIV62_MASK		GENMASK(5, 0)
+#define RCC_FINDIV62CFGR_FINDIV62_SHIFT		0
+#define RCC_FINDIV62CFGR_FINDIV62EN		BIT(6)
+
+/* RCC_FINDIV63CFGR register fields */
+#define RCC_FINDIV63CFGR_FINDIV63_MASK		GENMASK(5, 0)
+#define RCC_FINDIV63CFGR_FINDIV63_SHIFT		0
+#define RCC_FINDIV63CFGR_FINDIV63EN		BIT(6)
+
+/* RCC_FINDIVxCFGR register fields */
+#define RCC_FINDIVxCFGR_FINDIVx_MASK		GENMASK(5, 0)
+#define RCC_FINDIVxCFGR_FINDIVx_SHIFT		0
+#define RCC_FINDIVxCFGR_FINDIVxEN		BIT(6)
+
+/* RCC_FCALCOBS0CFGR register fields */
+#define RCC_FCALCOBS0CFGR_CKINTSEL_MASK		GENMASK(7, 0)
+#define RCC_FCALCOBS0CFGR_CKINTSEL_SHIFT	0
+#define RCC_FCALCOBS0CFGR_CKEXTSEL_MASK		GENMASK(10, 8)
+#define RCC_FCALCOBS0CFGR_CKEXTSEL_SHIFT	8
+#define RCC_FCALCOBS0CFGR_FCALCCKEXTSEL		BIT(15)
+#define RCC_FCALCOBS0CFGR_CKOBSEXTSEL		BIT(16)
+#define RCC_FCALCOBS0CFGR_FCALCCKINV		BIT(17)
+#define RCC_FCALCOBS0CFGR_CKOBSINV		BIT(18)
+#define RCC_FCALCOBS0CFGR_CKOBSDIV_MASK		GENMASK(24, 22)
+#define RCC_FCALCOBS0CFGR_CKOBSDIV_SHIFT	22
+#define RCC_FCALCOBS0CFGR_FCALCCKEN		BIT(25)
+#define RCC_FCALCOBS0CFGR_CKOBSEN		BIT(26)
+
+/* RCC_FCALCOBS1CFGR register fields */
+#define RCC_FCALCOBS1CFGR_CKINTSEL_MASK		GENMASK(7, 0)
+#define RCC_FCALCOBS1CFGR_CKINTSEL_SHIFT	0
+#define RCC_FCALCOBS1CFGR_CKEXTSEL_MASK		GENMASK(10, 8)
+#define RCC_FCALCOBS1CFGR_CKEXTSEL_SHIFT	8
+#define RCC_FCALCOBS1CFGR_CKOBSEXTSEL		BIT(16)
+#define RCC_FCALCOBS1CFGR_CKOBSINV		BIT(18)
+#define RCC_FCALCOBS1CFGR_CKOBSDIV_MASK		GENMASK(24, 22)
+#define RCC_FCALCOBS1CFGR_CKOBSDIV_SHIFT	22
+#define RCC_FCALCOBS1CFGR_CKOBSEN		BIT(26)
+#define RCC_FCALCOBS1CFGR_FCALCRSTN		BIT(27)
+
+/* RCC_FCALCREFCFGR register fields */
+#define RCC_FCALCREFCFGR_FCALCREFCKSEL_MASK	GENMASK(2, 0)
+#define RCC_FCALCREFCFGR_FCALCREFCKSEL_SHIFT	0
+
+/* RCC_FCALCCR1 register fields */
+#define RCC_FCALCCR1_FCALCRUN			BIT(0)
+
+/* RCC_FCALCCR2 register fields */
+#define RCC_FCALCCR2_FCALCMD_MASK		GENMASK(4, 3)
+#define RCC_FCALCCR2_FCALCMD_SHIFT		3
+#define RCC_FCALCCR2_FCALCTWC_MASK		GENMASK(14, 11)
+#define RCC_FCALCCR2_FCALCTWC_SHIFT		11
+#define RCC_FCALCCR2_FCALCTYP_MASK		GENMASK(21, 17)
+#define RCC_FCALCCR2_FCALCTYP_SHIFT		17
+
+/* RCC_FCALCSR register fields */
+#define RCC_FCALCSR_FVAL_MASK			GENMASK(16, 0)
+#define RCC_FCALCSR_FVAL_SHIFT			0
+#define RCC_FCALCSR_FCALCSTS			BIT(19)
+
+/* RCC_PLL4CFGR1 register fields */
+#define RCC_PLL4CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL4CFGR1_PLLEN			BIT(8)
+#define RCC_PLL4CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL4CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL4CFGR2 register fields */
+#define RCC_PLL4CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL4CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL4CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL4CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL4CFGR3 register fields */
+#define RCC_PLL4CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL4CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL4CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL4CFGR3_DACEN			BIT(25)
+#define RCC_PLL4CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL4CFGR4 register fields */
+#define RCC_PLL4CFGR4_DSMEN			BIT(8)
+#define RCC_PLL4CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL4CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL4CFGR5 register fields */
+#define RCC_PLL4CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL4CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL4CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL4CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL4CFGR6 register fields */
+#define RCC_PLL4CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL4CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL4CFGR7 register fields */
+#define RCC_PLL4CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL4CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL5CFGR1 register fields */
+#define RCC_PLL5CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL5CFGR1_PLLEN			BIT(8)
+#define RCC_PLL5CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL5CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL5CFGR2 register fields */
+#define RCC_PLL5CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL5CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL5CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL5CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL5CFGR3 register fields */
+#define RCC_PLL5CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL5CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL5CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL5CFGR3_DACEN			BIT(25)
+#define RCC_PLL5CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL5CFGR4 register fields */
+#define RCC_PLL5CFGR4_DSMEN			BIT(8)
+#define RCC_PLL5CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL5CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL5CFGR5 register fields */
+#define RCC_PLL5CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL5CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL5CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL5CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL5CFGR6 register fields */
+#define RCC_PLL5CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL5CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL5CFGR7 register fields */
+#define RCC_PLL5CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL5CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL6CFGR1 register fields */
+#define RCC_PLL6CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL6CFGR1_PLLEN			BIT(8)
+#define RCC_PLL6CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL6CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL6CFGR2 register fields */
+#define RCC_PLL6CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL6CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL6CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL6CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL6CFGR3 register fields */
+#define RCC_PLL6CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL6CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL6CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL6CFGR3_DACEN			BIT(25)
+#define RCC_PLL6CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL6CFGR4 register fields */
+#define RCC_PLL6CFGR4_DSMEN			BIT(8)
+#define RCC_PLL6CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL6CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL6CFGR5 register fields */
+#define RCC_PLL6CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL6CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL6CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL6CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL6CFGR6 register fields */
+#define RCC_PLL6CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL6CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL6CFGR7 register fields */
+#define RCC_PLL6CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL6CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL7CFGR1 register fields */
+#define RCC_PLL7CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL7CFGR1_PLLEN			BIT(8)
+#define RCC_PLL7CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL7CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL7CFGR2 register fields */
+#define RCC_PLL7CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL7CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL7CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL7CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL7CFGR3 register fields */
+#define RCC_PLL7CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL7CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL7CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL7CFGR3_DACEN			BIT(25)
+#define RCC_PLL7CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL7CFGR4 register fields */
+#define RCC_PLL7CFGR4_DSMEN			BIT(8)
+#define RCC_PLL7CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL7CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL7CFGR5 register fields */
+#define RCC_PLL7CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL7CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL7CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL7CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL7CFGR6 register fields */
+#define RCC_PLL7CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL7CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL7CFGR7 register fields */
+#define RCC_PLL7CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL7CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL8CFGR1 register fields */
+#define RCC_PLL8CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL8CFGR1_PLLEN			BIT(8)
+#define RCC_PLL8CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL8CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL8CFGR2 register fields */
+#define RCC_PLL8CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL8CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL8CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL8CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL8CFGR3 register fields */
+#define RCC_PLL8CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL8CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL8CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL8CFGR3_DACEN			BIT(25)
+#define RCC_PLL8CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL8CFGR4 register fields */
+#define RCC_PLL8CFGR4_DSMEN			BIT(8)
+#define RCC_PLL8CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL8CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL8CFGR5 register fields */
+#define RCC_PLL8CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL8CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL8CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL8CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL8CFGR6 register fields */
+#define RCC_PLL8CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL8CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL8CFGR7 register fields */
+#define RCC_PLL8CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL8CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLLxCFGR1 register fields */
+#define RCC_PLLxCFGR1_SSMODRST			BIT(0)
+#define RCC_PLLxCFGR1_PLLEN			BIT(8)
+#define RCC_PLLxCFGR1_PLLRDY			BIT(24)
+#define RCC_PLLxCFGR1_CKREFST			BIT(28)
+
+/* RCC_PLLxCFGR2 register fields */
+#define RCC_PLLxCFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLLxCFGR2_FREFDIV_SHIFT		0
+#define RCC_PLLxCFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLLxCFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLLxCFGR3 register fields */
+#define RCC_PLLxCFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLLxCFGR3_FRACIN_SHIFT		0
+#define RCC_PLLxCFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLLxCFGR3_DACEN			BIT(25)
+#define RCC_PLLxCFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLLxCFGR4 register fields */
+#define RCC_PLLxCFGR4_DSMEN			BIT(8)
+#define RCC_PLLxCFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLLxCFGR4_BYPASS			BIT(10)
+
+/* RCC_PLLxCFGR5 register fields */
+#define RCC_PLLxCFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLLxCFGR5_DIVVAL_SHIFT		0
+#define RCC_PLLxCFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLLxCFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLLxCFGR6 register fields */
+#define RCC_PLLxCFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLLxCFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLLxCFGR7 register fields */
+#define RCC_PLLxCFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLLxCFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_VERR register fields */
+#define RCC_VERR_MINREV_MASK			GENMASK(3, 0)
+#define RCC_VERR_MINREV_SHIFT			0
+#define RCC_VERR_MAJREV_MASK			GENMASK(7, 4)
+#define RCC_VERR_MAJREV_SHIFT			4
+
+#endif /* STM32MP2_RCC_H */
diff --git a/drivers/clocksource/timer-stm32-lp.c b/drivers/clocksource/timer-stm32-lp.c
index db2841d0b..90c10f378 100644
--- a/drivers/clocksource/timer-stm32-lp.c
+++ b/drivers/clocksource/timer-stm32-lp.c
@@ -168,9 +168,7 @@ static int stm32_clkevent_lp_probe(struct platform_device *pdev)
 	}
 
 	if (of_property_read_bool(pdev->dev.parent->of_node, "wakeup-source")) {
-		ret = device_init_wakeup(&pdev->dev, true);
-		if (ret)
-			goto out_clk_disable;
+		device_set_wakeup_capable(&pdev->dev, true);
 
 		ret = dev_pm_set_wake_irq(&pdev->dev, irq);
 		if (ret)
diff --git a/drivers/counter/stm32-lptimer-cnt.c b/drivers/counter/stm32-lptimer-cnt.c
index 13656957c..89e31e893 100644
--- a/drivers/counter/stm32-lptimer-cnt.c
+++ b/drivers/counter/stm32-lptimer-cnt.c
@@ -69,7 +69,7 @@ static int stm32_lptim_set_enable_state(struct stm32_lptim_cnt *priv,
 
 	/* ensure CMP & ARR registers are properly written */
 	ret = regmap_read_poll_timeout(priv->regmap, STM32_LPTIM_ISR, val,
-				       (val & STM32_LPTIM_CMPOK_ARROK),
+				       (val & STM32_LPTIM_CMPOK_ARROK) == STM32_LPTIM_CMPOK_ARROK,
 				       100, 1000);
 	if (ret)
 		return ret;
@@ -509,6 +509,7 @@ static SIMPLE_DEV_PM_OPS(stm32_lptim_cnt_pm_ops, stm32_lptim_cnt_suspend,
 
 static const struct of_device_id stm32_lptim_cnt_of_match[] = {
 	{ .compatible = "st,stm32-lptimer-counter", },
+	{ .compatible = "st,stm32mp25-lptimer-counter", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32_lptim_cnt_of_match);
diff --git a/drivers/cpufreq/Kconfig.arm b/drivers/cpufreq/Kconfig.arm
index 954749afb..eac08e907 100644
--- a/drivers/cpufreq/Kconfig.arm
+++ b/drivers/cpufreq/Kconfig.arm
@@ -311,6 +311,13 @@ config ARM_STI_CPUFREQ
 	  this config option if you wish to add CPUFreq support for STi based
 	  SoCs.
 
+config ARM_STM32_CPUFREQ
+	tristate "STM32 CPUFreq support"
+	depends on MACH_STM32MP157
+	default y
+	help
+	  This adds the CPUFreq driver support for STM32 MPU SOCs.
+
 config ARM_TEGRA20_CPUFREQ
 	tristate "Tegra20/30 CPUFreq support"
 	depends on ARCH_TEGRA && CPUFREQ_DT
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index 48ee58590..d34de1b92 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -78,6 +78,7 @@ obj-$(CONFIG_ARM_SCMI_CPUFREQ)		+= scmi-cpufreq.o
 obj-$(CONFIG_ARM_SCPI_CPUFREQ)		+= scpi-cpufreq.o
 obj-$(CONFIG_ARM_SPEAR_CPUFREQ)		+= spear-cpufreq.o
 obj-$(CONFIG_ARM_STI_CPUFREQ)		+= sti-cpufreq.o
+obj-$(CONFIG_ARM_STM32_CPUFREQ)		+= stm32-cpufreq.o
 obj-$(CONFIG_ARM_ALLWINNER_SUN50I_CPUFREQ_NVMEM) += sun50i-cpufreq-nvmem.o
 obj-$(CONFIG_ARM_TEGRA20_CPUFREQ)	+= tegra20-cpufreq.o
 obj-$(CONFIG_ARM_TEGRA124_CPUFREQ)	+= tegra124-cpufreq.o
diff --git a/drivers/cpufreq/cpufreq-dt-platdev.c b/drivers/cpufreq/cpufreq-dt-platdev.c
index ca1d103ec..f205e6e97 100644
--- a/drivers/cpufreq/cpufreq-dt-platdev.c
+++ b/drivers/cpufreq/cpufreq-dt-platdev.c
@@ -150,6 +150,7 @@ static const struct of_device_id blocklist[] __initconst = {
 	{ .compatible = "st,stih407", },
 	{ .compatible = "st,stih410", },
 	{ .compatible = "st,stih418", },
+	{ .compatible = "st,stm32mp157", },
 
 	{ .compatible = "ti,am33xx", },
 	{ .compatible = "ti,am43", },
diff --git a/drivers/cpufreq/stm32-cpufreq.c b/drivers/cpufreq/stm32-cpufreq.c
new file mode 100644
index 000000000..d7b1b16ea
--- /dev/null
+++ b/drivers/cpufreq/stm32-cpufreq.c
@@ -0,0 +1,103 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Authors: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+#include <linux/cpu.h>
+#include <linux/cpufreq.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/nvmem-consumer.h>
+#include <linux/of_platform.h>
+#include <linux/pm_opp.h>
+
+struct stm32_cpufreq_priv {
+	struct opp_table *opps;
+	struct platform_device *cpufreq_dt_pdev;
+};
+
+static int stm32_cpufreq_probe(struct platform_device *pdev)
+{
+	struct stm32_cpufreq_priv *priv;
+	struct device_node *opp_node;
+	struct device *cpu_dev;
+	u8 part_number;
+	u32 supported_hw;
+	int ret;
+
+	cpu_dev = get_cpu_device(0);
+	if (!cpu_dev) {
+		dev_err(&pdev->dev, "failed to get cpu0 device\n");
+		return -ENODEV;
+	}
+	opp_node = dev_pm_opp_of_get_opp_desc_node(cpu_dev);
+	if (!opp_node) {
+		dev_err(&pdev->dev, "OPP-v2 not supported\n");
+		return -ENODEV;
+	}
+
+	/* Get chip info */
+	ret = nvmem_cell_read_u8(cpu_dev, "part_number", &part_number);
+	if (ret) {
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Failed to get chip info: %d\n",
+				ret);
+		return ret;
+	}
+
+	supported_hw = BIT((part_number & 0x80) >> 7);
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->opps = dev_pm_opp_set_supported_hw(cpu_dev, &supported_hw, 1);
+	if (IS_ERR(priv->opps)) {
+		ret = PTR_ERR(priv->opps);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Failed to set supported opp: %d\n",
+				ret);
+		return ret;
+	}
+
+	of_node_put(opp_node);
+	priv->cpufreq_dt_pdev = platform_device_register_simple("cpufreq-dt",
+								-1, NULL, 0);
+
+	platform_set_drvdata(pdev, priv);
+
+	return 0;
+}
+
+static int stm32_cpufreq_remove(struct platform_device *pdev)
+{
+	struct stm32_cpufreq_priv *priv	= platform_get_drvdata(pdev);
+
+	platform_device_unregister(priv->cpufreq_dt_pdev);
+	dev_pm_opp_put_supported_hw(priv->opps);
+
+	return 0;
+}
+
+static int stm32_cpufreq_init(void)
+{
+	platform_device_register_simple("stm32-cpufreq", -1, NULL, 0);
+
+	return 0;
+}
+module_init(stm32_cpufreq_init);
+
+static struct platform_driver stm32_cpufreq_platdrv = {
+	.driver = {
+		.name	= "stm32-cpufreq",
+	},
+	.probe		= stm32_cpufreq_probe,
+	.remove		= stm32_cpufreq_remove,
+};
+module_platform_driver(stm32_cpufreq_platdrv);
+
+MODULE_DESCRIPTION("STM32 CPU freq driver");
+MODULE_AUTHOR("Alexandre Torgue <alexandre.torgue@st.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/cpuidle/Kconfig.arm b/drivers/cpuidle/Kconfig.arm
index 334f83e56..4de5db493 100644
--- a/drivers/cpuidle/Kconfig.arm
+++ b/drivers/cpuidle/Kconfig.arm
@@ -91,6 +91,14 @@ config ARM_EXYNOS_CPUIDLE
 	help
 	  Select this to enable cpuidle for Exynos processors.
 
+config ARM_STM32_CPUIDLE
+	bool "Cpu Idle Driver for the STM32 processors"
+	depends on MACH_STM32MP157
+	select DT_IDLE_STATES
+	select ARCH_NEEDS_CPU_IDLE_COUPLED if SMP
+	help
+	  Select this to enable cpuidle for STM32 processors.
+
 config ARM_MVEBU_V7_CPUIDLE
 	bool "CPU Idle Driver for mvebu v7 family processors"
 	depends on (ARCH_MVEBU || COMPILE_TEST) && !ARM64
diff --git a/drivers/cpuidle/Makefile b/drivers/cpuidle/Makefile
index 26bbc5e74..cc1eccc73 100644
--- a/drivers/cpuidle/Makefile
+++ b/drivers/cpuidle/Makefile
@@ -25,6 +25,7 @@ obj-$(CONFIG_ARM_PSCI_CPUIDLE)		+= cpuidle-psci.o
 obj-$(CONFIG_ARM_PSCI_CPUIDLE_DOMAIN)	+= cpuidle-psci-domain.o
 obj-$(CONFIG_ARM_TEGRA_CPUIDLE)		+= cpuidle-tegra.o
 obj-$(CONFIG_ARM_QCOM_SPM_CPUIDLE)	+= cpuidle-qcom-spm.o
+obj-$(CONFIG_ARM_STM32_CPUIDLE)		+= cpuidle-stm32.o
 
 ###############################################################################
 # MIPS drivers
diff --git a/drivers/cpuidle/cpuidle-stm32.c b/drivers/cpuidle/cpuidle-stm32.c
new file mode 100644
index 000000000..2fef170d6
--- /dev/null
+++ b/drivers/cpuidle/cpuidle-stm32.c
@@ -0,0 +1,276 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) STMicroelectronics 2019
+// Author:
+
+#include <linux/arm-smccc.h>
+#include <linux/cpu_pm.h>
+#include <linux/cpuidle.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/pm_domain.h>
+#include <linux/pm_runtime.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/tick.h>
+
+#include <asm/cpuidle.h>
+
+#include "dt_idle_states.h"
+
+#define SMC_AUTOSTOP()				\
+{								\
+	struct arm_smccc_res res;				\
+	arm_smccc_smc(0x8200100a, 0, 0, 0,			\
+		      0, 0, 0, 0, &res);			\
+}
+
+struct stm32_pm_domain {
+	struct device *dev;
+	struct generic_pm_domain genpd;
+	int id;
+};
+
+static atomic_t stm_idle_barrier;
+
+static int stm32_enter_idle(struct cpuidle_device *dev,
+			    struct cpuidle_driver *drv, int index)
+{
+	/*
+	 * Call idle CPU PM enter notifier chain so that
+	 * VFP and per CPU interrupt context is saved.
+	 */
+	cpu_pm_enter();
+
+	/*
+	 * be sure that both cpu enter at the same time
+	 * normally not needed is the state is declared as coupled
+	 */
+	cpuidle_coupled_parallel_barrier(dev, &stm_idle_barrier);
+
+	/* Enter broadcast mode for periodic timers */
+	tick_broadcast_enable();
+
+	/* Enter broadcast mode for one-shot timers */
+	tick_broadcast_enter();
+
+	if (dev->cpu == 0)
+		cpu_cluster_pm_enter();
+
+	SMC_AUTOSTOP();
+
+	if (dev->cpu == 0)
+		cpu_cluster_pm_exit();
+
+	tick_broadcast_exit();
+
+	cpuidle_coupled_parallel_barrier(dev, &stm_idle_barrier);
+
+	/*
+	 * Call idle CPU PM exit notifier chain to restore
+	 * VFP and per CPU IRQ context.
+	 */
+	cpu_pm_exit();
+
+	return index;
+}
+
+static const struct of_device_id stm32_idle_state_match[] __initconst = {
+	{ .compatible = "arm,idle-state",
+	  .data = stm32_enter_idle },
+	{ },
+};
+
+static struct cpuidle_driver stm32_idle_driver = {
+	.name = "stm32_idle",
+	.states = {
+		ARM_CPUIDLE_WFI_STATE,
+		{
+			.enter		  = stm32_enter_idle,
+			.exit_latency	  = 620,
+			.target_residency = 700,
+			.flags		  = /*CPUIDLE_FLAG_TIMER_STOP | */
+						CPUIDLE_FLAG_COUPLED,
+			.name		  = "CStop",
+			.desc		  = "Clocks off",
+		},
+	},
+	.safe_state_index = 0,
+	.state_count = 2,
+};
+
+static int stm32_pd_cpuidle_off(struct generic_pm_domain *domain)
+{
+	struct stm32_pm_domain *priv = container_of(domain,
+						    struct stm32_pm_domain,
+						    genpd);
+	int cpu;
+
+	for_each_possible_cpu(cpu) {
+		struct cpuidle_device *cpuidle_dev = per_cpu(cpuidle_devices,
+							     cpu);
+
+		cpuidle_dev->states_usage[1].disable = false;
+	}
+
+	dev_dbg(priv->dev, "%s OFF\n", domain->name);
+
+	return 0;
+}
+
+static int stm32_pd_cpuidle_on(struct generic_pm_domain *domain)
+{
+	struct stm32_pm_domain *priv = container_of(domain,
+						    struct stm32_pm_domain,
+						    genpd);
+	int cpu;
+
+	for_each_possible_cpu(cpu) {
+		struct cpuidle_device *cpuidle_dev = per_cpu(cpuidle_devices,
+							     cpu);
+
+		cpuidle_dev->states_usage[1].disable = true;
+	}
+
+	dev_dbg(priv->dev, "%s ON\n", domain->name);
+
+	return 0;
+}
+
+static void stm32_cpuidle_domain_remove(struct stm32_pm_domain *domain)
+{
+	int ret;
+
+	ret = pm_genpd_remove(&domain->genpd);
+	if (ret)
+		dev_err(domain->dev, "failed to remove PM domain %s: %d\n",
+			domain->genpd.name, ret);
+}
+
+static int stm32_cpuidle_domain_add(struct stm32_pm_domain *domain,
+				    struct device *dev,
+				    struct device_node *np)
+{
+	int ret;
+
+	domain->dev = dev;
+	domain->genpd.name = np->name;
+	domain->genpd.power_off = stm32_pd_cpuidle_off;
+	domain->genpd.power_on = stm32_pd_cpuidle_on;
+
+	ret = pm_genpd_init(&domain->genpd, NULL, 0);
+	if (ret < 0) {
+		dev_err(domain->dev, "failed to initialise PM domain %s: %d\n",
+			np->name, ret);
+		return ret;
+	}
+
+	ret = of_genpd_add_provider_simple(np, &domain->genpd);
+	if (ret < 0) {
+		dev_err(domain->dev, "failed to register PM domain %s: %d\n",
+			np->name, ret);
+		stm32_cpuidle_domain_remove(domain);
+		return ret;
+	}
+
+	dev_info(domain->dev, "domain %s registered\n", np->name);
+
+	return 0;
+}
+
+static int stm32_cpuidle_probe(struct platform_device *pdev)
+{
+	struct cpuidle_driver *drv;
+	struct stm32_pm_domain *domain;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct of_phandle_args child, parent;
+	struct device_node *np_child;
+	int cpu, ret;
+
+	drv = devm_kmemdup(dev, &stm32_idle_driver, sizeof(*drv), GFP_KERNEL);
+	if (!drv)
+		return -ENOMEM;
+
+	/* Start at index 1, index 0 standard WFI */
+	ret = dt_init_idle_driver(drv, stm32_idle_state_match, 1);
+	if (ret < 0)
+		return ret;
+
+	/* all the cpus of the system are coupled */
+	ret = cpuidle_register(drv, cpu_possible_mask);
+	if (ret)
+		return ret;
+
+	/* Declare cpuidle domain */
+	domain = devm_kzalloc(dev, sizeof(*domain), GFP_KERNEL);
+	if (!domain)
+		return -ENOMEM;
+
+	ret = stm32_cpuidle_domain_add(domain, dev, np);
+	if (ret) {
+		devm_kfree(dev, domain);
+		return ret;
+	}
+
+	/* disable cpu idle */
+	for_each_possible_cpu(cpu) {
+		struct cpuidle_device *cpuidle_dev = per_cpu(cpuidle_devices,
+							     cpu);
+
+		cpuidle_dev->states_usage[1].disable = true;
+	}
+
+	/*  link main cpuidle domain to consumer domain */
+	for_each_child_of_node(np, np_child) {
+		if (!of_parse_phandle_with_args(np_child, "power-domains",
+						"#power-domain-cells",
+						0, &child)) {
+			struct device_node *np_test = child.np;
+
+			parent.np = np;
+			parent.args_count = 0;
+
+			ret = of_genpd_add_subdomain(&parent, &child);
+			if (ret < 0)
+				dev_err(dev, "failed to add Sub PM domain %d\n",
+					ret);
+
+			dev_dbg(dev, "%s, add sub cpuidle of %s, with child %s\n",
+				__func__, np->name, np_test->name);
+
+			pm_runtime_put(dev);
+		}
+	}
+
+	dev_info(dev, "cpuidle domain probed\n");
+
+	return 0;
+}
+
+static int stm32_cpuidle_remove(struct platform_device *pdev)
+{
+	cpuidle_unregister(&stm32_idle_driver);
+	return 0;
+}
+
+static const struct of_device_id stm32_cpuidle_of_match[] = {
+	{
+		.compatible = "stm32,cpuidle",
+	},
+};
+
+static struct platform_driver stm32_cpuidle_driver = {
+	.probe = stm32_cpuidle_probe,
+	.remove = stm32_cpuidle_remove,
+	.driver = {
+		   .name = "stm32_cpuidle",
+		   .owner = THIS_MODULE,
+		   .of_match_table = stm32_cpuidle_of_match,
+		   },
+};
+
+module_platform_driver(stm32_cpuidle_driver);
+
+MODULE_AUTHOR("<>");
+MODULE_DESCRIPTION("STM32 cpu idle driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/crypto/stm32/stm32-cryp.c b/drivers/crypto/stm32/stm32-cryp.c
index 81eb136b6..d76641596 100644
--- a/drivers/crypto/stm32/stm32-cryp.c
+++ b/drivers/crypto/stm32/stm32-cryp.c
@@ -5,7 +5,10 @@
  */
 
 #include <linux/clk.h>
+#include <linux/debugfs.h>
 #include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
 #include <linux/interrupt.h>
 #include <linux/iopoll.h>
 #include <linux/module.h>
@@ -37,6 +40,8 @@
 /* Mode mask = bits [15..0] */
 #define FLG_MODE_MASK           GENMASK(15, 0)
 /* Bit [31..16] status  */
+#define FLG_IN_OUT_DMA          BIT(16)
+#define FLG_HEADER_DMA          BIT(17)
 
 /* Registers */
 #define CRYP_CR                 0x00000000
@@ -62,6 +67,21 @@
 #define CRYP_CSGCMCCM0R         0x00000050
 #define CRYP_CSGCM0R            0x00000070
 
+static const struct debugfs_reg32 stm32_cryp_regs[] = {
+	{
+		.name = "cr",
+		.offset = CRYP_CR
+	},
+	{
+		.name = "sr",
+		.offset = CRYP_SR
+	},
+	{
+		.name = "dmacr",
+		.offset = CRYP_DMACR
+	}
+};
+
 /* Registers values */
 #define CR_DEC_NOT_ENC          0x00000004
 #define CR_TDES_ECB             0x00000000
@@ -92,8 +112,12 @@
 #define CR_PH_MASK              0x00030000
 #define CR_NBPBL_SHIFT          20
 
-#define SR_BUSY                 0x00000010
-#define SR_OFNE                 0x00000004
+#define SR_IFNF                 BIT(1)
+#define SR_OFNE                 BIT(2)
+#define SR_BUSY                 BIT(8)
+
+#define DMACR_DIEN              BIT(0)
+#define DMACR_DOEN              BIT(1)
 
 #define IMSCR_IN                BIT(0)
 #define IMSCR_OUT               BIT(1)
@@ -104,7 +128,16 @@
 /* Misc */
 #define AES_BLOCK_32            (AES_BLOCK_SIZE / sizeof(u32))
 #define GCM_CTR_INIT            2
-#define CRYP_AUTOSUSPEND_DELAY	50
+#define CRYP_AUTOSUSPEND_DELAY  50
+
+#define CRYP_DMA_BURST_MEM      16
+#define CRYP_DMA_BURST_REG      4
+
+enum stm32_dma_mode {
+	NO_DMA,
+	DMA_PLAIN_SG,
+	DMA_NEED_SG_TRUNC
+};
 
 struct stm32_cryp_caps {
 	bool                    swap_final;
@@ -127,11 +160,13 @@ struct stm32_cryp {
 	struct list_head        list;
 	struct device           *dev;
 	void __iomem            *regs;
+	phys_addr_t             phys_base;
 	struct clk              *clk;
 	unsigned long           flags;
 	u32                     irq_status;
 	const struct stm32_cryp_caps *caps;
 	struct stm32_cryp_ctx   *ctx;
+	struct dentry           *dbgdir;
 
 	struct crypto_engine    *engine;
 
@@ -145,8 +180,19 @@ struct stm32_cryp {
 	size_t                  header_in;
 	size_t                  payload_out;
 
+	/* DMA process fields */
+	struct scatterlist      *in_sg;
+	struct scatterlist      *header_sg;
 	struct scatterlist      *out_sg;
+	size_t                  in_sg_len;
+	size_t                  header_sg_len;
+	size_t                  out_sg_len;
 
+	struct dma_chan         *dma_lch_in;
+	struct dma_chan         *dma_lch_out;
+	enum stm32_dma_mode     dma_mode;
+
+	/* IT process fields */
 	struct scatter_walk     in_walk;
 	struct scatter_walk     out_walk;
 
@@ -232,6 +278,11 @@ static inline int stm32_cryp_wait_busy(struct stm32_cryp *cryp)
 			!(status & SR_BUSY), 10, 100000);
 }
 
+static inline void stm32_cryp_enable(struct stm32_cryp *cryp)
+{
+	writel_relaxed(readl_relaxed(cryp->regs + CRYP_CR) | CR_CRYPEN, cryp->regs + CRYP_CR);
+}
+
 static inline int stm32_cryp_wait_enable(struct stm32_cryp *cryp)
 {
 	u32 status;
@@ -240,6 +291,14 @@ static inline int stm32_cryp_wait_enable(struct stm32_cryp *cryp)
 			!(status & CR_CRYPEN), 10, 100000);
 }
 
+static inline int stm32_cryp_wait_input(struct stm32_cryp *cryp)
+{
+	u32 status;
+
+	return readl_relaxed_poll_timeout(cryp->regs + CRYP_SR, status,
+			status & SR_IFNF, 10, 100000);
+}
+
 static inline int stm32_cryp_wait_output(struct stm32_cryp *cryp)
 {
 	u32 status;
@@ -248,8 +307,13 @@ static inline int stm32_cryp_wait_output(struct stm32_cryp *cryp)
 			status & SR_OFNE, 10, 100000);
 }
 
+static void stm32_cryp_irq_read_data(struct stm32_cryp *cryp);
+static void stm32_cryp_irq_write_data(struct stm32_cryp *cryp);
+static void stm32_cryp_irq_write_gcmccm_header(struct stm32_cryp *cryp);
 static int stm32_cryp_read_auth_tag(struct stm32_cryp *cryp);
 static void stm32_cryp_finish_req(struct stm32_cryp *cryp, int err);
+static int stm32_cryp_dma_start(struct stm32_cryp *cryp);
+static int stm32_cryp_it_start(struct stm32_cryp *cryp);
 
 static struct stm32_cryp *stm32_cryp_find_dev(struct stm32_cryp_ctx *ctx)
 {
@@ -535,9 +599,6 @@ static int stm32_cryp_hw_init(struct stm32_cryp *cryp)
 	/* Disable interrupt */
 	stm32_cryp_write(cryp, CRYP_IMSCR, 0);
 
-	/* Set key */
-	stm32_cryp_hw_write_key(cryp);
-
 	/* Set configuration */
 	cfg = CR_DATA8 | CR_FFLUSH;
 
@@ -563,23 +624,36 @@ static int stm32_cryp_hw_init(struct stm32_cryp *cryp)
 	/* AES ECB/CBC decrypt: run key preparation first */
 	if (is_decrypt(cryp) &&
 	    ((hw_mode == CR_AES_ECB) || (hw_mode == CR_AES_CBC))) {
-		stm32_cryp_write(cryp, CRYP_CR, cfg | CR_AES_KP | CR_CRYPEN);
+		/* Configure in key preparation mode */
+		stm32_cryp_write(cryp, CRYP_CR, cfg | CR_AES_KP);
+
+		/* Set key only after full configuration done */
+		stm32_cryp_hw_write_key(cryp);
 
+		/* Start prepare key */
+		stm32_cryp_enable(cryp);
 		/* Wait for end of processing */
 		ret = stm32_cryp_wait_busy(cryp);
 		if (ret) {
 			dev_err(cryp->dev, "Timeout (key preparation)\n");
 			return ret;
 		}
-	}
 
-	cfg |= hw_mode;
+		cfg |= hw_mode | CR_DEC_NOT_ENC;
 
-	if (is_decrypt(cryp))
-		cfg |= CR_DEC_NOT_ENC;
+		/* Apply updated config (Decrypt + algo) and flush */
+		stm32_cryp_write(cryp, CRYP_CR, cfg);
+	} else {
+		cfg |= hw_mode;
+		if (is_decrypt(cryp))
+			cfg |= CR_DEC_NOT_ENC;
 
-	/* Apply config and flush (valid when CRYPEN = 0) */
-	stm32_cryp_write(cryp, CRYP_CR, cfg);
+		/* Apply config and flush */
+		stm32_cryp_write(cryp, CRYP_CR, cfg);
+
+		/* Set key only after configuration done */
+		stm32_cryp_hw_write_key(cryp);
+	}
 
 	switch (hw_mode) {
 	case CR_AES_GCM:
@@ -607,9 +681,7 @@ static int stm32_cryp_hw_init(struct stm32_cryp *cryp)
 	}
 
 	/* Enable now */
-	cfg |= CR_CRYPEN;
-
-	stm32_cryp_write(cryp, CRYP_CR, cfg);
+	stm32_cryp_enable(cryp);
 
 	return 0;
 }
@@ -629,11 +701,223 @@ static void stm32_cryp_finish_req(struct stm32_cryp *cryp, int err)
 	if (is_gcm(cryp) || is_ccm(cryp))
 		crypto_finalize_aead_request(cryp->engine, cryp->areq, err);
 	else
-		crypto_finalize_skcipher_request(cryp->engine, cryp->req,
-						   err);
+		crypto_finalize_skcipher_request(cryp->engine, cryp->req, err);
 }
 
-static int stm32_cryp_cpu_start(struct stm32_cryp *cryp)
+static void stm32_cryp_header_dma_callback(void *param)
+{
+	struct stm32_cryp *cryp = (struct stm32_cryp *)param;
+	int ret;
+	u32 reg;
+
+	dma_unmap_sg(cryp->dev, cryp->header_sg, cryp->header_sg_len, DMA_TO_DEVICE);
+
+	reg = stm32_cryp_read(cryp, CRYP_DMACR);
+	stm32_cryp_write(cryp, CRYP_DMACR, reg & ~(DMACR_DOEN | DMACR_DIEN));
+
+	kfree(cryp->header_sg);
+
+	reg = stm32_cryp_read(cryp, CRYP_CR);
+
+	if (cryp->header_in) {
+		stm32_cryp_write(cryp, CRYP_CR, reg | CR_CRYPEN);
+
+		ret = stm32_cryp_wait_input(cryp);
+		if (ret) {
+			dev_err(cryp->dev, "input header ready timeout after dma\n");
+			stm32_cryp_finish_req(cryp, ret);
+			return;
+		}
+		stm32_cryp_irq_write_gcmccm_header(cryp);
+		WARN_ON(cryp->header_in);
+	}
+
+	if (stm32_cryp_get_input_text_len(cryp)) {
+		/* Phase 3 : payload */
+		reg = stm32_cryp_read(cryp, CRYP_CR);
+		stm32_cryp_write(cryp, CRYP_CR, reg & ~CR_CRYPEN);
+
+		reg &= ~CR_PH_MASK;
+		reg |= CR_PH_PAYLOAD | CR_CRYPEN;
+		stm32_cryp_write(cryp, CRYP_CR, reg);
+
+		if (cryp->flags & FLG_IN_OUT_DMA) {
+			ret = stm32_cryp_dma_start(cryp);
+			if (ret)
+				stm32_cryp_finish_req(cryp, ret);
+		} else {
+			stm32_cryp_it_start(cryp);
+		}
+	} else {
+		/*
+		 * Phase 4 : tag.
+		 * Nothing to read, nothing to write => end request
+		 */
+		stm32_cryp_finish_req(cryp, 0);
+	}
+}
+static void stm32_cryp_dma_callback(void *param)
+{
+	struct stm32_cryp *cryp = (struct stm32_cryp *)param;
+	int ret;
+	u32 reg;
+
+	dma_sync_sg_for_device(cryp->dev, cryp->out_sg, cryp->out_sg_len, DMA_FROM_DEVICE);
+	dma_unmap_sg(cryp->dev, cryp->in_sg, cryp->in_sg_len, DMA_TO_DEVICE);
+	dma_unmap_sg(cryp->dev, cryp->out_sg, cryp->out_sg_len, DMA_FROM_DEVICE);
+
+	reg = stm32_cryp_read(cryp, CRYP_DMACR);
+	stm32_cryp_write(cryp, CRYP_DMACR, reg & ~(DMACR_DOEN | DMACR_DIEN));
+
+	reg = stm32_cryp_read(cryp, CRYP_CR);
+
+	if (is_gcm(cryp) || is_ccm(cryp)) {
+		kfree(cryp->in_sg);
+		kfree(cryp->out_sg);
+	} else {
+		if (cryp->in_sg != cryp->req->src)
+			kfree(cryp->in_sg);
+		if (cryp->out_sg != cryp->req->dst)
+			kfree(cryp->out_sg);
+	}
+
+	if (cryp->payload_in) {
+		stm32_cryp_write(cryp, CRYP_CR, reg | CR_CRYPEN);
+
+		ret = stm32_cryp_wait_input(cryp);
+		if (ret) {
+			dev_err(cryp->dev, "input ready timeout after dma\n");
+			stm32_cryp_finish_req(cryp, ret);
+			return;
+		}
+		stm32_cryp_irq_write_data(cryp);
+
+		ret = stm32_cryp_wait_output(cryp);
+		if (ret) {
+			dev_err(cryp->dev, "output ready timeout after dma\n");
+			stm32_cryp_finish_req(cryp, ret);
+			return;
+		}
+		stm32_cryp_irq_read_data(cryp);
+	}
+
+	stm32_cryp_finish_req(cryp, 0);
+}
+
+static int stm32_cryp_header_dma_start(struct stm32_cryp *cryp)
+{
+	int err;
+	struct dma_async_tx_descriptor *tx_in;
+	u32 reg;
+	size_t align_size;
+
+	err = dma_map_sg(cryp->dev, cryp->header_sg, cryp->header_sg_len, DMA_TO_DEVICE);
+	if (!err) {
+		dev_err(cryp->dev, "dma_map_sg() error\n");
+		return err;
+	}
+
+	dma_sync_sg_for_device(cryp->dev, cryp->header_sg, cryp->header_sg_len, DMA_TO_DEVICE);
+
+	tx_in = dmaengine_prep_slave_sg(cryp->dma_lch_in, cryp->header_sg, cryp->header_sg_len,
+					DMA_MEM_TO_DEV, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!tx_in) {
+		dev_err(cryp->dev, "IN prep_slave_sg() failed\n");
+		return -EINVAL;
+	}
+
+	tx_in->callback_param = cryp;
+	tx_in->callback = stm32_cryp_header_dma_callback;
+
+	/* Advance scatterwalk to not DMA'ed data */
+	align_size = ALIGN_DOWN(cryp->header_in, cryp->hw_blocksize);
+	scatterwalk_copychunks(NULL, &cryp->in_walk, align_size, 2);
+	cryp->header_in -= align_size;
+
+	err = dma_submit_error(dmaengine_submit(tx_in));
+	if (err < 0) {
+		dev_err(cryp->dev, "DMA in submit failed\n");
+		return err;
+	}
+	dma_async_issue_pending(cryp->dma_lch_in);
+
+	reg = stm32_cryp_read(cryp, CRYP_DMACR);
+	stm32_cryp_write(cryp, CRYP_DMACR, reg | DMACR_DIEN);
+
+	return 0;
+}
+
+static int stm32_cryp_dma_start(struct stm32_cryp *cryp)
+{
+	int err;
+	size_t align_size;
+	struct dma_async_tx_descriptor *tx_in, *tx_out;
+	u32 reg;
+
+	err = dma_map_sg(cryp->dev, cryp->in_sg, cryp->in_sg_len, DMA_TO_DEVICE);
+	if (!err) {
+		dev_err(cryp->dev, "dma_map_sg() error\n");
+		return err;
+	}
+
+	err = dma_map_sg(cryp->dev, cryp->out_sg, cryp->out_sg_len, DMA_FROM_DEVICE);
+	if (!err) {
+		dev_err(cryp->dev, "dma_map_sg() error\n");
+		return err;
+	}
+
+	dma_sync_sg_for_device(cryp->dev, cryp->in_sg, cryp->in_sg_len, DMA_TO_DEVICE);
+
+	tx_in = dmaengine_prep_slave_sg(cryp->dma_lch_in, cryp->in_sg, cryp->in_sg_len,
+					DMA_MEM_TO_DEV, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!tx_in) {
+		dev_err(cryp->dev, "IN prep_slave_sg() failed\n");
+		return -EINVAL;
+	}
+
+	/* No callback necessary */
+	tx_in->callback_param = cryp;
+	tx_in->callback = NULL;
+
+	tx_out = dmaengine_prep_slave_sg(cryp->dma_lch_out, cryp->out_sg, cryp->out_sg_len,
+					 DMA_DEV_TO_MEM, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!tx_out) {
+		dev_err(cryp->dev, "OUT prep_slave_sg() failed\n");
+		return -EINVAL;
+	}
+
+	tx_out->callback = stm32_cryp_dma_callback;
+	tx_out->callback_param = cryp;
+
+	/* Advance scatterwalk to not DMA'ed data */
+	align_size = ALIGN_DOWN(cryp->payload_in, cryp->hw_blocksize);
+	scatterwalk_copychunks(NULL, &cryp->in_walk, align_size, 2);
+	cryp->payload_in -= align_size;
+
+	err = dma_submit_error(dmaengine_submit(tx_in));
+	if (err < 0) {
+		dev_err(cryp->dev, "DMA in submit failed\n");
+		return err;
+	}
+	dma_async_issue_pending(cryp->dma_lch_in);
+
+	/* Advance scatterwalk to not DMA'ed data */
+	scatterwalk_copychunks(NULL, &cryp->out_walk, align_size, 2);
+	cryp->payload_out -= align_size;
+	err = dma_submit_error(dmaengine_submit(tx_out));
+	if (err < 0) {
+		dev_err(cryp->dev, "DMA out submit failed\n");
+		return err;
+	}
+	dma_async_issue_pending(cryp->dma_lch_out);
+
+	reg = stm32_cryp_read(cryp, CRYP_DMACR);
+	stm32_cryp_write(cryp, CRYP_DMACR, reg | DMACR_DOEN | DMACR_DIEN);
+
+	return 0;
+}
+
+static int stm32_cryp_it_start(struct stm32_cryp *cryp)
 {
 	/* Enable interrupt and let the IRQ handler do everything */
 	stm32_cryp_write(cryp, CRYP_IMSCR, IMSCR_IN | IMSCR_OUT);
@@ -980,13 +1264,254 @@ static int stm32_cryp_tdes_cbc_decrypt(struct skcipher_request *req)
 	return stm32_cryp_crypt(req, FLG_TDES | FLG_CBC);
 }
 
+static enum stm32_dma_mode stm32_cryp_dma_check_sg(struct scatterlist *test_sg, size_t len,
+						   size_t block_size)
+{
+	struct scatterlist *sg;
+	int i;
+
+	if (len <= 16)
+		return NO_DMA; /* Faster */
+
+	for_each_sg(test_sg, sg, sg_nents(test_sg), i) {
+		if (!IS_ALIGNED(sg->length, block_size) && !sg_is_last(sg))
+			return NO_DMA;
+
+		if (sg->offset % sizeof(u32))
+			return NO_DMA;
+
+		if (sg_is_last(sg) && !IS_ALIGNED(sg->length, AES_BLOCK_SIZE))
+			return DMA_NEED_SG_TRUNC;
+	}
+
+	return DMA_PLAIN_SG;
+}
+
+static enum stm32_dma_mode stm32_cryp_dma_check(struct stm32_cryp *cryp, struct scatterlist *in_sg,
+						struct scatterlist *out_sg)
+{
+	enum stm32_dma_mode ret = DMA_PLAIN_SG;
+
+	if (!is_aes(cryp))
+		return NO_DMA;
+
+	if (!cryp->dma_lch_in || !cryp->dma_lch_out)
+		return NO_DMA;
+
+	ret = stm32_cryp_dma_check_sg(in_sg, cryp->payload_in, AES_BLOCK_SIZE);
+	if (ret == NO_DMA)
+		return ret;
+
+	ret = stm32_cryp_dma_check_sg(out_sg, cryp->payload_out, AES_BLOCK_SIZE);
+	if (ret == NO_DMA)
+		return ret;
+
+	/* Check CTR counter overflow */
+	if (is_aes(cryp) && is_ctr(cryp)) {
+		u32 c;
+		__be32 iv3;
+
+		memcpy(&iv3, &cryp->req->iv[3*sizeof(u32)], sizeof(iv3));
+		c = be32_to_cpu(iv3);
+		if ((c + cryp->payload_in) < cryp->payload_in)
+			return NO_DMA;
+	}
+
+	/* Workaround */
+	if (is_aes(cryp) && is_ctr(cryp) && ret == DMA_NEED_SG_TRUNC)
+		return NO_DMA;
+
+	return ret;
+}
+
+static int stm32_cryp_truncate_sg(struct scatterlist **new_sg, int *new_sg_len,
+				  struct scatterlist *sg, off_t skip, size_t size)
+{
+	struct scatterlist *cur;
+	size_t alloc_sg_len;
+
+	*new_sg_len = 0;
+
+	if (!sg || !size) {
+		*new_sg = NULL;
+		return 0;
+	}
+
+	alloc_sg_len = sg_nents_for_len(sg, skip + size);
+	if (alloc_sg_len < 0)
+		return alloc_sg_len;
+
+	/* We allocate to much sg entry, but it is easier */
+	*new_sg = kmalloc_array(alloc_sg_len, sizeof(struct scatterlist), GFP_KERNEL);
+	if (!*new_sg)
+		return -ENOMEM;
+
+	sg_init_table(*new_sg, alloc_sg_len);
+
+	cur = *new_sg;
+	while (sg && size) {
+		unsigned int len = sg->length;
+		unsigned int offset = sg->offset;
+
+		if (skip > len) {
+			skip -= len;
+			sg = sg_next(sg);
+			continue;
+		}
+
+		if (skip) {
+			len -= skip;
+			offset += skip;
+			skip = 0;
+		}
+
+		if (size < len)
+			len = size;
+
+		if (len > 0) {
+			(*new_sg_len)++;
+			size -= len;
+			sg_set_page(cur, sg_page(sg), len, offset);
+			if (size == 0)
+				sg_mark_end(cur);
+			cur = sg_next(cur);
+		}
+
+		sg = sg_next(sg);
+	}
+
+	return 0;
+}
+
+static int stm32_cryp_cipher_prepare(struct stm32_cryp *cryp, struct scatterlist *in_sg,
+				     struct scatterlist *out_sg)
+{
+	size_t align_size;
+
+	cryp->dma_mode = stm32_cryp_dma_check(cryp, in_sg, out_sg);
+
+	scatterwalk_start(&cryp->in_walk, in_sg);
+	scatterwalk_start(&cryp->out_walk, out_sg);
+
+	if (cryp->dma_mode == NO_DMA) {
+		cryp->flags &= ~FLG_IN_OUT_DMA;
+
+		if (is_ctr(cryp))
+			memset(cryp->last_ctr, 0, sizeof(cryp->last_ctr));
+
+	} else if (cryp->dma_mode == DMA_NEED_SG_TRUNC) {
+		int ret;
+
+		cryp->flags |= FLG_IN_OUT_DMA;
+
+		align_size = ALIGN_DOWN(cryp->payload_in, cryp->hw_blocksize);
+		ret = stm32_cryp_truncate_sg(&cryp->in_sg, &cryp->in_sg_len, in_sg, 0, align_size);
+		if (ret)
+			return ret;
+
+		ret = stm32_cryp_truncate_sg(&cryp->out_sg, &cryp->out_sg_len, out_sg, 0,
+					     align_size);
+		if (ret) {
+			kfree(cryp->in_sg);
+			return ret;
+		}
+	} else {
+		cryp->flags |= FLG_IN_OUT_DMA;
+
+		cryp->in_sg = in_sg;
+		cryp->out_sg = out_sg;
+
+		cryp->in_sg_len = sg_nents_for_len(cryp->in_sg, cryp->payload_in);
+		if (cryp->in_sg_len < 0)
+			return cryp->in_sg_len;
+
+		cryp->out_sg_len = sg_nents_for_len(out_sg, cryp->payload_out);
+		if (cryp->out_sg_len < 0)
+			return cryp->out_sg_len;
+	}
+
+	return 0;
+}
+
+static int stm32_cryp_aead_prepare(struct stm32_cryp *cryp, struct scatterlist *in_sg,
+				   struct scatterlist *out_sg)
+{
+	size_t align_size;
+	off_t skip;
+	int ret, ret2;
+
+	cryp->header_sg = NULL;
+	cryp->in_sg = NULL;
+	cryp->out_sg = NULL;
+
+	if (!cryp->dma_lch_in || !cryp->dma_lch_out) {
+		cryp->dma_mode = NO_DMA;
+		cryp->flags &= ~(FLG_IN_OUT_DMA | FLG_HEADER_DMA);
+
+		return 0;
+	}
+
+	/* CCM hw_init may have advanced in header */
+	skip = cryp->areq->assoclen - cryp->header_in;
+
+	align_size = ALIGN_DOWN(cryp->header_in, cryp->hw_blocksize);
+	ret = stm32_cryp_truncate_sg(&cryp->header_sg, &cryp->header_sg_len, in_sg, skip,
+				     align_size);
+	if (ret)
+		return ret;
+
+	ret = stm32_cryp_dma_check_sg(cryp->header_sg, align_size, AES_BLOCK_SIZE);
+	if (ret == NO_DMA) {
+		/* We cannot DMA the header */
+		kfree(cryp->header_sg);
+		cryp->header_sg = NULL;
+
+		cryp->flags &= ~FLG_HEADER_DMA;
+	} else {
+		cryp->flags |= FLG_HEADER_DMA;
+	}
+
+	/* Now skip all header to be at payload start */
+	skip = cryp->areq->assoclen;
+	align_size = ALIGN_DOWN(cryp->payload_in, cryp->hw_blocksize);
+	ret = stm32_cryp_truncate_sg(&cryp->in_sg, &cryp->in_sg_len, in_sg, skip, align_size);
+	if (ret) {
+		kfree(cryp->header_sg);
+		return ret;
+	}
+
+	/* For out buffer align_size is same as in buffer */
+	ret = stm32_cryp_truncate_sg(&cryp->out_sg, &cryp->out_sg_len, out_sg, skip, align_size);
+	if (ret) {
+		kfree(cryp->header_sg);
+		kfree(cryp->in_sg);
+		return ret;
+	}
+
+	ret = stm32_cryp_dma_check_sg(cryp->in_sg, align_size, AES_BLOCK_SIZE);
+	ret2 = stm32_cryp_dma_check_sg(cryp->out_sg, align_size, AES_BLOCK_SIZE);
+	if (ret == NO_DMA || ret2 == NO_DMA) {
+		kfree(cryp->in_sg);
+		cryp->in_sg = NULL;
+
+		kfree(cryp->out_sg);
+		cryp->out_sg = NULL;
+
+		cryp->flags &= ~FLG_IN_OUT_DMA;
+	} else {
+		cryp->flags |= FLG_IN_OUT_DMA;
+	}
+
+	return 0;
+}
+
 static int stm32_cryp_prepare_req(struct skcipher_request *req,
 				  struct aead_request *areq)
 {
 	struct stm32_cryp_ctx *ctx;
 	struct stm32_cryp *cryp;
 	struct stm32_cryp_reqctx *rctx;
-	struct scatterlist *in_sg;
+	struct scatterlist *in_sg, *out_sg;
 	int ret;
 
 	if (!req && !areq)
@@ -1016,6 +1541,15 @@ static int stm32_cryp_prepare_req(struct skcipher_request *req,
 		cryp->payload_in = req->cryptlen;
 		cryp->payload_out = req->cryptlen;
 		cryp->authsize = 0;
+
+		in_sg = req->src;
+		out_sg = req->dst;
+
+		ret = stm32_cryp_cipher_prepare(cryp, in_sg, out_sg);
+		if (ret)
+			return ret;
+
+		ret = stm32_cryp_hw_init(cryp);
 	} else {
 		/*
 		 * Length of input and output data:
@@ -1045,23 +1579,22 @@ static int stm32_cryp_prepare_req(struct skcipher_request *req,
 			cryp->header_in = areq->assoclen;
 			cryp->payload_out = cryp->payload_in;
 		}
-	}
 
-	in_sg = req ? req->src : areq->src;
-	scatterwalk_start(&cryp->in_walk, in_sg);
-
-	cryp->out_sg = req ? req->dst : areq->dst;
-	scatterwalk_start(&cryp->out_walk, cryp->out_sg);
+		in_sg = areq->src;
+		out_sg = areq->dst;
 
-	if (is_gcm(cryp) || is_ccm(cryp)) {
+		scatterwalk_start(&cryp->in_walk, in_sg);
+		scatterwalk_start(&cryp->out_walk, out_sg);
 		/* In output, jump after assoc data */
 		scatterwalk_copychunks(NULL, &cryp->out_walk, cryp->areq->assoclen, 2);
-	}
 
-	if (is_ctr(cryp))
-		memset(cryp->last_ctr, 0, sizeof(cryp->last_ctr));
+		ret = stm32_cryp_hw_init(cryp);
+		if (ret)
+			return ret;
+
+		ret = stm32_cryp_aead_prepare(cryp, in_sg, out_sg);
+	}
 
-	ret = stm32_cryp_hw_init(cryp);
 	return ret;
 }
 
@@ -1087,7 +1620,10 @@ static int stm32_cryp_cipher_one_req(struct crypto_engine *engine, void *areq)
 	if (!cryp)
 		return -ENODEV;
 
-	return stm32_cryp_cpu_start(cryp);
+	if (cryp->flags & FLG_IN_OUT_DMA)
+		return stm32_cryp_dma_start(cryp);
+	else
+		return stm32_cryp_it_start(cryp);
 }
 
 static int stm32_cryp_prepare_aead_req(struct crypto_engine *engine, void *areq)
@@ -1108,13 +1644,20 @@ static int stm32_cryp_aead_one_req(struct crypto_engine *engine, void *areq)
 	if (!cryp)
 		return -ENODEV;
 
-	if (unlikely(!cryp->payload_in && !cryp->header_in)) {
+	if (!stm32_cryp_get_input_text_len(cryp) && !cryp->header_in &&
+	    !(cryp->flags & FLG_HEADER_DMA)) {
 		/* No input data to process: get tag and finish */
 		stm32_cryp_finish_req(cryp, 0);
 		return 0;
 	}
 
-	return stm32_cryp_cpu_start(cryp);
+	if (cryp->flags & FLG_HEADER_DMA)
+		return stm32_cryp_header_dma_start(cryp);
+
+	if (!cryp->header_in && cryp->flags & FLG_IN_OUT_DMA)
+		return stm32_cryp_dma_start(cryp);
+
+	return stm32_cryp_it_start(cryp);
 }
 
 static int stm32_cryp_read_auth_tag(struct stm32_cryp *cryp)
@@ -1540,11 +2083,70 @@ static irqreturn_t stm32_cryp_irq(int irq, void *arg)
 	return IRQ_WAKE_THREAD;
 }
 
+static int stm32_cryp_dma_init(struct stm32_cryp *cryp)
+{
+	struct dma_slave_config dma_conf;
+	struct dma_chan *chan;
+	int err;
+
+	memset(&dma_conf, 0, sizeof(dma_conf));
+
+	dma_conf.direction = DMA_MEM_TO_DEV;
+	dma_conf.dst_addr = cryp->phys_base + CRYP_DIN;
+	dma_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	dma_conf.src_maxburst = CRYP_DMA_BURST_MEM;
+	dma_conf.dst_maxburst = CRYP_DMA_BURST_REG;
+	dma_conf.device_fc = false;
+
+	chan = dma_request_chan(cryp->dev, "in");
+	if (IS_ERR(chan))
+		return PTR_ERR(chan);
+
+	cryp->dma_lch_in = chan;
+	err = dmaengine_slave_config(cryp->dma_lch_in, &dma_conf);
+	if (err) {
+		dma_release_channel(cryp->dma_lch_in);
+		cryp->dma_lch_in = NULL;
+		dev_err(cryp->dev, "Couldn't configure DMA in slave.\n");
+		return err;
+	}
+
+	memset(&dma_conf, 0, sizeof(dma_conf));
+
+	dma_conf.direction = DMA_DEV_TO_MEM;
+	dma_conf.src_addr = cryp->phys_base + CRYP_DOUT;
+	dma_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	dma_conf.src_maxburst = CRYP_DMA_BURST_REG;
+	dma_conf.dst_maxburst = CRYP_DMA_BURST_MEM;
+	dma_conf.device_fc = false;
+
+	chan = dma_request_chan(cryp->dev, "out");
+	if (IS_ERR(chan)) {
+		dma_release_channel(cryp->dma_lch_in);
+		cryp->dma_lch_in = NULL;
+		return PTR_ERR(chan);
+	}
+
+	cryp->dma_lch_out = chan;
+
+	err = dmaengine_slave_config(cryp->dma_lch_out, &dma_conf);
+	if (err) {
+		dma_release_channel(cryp->dma_lch_out);
+		cryp->dma_lch_out = NULL;
+		dev_err(cryp->dev, "Couldn't configure DMA out slave.\n");
+		dma_release_channel(cryp->dma_lch_in);
+		cryp->dma_lch_in = NULL;
+		return err;
+	}
+
+	return 0;
+}
+
 static struct skcipher_alg crypto_algs[] = {
 {
 	.base.cra_name		= "ecb(aes)",
 	.base.cra_driver_name	= "stm32-ecb-aes",
-	.base.cra_priority	= 200,
+	.base.cra_priority	= 1200,
 	.base.cra_flags		= CRYPTO_ALG_ASYNC,
 	.base.cra_blocksize	= AES_BLOCK_SIZE,
 	.base.cra_ctxsize	= sizeof(struct stm32_cryp_ctx),
@@ -1561,7 +2163,7 @@ static struct skcipher_alg crypto_algs[] = {
 {
 	.base.cra_name		= "cbc(aes)",
 	.base.cra_driver_name	= "stm32-cbc-aes",
-	.base.cra_priority	= 200,
+	.base.cra_priority	= 1200,
 	.base.cra_flags		= CRYPTO_ALG_ASYNC,
 	.base.cra_blocksize	= AES_BLOCK_SIZE,
 	.base.cra_ctxsize	= sizeof(struct stm32_cryp_ctx),
@@ -1579,7 +2181,7 @@ static struct skcipher_alg crypto_algs[] = {
 {
 	.base.cra_name		= "ctr(aes)",
 	.base.cra_driver_name	= "stm32-ctr-aes",
-	.base.cra_priority	= 200,
+	.base.cra_priority	= 1200,
 	.base.cra_flags		= CRYPTO_ALG_ASYNC,
 	.base.cra_blocksize	= 1,
 	.base.cra_ctxsize	= sizeof(struct stm32_cryp_ctx),
@@ -1597,7 +2199,7 @@ static struct skcipher_alg crypto_algs[] = {
 {
 	.base.cra_name		= "ecb(des)",
 	.base.cra_driver_name	= "stm32-ecb-des",
-	.base.cra_priority	= 200,
+	.base.cra_priority	= 1200,
 	.base.cra_flags		= CRYPTO_ALG_ASYNC,
 	.base.cra_blocksize	= DES_BLOCK_SIZE,
 	.base.cra_ctxsize	= sizeof(struct stm32_cryp_ctx),
@@ -1614,7 +2216,7 @@ static struct skcipher_alg crypto_algs[] = {
 {
 	.base.cra_name		= "cbc(des)",
 	.base.cra_driver_name	= "stm32-cbc-des",
-	.base.cra_priority	= 200,
+	.base.cra_priority	= 1200,
 	.base.cra_flags		= CRYPTO_ALG_ASYNC,
 	.base.cra_blocksize	= DES_BLOCK_SIZE,
 	.base.cra_ctxsize	= sizeof(struct stm32_cryp_ctx),
@@ -1632,7 +2234,7 @@ static struct skcipher_alg crypto_algs[] = {
 {
 	.base.cra_name		= "ecb(des3_ede)",
 	.base.cra_driver_name	= "stm32-ecb-des3",
-	.base.cra_priority	= 200,
+	.base.cra_priority	= 1200,
 	.base.cra_flags		= CRYPTO_ALG_ASYNC,
 	.base.cra_blocksize	= DES_BLOCK_SIZE,
 	.base.cra_ctxsize	= sizeof(struct stm32_cryp_ctx),
@@ -1649,7 +2251,7 @@ static struct skcipher_alg crypto_algs[] = {
 {
 	.base.cra_name		= "cbc(des3_ede)",
 	.base.cra_driver_name	= "stm32-cbc-des3",
-	.base.cra_priority	= 200,
+	.base.cra_priority	= 1200,
 	.base.cra_flags		= CRYPTO_ALG_ASYNC,
 	.base.cra_blocksize	= DES_BLOCK_SIZE,
 	.base.cra_ctxsize	= sizeof(struct stm32_cryp_ctx),
@@ -1726,6 +2328,25 @@ static const struct of_device_id stm32_dt_ids[] = {
 };
 MODULE_DEVICE_TABLE(of, stm32_dt_ids);
 
+static void cryp_debugfs(struct stm32_cryp *cryp)
+{
+	struct debugfs_regset32 *regset;
+
+	cryp->dbgdir = debugfs_create_dir("stm32_cryp", NULL);
+	if (IS_ERR_OR_NULL(cryp->dbgdir))
+		return;
+
+	regset = devm_kzalloc(cryp->dev, sizeof(*regset), GFP_KERNEL);
+	if (!regset)
+		return;
+
+	regset->regs = stm32_cryp_regs;
+	regset->nregs = ARRAY_SIZE(stm32_cryp_regs);
+	regset->base = cryp->regs;
+
+	debugfs_create_regset32("regset", 0444, cryp->dbgdir, regset);
+}
+
 static int stm32_cryp_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -1747,6 +2368,8 @@ static int stm32_cryp_probe(struct platform_device *pdev)
 	if (IS_ERR(cryp->regs))
 		return PTR_ERR(cryp->regs);
 
+	cryp->phys_base = platform_get_resource(pdev, IORESOURCE_MEM, 0)->start;
+
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
 		return irq;
@@ -1761,7 +2384,8 @@ static int stm32_cryp_probe(struct platform_device *pdev)
 
 	cryp->clk = devm_clk_get(dev, NULL);
 	if (IS_ERR(cryp->clk)) {
-		dev_err(dev, "Could not get clock\n");
+		dev_err_probe(dev, PTR_ERR(cryp->clk), "Could not get clock\n");
+
 		return PTR_ERR(cryp->clk);
 	}
 
@@ -1779,7 +2403,11 @@ static int stm32_cryp_probe(struct platform_device *pdev)
 	pm_runtime_enable(dev);
 
 	rst = devm_reset_control_get(dev, NULL);
-	if (!IS_ERR(rst)) {
+	if (IS_ERR(rst)) {
+		ret = PTR_ERR(rst);
+		if (ret == -EPROBE_DEFER)
+			goto err_rst;
+	} else {
 		reset_control_assert(rst);
 		udelay(2);
 		reset_control_deassert(rst);
@@ -1787,6 +2415,17 @@ static int stm32_cryp_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, cryp);
 
+	ret = stm32_cryp_dma_init(cryp);
+	switch (ret) {
+	case 0:
+		break;
+	case -ENODEV:
+		dev_dbg(dev, "DMA mode not available\n");
+		break;
+	default:
+		goto err_dma;
+	}
+
 	spin_lock(&cryp_list.lock);
 	list_add(&cryp->list, &cryp_list.dev_list);
 	spin_unlock(&cryp_list.lock);
@@ -1815,6 +2454,7 @@ static int stm32_cryp_probe(struct platform_device *pdev)
 	if (ret)
 		goto err_aead_algs;
 
+	cryp_debugfs(cryp);
 	dev_info(dev, "Initialized\n");
 
 	pm_runtime_put_sync(dev);
@@ -1831,6 +2471,12 @@ static int stm32_cryp_probe(struct platform_device *pdev)
 	list_del(&cryp->list);
 	spin_unlock(&cryp_list.lock);
 
+	if (cryp->dma_lch_in)
+		dma_release_channel(cryp->dma_lch_in);
+	if (cryp->dma_lch_out)
+		dma_release_channel(cryp->dma_lch_out);
+err_dma:
+err_rst:
 	pm_runtime_disable(dev);
 	pm_runtime_put_noidle(dev);
 
@@ -1851,6 +2497,9 @@ static int stm32_cryp_remove(struct platform_device *pdev)
 	if (ret < 0)
 		return ret;
 
+	debugfs_remove_recursive(cryp->dbgdir);
+	cryp->dbgdir = NULL;
+
 	crypto_unregister_aeads(aead_algs, ARRAY_SIZE(aead_algs));
 	crypto_unregister_skciphers(crypto_algs, ARRAY_SIZE(crypto_algs));
 
@@ -1860,6 +2509,12 @@ static int stm32_cryp_remove(struct platform_device *pdev)
 	list_del(&cryp->list);
 	spin_unlock(&cryp_list.lock);
 
+	if (cryp->dma_lch_in)
+		dma_release_channel(cryp->dma_lch_in);
+
+	if (cryp->dma_lch_out)
+		dma_release_channel(cryp->dma_lch_out);
+
 	pm_runtime_disable(cryp->dev);
 	pm_runtime_put_noidle(cryp->dev);
 
diff --git a/drivers/crypto/stm32/stm32-hash.c b/drivers/crypto/stm32/stm32-hash.c
index d33006d43..05efad85d 100644
--- a/drivers/crypto/stm32/stm32-hash.c
+++ b/drivers/crypto/stm32/stm32-hash.c
@@ -27,6 +27,7 @@
 #include <crypto/scatterwalk.h>
 #include <crypto/sha1.h>
 #include <crypto/sha2.h>
+#include <crypto/sha3.h>
 #include <crypto/internal/hash.h>
 
 #define HASH_CR				0x00
@@ -49,11 +50,6 @@
 #define HASH_CR_DMAA			BIT(14)
 #define HASH_CR_LKEY			BIT(16)
 
-#define HASH_CR_ALGO_SHA1		0x0
-#define HASH_CR_ALGO_MD5		0x80
-#define HASH_CR_ALGO_SHA224		0x40000
-#define HASH_CR_ALGO_SHA256		0x40080
-
 /* Interrupt */
 #define HASH_DINIE			BIT(0)
 #define HASH_DCIE			BIT(1)
@@ -62,9 +58,6 @@
 #define HASH_MASK_CALC_COMPLETION	BIT(0)
 #define HASH_MASK_DATA_INPUT		BIT(1)
 
-/* Context swap register */
-#define HASH_CSR_REGISTER_NUMBER	53
-
 /* Status Flags */
 #define HASH_SR_DATA_INPUT_READY	BIT(0)
 #define HASH_SR_OUTPUT_READY		BIT(1)
@@ -75,6 +68,18 @@
 #define HASH_STR_NBLW_MASK		GENMASK(4, 0)
 #define HASH_STR_DCAL			BIT(8)
 
+/* HWCFGR Register */
+#define HASH_HWCFG_DMA_MASK		GENMASK(3, 0)
+
+/* CSR register */
+#define HASH_CSR_NB_SHA256_HMAC		54
+#define HASH_CSR_NB_SHA256		22
+#define HASH_CSR_NB_SHA512_HMAC		103
+#define HASH_CSR_NB_SHA512		91
+#define HASH_CSR_NB_SHA3_HMAC		88
+#define HASH_CSR_NB_SHA3		72
+#define HASH_CSR_NB_MAX			HASH_CSR_NB_SHA512_HMAC
+
 #define HASH_FLAGS_INIT			BIT(0)
 #define HASH_FLAGS_OUTPUT_READY		BIT(1)
 #define HASH_FLAGS_CPU			BIT(2)
@@ -83,20 +88,19 @@
 #define HASH_FLAGS_HMAC_INIT		BIT(5)
 #define HASH_FLAGS_HMAC_FINAL		BIT(6)
 #define HASH_FLAGS_HMAC_KEY		BIT(7)
-
+#define HASH_FLAGS_SHA3_MODE		BIT(8)
 #define HASH_FLAGS_FINAL		BIT(15)
 #define HASH_FLAGS_FINUP		BIT(16)
-#define HASH_FLAGS_ALGO_MASK		GENMASK(21, 18)
-#define HASH_FLAGS_MD5			BIT(18)
-#define HASH_FLAGS_SHA1			BIT(19)
-#define HASH_FLAGS_SHA224		BIT(20)
-#define HASH_FLAGS_SHA256		BIT(21)
-#define HASH_FLAGS_ERRORS		BIT(22)
-#define HASH_FLAGS_HMAC			BIT(23)
+#define HASH_FLAGS_ALGO_MASK		GENMASK(20, 17)
+#define HASH_FLAGS_ALGO_SHIFT		17
+#define HASH_FLAGS_ERRORS		BIT(21)
+#define HASH_FLAGS_HMAC			BIT(22)
 
 #define HASH_OP_UPDATE			1
 #define HASH_OP_FINAL			2
 
+#define HASH_BURST_LEVEL		4
+
 enum stm32_hash_data_format {
 	HASH_DATA_32_BITS		= 0x0,
 	HASH_DATA_16_BITS		= 0x1,
@@ -104,49 +108,63 @@ enum stm32_hash_data_format {
 	HASH_DATA_1_BIT			= 0x3
 };
 
-#define HASH_BUFLEN			256
-#define HASH_LONG_KEY			64
-#define HASH_MAX_KEY_SIZE		(SHA256_BLOCK_SIZE * 8)
-#define HASH_QUEUE_LENGTH		16
-#define HASH_DMA_THRESHOLD		50
+enum stm32_hash_algo {
+	HASH_SHA1			= 0,
+	HASH_MD5			= 1,
+	HASH_SHA224			= 2,
+	HASH_SHA256			= 3,
+	HASH_SHA3_224			= 4,
+	HASH_SHA3_256			= 5,
+	HASH_SHA3_384			= 6,
+	HASH_SHA3_512			= 7,
+	HASH_SHA384			= 12,
+	HASH_SHA512			= 15,
+};
+
+#define HASH_HW_FIFO_INIT_SIZE		(17 * sizeof(u32))
+#define HASH_HW_FIFO_SIZE		(16 * sizeof(u32))
 
+#define HASH_MAX_KEY_SIZE		(SHA512_BLOCK_SIZE * 8)
+#define HASH_QUEUE_LENGTH		60
 #define HASH_AUTOSUSPEND_DELAY		50
 
 struct stm32_hash_ctx {
 	struct crypto_engine_ctx enginectx;
-	struct stm32_hash_dev	*hdev;
 	unsigned long		flags;
 
 	u8			key[HASH_MAX_KEY_SIZE];
 	int			keylen;
 };
 
-struct stm32_hash_request_ctx {
+struct stm32_hash_state {
 	struct stm32_hash_dev	*hdev;
 	unsigned long		flags;
-	unsigned long		op;
 
-	u8 digest[SHA256_DIGEST_SIZE] __aligned(sizeof(u32));
-	size_t			digcnt;
+	/* Data not yet sent to hw */
+	u8 buffer[HASH_HW_FIFO_INIT_SIZE] __aligned(sizeof(u32));
 	size_t			bufcnt;
 	size_t			buflen;
 
+	/* HW Context */
+	u32			hw_context[3 + HASH_CSR_NB_MAX];
+};
+
+struct stm32_hash_request_ctx {
+	struct stm32_hash_state	state;
+
+	/*
+	 * Each new request will update following fields
+	 */
+	unsigned long		op;
+
 	/* DMA */
 	struct scatterlist	*sg;
 	unsigned int		offset;
 	unsigned int		total;
 	struct scatterlist	sg_key;
 
-	dma_addr_t		dma_addr;
 	size_t			dma_ct;
 	int			nents;
-
-	u8			data_type;
-
-	u8 buffer[HASH_BUFLEN] __aligned(sizeof(u32));
-
-	/* Export Context */
-	u32			*hw_context;
 };
 
 struct stm32_hash_algs_info {
@@ -155,8 +173,9 @@ struct stm32_hash_algs_info {
 };
 
 struct stm32_hash_pdata {
-	struct stm32_hash_algs_info	*algs_info;
-	size_t				algs_info_size;
+	const int				alg_shift;
+	const struct stm32_hash_algs_info	*algs_info;
+	size_t					algs_info_size;
 };
 
 struct stm32_hash_dev {
@@ -167,10 +186,10 @@ struct stm32_hash_dev {
 	void __iomem		*io_base;
 	phys_addr_t		phys_base;
 	u32			dma_mode;
-	u32			dma_maxburst;
 
 	struct ahash_request	*req;
 	struct crypto_engine	*engine;
+	struct crypto_queue	queue;
 
 	int			err;
 	unsigned long		flags;
@@ -212,11 +231,107 @@ static inline int stm32_hash_wait_busy(struct stm32_hash_dev *hdev)
 				   !(status & HASH_SR_BUSY), 10, 10000);
 }
 
-static void stm32_hash_set_nblw(struct stm32_hash_dev *hdev, int length)
+static inline int stm32_hash_wait_dinis(struct stm32_hash_dev *hdev)
+{
+	u32 status;
+
+	return readl_relaxed_poll_timeout(hdev->io_base + HASH_SR, status,
+				   (status & HASH_SR_DATA_INPUT_READY), 10, 10000);
+}
+
+static int hash_swap_reg(struct stm32_hash_request_ctx *rctx)
 {
+	switch ((rctx->state.flags & HASH_FLAGS_ALGO_MASK) >> HASH_FLAGS_ALGO_SHIFT) {
+	case HASH_MD5:
+	case HASH_SHA1:
+	case HASH_SHA224:
+	case HASH_SHA256:
+		if (rctx->state.flags & HASH_FLAGS_HMAC)
+			return HASH_CSR_NB_SHA256_HMAC;
+		else
+			return HASH_CSR_NB_SHA256;
+		break;
+
+	case HASH_SHA384:
+	case HASH_SHA512:
+		if (rctx->state.flags & HASH_FLAGS_HMAC)
+			return HASH_CSR_NB_SHA512_HMAC;
+		else
+			return HASH_CSR_NB_SHA512;
+		break;
+
+	case HASH_SHA3_224:
+	case HASH_SHA3_256:
+	case HASH_SHA3_384:
+	case HASH_SHA3_512:
+		if (rctx->state.flags & HASH_FLAGS_HMAC)
+			return HASH_CSR_NB_SHA3_HMAC;
+		else
+			return HASH_CSR_NB_SHA3;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static int stm32_hash_save_hw_context(struct stm32_hash_dev *hdev)
+{
+	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(hdev->req);
+	u32 *preg;
+	unsigned int i;
+	int swap_reg;
+
+	swap_reg = hash_swap_reg(rctx);
+	if (swap_reg < 0)
+		return swap_reg;
+
+	if (stm32_hash_wait_busy(hdev))
+		return -ETIMEDOUT;
+
+	preg = rctx->state.hw_context;
+
+	*preg++ = stm32_hash_read(hdev, HASH_IMR);
+	*preg++ = stm32_hash_read(hdev, HASH_STR);
+	*preg++ = stm32_hash_read(hdev, HASH_CR);
+	for (i = 0; i < swap_reg; i++)
+		*preg++ = stm32_hash_read(hdev, HASH_CSR(i));
+
+	return 0;
+}
+
+static int stm32_hash_restore_hw_context(struct stm32_hash_dev *hdev)
+{
+	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(hdev->req);
+	u32 *preg;
 	u32 reg;
+	unsigned int i;
+	int swap_reg;
+
+	swap_reg = hash_swap_reg(rctx);
+	if (swap_reg < 0)
+		return swap_reg;
+
+	if (stm32_hash_wait_busy(hdev))
+		return -ETIMEDOUT;
+
+	preg = rctx->state.hw_context;
+
+	stm32_hash_write(hdev, HASH_IMR, *preg++);
+	stm32_hash_write(hdev, HASH_STR, *preg++);
+	reg = *preg++ | HASH_CR_INIT;
+	stm32_hash_write(hdev, HASH_CR, reg);
+
+	for (i = 0; i < swap_reg; i++)
+		stm32_hash_write(hdev, HASH_CSR(i), *preg++);
+
+	return 0;
+}
+
+static void stm32_hash_set_nblw(struct stm32_hash_dev *hdev, int length)
+{
+	u32 reg = stm32_hash_read(hdev, HASH_STR);
 
-	reg = stm32_hash_read(hdev, HASH_STR);
 	reg &= ~(HASH_STR_NBLW_MASK);
 	reg |= (8U * ((length) % 4U));
 	stm32_hash_write(hdev, HASH_STR, reg);
@@ -254,53 +369,44 @@ static void stm32_hash_write_ctrl(struct stm32_hash_dev *hdev)
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(hdev->req);
 	struct crypto_ahash *tfm = crypto_ahash_reqtfm(hdev->req);
 	struct stm32_hash_ctx *ctx = crypto_ahash_ctx(tfm);
-
+	u32 alg = (rctx->state.flags & HASH_FLAGS_ALGO_MASK) >> HASH_FLAGS_ALGO_SHIFT;
 	u32 reg = HASH_CR_INIT;
 
-	if (!(hdev->flags & HASH_FLAGS_INIT)) {
-		switch (rctx->flags & HASH_FLAGS_ALGO_MASK) {
-		case HASH_FLAGS_MD5:
-			reg |= HASH_CR_ALGO_MD5;
-			break;
-		case HASH_FLAGS_SHA1:
-			reg |= HASH_CR_ALGO_SHA1;
-			break;
-		case HASH_FLAGS_SHA224:
-			reg |= HASH_CR_ALGO_SHA224;
-			break;
-		case HASH_FLAGS_SHA256:
-			reg |= HASH_CR_ALGO_SHA256;
-			break;
-		default:
-			reg |= HASH_CR_ALGO_MD5;
-		}
+	if (hdev->pdata->alg_shift == 7)
+		reg |= ((alg & BIT(1)) << 17) | ((alg & BIT(0)) << 7);
+	else
+		reg |= alg << hdev->pdata->alg_shift;
 
-		reg |= (rctx->data_type << HASH_CR_DATATYPE_POS);
+	reg |= (HASH_DATA_8_BITS << HASH_CR_DATATYPE_POS);
 
-		if (rctx->flags & HASH_FLAGS_HMAC) {
-			hdev->flags |= HASH_FLAGS_HMAC;
-			reg |= HASH_CR_MODE;
-			if (ctx->keylen > HASH_LONG_KEY)
-				reg |= HASH_CR_LKEY;
-		}
+	if (rctx->state.flags & HASH_FLAGS_HMAC) {
+		hdev->flags |= HASH_FLAGS_HMAC;
+		reg |= HASH_CR_MODE;
+		if (ctx->keylen > crypto_ahash_blocksize(tfm))
+			reg |= HASH_CR_LKEY;
+	}
 
-		stm32_hash_write(hdev, HASH_IMR, HASH_DCIE);
+	stm32_hash_write(hdev, HASH_IMR, HASH_DCIE);
+	stm32_hash_write(hdev, HASH_CR, reg);
+	stm32_hash_read(hdev, HASH_SR);
 
-		stm32_hash_write(hdev, HASH_CR, reg);
+	rctx->state.flags |= HASH_FLAGS_INIT;
 
-		hdev->flags |= HASH_FLAGS_INIT;
+	dev_dbg(hdev->dev, "Write Control %x\n", reg);
 
-		dev_dbg(hdev->dev, "Write Control %x\n", reg);
-	}
+	/*
+	 * After first buflen is fill up, the new buflen is smaller of one u32
+	 */
+	rctx->state.buflen = HASH_HW_FIFO_SIZE;
 }
 
 static void stm32_hash_append_sg(struct stm32_hash_request_ctx *rctx)
 {
 	size_t count;
 
-	while ((rctx->bufcnt < rctx->buflen) && rctx->total) {
+	while ((rctx->state.bufcnt < rctx->state.buflen) && rctx->total) {
 		count = min(rctx->sg->length - rctx->offset, rctx->total);
-		count = min(count, rctx->buflen - rctx->bufcnt);
+		count = min(count, rctx->state.buflen - rctx->state.bufcnt);
 
 		if (count <= 0) {
 			if ((rctx->sg->length == 0) && !sg_is_last(rctx->sg)) {
@@ -311,10 +417,10 @@ static void stm32_hash_append_sg(struct stm32_hash_request_ctx *rctx)
 			}
 		}
 
-		scatterwalk_map_and_copy(rctx->buffer + rctx->bufcnt, rctx->sg,
+		scatterwalk_map_and_copy(rctx->state.buffer + rctx->state.bufcnt, rctx->sg,
 					 rctx->offset, count, 0);
 
-		rctx->bufcnt += count;
+		rctx->state.bufcnt += count;
 		rctx->offset += count;
 		rctx->total -= count;
 
@@ -328,11 +434,12 @@ static void stm32_hash_append_sg(struct stm32_hash_request_ctx *rctx)
 	}
 }
 
-static int stm32_hash_xmit_cpu(struct stm32_hash_dev *hdev,
-			       const u8 *buf, size_t length, int final)
+static int stm32_hash_xmit_cpu(struct stm32_hash_request_ctx *rctx,
+			       size_t length, int final)
 {
+	const u32 *buffer = (const u32 *)rctx->state.buffer;
+	struct stm32_hash_dev *hdev = rctx->state.hdev;
 	unsigned int count, len32;
-	const u32 *buffer = (const u32 *)buf;
 	u32 reg;
 
 	if (final)
@@ -345,10 +452,8 @@ static int stm32_hash_xmit_cpu(struct stm32_hash_dev *hdev,
 
 	hdev->flags |= HASH_FLAGS_CPU;
 
-	stm32_hash_write_ctrl(hdev);
-
-	if (stm32_hash_wait_busy(hdev))
-		return -ETIMEDOUT;
+	if (!(rctx->state.flags & HASH_FLAGS_INIT))
+		stm32_hash_write_ctrl(hdev);
 
 	if ((hdev->flags & HASH_FLAGS_HMAC) &&
 	    (!(hdev->flags & HASH_FLAGS_HMAC_KEY))) {
@@ -371,6 +476,7 @@ static int stm32_hash_xmit_cpu(struct stm32_hash_dev *hdev,
 				return -ETIMEDOUT;
 			stm32_hash_write_key(hdev);
 		}
+
 		return -EINPROGRESS;
 	}
 
@@ -382,28 +488,30 @@ static int stm32_hash_update_cpu(struct stm32_hash_dev *hdev)
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(hdev->req);
 	int bufcnt, err = 0, final;
 
-	dev_dbg(hdev->dev, "%s flags %lx\n", __func__, rctx->flags);
+	dev_dbg(hdev->dev, "%s flags %lx\n", __func__, rctx->state.flags);
 
-	final = (rctx->flags & HASH_FLAGS_FINUP);
+	final = (rctx->state.flags & HASH_FLAGS_FINUP);
 
-	while ((rctx->total >= rctx->buflen) ||
-	       (rctx->bufcnt + rctx->total >= rctx->buflen)) {
+	while ((rctx->total > rctx->state.buflen) ||
+	       (rctx->state.bufcnt + rctx->total > rctx->state.buflen)) {
 		stm32_hash_append_sg(rctx);
-		bufcnt = rctx->bufcnt;
-		rctx->bufcnt = 0;
-		err = stm32_hash_xmit_cpu(hdev, rctx->buffer, bufcnt, 0);
+		bufcnt = rctx->state.bufcnt;
+		rctx->state.bufcnt = 0;
+		err = stm32_hash_xmit_cpu(rctx, bufcnt, 0);
 	}
 
 	stm32_hash_append_sg(rctx);
 
 	if (final) {
-		bufcnt = rctx->bufcnt;
-		rctx->bufcnt = 0;
-		err = stm32_hash_xmit_cpu(hdev, rctx->buffer, bufcnt,
-					  (rctx->flags & HASH_FLAGS_FINUP));
+		bufcnt = rctx->state.bufcnt;
+		rctx->state.bufcnt = 0;
+		err = stm32_hash_xmit_cpu(rctx, bufcnt,
+					  (rctx->state.flags & HASH_FLAGS_FINUP));
 	}
+	if (err)
+		return err;
 
-	return err;
+	return stm32_hash_save_hw_context(hdev);
 }
 
 static int stm32_hash_xmit_dma(struct stm32_hash_dev *hdev,
@@ -482,7 +590,7 @@ static int stm32_hash_hmac_dma_send(struct stm32_hash_dev *hdev)
 	struct stm32_hash_ctx *ctx = crypto_ahash_ctx(tfm);
 	int err;
 
-	if (ctx->keylen < HASH_DMA_THRESHOLD || (hdev->dma_mode == 1)) {
+	if (ctx->keylen < rctx->state.buflen || (hdev->dma_mode == 1)) {
 		err = stm32_hash_write_key(hdev);
 		if (stm32_hash_wait_busy(hdev))
 			return -ETIMEDOUT;
@@ -517,8 +625,8 @@ static int stm32_hash_dma_init(struct stm32_hash_dev *hdev)
 	dma_conf.direction = DMA_MEM_TO_DEV;
 	dma_conf.dst_addr = hdev->phys_base + HASH_DIN;
 	dma_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	dma_conf.src_maxburst = hdev->dma_maxburst;
-	dma_conf.dst_maxburst = hdev->dma_maxburst;
+	dma_conf.src_maxburst = HASH_BURST_LEVEL;
+	dma_conf.dst_maxburst = HASH_BURST_LEVEL;
 	dma_conf.device_fc = false;
 
 	chan = dma_request_chan(hdev->dev, "in");
@@ -546,17 +654,17 @@ static int stm32_hash_dma_send(struct stm32_hash_dev *hdev)
 	struct scatterlist sg[1], *tsg;
 	int err = 0, len = 0, reg, ncp = 0;
 	unsigned int i;
-	u32 *buffer = (void *)rctx->buffer;
+	u32 *buffer = (void *)rctx->state.buffer;
 
 	rctx->sg = hdev->req->src;
 	rctx->total = hdev->req->nbytes;
 
 	rctx->nents = sg_nents(rctx->sg);
-
 	if (rctx->nents < 0)
 		return -EINVAL;
 
-	stm32_hash_write_ctrl(hdev);
+	if (!(rctx->state.flags & HASH_FLAGS_INIT))
+		stm32_hash_write_ctrl(hdev);
 
 	if (hdev->flags & HASH_FLAGS_HMAC) {
 		err = stm32_hash_hmac_dma_send(hdev);
@@ -565,16 +673,16 @@ static int stm32_hash_dma_send(struct stm32_hash_dev *hdev)
 	}
 
 	for_each_sg(rctx->sg, tsg, rctx->nents, i) {
-		len = sg->length;
-
 		sg[0] = *tsg;
+
+		len = sg->length;
 		if (sg_is_last(sg)) {
 			if (hdev->dma_mode == 1) {
 				len = (ALIGN(sg->length, 16) - 16);
 
 				ncp = sg_pcopy_to_buffer(
 					rctx->sg, rctx->nents,
-					rctx->buffer, sg->length - len,
+					rctx->state.buffer, sg->length - len,
 					rctx->total - sg->length + len);
 
 				sg->length = len;
@@ -633,21 +741,17 @@ static int stm32_hash_dma_send(struct stm32_hash_dev *hdev)
 	return err;
 }
 
-static struct stm32_hash_dev *stm32_hash_find_dev(struct stm32_hash_ctx *ctx)
+static struct stm32_hash_dev *stm32_hash_find_dev(struct stm32_hash_request_ctx *rctx)
 {
-	struct stm32_hash_dev *hdev = NULL, *tmp;
+	struct stm32_hash_dev *hdev = NULL;
 
-	spin_lock_bh(&stm32_hash.lock);
-	if (!ctx->hdev) {
-		list_for_each_entry(tmp, &stm32_hash.dev_list, list) {
-			hdev = tmp;
-			break;
-		}
-		ctx->hdev = hdev;
-	} else {
-		hdev = ctx->hdev;
-	}
+	if (rctx->state.hdev)
+		return rctx->state.hdev;
 
+	spin_lock_bh(&stm32_hash.lock);
+	hdev = list_first_entry(&stm32_hash.dev_list, struct stm32_hash_dev, list);
+	list_move_tail(&hdev->list, &stm32_hash.dev_list);
+	rctx->state.hdev = hdev;
 	spin_unlock_bh(&stm32_hash.lock);
 
 	return hdev;
@@ -656,16 +760,17 @@ static struct stm32_hash_dev *stm32_hash_find_dev(struct stm32_hash_ctx *ctx)
 static bool stm32_hash_dma_aligned_data(struct ahash_request *req)
 {
 	struct scatterlist *sg;
-	struct stm32_hash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
-	struct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);
+	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
+	struct stm32_hash_dev *hdev = rctx->state.hdev;
 	int i;
 
-	if (req->nbytes <= HASH_DMA_THRESHOLD)
+	if ((!hdev->dma_lch) || (req->nbytes <= rctx->state.buflen))
 		return false;
 
 	if (sg_nents(req->src) > 1) {
 		if (hdev->dma_mode == 1)
 			return false;
+
 		for_each_sg(req->src, sg, sg_nents(req->src), i) {
 			if ((!IS_ALIGNED(sg->length, sizeof(u32))) &&
 			    (!sg_is_last(sg)))
@@ -684,42 +789,66 @@ static int stm32_hash_init(struct ahash_request *req)
 	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
 	struct stm32_hash_ctx *ctx = crypto_ahash_ctx(tfm);
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
-	struct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);
+	struct stm32_hash_dev *hdev;
+	bool sha3_mode = ctx->flags & HASH_FLAGS_SHA3_MODE;
+
+	rctx->state.hdev = NULL;
+	hdev = stm32_hash_find_dev(rctx);
+	if (!hdev)
+		return -ENODEV;
 
-	rctx->hdev = hdev;
+	rctx->state.flags = HASH_FLAGS_CPU;
 
-	rctx->flags = HASH_FLAGS_CPU;
+	if (sha3_mode)
+		rctx->state.flags |= HASH_FLAGS_SHA3_MODE;
 
-	rctx->digcnt = crypto_ahash_digestsize(tfm);
-	switch (rctx->digcnt) {
+	switch (crypto_ahash_digestsize(tfm)) {
 	case MD5_DIGEST_SIZE:
-		rctx->flags |= HASH_FLAGS_MD5;
+		rctx->state.flags |= HASH_MD5 << HASH_FLAGS_ALGO_SHIFT;
 		break;
 	case SHA1_DIGEST_SIZE:
-		rctx->flags |= HASH_FLAGS_SHA1;
+		rctx->state.flags |= HASH_SHA1 << HASH_FLAGS_ALGO_SHIFT;
 		break;
 	case SHA224_DIGEST_SIZE:
-		rctx->flags |= HASH_FLAGS_SHA224;
+		if (sha3_mode)
+			rctx->state.flags |= HASH_SHA3_224 << HASH_FLAGS_ALGO_SHIFT;
+		else
+			rctx->state.flags |= HASH_SHA224 << HASH_FLAGS_ALGO_SHIFT;
 		break;
 	case SHA256_DIGEST_SIZE:
-		rctx->flags |= HASH_FLAGS_SHA256;
+		if (sha3_mode)
+			rctx->state.flags |= HASH_SHA3_256 << HASH_FLAGS_ALGO_SHIFT;
+		else
+			rctx->state.flags |= HASH_SHA256 << HASH_FLAGS_ALGO_SHIFT;
+		break;
+	case SHA384_DIGEST_SIZE:
+		if (sha3_mode)
+			rctx->state.flags |= HASH_SHA3_384 << HASH_FLAGS_ALGO_SHIFT;
+		else
+			rctx->state.flags |= HASH_SHA384 << HASH_FLAGS_ALGO_SHIFT;
+		break;
+	case SHA512_DIGEST_SIZE:
+		if (sha3_mode)
+			rctx->state.flags |= HASH_SHA3_512 << HASH_FLAGS_ALGO_SHIFT;
+		else
+			rctx->state.flags |= HASH_SHA512 << HASH_FLAGS_ALGO_SHIFT;
 		break;
 	default:
 		return -EINVAL;
 	}
 
-	rctx->bufcnt = 0;
-	rctx->buflen = HASH_BUFLEN;
+	rctx->state.buflen = HASH_HW_FIFO_INIT_SIZE;
+	rctx->state.bufcnt = 0;
 	rctx->total = 0;
 	rctx->offset = 0;
-	rctx->data_type = HASH_DATA_8_BITS;
 
-	memset(rctx->buffer, 0, HASH_BUFLEN);
+	memset(rctx->state.buffer, 0, rctx->state.buflen);
+	memset(rctx->state.hw_context, 0, sizeof(rctx->state.hw_context));
 
 	if (ctx->flags & HASH_FLAGS_HMAC)
-		rctx->flags |= HASH_FLAGS_HMAC;
+		rctx->state.flags |= HASH_FLAGS_HMAC;
 
-	dev_dbg(hdev->dev, "%s Flags %lx\n", __func__, rctx->flags);
+	dev_dbg(hdev->dev, "%s Flags %lx\n", __func__, rctx->state.flags);
 
 	return 0;
 }
@@ -734,55 +863,39 @@ static int stm32_hash_final_req(struct stm32_hash_dev *hdev)
 	struct ahash_request *req = hdev->req;
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
 	int err;
-	int buflen = rctx->bufcnt;
+	int buflen = rctx->state.bufcnt;
 
-	rctx->bufcnt = 0;
+	rctx->state.bufcnt = 0;
 
-	if (!(rctx->flags & HASH_FLAGS_CPU))
+	if (!(rctx->state.flags & HASH_FLAGS_CPU))
 		err = stm32_hash_dma_send(hdev);
 	else
-		err = stm32_hash_xmit_cpu(hdev, rctx->buffer, buflen, 1);
-
+		err = stm32_hash_xmit_cpu(rctx, buflen, 1);
 
 	return err;
 }
 
-static void stm32_hash_copy_hash(struct ahash_request *req)
+static int stm32_hash_finish(struct ahash_request *req)
 {
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
-	__be32 *hash = (void *)rctx->digest;
-	unsigned int i, hashsize;
-
-	switch (rctx->flags & HASH_FLAGS_ALGO_MASK) {
-	case HASH_FLAGS_MD5:
-		hashsize = MD5_DIGEST_SIZE;
-		break;
-	case HASH_FLAGS_SHA1:
-		hashsize = SHA1_DIGEST_SIZE;
-		break;
-	case HASH_FLAGS_SHA224:
-		hashsize = SHA224_DIGEST_SIZE;
-		break;
-	case HASH_FLAGS_SHA256:
-		hashsize = SHA256_DIGEST_SIZE;
-		break;
-	default:
-		return;
-	}
+	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
+	unsigned int hashsize = crypto_ahash_digestsize(tfm);
+	__be32 hash[SHA512_DIGEST_SIZE / sizeof(__be32)];
+	unsigned int i;
+	u32 reg;
 
 	for (i = 0; i < hashsize / sizeof(u32); i++)
-		hash[i] = cpu_to_be32(stm32_hash_read(rctx->hdev,
+		hash[i] = cpu_to_be32(stm32_hash_read(rctx->state.hdev,
 						      HASH_HREG(i)));
-}
 
-static int stm32_hash_finish(struct ahash_request *req)
-{
-	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
+	reg = stm32_hash_read(rctx->state.hdev, HASH_SR);
+	reg &= ~HASH_SR_OUTPUT_READY;
+	stm32_hash_write(rctx->state.hdev, HASH_SR, reg);
 
 	if (!req->result)
 		return -EINVAL;
 
-	memcpy(req->result, rctx->digest, rctx->digcnt);
+	memcpy(req->result, hash, hashsize);
 
 	return 0;
 }
@@ -790,18 +903,18 @@ static int stm32_hash_finish(struct ahash_request *req)
 static void stm32_hash_finish_req(struct ahash_request *req, int err)
 {
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
-	struct stm32_hash_dev *hdev = rctx->hdev;
+	struct stm32_hash_dev *hdev = rctx->state.hdev;
 
 	if (!err && (HASH_FLAGS_FINAL & hdev->flags)) {
-		stm32_hash_copy_hash(req);
 		err = stm32_hash_finish(req);
 		hdev->flags &= ~(HASH_FLAGS_FINAL | HASH_FLAGS_CPU |
-				 HASH_FLAGS_INIT | HASH_FLAGS_DMA_READY |
+				 HASH_FLAGS_DMA_READY |
 				 HASH_FLAGS_OUTPUT_READY | HASH_FLAGS_HMAC |
 				 HASH_FLAGS_HMAC_INIT | HASH_FLAGS_HMAC_FINAL |
-				 HASH_FLAGS_HMAC_KEY);
+				 HASH_FLAGS_HMAC_KEY | HASH_FLAGS_SHA3_MODE);
+		rctx->state.flags &= ~HASH_FLAGS_INIT;
 	} else {
-		rctx->flags |= HASH_FLAGS_ERRORS;
+		rctx->state.flags |= HASH_FLAGS_ERRORS;
 	}
 
 	pm_runtime_mark_last_busy(hdev->dev);
@@ -810,20 +923,24 @@ static void stm32_hash_finish_req(struct ahash_request *req, int err)
 	crypto_finalize_hash_request(hdev->engine, req, err);
 }
 
-static int stm32_hash_hw_init(struct stm32_hash_dev *hdev,
-			      struct stm32_hash_request_ctx *rctx)
+static int stm32_hash_hw_init(struct stm32_hash_request_ctx *rctx)
 {
+	int ret = 0;
+	struct stm32_hash_dev *hdev = rctx->state.hdev;
+
 	pm_runtime_get_sync(hdev->dev);
 
-	if (!(HASH_FLAGS_INIT & hdev->flags)) {
+	if (!(HASH_FLAGS_INIT & rctx->state.flags)) {
 		stm32_hash_write(hdev, HASH_CR, HASH_CR_INIT);
 		stm32_hash_write(hdev, HASH_STR, 0);
 		stm32_hash_write(hdev, HASH_DIN, 0);
 		stm32_hash_write(hdev, HASH_IMR, 0);
 		hdev->err = 0;
+	} else {
+		ret = stm32_hash_restore_hw_context(hdev);
 	}
 
-	return 0;
+	return ret;
 }
 
 static int stm32_hash_one_request(struct crypto_engine *engine, void *areq);
@@ -839,38 +956,30 @@ static int stm32_hash_prepare_req(struct crypto_engine *engine, void *areq)
 {
 	struct ahash_request *req = container_of(areq, struct ahash_request,
 						 base);
-	struct stm32_hash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
-	struct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);
-	struct stm32_hash_request_ctx *rctx;
-
-	if (!hdev)
-		return -ENODEV;
+	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
+	struct stm32_hash_dev *hdev = rctx->state.hdev;
 
 	hdev->req = req;
 
-	rctx = ahash_request_ctx(req);
-
 	dev_dbg(hdev->dev, "processing new req, op: %lu, nbytes %d\n",
 		rctx->op, req->nbytes);
 
-	return stm32_hash_hw_init(hdev, rctx);
+	return 0;
 }
 
 static int stm32_hash_one_request(struct crypto_engine *engine, void *areq)
 {
 	struct ahash_request *req = container_of(areq, struct ahash_request,
 						 base);
-	struct stm32_hash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
-	struct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);
-	struct stm32_hash_request_ctx *rctx;
+	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
+	struct stm32_hash_dev *hdev = rctx->state.hdev;
 	int err = 0;
 
-	if (!hdev)
-		return -ENODEV;
-
 	hdev->req = req;
 
-	rctx = ahash_request_ctx(req);
+	err = stm32_hash_hw_init(rctx);
+	if (err)
+		return err;
 
 	if (rctx->op == HASH_OP_UPDATE)
 		err = stm32_hash_update_req(hdev);
@@ -887,8 +996,7 @@ static int stm32_hash_one_request(struct crypto_engine *engine, void *areq)
 static int stm32_hash_enqueue(struct ahash_request *req, unsigned int op)
 {
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
-	struct stm32_hash_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct stm32_hash_dev *hdev = ctx->hdev;
+	struct stm32_hash_dev *hdev = rctx->state.hdev;
 
 	rctx->op = op;
 
@@ -899,14 +1007,16 @@ static int stm32_hash_update(struct ahash_request *req)
 {
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
 
-	if (!req->nbytes || !(rctx->flags & HASH_FLAGS_CPU))
+	if ((!req->nbytes) || !(rctx->state.flags & HASH_FLAGS_CPU))
 		return 0;
 
+	stm32_hash_find_dev(rctx);
+
 	rctx->total = req->nbytes;
 	rctx->sg = req->src;
 	rctx->offset = 0;
 
-	if ((rctx->bufcnt + rctx->total < rctx->buflen)) {
+	if (rctx->state.bufcnt + rctx->total <= rctx->state.buflen) {
 		stm32_hash_append_sg(rctx);
 		return 0;
 	}
@@ -918,7 +1028,7 @@ static int stm32_hash_final(struct ahash_request *req)
 {
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
 
-	rctx->flags |= HASH_FLAGS_FINUP;
+	rctx->state.flags |= HASH_FLAGS_FINUP;
 
 	return stm32_hash_enqueue(req, HASH_OP_FINAL);
 }
@@ -926,14 +1036,9 @@ static int stm32_hash_final(struct ahash_request *req)
 static int stm32_hash_finup(struct ahash_request *req)
 {
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
-	struct stm32_hash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
-	struct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);
 	int err1, err2;
 
-	rctx->flags |= HASH_FLAGS_FINUP;
-
-	if (hdev->dma_lch && stm32_hash_dma_aligned_data(req))
-		rctx->flags &= ~HASH_FLAGS_CPU;
+	rctx->state.flags |= HASH_FLAGS_FINUP;
 
 	err1 = stm32_hash_update(req);
 
@@ -951,38 +1056,24 @@ static int stm32_hash_finup(struct ahash_request *req)
 
 static int stm32_hash_digest(struct ahash_request *req)
 {
-	return stm32_hash_init(req) ?: stm32_hash_finup(req);
-}
-
-static int stm32_hash_export(struct ahash_request *req, void *out)
-{
+	int ret;
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
-	struct stm32_hash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
-	struct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);
-	u32 *preg;
-	unsigned int i;
 
-	pm_runtime_get_sync(hdev->dev);
-
-	while ((stm32_hash_read(hdev, HASH_SR) & HASH_SR_BUSY))
-		cpu_relax();
-
-	rctx->hw_context = kmalloc_array(3 + HASH_CSR_REGISTER_NUMBER,
-					 sizeof(u32),
-					 GFP_KERNEL);
+	ret = stm32_hash_init(req);
+	if (ret)
+		return ret;
 
-	preg = rctx->hw_context;
+	if (stm32_hash_dma_aligned_data(req))
+		rctx->state.flags &= ~HASH_FLAGS_CPU;
 
-	*preg++ = stm32_hash_read(hdev, HASH_IMR);
-	*preg++ = stm32_hash_read(hdev, HASH_STR);
-	*preg++ = stm32_hash_read(hdev, HASH_CR);
-	for (i = 0; i < HASH_CSR_REGISTER_NUMBER; i++)
-		*preg++ = stm32_hash_read(hdev, HASH_CSR(i));
+	return stm32_hash_finup(req);
+}
 
-	pm_runtime_mark_last_busy(hdev->dev);
-	pm_runtime_put_autosuspend(hdev->dev);
+static int stm32_hash_export(struct ahash_request *req, void *out)
+{
+	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
 
-	memcpy(out, rctx, sizeof(*rctx));
+	memcpy(out, &rctx->state, sizeof(rctx->state));
 
 	return 0;
 }
@@ -990,31 +1081,8 @@ static int stm32_hash_export(struct ahash_request *req, void *out)
 static int stm32_hash_import(struct ahash_request *req, const void *in)
 {
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
-	struct stm32_hash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
-	struct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);
-	const u32 *preg = in;
-	u32 reg;
-	unsigned int i;
-
-	memcpy(rctx, in, sizeof(*rctx));
-
-	preg = rctx->hw_context;
-
-	pm_runtime_get_sync(hdev->dev);
-
-	stm32_hash_write(hdev, HASH_IMR, *preg++);
-	stm32_hash_write(hdev, HASH_STR, *preg++);
-	stm32_hash_write(hdev, HASH_CR, *preg);
-	reg = *preg++ | HASH_CR_INIT;
-	stm32_hash_write(hdev, HASH_CR, reg);
-
-	for (i = 0; i < HASH_CSR_REGISTER_NUMBER; i++)
-		stm32_hash_write(hdev, HASH_CSR(i), *preg++);
 
-	pm_runtime_mark_last_busy(hdev->dev);
-	pm_runtime_put_autosuspend(hdev->dev);
-
-	kfree(rctx->hw_context);
+	memcpy(&rctx->state, in, sizeof(rctx->state));
 
 	return 0;
 }
@@ -1034,8 +1102,7 @@ static int stm32_hash_setkey(struct crypto_ahash *tfm,
 	return 0;
 }
 
-static int stm32_hash_cra_init_algs(struct crypto_tfm *tfm,
-				    const char *algs_hmac_name)
+static int stm32_hash_cra_init_algs(struct crypto_tfm *tfm, u32 algs_flags)
 {
 	struct stm32_hash_ctx *ctx = crypto_tfm_ctx(tfm);
 
@@ -1044,8 +1111,8 @@ static int stm32_hash_cra_init_algs(struct crypto_tfm *tfm,
 
 	ctx->keylen = 0;
 
-	if (algs_hmac_name)
-		ctx->flags |= HASH_FLAGS_HMAC;
+	if (algs_flags)
+		ctx->flags |= algs_flags;
 
 	ctx->enginectx.op.do_one_request = stm32_hash_one_request;
 	ctx->enginectx.op.prepare_request = stm32_hash_prepare_req;
@@ -1055,27 +1122,23 @@ static int stm32_hash_cra_init_algs(struct crypto_tfm *tfm,
 
 static int stm32_hash_cra_init(struct crypto_tfm *tfm)
 {
-	return stm32_hash_cra_init_algs(tfm, NULL);
+	return stm32_hash_cra_init_algs(tfm, 0);
 }
 
-static int stm32_hash_cra_md5_init(struct crypto_tfm *tfm)
+static int stm32_hash_cra_hmac_init(struct crypto_tfm *tfm)
 {
-	return stm32_hash_cra_init_algs(tfm, "md5");
+	return stm32_hash_cra_init_algs(tfm, HASH_FLAGS_HMAC);
 }
 
-static int stm32_hash_cra_sha1_init(struct crypto_tfm *tfm)
+static int stm32_hash_cra_sha3_init(struct crypto_tfm *tfm)
 {
-	return stm32_hash_cra_init_algs(tfm, "sha1");
+	return stm32_hash_cra_init_algs(tfm, HASH_FLAGS_SHA3_MODE);
 }
 
-static int stm32_hash_cra_sha224_init(struct crypto_tfm *tfm)
+static int stm32_hash_cra_sha3_hmac_init(struct crypto_tfm *tfm)
 {
-	return stm32_hash_cra_init_algs(tfm, "sha224");
-}
-
-static int stm32_hash_cra_sha256_init(struct crypto_tfm *tfm)
-{
-	return stm32_hash_cra_init_algs(tfm, "sha256");
+	return stm32_hash_cra_init_algs(tfm, HASH_FLAGS_SHA3_MODE |
+					HASH_FLAGS_HMAC);
 }
 
 static irqreturn_t stm32_hash_irq_thread(int irq, void *dev_id)
@@ -1110,8 +1173,6 @@ static irqreturn_t stm32_hash_irq_handler(int irq, void *dev_id)
 
 	reg = stm32_hash_read(hdev, HASH_SR);
 	if (reg & HASH_SR_OUTPUT_READY) {
-		reg &= ~HASH_SR_OUTPUT_READY;
-		stm32_hash_write(hdev, HASH_SR, reg);
 		hdev->flags |= HASH_FLAGS_OUTPUT_READY;
 		/* Disable IT*/
 		stm32_hash_write(hdev, HASH_IMR, 0);
@@ -1121,7 +1182,7 @@ static irqreturn_t stm32_hash_irq_handler(int irq, void *dev_id)
 	return IRQ_NONE;
 }
 
-static struct ahash_alg algs_md5_sha1[] = {
+static struct ahash_alg algs_md5[] = {
 	{
 		.init = stm32_hash_init,
 		.update = stm32_hash_update,
@@ -1132,7 +1193,7 @@ static struct ahash_alg algs_md5_sha1[] = {
 		.import = stm32_hash_import,
 		.halg = {
 			.digestsize = MD5_DIGEST_SIZE,
-			.statesize = sizeof(struct stm32_hash_request_ctx),
+			.statesize = sizeof(struct stm32_hash_state),
 			.base = {
 				.cra_name = "md5",
 				.cra_driver_name = "stm32-md5",
@@ -1158,7 +1219,7 @@ static struct ahash_alg algs_md5_sha1[] = {
 		.setkey = stm32_hash_setkey,
 		.halg = {
 			.digestsize = MD5_DIGEST_SIZE,
-			.statesize = sizeof(struct stm32_hash_request_ctx),
+			.statesize = sizeof(struct stm32_hash_state),
 			.base = {
 				.cra_name = "hmac(md5)",
 				.cra_driver_name = "stm32-hmac-md5",
@@ -1168,11 +1229,14 @@ static struct ahash_alg algs_md5_sha1[] = {
 				.cra_blocksize = MD5_HMAC_BLOCK_SIZE,
 				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
 				.cra_alignmask = 3,
-				.cra_init = stm32_hash_cra_md5_init,
+				.cra_init = stm32_hash_cra_hmac_init,
 				.cra_module = THIS_MODULE,
 			}
 		}
-	},
+	}
+};
+
+static struct ahash_alg algs_sha1[] = {
 	{
 		.init = stm32_hash_init,
 		.update = stm32_hash_update,
@@ -1183,7 +1247,7 @@ static struct ahash_alg algs_md5_sha1[] = {
 		.import = stm32_hash_import,
 		.halg = {
 			.digestsize = SHA1_DIGEST_SIZE,
-			.statesize = sizeof(struct stm32_hash_request_ctx),
+			.statesize = sizeof(struct stm32_hash_state),
 			.base = {
 				.cra_name = "sha1",
 				.cra_driver_name = "stm32-sha1",
@@ -1209,7 +1273,7 @@ static struct ahash_alg algs_md5_sha1[] = {
 		.setkey = stm32_hash_setkey,
 		.halg = {
 			.digestsize = SHA1_DIGEST_SIZE,
-			.statesize = sizeof(struct stm32_hash_request_ctx),
+			.statesize = sizeof(struct stm32_hash_state),
 			.base = {
 				.cra_name = "hmac(sha1)",
 				.cra_driver_name = "stm32-hmac-sha1",
@@ -1219,7 +1283,7 @@ static struct ahash_alg algs_md5_sha1[] = {
 				.cra_blocksize = SHA1_BLOCK_SIZE,
 				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
 				.cra_alignmask = 3,
-				.cra_init = stm32_hash_cra_sha1_init,
+				.cra_init = stm32_hash_cra_hmac_init,
 				.cra_module = THIS_MODULE,
 			}
 		}
@@ -1237,7 +1301,7 @@ static struct ahash_alg algs_sha224_sha256[] = {
 		.import = stm32_hash_import,
 		.halg = {
 			.digestsize = SHA224_DIGEST_SIZE,
-			.statesize = sizeof(struct stm32_hash_request_ctx),
+			.statesize = sizeof(struct stm32_hash_state),
 			.base = {
 				.cra_name = "sha224",
 				.cra_driver_name = "stm32-sha224",
@@ -1263,7 +1327,7 @@ static struct ahash_alg algs_sha224_sha256[] = {
 		.import = stm32_hash_import,
 		.halg = {
 			.digestsize = SHA224_DIGEST_SIZE,
-			.statesize = sizeof(struct stm32_hash_request_ctx),
+			.statesize = sizeof(struct stm32_hash_state),
 			.base = {
 				.cra_name = "hmac(sha224)",
 				.cra_driver_name = "stm32-hmac-sha224",
@@ -1273,7 +1337,7 @@ static struct ahash_alg algs_sha224_sha256[] = {
 				.cra_blocksize = SHA224_BLOCK_SIZE,
 				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
 				.cra_alignmask = 3,
-				.cra_init = stm32_hash_cra_sha224_init,
+				.cra_init = stm32_hash_cra_hmac_init,
 				.cra_module = THIS_MODULE,
 			}
 		}
@@ -1288,7 +1352,7 @@ static struct ahash_alg algs_sha224_sha256[] = {
 		.import = stm32_hash_import,
 		.halg = {
 			.digestsize = SHA256_DIGEST_SIZE,
-			.statesize = sizeof(struct stm32_hash_request_ctx),
+			.statesize = sizeof(struct stm32_hash_state),
 			.base = {
 				.cra_name = "sha256",
 				.cra_driver_name = "stm32-sha256",
@@ -1314,7 +1378,7 @@ static struct ahash_alg algs_sha224_sha256[] = {
 		.setkey = stm32_hash_setkey,
 		.halg = {
 			.digestsize = SHA256_DIGEST_SIZE,
-			.statesize = sizeof(struct stm32_hash_request_ctx),
+			.statesize = sizeof(struct stm32_hash_state),
 			.base = {
 				.cra_name = "hmac(sha256)",
 				.cra_driver_name = "stm32-hmac-sha256",
@@ -1324,11 +1388,323 @@ static struct ahash_alg algs_sha224_sha256[] = {
 				.cra_blocksize = SHA256_BLOCK_SIZE,
 				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
 				.cra_alignmask = 3,
-				.cra_init = stm32_hash_cra_sha256_init,
+				.cra_init = stm32_hash_cra_hmac_init,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+};
+
+static struct ahash_alg algs_sha384_sha512[] = {
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.halg = {
+			.digestsize = SHA384_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "sha384",
+				.cra_driver_name = "stm32-sha384",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA384_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_init,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.setkey = stm32_hash_setkey,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.halg = {
+			.digestsize = SHA384_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "hmac(sha384)",
+				.cra_driver_name = "stm32-hmac-sha384",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA384_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_hmac_init,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.halg = {
+			.digestsize = SHA512_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "sha512",
+				.cra_driver_name = "stm32-sha512",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA512_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_init,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.setkey = stm32_hash_setkey,
+		.halg = {
+			.digestsize = SHA512_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "hmac(sha512)",
+				.cra_driver_name = "stm32-hmac-sha512",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA512_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_hmac_init,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+};
+
+static struct ahash_alg algs_sha3[] = {
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.halg = {
+			.digestsize = SHA3_224_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "sha3-224",
+				.cra_driver_name = "stm32-sha3-224",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA3_224_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_sha3_init,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.setkey = stm32_hash_setkey,
+		.halg = {
+			.digestsize = SHA3_224_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "hmac(sha3-224)",
+				.cra_driver_name = "stm32-hmac-sha3-224",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA3_224_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_sha3_hmac_init,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+		{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.halg = {
+			.digestsize = SHA3_256_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "sha3-256",
+				.cra_driver_name = "stm32-sha3-256",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA3_256_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_sha3_init,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.setkey = stm32_hash_setkey,
+		.halg = {
+			.digestsize = SHA3_256_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "hmac(sha3-256)",
+				.cra_driver_name = "stm32-hmac-sha3-256",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA3_256_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_sha3_hmac_init,
 				.cra_module = THIS_MODULE,
 			}
 		}
 	},
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.halg = {
+			.digestsize = SHA3_384_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "sha3-384",
+				.cra_driver_name = "stm32-sha3-384",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA3_384_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_sha3_init,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.setkey = stm32_hash_setkey,
+		.halg = {
+			.digestsize = SHA3_384_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "hmac(sha3-384)",
+				.cra_driver_name = "stm32-hmac-sha3-384",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA3_384_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_sha3_hmac_init,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.halg = {
+			.digestsize = SHA3_512_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "sha3-512",
+				.cra_driver_name = "stm32-sha3-512",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA3_512_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_sha3_init,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.setkey = stm32_hash_setkey,
+		.halg = {
+			.digestsize = SHA3_512_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "hmac(sha3-512)",
+				.cra_driver_name = "stm32-hmac-sha3-512",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA3_512_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_sha3_hmac_init,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	}
 };
 
 static int stm32_hash_register_algs(struct stm32_hash_dev *hdev)
@@ -1372,20 +1748,29 @@ static int stm32_hash_unregister_algs(struct stm32_hash_dev *hdev)
 
 static struct stm32_hash_algs_info stm32_hash_algs_info_stm32f4[] = {
 	{
-		.algs_list	= algs_md5_sha1,
-		.size		= ARRAY_SIZE(algs_md5_sha1),
+		.algs_list	= algs_md5,
+		.size		= ARRAY_SIZE(algs_md5),
+	},
+	{
+		.algs_list	= algs_sha1,
+		.size		= ARRAY_SIZE(algs_sha1),
 	},
 };
 
 static const struct stm32_hash_pdata stm32_hash_pdata_stm32f4 = {
+	.alg_shift	= 7,
 	.algs_info	= stm32_hash_algs_info_stm32f4,
 	.algs_info_size	= ARRAY_SIZE(stm32_hash_algs_info_stm32f4),
 };
 
 static struct stm32_hash_algs_info stm32_hash_algs_info_stm32f7[] = {
 	{
-		.algs_list	= algs_md5_sha1,
-		.size		= ARRAY_SIZE(algs_md5_sha1),
+		.algs_list	= algs_md5,
+		.size		= ARRAY_SIZE(algs_md5),
+	},
+	{
+		.algs_list	= algs_sha1,
+		.size		= ARRAY_SIZE(algs_sha1),
 	},
 	{
 		.algs_list	= algs_sha224_sha256,
@@ -1394,19 +1779,40 @@ static struct stm32_hash_algs_info stm32_hash_algs_info_stm32f7[] = {
 };
 
 static const struct stm32_hash_pdata stm32_hash_pdata_stm32f7 = {
+	.alg_shift	= 7,
 	.algs_info	= stm32_hash_algs_info_stm32f7,
 	.algs_info_size	= ARRAY_SIZE(stm32_hash_algs_info_stm32f7),
 };
 
-static const struct of_device_id stm32_hash_of_match[] = {
+static struct stm32_hash_algs_info stm32_hash_algs_info_stm32mp13[] = {
 	{
-		.compatible = "st,stm32f456-hash",
-		.data = &stm32_hash_pdata_stm32f4,
+		.algs_list	= algs_sha1,
+		.size		= ARRAY_SIZE(algs_sha1),
 	},
 	{
-		.compatible = "st,stm32f756-hash",
-		.data = &stm32_hash_pdata_stm32f7,
+		.algs_list	= algs_sha224_sha256,
+		.size		= ARRAY_SIZE(algs_sha224_sha256),
+	},
+	{
+		.algs_list	= algs_sha384_sha512,
+		.size		= ARRAY_SIZE(algs_sha384_sha512),
 	},
+	{
+		.algs_list	= algs_sha3,
+		.size		= ARRAY_SIZE(algs_sha3),
+	},
+};
+
+static const struct stm32_hash_pdata stm32_hash_pdata_stm32mp13 = {
+	.alg_shift	= 17,
+	.algs_info	= stm32_hash_algs_info_stm32mp13,
+	.algs_info_size	= ARRAY_SIZE(stm32_hash_algs_info_stm32mp13),
+};
+
+static const struct of_device_id stm32_hash_of_match[] = {
+	{ .compatible = "st,stm32f456-hash", .data = &stm32_hash_pdata_stm32f4 },
+	{ .compatible = "st,stm32f756-hash", .data = &stm32_hash_pdata_stm32f7 },
+	{ .compatible = "st,stm32mp13-hash", .data = &stm32_hash_pdata_stm32mp13 },
 	{},
 };
 
@@ -1421,12 +1827,6 @@ static int stm32_hash_get_of_match(struct stm32_hash_dev *hdev,
 		return -EINVAL;
 	}
 
-	if (of_property_read_u32(dev->of_node, "dma-maxburst",
-				 &hdev->dma_maxburst)) {
-		dev_info(dev, "dma-maxburst not specified, using 0\n");
-		hdev->dma_maxburst = 0;
-	}
-
 	return 0;
 }
 
@@ -1494,6 +1894,8 @@ static int stm32_hash_probe(struct platform_device *pdev)
 		reset_control_deassert(hdev->rst);
 	}
 
+	crypto_init_queue(&hdev->queue, HASH_QUEUE_LENGTH);
+
 	hdev->dev = dev;
 
 	platform_set_drvdata(pdev, hdev);
@@ -1502,7 +1904,7 @@ static int stm32_hash_probe(struct platform_device *pdev)
 	switch (ret) {
 	case 0:
 		break;
-	case -ENOENT:
+	case -ENODEV:
 		dev_dbg(dev, "DMA mode not available\n");
 		break;
 	default:
@@ -1524,7 +1926,8 @@ static int stm32_hash_probe(struct platform_device *pdev)
 	if (ret)
 		goto err_engine_start;
 
-	hdev->dma_mode = stm32_hash_read(hdev, HASH_HWCFGR);
+	hdev->dma_mode = stm32_hash_read(hdev, HASH_HWCFGR) &
+		HASH_HWCFG_DMA_MASK;
 
 	/* Register algos */
 	ret = stm32_hash_register_algs(hdev);
@@ -1633,6 +2036,6 @@ static struct platform_driver stm32_hash_driver = {
 
 module_platform_driver(stm32_hash_driver);
 
-MODULE_DESCRIPTION("STM32 SHA1/224/256 & MD5 (HMAC) hw accelerator driver");
+MODULE_DESCRIPTION("STM32 SHA1/SHA2/SHA3 & MD5 (HMAC) hw accelerator driver");
 MODULE_AUTHOR("Lionel Debieve <lionel.debieve@st.com>");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index 80c2c03cb..773cac77e 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -569,6 +569,17 @@ config ST_FDMA
 	  Say Y here if you have such a chipset.
 	  If unsure, say N.
 
+config STM32_DMA3
+	bool "STMicroelectronics STM32 DMA3 support"
+	depends on ARCH_STM32 || COMPILE_TEST
+	select DMA_ENGINE
+	select DMA_VIRTUAL_CHANNELS
+	help
+	  Enable support for the on-chip DMA3 controller on STMicroelectronics
+	  STM32 platforms.
+	  If you have an STM32 SoC with such DMA3 controller and want to use
+	  DMA, say Y here.
+
 config STM32_DMA
 	bool "STMicroelectronics STM32 DMA support"
 	depends on ARCH_STM32 || COMPILE_TEST
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index 616d926cf..e455f800a 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -66,6 +66,7 @@ obj-$(CONFIG_PXA_DMA) += pxa_dma.o
 obj-$(CONFIG_RENESAS_DMA) += sh/
 obj-$(CONFIG_SF_PDMA) += sf-pdma/
 obj-$(CONFIG_STE_DMA40) += ste_dma40.o ste_dma40_ll.o
+obj-$(CONFIG_STM32_DMA3) += stm32-dma3.o
 obj-$(CONFIG_STM32_DMA) += stm32-dma.o
 obj-$(CONFIG_STM32_DMAMUX) += stm32-dmamux.o
 obj-$(CONFIG_STM32_MDMA) += stm32-mdma.o
diff --git a/drivers/dma/stm32-dma.c b/drivers/dma/stm32-dma.c
index 7dfc743ac..7c6078c6c 100644
--- a/drivers/dma/stm32-dma.c
+++ b/drivers/dma/stm32-dma.c
@@ -14,12 +14,14 @@
 #include <linux/dmaengine.h>
 #include <linux/dma-mapping.h>
 #include <linux/err.h>
+#include <linux/genalloc.h>
 #include <linux/init.h>
 #include <linux/iopoll.h>
 #include <linux/jiffies.h>
 #include <linux/list.h>
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/of_address.h>
 #include <linux/of_device.h>
 #include <linux/of_dma.h>
 #include <linux/platform_device.h>
@@ -121,6 +123,7 @@
 #define STM32_DMA_FIFO_THRESHOLD_NONE			0x04
 
 #define STM32_DMA_MAX_DATA_ITEMS	0xffff
+#define STM32_DMA_SRAM_GRANULARITY	PAGE_SIZE
 /*
  * Valid transfer starts from @0 to @0xFFFE leading to unaligned scatter
  * gather at boundary. Thus it's safer to round down this value on FIFO
@@ -142,6 +145,10 @@
 #define STM32_DMA_DIRECT_MODE_GET(n)	(((n) & STM32_DMA_DIRECT_MODE_MASK) >> 2)
 #define STM32_DMA_ALT_ACK_MODE_MASK	BIT(4)
 #define STM32_DMA_ALT_ACK_MODE_GET(n)	(((n) & STM32_DMA_ALT_ACK_MODE_MASK) >> 4)
+#define STM32_DMA_MDMA_CHAIN_FTR_MASK	BIT(31)
+#define STM32_DMA_MDMA_CHAIN_FTR_GET(n)	(((n) & STM32_DMA_MDMA_CHAIN_FTR_MASK) >> 31)
+#define STM32_DMA_MDMA_SRAM_SIZE_MASK	GENMASK(30, 29)
+#define STM32_DMA_MDMA_SRAM_SIZE_GET(n)	(((n) & STM32_DMA_MDMA_SRAM_SIZE_MASK) >> 29)
 
 enum stm32_dma_width {
 	STM32_DMA_BYTE,
@@ -183,15 +190,31 @@ struct stm32_dma_chan_reg {
 	u32 dma_sfcr;
 };
 
+struct stm32_dma_mdma_desc {
+	struct sg_table sgt;
+	struct dma_async_tx_descriptor *desc;
+};
+
+struct stm32_dma_mdma {
+	struct dma_chan *chan;
+	enum dma_transfer_direction dir;
+	dma_addr_t sram_buf;
+	u32 sram_period;
+};
+
 struct stm32_dma_sg_req {
-	u32 len;
+	struct scatterlist stm32_sgl_req;
 	struct stm32_dma_chan_reg chan_reg;
+	struct stm32_dma_mdma_desc m_desc;
 };
 
 struct stm32_dma_desc {
 	struct virt_dma_desc vdesc;
 	bool cyclic;
 	u32 num_sgs;
+	dma_addr_t dma_buf;
+	void *dma_buf_cpu;
+	u32 dma_buf_size;
 	struct stm32_dma_sg_req sg_req[];
 };
 
@@ -208,6 +231,13 @@ struct stm32_dma_chan {
 	u32 threshold;
 	u32 mem_burst;
 	u32 mem_width;
+	enum dma_status status;
+	struct stm32_dma_mdma mchan;
+	u32 use_mdma;
+	u32 sram_size;
+	u32 residue_after_drain;
+	struct workqueue_struct *mdma_wq;
+	struct work_struct mdma_work;
 };
 
 struct stm32_dma_device {
@@ -216,6 +246,7 @@ struct stm32_dma_device {
 	struct clk *clk;
 	bool mem2mem;
 	struct stm32_dma_chan chan[STM32_DMA_MAX_CHANNELS];
+	struct gen_pool *sram_pool;
 };
 
 static struct stm32_dma_device *stm32_dma_get_dev(struct stm32_dma_chan *chan)
@@ -266,7 +297,7 @@ static int stm32_dma_get_width(struct stm32_dma_chan *chan,
 }
 
 static enum dma_slave_buswidth stm32_dma_get_max_width(u32 buf_len,
-						       dma_addr_t buf_addr,
+						       u64 buf_addr,
 						       u32 threshold)
 {
 	enum dma_slave_buswidth max_width;
@@ -380,6 +411,16 @@ static void stm32_dma_set_fifo_config(struct stm32_dma_chan *chan,
 	}
 }
 
+static void stm32_dma_slave_caps(struct dma_chan *c, struct dma_slave_caps *caps)
+{
+	struct stm32_dma_chan *chan = to_stm32_dma_chan(c);
+
+	if (chan->use_mdma)
+		caps->max_sg_burst = 0; /* unlimited */
+	else
+		caps->max_sg_burst = STM32_DMA_ALIGNED_MAX_DATA_ITEMS;
+}
+
 static int stm32_dma_slave_config(struct dma_chan *c,
 				  struct dma_slave_config *config)
 {
@@ -485,17 +526,25 @@ static void stm32_dma_stop(struct stm32_dma_chan *chan)
 	}
 
 	chan->busy = false;
+	chan->status = DMA_COMPLETE;
 }
 
 static int stm32_dma_terminate_all(struct dma_chan *c)
 {
 	struct stm32_dma_chan *chan = to_stm32_dma_chan(c);
+	struct stm32_dma_mdma *mchan = &chan->mchan;
 	unsigned long flags;
 	LIST_HEAD(head);
 
-	spin_lock_irqsave(&chan->vchan.lock, flags);
+	if (chan->use_mdma) {
+		spin_lock_irqsave_nested(&chan->vchan.lock, flags, SINGLE_DEPTH_NESTING);
+		dmaengine_terminate_async(mchan->chan);
+	} else {
+		spin_lock_irqsave(&chan->vchan.lock, flags);
+	}
 
 	if (chan->desc) {
+		dma_cookie_complete(&chan->desc->vdesc.tx);
 		vchan_terminate_vdesc(&chan->desc->vdesc);
 		if (chan->busy)
 			stm32_dma_stop(chan);
@@ -509,9 +558,102 @@ static int stm32_dma_terminate_all(struct dma_chan *c)
 	return 0;
 }
 
+static u32 stm32_dma_get_remaining_bytes(struct stm32_dma_chan *chan)
+{
+	u32 dma_scr, width, ndtr;
+	struct stm32_dma_device *dmadev = stm32_dma_get_dev(chan);
+
+	dma_scr = stm32_dma_read(dmadev, STM32_DMA_SCR(chan->id));
+	width = STM32_DMA_SCR_PSIZE_GET(dma_scr);
+	ndtr = stm32_dma_read(dmadev, STM32_DMA_SNDTR(chan->id));
+
+	return ndtr << width;
+}
+
+static int stm32_dma_mdma_drain(struct stm32_dma_chan *chan)
+{
+	struct stm32_dma_mdma *mchan = &chan->mchan;
+	struct stm32_dma_sg_req *sg_req;
+	struct dma_device *ddev = mchan->chan->device;
+	struct dma_async_tx_descriptor *desc = NULL;
+	enum dma_status status;
+	dma_addr_t src_buf, dst_buf;
+	u32 mdma_residue, mdma_wrote, dma_to_write, len;
+	struct dma_tx_state state;
+	int ret;
+	unsigned long flags;
+
+	flush_workqueue(chan->mdma_wq);
+
+	/* DMA/MDMA chain: drain remaining data in SRAM */
+
+	/* Get the residue on MDMA side */
+	status = dmaengine_tx_status(mchan->chan, mchan->chan->cookie, &state);
+	if (status == DMA_COMPLETE)
+		return status;
+
+	mdma_residue = state.residue;
+	sg_req = &chan->desc->sg_req[chan->next_sg - 1];
+	len = sg_dma_len(&sg_req->stm32_sgl_req);
+
+	/*
+	 * Total = mdma blocks * sram_period + rest (< sram_period)
+	 * so mdma blocks * sram_period = len - mdma residue - rest
+	 */
+	mdma_wrote = len - mdma_residue - (len % mchan->sram_period);
+
+	/* Remaining data stuck in SRAM */
+	dma_to_write = mchan->sram_period - stm32_dma_get_remaining_bytes(chan);
+	if (dma_to_write > 0) {
+		spin_lock_irqsave_nested(&chan->vchan.lock, flags, SINGLE_DEPTH_NESTING);
+
+		/* Terminate current MDMA to initiate a new one */
+		dmaengine_terminate_async(mchan->chan);
+
+		/* Stop DMA current operation */
+		stm32_dma_disable_chan(chan);
+
+		spin_unlock_irqrestore(&chan->vchan.lock, flags);
+
+		/* Double buffer management */
+		src_buf = mchan->sram_buf +
+			  ((mdma_wrote / mchan->sram_period) & 0x1) * mchan->sram_period;
+		dst_buf = sg_dma_address(&sg_req->stm32_sgl_req) + mdma_wrote;
+
+		desc = ddev->device_prep_dma_memcpy(mchan->chan, dst_buf, src_buf, dma_to_write,
+						    DMA_PREP_INTERRUPT);
+		if (!desc)
+			return -EINVAL;
+
+		ret = dma_submit_error(dmaengine_submit(desc));
+		if (ret < 0)
+			return ret;
+
+		status = dma_wait_for_async_tx(desc);
+		if (status != DMA_COMPLETE) {
+			dev_err(chan2dev(chan), "%s dma_wait_for_async_tx error\n", __func__);
+			dmaengine_terminate_async(mchan->chan);
+			return -EBUSY;
+		}
+
+		/* We need to store residue for tx_status() */
+		chan->residue_after_drain = len - (mdma_wrote + dma_to_write);
+	}
+
+	return 0;
+}
+
 static void stm32_dma_synchronize(struct dma_chan *c)
 {
 	struct stm32_dma_chan *chan = to_stm32_dma_chan(c);
+	struct stm32_dma_mdma *mchan = &chan->mchan;
+
+	if (chan->desc && chan->use_mdma && mchan->dir == DMA_DEV_TO_MEM)
+		if (stm32_dma_mdma_drain(chan))
+			dev_err(chan2dev(chan), "%s: can't drain DMA\n", __func__);
+
+	if (chan->use_mdma)
+		dmaengine_synchronize(mchan->chan);
 
 	vchan_synchronize(&chan->vchan);
 }
@@ -534,6 +676,231 @@ static void stm32_dma_dump_reg(struct stm32_dma_chan *chan)
 	dev_dbg(chan2dev(chan), "SFCR:  0x%08x\n", sfcr);
 }
 
+static int stm32_dma_dummy_memcpy_xfer(struct stm32_dma_chan *chan)
+{
+	struct stm32_dma_device *dmadev = stm32_dma_get_dev(chan);
+	struct dma_device *ddev = &dmadev->ddev;
+	struct stm32_dma_chan_reg reg;
+	u8 src_buf, dst_buf;
+	dma_addr_t dma_src_buf, dma_dst_buf;
+	u32 ndtr, status;
+	int len, ret;
+
+	ret = 0;
+	src_buf = 0;
+	len = 1;
+
+	dma_src_buf = dma_map_single(ddev->dev, &src_buf, len, DMA_TO_DEVICE);
+	ret = dma_mapping_error(ddev->dev, dma_src_buf);
+	if (ret < 0) {
+		dev_err(chan2dev(chan), "Source buffer map failed\n");
+		return ret;
+	}
+
+	dma_dst_buf = dma_map_single(ddev->dev, &dst_buf, len, DMA_FROM_DEVICE);
+	ret = dma_mapping_error(ddev->dev, dma_dst_buf);
+	if (ret < 0) {
+		dev_err(chan2dev(chan), "Destination buffer map failed\n");
+		dma_unmap_single(ddev->dev, dma_src_buf, len, DMA_TO_DEVICE);
+		return ret;
+	}
+
+	reg.dma_scr =	STM32_DMA_SCR_DIR(STM32_DMA_MEM_TO_MEM) |
+			STM32_DMA_SCR_PBURST(STM32_DMA_BURST_SINGLE) |
+			STM32_DMA_SCR_MBURST(STM32_DMA_BURST_SINGLE) |
+			STM32_DMA_SCR_MINC | STM32_DMA_SCR_PINC |
+			STM32_DMA_SCR_TEIE;
+	reg.dma_spar = dma_src_buf;
+	reg.dma_sm0ar = dma_dst_buf;
+	reg.dma_sfcr = STM32_DMA_SFCR_MASK | STM32_DMA_SFCR_FTH(STM32_DMA_FIFO_THRESHOLD_FULL);
+	reg.dma_sm1ar = dma_dst_buf;
+	reg.dma_sndtr = 1;
+
+	stm32_dma_write(dmadev, STM32_DMA_SCR(chan->id), reg.dma_scr);
+	stm32_dma_write(dmadev, STM32_DMA_SPAR(chan->id), reg.dma_spar);
+	stm32_dma_write(dmadev, STM32_DMA_SM0AR(chan->id), reg.dma_sm0ar);
+	stm32_dma_write(dmadev, STM32_DMA_SFCR(chan->id), reg.dma_sfcr);
+	stm32_dma_write(dmadev, STM32_DMA_SM1AR(chan->id), reg.dma_sm1ar);
+	stm32_dma_write(dmadev, STM32_DMA_SNDTR(chan->id), reg.dma_sndtr);
+
+	/* Clear interrupt status if it is there */
+	status = stm32_dma_irq_status(chan);
+	if (status)
+		stm32_dma_irq_clear(chan, status);
+
+	stm32_dma_dump_reg(chan);
+
+	chan->busy = true;
+	chan->status = DMA_IN_PROGRESS;
+	/* Start DMA */
+	reg.dma_scr |= STM32_DMA_SCR_EN;
+	stm32_dma_write(dmadev, STM32_DMA_SCR(chan->id), reg.dma_scr);
+
+	ret = readl_relaxed_poll_timeout_atomic(dmadev->base + STM32_DMA_SNDTR(chan->id),
+						ndtr, !ndtr, 10, 1000);
+	if (ret) {
+		dev_err(chan2dev(chan), "%s: timeout!\n", __func__);
+		ret = -EBUSY;
+	}
+
+	chan->busy = false;
+	chan->status = DMA_COMPLETE;
+
+	ret = stm32_dma_disable_chan(chan);
+	status = stm32_dma_irq_status(chan);
+	if (status)
+		stm32_dma_irq_clear(chan, status);
+
+	dma_unmap_single(ddev->dev, dma_src_buf, len, DMA_TO_DEVICE);
+	dma_unmap_single(ddev->dev, dma_dst_buf, len, DMA_FROM_DEVICE);
+
+	return ret;
+}
+
+static int stm32_dma_mdma_flush_remaining(struct stm32_dma_chan *chan)
+{
+	struct stm32_dma_device *dmadev = stm32_dma_get_dev(chan);
+	struct stm32_dma_mdma *mchan = &chan->mchan;
+	struct stm32_dma_sg_req *sg_req;
+	struct dma_device *ddev = mchan->chan->device;
+	struct dma_async_tx_descriptor *desc = NULL;
+	enum dma_status status;
+	dma_addr_t src_buf, dst_buf;
+	u32 residue, remain, len, dma_scr;
+	int ret;
+
+	residue = stm32_dma_get_remaining_bytes(chan);
+	if (!residue)
+		return 0;
+
+	dma_scr = stm32_dma_read(dmadev, STM32_DMA_SCR(chan->id));
+	if (!(dma_scr & STM32_DMA_SCR_EN))
+		return -EPERM;
+
+	sg_req = &chan->desc->sg_req[chan->next_sg - 1];
+	len = sg_dma_len(&sg_req->stm32_sgl_req);
+	remain = len % mchan->sram_period;
+
+	if (len > mchan->sram_period && ((len % mchan->sram_period) != 0)) {
+		unsigned long dma_sync_wait_timeout = jiffies + msecs_to_jiffies(5000);
+
+		while (residue > 0 && residue > (mchan->sram_period - remain)) {
+			if (time_after_eq(jiffies, dma_sync_wait_timeout)) {
+				dev_err(chan2dev(chan),
+					"%s timeout pending last %d bytes\n", __func__, residue);
+				return -EBUSY;
+			}
+			cpu_relax();
+			residue = stm32_dma_get_remaining_bytes(chan);
+		}
+		stm32_dma_disable_chan(chan);
+
+		src_buf = mchan->sram_buf + ((len / mchan->sram_period) & 0x1) * mchan->sram_period;
+		dst_buf = sg_dma_address(&sg_req->stm32_sgl_req) + len - (len % mchan->sram_period);
+
+		desc = ddev->device_prep_dma_memcpy(mchan->chan, dst_buf, src_buf,
+						    len % mchan->sram_period, DMA_PREP_INTERRUPT);
+
+		if (!desc)
+			return -EINVAL;
+
+		ret = dma_submit_error(dmaengine_submit(desc));
+		if (ret < 0)
+			return ret;
+
+		status = dma_wait_for_async_tx(desc);
+		if (status != DMA_COMPLETE) {
+			dmaengine_terminate_async(mchan->chan);
+			return -EBUSY;
+		}
+	}
+
+	return 0;
+}
+
+static void stm32_dma_start_transfer(struct stm32_dma_chan *chan);
+
+static void stm32_mdma_chan_complete_worker(struct work_struct *work)
+{
+	struct stm32_dma_chan *chan = container_of(work, struct stm32_dma_chan, mdma_work);
+	unsigned long flags;
+	int ret;
+
+	chan->busy = false;
+	chan->status = DMA_COMPLETE;
+	ret = stm32_dma_mdma_flush_remaining(chan);
+	if (ret) {
+		dev_err(chan2dev(chan), "Can't flush DMA: %d\n", ret);
+		return;
+	}
+
+	spin_lock_irqsave_nested(&chan->vchan.lock, flags, SINGLE_DEPTH_NESTING);
+
+	if (chan->next_sg == chan->desc->num_sgs) {
+		vchan_cookie_complete(&chan->desc->vdesc);
+		chan->desc = NULL;
+	}
+
+	stm32_dma_start_transfer(chan);
+
+	spin_unlock_irqrestore(&chan->vchan.lock, flags);
+}
+
+static void stm32_mdma_chan_complete(void *param, const struct dmaengine_result *result)
+{
+	struct stm32_dma_chan *chan = param;
+
+	if (result->result == DMA_TRANS_NOERROR) {
+		if (!queue_work(chan->mdma_wq, &chan->mdma_work)) {
+			chan->busy = false;
+			chan->status = DMA_COMPLETE;
+			dev_warn(chan2dev(chan), "Work already queued\n");
+		}
+	} else {
+		chan->busy = false;
+		chan->status = DMA_COMPLETE;
+		dev_err(chan2dev(chan), "MDMA transfer error: %d\n", result->result);
+	}
+}
+
+static int stm32_dma_mdma_start(struct stm32_dma_chan *chan, struct stm32_dma_sg_req *sg_req)
+{
+	struct stm32_dma_mdma *mchan = &chan->mchan;
+	struct stm32_dma_mdma_desc *m_desc = &sg_req->m_desc;
+	int ret;
+
+	ret = dma_submit_error(dmaengine_submit(m_desc->desc));
+	if (ret < 0) {
+		dev_err(chan2dev(chan), "MDMA submit failed\n");
+		goto error;
+	}
+
+	dma_async_issue_pending(mchan->chan);
+
+	/*
+	 * In case of M2D transfer, we have to generate dummy DMA transfer to
+	 * copy 1st sg data into SRAM
+	 */
+	if (mchan->dir == DMA_MEM_TO_DEV) {
+		ret = stm32_dma_dummy_memcpy_xfer(chan);
+		if (ret < 0) {
+			dmaengine_terminate_async(mchan->chan);
+			goto error;
+		}
+	}
+
+	return 0;
+error:
+	return ret;
+}
+
+static void stm32_dma_sg_inc(struct stm32_dma_chan *chan)
+{
+	chan->next_sg++;
+	if (chan->desc->cyclic && (chan->next_sg == chan->desc->num_sgs))
+		chan->next_sg = 0;
+}
+
 static void stm32_dma_configure_next_sg(struct stm32_dma_chan *chan);
 
 static void stm32_dma_start_transfer(struct stm32_dma_chan *chan)
@@ -558,6 +925,8 @@ static void stm32_dma_start_transfer(struct stm32_dma_chan *chan)
 
 		chan->desc = to_stm32_dma_desc(vdesc);
 		chan->next_sg = 0;
+	} else {
+		vdesc = &chan->desc->vdesc;
 	}
 
 	if (chan->next_sg == chan->desc->num_sgs)
@@ -566,6 +935,53 @@ static void stm32_dma_start_transfer(struct stm32_dma_chan *chan)
 	sg_req = &chan->desc->sg_req[chan->next_sg];
 	reg = &sg_req->chan_reg;
 
+	/* Clear interrupt status if it is there */
+	status = stm32_dma_irq_status(chan);
+	if (status)
+		stm32_dma_irq_clear(chan, status);
+
+	if (chan->use_mdma) {
+		if (chan->next_sg == 0) {
+			struct stm32_dma_mdma_desc *m_desc;
+
+			m_desc = &sg_req->m_desc;
+			if (chan->desc->cyclic) {
+				/* If one callback is set, it will be called by MDMA driver. */
+				if (vdesc->tx.callback) {
+					m_desc->desc->callback = vdesc->tx.callback;
+					m_desc->desc->callback_param = vdesc->tx.callback_param;
+					vdesc->tx.callback = NULL;
+					vdesc->tx.callback_param = NULL;
+				}
+			}
+		}
+
+		if (chan->mchan.dir == DMA_MEM_TO_DEV) {
+			ret = stm32_dma_dummy_memcpy_xfer(chan);
+			if (ret < 0) {
+				dmaengine_terminate_async(chan->mchan.chan);
+				chan->desc = NULL;
+				return;
+			}
+		} else {
+			reg->dma_scr &= ~STM32_DMA_SCR_TCIE;
+		}
+
+		if (!chan->desc->cyclic) {
+			/*  MDMA already started */
+			if (chan->mchan.dir != DMA_MEM_TO_DEV &&
+			    sg_dma_len(&sg_req->stm32_sgl_req) > chan->mchan.sram_period)
+				reg->dma_scr |= STM32_DMA_SCR_DBM;
+			ret = stm32_dma_mdma_start(chan, sg_req);
+			if (ret < 0) {
+				chan->desc = NULL;
+				return;
+			}
+		}
+	}
+
+	stm32_dma_sg_inc(chan);
+
 	reg->dma_scr &= ~STM32_DMA_SCR_EN;
 	stm32_dma_write(dmadev, STM32_DMA_SCR(chan->id), reg->dma_scr);
 	stm32_dma_write(dmadev, STM32_DMA_SPAR(chan->id), reg->dma_spar);
@@ -574,24 +990,17 @@ static void stm32_dma_start_transfer(struct stm32_dma_chan *chan)
 	stm32_dma_write(dmadev, STM32_DMA_SM1AR(chan->id), reg->dma_sm1ar);
 	stm32_dma_write(dmadev, STM32_DMA_SNDTR(chan->id), reg->dma_sndtr);
 
-	chan->next_sg++;
-
-	/* Clear interrupt status if it is there */
-	status = stm32_dma_irq_status(chan);
-	if (status)
-		stm32_dma_irq_clear(chan, status);
-
 	if (chan->desc->cyclic)
 		stm32_dma_configure_next_sg(chan);
 
 	stm32_dma_dump_reg(chan);
 
 	/* Start DMA */
+	chan->busy = true;
+	chan->status = DMA_IN_PROGRESS;
 	reg->dma_scr |= STM32_DMA_SCR_EN;
 	stm32_dma_write(dmadev, STM32_DMA_SCR(chan->id), reg->dma_scr);
 
-	chan->busy = true;
-
 	dev_dbg(chan2dev(chan), "vchan %pK: started\n", &chan->vchan);
 }
 
@@ -604,41 +1013,137 @@ static void stm32_dma_configure_next_sg(struct stm32_dma_chan *chan)
 	id = chan->id;
 	dma_scr = stm32_dma_read(dmadev, STM32_DMA_SCR(id));
 
-	if (dma_scr & STM32_DMA_SCR_DBM) {
-		if (chan->next_sg == chan->desc->num_sgs)
-			chan->next_sg = 0;
+	sg_req = &chan->desc->sg_req[chan->next_sg];
 
-		sg_req = &chan->desc->sg_req[chan->next_sg];
+	if (dma_scr & STM32_DMA_SCR_CT) {
+		dma_sm0ar = sg_req->chan_reg.dma_sm0ar;
+		stm32_dma_write(dmadev, STM32_DMA_SM0AR(id), dma_sm0ar);
+		dev_dbg(chan2dev(chan), "CT=1 <=> SM0AR: 0x%08x\n",
+			stm32_dma_read(dmadev, STM32_DMA_SM0AR(id)));
+	} else {
+		dma_sm1ar = sg_req->chan_reg.dma_sm1ar;
+		stm32_dma_write(dmadev, STM32_DMA_SM1AR(id), dma_sm1ar);
+		dev_dbg(chan2dev(chan), "CT=0 <=> SM1AR: 0x%08x\n",
+			stm32_dma_read(dmadev, STM32_DMA_SM1AR(id)));
+	}
+}
 
-		if (dma_scr & STM32_DMA_SCR_CT) {
-			dma_sm0ar = sg_req->chan_reg.dma_sm0ar;
-			stm32_dma_write(dmadev, STM32_DMA_SM0AR(id), dma_sm0ar);
-			dev_dbg(chan2dev(chan), "CT=1 <=> SM0AR: 0x%08x\n",
-				stm32_dma_read(dmadev, STM32_DMA_SM0AR(id)));
-		} else {
-			dma_sm1ar = sg_req->chan_reg.dma_sm1ar;
-			stm32_dma_write(dmadev, STM32_DMA_SM1AR(id), dma_sm1ar);
-			dev_dbg(chan2dev(chan), "CT=0 <=> SM1AR: 0x%08x\n",
-				stm32_dma_read(dmadev, STM32_DMA_SM1AR(id)));
-		}
+static void stm32_dma_handle_chan_paused(struct stm32_dma_chan *chan)
+{
+	struct stm32_dma_device *dmadev = stm32_dma_get_dev(chan);
+	u32 dma_scr;
+
+	/*
+	 * Read and store current remaining data items and peripheral/memory addresses to be
+	 * updated on resume
+	 */
+	dma_scr = stm32_dma_read(dmadev, STM32_DMA_SCR(chan->id));
+	/*
+	 * Transfer can be paused while between a previous resume and reconfiguration on transfer
+	 * complete. If transfer is cyclic and CIRC and DBM have been deactivated for resume, need
+	 * to set it here in SCR backup to ensure a good reconfiguration on transfer complete.
+	 */
+	if (chan->desc && chan->desc->cyclic) {
+		if (chan->desc->num_sgs == 1)
+			dma_scr |= STM32_DMA_SCR_CIRC;
+		else
+			dma_scr |= STM32_DMA_SCR_DBM;
+	}
+	chan->chan_reg.dma_scr = dma_scr;
+
+	/*
+	 * Need to temporarily deactivate CIRC/DBM until next Transfer Complete interrupt, otherwise
+	 * on resume NDTR autoreload value will be wrong (lower than the initial period length)
+	 */
+	if (chan->desc && chan->desc->cyclic) {
+		dma_scr &= ~(STM32_DMA_SCR_DBM | STM32_DMA_SCR_CIRC);
+		stm32_dma_write(dmadev, STM32_DMA_SCR(chan->id), dma_scr);
 	}
+
+	chan->chan_reg.dma_sndtr = stm32_dma_read(dmadev, STM32_DMA_SNDTR(chan->id));
+
+	chan->status = DMA_PAUSED;
+
+	dev_dbg(chan2dev(chan), "vchan %pK: paused\n", &chan->vchan);
 }
 
-static void stm32_dma_handle_chan_done(struct stm32_dma_chan *chan)
+static void stm32_dma_post_resume_reconfigure(struct stm32_dma_chan *chan)
 {
-	if (chan->desc) {
-		if (chan->desc->cyclic) {
-			vchan_cyclic_callback(&chan->desc->vdesc);
-			chan->next_sg++;
+	struct stm32_dma_device *dmadev = stm32_dma_get_dev(chan);
+	struct stm32_dma_sg_req *sg_req;
+	u32 dma_scr, status, id;
+
+	id = chan->id;
+	dma_scr = stm32_dma_read(dmadev, STM32_DMA_SCR(id));
+
+	/* Clear interrupt status if it is there */
+	status = stm32_dma_irq_status(chan);
+	if (status)
+		stm32_dma_irq_clear(chan, status);
+
+	if (!chan->next_sg)
+		sg_req = &chan->desc->sg_req[chan->desc->num_sgs - 1];
+	else
+		sg_req = &chan->desc->sg_req[chan->next_sg - 1];
+
+	/* Reconfigure NDTR with the initial value */
+	stm32_dma_write(dmadev, STM32_DMA_SNDTR(chan->id), sg_req->chan_reg.dma_sndtr);
+
+	/* Restore SPAR */
+	stm32_dma_write(dmadev, STM32_DMA_SPAR(id), sg_req->chan_reg.dma_spar);
+
+	/* Restore SM0AR/SM1AR whatever DBM/CT as they may have been modified */
+	stm32_dma_write(dmadev, STM32_DMA_SM0AR(id), sg_req->chan_reg.dma_sm0ar);
+	stm32_dma_write(dmadev, STM32_DMA_SM1AR(id), sg_req->chan_reg.dma_sm1ar);
+
+	/* Reactivate CIRC/DBM if needed */
+	if (chan->chan_reg.dma_scr & STM32_DMA_SCR_DBM) {
+		dma_scr |= STM32_DMA_SCR_DBM;
+		/* Restore CT */
+		if (chan->chan_reg.dma_scr & STM32_DMA_SCR_CT)
+			dma_scr &= ~STM32_DMA_SCR_CT;
+		else
+			dma_scr |= STM32_DMA_SCR_CT;
+	} else if (chan->chan_reg.dma_scr & STM32_DMA_SCR_CIRC) {
+		dma_scr |= STM32_DMA_SCR_CIRC;
+	}
+	stm32_dma_write(dmadev, STM32_DMA_SCR(chan->id), dma_scr);
+
+	stm32_dma_configure_next_sg(chan);
+
+	stm32_dma_dump_reg(chan);
+
+	dma_scr |= STM32_DMA_SCR_EN;
+	stm32_dma_write(dmadev, STM32_DMA_SCR(chan->id), dma_scr);
+
+	dev_dbg(chan2dev(chan), "vchan %pK: reconfigured after pause/resume\n", &chan->vchan);
+}
+
+static void stm32_dma_handle_chan_done(struct stm32_dma_chan *chan, u32 scr)
+{
+	if (!chan->desc)
+		return;
+
+	if (chan->desc->cyclic) {
+		vchan_cyclic_callback(&chan->desc->vdesc);
+		if (chan->use_mdma)
+			return;
+		stm32_dma_sg_inc(chan);
+		/* cyclic while CIRC/DBM disable => post resume reconfiguration needed */
+		if (!(scr & (STM32_DMA_SCR_CIRC | STM32_DMA_SCR_DBM)))
+			stm32_dma_post_resume_reconfigure(chan);
+		else if (scr & STM32_DMA_SCR_DBM)
 			stm32_dma_configure_next_sg(chan);
-		} else {
-			chan->busy = false;
-			if (chan->next_sg == chan->desc->num_sgs) {
-				vchan_cookie_complete(&chan->desc->vdesc);
-				chan->desc = NULL;
-			}
-			stm32_dma_start_transfer(chan);
+	} else {
+		if (chan->use_mdma && chan->mchan.dir != DMA_MEM_TO_DEV)
+			return; /* wait for callback */
+		chan->busy = false;
+		chan->status = DMA_COMPLETE;
+		if (chan->next_sg == chan->desc->num_sgs) {
+			vchan_cookie_complete(&chan->desc->vdesc);
+			chan->desc = NULL;
 		}
+		stm32_dma_start_transfer(chan);
 	}
 }
 
@@ -674,8 +1179,10 @@ static irqreturn_t stm32_dma_chan_irq(int irq, void *devid)
 
 	if (status & STM32_DMA_TCI) {
 		stm32_dma_irq_clear(chan, STM32_DMA_TCI);
-		if (scr & STM32_DMA_SCR_TCIE)
-			stm32_dma_handle_chan_done(chan);
+		if (scr & STM32_DMA_SCR_TCIE) {
+			if (chan->status != DMA_PAUSED)
+				stm32_dma_handle_chan_done(chan, scr);
+		}
 		status &= ~STM32_DMA_TCI;
 	}
 
@@ -701,19 +1208,122 @@ static void stm32_dma_issue_pending(struct dma_chan *c)
 	struct stm32_dma_chan *chan = to_stm32_dma_chan(c);
 	unsigned long flags;
 
-	spin_lock_irqsave(&chan->vchan.lock, flags);
+	if (chan->use_mdma)
+		spin_lock_irqsave_nested(&chan->vchan.lock, flags, SINGLE_DEPTH_NESTING);
+	else
+		spin_lock_irqsave(&chan->vchan.lock, flags);
+
 	if (vchan_issue_pending(&chan->vchan) && !chan->desc && !chan->busy) {
 		dev_dbg(chan2dev(chan), "vchan %pK: issued\n", &chan->vchan);
 		stm32_dma_start_transfer(chan);
-
 	}
+
 	spin_unlock_irqrestore(&chan->vchan.lock, flags);
 }
 
+static int stm32_dma_pause(struct dma_chan *c)
+{
+	struct stm32_dma_chan *chan = to_stm32_dma_chan(c);
+	unsigned long flags;
+	int ret;
+
+	if (chan->status != DMA_IN_PROGRESS || chan->use_mdma)
+		return -EPERM;
+
+	spin_lock_irqsave(&chan->vchan.lock, flags);
+
+	ret = stm32_dma_disable_chan(chan);
+	if (!ret)
+		stm32_dma_handle_chan_paused(chan);
+
+	spin_unlock_irqrestore(&chan->vchan.lock, flags);
+
+	return ret;
+}
+
+static int stm32_dma_resume(struct dma_chan *c)
+{
+	struct stm32_dma_chan *chan = to_stm32_dma_chan(c);
+	struct stm32_dma_device *dmadev = stm32_dma_get_dev(chan);
+	struct stm32_dma_chan_reg chan_reg = chan->chan_reg;
+	u32 id = chan->id, scr, ndtr, offset, spar, sm0ar, sm1ar;
+	struct stm32_dma_sg_req *sg_req;
+	unsigned long flags;
+
+	if (chan->status != DMA_PAUSED || chan->use_mdma)
+		return -EPERM;
+
+	scr = stm32_dma_read(dmadev, STM32_DMA_SCR(id));
+	if (WARN_ON(scr & STM32_DMA_SCR_EN))
+		return -EPERM;
+
+	spin_lock_irqsave(&chan->vchan.lock, flags);
+
+	/* sg_reg[prev_sg] contains original ndtr, sm0ar and sm1ar before pausing the transfer */
+	if (!chan->next_sg)
+		sg_req = &chan->desc->sg_req[chan->desc->num_sgs - 1];
+	else
+		sg_req = &chan->desc->sg_req[chan->next_sg - 1];
+
+	ndtr = sg_req->chan_reg.dma_sndtr;
+	offset = (ndtr - chan_reg.dma_sndtr) << STM32_DMA_SCR_PSIZE_GET(chan_reg.dma_scr);
+	spar = sg_req->chan_reg.dma_spar;
+	sm0ar = sg_req->chan_reg.dma_sm0ar;
+	sm1ar = sg_req->chan_reg.dma_sm1ar;
+
+	/*
+	 * The peripheral and/or memory addresses have to be updated in order to adjust the
+	 * address pointers. Need to check increment.
+	 */
+	if (chan_reg.dma_scr & STM32_DMA_SCR_PINC)
+		stm32_dma_write(dmadev, STM32_DMA_SPAR(id), spar + offset);
+	else
+		stm32_dma_write(dmadev, STM32_DMA_SPAR(id), spar);
+
+	if (!(chan_reg.dma_scr & STM32_DMA_SCR_MINC))
+		offset = 0;
+
+	/*
+	 * In case of DBM, the current target could be SM1AR.
+	 * Need to temporarily deactivate CIRC/DBM to finish the current transfer, so
+	 * SM0AR becomes the current target and must be updated with SM1AR + offset if CT=1.
+	 */
+	if ((chan_reg.dma_scr & STM32_DMA_SCR_DBM) && (chan_reg.dma_scr & STM32_DMA_SCR_CT))
+		stm32_dma_write(dmadev, STM32_DMA_SM1AR(id), sm1ar + offset);
+	else
+		stm32_dma_write(dmadev, STM32_DMA_SM0AR(id), sm0ar + offset);
+
+	/* NDTR must be restored otherwise internal HW counter won't be correctly reset */
+	stm32_dma_write(dmadev, STM32_DMA_SNDTR(id), chan_reg.dma_sndtr);
+
+	/*
+	 * Need to temporarily deactivate CIRC/DBM until next Transfer Complete interrupt,
+	 * otherwise NDTR autoreload value will be wrong (lower than the initial period length)
+	 */
+	if (chan_reg.dma_scr & (STM32_DMA_SCR_CIRC | STM32_DMA_SCR_DBM))
+		chan_reg.dma_scr &= ~(STM32_DMA_SCR_CIRC | STM32_DMA_SCR_DBM);
+
+	if (chan_reg.dma_scr & STM32_DMA_SCR_DBM)
+		stm32_dma_configure_next_sg(chan);
+
+	stm32_dma_dump_reg(chan);
+
+	/* The stream may then be re-enabled to restart transfer from the point it was stopped */
+	chan->status = DMA_IN_PROGRESS;
+	chan_reg.dma_scr |= STM32_DMA_SCR_EN;
+	stm32_dma_write(dmadev, STM32_DMA_SCR(id), chan_reg.dma_scr);
+
+	spin_unlock_irqrestore(&chan->vchan.lock, flags);
+
+	dev_dbg(chan2dev(chan), "vchan %pK: resumed\n", &chan->vchan);
+
+	return 0;
+}
+
 static int stm32_dma_set_xfer_param(struct stm32_dma_chan *chan,
 				    enum dma_transfer_direction direction,
 				    enum dma_slave_buswidth *buswidth,
-				    u32 buf_len, dma_addr_t buf_addr)
+				    u32 buf_len, u64 buf_addr)
 {
 	enum dma_slave_buswidth src_addr_width, dst_addr_width;
 	int src_bus_width, dst_bus_width;
@@ -862,6 +1472,151 @@ static void stm32_dma_clear_reg(struct stm32_dma_chan_reg *regs)
 	memset(regs, 0, sizeof(struct stm32_dma_chan_reg));
 }
 
+static int stm32_dma_mdma_prep_slave_sg(struct stm32_dma_chan *chan,
+					struct scatterlist *sgl, u32 sg_len,
+					struct stm32_dma_desc *desc, unsigned long flags)
+{
+	struct stm32_dma_device *dmadev = stm32_dma_get_dev(chan);
+	struct stm32_dma_mdma *mchan = &chan->mchan;
+	struct scatterlist *sg, *m_sg;
+	dma_addr_t dma_buf;
+	u32 len, num_sgs, sram_period;
+	int i, j, ret;
+
+	desc->dma_buf_cpu = gen_pool_dma_alloc(dmadev->sram_pool, chan->sram_size, &desc->dma_buf);
+	if (!desc->dma_buf_cpu)
+		return -ENOMEM;
+	desc->dma_buf_size = chan->sram_size;
+
+	sram_period = chan->sram_size / 2;
+
+	for_each_sg(sgl, sg, sg_len, i) {
+		struct stm32_dma_mdma_desc *m_desc = &desc->sg_req[i].m_desc;
+		struct dma_slave_config config;
+
+		len = sg_dma_len(sg);
+		desc->sg_req[i].stm32_sgl_req = *sg;
+		num_sgs = 1;
+
+		if (mchan->dir == DMA_MEM_TO_DEV) {
+			if (len > chan->sram_size) {
+				dev_err(chan2dev(chan),
+					"max buf size = %d bytes\n", chan->sram_size);
+				ret = -EINVAL;
+				goto free_alloc;
+			}
+		} else {
+			/*
+			 * Build new sg for MDMA transfer
+			 * Scatter DMA Req into several SDRAM transfer
+			 */
+			if (len > sram_period)
+				num_sgs = len / sram_period;
+		}
+
+		ret = sg_alloc_table(&m_desc->sgt, num_sgs, GFP_ATOMIC);
+		if (ret) {
+			dev_err(chan2dev(chan), "MDMA sg table alloc failed\n");
+			ret = -ENOMEM;
+			goto err;
+		}
+
+		dma_buf = sg_dma_address(sg);
+		for_each_sg(m_desc->sgt.sgl, m_sg, num_sgs, j) {
+			size_t bytes = min_t(size_t, len, sram_period);
+
+			sg_dma_address(m_sg) = dma_buf;
+			sg_dma_len(m_sg) = bytes;
+			dma_buf += bytes;
+			len -= bytes;
+		}
+
+		/* Configure MDMA channel */
+		memset(&config, 0, sizeof(config));
+		if (mchan->dir == DMA_MEM_TO_DEV)
+			config.dst_addr = desc->dma_buf;
+		else
+			config.src_addr = desc->dma_buf;
+
+		ret = dmaengine_slave_config(mchan->chan, &config);
+		if (ret < 0)
+			goto err;
+
+		/* Prepare MDMA descriptor */
+		m_desc->desc = dmaengine_prep_slave_sg(mchan->chan,
+						       m_desc->sgt.sgl, m_desc->sgt.nents,
+						       mchan->dir, DMA_PREP_INTERRUPT);
+
+		if (!m_desc->desc) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		if (flags & DMA_CTRL_REUSE)
+			dmaengine_desc_set_reuse(m_desc->desc);
+
+		if (mchan->dir != DMA_MEM_TO_DEV) {
+			m_desc->desc->callback_result = stm32_mdma_chan_complete;
+			m_desc->desc->callback_param = chan;
+			INIT_WORK(&chan->mdma_work, stm32_mdma_chan_complete_worker);
+		}
+	}
+
+	chan->mchan.sram_buf = desc->dma_buf;
+	chan->mchan.sram_period = sram_period;
+
+	return 0;
+
+err:
+	for (j = 0; j < i; j++) {
+		struct stm32_dma_mdma_desc *m_desc = &desc->sg_req[j].m_desc;
+
+		m_desc->desc = NULL;
+		sg_free_table(&desc->sg_req[j].m_desc.sgt);
+	}
+free_alloc:
+	gen_pool_free(dmadev->sram_pool, (unsigned long)desc->dma_buf_cpu, desc->dma_buf_size);
+	return ret;
+}
+
+static int stm32_dma_setup_sg_requests(struct stm32_dma_chan *chan,
+				       struct scatterlist *sgl, unsigned int sg_len,
+				       enum dma_transfer_direction direction,
+				       struct stm32_dma_desc *desc)
+{
+	struct scatterlist *sg;
+	u32 nb_data_items;
+	int i, ret;
+	enum dma_slave_buswidth buswidth;
+
+	for_each_sg(sgl, sg, sg_len, i) {
+		ret = stm32_dma_set_xfer_param(chan, direction, &buswidth, sg_dma_len(sg),
+					       (u64)sg_dma_address(sg));
+		if (ret < 0)
+			return ret;
+
+		nb_data_items = sg_dma_len(sg) / buswidth;
+		if (nb_data_items > STM32_DMA_ALIGNED_MAX_DATA_ITEMS) {
+			dev_err(chan2dev(chan), "nb items not supported\n");
+			return -EINVAL;
+		}
+
+		stm32_dma_clear_reg(&desc->sg_req[i].chan_reg);
+		desc->sg_req[i].chan_reg.dma_scr = chan->chan_reg.dma_scr;
+		desc->sg_req[i].chan_reg.dma_sfcr = chan->chan_reg.dma_sfcr;
+		desc->sg_req[i].chan_reg.dma_spar = chan->chan_reg.dma_spar;
+		desc->sg_req[i].chan_reg.dma_sm0ar = sg_dma_address(sg);
+		desc->sg_req[i].chan_reg.dma_sm1ar = sg_dma_address(sg);
+		if (chan->use_mdma)
+			desc->sg_req[i].chan_reg.dma_sm1ar += chan->mchan.sram_period;
+		desc->sg_req[i].chan_reg.dma_sndtr = nb_data_items;
+	}
+
+	desc->num_sgs = sg_len;
+
+	return 0;
+}
+
 static struct dma_async_tx_descriptor *stm32_dma_prep_slave_sg(
 	struct dma_chan *c, struct scatterlist *sgl,
 	u32 sg_len, enum dma_transfer_direction direction,
@@ -869,9 +1624,6 @@ static struct dma_async_tx_descriptor *stm32_dma_prep_slave_sg(
 {
 	struct stm32_dma_chan *chan = to_stm32_dma_chan(c);
 	struct stm32_dma_desc *desc;
-	struct scatterlist *sg;
-	enum dma_slave_buswidth buswidth;
-	u32 nb_data_items;
 	int i, ret;
 
 	if (!chan->config_init) {
@@ -894,49 +1646,130 @@ static struct dma_async_tx_descriptor *stm32_dma_prep_slave_sg(
 	else
 		chan->chan_reg.dma_scr &= ~STM32_DMA_SCR_PFCTRL;
 
-	for_each_sg(sgl, sg, sg_len, i) {
-		ret = stm32_dma_set_xfer_param(chan, direction, &buswidth,
-					       sg_dma_len(sg),
-					       sg_dma_address(sg));
+	if (chan->use_mdma) {
+		struct sg_table new_sgt;
+		struct scatterlist *s, *_sgl;
+
+		chan->mchan.dir = direction;
+		ret = stm32_dma_mdma_prep_slave_sg(chan, sgl, sg_len, desc, flags);
 		if (ret < 0)
-			goto err;
+			return NULL;
 
-		desc->sg_req[i].len = sg_dma_len(sg);
+		ret = sg_alloc_table(&new_sgt, sg_len, GFP_ATOMIC);
+		if (ret)
+			dev_err(chan2dev(chan), "DMA sg table alloc failed\n");
 
-		nb_data_items = desc->sg_req[i].len / buswidth;
-		if (nb_data_items > STM32_DMA_ALIGNED_MAX_DATA_ITEMS) {
-			dev_err(chan2dev(chan), "nb items not supported\n");
-			goto err;
+		for_each_sg(new_sgt.sgl, s, sg_len, i) {
+			_sgl = sgl;
+			sg_dma_len(s) = min(sg_dma_len(_sgl), chan->mchan.sram_period);
+			s->dma_address = chan->mchan.sram_buf;
+			_sgl = sg_next(_sgl);
 		}
 
-		stm32_dma_clear_reg(&desc->sg_req[i].chan_reg);
-		desc->sg_req[i].chan_reg.dma_scr = chan->chan_reg.dma_scr;
-		desc->sg_req[i].chan_reg.dma_sfcr = chan->chan_reg.dma_sfcr;
-		desc->sg_req[i].chan_reg.dma_spar = chan->chan_reg.dma_spar;
-		desc->sg_req[i].chan_reg.dma_sm0ar = sg_dma_address(sg);
-		desc->sg_req[i].chan_reg.dma_sm1ar = sg_dma_address(sg);
-		desc->sg_req[i].chan_reg.dma_sndtr = nb_data_items;
+		ret = stm32_dma_setup_sg_requests(chan, new_sgt.sgl, sg_len, direction, desc);
+		sg_free_table(&new_sgt);
+		if (ret < 0)
+			goto err;
+	} else {
+		/* Prepare a normal DMA transfer */
+		ret = stm32_dma_setup_sg_requests(chan, sgl, sg_len, direction, desc);
+		if (ret < 0)
+			goto err;
 	}
 
-	desc->num_sgs = sg_len;
 	desc->cyclic = false;
 
 	return vchan_tx_prep(&chan->vchan, &desc->vdesc, flags);
-
 err:
+	if (chan->use_mdma) {
+		struct stm32_dma_device *dmadev = stm32_dma_get_dev(chan);
+
+		for (i = 0; i < sg_len; i++)
+			sg_free_table(&desc->sg_req[i].m_desc.sgt);
+
+		gen_pool_free(dmadev->sram_pool, (unsigned long)desc->dma_buf_cpu,
+			      desc->dma_buf_size);
+	}
 	kfree(desc);
 	return NULL;
 }
 
+static int stm32_dma_mdma_prep_dma_cyclic(struct stm32_dma_chan *chan,
+					  dma_addr_t buf_addr, size_t buf_len,
+					  size_t period_len, struct stm32_dma_desc *desc)
+{
+	struct stm32_dma_device *dmadev = stm32_dma_get_dev(chan);
+	struct stm32_dma_mdma *mchan = &chan->mchan;
+	struct stm32_dma_mdma_desc *m_desc = &desc->sg_req[0].m_desc;
+	struct dma_slave_config config;
+	int ret;
+
+	chan->sram_size = ALIGN(period_len, STM32_DMA_SRAM_GRANULARITY);
+	desc->dma_buf_cpu = gen_pool_dma_alloc(dmadev->sram_pool, 2 * chan->sram_size,
+					       &desc->dma_buf);
+	if (!desc->dma_buf_cpu)
+		return -ENOMEM;
+	desc->dma_buf_size = 2 * chan->sram_size;
+
+	memset(&config, 0, sizeof(config));
+
+	/* Configure MDMA channel */
+	if (chan->mchan.dir == DMA_MEM_TO_DEV)
+		config.dst_addr = desc->dma_buf;
+	else
+		config.src_addr = desc->dma_buf;
+	ret = dmaengine_slave_config(mchan->chan, &config);
+	if (ret < 0)
+		goto err;
+
+	/* Prepare MDMA descriptor */
+	m_desc->desc = dmaengine_prep_dma_cyclic(mchan->chan, buf_addr, buf_len,
+						 period_len, chan->mchan.dir,
+						 DMA_PREP_INTERRUPT);
+
+	if (!m_desc->desc) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	ret = dma_submit_error(dmaengine_submit(m_desc->desc));
+	if (ret < 0) {
+		dev_err(chan2dev(chan), "MDMA submit failed\n");
+		goto err;
+	}
+
+	dma_async_issue_pending(mchan->chan);
+
+	/*
+	 * In case of M2D transfer, we have to generate dummy DMA transfer to
+	 * copy 1 period of data into SRAM
+	 */
+	if (chan->mchan.dir == DMA_MEM_TO_DEV) {
+		ret = stm32_dma_dummy_memcpy_xfer(chan);
+		if (ret < 0) {
+			dev_err(chan2dev(chan), "stm32_dma_dummy_memcpy_xfer failed\n");
+			dmaengine_terminate_async(mchan->chan);
+			goto err;
+		}
+	}
+
+	return 0;
+err:
+	gen_pool_free(dmadev->sram_pool, (unsigned long)desc->dma_buf_cpu, desc->dma_buf_size);
+	return ret;
+}
+
 static struct dma_async_tx_descriptor *stm32_dma_prep_dma_cyclic(
 	struct dma_chan *c, dma_addr_t buf_addr, size_t buf_len,
 	size_t period_len, enum dma_transfer_direction direction,
 	unsigned long flags)
 {
 	struct stm32_dma_chan *chan = to_stm32_dma_chan(c);
+	struct stm32_dma_chan_reg *chan_reg = &chan->chan_reg;
 	struct stm32_dma_desc *desc;
 	enum dma_slave_buswidth buswidth;
 	u32 num_periods, nb_data_items;
+	dma_addr_t dma_buf = 0;
 	int i, ret;
 
 	if (!buf_len || !period_len) {
@@ -965,8 +1798,7 @@ static struct dma_async_tx_descriptor *stm32_dma_prep_dma_cyclic(
 		return NULL;
 	}
 
-	ret = stm32_dma_set_xfer_param(chan, direction, &buswidth, period_len,
-				       buf_addr);
+	ret = stm32_dma_set_xfer_param(chan, direction, &buswidth, period_len, (u64)buf_addr);
 	if (ret < 0)
 		return NULL;
 
@@ -977,36 +1809,57 @@ static struct dma_async_tx_descriptor *stm32_dma_prep_dma_cyclic(
 	}
 
 	/*  Enable Circular mode or double buffer mode */
-	if (buf_len == period_len)
+	if (buf_len == period_len) {
 		chan->chan_reg.dma_scr |= STM32_DMA_SCR_CIRC;
-	else
+	} else {
 		chan->chan_reg.dma_scr |= STM32_DMA_SCR_DBM;
+		chan->chan_reg.dma_scr &= ~STM32_DMA_SCR_CT;
+	}
 
 	/* Clear periph ctrl if client set it */
 	chan->chan_reg.dma_scr &= ~STM32_DMA_SCR_PFCTRL;
 
-	num_periods = buf_len / period_len;
+	if (chan->use_mdma)
+		num_periods = 1;
+	else
+		num_periods = buf_len / period_len;
 
 	desc = kzalloc(struct_size(desc, sg_req, num_periods), GFP_NOWAIT);
 	if (!desc)
 		return NULL;
 
-	for (i = 0; i < num_periods; i++) {
-		desc->sg_req[i].len = period_len;
+	desc->num_sgs = num_periods;
+	desc->cyclic = true;
+
+	if (chan->use_mdma) {
+		chan->mchan.dir = direction;
 
+		ret = stm32_dma_mdma_prep_dma_cyclic(chan, buf_addr, buf_len, period_len, desc);
+		if (ret < 0)
+			return NULL;
+		dma_buf = desc->dma_buf;
+	} else {
+		dma_buf = buf_addr;
+	}
+
+	for (i = 0; i < num_periods; i++) {
+		sg_dma_len(&desc->sg_req[i].stm32_sgl_req) = period_len;
+		sg_dma_address(&desc->sg_req[i].stm32_sgl_req) = dma_buf;
 		stm32_dma_clear_reg(&desc->sg_req[i].chan_reg);
-		desc->sg_req[i].chan_reg.dma_scr = chan->chan_reg.dma_scr;
-		desc->sg_req[i].chan_reg.dma_sfcr = chan->chan_reg.dma_sfcr;
-		desc->sg_req[i].chan_reg.dma_spar = chan->chan_reg.dma_spar;
-		desc->sg_req[i].chan_reg.dma_sm0ar = buf_addr;
-		desc->sg_req[i].chan_reg.dma_sm1ar = buf_addr;
+		desc->sg_req[i].chan_reg.dma_scr = chan_reg->dma_scr;
+		desc->sg_req[i].chan_reg.dma_sfcr = chan_reg->dma_sfcr;
+		desc->sg_req[i].chan_reg.dma_spar = chan_reg->dma_spar;
+		if (chan->use_mdma) {
+			desc->sg_req[i].chan_reg.dma_sm0ar = desc->dma_buf;
+			desc->sg_req[i].chan_reg.dma_sm1ar = desc->dma_buf + chan->sram_size;
+		} else {
+			desc->sg_req[i].chan_reg.dma_sm0ar = dma_buf;
+			desc->sg_req[i].chan_reg.dma_sm1ar = dma_buf;
+			dma_buf += period_len;
+		}
 		desc->sg_req[i].chan_reg.dma_sndtr = nb_data_items;
-		buf_addr += period_len;
 	}
 
-	desc->num_sgs = num_periods;
-	desc->cyclic = true;
-
 	return vchan_tx_prep(&chan->vchan, &desc->vdesc, flags);
 }
 
@@ -1047,13 +1900,13 @@ static struct dma_async_tx_descriptor *stm32_dma_prep_dma_memcpy(
 			STM32_DMA_SCR_PINC |
 			STM32_DMA_SCR_TCIE |
 			STM32_DMA_SCR_TEIE;
-		desc->sg_req[i].chan_reg.dma_sfcr |= STM32_DMA_SFCR_MASK;
+		desc->sg_req[i].chan_reg.dma_sfcr &= ~STM32_DMA_SFCR_MASK;
 		desc->sg_req[i].chan_reg.dma_sfcr |=
 			STM32_DMA_SFCR_FTH(threshold);
 		desc->sg_req[i].chan_reg.dma_spar = src + offset;
 		desc->sg_req[i].chan_reg.dma_sm0ar = dest + offset;
 		desc->sg_req[i].chan_reg.dma_sndtr = xfer_count;
-		desc->sg_req[i].len = xfer_count;
+		sg_dma_len(&desc->sg_req[i].stm32_sgl_req) = xfer_count;
 	}
 
 	desc->num_sgs = num_sgs;
@@ -1062,18 +1915,6 @@ static struct dma_async_tx_descriptor *stm32_dma_prep_dma_memcpy(
 	return vchan_tx_prep(&chan->vchan, &desc->vdesc, flags);
 }
 
-static u32 stm32_dma_get_remaining_bytes(struct stm32_dma_chan *chan)
-{
-	u32 dma_scr, width, ndtr;
-	struct stm32_dma_device *dmadev = stm32_dma_get_dev(chan);
-
-	dma_scr = stm32_dma_read(dmadev, STM32_DMA_SCR(chan->id));
-	width = STM32_DMA_SCR_PSIZE_GET(dma_scr);
-	ndtr = stm32_dma_read(dmadev, STM32_DMA_SNDTR(chan->id));
-
-	return ndtr << width;
-}
-
 /**
  * stm32_dma_is_current_sg - check that expected sg_req is currently transferred
  * @chan: dma channel
@@ -1090,24 +1931,36 @@ static bool stm32_dma_is_current_sg(struct stm32_dma_chan *chan)
 {
 	struct stm32_dma_device *dmadev = stm32_dma_get_dev(chan);
 	struct stm32_dma_sg_req *sg_req;
-	u32 dma_scr, dma_smar, id;
+	u32 dma_scr, dma_smar, id, period_len;
 
 	id = chan->id;
 	dma_scr = stm32_dma_read(dmadev, STM32_DMA_SCR(id));
 
+	/* In cyclic CIRC but not DBM, CT is not used */
 	if (!(dma_scr & STM32_DMA_SCR_DBM))
 		return true;
 
 	sg_req = &chan->desc->sg_req[chan->next_sg];
+	period_len = sg_dma_len(&sg_req->stm32_sgl_req);
 
+	/* DBM - take care of a previous pause/resume not yet post reconfigured */
 	if (dma_scr & STM32_DMA_SCR_CT) {
 		dma_smar = stm32_dma_read(dmadev, STM32_DMA_SM0AR(id));
-		return (dma_smar == sg_req->chan_reg.dma_sm0ar);
+		/*
+		 * If transfer has been pause/resumed,
+		 * SM0AR is in the range of [SM0AR:SM0AR+period_len]
+		 */
+		return (dma_smar >= sg_req->chan_reg.dma_sm0ar &&
+			dma_smar < sg_req->chan_reg.dma_sm0ar + period_len);
 	}
 
 	dma_smar = stm32_dma_read(dmadev, STM32_DMA_SM1AR(id));
-
-	return (dma_smar == sg_req->chan_reg.dma_sm1ar);
+	/*
+	 * If transfer has been pause/resumed,
+	 * SM1AR is in the range of [SM1AR:SM1AR+period_len]
+	 */
+	return (dma_smar >= sg_req->chan_reg.dma_sm1ar &&
+		dma_smar < sg_req->chan_reg.dma_sm1ar + period_len);
 }
 
 static size_t stm32_dma_desc_residue(struct stm32_dma_chan *chan,
@@ -1120,6 +1973,10 @@ static size_t stm32_dma_desc_residue(struct stm32_dma_chan *chan,
 	struct stm32_dma_sg_req *sg_req = &chan->desc->sg_req[chan->next_sg];
 	int i;
 
+	/* Drain case */
+	if (chan->residue_after_drain)
+		return chan->residue_after_drain;
+
 	/*
 	 * Calculate the residue means compute the descriptors
 	 * information:
@@ -1147,11 +2004,11 @@ static size_t stm32_dma_desc_residue(struct stm32_dma_chan *chan,
 
 	residue = stm32_dma_get_remaining_bytes(chan);
 
-	if (!stm32_dma_is_current_sg(chan)) {
+	if (chan->desc->cyclic && !stm32_dma_is_current_sg(chan)) {
 		n_sg++;
 		if (n_sg == chan->desc->num_sgs)
 			n_sg = 0;
-		residue = sg_req->len;
+		residue = sg_dma_len(&sg_req->stm32_sgl_req);
 	}
 
 	/*
@@ -1163,7 +2020,7 @@ static size_t stm32_dma_desc_residue(struct stm32_dma_chan *chan,
 	 */
 	if (!chan->desc->cyclic || n_sg != 0)
 		for (i = n_sg; i < desc->num_sgs; i++)
-			residue += desc->sg_req[i].len;
+			residue += sg_dma_len(&desc->sg_req[i].stm32_sgl_req);
 
 	if (!chan->mem_burst)
 		return residue;
@@ -1181,13 +2038,29 @@ static enum dma_status stm32_dma_tx_status(struct dma_chan *c,
 					   struct dma_tx_state *state)
 {
 	struct stm32_dma_chan *chan = to_stm32_dma_chan(c);
+	struct stm32_dma_mdma *mchan = &chan->mchan;
 	struct virt_dma_desc *vdesc;
 	enum dma_status status;
 	unsigned long flags;
 	u32 residue = 0;
 
+	/*
+	 * When DMA/MDMA chain is used, we return the status of MDMA in cyclic
+	 * mode and for D2M transfer in sg mode in order to return the correct
+	 * residue if any
+	 */
+	if (chan->desc && chan->use_mdma &&
+	    (mchan->dir != DMA_MEM_TO_DEV || chan->desc->cyclic) &&
+	    !chan->residue_after_drain)
+		return dmaengine_tx_status(mchan->chan, mchan->chan->cookie, state);
+
 	status = dma_cookie_status(c, cookie, state);
-	if (status == DMA_COMPLETE || !state)
+	if (status == DMA_COMPLETE)
+		return status;
+
+	status = chan->status;
+
+	if (!state)
 		return status;
 
 	spin_lock_irqsave(&chan->vchan.lock, flags);
@@ -1244,29 +2117,50 @@ static void stm32_dma_free_chan_resources(struct dma_chan *c)
 	vchan_free_chan_resources(to_virt_chan(c));
 	stm32_dma_clear_reg(&chan->chan_reg);
 	chan->threshold = 0;
+	chan->use_mdma = false;
+	chan->sram_size = 0;
 }
 
 static void stm32_dma_desc_free(struct virt_dma_desc *vdesc)
 {
-	kfree(container_of(vdesc, struct stm32_dma_desc, vdesc));
+	struct stm32_dma_desc *desc = to_stm32_dma_desc(vdesc);
+	struct stm32_dma_chan *chan = to_stm32_dma_chan(vdesc->tx.chan);
+	struct stm32_dma_device *dmadev = stm32_dma_get_dev(chan);
+	int i;
+
+	if (chan->use_mdma) {
+		struct stm32_dma_mdma_desc *m_desc;
+
+		for (i = 0; i < desc->num_sgs; i++) {
+			m_desc = &desc->sg_req[i].m_desc;
+			if (dmaengine_desc_test_reuse(&vdesc->tx))
+				dmaengine_desc_free(m_desc->desc);
+			m_desc->desc = NULL;
+			sg_free_table(&m_desc->sgt);
+		}
+
+		gen_pool_free(dmadev->sram_pool, (unsigned long)desc->dma_buf_cpu,
+			      desc->dma_buf_size);
+	}
+
+	kfree(desc);
 }
 
 static void stm32_dma_set_config(struct stm32_dma_chan *chan,
 				 struct stm32_dma_cfg *cfg)
 {
 	stm32_dma_clear_reg(&chan->chan_reg);
-
 	chan->chan_reg.dma_scr = cfg->stream_config & STM32_DMA_SCR_CFG_MASK;
 	chan->chan_reg.dma_scr |= STM32_DMA_SCR_REQ(cfg->request_line);
-
-	/* Enable Interrupts  */
 	chan->chan_reg.dma_scr |= STM32_DMA_SCR_TEIE | STM32_DMA_SCR_TCIE;
-
 	chan->threshold = STM32_DMA_THRESHOLD_FTR_GET(cfg->features);
 	if (STM32_DMA_DIRECT_MODE_GET(cfg->features))
 		chan->threshold = STM32_DMA_FIFO_THRESHOLD_NONE;
 	if (STM32_DMA_ALT_ACK_MODE_GET(cfg->features))
 		chan->chan_reg.dma_scr |= STM32_DMA_SCR_TRBUFF;
+	chan->use_mdma = STM32_DMA_MDMA_CHAIN_FTR_GET(cfg->features);
+	chan->sram_size = (1 << STM32_DMA_MDMA_SRAM_SIZE_GET(cfg->features)) *
+			  STM32_DMA_SRAM_GRANULARITY;
 }
 
 static struct dma_chan *stm32_dma_of_xlate(struct of_phandle_args *dma_spec,
@@ -1304,6 +2198,9 @@ static struct dma_chan *stm32_dma_of_xlate(struct of_phandle_args *dma_spec,
 
 	stm32_dma_set_config(chan, &cfg);
 
+	if (!dmadev->sram_pool || !chan->mchan.chan)
+		chan->use_mdma = 0;
+
 	return c;
 }
 
@@ -1316,11 +2213,13 @@ MODULE_DEVICE_TABLE(of, stm32_dma_of_match);
 static int stm32_dma_probe(struct platform_device *pdev)
 {
 	struct stm32_dma_chan *chan;
+	struct stm32_dma_mdma *mchan;
 	struct stm32_dma_device *dmadev;
 	struct dma_device *dd;
 	const struct of_device_id *match;
 	struct resource *res;
 	struct reset_control *rst;
+	char name[4];
 	int i, ret;
 
 	match = of_match_device(stm32_dma_of_match, &pdev->dev);
@@ -1364,6 +2263,13 @@ static int stm32_dma_probe(struct platform_device *pdev)
 		reset_control_deassert(rst);
 	}
 
+	dmadev->sram_pool = of_gen_pool_get(pdev->dev.of_node, "sram", 0);
+	if (!dmadev->sram_pool)
+		dev_info(&pdev->dev, "no dma pool: can't use MDMA: %d\n", ret);
+	else
+		dev_dbg(&pdev->dev,
+			"SRAM pool: %zu KiB\n", gen_pool_size(dmadev->sram_pool) / 1024);
+
 	dma_set_max_seg_size(&pdev->dev, STM32_DMA_ALIGNED_MAX_DATA_ITEMS);
 
 	dma_cap_set(DMA_SLAVE, dd->cap_mask);
@@ -1375,7 +2281,10 @@ static int stm32_dma_probe(struct platform_device *pdev)
 	dd->device_issue_pending = stm32_dma_issue_pending;
 	dd->device_prep_slave_sg = stm32_dma_prep_slave_sg;
 	dd->device_prep_dma_cyclic = stm32_dma_prep_dma_cyclic;
+	dd->device_caps = stm32_dma_slave_caps;
 	dd->device_config = stm32_dma_slave_config;
+	dd->device_pause = stm32_dma_pause;
+	dd->device_resume = stm32_dma_resume;
 	dd->device_terminate_all = stm32_dma_terminate_all;
 	dd->device_synchronize = stm32_dma_synchronize;
 	dd->src_addr_widths = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |
@@ -1403,11 +2312,39 @@ static int stm32_dma_probe(struct platform_device *pdev)
 		chan->id = i;
 		chan->vchan.desc_free = stm32_dma_desc_free;
 		vchan_init(&chan->vchan, dd);
+
+		mchan = &chan->mchan;
+		if (dmadev->sram_pool) {
+			snprintf(name, sizeof(name), "ch%d", chan->id);
+			mchan->chan = dma_request_chan(dd->dev, name);
+			if (IS_ERR(mchan->chan)) {
+				ret = PTR_ERR(mchan->chan);
+				mchan->chan = NULL;
+				if (ret == -EPROBE_DEFER)
+					goto err_dma;
+
+				dev_info(&pdev->dev, "can't request MDMA chan for %s\n", name);
+			} else {
+				/*
+				 * Allocate workqueue per channel in case of MDMA/DMA chaining, to
+				 * avoid deadlock with MDMA callback stm32_mdma_chan_complete() when
+				 * MDMA interrupt handler is executed in a thread (which is the
+				 * case in Linux-RT kernel or if force_irqthreads is set).
+				 */
+				chan->mdma_wq = alloc_ordered_workqueue("dma_work-%s", 0, name);
+				if (!chan->mdma_wq) {
+					dma_release_channel(mchan->chan);
+					mchan->chan = NULL;
+					dev_warn(&pdev->dev,
+						 "can't alloc MDMA workqueue for %s\n", name);
+				}
+			}
+		}
 	}
 
 	ret = dma_async_device_register(dd);
 	if (ret)
-		goto clk_free;
+		goto err_dma;
 
 	for (i = 0; i < STM32_DMA_MAX_CHANNELS; i++) {
 		chan = &dmadev->chan[i];
@@ -1448,6 +2385,10 @@ static int stm32_dma_probe(struct platform_device *pdev)
 
 err_unregister:
 	dma_async_device_unregister(dd);
+err_dma:
+	for (i = 0; i < STM32_DMA_MAX_CHANNELS; i++)
+		if (dmadev->chan[i].mchan.chan)
+			dma_release_channel(dmadev->chan[i].mchan.chan);
 clk_free:
 	clk_disable_unprepare(dmadev->clk);
 
@@ -1480,7 +2421,7 @@ static int stm32_dma_runtime_resume(struct device *dev)
 #endif
 
 #ifdef CONFIG_PM_SLEEP
-static int stm32_dma_suspend(struct device *dev)
+static int stm32_dma_pm_suspend(struct device *dev)
 {
 	struct stm32_dma_device *dmadev = dev_get_drvdata(dev);
 	int id, ret, scr;
@@ -1504,14 +2445,14 @@ static int stm32_dma_suspend(struct device *dev)
 	return 0;
 }
 
-static int stm32_dma_resume(struct device *dev)
+static int stm32_dma_pm_resume(struct device *dev)
 {
 	return pm_runtime_force_resume(dev);
 }
 #endif
 
 static const struct dev_pm_ops stm32_dma_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(stm32_dma_suspend, stm32_dma_resume)
+	SET_SYSTEM_SLEEP_PM_OPS(stm32_dma_pm_suspend, stm32_dma_pm_resume)
 	SET_RUNTIME_PM_OPS(stm32_dma_runtime_suspend,
 			   stm32_dma_runtime_resume, NULL)
 };
@@ -1529,4 +2470,4 @@ static int __init stm32_dma_init(void)
 {
 	return platform_driver_register(&stm32_dma_driver);
 }
-subsys_initcall(stm32_dma_init);
+device_initcall(stm32_dma_init);
diff --git a/drivers/dma/stm32-dma3.c b/drivers/dma/stm32-dma3.c
new file mode 100644
index 000000000..85d04bfa9
--- /dev/null
+++ b/drivers/dma/stm32-dma3.c
@@ -0,0 +1,2120 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * STM32 DMA3 controller driver
+ *
+ * Copyright (C) STMicroelectronics 2022
+ * Author(s): Amelie Delaunay <amelie.delaunay@foss.st.com>
+ */
+
+#include <linux/bitfield.h>
+#include <linux/clk.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/init.h>
+#include <linux/iopoll.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/of_dma.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+
+#include "virt-dma.h"
+
+#define STM32_DMA3_SECCFGR		0x00
+#define STM32_DMA3_PRIVCFGR		0x04
+#define STM32_DMA3_RCFGLOCKR		0x08
+#define STM32_DMA3_MISR			0x0C
+#define STM32_DMA3_SMISR		0x10
+
+#define STM32_DMA3_CLBAR(x)		(0x50 + 0x80 * (x))
+#define STM32_DMA3_CCIDCFGR(x)		(0x54 + 0x80 * (x))
+#define STM32_DMA3_CSEMCR(x)		(0x58 + 0x80 * (x))
+#define STM32_DMA3_CFCR(x)		(0x5C + 0x80 * (x))
+#define STM32_DMA3_CSR(x)		(0x60 + 0x80 * (x))
+#define STM32_DMA3_CCR(x)		(0x64 + 0x80 * (x))
+#define STM32_DMA3_CTR1(x)		(0x90 + 0x80 * (x))
+#define STM32_DMA3_CTR2(x)		(0x94 + 0x80 * (x))
+#define STM32_DMA3_CBR1(x)		(0x98 + 0x80 * (x))
+#define STM32_DMA3_CSAR(x)		(0x9C + 0x80 * (x))
+#define STM32_DMA3_CDAR(x)		(0xA0 + 0x80 * (x))
+#define STM32_DMA3_CTR3(x)		(0xA4 + 0x80 * (x)) /* G_ADDRESSING > FIXED_BLOCK */
+#define STM32_DMA3_CBR2(x)		(0xA8 + 0x80 * (x)) /* G_ADDRESSING > FIXED_BLOCK */
+#define STM32_DMA3_CLLR(x)		(0xCC + 0x80 * (x))
+
+#define STM32_DMA3_HWCFGR13		0xFC0 /* G_PER_CTRL(X) x=8..15 */
+#define STM32_DMA3_HWCFGR12		0xFC4 /* G_PER_CTRL(X) x=0..7 */
+#define STM32_DMA3_HWCFGR11		0xFC8
+#define STM32_DMA3_HWCFGR10		0xFCC /* G_ADDRESSING(X) x=8..15 */
+#define STM32_DMA3_HWCFGR9		0xFD0 /* G_ADDRESSING(X) x=0..7 */
+#define STM32_DMA3_HWCFGR8		0xFD4 /* G_LINKED_LIST(X) x=8..15 */
+#define STM32_DMA3_HWCFGR7		0xFD8 /* G_LINKED_LIST(X) x=0..7 */
+#define STM32_DMA3_HWCFGR6		0xFDC /* G_TRANSFERS(X) x=8..15 */
+#define STM32_DMA3_HWCFGR5		0xFE0 /* G_TRANSFERS(X) x=0..7 */
+#define STM32_DMA3_HWCFGR4		0xFE4 /* G_FIFO_SIZE(X) x=8..15 */
+#define STM32_DMA3_HWCFGR3		0xFE8 /* G_FIFO_SIZE(X) x=0..7 */
+#define STM32_DMA3_HWCFGR2		0xFEC /* G_MAX_REQ_ID */
+#define STM32_DMA3_HWCFGR1		0xFF0 /* G_NUM_CHANNELS, G_Mx_DATA_WIDTH */
+#define STM32_DMA3_VERR			0xFF4
+
+/* SECCFGR DMA secure configuration register */
+#define SECCFGR_SEC(x)			BIT((x))
+
+/* PRIVCFGR DMA privileged configuration register */
+#define PRIVCFGR_PRIV(x)		BIT((x))
+
+/* RCFGLOCKR DMA configuration lock register */
+#define RCFGLOCKR_LOCK(x)		BIT((x))
+
+/* MISR DMA non-secure/secure masked interrupt status register */
+#define MISR_MIS(x)			BIT((x))
+
+/* CxLBAR DMA channel x linked_list base address register */
+#define CLBAR_LBA			GENMASK(31, 16)
+
+/* CxCIDCFGR DMA channel x CID register */
+#define CCIDCFGR_CFEN			BIT(0)
+#define CCIDCFGR_SEM_EN			BIT(1)
+#define CCIDCFGR_SCID			GENMASK(5, 4)
+#define CCIDCFGR_SEM_WLIST_CID0		BIT(16)
+#define CCIDCFGR_SEM_WLIST_CID1		BIT(17)
+#define CCIDCFGR_SEM_WLIST_CID2		BIT(18)
+
+enum ccidcfgr_cid {
+	CCIDCFGR_CID0,
+	CCIDCFGR_CID1,
+	CCIDCFGR_CID2,
+};
+
+/* CxSEMCR DMA channel x semaphore control register */
+#define CSEMCR_SEM_MUTEX		BIT(0)
+#define CSEMCR_SEM_CCID			GENMASK(5, 4)
+
+/* CxFCR DMA channel x flag clear register */
+#define CFCR_TCF			BIT(8)
+#define CFCR_HTF			BIT(9)
+#define CFCR_DTEF			BIT(10)
+#define CFCR_ULEF			BIT(11)
+#define CFCR_USEF			BIT(12)
+#define CFCR_SUSPF			BIT(13)
+#define CFCR_TOF			BIT(14)
+
+/* CxSR DMA channel x status register */
+#define CSR_IDLEF			BIT(0)
+#define CSR_TCF				BIT(8)
+#define CSR_HTF				BIT(9)
+#define CSR_DTEF			BIT(10)
+#define CSR_ULEF			BIT(11)
+#define CSR_USEF			BIT(12)
+#define CSR_SUSPF			BIT(13)
+#define CSR_TOF				BIT(14)
+#define CSR_ALL_F			GENMASK(14, 8)
+#define CSR_FIFOL			GENMASK(24, 16)
+
+/* CxCR DMA channel x control register */
+#define CCR_EN				BIT(0)
+#define CCR_RESET			BIT(1)
+#define CCR_SUSP			BIT(2)
+#define CCR_TCIE			BIT(8)
+#define CCR_HTIE			BIT(9)
+#define CCR_DTEIE			BIT(10)
+#define CCR_ULEIE			BIT(11)
+#define CCR_USEIE			BIT(12)
+#define CCR_SUSPIE			BIT(13)
+#define CCR_TOIE			BIT(14)
+#define CCR_ALLIE			GENMASK(14, 8)
+#define CCR_LSM				BIT(16)
+#define CCR_LAP				BIT(17)
+#define CCR_PRIO			GENMASK(23, 22)
+
+enum ccr_prio {
+	CCR_PRIO_LOW, /* low priority, low weight */
+	CCR_PRIO_MID, /* low priority, mid weight */
+	CCR_PRIO_HIGH, /* low priority, high weight */
+	CCR_PRIO_VERY_HIGH, /* high priority */
+};
+
+/* CxTR1 DMA channel x transfer register 1 */
+#define CTR1_SINC			BIT(3)
+#define CTR1_SBL_1			GENMASK(9, 4)
+#define CTR1_DINC			BIT(19)
+#define CTR1_DBL_1			GENMASK(25, 20)
+#define CTR1_SDW_LOG2			GENMASK(1, 0)
+#define CTR1_PAM			GENMASK(12, 11)
+#define CTR1_SBX			BIT(13)
+#define CTR1_SAP			BIT(14)
+#define CTR1_SSEC			BIT(15)
+#define CTR1_DDW_LOG2			GENMASK(17, 16)
+#define CTR1_DBX			BIT(26)
+#define CTR1_DHX			BIT(27)
+#define CTR1_DWX			BIT(28)
+#define CTR1_DAP			BIT(30)
+#define CTR1_DSEC			BIT(31)
+
+enum ctr1_dw {
+	CTR1_DW_BYTE,
+	CTR1_DW_HWORD,
+	CTR1_DW_WORD,
+	CTR1_DW_DWORD, /* if CTR1_DAP=0 (AXI) or CTR1_SAP=0 (AXI) */
+};
+
+enum ctr1_pam {
+	CTR1_PAM_0S_LT, /* if DDW > SDW, padded with 0s else left-truncated */
+	CTR1_PAM_SE_RT, /* if DDW > SDW, sign extended else right-truncated */
+	CTR1_PAM_PACK_UNPACK, /* FIFO queued */
+};
+
+enum stm32_dma3_ap {
+	AP_AXI,
+	AP_AHB,
+};
+
+/* CxTR2 DMA channel x transfer register 2 */
+#define CTR2_REQSEL			GENMASK(7, 0)
+#define CTR2_SWREQ			BIT(9)
+#define CTR2_DREQ			BIT(10)
+#define CTR2_BREQ			BIT(11)
+#define CTR2_PFREQ			BIT(12)
+#define CTR2_TRIGM			GENMASK(15, 14)
+#define CTR2_TRIGSEL			GENMASK(22, 16)
+#define CTR2_TRIGPOL			GENMASK(25, 24)
+#define CTR2_TCEM			GENMASK(31, 30)
+
+enum ctr2_tcem {
+	CTR2_TCEM_BLOCK,
+	CTR2_TCEM_REPEAT_BLOCK,
+	CTR2_TCEM_LLI,
+	CTR2_TCEM_CHANNEL,
+};
+
+/* CxBR1 DMA channel x block register 1 */
+#define CBR1_BNDT			GENMASK(15, 0)
+#define CBR1_BRC			GENMASK(26, 16) /* G_ADDRESSING > FIXED_BLOCK */
+#define CBR1_SDEC			BIT(28) /* G_ADDRESSING > FIXED_BLOCK */
+#define CBR1_DDEC			BIT(29) /* G_ADDRESSING > FIXED_BLOCK */
+#define CBR1_BRSDEC			BIT(30) /* G_ADDRESSING > FIXED_BLOCK */
+#define CBR1_BRDDEC			BIT(31) /* G_ADDRESSING > FIXED_BLOCK */
+
+/* CxTR3 DMA channel x transfer register 3 */
+#define CTR3_SAO			GENMASK(12, 0) /* G_ADDRESSING > FIXED_BLOCK */
+#define CTR3_BAM			GENMASK(15, 14) /* G_ADDRESSING == 2D_EXT */
+#define CTR3_DAO			GENMASK(28, 16) /* G_ADDRESSING > FIXED_BLOCK */
+#define CTR3_BRAM			GENMASK(31, 30) /* G_ADDRESSING == 2D_EXT */
+
+/* CxBR2 DMA channel x block register 2 */
+#define CBR2_BRSAO			GENMASK(15, 0) /* G_ADDRESSING > FIXED_BLOCK */
+#define CBR2_BRDAO			GENMASK(31, 16) /* G_ADDRESSING > FIXED_BLOCK */
+
+/* CxLLR DMA channel x linked-list address register */
+#define CLLR_LA				GENMASK(15, 2)
+#define CLLR_ULL			BIT(16)
+#define CLLR_UB2			BIT(25) /* G_ADDRESSING > FIXED_BLOCK */
+#define CLLR_UT3			BIT(26) /* G_ADDRESSING > FIXED_BLOCK */
+#define CLLR_UDA			BIT(27)
+#define CLLR_USA			BIT(28)
+#define CLLR_UB1			BIT(29)
+#define CLLR_UT2			BIT(30)
+#define CLLR_UT1			BIT(31)
+
+/* HWCFGR13 DMA hardware configuration register 13 x=8..15 */
+/* HWCFGR12 DMA hardware configuration register 12 x=0..7 */
+#define G_PER_CTRL(x)			(0x1 << (4 * ((x) & 0x7)))
+
+/* HWCFGR11 DMA hardware configuration register 11 */
+#define G_NONSEC_OPTIONREG		GENMASK(5, 0)
+#define G_SEC_OPTIONREG			GENMASK(13, 8)
+#define G_CID_WIDTH			GENMASK(18, 16)
+#define G_NUM_RESYNC_FFS		GENMASK(22, 20)
+
+/* HWCFGR10 DMA hardware configuration register 10 x=8..15 */
+/* HWCFGR9 DMA hardware configuration register 9 x=0..7 */
+#define G_ADDRESSING(x)			(0x3 << (4 * ((x) & 0x7)))
+/*
+ * G_ADDRESSING:
+ *  0 (FIXED_BLOCK): (fixed or) linear contiguous block addressing
+ *    - CBR1 with 16-bit BNDT (block size up to 64 kB-1).
+ *    - no 2D/repeated block mode. No CTR3, no CBR2 registers.
+ *  1 (2D): flexible 2D block addressing
+ *    - additional repeated block mode, CBR1 with additional 11-bit BRC (up to 2k blocks -1).
+ *    - additional src/dst address offset, additional CTR3.
+ *    - additional src/dst address offset between each repeated block, additional CBR2.
+ *  2 (2D_EXT): flexible 2D block addressing with extended (possibly repeated) block size/offsets
+ *    - additional CTR3.BAM&BRAM.
+ */
+enum g_addressing {
+	G_ADDRESSING_FIXED_BLOCK,	/* no CBR1[31:16], no CTR3, no CBR2*/
+	G_ADDRESSING_2D,		/* CTR3 without BAM & BRAM, CBR2 */
+	G_ADDRESSING_2D_EXT,		/* CTR3 with BAM & BRAM, CBR2 */
+};
+
+/* HWCFGR8 DMA hardware configuration register 8 x=8..15 */
+/* HWCFGR7 DMA hardware configuration register 7 x=0..7 */
+#define G_LINKED_LIST(x)		(0x1 << (4 * ((x) & 0x7)))
+
+/* HWCFGR6 DMA hardware configuration register 6 x=8..15 */
+/* HWCFGR5 DMA hardware configuration register 5 x=0..7 */
+#define G_TRANSFERS(x)			(0x1 << (4 * ((x) & 0x7)))
+
+/* HWCFGR4 DMA hardware configuration register 4 x=8..15 */
+/* HWCFGR3 DMA hardware configuration register 3 x=0..7 */
+#define G_FIFO_SIZE(x)			(0x7 << (4 * ((x) & 0x7)))
+
+/* HWCFGR2 DMA hardware configuration register 2 */
+#define G_MAX_REQ_ID			GENMASK(7, 0)
+#define G_MAX_TRIG_ID			GENMASK(14, 8)
+
+/* HWCFGR1 DMA hardware configuration register 1 */
+#define G_MASTER_PORTS			GENMASK(2, 0)
+#define G_PRIVILEGE			BIT(4)
+#define G_NUM_CHANNELS			GENMASK(12, 8)
+#define G_TRUSTZONE			BIT(16)
+#define G_MAX_CID			GENMASK(23, 20)
+#define G_M0_DATA_WIDTH_ENC		GENMASK(25, 24)
+#define G_M1_DATA_WIDTH_ENC		GENMASK(29, 28)
+
+enum g_data_width {
+	G_DATA_WIDTH_32BIT,
+	G_DATA_WIDTH_64BIT,
+	G_DATA_WIDTH_128BIT,
+};
+
+#define get_chan_hwcfg(x, mask, reg)	(((reg) & (mask)) >> (4 * (((x) & 0x7))))
+
+/* VERR DMA version register */
+#define VERR_MINREV			GENMASK(3, 0)
+#define VERR_MAJREV			GENMASK(7, 4)
+
+/* Device tree */
+/* struct stm32_dma3_dt_conf */
+/* .ch_conf */
+#define STM32_DMA3_DT_PRIO		GENMASK(1, 0)	/* CCR_PRIO */
+#define STM32_DMA3_DT_FIFO		GENMASK(7, 4)
+/* .tr_conf */
+#define STM32_DMA3_DT_SINC		BIT(0)		/* CTR1_SINC */
+#define STM32_DMA3_DT_SAP		BIT(1)		/* CTR1_SAP */
+#define STM32_DMA3_DT_DINC		BIT(4)		/* CTR1_DINC */
+#define STM32_DMA3_DT_DAP		BIT(5)		/* CTR1_DAP */
+#define STM32_DMA3_DT_BREQ		BIT(8)		/* CTR2_BREQ */
+#define STM32_DMA3_DT_PFREQ		BIT(9)		/* CTR2_PFREQ */
+#define STM32_DMA3_DT_TCEM		GENMASK(13, 12)	/* CTR2_TCEM */
+/* .tr_conf_ext */
+#define STM32_DMA3_DT_SAO		GENMASK(12, 0)	/* CTR3_SAO */
+#define STM32_DMA3_DT_SDEC		BIT(13)		/* CBR1_SDEC */
+#define STM32_DMA3_DT_BAM		GENMASK(15, 14) /* CTR3_BAM */
+#define STM32_DMA3_DT_DAO		GENMASK(28, 16) /* CTR3_DAO */
+#define STM32_DMA3_DT_DDEC		BIT(29)		/* CBR1_DDEC */
+
+/* struct stm32_dma3_chan .config_set bitfield */
+#define STM32_DMA3_CFG_SET_DT		BIT(0)
+#define STM32_DMA3_CFG_SET_DMA		BIT(1)
+#define STM32_DMA3_CFG_SET_BOTH		(STM32_DMA3_CFG_SET_DT | STM32_DMA3_CFG_SET_DMA)
+
+#define STM32_DMA3_MAX_BLOCK_SIZE	ALIGN_DOWN(CBR1_BNDT, 64)
+#define STM32_DMA3_MAX_16B_BLOCK_SIZE	(STM32_DMA3_MAX_BLOCK_SIZE * 16)
+#define STM32_DMA3_MAX_256B_BLOCK_SIZE	(STM32_DMA3_MAX_BLOCK_SIZE * 256)
+
+/*
+ * Static linked-list data structure
+ * (depends on update bits UT1/UT2/UB1/USA/UDA/UT3/UB2/ULL)
+ * for channel with G_ADDRESSING == FIXED_BLOCK: up to 6 contiguous 32-bit locations;
+ * for channel with  G_ADDRESSING > FIXED_BLOCK: up to 8 contiguous 32-bit locations.
+ */
+struct stm32_dma3_hwdesc {
+	u32 ctr1;
+	u32 ctr2;
+	u32 cbr1;
+	u32 csar;
+	u32 cdar;
+//	u32 ctr3;
+//	u32 cbr2;
+	u32 cllr;
+} __aligned(32);
+//TODO: Dynamic linked-list data structure: Alternatively, the memory organization for the full
+//list of LLIs may be compacted, with specific data structure for each LLI.
+
+/*
+ * CLLR_LA / 8 represents the number of hdwdesc that can be adressed; multiplied by the max block
+ * size of each item, it represents the sg size limitation
+ */
+#define STM32_DMA3_MAX_SEG_SIZE		((CLLR_LA / 8) * STM32_DMA3_MAX_BLOCK_SIZE)
+
+/*
+ * Linked-list items
+ */
+struct stm32_dma3_lli {
+	struct stm32_dma3_hwdesc *hwdesc;
+	dma_addr_t hwdesc_lli;
+};
+
+struct stm32_dma3_swdesc {
+	struct virt_dma_desc vdesc;
+	u32 ccr;
+	bool cyclic;
+	u32 lli_size;
+	struct stm32_dma3_lli lli[];
+};
+
+struct stm32_dma3_dt_conf {
+	u32 ch_id;
+	u32 req_line;
+	u32 ch_conf;
+	u32 tr_conf;
+	u32 tr_conf_ext;
+};
+
+struct stm32_dma3_chan {
+	struct virt_dma_chan vchan;
+	u32 id;
+	int irq;
+	u32 fifo_size;
+	bool ext_addressing;
+	bool semaphore_mode;
+	struct stm32_dma3_dt_conf dt_config;
+	struct dma_slave_config dma_config;
+	u8 config_set;
+	struct dma_pool *lli_pool;
+	struct stm32_dma3_swdesc *swdesc;
+	enum ctr2_tcem tcem;
+	u32 curr_lli;
+	u32 dma_status;
+};
+
+struct stm32_dma3_ddata {
+	struct dma_device dma_dev;
+	void __iomem *base;
+	struct clk *clk;
+	struct stm32_dma3_chan *chans;
+	u32 dma_channels;
+	u32 dma_requests;
+	u32 chan_reserved;
+	u32 max_burst_length;
+};
+
+static inline struct stm32_dma3_chan *to_stm32_dma3_chan(struct dma_chan *c)
+{
+	return container_of(c, struct stm32_dma3_chan, vchan.chan);
+}
+
+static inline struct stm32_dma3_swdesc *to_stm32_dma3_swdesc(struct virt_dma_desc *vdesc)
+{
+	return container_of(vdesc, struct stm32_dma3_swdesc, vdesc);
+}
+
+static inline struct stm32_dma3_ddata *to_stm32_dma3_ddata(struct dma_chan *c)
+{
+	return container_of(c->device, struct stm32_dma3_ddata, dma_dev);
+}
+
+static struct device *chan2dev(struct stm32_dma3_chan *chan)
+{
+	return &chan->vchan.chan.dev->device;
+}
+
+/*static struct device *ddata2dev(struct stm32_dma3_ddata *ddata)*/
+/*{*/
+/*        return ddata->dma_dev.dev;*/
+/*}*/
+
+#ifdef CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+static void stm32_dma3_dbg_summary_show(struct seq_file *s, struct dma_device *dma_dev)
+{
+	struct dma_chan *c;
+	struct stm32_dma3_ddata *ddata;
+	struct stm32_dma3_chan *chan;
+	u32 offset;
+	int ret;
+
+	ret = pm_runtime_resume_and_get(dma_dev->dev);
+	if (ret < 0)
+		return;
+
+	list_for_each_entry(c, &dma_dev->channels, device_node) {
+		char str[18];
+
+		ddata = to_stm32_dma3_ddata(c);
+		chan  = to_stm32_dma3_chan(c);
+
+		if (!c->client_count)
+			continue;
+
+		seq_printf(s, " %-13s| %s", dma_chan_name(c), c->dbg_client_name ?: "in-use");
+
+		if (c->router)
+			seq_printf(s, " (via router: %s)\n", dev_name(c->router->dev));
+		else
+			seq_puts(s, "\n");
+
+		offset = STM32_DMA3_SECCFGR;
+		snprintf(str, sizeof(str), "SECCFGR(0x%03x)", offset);
+		seq_printf(s, "  %-18s: %08x\n", str, readl_relaxed(ddata->base + offset));
+		offset = STM32_DMA3_PRIVCFGR;
+		snprintf(str, sizeof(str), "PRIVCFGR(0x%03x)", offset);
+		seq_printf(s, "  %-18s: %08x\n", str, readl_relaxed(ddata->base + offset));
+
+		offset = STM32_DMA3_CCIDCFGR(chan->id);
+		snprintf(str, sizeof(str), "C%dCIDCFGR(0x%03x)", chan->id, offset);
+		seq_printf(s, "  %-18s: %08x\n", str, readl_relaxed(ddata->base + offset));
+		offset = STM32_DMA3_CSEMCR(chan->id);
+		snprintf(str, sizeof(str), "C%dSEMCR(0x%03x)", chan->id, offset);
+		seq_printf(s, "  %-18s: %08x\n", str, readl_relaxed(ddata->base + offset));
+		offset = STM32_DMA3_CSR(chan->id);
+		snprintf(str, sizeof(str), "C%dSR(0x%03x)", chan->id, offset);
+		seq_printf(s, "  %-18s: %08x\n", str, readl_relaxed(ddata->base + offset));
+		offset = STM32_DMA3_CCR(chan->id);
+		snprintf(str, sizeof(str), "C%dCCR(0x%03x)", chan->id, offset);
+		seq_printf(s, "  %-18s: %08x\n", str, readl_relaxed(ddata->base + offset));
+		offset = STM32_DMA3_CTR1(chan->id);
+		snprintf(str, sizeof(str), "C%dTR1(0x%03x)", chan->id, offset);
+		seq_printf(s, "  %-18s: %08x\n", str, readl_relaxed(ddata->base + offset));
+		offset = STM32_DMA3_CTR2(chan->id);
+		snprintf(str, sizeof(str), "C%dTR2(0x%03x)", chan->id, offset);
+		seq_printf(s, "  %-18s: %08x\n", str, readl_relaxed(ddata->base + offset));
+		offset = STM32_DMA3_CBR1(chan->id);
+		snprintf(str, sizeof(str), "C%dBR1(0x%03x)", chan->id, offset);
+		seq_printf(s, "  %-18s: %08x\n", str, readl_relaxed(ddata->base + offset));
+		offset = STM32_DMA3_CSAR(chan->id);
+		snprintf(str, sizeof(str), "C%dSAR(0x%03x)", chan->id, offset);
+		seq_printf(s, "  %-18s: %08x\n", str, readl_relaxed(ddata->base + offset));
+		offset = STM32_DMA3_CDAR(chan->id);
+		snprintf(str, sizeof(str), "C%dDAR(0x%03x)", chan->id, offset);
+		seq_printf(s, "  %-18s: %08x\n", str, readl_relaxed(ddata->base + offset));
+		if (chan->ext_addressing) {
+			offset = STM32_DMA3_CTR3(chan->id);
+			snprintf(str, sizeof(str), "C%dTR3(0x%03x)", chan->id, offset);
+			seq_printf(s, "  %-18s: %08x\n", str, readl_relaxed(ddata->base + offset));
+			offset = STM32_DMA3_CBR2(chan->id);
+			snprintf(str, sizeof(str), "C%dBR2(0x%03x)", chan->id, offset);
+			seq_printf(s, "  %-18s: %08x\n", str, readl_relaxed(ddata->base + offset));
+		}
+		offset = STM32_DMA3_CLLR(chan->id);
+		snprintf(str, sizeof(str), "C%dLLR(0x%03x)", chan->id, offset);
+		seq_printf(s, "  %-18s: %08x\n", str, readl_relaxed(ddata->base + offset));
+		offset = STM32_DMA3_CLBAR(chan->id);
+		snprintf(str, sizeof(str), "C%dLBAR(0x%03x)", chan->id, offset);
+		seq_printf(s, "  %-18s: %08x\n", str, readl_relaxed(ddata->base + offset));
+	}
+
+	pm_runtime_put_sync(dma_dev->dev);
+}
+#endif
+
+static void stm32_dma3_chan_dump_reg(struct stm32_dma3_chan *chan)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(&chan->vchan.chan);
+	struct device *dev = chan2dev(chan);
+	u32 id = chan->id, offset;
+
+	offset = STM32_DMA3_SECCFGR;
+	dev_dbg(dev, "SECCFGR(0x%03x): %08x\n", offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_PRIVCFGR;
+	dev_dbg(dev, "PRIVCFGR(0x%03x): %08x\n", offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CCIDCFGR(id);
+	dev_dbg(dev, "C%dCIDCFGR(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CSEMCR(id);
+	dev_dbg(dev, "C%dSEMCR(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CSR(id);
+	dev_dbg(dev, "C%dSR(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CCR(id);
+	dev_dbg(dev, "C%dCR(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CTR1(id);
+	dev_dbg(dev, "C%dTR1(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CTR2(id);
+	dev_dbg(dev, "C%dTR2(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CBR1(id);
+	dev_dbg(dev, "C%dBR1(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CSAR(id);
+	dev_dbg(dev, "C%dSAR(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CDAR(id);
+	dev_dbg(dev, "C%dDAR(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	if (chan->ext_addressing) {
+		offset = STM32_DMA3_CTR3(id);
+		dev_dbg(dev, "C%dTR3(0x%03x): %08x\n",
+			id, offset, readl_relaxed(ddata->base + offset));
+		offset = STM32_DMA3_CBR2(id);
+		dev_dbg(dev, "C%dBR2(0x%03x): %08x\n",
+			id, offset, readl_relaxed(ddata->base + offset));
+	}
+	offset = STM32_DMA3_CLLR(id);
+	dev_dbg(dev, "C%dLLR(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CLBAR(id);
+	dev_dbg(dev, "C%dLBAR(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+}
+
+static void stm32_dma3_chan_dump_hwdesc(struct stm32_dma3_chan *chan, struct stm32_dma3_lli *lli)
+{
+	dev_dbg(chan2dev(chan), "hwdesc: %pad\n", &lli->hwdesc_lli);
+	dev_dbg(chan2dev(chan), "CTR1: 0x%08x\n", lli->hwdesc->ctr1);
+	dev_dbg(chan2dev(chan), "CTR2: 0x%08x\n", lli->hwdesc->ctr2);
+	dev_dbg(chan2dev(chan), "CBR1: 0x%08x\n", lli->hwdesc->cbr1);
+	dev_dbg(chan2dev(chan), "CSAR: 0x%08x\n", lli->hwdesc->csar);
+	dev_dbg(chan2dev(chan), "CDAR: 0x%08x\n", lli->hwdesc->cdar);
+	dev_dbg(chan2dev(chan), "CLLR: 0x%08x\n", lli->hwdesc->cllr);
+}
+
+static struct stm32_dma3_swdesc *stm32_dma3_chan_desc_alloc(struct stm32_dma3_chan *chan, u32 count)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(&chan->vchan.chan);
+	struct stm32_dma3_swdesc *swdesc;
+	u32 ccr;
+	int i;
+
+	/*
+	 * If the number of hwdesc to allocate is greater than the maximum address of CLLR_LA,
+	 * then the last items can't be addressed, so abort the allocation.
+	 */
+	if ((count * sizeof(struct stm32_dma3_hwdesc)) > CLLR_LA) {
+		dev_err(chan2dev(chan), "Transfer is too big (> %luB)\n", STM32_DMA3_MAX_SEG_SIZE);
+		return NULL;
+	}
+
+	swdesc = kzalloc(struct_size(swdesc, lli, count), GFP_NOWAIT);
+	if (!swdesc)
+		return NULL;
+
+	/*
+	 * TODO:
+	 * tab of hwdesc or not ?
+	 * may depend on the @ of next LL constraints
+	 */
+
+	for (i = 0; i < count; i++) {
+		swdesc->lli[i].hwdesc = dma_pool_zalloc(chan->lli_pool, GFP_NOWAIT,
+							&swdesc->lli[i].hwdesc_lli);
+		if (!swdesc->lli[i].hwdesc)
+			goto err_pool_free;
+	}
+
+	/* Set LL base address */
+	writel_relaxed(swdesc->lli[0].hwdesc_lli & CLBAR_LBA,
+		       ddata->base + STM32_DMA3_CLBAR(chan->id));
+
+	/* Set LL allocated port (AXI) */
+	ccr = readl_relaxed(ddata->base + STM32_DMA3_CCR(chan->id));
+	writel_relaxed(ccr & ~CCR_LAP, ddata->base + STM32_DMA3_CCR(chan->id));
+
+	swdesc->lli_size = count;
+
+	return swdesc;
+
+err_pool_free:
+	dev_err(chan2dev(chan), "Failed to alloc descriptors.\n");
+	while (--i >= 0)
+		dma_pool_free(chan->lli_pool, swdesc->lli[i].hwdesc, swdesc->lli[i].hwdesc_lli);
+	kfree(swdesc);
+
+	return NULL;
+}
+
+static void stm32_dma3_chan_desc_free(struct stm32_dma3_chan *chan,
+				      struct stm32_dma3_swdesc *swdesc)
+{
+	int i;
+
+	for (i = 0; i < swdesc->lli_size; i++)
+		dma_pool_free(chan->lli_pool, swdesc->lli[i].hwdesc,
+			      swdesc->lli[i].hwdesc_lli);
+	kfree(swdesc);
+}
+
+static void stm32_dma3_chan_vdesc_free(struct virt_dma_desc *vdesc)
+{
+	struct stm32_dma3_swdesc *swdesc = to_stm32_dma3_swdesc(vdesc);
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(vdesc->tx.chan);
+
+	stm32_dma3_chan_desc_free(chan, swdesc);
+}
+
+/* TODO: To remove */
+static int stm32_dma3_check_user_setting(struct stm32_dma3_hwdesc *hwdesc)
+{
+	u32 bndt = FIELD_GET(CBR1_BNDT, hwdesc->cbr1);
+	u32 sdw = 1 << FIELD_GET(CTR1_SDW_LOG2, hwdesc->ctr1);
+	u32 ddw = 1 << FIELD_GET(CTR1_DDW_LOG2, hwdesc->ctr1);
+	int ret = -EINVAL;
+
+	if (!bndt && !FIELD_GET(CLLR_UB1, hwdesc->cllr))
+		pr_err("null src block size and no update of this value\n");
+	else if (bndt % sdw)
+		pr_err("src block size not multiple of data width of src burst transfer\n");
+	else if (FIELD_GET(CTR1_PAM, hwdesc->ctr1) == CTR1_PAM_PACK_UNPACK && bndt % ddw)
+		pr_err("src block size not multiple of data width of dst burst transfer\n");
+	else if (hwdesc->csar % sdw)
+		pr_err("unaligned src @; src @ not multiple of data width of src burst transfer\n");
+	else if (hwdesc->cdar % ddw)
+		pr_err("unaligned drc @; drc @ not multiple of data width of drc burst transfer\n");
+	else if (sdw == 8 && FIELD_GET(CTR1_SAP, hwdesc->ctr1))
+		pr_err("dword src data width and AHB src allocated port\n");
+	else if (ddw == 8 && FIELD_GET(CTR1_DAP, hwdesc->ctr1))
+		pr_err("dword dst data width and AHB dst allocated port\n");
+	else
+		ret = 0;
+
+	return ret;
+}
+
+/*
+ * TODO: memory footprint and bus traffic required for the linked-list
+ * item(s) update from memory may be minized, by the usage of the conditional
+ * update bits.
+ */
+static int stm32_dma3_chan_prep_hwdesc(struct stm32_dma3_chan *chan,
+				       struct stm32_dma3_swdesc *swdesc,
+				       u32 curr, dma_addr_t src, dma_addr_t dst, u32 len,
+				       u32 ctr1, u32 ctr2, u32 ctr3, bool is_last, bool is_cyclic)
+{
+	struct stm32_dma3_hwdesc *hwdesc;
+	dma_addr_t next_lli;
+	u32 next = curr + 1;
+
+	hwdesc = swdesc->lli[curr].hwdesc;
+	hwdesc->ctr1 = ctr1;
+	hwdesc->ctr2 = ctr2;
+	hwdesc->cbr1 = FIELD_PREP(CBR1_BNDT, len);
+	//hwdesc->ctr3 = ctr3; //TODO
+	hwdesc->csar = src;
+	hwdesc->cdar = dst;
+
+	if (is_last) {
+		if (is_cyclic)
+			next_lli = swdesc->lli[0].hwdesc_lli;
+		else
+			next_lli = 0;
+	} else {
+		next_lli = swdesc->lli[next].hwdesc_lli;
+	}
+
+	/* TODO:
+	 * LA pointer (16-bit low significant address) should be 32-bit aligned
+	 */
+	hwdesc->cllr = 0;
+	if (next_lli) {
+		hwdesc->cllr |= CLLR_UT1 | CLLR_UT2 | CLLR_UB1;
+		hwdesc->cllr |= CLLR_USA | CLLR_UDA | CLLR_ULL;
+		hwdesc->cllr |= (next_lli & CLLR_LA);
+	}
+
+	return stm32_dma3_check_user_setting(hwdesc);
+}
+
+static enum dma_slave_buswidth stm32_dma3_get_max_dw(u32 len, dma_addr_t addr, u32 chan_max_burst)
+{
+	enum dma_slave_buswidth max_dw = DMA_SLAVE_BUSWIDTH_16_BYTES;
+
+	if (!chan_max_burst)
+		max_dw = DMA_SLAVE_BUSWIDTH_8_BYTES;
+
+	/* len and addr must be a multiple of dw */
+	while (max_dw >>= 1)
+		if (!(len & (max_dw - 1)) && !(addr & (max_dw - 1)))
+			break;
+
+	/* max_dw could be greater than chan_max_burst on channels with FIFO size <= 8 bytes */
+	while (max_dw > chan_max_burst)
+		max_dw >>= 1;
+
+	return max_dw;
+}
+
+static u32 stm32_dma3_get_max_burst(u32 len, enum dma_slave_buswidth dw, u32 chan_max_burst)
+{
+	u32 max_burst = chan_max_burst / dw;
+
+	if (!chan_max_burst)
+		return 1;
+
+	/* len is a multiple of dw, so if len is < chan_max_burst, shorten burst */
+	if (len < chan_max_burst)
+		max_burst = len / dw;
+
+	/*
+	 * HW doesn't modify the burst if burst size <= half of the fifo size.
+	 * If len is not a multiple of burst size, last burst is shortened by HW.
+	 */
+	return max_burst;
+}
+
+static int stm32_dma3_chan_prep_hw(struct stm32_dma3_chan *chan, enum dma_transfer_direction dir,
+				   u32 *ccr, u32 *ctr1, u32 *ctr2, u32 *ctr3,
+				   dma_addr_t src_addr, dma_addr_t dst_addr, u32 len)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(&chan->vchan.chan);
+	struct dma_device dma_device = ddata->dma_dev;
+	u32 sdw, ddw, sbl_max, dbl_max, chan_max_burst, tcem, id = chan->id;
+	u32 _ccr, _ctr1 = 0, _ctr2 = 0, _ctr3 = 0;
+	u32 ch_conf = chan->dt_config.ch_conf;
+	u32 tr_conf = chan->dt_config.tr_conf;
+
+	dev_dbg(chan2dev(chan),	"%s: %s src_addr=%pad dst_addr=%pad\n",
+		__func__, dmaengine_get_direction_text(dir), &src_addr, &dst_addr);
+
+	chan_max_burst = !chan->fifo_size ? 0 :
+			  min_t(u32, (1 << (chan->fifo_size + 1)) / 2, ddata->max_burst_length);
+	sdw = chan->dma_config.src_addr_width;
+	if (sdw == DMA_SLAVE_BUSWIDTH_UNDEFINED) /* Can be the case if DMA_MEM_TO_DEV */
+		sdw = chan_max_burst < DMA_SLAVE_BUSWIDTH_8_BYTES ?
+		      DMA_SLAVE_BUSWIDTH_4_BYTES : DMA_SLAVE_BUSWIDTH_8_BYTES;
+	ddw = chan->dma_config.dst_addr_width;
+	if (ddw == DMA_SLAVE_BUSWIDTH_UNDEFINED) /* Can be the case if DMA_DEV_TO_MEM */
+		ddw = chan_max_burst < DMA_SLAVE_BUSWIDTH_8_BYTES ?
+		      DMA_SLAVE_BUSWIDTH_4_BYTES : DMA_SLAVE_BUSWIDTH_8_BYTES;
+
+	if (!(dma_device.src_addr_widths & BIT(sdw)) || !(dma_device.dst_addr_widths & BIT(ddw))) {
+		dev_err(chan2dev(chan), "Bus width (src=%u, dst=%u) not supported\n", sdw, ddw);
+		return -EINVAL;
+	}
+
+	if ((FIELD_GET(STM32_DMA3_DT_SAP, tr_conf) && sdw == DMA_SLAVE_BUSWIDTH_8_BYTES) ||
+	    (FIELD_GET(STM32_DMA3_DT_DAP, tr_conf) && ddw == DMA_SLAVE_BUSWIDTH_8_BYTES)) {
+		dev_err(chan2dev(chan),
+			"Bus width (src=%u, dst=%u) not supported on AHB port\n", sdw, ddw);
+		return -EINVAL;
+	}
+
+	sbl_max = chan->dma_config.src_maxburst ? : 1;
+	dbl_max = chan->dma_config.dst_maxburst ? : 1;
+
+	if (chan->fifo_size && (sbl_max * sdw > chan_max_burst || dbl_max * ddw > chan_max_burst)) {
+		dev_err(chan2dev(chan),
+			"Burst too high (src=%u bytes, dst=%u bytes, channel max_burst=%u bytes)\n",
+			sbl_max * sdw, dbl_max * ddw, chan_max_burst);
+		return -EINVAL;
+	}
+
+	_ccr = readl_relaxed(ddata->base + STM32_DMA3_CCR(id));
+	_ccr &= ~(CCR_PRIO);
+	_ccr |= FIELD_PREP(CCR_PRIO, FIELD_GET(STM32_DMA3_DT_PRIO, ch_conf));
+
+	if (FIELD_GET(STM32_DMA3_DT_SINC, tr_conf))
+		_ctr1 |= CTR1_SINC;
+	if (FIELD_GET(STM32_DMA3_DT_SAP, tr_conf))
+		_ctr1 |= CTR1_SAP;
+	if (FIELD_GET(STM32_DMA3_DT_DINC, tr_conf))
+		_ctr1 |= CTR1_DINC;
+	if (FIELD_GET(STM32_DMA3_DT_DAP, tr_conf))
+		_ctr1 |= CTR1_DAP;
+
+	_ctr2 |= FIELD_PREP(CTR2_REQSEL, chan->dt_config.req_line);
+	_ctr2 &= ~CTR2_SWREQ;
+	if (FIELD_GET(STM32_DMA3_DT_BREQ, tr_conf))
+		_ctr2 |= CTR2_BREQ;
+	if (FIELD_GET(STM32_DMA3_DT_PFREQ, tr_conf))
+		_ctr2 |= CTR2_PFREQ;
+	tcem = FIELD_GET(STM32_DMA3_DT_TCEM, tr_conf);
+	_ctr2 |= FIELD_PREP(CTR2_TCEM, tcem);
+	/* Store TCEM to know on which event TC flag occurred */
+	chan->tcem = tcem;
+
+	switch (dir) {
+	case DMA_MEM_TO_DEV:
+		/* Set source (memory) data width and burst */
+		sdw = stm32_dma3_get_max_dw(len, src_addr, chan_max_burst);
+		_ctr1 |= FIELD_PREP(CTR1_SDW_LOG2, ilog2(sdw));
+		sbl_max = stm32_dma3_get_max_burst(len, sdw, chan_max_burst);
+		_ctr1 |= FIELD_PREP(CTR1_SBL_1, sbl_max - 1);
+
+		/* Set destination (device) data width and burst */
+		ddw = min_t(u32, ddw, stm32_dma3_get_max_dw(len, dst_addr, chan_max_burst));
+		_ctr1 |= FIELD_PREP(CTR1_DDW_LOG2, ilog2(ddw));
+		dbl_max = min_t(u32, dbl_max, stm32_dma3_get_max_burst(len, ddw, chan_max_burst));
+		_ctr1 |= FIELD_PREP(CTR1_DBL_1, dbl_max - 1);
+
+		/* TODO: packing is not supported if PFREQ=1 */
+		if (ddw != sdw) {
+			_ctr1 |= FIELD_PREP(CTR1_PAM, CTR1_PAM_PACK_UNPACK);
+			/* Should never reach this case as ddw is clamped down */
+			if (len & (ddw - 1)) {
+				dev_err(chan2dev(chan),
+					"Packing mode is enabled and len is not multiple of ddw");
+				return -EINVAL;
+			}
+		}
+
+		/* dst = dev */
+		_ctr2 |= CTR2_DREQ;
+
+		break;
+
+	case DMA_DEV_TO_MEM:
+		/* Set source (device) data width and burst */
+		sdw = min_t(u32, sdw, stm32_dma3_get_max_dw(len, src_addr, chan_max_burst));
+		_ctr1 |= FIELD_PREP(CTR1_SDW_LOG2, ilog2(sdw));
+		sbl_max = min_t(u32, sbl_max, stm32_dma3_get_max_burst(len, sdw, chan_max_burst));
+		_ctr1 |= FIELD_PREP(CTR1_SBL_1, sbl_max - 1);
+
+		/* Set destination (memory) data width and burst */
+		ddw = stm32_dma3_get_max_dw(len, dst_addr, chan_max_burst);
+		_ctr1 |= FIELD_PREP(CTR1_DDW_LOG2, ilog2(ddw));
+		dbl_max = stm32_dma3_get_max_burst(len, ddw, chan_max_burst);
+		_ctr1 |= FIELD_PREP(CTR1_DBL_1, dbl_max - 1);
+
+		/* TODO: packing is not supported if PFREQ=1 */
+		if (ddw != sdw) {
+			_ctr1 |= FIELD_PREP(CTR1_PAM, CTR1_PAM_PACK_UNPACK);
+			/* Should never reach this case as ddw is clamped down */
+			if (len & (ddw - 1)) {
+				dev_err(chan2dev(chan),
+					"Packing mode is enabled and len is not multiple of ddw");
+				return -EINVAL;
+			}
+		}
+
+		/* dst = mem */
+		_ctr2 &= ~CTR2_DREQ;
+
+		break;
+
+	case DMA_MEM_TO_MEM:
+		/* Set source (memory) data width and burst */
+		sdw = stm32_dma3_get_max_dw(len, src_addr, chan_max_burst);
+		_ctr1 |= FIELD_PREP(CTR1_SDW_LOG2, ilog2(sdw));
+		sbl_max = stm32_dma3_get_max_burst(len, sdw, chan_max_burst);
+		_ctr1 |= FIELD_PREP(CTR1_SBL_1, sbl_max - 1);
+
+		/* Set destination (memory) data width and burst */
+		ddw = stm32_dma3_get_max_dw(len, dst_addr, chan_max_burst);
+		_ctr1 |= FIELD_PREP(CTR1_DDW_LOG2, ilog2(ddw));
+		dbl_max = stm32_dma3_get_max_burst(len, ddw, chan_max_burst);
+		_ctr1 |= FIELD_PREP(CTR1_DBL_1, dbl_max - 1);
+
+		if (ddw != sdw)
+			_ctr1 |= FIELD_PREP(CTR1_PAM, CTR1_PAM_PACK_UNPACK);
+
+		/* CTR2_REQSEL/DREQ/BREQ/PFREQ are ignored with CTR2_SWREQ=1 */
+		_ctr2 |= CTR2_SWREQ;
+
+		break;
+
+	default:
+		dev_err(chan2dev(chan), "Invalid direction\n");
+		return -EINVAL;
+	}
+
+	*ccr = _ccr;
+	*ctr1 = _ctr1;
+	*ctr2 = _ctr2;
+	*ctr3 = _ctr3; //TODO
+
+	dev_dbg(chan2dev(chan),	"%s: sdw=%u bytes sbl=%u beats ddw=%u bytes dbl=%u beats\n",
+		__func__, sdw, sbl_max, ddw, dbl_max);
+
+	return 0;
+}
+
+static void stm32_dma3_chan_start(struct stm32_dma3_chan *chan)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(&chan->vchan.chan);
+	struct virt_dma_desc *vdesc;
+	struct stm32_dma3_hwdesc *hwdesc;
+	u32 id = chan->id;
+	u32 csr, ccr;
+
+	vdesc = vchan_next_desc(&chan->vchan);
+	if (!vdesc) {
+		chan->swdesc = NULL;
+		return;
+	}
+
+	chan->swdesc = to_stm32_dma3_swdesc(vdesc);
+	hwdesc = chan->swdesc->lli[0].hwdesc;
+	chan->curr_lli = 0;
+
+	{ //TODO: to remove
+		u32 i;
+
+		for (i = 0; i < chan->swdesc->lli_size; i++) {
+			if (i) {
+				dev_dbg(chan2dev(chan), "|");
+				dev_dbg(chan2dev(chan), "V");
+			}
+			dev_dbg(chan2dev(chan), "lli[%d]", i);
+			stm32_dma3_chan_dump_hwdesc(chan, &chan->swdesc->lli[i]);
+		}
+	}
+
+	writel_relaxed(chan->swdesc->ccr, ddata->base + STM32_DMA3_CCR(id));
+	writel_relaxed(hwdesc->ctr1, ddata->base + STM32_DMA3_CTR1(id));
+	writel_relaxed(hwdesc->ctr2, ddata->base + STM32_DMA3_CTR2(id));
+	writel_relaxed(hwdesc->cbr1, ddata->base + STM32_DMA3_CBR1(id));
+	writel_relaxed(hwdesc->csar, ddata->base + STM32_DMA3_CSAR(id));
+	writel_relaxed(hwdesc->cdar, ddata->base + STM32_DMA3_CDAR(id));
+	if (chan->ext_addressing) { //TODO
+		writel_relaxed(0 /* hwdesc->ctr3 */, ddata->base + STM32_DMA3_CTR3(id));
+		writel_relaxed(0 /* hwdesc->cbr2 */, ddata->base + STM32_DMA3_CBR2(id));
+	}
+	writel_relaxed(hwdesc->cllr, ddata->base + STM32_DMA3_CLLR(id));
+
+	/* Clear any pending interrupts */
+	csr = readl_relaxed(ddata->base + STM32_DMA3_CSR(id));
+	if (csr & CSR_ALL_F)
+		writel_relaxed(csr, ddata->base + STM32_DMA3_CFCR(id));
+
+	stm32_dma3_chan_dump_reg(chan);
+
+	ccr = readl_relaxed(ddata->base + STM32_DMA3_CCR(id));
+	writel_relaxed(ccr | CCR_EN, ddata->base + STM32_DMA3_CCR(id));
+
+	chan->dma_status = DMA_IN_PROGRESS;
+
+	dev_dbg(chan2dev(chan), "vchan %pK: started\n", &chan->vchan);
+}
+
+static void stm32_dma3_chan_suspend(struct stm32_dma3_chan *chan, bool susp)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(&chan->vchan.chan);
+	u32 ccr = readl_relaxed(ddata->base + STM32_DMA3_CCR(chan->id));
+
+	if (susp)
+		ccr |= CCR_SUSP;
+	else
+		ccr &= ~CCR_SUSP;
+
+	writel_relaxed(ccr, ddata->base + STM32_DMA3_CCR(chan->id));
+
+	/* TODO: Wait for SUSPF interrupt if suspend required */
+}
+
+static void stm32_dma3_chan_reset(struct stm32_dma3_chan *chan)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(&chan->vchan.chan);
+	u32 ccr = readl_relaxed(ddata->base + STM32_DMA3_CCR(chan->id));
+
+	writel_relaxed(ccr |= CCR_RESET, ddata->base + STM32_DMA3_CCR(chan->id));
+}
+
+static void stm32_dma3_chan_set_residue(struct stm32_dma3_chan *chan,
+					struct stm32_dma3_swdesc *swdesc,
+					struct dma_tx_state *txstate)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(&chan->vchan.chan);
+	struct stm32_dma3_hwdesc *hwdesc;
+	u32 residue, cbr1, cdar, csr, bndt, ctr1, fifol, cdar_start, cdar_end;
+	u32 i, _curr_lli = chan->curr_lli;
+
+	residue = 0;
+
+	/* Read registers to have a snapshot */
+	cbr1 = readl_relaxed(ddata->base + STM32_DMA3_CBR1(chan->id));
+	cdar = readl_relaxed(ddata->base + STM32_DMA3_CDAR(chan->id));
+	csr = readl_relaxed(ddata->base + STM32_DMA3_CSR(chan->id));
+
+
+	/* Check if a TCF flag is pending to fix curr_lli */
+	csr = readl_relaxed(ddata->base + STM32_DMA3_CSR(chan->id));
+	if (csr & CSR_TCF) {
+		dev_dbg(chan2dev(chan), "TCF set, curr_lli not yet updated\n");
+		_curr_lli++;
+		if (swdesc->cyclic && _curr_lli == swdesc->lli_size)
+			_curr_lli = 0;
+	}
+
+	/* Add all pending hwdesc BNDT */
+	for (i = _curr_lli + 1; i < swdesc->lli_size; i++) {
+		hwdesc = swdesc->lli[i].hwdesc;
+		residue += FIELD_GET(CBR1_BNDT, hwdesc->cbr1);
+	}
+
+	/* Add current BNDT */
+	bndt = FIELD_GET(CBR1_BNDT, cbr1);
+	residue += bndt;
+
+	/* Read current FIFO level - in units of programmed dst data width */
+	ctr1 = readl_relaxed(ddata->base + STM32_DMA3_CTR1(chan->id));
+	fifol = FIELD_GET(CSR_FIFOL, csr) * (1 << FIELD_GET(CTR1_DDW_LOG2, ctr1));
+
+	/*
+	 * Be careful! In case of PACKING (Destination data width > Source data width),
+	 * some bytes could be pending in the FIFO (to be packed up to Destination data width),
+	 * so BNDT is not reliable. In this case, FIFOL is not sufficient (because it reflects
+	 * the number of available write beats in units of Destination data width but not the bytes
+	 * not yet packed). In case of Destination increment DINC, it is possible to compute the
+	 * number of bytes in the FIFO:
+	 * fifol_in_bytes = bytes_read - bytes_written.
+	 */
+	if (!fifol && (FIELD_GET(CTR1_PAM, ctr1) == CTR1_PAM_PACK_UNPACK) && (ctr1 & CTR1_DINC)) {
+		int bytes_read, bytes_written;
+
+		cdar_start = swdesc->lli[_curr_lli].hwdesc->cdar;
+		cdar_end = cdar_start + FIELD_GET(CBR1_BNDT, swdesc->lli[_curr_lli].hwdesc->cbr1);
+		if (cdar < cdar_start || cdar > cdar_end) {
+			dev_err(chan2dev(chan),
+				"Current DAR (0x%08x) outside range [0x%08x;0x%08x[\n",
+				cdar, cdar_start, cdar_end);
+			goto skip_fifol_update;
+		}
+
+		bytes_read = FIELD_GET(CBR1_BNDT, swdesc->lli[_curr_lli].hwdesc->cbr1) - bndt;
+		bytes_written = cdar - cdar_start;
+
+		if (bytes_read > 0) {
+			fifol = bytes_read - bytes_written;
+			dma_set_in_flight_bytes(txstate, fifol);
+			if (fifol)
+				dev_dbg(chan2dev(chan),	"%d byte(s) stucked in the FIFO\n", fifol);
+		}
+	}
+
+skip_fifol_update:
+	residue += fifol;
+	dma_set_residue(txstate, residue);
+}
+
+/* Must be called in atomic context */
+static int stm32_dma3_chan_stop(struct stm32_dma3_chan *chan)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(&chan->vchan.chan);
+	u32 ccr, csr;
+	int ret = 0;
+
+	/* Disable interrupts */
+	ccr = readl_relaxed(ddata->base + STM32_DMA3_CCR(chan->id));
+	writel_relaxed(ccr & ~CCR_ALLIE, ddata->base + STM32_DMA3_CCR(chan->id));
+
+	if (!(ccr & CCR_EN))
+		return 0;
+
+	if (!(ccr & CCR_SUSP)) {
+		/* Suspend the channel */
+		stm32_dma3_chan_suspend(chan, true);
+
+		/* Poll SUSPF to wait for the completion of any on-going DMA transfer */
+		ret = readl_relaxed_poll_timeout_atomic(ddata->base + STM32_DMA3_CSR(chan->id),
+							csr, (csr & CSR_SUSPF), 10, USEC_PER_SEC);
+		if (ret)
+			dev_warn(chan2dev(chan),
+				 "%s: timeout, data might be lost (FIFO status=%04lx)\n", __func__,
+				 FIELD_GET(CSR_FIFOL, csr));
+	}
+
+
+	/*
+	 * Reset the channel: this causes the reset of the FIFO and the reset
+	 * of the channel internal state, the reset of CCR_EN and CCR_SUSP
+	 * bits.
+	 */
+	stm32_dma3_chan_reset(chan);
+
+	chan->dma_status = DMA_COMPLETE;
+
+	return ret;
+}
+
+static void stm32_dma3_chan_complete(struct stm32_dma3_chan *chan)
+{
+	if (!chan->swdesc)
+		return;
+
+	if (chan->tcem == CTR2_TCEM_CHANNEL)
+		chan->curr_lli = chan->swdesc->lli_size;
+
+	list_del(&chan->swdesc->vdesc.node);
+	vchan_cookie_complete(&chan->swdesc->vdesc);
+	chan->swdesc = NULL;
+	stm32_dma3_chan_start(chan);
+}
+
+static irqreturn_t stm32_dma3_chan_irq(int irq, void *devid)
+{
+	struct stm32_dma3_chan *chan = devid;
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(&chan->vchan.chan);
+	u32 misr, csr, ccr;
+
+	spin_lock(&chan->vchan.lock);
+
+	misr = readl_relaxed(ddata->base + STM32_DMA3_MISR);
+	if (!(misr & MISR_MIS(chan->id))) {
+		spin_unlock(&chan->vchan.lock);
+		return IRQ_NONE;
+	}
+
+	csr = readl_relaxed(ddata->base + STM32_DMA3_CSR(chan->id));
+	ccr = readl_relaxed(ddata->base + STM32_DMA3_CCR(chan->id)) & CCR_ALLIE;
+
+	if (csr & CSR_SUSPF && ccr & CCR_SUSPIE) {
+		dev_info(chan2dev(chan),
+			 "Chan is suspended (FIFO status=%04lx)\n", FIELD_GET(CSR_FIFOL, csr));
+		chan->dma_status = DMA_PAUSED;
+		stm32_dma3_chan_dump_reg(chan);
+	}
+
+	//TODO: to remove when driver will be mature
+	if (csr & CSR_USEF && ccr & CCR_USEIE) {
+		dev_err(chan2dev(chan), "User setting error\n");
+		chan->dma_status = DMA_ERROR;
+		/* CCR.EN automatically cleared by HW */
+		stm32_dma3_check_user_setting(chan->swdesc->lli[chan->curr_lli].hwdesc);
+		stm32_dma3_chan_reset(chan);
+	}
+
+	if (csr & CSR_ULEF && ccr & CCR_ULEIE) {
+		dev_err(chan2dev(chan), "Update link transfer error\n");
+		chan->dma_status = DMA_ERROR;
+		/* CCR.EN automatically cleared by HW */
+		stm32_dma3_chan_reset(chan);
+	}
+
+	if (csr & CSR_DTEF && ccr & CCR_DTEIE) {
+		dev_err(chan2dev(chan), "Data transfer error\n");
+		chan->dma_status = DMA_ERROR;
+		/* CCR.EN automatically cleared by HW */
+		stm32_dma3_chan_reset(chan);
+	}
+
+	if (csr & CSR_TCF && ccr & CCR_TCIE) {
+		dev_dbg(chan2dev(chan), "Transfer complete\n");
+		chan->curr_lli++;
+		if (chan->swdesc->cyclic) {
+			if (chan->curr_lli == chan->swdesc->lli_size)
+				chan->curr_lli = 0;
+			vchan_cyclic_callback(&chan->swdesc->vdesc);
+		} else {
+			stm32_dma3_chan_complete(chan);
+		}
+	}
+
+	/*
+	 * Half Transfer Interrupt is disabled but Half Transfer Flag can be set,
+	 * ensure HTF flag to be cleared, with other flags.
+	 */
+	csr &= (ccr | CCR_HTIE);
+
+	if (csr)
+		writel_relaxed(csr, ddata->base + STM32_DMA3_CFCR(chan->id));
+
+	spin_unlock(&chan->vchan.lock);
+
+	return IRQ_HANDLED;
+}
+
+/*** Device operations ***/
+
+static int stm32_dma3_alloc_chan_resources(struct dma_chan *c)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(c);
+	u32 id = chan->id, csemcr, ccid;
+	int ret;
+
+	ret = pm_runtime_resume_and_get(ddata->dma_dev.dev);
+	if (ret < 0)
+		return ret;
+
+	/* Ensure the channel is free (it should be, because it is checked in filter_fn) */
+	if (readl_relaxed(ddata->base + STM32_DMA3_CSEMCR(chan->id)) & CSEMCR_SEM_MUTEX) {
+		ret = -EBUSY;
+		goto err_put_sync;
+	}
+
+	chan->lli_pool = dmam_pool_create(dev_name(&c->dev->device), c->device->dev,
+					  sizeof(struct stm32_dma3_hwdesc),
+					  __alignof__(struct stm32_dma3_hwdesc), 0);
+	if (!chan->lli_pool) {
+		dev_err(chan2dev(chan), "Failed to create LLI pool\n");
+		ret = -ENOMEM;
+		goto err_put_sync;
+	}
+
+	/* Take the channel semaphore */
+	if (chan->semaphore_mode) {
+		writel_relaxed(CSEMCR_SEM_MUTEX, ddata->base + STM32_DMA3_CSEMCR(id));
+		csemcr = readl_relaxed(ddata->base + STM32_DMA3_CSEMCR(id));
+		ccid = FIELD_GET(CSEMCR_SEM_CCID, csemcr);
+		/* Check that the channel is well taken */
+		if (ccid != CCIDCFGR_CID1) {
+			dev_err(chan2dev(chan), "not under CID1 control (used by CID%d)\n", ccid);
+			ret = -EPERM;
+			goto err_pool_destroy;
+		}
+		dev_dbg(chan2dev(chan), "under CID1 control (semcr=0x%08x)\n", csemcr);
+	}
+
+	return 0;
+
+err_pool_destroy:
+	dmam_pool_destroy(chan->lli_pool);
+	chan->lli_pool = NULL;
+
+err_put_sync:
+	pm_runtime_put_sync(ddata->dma_dev.dev);
+
+	return ret;
+}
+
+static void stm32_dma3_free_chan_resources(struct dma_chan *c)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(c);
+	unsigned long flags;
+
+	dev_dbg(chan2dev(chan), "%s\n", __func__);
+
+	/* Ensure channel is in idle state */
+	spin_lock_irqsave(&chan->vchan.lock, flags);
+	stm32_dma3_chan_stop(chan);
+	chan->swdesc = NULL; //TODO
+	spin_unlock_irqrestore(&chan->vchan.lock, flags);
+
+	vchan_free_chan_resources(to_virt_chan(c));
+	/*
+	 * Caller must guarantee that no more memory from the pool is in use,
+	 * and that nothing will try to use the pool after this call.
+	 */
+	dmam_pool_destroy(chan->lli_pool);
+	chan->lli_pool = NULL;
+
+	/* Release the channel semaphore */
+	if (chan->semaphore_mode)
+		writel_relaxed(0, ddata->base + STM32_DMA3_CSEMCR(chan->id));
+
+	pm_runtime_put_sync(ddata->dma_dev.dev);
+
+	/* Reset configuration */
+	memset(&chan->dt_config, 0, sizeof(chan->dt_config));
+	memset(&chan->dma_config, 0, sizeof(chan->dma_config));
+	chan->config_set = 0;
+}
+
+static void stm32_dma3_init_chan_config_for_memcpy(struct stm32_dma3_chan *chan,
+						   dma_addr_t dst, dma_addr_t src)
+{
+	u32 half_fifo = min_t(u32, chan->fifo_size, (1 << (chan->fifo_size + 1)) / 2);
+	u32 dw = half_fifo < DMA_SLAVE_BUSWIDTH_8_BYTES ? DMA_SLAVE_BUSWIDTH_4_BYTES :
+							  DMA_SLAVE_BUSWIDTH_8_BYTES;
+	u32 burst = !chan->fifo_size ? 0 : half_fifo / dw;
+
+	/* Initialize dt_config if channel not pre-configured through DT */
+	if (!(chan->config_set & STM32_DMA3_CFG_SET_DT)) {
+		chan->dt_config.ch_conf = FIELD_PREP(STM32_DMA3_DT_PRIO, CCR_PRIO_VERY_HIGH);
+		chan->dt_config.ch_conf |= FIELD_PREP(STM32_DMA3_DT_FIFO, chan->fifo_size);
+		chan->dt_config.tr_conf = STM32_DMA3_DT_SINC | STM32_DMA3_DT_DINC;
+		chan->dt_config.tr_conf |= FIELD_PREP(STM32_DMA3_DT_TCEM, CTR2_TCEM_CHANNEL);
+		chan->dt_config.tr_conf_ext = 0;
+
+		dev_dbg(chan2dev(chan), "%s: ch_conf=%08x tr_conf=%08x\n",
+			__func__, chan->dt_config.ch_conf, chan->dt_config.tr_conf);
+	}
+
+	/* Initialize dma_config if dmaengine_slave_config() not used */
+	if (!(chan->config_set & STM32_DMA3_CFG_SET_DMA)) {
+		chan->dma_config.src_addr_width = dw;
+		chan->dma_config.dst_addr_width = dw;
+		chan->dma_config.src_maxburst = burst;
+		chan->dma_config.dst_maxburst = burst;
+		chan->dma_config.src_addr = src;
+		chan->dma_config.dst_addr = dst;
+
+		dev_dbg(chan2dev(chan), "%s: dma_config.*_addr_width=%d .*_max_burst=%d\n",
+			__func__, dw, burst);
+	}
+}
+
+static struct dma_async_tx_descriptor *stm32_dma3_prep_dma_memcpy(struct dma_chan *c,
+								  dma_addr_t dst, dma_addr_t src,
+								  size_t len, unsigned long flags)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+	struct stm32_dma3_swdesc *swdesc;
+	size_t next_size, offset;
+	u32 max_block_size = STM32_DMA3_MAX_BLOCK_SIZE;
+	u32 count, i, ccr, ctr1, ctr2, ctr3;
+
+	/* TODO: Check if channel is busy ? */
+
+/* TODO: ch12-15 extra block size
+ *	if (chan->ext_addressing) {
+ *                if (len >= STM32_DMA3_MAX_256B_BLOCK_SIZE && !(len % 256))
+ *                        max_block_size = STM32_DMA3_MAX_256B_BLOCK_SIZE;
+ *                else if (len >= STM32_DMA3_MAX_16B_BLOCK_SIZE && !(len % 16))
+ *                        max_block_size = STM32_DMA3_MAX_16B_BLOCK_SIZE;
+ *        }
+ */
+
+	count = DIV_ROUND_UP(len, max_block_size);
+	swdesc = stm32_dma3_chan_desc_alloc(chan, count);
+	if (!swdesc)
+		return NULL;
+
+	if (!(chan->config_set & STM32_DMA3_CFG_SET_BOTH))
+		stm32_dma3_init_chan_config_for_memcpy(chan, dst, src);
+
+	/*
+	 * i = current chunk
+	 * offset = bytes already transferred
+	 * len = total size of the transfer in bytes
+	 */
+	for (i = 0, offset = 0; offset < len; i++, offset += next_size) {
+		u32 remaining;
+		int ret;
+
+		remaining = len - offset;
+		next_size = min_t(size_t, remaining, max_block_size);
+
+		ret = stm32_dma3_chan_prep_hw(chan, DMA_MEM_TO_MEM, &ccr, &ctr1, &ctr2, &ctr3,
+					      src + offset, dst + offset, next_size);
+		if (ret)
+			goto err_desc_free;
+
+		ret = stm32_dma3_chan_prep_hwdesc(chan, swdesc, i,
+						  src + offset, dst + offset, next_size,
+						  ctr1, ctr2, ctr3, next_size == remaining, false);
+		if (ret)
+			goto err_desc_free;
+	}
+
+	/* Enable Errors interrupts */
+	ccr |= CCR_USEIE | CCR_ULEIE | CCR_DTEIE;
+	/* Enable Transfer state interrupts */
+	ccr |= CCR_SUSPIE | CCR_TCIE;
+
+	swdesc->ccr = ccr;
+	swdesc->cyclic = false;
+
+	return vchan_tx_prep(&chan->vchan, &swdesc->vdesc, flags);
+
+err_desc_free:
+	stm32_dma3_chan_desc_free(chan, swdesc);
+
+	return NULL;
+}
+
+static struct dma_async_tx_descriptor *stm32_dma3_prep_slave_sg(struct dma_chan *c,
+								struct scatterlist *sgl,
+								unsigned int sg_len,
+								enum dma_transfer_direction dir,
+								unsigned long flags, void *context)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+	struct stm32_dma3_swdesc *swdesc;
+	struct scatterlist *sg;
+	size_t len;
+	dma_addr_t sg_addr, dev_addr, src, dst;
+	u32 max_block_size = STM32_DMA3_MAX_BLOCK_SIZE;
+	u32 i, j, count, ccr, ctr1, ctr2, ctr3;
+	int ret;
+
+	/* TODO: Check if channel is busy ? */
+
+/* TODO: ch12-15 extra block size
+ *	if (chan->ext_addressing) {
+ *                if (len >= STM32_DMA3_MAX_256B_BLOCK_SIZE && !(len % 256))
+ *                        max_block_size = STM32_DMA3_MAX_256B_BLOCK_SIZE;
+ *                else if (len >= STM32_DMA3_MAX_16B_BLOCK_SIZE && !(len % 16))
+ *                        max_block_size = STM32_DMA3_MAX_16B_BLOCK_SIZE;
+ *        }
+ */
+
+	count = sg_len;
+	for_each_sg(sgl, sg, sg_len, i) {
+		len = sg_dma_len(sg);
+		if (len > max_block_size)
+			count += DIV_ROUND_UP(len, max_block_size) - 1;
+	}
+
+	swdesc = stm32_dma3_chan_desc_alloc(chan, count);
+	if (!swdesc)
+		return NULL;
+
+	/* sg_len and i correspond to the initial sgl; count and j correspond to the hwdesc LL */
+	j = 0;
+	for_each_sg(sgl, sg, sg_len, i) {
+		sg_addr = sg_dma_address(sg);
+		dev_addr = (dir == DMA_MEM_TO_DEV) ? chan->dma_config.dst_addr :
+						     chan->dma_config.src_addr;
+		len = sg_dma_len(sg);
+
+		do {
+			size_t chunk = min_t(size_t, len, max_block_size);
+
+			if (dir == DMA_MEM_TO_DEV) {
+				src = sg_addr;
+				dst = dev_addr;
+
+				/* Prepare control & transfer registers */
+				ret = stm32_dma3_chan_prep_hw(chan, dir, &ccr, &ctr1, &ctr2, &ctr3,
+							      src, dst, chunk);
+
+				if (FIELD_GET(CTR1_DINC, ctr1))
+					dev_addr += chunk;
+			} else {//if (dir == DMA_DEV_TO_MEM || dir == DMA_MEM_TO_MEM) { //TODO!!
+				src = dev_addr;
+				dst = sg_addr;
+
+				/* Prepare control & transfer registers */
+				ret = stm32_dma3_chan_prep_hw(chan, dir, &ccr, &ctr1, &ctr2, &ctr3,
+							      src, dst, chunk);
+
+				if (FIELD_GET(CTR1_SINC, ctr1))
+					dev_addr += chunk;
+			}
+
+			if (ret)
+				goto err_desc_free;
+
+			ret = stm32_dma3_chan_prep_hwdesc(chan, swdesc, j, src, dst, chunk,
+							  ctr1, ctr2, ctr3,
+							  j == (count - 1), false);
+			if (ret)
+				goto err_desc_free;
+
+			sg_addr += chunk;
+			len -= chunk;
+			j++;
+		} while (len);
+	}
+
+	/* Enable Error interrupts */
+	ccr |= CCR_USEIE | CCR_ULEIE | CCR_DTEIE;
+	/* Enable Transfer state interrupts */
+	ccr |= CCR_SUSPIE | CCR_TCIE;
+
+	swdesc->ccr = ccr;
+	swdesc->cyclic = false;
+
+	return vchan_tx_prep(&chan->vchan, &swdesc->vdesc, flags);
+
+err_desc_free:
+	stm32_dma3_chan_desc_free(chan, swdesc);
+
+	return NULL;
+}
+
+/*
+ * The function takes a buffer of size buf_len. The callback function will
+ * be called after period_len bytes have been transferred.
+ */
+static struct dma_async_tx_descriptor *stm32_dma3_prep_dma_cyclic(struct dma_chan *c,
+								  dma_addr_t buf_addr,
+								  size_t buf_len, size_t period_len,
+								  enum dma_transfer_direction dir,
+								  unsigned long flags)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+	struct stm32_dma3_swdesc *swdesc;
+	dma_addr_t src, dst;
+	u32 count, i, max_block_size = STM32_DMA3_MAX_BLOCK_SIZE;
+	u32 ccr, ctr1, ctr2, ctr3;
+	int ret;
+
+	/* TODO: Check if channel is busy ? */
+
+/* TODO: ch12-15 extra block size
+ *	if (chan->ext_addressing) {
+ *                if (len >= STM32_DMA3_MAX_256B_BLOCK_SIZE && !(len % 256))
+ *                        max_block_size = STM32_DMA3_MAX_256B_BLOCK_SIZE;
+ *                else if (len >= STM32_DMA3_MAX_16B_BLOCK_SIZE && !(len % 16))
+ *                        max_block_size = STM32_DMA3_MAX_16B_BLOCK_SIZE;
+ *        }
+ */
+
+	if (!buf_len || !period_len || period_len > max_block_size) {
+		dev_err(chan2dev(chan), "Invalid buffer/period len\n");
+		return NULL;
+	}
+
+	if (buf_len % period_len) {
+		dev_err(chan2dev(chan), "buf_len not multiple of period_len\n");
+		return NULL;
+	}
+
+	count = buf_len / period_len;
+	swdesc = stm32_dma3_chan_desc_alloc(chan, count);
+	if (!swdesc)
+		return NULL;
+
+	if (dir == DMA_MEM_TO_DEV) {
+		src = buf_addr;
+		dst = chan->dma_config.dst_addr;
+
+		/* Prepare control & transfer registers */
+		ret = stm32_dma3_chan_prep_hw(chan, DMA_MEM_TO_DEV, &ccr, &ctr1, &ctr2, &ctr3,
+					      src, dst, period_len);
+	} else if (dir == DMA_DEV_TO_MEM) {
+		src = chan->dma_config.src_addr;
+		dst = buf_addr;
+
+		/* Prepare control & transfer registers */
+		ret = stm32_dma3_chan_prep_hw(chan, DMA_DEV_TO_MEM, &ccr, &ctr1, &ctr2, &ctr3,
+					      src, dst, period_len);
+	} else {
+		dev_err(chan2dev(chan), "Invalid direction\n");
+		ret = -EINVAL;
+	}
+
+	if (ret)
+		goto err_desc_free;
+
+	for (i = 0; i < count; i++) {
+		if (dir == DMA_MEM_TO_DEV) {
+			src = buf_addr + i * period_len;
+			dst = chan->dma_config.dst_addr;
+		} else { /* DMA_DEV_TO_MEM */
+			src = chan->dma_config.src_addr;
+			dst = buf_addr + i * period_len;
+		}
+
+		/* TODO: just an update of SAR/DAR in cyclic */
+		ret = stm32_dma3_chan_prep_hwdesc(chan, swdesc, i, src, dst, period_len,
+						  ctr1, ctr2, ctr3, i == (count - 1), true);
+		if (ret)
+			goto err_desc_free;
+	}
+
+	/* Enable Error interrupts */
+	ccr |= CCR_USEIE | CCR_ULEIE | CCR_DTEIE;
+	/* Enable Transfer state interrupts */
+	ccr |= CCR_SUSPIE | CCR_TCIE;
+
+	swdesc->ccr = ccr;
+	swdesc->cyclic = true;
+
+	return vchan_tx_prep(&chan->vchan, &swdesc->vdesc, flags);
+
+err_desc_free:
+	stm32_dma3_chan_desc_free(chan, swdesc);
+
+	return NULL;
+}
+
+static void stm32_dma3_caps(struct dma_chan *c, struct dma_slave_caps *caps)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+
+	if (!chan->fifo_size) {
+		caps->max_burst = 0;
+		caps->src_addr_widths &= ~BIT(DMA_SLAVE_BUSWIDTH_8_BYTES);
+		caps->dst_addr_widths &= ~BIT(DMA_SLAVE_BUSWIDTH_8_BYTES);
+	} else {
+		/* Burst transfer should not exceed half of the fifo size */
+		caps->max_burst = (1 << (chan->fifo_size + 1)) / 2;
+		if (caps->max_burst < DMA_SLAVE_BUSWIDTH_8_BYTES) {
+			caps->src_addr_widths &= ~BIT(DMA_SLAVE_BUSWIDTH_8_BYTES);
+			caps->dst_addr_widths &= ~BIT(DMA_SLAVE_BUSWIDTH_8_BYTES);
+		}
+	}
+
+	caps->max_sg_burst = STM32_DMA3_MAX_SEG_SIZE;
+}
+
+static int stm32_dma3_config(struct dma_chan *c, struct dma_slave_config *config)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+
+	memcpy(&chan->dma_config, config, sizeof(*config));
+	chan->config_set |= STM32_DMA3_CFG_SET_DMA;
+
+	return 0;
+}
+
+static int stm32_dma3_pause(struct dma_chan *c)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+
+	stm32_dma3_chan_suspend(chan, true);
+
+	dev_dbg(chan2dev(chan), "vchan %pK: paused\n", &chan->vchan);
+
+	return 0;
+}
+
+static int stm32_dma3_resume(struct dma_chan *c)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+
+	stm32_dma3_chan_suspend(chan, false);
+
+	chan->dma_status = DMA_IN_PROGRESS;
+
+	dev_dbg(chan2dev(chan), "vchan %pK: resumed\n", &chan->vchan);
+
+	return 0;
+}
+
+static int stm32_dma3_terminate_all(struct dma_chan *c)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+	unsigned long flags;
+	LIST_HEAD(head);
+
+	spin_lock_irqsave(&chan->vchan.lock, flags);
+
+	if (chan->swdesc) {
+		vchan_terminate_vdesc(&chan->swdesc->vdesc);
+		chan->swdesc = NULL;
+	}
+
+	stm32_dma3_chan_stop(chan);
+
+	vchan_get_all_descriptors(&chan->vchan, &head);
+
+	spin_unlock_irqrestore(&chan->vchan.lock, flags);
+	vchan_dma_desc_free_list(&chan->vchan, &head);
+
+	dev_dbg(chan2dev(chan), "vchan %pK: terminated\n", &chan->vchan);
+
+	return 0;
+}
+
+static void stm32_dma3_synchronize(struct dma_chan *c)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+
+	vchan_synchronize(&chan->vchan);
+}
+
+static enum dma_status stm32_dma3_tx_status(struct dma_chan *c, dma_cookie_t cookie,
+					    struct dma_tx_state *txstate)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+	struct stm32_dma3_swdesc *swdesc = NULL;
+	enum dma_status status;
+	unsigned long flags;
+	struct virt_dma_desc *vd;
+
+	status = dma_cookie_status(c, cookie, txstate);
+	if (status == DMA_COMPLETE)
+		return status;
+
+	if (!txstate)
+		return chan->dma_status;
+
+	spin_lock_irqsave(&chan->vchan.lock, flags);
+
+	vd = vchan_find_desc(&chan->vchan, cookie);
+	if (vd)
+		swdesc = to_stm32_dma3_swdesc(vd);
+	else if (chan->swdesc && chan->swdesc->vdesc.tx.cookie == cookie)
+		swdesc = chan->swdesc;
+
+	/* Get residue/in_flight_bytes only if a transfer is currently running (swdesc != NULL) */
+	if (swdesc) {
+		if (chan->tcem == CTR2_TCEM_CHANNEL)
+			dev_warn(chan2dev(chan),
+				 "Due to transfer complete event mode, residue is not reliable\n");
+		stm32_dma3_chan_set_residue(chan, swdesc, txstate);
+	}
+
+	spin_unlock_irqrestore(&chan->vchan.lock, flags);
+
+	return chan->dma_status;
+}
+
+static void stm32_dma3_issue_pending(struct dma_chan *c)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+	unsigned long flags;
+
+	spin_lock_irqsave(&chan->vchan.lock, flags);
+
+	if (vchan_issue_pending(&chan->vchan) && !chan->swdesc) {
+		stm32_dma3_chan_start(chan);
+		dev_dbg(chan2dev(chan), "vchan %pK: issued\n", &chan->vchan);
+	} else {
+		dev_dbg(chan2dev(chan), "vchan %pK: nothing to issue\n", &chan->vchan);
+	}
+
+	spin_unlock_irqrestore(&chan->vchan.lock, flags);
+}
+
+/*
+ * callback filter for dma_request_channel
+ */
+static bool stm32_dma3_filter_fn(struct dma_chan *c, void *fn_param)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(c);
+	struct stm32_dma3_dt_conf *conf = fn_param;
+	u32 mask, semcr;
+	int ret;
+
+	dev_dbg(c->device->dev, "%s(%s): req_line=%d ch_conf=%08x tr_conf=%08x tr_conf_ext=%08x\n",
+		__func__, dma_chan_name(c),
+		conf->req_line, conf->ch_conf, conf->tr_conf, conf->tr_conf_ext);
+
+	/* Check if chan is reserved (Secure) */
+	if (ddata->chan_reserved & BIT(chan->id))
+		return false;
+
+	if (!of_property_read_u32(c->device->dev->of_node, "dma-channel-mask", &mask))
+		if (!(mask & BIT(chan->id)))
+			return false;
+
+	ret = pm_runtime_resume_and_get(ddata->dma_dev.dev);
+	if (ret < 0)
+		return false;
+	semcr = readl_relaxed(ddata->base + STM32_DMA3_CSEMCR(chan->id));
+	pm_runtime_put_sync(ddata->dma_dev.dev);
+
+	/* Check if chan is free */
+	if (semcr & CSEMCR_SEM_MUTEX)
+		return false;
+
+	/* Check if chan fifo fits well */
+	if (FIELD_GET(STM32_DMA3_DT_FIFO, conf->ch_conf) != chan->fifo_size)
+		return false;
+
+	/* Check if chan features fit well */
+	if (conf->tr_conf_ext && !chan->ext_addressing)
+		return false;
+
+	return true;
+}
+
+/*
+ * translation function which converts a phandle arguments list into a dma_chan
+ * structure
+ */
+static struct dma_chan *stm32_dma3_of_xlate(struct of_phandle_args *dma_spec, struct of_dma *ofdma)
+{
+	struct stm32_dma3_ddata *ddata = ofdma->of_dma_data;
+	dma_cap_mask_t mask = ddata->dma_dev.cap_mask;
+	struct stm32_dma3_dt_conf conf;
+	struct stm32_dma3_chan *chan;
+	struct dma_chan *c;
+
+	dev_dbg(ddata->dma_dev.dev, "%s\n", __func__);
+
+	if (dma_spec->args_count < 4) {
+		dev_err(ddata->dma_dev.dev, "Invalid args count\n");
+		return NULL;
+	}
+
+	conf.req_line = dma_spec->args[0];
+	conf.ch_conf = dma_spec->args[1];
+	conf.tr_conf = dma_spec->args[2];
+	conf.tr_conf_ext = dma_spec->args[3];
+
+	//TODO: should check other parameters
+
+	if (conf.req_line >= ddata->dma_requests) {
+		dev_err(ddata->dma_dev.dev, "Invalid request line\n");
+		return NULL;
+	}
+
+	/* Find a channel among all registered dma controllers, rely on find_candidate() */
+	c = dma_request_channel(mask, stm32_dma3_filter_fn, &conf);
+	if (!c) {
+		dev_err(ddata->dma_dev.dev, "No suitable channel found\n");
+		return NULL;
+	}
+
+	chan = to_stm32_dma3_chan(c);
+	chan->dt_config = conf;
+	chan->config_set |= STM32_DMA3_CFG_SET_DT;
+
+	return c;
+}
+
+static void stm32_dma3_check_rif(struct stm32_dma3_ddata *ddata)
+{
+	u32 mask = 0, i, ccidcfgr, invalid_cid = 0;
+
+	/* reserve Secure channels */
+	ddata->chan_reserved = readl_relaxed(ddata->base + STM32_DMA3_SECCFGR);
+
+	of_property_read_u32(ddata->dma_dev.dev->of_node, "dma-channel-mask", &mask);
+
+	/*
+	 * CID filtering must be configured to ensure that the DMA3 channel will inherit the CID of
+	 * the processor which is configuring and using the given channel.
+	 */
+
+	/* reserve !CID-filtered, static CID != CID1, CID1 not in allowlist channels */
+	for (i = 0; i < ddata->dma_channels; i++) {
+		ccidcfgr = readl_relaxed(ddata->base + STM32_DMA3_CCIDCFGR(i));
+
+		if (!(ccidcfgr & CCIDCFGR_CFEN)) { /* !CID-filtered */
+			invalid_cid |= BIT(i);
+			if (!(mask & BIT(i)))
+				ddata->chan_reserved |= BIT(i);
+		} else { /* CID-filtered */
+			if (!(ccidcfgr & CCIDCFGR_SEM_EN)) { /* Static CID mode */
+				if (FIELD_GET(CCIDCFGR_SCID, ccidcfgr) != CCIDCFGR_CID1)
+					ddata->chan_reserved |= BIT(i);
+			} else { /* Semaphore mode */
+				if (!FIELD_GET(CCIDCFGR_SEM_WLIST_CID1, ccidcfgr))
+					ddata->chan_reserved |= BIT(i);
+				ddata->chans[i].semaphore_mode = true;
+			}
+		}
+		dev_dbg(ddata->dma_dev.dev, "chan%d: %s mode, %s\n", i,
+			!(ccidcfgr & CCIDCFGR_CFEN) ? "!CID-filtered" :
+			ddata->chans[i].semaphore_mode ? "Semaphore" : "Static CID",
+			(ddata->chan_reserved & BIT(i)) ? "denied" :
+			mask & BIT(i) ? "force allowed" : "allowed");
+	}
+
+	if (invalid_cid)
+		dev_warn(ddata->dma_dev.dev, "chan%*pbl have invalid CID configuration\n",
+			 ddata->dma_channels, &invalid_cid);
+}
+
+static const struct of_device_id stm32_dma3_of_match[] = {
+	{ .compatible = "st,stm32-dma3", },
+	{ /* sentinel */},
+};
+MODULE_DEVICE_TABLE(of, stm32_dma3_of_match);
+
+static int stm32_dma3_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct stm32_dma3_ddata *ddata;
+	struct reset_control *reset;
+	struct stm32_dma3_chan *chan;
+	struct dma_device *dma_dev;
+	struct resource *res;
+	u32 i, j, hwcfgr[4], verr;
+	int ret;
+
+	ddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);
+	if (!ddata)
+		return -ENOMEM;
+
+	dma_dev = &ddata->dma_dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	ddata->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(ddata->base))
+		return PTR_ERR(ddata->base);
+
+	ddata->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(ddata->clk)) {
+		ret = PTR_ERR(ddata->clk);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Failed to get clk: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(ddata->clk);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to enable clk: %d\n", ret);
+		return ret;
+	}
+
+	reset = devm_reset_control_get(&pdev->dev, NULL);
+	if (IS_ERR(reset)) {
+		ret = PTR_ERR(reset);
+		if (ret == -EPROBE_DEFER)
+			goto err_clk_disable;
+	} else {
+		reset_control_assert(reset);
+		reset_control_deassert(reset);
+	}
+
+	INIT_LIST_HEAD(&dma_dev->channels);
+
+	//TODO: dma_device->filter* used in case of non-DT support ?
+	//dma_device->filter = ?
+	//dma_device->filter.map = ?
+	//dma_device->filter.mapcnt ?
+	//dma_device->filter.fn = ?
+
+	dma_cap_set(DMA_SLAVE, dma_dev->cap_mask);
+	dma_cap_set(DMA_PRIVATE, dma_dev->cap_mask);
+	dma_cap_set(DMA_CYCLIC, dma_dev->cap_mask);
+	dma_cap_set(DMA_MEMCPY, dma_dev->cap_mask);
+	dma_dev->dev = &pdev->dev;
+	/*
+	 * This controller supports up to 8-byte buswidth depending on channel
+	 * and can only access address at even boundaries, multiple of the
+	 * buswidth.
+	 */
+	dma_dev->copy_align = DMAENGINE_ALIGN_8_BYTES;
+	dma_dev->src_addr_widths = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |
+				   BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |
+				   BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) |
+				   BIT(DMA_SLAVE_BUSWIDTH_8_BYTES);
+	dma_dev->dst_addr_widths = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |
+				   BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |
+				   BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) |
+				   BIT(DMA_SLAVE_BUSWIDTH_8_BYTES);
+	dma_dev->directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV) |
+			      BIT(DMA_MEM_TO_MEM) | BIT(DMA_DEV_TO_DEV);
+	//TODO: DMA_DEV_TO_DEV: really???
+
+	/*
+	 * Burst transfer should not exceed half of the fifo size, so set the max half fifo size
+	 * but it is updated by stm32_dma3_caps depending on the channel. Clients should use
+	 * dma_get_slave_caps() prior to configure a transfer.
+	 */
+	dma_dev->max_burst = SZ_64;
+	//TODO: a submitted transfer can be resubmitted after completion
+	//dma_device->descriptor_reuse = true;
+	dma_dev->residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;
+	dma_dev->device_alloc_chan_resources = stm32_dma3_alloc_chan_resources;
+	dma_dev->device_free_chan_resources = stm32_dma3_free_chan_resources;
+	dma_dev->device_prep_dma_memcpy = stm32_dma3_prep_dma_memcpy;
+	dma_dev->device_prep_slave_sg = stm32_dma3_prep_slave_sg;
+	dma_dev->device_prep_dma_cyclic = stm32_dma3_prep_dma_cyclic;
+	dma_dev->device_caps = stm32_dma3_caps;
+	dma_dev->device_config = stm32_dma3_config;
+	dma_dev->device_pause = stm32_dma3_pause;
+	dma_dev->device_resume = stm32_dma3_resume;
+	dma_dev->device_terminate_all = stm32_dma3_terminate_all;
+	dma_dev->device_synchronize = stm32_dma3_synchronize;
+	dma_dev->device_tx_status = stm32_dma3_tx_status;
+	dma_dev->device_issue_pending = stm32_dma3_issue_pending;
+#ifdef CONFIG_DEBUG_FS
+	dma_dev->dbg_summary_show = stm32_dma3_dbg_summary_show;
+#endif
+
+	dma_set_max_seg_size(dma_dev->dev, STM32_DMA3_MAX_SEG_SIZE);
+
+	/* if dma_channels is not modified, get it from hwcfgr1 */
+	if (of_property_read_u32(np, "dma-channels", &ddata->dma_channels)) {
+		hwcfgr[0] = readl_relaxed(ddata->base + STM32_DMA3_HWCFGR1);
+		ddata->dma_channels = FIELD_GET(G_NUM_CHANNELS, hwcfgr[0]);
+	}
+
+	/* if dma_requests is not modified, get it from hwcfgr2 */
+	if (of_property_read_u32(np, "dma-requests", &ddata->dma_requests)) {
+		hwcfgr[0] = readl_relaxed(ddata->base + STM32_DMA3_HWCFGR2);
+		ddata->dma_requests = FIELD_GET(G_MAX_REQ_ID, hwcfgr[0]) + 1;
+	}
+
+	//TODO: pre-allocate any memory needed during transfer setup to avoid
+	//putting to much pressure on the nowait allocator.
+
+	//TODO: as many vchan as dma_channels or dma_requests ?
+	ddata->chans = devm_kcalloc(&pdev->dev, ddata->dma_channels, sizeof(*ddata->chans),
+				    GFP_KERNEL);
+	if (!ddata->chans) {
+		ret = -ENOMEM;
+		goto err_clk_disable;
+	}
+
+	/* Get max burst length property */
+	ret = of_property_read_u32(np, "st,burstlen", &ddata->max_burst_length);
+	if (ret)
+		/* Set to max value if not DT properties */
+		ddata->max_burst_length = 64;
+
+	stm32_dma3_check_rif(ddata);
+
+	/* TODO: check that all channels support burst and linked-list ? */
+	/* G_FIFO_SIZE x=0..7 */
+	hwcfgr[0] = readl_relaxed(ddata->base + STM32_DMA3_HWCFGR3);
+	/* G_FIFO_SIZE x=8..15 */
+	hwcfgr[1] = readl_relaxed(ddata->base + STM32_DMA3_HWCFGR4);
+	/* G_ADDRESSING x=0..7 */
+	hwcfgr[2] = readl_relaxed(ddata->base + STM32_DMA3_HWCFGR9);
+	/* G_ADDRESSING x=8..15 */
+	hwcfgr[3] = readl_relaxed(ddata->base + STM32_DMA3_HWCFGR10);
+
+	for (i = 0, j = 0; i < ddata->dma_channels; i++, j = i / 8) {
+		u32 g_fifosz, g_addr;
+
+		g_fifosz = get_chan_hwcfg(i, G_FIFO_SIZE(i), hwcfgr[j]);
+		g_addr = get_chan_hwcfg(i, G_ADDRESSING(i), hwcfgr[j + 2]);
+
+		chan = &ddata->chans[i];
+		chan->id = i;
+		chan->fifo_size = g_fifosz; /* If !g_fifosz, then no FIFO, no burst */
+		chan->ext_addressing = (g_addr != G_ADDRESSING_FIXED_BLOCK);
+		chan->vchan.desc_free = stm32_dma3_chan_vdesc_free;
+
+		vchan_init(&chan->vchan, dma_dev);
+	}
+
+	ret = dmaenginem_async_device_register(dma_dev);
+	if (ret)
+		goto err_clk_disable;
+
+	for (i = 0; i < ddata->dma_channels; i++) {
+		chan = &ddata->chans[i];
+		ret = platform_get_irq(pdev, i);
+		if (ret < 0) {
+			dev_err(&pdev->dev,
+				"Failed to get %s IRQ: %d\n", dev_name(chan2dev(chan)), ret);
+			goto err_clk_disable;
+		}
+		chan->irq = ret;
+
+		ret = devm_request_irq(&pdev->dev, chan->irq, stm32_dma3_chan_irq, 0,
+				       dev_name(chan2dev(chan)), chan);
+		if (ret) {
+			dev_err(&pdev->dev,
+				"Failed to request %s IRQ: %d\n", dev_name(chan2dev(chan)), ret);
+			goto err_clk_disable;
+		}
+	}
+
+	ret = of_dma_controller_register(np, stm32_dma3_of_xlate, ddata);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register controller: %d\n", ret);
+		goto err_clk_disable;
+	}
+
+	platform_set_drvdata(pdev, ddata);
+
+	verr = readl_relaxed(ddata->base + STM32_DMA3_VERR);
+
+	pm_runtime_set_active(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
+	pm_runtime_get_noresume(&pdev->dev);
+	pm_runtime_put(&pdev->dev);
+
+	dev_info(&pdev->dev, "STM32 DMA3 registered rev:%lu.%lu\n",
+		 FIELD_GET(VERR_MAJREV, verr), FIELD_GET(VERR_MINREV, verr));
+
+	return 0;
+
+err_clk_disable:
+	clk_disable_unprepare(ddata->clk);
+
+	return ret;
+}
+
+static int __maybe_unused stm32_dma3_runtime_suspend(struct device *dev)
+{
+	struct stm32_dma3_ddata *ddata = dev_get_drvdata(dev);
+
+	//TODO: check if a channel is active
+	//TODO: disable dma ?
+	clk_disable_unprepare(ddata->clk);
+
+	return 0;
+}
+
+static int __maybe_unused stm32_dma3_runtime_resume(struct device *dev)
+{
+	struct stm32_dma3_ddata *ddata = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(ddata->clk);
+	if (ret)
+		dev_err(dev, "clk_prepare_enable failed: %d\n", ret);
+
+	//TODO: enable dma ?
+
+	return ret;
+}
+
+static const struct dev_pm_ops stm32_dma3_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+	SET_RUNTIME_PM_OPS(stm32_dma3_runtime_suspend,
+			   stm32_dma3_runtime_resume, NULL)
+};
+
+static struct platform_driver stm32_dma3_driver = {
+	.probe = stm32_dma3_probe,
+	.driver = {
+		.name = "stm32-dma3",
+		.of_match_table = stm32_dma3_of_match,
+		.pm = &stm32_dma3_pm_ops,
+	},
+};
+
+static int __init stm32_dma3_init(void)
+{
+	return platform_driver_register(&stm32_dma3_driver);
+}
+
+subsys_initcall(stm32_dma3_init);
+
+MODULE_DESCRIPTION("STM32 DMA3 controller driver");
+MODULE_AUTHOR("Amelie Delaunay <amelie.delaunay@foss.st.com>");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/dma/stm32-dmamux.c b/drivers/dma/stm32-dmamux.c
index d5d55732a..eee0c5aa5 100644
--- a/drivers/dma/stm32-dmamux.c
+++ b/drivers/dma/stm32-dmamux.c
@@ -267,7 +267,7 @@ static int stm32_dmamux_probe(struct platform_device *pdev)
 		ret = PTR_ERR(rst);
 		if (ret == -EPROBE_DEFER)
 			goto err_clk;
-	} else {
+	} else if (count > 1) { /* Don't reset if there is only one dma-master */
 		reset_control_assert(rst);
 		udelay(2);
 		reset_control_deassert(rst);
diff --git a/drivers/dma/stm32-mdma.c b/drivers/dma/stm32-mdma.c
index 21a7bdc88..133534663 100644
--- a/drivers/dma/stm32-mdma.c
+++ b/drivers/dma/stm32-mdma.c
@@ -78,6 +78,7 @@
 #define STM32_MDMA_CCR_WEX		BIT(14)
 #define STM32_MDMA_CCR_HEX		BIT(13)
 #define STM32_MDMA_CCR_BEX		BIT(12)
+#define STM32_MDMA_CCR_SM		BIT(8)
 #define STM32_MDMA_CCR_PL_MASK		GENMASK(7, 6)
 #define STM32_MDMA_CCR_PL(n)		STM32_MDMA_SET(n, \
 						       STM32_MDMA_CCR_PL_MASK)
@@ -200,6 +201,8 @@
 #define STM32_MDMA_MAX_BURST		128
 #define STM32_MDMA_VERY_HIGH_PRIORITY	0x3
 
+#define STM32_DMA_SRAM_GRANULARITY	PAGE_SIZE
+
 enum stm32_mdma_trigger_mode {
 	STM32_MDMA_BUFFER,
 	STM32_MDMA_BLOCK,
@@ -226,6 +229,7 @@ struct stm32_mdma_chan_config {
 	u32 transfer_config;
 	u32 mask_addr;
 	u32 mask_data;
+	bool m2m_hw;
 };
 
 struct stm32_mdma_hwdesc {
@@ -251,6 +255,7 @@ struct stm32_mdma_desc {
 	u32 ccr;
 	bool cyclic;
 	u32 count;
+	enum dma_transfer_direction dir;
 	struct stm32_mdma_desc_node node[];
 };
 
@@ -275,6 +280,7 @@ struct stm32_mdma_device {
 	u32 nr_channels;
 	u32 nr_requests;
 	u32 nr_ahb_addr_masks;
+	u32 chan_reserved;
 	struct stm32_mdma_chan chan[STM32_MDMA_MAX_CHANNELS];
 	u32 ahb_addr_masks[];
 };
@@ -565,13 +571,24 @@ static int stm32_mdma_set_xfer_param(struct stm32_mdma_chan *chan,
 		dst_addr = chan->dma_config.dst_addr;
 
 		/* Set device data size */
+		if (chan_config->m2m_hw)
+			dst_addr_width = stm32_mdma_get_max_width(dst_addr, buf_len,
+								  STM32_MDMA_MAX_BUF_LEN);
+
 		dst_bus_width = stm32_mdma_get_width(chan, dst_addr_width);
 		if (dst_bus_width < 0)
 			return dst_bus_width;
 		ctcr &= ~STM32_MDMA_CTCR_DSIZE_MASK;
 		ctcr |= STM32_MDMA_CTCR_DSIZE(dst_bus_width);
+		if (chan_config->m2m_hw) {
+			ctcr &= ~STM32_MDMA_CTCR_DINCOS_MASK;
+			ctcr |= STM32_MDMA_CTCR_DINCOS(dst_bus_width);
+		}
 
 		/* Set device burst value */
+		if (chan_config->m2m_hw)
+			dst_maxburst = STM32_MDMA_MAX_BUF_LEN / dst_addr_width;
+
 		dst_best_burst = stm32_mdma_get_best_burst(buf_len, tlen,
 							   dst_maxburst,
 							   dst_addr_width);
@@ -614,13 +631,24 @@ static int stm32_mdma_set_xfer_param(struct stm32_mdma_chan *chan,
 		src_addr = chan->dma_config.src_addr;
 
 		/* Set device data size */
+		if (chan_config->m2m_hw)
+			src_addr_width = stm32_mdma_get_max_width(src_addr, buf_len,
+								  STM32_MDMA_MAX_BUF_LEN);
+
 		src_bus_width = stm32_mdma_get_width(chan, src_addr_width);
 		if (src_bus_width < 0)
 			return src_bus_width;
 		ctcr &= ~STM32_MDMA_CTCR_SSIZE_MASK;
 		ctcr |= STM32_MDMA_CTCR_SSIZE(src_bus_width);
+		if (chan_config->m2m_hw) {
+			ctcr &= ~STM32_MDMA_CTCR_SINCOS_MASK;
+			ctcr |= STM32_MDMA_CTCR_SINCOS(src_bus_width);
+		}
 
 		/* Set device burst value */
+		if (chan_config->m2m_hw)
+			src_maxburst = STM32_MDMA_MAX_BUF_LEN / src_addr_width;
+
 		src_best_burst = stm32_mdma_get_best_burst(buf_len, tlen,
 							   src_maxburst,
 							   src_addr_width);
@@ -728,6 +756,7 @@ static int stm32_mdma_setup_xfer(struct stm32_mdma_chan *chan,
 {
 	struct stm32_mdma_device *dmadev = stm32_mdma_get_dev(chan);
 	struct dma_slave_config *dma_config = &chan->dma_config;
+	struct stm32_mdma_chan_config *chan_config = &chan->chan_config;
 	struct scatterlist *sg;
 	dma_addr_t src_addr, dst_addr;
 	u32 ccr, ctcr, ctbr;
@@ -750,6 +779,8 @@ static int stm32_mdma_setup_xfer(struct stm32_mdma_chan *chan,
 		} else {
 			src_addr = dma_config->src_addr;
 			dst_addr = sg_dma_address(sg);
+			if (chan_config->m2m_hw)
+				src_addr += ((i & 1) ? sg_dma_len(sg) : 0);
 			ret = stm32_mdma_set_xfer_param(chan, direction, &ccr,
 							&ctcr, &ctbr, dst_addr,
 							sg_dma_len(sg));
@@ -768,8 +799,6 @@ static int stm32_mdma_setup_xfer(struct stm32_mdma_chan *chan,
 	/* Enable interrupts */
 	ccr &= ~STM32_MDMA_CCR_IRQ_MASK;
 	ccr |= STM32_MDMA_CCR_TEIE | STM32_MDMA_CCR_CTCIE;
-	if (sg_len > 1)
-		ccr |= STM32_MDMA_CCR_BTIE;
 	desc->ccr = ccr;
 
 	return 0;
@@ -781,7 +810,9 @@ stm32_mdma_prep_slave_sg(struct dma_chan *c, struct scatterlist *sgl,
 			 unsigned long flags, void *context)
 {
 	struct stm32_mdma_chan *chan = to_stm32_mdma_chan(c);
+	struct stm32_mdma_chan_config *chan_config = &chan->chan_config;
 	struct stm32_mdma_desc *desc;
+	struct stm32_mdma_hwdesc *hwdesc;
 	int i, ret;
 
 	/*
@@ -803,6 +834,20 @@ stm32_mdma_prep_slave_sg(struct dma_chan *c, struct scatterlist *sgl,
 	if (ret < 0)
 		goto xfer_setup_err;
 
+	/*
+	 * In case of M2M HW transfer triggered by STM32 DMA, we do not have to
+	 * clear the transfer complete flag by hardware in order to let the
+	 * CPU rearm the DMA with the next sg element and update some data in
+	 * dmaengine framework
+	 */
+	if (chan_config->m2m_hw && direction == DMA_MEM_TO_DEV) {
+		for (i = 0; i < sg_len; i++) {
+			hwdesc = desc->node[i].hwdesc;
+			hwdesc->cmar = 0;
+			hwdesc->cmdr = 0;
+		}
+	}
+
 	desc->cyclic = false;
 
 	return vchan_tx_prep(&chan->vchan, &desc->vdesc, flags);
@@ -824,9 +869,10 @@ stm32_mdma_prep_dma_cyclic(struct dma_chan *c, dma_addr_t buf_addr,
 	struct stm32_mdma_chan *chan = to_stm32_mdma_chan(c);
 	struct stm32_mdma_device *dmadev = stm32_mdma_get_dev(chan);
 	struct dma_slave_config *dma_config = &chan->dma_config;
+	struct stm32_mdma_chan_config *chan_config = &chan->chan_config;
 	struct stm32_mdma_desc *desc;
 	dma_addr_t src_addr, dst_addr;
-	u32 ccr, ctcr, ctbr, count;
+	u32 ccr, ctcr, ctbr, count, offset;
 	int i, ret;
 
 	/*
@@ -880,12 +926,29 @@ stm32_mdma_prep_dma_cyclic(struct dma_chan *c, dma_addr_t buf_addr,
 	desc->ccr = ccr;
 
 	/* Configure hwdesc list */
+	offset =  ALIGN(period_len, STM32_DMA_SRAM_GRANULARITY);
 	for (i = 0; i < count; i++) {
 		if (direction == DMA_MEM_TO_DEV) {
+			/*
+			 * When the DMA is configured in double buffer mode,
+			 * the MDMA has to use 2 destination buffers to be
+			 * compliant with this mode.
+			 */
+			if (chan_config->m2m_hw && count > 1 && i % 2)
+				dst_addr = dma_config->dst_addr + offset;
+			else
+				dst_addr = dma_config->dst_addr;
 			src_addr = buf_addr + i * period_len;
-			dst_addr = dma_config->dst_addr;
 		} else {
-			src_addr = dma_config->src_addr;
+			/*
+			 * When the DMA is configured in double buffer mode,
+			 * the MDMA has to use 2 destination buffers to be
+			 * compliant with this mode.
+			 */
+			if (chan_config->m2m_hw && count > 1 && i % 2)
+				src_addr = dma_config->src_addr + offset;
+			else
+				src_addr = dma_config->src_addr;
 			dst_addr = buf_addr + i * period_len;
 		}
 
@@ -895,6 +958,7 @@ stm32_mdma_prep_dma_cyclic(struct dma_chan *c, dma_addr_t buf_addr,
 	}
 
 	desc->cyclic = true;
+	desc->dir = direction;
 
 	return vchan_tx_prep(&chan->vchan, &desc->vdesc, flags);
 
@@ -1279,14 +1343,28 @@ static size_t stm32_mdma_desc_residue(struct stm32_mdma_chan *chan,
 {
 	struct stm32_mdma_device *dmadev = stm32_mdma_get_dev(chan);
 	struct stm32_mdma_hwdesc *hwdesc = desc->node[0].hwdesc;
-	u32 cbndtr, residue, modulo, burst_size;
+	u32 residue = 0;
+	u32 modulo, burst_size;
+	dma_addr_t next_clar;
+	u32 cbndtr;
 	int i;
 
-	residue = 0;
-	for (i = curr_hwdesc + 1; i < desc->count; i++) {
+	/*
+	 * Get the residue of pending descriptors
+	 */
+	/* Get the next hw descriptor to process from current transfer */
+	next_clar = stm32_mdma_read(dmadev, STM32_MDMA_CLAR(chan->id));
+	for (i = desc->count - 1; i >= 0; i--) {
 		hwdesc = desc->node[i].hwdesc;
+
+		if (hwdesc->clar == next_clar)
+			break;/* Current transfer found, stop cumulating */
+
+		/* Cumulate residue of unprocessed hw descriptors */
 		residue += STM32_MDMA_CBNDTR_BNDT(hwdesc->cbndtr);
 	}
+
+	/* Read & cumulate the residue of the current transfer */
 	cbndtr = stm32_mdma_read(dmadev, STM32_MDMA_CBNDTR(chan->id));
 	residue += cbndtr & STM32_MDMA_CBNDTR_BNDT_MASK;
 
@@ -1306,24 +1384,36 @@ static enum dma_status stm32_mdma_tx_status(struct dma_chan *c,
 					    struct dma_tx_state *state)
 {
 	struct stm32_mdma_chan *chan = to_stm32_mdma_chan(c);
+	struct stm32_mdma_chan_config *chan_config = &chan->chan_config;
 	struct virt_dma_desc *vdesc;
 	enum dma_status status;
 	unsigned long flags;
 	u32 residue = 0;
 
 	status = dma_cookie_status(c, cookie, state);
-	if ((status == DMA_COMPLETE) || (!state))
+	if (status == DMA_COMPLETE || !state)
 		return status;
 
 	spin_lock_irqsave(&chan->vchan.lock, flags);
 
 	vdesc = vchan_find_desc(&chan->vchan, cookie);
-	if (chan->desc && cookie == chan->desc->vdesc.tx.cookie)
-		residue = stm32_mdma_desc_residue(chan, chan->desc,
-						  chan->curr_hwdesc);
-	else if (vdesc)
+	if (chan->desc && cookie == chan->desc->vdesc.tx.cookie) {
+		/*
+		 * In case of M2D transfer triggered by STM32 DMA, the MDMA has
+		 * always one period in advance in cyclic mode. So, we have to
+		 * add 1 period of data to return the good residue to the
+		 * client
+		 */
+		if (chan_config->m2m_hw &&
+		    chan->desc->dir == DMA_MEM_TO_DEV && chan->curr_hwdesc > 1)
+			residue = stm32_mdma_desc_residue(chan, chan->desc, chan->curr_hwdesc - 1);
+		else
+			residue = stm32_mdma_desc_residue(chan, chan->desc, chan->curr_hwdesc);
+	} else if (vdesc) {
 		residue = stm32_mdma_desc_residue(chan,
 						  to_stm32_mdma_desc(vdesc), 0);
+	}
+
 	dma_set_residue(state, residue);
 
 	spin_unlock_irqrestore(&chan->vchan.lock, flags);
@@ -1371,9 +1461,12 @@ static irqreturn_t stm32_mdma_irq_handler(int irq, void *devid)
 
 	if (!(status & ien)) {
 		spin_unlock(&chan->vchan.lock);
-		dev_warn(chan2dev(chan),
-			 "spurious it (status=0x%04x, ien=0x%04x)\n",
-			 status, ien);
+		if (chan->busy)
+			dev_warn(chan2dev(chan),
+				 "spurious it (status=0x%04x, ien=0x%04x)\n", status, ien);
+		else
+			dev_dbg(chan2dev(chan),
+				"spurious it (status=0x%04x, ien=0x%04x)\n", status, ien);
 		return IRQ_NONE;
 	}
 
@@ -1473,15 +1566,28 @@ static void stm32_mdma_free_chan_resources(struct dma_chan *c)
 	chan->desc_pool = NULL;
 }
 
+static bool stm32_mdma_filter_fn(struct dma_chan *c, void *fn_param)
+{
+	struct stm32_mdma_chan *chan = to_stm32_mdma_chan(c);
+	struct stm32_mdma_device *dmadev = stm32_mdma_get_dev(chan);
+
+	/* Check if chan is marked Secure */
+	if (dmadev->chan_reserved & BIT(chan->id))
+		return false;
+
+	return true;
+}
+
 static struct dma_chan *stm32_mdma_of_xlate(struct of_phandle_args *dma_spec,
 					    struct of_dma *ofdma)
 {
 	struct stm32_mdma_device *dmadev = ofdma->of_dma_data;
+	dma_cap_mask_t mask = dmadev->ddev.cap_mask;
 	struct stm32_mdma_chan *chan;
 	struct dma_chan *c;
 	struct stm32_mdma_chan_config config;
 
-	if (dma_spec->args_count < 5) {
+	if (dma_spec->args_count < 6) {
 		dev_err(mdma2dev(dmadev), "Bad number of args\n");
 		return NULL;
 	}
@@ -1491,6 +1597,7 @@ static struct dma_chan *stm32_mdma_of_xlate(struct of_phandle_args *dma_spec,
 	config.transfer_config = dma_spec->args[2];
 	config.mask_addr = dma_spec->args[3];
 	config.mask_data = dma_spec->args[4];
+	config.m2m_hw = dma_spec->args[5];
 
 	if (config.request >= dmadev->nr_requests) {
 		dev_err(mdma2dev(dmadev), "Bad request line\n");
@@ -1502,7 +1609,7 @@ static struct dma_chan *stm32_mdma_of_xlate(struct of_phandle_args *dma_spec,
 		return NULL;
 	}
 
-	c = dma_get_any_slave_channel(&dmadev->ddev);
+	c = __dma_request_channel(&mask, stm32_mdma_filter_fn, &config, ofdma->of_node);
 	if (!c) {
 		dev_err(mdma2dev(dmadev), "No more channels available\n");
 		return NULL;
@@ -1631,6 +1738,10 @@ static int stm32_mdma_probe(struct platform_device *pdev)
 	for (i = 0; i < dmadev->nr_channels; i++) {
 		chan = &dmadev->chan[i];
 		chan->id = i;
+
+		if (stm32_mdma_read(dmadev, STM32_MDMA_CCR(i)) & STM32_MDMA_CCR_SM)
+			dmadev->chan_reserved |= BIT(i);
+
 		chan->vchan.desc_free = stm32_mdma_desc_free;
 		vchan_init(&chan->vchan, dd);
 	}
diff --git a/drivers/firmware/Kconfig b/drivers/firmware/Kconfig
index 97ce31e66..b54bfd332 100644
--- a/drivers/firmware/Kconfig
+++ b/drivers/firmware/Kconfig
@@ -11,7 +11,7 @@ source "drivers/firmware/arm_scmi/Kconfig"
 config ARM_SCPI_PROTOCOL
 	tristate "ARM System Control and Power Interface (SCPI) Message Protocol"
 	depends on ARM || ARM64 || COMPILE_TEST
-	depends on MAILBOX
+	depends on MAILBOX || HAVE_ARM_SMCCC || OPTEE
 	help
 	  System Control and Power Interface (SCPI) Message Protocol is
 	  defined for the purpose of communication between the Application
diff --git a/drivers/firmware/arm_scmi/Makefile b/drivers/firmware/arm_scmi/Makefile
index 1dcf123d6..d1460cf7e 100644
--- a/drivers/firmware/arm_scmi/Makefile
+++ b/drivers/firmware/arm_scmi/Makefile
@@ -6,6 +6,7 @@ scmi-transport-$(CONFIG_ARM_SCMI_TRANSPORT_MAILBOX) += mailbox.o
 scmi-transport-$(CONFIG_ARM_SCMI_TRANSPORT_SMC) += smc.o
 scmi-transport-$(CONFIG_ARM_SCMI_HAVE_MSG) += msg.o
 scmi-transport-$(CONFIG_ARM_SCMI_TRANSPORT_VIRTIO) += virtio.o
+scmi-transport-$(CONFIG_OPTEE) += optee.o
 scmi-protocols-y = base.o clock.o perf.o power.o reset.o sensors.o system.o voltage.o
 scmi-module-objs := $(scmi-bus-y) $(scmi-driver-y) $(scmi-protocols-y) \
 		    $(scmi-transport-y)
diff --git a/drivers/firmware/arm_scmi/clock.c b/drivers/firmware/arm_scmi/clock.c
index 492f3a919..47814d175 100644
--- a/drivers/firmware/arm_scmi/clock.c
+++ b/drivers/firmware/arm_scmi/clock.c
@@ -16,6 +16,8 @@ enum scmi_clock_protocol_cmd {
 	CLOCK_RATE_SET = 0x5,
 	CLOCK_RATE_GET = 0x6,
 	CLOCK_CONFIG_SET = 0x7,
+	CLOCK_DUTY_CYCLE_GET = 0x8,
+	CLOCK_ROUND_RATE_GET = 0x9,
 };
 
 struct scmi_msg_resp_clock_protocol_attributes {
@@ -56,6 +58,11 @@ struct scmi_msg_resp_clock_describe_rates {
 })
 };
 
+struct scmi_msg_resp_get_duty_cyle {
+	__le32 num;
+	__le32 den;
+};
+
 struct scmi_clock_set_rate {
 	__le32 flags;
 #define CLOCK_SET_ASYNC		BIT(0)
@@ -215,6 +222,34 @@ scmi_clock_describe_rates_get(const struct scmi_protocol_handle *ph, u32 clk_id,
 	return ret;
 }
 
+static int
+scmi_clock_get_duty_cycle(const struct scmi_protocol_handle *ph,
+			  u32 clk_id, int *num, int *den)
+{
+	int ret;
+	struct scmi_xfer *t;
+	struct scmi_msg_resp_get_duty_cyle *resp;
+
+	ret = ph->xops->xfer_get_init(ph, CLOCK_DUTY_CYCLE_GET,
+				      sizeof(__le32), sizeof(u64), &t);
+	if (ret)
+		return ret;
+
+	resp = t->rx.buf;
+
+	put_unaligned_le32(clk_id, t->tx.buf);
+
+	ret = ph->xops->do_xfer(ph, t);
+	if (!ret) {
+		*num = resp->num;
+		*den = resp->den;
+	}
+
+	ph->xops->xfer_put(ph, t);
+
+	return ret;
+}
+
 static int
 scmi_clock_rate_get(const struct scmi_protocol_handle *ph,
 		    u32 clk_id, u64 *value)
@@ -272,6 +307,47 @@ static int scmi_clock_rate_set(const struct scmi_protocol_handle *ph,
 	return ret;
 }
 
+static int
+scmi_clock_round_rate_get(const struct scmi_protocol_handle *ph,
+			  u32 clk_id, u64 *value)
+{
+	int ret;
+	struct scmi_xfer *t;
+	struct scmi_clock_set_rate *cfg;
+	struct clock_info *ci = ph->get_priv(ph);
+	u32 flags = 0;
+
+	ret = ph->xops->xfer_get_init(ph, CLOCK_ROUND_RATE_GET,
+				      sizeof(*cfg), 0, &t);
+	if (ret)
+		return ret;
+
+	if (ci->max_async_req &&
+	    atomic_inc_return(&ci->cur_async_req) < ci->max_async_req)
+		flags |= CLOCK_SET_ASYNC;
+
+	cfg = t->tx.buf;
+	cfg->flags = cpu_to_le32(flags);
+	cfg->id = cpu_to_le32(clk_id);
+	cfg->value_low = cpu_to_le32(*value & 0xffffffff);
+	cfg->value_high = cpu_to_le32(*value >> 32);
+
+	if (flags & CLOCK_SET_ASYNC)
+		ret = ph->xops->do_xfer_with_response(ph, t);
+	else
+		ret = ph->xops->do_xfer(ph, t);
+
+	if (ci->max_async_req)
+		atomic_dec(&ci->cur_async_req);
+
+	if (!ret)
+		*value = get_unaligned_le64(t->rx.buf);
+
+	ph->xops->xfer_put(ph, t);
+
+	return ret;
+}
+
 static int
 scmi_clock_config_set(const struct scmi_protocol_handle *ph, u32 clk_id,
 		      u32 config)
@@ -331,6 +407,8 @@ static const struct scmi_clk_proto_ops clk_proto_ops = {
 	.rate_set = scmi_clock_rate_set,
 	.enable = scmi_clock_enable,
 	.disable = scmi_clock_disable,
+	.get_duty_cycle = scmi_clock_get_duty_cycle,
+	.round_rate_get = scmi_clock_round_rate_get,
 };
 
 static int scmi_clock_protocol_init(const struct scmi_protocol_handle *ph)
diff --git a/drivers/firmware/arm_scmi/common.h b/drivers/firmware/arm_scmi/common.h
index dea1bfbe1..82ff3c3a6 100644
--- a/drivers/firmware/arm_scmi/common.h
+++ b/drivers/firmware/arm_scmi/common.h
@@ -421,6 +421,9 @@ extern const struct scmi_desc scmi_smc_desc;
 #ifdef CONFIG_ARM_SCMI_TRANSPORT_VIRTIO
 extern const struct scmi_desc scmi_virtio_desc;
 #endif
+#ifdef CONFIG_OPTEE
+extern const struct scmi_desc scmi_optee_desc;
+#endif
 
 void scmi_rx_callback(struct scmi_chan_info *cinfo, u32 msg_hdr, void *priv);
 void scmi_free_channel(struct scmi_chan_info *cinfo, struct idr *idr, int id);
diff --git a/drivers/firmware/arm_scmi/driver.c b/drivers/firmware/arm_scmi/driver.c
index e815b8f98..4a5b9c2c0 100644
--- a/drivers/firmware/arm_scmi/driver.c
+++ b/drivers/firmware/arm_scmi/driver.c
@@ -1998,6 +1998,9 @@ static const struct of_device_id scmi_of_match[] = {
 #ifdef CONFIG_ARM_SCMI_TRANSPORT_SMC
 	{ .compatible = "arm,scmi-smc", .data = &scmi_smc_desc},
 #endif
+#ifdef CONFIG_OPTEE
+	{ .compatible = "linaro,scmi-optee", .data = &scmi_optee_desc },
+#endif
 #ifdef CONFIG_ARM_SCMI_TRANSPORT_VIRTIO
 	{ .compatible = "arm,scmi-virtio", .data = &scmi_virtio_desc},
 #endif
diff --git a/drivers/firmware/arm_scmi/optee.c b/drivers/firmware/arm_scmi/optee.c
new file mode 100644
index 000000000..4ec54b3c6
--- /dev/null
+++ b/drivers/firmware/arm_scmi/optee.c
@@ -0,0 +1,848 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019-2021 Linaro Limited
+ */
+
+#include <linux/freezer.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/slab.h>
+#include <linux/tee_drv.h>
+#include <linux/uuid.h>
+#include <uapi/linux/tee.h>
+
+#include "common.h"
+
+#define DRIVER_NAME "optee-scmi-agent"
+
+/* IDs defined in GPD TEE specification OP-TEE is based on */
+#define TEEC_SUCCESS			0
+#define TEEC_ERROR_GENERIC		0xffff0000
+#define TEEC_ERROR_NOT_SUPPORTED	0xffff000a
+
+/*
+ * PTA_SCMI_CMD_CAPABILITIES - Get channel capabilities
+ *
+ * [out]    value[0].a: Capability bit mask (PTA_SCMI_CAPS_*)
+ * [out]    value[0].b: Extended capabilities or 0
+ */
+#define PTA_SCMI_CMD_CAPABILITIES	0
+
+/*
+ * PTA_SCMI_CMD_PROCESS_SMT_CHANNEL - Process SCMI message in SMT buffer
+ *
+ * [in]     value[0].a: Channel handle
+ *
+ * Shared memory used for SCMI message/response exhange is expected
+ * already identified and bound to channel handle in both SCMI agent
+ * and SCMI server (OP-TEE) parts.
+ * The memory uses SMT header to carry SCMI meta-data (protocol ID and
+ * protocol message ID).
+ */
+#define PTA_SCMI_CMD_PROCESS_SMT_CHANNEL	1
+
+/*
+ * PTA_SCMI_CMD_PROCESS_SMT_CHANNEL_MESSAGE - Process SMT/SCMI message
+ *
+ * [in]     value[0].a: Channel handle
+ * [in/out] memref[1]: Message/response buffer (SMT and SCMI payload)
+ *
+ * Shared memory used for SCMI message/response is a SMT buffer
+ * referenced by param[1]. It shall be 128 bytes large to fit response
+	 * payload whatever message playload size.
+ * The memory uses SMT header to carry SCMI meta-data (protocol ID and
+ * protocol message ID).
+ */
+#define PTA_SCMI_CMD_PROCESS_SMT_CHANNEL_MESSAGE	2
+
+/*
+ * PTA_SCMI_CMD_GET_CHANNEL_HANDLE - Get channel handle
+ *
+ * SCMI shm information are 0 if agent expects to use OP-TEE regular SHM
+ *
+ * [in]     value[0].a: Channel identifier
+ * [out]    value[0].a: Returned channel handle
+ * [in]     value[0].b: Requested capabilities mask (PTA_SCMI_CAPS_*)
+ */
+#define PTA_SCMI_CMD_GET_CHANNEL_HANDLE		3
+
+/*
+ * PTA_SCMI_CMD_OCALL_THREAD - Allocate a threaded path using OCALL
+ *
+ * [in]   value[0].a: channel handle
+ *
+ * Use Ocall support to create a provisioned OP-TEE thread context for
+ * the channel. Successful creation of the thread makes this command to
+ * return with Ocall command PTA_SCMI_OCALL_CMD_THREAD_READY.
+ */
+#define PTA_SCMI_CMD_OCALL_THREAD		4
+
+/*
+ * Channel capabilities
+ */
+
+/* Channel supports shared memory using the SMT header protocol */
+#define PTA_SCMI_CAPS_SMT_HEADER			BIT(0)
+
+/*
+ * Channel can use command PTA_SCMI_CMD_OCALL_THREAD to provision a
+ * TEE thread for SCMI message passing.
+ */
+#define PTA_SCMI_CAPS_OCALL_THREAD			BIT(1)
+
+enum optee_scmi_ocall_cmd {
+	PTA_SCMI_OCALL_CMD_THREAD_READY = 0,
+};
+
+enum optee_scmi_ocall_reply {
+	PTA_SCMI_OCALL_ERROR = 0,
+	PTA_SCMI_OCALL_CLOSE_THREAD = 1,
+	PTA_SCMI_OCALL_PROCESS_SMT_CHANNEL = 2,
+};
+
+/* 4 should be enough but current Ocall implementation mandates > 4 */
+#define OCALL_CTX_PARAMS_COUNT		5
+
+struct ocall_ctx {
+	/* REE context exposed to TEE interface param[] must follow args */
+	struct tee_ioctl_invoke_arg args;
+	struct tee_param param[OCALL_CTX_PARAMS_COUNT];
+};
+
+struct optee_scmi_channel {
+	/* OP-TEE channel ID used in transoprt */
+	u32 channel_id;
+	/* Channel entry protection */
+	struct mutex mu;
+	/* Channel private data */
+	u32 tee_session;
+	struct optee_scmi_agent *agent;
+	struct scmi_chan_info *cinfo;
+	struct ocall_ctx *ocall_ctx;
+	struct scmi_shared_mem __iomem *shmem;
+	/* Channel capabilities */
+	u32 caps;
+	/* Reference in agent's channel list */
+	struct list_head link;
+};
+
+/**
+ * struct optee_scmi_agent - OP-TEE transport private data
+ */
+struct optee_scmi_agent {
+	/* TEE context the agent operates with */
+	struct device *dev;
+	struct tee_context *tee_ctx;
+	/* Supported channel capabilities (PTA_SCMI_CAPS_*) */
+	u32 caps;
+	/* List all created channels */
+	struct list_head channel_list;
+};
+
+/* There is only 1 SCMI PTA to connect to */
+static struct optee_scmi_agent *agent_private;
+
+static struct list_head optee_agent_list = LIST_HEAD_INIT(optee_agent_list);
+static DEFINE_MUTEX(list_mutex);
+
+/* Open a session toward SCMI PTA with REE_KERNEL identity */
+static int open_session(struct optee_scmi_agent *agent, u32 *tee_session)
+{
+	struct device *dev = agent->dev;
+	struct tee_client_device *scmi_pta = to_tee_client_device(dev);
+	struct tee_ioctl_open_session_arg sess_arg;
+	int ret;
+
+	memset(&sess_arg, 0, sizeof(sess_arg));
+
+	memcpy(sess_arg.uuid, scmi_pta->id.uuid.b, TEE_IOCTL_UUID_LEN);
+	sess_arg.clnt_login = TEE_IOCTL_LOGIN_REE_KERNEL;
+
+	ret = tee_client_open_session(agent->tee_ctx, &sess_arg, NULL);
+	if ((ret < 0) || (sess_arg.ret != 0)) {
+		dev_err(dev, "tee_client_open_session failed, err: %x\n",
+			sess_arg.ret);
+		return -EINVAL;
+	}
+
+	*tee_session = sess_arg.session;
+
+	return 0;
+}
+
+static void close_session(struct optee_scmi_agent *agent, u32 tee_session)
+{
+	tee_client_close_session(agent->tee_ctx, tee_session);
+}
+
+static int get_capabilities(struct optee_scmi_agent *agent)
+{
+	int ret;
+	struct tee_ioctl_invoke_arg inv_arg;
+	struct tee_param param[1];
+	u32 tee_session;
+
+	ret = open_session(agent, &tee_session);
+	if (ret)
+		return ret;
+
+	memset(&inv_arg, 0, sizeof(inv_arg));
+	memset(&param, 0, sizeof(param));
+
+	inv_arg.func = PTA_SCMI_CMD_CAPABILITIES;
+	inv_arg.session = tee_session;
+	inv_arg.num_params = 1;
+
+	param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT;
+
+	ret = tee_client_invoke_func(agent->tee_ctx, &inv_arg, param);
+
+	close_session(agent, tee_session);
+
+	if ((ret < 0) || (inv_arg.ret != 0)) {
+		dev_err(agent->dev, "Can't get capabilities: %d / %#x\n",
+			ret, inv_arg.ret);
+
+		return -ENOTSUPP;
+	}
+
+	agent->caps = param[0].u.value.a;
+
+	if (!(agent->caps & PTA_SCMI_CAPS_SMT_HEADER)) {
+		dev_err(agent->dev, "OP-TEE SCMI PTA doesn't support SMT\n");
+
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int get_channel(struct optee_scmi_channel *channel)
+{
+	struct device *dev = channel->agent->dev;
+	int ret;
+	struct tee_ioctl_invoke_arg inv_arg;
+	struct tee_param param[1];
+	unsigned int caps;
+
+	caps = PTA_SCMI_CAPS_SMT_HEADER;
+	if (channel->agent->caps & PTA_SCMI_CAPS_OCALL_THREAD)
+		caps |= PTA_SCMI_CAPS_OCALL_THREAD;
+
+	memset(&inv_arg, 0, sizeof(inv_arg));
+	memset(&param, 0, sizeof(param));
+
+	inv_arg.func = PTA_SCMI_CMD_GET_CHANNEL_HANDLE;
+	inv_arg.session = channel->tee_session;
+	inv_arg.num_params = 1;
+
+	param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT;
+	param[0].u.value.a = channel->channel_id;
+	param[0].u.value.b = caps;
+
+	ret = tee_client_invoke_func(channel->agent->tee_ctx, &inv_arg, param);
+
+	if (!ret && (caps & PTA_SCMI_CAPS_OCALL_THREAD) &&
+	    inv_arg.ret == TEEC_ERROR_NOT_SUPPORTED) {
+		dev_info(dev, "Ocall not supported, fallback to non-Ocall\n");
+
+		caps &= ~PTA_SCMI_CAPS_OCALL_THREAD;
+
+		memset(&inv_arg, 0, sizeof(inv_arg));
+		memset(&param, 0, sizeof(param));
+
+		inv_arg.func = PTA_SCMI_CMD_GET_CHANNEL_HANDLE;
+		inv_arg.session = channel->tee_session;
+		inv_arg.num_params = 1;
+
+		param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT;
+		param[0].u.value.a = channel->channel_id;
+		param[0].u.value.b = caps;
+
+		ret = tee_client_invoke_func(channel->agent->tee_ctx, &inv_arg, param);
+	}
+
+	if (ret || inv_arg.ret) {
+		dev_err(dev, "Can't get channel with caps %#x: ret=%d, tee-res=%#x\n",
+			caps, ret, inv_arg.ret);
+
+		return -ENOTSUPP;
+	}
+
+	/* Only channel handler is used, can discard old channel ID value */
+	channel->channel_id = param[0].u.value.a;
+	channel->caps = caps;
+
+	return 0;
+}
+
+/*
+ * The below creates an Ocall thread context for SCMI agent to invoke by
+ * returning from an Ocall instead of invoking a command. This provisioned
+ * a secure thread for SCMI system communication.
+ */
+static int invoke_optee(struct optee_scmi_channel *channel)
+{
+	struct tee_ioctl_invoke_arg *args = &channel->ocall_ctx->args;
+	struct tee_param *params = channel->ocall_ctx->param;
+
+	return tee_client_invoke_func(channel->agent->tee_ctx, args, params);
+}
+
+static bool return_is_ocall(struct ocall_ctx *ocall_ctx)
+{
+	/* Non-null OCall function means an OCall context invoked by OP-TEE */
+	return TEE_IOCTL_OCALL_GET_FUNC(ocall_ctx->param[0].u.value.a);
+}
+
+static int alloc_ocall_ctx(struct optee_scmi_channel *channel)
+{
+	if (WARN_ON(channel->ocall_ctx))
+		return -EINVAL;
+
+	channel->ocall_ctx = devm_kzalloc(channel->agent->dev,
+					  sizeof(*channel->ocall_ctx),
+					  GFP_KERNEL);
+	if (!channel->ocall_ctx)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void free_ocall_ctx(struct optee_scmi_channel *channel)
+{
+	devm_kfree(channel->agent->dev, channel->ocall_ctx);
+	channel->ocall_ctx = NULL;
+}
+
+static void abort_ocall(struct optee_scmi_channel *channel)
+{
+	struct ocall_ctx *ocall_ctx = channel->ocall_ctx;
+	int ret;
+
+	ocall_ctx->param[0].u.value.b = TEEC_ERROR_GENERIC;
+	ocall_ctx->param[0].u.value.c = 1; /* Origin is client */
+
+	ret = invoke_optee(channel);
+
+	WARN_ONCE(ret || return_is_ocall(ocall_ctx), "Unexpected error\n");
+}
+
+/*
+ * ocall_thread_is_ready() - Called on return from invoke_optee()
+ *
+ * At this point, if we're invoked from SCMI PTA Ocall thread, the parameters
+ * in OCall context should be:
+ * param[0].value.a = TEE_IOCTL_OCALL_CMD_INVOKE | Ocall command ID
+ * param[0].value.b = Invoked OCall service UUID (64b LSB)
+ * param[0].value.c = Invoked OCall service UUID (64b MSB)
+ * param[1..4] are 4 parameters passed by OP-TEE SCMI PTA through the OCall
+ */
+static bool ocall_thread_is_ready(struct optee_scmi_channel *channel)
+{
+	struct ocall_ctx *ocall_ctx = channel->ocall_ctx;
+	unsigned int ocall_func = 0;
+	unsigned int ocall_cmd = 0;
+	uint64_t *ocall_uuid = NULL;
+	struct device *dev = channel->agent->dev;
+	struct tee_client_device *scmi_pta = to_tee_client_device(dev);
+
+	if (!return_is_ocall(ocall_ctx)) {
+		dev_err(dev, "Ocall expected\n");
+		return false;
+	}
+
+	/* TODO: we could skip this part (PTA could not set Ocall UUID) */
+	ocall_uuid = &ocall_ctx->param[0].u.value.b;
+	if (memcmp(ocall_uuid, scmi_pta->id.uuid.b, TEE_IOCTL_UUID_LEN)) {
+		dev_err(dev, "Ocall from unexpected TA %pUb\n",
+			&ocall_ctx->param[1].u.value.a);
+		return false;
+	}
+
+	ocall_func = TEE_IOCTL_OCALL_GET_FUNC(ocall_ctx->param[0].u.value.a);
+	ocall_cmd = TEE_IOCTL_OCALL_GET_CMD(ocall_ctx->param[0].u.value.a);
+	if (ocall_func != TEE_IOCTL_OCALL_CMD_INVOKE ||
+	    ocall_cmd != PTA_SCMI_OCALL_CMD_THREAD_READY) {
+		dev_err(dev, "Unexpected Ocall function %#x, command %#x\n",
+			ocall_func, ocall_cmd);
+		return false;
+	}
+
+	return true;
+}
+
+static int open_ocall_thread(struct optee_scmi_channel *channel)
+{
+	struct device *dev = channel->agent->dev;
+	int ret;
+
+	if (WARN_ONCE(channel->ocall_ctx, "Unexpected error\n"))
+		return -EINVAL;
+
+	ret = alloc_ocall_ctx(channel);
+	if (ret)
+		return ret;
+
+	/*
+	 * Setup parameters for initial TEE invocation with an Ocall
+	 * context to return from tee_client_invoke_func() with
+	 * a provisioned OP-TEE thread.
+	 */
+	*channel->ocall_ctx = (struct ocall_ctx){
+		.args.func = PTA_SCMI_CMD_OCALL_THREAD,
+		.args.session = channel->tee_session,
+		.args.num_params = OCALL_CTX_PARAMS_COUNT,
+		.param[0] = {
+			.attr = TEE_IOCTL_PARAM_ATTR_OCALL |
+				TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT,
+		},
+		.param[1] = {
+			.attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT,
+			.u.value.a = channel->channel_id,
+		},
+	};
+
+	ret = -EAGAIN;
+	while (ret == -EAGAIN)
+		ret = invoke_optee(channel);
+
+	if (ret)
+		goto err;
+
+	if (ocall_thread_is_ready(channel))
+		return 0;
+
+	ret = -EPROTO;
+
+	if (!return_is_ocall(channel->ocall_ctx)) {
+		struct ocall_ctx *ocall_ctx = channel->ocall_ctx;
+
+		switch (ocall_ctx->args.ret) {
+		case TEEC_SUCCESS:
+			dev_dbg(dev, "unexpected successfull invocation\n");
+			break;
+		case TEEC_ERROR_NOT_SUPPORTED:
+			ret = -EOPNOTSUPP;
+			break;
+		default:
+			dev_dbg(dev, "invoke error %#x\n", ocall_ctx->args.ret);
+			break;
+		}
+	} else {
+		dev_dbg(dev, "Unexpected ocall context\n");
+	}
+
+err:
+	if (return_is_ocall(channel->ocall_ctx))
+		abort_ocall(channel);
+
+	free_ocall_ctx(channel);
+
+	return ret;
+}
+
+static int close_ocall_thread(struct optee_scmi_channel *channel)
+{
+	struct ocall_ctx *ocall_ctx = channel->ocall_ctx;
+	int ret;
+
+	if(!ocall_ctx)
+		return 0;
+
+	ocall_ctx->param[0].u.value.b = TEEC_SUCCESS;
+	ocall_ctx->param[1].u.value.a = PTA_SCMI_OCALL_CLOSE_THREAD;
+
+	ret = invoke_optee(channel);
+
+	if (ret) {
+		dev_dbg(channel->agent->dev, "can't invoke OP-TEE: %d\n", ret);
+	} else {
+		if (return_is_ocall(channel->ocall_ctx)) {
+			ret = -EPROTO;
+			abort_ocall(channel);
+		}
+	}
+
+	free_ocall_ctx(channel);
+
+	return ret;
+}
+
+static int invoke_ocall_thread(struct optee_scmi_channel *channel)
+{
+	struct ocall_ctx *ocall_ctx = channel->ocall_ctx;
+	int ret = -EPROTO;
+
+	if (!ocall_ctx)
+		return -EINVAL;
+
+	ocall_ctx->param[0].u.value.b = TEEC_SUCCESS;
+	ocall_ctx->param[1].u.value.a = PTA_SCMI_OCALL_PROCESS_SMT_CHANNEL;
+
+	ret = invoke_optee(channel);
+
+	if (!ret && ocall_thread_is_ready(channel))
+		return 0;
+
+	if (return_is_ocall(channel->ocall_ctx))
+		abort_ocall(channel);
+
+	free_ocall_ctx(channel);
+
+	return -EPROTO;
+}
+
+/* Invocation of the PTA through a regular command invoke */
+static int invoke_process_smt_channel(struct optee_scmi_channel *channel)
+{
+	int ret;
+	struct tee_ioctl_invoke_arg inv_arg;
+	struct tee_param param[1];
+
+	if (!(channel->caps & PTA_SCMI_CAPS_SMT_HEADER))
+		return -EINVAL;
+
+	memset(&inv_arg, 0, sizeof(inv_arg));
+	memset(&param, 0, sizeof(param));
+
+	inv_arg.func = PTA_SCMI_CMD_PROCESS_SMT_CHANNEL;
+	inv_arg.session = channel->tee_session;
+	inv_arg.num_params = 1;
+
+	param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;
+	param[0].u.value.a = channel->channel_id;
+
+	ret = tee_client_invoke_func(channel->agent->tee_ctx, &inv_arg, param);
+	if (ret < 0 || inv_arg.ret) {
+		dev_err(channel->agent->dev, "Failed on channel %u: 0x%x\n",
+			channel->channel_id, inv_arg.ret);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static bool optee_chan_available(struct device *dev, int idx)
+{
+	u32 channel_id;
+	struct device_node *np = of_parse_phandle(dev->of_node, "shmem", 0);
+
+	/* Currently expect a shmem, but will maybe not in the future */
+	if (!np)
+		return false;
+
+	of_node_put(np);
+
+	return !of_property_read_u32_index(dev->of_node, "linaro,optee-channel-id",
+					   idx, &channel_id);
+}
+
+static int optee_chan_setup_shmem(struct scmi_chan_info *cinfo,
+				  unsigned int channel_id, bool tx,
+				  struct optee_scmi_channel *channel)
+{
+	struct device *cdev = cinfo->dev;
+	struct device_node *np;
+	resource_size_t size;
+	struct resource res;
+	int ret;
+
+	np = of_parse_phandle(cdev->of_node, "shmem", 0);
+	ret = of_address_to_resource(np, 0, &res);
+	of_node_put(np);
+	if (ret) {
+		dev_err(cdev, "failed to get SCMI Tx shared memory\n");
+		return ret;
+	}
+
+	size = resource_size(&res);
+
+	channel->shmem = devm_ioremap(cdev, res.start, size);
+	if (!channel->shmem) {
+		dev_err(cdev, "failed to ioremap SCMI Tx shared memory\n");
+		return -EADDRNOTAVAIL;
+	}
+
+	return 0;
+}
+
+static void optee_clear_channel(struct scmi_chan_info *cinfo)
+{
+	struct optee_scmi_channel *channel = cinfo->transport_info;
+
+	shmem_clear_channel(channel->shmem);
+}
+
+static int optee_chan_setup(struct scmi_chan_info *cinfo, struct device *dev,
+			    bool tx)
+{
+	struct device *cdev = cinfo->dev;
+	struct optee_scmi_channel *channel;
+	uint32_t channel_id;
+	int ret, idx = tx ? 0 : 1;
+
+	/* Shall wait for OP-TEE driver to be up and ready */
+	if (!agent_private || !agent_private->tee_ctx)
+		return -EPROBE_DEFER;
+
+	channel = devm_kzalloc(dev, sizeof(*channel), GFP_KERNEL);
+	if (!channel)
+		return -ENOMEM;
+
+	ret = of_property_read_u32_index(cdev->of_node, "linaro,optee-channel-id",
+					 idx, &channel_id);
+	/* Allow optee-channel-id to be optional? (case only 1 SCMI agent in Linux) */
+	if (ret == -ENOENT)
+		channel_id = 0;
+	else if (ret)
+		return ret;
+
+	ret = optee_chan_setup_shmem(cinfo, channel_id, tx, channel);
+	if (ret)
+		return ret;
+
+	cinfo->transport_info = channel;
+	channel->cinfo = cinfo;
+	channel->agent = agent_private;
+
+	ret = open_session(channel->agent, &channel->tee_session);
+	if (ret)
+		return ret;
+
+	ret = get_channel(channel);
+	if (ret)
+		goto err;
+
+	if (channel->caps & PTA_SCMI_CAPS_OCALL_THREAD) {
+		ret = open_ocall_thread(channel);
+		if (ret) {
+			if (ret != -EOPNOTSUPP)
+				goto err;
+
+			dev_warn(dev, "Ocall failed: fallback to non-Ocall\n");
+		}
+	}
+
+	mutex_init(&channel->mu);
+
+	mutex_lock(&list_mutex);
+	list_add(&channel->link, &channel->agent->channel_list);
+	mutex_unlock(&list_mutex);
+
+	return 0;
+
+err:
+	close_session(channel->agent, channel->tee_session);
+	channel->tee_session = 0;
+
+	return ret;
+}
+
+static int optee_chan_free(int id, void *p, void *data)
+{
+	int ret;
+	struct scmi_chan_info *cinfo = p;
+	struct optee_scmi_channel *channel = cinfo->transport_info;
+
+	ret = close_ocall_thread(channel);
+	if (ret)
+		return ret;
+
+	mutex_lock(&list_mutex);
+	list_del(&channel->link);
+	mutex_unlock(&list_mutex);
+
+	cinfo->transport_info = NULL;
+	channel->cinfo = NULL;
+
+	devm_kfree(channel->agent->dev, channel);
+	scmi_free_channel(cinfo, data, id);
+
+	return 0;
+}
+
+static struct scmi_shared_mem *get_channel_shm(struct optee_scmi_channel *chan,
+					       struct scmi_xfer *xfer)
+{
+	if (!chan)
+		return NULL;
+
+	return chan->shmem;
+}
+
+static int optee_send_message(struct scmi_chan_info *cinfo,
+			      struct scmi_xfer *xfer)
+{
+	struct optee_scmi_channel *channel = cinfo->transport_info;
+	struct scmi_shared_mem *shmem;
+	int ret = 0;
+
+	if (!channel && !channel->agent && !channel->agent->tee_ctx)
+		return -ENODEV;
+
+	shmem = get_channel_shm(channel, xfer);
+
+	mutex_lock(&channel->mu);
+	shmem_tx_prepare(shmem, xfer);
+
+	if (channel->ocall_ctx)
+		ret = invoke_ocall_thread(channel);
+	else
+		ret = invoke_process_smt_channel(channel);
+
+	scmi_rx_callback(cinfo, shmem_read_header(shmem), NULL);
+	mutex_unlock(&channel->mu);
+
+	return ret;
+}
+
+static void optee_fetch_response(struct scmi_chan_info *cinfo,
+				 struct scmi_xfer *xfer)
+{
+	struct optee_scmi_channel *channel = cinfo->transport_info;
+	struct scmi_shared_mem *shmem = get_channel_shm(channel, xfer);
+
+	shmem_fetch_response(shmem, xfer);
+}
+
+static bool optee_poll_done(struct scmi_chan_info *cinfo,
+			    struct scmi_xfer *xfer)
+{
+	struct optee_scmi_channel *channel = cinfo->transport_info;
+	struct scmi_shared_mem *shmem = get_channel_shm(channel, xfer);
+
+	return shmem_poll_done(shmem, xfer);
+}
+
+static struct scmi_transport_ops scmi_optee_ops = {
+	.chan_available = optee_chan_available,
+	.chan_setup = optee_chan_setup,
+	.chan_free = optee_chan_free,
+	.send_message = optee_send_message,
+	.fetch_response = optee_fetch_response,
+	.clear_channel = optee_clear_channel,
+	.poll_done = optee_poll_done,
+};
+
+const struct scmi_desc scmi_optee_desc = {
+	.ops = &scmi_optee_ops,
+	.max_rx_timeout_ms = 30, /* We may increase this if required */
+	.max_msg = 8,
+	.max_msg_size = 128,
+};
+
+static int optee_ctx_match(struct tee_ioctl_version_data *ver, const void *data)
+{
+	return ver->impl_id == TEE_IMPL_ID_OPTEE;
+}
+
+static int optee_scmi_probe(struct device *dev)
+{
+	struct optee_scmi_agent *agent;
+	struct tee_context *tee_ctx;
+	int ret;
+
+	tee_ctx = tee_client_open_context(NULL, optee_ctx_match, NULL, NULL);
+	if (IS_ERR(tee_ctx))
+		return -ENODEV;
+
+	agent = devm_kzalloc(dev, sizeof(*agent), GFP_KERNEL);
+	if (!agent) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	agent->dev = dev;
+	agent->tee_ctx = tee_ctx;
+
+	ret = get_capabilities(agent);
+	if (ret)
+		goto err;
+
+	/* We currently support only 1 OP-TEE device */
+	if (WARN_ON(agent_private)) {
+		ret = -EINVAL;
+		goto err;
+	}
+	agent_private = agent;
+
+	INIT_LIST_HEAD(&agent->channel_list);
+
+	dev_dbg(dev, "OP-TEE SCMI channel probed\n");
+
+	return 0;
+
+err:
+	tee_client_close_context(tee_ctx);
+	return ret;
+}
+
+static int optee_scmi_remove(struct device *dev)
+{
+	struct optee_scmi_channel *channel;
+	struct list_head *elt, *n;
+
+	mutex_lock(&list_mutex);
+	list_for_each_safe(elt, n, &agent_private->channel_list) {
+		channel = list_entry(elt, struct optee_scmi_channel, link);
+		close_ocall_thread(channel);
+		list_del(&channel->link);
+	}
+	mutex_unlock(&list_mutex);
+
+	tee_client_close_context(agent_private->tee_ctx);
+
+	agent_private = NULL;
+
+	return 0;
+}
+
+static void optee_scmi_shutdown(struct device *dev)
+{
+	optee_scmi_remove(dev);
+}
+
+static const struct tee_client_device_id optee_scmi_id_table[] = {
+	{
+		UUID_INIT(0xa8cfe406, 0xd4f5, 0x4a2e,
+			  0x9f, 0x8d, 0xa2, 0x5d, 0xc7, 0x54, 0xc0, 0x99)
+	},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(tee, optee_scmi_id_table);
+
+static struct tee_client_driver optee_scmi_driver = {
+	.id_table	= optee_scmi_id_table,
+	.driver		= {
+		.name = DRIVER_NAME,
+		.bus = &tee_bus_type,
+		.probe = optee_scmi_probe,
+		.remove = optee_scmi_remove,
+		.shutdown = optee_scmi_shutdown,
+	},
+};
+
+static int __init optee_scmi_init(void)
+{
+	return driver_register(&optee_scmi_driver.driver);
+}
+
+static void __exit optee_scmi_exit(void)
+{
+	driver_unregister(&optee_scmi_driver.driver);
+}
+
+module_init(optee_scmi_init);
+module_exit(optee_scmi_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Etienne Carriere <etienne.carriere@linaro.org>");
+MODULE_DESCRIPTION("OP-TEE SCMI transport driver");
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index 320baed94..db4ad34fc 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -422,8 +422,16 @@ static int devprop_gpiochip_set_names(struct gpio_chip *chip)
 	if (count > chip->ngpio)
 		count = chip->ngpio;
 
-	for (i = 0; i < count; i++)
-		gdev->descs[i].name = names[chip->offset + i];
+	for (i = 0; i < count; i++) {
+		/*
+		 * Allow overriding "fixed" names provided by the GPIO
+		 * provider. The "fixed" names are more often than not
+		 * generic and less informative than the names given in
+		 * device properties.
+		 */
+		if (names[chip->offset + i] && names[chip->offset + i][0])
+			gdev->descs[i].name = names[chip->offset + i];
+	}
 
 	kfree(names);
 
@@ -708,10 +716,12 @@ int gpiochip_add_data_with_key(struct gpio_chip *gc, void *data,
 	INIT_LIST_HEAD(&gdev->pin_ranges);
 #endif
 
-	if (gc->names)
+	if (gc->names) {
 		ret = gpiochip_set_desc_names(gc);
-	else
-		ret = devprop_gpiochip_set_names(gc);
+		if (ret)
+			goto err_remove_from_list;
+	}
+	ret = devprop_gpiochip_set_names(gc);
 	if (ret)
 		goto err_remove_from_list;
 
diff --git a/drivers/gpu/drm/bridge/sii902x.c b/drivers/gpu/drm/bridge/sii902x.c
index 89558e581..69208ead5 100644
--- a/drivers/gpu/drm/bridge/sii902x.c
+++ b/drivers/gpu/drm/bridge/sii902x.c
@@ -16,6 +16,7 @@
 #include <linux/i2c-mux.h>
 #include <linux/i2c.h>
 #include <linux/module.h>
+#include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/regulator/consumer.h>
 #include <linux/clk.h>
@@ -162,6 +163,11 @@
 
 #define SII902X_AUDIO_PORT_INDEX		3
 
+/* CEC device */
+#define SII902X_CEC_I2C_ADDR			0x30
+
+#define SII902X_CEC_SETUP			0x8e
+
 struct sii902x {
 	struct i2c_client *i2c;
 	struct regmap *regmap;
@@ -170,6 +176,7 @@ struct sii902x {
 	struct gpio_desc *reset_gpio;
 	struct i2c_mux_core *i2cmux;
 	struct regulator_bulk_data supplies[2];
+	struct edid *edid;
 	/*
 	 * Mutex protects audio and video functions from interfering
 	 * each other, by keeping their i2c command sequences atomic.
@@ -280,6 +287,8 @@ static int sii902x_get_modes(struct drm_connector *connector)
 
 	mutex_lock(&sii902x->mutex);
 
+	kfree(sii902x->edid);
+	sii902x->edid = NULL;
 	edid = drm_get_edid(connector, sii902x->i2cmux->adapter[0]);
 	drm_connector_update_edid_property(connector, edid);
 	if (edid) {
@@ -287,7 +296,7 @@ static int sii902x_get_modes(struct drm_connector *connector)
 			output_mode = SII902X_SYS_CTRL_OUTPUT_HDMI;
 
 		num = drm_add_edid_modes(connector, edid);
-		kfree(edid);
+		sii902x->edid = edid;
 	}
 
 	ret = drm_display_info_set_bus_formats(&connector->display_info,
@@ -337,6 +346,7 @@ static void sii902x_bridge_disable(struct drm_bridge *bridge)
 static void sii902x_bridge_enable(struct drm_bridge *bridge)
 {
 	struct sii902x *sii902x = bridge_to_sii902x(bridge);
+	u8 output_mode = SII902X_SYS_CTRL_OUTPUT_DVI;
 
 	mutex_lock(&sii902x->mutex);
 
@@ -346,6 +356,14 @@ static void sii902x_bridge_enable(struct drm_bridge *bridge)
 	regmap_update_bits(sii902x->regmap, SII902X_SYS_CTRL_DATA,
 			   SII902X_SYS_CTRL_PWR_DWN, 0);
 
+	if (sii902x->edid) {
+		if (drm_detect_hdmi_monitor(sii902x->edid))
+			output_mode = SII902X_SYS_CTRL_OUTPUT_HDMI;
+	}
+
+	regmap_update_bits(sii902x->regmap, SII902X_SYS_CTRL_DATA,
+			   SII902X_SYS_CTRL_OUTPUT_MODE, output_mode);
+
 	mutex_unlock(&sii902x->mutex);
 }
 
@@ -960,6 +978,13 @@ static int sii902x_init(struct sii902x *sii902x)
 {
 	struct device *dev = &sii902x->i2c->dev;
 	unsigned int status = 0;
+	unsigned char data[2] = { SII902X_CEC_SETUP, 0};
+	struct i2c_msg msg = {
+		.addr	= SII902X_CEC_I2C_ADDR << 1,
+		.flags	= 0,
+		.len	= 2,
+		.buf	= data,
+	};
 	u8 chipid[4];
 	int ret;
 
@@ -982,13 +1007,22 @@ static int sii902x_init(struct sii902x *sii902x)
 		return -EINVAL;
 	}
 
+	/*
+	 * By default, CEC must be disabled to allow other CEC devives
+	 * to bypass the bridge.
+	 */
+	ret = i2c_transfer(sii902x->i2c->adapter, &msg, 1);
+	if (ret < 0)
+		dev_warn(&sii902x->i2c->dev, "Failed to disable CEC device!\n");
+
 	/* Clear all pending interrupts */
 	regmap_read(sii902x->regmap, SII902X_INT_STATUS, &status);
 	regmap_write(sii902x->regmap, SII902X_INT_STATUS, status);
 
 	if (sii902x->i2c->irq > 0) {
-		regmap_write(sii902x->regmap, SII902X_INT_ENABLE,
-			     SII902X_HOTPLUG_EVENT);
+		regmap_update_bits(sii902x->regmap, SII902X_INT_ENABLE,
+				   SII902X_HOTPLUG_EVENT,
+				   SII902X_HOTPLUG_EVENT);
 
 		ret = devm_request_threaded_irq(dev, sii902x->i2c->irq, NULL,
 						sii902x_interrupt,
@@ -1087,6 +1121,65 @@ static int sii902x_remove(struct i2c_client *client)
 	return 0;
 }
 
+static int sii902x_pm_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct sii902x *sii902x = i2c_get_clientdata(client);
+
+	DRM_DEBUG_DRIVER("\n");
+
+	if (sii902x->reset_gpio)
+		gpiod_set_value(sii902x->reset_gpio, 1);
+
+	regulator_bulk_disable(ARRAY_SIZE(sii902x->supplies),
+			       sii902x->supplies);
+
+	return 0;
+}
+
+static int sii902x_pm_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct sii902x *sii902x = i2c_get_clientdata(client);
+	unsigned char data[2] = { SII902X_CEC_SETUP, 0};
+	struct i2c_msg msg = {
+		.addr	= SII902X_CEC_I2C_ADDR << 1,
+		.flags	= 0,
+		.len	= 2,
+		.buf	= data,
+	};
+	int ret;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(sii902x->supplies),
+				    sii902x->supplies);
+	if (ret) {
+		DRM_ERROR("regulator_bulk_enable failed\n");
+		return ret;
+	}
+
+	if (sii902x->reset_gpio)
+		gpiod_set_value(sii902x->reset_gpio, 0);
+
+	regmap_write(sii902x->regmap, SII902X_REG_TPI_RQB, 0x00);
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0)
+		DRM_ERROR("Failed to disable CEC device!\n");
+
+	if (client->irq > 0)
+		regmap_update_bits(sii902x->regmap, SII902X_INT_ENABLE,
+				   SII902X_HOTPLUG_EVENT,
+				   SII902X_HOTPLUG_EVENT);
+
+	return 0;
+}
+
+static const struct dev_pm_ops sii902x_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(sii902x_pm_suspend, sii902x_pm_resume)
+};
+
 static const struct of_device_id sii902x_dt_ids[] = {
 	{ .compatible = "sil,sii9022", },
 	{ }
@@ -1105,6 +1198,7 @@ static struct i2c_driver sii902x_driver = {
 	.driver = {
 		.name = "sii902x",
 		.of_match_table = sii902x_dt_ids,
+		.pm = &sii902x_pm_ops,
 	},
 	.id_table = sii902x_i2c_ids,
 };
diff --git a/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c b/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c
index 56c3fd08c..2a58b0b7a 100644
--- a/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c
+++ b/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c
@@ -998,7 +998,10 @@ dw_mipi_dsi_bridge_mode_valid(struct drm_bridge *bridge,
 	enum drm_mode_status mode_status = MODE_OK;
 
 	if (pdata->mode_valid)
-		mode_status = pdata->mode_valid(pdata->priv_data, mode);
+		mode_status = pdata->mode_valid(pdata->priv_data, mode,
+						dsi->mode_flags,
+						dw_mipi_dsi_get_lanes(dsi),
+						dsi->format);
 
 	return mode_status;
 }
diff --git a/drivers/gpu/drm/drm_atomic_uapi.c b/drivers/gpu/drm/drm_atomic_uapi.c
index f195c7013..9301aa72e 100644
--- a/drivers/gpu/drm/drm_atomic_uapi.c
+++ b/drivers/gpu/drm/drm_atomic_uapi.c
@@ -773,6 +773,8 @@ static int drm_atomic_connector_set_property(struct drm_connector *connector,
 		state->content_type = val;
 	} else if (property == connector->scaling_mode_property) {
 		state->scaling_mode = val;
+	} else if (property == connector->dithering_property) {
+		state->dithering = val;
 	} else if (property == config->content_protection_property) {
 		if (val == DRM_MODE_CONTENT_PROTECTION_ENABLED) {
 			DRM_DEBUG_KMS("only drivers can set CP Enabled\n");
@@ -862,6 +864,8 @@ drm_atomic_connector_get_property(struct drm_connector *connector,
 		*val = state->colorspace;
 	} else if (property == connector->scaling_mode_property) {
 		*val = state->scaling_mode;
+	} else if (property == connector->dithering_property) {
+		*val = state->dithering;
 	} else if (property == config->hdr_output_metadata_property) {
 		*val = state->hdr_output_metadata ?
 			state->hdr_output_metadata->base.id : 0;
diff --git a/drivers/gpu/drm/drm_bridge.c b/drivers/gpu/drm/drm_bridge.c
index 7ee29f073..798d2cff1 100644
--- a/drivers/gpu/drm/drm_bridge.c
+++ b/drivers/gpu/drm/drm_bridge.c
@@ -227,11 +227,13 @@ int drm_bridge_attach(struct drm_encoder *encoder, struct drm_bridge *bridge,
 	list_del(&bridge->chain_node);
 
 #ifdef CONFIG_OF
-	DRM_ERROR("failed to attach bridge %pOF to encoder %s: %d\n",
-		  bridge->of_node, encoder->name, ret);
+	if (ret != -EPROBE_DEFER)
+		DRM_ERROR("failed to attach bridge %pOF to encoder %s: %d\n",
+			  bridge->of_node, encoder->name, ret);
 #else
-	DRM_ERROR("failed to attach bridge to encoder %s: %d\n",
-		  encoder->name, ret);
+	if (ret != -EPROBE_DEFER)
+		DRM_ERROR("failed to attach bridge to encoder %s: %d\n",
+			  encoder->name, ret);
 #endif
 
 	return ret;
diff --git a/drivers/gpu/drm/drm_connector.c b/drivers/gpu/drm/drm_connector.c
index e9b7926d9..c035729fa 100644
--- a/drivers/gpu/drm/drm_connector.c
+++ b/drivers/gpu/drm/drm_connector.c
@@ -824,6 +824,12 @@ static const struct drm_prop_enum_list drm_scaling_mode_enum_list[] = {
 	{ DRM_MODE_SCALE_ASPECT, "Full aspect" },
 };
 
+static const struct drm_prop_enum_list drm_dithering_enum_list[] = {
+	{ DRM_MODE_DITHERING_OFF, "Off" },
+	{ DRM_MODE_DITHERING_ON, "On" },
+	{ DRM_MODE_DITHERING_AUTO, "Automatic" },
+};
+
 static const struct drm_prop_enum_list drm_aspect_ratio_enum_list[] = {
 	{ DRM_MODE_PICTURE_ASPECT_NONE, "Automatic" },
 	{ DRM_MODE_PICTURE_ASPECT_4_3, "4:3" },
@@ -1776,6 +1782,62 @@ int drm_connector_attach_scaling_mode_property(struct drm_connector *connector,
 }
 EXPORT_SYMBOL(drm_connector_attach_scaling_mode_property);
 
+/**
+ * drm_connector_attach_dithering_property - attach atomic dithering property
+ * @connector: connector to attach dithering property on.
+ * @dithering_mask: or'ed mask of BIT(%DRM_MODE_DITHERING_\*).
+ *
+ * This is used to add support for dithering to atomic drivers.
+ *
+ * Returns:
+ * Zero on success, negative errno on failure.
+ */
+int drm_connector_attach_dithering_property(struct drm_connector *connector,
+					    u32 dithering_mask)
+{
+	struct drm_device *dev = connector->dev;
+	struct drm_property *dithering_property;
+	int i;
+	const unsigned int valid_dithering_mask =
+		(1U << ARRAY_SIZE(drm_dithering_enum_list)) - 1;
+
+	if (WARN_ON(hweight32(dithering_mask) < 2 ||
+		    dithering_mask & ~valid_dithering_mask))
+		return -EINVAL;
+
+	dithering_property =
+		drm_property_create(dev, DRM_MODE_PROP_ENUM, "dithering",
+				    hweight32(dithering_mask));
+
+	if (!dithering_property)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(drm_dithering_enum_list); i++) {
+		int ret;
+
+		if (!(BIT(i) & dithering_mask))
+			continue;
+
+		ret = drm_property_add_enum(dithering_property,
+					    drm_dithering_enum_list[i].type,
+					    drm_dithering_enum_list[i].name);
+
+		if (ret) {
+			drm_property_destroy(dev, dithering_property);
+
+			return ret;
+		}
+	}
+
+	drm_object_attach_property(&connector->base,
+				   dithering_property, 0);
+
+	connector->dithering_property = dithering_property;
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_connector_attach_dithering_property);
+
 /**
  * drm_mode_create_aspect_ratio_property - create aspect ratio property
  * @dev: DRM device
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index 479ffdb64..c49fb01b1 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -359,6 +359,15 @@ config DRM_PANEL_RAYDIUM_RM68200
 	  Say Y here if you want to enable support for Raydium RM68200
 	  720x1280 DSI video mode panel.
 
+config DRM_PANEL_ROCKTECH_HX8394
+	tristate "Rocktech HX8394 720x1280 DSI video mode panel"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y here if you want to enable support for Rocktech HX8394
+	  720x1280 DSI video mode panel.
+
 config DRM_PANEL_RONBO_RB070D30
 	tristate "Ronbo Electronics RB070D30 panel"
 	depends on OF
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index c8132050b..57d794897 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -10,6 +10,7 @@ obj-$(CONFIG_DRM_PANEL_SIMPLE) += panel-simple.o
 obj-$(CONFIG_DRM_PANEL_ELIDA_KD35T133) += panel-elida-kd35t133.o
 obj-$(CONFIG_DRM_PANEL_FEIXIN_K101_IM2BA02) += panel-feixin-k101-im2ba02.o
 obj-$(CONFIG_DRM_PANEL_FEIYANG_FY07024DI26A30D) += panel-feiyang-fy07024di26a30d.o
+obj-$(CONFIG_DRM_PANEL_ROCKTECH_HX8394) += panel-rocktech-hx8394.o
 obj-$(CONFIG_DRM_PANEL_ILITEK_IL9322) += panel-ilitek-ili9322.o
 obj-$(CONFIG_DRM_PANEL_ILITEK_ILI9341) += panel-ilitek-ili9341.o
 obj-$(CONFIG_DRM_PANEL_ILITEK_ILI9881C) += panel-ilitek-ili9881c.o
diff --git a/drivers/gpu/drm/panel/panel-orisetech-otm8009a.c b/drivers/gpu/drm/panel/panel-orisetech-otm8009a.c
index f80b44a8a..70b2bb72d 100644
--- a/drivers/gpu/drm/panel/panel-orisetech-otm8009a.c
+++ b/drivers/gpu/drm/panel/panel-orisetech-otm8009a.c
@@ -60,6 +60,9 @@
 #define MCS_CMD2_ENA1	0xFF00	/* Enable Access Command2 "CMD2" */
 #define MCS_CMD2_ENA2	0xFF80	/* Enable Access Orise Command2 */
 
+#define OTM8009A_HDISPLAY	480
+#define OTM8009A_VDISPLAY	800
+
 struct otm8009a {
 	struct device *dev;
 	struct drm_panel panel;
@@ -70,19 +73,35 @@ struct otm8009a {
 	bool enabled;
 };
 
-static const struct drm_display_mode default_mode = {
-	.clock = 29700,
-	.hdisplay = 480,
-	.hsync_start = 480 + 98,
-	.hsync_end = 480 + 98 + 32,
-	.htotal = 480 + 98 + 32 + 98,
-	.vdisplay = 800,
-	.vsync_start = 800 + 15,
-	.vsync_end = 800 + 15 + 10,
-	.vtotal = 800 + 15 + 10 + 14,
-	.flags = 0,
-	.width_mm = 52,
-	.height_mm = 86,
+static const struct drm_display_mode modes[] = {
+	{ /* 50 Hz, preferred */
+		.clock = 29700,
+		.hdisplay = 480,
+		.hsync_start = 480 + 98,
+		.hsync_end = 480 + 98 + 32,
+		.htotal = 480 + 98 + 32 + 98,
+		.vdisplay = 800,
+		.vsync_start = 800 + 15,
+		.vsync_end = 800 + 15 + 10,
+		.vtotal = 800 + 15 + 10 + 14,
+		.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+		.width_mm = 52,
+		.height_mm = 86,
+	},
+	{ /* 60 Hz */
+		.clock = 33000,
+		.hdisplay = 480,
+		.hsync_start = 480 + 70,
+		.hsync_end = 480 + 70 + 32,
+		.htotal = 480 + 70 + 32 + 72,
+		.vdisplay = 800,
+		.vsync_start = 800 + 15,
+		.vsync_end = 800 + 15 + 10,
+		.vtotal = 800 + 15 + 10 + 16,
+		.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+		.width_mm = 52,
+		.height_mm = 86,
+	},
 };
 
 static inline struct otm8009a *panel_to_otm8009a(struct drm_panel *panel)
@@ -208,12 +227,11 @@ static int otm8009a_init_sequence(struct otm8009a *ctx)
 	/* Default portrait 480x800 rgb24 */
 	dcs_write_seq(ctx, MIPI_DCS_SET_ADDRESS_MODE, 0x00);
 
-	ret = mipi_dsi_dcs_set_column_address(dsi, 0,
-					      default_mode.hdisplay - 1);
+	ret = mipi_dsi_dcs_set_column_address(dsi, 0, OTM8009A_HDISPLAY - 1);
 	if (ret)
 		return ret;
 
-	ret = mipi_dsi_dcs_set_page_address(dsi, 0, default_mode.vdisplay - 1);
+	ret = mipi_dsi_dcs_set_page_address(dsi, 0, OTM8009A_VDISPLAY - 1);
 	if (ret)
 		return ret;
 
@@ -337,24 +355,35 @@ static int otm8009a_get_modes(struct drm_panel *panel,
 			      struct drm_connector *connector)
 {
 	struct drm_display_mode *mode;
-
-	mode = drm_mode_duplicate(connector->dev, &default_mode);
-	if (!mode) {
-		dev_err(panel->dev, "failed to add mode %ux%u@%u\n",
-			default_mode.hdisplay, default_mode.vdisplay,
-			drm_mode_vrefresh(&default_mode));
-		return -ENOMEM;
+	unsigned int num_modes = ARRAY_SIZE(modes);
+	unsigned int i;
+
+	for (i = 0; i < num_modes; i++) {
+		mode = drm_mode_duplicate(connector->dev, &modes[i]);
+		if (!mode) {
+			dev_err(panel->dev, "failed to add mode %ux%u@%u\n",
+				modes[i].hdisplay,
+				modes[i].vdisplay,
+				drm_mode_vrefresh(&modes[i]));
+			return -ENOMEM;
+		}
+
+		mode->type = DRM_MODE_TYPE_DRIVER;
+
+		/* Setting first mode as preferred */
+		if (!i)
+			mode->type |=  DRM_MODE_TYPE_PREFERRED;
+
+		drm_mode_set_name(mode);
+		drm_mode_probed_add(connector, mode);
 	}
 
-	drm_mode_set_name(mode);
-
-	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
-	drm_mode_probed_add(connector, mode);
-
 	connector->display_info.width_mm = mode->width_mm;
 	connector->display_info.height_mm = mode->height_mm;
+	connector->display_info.bus_flags = DRM_BUS_FLAG_DE_HIGH |
+					    DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;
 
-	return 1;
+	return num_modes;
 }
 
 static const struct drm_panel_funcs otm8009a_drm_funcs = {
@@ -419,8 +448,18 @@ static int otm8009a_probe(struct mipi_dsi_device *dsi)
 
 	ctx->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
 	if (IS_ERR(ctx->reset_gpio)) {
-		dev_err(dev, "cannot get reset-gpio\n");
-		return PTR_ERR(ctx->reset_gpio);
+		ret = PTR_ERR(ctx->reset_gpio);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "cannot get reset GPIO: %d\n", ret);
+		return ret;
+	}
+
+	/* Reset the panel to avoid visual artifacts */
+	if (ctx->reset_gpio) {
+		gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		msleep(20);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 0);
 	}
 
 	ctx->supply = devm_regulator_get(dev, "power");
diff --git a/drivers/gpu/drm/panel/panel-raydium-rm68200.c b/drivers/gpu/drm/panel/panel-raydium-rm68200.c
index 412c0dbcb..d5542266e 100644
--- a/drivers/gpu/drm/panel/panel-raydium-rm68200.c
+++ b/drivers/gpu/drm/panel/panel-raydium-rm68200.c
@@ -91,7 +91,7 @@ static const struct drm_display_mode default_mode = {
 	.vsync_start = 1280 + 12,
 	.vsync_end = 1280 + 12 + 5,
 	.vtotal = 1280 + 12 + 5 + 12,
-	.flags = 0,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
 	.width_mm = 68,
 	.height_mm = 122,
 };
@@ -347,6 +347,8 @@ static int rm68200_get_modes(struct drm_panel *panel,
 
 	connector->display_info.width_mm = mode->width_mm;
 	connector->display_info.height_mm = mode->height_mm;
+	connector->display_info.bus_flags = DRM_BUS_FLAG_DE_HIGH |
+					    DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;
 
 	return 1;
 }
@@ -372,7 +374,8 @@ static int rm68200_probe(struct mipi_dsi_device *dsi)
 	ctx->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
 	if (IS_ERR(ctx->reset_gpio)) {
 		ret = PTR_ERR(ctx->reset_gpio);
-		dev_err(dev, "cannot get reset GPIO: %d\n", ret);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "cannot get reset GPIO: %d\n", ret);
 		return ret;
 	}
 
diff --git a/drivers/gpu/drm/panel/panel-rocktech-hx8394.c b/drivers/gpu/drm/panel/panel-rocktech-hx8394.c
new file mode 100644
index 000000000..6a5926cc7
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-rocktech-hx8394.c
@@ -0,0 +1,397 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics SA 2022
+ *
+ * Author: Yannick Fertre <yannick.fertre@foss.st.com>
+ */
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct hx8394 {
+	struct device *dev;
+	struct drm_panel panel;
+	struct gpio_desc *reset_gpio;
+	struct regulator *supply;
+	bool prepared;
+	bool enabled;
+};
+
+static const struct drm_display_mode default_mode = {
+	.clock = 54000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 48,
+	.hsync_end = 720 + 48 + 9,
+	.htotal = 720 + 48 + 9 + 48,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 12,
+	.vsync_end = 1280 + 12 + 5,
+	.vtotal = 1280 + 12 + 5 + 12,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+	.width_mm = 68,
+	.height_mm = 122,
+};
+
+#define MCS_SETPOWER	0xB1
+#define MCS_SETDISP	0xB2
+#define MCS_SETCYC	0xB4
+#define MCS_SETVCOM	0xB6
+#define MCS_SETEXTC	0xB9
+#define MCS_SETMIPI	0xBA
+#define MCS_SET_BANK	0xBD
+#define MCS_NO_DOC1	0xBF
+#define MCS_NO_DOC2	0xC0
+#define MCS_NO_DOC3	0xC6
+#define MCS_NO_DOC4	0xD8
+#define MCS_NO_DOC5	0xD4
+#define MCS_SETPANEL	0xCC
+#define MCS_SETGIP_0	0xD3
+#define MCS_SETGIP_1	0xD5
+#define MCS_SETGIP_2	0xD6
+
+#define MCS_SETGAMMA	0xE0
+#define MCS_READ_ID1	0xDA
+#define MCS_READ_ID2	0xDB
+#define MCS_READ_ID3	0xDC
+
+#define MY	BIT(7)	/* Row Address Order */
+#define MX	BIT(6)	/* Column Address Order */
+#define MV	BIT(5)	/* Row/Column Exchange */
+#define ML	BIT(4)	/* Vertical Refresh Order */
+#define RGB	BIT(3)	/* RGB-BGR Order */
+#define DDL	BIT(2)	/* Display Data Latch Order */
+#define FH	BIT(1)	/* Flip Horizontal */
+#define FV	BIT(0)	/* Flip Vertical */
+
+static inline struct hx8394 *panel_to_hx8394(struct drm_panel *panel)
+{
+	return container_of(panel, struct hx8394, panel);
+}
+
+#define dcs_write_cmd_seq(ctx, cmd, seq...)						\
+({											\
+	static const u8 d[] = { seq };							\
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);			\
+	int err;									\
+	err = mipi_dsi_dcs_write(dsi, cmd, d, ARRAY_SIZE(d));				\
+	if (err < 0)									\
+		dev_err(ctx->dev, "MIPI DSI DCS write failed: %d\n",err);		\
+})
+
+static void hx8394_dcs_write_buf(struct hx8394 *ctx, const void *data,
+				  size_t len)
+{
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	int err;
+
+	err = mipi_dsi_dcs_write_buffer(dsi, data, len);
+	if (err < 0)
+		dev_err_ratelimited(ctx->dev, "MIPI DSI DCS write buffer failed: %d\n", err);
+}
+
+#define dcs_write_seq(ctx, seq...)				\
+({								\
+	static const u8 d[] = { seq };				\
+								\
+	hx8394_dcs_write_buf(ctx, d, ARRAY_SIZE(d));	\
+})
+
+static void hx8394_init_sequence(struct hx8394 *ctx)
+{
+	dcs_write_cmd_seq(ctx, MCS_SETEXTC, 0xFF, 0x83, 0x94);
+	dcs_write_cmd_seq(ctx, MCS_SETMIPI, 0x61, 0x03, 0x68, 0x6B, 0xB2, 0xC0);
+	dcs_write_seq(ctx, MCS_SETPOWER, 0x48, 0x12, 0x72, 0x09, 0x32, 0x54, 0x71, 0x71, 0x57,
+		      0x47);
+	dcs_write_cmd_seq(ctx, MCS_SETDISP, 0x00, 0x80, 0x64, 0x0C, 0x0D, 0x2F);
+	dcs_write_seq(ctx, MCS_SETCYC, 0x73, 0x74, 0x73, 0x74, 0x73, 0x74, 0x01, 0x0C, 0x86, 0x75,
+		      0x00, 0x3F, 0x73, 0x74, 0x73, 0x74, 0x73, 0x74, 0x01, 0x0C, 0x86);
+	dcs_write_seq(ctx, MCS_SETGIP_0, 0x00, 0x00, 0x07, 0x07, 0x40, 0x07, 0x0C, 0x00, 0x08, 0x10,
+		      0x08, 0x00, 0x08, 0x54, 0x15, 0x0A, 0x05, 0x0A, 0x02, 0x15, 0x06, 0x05, 0x06,
+		      0x47, 0x44, 0x0A, 0x0A, 0x4B, 0x10, 0x07, 0x07, 0x0C, 0x40);
+	dcs_write_seq(ctx, MCS_SETGIP_1, 0x1C, 0x1C, 0x1D, 0x1D, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
+		      0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x24, 0x25, 0x18, 0x18, 0x26, 0x27, 0x18,
+		      0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+		      0x18, 0x18, 0x20, 0x21, 0x18, 0x18, 0x18, 0x18);
+	dcs_write_seq(ctx, MCS_SETGIP_2, 0x1C, 0x1C, 0x1D, 0x1D, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02,
+		      0x01, 0x00, 0x0B, 0x0A, 0x09, 0x08, 0x21, 0x20, 0x18, 0x18, 0x27, 0x26, 0x18,
+		      0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+		      0x18, 0x18, 0x25, 0x24, 0x18, 0x18, 0x18, 0x18);
+	dcs_write_cmd_seq(ctx, MCS_SETVCOM, 0x92, 0x92);
+	dcs_write_seq(ctx, MCS_SETGAMMA, 0x00, 0x0A, 0x15, 0x1B, 0x1E, 0x21, 0x24, 0x22, 0x47, 0x56,
+		      0x65, 0x66, 0x6E, 0x82, 0x88, 0x8B, 0x9A, 0x9D, 0x98, 0xA8, 0xB9, 0x5D, 0x5C,
+		      0x61, 0x66, 0x6A, 0x6F, 0x7F, 0x7F, 0x00, 0x0A, 0x15, 0x1B, 0x1E, 0x21, 0x24,
+		      0x22, 0x47, 0x56, 0x65, 0x65, 0x6E, 0x81, 0x87, 0x8B, 0x98, 0x9D, 0x99, 0xA8,
+		      0xBA, 0x5D, 0x5D, 0x62, 0x67, 0x6B, 0x72, 0x7F,  0x7F);
+	dcs_write_cmd_seq(ctx, MCS_NO_DOC2, 0x1F, 0x31);
+	dcs_write_cmd_seq(ctx, MCS_SETPANEL, 0x03);
+	dcs_write_cmd_seq(ctx, MCS_NO_DOC5, 0x02);
+	dcs_write_cmd_seq(ctx, MCS_SET_BANK, 0x02);
+	dcs_write_seq(ctx, MCS_NO_DOC4, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+		      0xFF, 0xFF);
+	dcs_write_cmd_seq(ctx, MCS_SET_BANK, 0x00);
+	dcs_write_cmd_seq(ctx, MCS_SET_BANK, 0x01);
+	dcs_write_cmd_seq(ctx, MCS_SETPOWER, 0x00);
+	dcs_write_cmd_seq(ctx, MCS_SET_BANK, 0x00);
+	dcs_write_cmd_seq(ctx, MCS_NO_DOC1, 0x40, 0x81, 0x50, 0x00, 0x1A, 0xFC, 0x01);
+	dcs_write_cmd_seq(ctx, MCS_NO_DOC3, 0xED);
+	dcs_write_cmd_seq(ctx, MIPI_DCS_SET_ADDRESS_MODE, FH);
+}
+
+
+static int hx8394_read_id(struct hx8394 *ctx)
+{
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	u8 id1, id2, id3;
+	int ret;
+
+	ret = mipi_dsi_dcs_read(dsi, MCS_READ_ID1, &id1, 1);
+	if (ret < 0) {
+		dev_err(ctx->dev, "could not read MTP ID1\n");
+		return ret;
+	}
+	ret = mipi_dsi_dcs_read(dsi, MCS_READ_ID2, &id2, 1);
+	if (ret < 0) {
+		dev_err(ctx->dev, "could not read MTP ID2\n");
+		return ret;
+	}
+	ret = mipi_dsi_dcs_read(dsi, MCS_READ_ID3, &id3, 1);
+	if (ret < 0) {
+		dev_err(ctx->dev, "could not read MTP ID3\n");
+		return ret;
+	}
+
+	dev_info(ctx->dev, "MTP ID manufacturer: %02x version: %02x driver: %02x\n", id1, id2, id3);
+
+	return 0;
+}
+
+static int hx8394_enable(struct drm_panel *panel)
+{
+	struct hx8394 *ctx = panel_to_hx8394(panel);
+
+	if (ctx->enabled)
+		return 0;
+
+	ctx->enabled = true;
+
+	return 0;
+}
+
+static int hx8394_disable(struct drm_panel *panel)
+{
+	struct hx8394 *ctx = panel_to_hx8394(panel);
+
+	if (!ctx->enabled)
+		return 0;
+
+	ctx->enabled = false;
+
+	return 0;
+}
+
+static int hx8394_prepare(struct drm_panel *panel)
+{
+	struct hx8394 *ctx = panel_to_hx8394(panel);
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(ctx->dev, "failed to enable supply: %d\n", ret);
+		return ret;
+	}
+
+	if (ctx->reset_gpio) {
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		msleep(1);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+		msleep(50);
+	}
+
+	ret = hx8394_read_id(ctx);
+	if (ret < 0)
+		return ret;
+
+	hx8394_init_sequence(ctx);
+
+	ret = mipi_dsi_dcs_set_tear_off(dsi);
+	if (ret)
+		return ret;
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret)
+		return ret;
+
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret)
+		return ret;
+
+	msleep(50);
+
+	ctx->prepared = true;
+
+	return 0;
+}
+
+static int hx8394_unprepare(struct drm_panel *panel)
+{
+	struct hx8394 *ctx = panel_to_hx8394(panel);
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret)
+		dev_warn(panel->dev, "failed to set display off: %d\n", ret);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret)
+		dev_warn(panel->dev, "failed to enter sleep mode: %d\n", ret);
+
+	msleep(120);
+
+	if (ctx->reset_gpio) {
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		msleep(20);
+	}
+
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
+
+	return 0;
+}
+
+static int hx8394_get_modes(struct drm_panel *panel,
+			     struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &default_mode);
+	if (!mode) {
+		dev_err(panel->dev, "failed to add mode %ux%u@%u\n",
+			default_mode.hdisplay, default_mode.vdisplay,
+			drm_mode_vrefresh(&default_mode));
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	connector->display_info.bus_flags = DRM_BUS_FLAG_DE_HIGH |
+					    DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;
+
+	return 1;
+}
+
+static const struct drm_panel_funcs hx8394_drm_funcs = {
+	.disable = hx8394_disable,
+	.unprepare = hx8394_unprepare,
+	.prepare = hx8394_prepare,
+	.enable = hx8394_enable,
+	.get_modes = hx8394_get_modes,
+};
+
+static int hx8394_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct hx8394 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->reset_gpio)) {
+		ret = PTR_ERR(ctx->reset_gpio);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "cannot get reset GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply)) {
+		ret = PTR_ERR(ctx->supply);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "cannot get regulator: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	ctx->dev = dev;
+
+	dsi->lanes = 2;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_LPM | MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &hx8394_drm_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return ret;
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "mipi_dsi_attach() failed: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int hx8394_remove(struct mipi_dsi_device *dsi)
+{
+	struct hx8394 *ctx = mipi_dsi_get_drvdata(dsi);
+
+	mipi_dsi_detach(dsi);
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id rocktech_hx8394_of_match[] = {
+	{ .compatible = "rocktech,hx8394" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, rocktech_hx8394_of_match);
+
+static struct mipi_dsi_driver rocktech_hx8394_driver = {
+	.probe = hx8394_probe,
+	.remove = hx8394_remove,
+	.driver = {
+		.name = "panel-rocktech-hx8394",
+		.of_match_table = rocktech_hx8394_of_match,
+	},
+};
+module_mipi_dsi_driver(rocktech_hx8394_driver);
+
+MODULE_AUTHOR("Yannick Fertre <yannick.fertre@foss.st.com>");
+MODULE_DESCRIPTION("DRM Driver for rocktech HX8394 MIPI DSI panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index 8dd7013c7..6934f3680 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -575,6 +575,7 @@ static int panel_dpi_probe(struct device *dev,
 	struct panel_desc *desc;
 	unsigned int bus_flags;
 	struct videomode vm;
+	const char *mapping;
 	int ret;
 
 	np = dev->of_node;
@@ -599,6 +600,21 @@ static int panel_dpi_probe(struct device *dev,
 	of_property_read_u32(np, "width-mm", &desc->size.width);
 	of_property_read_u32(np, "height-mm", &desc->size.height);
 
+	of_property_read_string(np, "data-mapping", &mapping);
+	if (!strcmp(mapping, "rgb24")) {
+		desc->bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+		desc->bpc = 8;
+	} else if (!strcmp(mapping, "rgb565")) {
+		desc->bus_format = MEDIA_BUS_FMT_RGB565_1X16;
+		desc->bpc = 6;
+	} else if (!strcmp(mapping, "bgr666")) {
+		desc->bus_format = MEDIA_BUS_FMT_RGB666_1X18;
+		desc->bpc = 6;
+	} else if (!strcmp(mapping, "lvds666")) {
+		desc->bus_format = MEDIA_BUS_FMT_RGB666_1X24_CPADHI;
+		desc->bpc = 6;
+	}
+
 	/* Extract bus_flags from display_timing */
 	bus_flags = 0;
 	vm.flags = timing->flags;
diff --git a/drivers/gpu/drm/stm/Kconfig b/drivers/gpu/drm/stm/Kconfig
index b7d66915a..109bb732e 100644
--- a/drivers/gpu/drm/stm/Kconfig
+++ b/drivers/gpu/drm/stm/Kconfig
@@ -21,3 +21,9 @@ config DRM_STM_DSI
 	select DRM_DW_MIPI_DSI
 	help
 	  Choose this option for MIPI DSI support on STMicroelectronics SoC.
+
+config DRM_STM_LVDS
+	tristate "STMicroelectronics LVDS Display Interface Transmitter DRM driver"
+	depends on DRM_STM
+	help
+	  Enable support for LVDS encoders on STMicroelectronics SoC.
diff --git a/drivers/gpu/drm/stm/Makefile b/drivers/gpu/drm/stm/Makefile
index 4df5caf01..ad740d617 100644
--- a/drivers/gpu/drm/stm/Makefile
+++ b/drivers/gpu/drm/stm/Makefile
@@ -5,4 +5,6 @@ stm-drm-y := \
 
 obj-$(CONFIG_DRM_STM_DSI) += dw_mipi_dsi-stm.o
 
+obj-$(CONFIG_DRM_STM_LVDS) += lvds.o
+
 obj-$(CONFIG_DRM_STM) += stm-drm.o
diff --git a/drivers/gpu/drm/stm/drv.c b/drivers/gpu/drm/stm/drv.c
index 222869b23..85c94b8f5 100644
--- a/drivers/gpu/drm/stm/drv.c
+++ b/drivers/gpu/drm/stm/drv.c
@@ -14,6 +14,7 @@
 #include <linux/of_platform.h>
 #include <linux/pm_runtime.h>
 
+#include <drm/drm_aperture.h>
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_drv.h>
@@ -93,6 +94,7 @@ static int drv_load(struct drm_device *ddev)
 	ddev->mode_config.max_width = STM_MAX_FB_WIDTH;
 	ddev->mode_config.max_height = STM_MAX_FB_HEIGHT;
 	ddev->mode_config.funcs = &drv_mode_config_funcs;
+	ddev->mode_config.normalize_zpos = true;
 
 	ret = ltdc_load(ddev);
 	if (ret)
@@ -183,6 +185,10 @@ static int stm_drm_platform_probe(struct platform_device *pdev)
 
 	DRM_DEBUG("%s\n", __func__);
 
+	ret = drm_aperture_remove_framebuffers(false, &drv_driver);
+	if (ret)
+		return ret;
+
 	dma_set_coherent_mask(dev, DMA_BIT_MASK(32));
 
 	ddev = drm_dev_alloc(&drv_driver, dev);
diff --git a/drivers/gpu/drm/stm/dw_mipi_dsi-stm.c b/drivers/gpu/drm/stm/dw_mipi_dsi-stm.c
index 32cb41b22..9611470db 100644
--- a/drivers/gpu/drm/stm/dw_mipi_dsi-stm.c
+++ b/drivers/gpu/drm/stm/dw_mipi_dsi-stm.c
@@ -4,12 +4,14 @@
  *
  * Authors: Philippe Cornu <philippe.cornu@st.com>
  *          Yannick Fertre <yannick.fertre@st.com>
+ *          Raphaël Gallais-Pou <raphael.gallais-pou@foss.st.com>
  */
 
 #include <linux/clk.h>
 #include <linux/iopoll.h>
 #include <linux/mod_devicetable.h>
 #include <linux/module.h>
+#include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/regulator/consumer.h>
 
@@ -21,6 +23,7 @@
 
 #define HWVER_130			0x31333000	/* IP version 1.30 */
 #define HWVER_131			0x31333100	/* IP version 1.31 */
+#define HWVER_141			0x31343100	/* IP version 1.41 */
 
 /* DSI digital registers & bit definitions */
 #define DSI_VERSION			0x00
@@ -57,6 +60,50 @@
 #define ODF_MIN		1
 #define ODF_MAX		8
 
+/* specific registers for hardware version 1.41 */
+#define DSI_WPCR1	0x0430		/* Wrapper Phy Conf Reg 1 */
+#define WPCR1_CCF	GENMASK(5, 0)	/* Configuration clock frequency */
+#define WPCR1_HSFR	GENMASK(14, 8)	/* High speed frequency range in Tx mode */
+#define WPCR1_DLD	BIT(16)		/* Data lanes 0 direction */
+
+#define DSI_WRPCR0	0x0434		/* Wrapper regulator and PLL configuration register 0 */
+#define WRPCR0_IDF	GENMASK(3, 0)	/* PLL input division ratio */
+#define WRPCR0_NDIV	GENMASK(13, 4)	/* PLL InLoop division ratio */
+#define WRPCR0_PSC	BIT(16)		/* PLL shadow control */
+
+#define DSI_WRPCR1	0x0438		/* Wrapper regulator and PLL configuration register 1 */
+#define WRPCR1_PROP	GENMASK(5, 0)	/* Proportional charge pump */
+#define WRPCR1_GMP	GENMASK(7, 6)	/* Loop filter resistance */
+#define WRPCR1_INT	GENMASK(13, 8)	/* Integral of charge pump */
+#define WRPCR1_BIAS	GENMASK(22, 16)	/* Charge pump bias */
+#define WRPCR1_VCO	GENMASK(27, 24)	/* VCO operating range */
+#define WRPCR1_ODF	GENMASK(29, 28)	/* Output division factor */
+
+#define DSI_WRPCR2	0x043C		/* Wrapper regulator and PLL configuration register 2 */
+#define WRPCR2_SEL	GENMASK(1, 0)	/* Output selection for PLL Clock */
+#define WRPCR2_PLLEN	BIT(8)		/* PLL ENable */
+#define WRPCR2_UPD	BIT(16)		/* Update (copies) the PLL shadow registers */
+#define WRPCR2_CLR	BIT(24)		/* Clears the PLL shadow registers to their reset values */
+#define WRPCR2_FPLL	BIT(28)		/* Force PLL lock signal */
+
+#define DSI_PTCR0	0x00B4		/* Host PHY test control register 0 */
+#define PTCR0_TRSEN	BIT(0)		/* Test-interface reset enable for the TDI bus */
+#define PTCR0_TCKEN	BIT(1)		/* Test-interface clock enable for the TDI bus */
+
+#define DSI_PCTLR	0x00A0		/* Host PHY control register */
+#define PCTLR_PWEN	BIT(0)		/* Power enable */
+#define PCTLR_DEN	BIT(1)		/* Digital enable */
+#define PCTLR_CKEN	BIT(2)		/* Clock enable */
+#define PCTLR_UCKEN	BIT(3)		/* ULPS clock enable */
+
+#define DSI_PSR		0x00B0		/* Host PHY status register */
+#define PSR_PSSC	BIT(2)		/* PHY stop state clock lane */
+
+#define IDF_PHY_141_MIN		1
+#define IDF_PHY_141_MAX		16
+#define NDIV_PHY_141_MIN	64
+#define NDIV_PHY_141_MAX	625
+
 /* dsi color format coding according to the datasheet */
 enum dsi_color {
 	DSI_RGB565_CONF1,
@@ -70,6 +117,11 @@ enum dsi_color {
 #define LANE_MIN_KBPS	31250
 #define LANE_MAX_KBPS	500000
 
+#define LANE_MIN_PHY_141_KBPS	80000
+#define LANE_MAX_PHY_141_KBPS	2500000
+#define FVCO_MIN_PHY_141_KBPS	320000
+#define FVCO_MAX_PHY_141_KBPS	1250000
+
 /* Sleep & timeout for regulator on/off, pll lock/unlock & fifo empty */
 #define SLEEP_US	1000
 #define TIMEOUT_US	200000
@@ -82,6 +134,9 @@ struct dw_mipi_dsi_stm {
 	int lane_min_kbps;
 	int lane_max_kbps;
 	struct regulator *vdd_supply;
+	struct dw_mipi_dsi_plat_data pdata;
+	unsigned int lane_mbps;
+	u32 format;
 };
 
 static inline void dsi_write(struct dw_mipi_dsi_stm *dsi, u32 reg, u32 val)
@@ -194,6 +249,286 @@ static int dsi_pll_get_params(struct dw_mipi_dsi_stm *dsi,
 	return 0;
 }
 
+static int dsi_phy_141_pll_get_params(struct dw_mipi_dsi_stm *dsi,
+				      int clkin_khz, int clkout_khz,
+				      int *idf, int *ndiv, int *odf)
+{
+	int i, n;
+	int delta, best_delta; /* all in khz */
+
+	/* Early checks preventing division by 0 & odd results */
+	if (clkin_khz <= 0 || clkout_khz <= 0)
+		return -EINVAL;
+
+	best_delta = 1000000; /* big started value (1000000khz) */
+
+	for (i = IDF_PHY_141_MIN; i <= IDF_PHY_141_MAX; i++) {
+		for (n = NDIV_PHY_141_MIN; n <= NDIV_PHY_141_MAX; n++) {
+			/* Check if new delta is better & saves parameters */
+			delta = dsi_pll_get_clkout_khz(clkin_khz, i, n, *odf) - clkout_khz;
+
+			if (delta < 0)
+				delta = -delta;
+			if (delta < best_delta) {
+				*idf = i;
+				*ndiv = n;
+				best_delta = delta;
+			}
+			/* fast return in case of "perfect result" */
+			if (!delta)
+				return 0;
+		}
+	}
+
+	return 0;
+}
+
+struct dphy_pll_parameter_map {
+	u32 data_rate;	/* upper margin of frequency range */
+	u8 hs_freq;	/* hsfreqrange */
+	u8 odf;
+	u8 vco;
+	u8 prop;
+};
+
+static const struct dphy_pll_parameter_map dppa_map[] = {
+	{80, 0x00, 0x03, 0x0F, 0x0B},
+	{90, 0x10, 0x03, 0x0F, 0x0B},
+	{100, 0x20, 0x03, 0x0F, 0x0B},
+	{110, 0x30, 0x03, 0x09, 0x0B},
+	{120, 0x01, 0x03, 0x09, 0x0B},
+	{130, 0x11, 0x03, 0x09, 0x0B},
+	{140, 0x21, 0x03, 0x09, 0x0B},
+	{150, 0x31, 0x03, 0x09, 0x0B},
+	{160, 0x02, 0x02, 0x0F, 0x0B},
+	{170, 0x12, 0x02, 0x0F, 0x0B},
+	{180, 0x22, 0x02, 0x0F, 0x0B},
+	{190, 0x32, 0x02, 0x0F, 0x0B},
+	{205, 0x03, 0x02, 0x0F, 0x0B},
+	{220, 0x13, 0x02, 0x09, 0x0B},
+	{235, 0x23, 0x02, 0x09, 0x0B},
+	{250, 0x33, 0x02, 0x09, 0x0B},
+	{275, 0x04, 0x02, 0x09, 0x0B},
+	{300, 0x14, 0x02, 0x09, 0x0B},
+	{325, 0x25, 0x01, 0x0F, 0x0B},
+	{350, 0x35, 0x01, 0x0F, 0x0B},
+	{400, 0x05, 0x01, 0x0F, 0x0B},
+	{450, 0x16, 0x01, 0x09, 0x0B},
+	{500, 0x26, 0x01, 0x09, 0x0B},
+	{550, 0x37, 0x01, 0x09, 0x0B},
+	{600, 0x07, 0x01, 0x09, 0x0B},
+	{650, 0x18, 0x00, 0x0F, 0x0B},
+	{700, 0x28, 0x00, 0x0F, 0x0B},
+	{750, 0x39, 0x00, 0x0F, 0x0B},
+	{800, 0x09, 0x00, 0x0F, 0x0B},
+	{850, 0x19, 0x00, 0x09, 0x0B},
+	{900, 0x29, 0x00, 0x09, 0x0B},
+	{950, 0x3A, 0x00, 0x09, 0x0B},
+	{1000, 0x0A, 0x00, 0x09, 0x0B},
+	{1050, 0x1A, 0x00, 0x09, 0x0B},
+	{1100, 0x2A, 0x00, 0x09, 0x0B},
+	{1150, 0x3B, 0x00, 0x09, 0x0B},
+	{1200, 0x0B, 0x00, 0x09, 0x0B},
+	{1250, 0x1B, 0x00, 0x09, 0x0B},
+	{1300, 0x2B, 0x00, 0x03, 0x0B},
+	{1350, 0x3C, 0x00, 0x03, 0x0B},
+	{1400, 0x0C, 0x00, 0x03, 0x0B},
+	{1450, 0x1C, 0x00, 0x03, 0x0B},
+	{1500, 0x2C, 0x00, 0x03, 0x0B},
+	{1550, 0x3D, 0x00, 0x03, 0x0B},
+	{1600, 0x0D, 0x00, 0x03, 0x0B},
+	{1650, 0x1D, 0x00, 0x03, 0x0B},
+	{1700, 0x2E, 0x00, 0x03, 0x0B},
+	{1750, 0x3E, 0x00, 0x03, 0x0B},
+	{1800, 0x0E, 0x00, 0x03, 0x0B},
+	{1850, 0x1E, 0x00, 0x03, 0x0B},
+	{1900, 0x2F, 0x00, 0x03, 0x0B},
+	{1950, 0x3F, 0x00, 0x03, 0x0B},
+	{2000, 0x0F, 0x00, 0x03, 0x0B},
+	{2050, 0x40, 0x00, 0x03, 0x0B},
+	{2100, 0x41, 0x00, 0x03, 0x0B},
+	{2150, 0x42, 0x00, 0x03, 0x0B},
+	{2200, 0x43, 0x00, 0x01, 0x0B},
+	{2250, 0x44, 0x00, 0x01, 0x0B},
+	{2300, 0x45, 0x00, 0x01, 0x0C},
+	{2350, 0x46, 0x00, 0x01, 0x0C},
+	{2400, 0x47, 0x00, 0x01, 0x0C},
+	{2450, 0x48, 0x00, 0x01, 0x0C},
+	{2500, 0x49, 0x00, 0x01, 0x0C}
+};
+
+static int dw_mipi_dsi_phy_141_init(void *priv_data)
+{
+	struct dw_mipi_dsi_stm *dsi = priv_data;
+	u32 val, ccf, prop, gmp, int1, bias, vco, ndiv, odf, idf;
+	unsigned int pll_in_khz, pll_out_khz, hsfreq;
+	int ret, i;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	/* Select video mode by resetting DSIM bit */
+	dsi_clear(dsi, DSI_WCFGR, WCFGR_DSIM);
+
+	/* Select the color coding */
+	dsi_update_bits(dsi, DSI_WCFGR, WCFGR_COLMUX,
+			dsi_color_from_mipi(dsi->format) << 1);
+
+	dsi_write(dsi, DSI_PCTLR, 0x00);
+
+	/* clear the pll shadow regs */
+	dsi_set(dsi, DSI_WRPCR2, WRPCR2_CLR);
+	mdelay(1);
+
+	dsi_clear(dsi, DSI_WRPCR2, WRPCR2_CLR);
+	mdelay(1);
+
+	/* set testclr = 1 */
+	dsi_set(dsi, DSI_PTCR0, PTCR0_TRSEN);
+	mdelay(1);
+
+	dsi_clear(dsi, DSI_PTCR0, PTCR0_TRSEN);
+	mdelay(1);
+
+	/* Compute requested pll out, pll out is the half of the lane data rate */
+	pll_out_khz = dsi->lane_mbps * 1000 / 2;
+	pll_in_khz = (unsigned int)(clk_get_rate(dsi->pllref_clk) / 1000);
+
+	/* find frequency mapping */
+	for (i = 0; i < ARRAY_SIZE(dppa_map); i++) {
+		if (dsi->lane_mbps < dppa_map[i].data_rate) {
+			i--;
+			break;
+		}
+	}
+
+	/* TODO check odf value */
+	switch (dppa_map[i].odf) {
+	case(3):
+		odf = 8;
+		break;
+	case(2):
+		odf = 4;
+		break;
+	case(1):
+		odf = 2;
+		break;
+	default:
+		odf = 1;
+		break;
+	}
+
+	dsi_phy_141_pll_get_params(dsi, pll_in_khz, pll_out_khz, &idf, &ndiv, &odf);
+
+	ccf = ((pll_in_khz / 1000 - 17)) * 4;
+	hsfreq = dppa_map[i].hs_freq;
+
+	vco = dppa_map[i].vco;
+	bias = 0x10;
+	int1 = 0x00;
+	gmp = 0x01;
+	prop = dppa_map[i].prop;
+
+	/* set DLD, HSFR & CCF */
+	val = (hsfreq << 8) | ccf;
+	dsi_write(dsi, DSI_WPCR1, val);
+
+	val = ((ndiv - 2) << 4) | (idf - 1);
+	dsi_write(dsi, DSI_WRPCR0, val);
+
+	val = ((odf - 1) << 28) | (vco << 24) | (bias << 16) | (int1 << 8) | (gmp << 6) | prop;
+	dsi_write(dsi, DSI_WRPCR1, val);
+
+	dsi_write(dsi, DSI_PCTLR, PCTLR_CKEN);
+
+	dsi_update_bits(dsi, DSI_WRPCR2, WRPCR2_SEL, 0x01);
+
+	dsi_set(dsi, DSI_WRPCR2, WRPCR2_UPD);
+	mdelay(1);
+
+	dsi_clear(dsi, DSI_WRPCR2, WRPCR2_UPD);
+	mdelay(1);
+
+	dsi_set(dsi, DSI_PCTLR, PCTLR_PWEN | PCTLR_DEN);
+
+	ret = readl_poll_timeout(dsi->base + DSI_PSR, val, val & PSR_PSSC,
+				 SLEEP_US, TIMEOUT_US);
+	if (ret)
+		DRM_ERROR("!TIMEOUT! waiting PLL, let's continue\n");
+
+	DRM_DEBUG_DRIVER("IDF %d ODF %d NDIV %d\n", idf, odf, ndiv);
+	DRM_DEBUG_DRIVER("VCO %d BIAS %d INT %d GMP %d PROP %d\n", vco, bias, int1, gmp, prop);
+
+	dsi_set(dsi, DSI_WRPCR2, WRPCR2_PLLEN);
+
+	return 0;
+}
+
+static int
+dw_mipi_dsi_phy_141_get_lane_mbps(void *priv_data,
+				  const struct drm_display_mode *mode,
+				  unsigned long mode_flags, u32 lanes,
+				  u32 format, unsigned int *lane_mbps)
+{
+	struct dw_mipi_dsi_stm *dsi = priv_data;
+	unsigned int pll_out_khz, pll_in_khz;
+	u32 ndiv, odf, idf;
+	int bpp, i;
+
+	/* Compute requested pll out */
+	dsi->format = format;
+	bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);
+	pll_out_khz = mode->clock * bpp / (lanes * 2);
+
+	/* Add 20% to pll out to be higher than pixel bw (burst mode only) */
+	if (mode_flags & MIPI_DSI_MODE_VIDEO_BURST)
+		pll_out_khz = (pll_out_khz * 12) / 10;
+
+	if (pll_out_khz > dsi->lane_max_kbps) {
+		pll_out_khz = dsi->lane_max_kbps;
+		DRM_WARN("Warning max phy mbps is used\n");
+	}
+	if (pll_out_khz < dsi->lane_min_kbps) {
+		pll_out_khz = dsi->lane_min_kbps;
+		DRM_WARN("Warning min phy mbps is used\n");
+	}
+
+	pll_in_khz = (unsigned int)(clk_get_rate(dsi->pllref_clk) / 1000);
+
+	/* find frequency mapping */
+	for (i = 0; i < ARRAY_SIZE(dppa_map); i++) {
+		if (dsi->lane_mbps < dppa_map[i].data_rate) {
+			i--;
+			break;
+		}
+	}
+
+	/* TODO check odf value */
+	switch (dppa_map[i].odf) {
+	case(3):
+		odf = 8;
+		break;
+	case(2):
+		odf = 4;
+		break;
+	case(1):
+		odf = 2;
+		break;
+	default:
+		odf = 1;
+		break;
+	}
+
+	dsi_phy_141_pll_get_params(dsi, pll_in_khz, pll_out_khz, &idf, &ndiv, &odf);
+
+	/* Get the adjusted lane data rate value, lane data rate = 2 * pll output */
+	*lane_mbps = 2 * dsi_pll_get_clkout_khz(pll_in_khz, idf, ndiv, odf) / 1000;
+	dsi->lane_mbps = *lane_mbps;
+
+	DRM_DEBUG_DRIVER("lane_mbps %d\n", *lane_mbps);
+
+	return 0;
+}
+
 static int dw_mipi_dsi_phy_init(void *priv_data)
 {
 	struct dw_mipi_dsi_stm *dsi = priv_data;
@@ -247,14 +582,6 @@ dw_mipi_dsi_get_lane_mbps(void *priv_data, const struct drm_display_mode *mode,
 	int ret, bpp;
 	u32 val;
 
-	/* Update lane capabilities according to hw version */
-	dsi->lane_min_kbps = LANE_MIN_KBPS;
-	dsi->lane_max_kbps = LANE_MAX_KBPS;
-	if (dsi->hw_version == HWVER_131) {
-		dsi->lane_min_kbps *= 2;
-		dsi->lane_max_kbps *= 2;
-	}
-
 	pll_in_khz = (unsigned int)(clk_get_rate(dsi->pllref_clk) / 1000);
 
 	/* Compute requested pll out */
@@ -330,6 +657,208 @@ dw_mipi_dsi_phy_get_timing(void *priv_data, unsigned int lane_mbps,
 	return 0;
 }
 
+struct hstt {
+	unsigned int maxfreq;
+	struct dw_mipi_dsi_dphy_timing timing;
+};
+
+#define HSTT(_maxfreq, _c_lp2hs, _c_hs2lp, _d_lp2hs, _d_hs2lp)	\
+{					\
+	.maxfreq = _maxfreq,		\
+	.timing = {			\
+		.clk_lp2hs = _c_lp2hs,	\
+		.clk_hs2lp = _c_hs2lp,	\
+		.data_lp2hs = _d_lp2hs,	\
+		.data_hs2lp = _d_hs2lp,	\
+	}				\
+}
+
+/* Table High-Speed Transition Times */
+struct hstt hstt_phy_141_table[] = {
+	HSTT(80, 21, 17, 15, 10),
+	HSTT(90, 23, 17, 16, 10),
+	HSTT(100, 22, 17, 16, 10),
+	HSTT(110, 25, 18, 17, 11),
+	HSTT(120, 26, 20, 18, 11),
+	HSTT(130, 27, 19, 19, 11),
+	HSTT(140, 27, 19, 19, 11),
+	HSTT(150, 28, 20, 20, 12),
+	HSTT(160, 30, 21, 22, 13),
+	HSTT(170, 30, 21, 23, 13),
+	HSTT(180, 31, 21, 23, 13),
+	HSTT(190, 32, 22, 24, 13),
+	HSTT(205, 35, 22, 25, 13),
+	HSTT(220, 37, 26, 27, 15),
+	HSTT(235, 38, 28, 27, 16),
+	HSTT(250, 41, 29, 30, 17),
+	HSTT(275, 43, 29, 32, 18),
+	HSTT(300, 45, 32, 35, 19),
+	HSTT(325, 48, 33, 36, 18),
+	HSTT(350, 51, 35, 40, 20),
+	HSTT(400, 59, 37, 44, 21),
+	HSTT(450, 65, 40, 49, 23),
+	HSTT(500, 71, 41, 54, 24),
+	HSTT(550, 77, 44, 57, 26),
+	HSTT(600, 82, 46, 64, 27),
+	HSTT(650, 87, 48, 67, 28),
+	HSTT(700, 94, 52, 71, 29),
+	HSTT(750, 99, 52, 75, 31),
+	HSTT(800, 105, 55, 82, 32),
+	HSTT(850, 110, 58, 85, 32),
+	HSTT(900, 115, 58, 88, 35),
+	HSTT(950, 120, 62, 93, 36),
+	HSTT(1000, 128, 63, 99, 38),
+	HSTT(1050, 132, 65, 102, 38),
+	HSTT(1100, 138, 67, 106, 39),
+	HSTT(1150, 146, 69, 112, 42),
+	HSTT(1200, 151, 71, 117, 43),
+	HSTT(1250, 153, 74, 120, 45),
+	HSTT(1300, 160, 73, 124, 46),
+	HSTT(1350, 165, 76, 130, 47),
+	HSTT(1400, 172, 78, 134, 49),
+	HSTT(1450, 177, 80, 138, 49),
+	HSTT(1500, 183, 81, 143, 52),
+	HSTT(1550, 191, 84, 147, 52),
+	HSTT(1600, 194, 85, 152, 52),
+	HSTT(1650, 201, 86, 155, 53),
+	HSTT(1700, 208, 88, 161, 53),
+	HSTT(1750, 212, 89, 165, 53),
+	HSTT(1800, 220, 90, 171, 54),
+	HSTT(1850, 223, 92, 175, 55),
+	HSTT(1900, 231, 91, 180, 56),
+	HSTT(1950, 236, 95, 185, 56),
+	HSTT(2000, 243, 97, 190, 58),
+	HSTT(2050, 248, 99, 194, 59),
+	HSTT(2100, 252, 100, 199, 61),
+	HSTT(2150, 259, 102, 204, 62),
+	HSTT(2200, 266, 105, 210, 63),
+	HSTT(2250, 269, 109, 213, 65),
+	HSTT(2300, 272, 109, 217, 66),
+	HSTT(2350, 281, 112, 225, 66),
+	HSTT(2400, 283, 115, 226, 67),
+	HSTT(2450, 282, 115, 226, 67),
+	HSTT(2500, 281, 118, 227, 68)
+};
+
+static int
+dw_mipi_dsi_phy_141_get_timing(void *priv_data, unsigned int lane_mbps,
+			       struct dw_mipi_dsi_dphy_timing *timing)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(hstt_phy_141_table); i++)
+		if (lane_mbps < hstt_phy_141_table[i].maxfreq)
+			break;
+
+	if (i == ARRAY_SIZE(hstt_phy_141_table))
+		i--;
+
+	*timing = hstt_phy_141_table[i].timing;
+
+	return 0;
+}
+
+#define CLK_TOLERANCE_HZ 50
+
+static enum drm_mode_status
+dw_mipi_dsi_stm_mode_valid(void *priv_data,
+			   const struct drm_display_mode *mode,
+			   unsigned long mode_flags, u32 lanes, u32 format)
+{
+	struct dw_mipi_dsi_stm *dsi = priv_data;
+	unsigned int idf, ndiv, odf, pll_in_khz, pll_out_khz;
+	int ret, bpp;
+
+	bpp = mipi_dsi_pixel_format_to_bpp(format);
+	if (bpp < 0)
+		return MODE_BAD;
+
+	/* Compute requested pll out */
+	pll_out_khz = mode->clock * bpp / lanes;
+
+	if (pll_out_khz > dsi->lane_max_kbps)
+		return MODE_CLOCK_HIGH;
+
+	if (mode_flags & MIPI_DSI_MODE_VIDEO_BURST) {
+		/* Add 20% to pll out to be higher than pixel bw */
+		pll_out_khz = (pll_out_khz * 12) / 10;
+	} else {
+		if (pll_out_khz < dsi->lane_min_kbps)
+			return MODE_CLOCK_LOW;
+	}
+
+	/* Compute best pll parameters */
+	idf = 0;
+	ndiv = 0;
+	odf = 0;
+	pll_in_khz = clk_get_rate(dsi->pllref_clk) / 1000;
+	ret = dsi_pll_get_params(dsi, pll_in_khz, pll_out_khz, &idf, &ndiv, &odf);
+	if (ret) {
+		DRM_WARN("Warning dsi_pll_get_params(): bad params\n");
+		return MODE_ERROR;
+	}
+
+	if (!(mode_flags & MIPI_DSI_MODE_VIDEO_BURST)) {
+		unsigned int px_clock_hz, target_px_clock_hz, lane_mbps;
+		int dsi_short_packet_size_px, hfp, hsync, hbp, delay_to_lp;
+		struct dw_mipi_dsi_dphy_timing dphy_timing;
+
+		/* Get the adjusted pll out value */
+		pll_out_khz = dsi_pll_get_clkout_khz(pll_in_khz, idf, ndiv, odf);
+
+		px_clock_hz = DIV_ROUND_CLOSEST_ULL(1000ULL * pll_out_khz * lanes, bpp);
+		target_px_clock_hz = mode->clock * 1000;
+		/*
+		 * Filter modes according to the clock value, particularly useful for
+		 * hdmi modes that require precise pixel clocks.
+		 */
+		if (px_clock_hz < target_px_clock_hz - CLK_TOLERANCE_HZ ||
+		    px_clock_hz > target_px_clock_hz + CLK_TOLERANCE_HZ)
+			return MODE_CLOCK_RANGE;
+
+		/* sync packets are codes as DSI short packets (4 bytes) */
+		dsi_short_packet_size_px = DIV_ROUND_UP(4 * BITS_PER_BYTE, bpp);
+
+		hfp = mode->hsync_start - mode->hdisplay;
+		hsync = mode->hsync_end - mode->hsync_start;
+		hbp = mode->htotal - mode->hsync_end;
+
+		/* hsync must be longer than 4 bytes HSS packets */
+		if (hsync < dsi_short_packet_size_px)
+			return MODE_HSYNC_NARROW;
+
+		if (mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE) {
+			/* HBP must be longer than 4 bytes HSE packets */
+			if (hbp < dsi_short_packet_size_px)
+				return MODE_HSYNC_NARROW;
+			hbp -= dsi_short_packet_size_px;
+		} else {
+			/* With sync events HBP extends in the hsync */
+			hbp += hsync - dsi_short_packet_size_px;
+		}
+
+		lane_mbps = pll_out_khz / 1000;
+
+		if (dsi->hw_version == HWVER_141)
+			ret = dw_mipi_dsi_phy_141_get_timing(priv_data, lane_mbps, &dphy_timing);
+		else
+			ret = dw_mipi_dsi_phy_get_timing(priv_data, lane_mbps, &dphy_timing);
+		if (ret)
+			return MODE_ERROR;
+		/*
+		 * In non-burst mode DSI has to enter in LP during HFP
+		 * (horizontal front porch) or HBP (horizontal back porch) to
+		 * resync with LTDC pixel clock.
+		 */
+		delay_to_lp = DIV_ROUND_UP((dphy_timing.data_hs2lp + dphy_timing.data_lp2hs) *
+					   lanes * BITS_PER_BYTE, bpp);
+		if (hfp < delay_to_lp && hbp < delay_to_lp)
+			return MODE_HSYNC;
+	}
+
+	return MODE_OK;
+}
+
 static const struct dw_mipi_dsi_phy_ops dw_mipi_dsi_stm_phy_ops = {
 	.init = dw_mipi_dsi_phy_init,
 	.power_on = dw_mipi_dsi_phy_power_on,
@@ -338,8 +867,17 @@ static const struct dw_mipi_dsi_phy_ops dw_mipi_dsi_stm_phy_ops = {
 	.get_timing = dw_mipi_dsi_phy_get_timing,
 };
 
+static const struct dw_mipi_dsi_phy_ops dw_mipi_dsi_stm_phy_141_ops = {
+	.init = dw_mipi_dsi_phy_141_init,
+	.power_on = dw_mipi_dsi_phy_power_on,
+	.power_off = dw_mipi_dsi_phy_power_off,
+	.get_lane_mbps = dw_mipi_dsi_phy_141_get_lane_mbps,
+	.get_timing = dw_mipi_dsi_phy_141_get_timing,
+};
+
 static struct dw_mipi_dsi_plat_data dw_mipi_dsi_stm_plat_data = {
 	.max_data_lanes = 2,
+	.mode_valid = dw_mipi_dsi_stm_mode_valid,
 	.phy_ops = &dw_mipi_dsi_stm_phy_ops,
 };
 
@@ -354,15 +892,14 @@ static int dw_mipi_dsi_stm_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct dw_mipi_dsi_stm *dsi;
 	struct clk *pclk;
-	struct resource *res;
+	const struct dw_mipi_dsi_plat_data *pdata = of_device_get_match_data(dev);
 	int ret;
 
 	dsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);
 	if (!dsi)
 		return -ENOMEM;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	dsi->base = devm_ioremap_resource(dev, res);
+	dsi->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(dsi->base)) {
 		ret = PTR_ERR(dsi->base);
 		DRM_ERROR("Unable to get dsi registers %d\n", ret);
@@ -411,18 +948,42 @@ static int dw_mipi_dsi_stm_probe(struct platform_device *pdev)
 	dsi->hw_version = dsi_read(dsi, DSI_VERSION) & VERSION;
 	clk_disable_unprepare(pclk);
 
-	if (dsi->hw_version != HWVER_130 && dsi->hw_version != HWVER_131) {
+	if (dsi->hw_version != HWVER_130 &&
+	    dsi->hw_version != HWVER_131 &&
+	    dsi->hw_version != HWVER_141) {
 		ret = -ENODEV;
 		DRM_ERROR("bad dsi hardware version\n");
 		goto err_dsi_probe;
 	}
 
-	dw_mipi_dsi_stm_plat_data.base = dsi->base;
-	dw_mipi_dsi_stm_plat_data.priv_data = dsi;
+	/* Update lane capabilities according to hw version */
+	switch (dsi->hw_version) {
+	case HWVER_141:
+		dsi->lane_min_kbps = LANE_MIN_PHY_141_KBPS;
+		dsi->lane_max_kbps = LANE_MAX_PHY_141_KBPS;
+	break;
+	case HWVER_131:
+		dsi->lane_min_kbps = 2 * LANE_MIN_KBPS;
+		dsi->lane_max_kbps = 2 * LANE_MAX_KBPS;
+	break;
+	default:
+		dsi->lane_min_kbps = LANE_MIN_KBPS;
+		dsi->lane_max_kbps = LANE_MAX_KBPS;
+	break;
+	}
+
+	dsi->pdata = *pdata;
+	dsi->pdata.base = dsi->base;
+	dsi->pdata.priv_data = dsi;
+
+	if (dsi->hw_version == HWVER_141) {
+		dsi->pdata.max_data_lanes = 4;
+		dsi->pdata.phy_ops = &dw_mipi_dsi_stm_phy_141_ops;
+	}
 
 	platform_set_drvdata(pdev, dsi);
 
-	dsi->dsi = dw_mipi_dsi_probe(pdev, &dw_mipi_dsi_stm_plat_data);
+	dsi->dsi = dw_mipi_dsi_probe(pdev, &dsi->pdata);
 	if (IS_ERR(dsi->dsi)) {
 		ret = PTR_ERR(dsi->dsi);
 		dev_err_probe(dev, ret, "Failed to initialize mipi dsi host\n");
@@ -452,7 +1013,7 @@ static int dw_mipi_dsi_stm_remove(struct platform_device *pdev)
 
 static int __maybe_unused dw_mipi_dsi_stm_suspend(struct device *dev)
 {
-	struct dw_mipi_dsi_stm *dsi = dw_mipi_dsi_stm_plat_data.priv_data;
+	struct dw_mipi_dsi_stm *dsi = dev_get_drvdata(dev);
 
 	DRM_DEBUG_DRIVER("\n");
 
@@ -464,7 +1025,7 @@ static int __maybe_unused dw_mipi_dsi_stm_suspend(struct device *dev)
 
 static int __maybe_unused dw_mipi_dsi_stm_resume(struct device *dev)
 {
-	struct dw_mipi_dsi_stm *dsi = dw_mipi_dsi_stm_plat_data.priv_data;
+	struct dw_mipi_dsi_stm *dsi = dev_get_drvdata(dev);
 	int ret;
 
 	DRM_DEBUG_DRIVER("\n");
@@ -502,7 +1063,8 @@ static struct platform_driver dw_mipi_dsi_stm_driver = {
 
 module_platform_driver(dw_mipi_dsi_stm_driver);
 
-MODULE_AUTHOR("Philippe Cornu <philippe.cornu@st.com>");
-MODULE_AUTHOR("Yannick Fertre <yannick.fertre@st.com>");
+MODULE_AUTHOR("Philippe Cornu <philippe.cornu@foss.st.com>");
+MODULE_AUTHOR("Yannick Fertre <yannick.fertre@foss.st.com>");
+MODULE_AUTHOR("Raphaël Gallais-Pou <raphael.gallais-pou@foss.st.com>");
 MODULE_DESCRIPTION("STMicroelectronics DW MIPI DSI host controller driver");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/stm/ltdc.c b/drivers/gpu/drm/stm/ltdc.c
index 9d235b60b..43a07f02c 100644
--- a/drivers/gpu/drm/stm/ltdc.c
+++ b/drivers/gpu/drm/stm/ltdc.c
@@ -12,12 +12,14 @@
 #include <linux/component.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
+#include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/of_address.h>
 #include <linux/of_graph.h>
 #include <linux/pinctrl/consumer.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
+#include <linux/regmap.h>
 #include <linux/reset.h>
 
 #include <drm/drm_atomic.h>
@@ -46,15 +48,15 @@
 #define HWVER_10200 0x010200
 #define HWVER_10300 0x010300
 #define HWVER_20101 0x020101
+#define HWVER_40100 0x040100
 
 /*
  * The address of some registers depends on the HW version: such registers have
- * an extra offset specified with reg_ofs.
+ * an extra offset specified with layer_ofs.
  */
-#define REG_OFS_NONE	0
-#define REG_OFS_4	4		/* Insertion of "Layer Conf. 2" reg */
-#define REG_OFS		(ldev->caps.reg_ofs)
-#define LAY_OFS		0x80		/* Register Offset between 2 layers */
+#define LAY_OFS_0	0x80
+#define LAY_OFS_1	0x100
+#define LAY_OFS	(ldev->caps.layer_ofs)
 
 /* Global register offsets */
 #define LTDC_IDR	0x0000		/* IDentification */
@@ -75,29 +77,36 @@
 #define LTDC_LIPCR	0x0040		/* Line Interrupt Position Conf. */
 #define LTDC_CPSR	0x0044		/* Current Position Status */
 #define LTDC_CDSR	0x0048		/* Current Display Status */
+#define LTDC_EDCR	0x0060		/* External Display Control */
+#define LTDC_CCRCR	0x007C		/* Computed CRC value */
+#define LTDC_FUT	0x0090		/* Fifo underrun Threshold */
 
 /* Layer register offsets */
-#define LTDC_L1LC1R	(0x80)		/* L1 Layer Configuration 1 */
-#define LTDC_L1LC2R	(0x84)		/* L1 Layer Configuration 2 */
-#define LTDC_L1CR	(0x84 + REG_OFS)/* L1 Control */
-#define LTDC_L1WHPCR	(0x88 + REG_OFS)/* L1 Window Hor Position Config */
-#define LTDC_L1WVPCR	(0x8C + REG_OFS)/* L1 Window Vert Position Config */
-#define LTDC_L1CKCR	(0x90 + REG_OFS)/* L1 Color Keying Configuration */
-#define LTDC_L1PFCR	(0x94 + REG_OFS)/* L1 Pixel Format Configuration */
-#define LTDC_L1CACR	(0x98 + REG_OFS)/* L1 Constant Alpha Config */
-#define LTDC_L1DCCR	(0x9C + REG_OFS)/* L1 Default Color Configuration */
-#define LTDC_L1BFCR	(0xA0 + REG_OFS)/* L1 Blend Factors Configuration */
-#define LTDC_L1FBBCR	(0xA4 + REG_OFS)/* L1 FrameBuffer Bus Control */
-#define LTDC_L1AFBCR	(0xA8 + REG_OFS)/* L1 AuxFB Control */
-#define LTDC_L1CFBAR	(0xAC + REG_OFS)/* L1 Color FrameBuffer Address */
-#define LTDC_L1CFBLR	(0xB0 + REG_OFS)/* L1 Color FrameBuffer Length */
-#define LTDC_L1CFBLNR	(0xB4 + REG_OFS)/* L1 Color FrameBuffer Line Nb */
-#define LTDC_L1AFBAR	(0xB8 + REG_OFS)/* L1 AuxFB Address */
-#define LTDC_L1AFBLR	(0xBC + REG_OFS)/* L1 AuxFB Length */
-#define LTDC_L1AFBLNR	(0xC0 + REG_OFS)/* L1 AuxFB Line Number */
-#define LTDC_L1CLUTWR	(0xC4 + REG_OFS)/* L1 CLUT Write */
-#define LTDC_L1YS1R	(0xE0 + REG_OFS)/* L1 YCbCr Scale 1 */
-#define LTDC_L1YS2R	(0xE4 + REG_OFS)/* L1 YCbCr Scale 2 */
+#define LTDC_L1C0R	(ldev->caps.layer_regs[0])	/* L1 configuration 0 */
+#define LTDC_L1C1R	(ldev->caps.layer_regs[1])	/* L1 configuration 1 */
+#define LTDC_L1RCR	(ldev->caps.layer_regs[2])	/* L1 reload control */
+#define LTDC_L1CR	(ldev->caps.layer_regs[3])	/* L1 control register */
+#define LTDC_L1WHPCR	(ldev->caps.layer_regs[4])	/* L1 window horizontal position configuration */
+#define LTDC_L1WVPCR	(ldev->caps.layer_regs[5])	/* L1 window vertical position configuration */
+#define LTDC_L1CKCR	(ldev->caps.layer_regs[6])	/* L1 color keying configuration */
+#define LTDC_L1PFCR	(ldev->caps.layer_regs[7])	/* L1 pixel format configuration */
+#define LTDC_L1CACR	(ldev->caps.layer_regs[8])	/* L1 constant alpha configuration */
+#define LTDC_L1DCCR	(ldev->caps.layer_regs[9])	/* L1 default color configuration */
+#define LTDC_L1BFCR	(ldev->caps.layer_regs[10])	/* L1 blending factors configuration */
+#define LTDC_L1BLCR	(ldev->caps.layer_regs[11])	/* L1 burst length configuration */
+#define LTDC_L1PCR	(ldev->caps.layer_regs[12])	/* L1 planar configuration */
+#define LTDC_L1CFBAR	(ldev->caps.layer_regs[13])	/* L1 color frame buffer address */
+#define LTDC_L1CFBLR	(ldev->caps.layer_regs[14])	/* L1 color frame buffer length */
+#define LTDC_L1CFBLNR	(ldev->caps.layer_regs[15])	/* L1 color frame buffer line number */
+#define LTDC_L1AFBA0R	(ldev->caps.layer_regs[16])	/* L1 auxiliary frame buffer address 0 */
+#define LTDC_L1AFBA1R	(ldev->caps.layer_regs[17])	/* L1 auxiliary frame buffer address 1 */
+#define LTDC_L1AFBLR	(ldev->caps.layer_regs[18])	/* L1 auxiliary frame buffer length */
+#define LTDC_L1AFBLNR	(ldev->caps.layer_regs[19])	/* L1 auxiliary frame buffer line number */
+#define LTDC_L1CLUTWR	(ldev->caps.layer_regs[20])	/* L1 CLUT write */
+#define LTDC_L1CYR0R	(ldev->caps.layer_regs[21])	/* L1 Conversion YCbCr RGB 0 */
+#define LTDC_L1CYR1R	(ldev->caps.layer_regs[22])	/* L1 Conversion YCbCr RGB 1 */
+#define LTDC_L1FPF0R	(ldev->caps.layer_regs[23])	/* L1 Flexible Pixel Format 0 */
+#define LTDC_L1FPF1R	(ldev->caps.layer_regs[24])	/* L1 Flexible Pixel Format 1 */
 
 /* Bit definitions */
 #define SSCR_VSH	GENMASK(10, 0)	/* Vertical Synchronization Height */
@@ -114,6 +123,7 @@
 
 #define GCR_LTDCEN	BIT(0)		/* LTDC ENable */
 #define GCR_DEN		BIT(16)		/* Dither ENable */
+#define GCR_CRCEN	BIT(19)		/* CRC ENable */
 #define GCR_PCPOL	BIT(28)		/* Pixel Clock POLarity-Inverted */
 #define GCR_DEPOL	BIT(29)		/* Data Enable POLarity-High */
 #define GCR_VSPOL	BIT(30)		/* Vertical Synchro POLarity-High */
@@ -153,20 +163,29 @@
 #define BCCR_BCWHITE	GENMASK(23, 0)	/* Background Color WHITE */
 
 #define IER_LIE		BIT(0)		/* Line Interrupt Enable */
-#define IER_FUIE	BIT(1)		/* Fifo Underrun Interrupt Enable */
+#define IER_FUWIE	BIT(1)		/* Fifo Underrun Warning Interrupt Enable */
 #define IER_TERRIE	BIT(2)		/* Transfer ERRor Interrupt Enable */
-#define IER_RRIE	BIT(3)		/* Register Reload Interrupt enable */
+#define IER_RRIE	BIT(3)		/* Register Reload Interrupt Enable */
+#define IER_FUEIE	BIT(6)		/* Fifo Underrun Error Interrupt Enable */
+#define IER_CRCIE	BIT(7)		/* CRC Error Interrupt Enable */
 
 #define CPSR_CYPOS	GENMASK(15, 0)	/* Current Y position */
 
 #define ISR_LIF		BIT(0)		/* Line Interrupt Flag */
-#define ISR_FUIF	BIT(1)		/* Fifo Underrun Interrupt Flag */
+#define ISR_FUWIF	BIT(1)		/* Fifo Underrun Warning Interrupt Flag */
 #define ISR_TERRIF	BIT(2)		/* Transfer ERRor Interrupt Flag */
 #define ISR_RRIF	BIT(3)		/* Register Reload Interrupt Flag */
+#define ISR_FUEIF	BIT(6)		/* Fifo Underrun Error Interrupt Flag */
+#define ISR_CRCIF	BIT(7)		/* CRC Error Interrupt Flag */
+
+#define EDCR_OCYEN	BIT(25)		/* Output Conversion to YCbCr 422: ENable */
+#define EDCR_OCYSEL	BIT(26)		/* Output Conversion to YCbCr 422: SELection of the CCIR */
+#define EDCR_OCYCO	BIT(27)		/* Output Conversion to YCbCr 422: Chrominance Order */
 
 #define LXCR_LEN	BIT(0)		/* Layer ENable */
 #define LXCR_COLKEN	BIT(1)		/* Color Keying Enable */
 #define LXCR_CLUTEN	BIT(4)		/* Color Look-Up Table ENable */
+#define LXCR_HMEN	BIT(8)		/* Horizontal Mirroring ENable */
 
 #define LXWHPCR_WHSTPOS	GENMASK(11, 0)	/* Window Horizontal StarT POSition */
 #define LXWHPCR_WHSPPOS	GENMASK(27, 16)	/* Window Horizontal StoP POSition */
@@ -175,17 +194,38 @@
 #define LXWVPCR_WVSPPOS	GENMASK(26, 16)	/* Window Vertical StoP POSition */
 
 #define LXPFCR_PF	GENMASK(2, 0)	/* Pixel Format */
+#define PF_FLEXIBLE	0x7		/* Flexible Pixel Format selected */
 
 #define LXCACR_CONSTA	GENMASK(7, 0)	/* CONSTant Alpha */
 
 #define LXBFCR_BF2	GENMASK(2, 0)	/* Blending Factor 2 */
 #define LXBFCR_BF1	GENMASK(10, 8)	/* Blending Factor 1 */
+#define LXBFCR_BOR	GENMASK(18, 16) /* Blending ORder */
 
 #define LXCFBLR_CFBLL	GENMASK(12, 0)	/* Color Frame Buffer Line Length */
-#define LXCFBLR_CFBP	GENMASK(28, 16)	/* Color Frame Buffer Pitch in bytes */
+#define LXCFBLR_CFBP	GENMASK(31, 16) /* Color Frame Buffer Pitch in bytes */
 
 #define LXCFBLNR_CFBLN	GENMASK(10, 0)	/* Color Frame Buffer Line Number */
 
+#define LXCR_C1R_YIA	BIT(0)		/* Ycbcr 422 Interleaved Ability */
+#define LXCR_C1R_YSPA	BIT(1)		/* Ycbcr 420 Semi-Planar Ability */
+#define LXCR_C1R_YFPA	BIT(2)		/* Ycbcr 420 Full-Planar Ability */
+#define LXCR_C1R_SCA	BIT(31)		/* SCaling Ability*/
+
+#define LxPCR_YREN	BIT(9)		/* Y Rescale Enable for the color dynamic range */
+#define LxPCR_OF	BIT(8)		/* Odd pixel First */
+#define LxPCR_CBF	BIT(7)		/* CB component First */
+#define LxPCR_YF	BIT(6)		/* Y component First */
+#define LxPCR_YCM	GENMASK(5, 4)	/* Ycbcr Conversion Mode */
+#define YCM_I		0x0		/* Interleaved 422 */
+#define YCM_SP		0x1		/* Semi-Planar 420 */
+#define YCM_FP		0x2		/* Full-Planar 420 */
+#define LxPCR_YCEN	BIT(3)		/* YCbCr-to-RGB Conversion Enable */
+
+#define LXRCR_IMR	BIT(0)		/* IMmediate Reload */
+#define LXRCR_VBR	BIT(1)		/* Vertical Blanking Reload */
+#define LXRCR_GRMSK	BIT(2)		/* Global (centralized) Reload MaSKed */
+
 #define CLUT_SIZE	256
 
 #define CONSTA_MAX	0xFF		/* CONSTant Alpha MAX= 1.0 */
@@ -196,13 +236,31 @@
 
 #define NB_PF		8		/* Max nb of HW pixel format */
 
+#define FUT_DFT		128		/* Default value of fifo underrun threshold */
+
+#define SYSCFG_DISPLAYCLKCR 0x5000
+#define DISPLAYCLKCR_DSI	0x00
+#define DISPLAYCLKCR_LVDS	0x01
+#define DISPLAYCLKCR_DPI	0x02
+
+/*
+ * Skip the first value and the second in case CRC was enabled during
+ * the thread irq. This is to be sure CRC value is relevant for the
+ * frame.
+ */
+#define CRC_SKIP_FRAMES 2
+
 enum ltdc_pix_fmt {
 	PF_NONE,
 	/* RGB formats */
 	PF_ARGB8888,		/* ARGB [32 bits] */
 	PF_RGBA8888,		/* RGBA [32 bits] */
+	PF_ABGR8888,		/* ABGR [32 bits] */
+	PF_BGRA8888,		/* BGRA [32 bits] */
 	PF_RGB888,		/* RGB [24 bits] */
+	PF_BGR888,		/* BGR [24 bits] */
 	PF_RGB565,		/* RGB [16 bits] */
+	PF_BGR565,		/* BGR [16 bits] */
 	PF_ARGB1555,		/* ARGB A:1 bit RGB:15 bits [16 bits] */
 	PF_ARGB4444,		/* ARGB A:4 bits R/G/B: 4 bits each [16 bits] */
 	/* Indexed formats */
@@ -234,36 +292,198 @@ static const enum ltdc_pix_fmt ltdc_pix_fmt_a1[NB_PF] = {
 	PF_ARGB4444		/* 0x07 */
 };
 
-static const u64 ltdc_format_modifiers[] = {
-	DRM_FORMAT_MOD_LINEAR,
-	DRM_FORMAT_MOD_INVALID
+static const enum ltdc_pix_fmt ltdc_pix_fmt_a2[NB_PF] = {
+	PF_ARGB8888,		/* 0x00 */
+	PF_ABGR8888,		/* 0x01 */
+	PF_RGBA8888,		/* 0x02 */
+	PF_BGRA8888,		/* 0x03 */
+	PF_RGB565,		/* 0x04 */
+	PF_BGR565,		/* 0x05 */
+	PF_RGB888,		/* 0x06 */
+	PF_NONE			/* 0x07 */
 };
 
-static inline u32 reg_read(void __iomem *base, u32 reg)
-{
-	return readl_relaxed(base + reg);
-}
+static const u32 ltdc_drm_fmt_a0[] = {
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_RGB888,
+	DRM_FORMAT_RGB565,
+	DRM_FORMAT_ARGB1555,
+	DRM_FORMAT_XRGB1555,
+	DRM_FORMAT_ARGB4444,
+	DRM_FORMAT_XRGB4444,
+	DRM_FORMAT_C8
+};
 
-static inline void reg_write(void __iomem *base, u32 reg, u32 val)
-{
-	writel_relaxed(val, base + reg);
-}
+static const u32 ltdc_drm_fmt_a1[] = {
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_RGB888,
+	DRM_FORMAT_RGB565,
+	DRM_FORMAT_RGBA8888,
+	DRM_FORMAT_RGBX8888,
+	DRM_FORMAT_ARGB1555,
+	DRM_FORMAT_XRGB1555,
+	DRM_FORMAT_ARGB4444,
+	DRM_FORMAT_XRGB4444,
+	DRM_FORMAT_C8
+};
 
-static inline void reg_set(void __iomem *base, u32 reg, u32 mask)
-{
-	reg_write(base, reg, reg_read(base, reg) | mask);
-}
+static const u32 ltdc_drm_fmt_a2[] = {
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_ABGR8888,
+	DRM_FORMAT_XBGR8888,
+	DRM_FORMAT_RGBA8888,
+	DRM_FORMAT_RGBX8888,
+	DRM_FORMAT_BGRA8888,
+	DRM_FORMAT_BGRX8888,
+	DRM_FORMAT_RGB565,
+	DRM_FORMAT_BGR565,
+	DRM_FORMAT_RGB888,
+	DRM_FORMAT_BGR888,
+	DRM_FORMAT_ARGB1555,
+	DRM_FORMAT_XRGB1555,
+	DRM_FORMAT_ARGB4444,
+	DRM_FORMAT_XRGB4444,
+	DRM_FORMAT_C8
+};
 
-static inline void reg_clear(void __iomem *base, u32 reg, u32 mask)
-{
-	reg_write(base, reg, reg_read(base, reg) & ~mask);
-}
+static const u32 ltdc_drm_fmt_ycbcr_cp[] = {
+	DRM_FORMAT_YUYV,
+	DRM_FORMAT_YVYU,
+	DRM_FORMAT_UYVY,
+	DRM_FORMAT_VYUY
+};
 
-static inline void reg_update_bits(void __iomem *base, u32 reg, u32 mask,
-				   u32 val)
-{
-	reg_write(base, reg, (reg_read(base, reg) & ~mask) | val);
-}
+static const u32 ltdc_drm_fmt_ycbcr_sp[] = {
+	DRM_FORMAT_NV12,
+	DRM_FORMAT_NV21
+};
+
+static const u32 ltdc_drm_fmt_ycbcr_fp[] = {
+	DRM_FORMAT_YUV420,
+	DRM_FORMAT_YVU420
+};
+
+/* Layer register offsets */
+static const u32 ltdc_layer_regs_a0[] = {
+	0x80,	/* L1 configuration 0 */
+	0x00,	/* not available */
+	0x00,	/* not available */
+	0x84,	/* L1 control register */
+	0x88,	/* L1 window horizontal position configuration */
+	0x8c,	/* L1 window vertical position configuration */
+	0x90,	/* L1 color keying configuration */
+	0x94,	/* L1 pixel format configuration */
+	0x98,	/* L1 constant alpha configuration */
+	0x9c,	/* L1 default color configuration */
+	0xa0,	/* L1 blending factors configuration */
+	0x00,	/* not available */
+	0x00,	/* not available */
+	0xac,	/* L1 color frame buffer address */
+	0xb0,	/* L1 color frame buffer length */
+	0xb4,	/* L1 color frame buffer line number */
+	0x00,	/* not available */
+	0x00,	/* not available */
+	0x00,	/* not available */
+	0x00,	/* not available */
+	0xc4,	/* L1 CLUT write */
+	0x00,	/* not available */
+	0x00,	/* not available */
+	0x00,	/* not available */
+	0x00	/* not available */
+};
+
+static const u32 ltdc_layer_regs_a1[] = {
+	0x80,	/* L1 configuration 0 */
+	0x84,	/* L1 configuration 1 */
+	0x00,	/* L1 reload control */
+	0x88,	/* L1 control register */
+	0x8c,	/* L1 window horizontal position configuration */
+	0x90,	/* L1 window vertical position configuration */
+	0x94,	/* L1 color keying configuration */
+	0x98,	/* L1 pixel format configuration */
+	0x9c,	/* L1 constant alpha configuration */
+	0xa0,	/* L1 default color configuration */
+	0xa4,	/* L1 blending factors configuration */
+	0xa8,	/* L1 burst length configuration */
+	0x00,	/* not available */
+	0xac,	/* L1 color frame buffer address */
+	0xb0,	/* L1 color frame buffer length */
+	0xb4,	/* L1 color frame buffer line number */
+	0xb8,	/* L1 auxiliary frame buffer address 0 */
+	0xbc,	/* L1 auxiliary frame buffer address 1 */
+	0xc0,	/* L1 auxiliary frame buffer length */
+	0xc4,	/* L1 auxiliary frame buffer line number */
+	0xc8,	/* L1 CLUT write */
+	0x00,	/* not available */
+	0x00,	/* not available */
+	0x00,	/* not available */
+	0x00	/* not available */
+};
+
+static const u32 ltdc_layer_regs_a2[] = {
+	0x100,	/* L1 configuration 0 */
+	0x104,	/* L1 configuration 1 */
+	0x108,	/* L1 reload control */
+	0x10c,	/* L1 control register */
+	0x110,	/* L1 window horizontal position configuration */
+	0x114,	/* L1 window vertical position configuration */
+	0x118,	/* L1 color keying configuration */
+	0x11c,	/* L1 pixel format configuration */
+	0x120,	/* L1 constant alpha configuration */
+	0x124,	/* L1 default color configuration */
+	0x128,	/* L1 blending factors configuration */
+	0x12c,	/* L1 burst length configuration */
+	0x130,	/* L1 planar configuration */
+	0x134,	/* L1 color frame buffer address */
+	0x138,	/* L1 color frame buffer length */
+	0x13c,	/* L1 color frame buffer line number */
+	0x140,	/* L1 auxiliary frame buffer address 0 */
+	0x144,	/* L1 auxiliary frame buffer address 1 */
+	0x148,	/* L1 auxiliary frame buffer length */
+	0x14c,	/* L1 auxiliary frame buffer line number */
+	0x150,	/* L1 CLUT write */
+	0x16c,	/* L1 Conversion YCbCr RGB 0 */
+	0x170,	/* L1 Conversion YCbCr RGB 1 */
+	0x174,	/* L1 Flexible Pixel Format 0 */
+	0x178	/* L1 Flexible Pixel Format 1 */
+};
+
+static const u64 ltdc_format_modifiers[] = {
+	DRM_FORMAT_MOD_LINEAR,
+	DRM_FORMAT_MOD_INVALID
+};
+
+static const struct regmap_config stm32_ltdc_regmap_cfg = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = sizeof(u32),
+	.max_register = 0x400,
+	.use_relaxed_mmio = true,
+	.cache_type = REGCACHE_NONE,
+};
+
+static const u32 ltdc_ycbcr2rgb_coeffs[DRM_COLOR_ENCODING_MAX][DRM_COLOR_RANGE_MAX][2] = {
+	[DRM_COLOR_YCBCR_BT601][DRM_COLOR_YCBCR_LIMITED_RANGE] = {
+		0x02040199,	/* (b_cb = 516 / r_cr = 409) */
+		0x006400D0	/* (g_cb = 100 / g_cr = 208) */
+	},
+	[DRM_COLOR_YCBCR_BT601][DRM_COLOR_YCBCR_FULL_RANGE] = {
+		0x01C60167,	/* (b_cb = 454 / r_cr = 359) */
+		0x005800B7	/* (g_cb = 88 / g_cr = 183) */
+	},
+	[DRM_COLOR_YCBCR_BT709][DRM_COLOR_YCBCR_LIMITED_RANGE] = {
+		0x021D01CB,	/* (b_cb = 541 / r_cr = 459) */
+		0x00370089	/* (g_cb = 55 / g_cr = 137) */
+	},
+	[DRM_COLOR_YCBCR_BT709][DRM_COLOR_YCBCR_FULL_RANGE] = {
+		0x01DB0193,	/* (b_cb = 475 / r_cr = 403) */
+		0x00300078	/* (g_cb = 48 / g_cr = 120) */
+	}
+	/* BT2020 not supported */
+};
 
 static inline struct ltdc_device *crtc_to_ltdc(struct drm_crtc *crtc)
 {
@@ -289,16 +509,30 @@ static inline enum ltdc_pix_fmt to_ltdc_pixelformat(u32 drm_fmt)
 	case DRM_FORMAT_XRGB8888:
 		pf = PF_ARGB8888;
 		break;
+	case DRM_FORMAT_ABGR8888:
+	case DRM_FORMAT_XBGR8888:
+		pf = PF_ABGR8888;
+		break;
 	case DRM_FORMAT_RGBA8888:
 	case DRM_FORMAT_RGBX8888:
 		pf = PF_RGBA8888;
 		break;
+	case DRM_FORMAT_BGRA8888:
+	case DRM_FORMAT_BGRX8888:
+		pf = PF_BGRA8888;
+		break;
 	case DRM_FORMAT_RGB888:
 		pf = PF_RGB888;
 		break;
+	case DRM_FORMAT_BGR888:
+		pf = PF_BGR888;
+		break;
 	case DRM_FORMAT_RGB565:
 		pf = PF_RGB565;
 		break;
+	case DRM_FORMAT_BGR565:
+		pf = PF_BGR565;
+		break;
 	case DRM_FORMAT_ARGB1555:
 	case DRM_FORMAT_XRGB1555:
 		pf = PF_ARGB1555;
@@ -319,49 +553,159 @@ static inline enum ltdc_pix_fmt to_ltdc_pixelformat(u32 drm_fmt)
 	return pf;
 }
 
-static inline u32 to_drm_pixelformat(enum ltdc_pix_fmt pf)
+static inline u32 ltdc_set_flexible_pixel_format(struct drm_plane *plane, enum ltdc_pix_fmt pix_fmt)
 {
-	switch (pf) {
-	case PF_ARGB8888:
-		return DRM_FORMAT_ARGB8888;
-	case PF_RGBA8888:
-		return DRM_FORMAT_RGBA8888;
-	case PF_RGB888:
-		return DRM_FORMAT_RGB888;
-	case PF_RGB565:
-		return DRM_FORMAT_RGB565;
+	struct ltdc_device *ldev = plane_to_ltdc(plane);
+	u32 lofs = plane->index * LAY_OFS, ret = PF_FLEXIBLE;
+	int psize, alen, apos, rlen, rpos, glen, gpos, blen, bpos;
+
+	switch (pix_fmt) {
+	case PF_BGR888:
+		psize = 3;
+		alen = 0; apos = 0; rlen = 8; rpos = 0;
+		glen = 8; gpos = 8; blen = 8; bpos = 16;
+	break;
 	case PF_ARGB1555:
-		return DRM_FORMAT_ARGB1555;
+		psize = 2;
+		alen = 1; apos = 15; rlen = 5; rpos = 10;
+		glen = 5; gpos = 5;  blen = 5; bpos = 0;
+	break;
 	case PF_ARGB4444:
-		return DRM_FORMAT_ARGB4444;
+		psize = 2;
+		alen = 4; apos = 12; rlen = 4; rpos = 8;
+		glen = 4; gpos = 4; blen = 4; bpos = 0;
+	break;
 	case PF_L8:
-		return DRM_FORMAT_C8;
-	case PF_AL44:		/* No DRM support */
-	case PF_AL88:		/* No DRM support */
-	case PF_NONE:
+		psize = 1;
+		alen = 0; apos = 0; rlen = 8; rpos = 0;
+		glen = 8; gpos = 0; blen = 8; bpos = 0;
+	break;
+	case PF_AL44:
+		psize = 1;
+		alen = 4; apos = 4; rlen = 4; rpos = 0;
+		glen = 4; gpos = 0; blen = 4; bpos = 0;
+	break;
+	case PF_AL88:
+		psize = 2;
+		alen = 8; apos = 8; rlen = 8; rpos = 0;
+		glen = 8; gpos = 0; blen = 8; bpos = 0;
+	break;
 	default:
-		return 0;
+		ret = NB_PF; /* error case, trace msg is handled by the caller */
+	break;
 	}
+
+	if (ret == PF_FLEXIBLE) {
+		regmap_write(ldev->regmap, LTDC_L1FPF0R + lofs,
+			     (rlen << 14)  + (rpos << 9) + (alen << 5) + apos);
+
+		regmap_write(ldev->regmap, LTDC_L1FPF1R + lofs,
+			     (psize << 18) + (blen << 14)  + (bpos << 9) + (glen << 5) + gpos);
+	}
+
+	return ret;
 }
 
-static inline u32 get_pixelformat_without_alpha(u32 drm)
+/*
+ * All non-alpha color formats derived from native alpha color formats are
+ * either characterized by a FourCC format code
+ */
+static inline u32 is_xrgb(u32 drm)
 {
-	switch (drm) {
-	case DRM_FORMAT_ARGB4444:
-		return DRM_FORMAT_XRGB4444;
-	case DRM_FORMAT_RGBA4444:
-		return DRM_FORMAT_RGBX4444;
-	case DRM_FORMAT_ARGB1555:
-		return DRM_FORMAT_XRGB1555;
-	case DRM_FORMAT_RGBA5551:
-		return DRM_FORMAT_RGBX5551;
-	case DRM_FORMAT_ARGB8888:
-		return DRM_FORMAT_XRGB8888;
-	case DRM_FORMAT_RGBA8888:
-		return DRM_FORMAT_RGBX8888;
+	return ((drm & 0xFF) == 'X' || ((drm >> 8) & 0xFF) == 'X');
+}
+
+static inline void ltdc_set_ycbcr_config(struct drm_plane *plane, u32 drm_pix_fmt)
+{
+	struct ltdc_device *ldev = plane_to_ltdc(plane);
+	struct drm_plane_state *state = plane->state;
+	u32 lofs = plane->index * LAY_OFS;
+	u32 val;
+
+	switch (drm_pix_fmt) {
+	case DRM_FORMAT_YUYV:
+		val = (YCM_I << 4) | LxPCR_YF | LxPCR_CBF;
+		break;
+	case DRM_FORMAT_YVYU:
+		val = (YCM_I << 4) | LxPCR_YF;
+		break;
+	case DRM_FORMAT_UYVY:
+		val = (YCM_I << 4) | LxPCR_CBF;
+		break;
+	case DRM_FORMAT_VYUY:
+		val = (YCM_I << 4);
+		break;
+	case DRM_FORMAT_NV12:
+		val = (YCM_SP << 4) | LxPCR_CBF;
+		break;
+	case DRM_FORMAT_NV21:
+		val = (YCM_SP << 4);
+		break;
+	case DRM_FORMAT_YUV420:
+	case DRM_FORMAT_YVU420:
+		val = (YCM_FP << 4);
+		break;
 	default:
-		return 0;
+		/* RGB or not a YCbCr supported format */
+		DRM_ERROR("Unsupported pixel format: %u\n", drm_pix_fmt);
+		return;
 	}
+
+	/* Enable limited range */
+	if (state->color_range == DRM_COLOR_YCBCR_LIMITED_RANGE)
+		val |= LxPCR_YREN;
+
+	/* enable ycbcr conversion */
+	val |= LxPCR_YCEN;
+
+	regmap_write(ldev->regmap, LTDC_L1PCR + lofs, val);
+}
+
+static inline void ltdc_set_ycbcr_coeffs(struct drm_plane *plane)
+{
+	struct ltdc_device *ldev = plane_to_ltdc(plane);
+	struct drm_plane_state *state = plane->state;
+	enum drm_color_encoding enc = state->color_encoding;
+	enum drm_color_range ran = state->color_range;
+	u32 lofs = plane->index * LAY_OFS;
+
+	if (enc != DRM_COLOR_YCBCR_BT601 && enc != DRM_COLOR_YCBCR_BT709) {
+		DRM_ERROR("color encoding %d not supported, use bt601 by default\n", enc);
+		/* set by default color encoding to DRM_COLOR_YCBCR_BT601 */
+		enc = DRM_COLOR_YCBCR_BT601;
+	}
+
+	if (ran != DRM_COLOR_YCBCR_LIMITED_RANGE && ran != DRM_COLOR_YCBCR_FULL_RANGE) {
+		DRM_ERROR("color range %d not supported, use limited range by default\n", ran);
+		/* set by default color range to DRM_COLOR_YCBCR_LIMITED_RANGE */
+		ran = DRM_COLOR_YCBCR_LIMITED_RANGE;
+	}
+
+	DRM_DEBUG_DRIVER("Color encoding=%d, range=%d\n", enc, ran);
+	regmap_write(ldev->regmap, LTDC_L1CYR0R + lofs,
+		     ltdc_ycbcr2rgb_coeffs[enc][ran][0]);
+	regmap_write(ldev->regmap, LTDC_L1CYR1R + lofs,
+		     ltdc_ycbcr2rgb_coeffs[enc][ran][1]);
+}
+
+static inline void ltdc_irq_crc_handle(struct ltdc_device *ldev,
+				       struct drm_crtc *crtc)
+{
+	u32 crc;
+	int ret;
+
+	if (ldev->crc_skip_count < CRC_SKIP_FRAMES) {
+		ldev->crc_skip_count++;
+		return;
+	}
+
+	/* Get the CRC of the frame */
+	ret = regmap_read(ldev->regmap, LTDC_CCRCR, &crc);
+	if (ret)
+		return;
+
+	/* Report to DRM the CRC (hw dependent feature) */
+	drm_crtc_add_crc_entry(crtc, true, drm_crtc_accurate_vblank_count(crtc), &crc);
 }
 
 static irqreturn_t ltdc_irq_thread(int irq, void *arg)
@@ -371,15 +715,21 @@ static irqreturn_t ltdc_irq_thread(int irq, void *arg)
 	struct drm_crtc *crtc = drm_crtc_from_index(ddev, 0);
 
 	/* Line IRQ : trigger the vblank event */
-	if (ldev->irq_status & ISR_LIF)
+	if (ldev->irq_status & ISR_LIF) {
 		drm_crtc_handle_vblank(crtc);
 
-	/* Save FIFO Underrun & Transfer Error status */
+		/* Early return if CRC is not active */
+		if (ldev->crc_active)
+			ltdc_irq_crc_handle(ldev, crtc);
+	}
+
 	mutex_lock(&ldev->err_lock);
-	if (ldev->irq_status & ISR_FUIF)
-		ldev->error_status |= ISR_FUIF;
 	if (ldev->irq_status & ISR_TERRIF)
-		ldev->error_status |= ISR_TERRIF;
+		ldev->transfer_err++;
+	if (ldev->irq_status & ISR_FUEIF)
+		ldev->fifo_err++;
+	if (ldev->irq_status & ISR_FUWIF)
+		ldev->fifo_warn++;
 	mutex_unlock(&ldev->err_lock);
 
 	return IRQ_HANDLED;
@@ -391,8 +741,8 @@ static irqreturn_t ltdc_irq(int irq, void *arg)
 	struct ltdc_device *ldev = ddev->dev_private;
 
 	/* Read & Clear the interrupt status */
-	ldev->irq_status = reg_read(ldev->regs, LTDC_ISR);
-	reg_write(ldev->regs, LTDC_ICR, ldev->irq_status);
+	ldev->irq_status = readl_relaxed(ldev->regs + LTDC_ISR);
+	writel_relaxed(ldev->irq_status, ldev->regs + LTDC_ICR);
 
 	return IRQ_WAKE_THREAD;
 }
@@ -416,7 +766,7 @@ static void ltdc_crtc_update_clut(struct drm_crtc *crtc)
 	for (i = 0; i < CLUT_SIZE; i++, lut++) {
 		val = ((lut->red << 8) & 0xff0000) | (lut->green & 0xff00) |
 			(lut->blue >> 8) | (i << 24);
-		reg_write(ldev->regs, LTDC_L1CLUTWR, val);
+		regmap_write(ldev->regmap, LTDC_L1CLUTWR, val);
 	}
 }
 
@@ -425,19 +775,27 @@ static void ltdc_crtc_atomic_enable(struct drm_crtc *crtc,
 {
 	struct ltdc_device *ldev = crtc_to_ltdc(crtc);
 	struct drm_device *ddev = crtc->dev;
+	int ret;
 
 	DRM_DEBUG_DRIVER("\n");
 
-	pm_runtime_get_sync(ddev->dev);
+	if (!pm_runtime_active(ddev->dev)) {
+		ret = pm_runtime_get_sync(ddev->dev);
+		if (ret) {
+			DRM_ERROR("Failed to set mode, cannot get sync\n");
+			return;
+		}
+	}
 
 	/* Sets the background color value */
-	reg_write(ldev->regs, LTDC_BCCR, BCCR_BCBLACK);
+	regmap_write(ldev->regmap, LTDC_BCCR, BCCR_BCBLACK);
 
 	/* Enable IRQ */
-	reg_set(ldev->regs, LTDC_IER, IER_RRIE | IER_FUIE | IER_TERRIE);
+	regmap_set_bits(ldev->regmap, LTDC_IER, IER_FUWIE | IER_FUEIE | IER_RRIE | IER_TERRIE);
 
 	/* Commit shadow registers = update planes at next vblank */
-	reg_set(ldev->regs, LTDC_SRCR, SRCR_VBR);
+	if (!ldev->caps.plane_reg_shadow)
+		regmap_set_bits(ldev->regmap, LTDC_SRCR, SRCR_VBR);
 
 	drm_crtc_vblank_on(crtc);
 }
@@ -447,18 +805,32 @@ static void ltdc_crtc_atomic_disable(struct drm_crtc *crtc,
 {
 	struct ltdc_device *ldev = crtc_to_ltdc(crtc);
 	struct drm_device *ddev = crtc->dev;
+	int layer_index = 0;
 
 	DRM_DEBUG_DRIVER("\n");
 
 	drm_crtc_vblank_off(crtc);
 
+	/* Disable all layers */
+	for (layer_index = 0; layer_index < ldev->caps.nb_layers; layer_index++)
+		regmap_write_bits(ldev->regmap, LTDC_L1CR + layer_index * LAY_OFS,
+				  LXCR_CLUTEN | LXCR_LEN, 0);
+
 	/* disable IRQ */
-	reg_clear(ldev->regs, LTDC_IER, IER_RRIE | IER_FUIE | IER_TERRIE);
+	regmap_clear_bits(ldev->regmap, LTDC_IER, IER_FUWIE | IER_FUEIE | IER_RRIE | IER_TERRIE);
 
 	/* immediately commit disable of layers before switching off LTDC */
-	reg_set(ldev->regs, LTDC_SRCR, SRCR_IMR);
+	if (!ldev->caps.plane_reg_shadow)
+		regmap_set_bits(ldev->regmap, LTDC_SRCR, SRCR_IMR);
 
-	pm_runtime_put_sync(ddev->dev);
+	pm_runtime_put_sync_suspend(ddev->dev);
+
+	/*  clear interrupt error counters */
+	mutex_lock(&ldev->err_lock);
+	ldev->transfer_err = 0;
+	ldev->fifo_err = 0;
+	ldev->fifo_warn = 0;
+	mutex_unlock(&ldev->err_lock);
 }
 
 #define CLK_TOLERANCE_HZ 50
@@ -473,7 +845,10 @@ ltdc_crtc_mode_valid(struct drm_crtc *crtc,
 	int target_max = target + CLK_TOLERANCE_HZ;
 	int result;
 
-	result = clk_round_rate(ldev->pixel_clk, target);
+	/* hack to get only valid clock (bug on clk_round_rate) */
+	clk_set_rate(ldev->pixel_clk, target);
+	result = clk_get_rate(ldev->pixel_clk);
+	/* result = clk_round_rate(ldev->pixel_clk, target); */
 
 	DRM_DEBUG_DRIVER("clk rate target %d, available %d\n", target, result);
 
@@ -533,6 +908,7 @@ static void ltdc_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	struct drm_display_mode *mode = &crtc->state->adjusted_mode;
 	u32 hsync, vsync, accum_hbp, accum_vbp, accum_act_w, accum_act_h;
 	u32 total_width, total_height;
+	u32 bus_formats = MEDIA_BUS_FMT_RGB888_1X24;
 	u32 bus_flags = 0;
 	u32 val;
 	int ret;
@@ -560,10 +936,13 @@ static void ltdc_crtc_mode_set_nofb(struct drm_crtc *crtc)
 		drm_connector_list_iter_end(&iter);
 	}
 
-	if (bridge && bridge->timings)
+	if (bridge && bridge->timings) {
 		bus_flags = bridge->timings->input_bus_flags;
-	else if (connector)
+	} else if (connector) {
 		bus_flags = connector->display_info.bus_flags;
+		if (connector->display_info.num_bus_formats)
+			bus_formats = connector->display_info.bus_formats[0];
+	}
 
 	if (!pm_runtime_active(ddev->dev)) {
 		ret = pm_runtime_get_sync(ddev->dev);
@@ -608,26 +987,59 @@ static void ltdc_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	if (bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE)
 		val |= GCR_PCPOL;
 
-	reg_update_bits(ldev->regs, LTDC_GCR,
-			GCR_HSPOL | GCR_VSPOL | GCR_DEPOL | GCR_PCPOL, val);
+	if (connector && connector->state->dithering == DRM_MODE_DITHERING_ON)
+		val |= GCR_DEN;
+
+	regmap_update_bits(ldev->regmap, LTDC_GCR,
+			   GCR_HSPOL | GCR_VSPOL | GCR_DEPOL | GCR_PCPOL | GCR_DEN, val);
 
 	/* Set Synchronization size */
 	val = (hsync << 16) | vsync;
-	reg_update_bits(ldev->regs, LTDC_SSCR, SSCR_VSH | SSCR_HSW, val);
+	regmap_update_bits(ldev->regmap, LTDC_SSCR, SSCR_VSH | SSCR_HSW, val);
 
 	/* Set Accumulated Back porch */
 	val = (accum_hbp << 16) | accum_vbp;
-	reg_update_bits(ldev->regs, LTDC_BPCR, BPCR_AVBP | BPCR_AHBP, val);
+	regmap_update_bits(ldev->regmap, LTDC_BPCR, BPCR_AVBP | BPCR_AHBP, val);
 
 	/* Set Accumulated Active Width */
 	val = (accum_act_w << 16) | accum_act_h;
-	reg_update_bits(ldev->regs, LTDC_AWCR, AWCR_AAW | AWCR_AAH, val);
+	regmap_update_bits(ldev->regmap, LTDC_AWCR, AWCR_AAW | AWCR_AAH, val);
 
 	/* Set total width & height */
 	val = (total_width << 16) | total_height;
-	reg_update_bits(ldev->regs, LTDC_TWCR, TWCR_TOTALH | TWCR_TOTALW, val);
+	regmap_update_bits(ldev->regmap, LTDC_TWCR, TWCR_TOTALH | TWCR_TOTALW, val);
+
+	regmap_write(ldev->regmap, LTDC_LIPCR, (accum_act_h + 1));
+
+	/* Configure the output format (hw version dependent) */
+	if (ldev->caps.ycbcr_output) {
+		/* Input video dynamic_range & colorimetry */
+		int vic = drm_match_cea_mode(mode);
+		u32 val;
 
-	reg_write(ldev->regs, LTDC_LIPCR, (accum_act_h + 1));
+		if (vic == 6 || vic == 7 || vic == 21 || vic == 22 ||
+		    vic == 2 || vic == 3 || vic == 17 || vic == 18)
+			/* ITU-R BT.601 */
+			val = 0;
+		else
+			/* ITU-R BT.709 */
+			val = EDCR_OCYSEL;
+
+		switch (bus_formats) {
+		case MEDIA_BUS_FMT_YUYV8_1X16:
+			/* enable ycbcr output converter */
+			regmap_write(ldev->regmap, LTDC_EDCR, EDCR_OCYEN | val);
+			break;
+		case MEDIA_BUS_FMT_YVYU8_1X16:
+			/* enable ycbcr output converter & invert chrominance order */
+			regmap_write(ldev->regmap, LTDC_EDCR, EDCR_OCYEN | EDCR_OCYCO | val);
+			break;
+		default:
+			/* disable ycbcr output converter */
+			regmap_write(ldev->regmap, LTDC_EDCR, 0);
+			break;
+		}
+	}
 }
 
 static void ltdc_crtc_atomic_flush(struct drm_crtc *crtc,
@@ -642,7 +1054,8 @@ static void ltdc_crtc_atomic_flush(struct drm_crtc *crtc,
 	ltdc_crtc_update_clut(crtc);
 
 	/* Commit shadow registers = update planes at next vblank */
-	reg_set(ldev->regs, LTDC_SRCR, SRCR_VBR);
+	if (!ldev->caps.plane_reg_shadow)
+		regmap_set_bits(ldev->regmap, LTDC_SRCR, SRCR_VBR);
 
 	if (event) {
 		crtc->state->event = NULL;
@@ -684,10 +1097,14 @@ static bool ltdc_crtc_get_scanout_position(struct drm_crtc *crtc,
 	 * simplify the code and only test if line > vactive_end
 	 */
 	if (pm_runtime_active(ddev->dev)) {
-		line = reg_read(ldev->regs, LTDC_CPSR) & CPSR_CYPOS;
-		vactive_start = reg_read(ldev->regs, LTDC_BPCR) & BPCR_AVBP;
-		vactive_end = reg_read(ldev->regs, LTDC_AWCR) & AWCR_AAH;
-		vtotal = reg_read(ldev->regs, LTDC_TWCR) & TWCR_TOTALH;
+		regmap_read(ldev->regmap, LTDC_CPSR, &line);
+		line &= CPSR_CYPOS;
+		regmap_read(ldev->regmap, LTDC_BPCR, &vactive_start);
+		vactive_start &= BPCR_AVBP;
+		regmap_read(ldev->regmap, LTDC_AWCR, &vactive_end);
+		vactive_end &= AWCR_AAH;
+		regmap_read(ldev->regmap, LTDC_TWCR, &vtotal);
+		vtotal &= TWCR_TOTALH;
 
 		if (line > vactive_end)
 			*vpos = line - vtotal - vactive_start;
@@ -723,7 +1140,7 @@ static int ltdc_crtc_enable_vblank(struct drm_crtc *crtc)
 	DRM_DEBUG_DRIVER("\n");
 
 	if (state->enable)
-		reg_set(ldev->regs, LTDC_IER, IER_LIE);
+		regmap_set_bits(ldev->regmap, LTDC_IER, IER_LIE);
 	else
 		return -EPERM;
 
@@ -735,7 +1152,61 @@ static void ltdc_crtc_disable_vblank(struct drm_crtc *crtc)
 	struct ltdc_device *ldev = crtc_to_ltdc(crtc);
 
 	DRM_DEBUG_DRIVER("\n");
-	reg_clear(ldev->regs, LTDC_IER, IER_LIE);
+	regmap_clear_bits(ldev->regmap, LTDC_IER, IER_LIE);
+}
+
+static int ltdc_crtc_set_crc_source(struct drm_crtc *crtc, const char *source)
+{
+	struct ltdc_device *ldev = crtc_to_ltdc(crtc);
+	int ret;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	if (!crtc)
+		return -ENODEV;
+
+	if (source && strcmp(source, "auto") == 0) {
+		ldev->crc_active = true;
+		ret = regmap_set_bits(ldev->regmap, LTDC_GCR, GCR_CRCEN);
+	} else if (!source) {
+		ldev->crc_active = false;
+		ret = regmap_clear_bits(ldev->regmap, LTDC_GCR, GCR_CRCEN);
+	} else {
+		ret = -EINVAL;
+	}
+
+	ldev->crc_skip_count = 0;
+	return ret;
+}
+
+static int ltdc_crtc_verify_crc_source(struct drm_crtc *crtc,
+				       const char *source, size_t *values_cnt)
+{
+	DRM_DEBUG_DRIVER("\n");
+
+	if (!crtc)
+		return -ENODEV;
+
+	if (source && strcmp(source, "auto") != 0) {
+		DRM_DEBUG_DRIVER("Unknown CRC source %s for %s\n",
+				 source, crtc->name);
+		return -EINVAL;
+	}
+
+	*values_cnt = 1;
+	return 0;
+}
+
+static void ltdc_crtc_atomic_print_state(struct drm_printer *p,
+					 const struct drm_crtc_state *state)
+{
+	struct drm_crtc *crtc = state->crtc;
+	struct ltdc_device *ldev = crtc_to_ltdc(crtc);
+
+	drm_printf(p, "\ttransfer_error=%d\n", ldev->transfer_err);
+	drm_printf(p, "\tfifo_underrun_error=%d\n", ldev->fifo_err);
+	drm_printf(p, "\tfifo_underrun_warning=%d\n", ldev->fifo_warn);
+	drm_printf(p, "\tfifo_underrun_threshold=%d\n", ldev->fifo_threshold);
 }
 
 static const struct drm_crtc_funcs ltdc_crtc_funcs = {
@@ -748,6 +1219,22 @@ static const struct drm_crtc_funcs ltdc_crtc_funcs = {
 	.enable_vblank = ltdc_crtc_enable_vblank,
 	.disable_vblank = ltdc_crtc_disable_vblank,
 	.get_vblank_timestamp = drm_crtc_vblank_helper_get_vblank_timestamp,
+	.atomic_print_state = ltdc_crtc_atomic_print_state,
+};
+
+static const struct drm_crtc_funcs ltdc_crtc_with_crc_support_funcs = {
+	.destroy = drm_crtc_cleanup,
+	.set_config = drm_atomic_helper_set_config,
+	.page_flip = drm_atomic_helper_page_flip,
+	.reset = drm_atomic_helper_crtc_reset,
+	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
+	.enable_vblank = ltdc_crtc_enable_vblank,
+	.disable_vblank = ltdc_crtc_disable_vblank,
+	.get_vblank_timestamp = drm_crtc_vblank_helper_get_vblank_timestamp,
+	.set_crc_source = ltdc_crtc_set_crc_source,
+	.verify_crc_source = ltdc_crtc_verify_crc_source,
+	.atomic_print_state = ltdc_crtc_atomic_print_state,
 };
 
 /*
@@ -773,7 +1260,8 @@ static int ltdc_plane_atomic_check(struct drm_plane *plane,
 
 	/* Reject scaling */
 	if (src_w != new_plane_state->crtc_w || src_h != new_plane_state->crtc_h) {
-		DRM_ERROR("Scaling is not supported");
+		DRM_DEBUG_DRIVER("Scaling is not supported");
+
 		return -EINVAL;
 	}
 
@@ -784,6 +1272,7 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 				     struct drm_atomic_state *state)
 {
 	struct ltdc_device *ldev = plane_to_ltdc(plane);
+	struct drm_device *ddev = plane->dev;
 	struct drm_plane_state *newstate = drm_atomic_get_new_plane_state(state,
 									  plane);
 	struct drm_framebuffer *fb = newstate->fb;
@@ -793,7 +1282,8 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 	u32 y0 = newstate->crtc_y;
 	u32 y1 = newstate->crtc_y + newstate->crtc_h - 1;
 	u32 src_x, src_y, src_w, src_h;
-	u32 val, pitch_in_bytes, line_length, paddr, ahbp, avbp, bpcr;
+	u32 val, pitch_in_bytes, line_length, line_number, ahbp, avbp, bpcr;
+	u32 paddr, paddr1, paddr2;
 	enum ltdc_pix_fmt pf;
 
 	if (!newstate->crtc || !fb) {
@@ -813,19 +1303,23 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 			 newstate->crtc_w, newstate->crtc_h,
 			 newstate->crtc_x, newstate->crtc_y);
 
-	bpcr = reg_read(ldev->regs, LTDC_BPCR);
+	if (!pm_runtime_active(ddev->dev))
+		return;
+
+	regmap_read(ldev->regmap, LTDC_BPCR, &bpcr);
+
 	ahbp = (bpcr & BPCR_AHBP) >> 16;
 	avbp = bpcr & BPCR_AVBP;
 
 	/* Configures the horizontal start and stop position */
 	val = ((x1 + 1 + ahbp) << 16) + (x0 + 1 + ahbp);
-	reg_update_bits(ldev->regs, LTDC_L1WHPCR + lofs,
-			LXWHPCR_WHSTPOS | LXWHPCR_WHSPPOS, val);
+	regmap_write_bits(ldev->regmap, LTDC_L1WHPCR + lofs,
+			  LXWHPCR_WHSTPOS | LXWHPCR_WHSPPOS, val);
 
 	/* Configures the vertical start and stop position */
 	val = ((y1 + 1 + avbp) << 16) + (y0 + 1 + avbp);
-	reg_update_bits(ldev->regs, LTDC_L1WVPCR + lofs,
-			LXWVPCR_WVSTPOS | LXWVPCR_WVSPPOS, val);
+	regmap_write_bits(ldev->regmap, LTDC_L1WVPCR + lofs,
+			  LXWVPCR_WVSTPOS | LXWVPCR_WVSPPOS, val);
 
 	/* Specifies the pixel format */
 	pf = to_ltdc_pixelformat(fb->format->format);
@@ -833,24 +1327,20 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 		if (ldev->caps.pix_fmt_hw[val] == pf)
 			break;
 
+	/* Use the flexible color format feature if necessary and available */
+	if (ldev->caps.pix_fmt_flex && val == NB_PF)
+		val = ltdc_set_flexible_pixel_format(plane, pf);
+
 	if (val == NB_PF) {
 		DRM_ERROR("Pixel format %.4s not supported\n",
 			  (char *)&fb->format->format);
 		val = 0;	/* set by default ARGB 32 bits */
 	}
-	reg_update_bits(ldev->regs, LTDC_L1PFCR + lofs, LXPFCR_PF, val);
-
-	/* Configures the color frame buffer pitch in bytes & line length */
-	pitch_in_bytes = fb->pitches[0];
-	line_length = fb->format->cpp[0] *
-		      (x1 - x0 + 1) + (ldev->caps.bus_width >> 3) - 1;
-	val = ((pitch_in_bytes << 16) | line_length);
-	reg_update_bits(ldev->regs, LTDC_L1CFBLR + lofs,
-			LXCFBLR_CFBLL | LXCFBLR_CFBP, val);
+	regmap_write_bits(ldev->regmap, LTDC_L1PFCR + lofs, LXPFCR_PF, val);
 
 	/* Specifies the constant alpha value */
-	val = CONSTA_MAX;
-	reg_update_bits(ldev->regs, LTDC_L1CACR + lofs, LXCACR_CONSTA, val);
+	val = newstate->alpha >> 8;
+	regmap_write_bits(ldev->regmap, LTDC_L1CACR + lofs, LXCACR_CONSTA, val);
 
 	/* Specifies the blending factors */
 	val = BF1_PAXCA | BF2_1PAXCA;
@@ -862,35 +1352,171 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 	    plane->type != DRM_PLANE_TYPE_PRIMARY)
 		val = BF1_PAXCA | BF2_1PAXCA;
 
-	reg_update_bits(ldev->regs, LTDC_L1BFCR + lofs,
-			LXBFCR_BF2 | LXBFCR_BF1, val);
-
-	/* Configures the frame buffer line number */
-	val = y1 - y0 + 1;
-	reg_update_bits(ldev->regs, LTDC_L1CFBLNR + lofs, LXCFBLNR_CFBLN, val);
+	if (ldev->caps.dynamic_zorder) {
+		val |= (newstate->normalized_zpos << 16);
+		regmap_write_bits(ldev->regmap, LTDC_L1BFCR + lofs,
+				  LXBFCR_BF2 | LXBFCR_BF1 | LXBFCR_BOR, val);
+	} else {
+		regmap_write_bits(ldev->regmap, LTDC_L1BFCR + lofs,
+				  LXBFCR_BF2 | LXBFCR_BF1, val);
+	}
 
 	/* Sets the FB address */
 	paddr = (u32)drm_fb_cma_get_gem_addr(fb, newstate, 0);
 
+	if (newstate->rotation & DRM_MODE_REFLECT_X)
+		paddr += (fb->format->cpp[0] * (x1 - x0 + 1)) - 1;
+
+	if (newstate->rotation & DRM_MODE_REFLECT_Y)
+		paddr += (fb->pitches[0] * (y1 - y0));
+
 	DRM_DEBUG_DRIVER("fb: phys 0x%08x", paddr);
-	reg_write(ldev->regs, LTDC_L1CFBAR + lofs, paddr);
+	regmap_write(ldev->regmap, LTDC_L1CFBAR + lofs, paddr);
+
+	/* Configures the color frame buffer pitch in bytes & line length */
+	line_length = fb->format->cpp[0] *
+		      (x1 - x0 + 1) + (ldev->caps.bus_width >> 3) - 1;
+
+	if (newstate->rotation & DRM_MODE_REFLECT_Y)
+		/* Compute negative value (signed on 16 bits) for the picth */
+		pitch_in_bytes = 0x10000 - fb->pitches[0];
+	else
+		pitch_in_bytes = fb->pitches[0];
+
+	val = (pitch_in_bytes << 16) | line_length;
+	regmap_write_bits(ldev->regmap, LTDC_L1CFBLR + lofs, LXCFBLR_CFBLL | LXCFBLR_CFBP, val);
+
+	/* Configures the frame buffer line number */
+	line_number = y1 - y0 + 1;
+	regmap_write_bits(ldev->regmap, LTDC_L1CFBLNR + lofs, LXCFBLNR_CFBLN, line_number);
+
+	if (ldev->caps.ycbcr_input) {
+		if (fb->format->is_yuv) {
+			switch (fb->format->format) {
+			case DRM_FORMAT_NV12:
+			case DRM_FORMAT_NV21:
+			/* Configure the auxiliary frame buffer address 0 */
+			paddr1 = (u32)drm_fb_cma_get_gem_addr(fb, newstate, 1);
+
+			if (newstate->rotation & DRM_MODE_REFLECT_X)
+				paddr1 += ((fb->format->cpp[1] * (x1 - x0 + 1)) >> 1) - 1;
+
+			if (newstate->rotation & DRM_MODE_REFLECT_Y)
+				paddr1 += (fb->pitches[1] * (y1 - y0 - 1)) >> 1;
+
+			regmap_write(ldev->regmap, LTDC_L1AFBA0R + lofs, paddr1);
+			break;
+			case DRM_FORMAT_YUV420:
+			/* Configure the auxiliary frame buffer address 0 & 1 */
+			paddr1 = (u32)drm_fb_cma_get_gem_addr(fb, newstate, 1);
+			paddr2 = (u32)drm_fb_cma_get_gem_addr(fb, newstate, 2);
+
+			if (newstate->rotation & DRM_MODE_REFLECT_X) {
+				paddr1 += ((fb->format->cpp[1] * (x1 - x0 + 1)) >> 1) - 1;
+				paddr2 += ((fb->format->cpp[2] * (x1 - x0 + 1)) >> 1) - 1;
+			}
+
+			if (newstate->rotation & DRM_MODE_REFLECT_Y) {
+				paddr1 += (fb->pitches[1] * (y1 - y0 - 1)) >> 1;
+				paddr2 += (fb->pitches[2] * (y1 - y0 - 1)) >> 1;
+			}
+
+			regmap_write(ldev->regmap, LTDC_L1AFBA0R + lofs, paddr1);
+			regmap_write(ldev->regmap, LTDC_L1AFBA1R + lofs, paddr2);
+			break;
+			case DRM_FORMAT_YVU420:
+			/* Configure the auxiliary frame buffer address 0 & 1 */
+			paddr1 = (u32)drm_fb_cma_get_gem_addr(fb, newstate, 2);
+			paddr2 = (u32)drm_fb_cma_get_gem_addr(fb, newstate, 1);
+
+			if (newstate->rotation & DRM_MODE_REFLECT_X) {
+				paddr1 += ((fb->format->cpp[1] * (x1 - x0 + 1)) >> 1) - 1;
+				paddr2 += ((fb->format->cpp[2] * (x1 - x0 + 1)) >> 1) - 1;
+			}
+
+			if (newstate->rotation & DRM_MODE_REFLECT_Y) {
+				paddr1 += (fb->pitches[1] * (y1 - y0 - 1)) >> 1;
+				paddr2 += (fb->pitches[2] * (y1 - y0 - 1)) >> 1;
+			}
+
+			regmap_write(ldev->regmap, LTDC_L1AFBA0R + lofs, paddr1);
+			regmap_write(ldev->regmap, LTDC_L1AFBA1R + lofs, paddr2);
+			break;
+			}
+
+			/*
+			 * Set the length and the number of lines of the auxiliary
+			 * buffers if the framebuffer contains more than one plane.
+			 */
+			if (fb->format->num_planes > 1) {
+				if (newstate->rotation & DRM_MODE_REFLECT_Y)
+					/*
+					 * Compute negative value (signed on 16 bits)
+					 * for the picth
+					 */
+					pitch_in_bytes = 0x10000 - fb->pitches[1];
+				else
+					pitch_in_bytes = fb->pitches[1];
+
+				line_length = ((fb->format->cpp[1] * (x1 - x0 + 1)) >> 1) +
+					      (ldev->caps.bus_width >> 3) - 1;
+
+				/* Configure the auxiliary buffer length */
+				val = (pitch_in_bytes << 16) | line_length;
+				regmap_write(ldev->regmap, LTDC_L1AFBLR + lofs, val);
+
+				/* Configure the auxiliary frame buffer line number */
+				val = line_number >> 1;
+				regmap_write(ldev->regmap, LTDC_L1AFBLNR + lofs, val);
+			}
+
+			/* Configure YCbC conversion coefficient */
+			ltdc_set_ycbcr_coeffs(plane);
+
+			/* Configure YCbCr format and enable/disable conversion */
+			ltdc_set_ycbcr_config(plane, fb->format->format);
+		} else {
+			/* disable ycbcr conversion */
+			regmap_write(ldev->regmap, LTDC_L1PCR + lofs, 0);
+		}
+	}
+
+	/* Configure burst length */
+	regmap_write(ldev->regmap, LTDC_L1BLCR + lofs, ldev->max_burst_length);
 
 	/* Enable layer and CLUT if needed */
 	val = fb->format->format == DRM_FORMAT_C8 ? LXCR_CLUTEN : 0;
 	val |= LXCR_LEN;
-	reg_update_bits(ldev->regs, LTDC_L1CR + lofs,
-			LXCR_LEN | LXCR_CLUTEN, val);
+
+	/* Enable horizontal mirroring if requested */
+	if (newstate->rotation & DRM_MODE_REFLECT_X)
+		val |= LXCR_HMEN;
+
+	regmap_write_bits(ldev->regmap, LTDC_L1CR + lofs, LXCR_LEN | LXCR_CLUTEN | LXCR_HMEN, val);
+
+	/* Commit shadow registers = update plane at next vblank */
+	if (ldev->caps.plane_reg_shadow)
+		regmap_write_bits(ldev->regmap, LTDC_L1RCR + lofs,
+				  LXRCR_IMR | LXRCR_VBR | LXRCR_GRMSK, LXRCR_VBR);
 
 	ldev->plane_fpsi[plane->index].counter++;
 
 	mutex_lock(&ldev->err_lock);
-	if (ldev->error_status & ISR_FUIF) {
-		DRM_WARN("ltdc fifo underrun: please verify display mode\n");
-		ldev->error_status &= ~ISR_FUIF;
+	if (ldev->transfer_err) {
+		DRM_WARN("ltdc transfer error: %d\n", ldev->transfer_err);
+		ldev->transfer_err = 0;
 	}
-	if (ldev->error_status & ISR_TERRIF) {
-		DRM_WARN("ltdc transfer error\n");
-		ldev->error_status &= ~ISR_TERRIF;
+
+	if (ldev->caps.fifo_threshold) {
+		if (ldev->fifo_err) {
+			DRM_WARN("ltdc fifo underrun: please verify display mode\n");
+			ldev->fifo_err = 0;
+		}
+	} else {
+		if (ldev->fifo_warn >= ldev->fifo_threshold) {
+			DRM_WARN("ltdc fifo underrun: please verify display mode\n");
+			ldev->fifo_warn = 0;
+		}
 	}
 	mutex_unlock(&ldev->err_lock);
 }
@@ -901,10 +1527,19 @@ static void ltdc_plane_atomic_disable(struct drm_plane *plane,
 	struct drm_plane_state *oldstate = drm_atomic_get_old_plane_state(state,
 									  plane);
 	struct ltdc_device *ldev = plane_to_ltdc(plane);
+	struct drm_device *ddev = plane->dev;
 	u32 lofs = plane->index * LAY_OFS;
 
-	/* disable layer */
-	reg_clear(ldev->regs, LTDC_L1CR + lofs, LXCR_LEN);
+	if (!pm_runtime_active(ddev->dev))
+		return;
+
+	/* Disable layer */
+	regmap_write_bits(ldev->regmap, LTDC_L1CR + lofs, LXCR_LEN | LXCR_CLUTEN |  LXCR_HMEN, 0);
+
+	/* Commit shadow registers = update plane at next vblank */
+	if (ldev->caps.plane_reg_shadow)
+		regmap_write_bits(ldev->regmap, LTDC_L1RCR + lofs,
+				  LXRCR_IMR | LXRCR_VBR | LXRCR_GRMSK, LXRCR_VBR);
 
 	DRM_DEBUG_DRIVER("CRTC:%d plane:%d\n",
 			 oldstate->crtc->base.id, plane->base.id);
@@ -957,36 +1592,57 @@ static const struct drm_plane_helper_funcs ltdc_plane_helper_funcs = {
 };
 
 static struct drm_plane *ltdc_plane_create(struct drm_device *ddev,
-					   enum drm_plane_type type)
+					   enum drm_plane_type type,
+					   int index)
 {
 	unsigned long possible_crtcs = CRTC_MASK;
 	struct ltdc_device *ldev = ddev->dev_private;
 	struct device *dev = ddev->dev;
 	struct drm_plane *plane;
 	unsigned int i, nb_fmt = 0;
-	u32 formats[NB_PF * 2];
-	u32 drm_fmt, drm_fmt_no_alpha;
+	u32 *formats;
+	u32 drm_fmt;
 	const u64 *modifiers = ltdc_format_modifiers;
+	u32 lofs = index * LAY_OFS;
+	u32 val;
 	int ret;
 
-	/* Get supported pixel formats */
-	for (i = 0; i < NB_PF; i++) {
-		drm_fmt = to_drm_pixelformat(ldev->caps.pix_fmt_hw[i]);
-		if (!drm_fmt)
-			continue;
-		formats[nb_fmt++] = drm_fmt;
+	/* Allocate the biggest size according to supported color formats */
+	formats = devm_kzalloc(dev, (ldev->caps.pix_fmt_nb +
+			       ARRAY_SIZE(ltdc_drm_fmt_ycbcr_cp) +
+			       ARRAY_SIZE(ltdc_drm_fmt_ycbcr_sp) +
+			       ARRAY_SIZE(ltdc_drm_fmt_ycbcr_fp)) *
+			       sizeof(*formats), GFP_KERNEL);
 
-		/* Add the no-alpha related format if any & supported */
-		drm_fmt_no_alpha = get_pixelformat_without_alpha(drm_fmt);
-		if (!drm_fmt_no_alpha)
-			continue;
+	for (i = 0; i < ldev->caps.pix_fmt_nb; i++) {
+		drm_fmt = ldev->caps.pix_fmt_drm[i];
 
 		/* Manage hw-specific capabilities */
-		if (ldev->caps.non_alpha_only_l1 &&
-		    type != DRM_PLANE_TYPE_PRIMARY)
-			continue;
+		if (ldev->caps.non_alpha_only_l1)
+			if (type != DRM_PLANE_TYPE_PRIMARY && is_xrgb(drm_fmt))
+			continue; /* XR24 & RX24 like formats supported only on primary layer */
 
-		formats[nb_fmt++] = drm_fmt_no_alpha;
+		formats[nb_fmt++] = drm_fmt;
+	}
+
+	/* Add YCbCr supported pixel formats */
+	if (ldev->caps.ycbcr_input) {
+		regmap_read(ldev->regmap, LTDC_L1C1R + lofs, &val);
+		if (val & LXCR_C1R_YIA) {
+			memcpy(&formats[nb_fmt], ltdc_drm_fmt_ycbcr_cp,
+			       ARRAY_SIZE(ltdc_drm_fmt_ycbcr_cp) * sizeof(*formats));
+			nb_fmt += ARRAY_SIZE(ltdc_drm_fmt_ycbcr_cp);
+		}
+		if (val & LXCR_C1R_YSPA) {
+			memcpy(&formats[nb_fmt], ltdc_drm_fmt_ycbcr_sp,
+			       ARRAY_SIZE(ltdc_drm_fmt_ycbcr_sp) * sizeof(*formats));
+			nb_fmt += ARRAY_SIZE(ltdc_drm_fmt_ycbcr_sp);
+		}
+		if (val & LXCR_C1R_YFPA) {
+			memcpy(&formats[nb_fmt], ltdc_drm_fmt_ycbcr_fp,
+			       ARRAY_SIZE(ltdc_drm_fmt_ycbcr_fp) * sizeof(*formats));
+			nb_fmt += ARRAY_SIZE(ltdc_drm_fmt_ycbcr_fp);
+		}
 	}
 
 	plane = devm_kzalloc(dev, sizeof(*plane), GFP_KERNEL);
@@ -999,8 +1655,21 @@ static struct drm_plane *ltdc_plane_create(struct drm_device *ddev,
 	if (ret < 0)
 		return NULL;
 
+	if (ldev->caps.ycbcr_input) {
+		if (val & (LXCR_C1R_YIA | LXCR_C1R_YSPA | LXCR_C1R_YFPA))
+			drm_plane_create_color_properties(plane,
+							  BIT(DRM_COLOR_YCBCR_BT601) |
+							  BIT(DRM_COLOR_YCBCR_BT709),
+							  BIT(DRM_COLOR_YCBCR_LIMITED_RANGE) |
+							  BIT(DRM_COLOR_YCBCR_FULL_RANGE),
+							  DRM_COLOR_YCBCR_BT601,
+							  DRM_COLOR_YCBCR_LIMITED_RANGE);
+	}
+
 	drm_plane_helper_add(plane, &ltdc_plane_helper_funcs);
 
+	drm_plane_create_alpha_property(plane);
+
 	DRM_DEBUG_DRIVER("plane:%d created\n", plane->base.id);
 
 	return plane;
@@ -1019,17 +1688,42 @@ static int ltdc_crtc_init(struct drm_device *ddev, struct drm_crtc *crtc)
 {
 	struct ltdc_device *ldev = ddev->dev_private;
 	struct drm_plane *primary, *overlay;
+	int supported_rotations = DRM_MODE_ROTATE_0 | DRM_MODE_REFLECT_X | DRM_MODE_REFLECT_Y;
 	unsigned int i;
 	int ret;
+	struct drm_connector *connector = NULL;
+	struct drm_connector_list_iter iter;
+
+	/* Add the dithering property to all connectors */
+	drm_connector_list_iter_begin(ddev, &iter);
+	drm_for_each_connector_iter(connector, &iter)
+		drm_connector_attach_dithering_property(connector,
+							BIT(DRM_MODE_DITHERING_OFF) |
+							BIT(DRM_MODE_DITHERING_ON));
+	drm_connector_list_iter_end(&iter);
 
-	primary = ltdc_plane_create(ddev, DRM_PLANE_TYPE_PRIMARY);
+	primary = ltdc_plane_create(ddev, DRM_PLANE_TYPE_PRIMARY, 0);
 	if (!primary) {
 		DRM_ERROR("Can not create primary plane\n");
 		return -EINVAL;
 	}
 
-	ret = drm_crtc_init_with_planes(ddev, crtc, primary, NULL,
-					&ltdc_crtc_funcs, NULL);
+	if (ldev->caps.dynamic_zorder)
+		drm_plane_create_zpos_property(primary, 0, 0, ldev->caps.nb_layers - 1);
+	else
+		drm_plane_create_zpos_immutable_property(primary, 0);
+
+	if (ldev->caps.plane_rotation)
+		drm_plane_create_rotation_property(primary, DRM_MODE_ROTATE_0,
+						   supported_rotations);
+
+	/* Init CRTC according to its hardware features */
+	if (ldev->caps.crc)
+		ret = drm_crtc_init_with_planes(ddev, crtc, primary, NULL,
+						&ltdc_crtc_with_crc_support_funcs, NULL);
+	else
+		ret = drm_crtc_init_with_planes(ddev, crtc, primary, NULL,
+						&ltdc_crtc_funcs, NULL);
 	if (ret) {
 		DRM_ERROR("Can not initialize CRTC\n");
 		goto cleanup;
@@ -1044,12 +1738,20 @@ static int ltdc_crtc_init(struct drm_device *ddev, struct drm_crtc *crtc)
 
 	/* Add planes. Note : the first layer is used by primary plane */
 	for (i = 1; i < ldev->caps.nb_layers; i++) {
-		overlay = ltdc_plane_create(ddev, DRM_PLANE_TYPE_OVERLAY);
+		overlay = ltdc_plane_create(ddev, DRM_PLANE_TYPE_OVERLAY, i);
 		if (!overlay) {
 			ret = -ENOMEM;
 			DRM_ERROR("Can not create overlay plane %d\n", i);
 			goto cleanup;
 		}
+		if (ldev->caps.dynamic_zorder)
+			drm_plane_create_zpos_property(overlay, i, 0, ldev->caps.nb_layers - 1);
+		else
+			drm_plane_create_zpos_immutable_property(overlay, i);
+
+		if (ldev->caps.plane_rotation)
+			drm_plane_create_rotation_property(overlay, DRM_MODE_ROTATE_0,
+							   supported_rotations);
 	}
 
 	return 0;
@@ -1067,7 +1769,7 @@ static void ltdc_encoder_disable(struct drm_encoder *encoder)
 	DRM_DEBUG_DRIVER("\n");
 
 	/* Disable LTDC */
-	reg_clear(ldev->regs, LTDC_GCR, GCR_LTDCEN);
+	regmap_clear_bits(ldev->regmap, LTDC_GCR, GCR_LTDCEN);
 
 	/* Set to sleep state the pinctrl whatever type of encoder */
 	pinctrl_pm_select_sleep_state(ddev->dev);
@@ -1080,8 +1782,12 @@ static void ltdc_encoder_enable(struct drm_encoder *encoder)
 
 	DRM_DEBUG_DRIVER("\n");
 
+	/* set fifo underrun threshold register */
+	if (ldev->caps.fifo_threshold)
+		regmap_write(ldev->regmap, LTDC_FUT, ldev->fifo_threshold);
+
 	/* Enable LTDC */
-	reg_set(ldev->regs, LTDC_GCR, GCR_LTDCEN);
+	regmap_set_bits(ldev->regmap, LTDC_GCR, GCR_LTDCEN);
 }
 
 static void ltdc_encoder_mode_set(struct drm_encoder *encoder,
@@ -1089,6 +1795,7 @@ static void ltdc_encoder_mode_set(struct drm_encoder *encoder,
 				  struct drm_display_mode *adjusted_mode)
 {
 	struct drm_device *ddev = encoder->dev;
+	struct ltdc_device *ldev = ddev->dev_private;
 
 	DRM_DEBUG_DRIVER("\n");
 
@@ -1099,6 +1806,22 @@ static void ltdc_encoder_mode_set(struct drm_encoder *encoder,
 	 */
 	if (encoder->encoder_type == DRM_MODE_ENCODER_DPI)
 		pinctrl_pm_select_default_state(ddev->dev);
+
+	/* check if muxer must be set to choose a clock source for pixel clock */
+	if (ldev->syscon_regmap) {
+		switch (encoder->encoder_type) {
+		case DRM_MODE_ENCODER_DSI:
+		case DRM_MODE_ENCODER_DPI:
+			regmap_write(ldev->syscon_regmap, SYSCFG_DISPLAYCLKCR, DISPLAYCLKCR_DPI);
+			break;
+		case DRM_MODE_ENCODER_LVDS:
+			regmap_write(ldev->syscon_regmap, SYSCFG_DISPLAYCLKCR, DISPLAYCLKCR_LVDS);
+			break;
+		default:
+			DRM_ERROR("Invalid Encoder type: %d\n", encoder->encoder_type);
+			break;
+		}
+	}
 }
 
 static const struct drm_encoder_helper_funcs ltdc_encoder_helper_funcs = {
@@ -1144,21 +1867,25 @@ static int ltdc_get_caps(struct drm_device *ddev)
 	 * at least 1 layer must be managed & the number of layers
 	 * must not exceed LTDC_MAX_LAYER
 	 */
-	lcr = reg_read(ldev->regs, LTDC_LCR);
+	regmap_read(ldev->regmap, LTDC_LCR, &lcr);
 
 	ldev->caps.nb_layers = clamp((int)lcr, 1, LTDC_MAX_LAYER);
 
 	/* set data bus width */
-	gc2r = reg_read(ldev->regs, LTDC_GC2R);
+	regmap_read(ldev->regmap, LTDC_GC2R, &gc2r);
 	bus_width_log2 = (gc2r & GC2R_BW) >> 4;
 	ldev->caps.bus_width = 8 << bus_width_log2;
-	ldev->caps.hw_version = reg_read(ldev->regs, LTDC_IDR);
+	regmap_read(ldev->regmap, LTDC_IDR, &ldev->caps.hw_version);
 
 	switch (ldev->caps.hw_version) {
 	case HWVER_10200:
 	case HWVER_10300:
-		ldev->caps.reg_ofs = REG_OFS_NONE;
+		ldev->caps.layer_ofs = LAY_OFS_0;
+		ldev->caps.layer_regs = ltdc_layer_regs_a0;
 		ldev->caps.pix_fmt_hw = ltdc_pix_fmt_a0;
+		ldev->caps.pix_fmt_drm = ltdc_drm_fmt_a0;
+		ldev->caps.pix_fmt_nb = ARRAY_SIZE(ltdc_drm_fmt_a0);
+		ldev->caps.pix_fmt_flex = false;
 		/*
 		 * Hw older versions support non-alpha color formats derived
 		 * from native alpha color formats only on the primary layer.
@@ -1171,13 +1898,53 @@ static int ltdc_get_caps(struct drm_device *ddev)
 		if (ldev->caps.hw_version == HWVER_10200)
 			ldev->caps.pad_max_freq_hz = 65000000;
 		ldev->caps.nb_irq = 2;
+		ldev->caps.ycbcr_input = false;
+		ldev->caps.ycbcr_output = false;
+		ldev->caps.plane_reg_shadow = false;
+		ldev->caps.crc = false;
+		ldev->caps.dynamic_zorder = false;
+		ldev->caps.plane_rotation = false;
+		ldev->caps.fifo_threshold = false;
 		break;
 	case HWVER_20101:
-		ldev->caps.reg_ofs = REG_OFS_4;
+		ldev->caps.layer_ofs = LAY_OFS_0;
+		ldev->caps.layer_regs = ltdc_layer_regs_a1;
 		ldev->caps.pix_fmt_hw = ltdc_pix_fmt_a1;
+		ldev->caps.pix_fmt_drm = ltdc_drm_fmt_a1;
+		ldev->caps.pix_fmt_nb = ARRAY_SIZE(ltdc_drm_fmt_a1);
+		ldev->caps.pix_fmt_flex = false;
 		ldev->caps.non_alpha_only_l1 = false;
 		ldev->caps.pad_max_freq_hz = 150000000;
 		ldev->caps.nb_irq = 4;
+		ldev->caps.ycbcr_input = false;
+		ldev->caps.ycbcr_output = false;
+		ldev->caps.plane_reg_shadow = false;
+		ldev->caps.crc = false;
+		ldev->caps.dynamic_zorder = false;
+		ldev->caps.plane_rotation = false;
+		ldev->caps.fifo_threshold = false;
+		break;
+	case HWVER_40100:
+		ldev->caps.layer_ofs = LAY_OFS_1;
+		ldev->caps.layer_regs = ltdc_layer_regs_a2;
+		ldev->caps.pix_fmt_hw = ltdc_pix_fmt_a2;
+		ldev->caps.pix_fmt_drm = ltdc_drm_fmt_a2;
+		ldev->caps.pix_fmt_nb = ARRAY_SIZE(ltdc_drm_fmt_a2);
+		ldev->caps.pix_fmt_flex = true;
+		ldev->caps.non_alpha_only_l1 = false;
+		/* Need a pad max frequency of 150MHz for 3 layers */
+		if (lcr == 3)
+			ldev->caps.pad_max_freq_hz = 150000000;
+		else
+			ldev->caps.pad_max_freq_hz = 90000000;
+		ldev->caps.nb_irq = 2;
+		ldev->caps.ycbcr_input = true;
+		ldev->caps.ycbcr_output = true;
+		ldev->caps.plane_reg_shadow = true;
+		ldev->caps.crc = true;
+		ldev->caps.dynamic_zorder = true;
+		ldev->caps.plane_rotation = true;
+		ldev->caps.fifo_threshold = true;
 		break;
 	default:
 		return -ENODEV;
@@ -1192,6 +1959,8 @@ void ltdc_suspend(struct drm_device *ddev)
 
 	DRM_DEBUG_DRIVER("\n");
 	clk_disable_unprepare(ldev->pixel_clk);
+	if (ldev->bus_clk)
+		clk_disable_unprepare(ldev->bus_clk);
 }
 
 int ltdc_resume(struct drm_device *ddev)
@@ -1206,6 +1975,12 @@ int ltdc_resume(struct drm_device *ddev)
 		DRM_ERROR("failed to enable pixel clock (%d)\n", ret);
 		return ret;
 	}
+	if (ldev->bus_clk) {
+		if (clk_prepare_enable(ldev->bus_clk)) {
+			DRM_ERROR("Unable to prepare bus clock\n");
+			return -ENODEV;
+		}
+	}
 
 	return 0;
 }
@@ -1220,9 +1995,9 @@ int ltdc_load(struct drm_device *ddev)
 	struct drm_panel *panel;
 	struct drm_crtc *crtc;
 	struct reset_control *rstc;
-	struct resource *res;
 	int irq, i, nb_endpoints;
 	int ret = -ENODEV;
+	u32 mbl;
 
 	DRM_DEBUG_DRIVER("\n");
 
@@ -1231,6 +2006,14 @@ int ltdc_load(struct drm_device *ddev)
 	if (!nb_endpoints)
 		return -ENODEV;
 
+	/* Get LTDC max burst length */
+	ret = of_property_read_u32(np, "st,burstlen", &mbl);
+	if (ret)
+		/* set to max burst length value */
+		ldev->max_burst_length = 0;
+	else
+		ldev->max_burst_length = mbl / 8;
+
 	ldev->pixel_clk = devm_clk_get(dev, "lcd");
 	if (IS_ERR(ldev->pixel_clk)) {
 		if (PTR_ERR(ldev->pixel_clk) != -EPROBE_DEFER)
@@ -1238,11 +2021,25 @@ int ltdc_load(struct drm_device *ddev)
 		return PTR_ERR(ldev->pixel_clk);
 	}
 
+	ldev->bus_clk = devm_clk_get(dev, "bus");
+	if (IS_ERR(ldev->bus_clk)) {
+		if (PTR_ERR(ldev->bus_clk) != -EPROBE_DEFER)
+			DRM_DEBUG_DRIVER("Unable to get bus clock\n");
+		ldev->bus_clk = NULL;
+	}
+
 	if (clk_prepare_enable(ldev->pixel_clk)) {
 		DRM_ERROR("Unable to prepare pixel clock\n");
 		return -ENODEV;
 	}
 
+	if (ldev->bus_clk) {
+		if (clk_prepare_enable(ldev->bus_clk)) {
+			DRM_ERROR("Unable to prepare bus clock\n");
+			return -ENODEV;
+		}
+	}
+
 	/* Get endpoints if any */
 	for (i = 0; i < nb_endpoints; i++) {
 		ret = drm_of_find_panel_or_bridge(np, 0, i, &panel, &bridge);
@@ -1287,17 +2084,30 @@ int ltdc_load(struct drm_device *ddev)
 		reset_control_deassert(rstc);
 	}
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	ldev->regs = devm_ioremap_resource(dev, res);
+	ldev->regs = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(ldev->regs)) {
 		DRM_ERROR("Unable to get ltdc registers\n");
 		ret = PTR_ERR(ldev->regs);
 		goto err;
 	}
 
-	/* Disable interrupts */
-	reg_clear(ldev->regs, LTDC_IER,
-		  IER_LIE | IER_RRIE | IER_FUIE | IER_TERRIE);
+	ldev->regmap = devm_regmap_init_mmio(&pdev->dev, ldev->regs, &stm32_ltdc_regmap_cfg);
+	if (IS_ERR(ldev->regmap)) {
+		DRM_ERROR("Unable to regmap ltdc registers\n");
+		ret = PTR_ERR(ldev->regmap);
+		goto err;
+	}
+
+	/* Get sysconf mapping registers */
+	ldev->syscon_regmap = syscon_regmap_lookup_by_phandle(np, "st,syscon");
+	if (IS_ERR(ldev->syscon_regmap)) {
+		DRM_DEBUG_DRIVER("Can't get sysconfig mapping\n");
+		ldev->syscon_regmap = NULL;
+	}
+
+	/* set display clock muxer by default on DPI clock source */
+	if (ldev->syscon_regmap)
+		regmap_write(ldev->syscon_regmap, SYSCFG_DISPLAYCLKCR, DISPLAYCLKCR_DPI);
 
 	ret = ltdc_get_caps(ddev);
 	if (ret) {
@@ -1306,8 +2116,22 @@ int ltdc_load(struct drm_device *ddev)
 		goto err;
 	}
 
+	/* Disable interrupts */
+	if (ldev->caps.fifo_threshold)
+		regmap_clear_bits(ldev->regmap, LTDC_IER, IER_LIE | IER_RRIE | IER_FUWIE |
+				  IER_TERRIE);
+	else
+		regmap_clear_bits(ldev->regmap, LTDC_IER, IER_LIE | IER_RRIE | IER_FUWIE |
+				  IER_TERRIE | IER_FUEIE);
+
 	DRM_DEBUG_DRIVER("ltdc hw version 0x%08x\n", ldev->caps.hw_version);
 
+	/* initialize default value for fifo underrun threshold & clear interrupt error counters */
+	ldev->transfer_err = 0;
+	ldev->fifo_err = 0;
+	ldev->fifo_warn = 0;
+	ldev->fifo_threshold = FUT_DFT;
+
 	for (i = 0; i < ldev->caps.nb_irq; i++) {
 		irq = platform_get_irq(pdev, i);
 		if (irq < 0) {
@@ -1322,7 +2146,6 @@ int ltdc_load(struct drm_device *ddev)
 			DRM_ERROR("Failed to register LTDC interrupt\n");
 			goto err;
 		}
-
 	}
 
 	crtc = devm_kzalloc(dev, sizeof(*crtc), GFP_KERNEL);
@@ -1345,6 +2168,8 @@ int ltdc_load(struct drm_device *ddev)
 	}
 
 	clk_disable_unprepare(ldev->pixel_clk);
+	if (ldev->bus_clk)
+		clk_disable_unprepare(ldev->bus_clk);
 
 	pinctrl_pm_select_sleep_state(ddev->dev);
 
@@ -1356,6 +2181,8 @@ int ltdc_load(struct drm_device *ddev)
 		drm_of_panel_bridge_remove(ddev->dev->of_node, 0, i);
 
 	clk_disable_unprepare(ldev->pixel_clk);
+	if (ldev->bus_clk)
+		clk_disable_unprepare(ldev->bus_clk);
 
 	return ret;
 }
diff --git a/drivers/gpu/drm/stm/ltdc.h b/drivers/gpu/drm/stm/ltdc.h
index f153b908c..77679c167 100644
--- a/drivers/gpu/drm/stm/ltdc.h
+++ b/drivers/gpu/drm/stm/ltdc.h
@@ -14,12 +14,23 @@
 struct ltdc_caps {
 	u32 hw_version;		/* hardware version */
 	u32 nb_layers;		/* number of supported layers */
-	u32 reg_ofs;		/* register offset for applicable regs */
+	u32 layer_ofs;		/* layer offset for applicable regs */
+	const u32 *layer_regs;	/* layer register offset */
 	u32 bus_width;		/* bus width (32 or 64 bits) */
-	const u32 *pix_fmt_hw;	/* supported pixel formats */
+	const u32 *pix_fmt_hw;	/* supported hw pixel formats */
+	const u32 *pix_fmt_drm;	/* supported drm pixel formats */
+	int pix_fmt_nb;		/* number of pixel format */
+	bool pix_fmt_flex;	/* pixel format flexibility supported */
 	bool non_alpha_only_l1; /* non-native no-alpha formats on layer 1 */
 	int pad_max_freq_hz;	/* max frequency supported by pad */
 	int nb_irq;		/* number of hardware interrupts */
+	bool ycbcr_input;	/* ycbcr input converter supported */
+	bool ycbcr_output;	/* ycbcr output converter supported */
+	bool plane_reg_shadow;	/* plane shadow registers ability */
+	bool crc;		/* cyclic redundancy check supported */
+	bool dynamic_zorder;	/* dynamic z-order */
+	bool plane_rotation;	/* plane rotation */
+	bool fifo_threshold;	/* fifo underrun threshold supported */
 };
 
 #define LTDC_MAX_LAYER	4
@@ -31,13 +42,22 @@ struct fps_info {
 
 struct ltdc_device {
 	void __iomem *regs;
+	struct regmap *regmap;
 	struct clk *pixel_clk;	/* lcd pixel clock */
-	struct mutex err_lock;	/* protecting error_status */
+	struct clk *bus_clk;	/* bus clock */
+	struct mutex err_lock;	/* protecting transfer_err, fifo_err, fifo_warn */
+	u32 transfer_err;	/* transfer error counter */
+	u32 fifo_err;		/* fifo underrun error counter */
+	u32 fifo_warn;		/* fifo underrun warning counter */
+	u32 fifo_threshold;	/* fifo underrun threshold */
 	struct ltdc_caps caps;
-	u32 error_status;
 	u32 irq_status;
 	struct fps_info plane_fpsi[LTDC_MAX_LAYER];
 	struct drm_atomic_state *suspend_state;
+	int crc_skip_count;
+	bool crc_active;
+	struct regmap *syscon_regmap;
+	u32 max_burst_length;
 };
 
 int ltdc_load(struct drm_device *ddev);
diff --git a/drivers/gpu/drm/stm/lvds.c b/drivers/gpu/drm/stm/lvds.c
new file mode 100644
index 000000000..5d3aa3469
--- /dev/null
+++ b/drivers/gpu/drm/stm/lvds.c
@@ -0,0 +1,1152 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ * Author(s): Raphaël GALLAIS-POU <raphael.gallais-pou@foss.st.com> for STMicroelectronics.
+ */
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_device.h>
+#include <drm/drm_of.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_print.h>
+#include <drm/drm_probe_helper.h>
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+
+/* LVDS Host registers */
+#define LVDS_CR		0x0000  /* configuration register */
+#define LVDS_DMLCR0	0x0004  /* data mapping lsb configuration register 0	*/
+#define LVDS_DMMCR0	0x0008  /* data mapping msb configuration register 0	*/
+#define LVDS_DMLCR1	0x000C  /* data mapping lsb configuration register 1	*/
+#define LVDS_DMMCR1	0x0010  /* data mapping msb configuration register 1	*/
+#define LVDS_DMLCR2	0x0014  /* data mapping lsb configuration register 2	*/
+#define LVDS_DMMCR2	0x0018  /* data mapping msb configuration register 2	*/
+#define LVDS_DMLCR3	0x001C  /* data mapping lsb configuration register 3	*/
+#define LVDS_DMMCR3	0x0020  /* data mapping msb configuration register 3	*/
+#define LVDS_DMLCR4	0x0024  /* data mapping lsb configuration register 4	*/
+#define LVDS_DMMCR4	0x0028  /* data mapping msb configuration register 4	*/
+#define LVDS_CDL1CR	0x002C  /* channel distrib link 1 configuration register	*/
+#define LVDS_CDL2CR	0x0030  /* channel distrib link 2 configuration register	*/
+
+/* LVDS Wrapper registers */
+#define LVDS_WCLKCR	0x11B0  /* Wrapper clock control register */
+
+#define LVDS_HWCFGR	0x1FF0  /* HW configuration register	*/
+#define LVDS_VERR	0x1FF4  /* Version register	*/
+#define LVDS_IPIDR	0x1FF8  /* Identification register	*/
+#define LVDS_SIDR	0x1FFC  /* Size Identification register	*/
+
+#define CR_LVDSEN	BIT(0)  /* LVDS PHY Enable */
+#define CR_HSPOL	BIT(1)  /* HS Polarity (horizontal sync) */
+#define CR_VSPOL	BIT(2)  /* VS Polarity (vertical sync) */
+#define CR_DEPOL	BIT(3)  /* DE Polarity (data enable) */
+#define CR_CI		BIT(4)  /* Control Internal (software controlled bit) */
+#define CR_LKMOD	BIT(5)  /* Link Mode, for both Links */
+#define CR_LKPHA	BIT(6)  /* Link Phase, for both Links */
+#define CR_LK1POL	GENMASK(20, 16)  /* Link-1 output Polarity */
+#define CR_LK2POL	GENMASK(25, 21)  /* Link-2 output Polarity */
+
+#define DMMCRx_MAP0	GENMASK(4, 0)
+#define DMMCRx_MAP1	GENMASK(9, 5)
+#define DMMCRx_MAP2	GENMASK(14, 10)
+#define DMMCRx_MAP3	GENMASK(19, 15)
+#define DMLCRx_MAP4	GENMASK(4, 0)
+#define DMLCRx_MAP5	GENMASK(9, 5)
+#define DMLCRx_MAP6	GENMASK(14, 10)
+
+#define CDLCRx_DISTR0	GENMASK(3, 0)
+#define CDLCRx_DISTR1	GENMASK(7, 4)
+#define CDLCRx_DISTR2	GENMASK(11, 8)
+#define CDLCRx_DISTR3	GENMASK(15, 12)
+#define CDLCRx_DISTR4	GENMASK(19, 16)
+
+#define FREF_INDEX	0
+#define NDIV_INDEX	1
+#define FPFD_INDEX	2
+#define MDIV_INDEX	3
+#define FVCO_INDEX	4
+#define BDIV_INDEX	5
+#define FBIT_INDEX	6
+#define FLS_INDEX	7
+#define FDP_INDEX	8
+
+#define PHY_GCR_BIT_CLK_OUT	BIT(0)
+#define PHY_GCR_LS_CLK_OUT	BIT(4)
+#define PHY_GCR_DP_CLK_OUT	BIT(8)
+#define PHY_GCR_RSTZ		BIT(24)
+#define PHY_GCR_DIV_RSTN	BIT(25)
+
+#define PHY_PxPLLTESTCR_TDIV	GENMASK(25, 16)
+#define PHY_PxPLLCR2_NDIV	GENMASK(25, 16)
+#define PHY_PxPLLCR2_BDIV	GENMASK(9, 0)
+#define PHY_PxPLLSDCR1_MDIV	GENMASK(9, 0)
+
+#define PLL_EN		BIT(0)
+#define PLL_LOCK	BIT(0)
+#define CM_EN_DL	(BIT(28) | BIT(20) | BIT(12) | BIT(4))
+#define CM_EN_DL4	BIT(4)
+#define VM_EN_DL	(BIT(16) | BIT(12) | BIT(8) | BIT(4) | BIT(0))
+#define EN_BIAS_DL	(BIT(16) | BIT(12) | BIT(8) | BIT(4) | BIT(0))
+#define EN_DIG_DL	GENMASK(4, 0)
+#define BIAS_EN		BIT(28)
+#define POWER_OK	BIT(12)
+
+#define WCLKCR_SLV_CLKPIX_SEL	BIT(0)
+#define WCLKCR_SRCSEL		BIT(8)
+
+/* Sleep & timeout for pll lock/unlock */
+#define SLEEP_US	1000
+#define TIMEOUT_US	20000000
+
+#define PHY_SLV_OFS	0x100
+
+/*
+ * The link phase defines whether an ODD pixel is carried over together with
+ * the next EVEN pixel or together with the previous EVEN pixel.
+ *
+ * LVDS_DUAL_LINK_EVEN_ODD_PIXELS (LKPHA = 0)
+ *
+ * ,--------.  ,--------.  ,--------.  ,--------.  ,---------.
+ * | ODD  LK \/ PIXEL  3 \/ PIXEL  1 \/ PIXEL' 1 \/ PIXEL' 3 |
+ * | EVEN LK /\ PIXEL  2 /\ PIXEL' 0 /\ PIXEL' 2 /\ PIXEL' 4 |
+ * `--------'  `--------'  `--------'  `--------'  `---------'
+ *
+ * LVDS_DUAL_LINK_ODD_EVEN_PIXELS (LKPHA = 1)
+ *
+ * ,--------.  ,--------.  ,--------.  ,--------.  ,---------.
+ * | ODD  LK \/ PIXEL  3 \/ PIXEL  1 \/ PIXEL' 1 \/ PIXEL' 3 |
+ * | EVEN LK /\ PIXEL  4 /\ PIXEL  2 /\ PIXEL' 0 /\ PIXEL' 2 |
+ * `--------'  `--------'  `--------'  `--------'  `---------'
+ *
+ */
+enum lvds_link_type {
+	LVDS_SINGLE_LINK_MASTER = 0,
+	LVDS_SINGLE_LINK_SLAVE = 1,
+	LVDS_DUAL_LINK_EVEN_ODD_PIXELS = 2,
+	LVDS_DUAL_LINK_ODD_EVEN_PIXELS = 3,
+};
+
+enum lvds_pixel {
+	PIX_R_0		= 0x00,
+	PIX_R_1		= 0x01,
+	PIX_R_2		= 0x02,
+	PIX_R_3		= 0x03,
+	PIX_R_4		= 0x04,
+	PIX_R_5		= 0x05,
+	PIX_R_6		= 0x06,
+	PIX_R_7		= 0x07,
+	PIX_G_0		= 0x08,
+	PIX_G_1		= 0x09,
+	PIX_G_2		= 0x0A,
+	PIX_G_3		= 0x0B,
+	PIX_G_4		= 0x0C,
+	PIX_G_5		= 0x0D,
+	PIX_G_6		= 0x0E,
+	PIX_G_7		= 0x0F,
+	PIX_B_0		= 0x10,
+	PIX_B_1		= 0x11,
+	PIX_B_2		= 0x12,
+	PIX_B_3		= 0x13,
+	PIX_B_4		= 0x14,
+	PIX_B_5		= 0x15,
+	PIX_B_6		= 0x16,
+	PIX_B_7		= 0x17,
+	PIX_H_S		= 0x18,
+	PIX_V_S		= 0x19,
+	PIX_D_E		= 0x1A,
+	PIX_C_E		= 0x1B,
+	PIX_C_I		= 0x1C,
+	PIX_TOG		= 0x1D,
+	PIX_ONE		= 0x1E,
+	PIX_ZER		= 0x1F,
+};
+
+struct phy_offsets {
+	u32 PxGCR;	/* Global Control Register	*/
+	u32 PxCMCR1;    /* Current Mode Control Register 1 */
+	u32 PxCMCR2;    /* Current Mode Control Register 2 */
+	u32 PxSCR;      /* Serial Control Register	*/
+	u32 PxBCR1;     /* Bias Control Register 1	*/
+	u32 PxBCR2;     /* Bias Control Register 2	*/
+	u32 PxBCR3;     /* Bias Control Register 3	*/
+	u32 PxMPLCR;    /* Monitor PLL Lock Control Register */
+	u32 PxDCR;      /* Debug Control Register	*/
+	u32 PxSSR1;     /* Spare Status Register 1	*/
+	u32 PxCFGCR;    /* Configuration Control Register */
+	u32 PxPLLCR1;   /* PLL_MODE 1 Control Register	*/
+	u32 PxPLLCR2;   /* PLL_MODE 2 Control Register	*/
+	u32 PxPLLSR;    /* PLL Status Register	*/
+	u32 PxPLLSDCR1; /* PLL_SD_1 Control Register	*/
+	u32 PxPLLSDCR2; /* PLL_SD_2 Control Register	*/
+	u32 PxPLLTWGCR1;/* PLL_TWG_1 Control Register	*/
+	u32 PxPLLTWGCR2;/* PLL_TWG_2 Control Register	*/
+	u32 PxPLLCPCR;	/* PLL_CP Control Register	*/
+	u32 PxPLLTESTCR;/* PLL_TEST Control Register	*/
+};
+
+struct lvds_phy_info {
+	u32 base;
+	struct phy_offsets ofs;
+};
+
+static struct lvds_phy_info lvds_phy_16ff_master = {
+	.base = 0x1000,
+	.ofs = {
+		.PxGCR = 0x0,
+		.PxCMCR1 = 0xC,
+		.PxCMCR2 = 0x10,
+		.PxSCR = 0x20,
+		.PxBCR1 = 0x2C,
+		.PxBCR2 = 0x30,
+		.PxBCR3 = 0x34,
+		.PxMPLCR = 0x64,
+		.PxDCR = 0x84,
+		.PxSSR1 = 0x88,
+		.PxCFGCR = 0xA0,
+		.PxPLLCR1 = 0xC0,
+		.PxPLLCR2 = 0xC4,
+		.PxPLLSR = 0xC8,
+		.PxPLLSDCR1 = 0xCC,
+		.PxPLLSDCR2 = 0xD0,
+		.PxPLLTWGCR1 = 0xD4,
+		.PxPLLTWGCR2 = 0xD8,
+		.PxPLLCPCR = 0xE0,
+		.PxPLLTESTCR = 0xE8,
+	}
+};
+
+static struct lvds_phy_info lvds_phy_16ff_slave = {
+	.base = 0x1100,
+	.ofs = {
+		.PxGCR = 0x0,
+		.PxCMCR1 = 0xC,
+		.PxCMCR2 = 0x10,
+		.PxSCR = 0x20,
+		.PxBCR1 = 0x2C,
+		.PxBCR2 = 0x30,
+		.PxBCR3 = 0x34,
+		.PxMPLCR = 0x64,
+		.PxDCR = 0x84,
+		.PxSSR1 = 0x88,
+		.PxCFGCR = 0xA0,
+		.PxPLLCR1 = 0xC0,
+		.PxPLLCR2 = 0xC4,
+		.PxPLLSR = 0xC8,
+		.PxPLLSDCR1 = 0xCC,
+		.PxPLLSDCR2 = 0xD0,
+		.PxPLLTWGCR1 = 0xD4,
+		.PxPLLTWGCR2 = 0xD8,
+		.PxPLLCPCR = 0xE0,
+		.PxPLLTESTCR = 0xE8,
+	}
+};
+
+struct lvds_clk_data {
+	const char *clk_name;
+	const struct clk_ops *clk_ops;
+	const char * const *clk_src;
+	unsigned int max_clk_src;
+};
+
+struct stm_lvds {
+	void __iomem *base;
+	struct device *dev;
+	struct clk *pclk;		/* APB bus clock */
+	struct clk *pllref_clk;		/* HSE / Flexclkgen */
+	struct clk_hw lvds_ck_px;	/*  Pixel clock  */
+	struct {
+		u32 hw_version;
+		u32 link_type;
+	} config;
+	struct lvds_phy_info *phy_master;
+	struct lvds_phy_info *phy_slave;
+
+	struct drm_bridge	lvds_bridge;
+	struct drm_bridge	*next_bridge;
+	struct drm_connector	connector;
+	struct drm_encoder	*encoder;
+	struct drm_panel	*panel;
+};
+
+#define bridge_to_stm_lvds(b) \
+	container_of(b, struct stm_lvds, lvds_bridge)
+
+#define connector_to_stm_lvds(c) \
+	container_of(c, struct stm_lvds, connector)
+
+static inline void lvds_write(struct stm_lvds *lvds, u32 reg, u32 val)
+{
+	writel(val, lvds->base + reg);
+}
+
+static inline u32 lvds_read(struct stm_lvds *lvds, u32 reg)
+{
+	return readl(lvds->base + reg);
+}
+
+static inline void lvds_set(struct stm_lvds *lvds, u32 reg, u32 mask)
+{
+	lvds_write(lvds, reg, lvds_read(lvds, reg) | mask);
+}
+
+static inline void lvds_clear(struct stm_lvds *lvds, u32 reg, u32 mask)
+{
+	lvds_write(lvds, reg, lvds_read(lvds, reg) & ~mask);
+}
+
+static inline void lvds_update_bits(struct stm_lvds *lvds, u32 reg,
+				    u32 mask, u32 val)
+{
+	lvds_write(lvds, reg, (lvds_read(lvds, reg) & ~mask) | val);
+}
+
+/*
+ * Expected JEIDA-RGB888 data to be sent in LSB format
+ *	    bit6 ............................bit0
+ * CHAN0   {ONE, ONE, ZERO, ZERO, ZERO, ONE, ONE}
+ * CHAN1   {G2,  R7,  R6,   R5,   R4,   R3,  R2}
+ * CHAN2   {B3,  B2,  G7,   G6,   G5,   G4,  G3}
+ * CHAN3   {DE,  VS,  HS,   B7,   B6,   B5,  B4}
+ * CHAN4   {CE,  B1,  B0,   G1,   G0,   R1,  R0}
+ */
+const enum lvds_pixel lvds_bitmap_jeida_rgb888[5][7] = {
+	{
+		PIX_ONE, PIX_ONE, PIX_ZER, PIX_ZER, PIX_ZER, PIX_ONE, PIX_ONE
+	}, {
+		PIX_G_2, PIX_R_7, PIX_R_6, PIX_R_5, PIX_R_4, PIX_R_3, PIX_R_2
+	}, {
+		PIX_B_3, PIX_B_2, PIX_G_7, PIX_G_6, PIX_G_5, PIX_G_4, PIX_G_3
+	}, {
+		PIX_D_E, PIX_V_S, PIX_H_S, PIX_B_7, PIX_B_6, PIX_B_5, PIX_B_4
+	}, {
+		PIX_C_E, PIX_B_1, PIX_B_0, PIX_G_1, PIX_G_0, PIX_R_1, PIX_R_0
+	}
+};
+
+/*
+ * Expected VESA-RGB888 data to be sent in LSB format
+ *	    bit6 ............................bit0
+ * CHAN0   {ONE, ONE, ZERO, ZERO, ZERO, ONE, ONE}
+ * CHAN1   {G0,  R5,  R4,   R3,   R2,   R1,  R0}
+ * CHAN2   {B1,  B0,  G5,   G4,   G3,   G2,  G1}
+ * CHAN3   {DE,  VS,  HS,   B5,   B4,   B3,  B2}
+ * CHAN4   {CE,  B7,  B6,   G7,   G6,   R7,  R6}
+ */
+const enum lvds_pixel lvds_bitmap_vesa_rgb888[5][7] = {
+	{
+		PIX_ONE, PIX_ONE, PIX_ZER, PIX_ZER, PIX_ZER, PIX_ONE, PIX_ONE
+	}, {
+		PIX_G_0, PIX_R_5, PIX_R_4, PIX_R_3, PIX_R_2, PIX_R_1, PIX_R_0
+	}, {
+		PIX_B_1, PIX_B_0, PIX_G_5, PIX_G_4, PIX_G_3, PIX_G_2, PIX_G_1
+	}, {
+		PIX_D_E, PIX_V_S, PIX_H_S, PIX_B_5, PIX_B_4, PIX_B_3, PIX_B_2
+	}, {
+		PIX_C_E, PIX_B_7, PIX_B_6, PIX_G_7, PIX_G_6, PIX_R_7, PIX_R_6
+	}
+};
+
+static int lvds_pll_enable(struct stm_lvds *lvds, struct lvds_phy_info *phy)
+{
+	u32 lvds_gcr;
+	int ret, val;
+
+	/* PLL lock timing control for the monitor unmask after startup (pll_en) */
+	/* Adjust the value so that the masking window is opened at start-up */
+	/* MST_MON_PLL_LOCK_UNMASK_TUNE */
+	lvds_write(lvds, phy->base + phy->ofs.PxMPLCR, (0x200 - 0x160) << 16);
+
+	lvds_write(lvds, phy->base + phy->ofs.PxBCR2, BIAS_EN);
+
+	lvds_gcr = PHY_GCR_DP_CLK_OUT | PHY_GCR_LS_CLK_OUT | PHY_GCR_BIT_CLK_OUT;
+	lvds_set(lvds, phy->base + phy->ofs.PxGCR, lvds_gcr);
+
+	/* TODO hardcoded values for now */
+	lvds_set(lvds, phy->base + phy->ofs.PxPLLTESTCR, BIT(8) /* PLL_TEST_DIV_EN */);
+	lvds_set(lvds, phy->base + phy->ofs.PxPLLCR1, BIT(8) /* PLL_DIVIDERS_ENABLE */);
+
+	lvds_set(lvds, phy->base + phy->ofs.PxSCR, BIT(16) /* SER_DATA_OK */);
+
+	/* Enable the LVDS PLL & wait for its lock */
+	lvds_set(lvds, phy->base + phy->ofs.PxPLLCR1, PLL_EN);
+	ret = readl_poll_timeout_atomic(lvds->base + phy->base + phy->ofs.PxPLLSR,
+					val, val & PLL_LOCK,
+					SLEEP_US, TIMEOUT_US);
+	if (ret)
+		DRM_ERROR("!TIMEOUT! waiting PLL, let's continue\n");
+
+	/* Select MST PHY clock as pixel clock for the LDITX instead of FREF */
+	/* WCLKCR_SLV_CLKPIX_SEL is for dual link */
+	lvds_write(lvds, LVDS_WCLKCR, WCLKCR_SLV_CLKPIX_SEL);
+
+	/* JF Duret */
+	lvds_set(lvds, phy->ofs.PxPLLTESTCR, BIT(0));
+
+	return ret;
+}
+
+/* Integer mode */
+#define EN_SD		0
+#define EN_TWG		0
+#define DOWN_SPREAD	0
+#define TEST_DIV	70
+/*
+ * OpenLDI standards
+ *
+ * fREF,  NDIV, fPFD,  MDIV, fVCO,  BDIV, fBIT,  fLS,   fDP
+ * [kHz], [],   [kHz], [],   [kHz], [],   [kHz], [kHz], [kHz]
+ */
+static int pll_setup[8][9] = {
+	{24000, 6, 4000, 539, 2156000, 2, 1078000, 154000, 308000},
+	{24000, 8, 3000, 693, 2079000, 2, 1039500, 148500, 297000},
+	{24000, 8, 3000, 693, 2079000, 4, 519750, 74250, 148500},
+	{24000, 6, 4000, 539, 2156000, 16, 134750, 19250, 38500},
+	{24000, 3, 8000, 280, 2240000, 2, 1120000, 160000, 320000},
+	{20000, 4, 5000, 409, 2450000, 6, 340833, 48690, 97381},
+	{20000, 4, 5000, 600, 3000000, 3, 1000000, 142857, 285714},
+	{26600, 4, 6650, 625, 4156250, 4, 1039063, 148347, 296875}  //MODE PREFERRED for now
+};
+
+static int pll_get_clkout_khz(int clkin_khz, int bdiv, int mdiv, int ndiv)
+{
+	int divisor = ndiv * bdiv;
+
+	/* Prevents from division by 0 */
+	if (!divisor)
+		return 0;
+
+	return clkin_khz * mdiv / divisor;
+}
+
+static void lvds_pll_config(struct stm_lvds *lvds, struct lvds_phy_info *phy)
+{
+	/* Set PLL Slv & Mst configs and timings */
+	struct clk_hw *hwclk;
+	unsigned int pll_in_khz;
+	int i, config;
+
+	/*
+	 * The LVDS PLL is made of a pre-divider and a multiplier (strangely
+	 * enough called M and N respectively), followed by a post-divider E.
+	 *
+	 *          ,------.         ,-----.     ,-----.
+	 * Fref --> | NDIV | -Fpdf-> | PFD | --> | VCO | --> Fvco
+	 *          `------'     ,-> |     |     `-----'  |
+	 *                       |   `-----'              |
+	 *                       |         ,------.       |
+	 *                       `-------- | MDIV | <-----'
+	 *                                 `------'
+	 *
+	 * The clock output by the PLL is then further divided by a programmable
+	 * divider DIV to achieve the desired target frequency. Finally, an
+	 * optional fixed /7 divider is used to convert the bit clock to a pixel
+	 * clock (as LVDS transmits 7 bits per lane per clock sample).
+	 *
+	 *          ,------.     ,-----.     ,-------.     |\
+	 * Fvco --> | BDIV | --> | 1/7 | --> | 1/3.5 | --> | |
+	 *          `------'  |  `-----'     `-------'     | | --> dot clock
+	 *                    `--------------------------> | |
+	 *                                                 |/
+	 *
+	 * The /7 divider is optional, it is enabled when the LVDS PLL is used
+	 * to drive the LVDS encoder, and disabled when used to generate a dot
+	 * clock for the display unit RGB output, without using the LVDS
+	 * encoder.
+	 *
+	 * The PLL allowed input frequency range is 12 MHz to 192 MHz.
+	 */
+
+	/* TODO resolv blocking subroutine */
+	hwclk = __clk_get_hw(lvds->pllref_clk);
+	if (!hwclk)
+		return;
+
+	pll_in_khz = clk_hw_get_rate(hwclk) / 1000;
+
+	for (i = 0; i < ARRAY_SIZE(pll_setup); i++) {
+		if (pll_setup[i][FREF_INDEX] != pll_in_khz)
+			continue;
+		else
+			config = i;
+	}
+
+	/* MST_PLL_INPUT_DIV */
+	lvds_write(lvds, phy->base + phy->ofs.PxPLLCR2, pll_setup[config][NDIV_INDEX] << 16);
+	/* MST_PLL_BIT_DIV */
+	lvds_set(lvds, phy->base + phy->ofs.PxPLLCR2, pll_setup[config][BDIV_INDEX] << 0);
+	/* MST_PLL_SD_INT_RATIO */
+	lvds_write(lvds, phy->base + phy->ofs.PxPLLSDCR1, pll_setup[config][MDIV_INDEX] << 0);
+	/* MST_PLL_TEST_DIV_SETTINGS */
+	lvds_write(lvds, phy->base + phy->ofs.PxPLLTESTCR, TEST_DIV << 16);
+
+	/*
+	 * PLL integer mode:
+	 *	- MST_PLL_TWG_STEP = MST_PLL_SD_INT_RATIO
+	 *	- EN_TWG = 0
+	 *	- EN_SD = 0
+	 *	- DOWN_SPREAD = 0
+	 *
+	 * PLL fractional mode:
+	 *	- EN_TWG = 0
+	 *	- EN_SD = 1
+	 *	- DOWN_SPREAD = 0
+	 */
+
+	/* For now, PLL just need to be in integer mode */
+	lvds_clear(lvds, phy->base + phy->ofs.PxPLLCR1, EN_TWG | EN_SD); /* Disable TWG and SD */
+
+	/* Power up bias and PLL dividers */
+	lvds_set(lvds, phy->base + phy->ofs.PxDCR, POWER_OK);
+
+	lvds_set(lvds, phy->base + phy->ofs.PxCMCR1, CM_EN_DL);
+	lvds_set(lvds, phy->base + phy->ofs.PxCMCR2, CM_EN_DL4);
+
+	/* JF Duret */
+	lvds_set(lvds, phy->base + phy->ofs.PxPLLCPCR, 0x1);
+
+	lvds_set(lvds, phy->base + phy->ofs.PxBCR3, VM_EN_DL);
+
+	lvds_set(lvds, phy->base + phy->ofs.PxBCR1, EN_BIAS_DL);
+
+	lvds_set(lvds, phy->base + phy->ofs.PxCFGCR, EN_DIG_DL);
+}
+
+/* TODO enhance & make clearer logic */
+static int lvds_pixel_clk_enable(struct clk_hw *hw)
+{
+	/* PLL enable here */
+	struct stm_lvds *lvds = container_of(hw, struct stm_lvds, lvds_ck_px);
+	struct lvds_phy_info *phy;
+	int ret;
+
+	/* TODO enable clock */
+	ret = clk_prepare_enable(lvds->pllref_clk);
+	if (ret) {
+		DRM_ERROR("%s: Failed to enable reference clk\n", __func__);
+		return ret;
+	}
+
+	/*
+	 * In case we are operating in dual link, PHY Slv is set before PHY
+	 * Mst.
+	 */
+	if (lvds->phy_slave) {
+		phy = lvds->phy_slave;
+
+		lvds_set(lvds, phy->base + phy->ofs.PxGCR, PHY_GCR_DIV_RSTN | PHY_GCR_RSTZ);
+		lvds_pll_config(lvds, phy);
+
+		ret = lvds_pll_enable(lvds, phy);
+		if (ret) {
+			DRM_ERROR("Unable to enable PHY PLL Slv: %d\n", ret);
+			return ret;
+		}
+	}
+
+	if (lvds->phy_master) {
+		phy = lvds->phy_master;
+
+		/* Release LVDS PHY from reset mode */
+		lvds_set(lvds, phy->base + phy->ofs.PxGCR, PHY_GCR_DIV_RSTN | PHY_GCR_RSTZ);
+		lvds_pll_config(lvds, phy);
+
+		ret = lvds_pll_enable(lvds, phy);
+		if (ret) {
+			DRM_ERROR("Unable to enable PHY PLL Mst: %d\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static void lvds_pixel_clk_disable(struct clk_hw *hw)
+{
+	/* PLL disable here */
+	struct stm_lvds *lvds = container_of(hw, struct stm_lvds, lvds_ck_px);
+
+	/* TODO Disable D-PHY clocks and digital */
+//	lvds_clear(lvds, lvds->phy_master->base + lvds->phy_master->ofs.PxGCR,
+//		   (PHY_GCR_DP_CLK_OUT | PHY_GCR_LS_CLK_OUT | PHY_GCR_BIT_CLK_OUT));
+
+	/* Assert LVDS PHY Master & Slave in reset mode */
+	if (lvds->phy_master)
+		lvds_clear(lvds, lvds->phy_master->base + lvds->phy_master->ofs.PxGCR,
+			   PHY_GCR_DIV_RSTN | PHY_GCR_RSTZ);
+
+	if (lvds->phy_slave)
+		lvds_clear(lvds, lvds->phy_slave->base + lvds->phy_slave->ofs.PxGCR,
+			   PHY_GCR_DIV_RSTN | PHY_GCR_RSTZ);
+}
+
+static unsigned long lvds_pixel_clk_recalc_rate(struct clk_hw *hw,
+						unsigned long parent_rate)
+{
+	struct stm_lvds *lvds = container_of(hw, struct stm_lvds, lvds_ck_px);
+	struct lvds_phy_info *phy = lvds->phy_master;
+	unsigned int bdiv, mdiv, ndiv, pll_in_khz, pll_out_khz;
+	u32 val;
+
+	pll_in_khz = (unsigned int)(parent_rate / 1000);
+
+	val = lvds_read(lvds, phy->base + phy->ofs.PxPLLCR2);
+
+	ndiv = (val & PHY_PxPLLCR2_NDIV) >> 16;
+	bdiv = (val & PHY_PxPLLCR2_BDIV) >> 0;
+
+	val = lvds_read(lvds, lvds->phy_master->base + lvds->phy_master->ofs.PxPLLSDCR1);
+	mdiv = val;
+
+	pll_out_khz = pll_get_clkout_khz(pll_in_khz, bdiv, mdiv, ndiv);
+
+	/* X7 because for each pixel in 1 lane there is 7 bits
+	 * We want pixclk, not bitclk
+	 */
+	return (unsigned long)pll_out_khz * 1000 / 7;
+}
+
+static const struct clk_ops lvds_pixel_clk_ops = {
+	.enable = lvds_pixel_clk_enable,
+	.disable = lvds_pixel_clk_disable,
+	.recalc_rate = lvds_pixel_clk_recalc_rate,
+};
+
+static const struct lvds_clk_data clk_data = {
+	.clk_name = "clk_pix_lvds",
+	.clk_ops = &lvds_pixel_clk_ops,
+	.clk_src = (const char * []) {"ck_ker_lvdsphy"},
+	.max_clk_src = 1,
+};
+
+static void lvds_pixel_clk_unregister(void *data)
+{
+	struct stm_lvds *lvds = data;
+
+	of_clk_del_provider(lvds->dev->of_node);
+	clk_hw_unregister(&lvds->lvds_ck_px);
+}
+
+static int lvds_pixel_clk_register(struct stm_lvds *lvds)
+{
+	struct device_node *node = lvds->dev->of_node;
+	struct clk_init_data init = {
+		.name = clk_data.clk_name,
+		.ops = clk_data.clk_ops,
+		.parent_names = clk_data.clk_src,
+		.num_parents = clk_data.max_clk_src,
+		.flags = CLK_IGNORE_UNUSED,
+	};
+	int ret;
+
+	lvds->lvds_ck_px.init = &init;
+
+	ret = clk_hw_register(lvds->dev, &lvds->lvds_ck_px);
+	if (ret)
+		return ret;
+
+	ret = of_clk_add_hw_provider(node, of_clk_hw_simple_get,
+				     &lvds->lvds_ck_px);
+	if (ret)
+		clk_hw_unregister(&lvds->lvds_ck_px);
+
+	return ret;
+}
+
+/* ------------------------------------------------------------------------- */
+static void lvds_config_data_mapping(struct stm_lvds *lvds)
+{
+	const struct drm_display_info *info;
+	u32 lvds_dmlcr[5], lvds_dmmcr[5]; /* 4 data lanes + 1 clk lane */
+	int i;
+
+	info = &(&lvds->connector)->display_info;
+	if (!info->num_bus_formats || !info->bus_formats)
+		dev_warn(lvds->dev, "No LVDS bus format reported\n");
+
+/*      Mode mirror : TODO
+ *      info->bus_flags & DRM_BUS_FLAG_DATA_LSB_TO_MSB
+ */
+
+	switch (info->bus_formats[0]) {
+	case MEDIA_BUS_FMT_RGB666_1X7X3_SPWG: /* VESA-RGB666 */
+		DRM_WARN("Pixel format with data mapping not yet compatible.\n");
+		break;
+	case MEDIA_BUS_FMT_RGB888_1X7X4_SPWG: /* VESA-RGB888 */
+		for (i = 0; i < 5; i++) {
+			lvds_dmlcr[i] = ((lvds_bitmap_vesa_rgb888[i][0])
+					 + (lvds_bitmap_vesa_rgb888[i][1] << 5)
+					 + (lvds_bitmap_vesa_rgb888[i][2] << 10)
+					 + (lvds_bitmap_vesa_rgb888[i][3] << 15));
+			lvds_dmmcr[i] = ((lvds_bitmap_vesa_rgb888[i][4])
+					 + (lvds_bitmap_vesa_rgb888[i][5] << 5)
+					 + (lvds_bitmap_vesa_rgb888[i][6] << 10));
+		}
+		break;
+	case MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA: /* JEIDA-RGB888 */
+		for (i = 0; i < 5; i++) {
+			lvds_dmlcr[i] = ((lvds_bitmap_jeida_rgb888[i][0])
+					+ (lvds_bitmap_jeida_rgb888[i][1] << 5)
+					+ (lvds_bitmap_jeida_rgb888[i][2] << 10)
+					+ (lvds_bitmap_jeida_rgb888[i][3] << 15));
+			lvds_dmmcr[i] = ((lvds_bitmap_jeida_rgb888[i][4])
+					+ (lvds_bitmap_jeida_rgb888[i][5] << 5)
+					+ (lvds_bitmap_jeida_rgb888[i][6] << 10));
+		}
+		break;
+	default:
+		dev_warn(lvds->dev, "Unsupported LVDS bus format 0x%04x\n",
+			 info->bus_formats[0]);
+	}
+
+	/* Write registers at the end of computations */
+	/* TODO use for loop */
+	lvds_write(lvds, LVDS_DMLCR0, lvds_dmlcr[0]);
+	lvds_write(lvds, LVDS_DMMCR0, lvds_dmmcr[0]);
+	lvds_write(lvds, LVDS_DMLCR1, lvds_dmlcr[1]);
+	lvds_write(lvds, LVDS_DMMCR1, lvds_dmmcr[1]);
+	lvds_write(lvds, LVDS_DMLCR2, lvds_dmlcr[2]);
+	lvds_write(lvds, LVDS_DMMCR2, lvds_dmmcr[2]);
+	lvds_write(lvds, LVDS_DMLCR3, lvds_dmlcr[3]);
+	lvds_write(lvds, LVDS_DMMCR3, lvds_dmmcr[3]);
+	lvds_write(lvds, LVDS_DMLCR4, lvds_dmlcr[4]);
+	lvds_write(lvds, LVDS_DMMCR4, lvds_dmmcr[4]);
+}
+
+static int lvds_config_mode(struct stm_lvds *lvds)
+{
+	const struct drm_display_mode *mode;
+	const struct drm_connector *connector;
+	u32 bus_flags, lvds_cr, lvds_cdl1cr, lvds_cdl2cr;
+
+	lvds_cr = 0;
+
+	connector = &lvds->connector;
+	if (!connector)
+		return -EINVAL;
+
+	if (list_empty(&connector->modes)) {
+		dev_dbg(lvds->dev, "connector: empty modes list\n");
+		return -EINVAL;
+	}
+
+	bus_flags = connector->display_info.bus_flags;
+	mode = list_first_entry(&connector->modes,
+				struct drm_display_mode, head);
+
+	lvds_clear(lvds, LVDS_CR, CR_LKMOD);
+	lvds_clear(lvds, LVDS_CDL1CR, CDLCRx_DISTR0 | CDLCRx_DISTR1 | CDLCRx_DISTR2
+					| CDLCRx_DISTR3 | CDLCRx_DISTR4);
+	lvds_clear(lvds, LVDS_CDL2CR, CDLCRx_DISTR0 | CDLCRx_DISTR1 | CDLCRx_DISTR2
+					| CDLCRx_DISTR3 | CDLCRx_DISTR4);
+
+	/* Set channel distribution */
+	/* TODO Hardcoded values for now */
+	if (lvds->phy_master)
+		lvds_cdl1cr = 0x4321;
+
+	if (lvds->phy_slave) {
+		lvds_cr |= CR_LKMOD;
+		lvds_cdl2cr = 0x98765;
+	}
+
+	/* Set signal polarity */
+	if (bus_flags & DRM_BUS_FLAG_DE_LOW)
+		lvds_cr |= CR_DEPOL;
+
+	if (mode->flags & DRM_MODE_FLAG_NHSYNC)
+		lvds_cr |= CR_HSPOL;
+
+	if (mode->flags & DRM_MODE_FLAG_NVSYNC)
+		lvds_cr |= CR_VSPOL;
+
+	switch (lvds->config.link_type) {
+	case LVDS_DUAL_LINK_EVEN_ODD_PIXELS: /* LKPHA = 0 */
+		lvds_cr &= ~CR_LKPHA;
+		break;
+	case LVDS_DUAL_LINK_ODD_EVEN_PIXELS: /* LKPHA = 1 */
+		lvds_cr |= CR_LKPHA;
+		break;
+	default:
+		dev_warn(lvds->dev, "No phase precised, setting default\n");
+		lvds_cr &= ~CR_LKPHA;
+		break;
+	}
+
+	/* Write config to registers */
+	lvds_set(lvds, LVDS_CR, lvds_cr);
+	lvds_write(lvds, LVDS_CDL1CR, lvds_cdl1cr);
+	lvds_write(lvds, LVDS_CDL2CR, lvds_cdl2cr);
+
+	/* Set Data Mapping */
+	lvds_config_data_mapping(lvds);
+
+	return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+static int lvds_connector_get_modes(struct drm_connector *connector)
+{
+	struct stm_lvds *lvds = connector_to_stm_lvds(connector);
+	int ret;
+
+	ret = drm_panel_get_modes(lvds->panel, connector);
+
+	return ret;
+}
+
+static int lvds_connector_atomic_check(struct drm_connector *connector,
+				       struct drm_atomic_state *state)
+{
+	struct stm_lvds *lvds = connector_to_stm_lvds(connector);
+	const struct drm_display_mode *panel_mode;
+	struct drm_connector_state *conn_state;
+	struct drm_crtc_state *crtc_state;
+
+	conn_state = drm_atomic_get_new_connector_state(state, connector);
+	if (!conn_state->crtc)
+		return 0;
+
+	if (list_empty(&connector->modes)) {
+		dev_dbg(lvds->dev, "connector: empty modes list\n");
+		return -EINVAL;
+	}
+
+	panel_mode = list_first_entry(&connector->modes,
+				      struct drm_display_mode, head);
+
+	/* We're not allowed to modify the resolution. */
+	crtc_state = drm_atomic_get_crtc_state(state, conn_state->crtc);
+	if (IS_ERR(crtc_state))
+		return PTR_ERR(crtc_state);
+
+	if (crtc_state->mode.hdisplay != panel_mode->hdisplay ||
+	    crtc_state->mode.vdisplay != panel_mode->vdisplay)
+		return -EINVAL;
+
+	/* The flat panel mode is fixed, just copy it to the adjusted mode. */
+	drm_mode_copy(&crtc_state->adjusted_mode, panel_mode);
+
+	return 0;
+}
+
+static const struct drm_connector_helper_funcs lvds_conn_helper_funcs = {
+	.get_modes = lvds_connector_get_modes,
+	.atomic_check = lvds_connector_atomic_check,
+};
+
+static const struct drm_connector_funcs lvds_conn_funcs = {
+	.reset = drm_atomic_helper_connector_reset,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = drm_connector_cleanup,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+/* ------------------------------------------------------------------------- */
+static int lvds_attach(struct drm_bridge *bridge,
+		       enum drm_bridge_attach_flags flags)
+{
+	struct stm_lvds *lvds = bridge_to_stm_lvds(bridge);
+	struct drm_connector *connector = &lvds->connector;
+	struct drm_encoder *encoder = bridge->encoder;
+	int ret = -ENODEV;
+
+	if (!bridge->encoder) {
+		DRM_ERROR("Parent encoder object not found\n");
+		return -ENODEV;
+	}
+
+	/* Set the encoder type as caller does not know it */
+	bridge->encoder->encoder_type = DRM_MODE_ENCODER_LVDS;
+
+	/* No cloning support */
+	bridge->encoder->possible_clones = 0;
+
+	/* If we have a next bridge just attach it. */
+	if (lvds->next_bridge)
+		return drm_bridge_attach(bridge->encoder, lvds->next_bridge,
+					 bridge, flags);
+
+	if (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR) {
+		DRM_ERROR("Fix bridge driver to make connector optional!");
+		return -EINVAL;
+	}
+
+	/* Otherwise if we have a panel, create a connector. */
+	if (!lvds->panel)
+		return 0;
+
+	ret = drm_connector_init(bridge->dev, connector,
+				 &lvds_conn_funcs, DRM_MODE_CONNECTOR_LVDS);
+	if (ret < 0)
+		return ret;
+
+	drm_connector_helper_add(connector, &lvds_conn_helper_funcs);
+
+	ret = drm_connector_attach_encoder(connector, encoder);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static void lvds_detach(struct drm_bridge *bridge)
+{}
+
+static void __lvds_atomic_enable(struct drm_bridge *bridge,
+				 struct drm_atomic_state *state,
+				 struct drm_crtc *crtc,
+				 struct drm_connector *connector)
+{
+	struct stm_lvds *lvds = bridge_to_stm_lvds(bridge);
+
+	lvds_config_mode(lvds);
+
+	/* Turn the output on. */
+	lvds_set(lvds, LVDS_CR, CR_LVDSEN);
+
+	if (lvds->panel) {
+		drm_panel_prepare(lvds->panel);
+		drm_panel_enable(lvds->panel);
+	}
+}
+
+static void lvds_atomic_enable(struct drm_bridge *bridge,
+			       struct drm_bridge_state *old_bridge_state)
+{
+	struct drm_atomic_state *state = old_bridge_state->base.state;
+	struct drm_connector *connector;
+	struct drm_crtc *crtc;
+
+	connector = drm_atomic_get_new_connector_for_encoder(state,
+							     bridge->encoder);
+	crtc = drm_atomic_get_new_connector_state(state, connector)->crtc;
+
+	__lvds_atomic_enable(bridge, state, crtc, connector);
+}
+
+static void lvds_atomic_disable(struct drm_bridge *bridge,
+				struct drm_bridge_state *old_bridge_state)
+{
+	struct stm_lvds *lvds = bridge_to_stm_lvds(bridge);
+
+	clk_disable((lvds->lvds_ck_px).clk);
+
+	if (lvds->panel) {
+		drm_panel_disable(lvds->panel);
+		drm_panel_unprepare(lvds->panel);
+	}
+
+	/* Check the LVDS handle allocation ? */
+
+	/* Disable LVDS module */
+	lvds_clear(lvds, LVDS_CR, CR_LVDSEN);
+
+	/* Shutdown the LVDS PLL */
+	/*
+	 * TODO: bug if PLL_EN cleared
+	 * Do NOT uncomment this line
+	 */
+	//lvds_clear(lvds, lvds->phy_master->base + lvds->phy_master->ofs.PxPLLCR1, PLL_EN);
+}
+
+static const struct drm_bridge_funcs lvds_bridge_funcs = {
+	.attach = lvds_attach,
+	.detach = lvds_detach,
+	.atomic_enable = lvds_atomic_enable,
+	.atomic_disable = lvds_atomic_disable,
+	.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,
+	.atomic_reset = drm_atomic_helper_bridge_reset,
+};
+
+/* ------------------------------------------------------------------------- */
+static int lvds_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *port1, *port2, *remote;
+	struct stm_lvds *lvds;
+	int ret, dual_link;
+
+	DRM_DEBUG_DRIVER("Probing LVDS driver...\n");
+
+	lvds = devm_kzalloc(dev, sizeof(*lvds), GFP_KERNEL);
+	if (!lvds)
+		return -ENOMEM;
+
+	lvds->dev = dev;
+
+	ret = drm_of_find_panel_or_bridge(lvds->dev->of_node, 1, 0,
+					  &lvds->panel, &lvds->next_bridge);
+	if (ret) {
+		DRM_ERROR("exit %d, @%d\n", ret, __LINE__);
+		return ret;
+	}
+
+	lvds->base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(lvds->base)) {
+		ret = PTR_ERR(lvds->base);
+		DRM_ERROR("Unable to get regs %d\n", ret);
+		return ret;
+	}
+
+	lvds->pclk = devm_clk_get(lvds->dev, "pclk");
+	if (IS_ERR(lvds->pclk)) {
+		ret = PTR_ERR(lvds->pclk);
+		DRM_ERROR("Unable to get peripheral clock: %d\n", ret);
+		goto err_lvds_probe;
+	}
+
+	ret = clk_prepare_enable(lvds->pclk);
+	if (ret) {
+		DRM_ERROR("%s: Failed to enable peripheral clk\n", __func__);
+		goto err_lvds_probe;
+	}
+
+	port1 = of_graph_get_port_by_id(dev->of_node, 1);
+	port2 = of_graph_get_port_by_id(dev->of_node, 2);
+	dual_link = drm_of_lvds_get_dual_link_pixel_order(port1, port2);
+
+	switch (dual_link) {
+	case DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS:
+		lvds->config.link_type = LVDS_DUAL_LINK_ODD_EVEN_PIXELS;
+		lvds->phy_master = &lvds_phy_16ff_master;
+		lvds->phy_slave = &lvds_phy_16ff_slave;
+		break;
+	case DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS:
+		lvds->config.link_type = LVDS_DUAL_LINK_EVEN_ODD_PIXELS;
+		lvds->phy_master = &lvds_phy_16ff_master;
+		lvds->phy_slave = &lvds_phy_16ff_slave;
+		break;
+	case -EINVAL:
+		/*
+		 * drm_of_lvds_get_dual_pixel_order returns 4 possible values.
+		 * In the case where the returned value is an error, it can be
+		 * either ENODEV or EINVAL. Seeing the structure of this
+		 * function, EINVAL means that either port1 or port2 is not
+		 * present in the device tree.
+		 * In that case, the lvds panel can be a single link panel, or
+		 * there is a semantical error in the device tree code.
+		 */
+		remote = of_get_next_available_child(port1, NULL);
+		if (remote) {
+			if (of_graph_get_remote_endpoint(remote)) {
+				lvds->config.link_type = LVDS_SINGLE_LINK_MASTER;
+				lvds->phy_master = &lvds_phy_16ff_master;
+				lvds->phy_slave = NULL;
+			} else {
+				ret = -EINVAL;
+			}
+
+			of_node_put(remote);
+		}
+
+		remote = of_get_next_available_child(port2, NULL);
+		if (remote) {
+			if (of_graph_get_remote_endpoint(remote)) {
+				lvds->config.link_type = LVDS_SINGLE_LINK_SLAVE;
+				lvds->phy_master = NULL;
+				lvds->phy_slave = &lvds_phy_16ff_slave;
+			} else {
+				ret = (ret == -EINVAL) ? -EINVAL : 0;
+			}
+
+			of_node_put(remote);
+		}
+		break;
+	default:
+		goto err_lvds_probe;
+	}
+	of_node_put(port1);
+	of_node_put(port2);
+
+	lvds->pllref_clk = devm_clk_get(lvds->dev, "ref");
+	if (IS_ERR(lvds->pllref_clk)) {
+		ret = PTR_ERR(lvds->pllref_clk);
+		DRM_ERROR("Unable to get reference clock: %d\n", ret);
+		goto err_lvds_probe;
+	}
+
+	ret = clk_prepare_enable(lvds->pllref_clk);
+	if (ret) {
+		DRM_ERROR("%s: Failed to enable reference clk\n", __func__);
+		goto err_lvds_probe;
+	}
+
+	ret = lvds_pixel_clk_register(lvds);
+	if (ret) {
+		DRM_ERROR("Failed to register LVDS pixel clock: %d\n", ret);
+		goto err_lvds_probe;
+	}
+
+	ret = clk_prepare_enable(lvds->lvds_ck_px.clk);
+	if (ret) {
+		DRM_ERROR("%s: Failed to enable reference clk\n", __func__);
+		goto err_lvds_probe;
+	}
+
+	lvds->lvds_bridge.funcs = &lvds_bridge_funcs;
+	lvds->lvds_bridge.of_node = dev->of_node;
+
+	drm_bridge_add(&lvds->lvds_bridge);
+
+	platform_set_drvdata(pdev, lvds);
+
+	/* TODO disable clocks */
+	return ret;
+
+err_lvds_probe:
+	clk_disable_unprepare(lvds->pclk);
+	clk_disable_unprepare(lvds->lvds_ck_px.clk);
+
+	return ret;
+}
+
+static int lvds_remove(struct platform_device *pdev)
+{
+	struct stm_lvds *lvds = platform_get_drvdata(pdev);
+
+	/* Disable all clocks */
+	lvds_pixel_clk_unregister(lvds);
+	clk_disable_unprepare(lvds->pclk);
+
+	/* Unregister LVDS bridge */
+	drm_bridge_remove(&lvds->lvds_bridge);
+
+	return 0;
+}
+
+static const struct of_device_id lvds_dt_ids[] = {
+	{
+		.compatible = "st,stm32-lvds",
+		.data = NULL
+	},
+	{ /* sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(of, lvds_dt_ids);
+
+static struct platform_driver lvds_platform_driver = {
+	.probe	  = lvds_probe,
+	.remove	 = lvds_remove,
+	.driver	 = {
+		.name   = "stm32-display-lvds",
+		.owner  = THIS_MODULE,
+		.of_match_table = lvds_dt_ids,
+/*    TODO ?    .pm = &lvds_pm_ops,*/
+	},
+};
+
+module_platform_driver(lvds_platform_driver);
+
+MODULE_AUTHOR("Raphaël Gallais-Pou <raphael.gallais-pou@foss.st.com>");
+MODULE_AUTHOR("Philippe Cornu <philippe.cornu@foss.st.com>");
+MODULE_AUTHOR("Yannick Fertre <yannick.fertre@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics LVDS Display Interface Transmitter DRM driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/hwspinlock/Kconfig b/drivers/hwspinlock/Kconfig
index 3874d15b0..c77b5a01e 100644
--- a/drivers/hwspinlock/Kconfig
+++ b/drivers/hwspinlock/Kconfig
@@ -38,7 +38,7 @@ config HWSPINLOCK_SPRD
 
 config HWSPINLOCK_STM32
 	tristate "STM32 Hardware Spinlock device"
-	depends on MACH_STM32MP157 || COMPILE_TEST
+	depends on ARCH_STM32 || COMPILE_TEST
 	help
 	  Say y here to support the STM32 Hardware Spinlock device.
 
diff --git a/drivers/hwspinlock/hwspinlock_core.c b/drivers/hwspinlock/hwspinlock_core.c
index fd5f5c5a5..a2197af89 100644
--- a/drivers/hwspinlock/hwspinlock_core.c
+++ b/drivers/hwspinlock/hwspinlock_core.c
@@ -29,6 +29,8 @@
 
 /* radix tree tags */
 #define HWSPINLOCK_UNUSED	(0) /* tags an hwspinlock as unused */
+#define HWSPINLOCK_EXCLUSIVE	(1) /* tags an hwspinlock as exclusive */
+#define HWSPINLOCK_SHARED	(2) /* tags an hwspinlock as shared */
 
 /*
  * A radix tree is used to maintain the available hwspinlock instances.
@@ -308,7 +310,7 @@ EXPORT_SYMBOL_GPL(__hwspin_unlock);
  * @hwlock_spec: hwlock specifier as found in the device tree
  *
  * This is a simple translation function, suitable for hwspinlock platform
- * drivers that only has a lock specifier length of 1.
+ * drivers that only has a lock specifier length of 1 or 2.
  *
  * Returns a relative index of the lock within a specified bank on success,
  * or -EINVAL on invalid specifier cell count.
@@ -316,7 +318,8 @@ EXPORT_SYMBOL_GPL(__hwspin_unlock);
 static inline int
 of_hwspin_lock_simple_xlate(const struct of_phandle_args *hwlock_spec)
 {
-	if (WARN_ON(hwlock_spec->args_count != 1))
+	if (WARN_ON(hwlock_spec->args_count != 1 &&
+		    hwlock_spec->args_count != 2))
 		return -EINVAL;
 
 	return hwlock_spec->args[0];
@@ -339,11 +342,12 @@ of_hwspin_lock_simple_xlate(const struct of_phandle_args *hwlock_spec)
 int of_hwspin_lock_get_id(struct device_node *np, int index)
 {
 	struct of_phandle_args args;
-	struct hwspinlock *hwlock;
+	struct hwspinlock *hwlock, *tmp;
 	struct radix_tree_iter iter;
 	void **slot;
 	int id;
 	int ret;
+	unsigned int tag;
 
 	ret = of_parse_phandle_with_args(np, "hwlocks", "#hwlock-cells", index,
 					 &args);
@@ -383,6 +387,37 @@ int of_hwspin_lock_get_id(struct device_node *np, int index)
 	}
 	id += hwlock->bank->base_id;
 
+	/* Set the EXCLUSIVE / SHARED tag */
+	if (args.args_count == 2 && args.args[1]) {
+		/* Tag SHARED unless already tagged EXCLUSIVE */
+		if (radix_tree_tag_get(&hwspinlock_tree, id,
+				       HWSPINLOCK_EXCLUSIVE)) {
+			ret = -EINVAL;
+			goto out;
+		}
+		tag = HWSPINLOCK_SHARED;
+	} else {
+		/* Tag EXCLUSIVE unless already tagged SHARED */
+		if (radix_tree_tag_get(&hwspinlock_tree, id,
+				       HWSPINLOCK_SHARED)) {
+			ret = -EINVAL;
+			goto out;
+		}
+		tag = HWSPINLOCK_EXCLUSIVE;
+	}
+
+	/* mark this hwspinlock */
+	hwlock = radix_tree_lookup(&hwspinlock_tree, id);
+	if (!hwlock) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	tmp = radix_tree_tag_set(&hwspinlock_tree, id, tag);
+
+	/* self-sanity check which should never fail */
+	WARN_ON(tmp != hwlock);
+
 out:
 	of_node_put(args.np);
 	return ret ? ret : id;
@@ -505,6 +540,7 @@ int hwspin_lock_register(struct hwspinlock_device *bank, struct device *dev,
 
 		spin_lock_init(&hwlock->lock);
 		hwlock->bank = bank;
+		hwlock->refcount = 0;
 
 		ret = hwspin_lock_register_single(hwlock, base_id + i);
 		if (ret)
@@ -647,7 +683,7 @@ static int __hwspin_lock_request(struct hwspinlock *hwlock)
 {
 	struct device *dev = hwlock->bank->dev;
 	struct hwspinlock *tmp;
-	int ret;
+	int ret, id;
 
 	/* prevent underlying implementation from being removed */
 	if (!try_module_get(dev->driver->owner)) {
@@ -666,13 +702,18 @@ static int __hwspin_lock_request(struct hwspinlock *hwlock)
 
 	ret = 0;
 
+	/* update shareable refcount */
+	id = hwlock_to_id(hwlock);
+	if (radix_tree_tag_get(&hwspinlock_tree, id, HWSPINLOCK_SHARED) &&
+	    hwlock->refcount++)
+		goto out;
+
 	/* mark hwspinlock as used, should not fail */
-	tmp = radix_tree_tag_clear(&hwspinlock_tree, hwlock_to_id(hwlock),
-							HWSPINLOCK_UNUSED);
+	tmp = radix_tree_tag_clear(&hwspinlock_tree, id, HWSPINLOCK_UNUSED);
 
 	/* self-sanity check that should never fail */
 	WARN_ON(tmp != hwlock);
-
+out:
 	return ret;
 }
 
@@ -766,9 +807,9 @@ struct hwspinlock *hwspin_lock_request_specific(unsigned int id)
 	/* sanity check (this shouldn't happen) */
 	WARN_ON(hwlock_to_id(hwlock) != id);
 
-	/* make sure this hwspinlock is unused */
-	ret = radix_tree_tag_get(&hwspinlock_tree, id, HWSPINLOCK_UNUSED);
-	if (ret == 0) {
+	/* make sure this hwspinlock is unused or shareable */
+	if (!radix_tree_tag_get(&hwspinlock_tree, id, HWSPINLOCK_SHARED) &&
+	    !radix_tree_tag_get(&hwspinlock_tree, id, HWSPINLOCK_UNUSED)) {
 		pr_warn("hwspinlock %u is already in use\n", id);
 		hwlock = NULL;
 		goto out;
@@ -801,7 +842,7 @@ int hwspin_lock_free(struct hwspinlock *hwlock)
 {
 	struct device *dev;
 	struct hwspinlock *tmp;
-	int ret;
+	int ret, id;
 
 	if (!hwlock) {
 		pr_err("invalid hwlock\n");
@@ -812,28 +853,33 @@ int hwspin_lock_free(struct hwspinlock *hwlock)
 	mutex_lock(&hwspinlock_tree_lock);
 
 	/* make sure the hwspinlock is used */
-	ret = radix_tree_tag_get(&hwspinlock_tree, hwlock_to_id(hwlock),
-							HWSPINLOCK_UNUSED);
+	id = hwlock_to_id(hwlock);
+	ret = radix_tree_tag_get(&hwspinlock_tree, id, HWSPINLOCK_UNUSED);
 	if (ret == 1) {
 		dev_err(dev, "%s: hwlock is already free\n", __func__);
 		dump_stack();
 		ret = -EINVAL;
-		goto out;
+		goto unlock;
 	}
 
 	/* notify the underlying device that power is not needed */
 	pm_runtime_put(dev);
 
+	/* update shareable refcount */
+	if (radix_tree_tag_get(&hwspinlock_tree, id, HWSPINLOCK_SHARED) &&
+	    --hwlock->refcount)
+		goto put;
+
 	/* mark this hwspinlock as available */
-	tmp = radix_tree_tag_set(&hwspinlock_tree, hwlock_to_id(hwlock),
-							HWSPINLOCK_UNUSED);
+	tmp = radix_tree_tag_set(&hwspinlock_tree, id, HWSPINLOCK_UNUSED);
 
 	/* sanity check (this shouldn't happen) */
 	WARN_ON(tmp != hwlock);
 
+put:
 	module_put(dev->driver->owner);
 
-out:
+unlock:
 	mutex_unlock(&hwspinlock_tree_lock);
 	return ret;
 }
diff --git a/drivers/hwspinlock/hwspinlock_internal.h b/drivers/hwspinlock/hwspinlock_internal.h
index 29892767b..e1f9c9600 100644
--- a/drivers/hwspinlock/hwspinlock_internal.h
+++ b/drivers/hwspinlock/hwspinlock_internal.h
@@ -35,11 +35,13 @@ struct hwspinlock_ops {
  * struct hwspinlock - this struct represents a single hwspinlock instance
  * @bank: the hwspinlock_device structure which owns this lock
  * @lock: initialized and used by hwspinlock core
+ * @refcount: number of users (when shared)
  * @priv: private data, owned by the underlying platform-specific hwspinlock drv
  */
 struct hwspinlock {
 	struct hwspinlock_device *bank;
 	spinlock_t lock;
+	unsigned int refcount;
 	void *priv;
 };
 
diff --git a/drivers/hwspinlock/stm32_hwspinlock.c b/drivers/hwspinlock/stm32_hwspinlock.c
index 3ad0ce0da..5bd11a7fa 100644
--- a/drivers/hwspinlock/stm32_hwspinlock.c
+++ b/drivers/hwspinlock/stm32_hwspinlock.c
@@ -54,8 +54,23 @@ static const struct hwspinlock_ops stm32_hwspinlock_ops = {
 	.relax		= stm32_hwspinlock_relax,
 };
 
+static void stm32_hwspinlock_disable_clk(void *data)
+{
+	struct platform_device *pdev = data;
+	struct stm32_hwspinlock *hw = platform_get_drvdata(pdev);
+	struct device *dev = &pdev->dev;
+
+	pm_runtime_get_sync(dev);
+	pm_runtime_disable(dev);
+	pm_runtime_set_suspended(dev);
+	pm_runtime_put_noidle(dev);
+
+	clk_disable_unprepare(hw->clk);
+}
+
 static int stm32_hwspinlock_probe(struct platform_device *pdev)
 {
+	struct device *dev = &pdev->dev;
 	struct stm32_hwspinlock *hw;
 	void __iomem *io_base;
 	size_t array_size;
@@ -66,41 +81,43 @@ static int stm32_hwspinlock_probe(struct platform_device *pdev)
 		return PTR_ERR(io_base);
 
 	array_size = STM32_MUTEX_NUM_LOCKS * sizeof(struct hwspinlock);
-	hw = devm_kzalloc(&pdev->dev, sizeof(*hw) + array_size, GFP_KERNEL);
+	hw = devm_kzalloc(dev, sizeof(*hw) + array_size, GFP_KERNEL);
 	if (!hw)
 		return -ENOMEM;
 
-	hw->clk = devm_clk_get(&pdev->dev, "hsem");
+	hw->clk = devm_clk_get(dev, "hsem");
 	if (IS_ERR(hw->clk))
 		return PTR_ERR(hw->clk);
 
-	for (i = 0; i < STM32_MUTEX_NUM_LOCKS; i++)
-		hw->bank.lock[i].priv = io_base + i * sizeof(u32);
+	ret = clk_prepare_enable(hw->clk);
+	if (ret) {
+		dev_err(dev, "Failed to prepare_enable clock\n");
+		return ret;
+	}
 
 	platform_set_drvdata(pdev, hw);
-	pm_runtime_enable(&pdev->dev);
 
-	ret = hwspin_lock_register(&hw->bank, &pdev->dev, &stm32_hwspinlock_ops,
-				   0, STM32_MUTEX_NUM_LOCKS);
+	pm_runtime_get_noresume(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_put(dev);
 
-	if (ret)
-		pm_runtime_disable(&pdev->dev);
+	ret = devm_add_action_or_reset(dev, stm32_hwspinlock_disable_clk, pdev);
+	if (ret) {
+		dev_err(dev, "Failed to register action\n");
+		return ret;
+	}
 
-	return ret;
-}
+	for (i = 0; i < STM32_MUTEX_NUM_LOCKS; i++)
+		hw->bank.lock[i].priv = io_base + i * sizeof(u32);
 
-static int stm32_hwspinlock_remove(struct platform_device *pdev)
-{
-	struct stm32_hwspinlock *hw = platform_get_drvdata(pdev);
-	int ret;
+	ret = devm_hwspin_lock_register(dev, &hw->bank, &stm32_hwspinlock_ops,
+					0, STM32_MUTEX_NUM_LOCKS);
 
-	ret = hwspin_lock_unregister(&hw->bank);
 	if (ret)
-		dev_err(&pdev->dev, "%s failed: %d\n", __func__, ret);
-
-	pm_runtime_disable(&pdev->dev);
+		dev_err(dev, "Failed to register hwspinlock\n");
 
-	return 0;
+	return ret;
 }
 
 static int __maybe_unused stm32_hwspinlock_runtime_suspend(struct device *dev)
@@ -135,7 +152,6 @@ MODULE_DEVICE_TABLE(of, stm32_hwpinlock_ids);
 
 static struct platform_driver stm32_hwspinlock_driver = {
 	.probe		= stm32_hwspinlock_probe,
-	.remove		= stm32_hwspinlock_remove,
 	.driver		= {
 		.name	= "stm32_hwspinlock",
 		.of_match_table = stm32_hwpinlock_ids,
diff --git a/drivers/i2c/busses/i2c-stm32f7.c b/drivers/i2c/busses/i2c-stm32f7.c
index 50d5ae81d..959e2862e 100644
--- a/drivers/i2c/busses/i2c-stm32f7.c
+++ b/drivers/i2c/busses/i2c-stm32f7.c
@@ -50,6 +50,7 @@
 #define STM32F7_I2C_TXDR			0x28
 
 /* STM32F7 I2C control 1 */
+#define STM32_I2C_CR1_FMP			BIT(24)
 #define STM32F7_I2C_CR1_PECEN			BIT(23)
 #define STM32F7_I2C_CR1_ALERTEN			BIT(22)
 #define STM32F7_I2C_CR1_SMBHEN			BIT(20)
@@ -226,6 +227,8 @@ struct stm32f7_i2c_spec {
  * @rise_time: Rise time (ns)
  * @fall_time: Fall time (ns)
  * @fmp_clr_offset: Fast Mode Plus clear register offset from set register
+ * @single_it_line: Only a single IT line is used for both events/errors
+ * @fmp_cr1_bit: Fast Mode Plus control is done via a bit in CR1
  */
 struct stm32f7_i2c_setup {
 	u32 speed_freq;
@@ -233,6 +236,8 @@ struct stm32f7_i2c_setup {
 	u32 rise_time;
 	u32 fall_time;
 	u32 fmp_clr_offset;
+	bool single_it_line;
+	bool fmp_cr1_bit;
 };
 
 /**
@@ -410,6 +415,19 @@ static const struct stm32f7_i2c_setup stm32mp15_setup = {
 	.fmp_clr_offset = 0x40,
 };
 
+static const struct stm32f7_i2c_setup stm32mp13_setup = {
+	.rise_time = STM32F7_I2C_RISE_TIME_DEFAULT,
+	.fall_time = STM32F7_I2C_FALL_TIME_DEFAULT,
+	.fmp_clr_offset = 0x4,
+};
+
+static const struct stm32f7_i2c_setup stm32mp25_setup = {
+	.rise_time = STM32F7_I2C_RISE_TIME_DEFAULT,
+	.fall_time = STM32F7_I2C_FALL_TIME_DEFAULT,
+	.single_it_line = true,
+	.fmp_cr1_bit = true,
+};
+
 static inline void stm32f7_i2c_set_bits(void __iomem *reg, u32 mask)
 {
 	writel_relaxed(readl_relaxed(reg) | mask, reg);
@@ -1414,17 +1432,15 @@ static bool stm32f7_i2c_is_slave_busy(struct stm32f7_i2c_dev *i2c_dev)
 	return i == busy;
 }
 
-static irqreturn_t stm32f7_i2c_slave_isr_event(struct stm32f7_i2c_dev *i2c_dev)
+static irqreturn_t stm32f7_i2c_slave_isr_event(struct stm32f7_i2c_dev *i2c_dev, u32 status)
 {
 	void __iomem *base = i2c_dev->base;
-	u32 cr2, status, mask;
+	u32 cr2, mask;
 	u8 val;
 	int ret;
 
-	status = readl_relaxed(i2c_dev->base + STM32F7_I2C_ISR);
-
 	/* Slave transmitter mode */
-	if (status & STM32F7_I2C_ISR_TXIS) {
+	if (i2c_dev->slave_running && (status & STM32F7_I2C_ISR_TXIS)) {
 		i2c_slave_event(i2c_dev->slave_running,
 				I2C_SLAVE_READ_PROCESSED,
 				&val);
@@ -1434,7 +1450,8 @@ static irqreturn_t stm32f7_i2c_slave_isr_event(struct stm32f7_i2c_dev *i2c_dev)
 	}
 
 	/* Transfer Complete Reload for Slave receiver mode */
-	if (status & STM32F7_I2C_ISR_TCR || status & STM32F7_I2C_ISR_RXNE) {
+	if (i2c_dev->slave_running &&
+	    (status & STM32F7_I2C_ISR_TCR || status & STM32F7_I2C_ISR_RXNE)) {
 		/*
 		 * Read data byte then set NBYTES to receive next byte or NACK
 		 * the current received byte
@@ -1460,7 +1477,7 @@ static irqreturn_t stm32f7_i2c_slave_isr_event(struct stm32f7_i2c_dev *i2c_dev)
 	}
 
 	/* STOP received */
-	if (status & STM32F7_I2C_ISR_STOPF) {
+	if (i2c_dev->slave_running && (status & STM32F7_I2C_ISR_STOPF)) {
 		/* Disable interrupts */
 		stm32f7_i2c_disable_irq(i2c_dev, STM32F7_I2C_XFER_IRQ_MASK);
 
@@ -1489,23 +1506,79 @@ static irqreturn_t stm32f7_i2c_slave_isr_event(struct stm32f7_i2c_dev *i2c_dev)
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t stm32f7_i2c_isr_event(int irq, void *data)
+static irqreturn_t stm32f7_i2c_handle_isr_errs(struct stm32f7_i2c_dev *i2c_dev, u32 status)
 {
-	struct stm32f7_i2c_dev *i2c_dev = data;
 	struct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;
-	struct stm32_i2c_dma *dma = i2c_dev->dma;
+	u16 addr = f7_msg->addr;
 	void __iomem *base = i2c_dev->base;
-	u32 status, mask;
-	int ret = IRQ_HANDLED;
+	struct device *dev = i2c_dev->dev;
+	struct stm32_i2c_dma *dma = i2c_dev->dma;
 
-	/* Check if the interrupt if for a slave device */
-	if (!i2c_dev->master_mode) {
-		ret = stm32f7_i2c_slave_isr_event(i2c_dev);
-		return ret;
+	/* Bus error */
+	if (status & STM32F7_I2C_ISR_BERR) {
+		dev_err(dev, "Bus error accessing addr 0x%x\n", addr);
+		writel_relaxed(STM32F7_I2C_ICR_BERRCF, base + STM32F7_I2C_ICR);
+		stm32f7_i2c_release_bus(&i2c_dev->adap);
+		f7_msg->result = -EIO;
+	}
+
+	/* Arbitration loss */
+	if (status & STM32F7_I2C_ISR_ARLO) {
+		dev_dbg(dev, "Arbitration loss accessing addr 0x%x\n", addr);
+		writel_relaxed(STM32F7_I2C_ICR_ARLOCF, base + STM32F7_I2C_ICR);
+		f7_msg->result = -EAGAIN;
 	}
 
+	if (status & STM32F7_I2C_ISR_PECERR) {
+		dev_err(dev, "PEC error in reception accessing addr 0x%x\n", addr);
+		writel_relaxed(STM32F7_I2C_ICR_PECCF, base + STM32F7_I2C_ICR);
+		f7_msg->result = -EINVAL;
+	}
+
+	if (status & STM32F7_I2C_ISR_ALERT) {
+		dev_dbg(dev, "SMBus alert received\n");
+		writel_relaxed(STM32F7_I2C_ICR_ALERTCF, base + STM32F7_I2C_ICR);
+		i2c_handle_smbus_alert(i2c_dev->alert->ara);
+		return IRQ_HANDLED;
+	}
+
+	if (!i2c_dev->slave_running) {
+		u32 mask;
+		/* Disable interrupts */
+		if (stm32f7_i2c_is_slave_registered(i2c_dev))
+			mask = STM32F7_I2C_XFER_IRQ_MASK;
+		else
+			mask = STM32F7_I2C_ALL_IRQ_MASK;
+		stm32f7_i2c_disable_irq(i2c_dev, mask);
+	}
+
+	/* Disable dma */
+	if (i2c_dev->use_dma) {
+		stm32f7_i2c_disable_dma_req(i2c_dev);
+		dmaengine_terminate_async(dma->chan_using);
+	}
+
+	i2c_dev->master_mode = false;
+	complete(&i2c_dev->complete);
+
+	return IRQ_HANDLED;
+}
+
+#define STM32F7_ERR_EVENTS (STM32F7_I2C_ISR_BERR | STM32F7_I2C_ISR_ARLO |\
+			    STM32F7_I2C_ISR_PECERR | STM32F7_I2C_ISR_ALERT)
+static irqreturn_t stm32f7_i2c_isr_event(int irq, void *data)
+{
+	struct stm32f7_i2c_dev *i2c_dev = data;
+	u32 status;
+
 	status = readl_relaxed(i2c_dev->base + STM32F7_I2C_ISR);
 
+	/* Check if the interrupt is for a slave device or related
+	 * to errors flags (in case of single it line mode) */
+	if (!i2c_dev->master_mode ||
+	    (i2c_dev->setup.single_it_line && (status & STM32F7_ERR_EVENTS)))
+		return IRQ_WAKE_THREAD;
+
 	/* Tx empty */
 	if (status & STM32F7_I2C_ISR_TXIS)
 		stm32f7_i2c_write_tx_data(i2c_dev);
@@ -1514,6 +1587,33 @@ static irqreturn_t stm32f7_i2c_isr_event(int irq, void *data)
 	if (status & STM32F7_I2C_ISR_RXNE)
 		stm32f7_i2c_read_rx_data(i2c_dev);
 
+	/* Wake up the thread if other flags are raised */
+	if (status &
+	    (STM32F7_I2C_ISR_NACKF | STM32F7_I2C_ISR_STOPF |
+	     STM32F7_I2C_ISR_TC | STM32F7_I2C_ISR_TCR))
+		return IRQ_WAKE_THREAD;
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t stm32f7_i2c_isr_event_thread(int irq, void *data)
+{
+	struct stm32f7_i2c_dev *i2c_dev = data;
+	struct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;
+	struct stm32_i2c_dma *dma = i2c_dev->dma;
+	void __iomem *base = i2c_dev->base;
+	u32 status, mask;
+	int ret;
+
+	status = readl_relaxed(i2c_dev->base + STM32F7_I2C_ISR);
+
+	if (!i2c_dev->master_mode)
+		return stm32f7_i2c_slave_isr_event(i2c_dev, status);
+
+	/* Handle errors in case of this handler is used for events/errors */
+	if (i2c_dev->setup.single_it_line && (status & STM32F7_ERR_EVENTS))
+		return stm32f7_i2c_handle_isr_errs(i2c_dev, status);
+
 	/* NACK received */
 	if (status & STM32F7_I2C_ISR_NACKF) {
 		dev_dbg(i2c_dev->dev, "<%s>: Receive NACK (addr %x)\n",
@@ -1521,38 +1621,33 @@ static irqreturn_t stm32f7_i2c_isr_event(int irq, void *data)
 		writel_relaxed(STM32F7_I2C_ICR_NACKCF, base + STM32F7_I2C_ICR);
 		if (i2c_dev->use_dma) {
 			stm32f7_i2c_disable_dma_req(i2c_dev);
-			dmaengine_terminate_all(dma->chan_using);
+			dmaengine_terminate_async(dma->chan_using);
 		}
 		f7_msg->result = -ENXIO;
 	}
 
-	/* STOP detection flag */
-	if (status & STM32F7_I2C_ISR_STOPF) {
-		/* Disable interrupts */
-		if (stm32f7_i2c_is_slave_registered(i2c_dev))
-			mask = STM32F7_I2C_XFER_IRQ_MASK;
+	if (status & STM32F7_I2C_ISR_TCR) {
+		if (f7_msg->smbus)
+			stm32f7_i2c_smbus_reload(i2c_dev);
 		else
-			mask = STM32F7_I2C_ALL_IRQ_MASK;
-		stm32f7_i2c_disable_irq(i2c_dev, mask);
-
-		/* Clear STOP flag */
-		writel_relaxed(STM32F7_I2C_ICR_STOPCF, base + STM32F7_I2C_ICR);
-
-		if (i2c_dev->use_dma && !f7_msg->result) {
-			ret = IRQ_WAKE_THREAD;
-		} else {
-			i2c_dev->master_mode = false;
-			complete(&i2c_dev->complete);
-		}
+			stm32f7_i2c_reload(i2c_dev);
 	}
 
 	/* Transfer complete */
 	if (status & STM32F7_I2C_ISR_TC) {
+		/* Wait for dma transfer completion before sending next message */
+		if (i2c_dev->use_dma && !f7_msg->result) {
+			ret = wait_for_completion_timeout(&i2c_dev->dma->dma_complete, HZ);
+			if (!ret) {
+				dev_dbg(i2c_dev->dev, "<%s>: Timed out\n", __func__);
+				stm32f7_i2c_disable_dma_req(i2c_dev);
+				dmaengine_terminate_async(dma->chan_using);
+				f7_msg->result = -ETIMEDOUT;
+			}
+		}
 		if (f7_msg->stop) {
 			mask = STM32F7_I2C_CR2_STOP;
 			stm32f7_i2c_set_bits(base + STM32F7_I2C_CR2, mask);
-		} else if (i2c_dev->use_dma && !f7_msg->result) {
-			ret = IRQ_WAKE_THREAD;
 		} else if (f7_msg->smbus) {
 			stm32f7_i2c_smbus_rep_start(i2c_dev);
 		} else {
@@ -1562,47 +1657,18 @@ static irqreturn_t stm32f7_i2c_isr_event(int irq, void *data)
 		}
 	}
 
-	if (status & STM32F7_I2C_ISR_TCR) {
-		if (f7_msg->smbus)
-			stm32f7_i2c_smbus_reload(i2c_dev);
+	/* STOP detection flag */
+	if (status & STM32F7_I2C_ISR_STOPF) {
+		/* Disable interrupts */
+		if (stm32f7_i2c_is_slave_registered(i2c_dev))
+			mask = STM32F7_I2C_XFER_IRQ_MASK;
 		else
-			stm32f7_i2c_reload(i2c_dev);
-	}
-
-	return ret;
-}
-
-static irqreturn_t stm32f7_i2c_isr_event_thread(int irq, void *data)
-{
-	struct stm32f7_i2c_dev *i2c_dev = data;
-	struct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;
-	struct stm32_i2c_dma *dma = i2c_dev->dma;
-	u32 status;
-	int ret;
-
-	/*
-	 * Wait for dma transfer completion before sending next message or
-	 * notity the end of xfer to the client
-	 */
-	ret = wait_for_completion_timeout(&i2c_dev->dma->dma_complete, HZ);
-	if (!ret) {
-		dev_dbg(i2c_dev->dev, "<%s>: Timed out\n", __func__);
-		stm32f7_i2c_disable_dma_req(i2c_dev);
-		dmaengine_terminate_all(dma->chan_using);
-		f7_msg->result = -ETIMEDOUT;
-	}
+			mask = STM32F7_I2C_ALL_IRQ_MASK;
+		stm32f7_i2c_disable_irq(i2c_dev, mask);
 
-	status = readl_relaxed(i2c_dev->base + STM32F7_I2C_ISR);
+		/* Clear STOP flag */
+		writel_relaxed(STM32F7_I2C_ICR_STOPCF, base + STM32F7_I2C_ICR);
 
-	if (status & STM32F7_I2C_ISR_TC) {
-		if (f7_msg->smbus) {
-			stm32f7_i2c_smbus_rep_start(i2c_dev);
-		} else {
-			i2c_dev->msg_id++;
-			i2c_dev->msg++;
-			stm32f7_i2c_xfer_msg(i2c_dev, i2c_dev->msg);
-		}
-	} else {
 		i2c_dev->master_mode = false;
 		complete(&i2c_dev->complete);
 	}
@@ -1610,68 +1676,14 @@ static irqreturn_t stm32f7_i2c_isr_event_thread(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t stm32f7_i2c_isr_error(int irq, void *data)
+static irqreturn_t stm32f7_i2c_isr_error_thread(int irq, void *data)
 {
 	struct stm32f7_i2c_dev *i2c_dev = data;
-	struct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;
-	void __iomem *base = i2c_dev->base;
-	struct device *dev = i2c_dev->dev;
-	struct stm32_i2c_dma *dma = i2c_dev->dma;
 	u32 status;
 
 	status = readl_relaxed(i2c_dev->base + STM32F7_I2C_ISR);
 
-	/* Bus error */
-	if (status & STM32F7_I2C_ISR_BERR) {
-		dev_err(dev, "<%s>: Bus error accessing addr 0x%x\n",
-			__func__, f7_msg->addr);
-		writel_relaxed(STM32F7_I2C_ICR_BERRCF, base + STM32F7_I2C_ICR);
-		stm32f7_i2c_release_bus(&i2c_dev->adap);
-		f7_msg->result = -EIO;
-	}
-
-	/* Arbitration loss */
-	if (status & STM32F7_I2C_ISR_ARLO) {
-		dev_dbg(dev, "<%s>: Arbitration loss accessing addr 0x%x\n",
-			__func__, f7_msg->addr);
-		writel_relaxed(STM32F7_I2C_ICR_ARLOCF, base + STM32F7_I2C_ICR);
-		f7_msg->result = -EAGAIN;
-	}
-
-	if (status & STM32F7_I2C_ISR_PECERR) {
-		dev_err(dev, "<%s>: PEC error in reception accessing addr 0x%x\n",
-			__func__, f7_msg->addr);
-		writel_relaxed(STM32F7_I2C_ICR_PECCF, base + STM32F7_I2C_ICR);
-		f7_msg->result = -EINVAL;
-	}
-
-	if (status & STM32F7_I2C_ISR_ALERT) {
-		dev_dbg(dev, "<%s>: SMBus alert received\n", __func__);
-		writel_relaxed(STM32F7_I2C_ICR_ALERTCF, base + STM32F7_I2C_ICR);
-		i2c_handle_smbus_alert(i2c_dev->alert->ara);
-		return IRQ_HANDLED;
-	}
-
-	if (!i2c_dev->slave_running) {
-		u32 mask;
-		/* Disable interrupts */
-		if (stm32f7_i2c_is_slave_registered(i2c_dev))
-			mask = STM32F7_I2C_XFER_IRQ_MASK;
-		else
-			mask = STM32F7_I2C_ALL_IRQ_MASK;
-		stm32f7_i2c_disable_irq(i2c_dev, mask);
-	}
-
-	/* Disable dma */
-	if (i2c_dev->use_dma) {
-		stm32f7_i2c_disable_dma_req(i2c_dev);
-		dmaengine_terminate_all(dma->chan_using);
-	}
-
-	i2c_dev->master_mode = false;
-	complete(&i2c_dev->complete);
-
-	return IRQ_HANDLED;
+	return stm32f7_i2c_handle_isr_errs(i2c_dev, status);
 }
 
 static int stm32f7_i2c_xfer(struct i2c_adapter *i2c_adap,
@@ -1702,6 +1714,9 @@ static int stm32f7_i2c_xfer(struct i2c_adapter *i2c_adap,
 						i2c_dev->adap.timeout);
 	ret = f7_msg->result;
 	if (ret) {
+		if (i2c_dev->use_dma)
+			dmaengine_synchronize(dma->chan_using);
+
 		/*
 		 * It is possible that some unsent data have already been
 		 * written into TXDR. To avoid sending old data in a
@@ -1716,7 +1731,7 @@ static int stm32f7_i2c_xfer(struct i2c_adapter *i2c_adap,
 		dev_dbg(i2c_dev->dev, "Access to slave 0x%x timed out\n",
 			i2c_dev->msg->addr);
 		if (i2c_dev->use_dma)
-			dmaengine_terminate_all(dma->chan_using);
+			dmaengine_terminate_sync(dma->chan_using);
 		stm32f7_i2c_wait_free_bus(i2c_dev);
 		ret = -ETIMEDOUT;
 	}
@@ -1761,6 +1776,9 @@ static int stm32f7_i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,
 					      i2c_dev->adap.timeout);
 	ret = f7_msg->result;
 	if (ret) {
+		if (i2c_dev->use_dma)
+			dmaengine_synchronize(dma->chan_using);
+
 		/*
 		 * It is possible that some unsent data have already been
 		 * written into TXDR. To avoid sending old data in a
@@ -1774,7 +1792,7 @@ static int stm32f7_i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,
 	if (!timeout) {
 		dev_dbg(dev, "Access to slave 0x%x timed out\n", f7_msg->addr);
 		if (i2c_dev->use_dma)
-			dmaengine_terminate_all(dma->chan_using);
+			dmaengine_terminate_sync(dma->chan_using);
 		stm32f7_i2c_wait_free_bus(i2c_dev);
 		ret = -ETIMEDOUT;
 		goto pm_free;
@@ -1967,20 +1985,24 @@ static int stm32f7_i2c_write_fm_plus_bits(struct stm32f7_i2c_dev *i2c_dev,
 	int ret;
 
 	if (i2c_dev->bus_rate <= I2C_MAX_FAST_MODE_FREQ ||
-	    IS_ERR_OR_NULL(i2c_dev->regmap))
+	    (!i2c_dev->setup.fmp_cr1_bit && IS_ERR_OR_NULL(i2c_dev->regmap)))
 		/* Optional */
 		return 0;
 
-	if (i2c_dev->fmp_sreg == i2c_dev->fmp_creg)
-		ret = regmap_update_bits(i2c_dev->regmap,
-					 i2c_dev->fmp_sreg,
-					 i2c_dev->fmp_mask,
-					 enable ? i2c_dev->fmp_mask : 0);
-	else
-		ret = regmap_write(i2c_dev->regmap,
-				   enable ? i2c_dev->fmp_sreg :
-					    i2c_dev->fmp_creg,
-				   i2c_dev->fmp_mask);
+	if (i2c_dev->setup.fmp_cr1_bit) {
+		if (enable)
+			stm32f7_i2c_set_bits(i2c_dev->base + STM32F7_I2C_CR1, STM32_I2C_CR1_FMP);
+		else
+			stm32f7_i2c_clr_bits(i2c_dev->base + STM32F7_I2C_CR1, STM32_I2C_CR1_FMP);
+	} else {
+		if (i2c_dev->fmp_sreg == i2c_dev->fmp_creg)
+			ret = regmap_update_bits(i2c_dev->regmap, i2c_dev->fmp_sreg,
+						 i2c_dev->fmp_mask, enable ? i2c_dev->fmp_mask : 0);
+		else
+			ret = regmap_write(i2c_dev->regmap,
+					   enable ? i2c_dev->fmp_sreg : i2c_dev->fmp_creg,
+					   i2c_dev->fmp_mask);
+	}
 
 	return ret;
 }
@@ -2113,6 +2135,14 @@ static int stm32f7_i2c_probe(struct platform_device *pdev)
 	if (!i2c_dev)
 		return -ENOMEM;
 
+	setup = of_device_get_match_data(&pdev->dev);
+	if (!setup) {
+		dev_err(&pdev->dev, "Can't get device data\n");
+		ret = -ENODEV;
+		goto clk_free;
+	}
+	i2c_dev->setup = *setup;
+
 	i2c_dev->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
 	if (IS_ERR(i2c_dev->base))
 		return PTR_ERR(i2c_dev->base);
@@ -2122,9 +2152,11 @@ static int stm32f7_i2c_probe(struct platform_device *pdev)
 	if (irq_event <= 0)
 		return irq_event ? : -ENOENT;
 
-	irq_error = platform_get_irq(pdev, 1);
-	if (irq_error <= 0)
-		return irq_error ? : -ENOENT;
+	if (!i2c_dev->setup.single_it_line) {
+		irq_error = platform_get_irq(pdev, 1);
+		if (irq_error <= 0)
+			return irq_error ? : -ENOENT;
+	}
 
 	i2c_dev->wakeup_src = of_property_read_bool(pdev->dev.of_node,
 						    "wakeup-source");
@@ -2163,21 +2195,18 @@ static int stm32f7_i2c_probe(struct platform_device *pdev)
 		goto clk_free;
 	}
 
-	ret = devm_request_irq(&pdev->dev, irq_error, stm32f7_i2c_isr_error, 0,
-			       pdev->name, i2c_dev);
-	if (ret) {
-		dev_err(&pdev->dev, "Failed to request irq error %i\n",
-			irq_error);
-		goto clk_free;
-	}
-
-	setup = of_device_get_match_data(&pdev->dev);
-	if (!setup) {
-		dev_err(&pdev->dev, "Can't get device data\n");
-		ret = -ENODEV;
-		goto clk_free;
+	if (!i2c_dev->setup.single_it_line) {
+		ret = devm_request_threaded_irq(&pdev->dev, irq_error,
+						NULL,
+						stm32f7_i2c_isr_error_thread,
+						IRQF_ONESHOT,
+						pdev->name, i2c_dev);
+		if (ret) {
+			dev_err(&pdev->dev, "Failed to request irq error %i\n",
+				irq_error);
+			goto clk_free;
+		}
 	}
-	i2c_dev->setup = *setup;
 
 	ret = stm32f7_i2c_setup_timing(i2c_dev, &i2c_dev->setup);
 	if (ret)
@@ -2185,9 +2214,11 @@ static int stm32f7_i2c_probe(struct platform_device *pdev)
 
 	/* Setup Fast mode plus if necessary */
 	if (i2c_dev->bus_rate > I2C_MAX_FAST_MODE_FREQ) {
-		ret = stm32f7_i2c_setup_fm_plus_bits(pdev, i2c_dev);
-		if (ret)
-			goto clk_free;
+		if (!i2c_dev->setup.fmp_cr1_bit) {
+			ret = stm32f7_i2c_setup_fm_plus_bits(pdev, i2c_dev);
+			if (ret)
+				goto clk_free;
+		}
 		ret = stm32f7_i2c_write_fm_plus_bits(i2c_dev, true);
 		if (ret)
 			goto clk_free;
@@ -2343,63 +2374,23 @@ static int stm32f7_i2c_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static int __maybe_unused stm32f7_i2c_runtime_suspend(struct device *dev)
-{
-	struct stm32f7_i2c_dev *i2c_dev = dev_get_drvdata(dev);
-
-	if (!stm32f7_i2c_is_slave_registered(i2c_dev))
-		clk_disable_unprepare(i2c_dev->clk);
-
-	return 0;
-}
-
-static int __maybe_unused stm32f7_i2c_runtime_resume(struct device *dev)
-{
-	struct stm32f7_i2c_dev *i2c_dev = dev_get_drvdata(dev);
-	int ret;
-
-	if (!stm32f7_i2c_is_slave_registered(i2c_dev)) {
-		ret = clk_prepare_enable(i2c_dev->clk);
-		if (ret) {
-			dev_err(dev, "failed to prepare_enable clock\n");
-			return ret;
-		}
-	}
-
-	return 0;
-}
-
-static int __maybe_unused stm32f7_i2c_regs_backup(struct stm32f7_i2c_dev *i2c_dev)
+static void __maybe_unused stm32f7_i2c_regs_backup(struct stm32f7_i2c_dev *i2c_dev)
 {
-	int ret;
 	struct stm32f7_i2c_regs *backup_regs = &i2c_dev->backup_regs;
 
-	ret = pm_runtime_resume_and_get(i2c_dev->dev);
-	if (ret < 0)
-		return ret;
-
 	backup_regs->cr1 = readl_relaxed(i2c_dev->base + STM32F7_I2C_CR1);
 	backup_regs->cr2 = readl_relaxed(i2c_dev->base + STM32F7_I2C_CR2);
 	backup_regs->oar1 = readl_relaxed(i2c_dev->base + STM32F7_I2C_OAR1);
 	backup_regs->oar2 = readl_relaxed(i2c_dev->base + STM32F7_I2C_OAR2);
 	backup_regs->tmgr = readl_relaxed(i2c_dev->base + STM32F7_I2C_TIMINGR);
 	stm32f7_i2c_write_fm_plus_bits(i2c_dev, false);
-
-	pm_runtime_put_sync(i2c_dev->dev);
-
-	return ret;
 }
 
-static int __maybe_unused stm32f7_i2c_regs_restore(struct stm32f7_i2c_dev *i2c_dev)
+static void __maybe_unused stm32f7_i2c_regs_restore(struct stm32f7_i2c_dev *i2c_dev)
 {
 	u32 cr1;
-	int ret;
 	struct stm32f7_i2c_regs *backup_regs = &i2c_dev->backup_regs;
 
-	ret = pm_runtime_resume_and_get(i2c_dev->dev);
-	if (ret < 0)
-		return ret;
-
 	cr1 = readl_relaxed(i2c_dev->base + STM32F7_I2C_CR1);
 	if (cr1 & STM32F7_I2C_CR1_PE)
 		stm32f7_i2c_clr_bits(i2c_dev->base + STM32F7_I2C_CR1,
@@ -2415,29 +2406,48 @@ static int __maybe_unused stm32f7_i2c_regs_restore(struct stm32f7_i2c_dev *i2c_d
 	writel_relaxed(backup_regs->oar1, i2c_dev->base + STM32F7_I2C_OAR1);
 	writel_relaxed(backup_regs->oar2, i2c_dev->base + STM32F7_I2C_OAR2);
 	stm32f7_i2c_write_fm_plus_bits(i2c_dev, true);
+}
 
-	pm_runtime_put_sync(i2c_dev->dev);
+static int __maybe_unused stm32f7_i2c_runtime_suspend(struct device *dev)
+{
+	struct stm32f7_i2c_dev *i2c_dev = dev_get_drvdata(dev);
 
-	return ret;
+	stm32f7_i2c_regs_backup(i2c_dev);
+
+	if (!stm32f7_i2c_is_slave_registered(i2c_dev))
+		clk_disable_unprepare(i2c_dev->clk);
+
+	return 0;
 }
 
-static int __maybe_unused stm32f7_i2c_suspend(struct device *dev)
+static int __maybe_unused stm32f7_i2c_runtime_resume(struct device *dev)
 {
 	struct stm32f7_i2c_dev *i2c_dev = dev_get_drvdata(dev);
 	int ret;
 
-	i2c_mark_adapter_suspended(&i2c_dev->adap);
-
-	if (!device_may_wakeup(dev) && !device_wakeup_path(dev)) {
-		ret = stm32f7_i2c_regs_backup(i2c_dev);
-		if (ret < 0) {
-			i2c_mark_adapter_resumed(&i2c_dev->adap);
+	if (!stm32f7_i2c_is_slave_registered(i2c_dev)) {
+		ret = clk_prepare_enable(i2c_dev->clk);
+		if (ret) {
+			dev_err(dev, "failed to prepare_enable clock\n");
 			return ret;
 		}
+	}
 
+	stm32f7_i2c_regs_restore(i2c_dev);
+
+	return 0;
+}
+
+static int __maybe_unused stm32f7_i2c_suspend(struct device *dev)
+{
+	struct stm32f7_i2c_dev *i2c_dev = dev_get_drvdata(dev);
+
+	i2c_mark_adapter_suspended(&i2c_dev->adap);
+
+	if (!device_may_wakeup(dev) && !device_wakeup_path(dev))
 		pinctrl_pm_select_sleep_state(dev);
-		pm_runtime_force_suspend(dev);
-	}
+
+	pm_runtime_force_suspend(dev);
 
 	return 0;
 }
@@ -2447,16 +2457,12 @@ static int __maybe_unused stm32f7_i2c_resume(struct device *dev)
 	struct stm32f7_i2c_dev *i2c_dev = dev_get_drvdata(dev);
 	int ret;
 
-	if (!device_may_wakeup(dev) && !device_wakeup_path(dev)) {
-		ret = pm_runtime_force_resume(dev);
-		if (ret < 0)
-			return ret;
-		pinctrl_pm_select_default_state(dev);
+	ret = pm_runtime_force_resume(dev);
+	if (ret < 0)
+		return ret;
 
-		ret = stm32f7_i2c_regs_restore(i2c_dev);
-		if (ret < 0)
-			return ret;
-	}
+	if (!device_may_wakeup(dev) && !device_wakeup_path(dev))
+		pinctrl_pm_select_default_state(dev);
 
 	i2c_mark_adapter_resumed(&i2c_dev->adap);
 
@@ -2472,6 +2478,8 @@ static const struct dev_pm_ops stm32f7_i2c_pm_ops = {
 static const struct of_device_id stm32f7_i2c_match[] = {
 	{ .compatible = "st,stm32f7-i2c", .data = &stm32f7_setup},
 	{ .compatible = "st,stm32mp15-i2c", .data = &stm32mp15_setup},
+	{ .compatible = "st,stm32mp13-i2c", .data = &stm32mp13_setup},
+	{ .compatible = "st,stm32mp25-i2c", .data = &stm32mp25_setup},
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32f7_i2c_match);
diff --git a/drivers/iio/adc/sd_adc_modulator.c b/drivers/iio/adc/sd_adc_modulator.c
index 327cc2097..ceb150296 100644
--- a/drivers/iio/adc/sd_adc_modulator.c
+++ b/drivers/iio/adc/sd_adc_modulator.c
@@ -9,10 +9,8 @@
 #include <linux/iio/iio.h>
 #include <linux/iio/triggered_buffer.h>
 #include <linux/module.h>
-#include <linux/mod_devicetable.h>
-#include <linux/platform_device.h>
-
-static const struct iio_info iio_sd_mod_iio_info;
+#include <linux/of_device.h>
+#include <linux/regulator/consumer.h>
 
 static const struct iio_chan_spec iio_sd_mod_ch = {
 	.type = IIO_VOLTAGE,
@@ -22,34 +20,99 @@ static const struct iio_chan_spec iio_sd_mod_ch = {
 		.realbits = 1,
 		.shift = 0,
 	},
+	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),
+};
+
+static const struct iio_chan_spec iio_sd_mod_ch_ads = {
+	.type = IIO_VOLTAGE,
+	.indexed = 1,
+	.scan_type = {
+		.sign = 'u',
+		.realbits = 1,
+		.shift = 0,
+	},
+	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),
+	.differential = 1,
+};
+
+struct iio_sd_mod_priv {
+	int vref_mv;
+};
+
+static const struct of_device_id sd_adc_of_match[] = {
+	{ .compatible = "sd-modulator", .data = &iio_sd_mod_ch },
+	{ .compatible = "ads1201", .data = &iio_sd_mod_ch_ads },
+	{ }
+};
+
+static int iio_sd_mod_read_raw(struct iio_dev *indio_dev,
+			       struct iio_chan_spec const *chan, int *val,
+			       int *val2, long mask)
+{
+	struct iio_sd_mod_priv *priv = iio_priv(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		*val = priv->vref_mv;
+		*val2 = chan->scan_type.realbits;
+		return IIO_VAL_INT;
+	}
+
+	return -EINVAL;
+}
+
+static const struct iio_info iio_sd_mod_iio_info = {
+	.read_raw = iio_sd_mod_read_raw,
 };
 
 static int iio_sd_mod_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
+	struct iio_sd_mod_priv *priv;
+	struct regulator *vref;
 	struct iio_dev *iio;
+	int ret;
 
-	iio = devm_iio_device_alloc(dev, 0);
+	iio = devm_iio_device_alloc(dev, sizeof(*priv));
 	if (!iio)
 		return -ENOMEM;
 
+	iio->channels = (const struct iio_chan_spec *)
+			of_match_device(sd_adc_of_match, &pdev->dev)->data;
+
+	priv = iio_priv(iio);
+
+	iio->dev.parent = dev;
+	iio->dev.of_node = dev->of_node;
 	iio->name = dev_name(dev);
 	iio->info = &iio_sd_mod_iio_info;
 	iio->modes = INDIO_BUFFER_HARDWARE;
-
 	iio->num_channels = 1;
-	iio->channels = &iio_sd_mod_ch;
 
-	platform_set_drvdata(pdev, iio);
+	vref = devm_regulator_get_optional(dev, "vref");
+	if (IS_ERR(vref)) {
+		ret = PTR_ERR(vref);
+		if (ret != -ENODEV) {
+			if (ret != -EPROBE_DEFER)
+				dev_err(dev, "vref get failed, %d\n", ret);
+			return ret;
+		}
+	}
+
+	if (!IS_ERR(vref)) {
+		ret = regulator_get_voltage(vref);
+		if (ret < 0) {
+			dev_err(dev, "vref get failed, %d\n", ret);
+			return ret;
+		}
+
+		priv->vref_mv = ret / 1000;
+		dev_dbg(dev, "vref+=%dmV\n", priv->vref_mv);
+	}
 
 	return devm_iio_device_register(&pdev->dev, iio);
 }
 
-static const struct of_device_id sd_adc_of_match[] = {
-	{ .compatible = "sd-modulator" },
-	{ .compatible = "ads1201" },
-	{ }
-};
 MODULE_DEVICE_TABLE(of, sd_adc_of_match);
 
 static struct platform_driver iio_sd_mod_adc = {
diff --git a/drivers/iio/adc/stm32-adc-core.c b/drivers/iio/adc/stm32-adc-core.c
index 42faca457..406272bc2 100644
--- a/drivers/iio/adc/stm32-adc-core.c
+++ b/drivers/iio/adc/stm32-adc-core.c
@@ -9,6 +9,7 @@
  *
  */
 
+#include <linux/bitfield.h>
 #include <linux/clk.h>
 #include <linux/interrupt.h>
 #include <linux/irqchip/chained_irq.h>
@@ -17,6 +18,7 @@
 #include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
+#include <linux/of_irq.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/regulator/consumer.h>
@@ -45,6 +47,8 @@
  * @ovr_msk:    array of ovr (overrun flag) masks in csr for adc1..n
  * @ier:	interrupt enable register offset for each adc
  * @eocie_msk:	end of conversion interrupt enable mask in @ier
+ * @presc_msk:	prescaler mask in ccr
+ * @presc_shift: prescaler bit shift in ccr
  */
 struct stm32_adc_common_regs {
 	u32 csr;
@@ -53,6 +57,8 @@ struct stm32_adc_common_regs {
 	u32 ovr_msk[STM32_ADC_MAX_ADCS];
 	u32 ier;
 	u32 eocie_msk;
+	u32 presc_msk;
+	u32 presc_shift;
 };
 
 struct stm32_adc_priv;
@@ -61,7 +67,10 @@ struct stm32_adc_priv;
  * struct stm32_adc_priv_cfg - stm32 core compatible configuration data
  * @regs:	common registers for all instances
  * @clk_sel:	clock selection routine
+ * @presc:	clock prescaler array
+ * @num_presc:	number of clock prescalers in presc array
  * @max_clk_rate_hz: maximum analog clock rate (Hz, from datasheet)
+ * @ipid:	adc identification number
  * @has_syscfg: SYSCFG capability flags
  * @num_irqs:	number of interrupt lines
  * @num_adcs:   maximum number of ADC instances in the common registers
@@ -69,7 +78,10 @@ struct stm32_adc_priv;
 struct stm32_adc_priv_cfg {
 	const struct stm32_adc_common_regs *regs;
 	int (*clk_sel)(struct platform_device *, struct stm32_adc_priv *);
+	int *presc;
+	int num_presc;
 	u32 max_clk_rate_hz;
+	u32 ipid;
 	unsigned int has_syscfg;
 	unsigned int num_irqs;
 	unsigned int num_adcs;
@@ -77,7 +89,11 @@ struct stm32_adc_priv_cfg {
 
 /**
  * struct stm32_adc_priv - stm32 ADC core private data
+ * @dev:		pointer to adc device
  * @irq:		irq(s) for ADC block
+ * @irq_map:		mapping between children and parents irqs
+ * @nb_adc_max:		actual maximum number of instance per ADC block
+ * @nb_irqs:		number of IRQs in the ADC block
  * @domain:		irq domain reference
  * @aclk:		clock reference for the analog circuitry
  * @bclk:		bus clock common for all ADCs, depends on part used
@@ -94,7 +110,11 @@ struct stm32_adc_priv_cfg {
  * @syscfg:		reference to syscon, system control registers
  */
 struct stm32_adc_priv {
+	struct device			*dev;
 	int				irq[STM32_ADC_MAX_ADCS];
+	int				irq_map[STM32_ADC_MAX_ADCS];
+	unsigned int			nb_adc_max;
+	unsigned int			nb_irqs;
 	struct irq_domain		*domain;
 	struct clk			*aclk;
 	struct clk			*bclk;
@@ -119,20 +139,23 @@ static struct stm32_adc_priv *to_stm32_adc_priv(struct stm32_adc_common *com)
 /* STM32F4 ADC internal common clock prescaler division ratios */
 static int stm32f4_pclk_div[] = {2, 4, 6, 8};
 
+/* STM32MP25 ADC internal common clock prescaler division ratios */
+static int stm32mp25_presc_div[] = {1, 2, 4, 6, 8, 10, 12, 16, 32, 64, 128, 256};
+
 /**
- * stm32f4_adc_clk_sel() - Select stm32f4 ADC common clock prescaler
+ * stm32_adc_clk_sel() - Select stm32f4 ADC common clock prescaler
  * @pdev: platform device
  * @priv: stm32 ADC core private data
  * Select clock prescaler used for analog conversions, before using ADC.
  */
-static int stm32f4_adc_clk_sel(struct platform_device *pdev,
-			       struct stm32_adc_priv *priv)
+static int stm32_adc_clk_sel(struct platform_device *pdev,
+			     struct stm32_adc_priv *priv)
 {
 	unsigned long rate;
 	u32 val;
 	int i;
 
-	/* stm32f4 has one clk input for analog (mandatory), enforce it here */
+	/* stm32f4/mp25 has one clk input for analog (mandatory), enforce it here */
 	if (!priv->aclk) {
 		dev_err(&pdev->dev, "No 'adc' clock found\n");
 		return -ENOENT;
@@ -144,20 +167,20 @@ static int stm32f4_adc_clk_sel(struct platform_device *pdev,
 		return -EINVAL;
 	}
 
-	for (i = 0; i < ARRAY_SIZE(stm32f4_pclk_div); i++) {
-		if ((rate / stm32f4_pclk_div[i]) <= priv->max_clk_rate)
+	for (i = 0; i < priv->cfg->num_presc; i++) {
+		if ((rate / priv->cfg->presc[i]) <= priv->max_clk_rate)
 			break;
 	}
-	if (i >= ARRAY_SIZE(stm32f4_pclk_div)) {
+	if (i >= priv->cfg->num_presc) {
 		dev_err(&pdev->dev, "adc clk selection failed\n");
 		return -EINVAL;
 	}
 
-	priv->common.rate = rate / stm32f4_pclk_div[i];
-	val = readl_relaxed(priv->common.base + STM32F4_ADC_CCR);
-	val &= ~STM32F4_ADC_ADCPRE_MASK;
-	val |= i << STM32F4_ADC_ADCPRE_SHIFT;
-	writel_relaxed(val, priv->common.base + STM32F4_ADC_CCR);
+	priv->common.rate = rate / priv->cfg->presc[i];
+	val = readl_relaxed(priv->common.base + priv->cfg->regs->ccr);
+	val &= ~priv->cfg->regs->presc_msk;
+	val |= i << priv->cfg->regs->presc_shift;
+	writel_relaxed(val, priv->common.base + priv->cfg->regs->ccr);
 
 	dev_dbg(&pdev->dev, "Using analog clock source at %ld kHz\n",
 		priv->common.rate / 1000);
@@ -305,6 +328,8 @@ static const struct stm32_adc_common_regs stm32f4_adc_common_regs = {
 	.ovr_msk = { STM32F4_OVR1, STM32F4_OVR2, STM32F4_OVR3},
 	.ier = STM32F4_ADC_CR1,
 	.eocie_msk = STM32F4_EOCIE,
+	.presc_msk = STM32F4_ADC_ADCPRE_MASK,
+	.presc_shift = STM32F4_ADC_ADCPRE_SHIFT,
 };
 
 /* STM32H7 common registers definitions */
@@ -317,6 +342,28 @@ static const struct stm32_adc_common_regs stm32h7_adc_common_regs = {
 	.eocie_msk = STM32H7_EOCIE,
 };
 
+/* STM32MP13 common registers definitions */
+static const struct stm32_adc_common_regs stm32mp13_adc_common_regs = {
+	.csr = STM32H7_ADC_CSR,
+	.ccr = STM32H7_ADC_CCR,
+	.eoc_msk = { STM32H7_EOC_MST},
+	.ovr_msk = { STM32H7_OVR_MST},
+	.ier = STM32H7_ADC_IER,
+	.eocie_msk = STM32H7_EOCIE,
+};
+
+/* STM32MP25 common registers definitions */
+static const struct stm32_adc_common_regs stm32mp25_adc_common_regs = {
+	.csr = STM32H7_ADC_CSR,
+	.ccr = STM32H7_ADC_CCR,
+	.eoc_msk = { STM32H7_EOC_MST, STM32H7_EOC_SLV},
+	.ovr_msk = { STM32H7_OVR_MST, STM32H7_OVR_SLV},
+	.ier = STM32H7_ADC_IER,
+	.eocie_msk = STM32H7_EOCIE,
+	.presc_msk = STM32H7_PRESC_MASK,
+	.presc_shift = STM32H7_PRESC_SHIFT,
+};
+
 static const unsigned int stm32_adc_offset[STM32_ADC_MAX_ADCS] = {
 	0, STM32_ADC_OFFSET, STM32_ADC_OFFSET * 2,
 };
@@ -354,34 +401,94 @@ static void stm32_adc_irq_handler(struct irq_desc *desc)
 	 * before invoking the interrupt handler (e.g. call ISR only for
 	 * IRQ-enabled ADCs).
 	 */
-	for (i = 0; i < priv->cfg->num_adcs; i++) {
+	for (i = 0; i < priv->nb_adc_max; i++) {
 		if ((status & priv->cfg->regs->eoc_msk[i] &&
 		     stm32_adc_eoc_enabled(priv, i)) ||
 		     (status & priv->cfg->regs->ovr_msk[i]))
-			generic_handle_irq(irq_find_mapping(priv->domain, i));
+			generic_handle_domain_irq(priv->domain, i);
 	}
 
 	chained_irq_exit(chip, desc);
 };
 
-static int stm32_adc_domain_map(struct irq_domain *d, unsigned int irq,
-				irq_hw_number_t hwirq)
+static void stm32_adc_core_mask(struct irq_data *d)
 {
-	irq_set_chip_data(irq, d->host_data);
-	irq_set_chip_and_handler(irq, &dummy_irq_chip, handle_level_irq);
+	if (d->parent_data->chip)
+		irq_chip_mask_parent(d);
+}
 
-	return 0;
+static void stm32_adc_core_unmask(struct irq_data *d)
+{
+	if (d->parent_data->chip)
+		irq_chip_unmask_parent(d);
 }
 
-static void stm32_adc_domain_unmap(struct irq_domain *d, unsigned int irq)
+struct irq_chip stm32_irq_chip = {
+	.name		= "stm32_adc_core",
+	.irq_mask	= stm32_adc_core_mask,
+	.irq_unmask	= stm32_adc_core_unmask,
+	.flags		= IRQCHIP_SKIP_SET_WAKE,
+};
+
+static int stm32_adc_core_domain_alloc(struct irq_domain *dm, unsigned int virq,
+				       unsigned int nr_irqs, void *data)
 {
-	irq_set_chip_and_handler(irq, NULL, NULL);
-	irq_set_chip_data(irq, NULL);
+	irq_hw_number_t hwirq;
+	struct stm32_adc_priv *priv = dm->host_data;
+	struct irq_fwspec *fwspec = data;
+	struct irq_data *irq_data, *irq_data_p;
+	u32 irq_parent;
+	int ret, virq_p;
+
+	if (!dm->parent) {
+		dev_err(priv->dev, "parent domain missing\n");
+		return -EINVAL;
+	}
+
+	hwirq = fwspec->param[0];
+	dev_dbg(priv->dev, "adc child hw irq %lu virt irq %u\n", hwirq, virq);
+
+	ret = irq_domain_set_hwirq_and_chip(dm, virq, hwirq, &stm32_irq_chip, NULL);
+	if (ret < 0)
+		return ret;
+
+	irq_set_chip_data(virq, dm->host_data);
+	irq_set_chip_and_handler(virq, &stm32_irq_chip, handle_level_irq);
+
+	irq_parent = priv->irq_map[hwirq];
+
+	virq_p = irq_find_mapping(dm->parent, irq_parent);
+	dev_dbg(priv->dev, "adc core hw irq %d, virt irq %d\n", irq_parent, virq_p);
+
+	irq_data = irq_get_irq_data(virq);
+	irq_data_p = irq_get_irq_data(virq_p);
+
+	if (!irq_data || !irq_data_p)
+		return -EINVAL;
+
+	irq_data->parent_data = irq_data_p;
+
+	return 0;
+};
+
+static void stm32_adc_core_domain_free(struct irq_domain *domain, unsigned int virq,
+				       unsigned int nr_irqs)
+{
+	struct irq_data *irq_data;
+
+	irq_set_chip_and_handler(virq, NULL, NULL);
+	irq_set_chip_data(virq, NULL);
+
+	irq_data = irq_get_irq_data(virq);
+	if (!irq_data)
+		return;
+
+	irq_data->parent_data = NULL;
 }
 
 static const struct irq_domain_ops stm32_adc_domain_ops = {
-	.map = stm32_adc_domain_map,
-	.unmap  = stm32_adc_domain_unmap,
+	.alloc	= stm32_adc_core_domain_alloc,
+	.free = stm32_adc_core_domain_free,
 	.xlate = irq_domain_xlate_onecell,
 };
 
@@ -389,28 +496,57 @@ static int stm32_adc_irq_probe(struct platform_device *pdev,
 			       struct stm32_adc_priv *priv)
 {
 	struct device_node *np = pdev->dev.of_node;
-	unsigned int i;
+	struct irq_domain *parent_domain;
+	struct irq_data *irqd;
+	int i;
 
 	/*
 	 * Interrupt(s) must be provided, depending on the compatible:
 	 * - stm32f4/h7 shares a common interrupt line.
 	 * - stm32mp1, has one line per ADC
+	 * - stm32mp25, has a dual ADC12 and standalone ADC3. Each ADC has an IRQ
+	 *   (two for ADC12, one for ADC3)
+	 *
+	 * Assume that children hw irqs are numbered from 0 to nb_adc_max-1
+	 * By default hw parent and children irqs are mapped by pair
+	 * If the ADC shares a common irq, all children irqs are mapped on the
+	 * same parent, yet.
 	 */
-	for (i = 0; i < priv->cfg->num_irqs; i++) {
+	for (i = 0; i < priv->nb_irqs; i++) {
 		priv->irq[i] = platform_get_irq(pdev, i);
 		if (priv->irq[i] < 0)
 			return priv->irq[i];
+		irqd = irq_get_irq_data(priv->irq[i]);
+		if (!irqd)
+			return -EINVAL;
+		priv->irq_map[i] = irqd->hwirq;
 	}
 
-	priv->domain = irq_domain_add_simple(np, STM32_ADC_MAX_ADCS, 0,
-					     &stm32_adc_domain_ops,
-					     priv);
+	if (priv->nb_irqs != priv->nb_adc_max) {
+		if (priv->cfg->num_irqs == 1) {
+			for (i = 1; i < priv->nb_adc_max; i++)
+				priv->irq_map[i] = priv->irq_map[0];
+		} else {
+			dev_err(&pdev->dev, "Could not map child irqs on parent irqs\n");
+			return -EINVAL;
+		}
+	}
+
+	parent_domain = irq_find_host(of_irq_find_parent(np));
+	if (!parent_domain) {
+		dev_err(&pdev->dev, "GIC interrupt-parent not found\n");
+		return -EINVAL;
+	}
+
+	priv->domain = irq_domain_add_hierarchy(parent_domain, 0, priv->nb_adc_max,
+						np, &stm32_adc_domain_ops, priv);
+
 	if (!priv->domain) {
 		dev_err(&pdev->dev, "Failed to add irq domain\n");
 		return -ENOMEM;
 	}
 
-	for (i = 0; i < priv->cfg->num_irqs; i++) {
+	for (i = 0; i < priv->nb_irqs; i++) {
 		irq_set_chained_handler(priv->irq[i], stm32_adc_irq_handler);
 		irq_set_handler_data(priv->irq[i], priv);
 	}
@@ -424,12 +560,14 @@ static void stm32_adc_irq_remove(struct platform_device *pdev,
 	int hwirq;
 	unsigned int i;
 
-	for (hwirq = 0; hwirq < STM32_ADC_MAX_ADCS; hwirq++)
+	for (hwirq = 0; hwirq < priv->nb_adc_max; hwirq++)
 		irq_dispose_mapping(irq_find_mapping(priv->domain, hwirq));
 	irq_domain_remove(priv->domain);
 
-	for (i = 0; i < priv->cfg->num_irqs; i++)
+	for (i = 0; i < priv->nb_irqs; i++) {
 		irq_set_chained_handler(priv->irq[i], NULL);
+		irq_dispose_mapping(priv->irq[i]);
+	}
 }
 
 static int stm32_adc_core_switches_supply_en(struct stm32_adc_priv *priv,
@@ -642,6 +780,58 @@ static int stm32_adc_core_switches_probe(struct device *dev,
 	return 0;
 }
 
+static int stm32_adc_sanity_check(struct platform_device *pdev,
+				  struct stm32_adc_priv *priv)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *child;
+	const char *compat;
+	int ret, count = 0;
+	u32 id, val;
+
+	if (!priv->cfg->ipid)
+		return 0;
+
+	id = FIELD_GET(STM32MP13_IPIDR_MASK,
+		       readl_relaxed(priv->common.base + STM32MP13_ADC_IPDR));
+	if (id != priv->cfg->ipid) {
+		dev_err(&pdev->dev, "Unexpected IP version: 0x%x", id);
+		return -EINVAL;
+	}
+
+	for_each_child_of_node(np, child) {
+		ret = of_property_read_string(child, "compatible", &compat);
+		if (ret)
+			continue;
+		/* Count child nodes with stm32 adc compatible */
+		if (strstr(compat, "st,stm32") && strstr(compat, "adc"))
+			count++;
+	}
+
+	val = readl_relaxed(priv->common.base + STM32MP13_ADC_HWCFGR0);
+	priv->nb_adc_max = FIELD_GET(STM32MP13_ADCNUM_MASK, val);
+	if (count > priv->nb_adc_max) {
+		dev_err(&pdev->dev, "Unexpected child number: %d", count);
+		return -EINVAL;
+	}
+
+	/*
+	 * ADC diversity on STM32MP25 is checked here. There may be:
+	 * - 2 IRQs for ADC12 block
+	 * - 1 IRQ for ADC3 block.
+	 * There cannot be more IRQs than the actual number of ADCs.
+	 */
+	if (priv->nb_irqs > priv->nb_adc_max)
+		priv->nb_irqs = priv->nb_adc_max;
+
+	val = readl_relaxed(priv->common.base + STM32MP13_ADC_VERR);
+	dev_dbg(&pdev->dev, "ADC version: %lu.%lu\n",
+		FIELD_GET(STM32MP13_MAJREV_MASK, val),
+		FIELD_GET(STM32MP13_MINREV_MASK, val));
+
+	return 0;
+}
+
 static int stm32_adc_probe(struct platform_device *pdev)
 {
 	struct stm32_adc_priv *priv;
@@ -659,8 +849,12 @@ static int stm32_adc_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	platform_set_drvdata(pdev, &priv->common);
 
+	priv->dev = dev;
 	priv->cfg = (const struct stm32_adc_priv_cfg *)
 		of_match_device(dev->driver->of_match_table, dev)->data;
+	priv->nb_adc_max = priv->cfg->num_adcs;
+	priv->nb_irqs = priv->cfg->num_irqs;
+	spin_lock_init(&priv->common.lock);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	priv->common.base = devm_ioremap_resource(&pdev->dev, res);
@@ -702,6 +896,10 @@ static int stm32_adc_probe(struct platform_device *pdev)
 	if (ret)
 		goto err_pm_stop;
 
+	ret = stm32_adc_sanity_check(pdev, priv);
+	if (ret < 0)
+		goto err_hw_stop;
+
 	ret = regulator_get_voltage(priv->vref);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "vref get voltage failed, %d\n", ret);
@@ -795,7 +993,9 @@ static const struct dev_pm_ops stm32_adc_core_pm_ops = {
 
 static const struct stm32_adc_priv_cfg stm32f4_adc_priv_cfg = {
 	.regs = &stm32f4_adc_common_regs,
-	.clk_sel = stm32f4_adc_clk_sel,
+	.clk_sel = stm32_adc_clk_sel,
+	.presc = stm32f4_pclk_div,
+	.num_presc = ARRAY_SIZE(stm32f4_pclk_div),
 	.max_clk_rate_hz = 36000000,
 	.num_irqs = 1,
 	.num_adcs = 3,
@@ -815,8 +1015,26 @@ static const struct stm32_adc_priv_cfg stm32mp1_adc_priv_cfg = {
 	.clk_sel = stm32h7_adc_clk_sel,
 	.max_clk_rate_hz = 36000000,
 	.has_syscfg = HAS_VBOOSTER | HAS_ANASWVDD,
+	.ipid = STM32MP15_IPIDR_NUMBER,
 	.num_irqs = 2,
-	.num_adcs = 2,
+};
+
+static const struct stm32_adc_priv_cfg stm32mp13_adc_priv_cfg = {
+	.regs = &stm32mp13_adc_common_regs,
+	.clk_sel = stm32h7_adc_clk_sel,
+	.max_clk_rate_hz = 75000000,
+	.ipid = STM32MP13_IPIDR_NUMBER,
+	.num_irqs = 1,
+};
+
+static const struct stm32_adc_priv_cfg stm32mp25_adc_priv_cfg = {
+	.regs = &stm32mp25_adc_common_regs,
+	.clk_sel = stm32_adc_clk_sel,
+	.presc = stm32mp25_presc_div,
+	.num_presc = ARRAY_SIZE(stm32mp25_presc_div),
+	.max_clk_rate_hz = 70000000,
+	.ipid = STM32MP25_IPIDR_NUMBER,
+	.num_irqs = 2, /* 2 IRQs for ADC12, 1 irq for ADC3 */
 };
 
 static const struct of_device_id stm32_adc_of_match[] = {
@@ -829,6 +1047,12 @@ static const struct of_device_id stm32_adc_of_match[] = {
 	}, {
 		.compatible = "st,stm32mp1-adc-core",
 		.data = (void *)&stm32mp1_adc_priv_cfg
+	}, {
+		.compatible = "st,stm32mp13-adc-core",
+		.data = (void *)&stm32mp13_adc_priv_cfg
+	}, {
+		.compatible = "st,stm32mp25-adc-core",
+		.data = (void *)&stm32mp25_adc_priv_cfg
 	}, {
 	},
 };
diff --git a/drivers/iio/adc/stm32-adc-core.h b/drivers/iio/adc/stm32-adc-core.h
index 2322809bf..bcdc3b540 100644
--- a/drivers/iio/adc/stm32-adc-core.h
+++ b/drivers/iio/adc/stm32-adc-core.h
@@ -24,6 +24,7 @@
  * | 0x300  |         Master & Slave common regs          |
  * --------------------------------------------------------
  */
+/* Maximum ADC instances number per ADC block for all supported SoCs */
 #define STM32_ADC_MAX_ADCS		3
 #define STM32_ADC_OFFSET		0x100
 #define STM32_ADCX_COMN_OFFSET		0x300
@@ -90,6 +91,7 @@
 #define STM32H7_ADC_IER			0x04
 #define STM32H7_ADC_CR			0x08
 #define STM32H7_ADC_CFGR		0x0C
+#define STM32H7_ADC_CFGR2		0x10
 #define STM32H7_ADC_SMPR1		0x14
 #define STM32H7_ADC_SMPR2		0x18
 #define STM32H7_ADC_PCSEL		0x1C
@@ -102,6 +104,15 @@
 #define STM32H7_ADC_CALFACT		0xC4
 #define STM32H7_ADC_CALFACT2		0xC8
 
+/* STM32MP1 - ADC2 instance option register */
+#define STM32MP1_ADC2_OR		0xD0
+
+/* STM32MP13 - ADC2 instance option register */
+#define STM32MP13_ADC2_OR		0xC8
+
+/* STM32MP25 - ADC2 and ADC3 option register */
+#define STM32MP25_ADC23_OR		0xD0
+
 /* STM32H7 - common registers for all ADC instances */
 #define STM32H7_ADC_CSR			(STM32_ADCX_COMN_OFFSET + 0x00)
 #define STM32H7_ADC_CCR			(STM32_ADCX_COMN_OFFSET + 0x08)
@@ -127,6 +138,7 @@
 #define STM32H7_LINCALRDYW3		BIT(24)
 #define STM32H7_LINCALRDYW2		BIT(23)
 #define STM32H7_LINCALRDYW1		BIT(22)
+#define STM32H7_LINCALRDYW_MASK		GENMASK(27, 22)
 #define STM32H7_ADCALLIN		BIT(16)
 #define STM32H7_BOOST			BIT(8)
 #define STM32H7_ADSTP			BIT(4)
@@ -144,6 +156,14 @@
 #define STM32H7_DMNGT_SHIFT		0
 #define STM32H7_DMNGT_MASK		GENMASK(1, 0)
 
+/* STM32H7_ADC_CFGR2 bit fields */
+#define STM32H7_OVSR_SHIFT		16 /* Correspond to OSVR field in datasheet */
+#define STM32H7_OVSR_MASK		GENMASK(25, 16)
+#define STM32H7_OVSR_BITS		10
+#define STM32H7_OVSS_SHIFT		5
+#define STM32H7_OVSS_MASK		GENMASK(8, 5)
+#define STM32H7_ROVSE			BIT(0)
+
 enum stm32h7_adc_dmngt {
 	STM32H7_DMNGT_DR_ONLY,		/* Regular data in DR only */
 	STM32H7_DMNGT_DMA_ONESHOT,	/* DMA one shot mode */
@@ -151,6 +171,10 @@ enum stm32h7_adc_dmngt {
 	STM32H7_DMNGT_DMA_CIRC,		/* DMA circular mode */
 };
 
+/* STM32H7_ADC_DIFSEL - bit fields */
+#define STM32H7_DIFSEL_SHIFT		0
+#define STM32H7_DIFSEL_MASK		GENMASK(19, 0)
+
 /* STM32H7_ADC_CALFACT - bit fields */
 #define STM32H7_CALFACT_D_SHIFT		16
 #define STM32H7_CALFACT_D_MASK		GENMASK(26, 16)
@@ -168,23 +192,110 @@ enum stm32h7_adc_dmngt {
 #define STM32H7_EOC_MST			BIT(2)
 
 /* STM32H7_ADC_CCR - bit fields */
+#define STM32H7_VBATEN			BIT(24)
+#define STM32H7_VREFEN			BIT(22)
 #define STM32H7_PRESC_SHIFT		18
 #define STM32H7_PRESC_MASK		GENMASK(21, 18)
 #define STM32H7_CKMODE_SHIFT		16
 #define STM32H7_CKMODE_MASK		GENMASK(17, 16)
 
+/* STM32MP1_ADC2_OR - bit fields */
+#define STM32MP1_VDDCOREEN		BIT(0)
+
+/* STM32MP13 - Registers for each ADC instance */
+#define STM32MP13_ADC_DIFSEL		0xB0
+#define STM32MP13_ADC_CALFACT		0xB4
+#define STM32MP13_ADC_HWCFGR0		0x3F0
+#define STM32MP13_ADC_VERR		0x3F4
+#define STM32MP13_ADC_IPDR		0x3F8
+#define STM32MP13_ADC_SIDR		0x3FC
+
+/* STM32MP13_ADC_CFGR specific bit fields */
+#define STM32MP13_DMAEN			BIT(0)
+#define STM32MP13_DMACFG		BIT(1)
+#define STM32MP13_DFSDMCFG		BIT(2)
+#define STM32MP13_RES_SHIFT		3
+#define STM32MP13_RES_MASK		GENMASK(4, 3)
+
+/* STM32MP13_ADC_CFGR2 bit fields */
+#define STM32MP13_OVSR_SHIFT		2
+#define STM32MP13_OVSR_MASK		GENMASK(4, 2)
+#define STM32MP13_OVSR_BITS		3
+#define STM32MP13_OVSS_SHIFT		5
+#define STM32MP13_OVSS_MASK		GENMASK(8, 5)
+
+/* STM32MP13_ADC_DIFSEL - bit fields */
+#define STM32MP13_DIFSEL_SHIFT		0
+#define STM32MP13_DIFSEL_MASK		GENMASK(18, 0)
+
+/* STM32MP13_ADC_CALFACT - bit fields */
+#define STM32MP13_CALFACT_D_SHIFT	16
+#define STM32MP13_CALFACT_D_MASK	GENMASK(22, 16)
+#define STM32MP13_CALFACT_S_SHIFT	0
+#define STM32MP13_CALFACT_S_MASK	GENMASK(6, 0)
+
+/* STM32MP13_ADC2_OR - bit fields */
+#define STM32MP13_OP2			BIT(2)
+#define STM32MP13_OP1			BIT(1)
+#define STM32MP13_OP0			BIT(0)
+
+/* STM32MP25 - Registers for each ADC instance */
+#define STM32MP25_ADC_CALFACT		0xC4
+
+/* STM32MP25_ADC_CALFACT - bit fields */
+#define STM32MP25_CALFACT_CALADDOS	BIT(31)
+#define STM32MP25_CALFACT_D_MASK	GENMASK(24, 16)
+#define STM32MP25_CALFACT_S_MASK	GENMASK(8, 0)
+
+/* STM32MP25_ADC_CFGR specific bit fields */
+#define STM32MP25_RES_SHIFT		2
+#define STM32MP25_RES_MASK		GENMASK(3, 2)
+
+/* STM32MP25_ADC23_OR - specific bit fields */
+#define STM32MP25_VDDCOREEN		BIT(2)
+#define STM32MP25_SELBG			BIT(1)
+#define STM32MP25_SELREF		BIT(0)
+
+/* STM32MP13_ADC_HWCFGR0 - bit fields */
+#define STM32MP13_ADCNUM_SHIFT		0
+#define STM32MP13_ADCNUM_MASK		GENMASK(3, 0)
+#define STM32MP13_MULPIPE_SHIFT		4
+#define STM32MP13_MULPIPE_MASK		GENMASK(7, 4)
+#define STM32MP13_OPBITS_SHIFT		8
+#define STM32MP13_OPBITS_MASK		GENMASK(11, 8)
+#define STM32MP13_IDLEVALUE_SHIFT	12
+#define STM32MP13_IDLEVALUE_MASK	GENMASK(15, 12)
+
+/* STM32MP13_ADC_VERR - bit fields */
+#define STM32MP13_MINREV_SHIFT		0
+#define STM32MP13_MINREV_MASK		GENMASK(3, 0)
+#define STM32MP13_MAJREV_SHIFT		4
+#define STM32MP13_MAJREV_MASK		GENMASK(7, 4)
+
+/* STM32MP13_ADC_IPDR - bit fields */
+#define STM32MP13_IPIDR_MASK		GENMASK(31, 0)
+
+/* STM32MP13_ADC_SIDR - bit fields */
+#define STM32MP13_SIDR_MASK		GENMASK(31, 0)
+
+#define STM32MP15_IPIDR_NUMBER		0x00110005
+#define STM32MP13_IPIDR_NUMBER		0x00110006
+#define STM32MP25_IPIDR_NUMBER		0x00110008
+
 /**
  * struct stm32_adc_common - stm32 ADC driver common data (for all instances)
  * @base:		control registers base cpu addr
  * @phys_base:		control registers base physical addr
  * @rate:		clock rate used for analog circuitry
  * @vref_mv:		vref voltage (mv)
+ * @lock:		spinlock
  */
 struct stm32_adc_common {
 	void __iomem			*base;
 	phys_addr_t			phys_base;
 	unsigned long			rate;
 	int				vref_mv;
+	spinlock_t			lock;		/* lock for common register */
 };
 
 #endif
diff --git a/drivers/iio/adc/stm32-adc.c b/drivers/iio/adc/stm32-adc.c
index ef5b54ed9..8fbdf721f 100644
--- a/drivers/iio/adc/stm32-adc.c
+++ b/drivers/iio/adc/stm32-adc.c
@@ -6,12 +6,15 @@
  * Author: Fabrice Gasnier <fabrice.gasnier@st.com>.
  */
 
+#include <linux/bitfield.h>
 #include <linux/clk.h>
+#include <linux/debugfs.h>
 #include <linux/delay.h>
 #include <linux/dma-mapping.h>
 #include <linux/dmaengine.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/buffer.h>
+#include <linux/iio/sysfs.h>
 #include <linux/iio/timer/stm32-lptim-trigger.h>
 #include <linux/iio/timer/stm32-timer-trigger.h>
 #include <linux/iio/trigger.h>
@@ -21,26 +24,32 @@
 #include <linux/io.h>
 #include <linux/iopoll.h>
 #include <linux/module.h>
+#include <linux/nvmem-consumer.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
+#include <linux/util_macros.h>
 
 #include "stm32-adc-core.h"
 
 /* Number of linear calibration shadow registers / LINCALRDYW control bits */
 #define STM32H7_LINCALFACT_NUM		6
 
+/* Number of loops in the calibration procedure to average data on STM32MP25 */
+#define STM32MP25_CALIB_LOOP		8
+
 /* BOOST bit must be set on STM32H7 when ADC clock is above 20MHz */
 #define STM32H7_BOOST_CLKRATE		20000000UL
 
 #define STM32_ADC_CH_MAX		20	/* max number of channels */
-#define STM32_ADC_CH_SZ			10	/* max channel name size */
+#define STM32_ADC_CH_SZ			16	/* max channel name size */
 #define STM32_ADC_MAX_SQ		16	/* SQ1..SQ16 */
 #define STM32_ADC_MAX_SMP		7	/* SMPx range is [0..7] */
 #define STM32_ADC_TIMEOUT_US		100000
 #define STM32_ADC_TIMEOUT	(msecs_to_jiffies(STM32_ADC_TIMEOUT_US / 1000))
 #define STM32_ADC_HW_STOP_DELAY_MS	100
+#define STM32_ADC_VREFINT_VOLTAGE	3300
 
 #define STM32_DMA_BUFFER_SIZE		PAGE_SIZE
 
@@ -75,6 +84,42 @@ enum stm32_adc_extsel {
 	STM32_EXT18,
 	STM32_EXT19,
 	STM32_EXT20,
+	STM32_EXT21,
+	STM32_EXT22,
+	STM32_EXT23,
+	STM32_EXT24,
+	STM32_EXT25,
+	STM32_EXT26,
+	STM32_EXT27,
+	STM32_EXT28,
+};
+
+enum stm32_adc_int_ch {
+	STM32_ADC_INT_CH_NONE = -1,
+	STM32_ADC_INT_CH_VDDCORE,
+	STM32_ADC_INT_CH_VDDCPU,
+	STM32_ADC_INT_CH_VDDQ_DDR,
+	STM32_ADC_INT_CH_VREFINT,
+	STM32_ADC_INT_CH_VBAT,
+	STM32_ADC_INT_CH_NB,
+};
+
+/**
+ * struct stm32_adc_ic - ADC internal channels
+ * @name:	name of the internal channel
+ * @idx:	internal channel enum index
+ */
+struct stm32_adc_ic {
+	const char *name;
+	u32 idx;
+};
+
+static const struct stm32_adc_ic stm32_adc_ic[STM32_ADC_INT_CH_NB] = {
+	{ "vddcore", STM32_ADC_INT_CH_VDDCORE },
+	{ "vddcpu", STM32_ADC_INT_CH_VDDCPU },
+	{ "vddq_ddr", STM32_ADC_INT_CH_VDDQ_DDR },
+	{ "vrefint", STM32_ADC_INT_CH_VREFINT },
+	{ "vbat", STM32_ADC_INT_CH_VBAT },
 };
 
 /**
@@ -89,16 +134,12 @@ struct stm32_adc_trig_info {
 
 /**
  * struct stm32_adc_calib - optional adc calibration data
- * @calfact_s: Calibration offset for single ended channels
- * @calfact_d: Calibration offset in differential
  * @lincalfact: Linearity calibration factor
- * @calibrated: Indicates calibration status
+ * @lincal_saved: Indicates that linear calibration factors are saved
  */
 struct stm32_adc_calib {
-	u32			calfact_s;
-	u32			calfact_d;
 	u32			lincalfact[STM32H7_LINCALFACT_NUM];
-	bool			calibrated;
+	bool			lincal_saved;
 };
 
 /**
@@ -113,6 +154,16 @@ struct stm32_adc_regs {
 	int shift;
 };
 
+/**
+ * struct stm32_adc_vrefint - stm32 ADC internal reference voltage data
+ * @vrefint_cal:	vrefint calibration value from nvmem
+ * @vrefint_data:	vrefint actual value
+ */
+struct stm32_adc_vrefint {
+	u32 vrefint_cal;
+	u32 vrefint_data;
+};
+
 /**
  * struct stm32_adc_regspec - stm32 registers definition
  * @dr:			data register offset
@@ -124,8 +175,14 @@ struct stm32_adc_regs {
  * @exten:		trigger control register & bitfield
  * @extsel:		trigger selection register & bitfield
  * @res:		resolution selection register & bitfield
+ * @difsel:		differential mode selection register & bitfield
  * @smpr:		smpr1 & smpr2 registers offset array
  * @smp_bits:		smpr1 & smpr2 index and bitfields
+ * @or_vddcore:		option register & vddcore bitfield
+ * @or_vddcpu:		option register & vddcpu bitfield
+ * @or_vddq_ddr:	option register & vddq_ddr bitfield
+ * @ccr_vbat:		common register & vbat bitfield
+ * @ccr_vref:		common register & vrefint bitfield
  */
 struct stm32_adc_regspec {
 	const u32 dr;
@@ -137,8 +194,14 @@ struct stm32_adc_regspec {
 	const struct stm32_adc_regs exten;
 	const struct stm32_adc_regs extsel;
 	const struct stm32_adc_regs res;
+	const struct stm32_adc_regs difsel;
 	const u32 smpr[2];
 	const struct stm32_adc_regs *smp_bits;
+	const struct stm32_adc_regs or_vddcore;
+	const struct stm32_adc_regs or_vddcpu;
+	const struct stm32_adc_regs or_vddq_ddr;
+	const struct stm32_adc_regs ccr_vbat;
+	const struct stm32_adc_regs ccr_vref;
 };
 
 struct stm32_adc;
@@ -150,12 +213,18 @@ struct stm32_adc;
  * @trigs:		external trigger sources
  * @clk_required:	clock is required
  * @has_vregready:	vregready status flag presence
+ * @has_boostmode:	boost mode support flag
+ * @has_linearcal:	linear calibration support flag
+ * @has_presel:		channel preselection support flag
+ * @has_oversampling:	oversampling support flag
  * @prepare:		optional prepare routine (power-up, enable)
  * @start_conv:		routine to start conversions
  * @stop_conv:		routine to stop conversions
  * @unprepare:		optional unprepare routine (disable, power-down)
  * @irq_clear:		routine to clear irqs
+ * @set_ovs:		routine to set oversampling configuration
  * @smp_cycles:		programmable sampling time (ADC clock cycles)
+ * @ts_int_ch:		pointer to array of internal channels minimum sampling time in ns
  */
 struct stm32_adc_cfg {
 	const struct stm32_adc_regspec	*regs;
@@ -163,12 +232,18 @@ struct stm32_adc_cfg {
 	struct stm32_adc_trig_info	*trigs;
 	bool clk_required;
 	bool has_vregready;
+	bool has_boostmode;
+	bool has_linearcal;
+	bool has_presel;
+	bool has_oversampling;
 	int (*prepare)(struct iio_dev *);
 	void (*start_conv)(struct iio_dev *, bool dma);
 	void (*stop_conv)(struct iio_dev *);
 	void (*unprepare)(struct iio_dev *);
 	void (*irq_clear)(struct iio_dev *indio_dev, u32 msk);
+	void (*set_ovs)(struct iio_dev *indio_dev, u32 ovs_idx);
 	const unsigned int *smp_cycles;
+	const unsigned int *ts_int_ch;
 };
 
 /**
@@ -193,7 +268,11 @@ struct stm32_adc_cfg {
  * @pcsel:		bitmask to preselect channels on some devices
  * @smpr_val:		sampling time settings (e.g. smpr1 / smpr2)
  * @cal:		optional calibration data on some devices
+ * @vrefint:		internal reference voltage data
  * @chan_name:		channel name array
+ * @num_diff:		number of differential channels
+ * @int_ch:		internal channel indexes array
+ * @ovs_idx:		current oversampling ratio index (in oversampling array)
  */
 struct stm32_adc {
 	struct stm32_adc_common	*common;
@@ -216,7 +295,11 @@ struct stm32_adc {
 	u32			pcsel;
 	u32			smpr_val[2];
 	struct stm32_adc_calib	cal;
+	struct stm32_adc_vrefint vrefint;
 	char			chan_name[STM32_ADC_CH_MAX][STM32_ADC_CH_SZ];
+	u32			num_diff;
+	int			int_ch[STM32_ADC_INT_CH_NB];
+	int			ovs_idx;
 };
 
 struct stm32_adc_diff_channel {
@@ -228,12 +311,24 @@ struct stm32_adc_diff_channel {
  * struct stm32_adc_info - stm32 ADC, per instance config data
  * @max_channels:	Number of channels
  * @resolutions:	available resolutions
+ * @oversampling:	available oversampling ratios
  * @num_res:		number of available resolutions
+ * @num_ovs:		number of available oversampling ratios
  */
 struct stm32_adc_info {
 	int max_channels;
 	const unsigned int *resolutions;
+	const unsigned int *oversampling;
 	const unsigned int num_res;
+	const unsigned int num_ovs;
+};
+
+static const unsigned int stm32h7_adc_oversampling_avail[] = {
+1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024
+};
+
+static const unsigned int stm32mp13_adc_oversampling_avail[] = {
+1, 2, 4, 8, 16, 32, 64, 128, 256
 };
 
 static const unsigned int stm32f4_adc_resolutions[] = {
@@ -257,7 +352,27 @@ static const unsigned int stm32h7_adc_resolutions[] = {
 static const struct stm32_adc_info stm32h7_adc_info = {
 	.max_channels = STM32_ADC_CH_MAX,
 	.resolutions = stm32h7_adc_resolutions,
+	.oversampling = stm32h7_adc_oversampling_avail,
 	.num_res = ARRAY_SIZE(stm32h7_adc_resolutions),
+	.num_ovs = ARRAY_SIZE(stm32h7_adc_oversampling_avail),
+};
+
+/* stm32mp13 can have up to 19 channels */
+static const struct stm32_adc_info stm32mp13_adc_info = {
+	.max_channels = 19,
+	.resolutions = stm32f4_adc_resolutions,
+	.oversampling = stm32mp13_adc_oversampling_avail,
+	.num_res = ARRAY_SIZE(stm32f4_adc_resolutions),
+	.num_ovs = ARRAY_SIZE(stm32mp13_adc_oversampling_avail),
+};
+
+/* stm32mp25 can have up to 20 channels */
+static const struct stm32_adc_info stm32mp25_adc_info = {
+	.max_channels = STM32_ADC_CH_MAX,
+	.resolutions = stm32f4_adc_resolutions,
+	.oversampling = stm32h7_adc_oversampling_avail,
+	.num_res = ARRAY_SIZE(stm32f4_adc_resolutions),
+	.num_ovs = ARRAY_SIZE(stm32h7_adc_oversampling_avail),
 };
 
 /*
@@ -445,8 +560,106 @@ static const struct stm32_adc_regspec stm32h7_adc_regspec = {
 	.extsel = { STM32H7_ADC_CFGR, STM32H7_EXTSEL_MASK,
 		    STM32H7_EXTSEL_SHIFT },
 	.res = { STM32H7_ADC_CFGR, STM32H7_RES_MASK, STM32H7_RES_SHIFT },
+	.difsel = { STM32H7_ADC_DIFSEL, STM32H7_DIFSEL_MASK},
+	.smpr = { STM32H7_ADC_SMPR1, STM32H7_ADC_SMPR2 },
+	.smp_bits = stm32h7_smp_bits,
+};
+
+/* STM32MP25 external trigger sources for all instances */
+static struct stm32_adc_trig_info stm32mp25_adc_trigs[] = {
+	{ TIM1_TRGO, STM32_EXT0 },
+	{ TIM1_TRGO2, STM32_EXT1 },
+	{ TIM8_TRGO, STM32_EXT2 },
+	{ TIM8_TRGO2, STM32_EXT3 },
+	{ TIM2_TRGO, STM32_EXT6 },
+	{ TIM3_TRGO, STM32_EXT7 },
+	{ TIM4_TRGO, STM32_EXT8 },
+	{ TIM5_TRGO, STM32_EXT9 },
+	{ TIM6_TRGO, STM32_EXT10 },
+	{ TIM15_TRGO, STM32_EXT11 },
+	{ TIM1_CH1, STM32_EXT12 },
+	{ TIM1_CH2, STM32_EXT13 },
+	{ TIM1_CH3, STM32_EXT14 },
+	{ TIM2_CH2, STM32_EXT18 },
+	{ TIM3_CH4, STM32_EXT19 },
+	{ TIM4_CH4, STM32_EXT20 },
+	{ TIM5_CH1, STM32_EXT21 },
+	{ TIM12_CH1, STM32_EXT22 },
+	{ LPTIM1_OUT, STM32_EXT24 },
+	{ LPTIM2_OUT, STM32_EXT25 },
+	{ LPTIM3_OUT, STM32_EXT26 },
+	{ LPTIM4_OUT, STM32_EXT27 },
+	{ LPTIM5_OUT, STM32_EXT28 },
+	{},
+};
+
+/* STM32MP25 programmable sampling time (ADC clock cycles, rounded down) */
+static const unsigned int stm32mp25_adc_smp_cycles[STM32_ADC_MAX_SMP + 1] = {
+	2, 3, 7, 12, 24, 47, 247, 1501,
+};
+
+static const struct stm32_adc_regspec stm32mp25_adc_regspec = {
+	.dr = STM32H7_ADC_DR,
+	.ier_eoc = { STM32H7_ADC_IER, STM32H7_EOCIE },
+	.ier_ovr = { STM32H7_ADC_IER, STM32H7_OVRIE },
+	.isr_eoc = { STM32H7_ADC_ISR, STM32H7_EOC },
+	.isr_ovr = { STM32H7_ADC_ISR, STM32H7_OVR },
+	.sqr = stm32h7_sq,
+	.exten = { STM32H7_ADC_CFGR, STM32H7_EXTEN_MASK, STM32H7_EXTEN_SHIFT },
+	.extsel = { STM32H7_ADC_CFGR, STM32H7_EXTSEL_MASK,
+		    STM32H7_EXTSEL_SHIFT },
+	.res = { STM32H7_ADC_CFGR, STM32MP25_RES_MASK, STM32MP25_RES_SHIFT },
+	.difsel = { STM32H7_ADC_DIFSEL, STM32H7_DIFSEL_MASK},
+	.smpr = { STM32H7_ADC_SMPR1, STM32H7_ADC_SMPR2 },
+	.smp_bits = stm32h7_smp_bits,
+	.or_vddcore = { STM32MP25_ADC23_OR, STM32MP25_VDDCOREEN },
+	.ccr_vbat = { STM32H7_ADC_CCR, STM32H7_VBATEN },
+	.ccr_vref = { STM32H7_ADC_CCR, STM32H7_VREFEN },
+};
+
+/* STM32MP13 programmable sampling time (ADC clock cycles, rounded down) */
+static const unsigned int stm32mp13_adc_smp_cycles[STM32_ADC_MAX_SMP + 1] = {
+	2, 6, 12, 24, 47, 92, 247, 640,
+};
+
+static const struct stm32_adc_regspec stm32mp13_adc_regspec = {
+	.dr = STM32H7_ADC_DR,
+	.ier_eoc = { STM32H7_ADC_IER, STM32H7_EOCIE },
+	.ier_ovr = { STM32H7_ADC_IER, STM32H7_OVRIE },
+	.isr_eoc = { STM32H7_ADC_ISR, STM32H7_EOC },
+	.isr_ovr = { STM32H7_ADC_ISR, STM32H7_OVR },
+	.sqr = stm32h7_sq,
+	.exten = { STM32H7_ADC_CFGR, STM32H7_EXTEN_MASK, STM32H7_EXTEN_SHIFT },
+	.extsel = { STM32H7_ADC_CFGR, STM32H7_EXTSEL_MASK,
+		    STM32H7_EXTSEL_SHIFT },
+	.res = { STM32H7_ADC_CFGR, STM32MP13_RES_MASK, STM32MP13_RES_SHIFT },
+	.difsel = { STM32MP13_ADC_DIFSEL, STM32MP13_DIFSEL_MASK},
+	.smpr = { STM32H7_ADC_SMPR1, STM32H7_ADC_SMPR2 },
+	.smp_bits = stm32h7_smp_bits,
+	.or_vddcore = { STM32MP13_ADC2_OR, STM32MP13_OP0 },
+	.or_vddcpu = { STM32MP13_ADC2_OR, STM32MP13_OP1 },
+	.or_vddq_ddr = { STM32MP13_ADC2_OR, STM32MP13_OP2 },
+	.ccr_vbat = { STM32H7_ADC_CCR, STM32H7_VBATEN },
+	.ccr_vref = { STM32H7_ADC_CCR, STM32H7_VREFEN },
+};
+
+static const struct stm32_adc_regspec stm32mp1_adc_regspec = {
+	.dr = STM32H7_ADC_DR,
+	.ier_eoc = { STM32H7_ADC_IER, STM32H7_EOCIE },
+	.ier_ovr = { STM32H7_ADC_IER, STM32H7_OVRIE },
+	.isr_eoc = { STM32H7_ADC_ISR, STM32H7_EOC },
+	.isr_ovr = { STM32H7_ADC_ISR, STM32H7_OVR },
+	.sqr = stm32h7_sq,
+	.exten = { STM32H7_ADC_CFGR, STM32H7_EXTEN_MASK, STM32H7_EXTEN_SHIFT },
+	.extsel = { STM32H7_ADC_CFGR, STM32H7_EXTSEL_MASK,
+		    STM32H7_EXTSEL_SHIFT },
+	.res = { STM32H7_ADC_CFGR, STM32H7_RES_MASK, STM32H7_RES_SHIFT },
+	.difsel = { STM32H7_ADC_DIFSEL, STM32H7_DIFSEL_MASK},
 	.smpr = { STM32H7_ADC_SMPR1, STM32H7_ADC_SMPR2 },
 	.smp_bits = stm32h7_smp_bits,
+	.or_vddcore = { STM32MP1_ADC2_OR, STM32MP1_VDDCOREEN },
+	.ccr_vbat = { STM32H7_ADC_CCR, STM32H7_VBATEN },
+	.ccr_vref = { STM32H7_ADC_CCR, STM32H7_VREFEN },
 };
 
 /*
@@ -487,6 +700,14 @@ static void stm32_adc_set_bits(struct stm32_adc *adc, u32 reg, u32 bits)
 	spin_unlock_irqrestore(&adc->lock, flags);
 }
 
+static void stm32_adc_set_bits_common(struct stm32_adc *adc, u32 reg, u32 bits)
+{
+	spin_lock(&adc->common->lock);
+	writel_relaxed(readl_relaxed(adc->common->base + reg) | bits,
+		       adc->common->base + reg);
+	spin_unlock(&adc->common->lock);
+}
+
 static void stm32_adc_clr_bits(struct stm32_adc *adc, u32 reg, u32 bits)
 {
 	unsigned long flags;
@@ -496,6 +717,14 @@ static void stm32_adc_clr_bits(struct stm32_adc *adc, u32 reg, u32 bits)
 	spin_unlock_irqrestore(&adc->lock, flags);
 }
 
+static void stm32_adc_clr_bits_common(struct stm32_adc *adc, u32 reg, u32 bits)
+{
+	spin_lock(&adc->common->lock);
+	writel_relaxed(readl_relaxed(adc->common->base + reg) & ~bits,
+		       adc->common->base + reg);
+	spin_unlock(&adc->common->lock);
+}
+
 /**
  * stm32_adc_conv_irq_enable() - Enable end of conversion interrupt
  * @adc: stm32 adc instance
@@ -577,6 +806,78 @@ static int stm32_adc_hw_start(struct device *dev)
 	return ret;
 }
 
+static void stm32_adc_int_ch_enable(struct iio_dev *indio_dev)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+	u32 i;
+
+	for (i = 0; i < STM32_ADC_INT_CH_NB; i++) {
+		if (adc->int_ch[i] == STM32_ADC_INT_CH_NONE)
+			continue;
+
+		switch (i) {
+		case STM32_ADC_INT_CH_VDDCORE:
+			dev_dbg(&indio_dev->dev, "Enable VDDCore\n");
+			stm32_adc_set_bits(adc, adc->cfg->regs->or_vddcore.reg,
+					   adc->cfg->regs->or_vddcore.mask);
+			break;
+		case STM32_ADC_INT_CH_VDDCPU:
+			dev_dbg(&indio_dev->dev, "Enable VDDCPU\n");
+			stm32_adc_set_bits(adc, adc->cfg->regs->or_vddcpu.reg,
+					   adc->cfg->regs->or_vddcpu.mask);
+			break;
+		case STM32_ADC_INT_CH_VDDQ_DDR:
+			dev_dbg(&indio_dev->dev, "Enable VDDQ_DDR\n");
+			stm32_adc_set_bits(adc, adc->cfg->regs->or_vddq_ddr.reg,
+					   adc->cfg->regs->or_vddq_ddr.mask);
+			break;
+		case STM32_ADC_INT_CH_VREFINT:
+			dev_dbg(&indio_dev->dev, "Enable VREFInt\n");
+			stm32_adc_set_bits_common(adc, adc->cfg->regs->ccr_vref.reg,
+						  adc->cfg->regs->ccr_vref.mask);
+			break;
+		case STM32_ADC_INT_CH_VBAT:
+			dev_dbg(&indio_dev->dev, "Enable VBAT\n");
+			stm32_adc_set_bits_common(adc, adc->cfg->regs->ccr_vbat.reg,
+						  adc->cfg->regs->ccr_vbat.mask);
+			break;
+		}
+	}
+}
+
+static void stm32_adc_int_ch_disable(struct stm32_adc *adc)
+{
+	u32 i;
+
+	for (i = 0; i < STM32_ADC_INT_CH_NB; i++) {
+		if (adc->int_ch[i] == STM32_ADC_INT_CH_NONE)
+			continue;
+
+		switch (i) {
+		case STM32_ADC_INT_CH_VDDCORE:
+			stm32_adc_clr_bits(adc, adc->cfg->regs->or_vddcore.reg,
+					   adc->cfg->regs->or_vddcore.mask);
+			break;
+		case STM32_ADC_INT_CH_VDDCPU:
+			stm32_adc_clr_bits(adc, adc->cfg->regs->or_vddcpu.reg,
+					   adc->cfg->regs->or_vddcpu.mask);
+			break;
+		case STM32_ADC_INT_CH_VDDQ_DDR:
+			stm32_adc_clr_bits(adc, adc->cfg->regs->or_vddq_ddr.reg,
+					   adc->cfg->regs->or_vddq_ddr.mask);
+			break;
+		case STM32_ADC_INT_CH_VREFINT:
+			stm32_adc_clr_bits_common(adc, adc->cfg->regs->ccr_vref.reg,
+						  adc->cfg->regs->ccr_vref.mask);
+			break;
+		case STM32_ADC_INT_CH_VBAT:
+			stm32_adc_clr_bits_common(adc, adc->cfg->regs->ccr_vbat.reg,
+						  adc->cfg->regs->ccr_vbat.mask);
+			break;
+		}
+	}
+}
+
 /**
  * stm32f4_adc_start_conv() - Start conversions for regular channels.
  * @indio_dev: IIO device instance
@@ -661,6 +962,7 @@ static void stm32h7_adc_stop_conv(struct iio_dev *indio_dev)
 	if (ret)
 		dev_warn(&indio_dev->dev, "stop failed\n");
 
+	/* STM32H7_DMNGT_MASK covers STM32MP13_DMAEN & STM32MP13_DMACFG */
 	stm32_adc_clr_bits(adc, STM32H7_ADC_CFGR, STM32H7_DMNGT_MASK);
 }
 
@@ -671,6 +973,55 @@ static void stm32h7_adc_irq_clear(struct iio_dev *indio_dev, u32 msk)
 	stm32_adc_set_bits(adc, adc->cfg->regs->isr_eoc.reg, msk);
 }
 
+static void stm32mp13_adc_start_conv(struct iio_dev *indio_dev, bool dma)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+
+	if (dma)
+		stm32_adc_set_bits(adc, STM32H7_ADC_CFGR,
+				   STM32MP13_DMAEN | STM32MP13_DMACFG);
+
+	stm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADSTART);
+}
+
+static void stm32h7_adc_set_ovs(struct iio_dev *indio_dev, u32 ovs_idx)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+	u32 ovsr_bits, bits, msk = STM32H7_ROVSE;
+
+	msk |= STM32H7_OVSR_MASK | STM32H7_OVSS_MASK;
+	stm32_adc_clr_bits(adc, STM32H7_ADC_CFGR2, msk);
+
+	if (!ovs_idx)
+		return;
+
+	bits = STM32H7_ROVSE;
+	ovsr_bits = (1 << ovs_idx) - 1;
+	bits |= ovsr_bits << STM32H7_OVSR_SHIFT;
+	bits |= ovs_idx << STM32H7_OVSS_SHIFT;
+
+	stm32_adc_set_bits(adc, STM32H7_ADC_CFGR2, bits & msk);
+}
+
+static void stm32mp13_adc_set_ovs(struct iio_dev *indio_dev, u32 ovs_idx)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+	u32 bits, msk = STM32H7_ROVSE;
+
+	msk |= STM32MP13_OVSR_MASK | STM32MP13_OVSS_MASK;
+	stm32_adc_clr_bits(adc, STM32H7_ADC_CFGR2, msk);
+
+	if (!ovs_idx)
+		return;
+
+	bits = STM32H7_ROVSE;
+	if (ovs_idx - 1)
+		bits |= (ovs_idx - 1) << STM32MP13_OVSR_SHIFT;
+	bits |= ovs_idx << STM32MP13_OVSS_SHIFT;
+
+	stm32_adc_set_bits(adc, STM32H7_ADC_CFGR2, bits & msk);
+}
+
 static int stm32h7_adc_exit_pwr_down(struct iio_dev *indio_dev)
 {
 	struct stm32_adc *adc = iio_priv(indio_dev);
@@ -681,7 +1032,8 @@ static int stm32h7_adc_exit_pwr_down(struct iio_dev *indio_dev)
 	stm32_adc_clr_bits(adc, STM32H7_ADC_CR, STM32H7_DEEPPWD);
 	stm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADVREGEN);
 
-	if (adc->common->rate > STM32H7_BOOST_CLKRATE)
+	if (adc->cfg->has_boostmode &&
+	    adc->common->rate > STM32H7_BOOST_CLKRATE)
 		stm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_BOOST);
 
 	/* Wait for startup time */
@@ -703,7 +1055,8 @@ static int stm32h7_adc_exit_pwr_down(struct iio_dev *indio_dev)
 
 static void stm32h7_adc_enter_pwr_down(struct stm32_adc *adc)
 {
-	stm32_adc_clr_bits(adc, STM32H7_ADC_CR, STM32H7_BOOST);
+	if (adc->cfg->has_boostmode)
+		stm32_adc_clr_bits(adc, STM32H7_ADC_CR, STM32H7_BOOST);
 
 	/* Setting DEEPPWD disables ADC vreg and clears ADVREGEN */
 	stm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_DEEPPWD);
@@ -738,6 +1091,9 @@ static void stm32h7_adc_disable(struct iio_dev *indio_dev)
 	int ret;
 	u32 val;
 
+	if (!(stm32_adc_readl(adc, STM32H7_ADC_CR) & STM32H7_ADEN))
+		return;
+
 	/* Disable ADC and wait until it's effectively disabled */
 	stm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADDIS);
 	ret = stm32_adc_readl_poll_timeout(STM32H7_ADC_CR, val,
@@ -779,14 +1135,7 @@ static int stm32h7_adc_read_selfcalib(struct iio_dev *indio_dev)
 
 		lincalrdyw_mask >>= 1;
 	}
-
-	/* Read offset calibration */
-	val = stm32_adc_readl(adc, STM32H7_ADC_CALFACT);
-	adc->cal.calfact_s = (val & STM32H7_CALFACT_S_MASK);
-	adc->cal.calfact_s >>= STM32H7_CALFACT_S_SHIFT;
-	adc->cal.calfact_d = (val & STM32H7_CALFACT_D_MASK);
-	adc->cal.calfact_d >>= STM32H7_CALFACT_D_SHIFT;
-	adc->cal.calibrated = true;
+	adc->cal.lincal_saved = true;
 
 	return 0;
 }
@@ -802,10 +1151,6 @@ static int stm32h7_adc_restore_selfcalib(struct iio_dev *indio_dev)
 	int i, ret;
 	u32 lincalrdyw_mask, val;
 
-	val = (adc->cal.calfact_s << STM32H7_CALFACT_S_SHIFT) |
-		(adc->cal.calfact_d << STM32H7_CALFACT_D_SHIFT);
-	stm32_adc_writel(adc, STM32H7_ADC_CALFACT, val);
-
 	lincalrdyw_mask = STM32H7_LINCALRDYW6;
 	for (i = STM32H7_LINCALFACT_NUM - 1; i >= 0; i--) {
 		/*
@@ -867,24 +1212,30 @@ static int stm32h7_adc_restore_selfcalib(struct iio_dev *indio_dev)
 /**
  * stm32h7_adc_selfcalib() - Procedure to calibrate ADC
  * @indio_dev: IIO device instance
+ * @do_lincal: linear calibration request flag
  * Note: Must be called once ADC is out of power down.
+ *
+ * Run offset calibration unconditionally.
+ * Run linear calibration if requested & supported.
  */
-static int stm32h7_adc_selfcalib(struct iio_dev *indio_dev)
+static int stm32h7_adc_selfcalib(struct iio_dev *indio_dev, int do_lincal)
 {
 	struct stm32_adc *adc = iio_priv(indio_dev);
 	int ret;
-	u32 val;
+	u32 val, msk = STM32H7_ADCALDIF;
 
-	if (adc->cal.calibrated)
-		return true;
+	if (adc->cfg->has_linearcal && do_lincal)
+		msk |= STM32H7_ADCALLIN;
+
+	/* ADC must be disabled for calibration */
+	stm32h7_adc_disable(indio_dev);
 
 	/*
 	 * Select calibration mode:
 	 * - Offset calibration for single ended inputs
 	 * - No linearity calibration (do it later, before reading it)
 	 */
-	stm32_adc_clr_bits(adc, STM32H7_ADC_CR, STM32H7_ADCALDIF);
-	stm32_adc_clr_bits(adc, STM32H7_ADC_CR, STM32H7_ADCALLIN);
+	stm32_adc_clr_bits(adc, STM32H7_ADC_CR, msk);
 
 	/* Start calibration, then wait for completion */
 	stm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADCAL);
@@ -892,7 +1243,7 @@ static int stm32h7_adc_selfcalib(struct iio_dev *indio_dev)
 					   !(val & STM32H7_ADCAL), 100,
 					   STM32H7_ADC_CALIB_TIMEOUT_US);
 	if (ret) {
-		dev_err(&indio_dev->dev, "calibration failed\n");
+		dev_err(&indio_dev->dev, "calibration (single-ended) error %d\n", ret);
 		goto out;
 	}
 
@@ -902,24 +1253,50 @@ static int stm32h7_adc_selfcalib(struct iio_dev *indio_dev)
 	 * - Linearity calibration (needs to be done only once for single/diff)
 	 *   will run simultaneously with offset calibration.
 	 */
-	stm32_adc_set_bits(adc, STM32H7_ADC_CR,
-			   STM32H7_ADCALDIF | STM32H7_ADCALLIN);
+	stm32_adc_set_bits(adc, STM32H7_ADC_CR, msk);
 	stm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADCAL);
 	ret = stm32_adc_readl_poll_timeout(STM32H7_ADC_CR, val,
 					   !(val & STM32H7_ADCAL), 100,
 					   STM32H7_ADC_CALIB_TIMEOUT_US);
 	if (ret) {
-		dev_err(&indio_dev->dev, "calibration failed\n");
+		dev_err(&indio_dev->dev, "calibration (diff%s) error %d\n",
+			(msk & STM32H7_ADCALLIN) ? "+linear" : "", ret);
 		goto out;
 	}
 
 out:
-	stm32_adc_clr_bits(adc, STM32H7_ADC_CR,
-			   STM32H7_ADCALDIF | STM32H7_ADCALLIN);
+	stm32_adc_clr_bits(adc, STM32H7_ADC_CR, msk);
 
 	return ret;
 }
 
+/**
+ * stm32h7_adc_check_selfcalib() - Check linear calibration status
+ * @indio_dev: IIO device instance
+ *
+ * Used to check if linear calibration has been done.
+ * Return true if linear calibration factors are already saved in private data
+ * or if a linear calibration has been done at boot stage.
+ */
+static int stm32h7_adc_check_selfcalib(struct iio_dev *indio_dev)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+	u32 val;
+
+	if (adc->cal.lincal_saved)
+		return true;
+
+	/*
+	 * Check if linear calibration factors are available in ADC registers,
+	 * by checking that all LINCALRDYWx bits are set.
+	 */
+	val = stm32_adc_readl(adc, STM32H7_ADC_CR) & STM32H7_LINCALRDYW_MASK;
+	if (val == STM32H7_LINCALRDYW_MASK)
+		return true;
+
+	return false;
+}
+
 /**
  * stm32h7_adc_prepare() - Leave power down mode to enable ADC.
  * @indio_dev: IIO device instance
@@ -934,37 +1311,48 @@ static int stm32h7_adc_selfcalib(struct iio_dev *indio_dev)
 static int stm32h7_adc_prepare(struct iio_dev *indio_dev)
 {
 	struct stm32_adc *adc = iio_priv(indio_dev);
-	int calib, ret;
+	int lincal_done = false;
+	int ret;
 
 	ret = stm32h7_adc_exit_pwr_down(indio_dev);
 	if (ret)
 		return ret;
 
-	ret = stm32h7_adc_selfcalib(indio_dev);
+	if (adc->cfg->has_linearcal)
+		lincal_done = stm32h7_adc_check_selfcalib(indio_dev);
+
+	/* Always run offset calibration. Run linear calibration only once */
+	ret = stm32h7_adc_selfcalib(indio_dev, !lincal_done);
 	if (ret < 0)
 		goto pwr_dwn;
-	calib = ret;
 
-	stm32_adc_writel(adc, STM32H7_ADC_DIFSEL, adc->difsel);
+	stm32_adc_int_ch_enable(indio_dev);
+
+	stm32_adc_writel(adc, adc->cfg->regs->difsel.reg, adc->difsel);
 
 	ret = stm32h7_adc_enable(indio_dev);
 	if (ret)
-		goto pwr_dwn;
+		goto ch_disable;
 
-	/* Either restore or read calibration result for future reference */
-	if (calib)
-		ret = stm32h7_adc_restore_selfcalib(indio_dev);
-	else
-		ret = stm32h7_adc_read_selfcalib(indio_dev);
-	if (ret)
-		goto disable;
+	if (adc->cfg->has_linearcal) {
+		if (!adc->cal.lincal_saved)
+			ret = stm32h7_adc_read_selfcalib(indio_dev);
+		else
+			ret = stm32h7_adc_restore_selfcalib(indio_dev);
+
+		if (ret)
+			goto disable;
+	}
 
-	stm32_adc_writel(adc, STM32H7_ADC_PCSEL, adc->pcsel);
+	if (adc->cfg->has_presel)
+		stm32_adc_writel(adc, STM32H7_ADC_PCSEL, adc->pcsel);
 
 	return 0;
 
 disable:
 	stm32h7_adc_disable(indio_dev);
+ch_disable:
+	stm32_adc_int_ch_disable(adc);
 pwr_dwn:
 	stm32h7_adc_enter_pwr_down(adc);
 
@@ -975,7 +1363,166 @@ static void stm32h7_adc_unprepare(struct iio_dev *indio_dev)
 {
 	struct stm32_adc *adc = iio_priv(indio_dev);
 
-	stm32_adc_writel(adc, STM32H7_ADC_PCSEL, 0);
+	if (adc->cfg->has_presel)
+		stm32_adc_writel(adc, STM32H7_ADC_PCSEL, 0);
+	stm32h7_adc_disable(indio_dev);
+	stm32_adc_int_ch_disable(adc);
+	stm32h7_adc_enter_pwr_down(adc);
+}
+
+/*
+ * STM32MP25 offset calibration software procedure. Basically the calibration routine is
+ * expected to average (for example) 8 samples in calibration mode, for single-ended  and
+ * differential channels, to calibrate the zero offset. In case offset is "negative", an
+ * additional offset can be added, to determine calibration factor. It must be kept later
+ * for all conversions.
+ */
+static int stm32mp25_adc_calib_get_average_data(struct iio_dev *indio_dev, u32 *average)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+	const struct stm32_adc_regspec *regs = adc->cfg->regs;
+	u32 val, avg = 0;
+	int i, ret;
+
+	/* Repeat several conversions in calibration mode, average the results */
+	for (i = 0; i < STM32MP25_CALIB_LOOP; i++) {
+		stm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADSTART);
+		ret = stm32_adc_readl_poll_timeout(STM32H7_ADC_CR, val,
+						   !(val & (STM32H7_ADSTART)),
+						   100, STM32_ADC_TIMEOUT_US);
+		if (ret) {
+			dev_err(&indio_dev->dev, "calibration average error %d\n", ret);
+			return ret;
+		}
+
+		val = stm32_adc_readl(adc, regs->dr);
+		dev_vdbg(&indio_dev->dev, "dr[%d]=0x%08x\n", i, val);
+		avg += val;
+	}
+
+	*average = DIV_ROUND_CLOSEST(avg, STM32MP25_CALIB_LOOP);
+	dev_vdbg(&indio_dev->dev, "average=0x%08x\n", *average);
+
+	return 0;
+}
+
+static int stm32mp25_adc_calib(struct iio_dev *indio_dev)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+	u32 calfact = 0, average;
+	int ret;
+
+	stm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADCAL);
+	/* Clears CALADDOS (and old calibration data if any) */
+	stm32_adc_writel(adc, STM32MP25_ADC_CALFACT, 0);
+	/* Select single ended input calibration */
+	stm32_adc_clr_bits(adc, STM32H7_ADC_CR, STM32H7_ADCALDIF);
+	/* Use default resolution (e.g. 12 bits) */
+	stm32_adc_clr_bits(adc, STM32H7_ADC_CFGR, STM32MP25_RES_MASK);
+
+retry:
+	ret = stm32mp25_adc_calib_get_average_data(indio_dev, &average);
+	if (ret)
+		goto out;
+
+	/* If the averaged data is zero, retry with additional offset (set CALADDOS) */
+	if (!average) {
+		if (!calfact) {
+			/* Averaged data is zero, retry with additional offset */
+			calfact = STM32MP25_CALFACT_CALADDOS;
+			stm32_adc_writel(adc, STM32MP25_ADC_CALFACT, calfact);
+			goto retry;
+		}
+		/* Averaged data is still zero with additional offset, just warn about it */
+		dev_warn(&indio_dev->dev, "Single-ended calibration average: 0\n");
+	}
+
+	calfact |= FIELD_PREP(STM32MP25_CALFACT_S_MASK, average);
+
+	/* Select differential input calibration (keep previous CALADDOS value) */
+	stm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADCALDIF);
+	ret = stm32mp25_adc_calib_get_average_data(indio_dev, &average);
+	if (ret)
+		goto out;
+
+	/*
+	 * If the averaged data is below 0x800 (half value in 12-bits mode),
+	 * retry with additional offset
+	 */
+	if (average < BIT(adc->cfg->adc_info->resolutions[0] - 1)) {
+		if (!(calfact & STM32MP25_CALFACT_CALADDOS)) {
+			/* Retry the whole calibration with additional offset */
+			stm32_adc_clr_bits(adc, STM32H7_ADC_CR, STM32H7_ADCALDIF);
+			calfact = STM32MP25_CALFACT_CALADDOS;
+			stm32_adc_writel(adc, STM32MP25_ADC_CALFACT, calfact);
+			goto retry;
+		}
+		/*
+		 * Averaged data is still below center value. It needs to be clamped to zero,
+		 * so don't use the result here, warn about it.
+		 */
+		dev_warn(&indio_dev->dev, "Differential calibration clamped(0): 0x%x\n", average);
+	} else {
+		calfact |= FIELD_PREP(STM32MP25_CALFACT_D_MASK, average);
+	}
+
+	stm32_adc_writel(adc, STM32MP25_ADC_CALFACT, calfact);
+
+	dev_dbg(&indio_dev->dev, "set calfact_s=0x%03lx, calfact_d=0x%03lx, calados=%ld\n",
+		FIELD_GET(STM32MP25_CALFACT_S_MASK, calfact),
+		FIELD_GET(STM32MP25_CALFACT_D_MASK, calfact),
+		FIELD_GET(STM32MP25_CALFACT_CALADDOS, calfact));
+out:
+	stm32_adc_clr_bits(adc, STM32H7_ADC_CR, STM32H7_ADCAL);
+	stm32_adc_set_res(adc);
+
+	return ret;
+}
+
+static int stm32mp25_adc_prepare(struct iio_dev *indio_dev)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+	int ret;
+
+	ret = stm32h7_adc_exit_pwr_down(indio_dev);
+	if (ret)
+		return ret;
+
+	/* Must enable the ADC before running software-assisted calibration */
+	ret = stm32h7_adc_enable(indio_dev);
+	if (ret)
+		goto pwr_dwn;
+
+	/* Always run offset calibration */
+	ret = stm32mp25_adc_calib(indio_dev);
+	if (ret)
+		goto adc_dis;
+
+	stm32_adc_int_ch_enable(indio_dev);
+
+	stm32_adc_writel(adc, adc->cfg->regs->difsel.reg, adc->difsel);
+
+	if (adc->cfg->has_presel)
+		stm32_adc_writel(adc, STM32H7_ADC_PCSEL, adc->pcsel);
+
+	return 0;
+
+adc_dis:
+	stm32h7_adc_disable(indio_dev);
+pwr_dwn:
+	stm32h7_adc_enter_pwr_down(adc);
+
+	return ret;
+}
+
+static void stm32mp25_adc_unprepare(struct iio_dev *indio_dev)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+
+	/* Undo things in the reverse order */
+	if (adc->cfg->has_presel)
+		stm32_adc_writel(adc, STM32H7_ADC_PCSEL, 0);
+	stm32_adc_int_ch_disable(adc);
 	stm32h7_adc_disable(indio_dev);
 	stm32h7_adc_enter_pwr_down(adc);
 }
@@ -1204,6 +1751,71 @@ static int stm32_adc_single_conv(struct iio_dev *indio_dev,
 	return ret;
 }
 
+static int stm32_adc_write_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,
+			       int val, int val2, long mask)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+	struct device *dev = indio_dev->dev.parent;
+	int nb = adc->cfg->adc_info->num_ovs;
+	u32 idx;
+	int ret;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_OVERSAMPLING_RATIO:
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+
+		if (val2) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		for (idx = 0; idx < nb; idx++)
+			if (adc->cfg->adc_info->oversampling[idx] == val)
+				break;
+
+		if (idx >= nb) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		ret = pm_runtime_resume_and_get(dev);
+		if (ret < 0)
+			goto err;
+
+		adc->cfg->set_ovs(indio_dev, idx);
+
+		pm_runtime_mark_last_busy(dev);
+		pm_runtime_put_autosuspend(dev);
+
+		adc->ovs_idx = idx;
+
+err:
+		iio_device_release_direct_mode(indio_dev);
+
+		return ret;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int stm32_adc_read_avail(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,
+				const int **vals, int *type, int *length, long m)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+
+	switch (m) {
+	case IIO_CHAN_INFO_OVERSAMPLING_RATIO:
+		*type = IIO_VAL_INT;
+		*length = adc->cfg->adc_info->num_ovs;
+		*vals = adc->cfg->adc_info->oversampling;
+		return IIO_AVAIL_LIST;
+	default:
+		return -EINVAL;
+	}
+}
+
 static int stm32_adc_read_raw(struct iio_dev *indio_dev,
 			      struct iio_chan_spec const *chan,
 			      int *val, int *val2, long mask)
@@ -1213,6 +1825,7 @@ static int stm32_adc_read_raw(struct iio_dev *indio_dev,
 
 	switch (mask) {
 	case IIO_CHAN_INFO_RAW:
+	case IIO_CHAN_INFO_PROCESSED:
 		ret = iio_device_claim_direct_mode(indio_dev);
 		if (ret)
 			return ret;
@@ -1220,6 +1833,10 @@ static int stm32_adc_read_raw(struct iio_dev *indio_dev,
 			ret = stm32_adc_single_conv(indio_dev, chan, val);
 		else
 			ret = -EINVAL;
+
+		if (mask == IIO_CHAN_INFO_PROCESSED)
+			*val = STM32_ADC_VREFINT_VOLTAGE * adc->vrefint.vrefint_cal / *val;
+
 		iio_device_release_direct_mode(indio_dev);
 		return ret;
 
@@ -1241,6 +1858,10 @@ static int stm32_adc_read_raw(struct iio_dev *indio_dev,
 			*val = 0;
 		return IIO_VAL_INT;
 
+	case IIO_CHAN_INFO_OVERSAMPLING_RATIO:
+		*val = adc->cfg->adc_info->oversampling[adc->ovs_idx];
+		return IIO_VAL_INT;
+
 	default:
 		return -EINVAL;
 	}
@@ -1417,6 +2038,8 @@ static int stm32_adc_debugfs_reg_access(struct iio_dev *indio_dev,
 
 static const struct iio_info stm32_adc_iio_info = {
 	.read_raw = stm32_adc_read_raw,
+	.write_raw = stm32_adc_write_raw,
+	.read_avail = stm32_adc_read_avail,
 	.validate_trigger = stm32_adc_validate_trigger,
 	.hwfifo_set_watermark = stm32_adc_set_watermark,
 	.update_scan_mode = stm32_adc_update_scan_mode,
@@ -1618,6 +2241,23 @@ static const struct iio_chan_spec_ext_info stm32_adc_ext_info[] = {
 	{},
 };
 
+static void stm32_adc_debugfs_init(struct iio_dev *indio_dev)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+	struct dentry *d = iio_get_debugfs_dentry(indio_dev);
+	struct stm32_adc_calib *cal = &adc->cal;
+	char buf[16];
+	unsigned int i;
+
+	if (!adc->cfg->has_linearcal)
+		return;
+
+	for (i = 0; i < STM32H7_LINCALFACT_NUM; i++) {
+		snprintf(buf, sizeof(buf), "lincalfact%d", i + 1);
+		debugfs_create_u32(buf, 0444, d, &cal->lincalfact[i]);
+	}
+}
+
 static int stm32_adc_of_get_resolution(struct iio_dev *indio_dev)
 {
 	struct device_node *node = indio_dev->dev.of_node;
@@ -1646,7 +2286,15 @@ static void stm32_adc_smpr_init(struct stm32_adc *adc, int channel, u32 smp_ns)
 {
 	const struct stm32_adc_regs *smpr = &adc->cfg->regs->smp_bits[channel];
 	u32 period_ns, shift = smpr->shift, mask = smpr->mask;
-	unsigned int smp, r = smpr->reg;
+	unsigned int i, smp, r = smpr->reg;
+
+	/*
+	 * For internal channels, ensure that the sampling time cannot
+	 * be lower than the one specified in the datasheet
+	 */
+	for (i = 0; i < STM32_ADC_INT_CH_NB; i++)
+		if (channel == adc->int_ch[i] && adc->int_ch[i] != STM32_ADC_INT_CH_NONE)
+			smp_ns = max(smp_ns, adc->cfg->ts_int_ch[i]);
 
 	/* Determine sampling time (ADC clock cycles) */
 	period_ns = NSEC_PER_SEC / adc->common->rate;
@@ -1679,9 +2327,16 @@ static void stm32_adc_chan_init_one(struct iio_dev *indio_dev,
 	chan->datasheet_name = name;
 	chan->scan_index = scan_index;
 	chan->indexed = 1;
-	chan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);
+	if (chan->channel == adc->int_ch[STM32_ADC_INT_CH_VREFINT])
+		chan->info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED);
+	else
+		chan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);
 	chan->info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |
 					 BIT(IIO_CHAN_INFO_OFFSET);
+	if (adc->cfg->has_oversampling) {
+		chan->info_mask_shared_by_all |= BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO);
+		chan->info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO);
+	}
 	chan->scan_type.sign = 'u';
 	chan->scan_type.realbits = adc->cfg->adc_info->resolutions[adc->res];
 	chan->scan_type.storagebits = 16;
@@ -1691,23 +2346,17 @@ static void stm32_adc_chan_init_one(struct iio_dev *indio_dev,
 	adc->pcsel |= BIT(chan->channel);
 	if (differential) {
 		/* pre-build diff channels mask */
-		adc->difsel |= BIT(chan->channel);
+		adc->difsel |= BIT(chan->channel) & adc->cfg->regs->difsel.mask;
 		/* Also add negative input to pre-selected channels */
 		adc->pcsel |= BIT(chan->channel2);
 	}
 }
 
-static int stm32_adc_chan_of_init(struct iio_dev *indio_dev, bool timestamping)
+static int stm32_adc_get_legacy_chan_count(struct iio_dev *indio_dev, struct stm32_adc *adc)
 {
 	struct device_node *node = indio_dev->dev.of_node;
-	struct stm32_adc *adc = iio_priv(indio_dev);
 	const struct stm32_adc_info *adc_info = adc->cfg->adc_info;
-	struct stm32_adc_diff_channel diff[STM32_ADC_CH_MAX];
-	struct property *prop;
-	const __be32 *cur;
-	struct iio_chan_spec *channels;
-	int scan_index = 0, num_channels = 0, num_diff = 0, ret, i;
-	u32 val, smp = 0;
+	int num_channels = 0, ret;
 
 	ret = of_property_count_u32_elems(node, "st,adc-channels");
 	if (ret > adc_info->max_channels) {
@@ -1718,24 +2367,13 @@ static int stm32_adc_chan_of_init(struct iio_dev *indio_dev, bool timestamping)
 	}
 
 	ret = of_property_count_elems_of_size(node, "st,adc-diff-channels",
-					      sizeof(*diff));
+					      sizeof(struct stm32_adc_diff_channel));
 	if (ret > adc_info->max_channels) {
 		dev_err(&indio_dev->dev, "Bad st,adc-diff-channels?\n");
 		return -EINVAL;
 	} else if (ret > 0) {
-		int size = ret * sizeof(*diff) / sizeof(u32);
-
-		num_diff = ret;
+		adc->num_diff = ret;
 		num_channels += ret;
-		ret = of_property_read_u32_array(node, "st,adc-diff-channels",
-						 (u32 *)diff, size);
-		if (ret)
-			return ret;
-	}
-
-	if (!num_channels) {
-		dev_err(&indio_dev->dev, "No channels configured\n");
-		return -ENODATA;
 	}
 
 	/* Optional sample time is provided either for each, or all channels */
@@ -1745,13 +2383,45 @@ static int stm32_adc_chan_of_init(struct iio_dev *indio_dev, bool timestamping)
 		return -EINVAL;
 	}
 
-	if (timestamping)
-		num_channels++;
+	return num_channels;
+}
 
-	channels = devm_kcalloc(&indio_dev->dev, num_channels,
-				sizeof(struct iio_chan_spec), GFP_KERNEL);
-	if (!channels)
-		return -ENOMEM;
+static int stm32_adc_legacy_chan_init(struct iio_dev *indio_dev,
+				      struct stm32_adc *adc,
+				      struct iio_chan_spec *channels)
+{
+	struct device_node *node = indio_dev->dev.of_node;
+	const struct stm32_adc_info *adc_info = adc->cfg->adc_info;
+	struct stm32_adc_diff_channel diff[STM32_ADC_CH_MAX];
+	u32 num_diff = adc->num_diff;
+	int size = num_diff * sizeof(*diff) / sizeof(u32);
+	int scan_index = 0, val, ret, i;
+	struct property *prop;
+	const __be32 *cur;
+	u32 smp = 0;
+
+	if (num_diff) {
+		ret = of_property_read_u32_array(node, "st,adc-diff-channels",
+						 (u32 *)diff, size);
+		if (ret) {
+			dev_err(&indio_dev->dev, "Failed to get diff channels %d\n", ret);
+			return ret;
+		}
+
+		for (i = 0; i < num_diff; i++) {
+			if (diff[i].vinp >= adc_info->max_channels ||
+			    diff[i].vinn >= adc_info->max_channels) {
+				dev_err(&indio_dev->dev, "Invalid channel in%d-in%d\n",
+					diff[i].vinp, diff[i].vinn);
+				return -EINVAL;
+			}
+
+			stm32_adc_chan_init_one(indio_dev, &channels[scan_index],
+						diff[i].vinp, diff[i].vinn,
+						scan_index, true);
+			scan_index++;
+		}
+	}
 
 	of_property_for_each_u32(node, "st,adc-channels", prop, cur, val) {
 		if (val >= adc_info->max_channels) {
@@ -1762,8 +2432,7 @@ static int stm32_adc_chan_of_init(struct iio_dev *indio_dev, bool timestamping)
 		/* Channel can't be configured both as single-ended & diff */
 		for (i = 0; i < num_diff; i++) {
 			if (val == diff[i].vinp) {
-				dev_err(&indio_dev->dev,
-					"channel %d miss-configured\n",	val);
+				dev_err(&indio_dev->dev, "channel %d misconfigured\n",	val);
 				return -EINVAL;
 			}
 		}
@@ -1772,19 +2441,6 @@ static int stm32_adc_chan_of_init(struct iio_dev *indio_dev, bool timestamping)
 		scan_index++;
 	}
 
-	for (i = 0; i < num_diff; i++) {
-		if (diff[i].vinp >= adc_info->max_channels ||
-		    diff[i].vinn >= adc_info->max_channels) {
-			dev_err(&indio_dev->dev, "Invalid channel in%d-in%d\n",
-				diff[i].vinp, diff[i].vinn);
-			return -EINVAL;
-		}
-		stm32_adc_chan_init_one(indio_dev, &channels[scan_index],
-					diff[i].vinp, diff[i].vinn, scan_index,
-					true);
-		scan_index++;
-	}
-
 	for (i = 0; i < scan_index; i++) {
 		/*
 		 * Using of_property_read_u32_index(), smp value will only be
@@ -1792,12 +2448,215 @@ static int stm32_adc_chan_of_init(struct iio_dev *indio_dev, bool timestamping)
 		 * get either no value, 1 shared value for all indexes, or one
 		 * value per channel.
 		 */
-		of_property_read_u32_index(node, "st,min-sample-time-nsecs",
-					   i, &smp);
+		of_property_read_u32_index(node, "st,min-sample-time-nsecs", i, &smp);
+
 		/* Prepare sampling time settings */
 		stm32_adc_smpr_init(adc, channels[i].channel, smp);
 	}
 
+	return scan_index;
+}
+
+static int stm32_adc_populate_int_ch(struct iio_dev *indio_dev, const char *ch_name,
+				     int chan)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+	u16 vrefint;
+	int i, ret;
+
+	for (i = 0; i < STM32_ADC_INT_CH_NB; i++) {
+		if (!strncmp(stm32_adc_ic[i].name, ch_name, STM32_ADC_CH_SZ)) {
+			/* Check internal channel availability */
+			switch (i) {
+			case STM32_ADC_INT_CH_VDDCORE:
+				if (!adc->cfg->regs->or_vddcore.reg)
+					dev_warn(&indio_dev->dev,
+						 "%s channel not available\n", ch_name);
+				break;
+			case STM32_ADC_INT_CH_VDDCPU:
+				if (!adc->cfg->regs->or_vddcpu.reg)
+					dev_warn(&indio_dev->dev,
+						 "%s channel not available\n", ch_name);
+				break;
+			case STM32_ADC_INT_CH_VDDQ_DDR:
+				if (!adc->cfg->regs->or_vddq_ddr.reg)
+					dev_warn(&indio_dev->dev,
+						 "%s channel not available\n", ch_name);
+				break;
+			case STM32_ADC_INT_CH_VREFINT:
+				if (!adc->cfg->regs->ccr_vref.reg)
+					dev_warn(&indio_dev->dev,
+						 "%s channel not available\n", ch_name);
+				break;
+			case STM32_ADC_INT_CH_VBAT:
+				if (!adc->cfg->regs->ccr_vbat.reg)
+					dev_warn(&indio_dev->dev,
+						 "%s channel not available\n", ch_name);
+				break;
+			}
+
+			if (stm32_adc_ic[i].idx != STM32_ADC_INT_CH_VREFINT) {
+				adc->int_ch[i] = chan;
+				break;
+			}
+
+			/* Get calibration data for vrefint channel */
+			ret = nvmem_cell_read_u16(&indio_dev->dev, "vrefint", &vrefint);
+			if (ret && ret != -ENOENT) {
+				return dev_err_probe(indio_dev->dev.parent, ret,
+						     "nvmem access error\n");
+			}
+			if (ret == -ENOENT) {
+				dev_dbg(&indio_dev->dev, "vrefint calibration not found. Skip vrefint channel\n");
+				return ret;
+			} else if (!vrefint) {
+				dev_dbg(&indio_dev->dev, "Null vrefint calibration value. Skip vrefint channel\n");
+				return -ENOENT;
+			}
+			adc->int_ch[i] = chan;
+			adc->vrefint.vrefint_cal = vrefint;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_adc_generic_chan_init(struct iio_dev *indio_dev,
+				       struct stm32_adc *adc,
+				       struct iio_chan_spec *channels)
+{
+	struct device_node *node = indio_dev->dev.of_node;
+	const struct stm32_adc_info *adc_info = adc->cfg->adc_info;
+	struct device_node *child;
+	const char *name;
+	int val, scan_index = 0, ret;
+	bool differential;
+	u32 vin[2];
+
+	for_each_available_child_of_node(node, child) {
+		ret = of_property_read_u32(child, "reg", &val);
+		if (ret) {
+			dev_err(&indio_dev->dev, "Missing channel index %d\n", ret);
+			goto err;
+		}
+
+		ret = of_property_read_string(child, "label", &name);
+		/* label is optional */
+		if (!ret) {
+			if (strlen(name) >= STM32_ADC_CH_SZ) {
+				dev_err(&indio_dev->dev, "Label %s exceeds %d characters\n",
+					name, STM32_ADC_CH_SZ);
+				return -EINVAL;
+			}
+			strncpy(adc->chan_name[val], name, STM32_ADC_CH_SZ);
+			ret = stm32_adc_populate_int_ch(indio_dev, name, val);
+			if (ret == -ENOENT)
+				continue;
+			else if (ret)
+				goto err;
+		} else if (ret != -EINVAL) {
+			dev_err(&indio_dev->dev, "Invalid label %d\n", ret);
+			goto err;
+		}
+
+		if (val >= adc_info->max_channels) {
+			dev_err(&indio_dev->dev, "Invalid channel %d\n", val);
+			ret = -EINVAL;
+			goto err;
+		}
+
+		differential = false;
+		ret = of_property_read_u32_array(child, "diff-channels", vin, 2);
+		/* diff-channels is optional */
+		if (!ret) {
+			differential = true;
+			if (vin[0] != val || vin[1] >= adc_info->max_channels) {
+				dev_err(&indio_dev->dev, "Invalid channel in%d-in%d\n",
+					vin[0], vin[1]);
+				goto err;
+			}
+		} else if (ret != -EINVAL) {
+			dev_err(&indio_dev->dev, "Invalid diff-channels property %d\n", ret);
+			goto err;
+		}
+
+		stm32_adc_chan_init_one(indio_dev, &channels[scan_index], val,
+					vin[1], scan_index, differential);
+
+		val = 0;
+		ret = of_property_read_u32(child, "st,min-sample-time-ns", &val);
+		/* st,min-sample-time-ns is optional */
+		if (ret && ret != -EINVAL) {
+			dev_err(&indio_dev->dev, "Invalid st,min-sample-time-ns property %d\n",
+				ret);
+			goto err;
+		}
+
+		stm32_adc_smpr_init(adc, channels[scan_index].channel, val);
+		if (differential)
+			stm32_adc_smpr_init(adc, vin[1], val);
+
+		scan_index++;
+	}
+
+	return scan_index;
+
+err:
+	of_node_put(child);
+
+	return ret;
+}
+
+static int stm32_adc_chan_of_init(struct iio_dev *indio_dev, bool timestamping)
+{
+	struct device_node *node = indio_dev->dev.of_node;
+	struct stm32_adc *adc = iio_priv(indio_dev);
+	const struct stm32_adc_info *adc_info = adc->cfg->adc_info;
+	struct iio_chan_spec *channels;
+	int scan_index = 0, num_channels = 0, ret, i;
+	bool legacy = false;
+
+	for (i = 0; i < STM32_ADC_INT_CH_NB; i++)
+		adc->int_ch[i] = STM32_ADC_INT_CH_NONE;
+
+	num_channels = of_get_available_child_count(node);
+	/* If no channels have been found, fallback to channels legacy properties. */
+	if (!num_channels) {
+		legacy = true;
+
+		ret = stm32_adc_get_legacy_chan_count(indio_dev, adc);
+		if (!ret) {
+			dev_err(indio_dev->dev.parent, "No channel found\n");
+			return -ENODATA;
+		} else if (ret < 0) {
+			return ret;
+		}
+
+		num_channels = ret;
+	}
+
+	if (num_channels > adc_info->max_channels) {
+		dev_err(&indio_dev->dev, "Channel number [%d] exceeds %d\n",
+			num_channels, adc_info->max_channels);
+		return -EINVAL;
+	}
+
+	if (timestamping)
+		num_channels++;
+
+	channels = devm_kcalloc(&indio_dev->dev, num_channels,
+				sizeof(struct iio_chan_spec), GFP_KERNEL);
+	if (!channels)
+		return -ENOMEM;
+
+	if (legacy)
+		ret = stm32_adc_legacy_chan_init(indio_dev, adc, channels);
+	else
+		ret = stm32_adc_generic_chan_init(indio_dev, adc, channels);
+	if (ret < 0)
+		return ret;
+	scan_index = ret;
+
 	if (timestamping) {
 		struct iio_chan_spec *timestamp = &channels[scan_index];
 
@@ -1972,6 +2831,9 @@ static int stm32_adc_probe(struct platform_device *pdev)
 	pm_runtime_mark_last_busy(dev);
 	pm_runtime_put_autosuspend(dev);
 
+	if (IS_ENABLED(CONFIG_DEBUG_FS))
+		stm32_adc_debugfs_init(indio_dev);
+
 	return 0;
 
 err_hw_stop:
@@ -2000,6 +2862,7 @@ static int stm32_adc_remove(struct platform_device *pdev)
 	struct stm32_adc *adc = iio_priv(indio_dev);
 
 	pm_runtime_get_sync(&pdev->dev);
+	/* iio_device_unregister() also removes debugfs entries */
 	iio_device_unregister(indio_dev);
 	stm32_adc_hw_stop(&pdev->dev);
 	pm_runtime_disable(&pdev->dev);
@@ -2077,35 +2940,93 @@ static const struct stm32_adc_cfg stm32f4_adc_cfg = {
 	.irq_clear = stm32f4_adc_irq_clear,
 };
 
+const unsigned int stm32_adc_min_ts_h7[] = { 0, 0, 0, 4300, 9000 };
+static_assert(ARRAY_SIZE(stm32_adc_min_ts_h7) == STM32_ADC_INT_CH_NB);
+
 static const struct stm32_adc_cfg stm32h7_adc_cfg = {
 	.regs = &stm32h7_adc_regspec,
 	.adc_info = &stm32h7_adc_info,
 	.trigs = stm32h7_adc_trigs,
+	.has_boostmode = true,
+	.has_linearcal = true,
+	.has_presel = true,
+	.has_oversampling = true,
 	.start_conv = stm32h7_adc_start_conv,
 	.stop_conv = stm32h7_adc_stop_conv,
 	.prepare = stm32h7_adc_prepare,
 	.unprepare = stm32h7_adc_unprepare,
 	.smp_cycles = stm32h7_adc_smp_cycles,
 	.irq_clear = stm32h7_adc_irq_clear,
+	.set_ovs = stm32h7_adc_set_ovs,
+	.ts_int_ch = stm32_adc_min_ts_h7,
 };
 
+const unsigned int stm32_adc_min_ts_mp1[] = { 100, 100, 100, 4300, 9800 };
+static_assert(ARRAY_SIZE(stm32_adc_min_ts_mp1) == STM32_ADC_INT_CH_NB);
+
 static const struct stm32_adc_cfg stm32mp1_adc_cfg = {
-	.regs = &stm32h7_adc_regspec,
+	.regs = &stm32mp1_adc_regspec,
 	.adc_info = &stm32h7_adc_info,
 	.trigs = stm32h7_adc_trigs,
 	.has_vregready = true,
+	.has_boostmode = true,
+	.has_linearcal = true,
+	.has_presel = true,
+	.has_oversampling = true,
 	.start_conv = stm32h7_adc_start_conv,
 	.stop_conv = stm32h7_adc_stop_conv,
 	.prepare = stm32h7_adc_prepare,
 	.unprepare = stm32h7_adc_unprepare,
 	.smp_cycles = stm32h7_adc_smp_cycles,
 	.irq_clear = stm32h7_adc_irq_clear,
+	.set_ovs = stm32h7_adc_set_ovs,
+	.ts_int_ch = stm32_adc_min_ts_mp1,
+};
+
+const unsigned int stm32_adc_min_ts_mp13[] = { 100, 0, 0, 4300, 9800 };
+static_assert(ARRAY_SIZE(stm32_adc_min_ts_mp13) == STM32_ADC_INT_CH_NB);
+
+static const struct stm32_adc_cfg stm32mp13_adc_cfg = {
+	.regs = &stm32mp13_adc_regspec,
+	.adc_info = &stm32mp13_adc_info,
+	.trigs = stm32h7_adc_trigs,
+	.has_oversampling = true,
+	.start_conv = stm32mp13_adc_start_conv,
+	.stop_conv = stm32h7_adc_stop_conv,
+	.prepare = stm32h7_adc_prepare,
+	.unprepare = stm32h7_adc_unprepare,
+	.smp_cycles = stm32mp13_adc_smp_cycles,
+	.irq_clear = stm32h7_adc_irq_clear,
+	.set_ovs = stm32mp13_adc_set_ovs,
+	.ts_int_ch = stm32_adc_min_ts_mp13,
+};
+
+/* TODO: Update min sampling time with databrief */
+const unsigned int stm32_adc_min_ts_mp25[] = { 10000, 10000, 0, 10000, 10000 };
+static_assert(ARRAY_SIZE(stm32_adc_min_ts_mp25) == STM32_ADC_INT_CH_NB);
+
+static const struct stm32_adc_cfg stm32mp25_adc_cfg = {
+	.regs = &stm32mp25_adc_regspec,
+	.adc_info = &stm32mp25_adc_info,
+	.trigs = stm32mp25_adc_trigs,
+	.has_oversampling = true,
+	.has_presel = true,
+	.start_conv = stm32h7_adc_start_conv,
+	.stop_conv = stm32h7_adc_stop_conv,
+	.prepare = stm32mp25_adc_prepare,
+	.unprepare = stm32mp25_adc_unprepare,
+	.smp_cycles = stm32mp25_adc_smp_cycles,
+	.irq_clear = stm32h7_adc_irq_clear,
+	.set_ovs = stm32h7_adc_set_ovs,
+	.ts_int_ch = stm32_adc_min_ts_mp25,
 };
 
 static const struct of_device_id stm32_adc_of_match[] = {
 	{ .compatible = "st,stm32f4-adc", .data = (void *)&stm32f4_adc_cfg },
 	{ .compatible = "st,stm32h7-adc", .data = (void *)&stm32h7_adc_cfg },
 	{ .compatible = "st,stm32mp1-adc", .data = (void *)&stm32mp1_adc_cfg },
+	{ .compatible = "st,stm32mp13-adc", .data = (void *)&stm32mp13_adc_cfg },
+	{ .compatible = "st,stm32mp25-adc", .data = (void *)&stm32mp25_adc_cfg },
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32_adc_of_match);
diff --git a/drivers/iio/adc/stm32-dfsdm-adc.c b/drivers/iio/adc/stm32-dfsdm-adc.c
index 1cfefb3b5..997f1f387 100644
--- a/drivers/iio/adc/stm32-dfsdm-adc.c
+++ b/drivers/iio/adc/stm32-dfsdm-adc.c
@@ -10,6 +10,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/iio/adc/stm32-dfsdm-adc.h>
 #include <linux/iio/buffer.h>
+#include <linux/iio/consumer.h>
 #include <linux/iio/hw-consumer.h>
 #include <linux/iio/sysfs.h>
 #include <linux/iio/timer/stm32-lptim-trigger.h>
@@ -67,6 +68,13 @@ struct stm32_dfsdm_dev_data {
 	const struct regmap_config *regmap_cfg;
 };
 
+struct stm32_dfsdm_sd_chan_info {
+	int scale_val;
+	int scale_val2;
+	int offset;
+	unsigned int differential;
+};
+
 struct stm32_dfsdm_adc {
 	struct stm32_dfsdm *dfsdm;
 	const struct stm32_dfsdm_dev_data *dev_data;
@@ -79,6 +87,7 @@ struct stm32_dfsdm_adc {
 	struct iio_hw_consumer *hwc;
 	struct completion completion;
 	u32 *buffer;
+	struct stm32_dfsdm_sd_chan_info *sd_chan;
 
 	/* Audio specific */
 	unsigned int spi_freq;  /* SPI bus clock frequency */
@@ -1224,7 +1233,13 @@ static int stm32_dfsdm_read_raw(struct iio_dev *indio_dev,
 				int *val2, long mask)
 {
 	struct stm32_dfsdm_adc *adc = iio_priv(indio_dev);
-	int ret;
+	struct stm32_dfsdm_filter *fl = &adc->dfsdm->fl_list[adc->fl_id];
+	struct stm32_dfsdm_filter_osr *flo = &fl->flo[fl->fast];
+	u32 max = flo->max << (flo->lshift - chan->scan_type.shift);
+	int ret, idx = chan->scan_index;
+
+	if (flo->lshift < chan->scan_type.shift)
+		max = flo->max >> (chan->scan_type.shift - flo->lshift);
 
 	switch (mask) {
 	case IIO_CHAN_INFO_RAW:
@@ -1260,6 +1275,39 @@ static int stm32_dfsdm_read_raw(struct iio_dev *indio_dev,
 		*val = adc->sample_freq;
 
 		return IIO_VAL_INT;
+
+	case IIO_CHAN_INFO_SCALE:
+		/*
+		 * Scale is expressed in mV.
+		 * When fast mode is disabled, actual resolution may be lower
+		 * than 2^n, where n=realbits-1.
+		 * This leads to underestimating input voltage. To
+		 * compensate this deviation, the voltage reference can be
+		 * corrected with a factor = realbits resolution / actual max
+		 */
+		*val = div_u64((u64)adc->sd_chan[idx].scale_val *
+			       (u64)BIT(DFSDM_DATA_RES - 1), max);
+		*val2 = chan->scan_type.realbits;
+		if (adc->sd_chan[idx].differential)
+			*val *= 2;
+		return IIO_VAL_FRACTIONAL_LOG2;
+
+	case IIO_CHAN_INFO_OFFSET:
+		/*
+		 * DFSDM output data are in the range [-2^n,2^n-1],
+		 * with n=realbits-1.
+		 * - Differential modulator:
+		 * Offset correspond to SD modulator offset.
+		 * - Single ended modulator:
+		 * Input is in [0V,Vref] range, where 0V corresponds to -2^n.
+		 * Add 2^n to offset. (i.e. middle of input range)
+		 * offset = offset(sd) * vref / res(sd) * max / vref.
+		 */
+		*val = div_u64((u64)max * adc->sd_chan[idx].offset,
+			       BIT(adc->sd_chan[idx].scale_val2 - 1));
+		if (!adc->sd_chan[idx].differential)
+			*val += max;
+		return IIO_VAL_INT;
 	}
 
 	return -EINVAL;
@@ -1384,7 +1432,9 @@ static int stm32_dfsdm_adc_chan_init_one(struct iio_dev *indio_dev,
 	 * IIO_CHAN_INFO_RAW: used to compute regular conversion
 	 * IIO_CHAN_INFO_OVERSAMPLING_RATIO: used to set oversampling
 	 */
-	ch->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);
+	ch->info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |
+				 BIT(IIO_CHAN_INFO_SCALE) |
+				 BIT(IIO_CHAN_INFO_OFFSET);
 	ch->info_mask_shared_by_all = BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO) |
 					BIT(IIO_CHAN_INFO_SAMP_FREQ);
 
@@ -1394,7 +1444,7 @@ static int stm32_dfsdm_adc_chan_init_one(struct iio_dev *indio_dev,
 		ch->scan_type.shift = 8;
 	}
 	ch->scan_type.sign = 's';
-	ch->scan_type.realbits = 24;
+	ch->scan_type.realbits = DFSDM_DATA_RES;
 	ch->scan_type.storagebits = 32;
 
 	return stm32_dfsdm_chan_configure(adc->dfsdm,
@@ -1435,8 +1485,10 @@ static int stm32_dfsdm_adc_init(struct device *dev, struct iio_dev *indio_dev)
 {
 	struct iio_chan_spec *ch;
 	struct stm32_dfsdm_adc *adc = iio_priv(indio_dev);
+	struct iio_channel *channels, *chan;
+	struct stm32_dfsdm_sd_chan_info *sd_chan;
 	int num_ch;
-	int ret, chan_idx;
+	int ret, chan_idx, val2;
 
 	adc->oversamp = DFSDM_DEFAULT_OVERSAMPLING;
 	ret = stm32_dfsdm_compute_all_osrs(indio_dev, adc->oversamp);
@@ -1460,6 +1512,21 @@ static int stm32_dfsdm_adc_init(struct device *dev, struct iio_dev *indio_dev)
 	if (!ch)
 		return -ENOMEM;
 
+	/* Get SD modulator channels */
+	channels = iio_channel_get_all(&indio_dev->dev);
+	if (IS_ERR(channels)) {
+		dev_err(&indio_dev->dev, "Failed to get channel %ld\n",
+			PTR_ERR(channels));
+		return PTR_ERR(channels);
+	}
+	chan = &channels[0];
+
+	adc->sd_chan = devm_kzalloc(&indio_dev->dev,
+				    sizeof(*adc->sd_chan) * num_ch, GFP_KERNEL);
+	if (!adc->sd_chan)
+		return -ENOMEM;
+	sd_chan = adc->sd_chan;
+
 	for (chan_idx = 0; chan_idx < num_ch; chan_idx++) {
 		ch[chan_idx].scan_index = chan_idx;
 		ret = stm32_dfsdm_adc_chan_init_one(indio_dev, &ch[chan_idx]);
@@ -1467,6 +1534,38 @@ static int stm32_dfsdm_adc_init(struct device *dev, struct iio_dev *indio_dev)
 			dev_err(&indio_dev->dev, "Channels init failed\n");
 			return ret;
 		}
+
+		if (!chan->indio_dev)
+			return -EINVAL;
+
+		ret = iio_read_channel_scale(chan, &sd_chan->scale_val,
+					     &sd_chan->scale_val2);
+		if (ret < 0) {
+			dev_err(&indio_dev->dev,
+				"Failed to get channel %d scale\n", chan_idx);
+			return ret;
+		}
+
+		if (iio_channel_has_info(chan->channel, IIO_CHAN_INFO_OFFSET)) {
+			ret = iio_read_channel_offset(chan, &sd_chan->offset,
+						      &val2);
+			if (ret < 0) {
+				dev_err(&indio_dev->dev,
+					"Failed to get channel %d offset\n",
+					chan_idx);
+				return ret;
+			}
+		}
+
+		sd_chan->differential = chan->channel->differential;
+
+		dev_dbg(&indio_dev->dev, "Channel %d %s scale ref=%d offset=%d",
+			chan_idx, chan->channel->differential ?
+			"differential" : "single-ended",
+			sd_chan->scale_val, sd_chan->offset);
+
+		chan++;
+		sd_chan++;
 	}
 
 	indio_dev->num_channels = num_ch;
@@ -1521,6 +1620,7 @@ static const struct of_device_id stm32_dfsdm_adc_match[] = {
 	},
 	{}
 };
+MODULE_DEVICE_TABLE(of, stm32_dfsdm_adc_match);
 
 static int stm32_dfsdm_adc_probe(struct platform_device *pdev)
 {
diff --git a/drivers/iio/adc/stm32-dfsdm-core.c b/drivers/iio/adc/stm32-dfsdm-core.c
index a627af9a8..65c01d522 100644
--- a/drivers/iio/adc/stm32-dfsdm-core.c
+++ b/drivers/iio/adc/stm32-dfsdm-core.c
@@ -6,6 +6,7 @@
  * Author(s): Arnaud Pouliquen <arnaud.pouliquen@st.com> for STMicroelectronics.
  */
 
+#include <linux/bitfield.h>
 #include <linux/clk.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/sysfs.h>
@@ -20,6 +21,7 @@
 #include "stm32-dfsdm.h"
 
 struct stm32_dfsdm_dev_data {
+	u32 ipid;
 	unsigned int num_filters;
 	unsigned int num_channels;
 	const struct regmap_config *regmap_cfg;
@@ -27,8 +29,6 @@ struct stm32_dfsdm_dev_data {
 
 #define STM32H7_DFSDM_NUM_FILTERS	4
 #define STM32H7_DFSDM_NUM_CHANNELS	8
-#define STM32MP1_DFSDM_NUM_FILTERS	6
-#define STM32MP1_DFSDM_NUM_CHANNELS	8
 
 static bool stm32_dfsdm_volatile_reg(struct device *dev, unsigned int reg)
 {
@@ -75,8 +75,7 @@ static const struct regmap_config stm32mp1_dfsdm_regmap_cfg = {
 };
 
 static const struct stm32_dfsdm_dev_data stm32mp1_dfsdm_data = {
-	.num_filters = STM32MP1_DFSDM_NUM_FILTERS,
-	.num_channels = STM32MP1_DFSDM_NUM_CHANNELS,
+	.ipid = STM32MP15_IPIDR_NUMBER,
 	.regmap_cfg = &stm32mp1_dfsdm_regmap_cfg,
 };
 
@@ -295,6 +294,64 @@ static const struct of_device_id stm32_dfsdm_of_match[] = {
 };
 MODULE_DEVICE_TABLE(of, stm32_dfsdm_of_match);
 
+static int stm32_dfsdm_config_check(struct platform_device *pdev,
+				    struct dfsdm_priv *priv,
+				    const struct stm32_dfsdm_dev_data *dev_data)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *child;
+	struct stm32_dfsdm *dfsdm = &priv->dfsdm;
+	const char *compat;
+	int ret, count = 0;
+	u32 id, val;
+
+	if (!dev_data->ipid) {
+		dfsdm->num_fls = dev_data->num_filters;
+		dfsdm->num_chs = dev_data->num_channels;
+		return 0;
+	}
+
+	ret = regmap_read(dfsdm->regmap, DFSDM_IPIDR, &val);
+	if (ret)
+		return ret;
+
+	id = FIELD_GET(DFSDM_IPIDR_MASK, val);
+	if (id != dev_data->ipid) {
+		dev_err(&pdev->dev, "Unexpected IP version: 0x%x", id);
+		return -EINVAL;
+	}
+
+	for_each_child_of_node(np, child) {
+		ret = of_property_read_string(child, "compatible", &compat);
+		if (ret)
+			continue;
+		count++;
+	}
+
+	ret = regmap_read(dfsdm->regmap, DFSDM_HWCFGR, &val);
+	if (ret)
+		return ret;
+
+	dfsdm->num_fls = FIELD_GET(DFSDM_HWCFGR_NBF_MASK, val);
+	dfsdm->num_chs = FIELD_GET(DFSDM_HWCFGR_NBT_MASK, val);
+
+	if (count > dfsdm->num_fls) {
+		dev_err(&pdev->dev, "Unexpected child number: %d", count);
+		return -EINVAL;
+	}
+
+	ret = regmap_read(dfsdm->regmap, DFSDM_VERR, &val);
+	if (ret)
+		return ret;
+
+	dev_dbg(&pdev->dev, "DFSDM version: %lu.%lu. %d channels/%d filters\n",
+		FIELD_GET(DFSDM_VERR_MAJREV_MASK, val),
+		FIELD_GET(DFSDM_VERR_MINREV_MASK, val),
+		dfsdm->num_chs, dfsdm->num_fls);
+
+	return 0;
+}
+
 static int stm32_dfsdm_probe(struct platform_device *pdev)
 {
 	struct dfsdm_priv *priv;
@@ -311,18 +368,6 @@ static int stm32_dfsdm_probe(struct platform_device *pdev)
 	dev_data = of_device_get_match_data(&pdev->dev);
 
 	dfsdm = &priv->dfsdm;
-	dfsdm->fl_list = devm_kcalloc(&pdev->dev, dev_data->num_filters,
-				      sizeof(*dfsdm->fl_list), GFP_KERNEL);
-	if (!dfsdm->fl_list)
-		return -ENOMEM;
-
-	dfsdm->num_fls = dev_data->num_filters;
-	dfsdm->ch_list = devm_kcalloc(&pdev->dev, dev_data->num_channels,
-				      sizeof(*dfsdm->ch_list),
-				      GFP_KERNEL);
-	if (!dfsdm->ch_list)
-		return -ENOMEM;
-	dfsdm->num_chs = dev_data->num_channels;
 
 	ret = stm32_dfsdm_parse_of(pdev, priv);
 	if (ret < 0)
@@ -338,6 +383,20 @@ static int stm32_dfsdm_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	ret = stm32_dfsdm_config_check(pdev, priv, dev_data);
+	if (ret < 0)
+		return ret;
+
+	dfsdm->fl_list = devm_kcalloc(&pdev->dev, dfsdm->num_fls,
+				      sizeof(*dfsdm->fl_list), GFP_KERNEL);
+	if (!dfsdm->fl_list)
+		return -ENOMEM;
+
+	dfsdm->ch_list = devm_kcalloc(&pdev->dev, dfsdm->num_chs,
+				      sizeof(*dfsdm->ch_list), GFP_KERNEL);
+	if (!dfsdm->ch_list)
+		return -ENOMEM;
+
 	platform_set_drvdata(pdev, dfsdm);
 
 	ret = stm32_dfsdm_clk_prepare_enable(dfsdm);
diff --git a/drivers/iio/adc/stm32-dfsdm.h b/drivers/iio/adc/stm32-dfsdm.h
index 4afc1f528..4f230e2a7 100644
--- a/drivers/iio/adc/stm32-dfsdm.h
+++ b/drivers/iio/adc/stm32-dfsdm.h
@@ -13,25 +13,28 @@
 
 /*
  * STM32 DFSDM - global register map
- * ________________________________________________________
- * | Offset |                 Registers block             |
- * --------------------------------------------------------
- * | 0x000  |      CHANNEL 0 + COMMON CHANNEL FIELDS      |
- * --------------------------------------------------------
- * | 0x020  |                CHANNEL 1                    |
- * --------------------------------------------------------
- * | ...    |                .....                        |
- * --------------------------------------------------------
- * | 0x0E0  |                CHANNEL 7                    |
- * --------------------------------------------------------
- * | 0x100  |      FILTER  0 + COMMON  FILTER FIELDs      |
- * --------------------------------------------------------
- * | 0x200  |                FILTER  1                    |
- * --------------------------------------------------------
- * | 0x300  |                FILTER  2                    |
- * --------------------------------------------------------
- * | 0x400  |                FILTER  3                    |
- * --------------------------------------------------------
+ * __________________________________________________________
+ * | Offset   |                 Registers block             |
+ * ----------------------------------------------------------
+ * | 0x000    |      CHANNEL 0 + COMMON CHANNEL FIELDS      |
+ * ----------------------------------------------------------
+ * | 0x020    |                CHANNEL 1                    |
+ * ----------------------------------------------------------
+ * | ...      |                .....                        |
+ * ----------------------------------------------------------
+ * | 0x20 x n |                CHANNEL n                    |
+ * ----------------------------------------------------------
+ * | 0x100    |      FILTER  0 + COMMON FILTER FIELDs       |
+ * ----------------------------------------------------------
+ * | 0x200    |                FILTER  1                    |
+ * ----------------------------------------------------------
+ * |          |                .....                        |
+ * ----------------------------------------------------------
+ * | 0x100 x m|                FILTER  m                    |
+ * ----------------------------------------------------------
+ * ----------------------------------------------------------
+ * | 0x7F0-7FC|         Identification registers            |
+ * ----------------------------------------------------------
  */
 
 /*
@@ -231,6 +234,34 @@
 #define DFSDM_AWCFR_AWHTF_MASK	GENMASK(15, 8)
 #define DFSDM_AWCFR_AWHTF(v)	FIELD_PREP(DFSDM_AWCFR_AWHTF_MASK, v)
 
+/*
+ * Identification register definitions
+ */
+#define DFSDM_HWCFGR		0x7F0
+#define DFSDM_VERR		0x7F4
+#define DFSDM_IPIDR		0x7F8
+#define DFSDM_SIDR		0x7FC
+
+/* HWCFGR: Hardware configuration register */
+#define DFSDM_HWCFGR_NBT_SHIFT	0
+#define DFSDM_HWCFGR_NBT_MASK	GENMASK(7, 0)
+#define DFSDM_HWCFGR_NBF_SHIFT	8
+#define DFSDM_HWCFGR_NBF_MASK	GENMASK(15, 8)
+
+/* VERR: Version register */
+#define DFSDM_VERR_MINREV_SHIFT	0
+#define DFSDM_VERR_MINREV_MASK	GENMASK(3, 0)
+#define DFSDM_VERR_MAJREV_SHIFT	4
+#define DFSDM_VERR_MAJREV_MASK	GENMASK(7, 4)
+
+/* IPDR: Identification register */
+#define DFSDM_IPIDR_MASK	GENMASK(31, 0)
+
+/* SIDR: Size identification register */
+#define DFSDM_SIDR_MASK		GENMASK(31, 0)
+
+#define STM32MP15_IPIDR_NUMBER	0x00110031
+
 /* DFSDM filter order  */
 enum stm32_dfsdm_sinc_order {
 	DFSDM_FASTSINC_ORDER, /* FastSinc filter type */
diff --git a/drivers/iio/trigger/stm32-lptimer-trigger.c b/drivers/iio/trigger/stm32-lptimer-trigger.c
index 98cdc7e47..944c7b072 100644
--- a/drivers/iio/trigger/stm32-lptimer-trigger.c
+++ b/drivers/iio/trigger/stm32-lptimer-trigger.c
@@ -14,11 +14,16 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 
+#define STM32_LPTIM_TRIGGERS		3
+#define STM32MP25_LPTIM_TRIGGERS	5
+
 /* List Low-Power Timer triggers */
 static const char * const stm32_lptim_triggers[] = {
 	LPTIM1_OUT,
 	LPTIM2_OUT,
-	LPTIM3_OUT,
+	LPTIM3_OUT,		/* STM32_LPTIM_TRIGGERS */
+	LPTIM4_OUT,
+	LPTIM5_OUT,		/* STM32MP25_LPTIM_TRIGGERS */
 };
 
 struct stm32_lptim_trigger {
@@ -71,6 +76,7 @@ static int stm32_lptim_trigger_probe(struct platform_device *pdev)
 {
 	struct stm32_lptim_trigger *priv;
 	u32 index;
+	unsigned int num_triggers;
 	int ret;
 
 	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
@@ -80,7 +86,9 @@ static int stm32_lptim_trigger_probe(struct platform_device *pdev)
 	if (of_property_read_u32(pdev->dev.of_node, "reg", &index))
 		return -EINVAL;
 
-	if (index >= ARRAY_SIZE(stm32_lptim_triggers))
+	num_triggers = (uintptr_t)device_get_match_data(&pdev->dev);
+
+	if (index >= ARRAY_SIZE(stm32_lptim_triggers) || index >= num_triggers)
 		return -EINVAL;
 
 	priv->dev = &pdev->dev;
@@ -96,7 +104,8 @@ static int stm32_lptim_trigger_probe(struct platform_device *pdev)
 }
 
 static const struct of_device_id stm32_lptim_trig_of_match[] = {
-	{ .compatible = "st,stm32-lptimer-trigger", },
+	{ .compatible = "st,stm32-lptimer-trigger", .data = (void *)STM32_LPTIM_TRIGGERS},
+	{ .compatible = "st,stm32mp25-lptimer-trigger", .data = (void *)STM32MP25_LPTIM_TRIGGERS},
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32_lptim_trig_of_match);
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index d4e74738c..2f6adfb7b 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -425,6 +425,7 @@ config TOUCHSCREEN_HYCON_HY46XX
 config TOUCHSCREEN_ILI210X
 	tristate "Ilitek ILI210X based touchscreen"
 	depends on I2C
+	select CRC_CCITT
 	help
 	  Say Y here if you have a ILI210X based touchscreen
 	  controller. This driver supports models ILI2102,
diff --git a/drivers/input/touchscreen/edt-ft5x06.c b/drivers/input/touchscreen/edt-ft5x06.c
index bb2e1cbff..918d81e6e 100644
--- a/drivers/input/touchscreen/edt-ft5x06.c
+++ b/drivers/input/touchscreen/edt-ft5x06.c
@@ -30,6 +30,8 @@
 #include <linux/uaccess.h>
 
 #include <asm/unaligned.h>
+#include <linux/of_device.h>
+#include <drm/drm_mipi_dsi.h>
 
 #define WORK_REGISTER_THRESHOLD		0x00
 #define WORK_REGISTER_REPORT_RATE	0x08
@@ -914,6 +916,10 @@ static int edt_ft5x06_ts_identify(struct i2c_client *client,
 			snprintf(model_name, EDT_NAME_LEN, "EP%i%i0ML00",
 				rdbuf[0] >> 4, rdbuf[0] & 0x0F);
 			break;
+		case 0x51:   /* Rocktech Rk043fn48h Display */
+			tsdata->version = EV_FT;
+			snprintf(model_name, EDT_NAME_LEN, "FT5336GQQ");
+			break;
 		case 0x5a:   /* Solomon Goldentek Display */
 			snprintf(model_name, EDT_NAME_LEN, "GKTW50SCED1R0");
 			break;
@@ -1078,6 +1084,8 @@ static int edt_ft5x06_ts_probe(struct i2c_client *client,
 	const struct edt_i2c_chip_data *chip_data;
 	struct edt_ft5x06_ts_data *tsdata;
 	u8 buf[2] = { 0xfc, 0x00 };
+	struct mipi_dsi_device *panel;
+	struct device_node *np;
 	struct input_dev *input;
 	unsigned long irq_flags;
 	int error;
@@ -1255,6 +1263,18 @@ static int edt_ft5x06_ts_probe(struct i2c_client *client,
 	if (error)
 		return error;
 
+	np = of_parse_phandle(client->dev.of_node, "panel", 0);
+	if (np) {
+		panel = of_find_mipi_dsi_device_by_node(np);
+		of_node_put(np);
+		if (!panel)
+			return -EPROBE_DEFER;
+
+		device_link_add(&client->dev, &panel->dev, DL_FLAG_STATELESS |
+				DL_FLAG_AUTOREMOVE_SUPPLIER);
+		put_device(&panel->dev);
+	}
+
 	edt_ft5x06_ts_prepare_debugfs(tsdata, dev_driver_string(&client->dev));
 
 	dev_dbg(&client->dev,
diff --git a/drivers/input/touchscreen/goodix.c b/drivers/input/touchscreen/goodix.c
index 3667f7e51..890cc8270 100644
--- a/drivers/input/touchscreen/goodix.c
+++ b/drivers/input/touchscreen/goodix.c
@@ -16,6 +16,7 @@
 #include <linux/firmware.h>
 #include <linux/module.h>
 #include <linux/delay.h>
+#include <drm/drm_mipi_dsi.h>
 #include <linux/irq.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
@@ -248,7 +249,7 @@ static int goodix_ts_read_input_report(struct goodix_ts_data *ts, u8 *data)
 		error = goodix_i2c_read(ts->client, addr, data,
 					header_contact_keycode_size);
 		if (error) {
-			dev_err(&ts->client->dev, "I2C transfer error: %d\n",
+			dev_dbg(&ts->client->dev, "I2C transfer error: %d\n",
 					error);
 			return error;
 		}
@@ -376,7 +377,7 @@ static irqreturn_t goodix_ts_irq_handler(int irq, void *dev_id)
 	goodix_process_events(ts);
 
 	if (goodix_i2c_write_u8(ts->client, GOODIX_READ_COOR_ADDR, 0) < 0)
-		dev_err(&ts->client->dev, "I2C write end_cmd error\n");
+		dev_dbg(&ts->client->dev, "I2C write end_cmd error\n");
 
 	return IRQ_HANDLED;
 }
@@ -1135,6 +1136,8 @@ static int goodix_ts_probe(struct i2c_client *client,
 			   const struct i2c_device_id *id)
 {
 	struct goodix_ts_data *ts;
+	struct mipi_dsi_device *panel;
+	struct device_node *np;
 	int error;
 
 	dev_dbg(&client->dev, "I2C Address: 0x%02x\n", client->addr);
@@ -1186,6 +1189,26 @@ static int goodix_ts_probe(struct i2c_client *client,
 		error = goodix_reset(ts);
 		if (error)
 			return error;
+	} else {
+		/* reset the controller */
+		if (ts->gpiod_rst) {
+			error = gpiod_direction_output(ts->gpiod_rst, 1);
+			if (error) {
+				dev_err(&client->dev, "Gpio reset failed.\n");
+				return error;
+			}
+
+			msleep(20);
+
+			error = gpiod_direction_output(ts->gpiod_rst, 0);
+			if (error) {
+				dev_err(&client->dev, "Gpio unreset failed.\n");
+				return error;
+			}
+
+			/* need a delay after reset to test I2C */
+			msleep(100);
+		}
 	}
 
 	error = goodix_i2c_test(client);
@@ -1232,6 +1255,17 @@ static int goodix_ts_probe(struct i2c_client *client,
 			return error;
 	}
 
+	np = of_parse_phandle(client->dev.of_node, "panel", 0);
+	if (np) {
+		panel = of_find_mipi_dsi_device_by_node(np);
+		of_node_put(np);
+		if (!panel)
+			return -EPROBE_DEFER;
+		device_link_add(&client->dev, &panel->dev, DL_FLAG_STATELESS |
+				DL_FLAG_AUTOREMOVE_SUPPLIER);
+		put_device(&panel->dev);
+	}
+
 	return 0;
 }
 
@@ -1287,6 +1321,7 @@ static int __maybe_unused goodix_suspend(struct device *dev)
 	 * sooner, delay 58ms here.
 	 */
 	msleep(58);
+
 	return 0;
 }
 
diff --git a/drivers/input/touchscreen/ili210x.c b/drivers/input/touchscreen/ili210x.c
index f437eefec..3a48262fb 100644
--- a/drivers/input/touchscreen/ili210x.c
+++ b/drivers/input/touchscreen/ili210x.c
@@ -1,7 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0-only
+#include <linux/crc-ccitt.h>
 #include <linux/delay.h>
 #include <linux/gpio/consumer.h>
 #include <linux/i2c.h>
+#include <linux/ihex.h>
 #include <linux/input.h>
 #include <linux/input/mt.h>
 #include <linux/input/touchscreen.h>
@@ -12,7 +14,7 @@
 #include <linux/slab.h>
 #include <asm/unaligned.h>
 
-#define ILI2XXX_POLL_PERIOD	20
+#define ILI2XXX_POLL_PERIOD	15
 
 #define ILI210X_DATA_SIZE	64
 #define ILI211X_DATA_SIZE	43
@@ -22,8 +24,23 @@
 /* Touchscreen commands */
 #define REG_TOUCHDATA		0x10
 #define REG_PANEL_INFO		0x20
+#define REG_FIRMWARE_VERSION	0x40
+#define REG_PROTOCOL_VERSION	0x42
+#define REG_KERNEL_VERSION	0x61
+#define REG_IC_BUSY		0x80
+#define REG_IC_BUSY_NOT_BUSY	0x50
+#define REG_GET_MODE		0xc0
+#define REG_GET_MODE_AP		0x5a
+#define REG_GET_MODE_BL		0x55
+#define REG_SET_MODE_AP		0xc1
+#define REG_SET_MODE_BL		0xc2
+#define REG_WRITE_DATA		0xc3
+#define REG_WRITE_ENABLE	0xc4
+#define REG_READ_DATA_CRC	0xc7
 #define REG_CALIBRATE		0xcc
 
+#define ILI251X_FW_FILENAME	"ilitek/ili251x.bin"
+
 struct ili2xxx_chip {
 	int (*read_reg)(struct i2c_client *client, u8 reg,
 			void *buf, size_t len);
@@ -35,6 +52,7 @@ struct ili2xxx_chip {
 	unsigned int max_touches;
 	unsigned int resolution;
 	bool has_calibrate_reg;
+	bool has_firmware_proto;
 	bool has_pressure_reg;
 };
 
@@ -44,6 +62,10 @@ struct ili210x {
 	struct gpio_desc *reset_gpio;
 	struct touchscreen_properties prop;
 	const struct ili2xxx_chip *chip;
+	u8 version_firmware[8];
+	u8 version_kernel[5];
+	u8 version_proto[2];
+	u8 ic_mode[2];
 	bool stop;
 };
 
@@ -202,15 +224,17 @@ static const struct ili2xxx_chip ili212x_chip = {
 	.has_calibrate_reg	= true,
 };
 
-static int ili251x_read_reg(struct i2c_client *client,
-			    u8 reg, void *buf, size_t len)
+static int ili251x_read_reg_common(struct i2c_client *client,
+				   u8 reg, void *buf, size_t len,
+				   unsigned int delay)
 {
 	int error;
 	int ret;
 
 	ret = i2c_master_send(client, &reg, 1);
 	if (ret == 1) {
-		usleep_range(5000, 5500);
+		if (delay)
+			usleep_range(delay, delay + 500);
 
 		ret = i2c_master_recv(client, buf, len);
 		if (ret == len)
@@ -222,12 +246,18 @@ static int ili251x_read_reg(struct i2c_client *client,
 	return ret;
 }
 
+static int ili251x_read_reg(struct i2c_client *client,
+			    u8 reg, void *buf, size_t len)
+{
+	return ili251x_read_reg_common(client, reg, buf, len, 5000);
+}
+
 static int ili251x_read_touch_data(struct i2c_client *client, u8 *data)
 {
 	int error;
 
-	error = ili251x_read_reg(client, REG_TOUCHDATA,
-				 data, ILI251X_DATA_SIZE1);
+	error = ili251x_read_reg_common(client, REG_TOUCHDATA,
+					data, ILI251X_DATA_SIZE1, 0);
 	if (!error && data[0] == 2) {
 		error = i2c_master_recv(client, data + ILI251X_DATA_SIZE1,
 					ILI251X_DATA_SIZE2);
@@ -268,6 +298,7 @@ static const struct ili2xxx_chip ili251x_chip = {
 	.continue_polling	= ili251x_check_continue_polling,
 	.max_touches		= 10,
 	.has_calibrate_reg	= true,
+	.has_firmware_proto	= true,
 	.has_pressure_reg	= true,
 };
 
@@ -303,10 +334,13 @@ static irqreturn_t ili210x_irq(int irq, void *irq_data)
 	const struct ili2xxx_chip *chip = priv->chip;
 	u8 touchdata[ILI210X_DATA_SIZE] = { 0 };
 	bool keep_polling;
+	ktime_t time_next;
+	s64 time_delta;
 	bool touch;
 	int error;
 
 	do {
+		time_next = ktime_add_ms(ktime_get(), ILI2XXX_POLL_PERIOD);
 		error = chip->get_touch_data(client, touchdata);
 		if (error) {
 			dev_err(&client->dev,
@@ -316,13 +350,201 @@ static irqreturn_t ili210x_irq(int irq, void *irq_data)
 
 		touch = ili210x_report_events(priv, touchdata);
 		keep_polling = chip->continue_polling(touchdata, touch);
-		if (keep_polling)
-			msleep(ILI2XXX_POLL_PERIOD);
+		if (keep_polling) {
+			time_delta = ktime_us_delta(time_next, ktime_get());
+			if (time_delta > 0)
+				usleep_range(time_delta, time_delta + 1000);
+		}
 	} while (!priv->stop && keep_polling);
 
 	return IRQ_HANDLED;
 }
 
+static int ili251x_firmware_update_resolution(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ili210x *priv = i2c_get_clientdata(client);
+	u16 resx, resy;
+	u8 rs[10];
+	int error;
+
+	/* The firmware update blob might have changed the resolution. */
+	error = priv->chip->read_reg(client, REG_PANEL_INFO, &rs, sizeof(rs));
+	if (error)
+		return error;
+
+	resx = le16_to_cpup((__le16 *)rs);
+	resy = le16_to_cpup((__le16 *)(rs + 2));
+
+	/* The value reported by the firmware is invalid. */
+	if (!resx || resx == 0xffff || !resy || resy == 0xffff)
+		return -EINVAL;
+
+	input_abs_set_max(priv->input, ABS_X, resx - 1);
+	input_abs_set_max(priv->input, ABS_Y, resy - 1);
+	input_abs_set_max(priv->input, ABS_MT_POSITION_X, resx - 1);
+	input_abs_set_max(priv->input, ABS_MT_POSITION_Y, resy - 1);
+
+	return 0;
+}
+
+static ssize_t ili251x_firmware_update_firmware_version(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ili210x *priv = i2c_get_clientdata(client);
+	int error;
+	u8 fw[8];
+
+	/* Get firmware version */
+	error = priv->chip->read_reg(client, REG_FIRMWARE_VERSION,
+				     &fw, sizeof(fw));
+	if (!error)
+		memcpy(priv->version_firmware, fw, sizeof(fw));
+
+	return error;
+}
+
+static ssize_t ili251x_firmware_update_kernel_version(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ili210x *priv = i2c_get_clientdata(client);
+	int error;
+	u8 kv[5];
+
+	/* Get kernel version */
+	error = priv->chip->read_reg(client, REG_KERNEL_VERSION,
+				     &kv, sizeof(kv));
+	if (!error)
+		memcpy(priv->version_kernel, kv, sizeof(kv));
+
+	return error;
+}
+
+static ssize_t ili251x_firmware_update_protocol_version(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ili210x *priv = i2c_get_clientdata(client);
+	int error;
+	u8 pv[2];
+
+	/* Get protocol version */
+	error = priv->chip->read_reg(client, REG_PROTOCOL_VERSION,
+				     &pv, sizeof(pv));
+	if (!error)
+		memcpy(priv->version_proto, pv, sizeof(pv));
+
+	return error;
+}
+
+static ssize_t ili251x_firmware_update_ic_mode(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ili210x *priv = i2c_get_clientdata(client);
+	int error;
+	u8 md[2];
+
+	/* Get chip boot mode */
+	error = priv->chip->read_reg(client, REG_GET_MODE, &md, sizeof(md));
+	if (!error)
+		memcpy(priv->ic_mode, md, sizeof(md));
+
+	return error;
+}
+
+static int ili251x_firmware_update_cached_state(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ili210x *priv = i2c_get_clientdata(client);
+	int error;
+
+	if (!priv->chip->has_firmware_proto)
+		return 0;
+
+	/* Wait for firmware to boot and stabilize itself. */
+	msleep(200);
+
+	/* Firmware does report valid information. */
+	error = ili251x_firmware_update_resolution(dev);
+	if (error)
+		return error;
+
+	error = ili251x_firmware_update_firmware_version(dev);
+	if (error)
+		return error;
+
+	error = ili251x_firmware_update_kernel_version(dev);
+	if (error)
+		return error;
+
+	error = ili251x_firmware_update_protocol_version(dev);
+	if (error)
+		return error;
+
+	error = ili251x_firmware_update_ic_mode(dev);
+	if (error)
+		return error;
+
+	return 0;
+}
+
+static ssize_t ili251x_firmware_version_show(struct device *dev,
+					     struct device_attribute *attr,
+					     char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ili210x *priv = i2c_get_clientdata(client);
+	u8 *fw = priv->version_firmware;
+
+	return sysfs_emit(buf, "%02x%02x.%02x%02x.%02x%02x.%02x%02x\n",
+			  fw[0], fw[1], fw[2], fw[3],
+			  fw[4], fw[5], fw[6], fw[7]);
+}
+static DEVICE_ATTR(firmware_version, 0444, ili251x_firmware_version_show, NULL);
+
+static ssize_t ili251x_kernel_version_show(struct device *dev,
+					   struct device_attribute *attr,
+					   char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ili210x *priv = i2c_get_clientdata(client);
+	u8 *kv = priv->version_kernel;
+
+	return sysfs_emit(buf, "%02x.%02x.%02x.%02x.%02x\n",
+			  kv[0], kv[1], kv[2], kv[3], kv[4]);
+}
+static DEVICE_ATTR(kernel_version, 0444, ili251x_kernel_version_show, NULL);
+
+static ssize_t ili251x_protocol_version_show(struct device *dev,
+					     struct device_attribute *attr,
+					     char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ili210x *priv = i2c_get_clientdata(client);
+	u8 *pv = priv->version_proto;
+
+	return sysfs_emit(buf, "%02x.%02x\n", pv[0], pv[1]);
+}
+static DEVICE_ATTR(protocol_version, 0444, ili251x_protocol_version_show, NULL);
+
+static ssize_t ili251x_mode_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ili210x *priv = i2c_get_clientdata(client);
+	u8 *md = priv->ic_mode;
+	char *mode = "AP";
+
+	if (md[0] == REG_GET_MODE_AP)		/* Application Mode */
+		mode = "AP";
+	else if (md[0] == REG_GET_MODE_BL)	/* BootLoader Mode */
+		mode = "BL";
+	else					/* Unknown Mode */
+		mode = "??";
+
+	return sysfs_emit(buf, "%02x.%02x:%s\n", md[0], md[1], mode);
+}
+static DEVICE_ATTR(mode, 0444, ili251x_mode_show, NULL);
+
 static ssize_t ili210x_calibrate(struct device *dev,
 				 struct device_attribute *attr,
 				 const char *buf, size_t count)
@@ -349,24 +571,333 @@ static ssize_t ili210x_calibrate(struct device *dev,
 }
 static DEVICE_ATTR(calibrate, S_IWUSR, NULL, ili210x_calibrate);
 
+static int ili251x_firmware_to_buffer(const struct firmware *fw,
+				      u8 **buf, u16 *ac_end, u16 *df_end)
+{
+	const struct ihex_binrec *rec;
+	u32 fw_addr, fw_last_addr = 0;
+	u16 fw_len;
+	u8 *fw_buf;
+	int error;
+
+	/*
+	 * The firmware ihex blob can never be bigger than 64 kiB, so make this
+	 * simple -- allocate a 64 kiB buffer, iterate over the ihex blob records
+	 * once, copy them all into this buffer at the right locations, and then
+	 * do all operations on this linear buffer.
+	 */
+	fw_buf = kzalloc(SZ_64K, GFP_KERNEL);
+	if (!fw_buf)
+		return -ENOMEM;
+
+	rec = (const struct ihex_binrec *)fw->data;
+	while (rec) {
+		fw_addr = be32_to_cpu(rec->addr);
+		fw_len = be16_to_cpu(rec->len);
+
+		/* The last 32 Byte firmware block can be 0xffe0 */
+		if (fw_addr + fw_len > SZ_64K || fw_addr > SZ_64K - 32) {
+			error = -EFBIG;
+			goto err_big;
+		}
+
+		/* Find the last address before DF start address, that is AC end */
+		if (fw_addr == 0xf000)
+			*ac_end = fw_last_addr;
+		fw_last_addr = fw_addr + fw_len;
+
+		memcpy(fw_buf + fw_addr, rec->data, fw_len);
+		rec = ihex_next_binrec(rec);
+	}
+
+	/* DF end address is the last address in the firmware blob */
+	*df_end = fw_addr + fw_len;
+	*buf = fw_buf;
+	return 0;
+
+err_big:
+	kfree(fw_buf);
+	return error;
+}
+
+/* Switch mode between Application and BootLoader */
+static int ili251x_switch_ic_mode(struct i2c_client *client, u8 cmd_mode)
+{
+	struct ili210x *priv = i2c_get_clientdata(client);
+	u8 cmd_wren[3] = { REG_WRITE_ENABLE, 0x5a, 0xa5 };
+	u8 md[2];
+	int error;
+
+	error = priv->chip->read_reg(client, REG_GET_MODE, md, sizeof(md));
+	if (error)
+		return error;
+	/* Mode already set */
+	if ((cmd_mode == REG_SET_MODE_AP && md[0] == REG_GET_MODE_AP) ||
+	    (cmd_mode == REG_SET_MODE_BL && md[0] == REG_GET_MODE_BL))
+		return 0;
+
+	/* Unlock writes */
+	error = i2c_master_send(client, cmd_wren, sizeof(cmd_wren));
+	if (error != sizeof(cmd_wren))
+		return -EINVAL;
+
+	mdelay(20);
+
+	/* Select mode (BootLoader or Application) */
+	error = i2c_master_send(client, &cmd_mode, 1);
+	if (error != 1)
+		return -EINVAL;
+
+	mdelay(200);	/* Reboot into bootloader takes a lot of time ... */
+
+	/* Read back mode */
+	error = priv->chip->read_reg(client, REG_GET_MODE, md, sizeof(md));
+	if (error)
+		return error;
+	/* Check if mode is correct now. */
+	if ((cmd_mode == REG_SET_MODE_AP && md[0] == REG_GET_MODE_AP) ||
+	    (cmd_mode == REG_SET_MODE_BL && md[0] == REG_GET_MODE_BL))
+		return 0;
+
+	return -EINVAL;
+}
+
+static int ili251x_firmware_busy(struct i2c_client *client)
+{
+	struct ili210x *priv = i2c_get_clientdata(client);
+	int error, i = 0;
+	u8 data;
+
+	do {
+		/* The read_reg already contains suitable delay */
+		error = priv->chip->read_reg(client, REG_IC_BUSY, &data, 1);
+		if (error)
+			return error;
+		if (i++ == 100000)
+			return -ETIMEDOUT;
+	} while (data != REG_IC_BUSY_NOT_BUSY);
+
+	return 0;
+}
+
+static int ili251x_firmware_write_to_ic(struct device *dev, u8 *fwbuf,
+					u16 start, u16 end, u8 dataflash)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ili210x *priv = i2c_get_clientdata(client);
+	u8 cmd_crc = REG_READ_DATA_CRC;
+	u8 crcrb[4] = { 0 };
+	u8 fw_data[33];
+	u16 fw_addr;
+	int error;
+
+	/*
+	 * The DF (dataflash) needs 2 bytes offset for unknown reasons,
+	 * the AC (application) has 2 bytes CRC16-CCITT at the end.
+	 */
+	u16 crc = crc_ccitt(0, fwbuf + start + (dataflash ? 2 : 0),
+			    end - start - 2);
+
+	/* Unlock write to either AC (application) or DF (dataflash) area */
+	u8 cmd_wr[10] = {
+		REG_WRITE_ENABLE, 0x5a, 0xa5, dataflash,
+		(end >> 16) & 0xff, (end >> 8) & 0xff, end & 0xff,
+		(crc >> 16) & 0xff, (crc >> 8) & 0xff, crc & 0xff
+	};
+
+	error = i2c_master_send(client, cmd_wr, sizeof(cmd_wr));
+	if (error != sizeof(cmd_wr))
+		return -EINVAL;
+
+	error = ili251x_firmware_busy(client);
+	if (error)
+		return error;
+
+	for (fw_addr = start; fw_addr < end; fw_addr += 32) {
+		fw_data[0] = REG_WRITE_DATA;
+		memcpy(&(fw_data[1]), fwbuf + fw_addr, 32);
+		error = i2c_master_send(client, fw_data, 33);
+		if (error != sizeof(fw_data))
+			return error;
+		error = ili251x_firmware_busy(client);
+		if (error)
+			return error;
+	}
+
+	error = i2c_master_send(client, &cmd_crc, 1);
+	if (error != 1)
+		return -EINVAL;
+
+	error = ili251x_firmware_busy(client);
+	if (error)
+		return error;
+
+	error = priv->chip->read_reg(client, REG_READ_DATA_CRC,
+				   &crcrb, sizeof(crcrb));
+	if (error)
+		return error;
+
+	/* Check CRC readback */
+	if ((crcrb[0] != (crc & 0xff)) || crcrb[1] != ((crc >> 8) & 0xff))
+		return -EINVAL;
+
+	return 0;
+}
+
+static int ili251x_firmware_reset(struct i2c_client *client)
+{
+	u8 cmd_reset[2] = { 0xf2, 0x01 };
+	int error;
+
+	error = i2c_master_send(client, cmd_reset, sizeof(cmd_reset));
+	if (error != sizeof(cmd_reset))
+		return -EINVAL;
+
+	return ili251x_firmware_busy(client);
+}
+
+static void ili251x_hardware_reset(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ili210x *priv = i2c_get_clientdata(client);
+
+	/* Reset the controller */
+	gpiod_set_value_cansleep(priv->reset_gpio, 1);
+	usleep_range(10000, 15000);
+	gpiod_set_value_cansleep(priv->reset_gpio, 0);
+	msleep(300);
+}
+
+static ssize_t ili210x_firmware_update_store(struct device *dev,
+					     struct device_attribute *attr,
+					     const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	const char *fwname = ILI251X_FW_FILENAME;
+	const struct firmware *fw;
+	u16 ac_end, df_end;
+	u8 *fwbuf;
+	int error;
+	int i;
+
+	error = request_ihex_firmware(&fw, fwname, dev);
+	if (error) {
+		dev_err(dev, "Failed to request firmware %s, error=%d\n",
+			fwname, error);
+		return error;
+	}
+
+	error = ili251x_firmware_to_buffer(fw, &fwbuf, &ac_end, &df_end);
+	release_firmware(fw);
+	if (error)
+		return error;
+
+	/*
+	 * Disable touchscreen IRQ, so that we would not get spurious touch
+	 * interrupt during firmware update, and so that the IRQ handler won't
+	 * trigger and interfere with the firmware update. There is no bit in
+	 * the touch controller to disable the IRQs during update, so we have
+	 * to do it this way here.
+	 */
+	disable_irq(client->irq);
+
+	dev_dbg(dev, "Firmware update started, firmware=%s\n", fwname);
+
+	ili251x_hardware_reset(dev);
+
+	error = ili251x_firmware_reset(client);
+	if (error)
+		goto exit;
+
+	/* This may not succeed on first try, so re-try a few times. */
+	for (i = 0; i < 5; i++) {
+		error = ili251x_switch_ic_mode(client, REG_SET_MODE_BL);
+		if (!error)
+			break;
+	}
+
+	if (error)
+		goto exit;
+
+	dev_dbg(dev, "IC is now in BootLoader mode\n");
+
+	msleep(200);	/* The bootloader seems to need some time too. */
+
+	error = ili251x_firmware_write_to_ic(dev, fwbuf, 0xf000, df_end, 1);
+	if (error) {
+		dev_err(dev, "DF firmware update failed, error=%d\n", error);
+		goto exit;
+	}
+
+	dev_dbg(dev, "DataFlash firmware written\n");
+
+	error = ili251x_firmware_write_to_ic(dev, fwbuf, 0x2000, ac_end, 0);
+	if (error) {
+		dev_err(dev, "AC firmware update failed, error=%d\n", error);
+		goto exit;
+	}
+
+	dev_dbg(dev, "Application firmware written\n");
+
+	/* This may not succeed on first try, so re-try a few times. */
+	for (i = 0; i < 5; i++) {
+		error = ili251x_switch_ic_mode(client, REG_SET_MODE_AP);
+		if (!error)
+			break;
+	}
+
+	if (error)
+		goto exit;
+
+	dev_dbg(dev, "IC is now in Application mode\n");
+
+	error = ili251x_firmware_update_cached_state(dev);
+	if (error)
+		goto exit;
+
+	error = count;
+
+exit:
+	ili251x_hardware_reset(dev);
+	dev_dbg(dev, "Firmware update ended, error=%i\n", error);
+	enable_irq(client->irq);
+	kfree(fwbuf);
+	return error;
+}
+
+static DEVICE_ATTR(firmware_update, 0200, NULL, ili210x_firmware_update_store);
+
 static struct attribute *ili210x_attributes[] = {
 	&dev_attr_calibrate.attr,
+	&dev_attr_firmware_update.attr,
+	&dev_attr_firmware_version.attr,
+	&dev_attr_kernel_version.attr,
+	&dev_attr_protocol_version.attr,
+	&dev_attr_mode.attr,
 	NULL,
 };
 
-static umode_t ili210x_calibrate_visible(struct kobject *kobj,
+static umode_t ili210x_attributes_visible(struct kobject *kobj,
 					  struct attribute *attr, int index)
 {
 	struct device *dev = kobj_to_dev(kobj);
 	struct i2c_client *client = to_i2c_client(dev);
 	struct ili210x *priv = i2c_get_clientdata(client);
 
-	return priv->chip->has_calibrate_reg ? attr->mode : 0;
+	/* Calibrate is present on all ILI2xxx which have calibrate register */
+	if (attr == &dev_attr_calibrate.attr)
+		return priv->chip->has_calibrate_reg ? attr->mode : 0;
+
+	/* Firmware/Kernel/Protocol/BootMode is implememted only for ILI251x */
+	if (!priv->chip->has_firmware_proto)
+		return 0;
+
+	return attr->mode;
 }
 
 static const struct attribute_group ili210x_attr_group = {
 	.attrs = ili210x_attributes,
-	.is_visible = ili210x_calibrate_visible,
+	.is_visible = ili210x_attributes_visible,
 };
 
 static void ili210x_power_down(void *data)
@@ -449,6 +980,12 @@ static int ili210x_i2c_probe(struct i2c_client *client,
 	input_set_abs_params(input, ABS_MT_POSITION_Y, 0, max_xy, 0, 0);
 	if (priv->chip->has_pressure_reg)
 		input_set_abs_params(input, ABS_MT_PRESSURE, 0, 0xa, 0, 0);
+	error = ili251x_firmware_update_cached_state(dev);
+	if (error) {
+		dev_err(dev, "Unable to cache firmware information, err: %d\n",
+			error);
+		return error;
+	}
 	touchscreen_parse_properties(input, true, &priv->prop);
 
 	error = input_mt_init_slots(input, priv->chip->max_touches,
diff --git a/drivers/irqchip/irq-stm32-exti.c b/drivers/irqchip/irq-stm32-exti.c
index 33c76710f..78bc38d1f 100644
--- a/drivers/irqchip/irq-stm32-exti.c
+++ b/drivers/irqchip/irq-stm32-exti.c
@@ -14,6 +14,7 @@
 #include <linux/irqchip.h>
 #include <linux/irqchip/chained_irq.h>
 #include <linux/irqdomain.h>
+#include <linux/list.h>
 #include <linux/module.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
@@ -34,21 +35,15 @@ struct stm32_exti_bank {
 	u32 swier_ofst;
 	u32 rpr_ofst;
 	u32 fpr_ofst;
+	u32 trg_ofst;
 };
 
 #define UNDEF_REG ~0
 
-struct stm32_desc_irq {
-	u32 exti;
-	u32 irq_parent;
-	struct irq_chip *chip;
-};
-
 struct stm32_exti_drv_data {
 	const struct stm32_exti_bank **exti_banks;
-	const struct stm32_desc_irq *desc_irqs;
+	const u8 *desc_irqs;
 	u32 bank_nr;
-	u32 irq_nr;
 };
 
 struct stm32_exti_chip_data {
@@ -62,13 +57,15 @@ struct stm32_exti_chip_data {
 };
 
 struct stm32_exti_host_data {
+	struct list_head lh;
 	void __iomem *base;
 	struct stm32_exti_chip_data *chips_data;
 	const struct stm32_exti_drv_data *drv_data;
 	struct hwspinlock *hwlock;
+	struct device_node *irq_map_node;
 };
 
-static struct stm32_exti_host_data *stm32_host_data;
+static LIST_HEAD(stm32_host_data_list);
 
 static const struct stm32_exti_bank stm32f4xx_exti_b1 = {
 	.imr_ofst	= 0x00,
@@ -78,6 +75,7 @@ static const struct stm32_exti_bank stm32f4xx_exti_b1 = {
 	.swier_ofst	= 0x10,
 	.rpr_ofst	= 0x14,
 	.fpr_ofst	= UNDEF_REG,
+	.trg_ofst	= UNDEF_REG,
 };
 
 static const struct stm32_exti_bank *stm32f4xx_exti_banks[] = {
@@ -97,6 +95,7 @@ static const struct stm32_exti_bank stm32h7xx_exti_b1 = {
 	.swier_ofst	= 0x08,
 	.rpr_ofst	= 0x88,
 	.fpr_ofst	= UNDEF_REG,
+	.trg_ofst	= UNDEF_REG,
 };
 
 static const struct stm32_exti_bank stm32h7xx_exti_b2 = {
@@ -107,6 +106,7 @@ static const struct stm32_exti_bank stm32h7xx_exti_b2 = {
 	.swier_ofst	= 0x28,
 	.rpr_ofst	= 0x98,
 	.fpr_ofst	= UNDEF_REG,
+	.trg_ofst	= UNDEF_REG,
 };
 
 static const struct stm32_exti_bank stm32h7xx_exti_b3 = {
@@ -117,6 +117,7 @@ static const struct stm32_exti_bank stm32h7xx_exti_b3 = {
 	.swier_ofst	= 0x48,
 	.rpr_ofst	= 0xA8,
 	.fpr_ofst	= UNDEF_REG,
+	.trg_ofst	= UNDEF_REG,
 };
 
 static const struct stm32_exti_bank *stm32h7xx_exti_banks[] = {
@@ -132,32 +133,32 @@ static const struct stm32_exti_drv_data stm32h7xx_drv_data = {
 
 static const struct stm32_exti_bank stm32mp1_exti_b1 = {
 	.imr_ofst	= 0x80,
-	.emr_ofst	= 0x84,
 	.rtsr_ofst	= 0x00,
 	.ftsr_ofst	= 0x04,
 	.swier_ofst	= 0x08,
 	.rpr_ofst	= 0x0C,
 	.fpr_ofst	= 0x10,
+	.trg_ofst	= 0x3EC,
 };
 
 static const struct stm32_exti_bank stm32mp1_exti_b2 = {
 	.imr_ofst	= 0x90,
-	.emr_ofst	= 0x94,
 	.rtsr_ofst	= 0x20,
 	.ftsr_ofst	= 0x24,
 	.swier_ofst	= 0x28,
 	.rpr_ofst	= 0x2C,
 	.fpr_ofst	= 0x30,
+	.trg_ofst	= 0x3E8,
 };
 
 static const struct stm32_exti_bank stm32mp1_exti_b3 = {
 	.imr_ofst	= 0xA0,
-	.emr_ofst	= 0xA4,
 	.rtsr_ofst	= 0x40,
 	.ftsr_ofst	= 0x44,
 	.swier_ofst	= 0x48,
 	.rpr_ofst	= 0x4C,
 	.fpr_ofst	= 0x50,
+	.trg_ofst	= 0x3E4,
 };
 
 static const struct stm32_exti_bank *stm32mp1_exti_banks[] = {
@@ -169,76 +170,115 @@ static const struct stm32_exti_bank *stm32mp1_exti_banks[] = {
 static struct irq_chip stm32_exti_h_chip;
 static struct irq_chip stm32_exti_h_chip_direct;
 
-static const struct stm32_desc_irq stm32mp1_desc_irq[] = {
-	{ .exti = 0, .irq_parent = 6, .chip = &stm32_exti_h_chip },
-	{ .exti = 1, .irq_parent = 7, .chip = &stm32_exti_h_chip },
-	{ .exti = 2, .irq_parent = 8, .chip = &stm32_exti_h_chip },
-	{ .exti = 3, .irq_parent = 9, .chip = &stm32_exti_h_chip },
-	{ .exti = 4, .irq_parent = 10, .chip = &stm32_exti_h_chip },
-	{ .exti = 5, .irq_parent = 23, .chip = &stm32_exti_h_chip },
-	{ .exti = 6, .irq_parent = 64, .chip = &stm32_exti_h_chip },
-	{ .exti = 7, .irq_parent = 65, .chip = &stm32_exti_h_chip },
-	{ .exti = 8, .irq_parent = 66, .chip = &stm32_exti_h_chip },
-	{ .exti = 9, .irq_parent = 67, .chip = &stm32_exti_h_chip },
-	{ .exti = 10, .irq_parent = 40, .chip = &stm32_exti_h_chip },
-	{ .exti = 11, .irq_parent = 42, .chip = &stm32_exti_h_chip },
-	{ .exti = 12, .irq_parent = 76, .chip = &stm32_exti_h_chip },
-	{ .exti = 13, .irq_parent = 77, .chip = &stm32_exti_h_chip },
-	{ .exti = 14, .irq_parent = 121, .chip = &stm32_exti_h_chip },
-	{ .exti = 15, .irq_parent = 127, .chip = &stm32_exti_h_chip },
-	{ .exti = 16, .irq_parent = 1, .chip = &stm32_exti_h_chip },
-	{ .exti = 19, .irq_parent = 3, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 21, .irq_parent = 31, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 22, .irq_parent = 33, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 23, .irq_parent = 72, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 24, .irq_parent = 95, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 25, .irq_parent = 107, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 26, .irq_parent = 37, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 27, .irq_parent = 38, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 28, .irq_parent = 39, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 29, .irq_parent = 71, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 30, .irq_parent = 52, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 31, .irq_parent = 53, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 32, .irq_parent = 82, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 33, .irq_parent = 83, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 47, .irq_parent = 93, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 48, .irq_parent = 138, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 50, .irq_parent = 139, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 52, .irq_parent = 140, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 53, .irq_parent = 141, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 54, .irq_parent = 135, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 61, .irq_parent = 100, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 65, .irq_parent = 144, .chip = &stm32_exti_h_chip },
-	{ .exti = 68, .irq_parent = 143, .chip = &stm32_exti_h_chip },
-	{ .exti = 70, .irq_parent = 62, .chip = &stm32_exti_h_chip_direct },
-	{ .exti = 73, .irq_parent = 129, .chip = &stm32_exti_h_chip },
+#define EXTI_INVALID_IRQ       U8_MAX
+#define STM32MP1_DESC_IRQ_SIZE (ARRAY_SIZE(stm32mp1_exti_banks) * IRQS_PER_BANK)
+
+static const u8 stm32mp1_desc_irq[] = {
+	/* default value */
+	[0 ... (STM32MP1_DESC_IRQ_SIZE - 1)] = EXTI_INVALID_IRQ,
+
+	[0] = 6,
+	[1] = 7,
+	[2] = 8,
+	[3] = 9,
+	[4] = 10,
+	[5] = 23,
+	[6] = 64,
+	[7] = 65,
+	[8] = 66,
+	[9] = 67,
+	[10] = 40,
+	[11] = 42,
+	[12] = 76,
+	[13] = 77,
+	[14] = 121,
+	[15] = 127,
+	[16] = 1,
+	[19] = 3,
+	[21] = 31,
+	[22] = 33,
+	[23] = 72,
+	[24] = 95,
+	[25] = 107,
+	[26] = 37,
+	[27] = 38,
+	[28] = 39,
+	[29] = 71,
+	[30] = 52,
+	[31] = 53,
+	[32] = 82,
+	[33] = 83,
+	[43] = 75,
+	[44] = 98,
+	[47] = 93,
+	[48] = 138,
+	[50] = 139,
+	[52] = 140,
+	[53] = 141,
+	[54] = 135,
+	[61] = 100,
+	[65] = 144,
+	[68] = 143,
+	[70] = 62,
+	[73] = 129,
+};
+
+static const u8 stm32mp13_desc_irq[] = {
+	/* default value */
+	[0 ... (STM32MP1_DESC_IRQ_SIZE - 1)] = EXTI_INVALID_IRQ,
+
+	[0] = 6,
+	[1] = 7,
+	[2] = 8,
+	[3] = 9,
+	[4] = 10,
+	[5] = 24,
+	[6] = 65,
+	[7] = 66,
+	[8] = 67,
+	[9] = 68,
+	[10] = 41,
+	[11] = 43,
+	[12] = 77,
+	[13] = 78,
+	[14] = 106,
+	[15] = 109,
+	[16] = 1,
+	[19] = 3,
+	[21] = 32,
+	[22] = 34,
+	[23] = 73,
+	[24] = 93,
+	[25] = 114,
+	[26] = 38,
+	[27] = 39,
+	[28] = 40,
+	[29] = 72,
+	[30] = 53,
+	[31] = 54,
+	[32] = 83,
+	[33] = 84,
+	[44] = 96,
+	[47] = 92,
+	[48] = 116,
+	[50] = 117,
+	[52] = 118,
+	[53] = 119,
+	[68] = 63,
+	[70] = 98,
 };
 
 static const struct stm32_exti_drv_data stm32mp1_drv_data = {
 	.exti_banks = stm32mp1_exti_banks,
 	.bank_nr = ARRAY_SIZE(stm32mp1_exti_banks),
 	.desc_irqs = stm32mp1_desc_irq,
-	.irq_nr = ARRAY_SIZE(stm32mp1_desc_irq),
 };
 
-static const struct
-stm32_desc_irq *stm32_exti_get_desc(const struct stm32_exti_drv_data *drv_data,
-				    irq_hw_number_t hwirq)
-{
-	const struct stm32_desc_irq *desc = NULL;
-	int i;
-
-	if (!drv_data->desc_irqs)
-		return NULL;
-
-	for (i = 0; i < drv_data->irq_nr; i++) {
-		desc = &drv_data->desc_irqs[i];
-		if (desc->exti == hwirq)
-			break;
-	}
-
-	return desc;
-}
+static const struct stm32_exti_drv_data stm32mp13_drv_data = {
+	.exti_banks = stm32mp1_exti_banks,
+	.bank_nr = ARRAY_SIZE(stm32mp1_exti_banks),
+	.desc_irqs = stm32mp13_desc_irq,
+};
 
 static unsigned long stm32_exti_pending(struct irq_chip_generic *gc)
 {
@@ -504,6 +544,16 @@ static void stm32_exti_h_unmask(struct irq_data *d)
 		irq_chip_unmask_parent(d);
 }
 
+static int stm32_exti_h_request_resources(struct irq_data *data)
+{
+	data = data->parent_data;
+
+	if (data->chip->irq_request_resources)
+		return data->chip->irq_request_resources(data);
+
+	return 0;
+}
+
 static int stm32_exti_h_set_type(struct irq_data *d, unsigned int type)
 {
 	struct stm32_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);
@@ -539,6 +589,9 @@ static int stm32_exti_h_set_type(struct irq_data *d, unsigned int type)
 unlock:
 	raw_spin_unlock(&chip_data->rlock);
 
+	if (d->parent_data->chip)
+		irq_chip_set_type_parent(d, type);
+
 	return err;
 }
 
@@ -556,6 +609,9 @@ static int stm32_exti_h_set_wake(struct irq_data *d, unsigned int on)
 
 	raw_spin_unlock(&chip_data->rlock);
 
+	if (d->parent_data->chip)
+		irq_chip_set_wake_parent(d, on);
+
 	return 0;
 }
 
@@ -565,53 +621,74 @@ static int stm32_exti_h_set_affinity(struct irq_data *d,
 	if (d->parent_data->chip)
 		return irq_chip_set_affinity_parent(d, dest, force);
 
-	return -EINVAL;
+	return IRQ_SET_MASK_OK_DONE;
 }
 
-static int __maybe_unused stm32_exti_h_suspend(void)
+static void stm32_exti_h_ack(struct irq_data *d)
+{
+	if (d->parent_data->chip)
+		irq_chip_ack_parent(d);
+}
+
+static int stm32_exti_h_suspend(void)
 {
 	struct stm32_exti_chip_data *chip_data;
+	struct stm32_exti_host_data *host_data;
 	int i;
 
-	for (i = 0; i < stm32_host_data->drv_data->bank_nr; i++) {
-		chip_data = &stm32_host_data->chips_data[i];
-		raw_spin_lock(&chip_data->rlock);
-		stm32_chip_suspend(chip_data, chip_data->wake_active);
-		raw_spin_unlock(&chip_data->rlock);
+	list_for_each_entry(host_data, &stm32_host_data_list, lh) {
+		for (i = 0; i < host_data->drv_data->bank_nr; i++) {
+			chip_data = &host_data->chips_data[i];
+			raw_spin_lock(&chip_data->rlock);
+			stm32_chip_suspend(chip_data, chip_data->wake_active);
+			raw_spin_unlock(&chip_data->rlock);
+		}
 	}
 
 	return 0;
 }
 
-static void __maybe_unused stm32_exti_h_resume(void)
+static void stm32_exti_h_resume(void)
 {
 	struct stm32_exti_chip_data *chip_data;
+	struct stm32_exti_host_data *host_data;
 	int i;
 
-	for (i = 0; i < stm32_host_data->drv_data->bank_nr; i++) {
-		chip_data = &stm32_host_data->chips_data[i];
-		raw_spin_lock(&chip_data->rlock);
-		stm32_chip_resume(chip_data, chip_data->mask_cache);
-		raw_spin_unlock(&chip_data->rlock);
+	list_for_each_entry(host_data, &stm32_host_data_list, lh) {
+		for (i = 0; i < host_data->drv_data->bank_nr; i++) {
+			chip_data = &host_data->chips_data[i];
+			raw_spin_lock(&chip_data->rlock);
+			stm32_chip_resume(chip_data, chip_data->mask_cache);
+			raw_spin_unlock(&chip_data->rlock);
+		}
 	}
 }
 
 static struct syscore_ops stm32_exti_h_syscore_ops = {
-#ifdef CONFIG_PM_SLEEP
 	.suspend	= stm32_exti_h_suspend,
 	.resume		= stm32_exti_h_resume,
-#endif
 };
 
 static void stm32_exti_h_syscore_init(struct stm32_exti_host_data *host_data)
 {
-	stm32_host_data = host_data;
-	register_syscore_ops(&stm32_exti_h_syscore_ops);
+	if (IS_ENABLED(CONFIG_PM_SLEEP)) {
+		if (list_empty(&stm32_host_data_list))
+			register_syscore_ops(&stm32_exti_h_syscore_ops);
+
+		list_add_tail(&host_data->lh, &stm32_host_data_list);
+	}
 }
 
-static void stm32_exti_h_syscore_deinit(void)
+static void stm32_exti_h_syscore_deinit(struct platform_device *pdev)
 {
-	unregister_syscore_ops(&stm32_exti_h_syscore_ops);
+	struct stm32_exti_host_data *host_data = platform_get_drvdata(pdev);
+
+	if (IS_ENABLED(CONFIG_PM_SLEEP)) {
+		list_del(&host_data->lh);
+
+		if (list_empty(&stm32_host_data_list))
+			unregister_syscore_ops(&stm32_exti_h_syscore_ops);
+	}
 }
 
 static int stm32_exti_h_retrigger(struct irq_data *d)
@@ -629,8 +706,11 @@ static int stm32_exti_h_retrigger(struct irq_data *d)
 static struct irq_chip stm32_exti_h_chip = {
 	.name			= "stm32-exti-h",
 	.irq_eoi		= stm32_exti_h_eoi,
+	.irq_ack		= stm32_exti_h_ack,
 	.irq_mask		= stm32_exti_h_mask,
 	.irq_unmask		= stm32_exti_h_unmask,
+	.irq_request_resources	= stm32_exti_h_request_resources,
+	.irq_release_resources	= irq_chip_release_resources_parent,
 	.irq_retrigger		= stm32_exti_h_retrigger,
 	.irq_set_type		= stm32_exti_h_set_type,
 	.irq_set_wake		= stm32_exti_h_set_wake,
@@ -642,8 +722,10 @@ static struct irq_chip stm32_exti_h_chip_direct = {
 	.name			= "stm32-exti-h-direct",
 	.irq_eoi		= irq_chip_eoi_parent,
 	.irq_ack		= irq_chip_ack_parent,
-	.irq_mask		= irq_chip_mask_parent,
-	.irq_unmask		= irq_chip_unmask_parent,
+	.irq_mask		= stm32_exti_h_mask,
+	.irq_unmask		= stm32_exti_h_unmask,
+	.irq_request_resources	= stm32_exti_h_request_resources,
+	.irq_release_resources	= irq_chip_release_resources_parent,
 	.irq_retrigger		= irq_chip_retrigger_hierarchy,
 	.irq_set_type		= irq_chip_set_type_parent,
 	.irq_set_wake		= stm32_exti_h_set_wake,
@@ -651,34 +733,109 @@ static struct irq_chip stm32_exti_h_chip_direct = {
 	.irq_set_affinity	= IS_ENABLED(CONFIG_SMP) ? irq_chip_set_affinity_parent : NULL,
 };
 
+static int stm32_exti_h_domain_match(struct irq_domain *dm,
+				     struct device_node *node,
+				     enum irq_domain_bus_token bus_token)
+{
+	struct stm32_exti_host_data *host_data = dm->host_data;
+
+	if (!node ||
+	    (bus_token != DOMAIN_BUS_ANY && dm->bus_token != bus_token))
+		return 0;
+
+	if (!host_data->irq_map_node)
+		return (to_of_node(dm->fwnode) == node);
+
+	if (node != host_data->irq_map_node->parent)
+		return 0;
+
+	return (to_of_node(dm->parent->fwnode) == of_irq_find_parent(host_data->irq_map_node->parent));
+}
+
+static int stm32_exti_h_domain_select(struct irq_domain *dm,
+				      struct irq_fwspec *fwspec,
+				      enum irq_domain_bus_token bus_token)
+{
+	struct fwnode_handle *fwnode = fwspec->fwnode;
+	struct stm32_exti_host_data *host_data = dm->host_data;
+	struct of_phandle_args out_irq;
+	int ret;
+
+	if (!fwnode ||
+	    (bus_token != DOMAIN_BUS_ANY && dm->bus_token != bus_token))
+		return 0;
+
+	if (!host_data->irq_map_node)
+		return (dm->fwnode == fwnode);
+
+	if (fwnode != of_node_to_fwnode(host_data->irq_map_node->parent))
+		return 0;
+
+	out_irq.np = host_data->irq_map_node;
+	out_irq.args_count = 2;
+	out_irq.args[0] = fwspec->param[0];
+	out_irq.args[1] = fwspec->param[1];
+
+	ret = of_irq_parse_raw(NULL, &out_irq);
+	if (ret)
+		return ret;
+
+	return (dm->parent->fwnode == of_node_to_fwnode(out_irq.np));
+}
+
 static int stm32_exti_h_domain_alloc(struct irq_domain *dm,
 				     unsigned int virq,
 				     unsigned int nr_irqs, void *data)
 {
 	struct stm32_exti_host_data *host_data = dm->host_data;
 	struct stm32_exti_chip_data *chip_data;
-	const struct stm32_desc_irq *desc;
+	u8 desc_irq;
 	struct irq_fwspec *fwspec = data;
 	struct irq_fwspec p_fwspec;
+	struct of_phandle_args out_irq;
 	irq_hw_number_t hwirq;
-	int bank;
+	int bank, ret;
+	u32 event_trg;
+	struct irq_chip *chip;
 
 	hwirq = fwspec->param[0];
+	if (hwirq >= host_data->drv_data->bank_nr * IRQS_PER_BANK)
+		return -EINVAL;
+
 	bank  = hwirq / IRQS_PER_BANK;
 	chip_data = &host_data->chips_data[bank];
 
+	event_trg = readl_relaxed(host_data->base + chip_data->reg_bank->trg_ofst);
+	chip = (event_trg & BIT(hwirq % IRQS_PER_BANK)) ?
+	       &stm32_exti_h_chip : &stm32_exti_h_chip_direct;
+
+	irq_domain_set_hwirq_and_chip(dm, virq, hwirq, chip, chip_data);
+
+	if (host_data->irq_map_node) {
+		out_irq.np = host_data->irq_map_node;
+		out_irq.args_count = 2;
+		out_irq.args[0] = fwspec->param[0];
+		out_irq.args[1] = fwspec->param[1];
+
+		ret = of_irq_parse_raw(NULL, &out_irq);
+		if (ret)
+			return ret;
+
+		of_phandle_args_to_fwspec(out_irq.np, out_irq.args,
+					  out_irq.args_count, &p_fwspec);
+
+		return irq_domain_alloc_irqs_parent(dm, virq, 1, &p_fwspec);
+	}
 
-	desc = stm32_exti_get_desc(host_data->drv_data, hwirq);
-	if (!desc)
+	if (!host_data->drv_data || !host_data->drv_data->desc_irqs)
 		return -EINVAL;
 
-	irq_domain_set_hwirq_and_chip(dm, virq, hwirq, desc->chip,
-				      chip_data);
-	if (desc->irq_parent) {
+	desc_irq = host_data->drv_data->desc_irqs[hwirq];
+	if (desc_irq != EXTI_INVALID_IRQ) {
 		p_fwspec.fwnode = dm->parent->fwnode;
 		p_fwspec.param_count = 3;
 		p_fwspec.param[0] = GIC_SPI;
-		p_fwspec.param[1] = desc->irq_parent;
+		p_fwspec.param[1] = desc_irq;
 		p_fwspec.param[2] = IRQ_TYPE_LEVEL_HIGH;
 
 		return irq_domain_alloc_irqs_parent(dm, virq, 1, &p_fwspec);
@@ -710,8 +867,6 @@ stm32_exti_host_data *stm32_exti_host_init(const struct stm32_exti_drv_data *dd,
 		goto free_chips_data;
 	}
 
-	stm32_host_data = host_data;
-
 	return host_data;
 
 free_chips_data:
@@ -743,7 +898,8 @@ stm32_exti_chip_data *stm32_exti_chip_init(struct stm32_exti_host_data *h_data,
 	 * clear registers to avoid residue
 	 */
 	writel_relaxed(0, base + stm32_bank->imr_ofst);
-	writel_relaxed(0, base + stm32_bank->emr_ofst);
+	if (stm32_bank->emr_ofst)
+		writel_relaxed(0, base + stm32_bank->emr_ofst);
 
 	pr_info("%pOF: bank%d\n", node, bank_idx);
 
@@ -824,6 +980,8 @@ static int __init stm32_exti_init(const struct stm32_exti_drv_data *drv_data,
 }
 
 static const struct irq_domain_ops stm32_exti_h_domain_ops = {
+	.match	= stm32_exti_h_domain_match,
+	.select = stm32_exti_h_domain_select,
 	.alloc	= stm32_exti_h_domain_alloc,
 	.free	= irq_domain_free_irqs_common,
 	.xlate = irq_domain_xlate_twocell,
@@ -832,13 +990,17 @@ static const struct irq_domain_ops stm32_exti_h_domain_ops = {
 static void stm32_exti_remove_irq(void *data)
 {
 	struct irq_domain *domain = data;
+	struct fwnode_handle *fwnode = domain->fwnode;
 
 	irq_domain_remove(domain);
+
+	if (is_fwnode_irqchip(fwnode))
+		irq_domain_free_fwnode(fwnode);
 }
 
 static int stm32_exti_remove(struct platform_device *pdev)
 {
-	stm32_exti_h_syscore_deinit();
+	stm32_exti_h_syscore_deinit(pdev);
 	return 0;
 }
 
@@ -846,16 +1008,20 @@ static int stm32_exti_probe(struct platform_device *pdev)
 {
 	int ret, i;
 	struct device *dev = &pdev->dev;
-	struct device_node *np = dev->of_node;
-	struct irq_domain *parent_domain, *domain;
+	struct device_node *child, *np = dev->of_node, *wakeup_np;
+	struct irq_domain *parent_domain, *domain, *wakeup_domain;
+	struct fwnode_handle *fwnode;
 	struct stm32_exti_host_data *host_data;
 	const struct stm32_exti_drv_data *drv_data;
 	struct resource *res;
+	char *name;
 
 	host_data = devm_kzalloc(dev, sizeof(*host_data), GFP_KERNEL);
 	if (!host_data)
 		return -ENOMEM;
 
+	platform_set_drvdata(pdev, host_data);
+
 	/* check for optional hwspinlock which may be not available yet */
 	ret = of_hwspin_lock_get_id(np, 0);
 	if (ret == -EPROBE_DEFER)
@@ -916,6 +1082,48 @@ static int stm32_exti_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
+	child = of_get_child_by_name(np, "exti-interrupt-map");
+	if (child && of_property_read_bool(child, "interrupt-map"))
+		host_data->irq_map_node = child;
+
+	wakeup_np = of_parse_phandle(np, "wakeup-parent", 0);
+	if (wakeup_np && !host_data->irq_map_node) {
+		dev_warn(dev, "wakeup-parent ignored due to missing interrupt-map nexus node");
+		of_node_put(wakeup_np);
+		wakeup_np = NULL;
+	}
+	if (wakeup_np) {
+		wakeup_domain = irq_find_host(wakeup_np);
+		of_node_put(wakeup_np);
+		if (!wakeup_domain)
+			return -EPROBE_DEFER;
+
+		/* as in __irq_domain_add() */
+		name = kasprintf(GFP_KERNEL, "%pOF-wakeup", np);
+		if (!name)
+			return -ENOMEM;
+		strreplace(name, '/', ':');
+
+		fwnode = irq_domain_alloc_named_fwnode(name);
+		kfree(name);
+		if (!fwnode)
+			return -ENOMEM;
+
+		domain = irq_domain_create_hierarchy(wakeup_domain, 0,
+						     drv_data->bank_nr * IRQS_PER_BANK,
+						     fwnode, &stm32_exti_h_domain_ops,
+						     host_data);
+		if (!domain) {
+			dev_err(dev, "Could not register exti domain\n");
+			irq_domain_free_fwnode(fwnode);
+			return -ENOMEM;
+		}
+
+		ret = devm_add_action_or_reset(dev, stm32_exti_remove_irq, domain);
+		if (ret)
+			return ret;
+	}
+
 	stm32_exti_h_syscore_init(host_data);
 
 	return 0;
@@ -924,6 +1132,7 @@ static int stm32_exti_probe(struct platform_device *pdev)
 /* platform driver only for MP1 */
 static const struct of_device_id stm32_exti_ids[] = {
 	{ .compatible = "st,stm32mp1-exti", .data = &stm32mp1_drv_data},
+	{ .compatible = "st,stm32mp13-exti", .data = &stm32mp13_drv_data},
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32_exti_ids);
diff --git a/drivers/mailbox/Kconfig b/drivers/mailbox/Kconfig
index c9fc06c7e..efb242d85 100644
--- a/drivers/mailbox/Kconfig
+++ b/drivers/mailbox/Kconfig
@@ -220,7 +220,7 @@ config BCM_FLEXRM_MBOX
 
 config STM32_IPCC
 	tristate "STM32 IPCC Mailbox"
-	depends on MACH_STM32MP157 || COMPILE_TEST
+	depends on ARCH_STM32 || COMPILE_TEST
 	help
 	  Mailbox implementation for STMicroelectonics STM32 family chips
 	  with hardware for Inter-Processor Communication Controller (IPCC)
diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index 6157e73ee..9343c680b 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -730,6 +730,18 @@ config VIDEO_APTINA_PLL
 config VIDEO_CCS_PLL
 	tristate
 
+config VIDEO_GC2145
+	tristate "GalaxyCore GC2145 sensor support"
+	depends on I2C && VIDEO_V4L2
+	select VIDEO_V4L2_SUBDEV_API
+	select V4L2_FWNODE
+	help
+	  This is a V4L2 sensor-level driver for GalaxyCore GC2145
+	  2 Mpixel camera.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gc2145.
+
 config VIDEO_HI556
 	tristate "Hynix Hi-556 sensor support"
 	depends on I2C && VIDEO_V4L2
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index 83268f20a..3916c2818 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -133,4 +133,5 @@ obj-$(CONFIG_VIDEO_MAX9271_LIB)	+= max9271.o
 obj-$(CONFIG_VIDEO_RDACM20)	+= rdacm20.o
 obj-$(CONFIG_VIDEO_RDACM21)	+= rdacm21.o
 obj-$(CONFIG_VIDEO_ST_MIPID02) += st-mipid02.o
+obj-$(CONFIG_VIDEO_GC2145)	+= gc2145.o
 obj-$(CONFIG_SDR_MAX2175) += max2175.o
diff --git a/drivers/media/i2c/gc2145.c b/drivers/media/i2c/gc2145.c
new file mode 100644
index 000000000..f892f18dc
--- /dev/null
+++ b/drivers/media/i2c/gc2145.c
@@ -0,0 +1,1949 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * A V4L2 driver for Galaxycore GC2145 camera.
+ * Copyright (C) 2022, STMicroelectronics SA
+ *
+ * Inspired from the imx219.c driver
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include <linux/units.h>
+#include <media/mipi-csi2.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-mediabus.h>
+
+/* Chip ID */
+/* Page 0 */
+#define GC2145_REG_ANALOG_MODE1	0x17
+#define GC2145_REG_OUTPUT_FMT	0x84
+#define GC2145_REG_DEBUG_MODE2	0x8c
+#define GC2145_REG_DEBUG_MODE3	0x8d
+#define GC2145_REG_CHIP_ID	0xf0
+#define GC2145_REG_PAGE_SELECT	0xfe
+/* Page 3 */
+#define GC2145_REG_FIFO_FULL_LVL_LOW	0x04
+#define GC2145_REG_FIFO_FULL_LVL_HIGH	0x05
+#define GC2145_REG_MIPI_DT	0x11
+#define GC2145_REG_LWC_LOW	0x12
+#define GC2145_REG_LWC_HIGH	0x13
+#define GC2145_REG_FIFO_GATE_MODE	0x17
+
+#define GC2145_CHIP_ID		0x2145
+
+/* External clock frequency is 24.0MHz */
+#define GC2145_XCLK_FREQ	(24 * HZ_PER_MHZ)
+
+struct gc2145_reg {
+	unsigned char address;
+	unsigned char val;
+};
+
+struct gc2145_reg_list {
+	unsigned int num_of_regs;
+	const struct gc2145_reg *regs;
+};
+
+/**
+ * struct gc2145_mode - GC2145 mode description
+ * @width: frame width (in pixel)
+ * @height: frame height (in pixel)
+ * @frame_interval: interval (fractionnal) between 2 frames
+ * @reg_list: registers config sequence to enter into the mode
+ * @pixel_rate: pixel_rate associated with the mode
+ */
+struct gc2145_mode {
+	unsigned int width;
+	unsigned int height;
+	struct v4l2_fract frame_interval;
+	struct gc2145_reg_list reg_list;
+	unsigned long pixel_rate;
+};
+
+#define GC2145_640_480_PIXELRATE	(60 * HZ_PER_MHZ)
+static const struct gc2145_reg mode_640_480_regs[] = {
+	{0xfe, 0xf0}, {0xfe, 0xf0}, {0xfe, 0xf0}, {0xfc, 0x06},
+	{0xf6, 0x00}, {0xf7, 0x1d}, {0xf8, 0x86}, {0xfa, 0x00},
+	{0xf9, 0x8e}, {0xf2, 0x00},
+	/* ISP registers */
+	{0xfe, 0x00},
+	/* Exposure */
+	{0x03, 0x04}, {0x04, 0xe2},
+	/* Offset Y */
+	{0x09, 0x00}, {0x0a, 0x00},
+	/* Offset X */
+	{0x0b, 0x00}, {0x0c, 0x00},
+	/* Windows Height */
+	{0x0d, 0x04}, {0x0e, 0xc0},
+	/* Windows Width */
+	{0x0f, 0x06}, {0x10, 0x52},
+	/* SH Delay */
+	{0x12, 0x2e},
+	/* Flip */
+	{0x17, 0x14},
+	/* Analog Mode 2 (row skip ??) */
+	{0x18, 0x22}, {0x19, 0x0e}, {0x1a, 0x01}, {0x1b, 0x4b},
+	{0x1c, 0x07}, {0x1d, 0x10}, {0x1e, 0x88}, {0x1f, 0x78},
+	{0x20, 0x03}, {0x21, 0x40}, {0x22, 0xa0}, {0x24, 0x16},
+	{0x25, 0x01}, {0x26, 0x10}, {0x2d, 0x60}, {0x30, 0x01},
+	{0x31, 0x90}, {0x33, 0x06}, {0x34, 0x01},
+	{0xfe, 0x00},
+	{0x80, 0x7f}, {0x81, 0x26}, {0x82, 0xfa}, {0x83, 0x00},
+	{0x84, 0x02}, {0x86, 0x02}, {0x88, 0x03}, {0x89, 0x03},
+	{0x85, 0x08}, {0x8a, 0x00}, {0x8b, 0x00}, {0xb0, 0x55},
+	{0xc3, 0x00}, {0xc4, 0x80}, {0xc5, 0x90}, {0xc6, 0x3b},
+	{0xc7, 0x46}, {0xec, 0x06}, {0xed, 0x04}, {0xee, 0x60},
+	{0xef, 0x90}, {0xb6, 0x01},
+	/* Crop */
+	{0x90, 0x01},
+	{0x91, 0x00}, {0x92, 0x00},
+	{0x93, 0x00}, {0x94, 0x00},
+	{0x95, 0x04}, {0x96, 0xb0},
+	{0x97, 0x06}, {0x98, 0x40},
+	/* BLK */
+	{0xfe, 0x00},
+	{0x40, 0x42}, {0x41, 0x00}, {0x43, 0x5b}, {0x5e, 0x00},
+	{0x5f, 0x00}, {0x60, 0x00}, {0x61, 0x00}, {0x62, 0x00},
+	{0x63, 0x00}, {0x64, 0x00}, {0x65, 0x00}, {0x66, 0x20},
+	{0x67, 0x20}, {0x68, 0x20}, {0x69, 0x20}, {0x76, 0x00},
+	{0x6a, 0x08}, {0x6b, 0x08}, {0x6c, 0x08}, {0x6d, 0x08},
+	{0x6e, 0x08}, {0x6f, 0x08}, {0x70, 0x08}, {0x71, 0x08},
+	{0x76, 0x00}, {0x72, 0xf0}, {0x7e, 0x3c}, {0x7f, 0x00},
+	{0xfe, 0x02},
+	{0x48, 0x15}, {0x49, 0x00}, {0x4b, 0x0b},
+	{0xfe, 0x00},
+	/* AEC */
+	{0xfe, 0x01},
+	{0x01, 0x04}, {0x02, 0xc0}, {0x03, 0x04}, {0x04, 0x90},
+	{0x05, 0x30}, {0x06, 0x90}, {0x07, 0x30}, {0x08, 0x80},
+	{0x09, 0x00}, {0x0a, 0x82}, {0x0b, 0x11}, {0x0c, 0x10},
+	{0x11, 0x10}, {0x13, 0x7b}, {0x17, 0x00}, {0x1c, 0x11},
+	{0x1e, 0x61}, {0x1f, 0x35}, {0x20, 0x40}, {0x22, 0x40},
+	{0x23, 0x20},
+	{0xfe, 0x02},
+	{0x0f, 0x04},
+	{0xfe, 0x01},
+	{0x12, 0x35}, {0x15, 0xb0}, {0x10, 0x31}, {0x3e, 0x28},
+	{0x3f, 0xb0}, {0x40, 0x90}, {0x41, 0x0f},
+	/* INTPEE */
+	{0xfe, 0x02},
+	{0x90, 0x6c}, {0x91, 0x03}, {0x92, 0xcb}, {0x94, 0x33},
+	{0x95, 0x84}, {0x97, 0x65}, {0xa2, 0x11},
+	{0xfe, 0x00},
+	/* DNDD */
+	{0xfe, 0x02},
+	{0x80, 0xc1}, {0x81, 0x08}, {0x82, 0x05}, {0x83, 0x08},
+	{0x84, 0x0a}, {0x86, 0xf0}, {0x87, 0x50}, {0x88, 0x15},
+	{0x89, 0xb0}, {0x8a, 0x30}, {0x8b, 0x10},
+	/* ASDE */
+	{0xfe, 0x01},
+	{0x21, 0x04},
+	{0xfe, 0x02},
+	{0xa3, 0x50}, {0xa4, 0x20}, {0xa5, 0x40}, {0xa6, 0x80},
+	{0xab, 0x40}, {0xae, 0x0c}, {0xb3, 0x46}, {0xb4, 0x64},
+	{0xb6, 0x38}, {0xb7, 0x01}, {0xb9, 0x2b}, {0x3c, 0x04},
+	{0x3d, 0x15}, {0x4b, 0x06}, {0x4c, 0x20},
+	{0xfe, 0x00},
+	/* Gamma */
+	{0xfe, 0x02},
+	{0x10, 0x09}, {0x11, 0x0d}, {0x12, 0x13}, {0x13, 0x19},
+	{0x14, 0x27}, {0x15, 0x37}, {0x16, 0x45}, {0x17, 0x53},
+	{0x18, 0x69}, {0x19, 0x7d}, {0x1a, 0x8f}, {0x1b, 0x9d},
+	{0x1c, 0xa9}, {0x1d, 0xbd}, {0x1e, 0xcd}, {0x1f, 0xd9},
+	{0x20, 0xe3}, {0x21, 0xea}, {0x22, 0xef}, {0x23, 0xf5},
+	{0x24, 0xf9}, {0x25, 0xff},
+	{0xfe, 0x00},
+	{0xc6, 0x20}, {0xc7, 0x2b},
+	/* Gamma 2 */
+	{0xfe, 0x02},
+	{0x26, 0x0f}, {0x27, 0x14}, {0x28, 0x19}, {0x29, 0x1e},
+	{0x2a, 0x27}, {0x2b, 0x33}, {0x2c, 0x3b}, {0x2d, 0x45},
+	{0x2e, 0x59}, {0x2f, 0x69}, {0x30, 0x7c}, {0x31, 0x89},
+	{0x32, 0x98}, {0x33, 0xae}, {0x34, 0xc0}, {0x35, 0xcf},
+	{0x36, 0xda}, {0x37, 0xe2}, {0x38, 0xe9}, {0x39, 0xf3},
+	{0x3a, 0xf9}, {0x3b, 0xff},
+	/* YCP */
+	{0xfe, 0x02},
+	{0xd1, 0x32}, {0xd2, 0x32}, {0xd3, 0x40}, {0xd6, 0xf0},
+	{0xd7, 0x10}, {0xd8, 0xda}, {0xdd, 0x14}, {0xde, 0x86},
+	{0xed, 0x80}, {0xee, 0x00}, {0xef, 0x3f}, {0xd8, 0xd8},
+	/* ABS */
+	{0xfe, 0x01},
+	{0x9f, 0x40},
+	/* LSC */
+	{0xfe, 0x01},
+	{0xc2, 0x14}, {0xc3, 0x0d}, {0xc4, 0x0c}, {0xc8, 0x15},
+	{0xc9, 0x0d}, {0xca, 0x0a}, {0xbc, 0x24}, {0xbd, 0x10},
+	{0xbe, 0x0b}, {0xb6, 0x25}, {0xb7, 0x16}, {0xb8, 0x15},
+	{0xc5, 0x00}, {0xc6, 0x00}, {0xc7, 0x00}, {0xcb, 0x00},
+	{0xcc, 0x00}, {0xcd, 0x00}, {0xbf, 0x07}, {0xc0, 0x00},
+	{0xc1, 0x00}, {0xb9, 0x00}, {0xba, 0x00}, {0xbb, 0x00},
+	{0xaa, 0x01}, {0xab, 0x01}, {0xac, 0x00}, {0xad, 0x05},
+	{0xae, 0x06}, {0xaf, 0x0e}, {0xb0, 0x0b}, {0xb1, 0x07},
+	{0xb2, 0x06}, {0xb3, 0x17}, {0xb4, 0x0e}, {0xb5, 0x0e},
+	{0xd0, 0x09}, {0xd1, 0x00}, {0xd2, 0x00}, {0xd6, 0x08},
+	{0xd7, 0x00}, {0xd8, 0x00}, {0xd9, 0x00}, {0xda, 0x00},
+	{0xdb, 0x00}, {0xd3, 0x0a}, {0xd4, 0x00}, {0xd5, 0x00},
+	{0xa4, 0x00}, {0xa5, 0x00}, {0xa6, 0x77}, {0xa7, 0x77},
+	{0xa8, 0x77}, {0xa9, 0x77}, {0xa1, 0x80}, {0xa2, 0x80},
+	{0xfe, 0x01},
+	{0xdf, 0x0d}, {0xdc, 0x25}, {0xdd, 0x30}, {0xe0, 0x77},
+	{0xe1, 0x80}, {0xe2, 0x77}, {0xe3, 0x90}, {0xe6, 0x90},
+	{0xe7, 0xa0}, {0xe8, 0x90}, {0xe9, 0xa0},
+	{0xfe, 0x00},
+	/* AWB */
+	{0xfe, 0x01},
+	{0x4f, 0x00}, {0x4f, 0x00}, {0x4b, 0x01}, {0x4f, 0x00},
+	{0x4c, 0x01}, {0x4d, 0x71}, {0x4e, 0x01},
+	{0x4c, 0x01}, {0x4d, 0x91}, {0x4e, 0x01},
+	{0x4c, 0x01}, {0x4d, 0x70}, {0x4e, 0x01},
+	{0x4c, 0x01}, {0x4d, 0x90}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xb0}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0x8f}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0x6f}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xaf}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xd0}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xf0}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xcf}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xef}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0x6e}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8e}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xae}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xce}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x4d}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x6d}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8d}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xad}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xcd}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x4c}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x6c}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8c}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xac}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xcc}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xcb}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x4b}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x6b}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8b}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xab}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8a}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xaa}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xca}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xca}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xc9}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0x8a}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0x89}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xa9}, {0x4e, 0x04},
+	{0x4c, 0x02}, {0x4d, 0x0b}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x0a}, {0x4e, 0x05},
+	{0x4c, 0x01}, {0x4d, 0xeb}, {0x4e, 0x05},
+	{0x4c, 0x01}, {0x4d, 0xea}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x09}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x29}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x2a}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x4a}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x8a}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x49}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x69}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x89}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0xa9}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x48}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x68}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x69}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0xca}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xc9}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xe9}, {0x4e, 0x07},
+	{0x4c, 0x03}, {0x4d, 0x09}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xc8}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xe8}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xa7}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xc7}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xe7}, {0x4e, 0x07},
+	{0x4c, 0x03}, {0x4d, 0x07}, {0x4e, 0x07},
+	{0x4f, 0x01},
+	{0x50, 0x80}, {0x51, 0xa8}, {0x52, 0x47}, {0x53, 0x38},
+	{0x54, 0xc7}, {0x56, 0x0e}, {0x58, 0x08}, {0x5b, 0x00},
+	{0x5c, 0x74}, {0x5d, 0x8b}, {0x61, 0xdb}, {0x62, 0xb8},
+	{0x63, 0x86}, {0x64, 0xc0}, {0x65, 0x04}, {0x67, 0xa8},
+	{0x68, 0xb0}, {0x69, 0x00}, {0x6a, 0xa8}, {0x6b, 0xb0},
+	{0x6c, 0xaf}, {0x6d, 0x8b}, {0x6e, 0x50}, {0x6f, 0x18},
+	{0x73, 0xf0}, {0x70, 0x0d}, {0x71, 0x60}, {0x72, 0x80},
+	{0x74, 0x01}, {0x75, 0x01}, {0x7f, 0x0c}, {0x76, 0x70},
+	{0x77, 0x58}, {0x78, 0xa0}, {0x79, 0x5e}, {0x7a, 0x54},
+	{0x7b, 0x58},
+	{0xfe, 0x00},
+	/* CC */
+	{0xfe, 0x02},
+	{0xc0, 0x01}, {0xc1, 0x44}, {0xc2, 0xfd}, {0xc3, 0x04},
+	{0xc4, 0xf0}, {0xc5, 0x48}, {0xc6, 0xfd}, {0xc7, 0x46},
+	{0xc8, 0xfd}, {0xc9, 0x02}, {0xca, 0xe0}, {0xcb, 0x45},
+	{0xcc, 0xec}, {0xcd, 0x48}, {0xce, 0xf0}, {0xcf, 0xf0},
+	{0xe3, 0x0c}, {0xe4, 0x4b}, {0xe5, 0xe0},
+	/* ABS */
+	{0xfe, 0x01},
+	{0x9f, 0x40},
+	{0xfe, 0x00},
+	/* Dark sun */
+	{0xfe, 0x02},
+	{0x40, 0xbf}, {0x46, 0xcf},
+	{0xfe, 0x00},
+	/* Framerate 50Hz */
+	{0xfe, 0x00},
+	{0x05, 0x01}, {0x06, 0x30}, {0x07, 0x00}, {0x08, 0x0c},
+	{0xfe, 0x01},
+	{0x25, 0x01}, {0x26, 0x75}, {0x27, 0x04}, {0x28, 0x5f},
+	{0x29, 0x04}, {0x2a, 0x5f}, {0x2b, 0x04}, {0x2c, 0x5f},
+	{0x2d, 0x04}, {0x2e, 0x5f},
+	{0xfe, 0x00},
+	/* Output */
+	{0xfe, 0x00},
+	{0xf2, 0x00},
+	/* Mipi */
+	{0xfe, 0x03},
+	{0x02, 0x22}, {0x03, 0x10},
+	{0x06, 0x88}, {0x01, 0x87}, {0x10, 0x95}, {0x11, 0x1e},
+	{0x15, 0x10}, {0x22, 0x04},
+	{0x23, 0x10}, {0x24, 0x10}, {0x25, 0x10}, {0x26, 0x05},
+	{0x21, 0x10}, {0x29, 0x03}, {0x2a, 0x0a}, {0x2b, 0x06},
+	{0xfe, 0x00},
+	{0xfe, 0x00},
+	{0xfd, 0x01}, {0xfa, 0x00},
+	/* Crop window */
+	{0xfe, 0x00},
+	{0x90, 0x01}, {0x91, 0x00}, {0x92, 0x00}, {0x93, 0x00},
+	{0x94, 0x00}, {0x95, 0x01}, {0x96, 0xe0}, {0x97, 0x02},
+	{0x98, 0x80}, {0x99, 0x55}, {0x9a, 0x06}, {0x9b, 0x01},
+	{0x9c, 0x23}, {0x9d, 0x00}, {0x9e, 0x00}, {0x9f, 0x01},
+	{0xa0, 0x23}, {0xa1, 0x00}, {0xa2, 0x00},
+	/* AWB */
+	{0xfe, 0x00},
+	{0xec, 0x06}, {0xed, 0x04}, {0xee, 0x60}, {0xef, 0x90},
+	{0xfe, 0x01},
+	{0x74, 0x01},
+	/* AEC */
+	{0xfe, 0x01},
+	{0x01, 0x04}, {0x02, 0xc0}, {0x03, 0x04}, {0x04, 0x90},
+	{0x05, 0x30}, {0x06, 0x90}, {0x07, 0x30}, {0x08, 0x80},
+	{0x0a, 0x82},
+	{0xfe, 0x01},
+	{0x21, 0x04},
+};
+
+#define GC2145_1280_720_PIXELRATE	(96 * HZ_PER_MHZ)
+static const struct gc2145_reg mode_1280_720_regs[] = {
+	{0xfe, 0xf0}, {0xfe, 0xf0}, {0xfe, 0xf0}, {0xfc, 0x06},
+	{0xf6, 0x00}, {0xf7, 0x1d}, {0xf8, 0x83}, {0xfa, 0x00},
+	{0xf9, 0x8e}, {0xf2, 0x00},
+	/* ISP registers */
+	{0xfe, 0x00},
+	/* Exposure */
+	{0x03, 0x04}, {0x04, 0xe2},
+	/* Offset Y */
+	{0x09, 0x00}, {0x0a, 0xf0},
+	/* Offset X */
+	{0x0b, 0x00}, {0x0c, 0xa0},
+	/* Windows Height */
+	{0x0d, 0x02}, {0x0e, 0xe0},
+	/* Windows Width */
+	{0x0f, 0x05}, {0x10, 0x10},
+	/* SH Delay */
+	{0x12, 0x2e},
+	/* Flip */
+	{0x17, 0x14},
+	/* Analog Mode 2 (row skip ??) */
+	{0x18, 0x22}, {0x19, 0x0e}, {0x1a, 0x01}, {0x1b, 0x4b},
+	{0x1c, 0x07}, {0x1d, 0x10}, {0x1e, 0x88}, {0x1f, 0x78},
+	{0x20, 0x03}, {0x21, 0x40}, {0x22, 0xa0}, {0x24, 0x3f},
+	{0x25, 0x01}, {0x26, 0x10}, {0x2d, 0x60}, {0x30, 0x01},
+	{0x31, 0x90}, {0x33, 0x06}, {0x34, 0x01},
+	{0xfe, 0x00},
+	{0x80, 0x7f}, {0x81, 0x26}, {0x82, 0xfa}, {0x83, 0x00},
+	{0x84, 0x02}, {0x86, 0x06}, {0x88, 0x03}, {0x89, 0x03},
+	{0x85, 0x08}, {0x8a, 0x00}, {0x8b, 0x00}, {0xb0, 0x55},
+	{0xc3, 0x00}, {0xc4, 0x80}, {0xc5, 0x90}, {0xc6, 0x3b},
+	{0xc7, 0x46}, {0xec, 0x06}, {0xed, 0x04}, {0xee, 0x60},
+	{0xef, 0x90}, {0xb6, 0x01},
+	/* Crop */
+	{0x90, 0x01},
+	{0x91, 0x00}, {0x92, 0x00},
+	{0x93, 0x00}, {0x94, 0x00},
+	{0x95, 0x02}, {0x96, 0xd0},
+	{0x97, 0x05}, {0x98, 0x00},
+	/* BLK */
+	{0xfe, 0x00},
+	{0x40, 0x42}, {0x41, 0x00}, {0x43, 0x5b}, {0x5e, 0x00},
+	{0x5f, 0x00}, {0x60, 0x00}, {0x61, 0x00}, {0x62, 0x00},
+	{0x63, 0x00}, {0x64, 0x00}, {0x65, 0x00}, {0x66, 0x20},
+	{0x67, 0x20}, {0x68, 0x20}, {0x69, 0x20}, {0x76, 0x00},
+	{0x6a, 0x08}, {0x6b, 0x08}, {0x6c, 0x08}, {0x6d, 0x08},
+	{0x6e, 0x08}, {0x6f, 0x08}, {0x70, 0x08}, {0x71, 0x08},
+	{0x76, 0x00}, {0x72, 0xf0}, {0x7e, 0x3c}, {0x7f, 0x00},
+	{0xfe, 0x02},
+	{0x48, 0x15}, {0x49, 0x00}, {0x4b, 0x0b},
+	{0xfe, 0x00},
+	/* AEC */
+	{0xfe, 0x01},
+	{0x01, 0x04}, {0x02, 0xc0}, {0x03, 0x04}, {0x04, 0x90},
+	{0x05, 0x30}, {0x06, 0x90}, {0x07, 0x30}, {0x08, 0x80},
+	{0x09, 0x00}, {0x0a, 0x82}, {0x0b, 0x11}, {0x0c, 0x10},
+	{0x11, 0x10}, {0x13, 0x7b}, {0x17, 0x00}, {0x1c, 0x11},
+	{0x1e, 0x61}, {0x1f, 0x35}, {0x20, 0x40}, {0x22, 0x40},
+	{0x23, 0x20},
+	{0xfe, 0x02},
+	{0x0f, 0x04},
+	{0xfe, 0x01},
+	{0x12, 0x35}, {0x15, 0xb0}, {0x10, 0x31}, {0x3e, 0x28},
+	{0x3f, 0xb0}, {0x40, 0x90}, {0x41, 0x0f},
+	/* INTPEE */
+	{0xfe, 0x02},
+	{0x90, 0x6c}, {0x91, 0x03}, {0x92, 0xcb}, {0x94, 0x33},
+	{0x95, 0x84}, {0x97, 0x65}, {0xa2, 0x11},
+	{0xfe, 0x00},
+	/* DNDD */
+	{0xfe, 0x02},
+	{0x80, 0xc1}, {0x81, 0x08}, {0x82, 0x05}, {0x83, 0x08},
+	{0x84, 0x0a}, {0x86, 0xf0}, {0x87, 0x50}, {0x88, 0x15},
+	{0x89, 0xb0}, {0x8a, 0x30}, {0x8b, 0x10},
+	/* ASDE */
+	{0xfe, 0x01},
+	{0x21, 0x04},
+	{0xfe, 0x02},
+	{0xa3, 0x50}, {0xa4, 0x20}, {0xa5, 0x40}, {0xa6, 0x80},
+	{0xab, 0x40}, {0xae, 0x0c}, {0xb3, 0x46}, {0xb4, 0x64},
+	{0xb6, 0x38}, {0xb7, 0x01}, {0xb9, 0x2b}, {0x3c, 0x04},
+	{0x3d, 0x15}, {0x4b, 0x06}, {0x4c, 0x20},
+	{0xfe, 0x00},
+	/* Gamma */
+	{0xfe, 0x02},
+	{0x10, 0x09}, {0x11, 0x0d}, {0x12, 0x13}, {0x13, 0x19},
+	{0x14, 0x27}, {0x15, 0x37}, {0x16, 0x45}, {0x17, 0x53},
+	{0x18, 0x69}, {0x19, 0x7d}, {0x1a, 0x8f}, {0x1b, 0x9d},
+	{0x1c, 0xa9}, {0x1d, 0xbd}, {0x1e, 0xcd}, {0x1f, 0xd9},
+	{0x20, 0xe3}, {0x21, 0xea}, {0x22, 0xef}, {0x23, 0xf5},
+	{0x24, 0xf9}, {0x25, 0xff},
+	{0xfe, 0x00},
+	{0xc6, 0x20}, {0xc7, 0x2b},
+	/* Gamma 2 */
+	{0xfe, 0x02},
+	{0x26, 0x0f}, {0x27, 0x14}, {0x28, 0x19}, {0x29, 0x1e},
+	{0x2a, 0x27}, {0x2b, 0x33}, {0x2c, 0x3b}, {0x2d, 0x45},
+	{0x2e, 0x59}, {0x2f, 0x69}, {0x30, 0x7c}, {0x31, 0x89},
+	{0x32, 0x98}, {0x33, 0xae}, {0x34, 0xc0}, {0x35, 0xcf},
+	{0x36, 0xda}, {0x37, 0xe2}, {0x38, 0xe9}, {0x39, 0xf3},
+	{0x3a, 0xf9}, {0x3b, 0xff},
+	/* YCP */
+	{0xfe, 0x02},
+	{0xd1, 0x32}, {0xd2, 0x32}, {0xd3, 0x40}, {0xd6, 0xf0},
+	{0xd7, 0x10}, {0xd8, 0xda}, {0xdd, 0x14}, {0xde, 0x86},
+	{0xed, 0x80}, {0xee, 0x00}, {0xef, 0x3f}, {0xd8, 0xd8},
+	/* ABS */
+	{0xfe, 0x01},
+	{0x9f, 0x40},
+	/* LSC */
+	{0xfe, 0x01},
+	{0xc2, 0x14}, {0xc3, 0x0d}, {0xc4, 0x0c}, {0xc8, 0x15},
+	{0xc9, 0x0d}, {0xca, 0x0a}, {0xbc, 0x24}, {0xbd, 0x10},
+	{0xbe, 0x0b}, {0xb6, 0x25}, {0xb7, 0x16}, {0xb8, 0x15},
+	{0xc5, 0x00}, {0xc6, 0x00}, {0xc7, 0x00}, {0xcb, 0x00},
+	{0xcc, 0x00}, {0xcd, 0x00}, {0xbf, 0x07}, {0xc0, 0x00},
+	{0xc1, 0x00}, {0xb9, 0x00}, {0xba, 0x00}, {0xbb, 0x00},
+	{0xaa, 0x01}, {0xab, 0x01}, {0xac, 0x00}, {0xad, 0x05},
+	{0xae, 0x06}, {0xaf, 0x0e}, {0xb0, 0x0b}, {0xb1, 0x07},
+	{0xb2, 0x06}, {0xb3, 0x17}, {0xb4, 0x0e}, {0xb5, 0x0e},
+	{0xd0, 0x09}, {0xd1, 0x00}, {0xd2, 0x00}, {0xd6, 0x08},
+	{0xd7, 0x00}, {0xd8, 0x00}, {0xd9, 0x00}, {0xda, 0x00},
+	{0xdb, 0x00}, {0xd3, 0x0a}, {0xd4, 0x00}, {0xd5, 0x00},
+	{0xa4, 0x00}, {0xa5, 0x00}, {0xa6, 0x77}, {0xa7, 0x77},
+	{0xa8, 0x77}, {0xa9, 0x77}, {0xa1, 0x80}, {0xa2, 0x80},
+	{0xfe, 0x01},
+	{0xdf, 0x0d}, {0xdc, 0x25}, {0xdd, 0x30}, {0xe0, 0x77},
+	{0xe1, 0x80}, {0xe2, 0x77}, {0xe3, 0x90}, {0xe6, 0x90},
+	{0xe7, 0xa0}, {0xe8, 0x90}, {0xe9, 0xa0},
+	{0xfe, 0x00},
+	/* AWB */
+	{0xfe, 0x01},
+	{0x4f, 0x00}, {0x4f, 0x00}, {0x4b, 0x01}, {0x4f, 0x00},
+	{0x4c, 0x01}, {0x4d, 0x71}, {0x4e, 0x01},
+	{0x4c, 0x01}, {0x4d, 0x91}, {0x4e, 0x01},
+	{0x4c, 0x01}, {0x4d, 0x70}, {0x4e, 0x01},
+	{0x4c, 0x01}, {0x4d, 0x90}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xb0}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0x8f}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0x6f}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xaf}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xd0}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xf0}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xcf}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xef}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0x6e}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8e}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xae}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xce}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x4d}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x6d}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8d}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xad}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xcd}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x4c}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x6c}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8c}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xac}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xcc}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xcb}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x4b}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x6b}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8b}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xab}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8a}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xaa}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xca}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xca}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xc9}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0x8a}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0x89}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xa9}, {0x4e, 0x04},
+	{0x4c, 0x02}, {0x4d, 0x0b}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x0a}, {0x4e, 0x05},
+	{0x4c, 0x01}, {0x4d, 0xeb}, {0x4e, 0x05},
+	{0x4c, 0x01}, {0x4d, 0xea}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x09}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x29}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x2a}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x4a}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x8a}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x49}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x69}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x89}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0xa9}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x48}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x68}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x69}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0xca}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xc9}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xe9}, {0x4e, 0x07},
+	{0x4c, 0x03}, {0x4d, 0x09}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xc8}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xe8}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xa7}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xc7}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xe7}, {0x4e, 0x07},
+	{0x4c, 0x03}, {0x4d, 0x07}, {0x4e, 0x07},
+	{0x4f, 0x01},
+	{0x50, 0x80}, {0x51, 0xa8}, {0x52, 0x47}, {0x53, 0x38},
+	{0x54, 0xc7}, {0x56, 0x0e}, {0x58, 0x08}, {0x5b, 0x00},
+	{0x5c, 0x74}, {0x5d, 0x8b}, {0x61, 0xdb}, {0x62, 0xb8},
+	{0x63, 0x86}, {0x64, 0xc0}, {0x65, 0x04}, {0x67, 0xa8},
+	{0x68, 0xb0}, {0x69, 0x00}, {0x6a, 0xa8}, {0x6b, 0xb0},
+	{0x6c, 0xaf}, {0x6d, 0x8b}, {0x6e, 0x50}, {0x6f, 0x18},
+	{0x73, 0xf0}, {0x70, 0x0d}, {0x71, 0x60}, {0x72, 0x80},
+	{0x74, 0x01}, {0x75, 0x01}, {0x7f, 0x0c}, {0x76, 0x70},
+	{0x77, 0x58}, {0x78, 0xa0}, {0x79, 0x5e}, {0x7a, 0x54},
+	{0x7b, 0x58},
+	{0xfe, 0x00},
+	/* CC */
+	{0xfe, 0x02},
+	{0xc0, 0x01}, {0xc1, 0x44}, {0xc2, 0xfd}, {0xc3, 0x04},
+	{0xc4, 0xf0}, {0xc5, 0x48}, {0xc6, 0xfd}, {0xc7, 0x46},
+	{0xc8, 0xfd}, {0xc9, 0x02}, {0xca, 0xe0}, {0xcb, 0x45},
+	{0xcc, 0xec}, {0xcd, 0x48}, {0xce, 0xf0}, {0xcf, 0xf0},
+	{0xe3, 0x0c}, {0xe4, 0x4b}, {0xe5, 0xe0},
+	/* ABS */
+	{0xfe, 0x01},
+	{0x9f, 0x40},
+	{0xfe, 0x00},
+	/* Dark sun */
+	{0xfe, 0x02},
+	{0x40, 0xbf}, {0x46, 0xcf},
+	{0xfe, 0x00},
+	/* Framerate 50Hz */
+	{0xfe, 0x00},
+	{0x05, 0x01}, {0x06, 0x56}, {0x07, 0x00}, {0x08, 0x12},
+	{0xfe, 0x01}, {0x25, 0x00}, {0x26, 0xe6}, {0x27, 0x02},
+	{0x28, 0xb2}, {0x29, 0x02}, {0x2a, 0xb2}, {0x2b, 0x02},
+	{0x2c, 0xb2}, {0x2d, 0x02}, {0x2e, 0xb2},
+	{0xfe, 0x00},
+	/* Output */
+	{0xfe, 0x00},
+	{0xf2, 0x00},
+	/* Mipi */
+	{0xfe, 0x03},
+	{0x01, 0x87}, {0x02, 0x22}, {0x03, 0x10},
+	{0x06, 0x88}, {0x10, 0x95}, {0x11, 0x1e},
+	{0x15, 0x12}, {0x22, 0x04},
+	{0x23, 0x10}, {0x24, 0x10}, {0x25, 0x10}, {0x26, 0x05},
+	{0x21, 0x10}, {0x29, 0x03}, {0x2a, 0x0a}, {0x2b, 0x06},
+	{0x42, 0x00}, {0x43, 0x05},
+	{0xfe, 0x00},
+};
+
+#define GC2145_1600_1200_PIXELRATE	(72 * HZ_PER_MHZ)
+static const struct gc2145_reg mode_1600_1200_regs[] = {
+	{0xfe, 0xf0}, {0xfe, 0xf0}, {0xfe, 0xf0}, {0xfc, 0x06},
+	{0xf6, 0x00}, {0xf7, 0x1d}, {0xf8, 0x84}, {0xfa, 0x00},
+	{0xf9, 0x8e}, {0xf2, 0x00},
+	/* ISP registers */
+	{0xfe, 0x00},
+	/* Exposure */
+	{0x03, 0x04}, {0x04, 0xe2},
+	/* Offset Y */
+	{0x09, 0x00}, {0x0a, 0x00},
+	/* Offset X */
+	{0x0b, 0x00}, {0x0c, 0x00},
+	/* Windows Height */
+	{0x0d, 0x04}, {0x0e, 0xc0},
+	/* Windows Width */
+	{0x0f, 0x06}, {0x10, 0x52},
+	/* SH Delay */
+	{0x12, 0x2e},
+	/* Flip */
+	{0x17, 0x14},
+	/* Analog Mode 2 (row skip ??) */
+	{0x18, 0x22}, {0x19, 0x0e}, {0x1a, 0x01}, {0x1b, 0x4b},
+	{0x1c, 0x07}, {0x1d, 0x10}, {0x1e, 0x88}, {0x1f, 0x78},
+	{0x20, 0x03}, {0x21, 0x40}, {0x22, 0xa0}, {0x24, 0x16},
+	{0x25, 0x01}, {0x26, 0x10}, {0x2d, 0x60}, {0x30, 0x01},
+	{0x31, 0x90}, {0x33, 0x06}, {0x34, 0x01},
+	{0xfe, 0x00},
+	{0x80, 0x7f}, {0x81, 0x26}, {0x82, 0xfa}, {0x83, 0x00},
+	{0x84, 0x02}, {0x86, 0x02}, {0x88, 0x03}, {0x89, 0x03},
+	{0x85, 0x08}, {0x8a, 0x00}, {0x8b, 0x00}, {0xb0, 0x55},
+	{0xc3, 0x00}, {0xc4, 0x80}, {0xc5, 0x90}, {0xc6, 0x3b},
+	{0xc7, 0x46}, {0xec, 0x06}, {0xed, 0x04}, {0xee, 0x60},
+	{0xef, 0x90}, {0xb6, 0x01},
+	/* Crop */
+	{0x90, 0x01},
+	{0x91, 0x00}, {0x92, 0x00},
+	{0x93, 0x00}, {0x94, 0x00},
+	{0x95, 0x04}, {0x96, 0xb0},
+	{0x97, 0x06}, {0x98, 0x40},
+	/* BLK */
+	{0xfe, 0x00},
+	{0x40, 0x42}, {0x41, 0x00}, {0x43, 0x5b}, {0x5e, 0x00},
+	{0x5f, 0x00}, {0x60, 0x00}, {0x61, 0x00}, {0x62, 0x00},
+	{0x63, 0x00}, {0x64, 0x00}, {0x65, 0x00}, {0x66, 0x20},
+	{0x67, 0x20}, {0x68, 0x20}, {0x69, 0x20}, {0x76, 0x00},
+	{0x6a, 0x08}, {0x6b, 0x08}, {0x6c, 0x08}, {0x6d, 0x08},
+	{0x6e, 0x08}, {0x6f, 0x08}, {0x70, 0x08}, {0x71, 0x08},
+	{0x76, 0x00}, {0x72, 0xf0}, {0x7e, 0x3c}, {0x7f, 0x00},
+	{0xfe, 0x02},
+	{0x48, 0x15}, {0x49, 0x00}, {0x4b, 0x0b},
+	{0xfe, 0x00},
+	/* AEC */
+	{0xfe, 0x01},
+	{0x01, 0x04}, {0x02, 0xc0}, {0x03, 0x04}, {0x04, 0x90},
+	{0x05, 0x30}, {0x06, 0x90}, {0x07, 0x30}, {0x08, 0x80},
+	{0x09, 0x00}, {0x0a, 0x82}, {0x0b, 0x11}, {0x0c, 0x10},
+	{0x11, 0x10}, {0x13, 0x7b}, {0x17, 0x00}, {0x1c, 0x11},
+	{0x1e, 0x61}, {0x1f, 0x35}, {0x20, 0x40}, {0x22, 0x40},
+	{0x23, 0x20},
+	{0xfe, 0x02},
+	{0x0f, 0x04},
+	{0xfe, 0x01},
+	{0x12, 0x35}, {0x15, 0xb0}, {0x10, 0x31}, {0x3e, 0x28},
+	{0x3f, 0xb0}, {0x40, 0x90}, {0x41, 0x0f},
+	/* INTPEE */
+	{0xfe, 0x02},
+	{0x90, 0x6c}, {0x91, 0x03}, {0x92, 0xcb}, {0x94, 0x33},
+	{0x95, 0x84}, {0x97, 0x65}, {0xa2, 0x11},
+	{0xfe, 0x00},
+	/* DNDD */
+	{0xfe, 0x02},
+	{0x80, 0xc1}, {0x81, 0x08}, {0x82, 0x05}, {0x83, 0x08},
+	{0x84, 0x0a}, {0x86, 0xf0}, {0x87, 0x50}, {0x88, 0x15},
+	{0x89, 0xb0}, {0x8a, 0x30}, {0x8b, 0x10},
+	/* ASDE */
+	{0xfe, 0x01},
+	{0x21, 0x04},
+	{0xfe, 0x02},
+	{0xa3, 0x50}, {0xa4, 0x20}, {0xa5, 0x40}, {0xa6, 0x80},
+	{0xab, 0x40}, {0xae, 0x0c}, {0xb3, 0x46}, {0xb4, 0x64},
+	{0xb6, 0x38}, {0xb7, 0x01}, {0xb9, 0x2b}, {0x3c, 0x04},
+	{0x3d, 0x15}, {0x4b, 0x06}, {0x4c, 0x20},
+	{0xfe, 0x00},
+	/* Gamma */
+	{0xfe, 0x02},
+	{0x10, 0x09}, {0x11, 0x0d}, {0x12, 0x13}, {0x13, 0x19},
+	{0x14, 0x27}, {0x15, 0x37}, {0x16, 0x45}, {0x17, 0x53},
+	{0x18, 0x69}, {0x19, 0x7d}, {0x1a, 0x8f}, {0x1b, 0x9d},
+	{0x1c, 0xa9}, {0x1d, 0xbd}, {0x1e, 0xcd}, {0x1f, 0xd9},
+	{0x20, 0xe3}, {0x21, 0xea}, {0x22, 0xef}, {0x23, 0xf5},
+	{0x24, 0xf9}, {0x25, 0xff},
+	{0xfe, 0x00},
+	{0xc6, 0x20}, {0xc7, 0x2b},
+	/* Gamma 2 */
+	{0xfe, 0x02},
+	{0x26, 0x0f}, {0x27, 0x14}, {0x28, 0x19}, {0x29, 0x1e},
+	{0x2a, 0x27}, {0x2b, 0x33}, {0x2c, 0x3b}, {0x2d, 0x45},
+	{0x2e, 0x59}, {0x2f, 0x69}, {0x30, 0x7c}, {0x31, 0x89},
+	{0x32, 0x98}, {0x33, 0xae}, {0x34, 0xc0}, {0x35, 0xcf},
+	{0x36, 0xda}, {0x37, 0xe2}, {0x38, 0xe9}, {0x39, 0xf3},
+	{0x3a, 0xf9}, {0x3b, 0xff},
+	/* YCP */
+	{0xfe, 0x02},
+	{0xd1, 0x32}, {0xd2, 0x32}, {0xd3, 0x40}, {0xd6, 0xf0},
+	{0xd7, 0x10}, {0xd8, 0xda}, {0xdd, 0x14}, {0xde, 0x86},
+	{0xed, 0x80}, {0xee, 0x00}, {0xef, 0x3f}, {0xd8, 0xd8},
+	/* ABS */
+	{0xfe, 0x01},
+	{0x9f, 0x40},
+	/* LSC */
+	{0xfe, 0x01},
+	{0xc2, 0x14}, {0xc3, 0x0d}, {0xc4, 0x0c}, {0xc8, 0x15},
+	{0xc9, 0x0d}, {0xca, 0x0a}, {0xbc, 0x24}, {0xbd, 0x10},
+	{0xbe, 0x0b}, {0xb6, 0x25}, {0xb7, 0x16}, {0xb8, 0x15},
+	{0xc5, 0x00}, {0xc6, 0x00}, {0xc7, 0x00}, {0xcb, 0x00},
+	{0xcc, 0x00}, {0xcd, 0x00}, {0xbf, 0x07}, {0xc0, 0x00},
+	{0xc1, 0x00}, {0xb9, 0x00}, {0xba, 0x00}, {0xbb, 0x00},
+	{0xaa, 0x01}, {0xab, 0x01}, {0xac, 0x00}, {0xad, 0x05},
+	{0xae, 0x06}, {0xaf, 0x0e}, {0xb0, 0x0b}, {0xb1, 0x07},
+	{0xb2, 0x06}, {0xb3, 0x17}, {0xb4, 0x0e}, {0xb5, 0x0e},
+	{0xd0, 0x09}, {0xd1, 0x00}, {0xd2, 0x00}, {0xd6, 0x08},
+	{0xd7, 0x00}, {0xd8, 0x00}, {0xd9, 0x00}, {0xda, 0x00},
+	{0xdb, 0x00}, {0xd3, 0x0a}, {0xd4, 0x00}, {0xd5, 0x00},
+	{0xa4, 0x00}, {0xa5, 0x00}, {0xa6, 0x77}, {0xa7, 0x77},
+	{0xa8, 0x77}, {0xa9, 0x77}, {0xa1, 0x80}, {0xa2, 0x80},
+	{0xfe, 0x01},
+	{0xdf, 0x0d}, {0xdc, 0x25}, {0xdd, 0x30}, {0xe0, 0x77},
+	{0xe1, 0x80}, {0xe2, 0x77}, {0xe3, 0x90}, {0xe6, 0x90},
+	{0xe7, 0xa0}, {0xe8, 0x90}, {0xe9, 0xa0},
+	{0xfe, 0x00},
+	/* AWB */
+	{0xfe, 0x01},
+	{0x4f, 0x00}, {0x4f, 0x00}, {0x4b, 0x01}, {0x4f, 0x00},
+	{0x4c, 0x01}, {0x4d, 0x71}, {0x4e, 0x01},
+	{0x4c, 0x01}, {0x4d, 0x91}, {0x4e, 0x01},
+	{0x4c, 0x01}, {0x4d, 0x70}, {0x4e, 0x01},
+	{0x4c, 0x01}, {0x4d, 0x90}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xb0}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0x8f}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0x6f}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xaf}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xd0}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xf0}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xcf}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xef}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0x6e}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8e}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xae}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xce}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x4d}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x6d}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8d}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xad}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xcd}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x4c}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x6c}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8c}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xac}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xcc}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xcb}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x4b}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x6b}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8b}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xab}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8a}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xaa}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xca}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xca}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xc9}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0x8a}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0x89}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xa9}, {0x4e, 0x04},
+	{0x4c, 0x02}, {0x4d, 0x0b}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x0a}, {0x4e, 0x05},
+	{0x4c, 0x01}, {0x4d, 0xeb}, {0x4e, 0x05},
+	{0x4c, 0x01}, {0x4d, 0xea}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x09}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x29}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x2a}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x4a}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x8a}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x49}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x69}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x89}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0xa9}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x48}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x68}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x69}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0xca}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xc9}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xe9}, {0x4e, 0x07},
+	{0x4c, 0x03}, {0x4d, 0x09}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xc8}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xe8}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xa7}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xc7}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xe7}, {0x4e, 0x07},
+	{0x4c, 0x03}, {0x4d, 0x07}, {0x4e, 0x07},
+	{0x4f, 0x01},
+	{0x50, 0x80}, {0x51, 0xa8}, {0x52, 0x47}, {0x53, 0x38},
+	{0x54, 0xc7}, {0x56, 0x0e}, {0x58, 0x08}, {0x5b, 0x00},
+	{0x5c, 0x74}, {0x5d, 0x8b}, {0x61, 0xdb}, {0x62, 0xb8},
+	{0x63, 0x86}, {0x64, 0xc0}, {0x65, 0x04}, {0x67, 0xa8},
+	{0x68, 0xb0}, {0x69, 0x00}, {0x6a, 0xa8}, {0x6b, 0xb0},
+	{0x6c, 0xaf}, {0x6d, 0x8b}, {0x6e, 0x50}, {0x6f, 0x18},
+	{0x73, 0xf0}, {0x70, 0x0d}, {0x71, 0x60}, {0x72, 0x80},
+	{0x74, 0x01}, {0x75, 0x01}, {0x7f, 0x0c}, {0x76, 0x70},
+	{0x77, 0x58}, {0x78, 0xa0}, {0x79, 0x5e}, {0x7a, 0x54},
+	{0x7b, 0x58},
+	{0xfe, 0x00},
+	/* CC */
+	{0xfe, 0x02},
+	{0xc0, 0x01}, {0xc1, 0x44}, {0xc2, 0xfd}, {0xc3, 0x04},
+	{0xc4, 0xf0}, {0xc5, 0x48}, {0xc6, 0xfd}, {0xc7, 0x46},
+	{0xc8, 0xfd}, {0xc9, 0x02}, {0xca, 0xe0}, {0xcb, 0x45},
+	{0xcc, 0xec}, {0xcd, 0x48}, {0xce, 0xf0}, {0xcf, 0xf0},
+	{0xe3, 0x0c}, {0xe4, 0x4b}, {0xe5, 0xe0},
+	/* ABS */
+	{0xfe, 0x01},
+	{0x9f, 0x40},
+	{0xfe, 0x00},
+	/* Dark sun */
+	{0xfe, 0x02},
+	{0x40, 0xbf}, {0x46, 0xcf},
+	{0xfe, 0x00},
+	/* Framerate 50Hz */
+	{0xfe, 0x00},
+	{0x05, 0x01}, {0x06, 0x56}, {0x07, 0x00}, {0x08, 0x32},
+	{0xfe, 0x01},
+	{0x25, 0x00}, {0x26, 0xfa}, {0x27, 0x04}, {0x28, 0xe2},
+	{0x29, 0x04}, {0x2a, 0xe2}, {0x2b, 0x04}, {0x2c, 0xe2},
+	{0x2d, 0x04}, {0x2e, 0xe2},
+	{0xfe, 0x00},
+	/* Output */
+	{0xfe, 0x00},
+	{0xf2, 0x00},
+	/* Mipi */
+	{0xfe, 0x03},
+	{0x01, 0x87}, {0x02, 0x22}, {0x03, 0x10},
+	{0x06, 0x88}, {0x10, 0x95}, {0x11, 0x1e},
+	{0x15, 0x10}, {0x22, 0x04},
+	{0x23, 0x10}, {0x24, 0x10}, {0x25, 0x10}, {0x26, 0x05},
+	{0x21, 0x10}, {0x29, 0x03}, {0x2a, 0x0a}, {0x2b, 0x06},
+	{0xfe, 0x00},
+};
+
+/* Regulators supplies */
+static const char * const gc2145_supply_name[] = {
+	"IOVDD", /* Digital I/O (1.7-3V) suppply */
+	"AVDD",  /* Analog (2.7-3V) supply */
+	"DVDD",  /* Digital Core (1.7-1.9V) supply */
+};
+
+#define GC2145_NUM_SUPPLIES ARRAY_SIZE(gc2145_supply_name)
+
+/* Mode configs */
+#define GC2145_MODE_640X480	0
+#define GC2145_MODE_1280X720	1
+#define GC2145_MODE_1600X1200	2
+static const struct gc2145_mode supported_modes[] = {
+	{
+		/* 640x480 30fps mode */
+		.width = 640,
+		.height = 480,
+		.frame_interval = {
+			.numerator = 1,
+			.denominator = 30,
+		},
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_640_480_regs),
+			.regs = mode_640_480_regs,
+		},
+		.pixel_rate = GC2145_640_480_PIXELRATE,
+	},
+	{
+		/* 1280x720 30fps mode */
+		.width = 1280,
+		.height = 720,
+		.frame_interval = {
+			.numerator = 1,
+			.denominator = 30,
+		},
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_1280_720_regs),
+			.regs = mode_1280_720_regs,
+		},
+		.pixel_rate = GC2145_1280_720_PIXELRATE,
+	},
+	{
+		/* 1600x1200 20fps mode */
+		.width = 1600,
+		.height = 1200,
+		.frame_interval = {
+			.numerator = 1,
+			.denominator = 20,
+		},
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_1600_1200_regs),
+			.regs = mode_1600_1200_regs,
+		},
+		.pixel_rate = GC2145_1600_1200_PIXELRATE,
+	},
+};
+
+/**
+ * struct gc2145_format - GC2145 pixel format description
+ * @code: media bus (MBUS) associated code
+ * @colorspace: V4L2 colospace
+ * @datatype: MIPI CSI2 data type
+ * @output_fmt: GC2145 output format
+ */
+struct gc2145_format {
+	unsigned int code;
+	unsigned int colorspace;
+	unsigned char datatype;
+	unsigned char output_fmt;
+};
+
+/* All supported formats */
+#define GC2145_DEFAULT_MBUS_FORMAT	MEDIA_BUS_FMT_YUYV8_2X8
+static const struct gc2145_format supported_formats[] = {
+	{
+		.code		= MEDIA_BUS_FMT_UYVY8_2X8,
+		.colorspace	= V4L2_COLORSPACE_SRGB,
+		.datatype	= MIPI_CSI2_DT_YUV422_8B,
+		.output_fmt	= 0x00,
+	},
+	{
+		.code		= MEDIA_BUS_FMT_VYUY8_2X8,
+		.colorspace	= V4L2_COLORSPACE_SRGB,
+		.datatype	= MIPI_CSI2_DT_YUV422_8B,
+		.output_fmt	= 0x01,
+	},
+	{
+		.code		= MEDIA_BUS_FMT_YUYV8_2X8,
+		.colorspace	= V4L2_COLORSPACE_SRGB,
+		.datatype	= MIPI_CSI2_DT_YUV422_8B,
+		.output_fmt	= 0x02,
+	},
+	{
+		.code		= MEDIA_BUS_FMT_YVYU8_2X8,
+		.colorspace	= V4L2_COLORSPACE_SRGB,
+		.datatype	= MIPI_CSI2_DT_YUV422_8B,
+		.output_fmt	= 0x03,
+	},
+	{
+		.code		= MEDIA_BUS_FMT_RGB565_2X8_BE,
+		.colorspace	= V4L2_COLORSPACE_SRGB,
+		.datatype	= MIPI_CSI2_DT_RGB565,
+		.output_fmt	= 0x06,
+	},
+	{
+		.code           = MEDIA_BUS_FMT_SRGGB8_1X8,
+		.colorspace     = V4L2_COLORSPACE_RAW,
+		.datatype       = MIPI_CSI2_DT_RAW8,
+		.output_fmt     = 0x19, /* Image is taken out of the Lens correction */
+	},
+};
+
+struct gc2145_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *test_pattern;
+	struct v4l2_ctrl *hflip;
+	struct v4l2_ctrl *vflip;
+};
+
+struct gc2145 {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+
+	struct v4l2_mbus_framefmt fmt;
+
+	struct clk *xclk;
+
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *powerdown_gpio;
+	struct regulator_bulk_data supplies[GC2145_NUM_SUPPLIES];
+
+	/* V4L2 controls */
+	struct gc2145_ctrls ctrls;
+
+	/* Current mode */
+	const struct gc2145_mode *mode;
+
+	/*
+	 * Mutex for serialized access:
+	 * Protect sensor module set pad format and start/stop streaming safely.
+	 */
+	struct mutex mutex;
+
+	/* Streaming on/off */
+	bool streaming;
+};
+
+static inline struct gc2145 *to_gc2145(struct v4l2_subdev *_sd)
+{
+	return container_of(_sd, struct gc2145, sd);
+}
+
+static inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct gc2145,
+			     ctrls.handler)->sd;
+}
+
+static int gc2145_read_reg(struct gc2145 *gc2145, u8 addr, u8 *data, int data_size)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc2145->sd);
+	struct i2c_msg msg[2];
+	int ret;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].buf = &addr;
+	msg[0].len = 1;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].buf = data;
+	msg[1].len = data_size;
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: error %d: start_index=%x, data_size=%d\n",
+			__func__, ret, (u32)addr, data_size);
+		return ret;
+	}
+
+	dev_dbg(&client->dev, "[rd %02x] => %*ph\n", (u32)addr, data_size, data);
+
+	return 0;
+}
+
+static int gc2145_write_reg(struct gc2145 *gc2145, u8 addr, u8 data)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc2145->sd);
+	struct i2c_msg msg;
+	u8 buf[] = { addr, data };
+	int ret;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.buf = buf;
+	msg.len = sizeof(buf);
+
+	dev_dbg(&client->dev, "[wr %02x] <= %02xh\n", (u32)addr, data);
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: error %d: addr=%x, data=%02xh\n",
+			__func__, ret, (u32)addr, data);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int gc2145_mod_reg(struct gc2145 *gc2145, u16 reg, u8 mask, u8 val)
+{
+	u8 readval;
+	int ret;
+
+	ret = gc2145_read_reg(gc2145, reg, &readval, 1);
+	if (ret)
+		return ret;
+
+	readval &= ~mask;
+	val &= mask;
+	val |= readval;
+
+	return gc2145_write_reg(gc2145, reg, val);
+}
+
+/* Write a list of registers */
+static int gc2145_write_regs(struct gc2145 *gc2145, const struct gc2145_reg *regs, u32 len)
+{
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < len; i++) {
+		ret = gc2145_write_reg(gc2145, regs[i].address, regs[i].val);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static const struct gc2145_format *gc2145_get_format_code(struct gc2145 *gc2145, u32 code)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(supported_formats); i++)
+		if (supported_formats[i].code == code)
+			break;
+
+	if (i >= ARRAY_SIZE(supported_formats))
+		i = 0;
+
+	return &supported_formats[i];
+}
+
+static void gc2145_set_default_format(struct gc2145 *gc2145)
+{
+	struct v4l2_mbus_framefmt *fmt = &gc2145->fmt;
+
+	fmt->code = supported_formats[0].code;
+	fmt->colorspace = supported_formats[0].colorspace;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_MAP_QUANTIZATION_DEFAULT(true, fmt->colorspace, fmt->ycbcr_enc);
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+	fmt->width = supported_modes[GC2145_MODE_640X480].width;
+	fmt->height = supported_modes[GC2145_MODE_640X480].height;
+	fmt->field = V4L2_FIELD_NONE;
+}
+
+static int gc2145_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct gc2145 *gc2145 = to_gc2145(sd);
+	struct v4l2_mbus_framefmt *try_fmt = v4l2_subdev_get_try_format(sd, fh->state, 0);
+
+	mutex_lock(&gc2145->mutex);
+
+	/* Initialize try_fmt */
+	try_fmt->width = supported_modes[GC2145_MODE_640X480].width;
+	try_fmt->height = supported_modes[GC2145_MODE_640X480].height;
+	try_fmt->code = GC2145_DEFAULT_MBUS_FORMAT;
+	try_fmt->field = V4L2_FIELD_NONE;
+
+	mutex_unlock(&gc2145->mutex);
+
+	return 0;
+}
+
+static int gc2145_enum_mbus_code(struct v4l2_subdev *sd, struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct gc2145 *gc2145 = to_gc2145(sd);
+
+	if (code->index >= ARRAY_SIZE(supported_formats))
+		return -EINVAL;
+
+	mutex_lock(&gc2145->mutex);
+	code->code = supported_formats[code->index].code;
+	mutex_unlock(&gc2145->mutex);
+
+	return 0;
+}
+
+static int gc2145_enum_frame_size(struct v4l2_subdev *sd, struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct gc2145 *gc2145 = to_gc2145(sd);
+	const struct gc2145_format *gc2145_format;
+	u32 code;
+
+	if (fse->index >= ARRAY_SIZE(supported_modes))
+		return -EINVAL;
+
+	mutex_lock(&gc2145->mutex);
+
+	gc2145_format = gc2145_get_format_code(gc2145, fse->code);
+	code = gc2145_format->code;
+
+	mutex_unlock(&gc2145->mutex);
+	if (fse->code != code)
+		return -EINVAL;
+
+	fse->min_width = supported_modes[fse->index].width;
+	fse->max_width = fse->min_width;
+	fse->min_height = supported_modes[fse->index].height;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static int gc2145_enum_frame_interval(struct v4l2_subdev *sd, struct v4l2_subdev_state *sd_state,
+				      struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct gc2145 *gc2145 = to_gc2145(sd);
+	const struct gc2145_format *gc2145_format;
+	u32 code, i;
+
+	/* The driver currently only support a unique framerate per resolution */
+	if (fie->index > 0)
+		return -EINVAL;
+
+	gc2145_format = gc2145_get_format_code(gc2145, fie->code);
+	code = gc2145_format->code;
+	if (fie->code != code)
+		return -EINVAL;
+
+	for (i = 0; i < ARRAY_SIZE(supported_modes); i++)
+		if (supported_modes[i].width == fie->width &&
+		    supported_modes[i].height == fie->height)
+			break;
+
+	if (i >= ARRAY_SIZE(supported_modes))
+		return -EINVAL;
+
+	fie->interval.numerator = supported_modes[i].frame_interval.numerator;
+	fie->interval.denominator = supported_modes[i].frame_interval.denominator;
+
+	return 0;
+}
+
+static void gc2145_reset_colorspace(struct v4l2_mbus_framefmt *fmt)
+{
+	fmt->colorspace = V4L2_COLORSPACE_SRGB;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_MAP_QUANTIZATION_DEFAULT(true, fmt->colorspace,
+							  fmt->ycbcr_enc);
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+}
+
+static void gc2145_update_pad_format(struct gc2145 *gc2145, const struct gc2145_mode *mode,
+				     struct v4l2_subdev_format *fmt)
+{
+	fmt->format.width = mode->width;
+	fmt->format.height = mode->height;
+	fmt->format.field = V4L2_FIELD_NONE;
+	gc2145_reset_colorspace(&fmt->format);
+}
+
+static int __gc2145_get_pad_format(struct gc2145 *gc2145, struct v4l2_subdev_state *sd_state,
+				   struct v4l2_subdev_format *fmt)
+{
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		struct v4l2_mbus_framefmt *try_fmt =
+			v4l2_subdev_get_try_format(&gc2145->sd, sd_state, fmt->pad);
+		fmt->format = *try_fmt;
+	} else {
+		gc2145_update_pad_format(gc2145, gc2145->mode, fmt);
+		fmt->format.code = gc2145->fmt.code;
+	}
+
+	return 0;
+}
+
+static int gc2145_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_format *fmt)
+{
+	struct gc2145 *gc2145 = to_gc2145(sd);
+	int ret;
+
+	mutex_lock(&gc2145->mutex);
+	ret = __gc2145_get_pad_format(gc2145, sd_state, fmt);
+	mutex_unlock(&gc2145->mutex);
+
+	return ret;
+}
+
+static int gc2145_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_format *fmt)
+{
+	struct gc2145 *gc2145 = to_gc2145(sd);
+	const struct gc2145_mode *mode;
+	const struct gc2145_format *gc2145_fmt;
+	struct v4l2_mbus_framefmt *framefmt;
+	struct gc2145_ctrls *ctrls = &gc2145->ctrls;
+
+	mutex_lock(&gc2145->mutex);
+
+	gc2145_fmt = gc2145_get_format_code(gc2145, fmt->format.code);
+	fmt->format.code = gc2145_fmt->code;
+
+	mode = v4l2_find_nearest_size(supported_modes, ARRAY_SIZE(supported_modes), width, height,
+				      fmt->format.width, fmt->format.height);
+
+	/* In RAW mode, VGA is not possible so use 720p instead */
+	if ((gc2145_fmt->colorspace == V4L2_COLORSPACE_RAW) &&
+	    (mode == &supported_modes[GC2145_MODE_640X480]))
+		mode = &supported_modes[GC2145_MODE_1280X720];
+
+	gc2145_update_pad_format(gc2145, mode, fmt);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		framefmt = v4l2_subdev_get_try_format(sd, sd_state, fmt->pad);
+		*framefmt = fmt->format;
+	} else if (gc2145->mode != mode || gc2145->fmt.code != fmt->format.code) {
+		gc2145->fmt = fmt->format;
+		gc2145->mode = mode;
+		/* Update pixel_rate based on the mode */
+		__v4l2_ctrl_s_ctrl_int64(ctrls->pixel_rate, mode->pixel_rate);
+	}
+
+	mutex_unlock(&gc2145->mutex);
+
+	return 0;
+}
+
+static int gc2145_start_streaming(struct gc2145 *gc2145)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc2145->sd);
+	const struct gc2145_reg_list *reg_list;
+	const struct gc2145_format *gc2145_format;
+	uint16_t lwc, fifo_full_lvl, fifo_gate_mode;
+	int ret;
+
+	ret = pm_runtime_resume_and_get(&client->dev);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * TODO - configuration of the sensor will have to be moved into
+	 * gc2145_set_pad_format once we have a way to configure without
+	 * starting the sensor.  In such case, only streaming start will
+	 * be done here.
+	 */
+
+	/* Apply default values of current mode */
+	reg_list = &gc2145->mode->reg_list;
+	ret = gc2145_write_regs(gc2145, reg_list->regs, reg_list->num_of_regs);
+	if (ret) {
+		dev_err(&client->dev, "%s failed to set mode\n", __func__);
+		goto err_rpm_put;
+	}
+
+	gc2145_format = gc2145_get_format_code(gc2145, gc2145->fmt.code);
+
+	/* Set the output format */
+	ret = gc2145_write_reg(gc2145, GC2145_REG_PAGE_SELECT, 0x00);
+	if (ret)
+		return ret;
+
+	ret = gc2145_write_reg(gc2145, GC2145_REG_OUTPUT_FMT, gc2145_format->output_fmt);
+	if (ret)
+		return ret;
+
+	/* Set 3rd page access */
+	ret = gc2145_write_reg(gc2145, GC2145_REG_PAGE_SELECT, 0x03);
+	if (ret)
+		return ret;
+
+	/*
+	 * Adjust the MIPI buffer settings.
+	 * For YUV/RGB, LWC = image width * 2
+	 * For RAW8, LWC = image width
+	 * For RAW10, LWC = image width * 1.25
+	 */
+	if (gc2145_format->colorspace != V4L2_COLORSPACE_RAW)
+		lwc = gc2145->mode->width * 2;
+	else if (gc2145_format->code == MEDIA_BUS_FMT_SRGGB8_1X8)
+		lwc = gc2145->mode->width * 1;
+	else
+		lwc = gc2145->mode->width + (gc2145->mode->width / 4);
+
+	ret = gc2145_write_reg(gc2145, GC2145_REG_LWC_HIGH, lwc >> 8);
+	if (ret)
+		return ret;
+	ret = gc2145_write_reg(gc2145, GC2145_REG_LWC_LOW, (lwc & 0xff));
+	if (ret)
+		return ret;
+
+	/*
+	 * Adjust the MIPI Fifo Full Level
+	 * TODO - would need to understand better the constraints
+	 * 640x480 RGB: 0x0190
+	 * 1280x720 / 1600x1200 (aka no scaler) non RAW: 0x0010
+	 * 1600x1200 RAW: 0x0190
+	 */
+	if (gc2145_format->colorspace != V4L2_COLORSPACE_RAW) {
+		if ((gc2145->mode->width == 720) || (gc2145->mode->width == 1200))
+			fifo_full_lvl = 0x0010;
+		else
+			fifo_full_lvl = 0x0190;
+	} else
+		fifo_full_lvl = 0x0190;
+
+	ret = gc2145_write_reg(gc2145, GC2145_REG_FIFO_FULL_LVL_HIGH,
+			       fifo_full_lvl >> 8);
+	if (ret)
+		return ret;
+	ret = gc2145_write_reg(gc2145, GC2145_REG_FIFO_FULL_LVL_LOW,
+			       fifo_full_lvl & 0xff);
+	if (ret)
+		return ret;
+
+	/* Set the fifo gate mode / MIPI wdiv set */
+	if (gc2145_format->colorspace == V4L2_COLORSPACE_RAW)
+		fifo_gate_mode = 0xf1;
+	else
+		fifo_gate_mode = 0xf0;
+	ret = gc2145_write_reg(gc2145, GC2145_REG_FIFO_GATE_MODE,
+			       fifo_gate_mode);
+	if (ret)
+		return ret;
+
+	/* Set the MIPI data type */
+	ret = gc2145_write_reg(gc2145, GC2145_REG_MIPI_DT, gc2145_format->datatype);
+	if (ret)
+		return ret;
+
+	/* Come back on page 0 by default */
+	ret = gc2145_write_reg(gc2145, GC2145_REG_PAGE_SELECT, 0x00);
+	if (ret)
+		return ret;
+
+	/* Apply customized values from user */
+	ret =  __v4l2_ctrl_handler_setup(&gc2145->ctrls.handler);
+	if (ret)
+		goto err_rpm_put;
+
+	return 0;
+
+err_rpm_put:
+	pm_runtime_put(&client->dev);
+	return ret;
+}
+
+static void gc2145_stop_streaming(struct gc2145 *gc2145)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc2145->sd);
+
+	/*
+	 * TODO - once we have a way to turn off only streaming of the
+	 * sensor, we will have to do it here.
+	 */
+
+	pm_runtime_put(&client->dev);
+}
+
+static int gc2145_g_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *fi)
+{
+	struct gc2145 *gc2145 = to_gc2145(sd);
+
+	mutex_lock(&gc2145->mutex);
+	fi->interval = gc2145->mode->frame_interval;
+	mutex_unlock(&gc2145->mutex);
+
+	return 0;
+}
+
+static int gc2145_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct gc2145 *gc2145 = to_gc2145(sd);
+	int ret = 0;
+
+	mutex_lock(&gc2145->mutex);
+	if (gc2145->streaming == enable) {
+		mutex_unlock(&gc2145->mutex);
+		return 0;
+	}
+
+	if (enable) {
+		/*
+		 * Apply default & customized values
+		 * and then start streaming.
+		 */
+		ret = gc2145_start_streaming(gc2145);
+		if (ret)
+			goto err_unlock;
+	} else {
+		gc2145_stop_streaming(gc2145);
+	}
+
+	gc2145->streaming = enable;
+
+	mutex_unlock(&gc2145->mutex);
+
+	return ret;
+
+err_unlock:
+	mutex_unlock(&gc2145->mutex);
+
+	return ret;
+}
+
+/* Power/clock management functions */
+static int gc2145_power_on(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct gc2145 *gc2145 = to_gc2145(sd);
+	int ret;
+
+	ret = regulator_bulk_enable(GC2145_NUM_SUPPLIES, gc2145->supplies);
+	if (ret) {
+		dev_err(dev, "failed to enable regulators\n");
+		return ret;
+	}
+
+	ret = clk_prepare_enable(gc2145->xclk);
+	if (ret) {
+		dev_err(dev, "failed to enable clock\n");
+		goto reg_off;
+	}
+
+	/* TODO - Following delays should be tuned */
+	usleep_range(10000, 12000);
+	gpiod_set_value_cansleep(gc2145->powerdown_gpio, 0);
+	usleep_range(10000, 12000);
+	gpiod_set_value_cansleep(gc2145->reset_gpio, 0);
+	usleep_range(40000, 50000);
+
+	return 0;
+
+reg_off:
+	regulator_bulk_disable(GC2145_NUM_SUPPLIES, gc2145->supplies);
+
+	return ret;
+}
+
+static int gc2145_power_off(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct gc2145 *gc2145 = to_gc2145(sd);
+
+	gpiod_set_value_cansleep(gc2145->powerdown_gpio, 1);
+	gpiod_set_value_cansleep(gc2145->reset_gpio, 1);
+	regulator_bulk_disable(GC2145_NUM_SUPPLIES, gc2145->supplies);
+	clk_disable_unprepare(gc2145->xclk);
+
+	return 0;
+}
+
+static int __maybe_unused gc2145_suspend(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct gc2145 *gc2145 = to_gc2145(sd);
+
+	if (gc2145->streaming)
+		gc2145_stop_streaming(gc2145);
+
+	return 0;
+}
+
+static int __maybe_unused gc2145_resume(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct gc2145 *gc2145 = to_gc2145(sd);
+	int ret;
+
+	if (gc2145->streaming) {
+		ret = gc2145_start_streaming(gc2145);
+		if (ret)
+			goto error;
+	}
+
+	return 0;
+
+error:
+	gc2145_stop_streaming(gc2145);
+	gc2145->streaming = false;
+
+	return ret;
+}
+
+static int gc2145_get_regulators(struct gc2145 *gc2145)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc2145->sd);
+	unsigned int i;
+
+	for (i = 0; i < GC2145_NUM_SUPPLIES; i++)
+		gc2145->supplies[i].supply = gc2145_supply_name[i];
+
+	return devm_regulator_bulk_get(&client->dev, GC2145_NUM_SUPPLIES, gc2145->supplies);
+}
+
+/* Verify chip ID */
+static int gc2145_identify_module(struct gc2145 *gc2145)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc2145->sd);
+	int ret;
+	u16 chip_id;
+
+	ret = gc2145_read_reg(gc2145, GC2145_REG_CHIP_ID, (u8 *)&chip_id, 2);
+	if (ret) {
+		dev_err(&client->dev, "failed to read chip id %x\n", GC2145_CHIP_ID);
+		return ret;
+	}
+	chip_id = be16_to_cpu(chip_id);
+
+	if (chip_id != GC2145_CHIP_ID) {
+		dev_err(&client->dev, "chip id mismatch: %x!=%x\n", GC2145_CHIP_ID, chip_id);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static const char * const test_pattern_menu[] = {
+	"Disabled",
+	"Colored patterns",
+	"Uniform white",
+	"Uniform yellow",
+	"Uniform cyan",
+	"Uniform green",
+	"Uniform magenta",
+	"Uniform red",
+	"Uniform black",
+};
+
+#define GC2145_TEST_PATTERN_ENABLE	BIT(0)
+#define GC2145_TEST_PATTERN_UXGA	BIT(3)
+
+#define GC2145_TEST_UNIFORM		BIT(3)
+#define GC2145_TEST_WHITE		(4 << 4)
+#define GC2145_TEST_YELLOW		(8 << 4)
+#define GC2145_TEST_CYAN		(9 << 4)
+#define GC2145_TEST_GREEN		(6 << 4)
+#define GC2145_TEST_MAGENTA		(10 << 4)
+#define GC2145_TEST_RED			(5 << 4)
+#define GC2145_TEST_BLACK		(0)
+
+static const u8 test_pattern_val[] = {
+	0,
+	GC2145_TEST_PATTERN_ENABLE,
+	GC2145_TEST_UNIFORM | GC2145_TEST_WHITE,
+	GC2145_TEST_UNIFORM | GC2145_TEST_YELLOW,
+	GC2145_TEST_UNIFORM | GC2145_TEST_CYAN,
+	GC2145_TEST_UNIFORM | GC2145_TEST_GREEN,
+	GC2145_TEST_UNIFORM | GC2145_TEST_MAGENTA,
+	GC2145_TEST_UNIFORM | GC2145_TEST_RED,
+	GC2145_TEST_UNIFORM | GC2145_TEST_BLACK,
+};
+
+static const struct v4l2_subdev_core_ops gc2145_core_ops = {
+	.subscribe_event = v4l2_ctrl_subdev_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+static const struct v4l2_subdev_video_ops gc2145_video_ops = {
+	.g_frame_interval = gc2145_g_frame_interval,
+	/*
+	 * Currently frame_interval can't be changed hence s_frame_interval
+	 * does same as g_frame_interval
+	 */
+	.s_frame_interval = gc2145_g_frame_interval,
+	.s_stream = gc2145_set_stream,
+};
+
+static const struct v4l2_subdev_pad_ops gc2145_pad_ops = {
+	.enum_mbus_code = gc2145_enum_mbus_code,
+	.get_fmt = gc2145_get_pad_format,
+	.set_fmt = gc2145_set_pad_format,
+	.enum_frame_size = gc2145_enum_frame_size,
+	.enum_frame_interval = gc2145_enum_frame_interval,
+};
+
+static const struct v4l2_subdev_ops gc2145_subdev_ops = {
+	.core = &gc2145_core_ops,
+	.video = &gc2145_video_ops,
+	.pad = &gc2145_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops gc2145_internal_ops = {
+	.open = gc2145_open,
+};
+
+static int gc2145_set_ctrl_test_pattern(struct gc2145 *gc2145, int value)
+{
+	int ret;
+
+	if (!value) {
+		/* Disable test pattern */
+		ret = gc2145_write_reg(gc2145, GC2145_REG_DEBUG_MODE2, 0);
+		if (ret)
+			return ret;
+
+		return gc2145_write_reg(gc2145, GC2145_REG_DEBUG_MODE3, 0);
+	}
+
+	/* Enable test pattern, colored or uniform */
+	ret = gc2145_write_reg(gc2145, GC2145_REG_DEBUG_MODE2,
+			       GC2145_TEST_PATTERN_ENABLE |
+			       GC2145_TEST_PATTERN_UXGA);
+	if (ret)
+		return ret;
+
+	if (!(test_pattern_val[value] & GC2145_TEST_UNIFORM))
+		return gc2145_write_reg(gc2145, GC2145_REG_DEBUG_MODE3, 0);
+
+	/* Uniform */
+	return gc2145_write_reg(gc2145, GC2145_REG_DEBUG_MODE3,
+				test_pattern_val[value]);
+}
+
+static int gc2145_set_ctrl_hflip(struct gc2145 *gc2145, int value)
+{
+	return gc2145_mod_reg(gc2145, GC2145_REG_ANALOG_MODE1,
+			      BIT(0), (value ? BIT(0) : 0));
+}
+
+static int gc2145_set_ctrl_vflip(struct gc2145 *gc2145, int value)
+{
+	return gc2145_mod_reg(gc2145, GC2145_REG_ANALOG_MODE1,
+			      BIT(1), (value ? BIT(1) : 0));
+}
+
+static int gc2145_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct gc2145 *gc2145 = to_gc2145(sd);
+	int ret;
+
+	/* v4l2_ctrl_lock() locks our own mutex */
+
+	ret = pm_runtime_resume_and_get(&client->dev);
+	if (ret < 0)
+		return ret;
+
+	switch (ctrl->id) {
+	case V4L2_CID_TEST_PATTERN:
+		ret = gc2145_set_ctrl_test_pattern(gc2145, ctrl->val);
+		break;
+	case V4L2_CID_HFLIP:
+		ret = gc2145_set_ctrl_hflip(gc2145, ctrl->val);
+		break;
+	case V4L2_CID_VFLIP:
+		ret = gc2145_set_ctrl_vflip(gc2145, ctrl->val);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	pm_runtime_put(&client->dev);
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops gc2145_ctrl_ops = {
+	.s_ctrl = gc2145_s_ctrl,
+};
+
+/* Initialize control handlers */
+static int gc2145_init_controls(struct gc2145 *gc2145)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc2145->sd);
+	const struct v4l2_ctrl_ops *ops = &gc2145_ctrl_ops;
+	struct gc2145_ctrls *ctrls = &gc2145->ctrls;
+	struct v4l2_ctrl_handler *hdl = &ctrls->handler;
+	int ret;
+
+	ret = v4l2_ctrl_handler_init(hdl, 12);
+	if (ret)
+		return ret;
+
+	hdl->lock = &gc2145->mutex;
+
+	/* By default, PIXEL_RATE is read only */
+	ctrls->pixel_rate = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_PIXEL_RATE,
+					      0, INT_MAX, 1,
+					      GC2145_640_480_PIXELRATE);
+	ctrls->pixel_rate->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	ctrls->test_pattern =
+		v4l2_ctrl_new_std_menu_items(hdl, ops, V4L2_CID_TEST_PATTERN,
+					     ARRAY_SIZE(test_pattern_menu) - 1,
+					     0, 0, test_pattern_menu);
+	ctrls->hflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HFLIP,
+					 0, 1, 1, 0);
+	ctrls->vflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VFLIP,
+					 0, 1, 1, 0);
+
+	if (hdl->error) {
+		ret = hdl->error;
+		dev_err(&client->dev, "control init failed (%d)\n", ret);
+		goto error;
+	}
+
+	gc2145->sd.ctrl_handler = hdl;
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(hdl);
+	mutex_destroy(&gc2145->mutex);
+
+	return ret;
+}
+
+static void gc2145_free_controls(struct gc2145 *gc2145)
+{
+	v4l2_ctrl_handler_free(&gc2145->ctrls.handler);
+}
+
+static int gc2145_check_hwcfg(struct device *dev)
+{
+	struct fwnode_handle *endpoint;
+	struct v4l2_fwnode_endpoint ep_cfg = {
+		.bus_type = V4L2_MBUS_CSI2_DPHY
+	};
+	int ret = -EINVAL;
+
+	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);
+	if (!endpoint) {
+		dev_err(dev, "endpoint node not found\n");
+		return -EINVAL;
+	}
+
+	if (v4l2_fwnode_endpoint_alloc_parse(endpoint, &ep_cfg)) {
+		dev_err(dev, "could not parse endpoint\n");
+		goto error_out;
+	}
+
+	/* Check the number of MIPI CSI2 data lanes */
+	if (ep_cfg.bus.mipi_csi2.num_data_lanes != 2) {
+		dev_err(dev, "only 2 data lanes are currently supported\n");
+		goto error_out;
+	}
+
+	ret = 0;
+
+error_out:
+	v4l2_fwnode_endpoint_free(&ep_cfg);
+	fwnode_handle_put(endpoint);
+
+	return ret;
+}
+
+static int gc2145_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct gc2145 *gc2145;
+	int ret;
+	unsigned int xclk_freq;
+
+	gc2145 = devm_kzalloc(&client->dev, sizeof(*gc2145), GFP_KERNEL);
+	if (!gc2145)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&gc2145->sd, client, &gc2145_subdev_ops);
+
+	/* Check the hardware configuration in device tree */
+	if (gc2145_check_hwcfg(dev))
+		return -EINVAL;
+
+	/* Get system clock (xclk) */
+	gc2145->xclk = devm_clk_get(dev, NULL);
+	if (IS_ERR(gc2145->xclk)) {
+		dev_err(dev, "failed to get xclk\n");
+		return PTR_ERR(gc2145->xclk);
+	}
+
+	xclk_freq = clk_get_rate(gc2145->xclk);
+	if (xclk_freq != GC2145_XCLK_FREQ) {
+		dev_err(dev, "xclk frequency not supported: %d Hz\n", xclk_freq);
+		return -EINVAL;
+	}
+
+	ret = gc2145_get_regulators(gc2145);
+	if (ret) {
+		dev_err(dev, "failed to get regulators\n");
+		return ret;
+	}
+
+	/* Request optional enable pin */
+	gc2145->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+
+	/* Request optional enable pin */
+	gc2145->powerdown_gpio = devm_gpiod_get_optional(dev, "powerdown", GPIOD_OUT_HIGH);
+
+	/*
+	 * The sensor must be powered for gc2145_identify_module()
+	 * to be able to read the CHIP_ID register
+	 */
+	ret = gc2145_power_on(dev);
+	if (ret)
+		return ret;
+
+	mutex_init(&gc2145->mutex);
+
+	ret = gc2145_identify_module(gc2145);
+	if (ret)
+		goto error_power_off;
+
+	/* Set default mode to max resolution */
+	gc2145->mode = &supported_modes[GC2145_MODE_1600X1200];
+
+	ret = gc2145_init_controls(gc2145);
+	if (ret)
+		goto error_power_off;
+
+	/* Initialize subdev */
+	gc2145->sd.internal_ops = &gc2145_internal_ops;
+	gc2145->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+	gc2145->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+
+	/* Initialize source pad */
+	gc2145->pad.flags = MEDIA_PAD_FL_SOURCE;
+
+	/* Initialize default format */
+	gc2145_set_default_format(gc2145);
+
+	ret = media_entity_pads_init(&gc2145->sd.entity, 1, &gc2145->pad);
+	if (ret) {
+		dev_err(dev, "failed to init entity pads: %d\n", ret);
+		goto error_handler_free;
+	}
+
+	ret = v4l2_async_register_subdev_sensor(&gc2145->sd);
+	if (ret < 0) {
+		dev_err(dev, "failed to register sensor sub-device: %d\n", ret);
+		goto error_media_entity;
+	}
+
+	/* Enable runtime PM and turn off the device */
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_idle(dev);
+
+	return 0;
+
+error_media_entity:
+	media_entity_cleanup(&gc2145->sd.entity);
+
+error_handler_free:
+	gc2145_free_controls(gc2145);
+
+error_power_off:
+	gc2145_power_off(dev);
+	mutex_destroy(&gc2145->mutex);
+
+	return ret;
+}
+
+static int gc2145_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc2145 *gc2145 = to_gc2145(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	gc2145_free_controls(gc2145);
+
+	pm_runtime_disable(&client->dev);
+	if (!pm_runtime_status_suspended(&client->dev))
+		gc2145_power_off(&client->dev);
+	pm_runtime_set_suspended(&client->dev);
+
+	mutex_destroy(&gc2145->mutex);
+
+	return 0;
+}
+
+static const struct of_device_id gc2145_dt_ids[] = {
+	{ .compatible = "galaxycore,gc2145" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, gc2145_dt_ids);
+
+static const struct dev_pm_ops gc2145_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(gc2145_suspend, gc2145_resume)
+	SET_RUNTIME_PM_OPS(gc2145_power_off, gc2145_power_on, NULL)
+};
+
+static struct i2c_driver gc2145_i2c_driver = {
+	.driver = {
+		.name = "gc2145",
+		.of_match_table	= gc2145_dt_ids,
+		.pm = &gc2145_pm_ops,
+	},
+	.probe_new = gc2145_probe,
+	.remove = gc2145_remove,
+};
+
+module_i2c_driver(gc2145_i2c_driver);
+
+MODULE_AUTHOR("Alain Volmat <alain.volmat@foss.st.com");
+MODULE_DESCRIPTION("GalaxyCore GC2145 sensor driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/imx335.c b/drivers/media/i2c/imx335.c
index 410d6b86f..32d0e7a24 100644
--- a/drivers/media/i2c/imx335.c
+++ b/drivers/media/i2c/imx335.c
@@ -50,7 +50,6 @@
 
 /* CSI2 HW configuration */
 #define IMX335_LINK_FREQ	594000000
-#define IMX335_NUM_DATA_LANES	4
 
 #define IMX335_REG_MIN		0x00
 #define IMX335_REG_MAX		0xfffff
@@ -86,7 +85,8 @@ struct imx335_reg_list {
  * @vblank_max: Maximum vertical blanking in lines
  * @pclk: Sensor pixel clock
  * @link_freq_idx: Link frequency index
- * @reg_list: Register list for sensor mode
+ * @common_regs: Register list for common settings
+ * @mode_regs: Register list for mode specific settings
  */
 struct imx335_mode {
 	u32 width;
@@ -98,7 +98,8 @@ struct imx335_mode {
 	u32 vblank_max;
 	u64 pclk;
 	u32 link_freq_idx;
-	struct imx335_reg_list reg_list;
+	struct imx335_reg_list common_regs;
+	struct imx335_reg_list mode_regs;
 };
 
 /**
@@ -108,6 +109,7 @@ struct imx335_mode {
  * @sd: V4L2 sub-device
  * @pad: Media pad. Only one pad supported
  * @reset_gpio: Sensor reset gpio
+ * @powerdown_gpio: Sensor powerdown gpio
  * @inclk: Sensor input clock
  * @ctrl_handler: V4L2 control handler
  * @link_freq_ctrl: Pointer to link frequency control
@@ -120,6 +122,7 @@ struct imx335_mode {
  * @cur_mode: Pointer to current selected sensor mode
  * @mutex: Mutex for serializing sensor controls
  * @streaming: Flag indicating streaming state
+ * @nb_lanes: Number of lanes to use
  */
 struct imx335 {
 	struct device *dev;
@@ -127,6 +130,7 @@ struct imx335 {
 	struct v4l2_subdev sd;
 	struct media_pad pad;
 	struct gpio_desc *reset_gpio;
+	struct gpio_desc *powerdown_gpio;
 	struct clk *inclk;
 	struct v4l2_ctrl_handler ctrl_handler;
 	struct v4l2_ctrl *link_freq_ctrl;
@@ -141,6 +145,7 @@ struct imx335 {
 	const struct imx335_mode *cur_mode;
 	struct mutex mutex;
 	bool streaming;
+	u32 nb_lanes;
 };
 
 static const s64 link_freq[] = {
@@ -235,8 +240,24 @@ static const struct imx335_reg mode_2592x1940_regs[] = {
 	{0x3a00, 0x01},
 };
 
+static const struct imx335_reg mode_10bits_regs[] = {
+	{0x3050, 0x00},
+	{0x319D, 0x00},
+	{0x341c, 0xff},
+	{0x341d, 0x01},
+	{0x3a01, 0x01},
+};
+
+static const struct imx335_reg mode_12bits_regs[] = {
+	{0x3050, 0x01},
+	{0x319D, 0x01},
+	{0x341c, 0x47},
+	{0x341d, 0x00},
+	{0x3a01, 0x03},
+};
+
 /* Supported sensor mode configurations */
-static const struct imx335_mode supported_mode = {
+static const struct imx335_mode supported_mode_4lanes = {
 	.width = 2592,
 	.height = 1940,
 	.hblank = 342,
@@ -246,10 +267,34 @@ static const struct imx335_mode supported_mode = {
 	.pclk = 396000000,
 	.link_freq_idx = 0,
 	.code = MEDIA_BUS_FMT_SRGGB12_1X12,
-	.reg_list = {
+	.common_regs = {
+		.num_of_regs = ARRAY_SIZE(mode_2592x1940_regs),
+		.regs = mode_2592x1940_regs,
+	},
+	.mode_regs = {
+		.num_of_regs = ARRAY_SIZE(mode_12bits_regs),
+		.regs = mode_12bits_regs,
+	},
+};
+
+static const struct imx335_mode supported_mode_2lanes = {
+	.width = 2592,
+	.height = 1940,
+	.hblank = 342,
+	.vblank = 2560,
+	.vblank_min = 2560,
+	.vblank_max = 133060,
+	.pclk = 396000000,
+	.link_freq_idx = 0,
+	.code = MEDIA_BUS_FMT_SRGGB10_1X10,
+	.common_regs = {
 		.num_of_regs = ARRAY_SIZE(mode_2592x1940_regs),
 		.regs = mode_2592x1940_regs,
 	},
+	.mode_regs = {
+		.num_of_regs = ARRAY_SIZE(mode_10bits_regs),
+		.regs = mode_10bits_regs,
+	},
 };
 
 /**
@@ -497,10 +542,12 @@ static int imx335_enum_mbus_code(struct v4l2_subdev *sd,
 				 struct v4l2_subdev_state *sd_state,
 				 struct v4l2_subdev_mbus_code_enum *code)
 {
+	struct imx335 *imx335 = to_imx335(sd);
+
 	if (code->index > 0)
 		return -EINVAL;
 
-	code->code = supported_mode.code;
+	code->code = imx335->cur_mode->code;
 
 	return 0;
 }
@@ -517,15 +564,17 @@ static int imx335_enum_frame_size(struct v4l2_subdev *sd,
 				  struct v4l2_subdev_state *sd_state,
 				  struct v4l2_subdev_frame_size_enum *fsize)
 {
+	struct imx335 *imx335 = to_imx335(sd);
+
 	if (fsize->index > 0)
 		return -EINVAL;
 
-	if (fsize->code != supported_mode.code)
+	if (fsize->code != imx335->cur_mode->code)
 		return -EINVAL;
 
-	fsize->min_width = supported_mode.width;
+	fsize->min_width = imx335->cur_mode->width;
 	fsize->max_width = fsize->min_width;
-	fsize->min_height = supported_mode.height;
+	fsize->min_height = imx335->cur_mode->height;
 	fsize->max_height = fsize->min_height;
 
 	return 0;
@@ -600,7 +649,7 @@ static int imx335_set_pad_format(struct v4l2_subdev *sd,
 
 	mutex_lock(&imx335->mutex);
 
-	mode = &supported_mode;
+	mode = imx335->cur_mode;
 	imx335_fill_pad_format(imx335, mode, fmt);
 
 	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
@@ -633,7 +682,7 @@ static int imx335_init_pad_cfg(struct v4l2_subdev *sd,
 	struct v4l2_subdev_format fmt = { 0 };
 
 	fmt.which = sd_state ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;
-	imx335_fill_pad_format(imx335, &supported_mode, &fmt);
+	imx335_fill_pad_format(imx335, imx335->cur_mode, &fmt);
 
 	return imx335_set_pad_format(sd, sd_state, &fmt);
 }
@@ -650,7 +699,7 @@ static int imx335_start_streaming(struct imx335 *imx335)
 	int ret;
 
 	/* Write sensor mode registers */
-	reg_list = &imx335->cur_mode->reg_list;
+	reg_list = &imx335->cur_mode->common_regs;
 	ret = imx335_write_regs(imx335, reg_list->regs,
 				reg_list->num_of_regs);
 	if (ret) {
@@ -658,6 +707,18 @@ static int imx335_start_streaming(struct imx335 *imx335)
 		return ret;
 	}
 
+	/*
+	 * Perform specific configuration depending on the number
+	 * of lanes used
+	 */
+	reg_list = &imx335->cur_mode->mode_regs;
+	ret = imx335_write_regs(imx335, reg_list->regs,
+				reg_list->num_of_regs);
+	if (ret) {
+		dev_err(imx335->dev, "fail to write mode registers");
+		return ret;
+	}
+
 	/* Setup handler will write actual exposure and gain */
 	ret =  __v4l2_ctrl_handler_setup(imx335->sd.ctrl_handler);
 	if (ret) {
@@ -790,6 +851,15 @@ static int imx335_parse_hw_config(struct imx335 *imx335)
 		return PTR_ERR(imx335->reset_gpio);
 	}
 
+	/* Request optional powerdown pin */
+	imx335->powerdown_gpio = devm_gpiod_get_optional(imx335->dev, "powerdown",
+							 GPIOD_OUT_LOW);
+	if (IS_ERR(imx335->powerdown_gpio)) {
+		dev_err(imx335->dev, "failed to get powerdown gpio %ld",
+			PTR_ERR(imx335->powerdown_gpio));
+		return PTR_ERR(imx335->powerdown_gpio);
+	}
+
 	/* Get sensor input clock */
 	imx335->inclk = devm_clk_get(imx335->dev, NULL);
 	if (IS_ERR(imx335->inclk)) {
@@ -812,7 +882,8 @@ static int imx335_parse_hw_config(struct imx335 *imx335)
 	if (ret)
 		return ret;
 
-	if (bus_cfg.bus.mipi_csi2.num_data_lanes != IMX335_NUM_DATA_LANES) {
+	if (bus_cfg.bus.mipi_csi2.num_data_lanes != 2 &&
+	    bus_cfg.bus.mipi_csi2.num_data_lanes != 4) {
 		dev_err(imx335->dev,
 			"number of CSI2 data lanes %d is not supported",
 			bus_cfg.bus.mipi_csi2.num_data_lanes);
@@ -820,6 +891,8 @@ static int imx335_parse_hw_config(struct imx335 *imx335)
 		goto done_endpoint_free;
 	}
 
+	imx335->nb_lanes = bus_cfg.bus.mipi_csi2.num_data_lanes;
+
 	if (!bus_cfg.nr_of_link_frequencies) {
 		dev_err(imx335->dev, "no link frequencies defined");
 		ret = -EINVAL;
@@ -868,6 +941,9 @@ static int imx335_power_on(struct device *dev)
 	struct imx335 *imx335 = to_imx335(sd);
 	int ret;
 
+	gpiod_set_value_cansleep(imx335->powerdown_gpio, 1);
+	/* FIXME - what is really needed here ?? */
+	usleep_range(5000, 10000);
 	gpiod_set_value_cansleep(imx335->reset_gpio, 1);
 
 	ret = clk_prepare_enable(imx335->inclk);
@@ -882,6 +958,7 @@ static int imx335_power_on(struct device *dev)
 
 error_reset:
 	gpiod_set_value_cansleep(imx335->reset_gpio, 0);
+	gpiod_set_value_cansleep(imx335->powerdown_gpio, 0);
 
 	return ret;
 }
@@ -898,6 +975,7 @@ static int imx335_power_off(struct device *dev)
 	struct imx335 *imx335 = to_imx335(sd);
 
 	gpiod_set_value_cansleep(imx335->reset_gpio, 0);
+	gpiod_set_value_cansleep(imx335->powerdown_gpio, 0);
 
 	clk_disable_unprepare(imx335->inclk);
 
@@ -1031,7 +1109,10 @@ static int imx335_probe(struct i2c_client *client)
 	}
 
 	/* Set default mode to max resolution */
-	imx335->cur_mode = &supported_mode;
+	if (imx335->nb_lanes == 2)
+		imx335->cur_mode = &supported_mode_2lanes;
+	else
+		imx335->cur_mode = &supported_mode_4lanes;
 	imx335->vblank = imx335->cur_mode->vblank;
 
 	ret = imx335_init_controls(imx335);
diff --git a/drivers/media/i2c/ov5640.c b/drivers/media/i2c/ov5640.c
index db5a19bab..df2b1fc1a 100644
--- a/drivers/media/i2c/ov5640.c
+++ b/drivers/media/i2c/ov5640.c
@@ -65,6 +65,7 @@
 #define OV5640_REG_TIMING_VTS		0x380e
 #define OV5640_REG_TIMING_TC_REG20	0x3820
 #define OV5640_REG_TIMING_TC_REG21	0x3821
+#define OV5640_REG_DVP_PCLK_DIVIDER	0x3824
 #define OV5640_REG_AEC_CTRL00		0x3a00
 #define OV5640_REG_AEC_B50_STEP		0x3a08
 #define OV5640_REG_AEC_B60_STEP		0x3a0a
@@ -88,6 +89,7 @@
 #define OV5640_REG_POLARITY_CTRL00	0x4740
 #define OV5640_REG_MIPI_CTRL00		0x4800
 #define OV5640_REG_DEBUG_MODE		0x4814
+#define OV5640_REG_PCLK_PERIOD		0x4837
 #define OV5640_REG_ISP_FORMAT_MUX_CTRL	0x501f
 #define OV5640_REG_PRE_ISP_TEST_SET1	0x503d
 #define OV5640_REG_SDE_CTRL0		0x5580
@@ -111,10 +113,11 @@ enum ov5640_mode_id {
 	OV5640_NUM_MODES,
 };
 
+#define OV5640_DEFAULT_MODE OV5640_MODE_VGA_640_480
+
 enum ov5640_frame_rate {
 	OV5640_15_FPS = 0,
 	OV5640_30_FPS,
-	OV5640_60_FPS,
 	OV5640_NUM_FRAMERATES,
 };
 
@@ -146,6 +149,19 @@ static const struct ov5640_pixfmt ov5640_formats[] = {
 	{ MEDIA_BUS_FMT_SRGGB8_1X8, V4L2_COLORSPACE_SRGB, },
 };
 
+static const s64 ov5640_link_freqs[] = {
+	 63136800, /* 1280x720@15 */
+	 83954880, /* 176x144@15, 320x240@15, 720x480@15 */
+	 92145600, /* 640x480@15, 1024x768@15 */
+	126273600, /* 1280x720@30 */
+	167909760, /* 176x144@30, 320x240@30, 720x480@30 */
+	184291200, /* 640x480@30, 1024x768@30 */
+	191116800, /* 1920x1080@15 */
+	335819520, /* 2592x1944@15 */
+	382233600, /* 1920x1080@30 */
+};
+#define OV5640_LINK_FREQS_NUM	ARRAY_SIZE(ov5640_link_freqs)
+
 /*
  * FIXME: remove this when a subdev API becomes available
  * to set the MIPI CSI-2 virtual channel.
@@ -158,7 +174,6 @@ MODULE_PARM_DESC(virtual_channel,
 static const int ov5640_framerates[] = {
 	[OV5640_15_FPS] = 15,
 	[OV5640_30_FPS] = 30,
-	[OV5640_60_FPS] = 60,
 };
 
 /* regulator supplies */
@@ -222,6 +237,7 @@ struct ov5640_ctrls {
 	struct v4l2_ctrl *test_pattern;
 	struct v4l2_ctrl *hflip;
 	struct v4l2_ctrl *vflip;
+	struct v4l2_ctrl *link_freq;
 };
 
 struct ov5640_dev {
@@ -377,8 +393,8 @@ static const struct reg_value ov5640_setting_VGA_640_480[] = {
 	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
 	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
-	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
-	{0x3824, 0x02, 0, 0}, {0x5001, 0xa3, 0, 0},
+	{0x4407, 0x04, 0, 0},
+	{0x5001, 0xa3, 0, 0},
 };
 
 static const struct reg_value ov5640_setting_XGA_1024_768[] = {
@@ -396,8 +412,7 @@ static const struct reg_value ov5640_setting_XGA_1024_768[] = {
 	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
 	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
-	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
-	{0x3824, 0x02, 0, 0}, {0x5001, 0xa3, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x5001, 0xa3, 0, 0},
 };
 
 static const struct reg_value ov5640_setting_QVGA_320_240[] = {
@@ -415,8 +430,7 @@ static const struct reg_value ov5640_setting_QVGA_320_240[] = {
 	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
 	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
-	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
-	{0x3824, 0x02, 0, 0}, {0x5001, 0xa3, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x5001, 0xa3, 0, 0},
 };
 
 static const struct reg_value ov5640_setting_QQVGA_160_120[] = {
@@ -452,8 +466,7 @@ static const struct reg_value ov5640_setting_QCIF_176_144[] = {
 	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
 	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
-	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
-	{0x3824, 0x02, 0, 0}, {0x5001, 0xa3, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x5001, 0xa3, 0, 0},
 };
 
 static const struct reg_value ov5640_setting_NTSC_720_480[] = {
@@ -471,8 +484,7 @@ static const struct reg_value ov5640_setting_NTSC_720_480[] = {
 	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
 	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
-	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
-	{0x3824, 0x02, 0, 0}, {0x5001, 0xa3, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x5001, 0xa3, 0, 0},
 };
 
 static const struct reg_value ov5640_setting_PAL_720_576[] = {
@@ -490,8 +502,7 @@ static const struct reg_value ov5640_setting_PAL_720_576[] = {
 	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
 	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
-	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
-	{0x3824, 0x02, 0, 0}, {0x5001, 0xa3, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x5001, 0xa3, 0, 0},
 };
 
 static const struct reg_value ov5640_setting_720P_1280_720[] = {
@@ -509,8 +520,7 @@ static const struct reg_value ov5640_setting_720P_1280_720[] = {
 	{0x3a0a, 0x01, 0, 0}, {0x3a0b, 0x72, 0, 0}, {0x3a0e, 0x01, 0, 0},
 	{0x3a0d, 0x02, 0, 0}, {0x3a14, 0x02, 0, 0}, {0x3a15, 0xe4, 0, 0},
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
-	{0x4407, 0x04, 0, 0}, {0x460b, 0x37, 0, 0}, {0x460c, 0x20, 0, 0},
-	{0x3824, 0x04, 0, 0}, {0x5001, 0x83, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x5001, 0xa3, 0, 0},
 };
 
 static const struct reg_value ov5640_setting_1080P_1920_1080[] = {
@@ -528,8 +538,8 @@ static const struct reg_value ov5640_setting_1080P_1920_1080[] = {
 	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
 	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x06, 0, 0},
-	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
-	{0x3824, 0x02, 0, 0}, {0x5001, 0x83, 0, 0},
+	{0x4407, 0x04, 0, 0},
+	{0x5001, 0x83, 0, 0},
 	{0x3c07, 0x07, 0, 0}, {0x3c08, 0x00, 0, 0},
 	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
 	{0x3800, 0x01, 0, 0}, {0x3801, 0x50, 0, 0}, {0x3802, 0x01, 0, 0},
@@ -540,7 +550,6 @@ static const struct reg_value ov5640_setting_1080P_1920_1080[] = {
 	{0x3a09, 0x50, 0, 0}, {0x3a0a, 0x01, 0, 0}, {0x3a0b, 0x18, 0, 0},
 	{0x3a0e, 0x03, 0, 0}, {0x3a0d, 0x04, 0, 0}, {0x3a14, 0x04, 0, 0},
 	{0x3a15, 0x60, 0, 0}, {0x4407, 0x04, 0, 0},
-	{0x460b, 0x37, 0, 0}, {0x460c, 0x20, 0, 0}, {0x3824, 0x04, 0, 0},
 	{0x4005, 0x1a, 0, 0},
 };
 
@@ -559,20 +568,31 @@ static const struct reg_value ov5640_setting_QSXGA_2592_1944[] = {
 	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
 	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x06, 0, 0},
-	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
-	{0x3824, 0x02, 0, 0}, {0x5001, 0x83, 0, 70},
+	{0x4407, 0x04, 0, 0},
+	{0x5001, 0x83, 0, 70},
 };
 
 /* power-on sensor init reg table */
-static const struct ov5640_mode_info ov5640_mode_init_data = {
+static const struct ov5640_mode_info *ov5640_mode_init_data;
+
+static const struct ov5640_mode_info ov5640_mode_init_data_dvp = {
 	0, SUBSAMPLING, 640, 1896, 480, 984,
 	ov5640_init_setting_30fps_VGA,
 	ARRAY_SIZE(ov5640_init_setting_30fps_VGA),
 	OV5640_30_FPS,
 };
 
+static const struct ov5640_mode_info ov5640_mode_init_data_csi2 = {
+	0, SUBSAMPLING, 640, 2844, 480, 984,
+	ov5640_init_setting_30fps_VGA,
+	ARRAY_SIZE(ov5640_init_setting_30fps_VGA),
+	OV5640_30_FPS,
+};
+
+static const struct ov5640_mode_info *ov5640_mode_data;
+
 static const struct ov5640_mode_info
-ov5640_mode_data[OV5640_NUM_MODES] = {
+ov5640_mode_data_dvp[OV5640_NUM_MODES] = {
 	{OV5640_MODE_QQVGA_160_120, SUBSAMPLING,
 	 160, 1896, 120, 984,
 	 ov5640_setting_QQVGA_160_120,
@@ -592,7 +612,7 @@ ov5640_mode_data[OV5640_NUM_MODES] = {
 	 640, 1896, 480, 1080,
 	 ov5640_setting_VGA_640_480,
 	 ARRAY_SIZE(ov5640_setting_VGA_640_480),
-	 OV5640_60_FPS},
+	 OV5640_30_FPS},
 	{OV5640_MODE_NTSC_720_480, SUBSAMPLING,
 	 720, 1896, 480, 984,
 	 ov5640_setting_NTSC_720_480,
@@ -625,6 +645,65 @@ ov5640_mode_data[OV5640_NUM_MODES] = {
 	 OV5640_15_FPS},
 };
 
+/*
+ * When using CSI-2 interface, adjusting htot to 2844
+ * gives better result in term of framerate, 720p support
+ * and overall stability with CSI-2 receiver
+ */
+static const struct ov5640_mode_info
+ov5640_mode_data_csi2[OV5640_NUM_MODES] = {
+	{OV5640_MODE_QQVGA_160_120, SUBSAMPLING,
+	 160, 2844, 120, 984,
+	 ov5640_setting_QQVGA_160_120,
+	 ARRAY_SIZE(ov5640_setting_QQVGA_160_120),
+	 OV5640_30_FPS},
+	{OV5640_MODE_QCIF_176_144, SUBSAMPLING,
+	 176, 2844, 144, 984,
+	 ov5640_setting_QCIF_176_144,
+	 ARRAY_SIZE(ov5640_setting_QCIF_176_144),
+	 OV5640_30_FPS},
+	{OV5640_MODE_QVGA_320_240, SUBSAMPLING,
+	 320, 2844, 240, 984,
+	 ov5640_setting_QVGA_320_240,
+	 ARRAY_SIZE(ov5640_setting_QVGA_320_240),
+	 OV5640_30_FPS},
+	{OV5640_MODE_VGA_640_480, SUBSAMPLING,
+	 640, 2844, 480, 1080,
+	 ov5640_setting_VGA_640_480,
+	 ARRAY_SIZE(ov5640_setting_VGA_640_480),
+	 OV5640_30_FPS},
+	{OV5640_MODE_NTSC_720_480, SUBSAMPLING,
+	 720, 2844, 480, 984,
+	 ov5640_setting_NTSC_720_480,
+	 ARRAY_SIZE(ov5640_setting_NTSC_720_480),
+	OV5640_30_FPS},
+	{OV5640_MODE_PAL_720_576, SUBSAMPLING,
+	 720, 2844, 576, 984,
+	 ov5640_setting_PAL_720_576,
+	 ARRAY_SIZE(ov5640_setting_PAL_720_576),
+	 OV5640_30_FPS},
+	{OV5640_MODE_XGA_1024_768, SUBSAMPLING,
+	 1024, 2844, 768, 1080,
+	 ov5640_setting_XGA_1024_768,
+	 ARRAY_SIZE(ov5640_setting_XGA_1024_768),
+	 OV5640_30_FPS},
+	{OV5640_MODE_720P_1280_720, SUBSAMPLING,
+	 1280, 2844, 720, 740,
+	 ov5640_setting_720P_1280_720,
+	 ARRAY_SIZE(ov5640_setting_720P_1280_720),
+	 OV5640_30_FPS},
+	{OV5640_MODE_1080P_1920_1080, SCALING,
+	 1920, 2844, 1080, 1120,
+	 ov5640_setting_1080P_1920_1080,
+	 ARRAY_SIZE(ov5640_setting_1080P_1920_1080),
+	 OV5640_30_FPS},
+	{OV5640_MODE_QSXGA_2592_1944, SCALING,
+	 2592, 2844, 1944, 1968,
+	 ov5640_setting_QSXGA_2592_1944,
+	 ARRAY_SIZE(ov5640_setting_QSXGA_2592_1944),
+	 OV5640_15_FPS},
+};
+
 static int ov5640_init_slave_id(struct ov5640_dev *sensor)
 {
 	struct i2c_client *client = sensor->i2c_client;
@@ -946,66 +1025,81 @@ static unsigned long ov5640_calc_sys_clk(struct ov5640_dev *sensor,
  * ov5640_set_mipi_pclk() - Calculate the clock tree configuration values
  *			    for the MIPI CSI-2 output.
  *
- * @rate: The requested bandwidth per lane in bytes per second.
- *	  'Bandwidth Per Lane' is calculated as:
- *	  bpl = HTOT * VTOT * FPS * bpp / num_lanes;
- *
- * This function use the requested bandwidth to calculate:
- * - sample_rate = bpl / (bpp / num_lanes);
- *	         = bpl / (PLL_RDIV * BIT_DIV * PCLK_DIV * MIPI_DIV / num_lanes);
- *
- * - mipi_sclk   = bpl / MIPI_DIV / 2; ( / 2 is for CSI-2 DDR)
- *
- * with these fixed parameters:
- *	PLL_RDIV	= 2;
- *	BIT_DIVIDER	= 2; (MIPI_BIT_MODE == 8 ? 2 : 2,5);
- *	PCLK_DIV	= 1;
- *
- * The MIPI clock generation differs for modes that use the scaler and modes
- * that do not. In case the scaler is in use, the MIPI_SCLK generates the MIPI
- * BIT CLk, and thus:
- *
- * - mipi_sclk = bpl / MIPI_DIV / 2;
- *   MIPI_DIV = 1;
- *
- * For modes that do not go through the scaler, the MIPI BIT CLOCK is generated
- * from the pixel clock, and thus:
- *
- * - sample_rate = bpl / (bpp / num_lanes);
- *	         = bpl / (2 * 2 * 1 * MIPI_DIV / num_lanes);
- *		 = bpl / (4 * MIPI_DIV / num_lanes);
- * - MIPI_DIV	 = bpp / (4 * num_lanes);
- *
  * FIXME: this have been tested with 16bpp and 2 lanes setup only.
- * MIPI_DIV is fixed to value 2, but it -might- be changed according to the
  * above formula for setups with 1 lane or image formats with different bpp.
- *
- * FIXME: this deviates from the sensor manual documentation which is quite
- * thin on the MIPI clock tree generation part.
  */
-static int ov5640_set_mipi_pclk(struct ov5640_dev *sensor,
-				unsigned long rate)
+static int ov5640_set_mipi_pclk(struct ov5640_dev *sensor)
 {
-	const struct ov5640_mode_info *mode = sensor->current_mode;
+	u8 bit_div, mipi_div, pclk_div, sclk_div, sclk2x_div, root_div;
 	u8 prediv, mult, sysdiv;
-	u8 mipi_div;
+	unsigned long link_freq;
+	unsigned long sysclk;
+	u8 pclk_period;
 	int ret;
 
+	/* Get current link frequency */
+	link_freq = ov5640_link_freqs[sensor->ctrls.link_freq->val];
+
 	/*
-	 * 1280x720 is reported to use 'SUBSAMPLING' only,
-	 * but according to the sensor manual it goes through the
-	 * scaler before subsampling.
+	 * - mipi_div - Assumptions not supported by documentation
+	 *
+	 *   The MIPI clock generation differs for modes that use the scaler and
+	 *   modes that do not.
 	 */
-	if (mode->dn_mode == SCALING ||
-	   (mode->id == OV5640_MODE_720P_1280_720))
-		mipi_div = OV5640_MIPI_DIV_SCLK;
+	if (sensor->current_mode->dn_mode == SCALING)
+		mipi_div = 1;
 	else
-		mipi_div = OV5640_MIPI_DIV_PCLK;
+		mipi_div = 2;
+
+	sysclk = link_freq * 2 * mipi_div;
+	ov5640_calc_sys_clk(sensor, sysclk, &prediv, &mult, &sysdiv);
+
+	/*
+	 * Adjust PLL parameters to maintain the MIPI_SCLK-to-PCLK ratio;
+	 *
+	 * - root_div = 2 (fixed)
+	 * - bit_div : MIPI 8-bit = 2
+	 *	       MIPI 10-bit = 2,5
+	 * - pclk_div = 1 (fixed)
+	 * - pll_div  = (2 lanes ? mipi_div : 2 * mipi_div)
+	 *   2 lanes: MIPI_SCLK = (4 or 5) * PCLK
+	 *   1 lanes: MIPI_SCLK = (8 or 10) * PCLK
+	 *
+	 * TODO: support 10-bit formats
+	 * TODO: support 1 lane
+	 */
+	root_div = OV5640_PLL_CTRL3_PLL_ROOT_DIV_2;
+	bit_div =  OV5640_PLL_CTRL0_MIPI_MODE_8BIT;
+	pclk_div = OV5640_PLL_SYS_ROOT_DIVIDER_BYPASS;
+
+	/*
+	 * Scaler clock:
+	 * - YUV: PCLK >= 2 * SCLK
+	 * - RAW or JPEG: PCLK >= SCLK
+	 * - sclk2x_div = sclk_div / 2
+	 *
+	 * TODO: add support for RAW and JPEG modes. To maintain the
+	 * SCLK to PCLK ratio, the sclk_div should probably be
+	 * adjusted.
+	 */
+	sclk_div = ilog2(OV5640_SCLK_ROOT_DIV);
+	sclk2x_div = ilog2(OV5640_SCLK2X_ROOT_DIV);
 
-	ov5640_calc_sys_clk(sensor, rate, &prediv, &mult, &sysdiv);
+	/*
+	 * This is called pclk period, but it actually represents the
+	 * sample period expressed in ns with 1-bit decimal (0x01=0.5ns).
+	 *
+	 * - pclk = link_freq * 2 * lanes / bpp
+	 *
+	 * TODO: support 1 data lane; support modes with bpp != 16.
+	 */
+	pclk_period = 2000000000UL / (link_freq / 2);
 
+	/* Program the clock tree registers. */
 	ret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL0,
-			     0x0f, OV5640_PLL_CTRL0_MIPI_MODE_8BIT);
+			     0x0f, bit_div);
+	if (ret)
+		return ret;
 
 	ret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL1,
 			     0xff, sysdiv << 4 | mipi_div);
@@ -1017,12 +1111,16 @@ static int ov5640_set_mipi_pclk(struct ov5640_dev *sensor,
 		return ret;
 
 	ret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL3,
-			     0x1f, OV5640_PLL_CTRL3_PLL_ROOT_DIV_2 | prediv);
+			     0x1f, root_div | prediv);
+	if (ret)
+		return ret;
+
+	ret = ov5640_mod_reg(sensor, OV5640_REG_SYS_ROOT_DIVIDER, 0x3f,
+			      (pclk_div << 4) | (sclk2x_div << 2) | sclk_div);
 	if (ret)
 		return ret;
 
-	return ov5640_mod_reg(sensor, OV5640_REG_SYS_ROOT_DIVIDER,
-			      0x30, OV5640_PLL_SYS_ROOT_DIVIDER_BYPASS);
+	return ov5640_write_reg(sensor, OV5640_REG_PCLK_PERIOD, pclk_period);
 }
 
 static unsigned long ov5640_calc_pclk(struct ov5640_dev *sensor,
@@ -1042,11 +1140,68 @@ static unsigned long ov5640_calc_pclk(struct ov5640_dev *sensor,
 	return _rate / *pll_rdiv / *bit_div / *pclk_div;
 }
 
-static int ov5640_set_dvp_pclk(struct ov5640_dev *sensor, unsigned long rate)
+static u64 ov5640_calc_pixel_rate(struct ov5640_dev *sensor)
+{
+	u64 rate;
+
+	rate = sensor->current_mode->vtot * sensor->current_mode->htot;
+	rate *= ov5640_framerates[sensor->current_fr];
+
+	return rate;
+}
+
+static int ov5640_set_dvp_pclk(struct ov5640_dev *sensor)
 {
+	const struct ov5640_mode_info *mode = sensor->current_mode;
 	u8 prediv, mult, sysdiv, pll_rdiv, bit_div, pclk_div;
+	struct i2c_client *client = sensor->i2c_client;
+	unsigned int pclk_freq, max_pclk_freq;
+	u8 dvp_pclk_divider;
+	unsigned long rate;
 	int ret;
 
+	/* Get pixel rate */
+	rate = ov5640_calc_pixel_rate(sensor);
+
+	dev_dbg(&client->dev, "pixel_rate=%lu selected (%dx%d@%d)(%dx%d)\n",
+		rate,
+		sensor->current_mode->hact,
+		sensor->current_mode->vact,
+		ov5640_framerates[sensor->current_fr],
+		sensor->current_mode->htot,
+		sensor->current_mode->vtot);
+
+	/*
+	 * All the formats we support have 16 bits per pixel, seems to require
+	 * the same rate than YUV, so we can just use 16 bpp all the time.
+	 */
+	rate = rate * 16 / sensor->ep.bus.parallel.bus_width;
+
+	/*
+	 * 1280x720 and 1024x768 are reported to use 'SUBSAMPLING' only,
+	 * but they seems to go through the scaler before subsampling.
+	 */
+	if (mode->dn_mode == SCALING ||
+	   (mode->id == OV5640_MODE_720P_1280_720) ||
+	   (mode->id == OV5640_MODE_XGA_1024_768))
+		dvp_pclk_divider = 1;
+	else
+		dvp_pclk_divider = 2;
+
+	ret = ov5640_write_reg(sensor, OV5640_REG_DVP_PCLK_DIVIDER,
+			       dvp_pclk_divider);
+	if (ret)
+		return ret;
+	pclk_freq = rate / dvp_pclk_divider;
+	max_pclk_freq = sensor->ep.bus.parallel.pclk_max_frequency;
+
+	/* clip rate according to optional maximum pixel clock limit */
+	if (max_pclk_freq && (pclk_freq > max_pclk_freq)) {
+		rate = max_pclk_freq * dvp_pclk_divider;
+		dev_dbg(&client->dev, "DVP pixel clock too high (%d > %d Hz), reducing rate...\n",
+			pclk_freq, max_pclk_freq);
+	}
+
 	ov5640_calc_pclk(sensor, rate, &prediv, &mult, &sysdiv, &pll_rdiv,
 			 &bit_div, &pclk_div);
 
@@ -1081,6 +1236,7 @@ static int ov5640_set_dvp_pclk(struct ov5640_dev *sensor, unsigned long rate)
 			      (ilog2(pclk_div) << 4));
 }
 
+#if 0
 /* set JPEG framing sizes */
 static int ov5640_set_jpeg_timings(struct ov5640_dev *sensor,
 				   const struct ov5640_mode_info *mode)
@@ -1104,19 +1260,20 @@ static int ov5640_set_jpeg_timings(struct ov5640_dev *sensor,
 
 	return ov5640_write_reg16(sensor, OV5640_REG_VFIFO_VSIZE, mode->vact);
 }
+#endif
 
 /* download ov5640 settings to sensor through i2c */
 static int ov5640_set_timings(struct ov5640_dev *sensor,
 			      const struct ov5640_mode_info *mode)
 {
 	int ret;
-
+#if 0
 	if (sensor->fmt.code == MEDIA_BUS_FMT_JPEG_1X8) {
 		ret = ov5640_set_jpeg_timings(sensor, mode);
 		if (ret < 0)
 			return ret;
 	}
-
+#endif
 	ret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_DVPHO, mode->hact);
 	if (ret < 0)
 		return ret;
@@ -1556,7 +1713,7 @@ ov5640_find_mode(struct ov5640_dev *sensor, enum ov5640_frame_rate fr,
 	const struct ov5640_mode_info *mode;
 
 	mode = v4l2_find_nearest_size(ov5640_mode_data,
-				      ARRAY_SIZE(ov5640_mode_data),
+				      OV5640_NUM_MODES,
 				      hact, vact,
 				      width, height);
 
@@ -1571,16 +1728,6 @@ ov5640_find_mode(struct ov5640_dev *sensor, enum ov5640_frame_rate fr,
 	return mode;
 }
 
-static u64 ov5640_calc_pixel_rate(struct ov5640_dev *sensor)
-{
-	u64 rate;
-
-	rate = sensor->current_mode->vtot * sensor->current_mode->htot;
-	rate *= ov5640_framerates[sensor->current_fr];
-
-	return rate;
-}
-
 /*
  * sensor changes between scaling and subsampling, go through
  * exposure calculation
@@ -1762,7 +1909,6 @@ static int ov5640_set_mode(struct ov5640_dev *sensor)
 	enum ov5640_downsize_mode dn_mode, orig_dn_mode;
 	bool auto_gain = sensor->ctrls.auto_gain->val == 1;
 	bool auto_exp =  sensor->ctrls.auto_exp->val == V4L2_EXPOSURE_AUTO;
-	unsigned long rate;
 	int ret;
 
 	dn_mode = mode->dn_mode;
@@ -1781,17 +1927,10 @@ static int ov5640_set_mode(struct ov5640_dev *sensor)
 			goto restore_auto_gain;
 	}
 
-	/*
-	 * All the formats we support have 16 bits per pixel, seems to require
-	 * the same rate than YUV, so we can just use 16 bpp all the time.
-	 */
-	rate = ov5640_calc_pixel_rate(sensor) * 16;
 	if (sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY) {
-		rate = rate / sensor->ep.bus.mipi_csi2.num_data_lanes;
-		ret = ov5640_set_mipi_pclk(sensor, rate);
+		ret = ov5640_set_mipi_pclk(sensor);
 	} else {
-		rate = rate / sensor->ep.bus.parallel.bus_width;
-		ret = ov5640_set_dvp_pclk(sensor, rate);
+		ret = ov5640_set_dvp_pclk(sensor);
 	}
 
 	if (ret < 0)
@@ -1860,10 +1999,10 @@ static int ov5640_restore_mode(struct ov5640_dev *sensor)
 	int ret;
 
 	/* first load the initial register values */
-	ret = ov5640_load_regs(sensor, &ov5640_mode_init_data);
+	ret = ov5640_load_regs(sensor, ov5640_mode_init_data);
 	if (ret < 0)
 		return ret;
-	sensor->last_mode = &ov5640_mode_init_data;
+	sensor->last_mode = ov5640_mode_init_data;
 
 	ret = ov5640_mod_reg(sensor, OV5640_REG_SYS_ROOT_DIVIDER, 0x3f,
 			     (ilog2(OV5640_SCLK2X_ROOT_DIV) << 2) |
@@ -2198,12 +2337,12 @@ static int ov5640_try_frame_interval(struct ov5640_dev *sensor,
 	int i;
 
 	minfps = ov5640_framerates[OV5640_15_FPS];
-	maxfps = ov5640_framerates[OV5640_60_FPS];
+	maxfps = ov5640_framerates[OV5640_30_FPS];
 
 	if (fi->numerator == 0) {
 		fi->denominator = maxfps;
 		fi->numerator = 1;
-		rate = OV5640_60_FPS;
+		rate = OV5640_30_FPS;
 		goto find_mode;
 	}
 
@@ -2286,6 +2425,70 @@ static int ov5640_try_fmt_internal(struct v4l2_subdev *sd,
 	return 0;
 }
 
+static int ov5640_set_link_freq_ctrl(struct ov5640_dev *sensor,
+				     unsigned long rate)
+{
+	u8 mipi_div;
+	unsigned int i;
+	unsigned int ret;
+	unsigned long link_freq;
+	unsigned int freq_index;
+	struct i2c_client *client = sensor->i2c_client;
+
+	if (sensor->ep.bus_type != V4L2_MBUS_CSI2_DPHY)
+		return 0;
+
+	/*
+	 * - mipi_div - Assumptions not supported by documentation
+	 *
+	 *   The MIPI clock generation differs for modes that use the scaler and
+	 *   modes that do not.
+	 */
+	if (sensor->current_mode->dn_mode == SCALING)
+		mipi_div = 1;
+	else
+		mipi_div = 2;
+
+	/*
+	 * All the formats we support have 16 bits per pixel, seems to require
+	 * the same rate than YUV, so we can just use 16 bpp all the time.
+	 */
+	rate = rate * 16;
+
+	/*
+	 * The 'rate' parameter is the bitrate = VTOT * HTOT * FPS * BPP
+	 *
+	 * Adjust it to represent the CSI-2 link frequency and use it to
+	 * update the associated control.
+	 */
+	link_freq = rate / sensor->ep.bus.mipi_csi2.num_data_lanes /
+		    2 / mipi_div;
+
+	freq_index = OV5640_LINK_FREQS_NUM - 1;
+	for (i = 0; i < OV5640_LINK_FREQS_NUM; ++i) {
+		if (ov5640_link_freqs[i] == link_freq) {
+			freq_index = i;
+			break;
+		}
+	}
+	WARN_ONCE(i == OV5640_LINK_FREQS_NUM,
+		  "Link frequency %ld not supported", link_freq);
+
+	ret = __v4l2_ctrl_s_ctrl(sensor->ctrls.link_freq, freq_index);
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(&client->dev, "link_freq[%d]=%lld selected (%dx%d@%d)(%dx%d)\n",
+		freq_index, ov5640_link_freqs[freq_index],
+		sensor->current_mode->hact,
+		sensor->current_mode->vact,
+		ov5640_framerates[sensor->current_fr],
+		sensor->current_mode->htot,
+		sensor->current_mode->vtot);
+
+	return ret;
+}
+
 static int ov5640_set_fmt(struct v4l2_subdev *sd,
 			  struct v4l2_subdev_state *sd_state,
 			  struct v4l2_subdev_format *format)
@@ -2325,8 +2528,14 @@ static int ov5640_set_fmt(struct v4l2_subdev *sd,
 	/* update format even if code is unchanged, resolution might change */
 	sensor->fmt = *mbus_fmt;
 
-	__v4l2_ctrl_s_ctrl_int64(sensor->ctrls.pixel_rate,
-				 ov5640_calc_pixel_rate(sensor));
+	if (sensor->pending_mode_change || sensor->pending_fmt_change) {
+		unsigned long rate = ov5640_calc_pixel_rate(sensor);
+
+		__v4l2_ctrl_s_ctrl_int64(sensor->ctrls.pixel_rate, rate);
+
+		ret = ov5640_set_link_freq_ctrl(sensor, rate);
+	}
+
 out:
 	mutex_unlock(&sensor->lock);
 	return ret;
@@ -2746,6 +2955,7 @@ static int ov5640_init_controls(struct ov5640_dev *sensor)
 	const struct v4l2_ctrl_ops *ops = &ov5640_ctrl_ops;
 	struct ov5640_ctrls *ctrls = &sensor->ctrls;
 	struct v4l2_ctrl_handler *hdl = &ctrls->handler;
+	unsigned long rate;
 	int ret;
 
 	v4l2_ctrl_handler_init(hdl, 32);
@@ -2754,9 +2964,22 @@ static int ov5640_init_controls(struct ov5640_dev *sensor)
 	hdl->lock = &sensor->lock;
 
 	/* Clock related controls */
+	rate = ov5640_calc_pixel_rate(sensor);
 	ctrls->pixel_rate = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_PIXEL_RATE,
 					      0, INT_MAX, 1,
-					      ov5640_calc_pixel_rate(sensor));
+					      rate);
+
+	ctrls->link_freq = v4l2_ctrl_new_int_menu(hdl, ops, V4L2_CID_LINK_FREQ,
+						  OV5640_LINK_FREQS_NUM - 1,
+						  0, ov5640_link_freqs);
+	if (ctrls->link_freq)
+		ctrls->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	mutex_lock(&sensor->lock);
+	ret = ov5640_set_link_freq_ctrl(sensor, rate);
+	mutex_unlock(&sensor->lock);
+	if (ret)
+		goto free_ctrls;
 
 	/* Auto/manual white balance */
 	ctrls->auto_wb = v4l2_ctrl_new_std(hdl, ops,
@@ -2914,13 +3137,16 @@ static int ov5640_s_frame_interval(struct v4l2_subdev *sd,
 
 	if (mode != sensor->current_mode ||
 	    frame_rate != sensor->current_fr) {
+		unsigned long rate;
+
 		sensor->current_fr = frame_rate;
 		sensor->frame_interval = fi->interval;
 		sensor->current_mode = mode;
 		sensor->pending_mode_change = true;
 
-		__v4l2_ctrl_s_ctrl_int64(sensor->ctrls.pixel_rate,
-					 ov5640_calc_pixel_rate(sensor));
+		rate = ov5640_calc_pixel_rate(sensor);
+		__v4l2_ctrl_s_ctrl_int64(sensor->ctrls.pixel_rate, rate);
+		ret = ov5640_set_link_freq_ctrl(sensor, rate);
 	}
 out:
 	mutex_unlock(&sensor->lock);
@@ -3066,15 +3292,10 @@ static int ov5640_probe(struct i2c_client *client)
 	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
 	fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;
 	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
-	fmt->width = 640;
-	fmt->height = 480;
 	fmt->field = V4L2_FIELD_NONE;
 	sensor->frame_interval.numerator = 1;
 	sensor->frame_interval.denominator = ov5640_framerates[OV5640_30_FPS];
 	sensor->current_fr = OV5640_30_FPS;
-	sensor->current_mode =
-		&ov5640_mode_data[OV5640_MODE_VGA_640_480];
-	sensor->last_mode = sensor->current_mode;
 
 	sensor->ae_target = 52;
 
@@ -3115,6 +3336,20 @@ static int ov5640_probe(struct i2c_client *client)
 		return -EINVAL;
 	}
 
+	if (sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY) {
+		ov5640_mode_data = ov5640_mode_data_csi2;
+		ov5640_mode_init_data = &ov5640_mode_init_data_csi2;
+	} else {
+		ov5640_mode_data = ov5640_mode_data_dvp;
+		ov5640_mode_init_data = &ov5640_mode_init_data_dvp;
+	}
+
+	fmt->width = ov5640_mode_data[OV5640_DEFAULT_MODE].hact;
+	fmt->height = ov5640_mode_data[OV5640_DEFAULT_MODE].vact;
+	sensor->current_mode =
+		&ov5640_mode_data[OV5640_DEFAULT_MODE];
+	sensor->last_mode = sensor->current_mode;
+
 	/* get system clock (xclk) */
 	sensor->xclk = devm_clk_get(dev, "xclk");
 	if (IS_ERR(sensor->xclk)) {
diff --git a/drivers/media/i2c/st-mipid02.c b/drivers/media/i2c/st-mipid02.c
index f630b88cb..b69e5baaf 100644
--- a/drivers/media/i2c/st-mipid02.c
+++ b/drivers/media/i2c/st-mipid02.c
@@ -50,6 +50,7 @@
 /* Bits definition for MIPID02_MODE_REG2 */
 #define MODE_HSYNC_ACTIVE_HIGH				BIT(1)
 #define MODE_VSYNC_ACTIVE_HIGH				BIT(2)
+#define MODE_PCLK_SAMPLE_RISING				BIT(3)
 /* Bits definition for MIPID02_DATA_SELECTION_CTRL */
 #define SELECTION_MANUAL_DATA				BIT(2)
 #define SELECTION_MANUAL_WIDTH				BIT(3)
@@ -63,7 +64,8 @@ static const u32 mipid02_supported_fmt_codes[] = {
 	MEDIA_BUS_FMT_SGRBG12_1X12, MEDIA_BUS_FMT_SRGGB12_1X12,
 	MEDIA_BUS_FMT_UYVY8_1X16, MEDIA_BUS_FMT_BGR888_1X24,
 	MEDIA_BUS_FMT_RGB565_2X8_LE, MEDIA_BUS_FMT_RGB565_2X8_BE,
-	MEDIA_BUS_FMT_YUYV8_2X8, MEDIA_BUS_FMT_UYVY8_2X8,
+	MEDIA_BUS_FMT_YUYV8_2X8, MEDIA_BUS_FMT_YVYU8_2X8,
+	MEDIA_BUS_FMT_UYVY8_2X8, MEDIA_BUS_FMT_VYUY8_2X8,
 	MEDIA_BUS_FMT_JPEG_1X8
 };
 
@@ -132,7 +134,9 @@ static int bpp_from_code(__u32 code)
 		return 12;
 	case MEDIA_BUS_FMT_UYVY8_1X16:
 	case MEDIA_BUS_FMT_YUYV8_2X8:
+	case MEDIA_BUS_FMT_YVYU8_2X8:
 	case MEDIA_BUS_FMT_UYVY8_2X8:
+	case MEDIA_BUS_FMT_VYUY8_2X8:
 	case MEDIA_BUS_FMT_RGB565_2X8_LE:
 	case MEDIA_BUS_FMT_RGB565_2X8_BE:
 		return 16;
@@ -163,7 +167,9 @@ static u8 data_type_from_code(__u32 code)
 		return 0x2c;
 	case MEDIA_BUS_FMT_UYVY8_1X16:
 	case MEDIA_BUS_FMT_YUYV8_2X8:
+	case MEDIA_BUS_FMT_YVYU8_2X8:
 	case MEDIA_BUS_FMT_UYVY8_2X8:
+	case MEDIA_BUS_FMT_VYUY8_2X8:
 		return 0x1e;
 	case MEDIA_BUS_FMT_BGR888_1X24:
 		return 0x24;
@@ -494,6 +500,8 @@ static int mipid02_configure_from_tx(struct mipid02_dev *bridge)
 		bridge->r.mode_reg2 |= MODE_HSYNC_ACTIVE_HIGH;
 	if (ep->bus.parallel.flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)
 		bridge->r.mode_reg2 |= MODE_VSYNC_ACTIVE_HIGH;
+	if (ep->bus.parallel.flags & V4L2_MBUS_PCLK_SAMPLE_RISING)
+		bridge->r.mode_reg2 |= MODE_PCLK_SAMPLE_RISING;
 
 	return 0;
 }
diff --git a/drivers/media/platform/Kconfig b/drivers/media/platform/Kconfig
index 80321e038..177cc6efa 100644
--- a/drivers/media/platform/Kconfig
+++ b/drivers/media/platform/Kconfig
@@ -124,6 +124,19 @@ config VIDEO_S3C_CAMIF
 	  To compile this driver as a module, choose M here: the module
 	  will be called s3c-camif.
 
+config VIDEO_STM32_CSI2HOST
+	tristate "STM32 Camera Serial Interface (CSI) support"
+	depends on VIDEO_V4L2 && OF
+	depends on ARCH_STM32 || COMPILE_TEST
+	select MEDIA_CONTROLLER
+	select V4L2_FWNODE
+	help
+	  This module makes the STM32 Camera Serial Interface (CSI)
+	  available as a v4l2 device.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called stm32-csi2host.
+
 config VIDEO_STM32_DCMI
 	tristate "STM32 Digital Camera Memory Interface (DCMI) support"
 	depends on VIDEO_V4L2 && OF
@@ -138,6 +151,19 @@ config VIDEO_STM32_DCMI
 	  To compile this driver as a module, choose M here: the module
 	  will be called stm32-dcmi.
 
+config VIDEO_STM32_DCMIPP
+	tristate "STM32 Digital Camera Memory Interface Pixel Processor (DCMIPP) support"
+	depends on VIDEO_V4L2 && OF && MEDIA_CONTROLLER
+	depends on ARCH_STM32 || COMPILE_TEST
+	select VIDEOBUF2_DMA_CONTIG
+	select V4L2_FWNODE
+	help
+	  This module makes the STM32 Digital Camera Memory Interface
+	  Pixel Processor (DCMIPP) available as a v4l2 device.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called stm32-dcmipp.
+
 config VIDEO_RENESAS_CEU
 	tristate "Renesas Capture Engine Unit (CEU) driver"
 	depends on VIDEO_DEV && VIDEO_V4L2
diff --git a/drivers/media/platform/stm32/Makefile b/drivers/media/platform/stm32/Makefile
index 48b36db2c..e1daa0511 100644
--- a/drivers/media/platform/stm32/Makefile
+++ b/drivers/media/platform/stm32/Makefile
@@ -1,2 +1,4 @@
 # SPDX-License-Identifier: GPL-2.0-only
+obj-$(CONFIG_VIDEO_STM32_CSI2HOST) += stm32-csi2host.o
 obj-$(CONFIG_VIDEO_STM32_DCMI) += stm32-dcmi.o
+obj-$(CONFIG_VIDEO_STM32_DCMIPP) += stm32-dcmipp/
diff --git a/drivers/media/platform/stm32/stm32-csi2host.c b/drivers/media/platform/stm32/stm32-csi2host.c
new file mode 100644
index 000000000..50d0be467
--- /dev/null
+++ b/drivers/media/platform/stm32/stm32-csi2host.c
@@ -0,0 +1,1144 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Driver for STM32 Camera Serial Interface
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Alain Volmat <alain.volmat@foss.st.com>
+ *
+ * This driver is based on cdns-csi2rx.c
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_graph.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+/* Uncomment the following define to show catch all CSI2HOST errors */
+/* #define CSI2HOST_ERROR_HANDLING */
+
+#define CSI_CR					0x0000
+#define CSI_CR_CSIEN				BIT(0)
+#define CSI_CR_VCxSTART(x)			BIT(2 + ((x) * 4))
+#define CSI_CR_VCxSTOP(x)			BIT(3 + ((x) * 4))
+#define CSI_PCR					0x0004
+#define CSI_PCR_DL1EN				BIT(3)
+#define CSI_PCR_DL0EN				BIT(2)
+#define CSI_PCR_CLEN				BIT(1)
+#define CSI_PCR_PWRDOWN				BIT(0)
+#define CSI_VCxCFGR1(x)				((((x) + 1) * 0x0010) + 0x0)
+#define CSI_VCxCFGR1_ALLDT			BIT(0)
+#define CSI_VCxCFGR1_DT0EN			BIT(1)
+#define CSI_VCxCFGR1_DT1EN			BIT(2)
+#define CSI_VCxCFGR1_CDTFT_SHIFT		8
+#define CSI_VCxCFGR1_DT0_SHIFT			16
+#define CSI_VCxCFGR1_DT0FT_SHIFT		24
+#define CSI_VCxCFGR2(x)				((((x) + 1) * 0x0010) + 0x4)
+#define CSI_VCxCFGR2_DT1_SHIFT			0
+#define CSI_VCxCFGR2_DT1FT_SHIFT		8
+#define CSI_VCxCFGRx_DTxFT_BPP8			2
+#define CSI_VCxCFGRx_DTxFT_BPP10		3
+#define CSI_LMCFGR				0x0070
+#define CSI_LMCFGR_LANENB_SHIFT			8
+#define CSI_LMCFGR_LANENB_MASK			GENMASK(10, 8)
+#define CSI_LMCFGR_DL0MAP_SHIFT			16
+#define CSI_LMCFGR_DL0MAP_MASK			GENMASK(18, 16)
+#define CSI_LMCFGR_DL1MAP_SHIFT			20
+#define CSI_LMCFGR_DL1MAP_MASK			GENMASK(22, 20)
+#define CSI_WDR					0x0078
+#define CSI_IER0				0x0080
+#define CSI_IER1				0x0084
+#define CSI_SR0					0x0090
+#define CSI_SR0_SYNCERRF			BIT(30)
+#define CSI_SR0_SPKTERRF			BIT(28)
+#define CSI_SR0_IDERRF				BIT(27)
+#define CSI_SR0_CECCERRF			BIT(26)
+#define CSI_SR0_ECCERRF				BIT(25)
+#define CSI_SR0_CRCERRF				BIT(24)
+#define CSI_SR0_CCFIFOFF			BIT(21)
+#define CSI_SR0_VCxSTATEF(x)			BIT(17 + (x))
+#define CSI_SR0_EOF3F				BIT(15)
+#define CSI_SR0_EOF2F				BIT(14)
+#define CSI_SR0_EOF1F				BIT(13)
+#define CSI_SR0_EOF0F				BIT(12)
+#define CSI_SR0_SOF3F				BIT(11)
+#define CSI_SR0_SOF2F				BIT(10)
+#define CSI_SR0_SOF1F				BIT(9)
+#define CSI_SR0_SOF0F				BIT(8)
+#define CSI_SR1					0x0094
+#define CSI_SR1_STOPCLF				BIT(28)
+#define CSI_SR1_STOPDL1F			BIT(25)
+#define CSI_SR1_STOPDL0F			BIT(19)
+#define CSI_SR1_ECTRLDL1F			BIT(12)
+#define CSI_SR1_ESYNCESCDL1F			BIT(11)
+#define CSI_SR1_EESCDL1F			BIT(10)
+#define CSI_SR1_ESOTSYNCDL1F			BIT(9)
+#define CSI_SR1_ESOTDL1F			BIT(8)
+#define CSI_SR1_ECTRLDL0F			BIT(4)
+#define CSI_SR1_ESYNCESCDL0F			BIT(3)
+#define CSI_SR1_EESCDL0F			BIT(2)
+#define CSI_SR1_ESOTSYNCDL0F			BIT(1)
+#define CSI_SR1_ESOTDL0F			BIT(0)
+#define CSI_FCR0				0x0100
+#define CSI_FCR1				0x0104
+#define CSI_SPDFR				0x0110
+#define DT_MASK	0x3f
+#define VC_MASK	0x03
+#define CSI_ERR1				0x0114
+#define CSI_ERR1_IDVCERR_SHIFT			22
+#define CSI_ERR1_IDDTERR_SHIFT			16
+#define CSI_ERR1_CECCVCERR_SHIFT		14
+#define CSI_ERR1_CECCDTERR_SHIFT		8
+#define CSI_ERR1_CRCVCERR_SHIFT			6
+#define CSI_ERR1_CRCDTERR_SHIFT			0
+#define CSI_ERR2				0x0118
+#define CSI_ERR2_SYNCVCERR_SHIFT		18
+#define CSI_ERR2_SPKTVCERR_SHIFT		6
+#define CSI_ERR2_SPKTDTERR_SHIFT		0
+#define CSI_PRCR				0x1000
+#define CSI_PRCR_PEN				BIT(1)
+#define CSI_PMCR				0x1004
+#define CSI_PFCR				0x1008
+#define CSI_PFCR_CCFR_MASK			GENMASK(5, 0)
+#define CSI_PFCR_CCFR_SHIFT			0
+#define CSI_PFCR_HSFR_MASK			GENMASK(14, 8)
+#define CSI_PFCR_HSFR_SHIFT			8
+#define CSI_PFCR_DLD				BIT(16)
+#define CSI_PTCR0				0x1010
+#define CSI_PTCR0_TCKEN				BIT(0)
+#define CSI_PTCR1				0x1014
+#define CSI_PTCR1_TWM				BIT(16)
+#define CSI_PTCR1_TDI_MASK			GENMASK(7, 0)
+#define CSI_PTCR1_TDI_SHIFT			0
+#define CSI_PTSR				0x1018
+#define CSI_HWCFGR				0x1ff0
+#define CSI_HWCFGR_LANES_MASK			GENMASK(7, 4)
+#define CSI_HWCFGR_LANES_SHIFT			4
+
+#define CSI2HOST_LANES_MAX	2
+
+#define CSI_SR0_ERRORS	(CSI_SR0_SYNCERRF | CSI_SR0_SPKTERRF | CSI_SR0_IDERRF |\
+			 CSI_SR0_CECCERRF | CSI_SR0_ECCERRF | CSI_SR0_CRCERRF |\
+			 CSI_SR0_CCFIFOFF)
+#define CSI_SR1_DL0_ERRORS	(CSI_SR1_ECTRLDL0F | CSI_SR1_ESYNCESCDL0F |\
+				 CSI_SR1_EESCDL0F | CSI_SR1_ESOTSYNCDL0F |\
+				 CSI_SR1_ESOTDL0F)
+#define CSI_SR1_DL1_ERRORS	(CSI_SR1_ECTRLDL1F | CSI_SR1_ESYNCESCDL1F |\
+				 CSI_SR1_EESCDL1F | CSI_SR1_ESOTSYNCDL1F |\
+				 CSI_SR1_ESOTDL1F)
+#define CSI_SR1_ERRORS	(CSI_SR1_DL0_ERRORS | CSI_SR1_DL1_ERRORS)
+
+enum csi2host_pads {
+	CSI2HOST_PAD_SINK,
+	CSI2HOST_PAD_SOURCE_STREAM0,
+	CSI2HOST_PAD_SOURCE_STREAM1,
+	CSI2HOST_PAD_SOURCE_STREAM2,
+	CSI2HOST_PAD_SOURCE_STREAM3,
+	CSI2HOST_PAD_SOURCE_STREAM4,
+	CSI2HOST_PAD_SOURCE_STREAM5,
+	CSI2HOST_PAD_SOURCE_STREAM6,
+	CSI2HOST_PAD_SOURCE_STREAM7,
+	CSI2HOST_PAD_MAX,
+};
+
+struct csi2host_priv {
+	struct device			*dev;
+	unsigned int			count;
+
+	/*
+	 * Used to prevent race conditions between multiple,
+	 * concurrent calls to start and stop.
+	 */
+	struct mutex			lock;
+
+	void __iomem			*base;
+	struct clk			*pclk;
+	struct clk			*txesc;
+	struct clk			*csi2phy;
+	struct reset_control		*rstc;
+
+	u8				lanes[CSI2HOST_LANES_MAX];
+	u8				num_lanes;
+	u8				max_lanes;
+
+	struct v4l2_subdev		subdev;
+	struct v4l2_async_notifier	notifier;
+	struct media_pad		pads[CSI2HOST_PAD_MAX];
+
+	struct v4l2_mbus_framefmt	mf[CSI2HOST_PAD_MAX];
+
+	/* Remote source */
+	struct v4l2_subdev		*source_subdev;
+
+#ifdef CSI2HOST_ERROR_HANDLING
+	/* Backup registers used within irq handlers */
+	u32 sr0;
+	u32 sr1;
+	u32 err1;
+	u32 err2;
+#endif
+};
+
+struct csi2host_fmts {
+	u32 code;
+	unsigned int datatype;
+	unsigned int datatype_fmt;
+	unsigned int bpp;
+};
+
+#define FMT_MBUS_DT_DTFMT_BPP(mbus, dt, dtfmt, byteperpixel)	\
+		{						\
+			.code = MEDIA_BUS_FMT_##mbus,		\
+			.datatype = dt,	\
+			.datatype_fmt = CSI_VCxCFGRx_DTxFT_##dtfmt,	\
+			.bpp = byteperpixel,	\
+		}
+static const struct csi2host_fmts csi2host_formats[] = {
+	/* YUV 422 8 bit */
+	FMT_MBUS_DT_DTFMT_BPP(UYVY8_2X8, 0x1e, BPP8, 8),
+	FMT_MBUS_DT_DTFMT_BPP(YUYV8_2X8, 0x1e, BPP8, 8),
+	FMT_MBUS_DT_DTFMT_BPP(YVYU8_2X8, 0x1e, BPP8, 8),
+	FMT_MBUS_DT_DTFMT_BPP(VYUY8_2X8, 0x1e, BPP8, 8),
+
+	/* Raw Bayer */
+	/* 8 bit */
+	FMT_MBUS_DT_DTFMT_BPP(SBGGR8_1X8, 0x2a, BPP8, 8),
+	FMT_MBUS_DT_DTFMT_BPP(SGBRG8_1X8, 0x2a, BPP8, 8),
+	FMT_MBUS_DT_DTFMT_BPP(SGRBG8_1X8, 0x2a, BPP8, 8),
+	FMT_MBUS_DT_DTFMT_BPP(SRGGB8_1X8, 0x2a, BPP8, 8),
+	/* 10 bit */
+	FMT_MBUS_DT_DTFMT_BPP(SRGGB10_1X10, 0x2b, BPP10, 10),
+	FMT_MBUS_DT_DTFMT_BPP(SGBRG10_1X10, 0x2b, BPP10, 10),
+	FMT_MBUS_DT_DTFMT_BPP(SGRBG10_1X10, 0x2b, BPP10, 10),
+	FMT_MBUS_DT_DTFMT_BPP(SRGGB10_1X10, 0x2b, BPP10, 10),
+
+	/* RGB 565 */
+	FMT_MBUS_DT_DTFMT_BPP(RGB565_2X8_LE, 0x22, BPP8, 8),
+
+	/* JPEG (datatype isn't used) */
+	FMT_MBUS_DT_DTFMT_BPP(JPEG_1X8, 0, BPP8, 8),
+};
+
+struct csi2host_mbps_phy_reg {
+	unsigned int mbps;
+	unsigned int hsfreqrange;
+	unsigned int osc_freq_target;
+};
+
+/*
+ * Table describing configuration of the PHY depending on the
+ * intended Bit Rate. From table 5-8 Frequency Ranges and Defaults
+ * of the Synopsis DWC MIPI PHY databook
+ */
+/* FIXME - this table should be configurable and depend on the compatible */
+static const struct csi2host_mbps_phy_reg snps_stm32mp257[] = {
+	{ .mbps =   80,	.hsfreqrange = 0x00,	.osc_freq_target = 460 },
+	{ .mbps =   90, .hsfreqrange = 0x10,	.osc_freq_target = 460 },
+	{ .mbps =  100, .hsfreqrange = 0x20,	.osc_freq_target = 460 },
+	{ .mbps =  110, .hsfreqrange = 0x30,	.osc_freq_target = 460 },
+	{ .mbps =  120, .hsfreqrange = 0x01,	.osc_freq_target = 460 },
+	{ .mbps =  130, .hsfreqrange = 0x11,	.osc_freq_target = 460 },
+	{ .mbps =  140, .hsfreqrange = 0x21,	.osc_freq_target = 460 },
+	{ .mbps =  150, .hsfreqrange = 0x31,	.osc_freq_target = 460 },
+	{ .mbps =  160, .hsfreqrange = 0x02,	.osc_freq_target = 460 },
+	{ .mbps =  170, .hsfreqrange = 0x12,	.osc_freq_target = 460 },
+	{ .mbps =  180, .hsfreqrange = 0x22,	.osc_freq_target = 460 },
+	{ .mbps =  190, .hsfreqrange = 0x32,	.osc_freq_target = 460 },
+	{ .mbps =  205, .hsfreqrange = 0x03,	.osc_freq_target = 460 },
+	{ .mbps =  220, .hsfreqrange = 0x13,	.osc_freq_target = 460 },
+	{ .mbps =  235, .hsfreqrange = 0x23,	.osc_freq_target = 460 },
+	{ .mbps =  250, .hsfreqrange = 0x33,	.osc_freq_target = 460 },
+	{ .mbps =  275, .hsfreqrange = 0x04,	.osc_freq_target = 460 },
+	{ .mbps =  300, .hsfreqrange = 0x14,	.osc_freq_target = 460 },
+	{ .mbps =  325, .hsfreqrange = 0x25,	.osc_freq_target = 460 },
+	{ .mbps =  350, .hsfreqrange = 0x35,	.osc_freq_target = 460 },
+	{ .mbps =  400, .hsfreqrange = 0x05,	.osc_freq_target = 460 },
+	{ .mbps =  450, .hsfreqrange = 0x16,	.osc_freq_target = 460 },
+	{ .mbps =  500, .hsfreqrange = 0x26,	.osc_freq_target = 460 },
+	{ .mbps =  550, .hsfreqrange = 0x37,	.osc_freq_target = 460 },
+	{ .mbps =  600, .hsfreqrange = 0x07,	.osc_freq_target = 460 },
+	{ .mbps =  650, .hsfreqrange = 0x18,	.osc_freq_target = 460 },
+	{ .mbps =  700, .hsfreqrange = 0x28,	.osc_freq_target = 460 },
+	{ .mbps =  750, .hsfreqrange = 0x39,	.osc_freq_target = 460 },
+	{ .mbps =  800, .hsfreqrange = 0x09,	.osc_freq_target = 460 },
+	{ .mbps =  850, .hsfreqrange = 0x19,	.osc_freq_target = 460 },
+	{ .mbps =  900, .hsfreqrange = 0x29,	.osc_freq_target = 460 },
+	{ .mbps =  950, .hsfreqrange = 0x3a,	.osc_freq_target = 460 },
+	{ .mbps = 1000, .hsfreqrange = 0x0a,	.osc_freq_target = 460 },
+	{ .mbps = 1050, .hsfreqrange = 0x1a,	.osc_freq_target = 460 },
+	{ .mbps = 1100, .hsfreqrange = 0x2a,	.osc_freq_target = 460 },
+	{ .mbps = 1150, .hsfreqrange = 0x3b,	.osc_freq_target = 460 },
+	{ .mbps = 1200, .hsfreqrange = 0x0b,	.osc_freq_target = 460 },
+	{ .mbps = 1250, .hsfreqrange = 0x1b,	.osc_freq_target = 460 },
+	{ .mbps = 1300, .hsfreqrange = 0x2b,	.osc_freq_target = 460 },
+	{ .mbps = 1350, .hsfreqrange = 0x3c,	.osc_freq_target = 460 },
+	{ .mbps = 1400, .hsfreqrange = 0x0c,	.osc_freq_target = 460 },
+	{ .mbps = 1450, .hsfreqrange = 0x1c,	.osc_freq_target = 460 },
+	{ .mbps = 1500, .hsfreqrange = 0x2c,	.osc_freq_target = 460 },
+	{ .mbps = 1550, .hsfreqrange = 0x3d,	.osc_freq_target = 285 },
+	{ .mbps = 1600, .hsfreqrange = 0x0d,	.osc_freq_target = 295 },
+	{ .mbps = 1650, .hsfreqrange = 0x1d,	.osc_freq_target = 304 },
+	{ .mbps = 1700, .hsfreqrange = 0x2e,	.osc_freq_target = 313 },
+	{ .mbps = 1750, .hsfreqrange = 0x3e,	.osc_freq_target = 322 },
+	{ .mbps = 1800, .hsfreqrange = 0x0e,	.osc_freq_target = 331 },
+	{ .mbps = 1850, .hsfreqrange = 0x1e,	.osc_freq_target = 341 },
+	{ .mbps = 1900, .hsfreqrange = 0x2f,	.osc_freq_target = 350 },
+	{ .mbps = 1950, .hsfreqrange = 0x3f,	.osc_freq_target = 359 },
+	{ .mbps = 2000, .hsfreqrange = 0x0f,	.osc_freq_target = 368 },
+	{ .mbps = 2050, .hsfreqrange = 0x40,	.osc_freq_target = 377 },
+	{ .mbps = 2100, .hsfreqrange = 0x41,	.osc_freq_target = 387 },
+	{ .mbps = 2150, .hsfreqrange = 0x42,	.osc_freq_target = 396 },
+	{ .mbps = 2200, .hsfreqrange = 0x43,	.osc_freq_target = 405 },
+	{ .mbps = 2250, .hsfreqrange = 0x44,	.osc_freq_target = 414 },
+	{ .mbps = 2300, .hsfreqrange = 0x45,	.osc_freq_target = 423 },
+	{ .mbps = 2350, .hsfreqrange = 0x46,	.osc_freq_target = 432 },
+	{ .mbps = 2400, .hsfreqrange = 0x47,	.osc_freq_target = 442 },
+	{ .mbps = 2450, .hsfreqrange = 0x48,	.osc_freq_target = 451 },
+	{ .mbps = 2500, .hsfreqrange = 0x49,	.osc_freq_target = 460 },
+	{ /* sentinel */ },
+};
+
+static const struct csi2host_fmts *csi2host_code_to_fmt(unsigned int code)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(csi2host_formats); i++)
+		if (csi2host_formats[i].code == code)
+			return &csi2host_formats[i];
+
+	return NULL;
+}
+
+static inline
+struct csi2host_priv *v4l2_subdev_to_csi2priv(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct csi2host_priv, subdev);
+}
+
+static int csi2host_setup_lane_merger(struct csi2host_priv *csi2priv)
+{
+	int i;
+	u32 lmcfgr;
+
+	lmcfgr = readl_relaxed(csi2priv->base + CSI_LMCFGR);
+	lmcfgr &= ~(CSI_LMCFGR_LANENB_MASK | CSI_LMCFGR_DL0MAP_MASK |
+		    CSI_LMCFGR_DL1MAP_MASK);
+
+	for (i = 0; i < csi2priv->num_lanes; i++) {
+		/* Check that lane ID is < max number of lane */
+		if (csi2priv->lanes[i] >= csi2priv->max_lanes) {
+			dev_err(csi2priv->dev, "Invalid lane id (%d)\n",
+				csi2priv->lanes[i]);
+			return -EINVAL;
+		}
+		lmcfgr |= ((csi2priv->lanes[i] + 1) << ((i * 4) +
+			   CSI_LMCFGR_DL0MAP_SHIFT));
+	}
+
+	lmcfgr |= (csi2priv->num_lanes << CSI_LMCFGR_LANENB_SHIFT);
+
+	writel_relaxed(lmcfgr, csi2priv->base + CSI_LMCFGR);
+
+	return 0;
+}
+
+static void csi2host_phy_reg_write(struct csi2host_priv *csi2priv, uint32_t addr, uint32_t val)
+{
+	/* Based on sequence described at section 5.2.3.2 of DesignWave document */
+	/* For writing the 4-bit testcode MSBs */
+	/* Set testen to high */
+	writel_relaxed(CSI_PTCR1_TWM, csi2priv->base + CSI_PTCR1);
+
+	/* Set testclk to high */
+	writel_relaxed(CSI_PTCR0_TCKEN, csi2priv->base + CSI_PTCR0);
+
+	/* Place 0x00 in testdin */
+	writel_relaxed(CSI_PTCR1_TWM, csi2priv->base + CSI_PTCR1);
+
+	/*
+	 * Set testclk to low (with the falling edge on testclk, the testdin signal content is
+	 * latched internally)
+	 */
+	writel_relaxed(0, csi2priv->base + CSI_PTCR0);
+
+	/* Set testen to low */
+	writel_relaxed(0, csi2priv->base + CSI_PTCR1);
+
+	/* Place the 8-bit word corresponding to the testcode MSBs in testdin */
+	writel_relaxed(((addr >> 8) & CSI_PTCR1_TDI_MASK) << CSI_PTCR1_TDI_SHIFT,
+		       csi2priv->base + CSI_PTCR1);
+
+	/* Set testclk to high */
+	writel_relaxed(CSI_PTCR0_TCKEN, csi2priv->base + CSI_PTCR0);
+
+	/* For writing the 8-bit testcode LSBs */
+	/* Set testclk to low */
+	writel_relaxed(0, csi2priv->base + CSI_PTCR0);
+
+	/* Set testen to high */
+	writel_relaxed(CSI_PTCR1_TWM, csi2priv->base + CSI_PTCR1);
+
+	/* Set testclk to high */
+	writel_relaxed(CSI_PTCR0_TCKEN, csi2priv->base + CSI_PTCR0);
+
+	/* Place the 8-bit word test data in testdin */
+	writel_relaxed((addr & CSI_PTCR1_TDI_MASK) << CSI_PTCR1_TDI_SHIFT | CSI_PTCR1_TWM,
+		       csi2priv->base + CSI_PTCR1);
+
+	/*
+	 * Set testclk to low (with the falling edge on testclk, the testdin signal content is
+	 * latched internally)
+	 */
+	writel_relaxed(0, csi2priv->base + CSI_PTCR0);
+
+	/* Set testen to low */
+	writel_relaxed(0, csi2priv->base + CSI_PTCR1);
+
+	/* For writing the data */
+	/* Place the 8-bit word corresponding to the page offset in testdin */
+	writel_relaxed((val & CSI_PTCR1_TDI_MASK) << CSI_PTCR1_TDI_SHIFT,
+		       csi2priv->base + CSI_PTCR1);
+
+	/* Set testclk to high (test data is programmed internally */
+	writel_relaxed(CSI_PTCR0_TCKEN, csi2priv->base + CSI_PTCR0);
+
+	/* Finish by setting testclk to low */
+	writel_relaxed(0, csi2priv->base + CSI_PTCR0);
+}
+
+static int csi2host_start(struct csi2host_priv *csi2priv)
+{
+	const struct csi2host_fmts *fmt;
+	const struct csi2host_mbps_phy_reg *phy_regs;
+	int ret, i, mbps;
+	unsigned long phy_clk_frate;
+	u32 lanes_ie = 0;
+	u32 lanes_en = 0;
+	u32 lanes_stop = 0;
+	u32 ccfr;
+	s64 link_freq;
+
+	dev_dbg(csi2priv->dev, "Starting the CSI2\n");
+	/* Get format info to get BPP - FIXME, is this ok to check pad 0 ?? */
+	fmt = csi2host_code_to_fmt(csi2priv->mf[0].code);
+
+	/* Get the remote sensor link frequency */
+	if (!csi2priv->source_subdev)
+		return -EIO;
+
+	link_freq = v4l2_get_link_freq(csi2priv->source_subdev->ctrl_handler,
+				       fmt->bpp, 2 * csi2priv->num_lanes);
+	if (link_freq < 0)
+		return link_freq;
+
+	/* MBPS is expressed in Mbps, hence link_freq / 100000 * 2 */
+	mbps = link_freq / 500000;
+	dev_dbg(csi2priv->dev, "Computed Mbps: %u\n", mbps);
+
+	for (phy_regs = snps_stm32mp257; phy_regs->mbps != 0; phy_regs++)
+		if (phy_regs->mbps >= mbps)
+			break;
+
+	if (!phy_regs->mbps) {
+		dev_err(csi2priv->dev, "Unsupported PHY speed (%u Mbps)", mbps);
+		return -ERANGE;
+	}
+
+	dev_dbg(csi2priv->dev, "PHY settings: (%u Mbps, %u HS FRange, %u OSC Freq)\n",
+		phy_regs->mbps, phy_regs->hsfreqrange,
+		phy_regs->osc_freq_target);
+
+	/* Prepare lanes related configuration bits */
+	for (i = 0; i < csi2priv->num_lanes; i++) {
+		if (!csi2priv->lanes[i]) {
+			lanes_ie |= CSI_SR1_DL0_ERRORS;
+			lanes_en |= CSI_PCR_DL0EN;
+			lanes_stop |= CSI_SR1_STOPDL0F;
+		} else {
+			lanes_ie |= CSI_SR1_DL1_ERRORS;
+			lanes_en |= CSI_PCR_DL1EN;
+			lanes_stop |= CSI_SR1_STOPDL1F;
+		}
+	}
+
+	ret = clk_prepare_enable(csi2priv->pclk);
+	if (ret)
+		goto error_out;
+
+	ret = clk_prepare_enable(csi2priv->txesc);
+	if (ret)
+		goto error_disable_pclk;
+
+	ret = clk_prepare_enable(csi2priv->csi2phy);
+	if (ret)
+		goto error_disable_txesc;
+
+	/* Retrieve CSI2PHY clock rate to compute CCFR value */
+	phy_clk_frate = clk_get_rate(csi2priv->csi2phy);
+	if (!phy_clk_frate) {
+		dev_err(csi2priv->dev, "CSI2PHY clock rate invalid (0)\n");
+		goto error_disable_txesc;
+	}
+
+	ret = csi2host_setup_lane_merger(csi2priv);
+	if (ret)
+		goto error_disable_csi2phy;
+
+	/* FIXME - how to set the watchdog value .. */
+	writel_relaxed(0, csi2priv->base + CSI_WDR);
+
+	/* Enable the CSI */
+	writel_relaxed(CSI_CR_CSIEN, csi2priv->base + CSI_CR);
+
+#ifdef CSI2HOST_ERROR_HANDLING
+	/* Enable some global CSI related interrupts - bits are same as SR0 */
+	writel_relaxed(CSI_SR0_ERRORS, csi2priv->base + CSI_IER0);
+
+	/* Enable lanes related error interrupts */
+	writel_relaxed(lanes_ie, csi2priv->base + CSI_IER1);
+#endif
+
+	/* Initialization of the D-PHY */
+	/* Stop the D-PHY */
+	writel_relaxed(0, csi2priv->base + CSI_PRCR);
+
+	/* Keep the D-PHY in power down state */
+	writel_relaxed(0, csi2priv->base + CSI_PCR);
+
+	/* Enable testclr clock during 15ns */
+	writel_relaxed(CSI_PTCR0_TCKEN, csi2priv->base + CSI_PTCR0);
+	udelay(1);
+	writel_relaxed(0, csi2priv->base + CSI_PTCR0);
+
+	/* Set hsfreqrange */
+	phy_clk_frate /= 1000000;
+	ccfr = (phy_clk_frate - 17) * 4;
+	writel_relaxed((ccfr << CSI_PFCR_CCFR_SHIFT) |
+		       (phy_regs->hsfreqrange << CSI_PFCR_HSFR_SHIFT),
+		       csi2priv->base + CSI_PFCR);
+
+	/* set reg @08 deskew_polarity_rw 1'b1 */
+	csi2host_phy_reg_write(csi2priv, 0x08, 0x38);
+
+	/* set reg @0xE4 counter_for_des_en_config_if_rx 0x10 + DLL prog EN */
+	/* This is because 13<= cfgclkfreqrange[5:0]<=38 */
+	csi2host_phy_reg_write(csi2priv, 0xe4, 0x11);
+
+	/* set reg @0xe2 & reg @0xe3 value DLL target oscilation freq */
+	/* Based on the table page 77, osc_freq_target */
+	csi2host_phy_reg_write(csi2priv, 0xe2, phy_regs->osc_freq_target & 0xFF);
+	csi2host_phy_reg_write(csi2priv, 0xe3, (phy_regs->osc_freq_target >> 8) & 0x0F);
+
+	writel_relaxed(CSI_PFCR_DLD | readl_relaxed(csi2priv->base + CSI_PFCR),
+		       csi2priv->base + CSI_PFCR);
+
+	/* Enable Lanes */
+	writel_relaxed(lanes_en | CSI_PCR_CLEN, csi2priv->base + CSI_PCR);
+	writel_relaxed(lanes_en | CSI_PCR_CLEN | CSI_PCR_PWRDOWN,
+		       csi2priv->base + CSI_PCR);
+
+	writel_relaxed(CSI_PRCR_PEN, csi2priv->base + CSI_PRCR);
+
+	/* Remove the force */
+	writel_relaxed(0, csi2priv->base + CSI_PMCR);
+
+	return ret;
+
+error_disable_csi2phy:
+	clk_disable_unprepare(csi2priv->csi2phy);
+error_disable_txesc:
+	clk_disable_unprepare(csi2priv->txesc);
+error_disable_pclk:
+	clk_disable_unprepare(csi2priv->pclk);
+error_out:
+	return ret;
+}
+
+static void csi2host_stop(struct csi2host_priv *csi2priv)
+{
+	dev_dbg(csi2priv->dev, "Stopping the CSI2\n");
+
+	/* Disable the D-PHY */
+	writel_relaxed(0, csi2priv->base + CSI_PCR);
+
+#ifdef CSI2HOST_ERROR_HANDLING
+	/* Disable ITs */
+	writel_relaxed(0, csi2priv->base + CSI_IER0);
+	writel_relaxed(0, csi2priv->base + CSI_IER1);
+#endif
+
+	/* Disable the CSI */
+	writel_relaxed(0, csi2priv->base + CSI_CR);
+
+	clk_disable_unprepare(csi2priv->csi2phy);
+	clk_disable_unprepare(csi2priv->txesc);
+	clk_disable_unprepare(csi2priv->pclk);
+}
+
+static int csi2host_start_vc(struct csi2host_priv *csi2priv, uint32_t vc)
+{
+	const struct csi2host_fmts *fmt;
+	struct media_pad *rpad;
+	int ret = 0;
+	u32 cfgr1 = 0, cfgr2 = 0;
+	u32 dt0 = 0, dt1 = 0;
+	u32 status;
+
+	/* Get DT codes of the two related source pads */
+	rpad = media_entity_remote_pad(&csi2priv->pads[1 + (2 * vc)]);
+	if (rpad)
+		dt0 = csi2priv->mf[1 + (2 * vc)].code;
+
+	rpad = media_entity_remote_pad(&csi2priv->pads[1 + (2 * vc) + 1]);
+	if (rpad)
+		dt1 = csi2priv->mf[1 + (2 * vc) + 1].code;
+
+	/* If either of the two output is JPEG, don't perform filtering */
+	if (dt0 == MEDIA_BUS_FMT_JPEG_1X8 || dt1 == MEDIA_BUS_FMT_JPEG_1X8) {
+		cfgr1 |= CSI_VCxCFGR1_ALLDT;
+		cfgr1 |= (CSI_VCxCFGRx_DTxFT_BPP8 << CSI_VCxCFGR1_CDTFT_SHIFT);
+		dev_dbg(csi2priv->dev, "VC%d: enable AllDT in BPP8 mode\n", vc);
+	} else {
+		/* Configure DT0 */
+		if (dt0) {
+			fmt = csi2host_code_to_fmt(dt0);
+			cfgr1 |= fmt->datatype << CSI_VCxCFGR1_DT0_SHIFT;
+			cfgr1 |= fmt->datatype_fmt << CSI_VCxCFGR1_DT0FT_SHIFT;
+			cfgr1 |= CSI_VCxCFGR1_DT0EN;
+			dev_dbg(csi2priv->dev, "VC%d: enable DT0 (0x%x) - DT0FT (0x%x)\n",
+				vc, fmt->datatype, fmt->datatype_fmt);
+		}
+
+		/* Configure DT1 */
+		if (dt1) {
+			fmt = csi2host_code_to_fmt(dt1);
+			cfgr2 |= fmt->datatype << CSI_VCxCFGR2_DT1_SHIFT;
+			cfgr2 |= fmt->datatype_fmt << CSI_VCxCFGR2_DT1FT_SHIFT;
+			cfgr1 |= CSI_VCxCFGR1_DT1EN;
+			dev_dbg(csi2priv->dev, "VC%d: enable DT1 (0x%x) - DT1FT (0x%x)\n",
+				vc, fmt->datatype, fmt->datatype_fmt);
+			writel_relaxed(cfgr2, csi2priv->base + CSI_VCxCFGR2(vc));
+		}
+	}
+
+	writel_relaxed(cfgr1, csi2priv->base + CSI_VCxCFGR1(vc));
+
+	/* Start the Virtual Channel if necessary */
+	if (!cfgr1)
+		return 0;
+
+	writel_relaxed(readl_relaxed(csi2priv->base + CSI_CR) | CSI_CR_VCxSTART(vc),
+		       csi2priv->base + CSI_CR);
+
+	ret = readl_relaxed_poll_timeout(csi2priv->base + CSI_SR0,
+					 status,
+					 status & CSI_SR0_VCxSTATEF(vc),
+					 1000, 1000000);
+	if (ret) {
+		dev_err(csi2priv->dev, "failed to start VC(%d)\n", vc);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int csi2host_stop_vc(struct csi2host_priv *csi2priv, uint32_t vc)
+{
+	int ret = 0;
+	u32 status;
+
+	/* Stop the Virtual Channel */
+	writel_relaxed(readl_relaxed(csi2priv->base + CSI_CR) | CSI_CR_VCxSTOP(vc),
+		       csi2priv->base + CSI_CR);
+
+	/*
+	 * FIXME - timeout is probably not correct. CSI2HOST will wait
+	 * until getting an EOF before resetting the VC
+	 */
+	ret = readl_relaxed_poll_timeout(csi2priv->base + CSI_SR0,
+					 status,
+					 !(status & CSI_SR0_VCxSTATEF(vc)),
+					 1000, 1000000);
+	if (ret) {
+		dev_err(csi2priv->dev, "failed to stop VC(%d)\n", vc);
+		return ret;
+	}
+
+	/* Disable all DTs */
+	writel_relaxed(0, csi2priv->base + CSI_VCxCFGR1(vc));
+	writel_relaxed(0, csi2priv->base + CSI_VCxCFGR2(vc));
+
+	return 0;
+}
+
+static int csi2host_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct csi2host_priv *csi2priv = v4l2_subdev_to_csi2priv(subdev);
+	int ret, i;
+
+	mutex_lock(&csi2priv->lock);
+
+	if (enable) {
+		/*
+		 * If we're not the first users, there's no need to
+		 * enable the whole controller.
+		 */
+		if (!csi2priv->count) {
+			ret = csi2host_start(csi2priv);
+			if (ret)
+				goto out;
+		}
+
+		/* Check and configure all 4 VCs */
+		for (i = 0; i < 4; i++) {
+			ret = csi2host_start_vc(csi2priv, i);
+			/* FIXME - better error handling needed here */
+			if (ret)
+				dev_err(csi2priv->dev, "Failed to start VC%d\n", i);
+		}
+
+		csi2priv->count++;
+	} else {
+		/* Stop all 4 VCs */
+		for (i = 0; i < 4; i++) {
+			ret = csi2host_stop_vc(csi2priv, i);
+			if (ret) {
+				dev_err(csi2priv->dev, "Failed to stop VC%d, turning off CSI to recover\n",
+					i);
+				csi2host_stop(csi2priv);
+			}
+		}
+
+		csi2priv->count--;
+
+		/*
+		 * Let the last user turn off the lights.
+		 */
+		if (!csi2priv->count)
+			csi2host_stop(csi2priv);
+	}
+
+out:
+	mutex_unlock(&csi2priv->lock);
+	return ret;
+}
+
+static int csi2host_enum_mbus_code(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *sd_state,
+				   struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index >= ARRAY_SIZE(csi2host_formats))
+		return -EINVAL;
+
+	code->code = csi2host_formats[code->index].code;
+	return 0;
+}
+
+static int csi2host_set_pad_format(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *state,
+				   struct v4l2_subdev_format *format)
+{
+	struct csi2host_priv *csi2priv = v4l2_subdev_to_csi2priv(sd);
+	const struct csi2host_fmts *fmt;
+
+	struct v4l2_mbus_framefmt *framefmt;
+
+	fmt = csi2host_code_to_fmt(format->format.code);
+	if (!fmt) {
+		dev_dbg(csi2priv->dev, "Unsupported code %d, use default\n",
+			format->format.code);
+		format->format.code = csi2host_formats[0].code;
+	}
+
+	if (format->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		csi2priv->mf[format->pad] = format->format;
+	} else {
+		framefmt = v4l2_subdev_get_try_format(sd, state, 0);
+		*framefmt = format->format;
+	}
+
+	return 0;
+}
+
+static int csi2host_get_pad_format(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *state,
+				   struct v4l2_subdev_format *format)
+{
+	struct csi2host_priv *csi2priv = v4l2_subdev_to_csi2priv(sd);
+
+	if (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		format->format = csi2priv->mf[format->pad];
+	else
+		format->format = *v4l2_subdev_get_try_format(sd, state, 0);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops csi2host_video_ops = {
+	.s_stream	= csi2host_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops csi2host_pad_ops = {
+	.enum_mbus_code	= csi2host_enum_mbus_code,
+	.set_fmt	= csi2host_set_pad_format,
+	.get_fmt	= csi2host_get_pad_format,
+};
+
+static const struct v4l2_subdev_ops csi2host_subdev_ops = {
+	.video		= &csi2host_video_ops,
+	.pad		= &csi2host_pad_ops,
+};
+
+static int csi2host_async_bound(struct v4l2_async_notifier *notifier,
+				struct v4l2_subdev *s_subdev,
+				struct v4l2_async_subdev *asd)
+{
+	struct v4l2_subdev *subdev = notifier->sd;
+	struct csi2host_priv *csi2priv = v4l2_subdev_to_csi2priv(subdev);
+	int remote_pad;
+
+	remote_pad = media_entity_get_fwnode_pad(&s_subdev->entity,
+						 s_subdev->fwnode,
+						 MEDIA_PAD_FL_SOURCE);
+	if (remote_pad < 0) {
+		dev_err(csi2priv->dev, "Couldn't find output pad for subdev %s\n",
+			s_subdev->name);
+		return remote_pad;
+	}
+
+	csi2priv->source_subdev = s_subdev;
+
+	return media_create_pad_link(&csi2priv->source_subdev->entity,
+				     remote_pad, &csi2priv->subdev.entity, 0,
+				     MEDIA_LNK_FL_ENABLED |
+				     MEDIA_LNK_FL_IMMUTABLE);
+}
+
+static const struct v4l2_async_notifier_operations csi2host_notifier_ops = {
+	.bound		= csi2host_async_bound,
+};
+
+#ifdef CSI2HOST_ERROR_HANDLING
+static irqreturn_t csi2host_irq_thread(int irq, void *arg)
+{
+	struct csi2host_priv *csi2priv = arg;
+
+	if (csi2priv->sr0 & CSI_SR0_SYNCERRF)
+		dev_dbg(csi2priv->dev, "Invalid synchronization error VC(%d)\n",
+			(csi2priv->err2 >> CSI_ERR2_SYNCVCERR_SHIFT) & VC_MASK);
+
+	if (csi2priv->sr0 & CSI_SR0_SPKTERRF)
+		dev_dbg(csi2priv->dev, "Short packet error VC(%d)/DT(%d)\n",
+			(csi2priv->err2 >> CSI_ERR2_SPKTVCERR_SHIFT) & VC_MASK,
+			(csi2priv->err2 >> CSI_ERR2_SPKTDTERR_SHIFT) & DT_MASK);
+
+	if (csi2priv->sr0 & CSI_SR0_IDERRF)
+		dev_dbg(csi2priv->dev, "Data type ID error VC(%d)/DT(%d)\n",
+			(csi2priv->err1 >> CSI_ERR1_IDVCERR_SHIFT) & VC_MASK,
+			(csi2priv->err1 >> CSI_ERR1_IDDTERR_SHIFT) & DT_MASK);
+
+	if (csi2priv->sr0 & CSI_SR0_CECCERRF)
+		dev_dbg(csi2priv->dev, "Corrected ECC error VC(%d)/DT(%d)\n",
+			(csi2priv->err1 >> CSI_ERR1_CECCVCERR_SHIFT) & VC_MASK,
+			(csi2priv->err1 >> CSI_ERR1_CECCDTERR_SHIFT) & DT_MASK);
+
+	if (csi2priv->sr0 & CSI_SR0_ECCERRF)
+		dev_dbg(csi2priv->dev, "ECC error\n");
+
+	if (csi2priv->sr0 & CSI_SR0_CRCERRF)
+		dev_dbg(csi2priv->dev, "CRC error VC(%d)/DT(%d)\n",
+			(csi2priv->err1 >> CSI_ERR1_CRCVCERR_SHIFT) & VC_MASK,
+			(csi2priv->err1 >> CSI_ERR1_CRCDTERR_SHIFT) & DT_MASK);
+
+	if (csi2priv->sr0 & CSI_SR0_CCFIFOFF)
+		dev_dbg(csi2priv->dev, "Clock changer FIFO full error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_ECTRLDL1F)
+		dev_dbg(csi2priv->dev, "L1: D-PHY_RX lane 1 control error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_ESYNCESCDL1F)
+		dev_dbg(csi2priv->dev, "L1: D-PHY_RX lane 1 low power data transmission synchronization error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_EESCDL1F)
+		dev_dbg(csi2priv->dev, "L1: D-PHY_RX lane 1 escape entry error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_ESOTSYNCDL1F)
+		dev_dbg(csi2priv->dev, "L1: Start of transmission synchronization error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_ESOTDL1F)
+		dev_dbg(csi2priv->dev, "L1: Start of transmission error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_ECTRLDL0F)
+		dev_dbg(csi2priv->dev, "L0: D-PHY_RX lane 0 control error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_ESYNCESCDL0F)
+		dev_dbg(csi2priv->dev, "L0: D-PHY_RX lane 0 low power data transmission synchronization error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_EESCDL0F)
+		dev_dbg(csi2priv->dev, "L0: D-PHY_RX lane 0 escape entry error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_ESOTSYNCDL0F)
+		dev_dbg(csi2priv->dev, "L0: Start of transmission synchronization error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_ESOTDL0F)
+		dev_dbg(csi2priv->dev, "L0: Start of transmission error\n");
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t csi2host_irq_callback(int irq, void *arg)
+{
+	struct csi2host_priv *csi2priv = arg;
+
+	csi2priv->sr0 = readl_relaxed(csi2priv->base + CSI_SR0);
+	csi2priv->sr1 = readl_relaxed(csi2priv->base + CSI_SR1);
+	csi2priv->err1 = readl_relaxed(csi2priv->base + CSI_ERR1);
+	csi2priv->err2 = readl_relaxed(csi2priv->base + CSI_ERR2);
+
+	/* Clear interrupt */
+	writel_relaxed(csi2priv->sr0 & CSI_SR0_ERRORS, csi2priv->base + CSI_FCR0);
+	writel_relaxed(csi2priv->sr1 & CSI_SR1_ERRORS, csi2priv->base + CSI_FCR1);
+
+	return IRQ_WAKE_THREAD;
+}
+#endif
+
+static int csi2host_get_resources(struct csi2host_priv *csi2priv,
+				  struct platform_device *pdev)
+{
+	struct resource *res;
+#ifdef CSI2HOST_ERROR_HANDLING
+	int irq, ret;
+#endif
+	u32 dev_cfg;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	csi2priv->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(csi2priv->base))
+		return dev_err_probe(&pdev->dev, PTR_ERR(csi2priv->base),
+				     "Failed to ioremap resource\n");
+
+	csi2priv->pclk = devm_clk_get(&pdev->dev, "pclk");
+	if (IS_ERR(csi2priv->pclk))
+		return dev_err_probe(&pdev->dev, PTR_ERR(csi2priv->pclk),
+				     "Couldn't get pclk\n");
+
+	csi2priv->txesc = devm_clk_get(&pdev->dev, "txesc");
+	if (IS_ERR(csi2priv->txesc))
+		return dev_err_probe(&pdev->dev, PTR_ERR(csi2priv->txesc),
+				     "Couldn't get txesc\n");
+
+	csi2priv->csi2phy = devm_clk_get(&pdev->dev, "csi2phy");
+	if (IS_ERR(csi2priv->csi2phy))
+		return dev_err_probe(&pdev->dev, PTR_ERR(csi2priv->csi2phy),
+				     "Couldn't get csi2phy\n");
+
+	csi2priv->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);
+	if (IS_ERR(csi2priv->rstc))
+		return dev_err_probe(&pdev->dev, PTR_ERR(csi2priv->rstc),
+				     "Couldn't get reset control\n");
+
+#ifdef CSI2HOST_ERROR_HANDLING
+	irq = platform_get_irq(pdev, 0);
+	if (irq <= 0)
+		return irq ? irq : -ENXIO;
+
+	ret = devm_request_threaded_irq(&pdev->dev, irq, csi2host_irq_callback,
+					csi2host_irq_thread, IRQF_ONESHOT,
+					dev_name(&pdev->dev), csi2priv);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret,
+				     "Unable to request irq");
+#endif
+
+	clk_prepare_enable(csi2priv->pclk);
+	dev_cfg = readl_relaxed(csi2priv->base + CSI_HWCFGR);
+	clk_disable_unprepare(csi2priv->pclk);
+
+	csi2priv->max_lanes = (dev_cfg & CSI_HWCFGR_LANES_MASK)
+				>> CSI_HWCFGR_LANES_SHIFT;
+	if (csi2priv->max_lanes > CSI2HOST_LANES_MAX) {
+		dev_err(&pdev->dev, "Invalid number of lanes: %u\n",
+			csi2priv->max_lanes);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int csi2host_parse_dt(struct csi2host_priv *csi2priv)
+{
+	struct v4l2_fwnode_endpoint v4l2_ep = { .bus_type = V4L2_MBUS_CSI2_DPHY };
+	struct v4l2_async_subdev *asd;
+	struct fwnode_handle *fwh;
+	struct device_node *ep;
+	int ret;
+
+	ep = of_graph_get_endpoint_by_regs(csi2priv->dev->of_node, 0, 0);
+	if (!ep)
+		return -EINVAL;
+
+	fwh = of_fwnode_handle(ep);
+	ret = v4l2_fwnode_endpoint_parse(fwh, &v4l2_ep);
+	if (ret) {
+		dev_err(csi2priv->dev, "Could not parse v4l2 endpoint\n");
+		of_node_put(ep);
+		return ret;
+	}
+	of_node_put(ep);
+
+	csi2priv->num_lanes = v4l2_ep.bus.mipi_csi2.num_data_lanes;
+	if (csi2priv->num_lanes > csi2priv->max_lanes) {
+		dev_err(csi2priv->dev, "Unsupported number of data-lanes: %d\n",
+			csi2priv->num_lanes);
+		of_node_put(ep);
+		return -EINVAL;
+	}
+
+	memcpy(csi2priv->lanes, v4l2_ep.bus.mipi_csi2.data_lanes,
+	       sizeof(csi2priv->lanes));
+
+	ep = of_graph_get_next_endpoint(csi2priv->dev->of_node, NULL);
+	if (!ep) {
+		dev_err(csi2priv->dev, "Failed to get next endpoint\n");
+		return -EINVAL;
+	}
+
+	v4l2_async_notifier_init(&csi2priv->notifier);
+
+	asd = v4l2_async_notifier_add_fwnode_remote_subdev
+		(&csi2priv->notifier, of_fwnode_handle(ep),
+		 struct v4l2_async_subdev);
+
+	of_node_put(ep);
+
+	if (IS_ERR(asd)) {
+		dev_err(csi2priv->dev, "Failed to add fwnode remote subdev\n");
+		return PTR_ERR(asd);
+	}
+
+	csi2priv->notifier.ops = &csi2host_notifier_ops;
+
+	ret = v4l2_async_subdev_notifier_register(&csi2priv->subdev,
+						  &csi2priv->notifier);
+	if (ret)
+		v4l2_async_notifier_cleanup(&csi2priv->notifier);
+
+	return ret;
+}
+
+static int csi2host_probe(struct platform_device *pdev)
+{
+	struct csi2host_priv *csi2priv;
+	unsigned int i;
+	int ret;
+
+	csi2priv = devm_kzalloc(&pdev->dev, sizeof(*csi2priv), GFP_KERNEL);
+	if (!csi2priv)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, csi2priv);
+	csi2priv->dev = &pdev->dev;
+	mutex_init(&csi2priv->lock);
+
+	ret = csi2host_get_resources(csi2priv, pdev);
+	if (ret)
+		goto err_free_priv;
+
+	ret = csi2host_parse_dt(csi2priv);
+	if (ret)
+		goto err_free_priv;
+
+	csi2priv->subdev.owner = THIS_MODULE;
+	csi2priv->subdev.dev = &pdev->dev;
+	v4l2_subdev_init(&csi2priv->subdev, &csi2host_subdev_ops);
+	v4l2_set_subdevdata(&csi2priv->subdev, &pdev->dev);
+	snprintf(csi2priv->subdev.name, V4L2_SUBDEV_NAME_SIZE, "%s.%s",
+		 KBUILD_MODNAME, dev_name(&pdev->dev));
+
+	/* Create our media pads */
+	csi2priv->subdev.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;
+	csi2priv->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	csi2priv->pads[CSI2HOST_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	csi2priv->mf[CSI2HOST_PAD_SINK].code = MEDIA_BUS_FMT_UYVY8_2X8;
+	for (i = CSI2HOST_PAD_SOURCE_STREAM0; i < CSI2HOST_PAD_MAX; i++) {
+		csi2priv->pads[i].flags = MEDIA_PAD_FL_SOURCE;
+		csi2priv->mf[i].code = MEDIA_BUS_FMT_UYVY8_2X8;
+	}
+
+	ret = media_entity_pads_init(&csi2priv->subdev.entity, CSI2HOST_PAD_MAX,
+				     csi2priv->pads);
+	if (ret)
+		goto err_cleanup;
+
+	ret = v4l2_async_register_subdev(&csi2priv->subdev);
+	if (ret < 0)
+		goto err_cleanup;
+
+	/* Reset device */
+	ret = reset_control_assert(csi2priv->rstc);
+	if (ret) {
+		ret = dev_err_probe(&pdev->dev, ret,
+				    "Failed to assert the reset line\n");
+		goto err_cleanup;
+	}
+
+	usleep_range(3000, 5000);
+
+	ret = reset_control_deassert(csi2priv->rstc);
+	if (ret) {
+		ret = dev_err_probe(&pdev->dev, ret,
+				    "Failed to deassert the reset line\n");
+		goto err_cleanup;
+	}
+
+	dev_info(&pdev->dev,
+		 "Probed CSI2HOST with %u lanes\n", csi2priv->num_lanes);
+
+	return 0;
+
+err_cleanup:
+	v4l2_async_notifier_cleanup(&csi2priv->notifier);
+err_free_priv:
+	return ret;
+}
+
+static int csi2host_remove(struct platform_device *pdev)
+{
+	struct csi2host_priv *csi2priv = platform_get_drvdata(pdev);
+
+	v4l2_async_unregister_subdev(&csi2priv->subdev);
+
+	return 0;
+}
+
+static const struct of_device_id csi2host_of_table[] = {
+	{ .compatible = "st,stm32-csi2host" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, csi2host_of_table);
+
+static struct platform_driver csi2host_driver = {
+	.probe	= csi2host_probe,
+	.remove	= csi2host_remove,
+
+	.driver	= {
+		.name		= "stm32-csi2host",
+		.of_match_table	= csi2host_of_table,
+	},
+};
+module_platform_driver(csi2host_driver);
+MODULE_AUTHOR("Alain Volmat <alain.volmat@foss.st.com>");
+MODULE_DESCRIPTION("STM32 CSI controller");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/stm32/stm32-dcmi.c b/drivers/media/platform/stm32/stm32-dcmi.c
index 611071864..c6d58e3ec 100644
--- a/drivers/media/platform/stm32/stm32-dcmi.c
+++ b/drivers/media/platform/stm32/stm32-dcmi.c
@@ -95,6 +95,9 @@ enum state {
 #define MIN_HEIGHT	16U
 #define MAX_HEIGHT	2592U
 
+/* DMA can sustain YUV 720p@15fps max */
+#define MAX_DMA_BANDWIDTH	(1280 * 720 * 2 * 15)
+
 #define TIMEOUT_MS	1000
 
 #define OVERRUN_ERROR_THRESHOLD	3
@@ -113,7 +116,7 @@ struct dcmi_framesize {
 struct dcmi_buf {
 	struct vb2_v4l2_buffer	vb;
 	bool			prepared;
-	dma_addr_t		paddr;
+	struct sg_table		sgt;
 	size_t			size;
 	struct list_head	list;
 };
@@ -157,6 +160,7 @@ struct stm32_dcmi {
 	enum state			state;
 	struct dma_chan			*dma_chan;
 	dma_cookie_t			dma_cookie;
+	u32				dma_max_burst;
 	u32				misr;
 	int				errors_count;
 	int				overrun_count;
@@ -326,13 +330,12 @@ static int dcmi_start_dma(struct stm32_dcmi *dcmi,
 	mutex_lock(&dcmi->dma_lock);
 
 	/* Prepare a DMA transaction */
-	desc = dmaengine_prep_slave_single(dcmi->dma_chan, buf->paddr,
-					   buf->size,
+	desc = dmaengine_prep_slave_sg(dcmi->dma_chan, buf->sgt.sgl,
+					   buf->sgt.nents,
 					   DMA_DEV_TO_MEM,
 					   DMA_PREP_INTERRUPT);
 	if (!desc) {
-		dev_err(dcmi->dev, "%s: DMA dmaengine_prep_slave_single failed for buffer phy=%pad size=%zu\n",
-			__func__, &buf->paddr, buf->size);
+		dev_err(dcmi->dev, "%s: DMA dmaengine_prep_slave_sg failed\n", __func__);
 		mutex_unlock(&dcmi->dma_lock);
 		return -EINVAL;
 	}
@@ -470,17 +473,12 @@ static irqreturn_t dcmi_irq_thread(int irq, void *arg)
 static irqreturn_t dcmi_irq_callback(int irq, void *arg)
 {
 	struct stm32_dcmi *dcmi = arg;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dcmi->irqlock, flags);
 
 	dcmi->misr = reg_read(dcmi->regs, DCMI_MIS);
 
 	/* Clear interrupt */
 	reg_set(dcmi->regs, DCMI_ICR, IT_FRAME | IT_OVR | IT_ERR);
 
-	spin_unlock_irqrestore(&dcmi->irqlock, flags);
-
 	return IRQ_WAKE_THREAD;
 }
 
@@ -524,6 +522,10 @@ static int dcmi_buf_prepare(struct vb2_buffer *vb)
 	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
 	struct dcmi_buf *buf = container_of(vbuf, struct dcmi_buf, vb);
 	unsigned long size;
+	unsigned int num_sgs;
+	dma_addr_t dma_buf;
+	struct scatterlist *sg;
+	int i, ret;
 
 	size = dcmi->fmt.fmt.pix.sizeimage;
 
@@ -537,15 +539,35 @@ static int dcmi_buf_prepare(struct vb2_buffer *vb)
 
 	if (!buf->prepared) {
 		/* Get memory addresses */
-		buf->paddr =
-			vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
 		buf->size = vb2_plane_size(&buf->vb.vb2_buf, 0);
-		buf->prepared = true;
+		if (buf->size <= dcmi->dma_max_burst)
+			num_sgs = 1;
+		else
+			num_sgs = DIV_ROUND_UP(buf->size, dcmi->dma_max_burst);
+
+		ret = sg_alloc_table(&buf->sgt, num_sgs, GFP_ATOMIC);
+		if (ret) {
+			dev_err(dcmi->dev, "sg table alloc failed\n");
+			return ret;
+		}
 
-		vb2_set_plane_payload(&buf->vb.vb2_buf, 0, buf->size);
+		dma_buf = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
 
 		dev_dbg(dcmi->dev, "buffer[%d] phy=%pad size=%zu\n",
-			vb->index, &buf->paddr, buf->size);
+			vb->index, &dma_buf, buf->size);
+
+		for_each_sg(buf->sgt.sgl, sg, num_sgs, i) {
+			size_t bytes = min_t(size_t, size, dcmi->dma_max_burst);
+
+			sg_dma_address(sg) = dma_buf;
+			sg_dma_len(sg) = bytes;
+			dma_buf += bytes;
+			size -= bytes;
+		}
+
+		buf->prepared = true;
+
+		vb2_set_plane_payload(&buf->vb.vb2_buf, 0, buf->size);
 	}
 
 	return 0;
@@ -579,6 +601,15 @@ static void dcmi_buf_queue(struct vb2_buffer *vb)
 	spin_unlock_irq(&dcmi->irqlock);
 }
 
+static void dcmi_buf_cleanup(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct dcmi_buf *buf = container_of(vbuf, struct dcmi_buf, vb);
+
+	if (buf->prepared)
+		sg_free_table(&buf->sgt);
+}
+
 static struct media_entity *dcmi_find_source(struct stm32_dcmi *dcmi)
 {
 	struct media_entity *entity = &dcmi->vdev->entity;
@@ -742,6 +773,33 @@ static int dcmi_start_streaming(struct vb2_queue *vq, unsigned int count)
 	if (ret)
 		goto err_media_pipeline_stop;
 
+	/* Check if snapshop mode is necessary for jpeg capture */
+	if (dcmi->sd_format->fourcc == V4L2_PIX_FMT_JPEG) {
+		unsigned int rate;
+		struct v4l2_streamparm p = {
+			.type = V4L2_BUF_TYPE_VIDEO_CAPTURE
+		};
+		struct v4l2_fract frame_interval = {1, 30};
+
+		ret = v4l2_g_parm_cap(dcmi->vdev, dcmi->source, &p);
+		if (!ret)
+			frame_interval = p.parm.capture.timeperframe;
+
+		rate = dcmi->fmt.fmt.pix.sizeimage *
+		       frame_interval.denominator / frame_interval.numerator;
+
+		/*
+		 * If rate exceed DMA capabilities, switch to snapshot mode
+		 * to ensure that current DMA transfer is elapsed before
+		 * capturing a new JPEG.
+		 */
+		if (rate > MAX_DMA_BANDWIDTH) {
+			val |= CR_CM;
+			dev_dbg(dcmi->dev, "Capture rate is too high for continuous mode (%d > %d bytes/s), switch to snapshot mode\n",
+				rate, MAX_DMA_BANDWIDTH);
+		}
+	}
+
 	spin_lock_irq(&dcmi->irqlock);
 
 	/* Set bus width */
@@ -795,10 +853,6 @@ static int dcmi_start_streaming(struct vb2_queue *vq, unsigned int count)
 	if (dcmi->do_crop)
 		dcmi_set_crop(dcmi);
 
-	/* Enable jpeg capture */
-	if (dcmi->sd_format->fourcc == V4L2_PIX_FMT_JPEG)
-		reg_set(dcmi->regs, DCMI_CR, CR_CM);/* Snapshot mode */
-
 	/* Enable dcmi */
 	reg_set(dcmi->regs, DCMI_CR, CR_ENABLE);
 
@@ -914,6 +968,7 @@ static const struct vb2_ops dcmi_video_qops = {
 	.buf_init		= dcmi_buf_init,
 	.buf_prepare		= dcmi_buf_prepare,
 	.buf_queue		= dcmi_buf_queue,
+	.buf_cleanup		= dcmi_buf_cleanup,
 	.start_streaming	= dcmi_start_streaming,
 	.stop_streaming		= dcmi_stop_streaming,
 	.wait_prepare		= vb2_ops_wait_prepare,
@@ -1793,6 +1848,15 @@ static int dcmi_graph_notify_bound(struct v4l2_async_notifier *notifier,
 
 	dev_dbg(dcmi->dev, "Subdev \"%s\" bound\n", subdev->name);
 
+	ret = video_register_device(dcmi->vdev, VFL_TYPE_VIDEO, -1);
+	if (ret) {
+		dev_err(dcmi->dev, "Failed to register video device\n");
+		return ret;
+	}
+
+	dev_dbg(dcmi->dev, "Device registered as %s\n",
+		video_device_node_name(dcmi->vdev));
+
 	/*
 	 * Link this sub-device to DCMI, it could be
 	 * a parallel camera sensor or a bridge
@@ -1805,10 +1869,11 @@ static int dcmi_graph_notify_bound(struct v4l2_async_notifier *notifier,
 				    &dcmi->vdev->entity, 0,
 				    MEDIA_LNK_FL_IMMUTABLE |
 				    MEDIA_LNK_FL_ENABLED);
-	if (ret)
+	if (ret) {
 		dev_err(dcmi->dev, "Failed to create media pad link with subdev \"%s\"\n",
 			subdev->name);
-	else
+		video_unregister_device(dcmi->vdev);
+	} else
 		dev_dbg(dcmi->dev, "DCMI is now linked to \"%s\"\n",
 			subdev->name);
 
@@ -1866,6 +1931,7 @@ static int dcmi_probe(struct platform_device *pdev)
 	struct stm32_dcmi *dcmi;
 	struct vb2_queue *q;
 	struct dma_chan *chan;
+	struct dma_slave_caps caps;
 	struct clk *mclk;
 	int irq;
 	int ret = 0;
@@ -1953,6 +2019,12 @@ static int dcmi_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	dcmi->dma_max_burst = UINT_MAX;
+	ret = dma_get_slave_caps(chan, &caps);
+	if (!ret && caps.max_sg_burst)
+		dcmi->dma_max_burst = caps.max_sg_burst	*
+				      DMA_SLAVE_BUSWIDTH_4_BYTES;
+
 	spin_lock_init(&dcmi->irqlock);
 	mutex_init(&dcmi->lock);
 	mutex_init(&dcmi->dma_lock);
@@ -2008,15 +2080,6 @@ static int dcmi_probe(struct platform_device *pdev)
 	}
 	dcmi->vdev->entity.flags |= MEDIA_ENT_FL_DEFAULT;
 
-	ret = video_register_device(dcmi->vdev, VFL_TYPE_VIDEO, -1);
-	if (ret) {
-		dev_err(dcmi->dev, "Failed to register video device\n");
-		goto err_media_entity_cleanup;
-	}
-
-	dev_dbg(dcmi->dev, "Device registered as %s\n",
-		video_device_node_name(dcmi->vdev));
-
 	/* Buffer queue */
 	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 	q->io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF;
@@ -2037,7 +2100,7 @@ static int dcmi_probe(struct platform_device *pdev)
 
 	ret = dcmi_graph_init(dcmi);
 	if (ret < 0)
-		goto err_media_entity_cleanup;
+		goto err_vb2_queue_release;
 
 	/* Reset device */
 	ret = reset_control_assert(dcmi->rstc);
@@ -2063,7 +2126,10 @@ static int dcmi_probe(struct platform_device *pdev)
 	return 0;
 
 err_cleanup:
+	v4l2_async_notifier_unregister(&dcmi->notifier);
 	v4l2_async_notifier_cleanup(&dcmi->notifier);
+err_vb2_queue_release:
+	vb2_queue_release(q);
 err_media_entity_cleanup:
 	media_entity_cleanup(&dcmi->vdev->entity);
 err_device_release:
@@ -2085,6 +2151,7 @@ static int dcmi_remove(struct platform_device *pdev)
 
 	v4l2_async_notifier_unregister(&dcmi->notifier);
 	v4l2_async_notifier_cleanup(&dcmi->notifier);
+	vb2_queue_release(&dcmi->queue);
 	media_entity_cleanup(&dcmi->vdev->entity);
 	v4l2_device_unregister(&dcmi->v4l2_dev);
 	media_device_cleanup(&dcmi->mdev);
diff --git a/drivers/media/platform/stm32/stm32-dcmipp/Makefile b/drivers/media/platform/stm32/stm32-dcmipp/Makefile
new file mode 100644
index 000000000..bd9e5c381
--- /dev/null
+++ b/drivers/media/platform/stm32/stm32-dcmipp/Makefile
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0
+stm32-dcmipp-y := dcmipp-core.o dcmipp-common.o
+
+obj-$(CONFIG_VIDEO_STM32_DCMIPP) += stm32-dcmipp.o
+obj-$(CONFIG_VIDEO_STM32_DCMIPP) += dcmipp-parallel.o dcmipp-byteproc.o dcmipp-bytecap.o dcmipp-isp.o dcmipp-colorconv.o dcmipp-pixelproc.o dcmipp-pixelcap.o
diff --git a/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-bytecap.c b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-bytecap.c
new file mode 100644
index 000000000..de51c9e76
--- /dev/null
+++ b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-bytecap.c
@@ -0,0 +1,1112 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include <linux/component.h>
+#include <linux/delay.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mc.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "dcmipp-common.h"
+
+#define DCMIPP_BYTECAP_DRV_NAME "dcmipp-bytecap"
+
+#define DCMIPP_PRSR (0x1F8)
+#define DCMIPP_CMIER (0x3F0)
+#define DCMIPP_CMIER_P0FRAMEIE BIT(9)
+#define DCMIPP_CMIER_P0VSYNCIE BIT(10)
+#define DCMIPP_CMIER_P0OVRIE BIT(15)
+#define DCMIPP_CMIER_P0ALL (DCMIPP_CMIER_P0VSYNCIE |\
+			    DCMIPP_CMIER_P0FRAMEIE |\
+			    DCMIPP_CMIER_P0OVRIE)
+#define DCMIPP_CMSR1 (0x3F4)
+#define DCMIPP_CMSR2 (0x3F8)
+#define DCMIPP_CMSR2_P0FRAMEF BIT(9)
+#define DCMIPP_CMSR2_P0VSYNCF BIT(10)
+#define DCMIPP_CMSR2_P0OVRF BIT(15)
+#define DCMIPP_CMFCR (0x3FC)
+#define DCMIPP_P0FSCR (0x404)
+#define DCMIPP_P0FSCR_PIPEN BIT(31)
+#define DCMIPP_P0FCTCR (0x500)
+#define DCMIPP_P0FCTCR_CPTREQ BIT(3)
+#define DCMIPP_P0DCCNTR (0x5B0)
+#define DCMIPP_P0DCLMTR (0x5B4)
+#define DCMIPP_P0DCLMTR_ENABLE BIT(31)
+#define DCMIPP_P0DCLMTR_LIMIT_MASK GENMASK(23, 0)
+#define DCMIPP_P0PPM0AR1 (0x5C4)
+#define DCMIPP_P0SR (0x5F8)
+#define DCMIPP_P0SR_CPTACT BIT(23)
+
+struct dcmipp_bytecap_pix_map {
+	unsigned int code;
+	u32 pixelformat;
+};
+
+#define PIXMAP_MBUS_PFMT(mbus, fmt)				\
+		{						\
+			.code = MEDIA_BUS_FMT_##mbus,		\
+			.pixelformat = V4L2_PIX_FMT_##fmt	\
+		}
+
+static const struct dcmipp_bytecap_pix_map dcmipp_bytecap_pix_map_list[] = {
+	PIXMAP_MBUS_PFMT(RGB565_2X8_LE, RGB565),
+	PIXMAP_MBUS_PFMT(YUYV8_2X8, YUYV),
+	PIXMAP_MBUS_PFMT(YVYU8_2X8, YVYU),
+	PIXMAP_MBUS_PFMT(UYVY8_2X8, UYVY),
+	PIXMAP_MBUS_PFMT(VYUY8_2X8, VYUY),
+	PIXMAP_MBUS_PFMT(Y8_1X8, GREY),
+	PIXMAP_MBUS_PFMT(SBGGR8_1X8, SBGGR8),
+	PIXMAP_MBUS_PFMT(SGBRG8_1X8, SGBRG8),
+	PIXMAP_MBUS_PFMT(SGRBG8_1X8, SGRBG8),
+	PIXMAP_MBUS_PFMT(SRGGB8_1X8, SRGGB8),
+	PIXMAP_MBUS_PFMT(JPEG_1X8, JPEG),
+};
+
+static const struct dcmipp_bytecap_pix_map *dcmipp_bytecap_pix_map_by_pixelformat
+						(u32 pixelformat)
+{
+	const struct dcmipp_bytecap_pix_map *l = dcmipp_bytecap_pix_map_list;
+	unsigned int size = ARRAY_SIZE(dcmipp_bytecap_pix_map_list);
+	unsigned int i;
+
+	for (i = 0; i < size; i++) {
+		if (l[i].pixelformat == pixelformat)
+			return &l[i];
+	}
+
+	return NULL;
+}
+
+static const struct dcmipp_bytecap_pix_map *dcmipp_bytecap_pix_map_by_index(unsigned int i)
+{
+	const struct dcmipp_bytecap_pix_map *l = dcmipp_bytecap_pix_map_list;
+	unsigned int size = ARRAY_SIZE(dcmipp_bytecap_pix_map_list);
+
+	if (i >= size)
+		return NULL;
+
+	return &l[i];
+}
+
+struct dcmipp_buf {
+	struct vb2_v4l2_buffer	vb;
+	bool			prepared;
+	dma_addr_t		paddr;
+	size_t			size;
+	struct list_head	list;
+};
+
+enum state {
+	STOPPED = 0,
+	WAIT_FOR_BUFFER,
+	RUNNING,
+};
+
+struct dcmipp_bytecap_device {
+	struct dcmipp_ent_device ved;
+	struct video_device vdev;
+	struct device *dev;
+	struct device *cdev;
+	struct v4l2_pix_format format;
+	struct vb2_queue queue;
+	struct list_head buffers;
+	/* Protects the access of variables shared within the interrupt */
+	spinlock_t irqlock;
+	/* Protect this data structure */
+	struct mutex lock;
+	u32 sequence;
+	struct media_pipeline pipe;
+
+	enum state state;
+
+	/*
+	 * DCMIPP driver is handling 2 buffers
+	 * active: buffer into which DCMIPP is currently writing into
+	 * next: buffer given to the DCMIPP and which will become
+	 *       automatically active on next VSYNC
+	 */
+	struct dcmipp_buf *active, *next;
+
+	void __iomem *regs;
+	struct reset_control *rstc;
+
+	u32 cmier;
+	u32 cmsr2;
+
+	int errors_count;
+	int limit_count;
+	int overrun_count;
+	int buffers_count;
+	int vsync_count;
+	int frame_count;
+	int it_count;
+	int underrun_count;
+	int nactive_count;
+};
+
+static const struct v4l2_pix_format fmt_default = {
+	.width = DCMIPP_FMT_WIDTH_DEFAULT,
+	.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	.pixelformat = V4L2_PIX_FMT_RGB565,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = DCMIPP_COLORSPACE_DEFAULT,
+	.ycbcr_enc = DCMIPP_YCBCR_ENC_DEFAULT,
+	.quantization = DCMIPP_QUANTIZATION_DEFAULT,
+	.xfer_func = DCMIPP_XFER_FUNC_DEFAULT,
+};
+
+static inline int frame_size(u32 width, u32 height, u32 format)
+{
+	switch (format) {
+	case V4L2_PIX_FMT_SBGGR8:
+	case V4L2_PIX_FMT_SGBRG8:
+	case V4L2_PIX_FMT_SGRBG8:
+	case V4L2_PIX_FMT_SRGGB8:
+	case V4L2_PIX_FMT_GREY:
+		return (width * height);
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_YVYU:
+	case V4L2_PIX_FMT_UYVY:
+	case V4L2_PIX_FMT_VYUY:
+		return (width * height * 2);
+	case V4L2_PIX_FMT_JPEG:
+		return (width * height);
+	default:
+		return 0;
+	}
+}
+
+static inline int frame_stride(u32 width, u32 format)
+{
+	switch (format) {
+	case V4L2_PIX_FMT_SBGGR8:
+	case V4L2_PIX_FMT_SGBRG8:
+	case V4L2_PIX_FMT_SGRBG8:
+	case V4L2_PIX_FMT_SRGGB8:
+	case V4L2_PIX_FMT_GREY:
+	case V4L2_PIX_FMT_JPEG:
+		return width;
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_YVYU:
+	case V4L2_PIX_FMT_UYVY:
+	case V4L2_PIX_FMT_VYUY:
+		return (width * 2);
+	default:
+		return 0;
+	}
+}
+
+static inline int hdw_pixel_alignment(u32 format)
+{
+	/* 16 bytes alignment required by hardware */
+	switch (format) {
+	case V4L2_PIX_FMT_SBGGR8:
+	case V4L2_PIX_FMT_SGBRG8:
+	case V4L2_PIX_FMT_SGRBG8:
+	case V4L2_PIX_FMT_SRGGB8:
+	case V4L2_PIX_FMT_GREY:
+	case V4L2_PIX_FMT_JPEG:
+		return 4;/* 2^4 = 16 pixels = 16 bytes */
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_YVYU:
+	case V4L2_PIX_FMT_UYVY:
+	case V4L2_PIX_FMT_VYUY:
+		return 3;/* 2^3  = 8 pixels = 16 bytes */
+	default:
+		return 0;
+	}
+}
+
+static int dcmipp_bytecap_querycap(struct file *file, void *priv,
+				   struct v4l2_capability *cap)
+{
+	strscpy(cap->driver, DCMIPP_PDEV_NAME, sizeof(cap->driver));
+	strscpy(cap->card, KBUILD_MODNAME, sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info),
+		 "platform:%s", DCMIPP_PDEV_NAME);
+
+	return 0;
+}
+
+static void dcmipp_bytecap_get_format(struct dcmipp_ent_device *ved,
+				      struct v4l2_pix_format *fmt)
+{
+	struct dcmipp_bytecap_device *vcap = container_of(ved, struct dcmipp_bytecap_device,
+						    ved);
+
+	*fmt = vcap->format;
+}
+
+static int dcmipp_bytecap_g_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct dcmipp_bytecap_device *vcap = video_drvdata(file);
+
+	f->fmt.pix = vcap->format;
+
+	return 0;
+}
+
+static int dcmipp_bytecap_try_fmt_vid_cap(struct file *file, void *priv,
+					  struct v4l2_format *f)
+{
+	struct dcmipp_bytecap_device *vcap = video_drvdata(file);
+	struct v4l2_pix_format *format = &f->fmt.pix;
+	const struct dcmipp_bytecap_pix_map *vpix;
+	u32 in_w, in_h;
+
+	/* Don't accept a pixelformat that is not on the table */
+	vpix = dcmipp_bytecap_pix_map_by_pixelformat(format->pixelformat);
+	if (!vpix)
+		format->pixelformat = fmt_default.pixelformat;
+
+	/* Adjust width & height */
+	in_w = format->width;
+	in_h = format->height;
+	v4l_bound_align_image(&format->width,
+			      DCMIPP_FRAME_MIN_WIDTH, DCMIPP_FRAME_MAX_WIDTH,
+			      hdw_pixel_alignment(format->pixelformat),
+			      &format->height,
+			      DCMIPP_FRAME_MIN_HEIGHT, DCMIPP_FRAME_MAX_HEIGHT,
+			      hdw_pixel_alignment(format->pixelformat),
+			      0);
+	if (format->width != in_w || format->height != in_h)
+		dev_dbg(vcap->dev,
+			"resolution updated: %dx%d -> %dx%d\n",
+			in_w, in_h, format->width, format->height);
+
+	format->bytesperline = frame_stride(format->width, format->pixelformat);
+	format->sizeimage = frame_size(format->width, format->height, format->pixelformat);
+
+	if (format->field == V4L2_FIELD_ANY)
+		format->field = fmt_default.field;
+
+	dcmipp_colorimetry_clamp(format);
+
+	return 0;
+}
+
+static int dcmipp_bytecap_s_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct dcmipp_bytecap_device *vcap = video_drvdata(file);
+	int ret;
+
+	/* Do not change the format while stream is on */
+	if (vb2_is_busy(&vcap->queue))
+		return -EBUSY;
+
+	ret = dcmipp_bytecap_try_fmt_vid_cap(file, priv, f);
+	if (ret)
+		return ret;
+
+	dev_dbg(vcap->dev, "%s: format update: old:%dx%d (0x%x, %d, %d, %d, %d) new:%dx%d (0x%x, %d, %d, %d, %d)\n",
+		vcap->vdev.name,
+		/* old */
+		vcap->format.width, vcap->format.height,
+		vcap->format.pixelformat, vcap->format.colorspace,
+		vcap->format.quantization, vcap->format.xfer_func,
+		vcap->format.ycbcr_enc,
+		/* new */
+		f->fmt.pix.width, f->fmt.pix.height,
+		f->fmt.pix.pixelformat, f->fmt.pix.colorspace,
+		f->fmt.pix.quantization, f->fmt.pix.xfer_func,
+		f->fmt.pix.ycbcr_enc);
+
+	vcap->format = f->fmt.pix;
+
+	return 0;
+}
+
+static int dcmipp_bytecap_enum_fmt_vid_cap(struct file *file, void *priv,
+					   struct v4l2_fmtdesc *f)
+{
+	const struct dcmipp_bytecap_pix_map *vpix = dcmipp_bytecap_pix_map_by_index(f->index);
+
+	if (!vpix)
+		return -EINVAL;
+
+	f->pixelformat = vpix->pixelformat;
+
+	return 0;
+}
+
+static int dcmipp_bytecap_enum_framesizes(struct file *file, void *fh,
+					  struct v4l2_frmsizeenum *fsize)
+{
+	const struct dcmipp_bytecap_pix_map *vpix;
+
+	if (fsize->index)
+		return -EINVAL;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_bytecap_pix_map_by_pixelformat(fsize->pixel_format);
+	if (!vpix)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;
+	fsize->stepwise.min_width = DCMIPP_FRAME_MIN_WIDTH;
+	fsize->stepwise.max_width = DCMIPP_FRAME_MAX_WIDTH;
+	fsize->stepwise.min_height = DCMIPP_FRAME_MIN_HEIGHT;
+	fsize->stepwise.max_height = DCMIPP_FRAME_MAX_HEIGHT;
+	fsize->stepwise.step_width = 1;
+	fsize->stepwise.step_height = 1;
+
+	return 0;
+}
+
+/* TODO - based on the explanation text, should also use v4l2_pipeline_link_notify */
+static int dcmipp_bytecap_open(struct file *file)
+{
+	struct dcmipp_bytecap_device *vcap = video_drvdata(file);
+	int ret;
+
+	ret = mutex_lock_interruptible(&vcap->lock);
+	if (ret)
+		return ret;
+
+	ret = v4l2_fh_open(file);
+	if (ret)
+		goto err_unlock;
+
+	ret = v4l2_pipeline_pm_get(&vcap->vdev.entity);
+	if (ret)
+		goto err_close;
+
+	mutex_unlock(&vcap->lock);
+
+	return 0;
+
+err_close:
+	v4l2_fh_release(file);
+err_unlock:
+	mutex_unlock(&vcap->lock);
+
+	return ret;
+}
+
+static int dcmipp_bytecap_close(struct file *file)
+{
+	struct dcmipp_bytecap_device *vcap = video_drvdata(file);
+
+	vb2_fop_release(file);
+
+	v4l2_pipeline_pm_put(&vcap->vdev.entity);
+
+	return 0;
+}
+
+static const struct v4l2_file_operations dcmipp_bytecap_fops = {
+	.owner		= THIS_MODULE,
+	.open		= dcmipp_bytecap_open,
+	.release	= dcmipp_bytecap_close,
+	.read           = vb2_fop_read,
+	.poll		= vb2_fop_poll,
+	.unlocked_ioctl = video_ioctl2,
+	.mmap           = vb2_fop_mmap,
+};
+
+static const struct v4l2_ioctl_ops dcmipp_bytecap_ioctl_ops = {
+	.vidioc_querycap = dcmipp_bytecap_querycap,
+
+	.vidioc_g_fmt_vid_cap = dcmipp_bytecap_g_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap = dcmipp_bytecap_s_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap = dcmipp_bytecap_try_fmt_vid_cap,
+	.vidioc_enum_fmt_vid_cap = dcmipp_bytecap_enum_fmt_vid_cap,
+	.vidioc_enum_framesizes = dcmipp_bytecap_enum_framesizes,
+
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+};
+
+static int dcmipp_pipeline_s_stream(struct dcmipp_bytecap_device *vcap,
+				    int state)
+{
+	struct media_entity *entity = &vcap->vdev.entity;
+	struct v4l2_subdev *subdev;
+	struct media_pad *pad;
+	int ret;
+
+	/* Start/stop all entities within pipeline */
+	while (1) {
+		pad = &entity->pads[0];
+		if (!(pad->flags & MEDIA_PAD_FL_SINK))
+			break;
+
+		pad = media_entity_remote_pad(pad);
+		if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
+			break;
+
+		entity = pad->entity;
+		subdev = media_entity_to_v4l2_subdev(entity);
+
+		ret = v4l2_subdev_call(subdev, video, s_stream, state);
+		if (ret < 0 && ret != -ENOIOCTLCMD) {
+			dev_err(vcap->dev, "%s: \"%s\" failed to %s streaming (%d)\n",
+				__func__, subdev->name,
+				state ? "start" : "stop", ret);
+
+			if (!state)
+				v4l2_subdev_call(subdev, core, s_power, state);
+
+			return ret;
+		}
+
+		dev_dbg(vcap->dev, "\"%s\" is %s\n",
+			subdev->name, state ? "started" : "stopped");
+	}
+
+	return 0;
+}
+
+static void dcmipp_start_capture(struct dcmipp_bytecap_device *vcap,
+				 struct dcmipp_buf *buf)
+{
+	/* Set buffer address */
+	reg_write(vcap, DCMIPP_P0PPM0AR1, buf->paddr);
+	dev_dbg(vcap->dev, "Write [%d] %p phy=%pad\n", buf->vb.vb2_buf.index, buf, &buf->paddr);
+
+	/* Set buffer size */
+	reg_write(vcap, DCMIPP_P0DCLMTR, DCMIPP_P0DCLMTR_ENABLE |
+		  ((buf->size / 4) & DCMIPP_P0DCLMTR_LIMIT_MASK));
+
+	/* Capture request */
+	reg_set(vcap, DCMIPP_P0FCTCR, DCMIPP_P0FCTCR_CPTREQ);
+}
+
+static int dcmipp_bytecap_start_streaming(struct vb2_queue *vq,
+					  unsigned int count)
+{
+	struct dcmipp_bytecap_device *vcap = vb2_get_drv_priv(vq);
+	struct media_entity *entity = &vcap->vdev.entity;
+	struct dcmipp_buf *buf, *node;
+	int ret;
+
+	vcap->sequence = 0;
+	vcap->errors_count = 0;
+	vcap->limit_count = 0;
+	vcap->overrun_count = 0;
+	vcap->buffers_count = 0;
+	vcap->vsync_count = 0;
+	vcap->frame_count = 0;
+	vcap->it_count = 0;
+	vcap->underrun_count = 0;
+	vcap->nactive_count = 0;
+
+	ret = pm_runtime_get_sync(vcap->cdev);
+	if (ret < 0) {
+		dev_err(vcap->dev, "%s: Failed to start streaming, cannot get sync (%d)\n",
+			__func__, ret);
+		goto err_pm_put;
+	}
+
+	/* Start the media pipeline */
+	ret = media_pipeline_start(entity, &vcap->pipe);
+	if (ret) {
+		dev_err(vcap->dev, "%s: Failed to start streaming, media pipeline start error (%d)\n",
+			__func__, ret);
+		goto err_pm_put;
+	}
+
+	/* Start all the elements within pipeline */
+	ret = dcmipp_pipeline_s_stream(vcap, 1);
+	if (ret)
+		goto err_media_pipeline_stop;
+
+	spin_lock_irq(&vcap->irqlock);
+
+	/* Enable pipe at the end of programming */
+	reg_set(vcap, DCMIPP_P0FSCR, DCMIPP_P0FSCR_PIPEN);
+
+	/*
+	 * Start capture if at least one buffer has been queued,
+	 * otherwise start is deferred at next buffer queueing
+	 */
+	buf = list_first_entry_or_null(&vcap->buffers, typeof(*buf), list);
+	if (!buf) {
+		dev_dbg(vcap->dev, "Start streaming is deferred to next buffer queueing\n");
+		vcap->next = NULL;
+		vcap->state = WAIT_FOR_BUFFER;
+		spin_unlock_irq(&vcap->irqlock);
+		return 0;
+	}
+	vcap->next = buf;
+	dev_dbg(vcap->dev, "Start with next [%d] %p phy=%pad\n",
+		buf->vb.vb2_buf.index, buf, &buf->paddr);
+
+	/* Start capture */
+	dcmipp_start_capture(vcap, buf);
+
+	/* Enable interruptions */
+	vcap->cmier |= DCMIPP_CMIER_P0ALL;
+	reg_set(vcap, DCMIPP_CMIER, vcap->cmier);
+
+	vcap->state = RUNNING;
+
+	spin_unlock_irq(&vcap->irqlock);
+
+	return 0;
+
+err_media_pipeline_stop:
+	media_pipeline_stop(entity);
+err_pm_put:
+	pm_runtime_put(vcap->cdev);
+	spin_lock_irq(&vcap->irqlock);
+	/*
+	 * Return all buffers to vb2 in QUEUED state.
+	 * This will give ownership back to userspace
+	 */
+	list_for_each_entry_safe(buf, node, &vcap->buffers, list) {
+		list_del_init(&buf->list);
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);
+	}
+	vcap->active = NULL;
+	spin_unlock_irq(&vcap->irqlock);
+
+	return ret;
+}
+
+static void dcmipp_dump_status(struct dcmipp_bytecap_device *vcap)
+{
+	struct device *dev = vcap->dev;
+
+	dev_dbg(dev, "[DCMIPP_PRSR]  =%#10.8x\n", reg_read(vcap, DCMIPP_PRSR));
+	dev_dbg(dev, "[DCMIPP_P0SR] =%#10.8x\n", reg_read(vcap, DCMIPP_P0SR));
+	dev_dbg(dev, "[DCMIPP_P0DCCNTR]=%#10.8x\n",
+		reg_read(vcap, DCMIPP_P0DCCNTR));
+	dev_dbg(dev, "[DCMIPP_CMSR1] =%#10.8x\n", reg_read(vcap, DCMIPP_CMSR1));
+	dev_dbg(dev, "[DCMIPP_CMSR2] =%#10.8x\n", reg_read(vcap, DCMIPP_CMSR2));
+}
+
+/*
+ * Stop the stream engine. Any remaining buffers in the stream queue are
+ * dequeued and passed on to the vb2 framework marked as STATE_ERROR.
+ */
+static void dcmipp_bytecap_stop_streaming(struct vb2_queue *vq)
+{
+	struct dcmipp_bytecap_device *vcap = vb2_get_drv_priv(vq);
+	struct dcmipp_buf *buf, *node;
+	int ret;
+	u32 status;
+
+	dcmipp_pipeline_s_stream(vcap, 0);
+
+	/* Stop the media pipeline */
+	media_pipeline_stop(&vcap->vdev.entity);
+
+	/* Disable interruptions */
+	reg_clear(vcap, DCMIPP_CMIER, vcap->cmier);
+
+	/* Stop capture */
+	reg_clear(vcap, DCMIPP_P0FCTCR, DCMIPP_P0FCTCR_CPTREQ);
+
+	/* Wait until CPTACT become 0 */
+	ret = readl_relaxed_poll_timeout(vcap->regs + DCMIPP_P0SR,
+					 status,
+					 !(status & DCMIPP_P0SR_CPTACT),
+					 20, 1000);
+	if (ret)
+		dev_warn(vcap->dev, "Timeout when stopping\n");
+
+	/* Disable pipe */
+	reg_clear(vcap, DCMIPP_P0FSCR, DCMIPP_P0FSCR_PIPEN);
+
+	spin_lock_irq(&vcap->irqlock);
+
+	/* Return all queued buffers to vb2 in ERROR state */
+	list_for_each_entry_safe(buf, node, &vcap->buffers, list) {
+		list_del_init(&buf->list);
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+	INIT_LIST_HEAD(&vcap->buffers);
+
+	vcap->active = NULL;
+	vcap->state = STOPPED;
+
+	dcmipp_dump_status(vcap);
+
+	spin_unlock_irq(&vcap->irqlock);
+
+	pm_runtime_put(vcap->cdev);
+
+	if (ret) {
+		/* Reset IP on timeout */
+		if (reset_control_assert(vcap->rstc))
+			dev_warn(vcap->dev, "Failed to assert the reset line\n");
+
+		usleep_range(3000, 5000);
+
+		if (reset_control_deassert(vcap->rstc))
+			dev_warn(vcap->dev, "Failed to deassert the reset line\n");
+	}
+
+	if (vcap->errors_count)
+		dev_warn(vcap->dev, "Some errors found while streaming: errors=%d (overrun=%d, limit=%d, nactive=%d), underrun=%d, buffers=%d\n",
+			 vcap->errors_count, vcap->overrun_count, vcap->limit_count,
+			 vcap->nactive_count, vcap->underrun_count, vcap->buffers_count);
+	dev_dbg(vcap->dev, "Stop streaming, errors=%d (overrun=%d, limit=%d, nactive=%d), underrun=%d, vsync=%d, frame=%d, buffers=%d, it=%d\n",
+		vcap->errors_count, vcap->overrun_count, vcap->limit_count,
+		vcap->nactive_count, vcap->underrun_count, vcap->vsync_count,
+		vcap->frame_count, vcap->buffers_count, vcap->it_count);
+}
+
+static int dcmipp_bytecap_buf_prepare(struct vb2_buffer *vb)
+{
+	struct dcmipp_bytecap_device *vcap =  vb2_get_drv_priv(vb->vb2_queue);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct dcmipp_buf *buf = container_of(vbuf, struct dcmipp_buf, vb);
+	unsigned long size;
+
+	size = vcap->format.sizeimage;
+
+	if (vb2_plane_size(vb, 0) < size) {
+		dev_err(vcap->dev, "%s data will not fit into plane (%lu < %lu)\n",
+			__func__, vb2_plane_size(vb, 0), size);
+		return -EINVAL;
+	}
+
+	vb2_set_plane_payload(vb, 0, size);
+
+	if (!buf->prepared) {
+		/* Get memory addresses */
+		buf->paddr =
+			vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
+		buf->size = vb2_plane_size(&buf->vb.vb2_buf, 0);
+		buf->prepared = true;
+
+		vb2_set_plane_payload(&buf->vb.vb2_buf, 0, buf->size);
+
+		dev_dbg(vcap->dev, "Setup [%d] phy=%pad size=%zu\n",
+			vb->index, &buf->paddr, buf->size);
+	}
+
+	return 0;
+}
+
+static void dcmipp_bytecap_buf_queue(struct vb2_buffer *vb2_buf)
+{
+	struct dcmipp_bytecap_device *vcap =
+		vb2_get_drv_priv(vb2_buf->vb2_queue);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb2_buf);
+	struct dcmipp_buf *buf = container_of(vbuf, struct dcmipp_buf, vb);
+
+	spin_lock_irq(&vcap->irqlock);
+	list_add_tail(&buf->list, &vcap->buffers);
+
+	dev_dbg(vcap->dev, "Queue [%d] %p phy=%pad\n", buf->vb.vb2_buf.index, buf, &buf->paddr);
+
+	if (vcap->state == WAIT_FOR_BUFFER) {
+		vcap->next = buf;
+		dev_dbg(vcap->dev, "Restart with next [%d] %p phy=%pad\n",
+			buf->vb.vb2_buf.index, buf, &buf->paddr);
+
+		dcmipp_start_capture(vcap, buf);
+
+		vcap->state = RUNNING;
+
+		spin_unlock_irq(&vcap->irqlock);
+
+		return;
+	}
+
+	spin_unlock_irq(&vcap->irqlock);
+}
+
+static int dcmipp_bytecap_queue_setup(struct vb2_queue *vq,
+				      unsigned int *nbuffers,
+				      unsigned int *nplanes,
+				      unsigned int sizes[],
+				      struct device *alloc_devs[])
+{
+	struct dcmipp_bytecap_device *vcap = vb2_get_drv_priv(vq);
+	unsigned int size;
+
+	size = vcap->format.sizeimage;
+
+	/* Make sure the image size is large enough */
+	if (*nplanes)
+		return sizes[0] < vcap->format.sizeimage ? -EINVAL : 0;
+
+	*nplanes = 1;
+	sizes[0] = vcap->format.sizeimage;
+
+	dev_dbg(vcap->dev, "Setup queue, count=%d, size=%d\n",
+		*nbuffers, size);
+
+	return 0;
+}
+
+static int dcmipp_bytecap_buf_init(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct dcmipp_buf *buf = container_of(vbuf, struct dcmipp_buf, vb);
+
+	INIT_LIST_HEAD(&buf->list);
+
+	return 0;
+}
+
+static const struct vb2_ops dcmipp_bytecap_qops = {
+	.start_streaming	= dcmipp_bytecap_start_streaming,
+	.stop_streaming		= dcmipp_bytecap_stop_streaming,
+	.buf_init		= dcmipp_bytecap_buf_init,
+	.buf_prepare		= dcmipp_bytecap_buf_prepare,
+	.buf_queue		= dcmipp_bytecap_buf_queue,
+	.queue_setup		= dcmipp_bytecap_queue_setup,
+	/*
+	 * Since q->lock is set we can use the standard
+	 * vb2_ops_wait_prepare/finish helper functions.
+	 */
+	.wait_prepare		= vb2_ops_wait_prepare,
+	.wait_finish		= vb2_ops_wait_finish,
+};
+
+static const struct media_entity_operations dcmipp_bytecap_mops = {
+	.link_validate		= dcmipp_link_validate,
+};
+
+static void dcmipp_bytecap_release(struct video_device *vdev)
+{
+	struct dcmipp_bytecap_device *vcap =
+		container_of(vdev, struct dcmipp_bytecap_device, vdev);
+
+	dcmipp_pads_cleanup(vcap->ved.pads);
+	kfree(vcap);
+}
+
+static void dcmipp_bytecap_comp_unbind(struct device *comp,
+				       struct device *master,
+				       void *master_data)
+{
+	struct dcmipp_ent_device *ved = dev_get_drvdata(comp);
+	struct dcmipp_bytecap_device *vcap =
+		container_of(ved, struct dcmipp_bytecap_device, ved);
+
+	media_entity_cleanup(ved->ent);
+	vb2_video_unregister_device(&vcap->vdev);
+}
+
+static void dcmipp_buffer_done(struct dcmipp_bytecap_device *vcap,
+			       struct dcmipp_buf *buf,
+			       size_t bytesused,
+			       int err)
+{
+	struct vb2_v4l2_buffer *vbuf;
+
+	list_del_init(&buf->list);
+
+	vbuf = &buf->vb;
+
+	vbuf->sequence = vcap->sequence++;
+	vbuf->field = V4L2_FIELD_NONE;
+	vbuf->vb2_buf.timestamp = ktime_get_ns();
+	vb2_set_plane_payload(&vbuf->vb2_buf, 0, bytesused);
+	vb2_buffer_done(&vbuf->vb2_buf,
+			err ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);
+	dev_dbg(vcap->dev, "Done  [%d] %p phy=%pad\n", buf->vb.vb2_buf.index, buf, &buf->paddr);
+	vcap->buffers_count++;
+}
+
+/* irqlock must be held */
+static void dcmipp_bytecap_set_next_frame_or_stop(struct dcmipp_bytecap_device *vcap)
+{
+	if (!vcap->next && list_is_singular(&vcap->buffers)) {
+		/*
+		 * If there is no available buffer (none or a single one in the list while two
+		 * are expected), stop the capture (effective for next frame). On-going frame
+		 * capture will continue till FRAME END but no further capture will be done.
+		 */
+		reg_clear(vcap, DCMIPP_P0FCTCR, DCMIPP_P0FCTCR_CPTREQ);
+
+		dev_dbg(vcap->dev, "Capture restart is deferred to next buffer queueing\n");
+		vcap->next = NULL;
+		vcap->state = WAIT_FOR_BUFFER;
+		return;
+	}
+
+	/* If we don't have buffer yet, pick the one after active */
+	if (!vcap->next)
+		vcap->next = list_next_entry(vcap->active, list);
+
+	/*
+	 * Set buffer address
+	 * This register is shadowed and will be taken into
+	 * account on next VSYNC (start of next frame)
+	 */
+	reg_write(vcap, DCMIPP_P0PPM0AR1, vcap->next->paddr);
+	dev_dbg(vcap->dev, "Write [%d] %p phy=%pad\n",
+		vcap->next->vb.vb2_buf.index, vcap->next, &vcap->next->paddr);
+}
+
+/* irqlock must be held */
+static void dcmipp_bytecap_process_frame(struct dcmipp_bytecap_device *vcap,
+					 size_t bytesused)
+{
+	int err = 0;
+	struct dcmipp_buf *buf = vcap->active;
+
+	if (!buf) {
+		vcap->nactive_count++;
+		vcap->errors_count++;
+		return;
+	}
+
+	if (bytesused > buf->size) {
+		dev_dbg(vcap->dev, "frame larger than expected (%zu > %zu)\n",
+			bytesused, buf->size);
+		/* Clip to buffer size and return buffer to V4L2 in error */
+		bytesused = buf->size;
+		vcap->limit_count++;
+		vcap->errors_count++;
+		err = -EOVERFLOW;
+	}
+
+	dcmipp_buffer_done(vcap, buf, bytesused, err);
+	vcap->active = NULL;
+}
+
+static irqreturn_t dcmipp_bytecap_irq_thread(int irq, void *arg)
+{
+	struct dcmipp_bytecap_device *vcap =
+			container_of(arg, struct dcmipp_bytecap_device, ved);
+	size_t bytesused = 0;
+	u32 cmsr2;
+
+	spin_lock_irq(&vcap->irqlock);
+
+	cmsr2 = vcap->cmsr2 & vcap->cmier;
+
+	/*
+	 * If we have an overrun, a frame-end will probably not be generated, in that
+	 * case the active buffer will be recycled as next buffer by the VSYNC handler
+	 */
+	if (cmsr2 & DCMIPP_CMSR2_P0OVRF) {
+		vcap->errors_count++;
+		vcap->overrun_count++;
+	}
+
+	if (cmsr2 & DCMIPP_CMSR2_P0FRAMEF) {
+		vcap->frame_count++;
+
+		/* Read captured buffer size */
+		bytesused = reg_read(vcap, DCMIPP_P0DCCNTR);
+		dcmipp_bytecap_process_frame(vcap, bytesused);
+	}
+
+	if (cmsr2 & DCMIPP_CMSR2_P0VSYNCF) {
+		vcap->vsync_count++;
+		if (vcap->state == WAIT_FOR_BUFFER) {
+			vcap->underrun_count++;
+			goto out;
+		}
+
+		/*
+		 * On VSYNC, the previously set next buffer is going to become active thanks to
+		 * the shadowing mechanism of the DCMIPP. In most of the cases, since a FRAMEEND
+		 * has already come, pointer next is NULL since active is reset during the
+		 * FRAMEEND handling. However, in case of framerate adjustment, there are more
+		 * VSYNC than FRAMEEND. Thus we recycle the active (but not used) buffer and put it
+		 * back into next.
+		 */
+		swap(vcap->active, vcap->next);
+		dcmipp_bytecap_set_next_frame_or_stop(vcap);
+	}
+
+out:
+	spin_unlock_irq(&vcap->irqlock);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t dcmipp_bytecap_irq_callback(int irq, void *arg)
+{
+	struct dcmipp_bytecap_device *vcap =
+			container_of(arg, struct dcmipp_bytecap_device, ved);
+
+	/* Store interrupt status register */
+	vcap->cmsr2 = reg_read(vcap, DCMIPP_CMSR2) & vcap->cmier;
+	vcap->it_count++;
+
+	/* Clear interrupt */
+	reg_write(vcap, DCMIPP_CMFCR, vcap->cmsr2);
+
+	return IRQ_WAKE_THREAD;
+}
+
+static int dcmipp_bytecap_comp_bind(struct device *comp, struct device *master,
+				    void *master_data)
+{
+	struct dcmipp_bind_data *bind_data = master_data;
+	struct dcmipp_platform_data *pdata = comp->platform_data;
+	struct dcmipp_bytecap_device *vcap;
+	struct v4l2_pix_format *format;
+	struct video_device *vdev;
+	struct vb2_queue *q;
+	int ret = 0;
+
+	/* Allocate the dcmipp_bytecap_device struct */
+	vcap = kzalloc(sizeof(*vcap), GFP_KERNEL);
+	if (!vcap)
+		return -ENOMEM;
+
+	/* Allocate the pads */
+	vcap->ved.pads =
+		dcmipp_pads_init(1,
+				 (const unsigned long[1]) {MEDIA_PAD_FL_SINK});
+	if (IS_ERR(vcap->ved.pads)) {
+		ret = PTR_ERR(vcap->ved.pads);
+		goto err_free_vcap;
+	}
+
+	/* Initialize the media entity */
+	vcap->vdev.entity.name = pdata->entity_name;
+	vcap->vdev.entity.function = MEDIA_ENT_F_IO_V4L;
+	ret = media_entity_pads_init(&vcap->vdev.entity,
+				     1, vcap->ved.pads);
+	if (ret)
+		goto err_clean_pads;
+
+	/* Initialize the lock */
+	mutex_init(&vcap->lock);
+
+	/* Initialize the vb2 queue */
+	q = &vcap->queue;
+	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	q->io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF;
+	q->lock = &vcap->lock;
+	q->drv_priv = vcap;
+	q->buf_struct_size = sizeof(struct dcmipp_buf);
+	q->ops = &dcmipp_bytecap_qops;
+	q->mem_ops = &vb2_dma_contig_memops;
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	q->min_buffers_needed = 1;
+	q->dev = comp;
+
+	ret = vb2_queue_init(q);
+	if (ret) {
+		dev_err(comp, "%s: vb2 queue init failed (err=%d)\n",
+			pdata->entity_name, ret);
+		goto err_clean_m_ent;
+	}
+
+	/* Initialize buffer list and its lock */
+	INIT_LIST_HEAD(&vcap->buffers);
+	spin_lock_init(&vcap->irqlock);
+
+	/* Set default frame format */
+	vcap->format = fmt_default;
+	format = &vcap->format;
+	format->bytesperline = frame_stride(format->width, format->pixelformat);
+	format->sizeimage = frame_size(format->width,
+				       format->height,
+				       format->pixelformat);
+
+	/* Fill the dcmipp_ent_device struct */
+	vcap->ved.ent = &vcap->vdev.entity;
+	vcap->ved.vdev_get_format = dcmipp_bytecap_get_format;
+	vcap->ved.handler = dcmipp_bytecap_irq_callback;
+	vcap->ved.thread_fn = dcmipp_bytecap_irq_thread;
+	dev_set_drvdata(comp, &vcap->ved);
+	vcap->dev = comp;
+	vcap->regs = bind_data->regs;
+	vcap->rstc = bind_data->rstc;
+	vcap->cdev = master;
+
+	/* Initialize the video_device struct */
+	vdev = &vcap->vdev;
+	vdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |
+			    V4L2_CAP_READWRITE;
+	vdev->entity.ops = &dcmipp_bytecap_mops;
+	vdev->release = dcmipp_bytecap_release;
+	vdev->fops = &dcmipp_bytecap_fops;
+	vdev->ioctl_ops = &dcmipp_bytecap_ioctl_ops;
+	vdev->lock = &vcap->lock;
+	vdev->queue = q;
+	vdev->v4l2_dev = bind_data->v4l2_dev;
+	strscpy(vdev->name, pdata->entity_name, sizeof(vdev->name));
+	video_set_drvdata(vdev, &vcap->ved);
+
+	/* Register the video_device with the v4l2 and the media framework */
+	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
+	if (ret) {
+		dev_err(comp, "%s: video register failed (err=%d)\n",
+			vcap->vdev.name, ret);
+		goto err_clean_m_ent;
+	}
+
+	return 0;
+
+err_clean_m_ent:
+	media_entity_cleanup(&vcap->vdev.entity);
+err_clean_pads:
+	dcmipp_pads_cleanup(vcap->ved.pads);
+err_free_vcap:
+	kfree(vcap);
+
+	return ret;
+}
+
+static const struct component_ops dcmipp_bytecap_comp_ops = {
+	.bind = dcmipp_bytecap_comp_bind,
+	.unbind = dcmipp_bytecap_comp_unbind,
+};
+
+static int dcmipp_bytecap_probe(struct platform_device *pdev)
+{
+	return component_add(&pdev->dev, &dcmipp_bytecap_comp_ops);
+}
+
+static int dcmipp_bytecap_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &dcmipp_bytecap_comp_ops);
+
+	return 0;
+}
+
+static const struct platform_device_id dcmipp_bytecap_driver_ids[] = {
+	{
+		.name	= DCMIPP_BYTECAP_DRV_NAME,
+	},
+	{ }
+};
+
+static struct platform_driver dcmipp_bytecap_pdrv = {
+	.probe		= dcmipp_bytecap_probe,
+	.remove		= dcmipp_bytecap_remove,
+	.id_table	= dcmipp_bytecap_driver_ids,
+	.driver		= {
+		.name	= DCMIPP_BYTECAP_DRV_NAME,
+	},
+};
+
+module_platform_driver(dcmipp_bytecap_pdrv);
+
+MODULE_DEVICE_TABLE(platform, dcmipp_bytecap_driver_ids);
+
+MODULE_AUTHOR("Hugues Fruchet <hugues.fruchet@foss.st.com>");
+MODULE_AUTHOR("Alain Volmat <alain.volmat@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 Digital Camera Memory Interface with Pixel Processor driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-byteproc.c b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-byteproc.c
new file mode 100644
index 000000000..5a33f3bf8
--- /dev/null
+++ b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-byteproc.c
@@ -0,0 +1,844 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include <linux/component.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/vmalloc.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/v4l2-rect.h>
+#include <media/v4l2-subdev.h>
+
+#include "dcmipp-common.h"
+
+#define DCMIPP_BYTEPROC_DRV_NAME "dcmipp-byteproc"
+
+#define DCMIPP_FMT_WIDTH_DEFAULT  640
+#define DCMIPP_FMT_HEIGHT_DEFAULT 480
+
+#define DCMIPP_P0FSCR (0x404)
+#define DCMIPP_P0FSCR_DTMODE_MASK GENMASK(17, 16)
+#define DCMIPP_P0FSCR_DTMODE_SHIFT 16
+#define DCMIPP_P0FSCR_DTMODE_DTIDA	0x00
+#define DCMIPP_P0FSCR_DTMODE_ALLDT	0x03
+#define DCMIPP_P0FSCR_DTIDA_MASK GENMASK(5, 0)
+#define DCMIPP_P0FSCR_DTIDA_SHIFT 0
+#define DCMIPP_P0FCTCR (0x500)
+#define DCMIPP_P0FCTCR_FRATE_MASK GENMASK(1, 0)
+#define DCMIPP_P0SCSTR (0x504)
+#define DCMIPP_P0SCSTR_HSTART_SHIFT	0
+#define DCMIPP_P0SCSTR_VSTART_SHIFT	16
+#define DCMIPP_P0SCSZR (0x508)
+#define DCMIPP_P0SCSZR_ENABLE BIT(31)
+#define DCMIPP_P0SCSZR_HSIZE_SHIFT	0
+#define DCMIPP_P0SCSZR_VSIZE_SHIFT	16
+#define DCMIPP_P0PPCR (0x5C0)
+#define DCMIPP_P0PPCR_BSM_1_2 0x1
+#define DCMIPP_P0PPCR_BSM_1_4 0x2
+#define DCMIPP_P0PPCR_BSM_2_4 0x3
+#define DCMIPP_P0PPCR_BSM_MASK GENMASK(8, 7)
+#define DCMIPP_P0PPCR_BSM_SHIFT 0x7
+#define DCMIPP_P0PPCR_LSM BIT(10)
+#define DCMIPP_P0PPCR_OELS BIT(11)
+
+#define IS_SINK(pad) (!(pad))
+#define IS_SRC(pad)  ((pad))
+#define PAD_STR(pad) (IS_SRC((pad))) ? "src" : "sink"
+
+#define BYTEPROC_MEDIA_BUS_FMT_DEFAULT MEDIA_BUS_FMT_RGB565_2X8_LE
+
+struct dcmipp_byteproc_pix_map {
+	unsigned int code;
+	unsigned int bpp;
+	unsigned int dt;
+};
+
+#define PIXMAP_MBUS_BPP(mbus, byteperpixel, data_type)	\
+		{						\
+			.code = MEDIA_BUS_FMT_##mbus,		\
+			.bpp = byteperpixel,	\
+			.dt = data_type,	\
+		}
+static const struct dcmipp_byteproc_pix_map dcmipp_byteproc_pix_map_list[] = {
+	PIXMAP_MBUS_BPP(RGB565_2X8_LE, 2, 0x22),
+	PIXMAP_MBUS_BPP(YUYV8_2X8, 2, 0x1e),
+	PIXMAP_MBUS_BPP(YVYU8_2X8, 2, 0x1e),
+	PIXMAP_MBUS_BPP(UYVY8_2X8, 2, 0x1e),
+	PIXMAP_MBUS_BPP(VYUY8_2X8, 2, 0x1e),
+	PIXMAP_MBUS_BPP(Y8_1X8, 1, 0x00), /* TODO - DT value to be fixed */
+	PIXMAP_MBUS_BPP(SBGGR8_1X8, 1, 0x2a),
+	PIXMAP_MBUS_BPP(SGBRG8_1X8, 1, 0x2a),
+	PIXMAP_MBUS_BPP(SGRBG8_1X8, 1, 0x2a),
+	PIXMAP_MBUS_BPP(SRGGB8_1X8, 1, 0x2a),
+	PIXMAP_MBUS_BPP(SBGGR10_1X10, 1, 0x2b),
+	PIXMAP_MBUS_BPP(SGBRG10_1X10, 1, 0x2b),
+	PIXMAP_MBUS_BPP(SGRBG10_1X10, 1, 0x2b),
+	PIXMAP_MBUS_BPP(SRGGB10_1X10, 1, 0x2b),
+	PIXMAP_MBUS_BPP(SBGGR12_1X12, 1, 0x2c),
+	PIXMAP_MBUS_BPP(SGBRG12_1X12, 1, 0x2c),
+	PIXMAP_MBUS_BPP(SGRBG12_1X12, 1, 0x2c),
+	PIXMAP_MBUS_BPP(SRGGB12_1X12, 1, 0x2c),
+	PIXMAP_MBUS_BPP(SBGGR14_1X14, 1, 0x2d),
+	PIXMAP_MBUS_BPP(SGBRG14_1X14, 1, 0x2d),
+	PIXMAP_MBUS_BPP(SGRBG14_1X14, 1, 0x2d),
+	PIXMAP_MBUS_BPP(SRGGB14_1X14, 1, 0x2d),
+	PIXMAP_MBUS_BPP(JPEG_1X8, 1, 0x00), /* TODO - DT value to be fixed */
+};
+
+static const struct dcmipp_byteproc_pix_map *dcmipp_byteproc_pix_map_by_index(unsigned int i)
+{
+	const struct dcmipp_byteproc_pix_map *l = dcmipp_byteproc_pix_map_list;
+	unsigned int size = ARRAY_SIZE(dcmipp_byteproc_pix_map_list);
+
+	if (i >= size)
+		return NULL;
+
+	return &l[i];
+}
+
+static const struct dcmipp_byteproc_pix_map *dcmipp_byteproc_pix_map_by_code(u32 code)
+{
+	const struct dcmipp_byteproc_pix_map *l = dcmipp_byteproc_pix_map_list;
+	unsigned int size = ARRAY_SIZE(dcmipp_byteproc_pix_map_list);
+	unsigned int i;
+
+	for (i = 0; i < size; i++) {
+		if (l[i].code == code)
+			return &l[i];
+	}
+
+	return NULL;
+}
+
+struct dcmipp_byteproc_device {
+	struct dcmipp_ent_device ved;
+	struct v4l2_subdev sd;
+	struct device *dev;
+	struct v4l2_mbus_framefmt sink_fmt;
+	bool streaming;
+	/* Protect this data structure */
+	struct mutex lock;
+
+	void __iomem *regs;
+
+	struct v4l2_fract sink_interval;
+	struct v4l2_fract src_interval;
+	unsigned int frate;
+	u32 src_code;
+	struct v4l2_rect crop;
+	struct v4l2_rect compose;
+};
+
+static const struct v4l2_mbus_framefmt fmt_default = {
+	.width = DCMIPP_FMT_WIDTH_DEFAULT,
+	.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	.code = BYTEPROC_MEDIA_BUS_FMT_DEFAULT,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = DCMIPP_COLORSPACE_DEFAULT,
+	.ycbcr_enc = DCMIPP_YCBCR_ENC_DEFAULT,
+	.quantization = DCMIPP_QUANTIZATION_DEFAULT,
+	.xfer_func = DCMIPP_XFER_FUNC_DEFAULT,
+};
+
+static const struct v4l2_rect crop_min = {
+	.width = DCMIPP_FRAME_MIN_WIDTH,
+	.height = DCMIPP_FRAME_MIN_HEIGHT,
+	.top = 0,
+	.left = 0,
+};
+
+static struct v4l2_rect
+dcmipp_byteproc_get_compose_bound(const struct v4l2_mbus_framefmt *fmt)
+{
+	/* Get the crop bounds to clamp the crop rectangle correctly */
+	struct v4l2_rect r = {
+		.left = 0,
+		.top = 0,
+		.width = fmt->width,
+		.height = fmt->height,
+	};
+
+	return r;
+}
+
+static void dcmipp_byteproc_adjust_crop(struct v4l2_rect *r, struct v4l2_rect *compose)
+{
+	/* Disallow rectangles smaller than the minimal one. */
+	v4l2_rect_set_min_size(r, &crop_min);
+	v4l2_rect_map_inside(r, compose);
+}
+
+static void dcmipp_byteproc_adjust_compose(struct v4l2_rect *r,
+					   const struct v4l2_mbus_framefmt *fmt)
+{
+	r->top = 0;
+	r->left = 0;
+
+	/* Compose is not possible for JPEG or Bayer formats */
+	if ((fmt->code == MEDIA_BUS_FMT_JPEG_1X8) ||
+	    (fmt->code == MEDIA_BUS_FMT_SBGGR8_1X8) ||
+	    (fmt->code == MEDIA_BUS_FMT_SGBRG8_1X8) ||
+	    (fmt->code == MEDIA_BUS_FMT_SGRBG8_1X8) ||
+	    (fmt->code == MEDIA_BUS_FMT_SRGGB8_1X8) ||
+	    (fmt->code == MEDIA_BUS_FMT_SBGGR10_1X10) ||
+	    (fmt->code == MEDIA_BUS_FMT_SGBRG10_1X10) ||
+	    (fmt->code == MEDIA_BUS_FMT_SGRBG10_1X10) ||
+	    (fmt->code == MEDIA_BUS_FMT_SRGGB10_1X10) ||
+	    (fmt->code == MEDIA_BUS_FMT_SBGGR12_1X12) ||
+	    (fmt->code == MEDIA_BUS_FMT_SGBRG12_1X12) ||
+	    (fmt->code == MEDIA_BUS_FMT_SGRBG12_1X12) ||
+	    (fmt->code == MEDIA_BUS_FMT_SRGGB12_1X12) ||
+	    (fmt->code == MEDIA_BUS_FMT_SBGGR14_1X14) ||
+	    (fmt->code == MEDIA_BUS_FMT_SGBRG14_1X14) ||
+	    (fmt->code == MEDIA_BUS_FMT_SGRBG14_1X14) ||
+	    (fmt->code == MEDIA_BUS_FMT_SRGGB14_1X14)) {
+		r->width = fmt->width;
+		r->height = fmt->height;
+		return;
+	}
+
+	/* Adjust height - we can only perform 1/2 decimation */
+	if (r->height <= (fmt->height / 2))
+		r->height = fmt->height / 2;
+	else
+		r->height = fmt->height;
+
+	/* Adjust width - /2 or /4 for 8bits formats and /2 for 16bits formats */
+	if (fmt->code == MEDIA_BUS_FMT_Y8_1X8 && r->width <= (fmt->width / 4))
+		r->width = fmt->width / 4;
+	else if (r->width <= (fmt->width / 2))
+		r->width = fmt->width / 2;
+	else
+		r->width = fmt->width;
+}
+
+static void dcmipp_byteproc_adjust_fmt(struct v4l2_mbus_framefmt *fmt)
+{
+	const struct dcmipp_byteproc_pix_map *vpix;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_byteproc_pix_map_by_code(fmt->code);
+	if (!vpix)
+		fmt->code = fmt_default.code;
+
+	fmt->width = clamp_t(u32, fmt->width, DCMIPP_FRAME_MIN_WIDTH,
+			     DCMIPP_FRAME_MAX_WIDTH) & ~1;
+	fmt->height = clamp_t(u32, fmt->height, DCMIPP_FRAME_MIN_HEIGHT,
+			      DCMIPP_FRAME_MAX_HEIGHT) & ~1;
+
+	if (fmt->field == V4L2_FIELD_ANY || fmt->field == V4L2_FIELD_ALTERNATE)
+		fmt->field = fmt_default.field;
+
+	dcmipp_colorimetry_clamp(fmt);
+}
+
+static int dcmipp_byteproc_init_cfg(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_state *sd_state)
+{
+	unsigned int i;
+
+	for (i = 0; i < sd->entity.num_pads; i++) {
+		struct v4l2_mbus_framefmt *mf;
+		struct v4l2_rect *r;
+
+		mf = v4l2_subdev_get_try_format(sd, sd_state, i);
+		*mf = fmt_default;
+
+		if (IS_SINK(i))
+			r = v4l2_subdev_get_try_compose(sd, sd_state, i);
+		else
+			r = v4l2_subdev_get_try_crop(sd, sd_state, i);
+
+		r->top = 0;
+		r->left = 0;
+		r->width = DCMIPP_FMT_WIDTH_DEFAULT;
+		r->height = DCMIPP_FMT_HEIGHT_DEFAULT;
+	}
+
+	return 0;
+}
+
+static int dcmipp_byteproc_enum_mbus_code(struct v4l2_subdev *sd,
+					  struct v4l2_subdev_state *sd_state,
+					  struct v4l2_subdev_mbus_code_enum *code)
+{
+	const struct dcmipp_byteproc_pix_map *vpix;
+
+	vpix = dcmipp_byteproc_pix_map_by_index(code->index);
+	if (!vpix)
+		return -EINVAL;
+
+	code->code = vpix->code;
+
+	return 0;
+}
+
+static int dcmipp_byteproc_enum_frame_size(struct v4l2_subdev *sd,
+					   struct v4l2_subdev_state *sd_state,
+					   struct v4l2_subdev_frame_size_enum *fse)
+{
+	const struct dcmipp_byteproc_pix_map *vpix;
+
+	if (fse->index)
+		return -EINVAL;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_byteproc_pix_map_by_code(fse->code);
+	if (!vpix)
+		return -EINVAL;
+
+	fse->min_width = DCMIPP_FRAME_MIN_WIDTH;
+	fse->max_width = DCMIPP_FRAME_MAX_WIDTH;
+	fse->min_height = DCMIPP_FRAME_MIN_HEIGHT;
+	fse->max_height = DCMIPP_FRAME_MAX_HEIGHT;
+
+	return 0;
+}
+
+static int dcmipp_byteproc_get_fmt(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *sd_state,
+				   struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_byteproc_device *byteproc = v4l2_get_subdevdata(sd);
+	struct v4l2_rect *crop_rect;
+
+	mutex_lock(&byteproc->lock);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		fmt->format = *v4l2_subdev_get_try_format(sd, sd_state, 0);
+		crop_rect = v4l2_subdev_get_try_crop(sd, sd_state, 1);
+	} else {
+		fmt->format = byteproc->sink_fmt;
+		crop_rect = &byteproc->crop;
+	}
+
+	if (IS_SRC(fmt->pad)) {
+		fmt->format.width = crop_rect->width;
+		fmt->format.height = crop_rect->height;
+	}
+
+	mutex_unlock(&byteproc->lock);
+
+	return 0;
+}
+
+static int dcmipp_byteproc_set_fmt(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *sd_state,
+				   struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_byteproc_device *byteproc = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *sink_fmt;
+	struct v4l2_rect *crop, *compose;
+	int ret = 0;
+
+	mutex_lock(&byteproc->lock);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		if (byteproc->streaming) {
+			ret = -EBUSY;
+			goto out;
+		}
+
+		sink_fmt = &byteproc->sink_fmt;
+		crop = &byteproc->crop;
+		compose = &byteproc->compose;
+	} else {
+		sink_fmt = v4l2_subdev_get_try_format(sd, sd_state, 0);
+		crop = v4l2_subdev_get_try_crop(sd, sd_state, 1);
+		compose = v4l2_subdev_get_try_compose(sd, sd_state, 0);
+	}
+
+	if (IS_SRC(fmt->pad)) {
+		fmt->format = *sink_fmt;
+		fmt->format.width = crop->width;
+		fmt->format.height = crop->height;
+	} else {
+		dcmipp_byteproc_adjust_fmt(&fmt->format);
+		crop->top = 0;
+		crop->left = 0;
+		crop->width = fmt->format.width;
+		crop->height = fmt->format.height;
+		*compose = *crop;
+		*sink_fmt = fmt->format;
+	}
+
+out:
+	mutex_unlock(&byteproc->lock);
+
+	return ret;
+}
+
+static int dcmipp_byteproc_get_selection(struct v4l2_subdev *sd,
+					 struct v4l2_subdev_state *sd_state,
+					 struct v4l2_subdev_selection *s)
+{
+	struct dcmipp_byteproc_device *byteproc = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *sink_fmt;
+	struct v4l2_rect *crop, *compose;
+
+	/*
+	 * In the HW, the decimation block is located prior to the crop hence:
+	 * Compose is done on the sink pad
+	 * Crop is done on the src pad
+	 */
+	if ((s->target == V4L2_SEL_TGT_CROP ||
+	     s->target == V4L2_SEL_TGT_CROP_BOUNDS ||
+	     s->target == V4L2_SEL_TGT_CROP_DEFAULT) && IS_SINK(s->pad))
+		return -EINVAL;
+
+	if ((s->target == V4L2_SEL_TGT_COMPOSE ||
+	     s->target == V4L2_SEL_TGT_COMPOSE_BOUNDS ||
+	     s->target == V4L2_SEL_TGT_COMPOSE_DEFAULT) && IS_SRC(s->pad))
+		return -EINVAL;
+
+	if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		sink_fmt = &byteproc->sink_fmt;
+		crop = &byteproc->crop;
+		compose = &byteproc->compose;
+	} else {
+		sink_fmt = v4l2_subdev_get_try_format(sd, sd_state, 0);
+		crop = v4l2_subdev_get_try_crop(sd, sd_state, 1);
+		compose = v4l2_subdev_get_try_compose(sd, sd_state, 0);
+	}
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		s->r = *crop;
+		break;
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		s->r = *compose;
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		s->r = *compose;
+		break;
+	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
+		s->r = dcmipp_byteproc_get_compose_bound(sink_fmt);
+		break;
+	case V4L2_SEL_TGT_COMPOSE_DEFAULT:
+		s->r.top = 0;
+		s->r.left = 0;
+		s->r.width = sink_fmt->width;
+		s->r.height = sink_fmt->height;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dcmipp_byteproc_set_selection(struct v4l2_subdev *sd,
+					 struct v4l2_subdev_state *sd_state,
+					 struct v4l2_subdev_selection *s)
+{
+	struct dcmipp_byteproc_device *byteproc = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *sink_fmt;
+	struct v4l2_rect *crop, *compose;
+
+	/*
+	 * In the HW, the decimation block is located prior to the crop hence:
+	 * Compose is done on the sink pad
+	 * Crop is done on the src pad
+	 */
+	if ((s->target == V4L2_SEL_TGT_CROP ||
+	     s->target == V4L2_SEL_TGT_CROP_BOUNDS ||
+	     s->target == V4L2_SEL_TGT_CROP_DEFAULT) && IS_SINK(s->pad))
+		return -EINVAL;
+
+	if ((s->target == V4L2_SEL_TGT_COMPOSE ||
+	     s->target == V4L2_SEL_TGT_COMPOSE_BOUNDS ||
+	     s->target == V4L2_SEL_TGT_COMPOSE_DEFAULT) && IS_SRC(s->pad))
+		return -EINVAL;
+
+	if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		sink_fmt = &byteproc->sink_fmt;
+		crop = &byteproc->crop;
+		compose = &byteproc->compose;
+	} else {
+		sink_fmt = v4l2_subdev_get_try_format(sd, sd_state, 0);
+		crop = v4l2_subdev_get_try_crop(sd, sd_state, 1);
+		compose = v4l2_subdev_get_try_compose(sd, sd_state, 0);
+	}
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		dcmipp_byteproc_adjust_crop(&s->r, compose);
+
+		*crop = s->r;
+
+		dev_dbg(byteproc->dev, "s_selection: crop %ux%u@(%u,%u)\n",
+			crop->width, crop->height, crop->left, crop->top);
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		dcmipp_byteproc_adjust_compose(&s->r, sink_fmt);
+		*compose = s->r;
+		*crop = s->r;
+
+		dev_dbg(byteproc->dev, "s_selection: compose %ux%u@(%u,%u)\n",
+			compose->width, compose->height, compose->left, compose->top);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const unsigned int dcmipp_frates[] = {1, 2, 4, 8};
+
+static int dcmipp_byteproc_enum_frame_interval
+				(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct dcmipp_byteproc_device *byteproc = v4l2_get_subdevdata(sd);
+	struct v4l2_fract *sink_interval = &byteproc->sink_interval;
+	unsigned int ratio;
+	int ret = 0;
+
+	if (fie->pad > 1 ||
+	    fie->index >= (IS_SRC(fie->pad) ? ARRAY_SIZE(dcmipp_frates) : 1) ||
+	    fie->width > DCMIPP_FRAME_MAX_WIDTH ||
+	    fie->height > DCMIPP_FRAME_MAX_HEIGHT)
+		return -EINVAL;
+
+	mutex_lock(&byteproc->lock);
+
+	if (IS_SINK(fie->pad)) {
+		fie->interval = *sink_interval;
+		goto out;
+	}
+
+	ratio = dcmipp_frates[fie->index];
+
+	fie->interval.numerator = sink_interval->numerator * ratio;
+	fie->interval.denominator = sink_interval->denominator;
+
+out:
+	mutex_unlock(&byteproc->lock);
+	return ret;
+}
+
+static const struct v4l2_subdev_pad_ops dcmipp_byteproc_pad_ops = {
+	.init_cfg		= dcmipp_byteproc_init_cfg,
+	.enum_mbus_code		= dcmipp_byteproc_enum_mbus_code,
+	.enum_frame_size	= dcmipp_byteproc_enum_frame_size,
+	.enum_frame_interval	= dcmipp_byteproc_enum_frame_interval,
+	.get_fmt		= dcmipp_byteproc_get_fmt,
+	.set_fmt		= dcmipp_byteproc_set_fmt,
+	.get_selection		= dcmipp_byteproc_get_selection,
+	.set_selection		= dcmipp_byteproc_set_selection,
+};
+
+static int dcmipp_byteproc_configure_scale_crop
+			(struct dcmipp_byteproc_device *byteproc)
+{
+	const struct dcmipp_byteproc_pix_map *vpix;
+	u32 hprediv, vprediv;
+	struct v4l2_rect *crop = &byteproc->crop;
+	u32 val = 0;
+
+	/* find output format bpp */
+	vpix = dcmipp_byteproc_pix_map_by_code(byteproc->sink_fmt.code);
+	if (!vpix)
+		return -EINVAL;
+
+	/* clear decimation/crop */
+	reg_clear(byteproc, DCMIPP_P0PPCR, DCMIPP_P0PPCR_BSM_MASK);
+	reg_clear(byteproc, DCMIPP_P0PPCR, DCMIPP_P0PPCR_LSM);
+	reg_write(byteproc, DCMIPP_P0SCSTR, 0);
+	reg_write(byteproc, DCMIPP_P0SCSZR, 0);
+
+	/* Ignore decimation/crop with JPEG */
+	if (vpix->code == MEDIA_BUS_FMT_JPEG_1X8)
+		return 0;
+
+	/* decimation */
+	hprediv = byteproc->sink_fmt.width / byteproc->compose.width;
+	if (hprediv == 4)
+		val |= DCMIPP_P0PPCR_BSM_1_4 << DCMIPP_P0PPCR_BSM_SHIFT;
+	else if ((vpix->code == MEDIA_BUS_FMT_Y8_1X8) && (hprediv == 2))
+		val |= DCMIPP_P0PPCR_BSM_1_2 << DCMIPP_P0PPCR_BSM_SHIFT;
+	else if (hprediv == 2)
+		val |= DCMIPP_P0PPCR_BSM_2_4 << DCMIPP_P0PPCR_BSM_SHIFT;
+
+	vprediv = byteproc->sink_fmt.height / byteproc->compose.height;
+	if (vprediv == 2)
+		val |= DCMIPP_P0PPCR_LSM | DCMIPP_P0PPCR_OELS;
+
+	/* decimate using bytes and lines skipping */
+	if (val) {
+		reg_set(byteproc, DCMIPP_P0PPCR, val);
+
+		dev_dbg(byteproc->dev, "decimate to %dx%d [prediv=%dx%d]\n",
+			byteproc->compose.width, byteproc->compose.height, hprediv, vprediv);
+	}
+
+	dev_dbg(byteproc->dev, "crop to %dx%d\n", crop->width, crop->height);
+
+	/* expressed in 32-bits words on X axis, lines on Y axis */
+	reg_write(byteproc, DCMIPP_P0SCSTR,
+		  (((crop->left * vpix->bpp) / 4) << DCMIPP_P0SCSTR_HSTART_SHIFT) |
+		  (crop->top << DCMIPP_P0SCSTR_VSTART_SHIFT));
+	reg_write(byteproc, DCMIPP_P0SCSZR,
+		  DCMIPP_P0SCSZR_ENABLE |
+		  (((crop->width * vpix->bpp) / 4) << DCMIPP_P0SCSZR_HSIZE_SHIFT) |
+		  (crop->height << DCMIPP_P0SCSZR_VSIZE_SHIFT));
+
+	return 0;
+}
+
+static void dcmipp_byteproc_configure_framerate
+			(struct dcmipp_byteproc_device *byteproc)
+{
+	/* Frame skipping */
+	reg_clear(byteproc, DCMIPP_P0FCTCR, DCMIPP_P0FCTCR_FRATE_MASK);
+	reg_set(byteproc, DCMIPP_P0FCTCR, byteproc->frate);
+}
+
+static int dcmipp_byteproc_g_frame_interval(struct v4l2_subdev *sd,
+					    struct v4l2_subdev_frame_interval *fi)
+{
+	struct dcmipp_byteproc_device *byteproc = v4l2_get_subdevdata(sd);
+
+	if (IS_SINK(fi->pad))
+		fi->interval = byteproc->sink_interval;
+	else
+		fi->interval = byteproc->src_interval;
+
+	return 0;
+}
+
+static int dcmipp_byteproc_s_frame_interval(struct v4l2_subdev *sd,
+					    struct v4l2_subdev_frame_interval *fi)
+{
+	struct dcmipp_byteproc_device *byteproc = v4l2_get_subdevdata(sd);
+
+	mutex_lock(&byteproc->lock);
+
+	if (byteproc->streaming) {
+		mutex_unlock(&byteproc->lock);
+		return -EBUSY;
+	}
+
+	if (fi->interval.numerator == 0 || fi->interval.denominator == 0)
+		fi->interval = byteproc->sink_interval;
+
+	if (IS_SINK(fi->pad)) {
+		/*
+		 * Setting sink frame interval resets frame skipping.
+		 * Sink frame interval is propagated to src.
+		 */
+		byteproc->frate = 0;
+		byteproc->sink_interval = fi->interval;
+		byteproc->src_interval = byteproc->sink_interval;
+	} else {
+		unsigned int ratio;
+
+		/* Normalize ratio */
+		ratio = (byteproc->sink_interval.denominator *
+			 fi->interval.numerator) /
+			(byteproc->sink_interval.numerator *
+			 fi->interval.denominator);
+
+		/* Hardware can skip 1 frame over 2, 4 or 8 */
+		byteproc->frate = ratio >= 8 ? 3 :
+				  ratio >= 4 ? 2 :
+				  ratio >= 2 ? 1 : 0;
+
+		/* Adjust src frame interval to what hardware can really do */
+		byteproc->src_interval.numerator =
+			byteproc->sink_interval.numerator * ratio;
+		byteproc->src_interval.denominator =
+			byteproc->sink_interval.denominator;
+	}
+
+	mutex_unlock(&byteproc->lock);
+
+	return 0;
+}
+
+#define STOP_TIMEOUT_US 1000
+#define POLL_INTERVAL_US  50
+static int dcmipp_byteproc_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct dcmipp_byteproc_device *byteproc = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	mutex_lock(&byteproc->lock);
+	if (enable) {
+		const struct dcmipp_byteproc_pix_map *vpix;
+
+		/*
+		 * find output format datatype - this call will always succeed since
+		 * format code has been sanitized at the set_fmt stage
+		 */
+		vpix = dcmipp_byteproc_pix_map_by_code(byteproc->sink_fmt.code);
+
+		/*
+		 * TODO - this should only be done with HW supporting CSI and
+		 * only when the source is CSI
+		 */
+		reg_clear(byteproc, DCMIPP_P0FSCR,
+			  DCMIPP_P0FSCR_DTMODE_MASK | DCMIPP_P0FSCR_DTIDA_MASK);
+
+		if (byteproc->sink_fmt.code == MEDIA_BUS_FMT_JPEG_1X8)
+			reg_set(byteproc, DCMIPP_P0FSCR,
+				DCMIPP_P0FSCR_DTMODE_ALLDT << DCMIPP_P0FSCR_DTMODE_SHIFT);
+		else
+			reg_set(byteproc, DCMIPP_P0FSCR,
+				vpix->dt << DCMIPP_P0FSCR_DTIDA_SHIFT |
+				DCMIPP_P0FSCR_DTMODE_DTIDA);
+
+		dcmipp_byteproc_configure_framerate(byteproc);
+
+		ret = dcmipp_byteproc_configure_scale_crop(byteproc);
+	}
+	mutex_unlock(&byteproc->lock);
+
+	return ret;
+}
+
+static const struct v4l2_subdev_video_ops dcmipp_byteproc_video_ops = {
+	.g_frame_interval = dcmipp_byteproc_g_frame_interval,
+	.s_frame_interval = dcmipp_byteproc_s_frame_interval,
+	.s_stream = dcmipp_byteproc_s_stream,
+};
+
+static const struct v4l2_subdev_ops dcmipp_byteproc_ops = {
+	.pad = &dcmipp_byteproc_pad_ops,
+	.video = &dcmipp_byteproc_video_ops,
+};
+
+/* FIXME */
+static void dcmipp_byteproc_release(struct v4l2_subdev *sd)
+{
+	struct dcmipp_byteproc_device *byteproc = v4l2_get_subdevdata(sd);
+
+	kfree(byteproc);
+}
+
+static const struct v4l2_subdev_internal_ops dcmipp_byteproc_int_ops = {
+	.release = dcmipp_byteproc_release,
+};
+
+static void dcmipp_byteproc_comp_unbind(struct device *comp,
+					struct device *master,
+					void *master_data)
+{
+	struct dcmipp_ent_device *ved = dev_get_drvdata(comp);
+	struct dcmipp_byteproc_device *byteproc =
+			container_of(ved, struct dcmipp_byteproc_device, ved);
+
+	dcmipp_ent_sd_unregister(ved, &byteproc->sd);
+}
+
+static int dcmipp_byteproc_comp_bind(struct device *comp, struct device *master,
+				     void *master_data)
+{
+	struct dcmipp_bind_data *bind_data = master_data;
+	struct dcmipp_platform_data *pdata = comp->platform_data;
+	struct dcmipp_byteproc_device *byteproc;
+	struct v4l2_rect r = {
+		.top = 0,
+		.left = 0,
+		.width = DCMIPP_FMT_WIDTH_DEFAULT,
+		.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	};
+	struct v4l2_fract interval = {
+		.numerator = 1,
+		.denominator = 30,
+	};
+	int ret;
+
+	/* Allocate the byteproc struct */
+	byteproc = kzalloc(sizeof(*byteproc), GFP_KERNEL);
+	if (!byteproc)
+		return -ENOMEM;
+
+	byteproc->regs = bind_data->regs;
+
+	/* Initialize the lock */
+	mutex_init(&byteproc->lock);
+
+	/* Initialize ved and sd */
+	ret = dcmipp_ent_sd_register(&byteproc->ved, &byteproc->sd,
+				     bind_data->v4l2_dev,
+				     pdata->entity_name,
+				     MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER, 2,
+				     (const unsigned long[2]) {
+				     MEDIA_PAD_FL_SINK,
+				     MEDIA_PAD_FL_SOURCE,
+				     },
+				     &dcmipp_byteproc_int_ops,
+				     &dcmipp_byteproc_ops,
+				     NULL, NULL);
+	if (ret) {
+		kfree(byteproc);
+		return ret;
+	}
+
+	dev_set_drvdata(comp, &byteproc->ved);
+	byteproc->dev = comp;
+
+	/* Initialize the frame format */
+	byteproc->sink_fmt = fmt_default;
+	byteproc->crop = r;
+	byteproc->compose = r;
+	byteproc->src_interval = interval;
+	byteproc->sink_interval = interval;
+
+	return 0;
+}
+
+static const struct component_ops dcmipp_byteproc_comp_ops = {
+	.bind = dcmipp_byteproc_comp_bind,
+	.unbind = dcmipp_byteproc_comp_unbind,
+};
+
+static int dcmipp_byteproc_probe(struct platform_device *pdev)
+{
+	return component_add(&pdev->dev, &dcmipp_byteproc_comp_ops);
+}
+
+static int dcmipp_byteproc_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &dcmipp_byteproc_comp_ops);
+
+	return 0;
+}
+
+static const struct platform_device_id dcmipp_byteproc_driver_ids[] = {
+	{
+		.name           = DCMIPP_BYTEPROC_DRV_NAME,
+	},
+	{ }
+};
+
+static struct platform_driver dcmipp_byteproc_pdrv = {
+	.probe		= dcmipp_byteproc_probe,
+	.remove		= dcmipp_byteproc_remove,
+	.id_table	= dcmipp_byteproc_driver_ids,
+	.driver		= {
+		.name	= DCMIPP_BYTEPROC_DRV_NAME,
+	},
+};
+
+module_platform_driver(dcmipp_byteproc_pdrv);
+
+MODULE_DEVICE_TABLE(platform, dcmipp_byteproc_driver_ids);
+
+MODULE_AUTHOR("Hugues Fruchet <hugues.fruchet@foss.st.com>");
+MODULE_AUTHOR("Alain Volmat <alain.volmat@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 Digital Camera Memory Interface with Pixel Processor driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-colorconv.c b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-colorconv.c
new file mode 100644
index 000000000..9d2710c1f
--- /dev/null
+++ b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-colorconv.c
@@ -0,0 +1,362 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+#include <linux/v4l2-mediabus.h>
+#include <media/v4l2-subdev.h>
+
+#include "dcmipp-colorconv.h"
+
+/* Macro for negative coefficient, 11 bits coded */
+#define N11(val) (((val) ^ 0x7FF) + 1)
+/* Macro for added value, 10 bits coded */
+#define N10(val) (((val) ^ 0x3FF) + 1)
+
+/* Macro to convert row matrix to DCMIPP PxCCCyy register value */
+#define ROW(c1, c2, c3, add) ((c2) << 16 | (c1)), ((add) << 16 | (c3))
+
+static const u32 rgbfull_to_yuv601full[] = {
+/*	     R		G		B		Add */
+/* Cr */ ROW(131,	N11(110),	N11(21),	128),
+/*  Y */ ROW(77,	150,		29,		0),
+/* Cb */ ROW(N11(44),	N11(87),	131,		128),
+};
+
+static const u32 rgbfull_to_yuv601lim[] = {
+/*	     R		G		B		Add */
+/* Cr */ ROW(112,	N11(94),	N11(18),	128),
+/*  Y */ ROW(66,	129,		25,		16),
+/* Cb */ ROW(N11(38),	N11(74),	112,		128),
+};
+
+static const u32 rgbfull_to_yuv709full[] = {
+/*	     R		G		B		Add */
+/* Cr */ ROW(131,	N11(119),	N11(12),	128),
+/*  Y */ ROW(55,	183,		18,		0),
+/* Cb */ ROW(N11(30),	N11(101),	131,		128),
+};
+
+static const u32 rgbfull_to_yuv709lim[] = {
+/*	     R		G		B		Add */
+/* Cr */ ROW(112,	N11(102),	N11(10),	128),
+/*  Y */ ROW(47,	157,		16,		16),
+/* Cb */ ROW(N11(26),	N11(87),	112,		128),
+};
+
+static const u32 rgblim_to_yuv601lim[] = {
+/*	     R		G		B		Add */
+/* Cr */ ROW(131,	N11(110),	N11(21),	128),
+/*  Y */ ROW(77,	150,		29,		0),
+/* Cb */ ROW(N11(44),	N11(87),	131,		128),
+};
+
+static const u32 rgblim_to_yuv709lim[] = {
+/*	     R		G		B		Add */
+/* Cr */ ROW(131,	N11(119),	N11(12),	128),
+/*  Y */ ROW(55,	183,		18,		0),
+/* Cb */ ROW(N11(30),	N11(101),	131,		128),
+};
+
+static const u32 yuv601full_to_rgbfull[] = {
+/*	     Cr		Y		Cb		Add */
+/* R */  ROW(351,	256,		0,		N10(175)),
+/* G */  ROW(N11(179),	256,		N11(86),	132),
+/* B */  ROW(0,		256,		443,		N10(222)),
+};
+
+static const u32 yuv601lim_to_rgbfull[] = {
+/*	     Cr		Y		Cb		Add */
+/* R */  ROW(409,	298,		0,		N10(223)),
+/* G */  ROW(N11(208),	298,		N11(100),	135),
+/* B */  ROW(0,		298,		517,		N10(277)),
+};
+
+static const u32 yuv601lim_to_rgblim[] = {
+/*	     Cr		Y		Cb		Add */
+/* R */  ROW(351,	256,		0,		N10(175)),
+/* G */  ROW(N11(179),	256,		N11(86),	132),
+/* B */  ROW(0,		256,		443,		N10(222)),
+};
+
+static const u32 yuv709full_to_rgbfull[] = {
+/*	     Cr		Y		Cb		Add */
+/* R */  ROW(394,	256,		0,		N10(197)),
+/* G */  ROW(N11(118),	256,		N11(47),	82),
+/* B */  ROW(0,		256,		456,		N10(232)),
+};
+
+static const u32 yuv709lim_to_rgbfull[] = {
+/*	     Cr		Y		Cb		Add */
+/* R */  ROW(459,	298,		0,		N10(248)),
+/* G */  ROW(N11(137),	298,		N11(55),	77),
+/* B */  ROW(0,		298,		541,		N10(289)),
+};
+
+static const u32 yuv709lim_to_rgblim[] = {
+/*	     Cr		Y		Cb		Add */
+/* R */  ROW(394,	256,		0,		N10(197)),
+/* G */  ROW(N11(118),	256,		N11(47),	82),
+/* B */  ROW(0,		256,		465,		N10(232)),
+};
+
+/* cconv_matrices[src_fmt][src_range][sink_fmt][sink_range] */
+static const u32 *cconv_matrices[3][2][3][2] = {
+	/* RGB */
+	{
+		/* RGB full range */
+		{
+			/* RGB full range => RGB */
+			{
+				/* RGB full range => RGB full range */
+				NULL,
+				/* RGB full range => RGB limited range */
+				NULL,
+			},
+			/* RGB full range => YUV601 */
+			{
+				/* RGB full range => YUV601 full range */
+				rgbfull_to_yuv601full,
+				/* RGB full range => YUV601 limited range */
+				rgbfull_to_yuv601lim,
+			},
+			/* RGB full range => YUV709 */
+			{
+				/* RGB full range => YUV709 full range */
+				rgbfull_to_yuv709full,
+				/* RGB full range => YUV709 limited range */
+				rgbfull_to_yuv709lim,
+			},
+		},
+		/* RGB limited range */
+		{
+			/* RGB limited range => RGB */
+			{
+				/* RGB limited range => RGB full range */
+				NULL,
+				/* RGB limited range => RGB limited range */
+				NULL,
+			},
+			/* RGB limited range => YUV601 */
+			{
+				/* RGB limited range => YUV601 full range */
+				NULL,
+				/* RGB limited range => YUV601 limited range */
+				rgblim_to_yuv601lim,
+			},
+			/* RGB limited range => YUV709 */
+			{
+				/* RGB limited range => YUV709 full range */
+				NULL,
+				/* RGB limited range => YUV709 limited range */
+				rgblim_to_yuv709lim,
+			},
+		},
+	},
+	/* YUV601 */
+	{
+		/* YUV601 full range */
+		{
+			/* YUV601 full range => RGB */
+			{
+				/* YUV601 full range => RGB full range */
+				yuv601full_to_rgbfull,
+				/* YUV601 full range => RGB limited range */
+				NULL,
+			},
+			/* YUV601 full range => YUV601 */
+			{
+				/* YUV601 full range => YUV601 full range */
+				NULL,
+				/* YUV601 full range => YUV601 limited range */
+				NULL,
+			},
+			/* YUV601 full range => YUV709 */
+			{
+				/* YUV601 full range => YUV709 full range */
+				NULL,
+				/* YUV601 full range => YUV709 limited range */
+				NULL,
+			},
+		},
+		/* YUV601 limited range */
+		{
+			/* YUV601 limited range => RGB */
+			{
+				/* YUV601 limited range => RGB full range */
+				yuv601lim_to_rgbfull,
+				/* YUV601 limited range => RGB limited range */
+				yuv601lim_to_rgblim,
+			},
+			/* YUV601 limited range => YUV601 */
+			{
+				/* YUV601 limited range => YUV601 full range */
+				NULL,
+				/* YUV601 limited range => YUV601 limited range */
+				NULL,
+			},
+			/* YUV601 limited range => YUV709 */
+			{
+				/* YUV601 limited range => YUV709 full range */
+				NULL,
+				/* YUV601 limited range => YUV709 limited range */
+				NULL,
+			},
+		},
+	},
+	/* YUV709 */
+	{
+		/* YUV709 full range */
+		{
+			/* YUV709 full range => RGB */
+			{
+				/* YUV709 full range => RGB full range */
+				yuv709full_to_rgbfull,
+				/* YUV709 full range => RGB limited range */
+				NULL,
+			},
+			/* YUV709 full range => YUV601 */
+			{
+				/* YUV709 full range => YUV601 full range */
+				NULL,
+				/* YUV709 full range => YUV601 limited range */
+				NULL,
+			},
+			/* YUV709 full range => YUV709 */
+			{
+				/* YUV709 full range => YUV709 full range */
+				NULL,
+				/* YUV709 full range => YUV709 limited range */
+				NULL,
+			},
+		},
+		/* YUV709 limited range */
+		{
+			/* YUV709 limited range => RGB */
+			{
+				/* YUV709 limited range => RGB full range */
+				yuv709lim_to_rgbfull,
+				/* YUV709 limited range => RGB limited range */
+				yuv709lim_to_rgblim,
+			},
+			/* YUV709 limited range => YUV601 */
+			{
+				/* YUV709 limited range => YUV601 full range */
+				NULL,
+				/* YUV709 limited range => YUV601 limited range */
+				NULL,
+			},
+			/* YUV709 limited range => YUV709 */
+			{
+				/* YUV709 limited range => YUV709 full range */
+				NULL,
+				/* YUV709 limited range => YUV709 limited range */
+				NULL,
+			},
+		},
+	},
+};
+
+enum cconv_fmt {
+	FMT_RGB = 0,
+	FMT_YUV601,
+	FMT_YUV709
+};
+
+static inline enum cconv_fmt to_cconv_fmt(struct v4l2_mbus_framefmt *fmt)
+{
+	/* YUV format codes are within the 0x2xxx */
+	if (fmt->code >= MEDIA_BUS_FMT_Y8_1X8 &&
+	    fmt->code < MEDIA_BUS_FMT_SBGGR8_1X8) {
+		if (fmt->ycbcr_enc == V4L2_YCBCR_ENC_709)
+			return FMT_YUV709;
+		else
+			return FMT_YUV601;
+	}
+
+	/* All other formats are referred as RGB, indeed, demosaicing bloc
+	 * generate RGB format
+	 */
+	return FMT_RGB;
+};
+
+#define FMT_STR(f) ({					\
+	typeof(f) __f = (f);				\
+	(__f) == FMT_RGB ? "RGB" :			\
+	(__f) == FMT_YUV601 ? "YUV601" :		\
+	(__f) == FMT_YUV709 ? "YUV709" : "?"; })
+
+enum cconv_range {
+	RANGE_FULL = 0,
+	RANGE_LIMITED,
+};
+
+static inline enum cconv_range to_cconv_range(struct v4l2_mbus_framefmt *fmt)
+{
+	if (fmt->quantization == V4L2_QUANTIZATION_FULL_RANGE)
+		return RANGE_FULL;
+
+	return RANGE_LIMITED;
+};
+
+#define RANGE_STR(range) ((range) == RANGE_FULL ? "full" : "limited")
+
+int dcmipp_colorconv_configure(struct device *dev,
+			       struct v4l2_mbus_framefmt *sink,
+			       struct v4l2_mbus_framefmt *src,
+			       struct dcmipp_colorconv_config *cfg)
+{
+	const u32 *cconv_matrix;
+	enum cconv_fmt sink_fmt;
+	enum cconv_range sink_range;
+	enum cconv_fmt src_fmt;
+	enum cconv_range src_range;
+	int i;
+
+	sink_fmt = to_cconv_fmt(sink);
+	sink_range = to_cconv_range(sink);
+	src_fmt = to_cconv_fmt(src);
+	src_range = to_cconv_range(src);
+
+	if (sink_fmt == src_fmt &&
+	    sink_range == src_range) {
+		cfg->enable = false;
+		return 0;
+	}
+
+	/* color conversion */
+	cconv_matrix = cconv_matrices[sink_fmt][sink_range][src_fmt][src_range];
+
+	dev_dbg(dev, "cconv_matrices[%d][%d][%d][%d]=%p\n",
+		sink_fmt, sink_range, src_fmt, src_range, cconv_matrix);
+	if (!cconv_matrix) {
+		dev_err(dev, "Unsupported color conversion %s-%s => %s-%s\n",
+			FMT_STR(sink_fmt), RANGE_STR(sink_range),
+			FMT_STR(src_fmt), RANGE_STR(src_range));
+		return -EINVAL;
+	}
+
+	dev_dbg(dev, "color conversion %s-%s => %s-%s\n",
+		FMT_STR(sink_fmt), RANGE_STR(sink_range),
+		FMT_STR(src_fmt), RANGE_STR(src_range));
+
+	if (src_range == RANGE_LIMITED)
+		cfg->clamping = true;
+
+	cfg->enable = true;
+
+	for (i = 0; i < ARRAY_SIZE(cfg->conv_matrix); i++)
+		cfg->conv_matrix[i] = cconv_matrix[i];
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dcmipp_colorconv_configure);
+
+MODULE_AUTHOR("Hugues Fruchet <hugues.fruchet@foss.st.com>");
+MODULE_AUTHOR("Alain Volmat <alain.volmat@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 Digital Camera Memory Interface with Pixel Processor driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-colorconv.h b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-colorconv.h
new file mode 100644
index 000000000..870e55e1f
--- /dev/null
+++ b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-colorconv.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#ifndef _DCMIPP_COLORCONV_H_
+#define _DCMIPP_COLORCONV_H_
+
+struct dcmipp_colorconv_config {
+	unsigned int conv_matrix[6];
+	bool clamping;
+	bool enable;
+};
+
+int dcmipp_colorconv_configure(struct device *dev,
+			       struct v4l2_mbus_framefmt *sink,
+			       struct v4l2_mbus_framefmt *src,
+			       struct dcmipp_colorconv_config *cfg);
+
+#endif
+
diff --git a/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-common.c b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-common.c
new file mode 100644
index 000000000..2a566bacc
--- /dev/null
+++ b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-common.c
@@ -0,0 +1,116 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+
+#include "dcmipp-common.h"
+
+/* Helper function to allocate and initialize pads */
+struct media_pad *dcmipp_pads_init(u16 num_pads, const unsigned long *pads_flag)
+{
+	struct media_pad *pads;
+	unsigned int i;
+
+	/* Allocate memory for the pads */
+	pads = kcalloc(num_pads, sizeof(*pads), GFP_KERNEL);
+	if (!pads)
+		return ERR_PTR(-ENOMEM);
+
+	/* Initialize the pads */
+	for (i = 0; i < num_pads; i++) {
+		pads[i].index = i;
+		pads[i].flags = pads_flag[i];
+	}
+
+	return pads;
+}
+EXPORT_SYMBOL_GPL(dcmipp_pads_init);
+
+int dcmipp_link_validate(struct media_link *link)
+{
+	/* TODO */
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dcmipp_link_validate);
+
+static const struct media_entity_operations dcmipp_ent_sd_mops = {
+	.link_validate = dcmipp_link_validate,
+};
+
+int dcmipp_ent_sd_register(struct dcmipp_ent_device *ved,
+			   struct v4l2_subdev *sd,
+			   struct v4l2_device *v4l2_dev,
+			   const char *const name,
+			   u32 function,
+			   u16 num_pads,
+			   const unsigned long *pads_flag,
+			   const struct v4l2_subdev_internal_ops *sd_int_ops,
+			   const struct v4l2_subdev_ops *sd_ops,
+			   irq_handler_t handler,
+			   irq_handler_t thread_fn)
+{
+	int ret;
+
+	/* Allocate the pads. Should be released from the sd_int_op release */
+	ved->pads = dcmipp_pads_init(num_pads, pads_flag);
+	if (IS_ERR(ved->pads))
+		return PTR_ERR(ved->pads);
+
+	/* Fill the dcmipp_ent_device struct */
+	ved->ent = &sd->entity;
+
+	/* Initialize the subdev */
+	v4l2_subdev_init(sd, sd_ops);
+	sd->internal_ops = sd_int_ops;
+	sd->entity.function = function;
+	sd->entity.ops = &dcmipp_ent_sd_mops;
+	sd->owner = THIS_MODULE;
+	strscpy(sd->name, name, sizeof(sd->name));
+	v4l2_set_subdevdata(sd, ved);
+
+	/* Expose this subdev to user space */
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	if (sd->ctrl_handler)
+		sd->flags |= V4L2_SUBDEV_FL_HAS_EVENTS;
+
+	/* Initialize the media entity */
+	ret = media_entity_pads_init(&sd->entity, num_pads, ved->pads);
+	if (ret)
+		goto err_clean_pads;
+
+	/* Register the subdev with the v4l2 and the media framework */
+	ret = v4l2_device_register_subdev(v4l2_dev, sd);
+	if (ret) {
+		dev_err(v4l2_dev->dev,
+			"%s: subdev register failed (err=%d)\n",
+			name, ret);
+		goto err_clean_m_ent;
+	}
+
+	ved->handler = handler;
+	ved->thread_fn = thread_fn;
+
+	return 0;
+
+err_clean_m_ent:
+	media_entity_cleanup(&sd->entity);
+err_clean_pads:
+	dcmipp_pads_cleanup(ved->pads);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(dcmipp_ent_sd_register);
+
+void dcmipp_ent_sd_unregister(struct dcmipp_ent_device *ved, struct v4l2_subdev *sd)
+{
+	media_entity_cleanup(ved->ent);
+	v4l2_device_unregister_subdev(sd);
+}
+EXPORT_SYMBOL_GPL(dcmipp_ent_sd_unregister);
diff --git a/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-common.h b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-common.h
new file mode 100644
index 000000000..50108fd45
--- /dev/null
+++ b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-common.h
@@ -0,0 +1,240 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#ifndef _DCMIPP_COMMON_H_
+#define _DCMIPP_COMMON_H_
+
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <media/media-device.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+
+#define DCMIPP_PDEV_NAME "dcmipp"
+
+/* DCMIPP-specific controls */
+#define DCMIPP_CID_DCMIPP_BASE		(0x00f00000 | 0xf000)
+#define DCMIPP_CID_DCMIPP_CLASS		(0x00f00000 | 1)
+#define DCMIPP_CID_TEST_PATTERN		(DCMIPP_CID_DCMIPP_BASE + 0)
+
+#define DCMIPP_FRAME_MAX_WIDTH 4096
+#define DCMIPP_FRAME_MAX_HEIGHT 2160
+#define DCMIPP_FRAME_MIN_WIDTH 16
+#define DCMIPP_FRAME_MIN_HEIGHT 16
+
+#define DCMIPP_FMT_WIDTH_DEFAULT  640
+#define DCMIPP_FMT_HEIGHT_DEFAULT 480
+
+#define DCMIPP_FRAME_INDEX(lin, col, width, bpp) \
+	(((lin) * (width) + (col)) * (bpp))
+
+#define DCMIPP_COLORSPACE_DEFAULT	V4L2_COLORSPACE_REC709
+#define DCMIPP_YCBCR_ENC_DEFAULT	V4L2_YCBCR_ENC_DEFAULT
+#define DCMIPP_QUANTIZATION_DEFAULT	V4L2_QUANTIZATION_DEFAULT
+#define DCMIPP_XFER_FUNC_DEFAULT	V4L2_XFER_FUNC_DEFAULT
+
+/**
+ * struct dcmipp_colorimetry_clamp - Adjust colorimetry parameters
+ *
+ * @fmt:		the pointer to struct v4l2_pix_format or
+ *			struct v4l2_mbus_framefmt
+ *
+ * Entities must check if colorimetry given by the userspace is valid, if not
+ * then set them as DEFAULT
+ */
+#define dcmipp_colorimetry_clamp(fmt)					\
+do {									\
+	if ((fmt)->colorspace == V4L2_COLORSPACE_DEFAULT ||		\
+	    (fmt)->colorspace > V4L2_COLORSPACE_DCI_P3) {		\
+		(fmt)->colorspace = DCMIPP_COLORSPACE_DEFAULT;		\
+		(fmt)->ycbcr_enc = DCMIPP_YCBCR_ENC_DEFAULT;		\
+		(fmt)->quantization = DCMIPP_QUANTIZATION_DEFAULT;	\
+		(fmt)->xfer_func = DCMIPP_XFER_FUNC_DEFAULT;		\
+	}								\
+	if ((fmt)->ycbcr_enc > V4L2_YCBCR_ENC_SMPTE240M)		\
+		(fmt)->ycbcr_enc = DCMIPP_YCBCR_ENC_DEFAULT;		\
+	if ((fmt)->quantization > V4L2_QUANTIZATION_LIM_RANGE)		\
+		(fmt)->quantization = DCMIPP_QUANTIZATION_DEFAULT;	\
+	if ((fmt)->xfer_func > V4L2_XFER_FUNC_SMPTE2084)		\
+		(fmt)->xfer_func = DCMIPP_XFER_FUNC_DEFAULT;		\
+} while (0)
+
+/**
+ * struct dcmipp_platform_data - platform data to components
+ *
+ * @entity_name:	The name of the entity to be created
+ *
+ * Board setup code will often provide additional information using the device's
+ * platform_data field to hold additional information.
+ * When injecting a new platform_device in the component system the core needs
+ * to provide to the corresponding submodules the name of the entity that should
+ * be used when registering the subdevice in the Media Controller system.
+ */
+struct dcmipp_platform_data {
+	char entity_name[32];
+};
+
+struct dcmipp_bind_data {
+	/* Internal v4l2 parent device*/
+	struct v4l2_device		*v4l2_dev;
+
+	/* Hardware resources */
+	struct reset_control		*rstc;
+	void __iomem			*regs;
+};
+
+/**
+ * struct dcmipp_ent_device - core struct that represents a node in the topology
+ *
+ * @ent:		the pointer to struct media_entity for the node
+ * @pads:		the list of pads of the node
+ * @process_frame:	callback send a frame to that node
+ * @vdev_get_format:	callback that returns the current format a pad, used
+ *			only when is_media_entity_v4l2_video_device(ent) returns
+ *			true
+ *
+ * Each node of the topology must create a dcmipp_ent_device struct. Depending on
+ * the node it will be of an instance of v4l2_subdev or video_device struct
+ * where both contains a struct media_entity.
+ * Those structures should embedded the dcmipp_ent_device struct through
+ * v4l2_set_subdevdata() and video_set_drvdata() respectivaly, allowing the
+ * dcmipp_ent_device struct to be retrieved from the corresponding struct
+ * media_entity
+ */
+struct dcmipp_ent_device {
+	struct media_entity *ent;
+	struct media_pad *pads;
+	void * (*process_frame)(struct dcmipp_ent_device *ved,
+				const void *frame);
+	void (*vdev_get_format)(struct dcmipp_ent_device *ved,
+				struct v4l2_pix_format *fmt);
+
+	/* Parallel input device */
+	struct v4l2_fwnode_bus_parallel	bus;
+	enum v4l2_mbus_type		bus_type;
+	irq_handler_t handler;
+	irqreturn_t handler_ret;
+	irq_handler_t thread_fn;
+};
+
+/**
+ * dcmipp_pads_init - initialize pads
+ *
+ * @num_pads:	number of pads to initialize
+ * @pads_flags:	flags to use in each pad
+ *
+ * Helper functions to allocate/initialize pads
+ */
+struct media_pad *dcmipp_pads_init(u16 num_pads,
+				   const unsigned long *pads_flag);
+
+/**
+ * dcmipp_pads_cleanup - free pads
+ *
+ * @pads: pointer to the pads
+ *
+ * Helper function to free the pads initialized with dcmipp_pads_init
+ */
+static inline void dcmipp_pads_cleanup(struct media_pad *pads)
+{
+	kfree(pads);
+}
+
+/**
+ * dcmipp_ent_sd_register - initialize and register a subdev node
+ *
+ * @ved:	the dcmipp_ent_device struct to be initialize
+ * @sd:		the v4l2_subdev struct to be initialize and registered
+ * @v4l2_dev:	the v4l2 device to register the v4l2_subdev
+ * @name:	name of the sub-device. Please notice that the name must be
+ *		unique.
+ * @function:	media entity function defined by MEDIA_ENT_F_* macros
+ * @num_pads:	number of pads to initialize
+ * @pads_flag:	flags to use in each pad
+ * @sd_int_ops:	pointer to &struct v4l2_subdev_internal_ops
+ * @sd_ops:	pointer to &struct v4l2_subdev_ops.
+ *
+ * Helper function initialize and register the struct dcmipp_ent_device and struct
+ * v4l2_subdev which represents a subdev node in the topology
+ */
+int dcmipp_ent_sd_register(struct dcmipp_ent_device *ved,
+			   struct v4l2_subdev *sd,
+			   struct v4l2_device *v4l2_dev,
+			   const char *const name,
+			   u32 function,
+			   u16 num_pads,
+			   const unsigned long *pads_flag,
+			   const struct v4l2_subdev_internal_ops *sd_int_ops,
+			   const struct v4l2_subdev_ops *sd_ops,
+			   irq_handler_t handler,
+			   irq_handler_t thread_fn);
+
+/**
+ * dcmipp_ent_sd_unregister - cleanup and unregister a subdev node
+ *
+ * @ved:	the dcmipp_ent_device struct to be cleaned up
+ * @sd:		the v4l2_subdev struct to be unregistered
+ *
+ * Helper function cleanup and unregister the struct dcmipp_ent_device and struct
+ * v4l2_subdev which represents a subdev node in the topology
+ */
+void dcmipp_ent_sd_unregister(struct dcmipp_ent_device *ved,
+			      struct v4l2_subdev *sd);
+
+/**
+ * dcmipp_link_validate - validates a media link
+ *
+ * @link: pointer to &struct media_link
+ *
+ * This function call validates if a media link is valid for streaming.
+ */
+int dcmipp_link_validate(struct media_link *link);
+
+#define reg_write(device, reg, val) \
+	(reg_write_dbg((device)->dev, #reg, (device)->regs, (reg), (val)))
+#define reg_read(device, reg) \
+	 (reg_read_dbg((device)->dev, #reg, (device)->regs, (reg)))
+#define reg_set(device, reg, mask) \
+	 (reg_set_dbg((device)->dev, #reg, (device)->regs, (reg), (mask)))
+#define reg_clear(device, reg, mask) \
+	 (reg_clear_dbg((device)->dev, #reg, (device)->regs, (reg), (mask)))
+
+static inline u32 reg_read_dbg(struct device *dev, const char *regname,
+			       void __iomem *base, u32 reg)
+{
+	u32 val = readl_relaxed(base + reg);
+
+	dev_dbg(dev, "RD  %s %#10.8x\n", regname, val);
+	return val;
+}
+
+static inline void reg_write_dbg(struct device *dev, const char *regname,
+				 void __iomem *base, u32 reg, u32 val)
+{
+	dev_dbg(dev, "WR  %s %#10.8x\n", regname, val);
+	writel_relaxed(val, base + reg);
+}
+
+static inline void reg_set_dbg(struct device *dev, const char *regname,
+			       void __iomem *base, u32 reg, u32 mask)
+{
+	dev_dbg(dev, "SET %s %#10.8x\n", regname, mask);
+	reg_write_dbg(dev, regname, base, reg, readl_relaxed(base + reg) | mask);
+}
+
+static inline void reg_clear_dbg(struct device *dev, const char *regname,
+				 void __iomem *base, u32 reg, u32 mask)
+{
+	dev_dbg(dev, "CLR %s %#10.8x\n", regname, mask);
+	reg_write_dbg(dev, regname, base, reg, readl_relaxed(base + reg) & ~mask);
+}
+
+#endif
+
diff --git a/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-core.c b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-core.c
new file mode 100644
index 000000000..e244fa41e
--- /dev/null
+++ b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-core.c
@@ -0,0 +1,816 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+#include <media/media-device.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+
+#include "dcmipp-common.h"
+
+#define DCMIPP_MDEV_MODEL_NAME "DCMIPP MDEV"
+
+#define DCMIPP_ENT_LINK(src, srcpad, sink, sinkpad, link_flags) {	\
+	.src_ent = src,						\
+	.src_pad = srcpad,					\
+	.sink_ent = sink,					\
+	.sink_pad = sinkpad,					\
+	.flags = link_flags,					\
+}
+
+#define DCMIPP_CMHWCFGR (0x200)
+#define DCMIPP_CMCR (0x204)
+#define DCMIPP_CMCR_INSEL BIT(0)
+#define DCMIPP_P0HWCFGR (0x400)
+#define DCMIPP_VERR (0xFF4)
+
+struct dcmipp_device {
+	/* The platform device */
+	struct platform_device		pdev;
+	struct device			*dev;
+
+	/* Hardware resources */
+	struct reset_control		*rstc;
+	void __iomem			*regs;
+	struct clk			*mclk;
+	struct clk			*kclk;
+
+	/* The pipeline configuration */
+	const struct dcmipp_pipeline_config	*pipe_cfg;
+
+	/* The Associated media_device parent */
+	struct media_device		mdev;
+
+	/* Internal v4l2 parent device*/
+	struct v4l2_device		v4l2_dev;
+
+	/* Subdevices */
+	struct platform_device		**subdevs;
+
+	struct v4l2_async_notifier	notifier;
+};
+
+static inline struct dcmipp_device *notifier_to_dcmipp(struct v4l2_async_notifier *n)
+{
+	return container_of(n, struct dcmipp_device, notifier);
+}
+
+/* Structure which describes individual configuration for each entity */
+struct dcmipp_ent_config {
+	const char *name;
+	const char *drv;
+};
+
+/* Structure which describes links between entities */
+struct dcmipp_ent_link {
+	unsigned int src_ent;
+	u16 src_pad;
+	unsigned int sink_ent;
+	u16 sink_pad;
+	u32 flags;
+};
+
+/* Structure which describes the whole topology */
+struct dcmipp_pipeline_config {
+	const struct dcmipp_ent_config *ents;
+	size_t num_ents;
+	const struct dcmipp_ent_link *links;
+	size_t num_links;
+};
+
+/* --------------------------------------------------------------------------
+ * Topology Configuration
+ */
+
+static const struct dcmipp_ent_config stm32mp13_ent_config[] = {
+	{
+		.name = "dcmipp_parallel",
+		.drv = "dcmipp-parallel",
+	},
+	{
+		.name = "dcmipp_dump_postproc",
+		.drv = "dcmipp-byteproc",
+	},
+	{
+		.name = "dcmipp_dump_capture",
+		.drv = "dcmipp-bytecap",
+	},
+};
+
+#define ID_PARALLEL 0
+#define ID_DUMP_BYTEPROC 1
+#define ID_DUMP_CAPTURE 2
+
+static const struct dcmipp_ent_link stm32mp13_ent_links[] = {
+	DCMIPP_ENT_LINK(ID_PARALLEL,      1, ID_DUMP_BYTEPROC, 0,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+	DCMIPP_ENT_LINK(ID_DUMP_BYTEPROC, 1, ID_DUMP_CAPTURE,  0,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+};
+
+static const struct dcmipp_pipeline_config stm32mp13_pipe_cfg = {
+	.ents		= stm32mp13_ent_config,
+	.num_ents	= ARRAY_SIZE(stm32mp13_ent_config),
+	.links		= stm32mp13_ent_links,
+	.num_links	= ARRAY_SIZE(stm32mp13_ent_links)
+};
+
+#define	ID_MAIN_ISP 3
+#define	ID_MAIN_POSTPROC 4
+#define	ID_MAIN_CAPTURE	5
+#define	ID_AUX_POSTPROC 6
+#define	ID_AUX_CAPTURE 7
+static const struct dcmipp_ent_config stm32mp25_ent_config[] = {
+	{
+		.name = "dcmipp_parallel",
+		.drv = "dcmipp-parallel",
+	},
+	{
+		.name = "dcmipp_dump_postproc",
+		.drv = "dcmipp-byteproc",
+	},
+	{
+		.name = "dcmipp_dump_capture",
+		.drv = "dcmipp-bytecap",
+	},
+	{
+		.name = "dcmipp_main_isp",
+		.drv = "dcmipp-isp",
+	},
+	{
+		.name = "dcmipp_main_postproc",
+		.drv = "dcmipp-pixelproc",
+	},
+	{
+		.name = "dcmipp_main_capture",
+		.drv = "dcmipp-pixelcap",
+	},
+	{
+		.name = "dcmipp_aux_postproc",
+		.drv = "dcmipp-pixelproc",
+	},
+	{
+		.name = "dcmipp_aux_capture",
+		.drv = "dcmipp-pixelcap",
+	},
+};
+
+static const struct dcmipp_ent_link stm32mp25_ent_links[] = {
+	DCMIPP_ENT_LINK(ID_PARALLEL,      1, ID_DUMP_BYTEPROC, 0, 0),
+	DCMIPP_ENT_LINK(ID_DUMP_BYTEPROC, 1, ID_DUMP_CAPTURE,  0,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+	DCMIPP_ENT_LINK(ID_PARALLEL,	1, ID_MAIN_ISP,  0, 0),
+	DCMIPP_ENT_LINK(ID_MAIN_ISP,	1, ID_MAIN_POSTPROC,  0,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+	DCMIPP_ENT_LINK(ID_MAIN_ISP,	2, ID_AUX_POSTPROC,  0, 0),
+	DCMIPP_ENT_LINK(ID_MAIN_POSTPROC,	1, ID_MAIN_CAPTURE,  0,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+	DCMIPP_ENT_LINK(ID_PARALLEL,	1, ID_AUX_POSTPROC,  0, 0),
+	DCMIPP_ENT_LINK(ID_AUX_POSTPROC,	1, ID_AUX_CAPTURE,  0,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+};
+
+static const struct dcmipp_pipeline_config stm32mp25_pipe_cfg = {
+	.ents		= stm32mp25_ent_config,
+	.num_ents	= ARRAY_SIZE(stm32mp25_ent_config),
+	.links		= stm32mp25_ent_links,
+	.num_links	= ARRAY_SIZE(stm32mp25_ent_links)
+};
+
+/* -------------------------------------------------------------------------- */
+#define LINK_FLAG_TO_STR(f) ((f) == 0 ? "" :\
+			     (f) == MEDIA_LNK_FL_ENABLED ? "ENABLED" :\
+			     (f) == MEDIA_LNK_FL_IMMUTABLE ? "IMMUTABLE" :\
+			     (f) == (MEDIA_LNK_FL_ENABLED |\
+				     MEDIA_LNK_FL_IMMUTABLE) ?\
+					"ENABLED, IMMUTABLE" :\
+			     "UNKNOWN")
+
+static int dcmipp_create_links(struct dcmipp_device *dcmipp)
+{
+	unsigned int i;
+	int ret;
+
+	/* Initialize the links between entities */
+	for (i = 0; i < dcmipp->pipe_cfg->num_links; i++) {
+		const struct dcmipp_ent_link *link = &dcmipp->pipe_cfg->links[i];
+		/*
+		 * TODO: Check another way of retrieving ved struct without
+		 * relying on platform_get_drvdata
+		 */
+		struct dcmipp_ent_device *ved_src =
+			platform_get_drvdata(dcmipp->subdevs[link->src_ent]);
+		struct dcmipp_ent_device *ved_sink =
+			platform_get_drvdata(dcmipp->subdevs[link->sink_ent]);
+
+		dev_dbg(dcmipp->dev, "Create link \"%s\":%d -> %d:\"%s\" [%s]\n",
+			dcmipp->pipe_cfg->ents[link->src_ent].name,
+			link->src_pad,
+			link->sink_pad,
+			dcmipp->pipe_cfg->ents[link->sink_ent].name,
+			LINK_FLAG_TO_STR(link->flags));
+
+		ret = media_create_pad_link(ved_src->ent, link->src_pad,
+					    ved_sink->ent, link->sink_pad,
+					    link->flags);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int dcmipp_graph_init(struct dcmipp_device *dcmipp);
+
+static int dcmipp_comp_bind(struct device *master)
+{
+	struct dcmipp_device *dcmipp = platform_get_drvdata(to_platform_device(master));
+	struct dcmipp_bind_data bind_data;
+	int ret;
+
+	/* Register the v4l2 struct */
+	ret = v4l2_device_register(dcmipp->mdev.dev, &dcmipp->v4l2_dev);
+	if (ret) {
+		dev_err(dcmipp->mdev.dev,
+			"v4l2 device register failed (err=%d)\n", ret);
+		return ret;
+	}
+
+	/* Bind subdevices */
+	bind_data.v4l2_dev = &dcmipp->v4l2_dev;
+	bind_data.rstc = dcmipp->rstc;
+	bind_data.regs = dcmipp->regs;
+	ret = component_bind_all(master, &bind_data);
+	if (ret)
+		goto err_v4l2_unregister;
+
+	/* Initialize links */
+	ret = dcmipp_create_links(dcmipp);
+	if (ret)
+		goto err_comp_unbind_all;
+
+	ret = dcmipp_graph_init(dcmipp);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+
+	media_device_unregister(&dcmipp->mdev);
+	media_device_cleanup(&dcmipp->mdev);
+err_comp_unbind_all:
+	component_unbind_all(master, NULL);
+err_v4l2_unregister:
+	v4l2_device_unregister(&dcmipp->v4l2_dev);
+
+	return ret;
+}
+
+static void dcmipp_comp_unbind(struct device *master)
+{
+	struct dcmipp_device *dcmipp = platform_get_drvdata(to_platform_device(master));
+
+	v4l2_async_notifier_unregister(&dcmipp->notifier);
+	v4l2_async_notifier_cleanup(&dcmipp->notifier);
+
+	media_device_unregister(&dcmipp->mdev);
+	media_device_cleanup(&dcmipp->mdev);
+	component_unbind_all(master, NULL);
+	v4l2_device_unregister(&dcmipp->v4l2_dev);
+}
+
+static int dcmipp_comp_compare(struct device *comp, void *data)
+{
+	return comp == data;
+}
+
+static struct component_match *dcmipp_add_subdevs(struct dcmipp_device *dcmipp)
+{
+	struct component_match *match = NULL;
+	struct dcmipp_platform_data pdata;
+	int i;
+
+	for (i = 0; i < dcmipp->pipe_cfg->num_ents; i++) {
+		dev_dbg(dcmipp->dev, "new pdev for %s (%s)\n",
+			dcmipp->pipe_cfg->ents[i].drv,
+			dcmipp->pipe_cfg->ents[i].name);
+
+		strscpy(pdata.entity_name, dcmipp->pipe_cfg->ents[i].name,
+			sizeof(pdata.entity_name));
+
+		dcmipp->subdevs[i] =
+			platform_device_register_data
+				(dcmipp->dev,
+				 dcmipp->pipe_cfg->ents[i].drv,
+				 PLATFORM_DEVID_AUTO,
+				 &pdata,
+				 sizeof(pdata));
+		if (IS_ERR(dcmipp->subdevs[i])) {
+			match = ERR_CAST(dcmipp->subdevs[i]);
+			while (--i >= 0)
+				platform_device_unregister(dcmipp->subdevs[i]);
+
+			dev_err(dcmipp->mdev.dev,
+				"%s error (err=%ld)\n", __func__,
+				PTR_ERR(match));
+			return match;
+		}
+
+		component_match_add(dcmipp->dev, &match, dcmipp_comp_compare,
+				    &dcmipp->subdevs[i]->dev);
+	}
+
+	return match;
+}
+
+static void dcmipp_rm_subdevs(struct dcmipp_device *dcmipp)
+{
+	unsigned int i;
+
+	for (i = 0; i < dcmipp->pipe_cfg->num_ents; i++)
+		platform_device_unregister(dcmipp->subdevs[i]);
+}
+
+static const struct component_master_ops dcmipp_comp_ops = {
+	.bind = dcmipp_comp_bind,
+	.unbind = dcmipp_comp_unbind,
+};
+
+static const struct of_device_id dcmipp_of_match[] = {
+	{ .compatible = "st,stm32mp13-dcmipp", .data = &stm32mp13_pipe_cfg},
+	{ .compatible = "st,stm32mp25-dcmipp", .data = &stm32mp25_pipe_cfg},
+	{ /* end node */ },
+};
+MODULE_DEVICE_TABLE(of, dcmipp_of_match);
+
+static int dcmipp_graph_notify_complete(struct v4l2_async_notifier *notifier)
+{
+	struct dcmipp_device *dcmipp = notifier_to_dcmipp(notifier);
+	int ret;
+
+	/* Register the media device */
+	ret = media_device_register(&dcmipp->mdev);
+	if (ret) {
+		dev_err(dcmipp->mdev.dev,
+			"media device register failed (err=%d)\n", ret);
+		return ret;
+	}
+
+	/* Expose all subdev's nodes*/
+	ret = v4l2_device_register_subdev_nodes(&dcmipp->v4l2_dev);
+	if (ret) {
+		dev_err(dcmipp->mdev.dev,
+			"dcmipp subdev nodes registration failed (err=%d)\n",
+			ret);
+		media_device_unregister(&dcmipp->mdev);
+		return ret;
+	}
+
+	dev_dbg(dcmipp->dev, "Notify complete !\n");
+
+	return 0;
+}
+
+static void dcmipp_graph_notify_unbind(struct v4l2_async_notifier *notifier,
+				       struct v4l2_subdev *sd,
+				       struct v4l2_async_subdev *asd)
+{
+	struct dcmipp_device *dcmipp = notifier_to_dcmipp(notifier);
+
+	dev_dbg(dcmipp->dev, "Removing %s\n", sd->name);
+}
+
+static irqreturn_t dcmipp_irq_thread(int irq, void *arg)
+{
+	struct dcmipp_device *dcmipp = arg;
+	struct dcmipp_ent_device *ved;
+	unsigned int i;
+
+	/* Call irq thread of each entities of pipeline */
+	for (i = 0; i < dcmipp->pipe_cfg->num_ents; i++) {
+		ved = platform_get_drvdata(dcmipp->subdevs[i]);
+		if (ved->thread_fn && ved->handler_ret == IRQ_WAKE_THREAD)
+			ved->thread_fn(irq, ved);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t dcmipp_irq_callback(int irq, void *arg)
+{
+	struct dcmipp_device *dcmipp = arg;
+	struct dcmipp_ent_device *ved;
+	irqreturn_t ret = IRQ_HANDLED;
+	unsigned int i;
+
+	/* Call irq handler of each entities of pipeline */
+	for (i = 0; i < dcmipp->pipe_cfg->num_ents; i++) {
+		ved = platform_get_drvdata(dcmipp->subdevs[i]);
+		if (ved->handler)
+			ved->handler_ret = ved->handler(irq, ved);
+		else if (ved->thread_fn)
+			ved->handler_ret = IRQ_WAKE_THREAD;
+		else
+			ved->handler_ret = IRQ_HANDLED;
+		if (ved->handler_ret != IRQ_HANDLED)
+			ret = ved->handler_ret;
+	}
+
+	return ret;
+}
+
+static int dcmipp_graph_notify_bound(struct v4l2_async_notifier *notifier,
+				     struct v4l2_subdev *subdev,
+				     struct v4l2_async_subdev *asd)
+{
+	struct dcmipp_device *dcmipp = notifier_to_dcmipp(notifier);
+	unsigned int ret;
+	int src_pad;
+	struct dcmipp_ent_device *sink;
+	struct device_node *np = dcmipp->dev->of_node;
+	struct v4l2_fwnode_endpoint ep = { .bus_type = 0 };
+	struct device_node *_np = dcmipp->dev->of_node;//FIXME _np/_ep...
+	struct device_node *_ep;
+	struct media_link *link;
+	u32 flags = MEDIA_LNK_FL_ENABLED;
+
+	dev_dbg(dcmipp->dev, "Subdev \"%s\" bound\n", subdev->name);
+
+	/*
+	 * Link this sub-device to DCMIPP, it could be
+	 * a parallel camera sensor or a CSI-2 to parallel bridge
+	 */
+
+	src_pad = media_entity_get_fwnode_pad(&subdev->entity,
+					      subdev->fwnode,
+					      MEDIA_PAD_FL_SOURCE);
+
+	/* Get bus characteristics from devicetree */
+	np = of_graph_get_next_endpoint(np, NULL);
+	if (!np) {
+		dev_err(dcmipp->dev, "Could not find the endpoint\n");
+		of_node_put(np);
+		return -ENODEV;
+	}
+
+	ret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(np), &ep);
+	of_node_put(np);
+	if (ret) {
+		dev_err(dcmipp->dev, "Could not parse the endpoint\n");
+		return ret;
+	}
+
+	if ((ep.bus_type == V4L2_MBUS_PARALLEL ||
+	     ep.bus_type == V4L2_MBUS_BT656) &&
+	     ep.bus.parallel.bus_width > 0) {
+		/* Only 8 bits bus width supported with BT656 bus */
+		if (ep.bus_type == V4L2_MBUS_BT656 &&
+		    ep.bus.parallel.bus_width != 8) {
+			dev_err(dcmipp->dev, "BT656 bus conflicts with %u bits bus width (8 bits required)\n",
+				ep.bus.parallel.bus_width);
+			return -ENODEV;
+		}
+
+		/*
+		 * Parallel input device detected
+		 * Connect it to parallel subdev
+		 */
+		sink = platform_get_drvdata(dcmipp->subdevs[ID_PARALLEL]);
+		sink->bus.flags = ep.bus.parallel.flags;
+		sink->bus.bus_width = ep.bus.parallel.bus_width;
+		sink->bus.data_shift = ep.bus.parallel.data_shift;
+		sink->bus_type = ep.bus_type;
+		ret = media_create_pad_link(&subdev->entity, src_pad,
+					    sink->ent, 0,
+					    MEDIA_LNK_FL_IMMUTABLE |
+					    MEDIA_LNK_FL_ENABLED);
+		if (ret)
+			dev_err(dcmipp->dev, "Failed to create media pad link with subdev \"%s\"\n",
+				subdev->name);
+		else
+			dev_dbg(dcmipp->dev, "DCMIPP is now linked to \"%s\"\n",
+				subdev->name);
+
+		/* Enable all links from the parallel subdev */
+		list_for_each_entry(link, &sink->ent->links, list) {
+			/* Only enable link starting from the parallel subdev */
+			if (link->source->entity == sink->ent) {
+				ret = media_entity_setup_link(link, MEDIA_LNK_FL_ENABLED);
+				if (ret)
+					dev_err(dcmipp->dev, "Failed to setup link (%d)\n", ret);
+			}
+		}
+
+		/* Use the parallel interface */
+		reg_write(dcmipp, DCMIPP_CMCR, 0);
+
+		return 0;
+	}
+
+	/*
+	 * CSI-2 receiver
+	 * Connect all of its channels to the DCMIPP pipes
+	 */
+	for_each_endpoint_of_node(_np, _ep) {
+		struct of_endpoint endpoint;
+		unsigned int sink_ids[3] = {ID_DUMP_BYTEPROC, ID_MAIN_ISP, ID_AUX_POSTPROC};
+		unsigned int i;
+
+		of_graph_parse_endpoint(_ep, &endpoint);
+		dev_info(dcmipp->dev, "endpoint.port=%d\n", endpoint.port);
+//FIXME check	if ((src_pad + endpoint.port) > subdev->entity.num_pads)
+
+		for (i = 0; i < ARRAY_SIZE(sink_ids); i++) {
+			sink = platform_get_drvdata(dcmipp->subdevs[sink_ids[i]]);
+			ret = media_create_pad_link(&subdev->entity, src_pad + endpoint.port,
+						    sink->ent, 0,
+						    flags);
+			if (ret)
+				dev_err(dcmipp->dev, "Failed to create link \"%s\":%d -> %d:\"%s\" [%s]\n",
+					subdev->name, src_pad + endpoint.port,
+					0, sink->ent->name,
+					LINK_FLAG_TO_STR(flags));
+			else
+				dev_dbg(dcmipp->dev, "Create link \"%s\":%d -> %d:\"%s\" [%s]\n",
+					subdev->name, src_pad + endpoint.port,
+					0, sink->ent->name,
+					LINK_FLAG_TO_STR(flags));
+		}
+
+		/*
+		 * Enable media link of first port connection by default,
+		 * Let the other connections disabled, they could be enabled
+		 * later on using MC
+		 */
+		flags = 0;
+	}
+
+	/* Use the CSI interface */
+	reg_write(dcmipp, DCMIPP_CMCR, DCMIPP_CMCR_INSEL);
+
+	return ret;
+}
+
+static const struct v4l2_async_notifier_operations dcmipp_graph_notify_ops = {
+	.bound = dcmipp_graph_notify_bound,
+	.unbind = dcmipp_graph_notify_unbind,
+	.complete = dcmipp_graph_notify_complete,
+};
+
+static int dcmipp_graph_init(struct dcmipp_device *dcmipp)
+{
+	struct v4l2_async_subdev *asd;
+	struct device_node *ep;
+	int ret;
+
+	ep = of_graph_get_next_endpoint(dcmipp->dev->of_node, NULL);
+	if (!ep) {
+		dev_err(dcmipp->dev, "Failed to get next endpoint\n");
+		return -EINVAL;
+	}
+
+	v4l2_async_notifier_init(&dcmipp->notifier);
+
+	asd = v4l2_async_notifier_add_fwnode_remote_subdev
+		(&dcmipp->notifier, of_fwnode_handle(ep),
+		 struct v4l2_async_subdev);
+
+	of_node_put(ep);
+
+	if (IS_ERR(asd)) {
+		dev_err(dcmipp->dev, "Failed to add fwnode remote subdev\n");
+		return PTR_ERR(asd);
+	}
+
+	dcmipp->notifier.ops = &dcmipp_graph_notify_ops;
+
+	ret = v4l2_async_notifier_register(&dcmipp->v4l2_dev, &dcmipp->notifier);
+	if (ret < 0) {
+		dev_err(dcmipp->dev, "Failed to register notifier\n");
+		v4l2_async_notifier_cleanup(&dcmipp->notifier);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int dcmipp_probe(struct platform_device *pdev)
+{
+	struct dcmipp_device *dcmipp;
+	struct component_match *comp_match = NULL;
+	struct resource *res;
+	struct clk *kclk, *mclk;
+	const struct dcmipp_pipeline_config *pipe_cfg;
+	int irq;
+	int ret;
+
+	dcmipp = devm_kzalloc(&pdev->dev, sizeof(struct dcmipp_device), GFP_KERNEL);
+	if (!dcmipp)
+		return -ENOMEM;
+
+	dcmipp->dev = &pdev->dev;
+
+	pipe_cfg = of_device_get_match_data(&pdev->dev);
+	if (!pipe_cfg) {
+		dev_err(&pdev->dev, "Can't get device data\n");
+		return -ENODEV;
+	}
+	dcmipp->pipe_cfg = pipe_cfg;
+
+	platform_set_drvdata(pdev, dcmipp);
+
+	/* Get hardware resources from devicetree */
+	dcmipp->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);
+	if (IS_ERR(dcmipp->rstc))
+		return dev_err_probe(&pdev->dev, PTR_ERR(dcmipp->rstc),
+				     "Could not get reset control\n");
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq <= 0) {
+		if (irq != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Could not get irq\n");
+		return irq ? irq : -ENXIO;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "Could not get resource\n");
+		return -ENODEV;
+	}
+
+	dcmipp->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(dcmipp->regs)) {
+		dev_err(&pdev->dev, "Could not map registers\n");
+		return PTR_ERR(dcmipp->regs);
+	}
+
+	ret = devm_request_threaded_irq(&pdev->dev, irq, dcmipp_irq_callback,
+					dcmipp_irq_thread, IRQF_ONESHOT,
+					dev_name(&pdev->dev), dcmipp);
+	if (ret) {
+		dev_err(&pdev->dev, "Unable to request irq %d\n", irq);
+		return ret;
+	}
+
+	/* Reset device */
+	ret = reset_control_assert(dcmipp->rstc);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to assert the reset line\n");
+		return ret;
+	}
+
+	usleep_range(3000, 5000);
+
+	ret = reset_control_deassert(dcmipp->rstc);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to deassert the reset line\n");
+		return ret;
+	}
+
+	kclk = devm_clk_get(&pdev->dev, "kclk");
+	if (IS_ERR(kclk))
+		return dev_err_probe(&pdev->dev, PTR_ERR(kclk),
+				     "Unable to get kclk\n");
+	dcmipp->kclk = kclk;
+
+	mclk = devm_clk_get(&pdev->dev, "mclk");
+	if (IS_ERR(kclk))
+		return dev_err_probe(&pdev->dev, PTR_ERR(mclk),
+				     "Unable to get mclk\n");
+	dcmipp->mclk = mclk;
+
+	/* Create platform_device for each entity in the topology */
+	dcmipp->subdevs = devm_kcalloc(&pdev->dev, dcmipp->pipe_cfg->num_ents,
+				       sizeof(*dcmipp->subdevs), GFP_KERNEL);
+	if (!dcmipp->subdevs)
+		return -ENOMEM;
+
+	comp_match = dcmipp_add_subdevs(dcmipp);
+	if (IS_ERR(comp_match))
+		return PTR_ERR(comp_match);
+
+	/* Link the media device within the v4l2_device */
+	dcmipp->v4l2_dev.mdev = &dcmipp->mdev;
+
+	/* Initialize media device */
+	strscpy(dcmipp->mdev.model, DCMIPP_MDEV_MODEL_NAME,
+		sizeof(dcmipp->mdev.model));
+	snprintf(dcmipp->mdev.bus_info, sizeof(dcmipp->mdev.bus_info),
+		 "platform:%s", DCMIPP_PDEV_NAME);
+	dcmipp->mdev.dev = &pdev->dev;
+	media_device_init(&dcmipp->mdev);
+
+	/* Add self to the component system */
+	ret = component_master_add_with_match(&pdev->dev, &dcmipp_comp_ops,
+					      comp_match);
+	if (ret) {
+		media_device_cleanup(&dcmipp->mdev);
+		dcmipp_rm_subdevs(dcmipp);
+		return ret;
+	}
+
+	pm_runtime_enable(dcmipp->dev);
+
+	dev_info(&pdev->dev, "Probe done");
+
+	return 0;
+}
+
+static int dcmipp_remove(struct platform_device *pdev)
+{
+	struct dcmipp_device *dcmipp = platform_get_drvdata(pdev);
+
+	pm_runtime_disable(&pdev->dev);
+
+	component_master_del(&pdev->dev, &dcmipp_comp_ops);
+	dcmipp_rm_subdevs(dcmipp);
+
+	return 0;
+}
+
+static __maybe_unused int dcmipp_runtime_suspend(struct device *dev)
+{
+	struct dcmipp_device *dcmipp = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(dcmipp->kclk);
+	clk_disable_unprepare(dcmipp->mclk);
+
+	return 0;
+}
+
+static __maybe_unused int dcmipp_runtime_resume(struct device *dev)
+{
+	struct dcmipp_device *dcmipp = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(dcmipp->mclk);
+	if (ret)
+		dev_err(dev, "%s: Failed to prepare_enable clock\n", __func__);
+
+	ret = clk_prepare_enable(dcmipp->kclk);
+	if (ret)
+		dev_err(dev, "%s: Failed to prepare_enable k clock\n", __func__);
+
+	return ret;
+}
+
+static __maybe_unused int dcmipp_suspend(struct device *dev)
+{
+	/* disable clock */
+	pm_runtime_force_suspend(dev);
+
+	/* change pinctrl state */
+	pinctrl_pm_select_sleep_state(dev);
+
+	return 0;
+}
+
+static __maybe_unused int dcmipp_resume(struct device *dev)
+{
+	/* restore pinctl default state */
+	pinctrl_pm_select_default_state(dev);
+
+	/* clock enable */
+	pm_runtime_force_resume(dev);
+
+	return 0;
+}
+
+static const struct dev_pm_ops dcmipp_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(dcmipp_suspend, dcmipp_resume)
+	SET_RUNTIME_PM_OPS(dcmipp_runtime_suspend,
+			   dcmipp_runtime_resume, NULL)
+};
+
+static struct platform_driver dcmipp_pdrv = {
+	.probe		= dcmipp_probe,
+	.remove		= dcmipp_remove,
+	.driver		= {
+		.name	= DCMIPP_PDEV_NAME,
+		.of_match_table = of_match_ptr(dcmipp_of_match),
+		.pm = &dcmipp_pm_ops,
+	},
+};
+
+module_platform_driver(dcmipp_pdrv);
+
+MODULE_AUTHOR("Hugues Fruchet <hugues.fruchet@foss.st.com>");
+MODULE_AUTHOR("Alain Volmat <alain.volmat@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 Digital Camera Memory Interface with Pixel Processor driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-isp.c b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-isp.c
new file mode 100644
index 000000000..2d0ee70a0
--- /dev/null
+++ b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-isp.c
@@ -0,0 +1,1005 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include <linux/component.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/vmalloc.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-rect.h>
+#include <media/v4l2-subdev.h>
+
+#include "dcmipp-common.h"
+#include "dcmipp-colorconv.h"
+
+#define DCMIPP_ISP_DRV_NAME "dcmipp-isp"
+
+#define DCMIPP_FMT_WIDTH_DEFAULT  640
+#define DCMIPP_FMT_HEIGHT_DEFAULT 480
+
+#define DCMIPP_P1FSCR (0x804)
+#define DCMIPP_P1FSCR_DTIDA_MASK GENMASK(5, 0)
+#define DCMIPP_P1FSCR_DTIDA_SHIFT 0
+#define DCMIPP_P1FSCR_PIPEDIFF BIT(18)
+#define DCMIPP_P1SRCR (0x820)
+#define DCMIPP_P1SRCR_LASTLINE_SHIFT 0
+#define DCMIPP_P1SRCR_LASTLINE_MASK GENMASK(11, 0)
+#define DCMIPP_P1SRCR_FIRSTLINEDEL_SHIFT 12
+#define DCMIPP_P1SRCR_FIRSTLINEDEL_MASK GENMASK(14, 12)
+#define DCMIPP_P1SRCR_CROPEN BIT(15)
+
+#define DCMIPP_P1BPRCR (0x824)
+#define DCMIPP_P1BPRCR_ENABLE BIT(0)
+#define DCMIPP_P1BPRCR_STRENGTH_SHIFT 1
+#define DCMIPP_P1BPRCR_STRENGTH_MASK GENMASK(3, 1)
+
+#define DCMIPP_P1BPRSR (0x828)
+#define DCMIPP_P1BPRSR_BADCNT_MASK GENMASK(11, 0)
+
+#define DCMIPP_P1DECR (0x830)
+#define DCMIPP_P1DECR_ENABLE BIT(0)
+#define DCMIPP_P1DECR_HDEC_SHIFT 1
+#define DCMIPP_P1DECR_HDEC_MASK GENMASK(2, 1)
+#define DCMIPP_P1DECR_VDEC_SHIFT 3
+#define DCMIPP_P1DECR_VDEC_MASK GENMASK(4, 3)
+
+#define DCMIPP_P1BLCCR (0x840)
+#define DCMIPP_P1BLCCR_ENABLE BIT(0)
+#define DCMIPP_P1BLCCR_BLCB_SHIFT 8
+#define DCMIPP_P1BLCCR_BLCB_MASK GENMASK(15, 8)
+#define DCMIPP_P1BLCCR_BLCG_SHIFT 16
+#define DCMIPP_P1BLCCR_BLCG_MASK GENMASK(23, 16)
+#define DCMIPP_P1BLCCR_BLCR_SHIFT 24
+#define DCMIPP_P1BLCCR_BLCR_MASK GENMASK(31, 24)
+
+#define DCMIPP_P1DMCR (0x870)
+#define DCMIPP_P1DMCR_ENABLE BIT(0)
+#define DCMIPP_P1DMCR_TYPE_SHIFT 1
+#define DCMIPP_P1DMCR_TYPE_MASK GENMASK(2, 1)
+#define DCMIPP_P1DMCR_TYPE_RGGB 0x0
+#define DCMIPP_P1DMCR_TYPE_GRBG 0x1
+#define DCMIPP_P1DMCR_TYPE_GBRG 0x2
+#define DCMIPP_P1DMCR_TYPE_BGGR 0x3
+#define DCMIPP_P1DMCR_PEAK_SHIFT 16
+#define DCMIPP_P1DMCR_PEAK_MASK GENMASK(19, 16)
+#define DCMIPP_P1DMCR_LINEV_SHIFT 20
+#define DCMIPP_P1DMCR_LINEV_MASK GENMASK(23, 20)
+#define DCMIPP_P1DMCR_LINEH_SHIFT 24
+#define DCMIPP_P1DMCR_LINEH_MASK GENMASK(27, 24)
+#define DCMIPP_P1DMCR_EDGE_SHIFT 28
+#define DCMIPP_P1DMCR_EDGE_MASK GENMASK(31, 28)
+
+#define DCMIPP_P1CCCR (0x880)
+#define DCMIPP_P1CCCR_ENABLE BIT(0)
+#define DCMIPP_P1CCCR_TYPE_YUV 0
+#define DCMIPP_P1CCCR_TYPE_RGB BIT(1)
+#define DCMIPP_P1CCCR_CLAMP BIT(2)
+#define DCMIPP_P1CCRR1 (0x884)
+#define DCMIPP_P1CCRR2 (0x888)
+#define DCMIPP_P1CCGR1 (0x88C)
+#define DCMIPP_P1CCGR2 (0x890)
+#define DCMIPP_P1CCBR1 (0x894)
+#define DCMIPP_P1CCBR2 (0x898)
+
+#define DCMIPP_P1CRSZR (0x908)
+#define DCMIPP_P1CRSZR_HSIZE_SHIFT 0
+#define DCMIPP_P1CRSZR_HSIZE_MASK GENMASK(11, 0)
+#define DCMIPP_P1CRSZR_VSIZE_SHIFT 16
+#define DCMIPP_P1CRSZR_VSIZE_MASK GENMASK(27, 16)
+#define DCMIPP_P1CRSZR_ENABLE BIT(31)
+
+#define DCMIPP_P1DSCR (0x910)
+#define DCMIPP_P1DSCR_HDIV_SHIFT 0
+#define DCMIPP_P1DSCR_HDIV_MASK GENMASK(9, 0)
+#define DCMIPP_P1DSCR_VDIV_SHIFT 16
+#define DCMIPP_P1DSCR_VDIV_MASK GENMASK(25, 16)
+#define DCMIPP_P1DSCR_ENABLE BIT(31)
+
+#define IS_SINK(pad) (!(pad))
+#define IS_SRC(pad)  ((pad))
+#define PAD_STR(pad) (IS_SRC((pad))) ? "src" : "sink"
+
+#define ISP_MEDIA_BUS_SINK_FMT_DEFAULT MEDIA_BUS_FMT_RGB565_2X8_LE
+#define ISP_MEDIA_BUS_SRC_FMT_DEFAULT MEDIA_BUS_FMT_RGB888_1X24
+
+struct dcmipp_isp_pix_map {
+	unsigned int code;
+	unsigned int dt;
+};
+
+#define PIXMAP_MBUS(mbus, datatype) \
+		{						\
+			.code = MEDIA_BUS_FMT_##mbus,		\
+			.dt = datatype,		\
+		}
+static const struct dcmipp_isp_pix_map dcmipp_isp_sink_pix_map_list[] = {
+	/* RGB565 */
+	PIXMAP_MBUS(RGB565_2X8_LE, 0x22),
+	/* YUV422 */
+	PIXMAP_MBUS(YUYV8_2X8, 0x1e),
+	PIXMAP_MBUS(UYVY8_2X8, 0x1e),
+	PIXMAP_MBUS(YVYU8_2X8, 0x1e),
+	PIXMAP_MBUS(VYUY8_2X8, 0x1e),
+	/* GREY */
+	PIXMAP_MBUS(Y8_1X8, 0x00), /* TODO - DT value to be fixed */
+	/* Raw Bayer */
+	/* Raw 8 */
+	PIXMAP_MBUS(SBGGR8_1X8, 0x2a),
+	PIXMAP_MBUS(SGBRG8_1X8, 0x2a),
+	PIXMAP_MBUS(SGRBG8_1X8, 0x2a),
+	PIXMAP_MBUS(SRGGB8_1X8, 0x2a),
+	/* Raw 10 */
+	PIXMAP_MBUS(SBGGR10_1X10, 0x2b),
+	PIXMAP_MBUS(SGBRG10_1X10, 0x2b),
+	PIXMAP_MBUS(SGRBG10_1X10, 0x2b),
+	PIXMAP_MBUS(SRGGB10_1X10, 0x2b),
+	/* Raw 12 */
+	PIXMAP_MBUS(SBGGR12_1X12, 0x2c),
+	PIXMAP_MBUS(SGBRG12_1X12, 0x2c),
+	PIXMAP_MBUS(SGRBG12_1X12, 0x2c),
+	PIXMAP_MBUS(SRGGB12_1X12, 0x2c),
+	/* Raw 14 */
+	PIXMAP_MBUS(SBGGR14_1X14, 0x2d),
+	PIXMAP_MBUS(SGBRG14_1X14, 0x2d),
+	PIXMAP_MBUS(SGRBG14_1X14, 0x2d),
+	PIXMAP_MBUS(SRGGB14_1X14, 0x2d),
+};
+
+static const struct dcmipp_isp_pix_map dcmipp_isp_src_pix_map_list[] = {
+	PIXMAP_MBUS(RGB888_1X24, 0),
+	PIXMAP_MBUS(YUV8_1X24, 0),
+};
+
+static const struct dcmipp_isp_pix_map *
+dcmipp_isp_pix_map_by_index(unsigned int i, unsigned int pad)
+{
+	const struct dcmipp_isp_pix_map *l;
+	unsigned int size;
+
+	if (IS_SRC(pad)) {
+		l = dcmipp_isp_src_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_isp_src_pix_map_list);
+	} else {
+		l = dcmipp_isp_sink_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_isp_sink_pix_map_list);
+	}
+
+	if (i >= size)
+		return NULL;
+
+	return &l[i];
+}
+
+static const struct dcmipp_isp_pix_map *
+dcmipp_isp_pix_map_by_code(u32 code, unsigned int pad)
+{
+	const struct dcmipp_isp_pix_map *l;
+	unsigned int size;
+	unsigned int i;
+
+	if (IS_SRC(pad)) {
+		l = dcmipp_isp_src_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_isp_src_pix_map_list);
+	} else {
+		l = dcmipp_isp_sink_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_isp_sink_pix_map_list);
+	}
+
+	for (i = 0; i < size; i++) {
+		if (l[i].code == code)
+			return &l[i];
+	}
+
+	return NULL;
+}
+
+struct dcmipp_isp_device {
+	struct dcmipp_ent_device ved;
+	struct v4l2_subdev sd;
+	struct device *dev;
+	struct v4l2_mbus_framefmt sink_fmt;
+	struct v4l2_mbus_framefmt src_fmt;
+	unsigned int decimation;
+	struct v4l2_rect crop;
+	struct v4l2_rect compose;
+	bool streaming;
+	/* Protect this data structure */
+	struct mutex lock;
+
+	void __iomem *regs;
+
+	struct v4l2_ctrl_handler ctrls;
+};
+
+static const struct v4l2_mbus_framefmt fmt_sink_default = {
+	.width = DCMIPP_FMT_WIDTH_DEFAULT,
+	.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	.code = ISP_MEDIA_BUS_SINK_FMT_DEFAULT,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_DEFAULT,
+};
+
+static const struct v4l2_mbus_framefmt fmt_src_default = {
+	.width = DCMIPP_FMT_WIDTH_DEFAULT,
+	.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	.code = ISP_MEDIA_BUS_SRC_FMT_DEFAULT,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_DEFAULT,
+};
+
+/*
+ * Functions handling controls
+ */
+#define V4L2_CID_ISP_DEMOSAICING_PEAK	(V4L2_CID_USER_BASE | 0x1001)
+#define V4L2_CID_ISP_DEMOSAICING_LINEH	(V4L2_CID_USER_BASE | 0x1002)
+#define V4L2_CID_ISP_DEMOSAICING_LINEV	(V4L2_CID_USER_BASE | 0x1003)
+#define V4L2_CID_ISP_DEMOSAICING_EDGE	(V4L2_CID_USER_BASE | 0x1004)
+#define V4L2_CID_ISP_BLACKLEVEL		(V4L2_CID_USER_BASE | 0x1005)
+#define V4L2_CID_ISP_BAD_PIXEL		(V4L2_CID_USER_BASE | 0x1006)
+#define V4L2_CID_ISP_BAD_PIXEL_COUNT	(V4L2_CID_USER_BASE | 0x1007)
+
+static int dcmipp_isp_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct dcmipp_isp_device *isp =
+			container_of(ctrl->handler, struct dcmipp_isp_device, ctrls);
+
+	if (!isp->streaming)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ISP_DEMOSAICING_PEAK:
+		reg_clear(isp, DCMIPP_P1DMCR, DCMIPP_P1DMCR_PEAK_MASK);
+		reg_set(isp, DCMIPP_P1DMCR, ctrl->val << DCMIPP_P1DMCR_PEAK_SHIFT);
+		break;
+	case V4L2_CID_ISP_DEMOSAICING_LINEH:
+		reg_clear(isp, DCMIPP_P1DMCR, DCMIPP_P1DMCR_LINEH_MASK);
+		reg_set(isp, DCMIPP_P1DMCR, ctrl->val << DCMIPP_P1DMCR_LINEH_SHIFT);
+		break;
+	case V4L2_CID_ISP_DEMOSAICING_LINEV:
+		reg_clear(isp, DCMIPP_P1DMCR, DCMIPP_P1DMCR_LINEV_MASK);
+		reg_set(isp, DCMIPP_P1DMCR, ctrl->val << DCMIPP_P1DMCR_LINEV_SHIFT);
+		break;
+	case V4L2_CID_ISP_DEMOSAICING_EDGE:
+		reg_clear(isp, DCMIPP_P1DMCR, DCMIPP_P1DMCR_EDGE_MASK);
+		reg_set(isp, DCMIPP_P1DMCR, ctrl->val << DCMIPP_P1DMCR_EDGE_SHIFT);
+		break;
+	case V4L2_CID_ISP_BLACKLEVEL:
+		reg_write(isp, DCMIPP_P1BLCCR, ctrl->val ?
+			  ((ctrl->val << DCMIPP_P1BLCCR_BLCB_SHIFT) |
+			   (ctrl->val << DCMIPP_P1BLCCR_BLCG_SHIFT) |
+			   (ctrl->val << DCMIPP_P1BLCCR_BLCR_SHIFT) |
+			   DCMIPP_P1BLCCR_ENABLE) : 0);
+		break;
+	case V4L2_CID_ISP_BAD_PIXEL:
+		reg_write(isp, DCMIPP_P1BPRCR, ctrl->val ?
+			   ((ctrl->val - 1) << DCMIPP_P1BPRCR_STRENGTH_SHIFT) |
+			   DCMIPP_P1BPRCR_ENABLE : 0);
+		break;
+	}
+
+	return 0;
+};
+
+static int dcmipp_isp_g_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct dcmipp_isp_device *isp =
+			container_of(ctrl->handler, struct dcmipp_isp_device, ctrls);
+	int ret = 0;
+
+	if (!isp->streaming)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ISP_BAD_PIXEL_COUNT:
+		ctrl->val = reg_read(isp, DCMIPP_P1BPRSR) &
+				     DCMIPP_P1BPRSR_BADCNT_MASK;
+		break;
+	}
+
+	return ret;
+};
+
+static const struct v4l2_ctrl_ops dcmipp_isp_ctrl_ops = {
+	.s_ctrl = dcmipp_isp_s_ctrl,
+};
+
+static const struct v4l2_ctrl_ops dcmipp_isp_get_ctrl_ops = {
+	.g_volatile_ctrl = dcmipp_isp_g_ctrl,
+};
+
+static const struct v4l2_ctrl_config dcmipp_isp_ctrls[] = {
+	{
+		.ops		= &dcmipp_isp_ctrl_ops,
+		.id		= V4L2_CID_ISP_DEMOSAICING_PEAK,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Demosaicing Peak",
+		.min		= 0,
+		.max		= 7,
+		.step		= 1,
+		.def		= 0,
+		.flags		= 0,
+	}, {
+		.ops		= &dcmipp_isp_ctrl_ops,
+		.id		= V4L2_CID_ISP_DEMOSAICING_LINEH,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Demosaicing Horizontal Line",
+		.min		= 0,
+		.max		= 7,
+		.step		= 1,
+		.def		= 0,
+		.flags		= 0,
+	}, {
+		.ops		= &dcmipp_isp_ctrl_ops,
+		.id		= V4L2_CID_ISP_DEMOSAICING_LINEV,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Demosaicing Vertical Line",
+		.min		= 0,
+		.max		= 7,
+		.step		= 1,
+		.def		= 0,
+		.flags		= 0,
+	}, {
+		.ops		= &dcmipp_isp_ctrl_ops,
+		.id		= V4L2_CID_ISP_DEMOSAICING_EDGE,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Demosaicing Edge",
+		.min		= 0,
+		.max		= 7,
+		.step		= 1,
+		.def		= 0,
+		.flags		= 0,
+	}, {
+		.ops		= &dcmipp_isp_ctrl_ops,
+		.id		= V4L2_CID_ISP_BLACKLEVEL,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "BlackLevel (RGB)",
+		.min		= 0,
+		.max		= 255,
+		.step		= 1,
+		.def		= 0,
+		.flags		= 0,
+	}, {
+		.ops		= &dcmipp_isp_ctrl_ops,
+		.id		= V4L2_CID_ISP_BAD_PIXEL,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Bad Pixel Control",
+		.min		= 0,
+		.max		= 8,
+		.step		= 1,
+		.def		= 0,
+		.flags		= 0,
+	}, {
+		.ops		= &dcmipp_isp_get_ctrl_ops,
+		.id		= V4L2_CID_ISP_BAD_PIXEL_COUNT,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Bad Pixel Count",
+		.min		= 0,
+		.max		= 4095,
+		.step		= 1,
+		.def		= 0,
+		.flags		= V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,
+	}
+};
+
+static inline unsigned int dcmipp_isp_compute_decimation(unsigned int orig,
+							 unsigned int req)
+{
+	unsigned int i;
+
+	for (i = 0; i < 4; i++) {
+		if (req >= (orig / (1 << i)))
+			return i;
+	}
+
+	return (i - 1);
+}
+
+static void dcmipp_isp_adjust_fmt(struct v4l2_mbus_framefmt *fmt, u32 pad)
+{
+	const struct dcmipp_isp_pix_map *vpix;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_isp_pix_map_by_code(fmt->code, pad);
+	if (!vpix)
+		fmt->code = IS_SRC(pad) ? fmt_src_default.code :
+					  fmt_sink_default.code;
+
+	fmt->width = clamp_t(u32, fmt->width, DCMIPP_FRAME_MIN_WIDTH,
+			     DCMIPP_FRAME_MAX_WIDTH) & ~1;
+	fmt->height = clamp_t(u32, fmt->height, DCMIPP_FRAME_MIN_HEIGHT,
+			      DCMIPP_FRAME_MAX_HEIGHT);
+
+	if (fmt->field == V4L2_FIELD_ANY || fmt->field == V4L2_FIELD_ALTERNATE)
+		fmt->field = IS_SRC(pad) ? fmt_src_default.field :
+					   fmt_sink_default.field;
+
+	dcmipp_colorimetry_clamp(fmt);
+}
+
+static int dcmipp_isp_init_cfg(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_state *state)
+{
+	unsigned int i;
+
+	for (i = 0; i < sd->entity.num_pads; i++) {
+		struct v4l2_mbus_framefmt *mf;
+
+		mf = v4l2_subdev_get_try_format(sd, state, i);
+		*mf = IS_SRC(i) ? fmt_src_default : fmt_sink_default;
+	}
+
+	return 0;
+}
+
+static int dcmipp_isp_enum_mbus_code(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *state,
+				     struct v4l2_subdev_mbus_code_enum *code)
+{
+	const struct dcmipp_isp_pix_map *vpix;
+
+	vpix = dcmipp_isp_pix_map_by_index(code->index, code->pad);
+	if (!vpix)
+		return -EINVAL;
+
+	code->code = vpix->code;
+
+	return 0;
+}
+
+static int dcmipp_isp_enum_frame_size(struct v4l2_subdev *sd,
+				      struct v4l2_subdev_state *state,
+				      struct v4l2_subdev_frame_size_enum *fse)
+{
+	const struct dcmipp_isp_pix_map *vpix;
+
+	if (fse->index)
+		return -EINVAL;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_isp_pix_map_by_code(fse->code, fse->pad);
+	if (!vpix)
+		return -EINVAL;
+
+	fse->min_width = DCMIPP_FRAME_MIN_WIDTH;
+	fse->max_width = DCMIPP_FRAME_MAX_WIDTH;
+	fse->min_height = DCMIPP_FRAME_MIN_HEIGHT;
+	fse->max_height = DCMIPP_FRAME_MAX_HEIGHT;
+
+	return 0;
+}
+
+static int dcmipp_isp_get_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_isp_device *isp = v4l2_get_subdevdata(sd);
+
+	mutex_lock(&isp->lock);
+
+	if (IS_SINK(fmt->pad))
+		fmt->format = fmt->which == V4L2_SUBDEV_FORMAT_TRY ?
+			      *v4l2_subdev_get_try_format(sd, state, 0) :
+			      isp->sink_fmt;
+	else
+		fmt->format = fmt->which == V4L2_SUBDEV_FORMAT_TRY ?
+			      *v4l2_subdev_get_try_format(sd, state, 0) :
+			      isp->src_fmt;
+
+	mutex_unlock(&isp->lock);
+
+	return 0;
+}
+
+#define dcmipp_isp_is_yuv_fmt(a) ({					      \
+	typeof(a) __a = (a);						      \
+	((__a) >= MEDIA_BUS_FMT_Y8_1X8 && (__a) < MEDIA_BUS_FMT_SBGGR8_1X8) ? \
+	 true : false; })
+static int dcmipp_isp_set_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_isp_device *isp = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *pad_fmt;
+	int ret = 0;
+
+	mutex_lock(&isp->lock);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		if (isp->streaming) {
+			ret = -EBUSY;
+			goto out;
+		}
+
+		if (IS_SINK(fmt->pad))
+			pad_fmt = &isp->sink_fmt;
+		else
+			pad_fmt = &isp->src_fmt;
+
+	} else {
+		pad_fmt = v4l2_subdev_get_try_format(sd, state, 0);
+	}
+
+	dcmipp_isp_adjust_fmt(&fmt->format, fmt->pad);
+
+	if (IS_SINK(fmt->pad) && fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		/* When setting sink format, we have to update the src format */
+		isp->src_fmt = fmt->format;
+		if (dcmipp_isp_is_yuv_fmt(fmt->format.code))
+			isp->src_fmt.code = MEDIA_BUS_FMT_YUV8_1X24;
+		else
+			isp->src_fmt.code = MEDIA_BUS_FMT_RGB888_1X24;
+	}
+	/* TODO - we need to update the try src format as well */
+
+	dev_dbg(isp->dev, "%s: %s format update: old:%dx%d (0x%x, %d, %d, %d, %d) new:%dx%d (0x%x, %d, %d, %d, %d)\n",
+		isp->sd.name,
+		PAD_STR(fmt->pad),
+		/* old */
+		pad_fmt->width, pad_fmt->height, pad_fmt->code,
+		pad_fmt->colorspace, pad_fmt->quantization,
+		pad_fmt->xfer_func, pad_fmt->ycbcr_enc,
+		/* new */
+		fmt->format.width, fmt->format.height, fmt->format.code,
+		fmt->format.colorspace, fmt->format.quantization,
+		fmt->format.xfer_func, fmt->format.ycbcr_enc);
+
+	*pad_fmt = fmt->format;
+
+	/* Update sink pad crop */
+	if (IS_SINK(fmt->pad) && fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		isp->crop.top = 0;
+		isp->crop.left = 0;
+		isp->crop.width = fmt->format.width;
+		isp->crop.height = fmt->format.height;
+
+		isp->compose.top = 0;
+		isp->compose.left = 0;
+		isp->compose.width = fmt->format.width;
+		isp->compose.height = fmt->format.height;
+		isp->decimation = 0;
+	}
+
+out:
+	mutex_unlock(&isp->lock);
+
+	return ret;
+}
+
+static struct v4l2_rect
+dcmipp_isp_get_crop_bound(const struct v4l2_mbus_framefmt *fmt)
+{
+	/* Get the crop bounds to clamp the crop rectangle correctly */
+	struct v4l2_rect r = {
+		.left = 0,
+		.top = 0,
+		.width = fmt->width,
+		.height = fmt->height,
+	};
+	return r;
+}
+
+static void dcmipp_isp_adjust_crop(struct v4l2_rect *r,
+				   const struct v4l2_mbus_framefmt *fmt,
+				   unsigned int fmt_width)
+{
+	const struct v4l2_rect src_rect =
+		dcmipp_isp_get_crop_bound(fmt);
+	static struct v4l2_rect crop_min = {
+		.width = DCMIPP_FMT_WIDTH_DEFAULT,
+		.height = 1,
+		.top = 8,
+		.left = 0,
+	};
+
+	/* Disallow rectangles smaller than the minimal one. */
+	crop_min.width = fmt_width;
+	v4l2_rect_set_min_size(r, &crop_min);
+	v4l2_rect_map_inside(r, &src_rect);
+}
+
+static int dcmipp_isp_get_selection(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_state *state,
+				    struct v4l2_subdev_selection *s)
+{
+	struct dcmipp_isp_device *isp = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *sink_fmt;
+	struct v4l2_rect *crop, *compose;
+
+	if (IS_SRC(s->pad))
+		return -EINVAL;
+
+	if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		sink_fmt = &isp->sink_fmt;
+		crop = &isp->crop;
+		compose = &isp->compose;
+	} else {
+		sink_fmt = v4l2_subdev_get_try_format(sd, state, s->pad);
+		crop = v4l2_subdev_get_try_crop(sd, state, s->pad);
+		compose = v4l2_subdev_get_try_compose(sd, state, s->pad);
+	}
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		s->r = *crop;
+		break;
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		s->r = dcmipp_isp_get_crop_bound(sink_fmt);
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		s->r = *compose;
+		break;
+	/* TODO - not sure how to define BOUND here */
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dcmipp_isp_set_selection(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_state *state,
+				    struct v4l2_subdev_selection *s)
+{
+	struct dcmipp_isp_device *isp = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *sink_fmt;
+	struct v4l2_rect *crop, *compose;
+	unsigned int dec;
+
+	if (IS_SRC(s->pad))
+		return -EINVAL;
+
+	if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		sink_fmt = &isp->sink_fmt;
+		crop = &isp->crop;
+		compose = &isp->compose;
+	} else {
+		sink_fmt = v4l2_subdev_get_try_format(sd, state, s->pad);
+		crop = v4l2_subdev_get_try_crop(sd, state, s->pad);
+		compose = v4l2_subdev_get_try_compose(sd, state, s->pad);
+	}
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		dcmipp_isp_adjust_crop(&s->r, sink_fmt, isp->sink_fmt.width);
+
+		*crop = s->r;
+
+		/* When we set the crop, this impact as well the compose */
+		*compose = s->r;
+		isp->decimation = 0;
+
+		/*
+		 * In case of setting the crop with ACTIVE set, we need to
+		 * update the source pad size
+		 */
+		if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+			isp->src_fmt.width = s->r.width;
+			isp->src_fmt.height = s->r.height;
+		}
+
+		/* TODO - when not in format active, we should also update the
+		 * try src pad format
+		 */
+
+		dev_dbg(isp->dev, "s_selection: crop %ux%u@(%u,%u)\n",
+			crop->width, crop->height, crop->left, crop->top);
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		s->r.top = 0;
+		s->r.left = 0;
+		if (s->r.width > crop->width)
+			s->r.width = crop->width;
+		if (s->r.height > crop->height)
+			s->r.height = crop->height;
+		dec = dcmipp_isp_compute_decimation(crop->width, s->r.width);
+		s->r.width = crop->width / (1 << dec);
+		if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+			isp->decimation = 0;
+			isp->decimation |= (dec << DCMIPP_P1DECR_HDEC_SHIFT);
+		}
+		dec = dcmipp_isp_compute_decimation(crop->height, s->r.height);
+		s->r.height = crop->height / (1 << dec);
+		if (crop->height % (1 << dec))
+			s->r.height += 1;
+		if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+			isp->decimation |= (dec << DCMIPP_P1DECR_VDEC_SHIFT);
+			if (isp->decimation)
+				isp->decimation |= DCMIPP_P1DECR_ENABLE;
+		}
+
+		*compose = s->r;
+
+		/*
+		 * In case of setting the compose with ACTIVE set, we need to
+		 * update the source pad size
+		 */
+		if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+			isp->src_fmt.width = s->r.width;
+			isp->src_fmt.height = s->r.height;
+		}
+		/* TODO - when not in format active, we should also update the
+		 * try src pad format
+		 */
+
+		dev_dbg(isp->dev, "s_selection: compose %ux%u@(%u,%u)\n",
+			s->r.width, s->r.height, s->r.left, s->r.top);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops dcmipp_isp_pad_ops = {
+	.init_cfg		= dcmipp_isp_init_cfg,
+	.enum_mbus_code		= dcmipp_isp_enum_mbus_code,
+	.enum_frame_size	= dcmipp_isp_enum_frame_size,
+	.get_fmt		= dcmipp_isp_get_fmt,
+	.set_fmt		= dcmipp_isp_set_fmt,
+	.get_selection		= dcmipp_isp_get_selection,
+	.set_selection		= dcmipp_isp_set_selection,
+};
+
+static void dcmipp_isp_config_demosaicing(struct dcmipp_isp_device *isp)
+{
+	const struct dcmipp_isp_pix_map *vpix =
+		dcmipp_isp_pix_map_by_code(isp->sink_fmt.code, 0);
+	unsigned int val = 0;
+
+	/* Disable demosaicing */
+	reg_clear(isp, DCMIPP_P1DMCR, DCMIPP_P1DMCR_ENABLE | DCMIPP_P1DMCR_TYPE_MASK);
+
+	if (vpix->code >= 0x3000 && vpix->code < 0x4000) {
+		dev_info(isp->dev, "Input is RawBayer, enable Demosaicing\n");
+
+		if (vpix->code == MEDIA_BUS_FMT_SBGGR8_1X8 ||
+		    vpix->code == MEDIA_BUS_FMT_SBGGR10_1X10 ||
+		    vpix->code == MEDIA_BUS_FMT_SBGGR12_1X12 ||
+		    vpix->code == MEDIA_BUS_FMT_SBGGR14_1X14)
+			val = DCMIPP_P1DMCR_TYPE_BGGR << DCMIPP_P1DMCR_TYPE_SHIFT;
+		else if (vpix->code == MEDIA_BUS_FMT_SGBRG8_1X8 ||
+			 vpix->code == MEDIA_BUS_FMT_SGBRG10_1X10 ||
+			 vpix->code == MEDIA_BUS_FMT_SGBRG12_1X12 ||
+			 vpix->code == MEDIA_BUS_FMT_SGBRG14_1X14)
+			val = DCMIPP_P1DMCR_TYPE_GBRG << DCMIPP_P1DMCR_TYPE_SHIFT;
+		else if (vpix->code == MEDIA_BUS_FMT_SGRBG8_1X8 ||
+			 vpix->code == MEDIA_BUS_FMT_SGRBG10_1X10 ||
+			 vpix->code == MEDIA_BUS_FMT_SGRBG12_1X12 ||
+			 vpix->code == MEDIA_BUS_FMT_SGRBG14_1X14)
+			val = DCMIPP_P1DMCR_TYPE_GRBG << DCMIPP_P1DMCR_TYPE_SHIFT;
+		else if (vpix->code == MEDIA_BUS_FMT_SRGGB8_1X8 ||
+			 vpix->code == MEDIA_BUS_FMT_SRGGB10_1X10 ||
+			 vpix->code == MEDIA_BUS_FMT_SRGGB12_1X12 ||
+			 vpix->code == MEDIA_BUS_FMT_SRGGB14_1X14)
+			val = DCMIPP_P1DMCR_TYPE_RGGB << DCMIPP_P1DMCR_TYPE_SHIFT;
+
+		val |= DCMIPP_P1DMCR_ENABLE;
+	}
+
+	if (val)
+		reg_set(isp, DCMIPP_P1DMCR, val);
+}
+
+static int dcmipp_isp_colorconv_config(struct dcmipp_isp_device *isp)
+{
+	struct dcmipp_colorconv_config ccconf = { 0 };
+	int i, ret = 0;
+	unsigned int val = 0;
+
+	ret = dcmipp_colorconv_configure(isp->dev, &isp->sink_fmt,
+					 &isp->src_fmt, &ccconf);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < 6; i++)
+		reg_write(isp, DCMIPP_P1CCRR1 + (4 * i), ccconf.conv_matrix[i]);
+
+	if (ccconf.clamping)
+		val |= DCMIPP_P1CCCR_CLAMP;
+	if (!dcmipp_isp_is_yuv_fmt(isp->src_fmt.code))
+		val |= DCMIPP_P1CCCR_TYPE_RGB;
+	if (ccconf.enable)
+		val |= DCMIPP_P1CCCR_ENABLE;
+
+	reg_write(isp, DCMIPP_P1CCCR, val);
+
+	return 0;
+}
+
+static int dcmipp_isp_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct dcmipp_isp_device *isp = v4l2_get_subdevdata(sd);
+	const struct dcmipp_isp_pix_map *vpix =
+		dcmipp_isp_pix_map_by_code(isp->sink_fmt.code, 0);
+	int ret = 0;
+
+	mutex_lock(&isp->lock);
+	if (enable) {
+		/* Configure CSI DataType */
+		reg_clear(isp, DCMIPP_P1FSCR, DCMIPP_P1FSCR_DTIDA_MASK);
+		reg_set(isp, DCMIPP_P1FSCR,
+			vpix->dt << DCMIPP_P1FSCR_DTIDA_SHIFT);
+
+		/* Check if link between ISP & Pipe2 postproc is enabled */
+		if (media_entity_remote_pad(&sd->entity.pads[2]))
+			reg_clear(isp, DCMIPP_P1FSCR, DCMIPP_P1FSCR_PIPEDIFF);
+		else
+			reg_set(isp, DCMIPP_P1FSCR, DCMIPP_P1FSCR_PIPEDIFF);
+
+		/* Configure Statistic Removal */
+		reg_write(isp, DCMIPP_P1SRCR,
+			  ((isp->crop.top << DCMIPP_P1SRCR_FIRSTLINEDEL_SHIFT) |
+			   (isp->crop.height << DCMIPP_P1SRCR_LASTLINE_SHIFT) |
+			   DCMIPP_P1SRCR_CROPEN));
+
+		/* Configure Decimation */
+		reg_write(isp, DCMIPP_P1DECR, isp->decimation);
+
+		/* Configure Exposure */
+		/* Configure Demosaicing */
+		dcmipp_isp_config_demosaicing(isp);
+
+		/* Configure ColorConversion */
+		ret = dcmipp_isp_colorconv_config(isp);
+		if (ret)
+			goto out;
+	}
+
+	isp->streaming = enable;
+
+	mutex_unlock(&isp->lock);
+
+	return v4l2_ctrl_handler_setup(&isp->ctrls);
+
+out:
+	mutex_unlock(&isp->lock);
+
+	return ret;
+}
+
+static const struct v4l2_subdev_video_ops dcmipp_isp_video_ops = {
+	.s_stream = dcmipp_isp_s_stream,
+};
+
+static const struct v4l2_subdev_ops dcmipp_isp_ops = {
+	.pad = &dcmipp_isp_pad_ops,
+	.video = &dcmipp_isp_video_ops,
+};
+
+/* FIXME */
+static void dcmipp_isp_release(struct v4l2_subdev *sd)
+{
+	struct dcmipp_isp_device *isp = v4l2_get_subdevdata(sd);
+
+	kfree(isp);
+}
+
+static const struct v4l2_subdev_internal_ops dcmipp_isp_int_ops = {
+	.release = dcmipp_isp_release,
+};
+
+static void dcmipp_isp_comp_unbind(struct device *comp, struct device *master,
+				   void *master_data)
+{
+	struct dcmipp_ent_device *ved = dev_get_drvdata(comp);
+	struct dcmipp_isp_device *isp =
+			container_of(ved, struct dcmipp_isp_device, ved);
+
+	dcmipp_ent_sd_unregister(ved, &isp->sd);
+}
+
+static int dcmipp_isp_comp_bind(struct device *comp, struct device *master,
+				void *master_data)
+{
+	struct dcmipp_bind_data *bind_data = master_data;
+	struct dcmipp_platform_data *pdata = comp->platform_data;
+	struct dcmipp_isp_device *isp;
+	int ret, i;
+
+	/* Allocate the isp struct */
+	isp = kzalloc(sizeof(*isp), GFP_KERNEL);
+	if (!isp)
+		return -ENOMEM;
+
+	isp->regs = bind_data->regs;
+
+	/* Initialize ved and sd */
+	ret = dcmipp_ent_sd_register(&isp->ved, &isp->sd,
+				     bind_data->v4l2_dev,
+				     pdata->entity_name,
+				     MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER, 3,
+				     (const unsigned long[3]) {
+				     MEDIA_PAD_FL_SINK,
+				     MEDIA_PAD_FL_SOURCE,
+				     MEDIA_PAD_FL_SOURCE,
+				     },
+				     &dcmipp_isp_int_ops, &dcmipp_isp_ops,
+				     NULL, NULL);
+	if (ret) {
+		kfree(isp);
+		return ret;
+	}
+
+	dev_set_drvdata(comp, &isp->ved);
+	isp->dev = comp;
+
+	/* Initialize the frame format */
+	isp->sink_fmt = fmt_sink_default;
+	isp->src_fmt = fmt_src_default;
+
+	/* Initialize controls */
+	v4l2_ctrl_handler_init(&isp->ctrls, ARRAY_SIZE(dcmipp_isp_ctrls));
+	isp->ctrls.lock = &isp->lock;
+
+	for (i = 0; i < ARRAY_SIZE(dcmipp_isp_ctrls); i++)
+		v4l2_ctrl_new_custom(&isp->ctrls, &dcmipp_isp_ctrls[i], NULL);
+
+	isp->sd.ctrl_handler = &isp->ctrls;
+	if (isp->ctrls.error) {
+		dev_err(isp->dev, "control initialization error %d\n",
+			isp->ctrls.error);
+		/* TODO - error handling */
+	}
+
+	ret = v4l2_ctrl_handler_setup(&isp->ctrls);
+	if (ret < 0) {
+		dev_err(isp->dev, "Failed to set up control handlers\n");
+		/* TODO - error handling */
+	}
+
+	return 0;
+}
+
+static const struct component_ops dcmipp_isp_comp_ops = {
+	.bind = dcmipp_isp_comp_bind,
+	.unbind = dcmipp_isp_comp_unbind,
+};
+
+static int dcmipp_isp_probe(struct platform_device *pdev)
+{
+	return component_add(&pdev->dev, &dcmipp_isp_comp_ops);
+}
+
+static int dcmipp_isp_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &dcmipp_isp_comp_ops);
+
+	return 0;
+}
+
+static const struct platform_device_id dcmipp_isp_driver_ids[] = {
+	{
+		.name           = DCMIPP_ISP_DRV_NAME,
+	},
+	{ }
+};
+
+static struct platform_driver dcmipp_isp_pdrv = {
+	.probe		= dcmipp_isp_probe,
+	.remove		= dcmipp_isp_remove,
+	.id_table	= dcmipp_isp_driver_ids,
+	.driver		= {
+		.name	= DCMIPP_ISP_DRV_NAME,
+	},
+};
+
+module_platform_driver(dcmipp_isp_pdrv);
+
+MODULE_DEVICE_TABLE(platform, dcmipp_isp_driver_ids);
+
+MODULE_AUTHOR("Hugues Fruchet <hugues.fruchet@foss.st.com>");
+MODULE_AUTHOR("Alain Volmat <alain.volmat@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 Digital Camera Memory Interface with Pixel Processor driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-parallel.c b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-parallel.c
new file mode 100644
index 000000000..e737a48cf
--- /dev/null
+++ b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-parallel.c
@@ -0,0 +1,497 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include <linux/component.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/vmalloc.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-subdev.h>
+
+#include "dcmipp-common.h"
+
+#define DCMIPP_PAR_DRV_NAME "dcmipp-parallel"
+
+#define DCMIPP_PRCR (0x104)
+#define DCMIPP_PRCR_FORMAT_SHIFT 16
+#define DCMIPP_PRCR_FORMAT_YUV422 0x1E
+#define DCMIPP_PRCR_FORMAT_RGB565 0x22
+#define DCMIPP_PRCR_FORMAT_RAW8 0x2A
+#define DCMIPP_PRCR_FORMAT_G8 0x4A
+#define DCMIPP_PRCR_FORMAT_BYTE_STREAM 0x5A
+#define DCMIPP_PRCR_ESS BIT(4)
+#define DCMIPP_PRCR_PCKPOL BIT(5)
+#define DCMIPP_PRCR_HSPOL BIT(6)
+#define DCMIPP_PRCR_VSPOL BIT(7)
+#define DCMIPP_PRCR_ENABLE BIT(14)
+#define DCMIPP_PRCR_SWAPCYCLES BIT(25)
+#define DCMIPP_PRCR_SWAPBITS BIT(26)
+
+#define DCMIPP_PRESCR (0x108)
+#define DCMIPP_PRESUR (0x10c)
+
+#define IS_SINK(pad) (!(pad))
+#define IS_SRC(pad)  ((pad))
+
+#define PAR_MEDIA_BUS_FMT_DEFAULT MEDIA_BUS_FMT_RGB565_2X8_LE
+
+struct dcmipp_par_pix_map {
+	unsigned int code_sink;
+	unsigned int code_src;
+	u8 prcr_format;
+	u8 prcr_swapbits;
+	u8 prcr_swapcycles;
+};
+
+#define PIXMAP_SINK_SRC_PRCR_SWAP(sink, src, prcr, swap)	\
+		{						\
+			.code_sink = MEDIA_BUS_FMT_##sink,		\
+			.code_src = MEDIA_BUS_FMT_##src,		\
+			.prcr_format = DCMIPP_PRCR_FORMAT_##prcr,	\
+			.prcr_swapcycles = swap,		\
+		}
+static const struct dcmipp_par_pix_map dcmipp_par_pix_map_list[] = {
+	/* RGB565 */
+	PIXMAP_SINK_SRC_PRCR_SWAP(RGB565_2X8_LE, RGB565_2X8_LE, RGB565, 1),
+	PIXMAP_SINK_SRC_PRCR_SWAP(RGB565_2X8_BE, RGB565_2X8_LE, RGB565, 0),
+	/* YUV422 */
+	PIXMAP_SINK_SRC_PRCR_SWAP(YUYV8_2X8, YUYV8_2X8, YUV422, 1),
+	PIXMAP_SINK_SRC_PRCR_SWAP(YUYV8_2X8, UYVY8_2X8, YUV422, 0),
+	PIXMAP_SINK_SRC_PRCR_SWAP(UYVY8_2X8, UYVY8_2X8, YUV422, 1),
+	PIXMAP_SINK_SRC_PRCR_SWAP(UYVY8_2X8, YUYV8_2X8, YUV422, 0),
+	PIXMAP_SINK_SRC_PRCR_SWAP(YVYU8_2X8, YVYU8_2X8, YUV422, 1),
+	PIXMAP_SINK_SRC_PRCR_SWAP(VYUY8_2X8, VYUY8_2X8, YUV422, 1),
+	/* GREY */
+	PIXMAP_SINK_SRC_PRCR_SWAP(Y8_1X8, Y8_1X8, G8, 0),
+	/* Raw Bayer */
+	PIXMAP_SINK_SRC_PRCR_SWAP(SBGGR8_1X8, SBGGR8_1X8, RAW8, 0),
+	PIXMAP_SINK_SRC_PRCR_SWAP(SGBRG8_1X8, SGBRG8_1X8, RAW8, 0),
+	PIXMAP_SINK_SRC_PRCR_SWAP(SGRBG8_1X8, SGRBG8_1X8, RAW8, 0),
+	PIXMAP_SINK_SRC_PRCR_SWAP(SRGGB8_1X8, SRGGB8_1X8, RAW8, 0),
+	/* JPEG */
+	PIXMAP_SINK_SRC_PRCR_SWAP(JPEG_1X8, JPEG_1X8, BYTE_STREAM, 0),
+};
+
+/*
+ * Search through the pix_map table, skipping two consecutive entry with the
+ * same code
+ */
+static inline const struct dcmipp_par_pix_map *dcmipp_par_pix_map_by_index
+						(unsigned int index,
+						 unsigned int pad)
+{
+	const struct dcmipp_par_pix_map *l = dcmipp_par_pix_map_list;
+	unsigned int size = ARRAY_SIZE(dcmipp_par_pix_map_list);
+	unsigned int i = 0;
+	u32 prev_code = 0, cur_code;
+
+	while (i < size) {
+		if (IS_SRC(pad))
+			cur_code = l[i].code_src;
+		else
+			cur_code = l[i].code_sink;
+
+		if (cur_code == prev_code) {
+			i++;
+			continue;
+		} else {
+			prev_code = cur_code;
+		}
+
+		if (index == 0)
+			break;
+		i++;
+		index--;
+	}
+
+	if (i >= size)
+		return NULL;
+
+	return &l[i];
+}
+
+static inline const struct dcmipp_par_pix_map *dcmipp_par_pix_map_by_code
+					(u32 code_sink, u32 code_src)
+{
+	const struct dcmipp_par_pix_map *l = dcmipp_par_pix_map_list;
+	unsigned int size = ARRAY_SIZE(dcmipp_par_pix_map_list);
+	unsigned int i;
+
+	for (i = 0; i < size; i++) {
+		if ((l[i].code_sink == code_sink && l[i].code_src == code_src) ||
+		    (l[i].code_sink == code_src && l[i].code_src == code_sink) ||
+		    (l[i].code_sink == code_sink && code_src == 0) ||
+		    (code_sink == 0 && l[i].code_src == code_src))
+			return &l[i];
+	}
+	return NULL;
+}
+
+struct dcmipp_par_device {
+	struct dcmipp_ent_device ved;
+	struct v4l2_subdev sd;
+	struct device *dev;
+	/* The active format */
+	struct v4l2_mbus_framefmt sink_format;
+	struct v4l2_mbus_framefmt src_format;
+	bool streaming;
+	void __iomem			*regs;
+};
+
+static const struct v4l2_mbus_framefmt fmt_default = {
+	.width = DCMIPP_FMT_WIDTH_DEFAULT,
+	.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	.code = PAR_MEDIA_BUS_FMT_DEFAULT,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = DCMIPP_COLORSPACE_DEFAULT,
+	.ycbcr_enc = DCMIPP_YCBCR_ENC_DEFAULT,
+	.quantization = DCMIPP_QUANTIZATION_DEFAULT,
+	.xfer_func = DCMIPP_XFER_FUNC_DEFAULT,
+};
+
+static int dcmipp_par_init_cfg(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_state *sd_state)
+{
+	unsigned int i;
+
+	for (i = 0; i < sd->entity.num_pads; i++) {
+		struct v4l2_mbus_framefmt *mf;
+
+		mf = v4l2_subdev_get_try_format(sd, sd_state, i);
+		*mf = fmt_default;
+	}
+
+	return 0;
+}
+
+static int dcmipp_par_enum_mbus_code(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *sd_state,
+				     struct v4l2_subdev_mbus_code_enum *code)
+{
+	const struct dcmipp_par_pix_map *vpix =
+		dcmipp_par_pix_map_by_index(code->index, code->pad);
+
+	if (!vpix)
+		return -EINVAL;
+
+	code->code = IS_SRC(code->pad) ? vpix->code_src : vpix->code_sink;
+
+	return 0;
+}
+
+static int dcmipp_par_enum_frame_size(struct v4l2_subdev *sd,
+				      struct v4l2_subdev_state *sd_state,
+				      struct v4l2_subdev_frame_size_enum *fse)
+{
+	const struct dcmipp_par_pix_map *vpix;
+
+	if (fse->index)
+		return -EINVAL;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_par_pix_map_by_code(IS_SINK(fse->pad) ? fse->code : 0,
+					  IS_SRC(fse->pad) ? fse->code : 0);
+	if (!vpix)
+		return -EINVAL;
+
+	fse->min_width = DCMIPP_FRAME_MIN_WIDTH;
+	fse->max_width = DCMIPP_FRAME_MAX_WIDTH;
+	fse->min_height = DCMIPP_FRAME_MIN_HEIGHT;
+	fse->max_height = DCMIPP_FRAME_MAX_HEIGHT;
+
+	return 0;
+}
+
+static int dcmipp_par_get_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_par_device *par =
+				container_of(sd, struct dcmipp_par_device, sd);
+
+	fmt->format = fmt->which == V4L2_SUBDEV_FORMAT_TRY ?
+		      *v4l2_subdev_get_try_format(sd, sd_state, fmt->pad) :
+		      (IS_SRC(fmt->pad) ? par->src_format : par->sink_format);
+
+	return 0;
+}
+
+static void dcmipp_par_adjust_fmt(struct dcmipp_par_device *par,
+				  struct v4l2_mbus_framefmt *fmt, __u32 pad)
+{
+	const struct dcmipp_par_pix_map *vpix;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_par_pix_map_by_code(IS_SINK(pad) ? fmt->code : 0,
+					  IS_SRC(pad) ? fmt->code : 0);
+	if (!vpix)
+		fmt->code = fmt_default.code;
+
+	/* Exclude JPEG if BT656 bus is selected */
+	if (vpix && vpix->code_sink == MEDIA_BUS_FMT_JPEG_1X8 &&
+	    par->ved.bus_type == V4L2_MBUS_BT656)
+		fmt->code = fmt_default.code;
+
+	fmt->width = clamp_t(u32, fmt->width, DCMIPP_FRAME_MIN_WIDTH,
+			     DCMIPP_FRAME_MAX_WIDTH) & ~1;
+	fmt->height = clamp_t(u32, fmt->height, DCMIPP_FRAME_MIN_HEIGHT,
+			      DCMIPP_FRAME_MAX_HEIGHT) & ~1;
+
+	if (fmt->field == V4L2_FIELD_ANY || fmt->field == V4L2_FIELD_ALTERNATE)
+		fmt->field = fmt_default.field;
+
+	dcmipp_colorimetry_clamp(fmt);
+}
+
+static int dcmipp_par_set_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_par_device *par = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *mf;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		/* Do not change the format while stream is on */
+		if (par->streaming)
+			return -EBUSY;
+
+		mf = IS_SRC(fmt->pad) ? &par->src_format : &par->sink_format;
+	} else {
+		mf = v4l2_subdev_get_try_format(sd, sd_state, fmt->pad);
+	}
+
+	/* Set the new format */
+	dcmipp_par_adjust_fmt(par, &fmt->format, fmt->pad);
+
+	dev_dbg(par->dev, "%s: format update: old:%dx%d (0x%x, %d, %d, %d, %d) new:%dx%d (0x%x, %d, %d, %d, %d)\n",
+		par->sd.name,
+		/* old */
+		mf->width, mf->height, mf->code,
+		mf->colorspace,	mf->quantization,
+		mf->xfer_func, mf->ycbcr_enc,
+		/* new */
+		fmt->format.width, fmt->format.height, fmt->format.code,
+		fmt->format.colorspace, fmt->format.quantization,
+		fmt->format.xfer_func, fmt->format.ycbcr_enc);
+
+	*mf = fmt->format;
+
+	/* When setting the sink format, report that format on the src pad as well */
+	if (IS_SINK(fmt->pad))
+		par->src_format = fmt->format;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops dcmipp_par_pad_ops = {
+	.init_cfg		= dcmipp_par_init_cfg,
+	.enum_mbus_code		= dcmipp_par_enum_mbus_code,
+	.enum_frame_size	= dcmipp_par_enum_frame_size,
+	.get_fmt		= dcmipp_par_get_fmt,
+	.set_fmt		= dcmipp_par_set_fmt,
+};
+
+static int dcmipp_par_configure(struct dcmipp_par_device *par)
+{
+	u32 val = 0;
+	const struct dcmipp_par_pix_map *vpix;
+
+	/* Set vertical synchronization polarity */
+	if (par->ved.bus.flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)
+		val |= DCMIPP_PRCR_VSPOL;
+
+	/* Set horizontal synchronization polarity */
+	if (par->ved.bus.flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)
+		val |= DCMIPP_PRCR_HSPOL;
+
+	/* Set pixel clock polarity */
+	if (par->ved.bus.flags & V4L2_MBUS_PCLK_SAMPLE_RISING)
+		val |= DCMIPP_PRCR_PCKPOL;
+
+	/*
+	 * BT656 embedded synchronisation bus mode.
+	 *
+	 * Default SAV/EAV mode is supported here with default codes
+	 * SAV=0xff000080 & EAV=0xff00009d.
+	 * With DCMIPP this means LSC=SAV=0x80 & LEC=EAV=0x9d.
+	 */
+	if (par->ved.bus_type == V4L2_MBUS_BT656) {
+		val |= DCMIPP_PRCR_ESS;
+
+		/* Unmask all codes */
+		reg_write(par, DCMIPP_PRESUR, 0xffffffff);/* FEC:LEC:LSC:FSC */
+
+		/* Trig on LSC=0x80 & LEC=0x9d codes, ignore FSC and FEC */
+		reg_write(par, DCMIPP_PRESCR, 0xff9d80ff);/* FEC:LEC:LSC:FSC */
+	}
+
+	/* Set format */
+	vpix = dcmipp_par_pix_map_by_code(par->sink_format.code,
+					  par->src_format.code);
+	if (!vpix) {
+		dev_err(par->dev, "Invalid sink/src format configuration\n");
+		return -EINVAL;
+	}
+
+	val |= vpix->prcr_format << DCMIPP_PRCR_FORMAT_SHIFT;
+
+	/* swap LSB vs MSB within one cycle */
+	if (vpix->prcr_swapbits)
+		val |= DCMIPP_PRCR_SWAPBITS;
+
+	/* swap cycles */
+	if (vpix->prcr_swapcycles)
+		val |= DCMIPP_PRCR_SWAPCYCLES;
+
+	reg_write(par, DCMIPP_PRCR, val);
+
+	return 0;
+}
+
+static int dcmipp_par_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct dcmipp_par_device *par =
+				container_of(sd, struct dcmipp_par_device, sd);
+	int ret = 0;
+
+	if (enable) {
+		ret = dcmipp_par_configure(par);
+		if (ret)
+			return ret;
+
+		/* Enable parallel interface */
+		reg_set(par, DCMIPP_PRCR, DCMIPP_PRCR_ENABLE);
+	} else {
+		/* Disable parallel interface */
+		reg_clear(par, DCMIPP_PRCR, DCMIPP_PRCR_ENABLE);
+	}
+
+	par->streaming = enable;
+	return ret;
+}
+
+static const struct v4l2_subdev_video_ops dcmipp_par_video_ops = {
+	.s_stream = dcmipp_par_s_stream,
+};
+
+static const struct v4l2_subdev_ops dcmipp_par_ops = {
+	.pad = &dcmipp_par_pad_ops,
+	.video = &dcmipp_par_video_ops,
+};
+
+static void dcmipp_par_release(struct v4l2_subdev *sd)
+{
+	struct dcmipp_par_device *par =
+				container_of(sd, struct dcmipp_par_device, sd);
+
+	kfree(par);
+}
+
+static const struct v4l2_subdev_internal_ops dcmipp_par_int_ops = {
+	.release = dcmipp_par_release,
+};
+
+static void dcmipp_par_comp_unbind(struct device *comp, struct device *master,
+				   void *master_data)
+{
+	struct dcmipp_ent_device *ved = dev_get_drvdata(comp);
+	struct dcmipp_par_device *par =
+			container_of(ved, struct dcmipp_par_device, ved);
+
+	dcmipp_ent_sd_unregister(ved, &par->sd);
+}
+
+static int dcmipp_par_comp_bind(struct device *comp, struct device *master,
+				void *master_data)
+{
+	struct dcmipp_bind_data *bind_data = master_data;
+	struct dcmipp_platform_data *pdata = comp->platform_data;
+	struct dcmipp_par_device *par;
+	int ret;
+
+	/* Allocate the par struct */
+	par = kzalloc(sizeof(*par), GFP_KERNEL);
+	if (!par)
+		return -ENOMEM;
+
+	par->regs = bind_data->regs;
+
+	/* Initialize ved and sd */
+	ret = dcmipp_ent_sd_register
+		(&par->ved, &par->sd, bind_data->v4l2_dev,
+		 pdata->entity_name,
+		 MEDIA_ENT_F_VID_IF_BRIDGE, 2,
+		 (const unsigned long[2]) {
+		  MEDIA_PAD_FL_SINK,
+		  MEDIA_PAD_FL_SOURCE,
+		  },
+		 &dcmipp_par_int_ops, &dcmipp_par_ops,
+		 NULL, NULL);
+	if (ret)
+		goto err_free_hdl;
+
+	dev_set_drvdata(comp, &par->ved);
+	par->dev = comp;
+
+	/* Initialize the frame format */
+	par->sink_format = fmt_default;
+	par->src_format = fmt_default;
+
+	return 0;
+
+err_free_hdl:
+	kfree(par);
+
+	return ret;
+}
+
+static const struct component_ops dcmipp_par_comp_ops = {
+	.bind = dcmipp_par_comp_bind,
+	.unbind = dcmipp_par_comp_unbind,
+};
+
+static int dcmipp_par_probe(struct platform_device *pdev)
+{
+	return component_add(&pdev->dev, &dcmipp_par_comp_ops);
+}
+
+static int dcmipp_par_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &dcmipp_par_comp_ops);
+
+	return 0;
+}
+
+static const struct platform_device_id dcmipp_par_driver_ids[] = {
+	{
+		.name           = DCMIPP_PAR_DRV_NAME,
+	},
+	{ }
+};
+
+static struct platform_driver dcmipp_par_pdrv = {
+	.probe		= dcmipp_par_probe,
+	.remove		= dcmipp_par_remove,
+	.id_table	= dcmipp_par_driver_ids,
+	.driver		= {
+		.name	= DCMIPP_PAR_DRV_NAME,
+	},
+};
+
+module_platform_driver(dcmipp_par_pdrv);
+
+MODULE_DEVICE_TABLE(platform, dcmipp_par_driver_ids);
+
+MODULE_AUTHOR("Hugues Fruchet <hugues.fruchet@foss.st.com>");
+MODULE_AUTHOR("Alain Volmat <hugues.fruchet@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 Digital Camera Memory Interface with Pixel Processor driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-pixelcap.c b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-pixelcap.c
new file mode 100644
index 000000000..3465d9d53
--- /dev/null
+++ b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-pixelcap.c
@@ -0,0 +1,1266 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include <linux/component.h>
+#include <linux/delay.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mc.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "dcmipp-common.h"
+
+#define DCMIPP_PIXELCAP_DRV_NAME "dcmipp-pixelcap"
+
+#define DCMIPP_PRSR (0x1F8)
+/* TODO - CMIER configuration should be done in a common place since it is
+ * common to all pipes and thus should be in core with a dedicated mutex
+ */
+#define DCMIPP_CMIER (0x3F0)
+#define DCMIPP_CMIER_P1FRAMEIE BIT(17)
+#define DCMIPP_CMIER_P1VSYNCIE BIT(18)
+#define DCMIPP_CMIER_P1OVRIE BIT(23)
+#define DCMIPP_CMIER_P2FRAMEIE BIT(25)
+#define DCMIPP_CMIER_P2VSYNCIE BIT(26)
+#define DCMIPP_CMIER_P2OVRIE BIT(31)
+#define DCMIPP_CMIER_PxALL(id) (((id) == 1) ? (DCMIPP_CMIER_P1VSYNCIE |\
+					       DCMIPP_CMIER_P1FRAMEIE |\
+					       DCMIPP_CMIER_P1OVRIE) :\
+					      (DCMIPP_CMIER_P2VSYNCIE |\
+					       DCMIPP_CMIER_P2FRAMEIE |\
+					       DCMIPP_CMIER_P2OVRIE))
+#define DCMIPP_CMSR1 (0x3F4)
+#define DCMIPP_CMSR2 (0x3F8)
+#define DCMIPP_CMSR2_P1FRAMEF BIT(17)
+#define DCMIPP_CMSR2_P1VSYNCF BIT(18)
+#define DCMIPP_CMSR2_P1OVRF BIT(23)
+#define DCMIPP_CMSR2_P2FRAMEF BIT(25)
+#define DCMIPP_CMSR2_P2VSYNCF BIT(26)
+#define DCMIPP_CMSR2_P2OVRF BIT(31)
+#define DCMIPP_CMSR2_PxFRAMEF(id) (((id) == 1) ? DCMIPP_CMSR2_P1FRAMEF :\
+						 DCMIPP_CMSR2_P2FRAMEF)
+#define DCMIPP_CMSR2_PxVSYNCF(id) (((id) == 1) ? DCMIPP_CMSR2_P1VSYNCF :\
+						 DCMIPP_CMSR2_P2VSYNCF)
+#define DCMIPP_CMSR2_PxOVRF(id) (((id) == 1) ? DCMIPP_CMSR2_P1OVRF :\
+					       DCMIPP_CMSR2_P2OVRF)
+#define DCMIPP_CMFCR (0x3FC)
+#define DCMIPP_P1FSCR (0x804)
+#define DCMIPP_P2FSCR (0xC04)
+#define DCMIPP_PxFSCR(id) (((id) == 1) ? DCMIPP_P1FSCR :\
+					 DCMIPP_P2FSCR)
+#define DCMIPP_PxFSCR_PIPEN BIT(31)
+#define DCMIPP_P1FCTCR (0x900)
+#define DCMIPP_P2FCTCR (0xD00)
+#define DCMIPP_PxFCTCR(id) (((id) == 1) ? DCMIPP_P1FCTCR :\
+					  DCMIPP_P2FCTCR)
+#define DCMIPP_PxFCTCR_CPTMODE BIT(2)
+#define DCMIPP_PxFCTCR_CPTREQ BIT(3)
+#define DCMIPP_P1PPM0AR1 (0x9C4)
+#define DCMIPP_P2PPM0AR1 (0xDC4)
+#define DCMIPP_PxPPM0AR1(id) (((id) == 1) ? DCMIPP_P1PPM0AR1 :\
+					    DCMIPP_P2PPM0AR1)
+#define DCMIPP_P1PPM0PR (0x9CC)
+#define DCMIPP_P2PPM0PR (0xDCC)
+#define DCMIPP_PxPPM0PR(id) (((id) == 1) ? DCMIPP_P1PPM0PR :\
+					   DCMIPP_P2PPM0PR)
+#define DCMIPP_P1PPM1AR1 (0x9D4)
+#define DCMIPP_P1PPM1PR (0x9DC)
+#define DCMIPP_P1PPM2AR1 (0x9E4)
+
+#define DCMIPP_P1SR (0x9F8)
+#define DCMIPP_P2SR (0xDF8)
+#define DCMIPP_PxSR(id) (((id) == 1) ? DCMIPP_P1SR :\
+				       DCMIPP_P2SR)
+#define DCMIPP_PxSR_CPTACT BIT(23)
+
+struct dcmipp_pixelcap_pix_map {
+	unsigned int code;
+	u32 pixelformat;
+	u32 plane_nb;
+};
+
+#define PIXMAP_MBUS_PFMT(mbus, fmt, nb_plane)			\
+		{						\
+			.code = MEDIA_BUS_FMT_##mbus,		\
+			.pixelformat = V4L2_PIX_FMT_##fmt,	\
+			.plane_nb = nb_plane,			\
+		}
+
+/* TODO - need to differiance here format of MAIN vs AUX */
+static const struct dcmipp_pixelcap_pix_map dcmipp_pixelcap_pix_map_list[] = {
+	PIXMAP_MBUS_PFMT(RGB565_2X8_LE, RGB565, 1),
+	PIXMAP_MBUS_PFMT(YUYV8_2X8, YUYV, 1),
+	PIXMAP_MBUS_PFMT(YVYU8_2X8, YVYU, 1),
+	PIXMAP_MBUS_PFMT(UYVY8_2X8, UYVY, 1),
+	PIXMAP_MBUS_PFMT(VYUY8_2X8, VYUY, 1),
+	PIXMAP_MBUS_PFMT(Y8_1X8, GREY, 1),
+	/* Added from dcmipp-capture - to be tested */
+	PIXMAP_MBUS_PFMT(RGB888_1X24, RGB24, 1),
+	PIXMAP_MBUS_PFMT(ARGB8888_1X32, ARGB32, 1),
+	PIXMAP_MBUS_PFMT(AYUV8_1X32, AYUV32, 1),
+	PIXMAP_MBUS_PFMT(YUYV8_1_5X8, NV12, 2), /* Not sure */
+	PIXMAP_MBUS_PFMT(YUYV8_1_5X8, NV16, 2), /* Not sure */
+	PIXMAP_MBUS_PFMT(Y12_1X12, YUV420, 3), /* Not sure */
+};
+
+static const struct dcmipp_pixelcap_pix_map *dcmipp_pixelcap_pix_map_by_pixelformat
+						(u32 pixelformat)
+{
+	const struct dcmipp_pixelcap_pix_map *l = dcmipp_pixelcap_pix_map_list;
+	unsigned int size = ARRAY_SIZE(dcmipp_pixelcap_pix_map_list);
+	unsigned int i;
+
+	for (i = 0; i < size; i++) {
+		if (l[i].pixelformat == pixelformat)
+			return &l[i];
+	}
+
+	return NULL;
+}
+
+static const struct dcmipp_pixelcap_pix_map *dcmipp_pixelcap_pix_map_by_index(unsigned int i)
+{
+	const struct dcmipp_pixelcap_pix_map *l = dcmipp_pixelcap_pix_map_list;
+	unsigned int size = ARRAY_SIZE(dcmipp_pixelcap_pix_map_list);
+
+	if (i >= size)
+		return NULL;
+
+	return &l[i];
+}
+
+struct dcmipp_buf {
+	struct vb2_v4l2_buffer	vb;
+	bool			prepared;
+	dma_addr_t		paddr;
+	size_t			size;
+	struct list_head	list;
+};
+
+enum state {
+	STOPPED = 0,
+	WAIT_FOR_BUFFER,
+	RUNNING,
+};
+
+struct dcmipp_pixelcap_device {
+	struct dcmipp_ent_device ved;
+	struct video_device vdev;
+	struct device *dev;
+	struct device *cdev;
+	struct v4l2_pix_format format;
+	struct vb2_queue queue;
+	struct list_head buffers;
+	/* Protects the access of variables shared within the interrupt */
+	spinlock_t irqlock;
+	/* Protect this data structure */
+	struct mutex lock;
+	u32 sequence;
+	struct media_pipeline pipe;
+
+	enum state state;
+
+	struct dcmipp_buf *active;
+
+	void __iomem *regs;
+	struct reset_control *rstc;
+
+	u32 pipe_id;
+
+	u32 cmier;
+	u32 cmsr2;
+
+	int errors_count;
+	int overrun_count;
+	int buffers_count;
+	int vsync_count;
+	int frame_count;
+	int it_count;
+};
+
+static const struct v4l2_pix_format fmt_default = {
+	.width = DCMIPP_FMT_WIDTH_DEFAULT,
+	.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	.pixelformat = V4L2_PIX_FMT_RGB565,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_DEFAULT,
+};
+
+struct dcmipp_pixelcap_buffer {
+	/*
+	 * struct vb2_v4l2_buffer must be the first element
+	 * the videobuf2 framework will allocate this struct based on
+	 * buf_struct_size and use the first sizeof(struct vb2_buffer) bytes of
+	 * memory as a vb2_buffer
+	 */
+	struct vb2_v4l2_buffer vb2;
+	struct list_head list;
+};
+
+static inline int frame_size(u32 width, u32 height, u32 format)
+{
+	switch (format) {
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_YUV420:
+		return (width * height * 3) / 2;
+	case V4L2_PIX_FMT_GREY:
+		return (width * height);
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_UYVY:
+		return (width * height * 2);
+	case V4L2_PIX_FMT_RGB24:
+		return (width * height * 3);
+	case V4L2_PIX_FMT_ARGB32:
+		return (width * height * 4);
+	default:
+		return 0;
+	}
+}
+
+static inline int frame_stride(u32 width, u32 format)
+{
+	switch (format) {
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_GREY:
+		return width;
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_UYVY:
+		return (width * 2);
+	case V4L2_PIX_FMT_RGB24:
+		return (width * 3);
+	case V4L2_PIX_FMT_ARGB32:
+		return (width * 4);
+	default:
+		return 0;
+	}
+}
+
+static inline int hdw_pixel_alignment(u32 format)
+{
+	/* 16 bytes alignment required by hardware */
+	switch (format) {
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_GREY:
+		return 4;/* 2^4 = 16 pixels = 16 bytes */
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_UYVY:
+	case V4L2_PIX_FMT_NV16:
+	case V4L2_PIX_FMT_RGB24:
+		return 3;/* 2^3  = 8 pixels = 16 bytes */
+	case V4L2_PIX_FMT_ARGB32:
+		return 2;/* 2^2  = 4 pixels = 16 bytes */
+	default:
+		return 0;
+	}
+}
+
+static inline u32 frame_chroma(u32 addr, u32 width, u32 height, u32 format)
+{
+	switch (format) {
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_YUV420:
+		return addr + width * height;
+	case V4L2_PIX_FMT_NV16:
+		return addr + (width * height * 2);
+	default:
+		return 0;
+	}
+}
+
+static inline u32 frame_chromab(u32 addr, u32 width, u32 height, u32 format)
+{
+	switch (format) {
+	case V4L2_PIX_FMT_YUV420:
+		return addr + (width * height * 5) / 4;
+	default:
+		return 0;
+	}
+}
+
+static inline int frame_addrs(dma_addr_t base_addr, dma_addr_t addrs[],
+			      u32 strides[], u64 sizes[],
+			      u32 width, u32 height, u32 format)
+{
+	switch (format) {
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_UYVY:
+		addrs[0] = base_addr;
+		strides[0] = width * 2;
+		sizes[0] = strides[0] * height;
+		return 0;
+	case V4L2_PIX_FMT_RGB24:
+		addrs[0] = base_addr;
+		strides[0] = width * 3;
+		sizes[0] = strides[0] * height;
+		return 0;
+	case V4L2_PIX_FMT_ARGB32:
+		addrs[0] = base_addr;
+		strides[0] = width * 4;
+		sizes[0] = strides[0] * height;
+		return 0;
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV21:
+		addrs[0] = base_addr;
+		strides[0] = width;
+		sizes[0] = width * height;
+		addrs[1] = addrs[0] + sizes[0];
+		strides[1] = strides[0];
+		sizes[1] = width * height / 2;
+		return 0;
+	case V4L2_PIX_FMT_NV16:
+	case V4L2_PIX_FMT_NV61:
+		addrs[0] = base_addr;
+		strides[0] = width;
+		sizes[0] = strides[0] * height;
+		addrs[1] = addrs[0] + sizes[0];
+		strides[1] = strides[0];
+		sizes[1] = width * height;
+		return 0;
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_YVU420:
+		addrs[0] = base_addr;
+		strides[0] = width;
+		sizes[0] = strides[0] * height;
+		addrs[1] = addrs[0] + sizes[0];
+		strides[1] = strides[0] / 2;
+		sizes[1] = width * height / 4;
+		addrs[2] = addrs[1] + sizes[1];
+		strides[2] = strides[0] / 2;
+		sizes[2] = width * height / 4;
+		return 0;
+	default:
+		return -1;
+	}
+}
+
+static int dcmipp_pixelcap_querycap(struct file *file, void *priv,
+				    struct v4l2_capability *cap)
+{
+	strscpy(cap->driver, DCMIPP_PDEV_NAME, sizeof(cap->driver));
+	strscpy(cap->card, KBUILD_MODNAME, sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info),
+		 "platform:%s", DCMIPP_PDEV_NAME);
+
+	return 0;
+}
+
+static void dcmipp_pixelcap_get_format(struct dcmipp_ent_device *ved,
+				       struct v4l2_pix_format *fmt)
+{
+	struct dcmipp_pixelcap_device *vcap =
+		container_of(ved, struct dcmipp_pixelcap_device, ved);
+
+	*fmt = vcap->format;
+}
+
+static int dcmipp_pixelcap_g_fmt_vid_cap(struct file *file, void *priv,
+					 struct v4l2_format *f)
+{
+	struct dcmipp_pixelcap_device *vcap = video_drvdata(file);
+
+	f->fmt.pix = vcap->format;
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_try_fmt_vid_cap(struct file *file, void *priv,
+					   struct v4l2_format *f)
+{
+	struct dcmipp_pixelcap_device *vcap = video_drvdata(file);
+	struct v4l2_pix_format *format = &f->fmt.pix;
+	const struct dcmipp_pixelcap_pix_map *vpix;
+	u32 in_w, in_h;
+
+	/* Don't accept a pixelformat that is not on the table */
+	vpix = dcmipp_pixelcap_pix_map_by_pixelformat(format->pixelformat);
+	if (!vpix)
+		format->pixelformat = fmt_default.pixelformat;
+
+	/* Adjust width & height */
+	in_w = format->width;
+	in_h = format->height;
+	v4l_bound_align_image(&format->width,
+			      DCMIPP_FRAME_MIN_WIDTH, DCMIPP_FRAME_MAX_WIDTH,
+			      hdw_pixel_alignment(format->pixelformat),
+			      &format->height,
+			      DCMIPP_FRAME_MIN_HEIGHT, DCMIPP_FRAME_MAX_HEIGHT,
+			      hdw_pixel_alignment(format->pixelformat),
+			      0);
+	if (format->width != in_w || format->height != in_h)
+		dev_dbg(vcap->dev,
+			"resolution updated: %dx%d -> %dx%d\n",
+			in_w, in_h, format->width, format->height);
+
+	format->bytesperline = frame_stride(format->width, format->pixelformat);
+	format->sizeimage = frame_size(format->width, format->height, format->pixelformat);
+
+	if (format->field == V4L2_FIELD_ANY)
+		format->field = fmt_default.field;
+
+	dcmipp_colorimetry_clamp(format);
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_s_fmt_vid_cap(struct file *file, void *priv,
+					 struct v4l2_format *f)
+{
+	struct dcmipp_pixelcap_device *vcap = video_drvdata(file);
+	int ret;
+
+	/* Do not change the format while stream is on */
+	if (vb2_is_busy(&vcap->queue))
+		return -EBUSY;
+
+	ret = dcmipp_pixelcap_try_fmt_vid_cap(file, priv, f);
+	if (ret)
+		return ret;
+
+	dev_dbg(vcap->dev, "%s: format update: old:%dx%d (0x%x, %d, %d, %d, %d) new:%dx%d (0x%x, %d, %d, %d, %d)\n",
+		vcap->vdev.name,
+		/* old */
+		vcap->format.width, vcap->format.height,
+		vcap->format.pixelformat, vcap->format.colorspace,
+		vcap->format.quantization, vcap->format.xfer_func,
+		vcap->format.ycbcr_enc,
+		/* new */
+		f->fmt.pix.width, f->fmt.pix.height,
+		f->fmt.pix.pixelformat, f->fmt.pix.colorspace,
+		f->fmt.pix.quantization, f->fmt.pix.xfer_func,
+		f->fmt.pix.ycbcr_enc);
+
+	vcap->format = f->fmt.pix;
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_enum_fmt_vid_cap(struct file *file, void *priv,
+					    struct v4l2_fmtdesc *f)
+{
+	const struct dcmipp_pixelcap_pix_map *vpix = dcmipp_pixelcap_pix_map_by_index(f->index);
+
+	if (!vpix)
+		return -EINVAL;
+
+	/* TODO - need to differentiate here format of MAIN vs AUX */
+
+	f->pixelformat = vpix->pixelformat;
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_enum_framesizes(struct file *file, void *fh,
+					   struct v4l2_frmsizeenum *fsize)
+{
+	const struct dcmipp_pixelcap_pix_map *vpix;
+
+	if (fsize->index)
+		return -EINVAL;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_pixelcap_pix_map_by_pixelformat(fsize->pixel_format);
+	if (!vpix)
+		return -EINVAL;
+
+	/* TODO - need to differentiate here format of MAIN vs AUX */
+
+	fsize->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;
+	fsize->stepwise.min_width = DCMIPP_FRAME_MIN_WIDTH;
+	fsize->stepwise.max_width = DCMIPP_FRAME_MAX_WIDTH;
+	fsize->stepwise.min_height = DCMIPP_FRAME_MIN_HEIGHT;
+	fsize->stepwise.max_height = DCMIPP_FRAME_MAX_HEIGHT;
+	fsize->stepwise.step_width = 1;
+	fsize->stepwise.step_height = 1;
+
+	return 0;
+}
+
+/* TODO - based on the explanation text, should also use v4l2_pipeline_link_notify */
+static int dcmipp_pixelcap_open(struct file *file)
+{
+	struct dcmipp_pixelcap_device *vcap = video_drvdata(file);
+	int ret;
+
+	ret = mutex_lock_interruptible(&vcap->lock);
+	if (ret)
+		return ret;
+
+	ret = v4l2_fh_open(file);
+	if (ret)
+		goto err_unlock;
+
+	ret = v4l2_pipeline_pm_get(&vcap->vdev.entity);
+	if (ret)
+		goto err_close;
+
+	mutex_unlock(&vcap->lock);
+
+	return 0;
+
+err_close:
+	v4l2_fh_release(file);
+err_unlock:
+	mutex_unlock(&vcap->lock);
+
+	return ret;
+}
+
+static int dcmipp_pixelcap_close(struct file *file)
+{
+	struct dcmipp_pixelcap_device *vcap = video_drvdata(file);
+
+	vb2_fop_release(file);
+
+	v4l2_pipeline_pm_put(&vcap->vdev.entity);
+
+	return 0;
+}
+
+static const struct v4l2_file_operations dcmipp_pixelcap_fops = {
+	.owner		= THIS_MODULE,
+	.open		= dcmipp_pixelcap_open,
+	.release	= dcmipp_pixelcap_close,
+	.read           = vb2_fop_read,
+	.poll		= vb2_fop_poll,
+	.unlocked_ioctl = video_ioctl2,
+	.mmap           = vb2_fop_mmap,
+};
+
+static const struct v4l2_ioctl_ops dcmipp_pixelcap_ioctl_ops = {
+	.vidioc_querycap = dcmipp_pixelcap_querycap,
+
+	.vidioc_g_fmt_vid_cap = dcmipp_pixelcap_g_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap = dcmipp_pixelcap_s_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap = dcmipp_pixelcap_try_fmt_vid_cap,
+	.vidioc_enum_fmt_vid_cap = dcmipp_pixelcap_enum_fmt_vid_cap,
+	.vidioc_enum_framesizes = dcmipp_pixelcap_enum_framesizes,
+
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+};
+
+static int dcmipp_pipeline_s_stream(struct dcmipp_pixelcap_device *vcap,
+				    int state)
+{
+	struct media_entity *entity = &vcap->vdev.entity;
+	struct v4l2_subdev *subdev;
+	struct media_pad *pad;
+	int ret;
+
+	/* Start/stop all entities within pipeline */
+	while (1) {
+		pad = &entity->pads[0];
+		if (!(pad->flags & MEDIA_PAD_FL_SINK))
+			break;
+
+		pad = media_entity_remote_pad(pad);
+		if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
+			break;
+
+		entity = pad->entity;
+		subdev = media_entity_to_v4l2_subdev(entity);
+
+		ret = v4l2_subdev_call(subdev, video, s_stream, state);
+		if (ret < 0 && ret != -ENOIOCTLCMD) {
+			dev_err(vcap->dev, "%s: \"%s\" failed to %s streaming (%d)\n",
+				__func__, subdev->name,
+				state ? "start" : "stop", ret);
+
+			if (!state)
+				v4l2_subdev_call(subdev, core, s_power, state);
+
+			return ret;
+		}
+
+		dev_dbg(vcap->dev, "\"%s\" is %s\n",
+			subdev->name, state ? "started" : "stopped");
+	}
+
+	return 0;
+}
+
+static int dcmipp_start_capture(struct dcmipp_pixelcap_device *vcap,
+				struct dcmipp_buf *buf)
+{
+	struct v4l2_pix_format *format = &vcap->format;
+	dma_addr_t addrs[3] = {0, 0, 0};
+	u32 strides[3] = {0, 0, 0};
+	u64 sizes[3] = {0, 0, 0};
+	int ret;
+
+	ret = frame_addrs(buf->paddr, addrs, strides, sizes,
+			  format->width, format->height, format->pixelformat);
+	if (ret) {
+		dev_err(vcap->dev, "%s: Unsupported pixel format (%x)\n",
+			__func__, format->pixelformat);
+		return ret;
+	}
+
+	/* Check for 16 bytes alignment required by hardware */
+	WARN_ON(addrs[0] & 15);
+	WARN_ON(strides[0] & 15);
+	WARN_ON(addrs[1] & 15);
+	WARN_ON(strides[1] & 15);
+	WARN_ON(addrs[2] & 15);
+
+	/*
+	 * Set buffer address
+	 * This register is taken into account immediately
+	 */
+	if (addrs[0]) {
+		reg_write(vcap, DCMIPP_PxPPM0AR1(vcap->pipe_id), addrs[0]);
+		reg_write(vcap, DCMIPP_PxPPM0PR(vcap->pipe_id), strides[0]);
+	}
+
+	/* TODO - AUX pipe cannot handling that I think */
+	if (addrs[1]) {
+		reg_write(vcap, DCMIPP_P1PPM1AR1, addrs[1]);
+		reg_write(vcap, DCMIPP_P1PPM1PR, strides[1]);
+	}
+
+	if (addrs[2])
+		reg_write(vcap, DCMIPP_P1PPM2AR1, addrs[2]);
+
+	/* Capture request */
+	reg_set(vcap, DCMIPP_PxFCTCR(vcap->pipe_id), DCMIPP_PxFCTCR_CPTREQ);
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_start_streaming(struct vb2_queue *vq,
+					   unsigned int count)
+{
+	struct dcmipp_pixelcap_device *vcap = vb2_get_drv_priv(vq);
+	struct media_entity *entity = &vcap->vdev.entity;
+	struct dcmipp_buf *buf, *node;
+	int ret;
+
+	vcap->sequence = 0;
+	vcap->errors_count = 0;
+	vcap->overrun_count = 0;
+	vcap->buffers_count = 0;
+	vcap->vsync_count = 0;
+	vcap->frame_count = 0;
+	vcap->it_count = 0;
+
+	ret = pm_runtime_get_sync(vcap->cdev);
+	if (ret < 0) {
+		dev_err(vcap->dev, "%s: Failed to start streaming, cannot get sync (%d)\n",
+			__func__, ret);
+		goto err_pm_put;
+	}
+
+	/* Start the media pipeline */
+	ret = media_pipeline_start(entity, &vcap->pipe);
+	if (ret) {
+		dev_err(vcap->dev, "%s: Failed to start streaming, media pipeline start error (%d)\n",
+			__func__, ret);
+		goto err_pm_put;
+	}
+
+	/* Start all the elements within pipeline */
+	ret = dcmipp_pipeline_s_stream(vcap, 1);
+	if (ret)
+		goto err_media_pipeline_stop;
+
+/* TODO - CMIER configuration should be done in a common place since it is
+ * common to all pipes and thus should be in core with a dedicated mutex
+ */
+	/* Enable interruptions */
+	vcap->cmier |= DCMIPP_CMIER_PxALL(vcap->pipe_id);
+	reg_set(vcap, DCMIPP_CMIER, vcap->cmier);
+
+	/* Snapshot mode */
+	reg_set(vcap, DCMIPP_PxFCTCR(vcap->pipe_id), DCMIPP_PxFCTCR_CPTMODE);
+
+	/* Enable pipe at the end of programming */
+	reg_set(vcap, DCMIPP_PxFSCR(vcap->pipe_id), DCMIPP_PxFSCR_PIPEN);
+
+	/*
+	 * Start capture if at least one buffer has been queued,
+	 * otherwise start is deferred at next buffer queueing
+	 */
+	buf = list_first_entry_or_null(&vcap->buffers, typeof(*buf), list);
+	if (!buf) {
+		dev_dbg(vcap->dev, "Start streaming is deferred to next buffer queueing\n");
+		vcap->active = NULL;
+		vcap->state = WAIT_FOR_BUFFER;
+		return 0;
+	}
+	vcap->active = buf;
+	dev_dbg(vcap->dev, "Start active [%d] %p phy=%pad\n",
+		buf->vb.vb2_buf.index, buf, &buf->paddr);
+
+	vcap->state = RUNNING;
+
+	/* Start capture */
+	ret = dcmipp_start_capture(vcap, buf);
+	if (ret)
+		goto err_media_pipeline_stop;
+
+	return 0;
+
+err_media_pipeline_stop:
+	media_pipeline_stop(entity);
+err_pm_put:
+	pm_runtime_put(vcap->cdev);
+	spin_lock_irq(&vcap->irqlock);
+	/*
+	 * Return all buffers to vb2 in QUEUED state.
+	 * This will give ownership back to userspace
+	 */
+	list_for_each_entry_safe(buf, node, &vcap->buffers, list) {
+		list_del_init(&buf->list);
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);
+	}
+	vcap->active = NULL;
+	spin_unlock_irq(&vcap->irqlock);
+
+	return ret;
+}
+
+static void dcmipp_dump_status(struct dcmipp_pixelcap_device *vcap)
+{
+	struct device *dev = vcap->dev;
+
+	dev_dbg(dev, "[DCMIPP_PRSR]  =%#10.8x\n", reg_read(vcap, DCMIPP_PRSR));
+	dev_dbg(dev, "[DCMIPP_PxSR] =%#10.8x\n", reg_read(vcap, DCMIPP_PxSR(vcap->pipe_id)));
+	dev_dbg(dev, "[DCMIPP_CMSR1] =%#10.8x\n", reg_read(vcap, DCMIPP_CMSR1));
+	dev_dbg(dev, "[DCMIPP_CMSR2] =%#10.8x\n", reg_read(vcap, DCMIPP_CMSR2));
+}
+
+/*
+ * Stop the stream engine. Any remaining buffers in the stream queue are
+ * dequeued and passed on to the vb2 framework marked as STATE_ERROR.
+ */
+static void dcmipp_pixelcap_stop_streaming(struct vb2_queue *vq)
+{
+	struct dcmipp_pixelcap_device *vcap = vb2_get_drv_priv(vq);
+	struct dcmipp_buf *buf, *node;
+	int ret;
+	u32 status;
+
+	dcmipp_pipeline_s_stream(vcap, 0);
+
+	/* Stop the media pipeline */
+	media_pipeline_stop(&vcap->vdev.entity);
+
+/* TODO - CMIER configuration should be done in a common place since it is
+ * common to all pipes and thus should be in core with a dedicated mutex
+ */
+
+	/* Disable interruptions */
+	reg_clear(vcap, DCMIPP_CMIER, vcap->cmier);
+
+	/* Stop capture */
+	reg_clear(vcap, DCMIPP_PxFCTCR(vcap->pipe_id), DCMIPP_PxFCTCR_CPTREQ);
+
+	/* Wait until CPTACT become 0 */
+	ret = readl_relaxed_poll_timeout(vcap->regs + DCMIPP_PxSR(vcap->pipe_id),
+					 status,
+					 !(status & DCMIPP_PxSR_CPTACT),
+					 20, 1000);
+	if (ret)
+		dev_warn(vcap->dev, "Timeout when stopping\n");
+
+	/* Disable pipe */
+	reg_clear(vcap, DCMIPP_PxFSCR(vcap->pipe_id), DCMIPP_PxFSCR_PIPEN);
+
+	spin_lock_irq(&vcap->irqlock);
+
+	/* Return all queued buffers to vb2 in ERROR state */
+	list_for_each_entry_safe(buf, node, &vcap->buffers, list) {
+		list_del_init(&buf->list);
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+	INIT_LIST_HEAD(&vcap->buffers);
+
+	vcap->active = NULL;
+	vcap->state = STOPPED;
+
+	dcmipp_dump_status(vcap);
+
+	spin_unlock_irq(&vcap->irqlock);
+
+	pm_runtime_put(vcap->cdev);
+
+	if (ret) {
+		/* Reset IP on timeout */
+		if (reset_control_assert(vcap->rstc))
+			dev_warn(vcap->dev, "Failed to assert the reset line\n");
+
+		usleep_range(3000, 5000);
+
+		if (reset_control_deassert(vcap->rstc))
+			dev_warn(vcap->dev, "Failed to deassert the reset line\n");
+	}
+
+	if (vcap->errors_count)
+		dev_warn(vcap->dev, "Some errors found while streaming: errors=%d (overrun=%d), buffers=%d\n",
+			 vcap->errors_count, vcap->overrun_count,
+			 vcap->buffers_count);
+	dev_dbg(vcap->dev, "Stop streaming, errors=%d (overrun=%d), vsync=%d, frame=%d, buffers=%d, it=%d\n",
+		vcap->errors_count, vcap->overrun_count,
+		vcap->vsync_count,
+		vcap->frame_count, vcap->buffers_count,
+		vcap->it_count);
+}
+
+static int dcmipp_pixelcap_buf_prepare(struct vb2_buffer *vb)
+{
+	struct dcmipp_pixelcap_device *vcap =  vb2_get_drv_priv(vb->vb2_queue);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct dcmipp_buf *buf = container_of(vbuf, struct dcmipp_buf, vb);
+	unsigned long size;
+
+	size = vcap->format.sizeimage;
+
+	if (vb2_plane_size(vb, 0) < size) {
+		dev_err(vcap->dev, "%s data will not fit into plane (%lu < %lu)\n",
+			__func__, vb2_plane_size(vb, 0), size);
+		return -EINVAL;
+	}
+
+	vb2_set_plane_payload(vb, 0, size);
+
+	if (!buf->prepared) {
+		/* Get memory addresses */
+		buf->paddr =
+			vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
+		buf->size = vb2_plane_size(&buf->vb.vb2_buf, 0);
+		buf->prepared = true;
+
+		vb2_set_plane_payload(&buf->vb.vb2_buf, 0, buf->size);
+
+		dev_dbg(vcap->dev, "buffer[%d] phy=%pad size=%zu\n",
+			vb->index, &buf->paddr, buf->size);
+	}
+
+	return 0;
+}
+
+static void dcmipp_pixelcap_buf_queue(struct vb2_buffer *vb2_buf)
+{
+	struct dcmipp_pixelcap_device *vcap = vb2_get_drv_priv(vb2_buf->vb2_queue);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb2_buf);
+	struct dcmipp_buf *buf = container_of(vbuf, struct dcmipp_buf, vb);
+
+	spin_lock_irq(&vcap->irqlock);
+	list_add_tail(&buf->list, &vcap->buffers);
+
+	if (vcap->state == WAIT_FOR_BUFFER) {
+		vcap->active = buf;
+		dev_dbg(vcap->dev, "Start active [%d] %p phy=%pad\n",
+			buf->vb.vb2_buf.index, buf, &buf->paddr);
+
+		vcap->state = RUNNING;
+
+		dev_dbg(vcap->dev, "Starting capture on buffer[%d] queued\n",
+			buf->vb.vb2_buf.index);
+
+		spin_unlock_irq(&vcap->irqlock);
+		if (dcmipp_start_capture(vcap, buf))
+			dev_err(vcap->dev, "%s: Cannot restart capture on new buffer\n",
+				__func__);
+		return;
+	}
+
+	spin_unlock_irq(&vcap->irqlock);
+}
+
+static int dcmipp_pixelcap_queue_setup(struct vb2_queue *vq,
+				       unsigned int *nbuffers,
+				       unsigned int *nplanes,
+				       unsigned int sizes[],
+				       struct device *alloc_devs[])
+{
+	struct dcmipp_pixelcap_device *vcap = vb2_get_drv_priv(vq);
+	unsigned int size;
+
+	size = vcap->format.sizeimage;
+
+	/* Make sure the image size is large enough */
+	if (*nplanes)
+		return sizes[0] < vcap->format.sizeimage ? -EINVAL : 0;
+
+	*nplanes = 1;
+	sizes[0] = vcap->format.sizeimage;
+
+	dev_dbg(vcap->dev, "Setup queue, count=%d, size=%d\n",
+		*nbuffers, size);
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_buf_init(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct dcmipp_buf *buf = container_of(vbuf, struct dcmipp_buf, vb);
+
+	INIT_LIST_HEAD(&buf->list);
+
+	return 0;
+}
+
+static const struct vb2_ops dcmipp_pixelcap_qops = {
+	.start_streaming	= dcmipp_pixelcap_start_streaming,
+	.stop_streaming		= dcmipp_pixelcap_stop_streaming,
+	.buf_init		= dcmipp_pixelcap_buf_init,
+	.buf_prepare		= dcmipp_pixelcap_buf_prepare,
+	.buf_queue		= dcmipp_pixelcap_buf_queue,
+	.queue_setup		= dcmipp_pixelcap_queue_setup,
+	/*
+	 * Since q->lock is set we can use the standard
+	 * vb2_ops_wait_prepare/finish helper functions.
+	 */
+	.wait_prepare		= vb2_ops_wait_prepare,
+	.wait_finish		= vb2_ops_wait_finish,
+};
+
+static const struct media_entity_operations dcmipp_pixelcap_mops = {
+	.link_validate		= dcmipp_link_validate,
+};
+
+static void dcmipp_pixelcap_release(struct video_device *vdev)
+{
+	struct dcmipp_pixelcap_device *vcap =
+		container_of(vdev, struct dcmipp_pixelcap_device, vdev);
+
+	dcmipp_pads_cleanup(vcap->ved.pads);
+	kfree(vcap);
+}
+
+static void dcmipp_pixelcap_comp_unbind(struct device *comp,
+					struct device *master,
+					void *master_data)
+{
+	struct dcmipp_ent_device *ved = dev_get_drvdata(comp);
+	struct dcmipp_pixelcap_device *vcap =
+		container_of(ved, struct dcmipp_pixelcap_device, ved);
+
+	media_entity_cleanup(ved->ent);
+	vb2_video_unregister_device(&vcap->vdev);
+}
+
+static void dcmipp_buffer_done(struct dcmipp_pixelcap_device *vcap,
+			       struct dcmipp_buf *buf,
+			       size_t bytesused,
+			       int err)
+{
+	struct vb2_v4l2_buffer *vbuf;
+
+	if (!buf)
+		return;
+
+	list_del_init(&buf->list);
+
+	vbuf = &buf->vb;
+
+	vbuf->sequence = vcap->sequence++;
+	vbuf->field = V4L2_FIELD_NONE;
+	vbuf->vb2_buf.timestamp = ktime_get_ns();
+	vb2_set_plane_payload(&vbuf->vb2_buf, 0, bytesused);
+	vb2_buffer_done(&vbuf->vb2_buf,
+			err ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);
+
+	vcap->buffers_count++;
+	vcap->active = NULL;
+}
+
+/* irqlock must be held */
+static void
+dcmipp_pixelcap_prepare_next_frame(struct dcmipp_pixelcap_device *vcap)
+{
+	struct dcmipp_buf *buf;
+
+	/* Configure address register with next buffer */
+	buf = list_first_entry_or_null(&vcap->buffers, typeof(*buf), list);
+	if (!buf) {
+		dev_dbg(vcap->dev, "Capture restart is deferred to next buffer queueing\n");
+		vcap->active = NULL;
+		vcap->state = WAIT_FOR_BUFFER;
+		return;
+	}
+	vcap->active = buf;
+
+	/*
+	 * Set buffer address
+	 * This register is shadowed and will be taken into
+	 * account on next VSYNC (start of next frame)
+	 */
+	reg_write(vcap, DCMIPP_PxPPM0AR1(vcap->pipe_id), buf->paddr);
+
+	/* TODO - need to update the other registers related to buffer address as well */
+
+	/* Capture request */
+	reg_set(vcap, DCMIPP_PxFCTCR(vcap->pipe_id), DCMIPP_PxFCTCR_CPTREQ);
+}
+
+/* irqlock must be held */
+static void dcmipp_pixelcap_process_frame(struct dcmipp_pixelcap_device *vcap)
+{
+	int err = 0;
+	struct dcmipp_buf *buf = vcap->active;
+
+	if (!buf) {
+		dev_dbg(vcap->dev, "skip NULL active frame\n");
+		return;
+	}
+
+	dcmipp_buffer_done(vcap, buf, vcap->format.sizeimage, err);
+
+	dcmipp_pixelcap_prepare_next_frame(vcap);
+}
+
+static irqreturn_t dcmipp_pixelcap_irq_thread(int irq, void *arg)
+{
+	struct dcmipp_pixelcap_device *vcap =
+			container_of(arg, struct dcmipp_pixelcap_device, ved);
+	u32 cmsr2_pxframef;
+	u32 cmsr2_pxvsyncf;
+	u32 cmsr2_pxovrf;
+
+	spin_lock_irq(&vcap->irqlock);
+
+	cmsr2_pxovrf = DCMIPP_CMSR2_PxOVRF(vcap->pipe_id);
+	cmsr2_pxvsyncf = DCMIPP_CMSR2_PxVSYNCF(vcap->pipe_id);
+	cmsr2_pxframef = DCMIPP_CMSR2_PxFRAMEF(vcap->pipe_id);
+
+	if (vcap->cmsr2 & cmsr2_pxovrf) {
+		vcap->overrun_count++;
+		spin_unlock_irq(&vcap->irqlock);
+		return IRQ_HANDLED;
+	}
+
+	if (vcap->cmsr2 & cmsr2_pxframef &&
+	    vcap->cmsr2 & cmsr2_pxvsyncf) {
+		/* If both IT FRAME and VSYNC are received together
+		 * buffers will be corrupted, skip this frame
+		 */
+		vcap->errors_count++;
+		spin_unlock_irq(&vcap->irqlock);
+		return IRQ_HANDLED;
+	}
+
+	if (vcap->cmsr2 & cmsr2_pxframef) {
+		vcap->frame_count++;
+
+		dcmipp_pixelcap_process_frame(vcap);
+	}
+
+	if (vcap->cmsr2 & cmsr2_pxvsyncf)
+		vcap->vsync_count++;
+
+	spin_unlock_irq(&vcap->irqlock);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t dcmipp_pixelcap_irq_callback(int irq, void *arg)
+{
+	struct dcmipp_pixelcap_device *vcap =
+			container_of(arg, struct dcmipp_pixelcap_device, ved);
+
+	vcap->cmsr2 = reg_read(vcap, DCMIPP_CMSR2);
+	vcap->cmsr2 = vcap->cmsr2 & vcap->cmier;
+
+	vcap->it_count++;
+
+	/* Clear interrupt */
+	reg_write(vcap, DCMIPP_CMFCR, vcap->cmsr2);
+
+	return IRQ_WAKE_THREAD;
+}
+
+static int dcmipp_name_to_pipe_id(const char *name)
+{
+	if (strstr(name, "main"))
+		return 1;
+	else if (strstr(name, "aux"))
+		return 2;
+	else
+		return -EINVAL;
+}
+
+static int dcmipp_pixelcap_comp_bind(struct device *comp, struct device *master,
+				     void *master_data)
+{
+	struct dcmipp_bind_data *bind_data = master_data;
+	struct dcmipp_platform_data *pdata = comp->platform_data;
+	struct dcmipp_pixelcap_device *vcap;
+	struct v4l2_pix_format *format;
+	struct video_device *vdev;
+	struct vb2_queue *q;
+	int ret = 0;
+
+	/* Allocate the dcmipp_cap_device struct */
+	vcap = kzalloc(sizeof(*vcap), GFP_KERNEL);
+	if (!vcap)
+		return -ENOMEM;
+
+	/* Retrieve the pipe_id */
+	vcap->pipe_id = dcmipp_name_to_pipe_id(pdata->entity_name);
+	if (vcap->pipe_id != 1 && vcap->pipe_id != 2) {
+		dev_err(comp, "failed to retrieve pipe_id\n");
+		goto err_free_vcap;
+	}
+	/* Allocate the pads */
+	vcap->ved.pads =
+		dcmipp_pads_init(1, (const unsigned long[1]) {MEDIA_PAD_FL_SINK});
+	if (IS_ERR(vcap->ved.pads)) {
+		ret = PTR_ERR(vcap->ved.pads);
+		goto err_free_vcap;
+	}
+
+	/* Initialize the media entity */
+	vcap->vdev.entity.name = pdata->entity_name;
+	vcap->vdev.entity.function = MEDIA_ENT_F_IO_V4L;
+	ret = media_entity_pads_init(&vcap->vdev.entity,
+				     1, vcap->ved.pads);
+	if (ret)
+		goto err_clean_pads;
+
+	/* Initialize the lock */
+	mutex_init(&vcap->lock);
+
+	/* Initialize the vb2 queue */
+	q = &vcap->queue;
+	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	q->io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF;
+	q->lock = &vcap->lock;
+	q->drv_priv = vcap;
+	q->buf_struct_size = sizeof(struct dcmipp_buf);
+	q->ops = &dcmipp_pixelcap_qops;
+	q->mem_ops = &vb2_dma_contig_memops;
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	q->min_buffers_needed = 1;
+	q->dev = comp;
+
+	ret = vb2_queue_init(q);
+	if (ret) {
+		dev_err(comp, "%s: vb2 queue init failed (err=%d)\n",
+			pdata->entity_name, ret);
+		goto err_clean_m_ent;
+	}
+
+	/* Initialize buffer list and its lock */
+	INIT_LIST_HEAD(&vcap->buffers);
+	spin_lock_init(&vcap->irqlock);
+
+	/* Set default frame format */
+	vcap->format = fmt_default;
+	format = &vcap->format;
+	format->bytesperline = frame_stride(format->width, format->pixelformat);
+	format->sizeimage = frame_size(format->width, format->height, format->pixelformat);
+
+	/* Fill the dcmipp_ent_device struct */
+	vcap->ved.ent = &vcap->vdev.entity;
+	vcap->ved.vdev_get_format = dcmipp_pixelcap_get_format;
+	vcap->ved.handler = dcmipp_pixelcap_irq_callback;
+	vcap->ved.thread_fn = dcmipp_pixelcap_irq_thread;
+	dev_set_drvdata(comp, &vcap->ved);
+	vcap->dev = comp;
+	vcap->regs = bind_data->regs;
+	vcap->rstc = bind_data->rstc;
+	vcap->cdev = master;
+
+	/* Initialize the video_device struct */
+	vdev = &vcap->vdev;
+	vdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |
+			    V4L2_CAP_READWRITE;
+	vdev->entity.ops = &dcmipp_pixelcap_mops;
+	vdev->release = dcmipp_pixelcap_release;
+	vdev->fops = &dcmipp_pixelcap_fops;
+	vdev->ioctl_ops = &dcmipp_pixelcap_ioctl_ops;
+	vdev->lock = &vcap->lock;
+	vdev->queue = q;
+	vdev->v4l2_dev = bind_data->v4l2_dev;
+	strscpy(vdev->name, pdata->entity_name, sizeof(vdev->name));
+	video_set_drvdata(vdev, &vcap->ved);
+
+	/* Register the video_device with the v4l2 and the media framework */
+	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
+	if (ret) {
+		dev_err(comp, "%s: video register failed (err=%d)\n",
+			vcap->vdev.name, ret);
+		goto err_clean_m_ent;
+	}
+
+	return 0;
+
+err_clean_m_ent:
+	media_entity_cleanup(&vcap->vdev.entity);
+err_clean_pads:
+	dcmipp_pads_cleanup(vcap->ved.pads);
+err_free_vcap:
+	kfree(vcap);
+
+	return ret;
+}
+
+static const struct component_ops dcmipp_pixelcap_comp_ops = {
+	.bind = dcmipp_pixelcap_comp_bind,
+	.unbind = dcmipp_pixelcap_comp_unbind,
+};
+
+static int dcmipp_pixelcap_probe(struct platform_device *pdev)
+{
+	return component_add(&pdev->dev, &dcmipp_pixelcap_comp_ops);
+}
+
+static int dcmipp_pixelcap_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &dcmipp_pixelcap_comp_ops);
+
+	return 0;
+}
+
+static const struct platform_device_id dcmipp_pixelcap_driver_ids[] = {
+	{
+		.name	= DCMIPP_PIXELCAP_DRV_NAME,
+	},
+	{ }
+};
+
+static struct platform_driver dcmipp_pixelcap_pdrv = {
+	.probe		= dcmipp_pixelcap_probe,
+	.remove		= dcmipp_pixelcap_remove,
+	.id_table	= dcmipp_pixelcap_driver_ids,
+	.driver		= {
+		.name	= DCMIPP_PIXELCAP_DRV_NAME,
+	},
+};
+
+module_platform_driver(dcmipp_pixelcap_pdrv);
+
+MODULE_DEVICE_TABLE(platform, dcmipp_pixelcap_driver_ids);
+
+MODULE_AUTHOR("Hugues Fruchet <hugues.fruchet@foss.st.com>");
+MODULE_AUTHOR("Alain Volmat <alain.volmat@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 Digital Camera Memory Interface with Pixel Processor driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-pixelproc.c b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-pixelproc.c
new file mode 100644
index 000000000..521f32615
--- /dev/null
+++ b/drivers/media/platform/stm32/stm32-dcmipp/dcmipp-pixelproc.c
@@ -0,0 +1,894 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include <linux/component.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/vmalloc.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-rect.h>
+#include <media/v4l2-subdev.h>
+
+#include "dcmipp-common.h"
+#include "dcmipp-colorconv.h"
+
+#define DCMIPP_PIXELPROC_DRV_NAME "dcmipp-pixelproc"
+
+#define DCMIPP_FMT_WIDTH_DEFAULT  640
+#define DCMIPP_FMT_HEIGHT_DEFAULT 480
+
+#define DCMIPP_P1FCTCR (0x900)
+#define DCMIPP_P2FCTCR (0xD00)
+#define DCMIPP_PxFCTCR(id) (((id) == 1) ? DCMIPP_P1FCTCR :\
+			   DCMIPP_P2FCTCR)
+#define DCMIPP_PxFCTCR_FRATE_MASK GENMASK(1, 0)
+#define DCMIPP_P1CRSTR (0x904)
+#define DCMIPP_P2CRSTR (0xD04)
+#define DCMIPP_PxCRSTR(id) (((id) == 1) ? DCMIPP_P1CRSTR :\
+			   DCMIPP_P2CRSTR)
+#define DCMIPP_PxCRSTR_HSTART_SHIFT	0
+#define DCMIPP_PxCRSTR_VSTART_SHIFT	16
+#define DCMIPP_P1CRSZR (0x908)
+#define DCMIPP_P2CRSZR (0xD08)
+#define DCMIPP_PxCRSZR(id) (((id) == 1) ? DCMIPP_P1CRSZR :\
+			   DCMIPP_P2CRSZR)
+#define DCMIPP_PxCRSZR_ENABLE BIT(31)
+#define DCMIPP_PxCRSZR_HSIZE_SHIFT	0
+#define DCMIPP_PxCRSZR_VSIZE_SHIFT	16
+
+#define DCMIPP_P1DSCR (0x910)
+#define DCMIPP_P2DSCR (0xD10)
+#define DCMIPP_PxDSCR(id) (((id) == 1) ? DCMIPP_P1DSCR :\
+			   DCMIPP_P2DSCR)
+#define DCMIPP_PxDSCR_HDIV_SHIFT 0
+#define DCMIPP_PxDSCR_HDIV_MASK GENMASK(9, 0)
+#define DCMIPP_PxDSCR_VDIV_SHIFT 16
+#define DCMIPP_PxDSCR_VDIV_MASK GENMASK(25, 16)
+#define DCMIPP_PxDSCR_ENABLE BIT(31)
+
+#define DCMIPP_P1DSRTIOR (0x914)
+#define DCMIPP_P2DSRTIOR (0xD14)
+#define DCMIPP_PxDSRTIOR(id) (((id) == 1) ? DCMIPP_P1DSRTIOR :\
+			   DCMIPP_P2DSRTIOR)
+#define DCMIPP_PxDSRTIOR_HRATIO_SHIFT 0
+#define DCMIPP_PxDSRTIOR_HRATIO_MASK GENMASK(15, 0)
+#define DCMIPP_PxDSRTIOR_VRATIO_SHIFT 16
+#define DCMIPP_PxDSRTIOR_VRATIO_MASK GENMASK(31, 16)
+
+#define DCMIPP_P1DSSZR (0x918)
+#define DCMIPP_P2DSSZR (0xD18)
+#define DCMIPP_PxDSSZR(id) (((id) == 1) ? DCMIPP_P1DSSZR :\
+			   DCMIPP_P2DSSZR)
+#define DCMIPP_PxDSSZR_HSIZE_SHIFT 0
+#define DCMIPP_PxDSSZR_HSIZE_MASK GENMASK(11, 0)
+#define DCMIPP_PxDSSZR_VSIZE_SHIFT 16
+#define DCMIPP_PxDSSZR_VSIZE_MASK GENMASK(27, 16)
+
+#define DCMIPP_P1GMCR (0x970)
+#define DCMIPP_P2GMCR (0x970)
+#define DCMIPP_PxGMCR(id) (((id) == 1) ? DCMIPP_P1GMCR :\
+			   DCMIPP_P2GMCR)
+#define DCMIPP_PxGMCR_ENABLE BIT(0)
+
+#define DCMIPP_P1YUVCR (0x980)
+#define DCMIPP_P1YUVCR_ENABLE BIT(0)
+#define DCMIPP_P1YUVCR_TYPE_YUV 0
+#define DCMIPP_P1YUVCR_TYPE_RGB BIT(1)
+#define DCMIPP_P1YUVCR_CLAMP BIT(2)
+#define DCMIPP_P1YUVRR1 (0x984)
+#define DCMIPP_P1YUVRR2 (0x988)
+#define DCMIPP_P1YUVGR1 (0x98C)
+#define DCMIPP_P1YUVGR2 (0x990)
+#define DCMIPP_P1YUVBR1 (0x994)
+#define DCMIPP_P1YUVBR2 (0x998)
+
+#define DCMIPP_P1PPCR (0x9C0)
+#define DCMIPP_P2PPCR (0xDC0)
+#define DCMIPP_PxPPCR(id) (((id) == 1) ? DCMIPP_P1PPCR :\
+			   DCMIPP_P2PPCR)
+#define DCMIPP_PxPPCR_FORMAT_SHIFT 0
+#define DCMIPP_PxPPCR_FORMAT_MASK GENMASK(3, 0)
+#define DCMIPP_PxPPCR_FORMAT_RGB888_OR_YUV444_1BUFFER 0x0
+#define DCMIPP_PxPPCR_FORMAT_RGB565 0x1
+#define DCMIPP_PxPPCR_FORMAT_ARGB8888 0x2
+#define DCMIPP_PxPPCR_FORMAT_RGBA8888 0x3
+#define DCMIPP_PxPPCR_FORMAT_Y8 0x4
+#define DCMIPP_PxPPCR_FORMAT_YUV444 0x5
+#define DCMIPP_PxPPCR_FORMAT_YUV422 0x6
+#define DCMIPP_P1PPCR_FORMAT_YUV422_2BUF 0x7
+#define DCMIPP_P1PPCR_FORMAT_NV21 0x8
+#define DCMIPP_P1PPCR_FORMAT_YV12 0x9
+
+#define DCMIPP_PxPPCR_SWAPRB BIT(4)
+
+#define IS_SINK(pad) (!(pad))
+#define IS_SRC(pad)  ((pad))
+#define PAD_STR(pad) (IS_SRC((pad))) ? "src" : "sink"
+
+#define PIXELPROC_MEDIA_BUS_SRC_FMT_DEFAULT MEDIA_BUS_FMT_RGB565_2X8_LE
+#define PIXELPROC_MEDIA_BUS_SINK_FMT_DEFAULT MEDIA_BUS_FMT_RGB888_1X24
+
+struct dcmipp_pixelproc_pix_map {
+	unsigned int code;
+	unsigned int ppcr_fmt;
+	unsigned int swap_uv;
+};
+
+#define PIXMAP_MBUS_PPCR_SWAPUV(mbus, pp_code, swap)	\
+		{						\
+			.code = MEDIA_BUS_FMT_##mbus,		\
+			.ppcr_fmt = pp_code,	\
+			.swap_uv = swap,	\
+		}
+static const struct dcmipp_pixelproc_pix_map dcmipp_pixelproc_sink_pix_map_list[] = {
+	PIXMAP_MBUS_PPCR_SWAPUV(RGB888_1X24, 0, 0),
+	PIXMAP_MBUS_PPCR_SWAPUV(YUV8_1X24, 0, 0),
+};
+
+static const struct dcmipp_pixelproc_pix_map dcmipp_pixelproc_src_pix_map_list[] = {
+	PIXMAP_MBUS_PPCR_SWAPUV(RGB888_1X24, DCMIPP_PxPPCR_FORMAT_RGB888_OR_YUV444_1BUFFER, 0),
+	PIXMAP_MBUS_PPCR_SWAPUV(RGB565_2X8_LE, DCMIPP_PxPPCR_FORMAT_RGB565, 0),
+	PIXMAP_MBUS_PPCR_SWAPUV(YUYV8_2X8, DCMIPP_PxPPCR_FORMAT_YUV422, 0),
+	PIXMAP_MBUS_PPCR_SWAPUV(YVYU8_2X8, DCMIPP_PxPPCR_FORMAT_YUV422, 1),
+	PIXMAP_MBUS_PPCR_SWAPUV(Y8_1X8, DCMIPP_PxPPCR_FORMAT_Y8, 0),
+};
+
+static const struct dcmipp_pixelproc_pix_map *
+dcmipp_pixelproc_pix_map_by_index(unsigned int i, unsigned int pad)
+{
+	const struct dcmipp_pixelproc_pix_map *l;
+	unsigned int size;
+
+	if (IS_SRC(pad)) {
+		l = dcmipp_pixelproc_src_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_pixelproc_src_pix_map_list);
+	} else {
+		l = dcmipp_pixelproc_sink_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_pixelproc_sink_pix_map_list);
+	}
+
+	if (i >= size)
+		return NULL;
+
+	return &l[i];
+}
+
+static const struct dcmipp_pixelproc_pix_map *
+dcmipp_pixelproc_pix_map_by_code(u32 code, unsigned int pad)
+{
+	const struct dcmipp_pixelproc_pix_map *l;
+	unsigned int size;
+	unsigned int i;
+
+	if (IS_SRC(pad)) {
+		l = dcmipp_pixelproc_src_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_pixelproc_src_pix_map_list);
+	} else {
+		l = dcmipp_pixelproc_sink_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_pixelproc_sink_pix_map_list);
+	}
+
+	for (i = 0; i < size; i++) {
+		if (l[i].code == code)
+			return &l[i];
+	}
+
+	return NULL;
+}
+
+struct dcmipp_pixelproc_device {
+	struct dcmipp_ent_device ved;
+	struct v4l2_subdev sd;
+	struct device *dev;
+	struct v4l2_mbus_framefmt sink_fmt;
+	struct v4l2_mbus_framefmt src_fmt;
+	bool streaming;
+	/* Protect this data structure */
+	struct mutex lock;
+
+	void __iomem *regs;
+	struct v4l2_ctrl_handler ctrls;
+
+	u32 pipe_id;
+
+	struct v4l2_fract sink_interval;
+	unsigned int frate;
+	u32 src_code;
+	struct v4l2_rect crop;
+	struct v4l2_rect compose;
+};
+
+static const struct v4l2_mbus_framefmt fmt_sink_default = {
+	.width = DCMIPP_FMT_WIDTH_DEFAULT,
+	.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	.code = PIXELPROC_MEDIA_BUS_SINK_FMT_DEFAULT,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_DEFAULT,
+};
+
+static const struct v4l2_mbus_framefmt fmt_src_default = {
+	.width = DCMIPP_FMT_WIDTH_DEFAULT,
+	.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	.code = PIXELPROC_MEDIA_BUS_SRC_FMT_DEFAULT,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_DEFAULT,
+};
+
+static const struct v4l2_rect crop_min = {
+	.width = DCMIPP_FRAME_MIN_WIDTH,
+	.height = DCMIPP_FRAME_MIN_HEIGHT,
+	.top = 0,
+	.left = 0,
+};
+
+#define DCMIPP_MAX_DOWNSIZE_RATIO 8
+
+/*
+ * Functions handling controls
+ */
+#define V4L2_CID_PIXELPROC_GAMMA_CORRECTION	(V4L2_CID_USER_BASE | 0x1001)
+
+static int dcmipp_pixelproc_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct dcmipp_pixelproc_device *pixelproc =
+		container_of(ctrl->handler,
+			     struct dcmipp_pixelproc_device, ctrls);
+	int ret = 0;
+
+	mutex_lock(&pixelproc->lock);
+
+	if (pixelproc->streaming) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	switch (ctrl->id) {
+	case V4L2_CID_PIXELPROC_GAMMA_CORRECTION:
+		reg_write(pixelproc, DCMIPP_PxGMCR(pixelproc->pipe_id),
+			  (ctrl->val ? DCMIPP_PxGMCR_ENABLE : 0));
+		break;
+	}
+
+out:
+	mutex_unlock(&pixelproc->lock);
+	return ret;
+};
+
+static const struct v4l2_ctrl_ops dcmipp_pixelproc_ctrl_ops = {
+	.s_ctrl = dcmipp_pixelproc_s_ctrl,
+};
+
+static const struct v4l2_ctrl_config dcmipp_pixelproc_ctrls[] = {
+	{
+		.ops		= &dcmipp_pixelproc_ctrl_ops,
+		.id		= V4L2_CID_PIXELPROC_GAMMA_CORRECTION,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.name		= "Gamma correction",
+		.min = 0,
+		.max = 1,
+		.step = 1,
+		.def = 0,
+	}
+};
+
+static struct v4l2_rect
+dcmipp_pixelproc_get_crop_bound(const struct v4l2_mbus_framefmt *fmt)
+{
+	/* Get the crop bounds to clamp the crop rectangle correctly */
+	struct v4l2_rect r = {
+		.left = 0,
+		.top = 0,
+		.width = fmt->width,
+		.height = fmt->height,
+	};
+	return r;
+}
+
+static void dcmipp_pixelproc_adjust_crop(struct v4l2_rect *r,
+					 const struct v4l2_mbus_framefmt *fmt)
+{
+	const struct v4l2_rect src_rect =
+		dcmipp_pixelproc_get_crop_bound(fmt);
+
+	/* Disallow rectangles smaller than the minimal one. */
+	v4l2_rect_set_min_size(r, &crop_min);
+	v4l2_rect_map_inside(r, &src_rect);
+}
+
+static void dcmipp_pixelproc_adjust_fmt(struct v4l2_mbus_framefmt *fmt, u32 pad)
+{
+	const struct dcmipp_pixelproc_pix_map *vpix;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_pixelproc_pix_map_by_code(fmt->code, pad);
+	if (!vpix)
+		fmt->code = IS_SRC(pad) ? fmt_src_default.code :
+					  fmt_sink_default.code;
+
+	fmt->width = clamp_t(u32, fmt->width, DCMIPP_FRAME_MIN_WIDTH,
+			     DCMIPP_FRAME_MAX_WIDTH) & ~1;
+	fmt->height = clamp_t(u32, fmt->height, DCMIPP_FRAME_MIN_HEIGHT,
+			      DCMIPP_FRAME_MAX_HEIGHT);
+
+	if (fmt->field == V4L2_FIELD_ANY || fmt->field == V4L2_FIELD_ALTERNATE)
+		fmt->field = IS_SRC(pad) ? fmt_src_default.field :
+					   fmt_sink_default.field;
+
+	dcmipp_colorimetry_clamp(fmt);
+}
+
+static int dcmipp_pixelproc_init_cfg(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *state)
+{
+	unsigned int i;
+
+	for (i = 0; i < sd->entity.num_pads; i++) {
+		struct v4l2_mbus_framefmt *mf;
+
+		mf = v4l2_subdev_get_try_format(sd, state, i);
+		*mf = IS_SRC(i) ? fmt_src_default : fmt_sink_default;
+	}
+
+	return 0;
+}
+
+static int dcmipp_pixelproc_enum_mbus_code(struct v4l2_subdev *sd,
+					   struct v4l2_subdev_state *state,
+					   struct v4l2_subdev_mbus_code_enum *code)
+{
+	const struct dcmipp_pixelproc_pix_map *vpix;
+
+	vpix = dcmipp_pixelproc_pix_map_by_index(code->index, code->pad);
+	if (!vpix)
+		return -EINVAL;
+
+	code->code = vpix->code;
+
+	return 0;
+}
+
+static int dcmipp_pixelproc_enum_frame_size(struct v4l2_subdev *sd,
+					    struct v4l2_subdev_state *state,
+					    struct v4l2_subdev_frame_size_enum *fse)
+{
+	const struct dcmipp_pixelproc_pix_map *vpix;
+
+	if (fse->index)
+		return -EINVAL;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_pixelproc_pix_map_by_code(fse->code, fse->pad);
+	if (!vpix)
+		return -EINVAL;
+
+	fse->min_width = DCMIPP_FRAME_MIN_WIDTH;
+	fse->max_width = DCMIPP_FRAME_MAX_WIDTH;
+	fse->min_height = DCMIPP_FRAME_MIN_HEIGHT;
+	fse->max_height = DCMIPP_FRAME_MAX_HEIGHT;
+
+	return 0;
+}
+
+static int dcmipp_pixelproc_get_fmt(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_state *state,
+				    struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+
+	mutex_lock(&pixelproc->lock);
+
+	if (IS_SINK(fmt->pad))
+		fmt->format = fmt->which == V4L2_SUBDEV_FORMAT_TRY ?
+			      *v4l2_subdev_get_try_format(sd, state, 0) :
+			      pixelproc->sink_fmt;
+	else
+		fmt->format = fmt->which == V4L2_SUBDEV_FORMAT_TRY ?
+			      *v4l2_subdev_get_try_format(sd, state, 0) :
+			      pixelproc->src_fmt;
+
+	mutex_unlock(&pixelproc->lock);
+
+	return 0;
+}
+
+#define dcmipp_pixelproc_is_yuv_fmt(a) ({				      \
+	typeof(a) __a = (a);						      \
+	((__a) >= MEDIA_BUS_FMT_Y8_1X8 && (__a) < MEDIA_BUS_FMT_SBGGR8_1X8) ? \
+	 true : false; })
+static int dcmipp_pixelproc_set_fmt(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_state *state,
+				    struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *pad_fmt;
+	int ret = 0;
+
+	mutex_lock(&pixelproc->lock);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		if (pixelproc->streaming) {
+			ret = -EBUSY;
+			goto out;
+		}
+
+		if (IS_SINK(fmt->pad))
+			pad_fmt = &pixelproc->sink_fmt;
+		else
+			pad_fmt = &pixelproc->src_fmt;
+
+	} else {
+		pad_fmt = v4l2_subdev_get_try_format(sd, state, 0);
+	}
+
+	dcmipp_pixelproc_adjust_fmt(&fmt->format, fmt->pad);
+
+	dev_dbg(pixelproc->dev, "%s: %s format update: old:%dx%d (0x%x, %d, %d, %d, %d) new:%dx%d (0x%x, %d, %d, %d, %d)\n",
+		pixelproc->sd.name,
+		PAD_STR(fmt->pad),
+		/* old */
+		pad_fmt->width, pad_fmt->height, pad_fmt->code,
+		pad_fmt->colorspace, pad_fmt->quantization,
+		pad_fmt->xfer_func, pad_fmt->ycbcr_enc,
+		/* new */
+		fmt->format.width, fmt->format.height, fmt->format.code,
+		fmt->format.colorspace, fmt->format.quantization,
+		fmt->format.xfer_func, fmt->format.ycbcr_enc);
+
+	*pad_fmt = fmt->format;
+
+	/* Update sink pad crop - compose */
+	if (IS_SINK(fmt->pad) && fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		/* Update sink pad crop */
+		pixelproc->crop.top = 0;
+		pixelproc->crop.left = 0;
+		pixelproc->crop.width = fmt->format.width;
+		pixelproc->crop.height = fmt->format.height;
+
+		pixelproc->compose.top = 0;
+		pixelproc->compose.left = 0;
+		pixelproc->compose.width = fmt->format.width;
+		pixelproc->compose.height = fmt->format.height;
+
+		/* Update src pad format & size */
+		pixelproc->src_fmt = fmt_src_default;
+		pixelproc->src_fmt.code =
+			dcmipp_pixelproc_is_yuv_fmt(fmt->format.code) ?
+				MEDIA_BUS_FMT_YUYV8_2X8 :
+				MEDIA_BUS_FMT_RGB565_2X8_LE;
+		pixelproc->src_fmt.width = fmt->format.width;
+		pixelproc->src_fmt.height = fmt->format.height;
+	}
+
+out:
+	mutex_unlock(&pixelproc->lock);
+
+	return ret;
+}
+
+static int dcmipp_pixelproc_get_selection(struct v4l2_subdev *sd,
+					  struct v4l2_subdev_state *state,
+					  struct v4l2_subdev_selection *s)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *sink_fmt;
+	struct v4l2_rect *crop, *compose;
+
+	if (IS_SRC(s->pad))
+		return -EINVAL;
+
+	if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		sink_fmt = &pixelproc->sink_fmt;
+		crop = &pixelproc->crop;
+		compose = &pixelproc->compose;
+	} else {
+		sink_fmt = v4l2_subdev_get_try_format(sd, state, s->pad);
+		crop = v4l2_subdev_get_try_crop(sd, state, s->pad);
+		compose = v4l2_subdev_get_try_compose(sd, state, s->pad);
+	}
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		s->r = *crop;
+		break;
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		s->r = dcmipp_pixelproc_get_crop_bound(sink_fmt);
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		s->r = *compose;
+		break;
+	/* TODO - not sure how to define BOUND here */
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dcmipp_pixelproc_set_selection(struct v4l2_subdev *sd,
+					  struct v4l2_subdev_state *state,
+					  struct v4l2_subdev_selection *s)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *sink_fmt;
+	struct v4l2_rect *crop, *compose;
+
+	if (IS_SRC(s->pad))
+		return -EINVAL;
+
+	if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		sink_fmt = &pixelproc->sink_fmt;
+		crop = &pixelproc->crop;
+		compose = &pixelproc->compose;
+	} else {
+		sink_fmt = v4l2_subdev_get_try_format(sd, state, s->pad);
+		crop = v4l2_subdev_get_try_crop(sd, state, s->pad);
+		compose = v4l2_subdev_get_try_compose(sd, state, s->pad);
+	}
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		dcmipp_pixelproc_adjust_crop(&s->r, sink_fmt);
+
+		*crop = s->r;
+
+		/* Setting the crop also set the compose identically */
+		*compose = *crop;
+
+		/*
+		 * In case of setting the crop with ACTIVE set, we need to
+		 * update the source pad size
+		 */
+		if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+			pixelproc->src_fmt.width = s->r.width;
+			pixelproc->src_fmt.height = s->r.height;
+		}
+		/* TODO - when not in format active, we should also update the
+		 * try src pad format
+		 */
+
+		dev_dbg(pixelproc->dev, "s_selection: crop %ux%u@(%u,%u)\n",
+			crop->width, crop->height, crop->left, crop->top);
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		if (s->r.width > crop->width)
+			s->r.width = crop->width;
+		else if (s->r.width < (crop->width / DCMIPP_MAX_DOWNSIZE_RATIO))
+			s->r.width = crop->width / DCMIPP_MAX_DOWNSIZE_RATIO;
+
+		if (s->r.height > crop->height)
+			s->r.height = crop->height;
+		else if (s->r.height < (crop->height / DCMIPP_MAX_DOWNSIZE_RATIO))
+			s->r.height = crop->width / DCMIPP_MAX_DOWNSIZE_RATIO;
+		s->r.top = 0;
+		s->r.left = 0;
+
+		*compose = s->r;
+
+		/*
+		 * In case of setting the compose with ACTIVE set, we need to
+		 * update the source pad size
+		 */
+		if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+			pixelproc->src_fmt.width = s->r.width;
+			pixelproc->src_fmt.height = s->r.height;
+		}
+		/* TODO - when not in format active, we should also update the
+		 * try src pad format
+		 */
+
+		dev_dbg(pixelproc->dev, "s_selection: compose %ux%u@(%u,%u)\n",
+			s->r.width, s->r.height, s->r.left, s->r.top);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops dcmipp_pixelproc_pad_ops = {
+	.init_cfg		= dcmipp_pixelproc_init_cfg,
+	.enum_mbus_code		= dcmipp_pixelproc_enum_mbus_code,
+	.enum_frame_size	= dcmipp_pixelproc_enum_frame_size,
+	.get_fmt		= dcmipp_pixelproc_get_fmt,
+	.set_fmt		= dcmipp_pixelproc_set_fmt,
+	.get_selection		= dcmipp_pixelproc_get_selection,
+	.set_selection		= dcmipp_pixelproc_set_selection,
+};
+
+static int
+dcmipp_pixelproc_colorconv_config(struct dcmipp_pixelproc_device *pixelproc)
+{
+	struct dcmipp_colorconv_config ccconf = { 0 };
+	int i, ret = 0;
+	unsigned int val = 0;
+
+	ret = dcmipp_colorconv_configure(pixelproc->dev, &pixelproc->sink_fmt,
+					 &pixelproc->src_fmt, &ccconf);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < 6; i++)
+		reg_write(pixelproc, DCMIPP_P1YUVRR1 + (4 * i),
+			  ccconf.conv_matrix[i]);
+
+	if (ccconf.clamping)
+		val |= DCMIPP_P1YUVCR_CLAMP;
+	if (!dcmipp_pixelproc_is_yuv_fmt(pixelproc->src_fmt.code))
+		val |= DCMIPP_P1YUVCR_TYPE_RGB;
+	if (ccconf.enable)
+		val |= DCMIPP_P1YUVCR_ENABLE;
+
+	reg_write(pixelproc, DCMIPP_P1YUVCR, val);
+
+	return 0;
+}
+
+#define DCMIPP_PIXELPROC_HVRATIO_CONS	8192
+#define DCMIPP_PIXELPROC_HVRATIO_MAX	65535
+#define DCMIPP_PIXELPROC_HVDIV_CONS	1024
+#define DCMIPP_PIXELPROC_HVDIV_MAX	1023
+static void
+dcmipp_pixelproc_set_downsize(struct dcmipp_pixelproc_device *pixelproc)
+{
+	unsigned int hratio, vratio, hdiv, vdiv;
+
+	hratio = (pixelproc->crop.width - 1) * DCMIPP_PIXELPROC_HVRATIO_CONS /
+		 (pixelproc->compose.width - 1);
+	if (hratio > DCMIPP_PIXELPROC_HVRATIO_MAX)
+		hratio = DCMIPP_PIXELPROC_HVRATIO_MAX;
+	vratio = (pixelproc->crop.height - 1) * DCMIPP_PIXELPROC_HVRATIO_CONS /
+		 (pixelproc->compose.height - 1);
+	if (vratio > DCMIPP_PIXELPROC_HVRATIO_MAX)
+		vratio = DCMIPP_PIXELPROC_HVRATIO_MAX;
+	hdiv = (DCMIPP_PIXELPROC_HVDIV_CONS * pixelproc->compose.width) /
+		pixelproc->crop.width;
+	if (hdiv > DCMIPP_PIXELPROC_HVDIV_MAX)
+		hdiv = DCMIPP_PIXELPROC_HVDIV_MAX;
+	vdiv = (DCMIPP_PIXELPROC_HVDIV_CONS * pixelproc->compose.height) /
+		pixelproc->crop.height;
+	if (vdiv > DCMIPP_PIXELPROC_HVDIV_MAX)
+		vdiv = DCMIPP_PIXELPROC_HVDIV_MAX;
+
+	dev_dbg(pixelproc->dev, "%s: downsize config: hratio: 0x%x, vratio: 0x%x, hdiv: 0x%x, vdiv: 0x%x\n",
+		pixelproc->sd.name,
+		hratio, vratio,
+		hdiv, vdiv);
+
+	reg_clear(pixelproc, DCMIPP_PxDSCR(pixelproc->pipe_id),
+		  DCMIPP_PxDSCR_ENABLE);
+	reg_write(pixelproc, DCMIPP_PxDSRTIOR(pixelproc->pipe_id),
+		  (hratio << DCMIPP_PxDSRTIOR_HRATIO_SHIFT) |
+		  (vratio << DCMIPP_PxDSRTIOR_VRATIO_SHIFT));
+	reg_write(pixelproc, DCMIPP_PxDSSZR(pixelproc->pipe_id),
+		  (pixelproc->compose.width << DCMIPP_PxDSSZR_HSIZE_SHIFT) |
+		  (pixelproc->compose.height << DCMIPP_PxDSSZR_VSIZE_SHIFT));
+	reg_write(pixelproc, DCMIPP_PxDSCR(pixelproc->pipe_id),
+		  (hdiv << DCMIPP_PxDSCR_HDIV_SHIFT) |
+		  (vdiv << DCMIPP_PxDSCR_VDIV_SHIFT) |
+		  DCMIPP_PxDSCR_ENABLE);
+}
+
+static int dcmipp_pixelproc_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+	const struct dcmipp_pixelproc_pix_map *vpix;
+	int ret = 0;
+	unsigned int val;
+
+	mutex_lock(&pixelproc->lock);
+	if (enable) {
+		/* TODO - need to add framerate control */
+
+		/* Configure cropping */
+		reg_write(pixelproc, DCMIPP_PxCRSTR(pixelproc->pipe_id),
+			  (pixelproc->crop.top << DCMIPP_PxCRSTR_VSTART_SHIFT) |
+			  (pixelproc->crop.left << DCMIPP_PxCRSTR_HSTART_SHIFT));
+		reg_write(pixelproc, DCMIPP_PxCRSZR(pixelproc->pipe_id),
+			  (pixelproc->crop.width << DCMIPP_PxCRSZR_HSIZE_SHIFT) |
+			  (pixelproc->crop.height << DCMIPP_PxCRSZR_VSIZE_SHIFT) |
+			  DCMIPP_PxCRSZR_ENABLE);
+
+		/* Configure downsize */
+		dcmipp_pixelproc_set_downsize(pixelproc);
+
+		/* Configure YUV Conversion (if applicable) */
+		if (pixelproc->pipe_id == 1) {
+			ret = dcmipp_pixelproc_colorconv_config(pixelproc);
+			if (ret)
+				goto out;
+		}
+
+		/* Setup the PixelPacker based on the src pad format */
+		vpix = dcmipp_pixelproc_pix_map_by_code(pixelproc->src_fmt.code, 1);
+		if (!vpix) {
+			ret = -EINVAL;
+			goto out;
+		}
+
+		val = vpix->ppcr_fmt;
+		if (vpix->swap_uv)
+			val |= DCMIPP_PxPPCR_SWAPRB;
+
+		reg_write(pixelproc, DCMIPP_PxPPCR(pixelproc->pipe_id), val);
+	}
+
+out:
+	mutex_unlock(&pixelproc->lock);
+
+	return ret;
+}
+
+static const struct v4l2_subdev_video_ops dcmipp_pixelproc_video_ops = {
+	.s_stream = dcmipp_pixelproc_s_stream,
+};
+
+static const struct v4l2_subdev_ops dcmipp_pixelproc_ops = {
+	.pad = &dcmipp_pixelproc_pad_ops,
+	.video = &dcmipp_pixelproc_video_ops,
+};
+
+/* FIXME */
+static void dcmipp_pixelproc_release(struct v4l2_subdev *sd)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+
+	kfree(pixelproc);
+}
+
+static const struct v4l2_subdev_internal_ops dcmipp_pixelproc_int_ops = {
+	.release = dcmipp_pixelproc_release,
+};
+
+static void
+dcmipp_pixelproc_comp_unbind(struct device *comp, struct device *master,
+			     void *master_data)
+{
+	struct dcmipp_ent_device *ved = dev_get_drvdata(comp);
+	struct dcmipp_pixelproc_device *pixelproc =
+			container_of(ved, struct dcmipp_pixelproc_device, ved);
+
+	dcmipp_ent_sd_unregister(ved, &pixelproc->sd);
+}
+
+static int dcmipp_name_to_pipe_id(const char *name)
+{
+	if (strstr(name, "main"))
+		return 1;
+	else if (strstr(name, "aux"))
+		return 2;
+	else
+		return -EINVAL;
+}
+
+static int
+dcmipp_pixelproc_comp_bind(struct device *comp, struct device *master,
+			   void *master_data)
+{
+	struct dcmipp_bind_data *bind_data = master_data;
+	struct dcmipp_platform_data *pdata = comp->platform_data;
+	struct dcmipp_pixelproc_device *pixelproc;
+	int ret, i;
+
+	/* Allocate the pixelproc struct */
+	pixelproc = kzalloc(sizeof(*pixelproc), GFP_KERNEL);
+	if (!pixelproc)
+		return -ENOMEM;
+
+	pixelproc->regs = bind_data->regs;
+
+	/* Initialize ved and sd */
+	ret = dcmipp_ent_sd_register(&pixelproc->ved, &pixelproc->sd,
+				     bind_data->v4l2_dev,
+				     pdata->entity_name,
+				     MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER, 2,
+				     (const unsigned long[2]) {
+				     MEDIA_PAD_FL_SINK,
+				     MEDIA_PAD_FL_SOURCE,
+				     },
+				     &dcmipp_pixelproc_int_ops, &dcmipp_pixelproc_ops,
+				     NULL, NULL);
+	if (ret) {
+		kfree(pixelproc);
+		return ret;
+	}
+
+	dev_set_drvdata(comp, &pixelproc->ved);
+	pixelproc->dev = comp;
+
+	/* Pipe identifier */
+	pixelproc->pipe_id = dcmipp_name_to_pipe_id(pdata->entity_name);
+	if (pixelproc->pipe_id != 1 && pixelproc->pipe_id != 2) {
+		dev_err(comp, "failed to retrieve pipe_id\n");
+		/* TODO - fix error handling */
+		return -1;
+	}
+
+	/* Initialize the frame format */
+	pixelproc->sink_fmt = fmt_sink_default;
+	pixelproc->src_fmt = fmt_src_default;
+	pixelproc->crop.top = 0;
+	pixelproc->crop.left = 0;
+	pixelproc->crop.width = DCMIPP_FMT_WIDTH_DEFAULT;
+	pixelproc->crop.height = DCMIPP_FMT_HEIGHT_DEFAULT;
+	pixelproc->compose.top = 0;
+	pixelproc->compose.left = 0;
+	pixelproc->compose.width = DCMIPP_FMT_WIDTH_DEFAULT;
+	pixelproc->compose.height = DCMIPP_FMT_HEIGHT_DEFAULT;
+
+	/* Initialize controls */
+	v4l2_ctrl_handler_init(&pixelproc->ctrls,
+			       ARRAY_SIZE(dcmipp_pixelproc_ctrls));
+
+	for (i = 0; i < ARRAY_SIZE(dcmipp_pixelproc_ctrls); i++)
+		v4l2_ctrl_new_custom(&pixelproc->ctrls,
+				     &dcmipp_pixelproc_ctrls[i], NULL);
+
+	pixelproc->sd.ctrl_handler = &pixelproc->ctrls;
+	if (pixelproc->ctrls.error) {
+		dev_err(pixelproc->dev, "control initialization error %d\n",
+			pixelproc->ctrls.error);
+		/* TODO - error handling */
+	}
+
+	ret = v4l2_ctrl_handler_setup(&pixelproc->ctrls);
+	if (ret < 0) {
+		dev_err(pixelproc->dev, "Failed to set up control handlers\n");
+		/* TODO - error handling */
+	}
+
+	return 0;
+}
+
+static const struct component_ops dcmipp_pixelproc_comp_ops = {
+	.bind = dcmipp_pixelproc_comp_bind,
+	.unbind = dcmipp_pixelproc_comp_unbind,
+};
+
+static int dcmipp_pixelproc_probe(struct platform_device *pdev)
+{
+	return component_add(&pdev->dev, &dcmipp_pixelproc_comp_ops);
+}
+
+static int dcmipp_pixelproc_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &dcmipp_pixelproc_comp_ops);
+
+	return 0;
+}
+
+static const struct platform_device_id dcmipp_pixelproc_driver_ids[] = {
+	{
+		.name           = DCMIPP_PIXELPROC_DRV_NAME,
+	},
+	{ }
+};
+
+static struct platform_driver dcmipp_pixelproc_pdrv = {
+	.probe		= dcmipp_pixelproc_probe,
+	.remove		= dcmipp_pixelproc_remove,
+	.id_table	= dcmipp_pixelproc_driver_ids,
+	.driver		= {
+		.name	= DCMIPP_PIXELPROC_DRV_NAME,
+	},
+};
+
+module_platform_driver(dcmipp_pixelproc_pdrv);
+
+MODULE_DEVICE_TABLE(platform, dcmipp_pixelproc_driver_ids);
+
+MODULE_AUTHOR("Hugues Fruchet <hugues.fruchet@foss.st.com>");
+MODULE_AUTHOR("Alain Volmat <alain.volmat@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 Digital Camera Memory Interface with Pixel Processor driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/v4l2-core/v4l2-fwnode.c b/drivers/media/v4l2-core/v4l2-fwnode.c
index 843259c30..1259d094a 100644
--- a/drivers/media/v4l2-core/v4l2-fwnode.c
+++ b/drivers/media/v4l2-core/v4l2-fwnode.c
@@ -345,6 +345,9 @@ v4l2_fwnode_endpoint_parse_parallel_bus(struct fwnode_handle *fwnode,
 		pr_debug("data-enable-active %s\n", v ? "high" : "low");
 	}
 
+	if (!fwnode_property_read_u32(fwnode, "pclk-max-frequency", &v))
+		bus->pclk_max_frequency = v;
+
 	switch (bus_type) {
 	default:
 		bus->flags = flags;
diff --git a/drivers/memory/Kconfig b/drivers/memory/Kconfig
index 72c0df129..402f7efa5 100644
--- a/drivers/memory/Kconfig
+++ b/drivers/memory/Kconfig
@@ -217,7 +217,7 @@ config RENESAS_RPCIF
 
 config STM32_FMC2_EBI
 	tristate "Support for FMC2 External Bus Interface on STM32MP SoCs"
-	depends on MACH_STM32MP157 || COMPILE_TEST
+	depends on ARCH_STM32 || COMPILE_TEST
 	select MFD_SYSCON
 	help
 	  Select this option to enable the STM32 FMC2 External Bus Interface
@@ -225,6 +225,14 @@ config STM32_FMC2_EBI
 	  devices (like SRAM, ethernet adapters, FPGAs, LCD displays, ...) on
 	  SOCs containing the FMC2 External Bus Interface.
 
+config STM32_OMI
+	tristate "Support for OSPI Memory Interface on STM32MP SoCs"
+	depends on ARCH_STM32 || COMPILE_TEST
+	help
+	  Select this option to enable the STM32 OSPI Memory Interface controller
+	  (OMI) which provides either SPI or HyperBus support. This allows to support
+	  sNOR, sNAND or HyperFlash devices.
+
 source "drivers/memory/samsung/Kconfig"
 source "drivers/memory/tegra/Kconfig"
 
diff --git a/drivers/memory/Makefile b/drivers/memory/Makefile
index bc7663ed1..33451d6c1 100644
--- a/drivers/memory/Makefile
+++ b/drivers/memory/Makefile
@@ -24,6 +24,7 @@ obj-$(CONFIG_DA8XX_DDRCTL)	+= da8xx-ddrctl.o
 obj-$(CONFIG_PL353_SMC)		+= pl353-smc.o
 obj-$(CONFIG_RENESAS_RPCIF)	+= renesas-rpc-if.o
 obj-$(CONFIG_STM32_FMC2_EBI)	+= stm32-fmc2-ebi.o
+obj-$(CONFIG_STM32_OMI)		+= stm32-omi.o
 
 obj-$(CONFIG_SAMSUNG_MC)	+= samsung/
 obj-$(CONFIG_TEGRA_MC)		+= tegra/
diff --git a/drivers/memory/stm32-fmc2-ebi.c b/drivers/memory/stm32-fmc2-ebi.c
index ffec26a99..3aaf1502c 100644
--- a/drivers/memory/stm32-fmc2-ebi.c
+++ b/drivers/memory/stm32-fmc2-ebi.c
@@ -18,8 +18,16 @@
 #define FMC2_BCR(x)			((x) * 0x8 + FMC2_BCR1)
 #define FMC2_BTR(x)			((x) * 0x8 + FMC2_BTR1)
 #define FMC2_PCSCNTR			0x20
+#define FMC2_CFGR			0x20
+#define FMC2_SR				0x84
 #define FMC2_BWTR1			0x104
 #define FMC2_BWTR(x)			((x) * 0x8 + FMC2_BWTR1)
+#define FMC2_SECCFGR			0x300
+#define FMC2_CIDCFGR0			0x30c
+#define FMC2_CIDCFGR(x)			((x) * 0x8 + FMC2_CIDCFGR0)
+#define FMC2_SEMCR0			0x310
+#define FMC2_SEMCR(x)			((x) * 0x8 + FMC2_SEMCR0)
+#define FMC2_VERR			0x3f4
 
 /* Register: FMC2_BCR1 */
 #define FMC2_BCR1_CCLKEN		BIT(20)
@@ -40,6 +48,7 @@
 #define FMC2_BCR_ASYNCWAIT		BIT(15)
 #define FMC2_BCR_CPSIZE			GENMASK(18, 16)
 #define FMC2_BCR_CBURSTRW		BIT(19)
+#define FMC2_BCR_CSCOUNT		GENMASK(21, 20)
 #define FMC2_BCR_NBLSET			GENMASK(23, 22)
 
 /* Register: FMC2_BTRx/FMC2_BWTRx */
@@ -56,8 +65,32 @@
 #define FMC2_PCSCNTR_CSCOUNT		GENMASK(15, 0)
 #define FMC2_PCSCNTR_CNTBEN(x)		BIT((x) + 16)
 
+/* Register: FMC2_CFGR */
+#define FMC2_CFGR_CLKDIV		GENMASK(19, 16)
+#define FMC2_CFGR_CCLKEN		BIT(20)
+#define FMC2_CFGR_FMC2EN		BIT(31)
+
+/* Register: FMC2_SR */
+#define FMC2_SR_ISOST			GENMASK(1, 0)
+
+/* Register: FMC2_CIDCFGR */
+#define FMC2_CIDCFGR_CFEN		BIT(0)
+#define FMC2_CIDCFGR_SEMEN		BIT(1)
+#define FMC2_CIDCFGR_SCID		GENMASK(6, 4)
+#define FMC2_CIDCFGR_SEMWLC1		BIT(17)
+
+/* Register: FMC2_SEMCR */
+#define FMC2_SEMCR_SEM_MUTEX		BIT(0)
+#define FMC2_SEMCR_SEMCID		GENMASK(7, 5)
+
+/* Register: FMC2_VERR */
+#define FMC2_VERR_MAJREV		GENMASK(7, 4)
+#define FMC2_VERR_MAJREV_2		2
+
 #define FMC2_MAX_EBI_CE			4
 #define FMC2_MAX_BANKS			5
+#define FMC2_MAX_RESOURCES		6
+#define FMC2_CID1			1
 
 #define FMC2_BCR_CPSIZE_0		0x0
 #define FMC2_BCR_CPSIZE_128		0x1
@@ -72,6 +105,11 @@
 #define FMC2_BCR_MTYP_PSRAM		0x1
 #define FMC2_BCR_MTYP_NOR		0x2
 
+#define FMC2_BCR_CSCOUNT_0		0x0
+#define FMC2_BCR_CSCOUNT_1		0x1
+#define FMC2_BCR_CSCOUNT_64		0x2
+#define FMC2_BCR_CSCOUNT_256		0x3
+
 #define FMC2_BXTR_EXTMOD_A		0x0
 #define FMC2_BXTR_EXTMOD_B		0x1
 #define FMC2_BXTR_EXTMOD_C		0x2
@@ -83,7 +121,7 @@
 #define FMC2_BXTR_DATAST_MAX		0xff
 #define FMC2_BXTR_BUSTURN_MAX		0xf
 #define FMC2_BXTR_DATAHLD_MAX		0x3
-#define FMC2_BTR_CLKDIV_MAX		0xf
+#define FMC2_REG_CLKDIV_MAX		0xf
 #define FMC2_BTR_DATLAT_MAX		0xf
 #define FMC2_PCSCNTR_CSCOUNT_MAX	0xff
 
@@ -99,7 +137,8 @@ enum stm32_fmc2_ebi_register_type {
 	FMC2_REG_BCR = 1,
 	FMC2_REG_BTR,
 	FMC2_REG_BWTR,
-	FMC2_REG_PCSCNTR
+	FMC2_REG_PCSCNTR,
+	FMC2_REG_CFGR,
 };
 
 enum stm32_fmc2_ebi_transaction_type {
@@ -130,16 +169,32 @@ enum stm32_fmc2_ebi_cpsize {
 	FMC2_CPSIZE_1024 = 1024
 };
 
+enum stm32_fmc2_ebi_cscount {
+	FMC2_CSCOUNT_0 = 0,
+	FMC2_CSCOUNT_1 = 1,
+	FMC2_CSCOUNT_64 = 64,
+	FMC2_CSCOUNT_256 = 256
+};
+
+struct stm32_fmc2_ebi_data {
+	bool rnb_for_nand;
+};
+
 struct stm32_fmc2_ebi {
 	struct device *dev;
 	struct clk *clk;
 	struct regmap *regmap;
+	const struct stm32_fmc2_ebi_data *data;
 	u8 bank_assigned;
+	u8 sem_taken;
+	u8 majrev;
+	bool access_granted;
 
 	u32 bcr[FMC2_MAX_EBI_CE];
 	u32 btr[FMC2_MAX_EBI_CE];
 	u32 bwtr[FMC2_MAX_EBI_CE];
 	u32 pcscntr;
+	u32 cfgr;
 };
 
 /*
@@ -267,15 +322,29 @@ static int stm32_fmc2_ebi_check_clk_period(struct stm32_fmc2_ebi *ebi,
 					   const struct stm32_fmc2_prop *prop,
 					   int cs)
 {
-	u32 bcr, bcr1;
+	u32 bcr, cfgr;
 
 	regmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);
-	if (cs)
-		regmap_read(ebi->regmap, FMC2_BCR1, &bcr1);
-	else
-		bcr1 = bcr;
 
-	if (bcr & FMC2_BCR_BURSTEN && (!cs || !(bcr1 & FMC2_BCR1_CCLKEN)))
+	if (ebi->majrev < FMC2_VERR_MAJREV_2) {
+		u32 bcr1;
+
+		if (cs)
+			regmap_read(ebi->regmap, FMC2_BCR1, &bcr1);
+		else
+			bcr1 = bcr;
+
+		if (bcr & FMC2_BCR_BURSTEN &&
+		    (!cs || !(bcr1 & FMC2_BCR1_CCLKEN)))
+			return 0;
+
+		return -EINVAL;
+	}
+
+	regmap_read(ebi->regmap, FMC2_CFGR, &cfgr);
+
+	if (bcr & FMC2_BCR_BURSTEN &&
+	    (!cs || !(cfgr & FMC2_CFGR_CCLKEN)))
 		return 0;
 
 	return -EINVAL;
@@ -304,15 +373,29 @@ static u32 stm32_fmc2_ebi_ns_to_clk_period(struct stm32_fmc2_ebi *ebi,
 					   int cs, u32 setup)
 {
 	u32 nb_clk_cycles = stm32_fmc2_ebi_ns_to_clock_cycles(ebi, cs, setup);
-	u32 bcr, btr, clk_period;
+	u32 btr, clk_period;
 
-	regmap_read(ebi->regmap, FMC2_BCR1, &bcr);
-	if (bcr & FMC2_BCR1_CCLKEN || !cs)
-		regmap_read(ebi->regmap, FMC2_BTR1, &btr);
-	else
-		regmap_read(ebi->regmap, FMC2_BTR(cs), &btr);
+	if (ebi->majrev < FMC2_VERR_MAJREV_2) {
+		u32 bcr;
+
+		regmap_read(ebi->regmap, FMC2_BCR1, &bcr);
+		if (bcr & FMC2_BCR1_CCLKEN || !cs)
+			regmap_read(ebi->regmap, FMC2_BTR1, &btr);
+		else
+			regmap_read(ebi->regmap, FMC2_BTR(cs), &btr);
 
-	clk_period = FIELD_GET(FMC2_BTR_CLKDIV, btr) + 1;
+		clk_period = FIELD_GET(FMC2_BTR_CLKDIV, btr) + 1;
+	} else {
+		u32 cfgr;
+
+		regmap_read(ebi->regmap, FMC2_CFGR, &cfgr);
+		if (cfgr & FMC2_CFGR_CCLKEN) {
+			clk_period = FIELD_GET(FMC2_CFGR_CLKDIV, cfgr) + 1;
+		} else {
+			regmap_read(ebi->regmap, FMC2_BTR(cs), &btr);
+			clk_period = FIELD_GET(FMC2_BTR_CLKDIV, btr) + 1;
+		}
+	}
 
 	return DIV_ROUND_UP(nb_clk_cycles, clk_period);
 }
@@ -332,6 +415,9 @@ static int stm32_fmc2_ebi_get_reg(int reg_type, int cs, u32 *reg)
 	case FMC2_REG_PCSCNTR:
 		*reg = FMC2_PCSCNTR;
 		break;
+	case FMC2_REG_CFGR:
+		*reg = FMC2_CFGR;
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -665,10 +751,31 @@ static int stm32_fmc2_ebi_set_clk_period(struct stm32_fmc2_ebi *ebi,
 					 int cs, u32 setup)
 {
 	u32 val;
+	u32 reg = FMC2_BTR(cs);
+	u32 mask = FMC2_BTR_CLKDIV;
+
+	if (!ebi->access_granted) {
+		dev_err(ebi->dev, "CFGR access forbidden\n");
+		return -EACCES;
+	}
+
+	if (ebi->majrev >= FMC2_VERR_MAJREV_2) {
+		u32 cfgr;
+
+		regmap_read(ebi->regmap, FMC2_CFGR, &cfgr);
+
+		if (cfgr & FMC2_CFGR_CCLKEN) {
+			reg = FMC2_CFGR;
+			mask = FMC2_CFGR_CLKDIV;
+		}
+	}
 
-	val = setup ? clamp_val(setup - 1, 1, FMC2_BTR_CLKDIV_MAX) : 1;
-	val = FIELD_PREP(FMC2_BTR_CLKDIV, val);
-	regmap_update_bits(ebi->regmap, FMC2_BTR(cs), FMC2_BTR_CLKDIV, val);
+	val = setup ? clamp_val(setup - 1, 1, FMC2_REG_CLKDIV_MAX) : 1;
+	if (reg == FMC2_CFGR)
+		val = FIELD_PREP(FMC2_CFGR_CLKDIV, val);
+	else
+		val = FIELD_PREP(FMC2_BTR_CLKDIV, val);
+	regmap_update_bits(ebi->regmap, reg, mask, val);
 
 	return 0;
 }
@@ -690,27 +797,63 @@ static int stm32_fmc2_ebi_set_max_low_pulse(struct stm32_fmc2_ebi *ebi,
 					    const struct stm32_fmc2_prop *prop,
 					    int cs, u32 setup)
 {
-	u32 old_val, new_val, pcscntr;
+	u32 val;
+	u32 reg = ebi->majrev < FMC2_VERR_MAJREV_2 ? FMC2_PCSCNTR :
+						     FMC2_BCR(cs);
+	u32 mask = ebi->majrev < FMC2_VERR_MAJREV_2 ? FMC2_PCSCNTR_CSCOUNT :
+						      FMC2_BCR_CSCOUNT;
 
-	if (setup < 1)
-		return 0;
+	if (ebi->majrev < FMC2_VERR_MAJREV_2) {
+		u32 old_val, pcscntr;
 
-	regmap_read(ebi->regmap, FMC2_PCSCNTR, &pcscntr);
+		if (setup < 1)
+			return 0;
 
-	/* Enable counter for the bank */
-	regmap_update_bits(ebi->regmap, FMC2_PCSCNTR,
-			   FMC2_PCSCNTR_CNTBEN(cs),
-			   FMC2_PCSCNTR_CNTBEN(cs));
+		regmap_read(ebi->regmap, reg, &pcscntr);
 
-	new_val = min_t(u32, setup - 1, FMC2_PCSCNTR_CSCOUNT_MAX);
-	old_val = FIELD_GET(FMC2_PCSCNTR_CSCOUNT, pcscntr);
-	if (old_val && new_val > old_val)
-		/* Keep current counter value */
-		return 0;
+		/* Enable counter for the bank */
+		regmap_update_bits(ebi->regmap, reg,
+				   FMC2_PCSCNTR_CNTBEN(cs),
+				   FMC2_PCSCNTR_CNTBEN(cs));
+
+		val = min_t(u32, setup - 1, FMC2_PCSCNTR_CSCOUNT_MAX);
+		old_val = FIELD_GET(FMC2_PCSCNTR_CSCOUNT, pcscntr);
+		if (old_val && val > old_val)
+			/* Keep current counter value */
+			return 0;
+
+		val = FIELD_PREP(FMC2_PCSCNTR_CSCOUNT, val);
+	} else {
+		if (setup == FMC2_CSCOUNT_0)
+			val = FIELD_PREP(FMC2_BCR_CSCOUNT, FMC2_BCR_CSCOUNT_0);
+		else if (setup == FMC2_CSCOUNT_1)
+			val = FIELD_PREP(FMC2_BCR_CSCOUNT, FMC2_BCR_CSCOUNT_1);
+		else if (setup <= FMC2_CSCOUNT_64)
+			val = FIELD_PREP(FMC2_BCR_CSCOUNT, FMC2_BCR_CSCOUNT_64);
+		else
+			val = FIELD_PREP(FMC2_BCR_CSCOUNT,
+					 FMC2_BCR_CSCOUNT_256);
+	}
+
+	regmap_update_bits(ebi->regmap, reg, mask, val);
+
+	return 0;
+}
+
+static int stm32_fmc2_ebi_set_cclk(struct stm32_fmc2_ebi *ebi,
+				   const struct stm32_fmc2_prop *prop,
+				   int cs, u32 setup)
+{
+	u32 reg = ebi->majrev < FMC2_VERR_MAJREV_2 ? FMC2_BCR1 : FMC2_CFGR;
+	u32 mask = ebi->majrev < FMC2_VERR_MAJREV_2 ? FMC2_BCR1_CCLKEN :
+						      FMC2_CFGR_CCLKEN;
+
+	if (!ebi->access_granted) {
+		dev_err(ebi->dev, "CFGR access forbidden\n");
+		return -EACCES;
+	}
 
-	new_val = FIELD_PREP(FMC2_PCSCNTR_CSCOUNT, new_val);
-	regmap_update_bits(ebi->regmap, FMC2_PCSCNTR,
-			   FMC2_PCSCNTR_CSCOUNT, new_val);
+	regmap_update_bits(ebi->regmap, reg, mask, setup ? mask : 0);
 
 	return 0;
 }
@@ -725,10 +868,8 @@ static const struct stm32_fmc2_prop stm32_fmc2_child_props[] = {
 	{
 		.name = "st,fmc2-ebi-cs-cclk-enable",
 		.bprop = true,
-		.reg_type = FMC2_REG_BCR,
-		.reg_mask = FMC2_BCR1_CCLKEN,
 		.check = stm32_fmc2_ebi_check_cclk,
-		.set = stm32_fmc2_ebi_set_bit_field,
+		.set = stm32_fmc2_ebi_set_cclk,
 	},
 	{
 		.name = "st,fmc2-ebi-cs-mux-enable",
@@ -824,7 +965,7 @@ static const struct stm32_fmc2_prop stm32_fmc2_child_props[] = {
 	},
 	{
 		.name = "st,fmc2-ebi-cs-clk-period-ns",
-		.reset_val = FMC2_BTR_CLKDIV_MAX + 1,
+		.reset_val = FMC2_REG_CLKDIV_MAX + 1,
 		.check = stm32_fmc2_ebi_check_clk_period,
 		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
 		.set = stm32_fmc2_ebi_set_clk_period,
@@ -880,6 +1021,107 @@ static const struct stm32_fmc2_prop stm32_fmc2_child_props[] = {
 	},
 };
 
+static int stm32_fmc2_ebi_check_rif(struct stm32_fmc2_ebi *ebi, u32 resource)
+{
+	u32 seccfgr, cidcfgr, semcr;
+	int cid;
+
+	if (ebi->majrev < FMC2_VERR_MAJREV_2)
+		return 0;
+
+	if (resource >= FMC2_MAX_RESOURCES)
+		return -EINVAL;
+
+	regmap_read(ebi->regmap, FMC2_SECCFGR, &seccfgr);
+	if (seccfgr & BIT(resource)) {
+		if (resource)
+			dev_err(ebi->dev, "resource %d is configured as secure\n",
+				resource);
+
+		return -EACCES;
+	}
+
+	regmap_read(ebi->regmap, FMC2_CIDCFGR(resource), &cidcfgr);
+	if (!(cidcfgr & FMC2_CIDCFGR_CFEN))
+		/* CID filtering is turned off: access granted */
+		return 0;
+
+	if (!(cidcfgr & FMC2_CIDCFGR_SEMEN)) {
+		/* Static CID mode */
+		cid = FIELD_GET(FMC2_CIDCFGR_SCID, cidcfgr);
+		if (cid != FMC2_CID1) {
+			if (resource)
+				dev_err(ebi->dev, "static CID%d set for resource %d\n",
+					cid, resource);
+
+			return -EACCES;
+		}
+
+		return 0;
+	}
+
+	/* Pass-list with semaphore mode */
+	if (!(cidcfgr & FMC2_CIDCFGR_SEMWLC1)) {
+		if (resource)
+			dev_err(ebi->dev, "CID1 is block-listed for resource %d\n",
+				resource);
+
+		return -EACCES;
+	}
+
+	regmap_read(ebi->regmap, FMC2_SEMCR(resource), &semcr);
+	if (!(semcr & FMC2_SEMCR_SEM_MUTEX)) {
+		regmap_update_bits(ebi->regmap, FMC2_SEMCR(resource),
+				   FMC2_SEMCR_SEM_MUTEX, FMC2_SEMCR_SEM_MUTEX);
+		regmap_read(ebi->regmap, FMC2_SEMCR(resource), &semcr);
+	}
+
+	cid = FIELD_GET(FMC2_SEMCR_SEMCID, semcr);
+	if (cid != FMC2_CID1) {
+		if (resource)
+			dev_err(ebi->dev, "resource %d is already used by CID%d\n",
+				resource, cid);
+
+		return -EACCES;
+	}
+
+	ebi->sem_taken |= BIT(resource);
+
+	return 0;
+}
+
+static void stm32_fmc2_ebi_put_sems(struct stm32_fmc2_ebi *ebi)
+{
+	unsigned int resource;
+
+	if (ebi->majrev < FMC2_VERR_MAJREV_2)
+		return;
+
+	for (resource = 0; resource < FMC2_MAX_RESOURCES; resource++) {
+		if (!(ebi->sem_taken & BIT(resource)))
+			continue;
+
+		regmap_update_bits(ebi->regmap, FMC2_SEMCR(resource),
+				   FMC2_SEMCR_SEM_MUTEX, 0);
+	}
+}
+
+static void stm32_fmc2_ebi_get_sems(struct stm32_fmc2_ebi *ebi)
+{
+	unsigned int resource;
+
+	if (ebi->majrev < FMC2_VERR_MAJREV_2)
+		return;
+
+	for (resource = 0; resource < FMC2_MAX_RESOURCES; resource++) {
+		if (!(ebi->sem_taken & BIT(resource)))
+			continue;
+
+		regmap_update_bits(ebi->regmap, FMC2_SEMCR(resource),
+				   FMC2_SEMCR_SEM_MUTEX, FMC2_SEMCR_SEM_MUTEX);
+	}
+}
+
 static int stm32_fmc2_ebi_parse_prop(struct stm32_fmc2_ebi *ebi,
 				     struct device_node *dev_node,
 				     const struct stm32_fmc2_prop *prop,
@@ -947,12 +1189,18 @@ static void stm32_fmc2_ebi_save_setup(struct stm32_fmc2_ebi *ebi)
 	unsigned int cs;
 
 	for (cs = 0; cs < FMC2_MAX_EBI_CE; cs++) {
+		if (!(ebi->bank_assigned & BIT(cs)))
+			continue;
+
 		regmap_read(ebi->regmap, FMC2_BCR(cs), &ebi->bcr[cs]);
 		regmap_read(ebi->regmap, FMC2_BTR(cs), &ebi->btr[cs]);
 		regmap_read(ebi->regmap, FMC2_BWTR(cs), &ebi->bwtr[cs]);
 	}
 
-	regmap_read(ebi->regmap, FMC2_PCSCNTR, &ebi->pcscntr);
+	if (ebi->majrev < FMC2_VERR_MAJREV_2)
+		regmap_read(ebi->regmap, FMC2_PCSCNTR, &ebi->pcscntr);
+	else if (ebi->access_granted)
+		regmap_read(ebi->regmap, FMC2_CFGR, &ebi->cfgr);
 }
 
 static void stm32_fmc2_ebi_set_setup(struct stm32_fmc2_ebi *ebi)
@@ -960,12 +1208,18 @@ static void stm32_fmc2_ebi_set_setup(struct stm32_fmc2_ebi *ebi)
 	unsigned int cs;
 
 	for (cs = 0; cs < FMC2_MAX_EBI_CE; cs++) {
+		if (!(ebi->bank_assigned & BIT(cs)))
+			continue;
+
 		regmap_write(ebi->regmap, FMC2_BCR(cs), ebi->bcr[cs]);
 		regmap_write(ebi->regmap, FMC2_BTR(cs), ebi->btr[cs]);
 		regmap_write(ebi->regmap, FMC2_BWTR(cs), ebi->bwtr[cs]);
 	}
 
-	regmap_write(ebi->regmap, FMC2_PCSCNTR, ebi->pcscntr);
+	if (ebi->majrev < FMC2_VERR_MAJREV_2)
+		regmap_write(ebi->regmap, FMC2_PCSCNTR, ebi->pcscntr);
+	else if (ebi->access_granted)
+		regmap_write(ebi->regmap, FMC2_CFGR, ebi->cfgr);
 }
 
 static void stm32_fmc2_ebi_disable_banks(struct stm32_fmc2_ebi *ebi)
@@ -986,6 +1240,9 @@ static bool stm32_fmc2_ebi_nwait_used_by_ctrls(struct stm32_fmc2_ebi *ebi)
 	unsigned int cs;
 	u32 bcr;
 
+	if (ebi->data->rnb_for_nand)
+		return false;
+
 	for (cs = 0; cs < FMC2_MAX_EBI_CE; cs++) {
 		if (!(ebi->bank_assigned & BIT(cs)))
 			continue;
@@ -1001,13 +1258,22 @@ static bool stm32_fmc2_ebi_nwait_used_by_ctrls(struct stm32_fmc2_ebi *ebi)
 
 static void stm32_fmc2_ebi_enable(struct stm32_fmc2_ebi *ebi)
 {
-	regmap_update_bits(ebi->regmap, FMC2_BCR1,
-			   FMC2_BCR1_FMC2EN, FMC2_BCR1_FMC2EN);
+	u32 reg = ebi->majrev < FMC2_VERR_MAJREV_2 ? FMC2_BCR1 : FMC2_CFGR;
+	u32 mask = ebi->majrev < FMC2_VERR_MAJREV_2 ? FMC2_BCR1_FMC2EN :
+						      FMC2_CFGR_FMC2EN;
+
+	if (ebi->access_granted)
+		regmap_update_bits(ebi->regmap, reg, mask, mask);
 }
 
 static void stm32_fmc2_ebi_disable(struct stm32_fmc2_ebi *ebi)
 {
-	regmap_update_bits(ebi->regmap, FMC2_BCR1, FMC2_BCR1_FMC2EN, 0);
+	u32 reg = ebi->majrev < FMC2_VERR_MAJREV_2 ? FMC2_BCR1 : FMC2_CFGR;
+	u32 mask = ebi->majrev < FMC2_VERR_MAJREV_2 ? FMC2_BCR1_FMC2EN :
+						      FMC2_CFGR_FMC2EN;
+
+	if (ebi->access_granted)
+		regmap_update_bits(ebi->regmap, reg, mask, 0);
 }
 
 static int stm32_fmc2_ebi_setup_cs(struct stm32_fmc2_ebi *ebi,
@@ -1064,6 +1330,13 @@ static int stm32_fmc2_ebi_parse_dt(struct stm32_fmc2_ebi *ebi)
 			return -EINVAL;
 		}
 
+		ret = stm32_fmc2_ebi_check_rif(ebi, bank + 1);
+		if (ret) {
+			dev_err(dev, "bank access failed: %d\n", bank);
+			of_node_put(child);
+			return ret;
+		}
+
 		if (bank < FMC2_MAX_EBI_CE) {
 			ret = stm32_fmc2_ebi_setup_cs(ebi, child, bank);
 			if (ret) {
@@ -1098,6 +1371,7 @@ static int stm32_fmc2_ebi_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct stm32_fmc2_ebi *ebi;
 	struct reset_control *rstc;
+	u32 verr;
 	int ret;
 
 	ebi = devm_kzalloc(&pdev->dev, sizeof(*ebi), GFP_KERNEL);
@@ -1106,6 +1380,10 @@ static int stm32_fmc2_ebi_probe(struct platform_device *pdev)
 
 	ebi->dev = dev;
 
+	ebi->data = of_device_get_match_data(dev);
+	if (!ebi->data)
+		return -EINVAL;
+
 	ebi->regmap = device_node_to_regmap(dev->of_node);
 	if (IS_ERR(ebi->regmap))
 		return PTR_ERR(ebi->regmap);
@@ -1127,6 +1405,26 @@ static int stm32_fmc2_ebi_probe(struct platform_device *pdev)
 		reset_control_deassert(rstc);
 	}
 
+	regmap_read(ebi->regmap, FMC2_VERR, &verr);
+	ebi->majrev = FIELD_GET(FMC2_VERR_MAJREV, verr);
+
+	/* Check if CFGR register can be modified */
+	ret = stm32_fmc2_ebi_check_rif(ebi, 0);
+	if (!ret)
+		ebi->access_granted = true;
+
+	/* In case of CFGR is secure, just check that the FMC2 is enabled */
+	if (!ebi->access_granted) {
+		u32 sr;
+
+		regmap_read(ebi->regmap, FMC2_SR, &sr);
+		if (sr & FMC2_SR_ISOST) {
+			dev_err(dev, "FMC2 is not ready to be used.\n");
+			ret = -EACCES;
+			goto err_release;
+		}
+	}
+
 	ret = stm32_fmc2_ebi_parse_dt(ebi);
 	if (ret)
 		goto err_release;
@@ -1139,6 +1437,7 @@ static int stm32_fmc2_ebi_probe(struct platform_device *pdev)
 err_release:
 	stm32_fmc2_ebi_disable_banks(ebi);
 	stm32_fmc2_ebi_disable(ebi);
+	stm32_fmc2_ebi_put_sems(ebi);
 	clk_disable_unprepare(ebi->clk);
 
 	return ret;
@@ -1151,6 +1450,7 @@ static int stm32_fmc2_ebi_remove(struct platform_device *pdev)
 	of_platform_depopulate(&pdev->dev);
 	stm32_fmc2_ebi_disable_banks(ebi);
 	stm32_fmc2_ebi_disable(ebi);
+	stm32_fmc2_ebi_put_sems(ebi);
 	clk_disable_unprepare(ebi->clk);
 
 	return 0;
@@ -1161,6 +1461,7 @@ static int __maybe_unused stm32_fmc2_ebi_suspend(struct device *dev)
 	struct stm32_fmc2_ebi *ebi = dev_get_drvdata(dev);
 
 	stm32_fmc2_ebi_disable(ebi);
+	stm32_fmc2_ebi_put_sems(ebi);
 	clk_disable_unprepare(ebi->clk);
 	pinctrl_pm_select_sleep_state(dev);
 
@@ -1178,6 +1479,7 @@ static int __maybe_unused stm32_fmc2_ebi_resume(struct device *dev)
 	if (ret)
 		return ret;
 
+	stm32_fmc2_ebi_get_sems(ebi);
 	stm32_fmc2_ebi_set_setup(ebi);
 	stm32_fmc2_ebi_enable(ebi);
 
@@ -1187,8 +1489,23 @@ static int __maybe_unused stm32_fmc2_ebi_resume(struct device *dev)
 static SIMPLE_DEV_PM_OPS(stm32_fmc2_ebi_pm_ops, stm32_fmc2_ebi_suspend,
 			 stm32_fmc2_ebi_resume);
 
+static const struct stm32_fmc2_ebi_data stm32_fmc2_ebi_mp1_data = {
+	.rnb_for_nand = false,
+};
+
+static const struct stm32_fmc2_ebi_data stm32_fmc2_ebi_mp25_data = {
+	.rnb_for_nand = true,
+};
+
 static const struct of_device_id stm32_fmc2_ebi_match[] = {
-	{.compatible = "st,stm32mp1-fmc2-ebi"},
+	{
+		.compatible = "st,stm32mp1-fmc2-ebi",
+		.data = &stm32_fmc2_ebi_mp1_data,
+	},
+	{
+		.compatible = "st,stm32mp25-fmc2-ebi",
+		.data = &stm32_fmc2_ebi_mp25_data,
+	},
 	{}
 };
 MODULE_DEVICE_TABLE(of, stm32_fmc2_ebi_match);
diff --git a/drivers/memory/stm32-omi.c b/drivers/memory/stm32-omi.c
new file mode 100644
index 000000000..40d347e88
--- /dev/null
+++ b/drivers/memory/stm32-omi.c
@@ -0,0 +1,559 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ * Author(s): Patrice Chotard <patrice.chotard@foss.st.com> for STMicroelectronics.
+ */
+
+#include <memory/stm32-omi.h>
+
+static void stm32_omi_read_fifo(u8 *val, void __iomem *addr)
+{
+	*val = readb_relaxed(addr);
+}
+
+static void stm32_omi_write_fifo(u8 *val, void __iomem *addr)
+{
+	writeb_relaxed(*val, addr);
+}
+
+int stm32_omi_abort(struct stm32_omi *omi)
+{
+	void __iomem *regs_base = omi->regs_base;
+	u32 cr;
+	int timeout;
+
+	cr = readl_relaxed(regs_base + OSPI_CR) | CR_ABORT;
+	writel_relaxed(cr, regs_base + OSPI_CR);
+
+	/* wait clear of abort bit by hw */
+	timeout = readl_relaxed_poll_timeout_atomic(regs_base + OSPI_CR,
+						    cr, !(cr & CR_ABORT), 1,
+						    STM32_ABT_TIMEOUT_US);
+
+	if (timeout)
+		dev_err(omi->dev, "%s abort timeout:%d\n", __func__, timeout);
+
+	return timeout;
+}
+EXPORT_SYMBOL(stm32_omi_abort);
+
+int stm32_omi_tx_poll(struct stm32_omi *omi, u8 *buf, u32 len, bool read)
+{
+	void __iomem *regs_base = omi->regs_base;
+	void (*tx_fifo)(u8 *val, void __iomem *addr);
+	u32 sr;
+	int ret;
+
+	if (read)
+		tx_fifo = stm32_omi_read_fifo;
+	else
+		tx_fifo = stm32_omi_write_fifo;
+
+	while (len--) {
+		ret = readl_relaxed_poll_timeout_atomic(regs_base + OSPI_SR,
+							sr, sr & SR_FTF, 1,
+							STM32_FIFO_TIMEOUT_US);
+		if (ret) {
+			dev_err(omi->dev, "fifo timeout (len:%d stat:%#x)\n",
+				len, sr);
+			return ret;
+		}
+		tx_fifo(buf++, regs_base + OSPI_DR);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(stm32_omi_tx_poll);
+
+int stm32_omi_wait_nobusy(struct stm32_omi *omi)
+{
+	u32 sr;
+
+	return readl_relaxed_poll_timeout_atomic(omi->regs_base + OSPI_SR,
+						 sr, !(sr & SR_BUSY), 1,
+						 STM32_BUSY_TIMEOUT_US);
+}
+EXPORT_SYMBOL(stm32_omi_wait_nobusy);
+
+int stm32_omi_wait_cmd(struct stm32_omi *omi)
+{
+	void __iomem *regs_base = omi->regs_base;
+	u32 cr, sr;
+	int err = 0;
+
+	if ((readl_relaxed(regs_base + OSPI_SR) & SR_TCF) ||
+	    omi->fmode == CR_FMODE_APM)
+		goto out;
+
+	reinit_completion(&omi->data_completion);
+	cr = readl_relaxed(regs_base + OSPI_CR);
+	writel_relaxed(cr | CR_TCIE | CR_TEIE, regs_base + OSPI_CR);
+
+	if (!wait_for_completion_timeout(&omi->data_completion,
+				msecs_to_jiffies(STM32_COMP_TIMEOUT_MS))) {
+		err = -ETIMEDOUT;
+	} else {
+		sr = readl_relaxed(regs_base + OSPI_SR);
+		if (sr & SR_TEF)
+			err = -EIO;
+	}
+
+out:
+	/* clear flags */
+	writel_relaxed(FCR_CTCF | FCR_CTEF, regs_base + OSPI_FCR);
+
+	if (!err)
+		err = stm32_omi_wait_nobusy(omi);
+
+	return err;
+}
+EXPORT_SYMBOL(stm32_omi_wait_cmd);
+
+irqreturn_t stm32_omi_irq(int irq, void *dev_id)
+{
+	struct stm32_omi *omi = (struct stm32_omi *)dev_id;
+	void __iomem *regs_base = omi->regs_base;
+	u32 cr, sr;
+
+	cr = readl_relaxed(regs_base + OSPI_CR);
+	sr = readl_relaxed(regs_base + OSPI_SR);
+
+	if (cr & CR_SMIE && sr & SR_SMF) {
+		/* disable irq */
+		cr &= ~CR_SMIE;
+		writel_relaxed(cr, regs_base + OSPI_CR);
+		complete(&omi->match_completion);
+
+		return IRQ_HANDLED;
+	}
+
+	if (sr & (SR_TEF | SR_TCF)) {
+		/* disable irq */
+		cr = readl_relaxed(regs_base + OSPI_CR);
+		cr &= ~CR_TCIE & ~CR_TEIE;
+		writel_relaxed(cr, regs_base + OSPI_CR);
+		complete(&omi->data_completion);
+	}
+
+	return IRQ_HANDLED;
+}
+EXPORT_SYMBOL(stm32_omi_irq);
+
+void stm32_omi_dma_callback(void *arg)
+{
+	struct completion *dma_completion = arg;
+
+	complete(dma_completion);
+}
+EXPORT_SYMBOL(stm32_omi_dma_callback);
+
+void stm32_omi_dma_free(struct stm32_omi *omi)
+{
+	if (omi->dma_chtx)
+		dma_release_channel(omi->dma_chtx);
+	if (omi->dma_chrx)
+		dma_release_channel(omi->dma_chrx);
+}
+EXPORT_SYMBOL(stm32_omi_dma_free);
+
+int stm32_omi_dma_setup(struct stm32_omi *omi, struct device *dev,
+			       struct dma_slave_config *dma_cfg)
+{
+	int ret = 0;
+
+	omi->dma_chrx = dma_request_chan(dev, "rx");
+	if (IS_ERR(omi->dma_chrx)) {
+		ret = PTR_ERR(omi->dma_chrx);
+		omi->dma_chrx = NULL;
+		if (ret == -EPROBE_DEFER)
+			goto out;
+	} else if (dma_cfg) {
+		if (dmaengine_slave_config(omi->dma_chrx, dma_cfg)) {
+			dev_err(dev, "dma rx config failed\n");
+			dma_release_channel(omi->dma_chrx);
+			omi->dma_chrx = NULL;
+		}
+	}
+
+	omi->dma_chtx = dma_request_chan(dev, "tx");
+	if (IS_ERR(omi->dma_chtx)) {
+		ret = PTR_ERR(omi->dma_chtx);
+		omi->dma_chtx = NULL;
+	} else if (dma_cfg) {
+		if (dmaengine_slave_config(omi->dma_chtx, dma_cfg)) {
+			dev_err(dev, "dma tx config failed\n");
+			dma_release_channel(omi->dma_chtx);
+			omi->dma_chtx = NULL;
+		}
+	}
+
+	init_completion(&omi->dma_completion);
+out:
+	if (ret != -EPROBE_DEFER)
+		ret = 0;
+
+	return ret;
+}
+EXPORT_SYMBOL(stm32_omi_dma_setup);
+
+int stm32_omi_get_resources(struct stm32_omi *omi, struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct device_node *np = dev->of_node;
+	struct resource res;
+	struct reset_control *rstc;
+	struct reserved_mem *rmem = NULL;
+	struct device_node *node;
+	int ret = 0;
+
+	omi->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(omi->clk))
+		return dev_err_probe(dev, PTR_ERR(omi->clk),
+				     "Can't get clock\n");
+
+	omi->irq = platform_get_irq(pdev, 0);
+	if (omi->irq < 0) {
+		dev_err(dev, "Can't get irq %d\n", omi->irq);
+		return omi->irq;
+	}
+
+	rstc = devm_reset_control_array_get(dev, false, true);
+	if (IS_ERR(rstc)) {
+		return dev_err_probe(dev, PTR_ERR(rstc),
+				     "Can't get reset\n");
+	} else {
+		reset_control_assert(rstc);
+		udelay(2);
+		reset_control_deassert(rstc);
+	}
+
+	omi->regmap = syscon_regmap_lookup_by_phandle(np, "st,syscfg-dlyb");
+	if (IS_ERR(omi->regmap)) {
+		/* Optional */
+		omi->regmap = NULL;
+		omi->dlyb_base = 0;
+	} else {
+		ret = of_property_read_u32_index(np, "st,syscfg-dlyb", 1,
+						 &omi->dlyb_base);
+		if (ret) {
+			dev_err(dev, "Can't read delay block base address\n");
+			return ret;
+		}
+	}
+
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret)
+		return ret;
+
+	omi->regs_base = ioremap(res.start, resource_size(&res));
+	if (IS_ERR(omi->regs_base))
+		return PTR_ERR(omi->regs_base);
+
+	omi->regs_phys_base = res.start;
+
+	node = of_parse_phandle(dev->of_node, "memory-region", 0);
+	if (node)
+		rmem = of_reserved_mem_lookup(node);
+
+	of_node_put(node);
+	if (rmem) {
+		omi->mm_phys_base = rmem->base;
+		omi->mm_size = rmem->size;
+		omi->mm_base = devm_ioremap(dev, rmem->base, rmem->size);
+		if (IS_ERR(omi->mm_base)) {
+			dev_err(dev, "unable to map memory region: %pa+%pa\n",
+				&rmem->base, &rmem->size);
+			ret = PTR_ERR(omi->mm_base);
+		}
+
+		if (omi->mm_size > STM32_OMI_MAX_MMAP_SZ) {
+			dev_err(dev, "Memory map size outsize bounds\n");
+			ret = -EINVAL;
+		}
+	} else {
+		dev_info(dev, "No memory-map region found\n");
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(stm32_omi_get_resources);
+
+int stm32_omi_dlyb_set_tap(struct stm32_omi *omi, u8 tap, bool rx_tap)
+{
+	u32 sr, mask, ack;
+	int ret;
+	u8 shift;
+
+	if (rx_tap) {
+		mask = DLYBOS_CR_RXTAPSEL_MASK;
+		shift = DLYBOS_CR_RXTAPSEL_SHIFT;
+		ack = DLYBOS_SR_RXTAPSEL_ACK;
+	} else {
+		mask = DLYBOS_CR_TXTAPSEL_MASK;
+		shift = DLYBOS_CR_TXTAPSEL_SHIFT;
+		ack = DLYBOS_SR_TXTAPSEL_ACK;
+	}
+
+	ret = regmap_update_bits(omi->regmap,
+				 omi->dlyb_base + SYSCFG_DLYBOS_CR,
+				 mask, mask & (tap << shift));
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_read_poll_timeout(omi->regmap,
+				       omi->dlyb_base + SYSCFG_DLYBOS_SR,
+				       sr, sr & ack, 1,
+				       1000 * STM32_DLYBOS_TIMEOUT_MS);
+	if (ret)
+		dev_err(omi->dev, "%s delay Block phase configuration timeout\n",
+			rx_tap ? "RX" : "TX");
+
+	return ret;
+}
+
+int stm32_omi_dlyb_find_tap(struct stm32_omi *omi, bool rx_only)
+{
+	struct stm32_tap_window rx_tap_w[DLYBOS_TAPSEL_NB];
+	int ret;
+	u8 rx_len, rx_window_len, rx_window_end;
+	u8 tx_len, tx_window_len, tx_window_end;
+	u8 rx_tap, tx_tap, tx_tap_max, tx_tap_min, best_tx_tap;
+	u8 score, score_max;
+
+	tx_len = 0;
+	tx_window_len = 0;
+	tx_window_end = 0;
+
+	for (tx_tap = 0;
+	     tx_tap < (rx_only ? 1 : DLYBOS_TAPSEL_NB);
+	     tx_tap++) {
+		ret = stm32_omi_dlyb_set_tap(omi, tx_tap, false);
+		if (ret)
+			return ret;
+
+		rx_len = 0;
+		rx_window_len = 0;
+		rx_window_end = 0;
+
+		for (rx_tap = 0; rx_tap < DLYBOS_TAPSEL_NB; rx_tap++) {
+			ret = stm32_omi_dlyb_set_tap(omi, rx_tap, true);
+			if (ret)
+				return ret;
+
+			ret = omi->check_transfer(omi);
+			if (ret) {
+				rx_len = 0;
+			} else {
+				rx_len++;
+				if (rx_len > rx_window_len) {
+					rx_window_len = rx_len;
+					rx_window_end = rx_tap;
+				}
+			}
+		}
+
+		rx_tap_w[tx_tap].end = rx_window_end;
+		rx_tap_w[tx_tap].length = rx_window_len;
+
+		if (!rx_window_len) {
+			tx_len = 0;
+		} else {
+			tx_len++;
+			if (tx_len > tx_window_len) {
+				tx_window_len = tx_len;
+				tx_window_end = tx_tap;
+			}
+		}
+		dev_dbg(omi->dev, "rx_tap_w[%02d].end = %d rx_tap_w[%02d].length = %d\n",
+			tx_tap, rx_tap_w[tx_tap].end, tx_tap, rx_tap_w[tx_tap].length);
+	}
+
+	if (rx_only) {
+		if (!rx_window_len) {
+			dev_err(omi->dev, "Can't find RX phase settings\n");
+			return -EIO;
+		}
+
+		rx_tap = rx_window_end - rx_window_len / 2;
+		dev_dbg(omi->dev, "RX_TAP_SEL set to %d\n", rx_tap);
+
+		return stm32_omi_dlyb_set_tap(omi, rx_tap, true);
+	}
+
+	/* find the best duet TX/RX TAP */
+	tx_tap_min = tx_window_end - tx_window_len + 1;
+	tx_tap_max = tx_window_end;
+	score_max = 0;
+	for (tx_tap = tx_tap_min; tx_tap <= tx_tap_max; tx_tap++) {
+		score = min_t(u8, tx_tap - tx_tap_min, tx_tap_max - tx_tap) +
+			rx_tap_w[tx_tap].length;
+		if (score > score_max) {
+			score_max = score;
+			best_tx_tap = tx_tap;
+		}
+	}
+
+	rx_tap = rx_tap_w[best_tx_tap].end - rx_tap_w[best_tx_tap].length / 2;
+
+	dev_dbg(omi->dev, "RX_TAP_SEL set to %d\n", rx_tap);
+	ret = stm32_omi_dlyb_set_tap(omi, rx_tap, true);
+	if (ret)
+		return ret;
+
+	dev_dbg(omi->dev, "TX_TAP_SEL set to %d\n", best_tx_tap);
+
+	return stm32_omi_dlyb_set_tap(omi, best_tx_tap, false);
+}
+
+/* ½ memory clock period in pico second */
+static const u16 dlybos_delay_ps[STM32_DLYBOS_DELAY_NB] = {
+2816, 4672, 6272, 7872, 9472, 11104, 12704, 14304, 15904, 17536, 19136, 20736,
+22336, 23968, 25568, 27168, 28768, 30400, 32000, 33600, 35232, 36832, 38432, 40032
+};
+
+static u32 stm32_omi_find_byp_cmd(u16 period_ps)
+{
+	u16 half_period_ps = period_ps / 2;
+	u8 max = STM32_DLYBOS_DELAY_NB - 1;
+	u8 i, min = 0;
+
+	/* find closest value in dlybos_delay_ps[] with half_period_ps*/
+	if (half_period_ps < dlybos_delay_ps[0])
+		return FIELD_PREP(DLYBOS_BYP_CMD_MASK, 1);
+
+	if (half_period_ps > dlybos_delay_ps[max])
+		return FIELD_PREP(DLYBOS_BYP_CMD_MASK, STM32_DLYBOS_DELAY_NB);
+
+	while (max - min > 1) {
+		i = DIV_ROUND_UP(min + max, 2);
+		if (half_period_ps > dlybos_delay_ps[i])
+			min = i;
+		else
+			max = i;
+	}
+
+	if ((dlybos_delay_ps[max] - half_period_ps) >
+	    (half_period_ps - dlybos_delay_ps[min]))
+		return FIELD_PREP(DLYBOS_BYP_CMD_MASK, min + 1);
+	else
+		return FIELD_PREP(DLYBOS_BYP_CMD_MASK, max + 1);
+}
+
+int stm32_omi_dlyb_configure(struct stm32_omi *omi, bool bypass_mode,
+			     u16 period_ps)
+{
+	u32 sr, mask = 0;
+	int ret;
+
+	if (bypass_mode) {
+		mask = DLYBOS_BYP_EN;
+		mask |= stm32_omi_find_byp_cmd(period_ps);
+	} else {
+		mask = DLYBOS_CR_EN;
+	}
+
+	/* enable Delay Block */
+	ret = regmap_update_bits(omi->regmap, omi->dlyb_base + SYSCFG_DLYBOS_CR,
+				 mask, mask);
+
+	if (ret < 0 || bypass_mode)
+		return ret;
+
+	/* in lock mode, wait for lock status bit */
+	ret = regmap_read_poll_timeout(omi->regmap,
+				       omi->dlyb_base + SYSCFG_DLYBOS_SR,
+				       sr, sr & DLYBOS_SR_LOCK, 1,
+				       1000 * STM32_DLYBOS_TIMEOUT_MS);
+	if (ret)
+		dev_err(omi->dev, "Delay Block lock timeout\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(stm32_omi_dlyb_configure);
+
+static int stm32_omi_probe(struct platform_device *pdev)
+{
+	struct platform_device *vdev;
+	struct device *dev = &pdev->dev;
+	struct device_node *child;
+	const char *name;
+	u8 hyperflash_count = 0;
+	u8 spi_flash_count = 0;
+	u8 child_count = 0;
+
+	/*
+	 * Flash subnodes sanity check:
+	 *        2 spi-nand/spi-nor flashes			=> supported
+	 *        1 HyperFlash					=> supported
+	 *	  All other flash node configuration		=> not supported
+	 */
+	for_each_available_child_of_node(dev->of_node, child) {
+		if (of_device_is_compatible(child, "cfi-flash"))
+			hyperflash_count++;
+
+		if (of_device_is_compatible(child, "jedec,spi-nor") ||
+		    of_device_is_compatible(child, "spi-nand"))
+			spi_flash_count++;
+
+		child_count++;
+	}
+
+	if (!child_count) {
+		dev_err(dev, "Missing flash node\n");
+		return -ENODEV;
+	}
+
+	if ((!hyperflash_count && !spi_flash_count) ||
+	    child_count != (hyperflash_count + spi_flash_count)) {
+		dev_err(dev, "Unknown flash type\n");
+		return -ENODEV;
+	}
+
+	if ((hyperflash_count && spi_flash_count) ||
+	     hyperflash_count > 1) {
+		dev_err(dev, "Flash node configuration not supported\n");
+		return -EINVAL;
+	}
+
+	if (spi_flash_count)
+		name = "stm32-ospi";
+	else
+		name = "stm32-hyperflash";
+
+	vdev = platform_device_alloc(name, PLATFORM_DEVID_AUTO);
+	if (!vdev)
+		return -ENOMEM;
+
+	vdev->dev.parent = dev;
+	platform_set_drvdata(pdev, vdev);
+
+	return platform_device_add(vdev);
+}
+
+static int stm32_omi_remove(struct platform_device *pdev)
+{
+	struct platform_device *vdev = platform_get_drvdata(pdev);
+
+	platform_device_unregister(vdev);
+
+	return 0;
+}
+
+static const struct of_device_id stm32_omi_of_match[] = {
+	{ .compatible = "st,stm32mp25-omi", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, stm32_omi_of_match);
+
+static struct platform_driver stm32_omi_driver = {
+	.probe	= stm32_omi_probe,
+	.remove	= stm32_omi_remove,
+	.driver = {
+		.name =	"stm32-omi",
+		.of_match_table = stm32_omi_of_match,
+	},
+};
+module_platform_driver(stm32_omi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics STM32 OSPI Memory Interface driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index d2f345245..181730a69 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -2042,6 +2042,16 @@ config MFD_STPMIC1
 	  To compile this driver as a module, choose M here: the
 	  module will be called stpmic1.
 
+config MFD_STM32MP1_PWR
+	bool "STM32MP1 wake-up pins"
+	depends on MACH_STM32MP157
+	default y
+	help
+	  Select this option to enable STM32 PWR Wake-up pins driver.
+
+	  This driver provides interruptions that can be used to wake-up from
+	  suspend.
+
 config MFD_STMFX
 	tristate "Support for STMicroelectronics Multi-Function eXpander (STMFX)"
 	depends on I2C
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index 2ba6646e8..68201ea8e 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -255,6 +255,7 @@ obj-$(CONFIG_MFD_SUN4I_GPADC)	+= sun4i-gpadc.o
 
 obj-$(CONFIG_MFD_STM32_LPTIMER)	+= stm32-lptimer.o
 obj-$(CONFIG_MFD_STM32_TIMERS) 	+= stm32-timers.o
+obj-$(CONFIG_MFD_STM32MP1_PWR)	+= stm32-pwr.o
 obj-$(CONFIG_MFD_MXS_LRADC)     += mxs-lradc.o
 obj-$(CONFIG_MFD_SC27XX_PMIC)	+= sprd-sc27xx-spi.o
 obj-$(CONFIG_RAVE_SP_CORE)	+= rave-sp.o
diff --git a/drivers/mfd/stm32-lptimer.c b/drivers/mfd/stm32-lptimer.c
index 746e51a17..41edfb76f 100644
--- a/drivers/mfd/stm32-lptimer.c
+++ b/drivers/mfd/stm32-lptimer.c
@@ -48,6 +48,40 @@ static int stm32_lptimer_detect_encoder(struct stm32_lptimer *ddata)
 	return 0;
 }
 
+static int stm32_lptimer_detect_hwcfgr(struct device *dev, struct stm32_lptimer *ddata)
+{
+	u32 val;
+	int ret;
+
+	/* Try to guess parameters from HWCFGR: e.g. encodrer mode (STM32MP15) */
+	ret = regmap_read(ddata->regmap, STM32MP15_LPTIM_HWCFGR, &val);
+	if (ret)
+		return ret;
+
+	/* Fall back to legacy init if HWCFGR isn't present */
+	if (!val)
+		return stm32_lptimer_detect_encoder(ddata);
+
+	ddata->has_encoder = FIELD_GET(STM32MP15_LPTIM_HWCFGR_ENCODER, val);
+
+	ret = regmap_read(ddata->regmap, STM32MP15_LPTIM_VERR, &val);
+	if (ret)
+		return ret;
+
+	dev_dbg(dev, "LPTIM version: %lu.%lu\n",
+		FIELD_GET(STM32MP15_MAJREV_MASK, val),
+		FIELD_GET(STM32MP15_MINREV_MASK, val));
+
+	ret = regmap_read(ddata->regmap, STM32MP25_LPTIM_HWCFGR2, &val);
+	if (ret)
+		return ret;
+
+	/* Number of capture/compare channels */
+	ddata->num_cc_chans = FIELD_GET(STM32MP25_LPTIM_HWCFGR2_CHAN_NUM, val);
+
+	return 0;
+}
+
 static int stm32_lptimer_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -74,7 +108,7 @@ static int stm32_lptimer_probe(struct platform_device *pdev)
 	if (IS_ERR(ddata->clk))
 		return PTR_ERR(ddata->clk);
 
-	ret = stm32_lptimer_detect_encoder(ddata);
+	ret = stm32_lptimer_detect_hwcfgr(dev, ddata);
 	if (ret)
 		return ret;
 
@@ -85,6 +119,7 @@ static int stm32_lptimer_probe(struct platform_device *pdev)
 
 static const struct of_device_id stm32_lptimer_of_match[] = {
 	{ .compatible = "st,stm32-lptimer", },
+	{ .compatible = "st,stm32mp25-lptimer", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32_lptimer_of_match);
diff --git a/drivers/mfd/stm32-pwr.c b/drivers/mfd/stm32-pwr.c
new file mode 100644
index 000000000..c06e2fb6c
--- /dev/null
+++ b/drivers/mfd/stm32-pwr.c
@@ -0,0 +1,423 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
+ * Author: Pascal Paillet <p.paillet@st.com> for STMicroelectronics.
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/irqchip.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <asm/exception.h>
+
+#define NB_WAKEUPPINS 6
+
+#define STM32_SVC_PWR 0x82001001
+#define STM32_WRITE 0x1
+#define STM32_SET_BITS 0x2
+#define STM32_CLEAR_BITS 0x3
+
+#define PWR_WKUP_OFFSET 0x20
+// PWR Registers
+#define WKUPCR 0x0
+#define WKUPFR 0x4
+#define MPUWKUPENR 0x8
+
+#define WKUP_FLAGS_MASK GENMASK(5, 0)
+
+// WKUPCR bits definition
+#define WKUP_EDGE_SHIFT 8
+#define WKUP_PULL_SHIFT 16
+#define WKUP_PULL_MASK GENMASK(1, 0)
+
+enum wkup_pull_setting {
+	WKUP_NO_PULL = 0,
+	WKUP_PULL_UP,
+	WKUP_PULL_DOWN,
+	WKUP_PULL_RESERVED
+};
+
+#define SMC(class, op, offset, val) do {				\
+	struct arm_smccc_res res;					\
+	arm_smccc_smc(class, op, PWR_WKUP_OFFSET + (offset), val,	\
+		      0, 0, 0, 0, &res);				\
+} while (0)								\
+
+struct stm32_pwr_data {
+	struct device *dev;
+	void __iomem *base;		/* IO Memory base address */
+	struct irq_domain *domain;	/* Domain for this controller */
+	int irq;			/* Parent interrupt */
+	u32 masked;			/* IRQ is masked */
+	u32 wake;			/* IRQ is wake on */
+	u32 pending;			/* IRQ has been received while wake on*/
+	int gpio[NB_WAKEUPPINS];
+};
+
+static void stm32_pwr_irq_ack(struct irq_data *d)
+{
+	struct stm32_pwr_data *priv = d->domain->host_data;
+
+	dev_dbg(priv->dev, "irq:%lu\n", d->hwirq);
+	SMC(STM32_SVC_PWR, STM32_SET_BITS, WKUPCR, BIT(d->hwirq));
+}
+
+static void stm32_pwr_irq_set_state(struct irq_data *d)
+{
+	struct stm32_pwr_data *priv = d->domain->host_data;
+
+	dev_dbg(priv->dev, "irq:%lu\n", d->hwirq);
+
+	/* enable is not masker or wake enabled */
+	if (!(priv->masked & BIT(d->hwirq)) || (priv->wake & BIT(d->hwirq)))
+		SMC(STM32_SVC_PWR, STM32_SET_BITS, MPUWKUPENR, BIT(d->hwirq));
+	else
+		SMC(STM32_SVC_PWR, STM32_CLEAR_BITS, MPUWKUPENR, BIT(d->hwirq));
+}
+
+static void stm32_pwr_irq_mask(struct irq_data *d)
+{
+	struct stm32_pwr_data *priv = d->domain->host_data;
+
+	dev_dbg(priv->dev, "irq:%lu\n", d->hwirq);
+	priv->masked |= BIT(d->hwirq);
+	stm32_pwr_irq_set_state(d);
+}
+
+static void stm32_pwr_irq_unmask(struct irq_data *d)
+{
+	struct stm32_pwr_data *priv = d->domain->host_data;
+
+	dev_dbg(priv->dev, "irq:%lu\n", d->hwirq);
+	priv->masked &= ~BIT(d->hwirq);
+	stm32_pwr_irq_set_state(d);
+}
+
+static int stm32_pwr_irq_set_wake(struct irq_data *d, unsigned int on)
+{
+	struct stm32_pwr_data *priv = d->domain->host_data;
+	struct irq_data *parent = irq_get_irq_data(priv->irq);
+
+	dev_dbg(priv->dev, "irq:%lu on:%d\n", d->hwirq, on);
+	if (on) {
+		priv->wake |= BIT(d->hwirq);
+	} else {
+		priv->wake &= ~BIT(d->hwirq);
+		priv->pending &= ~BIT(d->hwirq);
+	}
+	stm32_pwr_irq_set_state(d);
+
+	if (parent->chip && parent->chip->irq_set_wake)
+		return parent->chip->irq_set_wake(parent, on);
+
+	return 0;
+}
+
+static int stm32_pwr_irq_set_type(struct irq_data *d, unsigned int flow_type)
+{
+	struct stm32_pwr_data *priv = d->domain->host_data;
+	int pin_id = d->hwirq;
+	u32 wkupcr;
+	int en;
+
+	dev_dbg(priv->dev, "irq:%lu\n", d->hwirq);
+
+	en = readl_relaxed(priv->base + MPUWKUPENR) & BIT(pin_id);
+	/* reference manual request to disable the wakeup pin while
+	 * changing the edge detection setting
+	 */
+	if (en)
+		stm32_pwr_irq_mask(d);
+
+	wkupcr = readl_relaxed(priv->base + WKUPCR);
+	switch (flow_type & IRQ_TYPE_SENSE_MASK) {
+	case IRQF_TRIGGER_FALLING:
+		wkupcr |= (1 << (WKUP_EDGE_SHIFT + pin_id));
+		break;
+	case IRQF_TRIGGER_RISING:
+		wkupcr &= ~(1 << (WKUP_EDGE_SHIFT + pin_id));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	SMC(STM32_SVC_PWR, STM32_WRITE, WKUPCR, wkupcr);
+
+	if (en)
+		stm32_pwr_irq_unmask(d);
+
+	return 0;
+}
+
+#ifdef CONFIG_SMP
+static int stm32_pwr_set_affinity_parent(struct irq_data *data,
+					 const struct cpumask *dest, bool force)
+{
+	struct stm32_pwr_data *priv = data->domain->host_data;
+	struct irq_data *parent = irq_get_irq_data(priv->irq);
+
+	irq_data_update_effective_affinity(data, dest);
+
+	if (parent->chip && parent->chip->irq_set_affinity)
+		return parent->chip->irq_set_affinity(parent, dest, force);
+
+	return IRQ_SET_MASK_OK_DONE;
+}
+#endif
+
+static int stm32_pwr_irq_request_resources(struct irq_data *d)
+{
+	struct stm32_pwr_data *priv = d->domain->host_data;
+	struct device_node *dn = priv->dev->of_node;
+	int gpio;
+	int ret;
+
+	if (!dn) {
+		dev_err(priv->dev, "No platform data\n");
+		return -ENODEV;
+	}
+
+	/* Get GPIO from device tree */
+	dev_dbg(priv->dev, "irq:%lu\n", d->hwirq);
+	gpio = of_get_named_gpio(dn, "st,wakeup-pins", d->hwirq);
+
+	if (gpio < 0) {
+		dev_err(priv->dev, "Failed to get wakeup gpio: %d", gpio);
+		return gpio;
+	}
+
+	/* GPIO request and configuration */
+	ret = devm_gpio_request_one(priv->dev, gpio, GPIOF_DIR_IN,
+				    "wake-up pin");
+	if (ret) {
+		dev_err(priv->dev, "Failed to request wake-up pin\n");
+		return -ENODEV;
+	}
+
+	priv->gpio[d->hwirq] = gpio;
+
+	return 0;
+}
+
+static void stm32_pwr_irq_release_resources(struct irq_data *d)
+{
+	struct stm32_pwr_data *priv = d->domain->host_data;
+
+	dev_dbg(priv->dev, "irq:%lu\n", d->hwirq);
+	devm_gpio_free(priv->dev, priv->gpio[d->hwirq]);
+}
+
+static struct irq_chip stm32_pwr_irq_chip = {
+	.name = "stm32-pwr-irq",
+	.irq_ack = stm32_pwr_irq_ack,
+	.irq_mask = stm32_pwr_irq_mask,
+	.irq_unmask = stm32_pwr_irq_unmask,
+	.irq_set_type = stm32_pwr_irq_set_type,
+	.irq_set_wake = stm32_pwr_irq_set_wake,
+	.irq_request_resources = stm32_pwr_irq_request_resources,
+	.irq_release_resources = stm32_pwr_irq_release_resources,
+#ifdef CONFIG_SMP
+	.irq_set_affinity = stm32_pwr_set_affinity_parent,
+#endif
+};
+
+static int stm32_pwr_irq_set_pull_config(struct irq_domain *d, int pin_id,
+					 enum wkup_pull_setting config)
+{
+	struct stm32_pwr_data *priv = d->host_data;
+	u32 wkupcr;
+
+	dev_dbg(priv->dev, "irq:%d pull config:0x%x\n", pin_id, config);
+
+	if (config >= WKUP_PULL_RESERVED) {
+		pr_err("%s: bad irq pull config\n", __func__);
+		return -EINVAL;
+	}
+
+	wkupcr = readl_relaxed(priv->base + WKUPCR);
+	wkupcr &= ~((WKUP_PULL_MASK) << (WKUP_PULL_SHIFT + pin_id * 2));
+	wkupcr |= (config & WKUP_PULL_MASK) << (WKUP_PULL_SHIFT + pin_id * 2);
+
+	SMC(STM32_SVC_PWR, STM32_WRITE, WKUPCR, wkupcr);
+
+	return 0;
+}
+
+static int stm32_pwr_xlate(struct irq_domain *d, struct device_node *ctrlr,
+			   const u32 *intspec, unsigned int intsize,
+			   irq_hw_number_t *out_hwirq, unsigned int *out_type)
+{
+	if (WARN_ON(intsize < 3)) {
+		pr_err("%s: bad irq config parameters\n", __func__);
+		return -EINVAL;
+	}
+
+	*out_hwirq = intspec[0];
+	*out_type = intspec[1] & (IRQ_TYPE_SENSE_MASK);
+
+	return stm32_pwr_irq_set_pull_config(d, intspec[0], intspec[2]);
+}
+
+static int stm32_pwr_alloc(struct irq_domain *d, unsigned int virq,
+			   unsigned int nr_irqs, void *data)
+{
+	struct irq_fwspec *fwspec = data;
+	irq_hw_number_t hwirq;
+
+	hwirq = fwspec->param[0];
+	irq_domain_set_info(d, virq, hwirq, &stm32_pwr_irq_chip, d->host_data,
+			    handle_edge_irq, NULL, NULL);
+
+	return 0;
+}
+
+static const struct irq_domain_ops stm32_pwr_irq_domain_ops = {
+	.alloc = stm32_pwr_alloc,
+	.xlate = stm32_pwr_xlate,
+	.free = irq_domain_free_irqs_common,
+};
+
+/*
+ * Handler for the cascaded IRQ.
+ */
+static void stm32_pwr_handle_irq(struct irq_desc *desc)
+{
+	struct stm32_pwr_data  *priv = irq_desc_get_handler_data(desc);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	u32 wkupfr, wkupenr, i;
+
+	chained_irq_enter(chip, desc);
+
+	wkupfr = readl_relaxed(priv->base + WKUPFR);
+	wkupenr = readl_relaxed(priv->base + MPUWKUPENR);
+
+	for (i = 0; i < NB_WAKEUPPINS; i++) {
+		if ((wkupfr & BIT(i)) && (wkupenr & BIT(i))) {
+			struct irq_desc *d;
+
+			d = irq_to_desc(irq_find_mapping(priv->domain, i));
+
+			if (priv->wake & BIT(i)) {
+				dev_dbg(priv->dev,
+					"irq %d while wake enabled\n", i);
+				priv->pending |= BIT(i);
+			}
+
+			dev_dbg(priv->dev, "handle wkup irq:%d\n", i);
+			handle_edge_irq(d);
+		}
+	}
+	chained_irq_exit(chip, desc);
+}
+
+static int __maybe_unused stm32_pwr_suspend(struct device *dev)
+{
+	struct stm32_pwr_data *priv = dev_get_drvdata(dev);
+
+	pr_debug("suspend");
+	if (priv->pending != 0)
+		return -EBUSY;
+
+	return 0;
+}
+
+static const struct dev_pm_ops stm32_pwr_pm = {
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(stm32_pwr_suspend, NULL)
+};
+
+static int stm32_pwr_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct stm32_pwr_data *priv;
+	struct device_node *np = dev->of_node;
+	struct resource *res;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	priv->dev = dev;
+	dev_set_drvdata(dev, priv);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->base)) {
+		dev_err(dev, "Unable to map registers\n");
+		return PTR_ERR(priv->base);
+	}
+
+	/* Disable all wake-up pins */
+	SMC(STM32_SVC_PWR, STM32_WRITE, MPUWKUPENR, 0);
+	/* Clear all interrupts flags */
+	SMC(STM32_SVC_PWR, STM32_SET_BITS, WKUPCR, WKUP_FLAGS_MASK);
+
+	priv->domain = irq_domain_add_linear(np, NB_WAKEUPPINS,
+					     &stm32_pwr_irq_domain_ops, priv);
+	if (!priv->domain) {
+		dev_err(dev, "%s: Unable to add irq domain!\n", __func__);
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = irq_of_parse_and_map(np, 0);
+	if (ret < 0) {
+		dev_err(dev, "failed to get PWR IRQ\n");
+		ret = priv->irq;
+		goto out_domain;
+	}
+
+	priv->irq = ret;
+	irq_set_chained_handler_and_data(priv->irq, stm32_pwr_handle_irq, priv);
+
+	of_node_clear_flag(np, OF_POPULATED);
+
+	return 0;
+
+out_domain:
+	irq_domain_remove(priv->domain);
+out:
+	return ret;
+}
+
+static int stm32_pwr_remove(struct platform_device *pdev)
+{
+	struct stm32_pwr_data *priv = dev_get_drvdata(&pdev->dev);
+
+	irq_domain_remove(priv->domain);
+	return 0;
+}
+
+static const struct of_device_id stm32_pwr_ids[] = {
+	{ .compatible = "st,stm32mp1-pwr", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, stm32_pwr_ids);
+
+static struct platform_driver stm32_pwr_driver = {
+	.probe		= stm32_pwr_probe,
+	.remove		= stm32_pwr_remove,
+	.driver		= {
+		.name	= "stm32_pwr",
+		.of_match_table = stm32_pwr_ids,
+		.pm = &stm32_pwr_pm,
+	},
+};
+
+static int __init stm32_pwr_init(void)
+{
+	return platform_driver_register(&stm32_pwr_driver);
+}
+
+static void __exit stm32_pwr_exit(void)
+{
+	return platform_driver_unregister(&stm32_pwr_driver);
+}
+
+arch_initcall(stm32_pwr_init);
+module_exit(stm32_pwr_exit);
diff --git a/drivers/mfd/stmfx.c b/drivers/mfd/stmfx.c
index e095a3930..b411d2958 100644
--- a/drivers/mfd/stmfx.c
+++ b/drivers/mfd/stmfx.c
@@ -81,13 +81,11 @@ static struct mfd_cell stmfx_cells[] = {
 		.num_resources = ARRAY_SIZE(stmfx_pinctrl_resources),
 	},
 	{
-		.of_compatible = "st,stmfx-0300-idd",
 		.name = "stmfx-idd",
 		.resources = stmfx_idd_resources,
 		.num_resources = ARRAY_SIZE(stmfx_idd_resources),
 	},
 	{
-		.of_compatible = "st,stmfx-0300-ts",
 		.name = "stmfx-ts",
 		.resources = stmfx_ts_resources,
 		.num_resources = ARRAY_SIZE(stmfx_ts_resources),
diff --git a/drivers/mfd/stpmic1.c b/drivers/mfd/stpmic1.c
index eb3da558c..40eef5d18 100644
--- a/drivers/mfd/stpmic1.c
+++ b/drivers/mfd/stpmic1.c
@@ -170,6 +170,9 @@ static int stpmic1_suspend(struct device *dev)
 
 	disable_irq(pmic_dev->irq);
 
+	if (device_may_wakeup(dev))
+		enable_irq_wake(pmic_dev->irq);
+
 	return 0;
 }
 
@@ -183,6 +186,9 @@ static int stpmic1_resume(struct device *dev)
 	if (ret)
 		return ret;
 
+	if (device_may_wakeup(dev))
+		disable_irq_wake(pmic_dev->irq);
+
 	enable_irq(pmic_dev->irq);
 
 	return 0;
diff --git a/drivers/mfd/wm8994-core.c b/drivers/mfd/wm8994-core.c
index 7b1d27072..e2c98c66b 100644
--- a/drivers/mfd/wm8994-core.c
+++ b/drivers/mfd/wm8994-core.c
@@ -185,6 +185,12 @@ static int wm8994_resume(struct device *dev)
 	if (!wm8994->suspended)
 		return 0;
 
+	/*
+	 * LDO1/2 minimum cycle time is 36ms according to codec specification
+	 * Wait before enabling regulator to make sure we fit this requirement
+	 */
+	msleep(40);
+
 	ret = regulator_bulk_enable(wm8994->num_supplies,
 				    wm8994->supplies);
 	if (ret != 0) {
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 0f5a49fc7..c8df7403f 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -435,6 +435,23 @@ config DW_XDATA_PCIE
 
 	  If unsure, say N.
 
+config STM32_OMM
+	bool "STM32 Octo Memory Manager"
+	depends on SPI_STM32_OSPI || TEST_COMPILE
+	help
+	  This driver manages the muxing between the 2 OSPI busses and
+	  the 2 output ports. There are 4 possible muxing configurations:
+	  - direct mode (no multiplexing): OSPI1 output is on port 1 and OSPI2
+	       output is on port 2
+	  - OSPI1 and OSPI2 are multiplexed over the same output port 1
+	  - swapped mode (no multiplexing), OSPI1 output is on port 2,
+	       OSPI2 output is on port 1
+	  - OSPI1 and OSPI2 are multiplexed over the same output port 2
+	  It also manages :
+	    - the split of the memory area shared between the 2 OSPI instances.
+	    - chip select selection override.
+	    - the time between 2 transactions in multiplexed mode.
+
 config PCI_ENDPOINT_TEST
 	depends on PCI
 	select CRC32
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index a086197af..57c78d991 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -59,3 +59,4 @@ obj-$(CONFIG_UACCE)		+= uacce/
 obj-$(CONFIG_XILINX_SDFEC)	+= xilinx_sdfec.o
 obj-$(CONFIG_HISI_HIKEY_USB)	+= hisi_hikey_usb.o
 obj-$(CONFIG_HI6421V600_IRQ)	+= hi6421v600-irq.o
+obj-$(CONFIG_STM32_OMM)	 	+= stm32_omm.o
diff --git a/drivers/misc/stm32_omm.c b/drivers/misc/stm32_omm.c
new file mode 100644
index 000000000..eabf0f3d0
--- /dev/null
+++ b/drivers/misc/stm32_omm.c
@@ -0,0 +1,516 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author(s): Patrice Chotard <patrice.chotard@foss.st.com> for STMicroelectronics.
+ */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/mfd/syscon.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <memory/stm32-omi.h>
+
+#define OMM_CR			0
+#define CR_MUXEN		BIT(0)
+#define CR_MUXENMODE_MASK	GENMASK(1, 0)
+#define CR_CSSEL_OVR_EN		BIT(4)
+#define CR_CSSEL_OVR_MASK	GENMASK(6, 5)
+#define CR_REQ2ACK_MASK		GENMASK(23, 16)
+
+#define OMM_CHILD_NB		2
+
+struct stm32_omm {
+	struct device *child_dev[OMM_CHILD_NB];
+	struct resource *mm_res;
+	struct clk *clk;
+	void __iomem *io_base;
+	u32 cr;
+	u8 nb_child;
+};
+
+static int stm32_omm_set_amcr(struct device *dev, bool set)
+{
+	struct stm32_omm *omm = dev_get_drvdata(dev);
+	struct regmap *syscfg_regmap;
+	struct device_node *node;
+	struct resource res, res1;
+	resource_size_t mm_ospi2_size = 0;
+	static const char * const mm_name[] = { "mm_ospi1", "mm_ospi2" };
+	u32 amcr_base, amcr_mask;
+	int ret, i, idx;
+	unsigned int amcr, read_amcr;
+
+	for (i = 0; i < 2; i++) {
+		idx = of_property_match_string(dev->of_node,
+					       "memory-region-names",
+					       mm_name[i]);
+		if (idx < 0)
+			continue;
+
+		node = of_parse_phandle(dev->of_node, "memory-region", idx);
+		ret = of_address_to_resource(node, 0, &res);
+		if (ret) {
+			dev_err(dev, "unable to resolve memory region\n");
+			return ret;
+		}
+
+		/* check that memory region fits inside OMM memory map area */
+		if (!resource_contains(omm->mm_res, &res)) {
+			dev_err(dev, "%s doesn't fit inside OMM memory map area\n",
+				mm_name[i]);
+			dev_err(dev, "[0x%llx-0x%llx] doesn't fit inside [0x%llx-0x%llx]\n",
+				res.start, res.end,
+				omm->mm_res->start, omm->mm_res->end);
+
+			return -EFAULT;
+		}
+
+		if (i == 1) {
+			mm_ospi2_size = resource_size(&res);
+
+			/* check that OMM memory region 1 doesn't overlap memory region 2 */
+			if (resource_overlaps(&res, &res1)) {
+				dev_err(dev, "OMM memory-region %s overlaps memory region %s\n",
+					mm_name[0], mm_name[1]);
+				dev_err(dev, "[0x%llx-0x%llx] overlaps [0x%llx-0x%llx]\n",
+					res1.start, res1.end, res.start, res.end);
+
+				return -EFAULT;
+			}
+		} else {
+			res1.start = res.start;
+			res1.end = res.end;
+		}
+	}
+
+	syscfg_regmap = syscon_regmap_lookup_by_phandle(dev->of_node, "st,syscfg-amcr");
+	if (IS_ERR(syscfg_regmap)) {
+		dev_err(dev, "Failed to get st,syscfg-amcr property\n");
+		return PTR_ERR(syscfg_regmap);
+	}
+
+	ret = of_property_read_u32_index(dev->of_node, "st,syscfg-amcr", 1,
+					 &amcr_base);
+	if (ret)
+		return ret;
+
+	ret = of_property_read_u32_index(dev->of_node, "st,syscfg-amcr", 2,
+					 &amcr_mask);
+	if (ret)
+		return ret;
+
+	amcr = mm_ospi2_size / SZ_64M;
+
+	if (set) {
+		ret = regmap_update_bits(syscfg_regmap, amcr_base, amcr_mask, amcr);
+		if (ret)
+			dev_err(dev, "Error updating AMCR bits (%d)\n", ret);
+
+		return ret;
+	}
+
+	/* read AMCR and check coherency with memory-map areas defined in DT */
+	regmap_read(syscfg_regmap, amcr_base, &read_amcr);
+	read_amcr = read_amcr >> (ffs(amcr_mask) - 1);
+
+	return amcr != read_amcr;
+}
+
+static int stm32_omm_configure(struct platform_device *pdev)
+{
+	struct stm32_omm *omm = platform_get_drvdata(pdev);
+	struct reset_control *rstc;
+	struct clk *child_clk;
+	struct device_node *child;
+	struct device *dev = &pdev->dev;
+	unsigned long clk_rate, clk_rate_max = 0;
+	int ret;
+	u32 mux = 0;
+	u32 cssel_ovr = 0;
+	u32 req2ack = 0;
+
+	omm->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(omm->clk)) {
+		dev_err(dev, "Failed to get OMM clock (%ld)\n",
+			PTR_ERR(omm->clk));
+
+		return PTR_ERR(omm->clk);
+	}
+
+	ret = clk_prepare_enable(omm->clk);
+	if (ret) {
+		dev_err(dev, "Failed to enable OMM clock (%d)\n", ret);
+		return ret;
+	}
+
+	/* parse children's clock */
+	for_each_available_child_of_node(dev->of_node, child) {
+		child_clk = of_clk_get(child, 0);
+
+		clk_rate = clk_get_rate(child_clk);
+		clk_put(child_clk);
+		if (!clk_rate) {
+			dev_err(dev, "Invalid clock rate\n");
+			of_node_put(child);
+			return -EINVAL;
+		}
+
+		if (clk_rate > clk_rate_max)
+			clk_rate_max = clk_rate;
+	}
+
+	rstc = devm_reset_control_get_optional(dev, NULL);
+	if (IS_ERR(rstc)) {
+		ret = dev_err_probe(dev, PTR_ERR(rstc), "reset get failed\n");
+		goto err_clk_disable;
+	}
+
+	reset_control_assert(rstc);
+	udelay(2);
+	reset_control_deassert(rstc);
+
+	omm->cr = readl_relaxed(omm->io_base + OMM_CR);
+	/* optional */
+	ret = of_property_read_u32(dev->of_node, "st,omm-mux", &mux);
+	if (!ret) {
+		if (mux & CR_MUXEN) {
+			ret = of_property_read_u32(dev->of_node, "st,omm-req2ack-ns",
+						  &req2ack);
+			if (!ret && !req2ack) {
+				req2ack = DIV_ROUND_UP(req2ack, NSEC_PER_SEC / clk_rate_max) - 1;
+
+				if (req2ack > 256)
+					req2ack = 256;
+			}
+
+			req2ack = FIELD_PREP(CR_REQ2ACK_MASK, req2ack);
+
+			omm->cr &= ~CR_REQ2ACK_MASK;
+			omm->cr |= FIELD_PREP(CR_REQ2ACK_MASK, req2ack);
+		}
+
+		omm->cr &= ~CR_MUXENMODE_MASK;
+		omm->cr |= FIELD_PREP(CR_MUXENMODE_MASK, mux);
+	}
+
+	/* optional */
+	ret = of_property_read_u32(dev->of_node, "st,omm-cssel-ovr", &cssel_ovr);
+	if (!ret) {
+		omm->cr &= ~CR_CSSEL_OVR_MASK;
+		omm->cr |= FIELD_PREP(CR_CSSEL_OVR_MASK, cssel_ovr);
+		omm->cr |= CR_CSSEL_OVR_EN;
+	}
+
+	writel_relaxed(omm->cr, omm->io_base + OMM_CR);
+
+	ret = stm32_omm_set_amcr(dev, true);
+
+err_clk_disable:
+	clk_disable_unprepare(omm->clk);
+
+	return ret;
+}
+
+/*
+ * Temporary implementation for stm32_get_access
+ * Currently it doesn't exist any specific driver/API to get IP
+ * access (RIFSC SECCFG bit)
+ * Will be removed when a RIFSC driver will be available
+ */
+static int stm32_get_access(struct device *dev, struct device_node *np)
+{
+	struct regmap *rifsc_regmap;
+	u32 index, seccfgr, cidcfgr, semcr;
+	int ret, bit, cid;
+
+	#define RIFSC_REG_SIZE		32
+	#define RIFSC_CID1		1
+	#define RIFSC_SECCFGR(x)	(((x) / RIFSC_REG_SIZE) * 0x4 + 0x10)
+	#define RIFSC_CIDCFGR(x)	((x) * 0x8 + 0x100)
+	#define RIFSC_SEMCR(x)		((x) * 0x8 + 0x104)
+
+	/* Register: RIFSC_CIDCFGR */
+	#define RIFSC_CIDCFGR_CFEN	BIT(0)
+	#define RIFSC_CIDCFGR_SEM_EN	BIT(1)
+	#define RIFSC_CIDCFGR_SCID	GENMASK(6, 4)
+	#define RIFSC_CIDCFGR_SEMWLC1	BIT(17)
+
+	/* Register: RIFSC_SEMCR */
+	#define RIFSC_SEMCR_SEM_MUTEX	BIT(0)
+	#define RIFSC_SEMCR_SEMCID	GENMASK(6, 4)
+
+	rifsc_regmap = syscon_regmap_lookup_by_phandle(np, "st,access");
+	if (IS_ERR(rifsc_regmap)) {
+		dev_err(dev, "Failed to find st,access property for node %s (%ld)\n",
+			np->full_name, PTR_ERR(rifsc_regmap));
+		return PTR_ERR(rifsc_regmap);
+	}
+
+	ret = of_property_read_u32_index(np, "st,access", 1, &index);
+	if (ret) {
+		dev_err(dev, "Failed to get st,access property value for node %s (%d)\n",
+			np->full_name, ret);
+		return ret;
+	}
+
+	bit = index % RIFSC_REG_SIZE;
+
+	ret = regmap_read(rifsc_regmap, RIFSC_SECCFGR(index), &seccfgr);
+	if (ret)
+		return ret;
+
+	if (seccfgr & BIT(bit)) {
+		dev_dbg(dev, "resource %d is configured as secure\n", index);
+		return -EACCES;
+	}
+
+	ret = regmap_read(rifsc_regmap, RIFSC_CIDCFGR(index), &cidcfgr);
+	if (ret)
+		return ret;
+
+	if (!(cidcfgr & RIFSC_CIDCFGR_CFEN))
+		/* CID filtering is turned off: access granted */
+		return 0;
+
+	if (!(cidcfgr & RIFSC_CIDCFGR_SEM_EN)) {
+		/* Static CID mode */
+		cid = FIELD_GET(RIFSC_CIDCFGR_SCID, cidcfgr);
+		if (cid != RIFSC_CID1) {
+			dev_dbg(dev, "static CID%d set for resource %d\n",
+				cid, index);
+			return -EACCES;
+		}
+
+		return 0;
+	}
+
+	/* Pass-list with semaphore mode */
+	if (!(cidcfgr & RIFSC_CIDCFGR_SEMWLC1)) {
+		dev_dbg(dev, "CID1 is block-listed for resource %d\n", index);
+		return -EACCES;
+	}
+
+	ret = regmap_read(rifsc_regmap, RIFSC_SEMCR(index), &semcr);
+	if (ret)
+		return ret;
+
+	if (!(semcr & RIFSC_SEMCR_SEM_MUTEX)) {
+		ret = regmap_update_bits(rifsc_regmap, RIFSC_SEMCR(index),
+					 RIFSC_SEMCR_SEM_MUTEX,
+					 RIFSC_SEMCR_SEM_MUTEX);
+		if (ret)
+			return ret;
+
+		ret = regmap_read(rifsc_regmap, RIFSC_SEMCR(index), &semcr);
+		if (ret)
+			return ret;
+	}
+
+	cid = FIELD_GET(RIFSC_SEMCR_SEMCID, semcr);
+	if (cid != RIFSC_CID1) {
+		dev_dbg(dev, "resource %d is already used by CID%d\n",
+			index, cid);
+		return -EACCES;
+	}
+
+	return 0;
+}
+
+static int stm32_omm_disable_child(struct device *dev, struct device_node *child)
+{
+	struct regmap *omi_regmap;
+	struct clk *clk;
+	int ret;
+
+	clk = of_clk_get(child, 0);
+	ret = clk_prepare_enable(clk);
+	if (ret) {
+		dev_err(dev, "Can not enable clock\n");
+		clk_put(clk);
+		return ret;
+	}
+
+	omi_regmap = device_node_to_regmap(child);
+	if (IS_ERR(omi_regmap)) {
+		dev_err(dev, "failed to get OMI regmap for %s (%ld)",
+			child->full_name, PTR_ERR(omi_regmap));
+		ret = PTR_ERR(omi_regmap);
+	} else {
+		ret = regmap_clear_bits(omi_regmap, OSPI_CR, CR_EN);
+	}
+
+	clk_disable_unprepare(clk);
+	clk_put(clk);
+
+	return ret;
+}
+
+static int stm32_omm_probe(struct platform_device *pdev)
+{
+	struct platform_device *vdev;
+	struct device *dev = &pdev->dev;
+	struct device_node *child;
+	struct device_node *child_node[OMM_CHILD_NB];
+	struct stm32_omm *omm;
+	struct resource *res;
+	int ret;
+	u8 child_access_granted = 0;
+	u8 i, j;
+	bool child_access[OMM_CHILD_NB];
+
+	omm = devm_kzalloc(&pdev->dev, sizeof(*omm), GFP_KERNEL);
+	if (!omm)
+		return -ENOMEM;
+
+	omm->nb_child = 0;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "omm");
+	omm->io_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(omm->io_base))
+		return PTR_ERR(omm->io_base);
+
+	omm->mm_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "omm_mm");
+
+	/* check child's access */
+	for_each_child_of_node(dev->of_node, child) {
+		if (omm->nb_child > OMM_CHILD_NB) {
+			dev_err(dev, "Bad DT, found too much children\n");
+			of_node_put(child);
+			return -E2BIG;
+		}
+
+		if (!of_device_is_compatible(child, "st,stm32mp25-omi")) {
+			of_node_put(child);
+			continue;
+		}
+
+		ret = stm32_get_access(dev, child);
+		if (ret < 0 && ret != -EACCES) {
+			of_node_put(child);
+			return ret;
+		}
+
+		child_access[omm->nb_child] = false;
+		if (!ret) {
+			child_access_granted++;
+			child_access[omm->nb_child] = true;
+		}
+
+		child_node[omm->nb_child] = child;
+		omm->nb_child++;
+	}
+
+	/* check if OMM's resource access is granted */
+	ret = stm32_get_access(dev, dev->of_node);
+	if (ret < 0 && ret != -EACCES)
+		return ret;
+
+	platform_set_drvdata(pdev, omm);
+
+	if (!ret) {
+		/* All child's access are granted ? */
+		if (child_access_granted == OMM_CHILD_NB) {
+			/* Ensure both OSPI instance are disabled before configuring OMM */
+			for (i = 0; i < omm->nb_child; i++) {
+				ret = stm32_omm_disable_child(dev, child_node[i]);
+				if (ret)
+					return ret;
+			}
+
+			ret = stm32_omm_configure(pdev);
+			if (ret)
+				return ret;
+		} else {
+			dev_dbg(dev, "Can't disable Octo Memory Manager's child\n");
+		}
+	} else {
+		dev_dbg(dev, "Octo Memory Manager resource's access not granted\n");
+		/*
+		 * AMCR can't be set, so check if current value is coherent
+		 * with memory-map areas defined in DT
+		 */
+		ret = stm32_omm_set_amcr(dev, false);
+		if (ret > 0) {
+			dev_err(dev, "AMCR value not coherent with DT memory-map areas\n");
+
+			return -EINVAL;
+		}
+	}
+
+	/* for each child, if resource access is granted and status "okay", probe it */
+	for (i = 0; i < omm->nb_child; i++) {
+		if (!child_access[i] || !of_device_is_available(child_node[i]))
+			continue;
+
+		vdev = of_platform_device_create(child_node[i], NULL, dev);
+		if (!vdev) {
+			dev_err(dev, "Failed to create Octo Memory Manager child\n");
+			for (j = i; j >= 0; --j)
+				of_platform_device_destroy(omm->child_dev[j], NULL);
+
+			return -EINVAL;
+		}
+		omm->child_dev[i] = &vdev->dev;
+	}
+
+	return 0;
+}
+
+static int stm32_omm_remove(struct platform_device *pdev)
+{
+	struct stm32_omm *omm = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < omm->nb_child; i++)
+		if (omm->child_dev[i])
+			of_platform_device_destroy(omm->child_dev[i], NULL);
+
+	return 0;
+}
+
+static const struct of_device_id stm32_omm_of_match[] = {
+	{ .compatible = "st,stm32mp25-omm", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, stm32_omm_of_match);
+
+static int __maybe_unused stm32_omm_suspend(struct device *dev)
+{
+	return pinctrl_pm_select_sleep_state(dev);
+}
+
+static int __maybe_unused stm32_omm_resume(struct device *dev)
+{
+	struct stm32_omm *omm = dev_get_drvdata(dev);
+
+	clk_prepare_enable(omm->clk);
+	pinctrl_pm_select_default_state(dev);
+	writel_relaxed(omm->cr, omm->io_base + OMM_CR);
+	clk_disable_unprepare(omm->clk);
+
+	return 0;
+}
+
+static const struct dev_pm_ops stm32_omm_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(stm32_omm_suspend, stm32_omm_resume)
+};
+
+static struct platform_driver stm32_omm_driver = {
+	.probe	= stm32_omm_probe,
+	.remove = stm32_omm_remove,
+	.driver	= {
+		.name = "stm32-omm",
+		.of_match_table = stm32_omm_of_match,
+		.pm = &stm32_omm_pm_ops,
+	},
+};
+module_platform_driver(stm32_omm_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics Octo Memory Manager driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mmc/host/mmci.c b/drivers/mmc/host/mmci.c
index 3765e2f4a..35c8dde0d 100644
--- a/drivers/mmc/host/mmci.c
+++ b/drivers/mmc/host/mmci.c
@@ -270,6 +270,7 @@ static struct variant_data variant_stm32_sdmmc = {
 	.datactrl_any_blocksz	= true,
 	.datactrl_mask_sdio	= MCI_DPSM_ST_SDIOEN,
 	.stm32_idmabsize_mask	= GENMASK(12, 5),
+	.stm32_idmabsize_align	= BIT(5),
 	.busy_timeout		= true,
 	.busy_detect		= true,
 	.busy_detect_flag	= MCI_STM32_BUSYD0,
@@ -280,7 +281,7 @@ static struct variant_data variant_stm32_sdmmc = {
 static struct variant_data variant_stm32_sdmmcv2 = {
 	.fifosize		= 16 * 4,
 	.fifohalfsize		= 8 * 4,
-	.f_max			= 208000000,
+	.f_max			= 267000000,
 	.stm32_clkdiv		= true,
 	.cmdreg_cpsm_enable	= MCI_CPSM_STM32_ENABLE,
 	.cmdreg_lrsp_crc	= MCI_CPSM_STM32_LRSP_CRC,
@@ -296,6 +297,35 @@ static struct variant_data variant_stm32_sdmmcv2 = {
 	.datactrl_any_blocksz	= true,
 	.datactrl_mask_sdio	= MCI_DPSM_ST_SDIOEN,
 	.stm32_idmabsize_mask	= GENMASK(16, 5),
+	.stm32_idmabsize_align	= BIT(5),
+	.dma_lli		= true,
+	.busy_timeout		= true,
+	.busy_detect		= true,
+	.busy_detect_flag	= MCI_STM32_BUSYD0,
+	.busy_detect_mask	= MCI_STM32_BUSYD0ENDMASK,
+	.init			= sdmmc_variant_init,
+};
+
+static struct variant_data variant_stm32_sdmmcv3 = {
+	.fifosize		= 256 * 4,
+	.fifohalfsize		= 128 * 4,
+	.f_max			= 267000000,
+	.stm32_clkdiv		= true,
+	.cmdreg_cpsm_enable	= MCI_CPSM_STM32_ENABLE,
+	.cmdreg_lrsp_crc	= MCI_CPSM_STM32_LRSP_CRC,
+	.cmdreg_srsp_crc	= MCI_CPSM_STM32_SRSP_CRC,
+	.cmdreg_srsp		= MCI_CPSM_STM32_SRSP,
+	.cmdreg_stop		= MCI_CPSM_STM32_CMDSTOP,
+	.data_cmd_enable	= MCI_CPSM_STM32_CMDTRANS,
+	.irq_pio_mask		= MCI_IRQ_PIO_STM32_MASK,
+	.datactrl_first		= true,
+	.datacnt_useless	= true,
+	.datalength_bits	= 25,
+	.datactrl_blocksz	= 14,
+	.datactrl_any_blocksz	= true,
+	.datactrl_mask_sdio	= MCI_DPSM_ST_SDIOEN,
+	.stm32_idmabsize_mask	= GENMASK(16, 6),
+	.stm32_idmabsize_align	= BIT(6),
 	.dma_lli		= true,
 	.busy_timeout		= true,
 	.busy_detect		= true,
@@ -2431,6 +2461,16 @@ static const struct amba_id mmci_ids[] = {
 		.mask	= 0xf0ffffff,
 		.data	= &variant_stm32_sdmmcv2,
 	},
+	{
+		.id     = 0x20253180,
+		.mask	= 0xf0ffffff,
+		.data	= &variant_stm32_sdmmcv2,
+	},
+	{
+		.id     = 0x00353180,
+		.mask	= 0xf0ffffff,
+		.data	= &variant_stm32_sdmmcv3,
+	},
 	/* Qualcomm variants */
 	{
 		.id     = 0x00051180,
diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index e1a9b96a3..d9a2589f7 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -218,6 +218,11 @@
 #define MCI_STM32_BUSYD0ENDMASK	BIT(21)
 
 #define MMCIMASK1		0x040
+
+/* STM32 sdmmc data FIFO threshold register */
+#define MMCI_STM32_FIFOTHRR	0x044
+#define MMCI_STM32_THR_MASK	GENMASK(3, 0)
+
 #define MMCIFIFOCNT		0x048
 #define MMCIFIFO		0x080 /* to 0x0bc */
 
@@ -227,8 +232,6 @@
 #define MMCI_STM32_IDMALLIEN	BIT(1)
 
 #define MMCI_STM32_IDMABSIZER		0x054
-#define MMCI_STM32_IDMABNDT_SHIFT	5
-#define MMCI_STM32_IDMABNDT_MASK	GENMASK(12, 5)
 
 #define MMCI_STM32_IDMABASE0R	0x058
 
@@ -361,6 +364,7 @@ struct variant_data {
 	u32			opendrain;
 	u8			dma_lli:1;
 	u32			stm32_idmabsize_mask;
+	u32			stm32_idmabsize_align;
 	void (*init)(struct mmci_host *host);
 };
 
diff --git a/drivers/mmc/host/mmci_stm32_sdmmc.c b/drivers/mmc/host/mmci_stm32_sdmmc.c
index 4cceb9bab..94805924a 100644
--- a/drivers/mmc/host/mmci_stm32_sdmmc.c
+++ b/drivers/mmc/host/mmci_stm32_sdmmc.c
@@ -15,7 +15,6 @@
 #include "mmci.h"
 
 #define SDMMC_LLI_BUF_LEN	PAGE_SIZE
-#define SDMMC_IDMA_BURST	BIT(MMCI_STM32_IDMABNDT_SHIFT)
 
 #define DLYB_CR			0x0
 #define DLYB_CR_DEN		BIT(0)
@@ -34,6 +33,20 @@
 #define DLYB_LNG_TIMEOUT_US	1000
 #define SDMMC_VSWEND_TIMEOUT_US 10000
 
+#define SYSCFG_DLYBSD_CR	0x0
+#define DLYBSD_CR_EN		BIT(0)
+#define DLYBSD_CR_RXTAPSEL_MASK	GENMASK(6, 1)
+#define DLYBSD_TAPSEL_NB	32
+#define DLYBSD_BYP_EN		BIT(16)
+#define DLYBSD_BYP_CMD		GENMASK(21, 17)
+#define DLYBSD_ANTIGLITCH_EN	BIT(22)
+
+#define SYSCFG_DLYBSD_SR	0x4
+#define DLYBSD_SR_LOCK		BIT(0)
+#define DLYBSD_SR_RXTAPSEL_ACK	BIT(1)
+
+#define DLYBSD_TIMEOUT_1S_IN_US	1000000
+
 struct sdmmc_lli_desc {
 	u32 idmalar;
 	u32 idmabase;
@@ -43,17 +56,33 @@ struct sdmmc_lli_desc {
 struct sdmmc_idma {
 	dma_addr_t sg_dma;
 	void *sg_cpu;
+	dma_addr_t bounce_dma_addr;
+	void *bounce_buf;
+	bool use_bounce_buffer;
+};
+
+struct sdmmc_dlyb;
+
+struct sdmmc_tuning_ops {
+	int (*dlyb_enable)(struct sdmmc_dlyb *dlyb);
+	void (*set_input_ck)(struct sdmmc_dlyb *dlyb);
+	int (*tuning_prepare)(struct mmci_host *host);
+	int (*set_cfg)(struct sdmmc_dlyb *dlyb, int unit __maybe_unused,
+		       int phase, bool sampler __maybe_unused);
 };
 
 struct sdmmc_dlyb {
 	void __iomem *base;
 	u32 unit;
 	u32 max;
+	struct sdmmc_tuning_ops *ops;
 };
 
 static int sdmmc_idma_validate_data(struct mmci_host *host,
 				    struct mmc_data *data)
 {
+	struct sdmmc_idma *idma = host->dma_priv;
+	struct device *dev = mmc_dev(host->mmc);
 	struct scatterlist *sg;
 	int i;
 
@@ -61,41 +90,70 @@ static int sdmmc_idma_validate_data(struct mmci_host *host,
 	 * idma has constraints on idmabase & idmasize for each element
 	 * excepted the last element which has no constraint on idmasize
 	 */
+	idma->use_bounce_buffer = false;
 	for_each_sg(data->sg, sg, data->sg_len - 1, i) {
 		if (!IS_ALIGNED(sg->offset, sizeof(u32)) ||
-		    !IS_ALIGNED(sg->length, SDMMC_IDMA_BURST)) {
-			dev_err(mmc_dev(host->mmc),
+		    !IS_ALIGNED(sg->length,
+				host->variant->stm32_idmabsize_align)) {
+			dev_dbg(mmc_dev(host->mmc),
 				"unaligned scatterlist: ofst:%x length:%d\n",
 				data->sg->offset, data->sg->length);
-			return -EINVAL;
+			goto use_bounce_buffer;
 		}
 	}
 
 	if (!IS_ALIGNED(sg->offset, sizeof(u32))) {
-		dev_err(mmc_dev(host->mmc),
+		dev_dbg(mmc_dev(host->mmc),
 			"unaligned last scatterlist: ofst:%x length:%d\n",
 			data->sg->offset, data->sg->length);
-		return -EINVAL;
+		goto use_bounce_buffer;
 	}
 
+	return 0;
+
+use_bounce_buffer:
+	if (!idma->bounce_buf) {
+		idma->bounce_buf = dmam_alloc_coherent(dev,
+						       host->mmc->max_req_size,
+						       &idma->bounce_dma_addr,
+						       GFP_KERNEL);
+		if (!idma->bounce_buf) {
+			dev_err(dev, "Unable to map allocate DMA bounce buffer.\n");
+			return -ENOMEM;
+		}
+	}
+
+	idma->use_bounce_buffer = true;
+
 	return 0;
 }
 
 static int _sdmmc_idma_prep_data(struct mmci_host *host,
 				 struct mmc_data *data)
 {
-	int n_elem;
+	struct sdmmc_idma *idma = host->dma_priv;
 
-	n_elem = dma_map_sg(mmc_dev(host->mmc),
-			    data->sg,
-			    data->sg_len,
-			    mmc_get_dma_dir(data));
+	if (idma->use_bounce_buffer) {
+		if (data->flags & MMC_DATA_WRITE) {
+			unsigned int xfer_bytes = data->blksz * data->blocks;
 
-	if (!n_elem) {
-		dev_err(mmc_dev(host->mmc), "dma_map_sg failed\n");
-		return -EINVAL;
-	}
+			sg_copy_to_buffer(data->sg, data->sg_len,
+					  idma->bounce_buf, xfer_bytes);
+			dma_wmb();
+		}
+	} else {
+		int n_elem;
+
+		n_elem = dma_map_sg(mmc_dev(host->mmc),
+				    data->sg,
+				    data->sg_len,
+				    mmc_get_dma_dir(data));
 
+		if (!n_elem) {
+			dev_err(mmc_dev(host->mmc), "dma_map_sg failed\n");
+			return -EINVAL;
+		}
+	}
 	return 0;
 }
 
@@ -112,8 +170,19 @@ static int sdmmc_idma_prep_data(struct mmci_host *host,
 static void sdmmc_idma_unprep_data(struct mmci_host *host,
 				   struct mmc_data *data, int err)
 {
-	dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
-		     mmc_get_dma_dir(data));
+	struct sdmmc_idma *idma = host->dma_priv;
+
+	if (idma->use_bounce_buffer) {
+		if (data->flags & MMC_DATA_READ) {
+			unsigned int xfer_bytes = data->blksz * data->blocks;
+
+			sg_copy_from_buffer(data->sg, data->sg_len,
+					    idma->bounce_buf, xfer_bytes);
+		}
+	} else {
+		dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
+			     mmc_get_dma_dir(data));
+	}
 }
 
 static int sdmmc_idma_setup(struct mmci_host *host)
@@ -137,6 +206,8 @@ static int sdmmc_idma_setup(struct mmci_host *host)
 		host->mmc->max_segs = SDMMC_LLI_BUF_LEN /
 			sizeof(struct sdmmc_lli_desc);
 		host->mmc->max_seg_size = host->variant->stm32_idmabsize_mask;
+
+		host->mmc->max_req_size = SZ_1M;
 	} else {
 		host->mmc->max_segs = 1;
 		host->mmc->max_seg_size = host->mmc->max_req_size;
@@ -154,8 +225,16 @@ static int sdmmc_idma_start(struct mmci_host *host, unsigned int *datactrl)
 	struct scatterlist *sg;
 	int i;
 
-	if (!host->variant->dma_lli || data->sg_len == 1) {
-		writel_relaxed(sg_dma_address(data->sg),
+	if (!host->variant->dma_lli || data->sg_len == 1 ||
+	    idma->use_bounce_buffer) {
+		u32 dma_addr;
+
+		if (idma->use_bounce_buffer)
+			dma_addr = idma->bounce_dma_addr;
+		else
+			dma_addr = sg_dma_address(data->sg);
+
+		writel_relaxed(dma_addr,
 			       host->base + MMCI_STM32_IDMABASE0R);
 		writel_relaxed(MMCI_STM32_IDMAEN,
 			       host->base + MMCI_STM32_IDMACTRLR);
@@ -239,22 +318,13 @@ static void mmci_sdmmc_set_clkreg(struct mmci_host *host, unsigned int desired)
 	clk |= host->clk_reg_add;
 	clk |= ddr;
 
-	/*
-	 * SDMMC_FBCK is selected when an external Delay Block is needed
-	 * with SDR104.
-	 */
-	if (host->mmc->ios.timing >= MMC_TIMING_UHS_SDR50) {
+	if (host->mmc->ios.timing >= MMC_TIMING_UHS_SDR50)
 		clk |= MCI_STM32_CLK_BUSSPEED;
-		if (host->mmc->ios.timing == MMC_TIMING_UHS_SDR104) {
-			clk &= ~MCI_STM32_CLK_SEL_MSK;
-			clk |= MCI_STM32_CLK_SELFBCK;
-		}
-	}
 
 	mmci_write_clkreg(host, clk);
 }
 
-static void sdmmc_dlyb_input_ck(struct sdmmc_dlyb *dlyb)
+static void sdmmc_dlyb_mp15_input_ck(struct sdmmc_dlyb *dlyb)
 {
 	if (!dlyb || !dlyb->base)
 		return;
@@ -271,7 +341,8 @@ static void mmci_sdmmc_set_pwrreg(struct mmci_host *host, unsigned int pwr)
 	/* adds OF options */
 	pwr = host->pwr_reg_add;
 
-	sdmmc_dlyb_input_ck(dlyb);
+	if (dlyb && dlyb->ops->set_input_ck)
+		dlyb->ops->set_input_ck(dlyb);
 
 	if (ios.power_mode == MMC_POWER_OFF) {
 		/* Only a reset could power-off sdmmc */
@@ -316,6 +387,18 @@ static u32 sdmmc_get_dctrl_cfg(struct mmci_host *host)
 
 	datactrl = mmci_dctrl_blksz(host);
 
+	if (host->hw_revision >= 3) {
+		u32 thr = 0;
+
+		if (host->mmc->ios.timing >= MMC_TIMING_UHS_SDR50) {
+			thr = ffs(min_t(unsigned int, host->data->blksz,
+					host->variant->fifosize));
+			thr = min_t(u32, thr, MMCI_STM32_THR_MASK);
+		}
+
+		writel_relaxed(thr, host->base + MMCI_STM32_FIFOTHRR);
+	}
+
 	if (host->mmc->card && mmc_card_sdio(host->mmc->card) &&
 	    host->data->blocks == 1)
 		datactrl |= MCI_DPSM_STM32_MODE_SDIO;
@@ -368,8 +451,15 @@ static bool sdmmc_busy_complete(struct mmci_host *host, u32 status, u32 err_msk)
 	return true;
 }
 
-static void sdmmc_dlyb_set_cfgr(struct sdmmc_dlyb *dlyb,
-				int unit, int phase, bool sampler)
+static int sdmmc_dlyb_mp15_enable(struct sdmmc_dlyb *dlyb)
+{
+	writel_relaxed(DLYB_CR_DEN, dlyb->base + DLYB_CR);
+
+	return 0;
+}
+
+static int sdmmc_dlyb_mp15_set_cfg(struct sdmmc_dlyb *dlyb,
+				   int unit, int phase, bool sampler)
 {
 	u32 cfgr;
 
@@ -381,16 +471,18 @@ static void sdmmc_dlyb_set_cfgr(struct sdmmc_dlyb *dlyb,
 
 	if (!sampler)
 		writel_relaxed(DLYB_CR_DEN, dlyb->base + DLYB_CR);
+
+	return 0;
 }
 
-static int sdmmc_dlyb_lng_tuning(struct mmci_host *host)
+static int sdmmc_dlyb_mp15_prepare(struct mmci_host *host)
 {
 	struct sdmmc_dlyb *dlyb = host->variant_priv;
 	u32 cfgr;
 	int i, lng, ret;
 
 	for (i = 0; i <= DLYB_CFGR_UNIT_MAX; i++) {
-		sdmmc_dlyb_set_cfgr(dlyb, i, DLYB_CFGR_SEL_MAX, true);
+		dlyb->ops->set_cfg(dlyb, i, DLYB_CFGR_SEL_MAX, true);
 
 		ret = readl_relaxed_poll_timeout(dlyb->base + DLYB_CFGR, cfgr,
 						 (cfgr & DLYB_CFGR_LNGF),
@@ -416,14 +508,58 @@ static int sdmmc_dlyb_lng_tuning(struct mmci_host *host)
 	return 0;
 }
 
+static int sdmmc_dlyb_mp25_enable(struct sdmmc_dlyb *dlyb)
+{
+	u32 cr, sr;
+
+	cr = readl_relaxed(dlyb->base + SYSCFG_DLYBSD_CR);
+	cr |= DLYBSD_CR_EN;
+
+	writel_relaxed(cr, dlyb->base + SYSCFG_DLYBSD_CR);
+
+	return readl_relaxed_poll_timeout(dlyb->base + SYSCFG_DLYBSD_SR,
+					   sr, sr & DLYBSD_SR_LOCK, 1,
+					   DLYBSD_TIMEOUT_1S_IN_US);
+}
+
+static int sdmmc_dlyb_mp25_set_cfg(struct sdmmc_dlyb *dlyb,
+				   int unit __maybe_unused, int phase,
+				   bool sampler __maybe_unused)
+{
+	u32 cr, sr;
+
+	cr = readl_relaxed(dlyb->base + SYSCFG_DLYBSD_CR);
+	cr &= ~DLYBSD_CR_RXTAPSEL_MASK;
+	cr |= FIELD_PREP(DLYBSD_CR_RXTAPSEL_MASK, phase);
+
+	writel_relaxed(cr, dlyb->base + SYSCFG_DLYBSD_CR);
+
+	return readl_relaxed_poll_timeout(dlyb->base + SYSCFG_DLYBSD_SR,
+					  sr, sr & DLYBSD_SR_RXTAPSEL_ACK, 1,
+					  DLYBSD_TIMEOUT_1S_IN_US);
+}
+
+static int sdmmc_dlyb_mp25_prepare(struct mmci_host *host)
+{
+	struct sdmmc_dlyb *dlyb = host->variant_priv;
+
+	dlyb->max = DLYBSD_TAPSEL_NB;
+
+	return 0;
+}
+
 static int sdmmc_dlyb_phase_tuning(struct mmci_host *host, u32 opcode)
 {
 	struct sdmmc_dlyb *dlyb = host->variant_priv;
 	int cur_len = 0, max_len = 0, end_of_len = 0;
-	int phase;
+	int phase, ret;
 
 	for (phase = 0; phase <= dlyb->max; phase++) {
-		sdmmc_dlyb_set_cfgr(dlyb, dlyb->unit, phase, false);
+		ret = dlyb->ops->set_cfg(dlyb, dlyb->unit, phase, false);
+		if (ret) {
+			dev_err(mmc_dev(host->mmc), "tuning config failed\n");
+			return ret;
+		}
 
 		if (mmc_send_tuning(host->mmc, opcode, NULL)) {
 			cur_len = 0;
@@ -441,10 +577,15 @@ static int sdmmc_dlyb_phase_tuning(struct mmci_host *host, u32 opcode)
 		return -EINVAL;
 	}
 
-	writel_relaxed(0, dlyb->base + DLYB_CR);
+	if (dlyb->ops->set_input_ck)
+		dlyb->ops->set_input_ck(dlyb);
 
 	phase = end_of_len - max_len / 2;
-	sdmmc_dlyb_set_cfgr(dlyb, dlyb->unit, phase, false);
+	ret = dlyb->ops->set_cfg(dlyb, dlyb->unit, phase, false);
+	if (ret) {
+		dev_err(mmc_dev(host->mmc), "tuning reconfig failed\n");
+		return ret;
+	}
 
 	dev_dbg(mmc_dev(host->mmc), "unit:%d max_dly:%d phase:%d\n",
 		dlyb->unit, dlyb->max, phase);
@@ -456,12 +597,32 @@ static int sdmmc_execute_tuning(struct mmc_host *mmc, u32 opcode)
 {
 	struct mmci_host *host = mmc_priv(mmc);
 	struct sdmmc_dlyb *dlyb = host->variant_priv;
+	u32 clk;
+	int ret;
+
+	if (host->mmc->ios.timing != MMC_TIMING_UHS_SDR104 &&
+	    host->mmc->ios.timing != MMC_TIMING_MMC_HS200)
+		return 0;
 
 	if (!dlyb || !dlyb->base)
 		return -EINVAL;
 
-	if (sdmmc_dlyb_lng_tuning(host))
-		return -EINVAL;
+	ret = dlyb->ops->dlyb_enable(dlyb);
+	if (ret)
+		return ret;
+
+	/*
+	 * SDMMC_FBCK is selected when an external Delay Block is needed
+	 * with SDR104 or HS200.
+	 */
+	clk = host->clk_reg;
+	clk &= ~MCI_STM32_CLK_SEL_MSK;
+	clk |= MCI_STM32_CLK_SELFBCK;
+	mmci_write_clkreg(host, clk);
+
+	ret = dlyb->ops->tuning_prepare(host);
+	if (ret)
+		return ret;
 
 	return sdmmc_dlyb_phase_tuning(host, opcode);
 }
@@ -519,6 +680,19 @@ static struct mmci_host_ops sdmmc_variant_ops = {
 	.post_sig_volt_switch = sdmmc_post_sig_volt_switch,
 };
 
+static struct sdmmc_tuning_ops dlyb_tuning_mp15_ops = {
+	.dlyb_enable = sdmmc_dlyb_mp15_enable,
+	.set_input_ck = sdmmc_dlyb_mp15_input_ck,
+	.tuning_prepare = sdmmc_dlyb_mp15_prepare,
+	.set_cfg = sdmmc_dlyb_mp15_set_cfg,
+};
+
+static struct sdmmc_tuning_ops dlyb_tuning_mp25_ops = {
+	.dlyb_enable = sdmmc_dlyb_mp25_enable,
+	.tuning_prepare = sdmmc_dlyb_mp25_prepare,
+	.set_cfg = sdmmc_dlyb_mp25_set_cfg,
+};
+
 void sdmmc_variant_init(struct mmci_host *host)
 {
 	struct device_node *np = host->mmc->parent->of_node;
@@ -537,6 +711,11 @@ void sdmmc_variant_init(struct mmci_host *host)
 		return;
 
 	dlyb->base = base_dlyb;
+	if (of_device_is_compatible(np, "st,stm32mp25-sdmmc2"))
+		dlyb->ops = &dlyb_tuning_mp25_ops;
+	else
+		dlyb->ops = &dlyb_tuning_mp15_ops;
+
 	host->variant_priv = dlyb;
 	host->mmc_ops->execute_tuning = sdmmc_execute_tuning;
 }
diff --git a/drivers/mtd/hyperbus/Kconfig b/drivers/mtd/hyperbus/Kconfig
index 46c7e407e..faaae0cbe 100644
--- a/drivers/mtd/hyperbus/Kconfig
+++ b/drivers/mtd/hyperbus/Kconfig
@@ -29,4 +29,10 @@ config RPCIF_HYPERBUS
 	help
 	  This option includes Renesas RPC-IF HyperBus support.
 
+config STM32_HYPERBUS
+	tristate "STM32 HyperBus driver"
+	depends on STM32_OMI || COMPILE_TEST
+	help
+	 This is the driver for HyperBus controller on STM32 MP2 SoC family.
+
 endif # MTD_HYPERBUS
diff --git a/drivers/mtd/hyperbus/Makefile b/drivers/mtd/hyperbus/Makefile
index 5fc2b5124..c2091e4c4 100644
--- a/drivers/mtd/hyperbus/Makefile
+++ b/drivers/mtd/hyperbus/Makefile
@@ -3,3 +3,5 @@
 obj-$(CONFIG_MTD_HYPERBUS)	+= hyperbus-core.o
 obj-$(CONFIG_HBMC_AM654)	+= hbmc-am654.o
 obj-$(CONFIG_RPCIF_HYPERBUS)	+= rpc-if.o
+obj-$(CONFIG_STM32_HYPERBUS)	+= hyperbus-stm32.o
+
diff --git a/drivers/mtd/hyperbus/hyperbus-stm32.c b/drivers/mtd/hyperbus/hyperbus-stm32.c
new file mode 100644
index 000000000..961bee927
--- /dev/null
+++ b/drivers/mtd/hyperbus/hyperbus-stm32.c
@@ -0,0 +1,434 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ * Author(s): Patrice Chotard <patrice.chotard@st.com> for STMicroelectronics.
+ */
+
+#include <linux/mtd/cfi.h>
+#include <memory/stm32-omi.h>
+
+struct stm32_hyperbus {
+	struct device *dev;
+	struct hyperbus_ctlr ctlr;
+	struct hyperbus_device hbdev;
+	struct stm32_omi omi;
+	u32 flash_freq;		/* flash max supported frequency */
+	u32 real_flash_freq;	/* real flash freq = bus_freq x prescaler */
+	u32 tacc;
+	u32 cs;
+	bool wzl;
+};
+
+static int stm32_hyperbus_dma_read(struct stm32_hyperbus *hyperbus, void *to,
+				   unsigned long from, ssize_t len)
+{
+	struct stm32_omi *omi = &hyperbus->omi;
+	enum dma_ctrl_flags flags = DMA_PREP_INTERRUPT;
+	struct dma_chan *dma_chrx = omi->dma_chrx;
+	struct dma_async_tx_descriptor *rx;
+	dma_addr_t dma_dst, dma_src;
+	dma_cookie_t cookie;
+	int ret;
+
+	if (!omi->dma_chrx || !virt_addr_valid(to) || object_is_on_stack(to))
+		return -EINVAL;
+
+	dma_dst = dma_map_single(dma_chrx->device->dev, to, len, DMA_FROM_DEVICE);
+	if (dma_mapping_error(dma_chrx->device->dev, dma_dst)) {
+		dev_err(hyperbus->dev, "DMA mapping failed\n");
+		return -EIO;
+	}
+
+	dma_src = omi->mm_phys_base + from;
+
+	dev_dbg(hyperbus->dev, "%s: read 0x%lx bytes @ 0x%llx\n",
+		__func__, len, dma_src);
+
+	rx = dmaengine_prep_dma_memcpy(dma_chrx, dma_dst, dma_src, len, flags);
+	if (!rx) {
+		dev_err(hyperbus->dev, "dmaengine_prep_dma_memcpy error\n");
+		ret = -EIO;
+		goto unmap_dma;
+	}
+
+	reinit_completion(&omi->dma_completion);
+	rx->callback = stm32_omi_dma_callback;
+	rx->callback_param = &omi->dma_completion;
+	cookie = dmaengine_submit(rx);
+
+	ret = dma_submit_error(cookie);
+	if (ret) {
+		dev_err(hyperbus->dev, "dma_submit_error %d\n", cookie);
+		goto unmap_dma;
+	}
+
+	dma_async_issue_pending(dma_chrx);
+	if (!wait_for_completion_timeout(&omi->dma_completion,
+					 msecs_to_jiffies(len + STM32_COMP_TIMEOUT_MS))) {
+		dmaengine_terminate_sync(dma_chrx);
+		dev_err(hyperbus->dev, "DMA wait_for_completion_timeout\n");
+		ret = -ETIMEDOUT;
+	}
+
+unmap_dma:
+	dma_unmap_single(dma_chrx->device->dev, dma_dst, len, DMA_FROM_DEVICE);
+
+	return ret;
+}
+
+static void stm32_hyperbus_copy_from(struct hyperbus_device *hbdev, void *to,
+				     unsigned long from, ssize_t len)
+{
+	struct stm32_hyperbus *hyperbus =
+		container_of(hbdev, struct stm32_hyperbus, hbdev);
+	void __iomem *mm_base = hyperbus->omi.mm_base;
+
+	/* TODO: adjust the len threshold */
+	if (len < SZ_1K || stm32_hyperbus_dma_read(hyperbus, to, from, len))
+		memcpy_fromio(to, mm_base + from, len);
+}
+
+static void stm32_hyperbus_set_mode(struct stm32_hyperbus *hyperbus, u8 mode)
+{
+	struct stm32_omi *omi = &hyperbus->omi;
+	void __iomem *regs_base = omi->regs_base;
+	u32 cr;
+
+	if (omi->fmode == mode)
+		return;
+
+	if (omi->fmode == CR_FMODE_MM)
+		stm32_omi_abort(omi);
+
+	cr = readl_relaxed(regs_base + OSPI_CR);
+	cr &= ~CR_FMODE_MASK;
+	cr |= FIELD_PREP(CR_FMODE_MASK, mode);
+	writel_relaxed(cr, regs_base + OSPI_CR);
+	omi->fmode = mode;
+}
+
+static u16 stm32_hyperbus_read16(struct hyperbus_device *hbdev, unsigned long addr)
+{
+	struct stm32_hyperbus *hyperbus =
+		container_of(hbdev, struct stm32_hyperbus, hbdev);
+	void __iomem *regs_base = hyperbus->omi.regs_base;
+	u16 data;
+
+	stm32_hyperbus_set_mode(hyperbus, CR_FMODE_INDR);
+	writel(addr, regs_base + OSPI_AR);
+	stm32_omi_tx_poll(&hyperbus->omi, (u8 *)&data, 2, true);
+
+	/* Wait end of tx in indirect mode */
+	stm32_omi_wait_cmd(&hyperbus->omi);
+
+	dev_dbg(hyperbus->dev, "%s: read 0x%x @ 0x%lx\n",
+		__func__, data, addr >> 1);
+
+	stm32_hyperbus_set_mode(hyperbus, CR_FMODE_MM);
+
+	return data;
+}
+
+static void stm32_hyperbus_write16(struct hyperbus_device *hbdev,
+				  unsigned long addr, u16 data)
+{
+	struct stm32_hyperbus *hyperbus =
+		container_of(hbdev, struct stm32_hyperbus, hbdev);
+	void __iomem *regs_base = hyperbus->omi.regs_base;
+
+	stm32_hyperbus_set_mode(hyperbus, CR_FMODE_INDW);
+	writel(addr, regs_base + OSPI_AR);
+	stm32_omi_tx_poll(&hyperbus->omi, (u8 *)&data, 2, false);
+
+	/* Wait end of tx in indirect mode */
+	stm32_omi_wait_cmd(&hyperbus->omi);
+
+	dev_dbg(hyperbus->dev, "%s: write 0x%x @ 0x%lx\n",
+		__func__, data, addr >> 1);
+
+	stm32_hyperbus_set_mode(hyperbus, CR_FMODE_MM);
+}
+
+static int stm32_hyperbus_check_transfert(struct stm32_omi *omi)
+{
+	struct stm32_hyperbus *hyperbus =
+		container_of(omi, struct stm32_hyperbus, omi);
+	struct map_info *map = &hyperbus->hbdev.map;
+	struct cfi_private cfi;
+	int ret;
+
+	cfi.interleave = 1;
+	cfi.device_type = CFI_DEVICETYPE_X16;
+
+	ret = cfi_qry_mode_on(0, map, &cfi);
+	cfi_qry_mode_off(0, map, &cfi);
+
+	return !ret;
+}
+
+static int stm32_hyperbus_calibrate(struct hyperbus_device *hbdev)
+{
+	struct stm32_hyperbus *hyperbus =
+		container_of(hbdev, struct stm32_hyperbus, hbdev);
+	struct stm32_omi *omi = &hyperbus->omi;
+	void __iomem *regs_base = omi->regs_base;
+	u32 prescaler;
+	u16 period_ps = 0;
+	int ret;
+	int calibrated = 1;
+	bool bypass_mode = false;
+
+	prescaler = FIELD_GET(DCR2_PRESC_MASK,
+			      readl(regs_base + OSPI_DCR2));
+	if (prescaler)
+		writel_relaxed(TCR_DHQC, regs_base + OSPI_TCR);
+
+	if (hyperbus->real_flash_freq < STM32_DLYB_FREQ_THRESHOLD) {
+		bypass_mode = true;
+		period_ps = NSEC_PER_SEC / (hyperbus->real_flash_freq / 1000);
+	}
+
+	ret = stm32_omi_dlyb_configure(omi, bypass_mode, period_ps);
+	if (ret) {
+		dev_err(hyperbus->dev, "Can't enable delay block\n");
+		return ret ? !calibrated : calibrated;
+	}
+
+	ret = stm32_omi_dlyb_configure(omi, bypass_mode, period_ps);
+	if (ret)
+		return (ret ? calibrated : !calibrated);
+
+	if (bypass_mode || prescaler)
+		/* perform only RX TAP selection */
+		ret = stm32_omi_dlyb_find_tap(omi, true);
+	else
+		/* perform RX/TX TAP selection */
+		ret = stm32_omi_dlyb_find_tap(omi, false);
+
+	return ret ? !calibrated : calibrated;
+}
+
+static const struct hyperbus_ops stm32_hyperbus_ops = {
+	.read16 = stm32_hyperbus_read16,
+	.write16 = stm32_hyperbus_write16,
+	.copy_from = stm32_hyperbus_copy_from,
+	.calibrate = stm32_hyperbus_calibrate,
+};
+
+static void stm32_hyperbus_init(struct stm32_hyperbus *hyperbus)
+{
+	struct stm32_omi *omi = &hyperbus->omi;
+	void __iomem *regs_base = omi->regs_base;
+	unsigned long period;
+	u32 cr, dcr1, hlcr, ccr, wccr;
+	u32 prescaler;
+
+	cr = CR_EN;
+	cr |= FIELD_PREP(CR_CSSEL, hyperbus->cs);
+	writel_relaxed(cr, regs_base + OSPI_CR);
+
+	/* set MTYP to HyperBus memory-map mode */
+	dcr1 = FIELD_PREP(DCR1_MTYP_MASK, DCR1_MTYP_HP_MEMMODE);
+	/* set DEVSIZE to memory map size */
+	dcr1 |= FIELD_PREP(DCR1_DEVSIZE_MASK, ffs(omi->mm_size) - 1);
+	writel_relaxed(dcr1, regs_base + OSPI_DCR1);
+
+	prescaler = DIV_ROUND_UP(omi->clk_rate, hyperbus->flash_freq) - 1;
+	if (prescaler > 255)
+		prescaler = 255;
+
+	writel_relaxed(FIELD_PREP(DCR2_PRESC_MASK, prescaler), regs_base + OSPI_DCR2);
+	hyperbus->real_flash_freq = omi->clk_rate / (prescaler + 1);
+
+	writel_relaxed(1, regs_base + OSPI_DLR);
+
+	/* set access time latency */
+	period = NSEC_PER_SEC / hyperbus->real_flash_freq;
+	hlcr = FIELD_PREP(HLCR_TACC_MASK, hyperbus->tacc / period);
+	if (hyperbus->wzl)
+		hlcr |= HLCR_WZL;
+
+	writel_relaxed(hlcr, regs_base + OSPI_HLCR);
+
+	ccr = CCR_DQSE | CCR_DDTR | CCR_ADDTR;
+	ccr |= FIELD_PREP(CCR_DMODE_MASK, CCR_DMODE_8LINES);
+	ccr |= FIELD_PREP(CCR_ADSIZE_MASK, CCR_ADSIZE_32BITS);
+	ccr |= FIELD_PREP(CCR_ADMODE_MASK, CCR_ADMODE_8LINES);
+	writel(ccr, regs_base + OSPI_CCR);
+
+	wccr = WCCR_DQSE | WCCR_DDTR | WCCR_ADDTR;
+	wccr |= FIELD_PREP(WCCR_DMODE_MASK, WCCR_DMODE_8LINES);
+	wccr |= FIELD_PREP(WCCR_ADSIZE_MASK, WCCR_ADSIZE_32BITS);
+	wccr |= FIELD_PREP(WCCR_ADMODE_MASK, WCCR_ADMODE_8LINES);
+	writel(wccr, regs_base + OSPI_WCCR);
+
+	stm32_hyperbus_set_mode(hyperbus, CR_FMODE_MM);
+}
+
+static int __maybe_unused stm32_hyperbus_suspend(struct device *dev)
+{
+	struct stm32_hyperbus *hyperbus = dev_get_drvdata(dev);
+	struct stm32_omi *omi = &hyperbus->omi;
+	void __iomem *regs_base = omi->regs_base;
+	u32 cr;
+
+	cr = readl_relaxed(regs_base + OSPI_CR);
+	cr &= ~CR_EN;
+	writel_relaxed(cr, regs_base + OSPI_CR);
+
+	clk_disable_unprepare(omi->clk);
+
+	return pinctrl_pm_select_sleep_state(dev);
+}
+
+static int __maybe_unused stm32_hyperbus_resume(struct device *dev)
+{
+	struct stm32_hyperbus *hyperbus = dev_get_drvdata(dev);
+	struct stm32_omi *omi = &hyperbus->omi;
+	int ret;
+
+	ret = clk_prepare_enable(omi->clk);
+	if (ret)
+		return ret;
+
+	pinctrl_pm_select_default_state(dev);
+	stm32_hyperbus_init(hyperbus);
+
+	return 0;
+}
+
+static const struct dev_pm_ops stm32_hyperbus_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(stm32_hyperbus_suspend, stm32_hyperbus_resume)
+};
+
+static int stm32_hyperbus_probe(struct platform_device *pdev)
+{
+	struct device *parent = pdev->dev.parent;
+	struct platform_device *ppdev = to_platform_device(parent);
+	struct device *dev = &ppdev->dev;
+	struct stm32_hyperbus *hyperbus;
+	struct stm32_omi *omi;
+	struct device_node *flash;
+	u32 value;
+	int ret;
+
+	hyperbus = devm_kzalloc(&pdev->dev, sizeof(*hyperbus), GFP_KERNEL);
+	if (!hyperbus)
+		return -ENOMEM;
+
+	omi = &hyperbus->omi;
+	omi->dev = &pdev->dev;
+	hyperbus->dev = dev;
+
+	ret = stm32_omi_dma_setup(omi, dev, NULL);
+	if (ret)
+		return ret;
+
+	ret = stm32_omi_get_resources(omi, parent);
+	if (ret)
+		return ret;
+
+	/* mandatory for HyperFlash */
+	if (!omi->mm_size) {
+		dev_err(dev, "Memory-map region not found\n");
+		return -EINVAL;
+	}
+
+	/* mandatory for HyperFlash */
+	if (!omi->dlyb_base) {
+		dev_err(dev, "Incorrect delay block base address\n");
+		return -EINVAL;
+	}
+
+	omi->clk_rate = clk_get_rate(omi->clk);
+	if (!omi->clk_rate) {
+		dev_err(dev, "Invalid clock rate\n");
+		return -EINVAL;
+	}
+
+	ret = clk_prepare_enable(omi->clk);
+	if (ret) {
+		dev_err(dev, "Can not enable hyperbus clock\n");
+		return ret;
+	}
+
+	ret = devm_request_irq(dev, omi->irq, stm32_omi_irq, 0,
+			       dev_name(dev), omi);
+	if (ret) {
+		dev_err(dev, "Failed to request irq\n");
+		goto err_clk_disable;
+	}
+
+	flash = of_get_next_child(ppdev->dev.of_node, NULL);
+	if (!flash) {
+		dev_warn(&pdev->dev, "No flash node found\n");
+		goto err_clk_disable;
+	}
+
+	ret = of_property_read_u32(flash, "reg", &hyperbus->cs);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't find reg property\n");
+		goto err_clk_disable;
+	}
+
+	ret = of_property_read_u32(flash, "st,max-frequency", &value);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't find st,max-frequency property\n");
+		goto err_clk_disable;
+	}
+	hyperbus->flash_freq = value;
+
+	/* optional */
+	ret = of_property_read_u32(flash, "st,tacc-ns", &hyperbus->tacc);
+	if (ret)
+		hyperbus->tacc = 0;
+
+	hyperbus->wzl = of_property_read_bool(flash, "st,wzl");
+
+	init_completion(&omi->data_completion);
+	omi->check_transfer = stm32_hyperbus_check_transfert;
+
+	stm32_hyperbus_init(hyperbus);
+
+	platform_set_drvdata(pdev, hyperbus);
+
+	hyperbus->hbdev.map.size = omi->mm_size;
+	hyperbus->hbdev.map.virt = omi->mm_base;
+
+	hyperbus->dev = &pdev->dev;
+	hyperbus->ctlr.dev = &pdev->dev;
+	hyperbus->ctlr.ops = &stm32_hyperbus_ops;
+	hyperbus->hbdev.ctlr = &hyperbus->ctlr;
+	hyperbus->hbdev.np = of_get_next_child(parent->of_node, NULL);
+
+	return hyperbus_register_device(&hyperbus->hbdev);
+
+err_clk_disable:
+	clk_disable_unprepare(omi->clk);
+
+	return ret;
+}
+
+static int stm32_hyperbus_remove(struct platform_device *pdev)
+{
+	struct stm32_hyperbus *hyperbus = platform_get_drvdata(pdev);
+
+	hyperbus_unregister_device(&hyperbus->hbdev);
+	stm32_omi_dma_free(&hyperbus->omi);
+	clk_disable_unprepare(hyperbus->omi.clk);
+
+	return 0;
+}
+
+static struct platform_driver stm32_hyperbus_driver = {
+	.probe	= stm32_hyperbus_probe,
+	.remove	= stm32_hyperbus_remove,
+	.driver	= {
+		.name = "stm32-hyperflash",
+		.pm = &stm32_hyperbus_pm_ops,
+	},
+};
+module_platform_driver(stm32_hyperbus_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics STM32 HyperBus driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mtd/nand/raw/Kconfig b/drivers/mtd/nand/raw/Kconfig
index 67b7cb67c..dccb86e57 100644
--- a/drivers/mtd/nand/raw/Kconfig
+++ b/drivers/mtd/nand/raw/Kconfig
@@ -385,7 +385,7 @@ config MTD_NAND_TEGRA
 
 config MTD_NAND_STM32_FMC2
 	tristate "Support for NAND controller on STM32MP SoCs"
-	depends on MACH_STM32MP157 || COMPILE_TEST
+	depends on ARCH_STM32 || COMPILE_TEST
 	select MFD_SYSCON
 	help
 	  Enables support for NAND Flash chips on SoCs containing the FMC2
diff --git a/drivers/mtd/nand/raw/stm32_fmc2_nand.c b/drivers/mtd/nand/raw/stm32_fmc2_nand.c
index 1c277fbb9..7a9cf0954 100644
--- a/drivers/mtd/nand/raw/stm32_fmc2_nand.c
+++ b/drivers/mtd/nand/raw/stm32_fmc2_nand.c
@@ -9,12 +9,14 @@
 #include <linux/dmaengine.h>
 #include <linux/dma-mapping.h>
 #include <linux/errno.h>
+#include <linux/gpio/consumer.h>
 #include <linux/interrupt.h>
 #include <linux/iopoll.h>
 #include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/mtd/rawnand.h>
 #include <linux/of_address.h>
+#include <linux/of_device.h>
 #include <linux/pinctrl/consumer.h>
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
@@ -36,7 +38,7 @@
 #define FMC2_MAX_SG			16
 
 /* Max chip enable */
-#define FMC2_MAX_CE			2
+#define FMC2_MAX_CE			4
 
 /* Max ECC buffer length */
 #define FMC2_MAX_ECC_BUF_LEN		(FMC2_BCHDSRS_LEN * FMC2_MAX_SG)
@@ -52,6 +54,7 @@
 
 /* FMC2 Controller Registers */
 #define FMC2_BCR1			0x0
+#define FMC2_CFGR			0x20
 #define FMC2_PCR			0x80
 #define FMC2_SR				0x84
 #define FMC2_PMEM			0x88
@@ -81,10 +84,14 @@
 #define FMC2_BCHDSR2			0x284
 #define FMC2_BCHDSR3			0x288
 #define FMC2_BCHDSR4			0x28c
+#define FMC2_VERR			0x3f4
 
 /* Register: FMC2_BCR1 */
 #define FMC2_BCR1_FMC2EN		BIT(31)
 
+/* Register: FMC2_CFGR */
+#define FMC2_CFGR_FMC2EN		BIT(31)
+
 /* Register: FMC2_PCR */
 #define FMC2_PCR_PWAITEN		BIT(1)
 #define FMC2_PCR_PBKEN			BIT(2)
@@ -206,6 +213,10 @@
 #define FMC2_BCHDSR4_EBP7		GENMASK(12, 0)
 #define FMC2_BCHDSR4_EBP8		GENMASK(28, 16)
 
+/* Register: FMC2_VERR */
+#define FMC2_VERR_MAJREV		GENMASK(7, 4)
+#define FMC2_VERR_MAJREV_2		2
+
 enum stm32_fmc2_ecc {
 	FMC2_ECC_HAM = 1,
 	FMC2_ECC_BCH4 = 4,
@@ -231,6 +242,7 @@ struct stm32_fmc2_timings {
 
 struct stm32_fmc2_nand {
 	struct nand_chip chip;
+	struct gpio_desc *wp_gpio;
 	struct stm32_fmc2_timings timings;
 	int ncs;
 	int cs_used[FMC2_MAX_CE];
@@ -241,6 +253,10 @@ static inline struct stm32_fmc2_nand *to_fmc2_nand(struct nand_chip *chip)
 	return container_of(chip, struct stm32_fmc2_nand, chip);
 }
 
+struct stm32_fmc2_nfc_data {
+	int max_ncs;
+};
+
 struct stm32_fmc2_nfc {
 	struct nand_controller base;
 	struct stm32_fmc2_nand nand;
@@ -254,6 +270,7 @@ struct stm32_fmc2_nfc {
 	phys_addr_t data_phys_addr[FMC2_MAX_CE];
 	struct clk *clk;
 	u8 irq_state;
+	const struct stm32_fmc2_nfc_data *data;
 
 	struct dma_chan *dma_tx_ch;
 	struct dma_chan *dma_rx_ch;
@@ -262,6 +279,8 @@ struct stm32_fmc2_nfc {
 	struct sg_table dma_ecc_sg;
 	u8 *ecc_buf;
 	int dma_ecc_len;
+	u32 tx_dma_max_burst;
+	u32 rx_dma_max_burst;
 
 	struct completion complete;
 	struct completion dma_data_complete;
@@ -345,20 +364,26 @@ static int stm32_fmc2_nfc_select_chip(struct nand_chip *chip, int chipnr)
 	stm32_fmc2_nfc_setup(chip);
 	stm32_fmc2_nfc_timings_init(chip);
 
-	if (nfc->dma_tx_ch && nfc->dma_rx_ch) {
+	if (nfc->dma_tx_ch) {
 		memset(&dma_cfg, 0, sizeof(dma_cfg));
-		dma_cfg.src_addr = nfc->data_phys_addr[nfc->cs_sel];
 		dma_cfg.dst_addr = nfc->data_phys_addr[nfc->cs_sel];
-		dma_cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 		dma_cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-		dma_cfg.src_maxburst = 32;
-		dma_cfg.dst_maxburst = 32;
+		dma_cfg.dst_maxburst = nfc->tx_dma_max_burst /
+				       dma_cfg.dst_addr_width;
 
 		ret = dmaengine_slave_config(nfc->dma_tx_ch, &dma_cfg);
 		if (ret) {
 			dev_err(nfc->dev, "tx DMA engine slave config failed\n");
 			return ret;
 		}
+	}
+
+	if (nfc->dma_rx_ch) {
+		memset(&dma_cfg, 0, sizeof(dma_cfg));
+		dma_cfg.src_addr = nfc->data_phys_addr[nfc->cs_sel];
+		dma_cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		dma_cfg.src_maxburst = nfc->rx_dma_max_burst /
+				       dma_cfg.src_addr_width;
 
 		ret = dmaengine_slave_config(nfc->dma_rx_ch, &dma_cfg);
 		if (ret) {
@@ -1379,9 +1404,20 @@ static void stm32_fmc2_nfc_init(struct stm32_fmc2_nfc *nfc)
 	pcr |= FIELD_PREP(FMC2_PCR_TAR, FMC2_PCR_TAR_DEFAULT);
 
 	/* Enable FMC2 controller */
-	if (nfc->dev == nfc->cdev)
-		regmap_update_bits(nfc->regmap, FMC2_BCR1,
-				   FMC2_BCR1_FMC2EN, FMC2_BCR1_FMC2EN);
+	if (nfc->dev == nfc->cdev) {
+		u32 verr;
+		u8 majrev;
+
+		regmap_read(nfc->regmap, FMC2_VERR, &verr);
+		majrev = FIELD_GET(FMC2_VERR_MAJREV, verr);
+
+		if (majrev < FMC2_VERR_MAJREV_2)
+			regmap_update_bits(nfc->regmap, FMC2_BCR1,
+					   FMC2_BCR1_FMC2EN, FMC2_BCR1_FMC2EN);
+		else
+			regmap_update_bits(nfc->regmap, FMC2_CFGR,
+					   FMC2_CFGR_FMC2EN, FMC2_CFGR_FMC2EN);
+	}
 
 	regmap_write(nfc->regmap, FMC2_PCR, pcr);
 	regmap_write(nfc->regmap, FMC2_PMEM, FMC2_PMEM_DEFAULT);
@@ -1538,6 +1574,7 @@ static int stm32_fmc2_nfc_setup_interface(struct nand_chip *chip, int chipnr,
 
 static int stm32_fmc2_nfc_dma_setup(struct stm32_fmc2_nfc *nfc)
 {
+	struct dma_slave_caps caps;
 	int ret = 0;
 
 	nfc->dma_tx_ch = dma_request_chan(nfc->dev, "tx");
@@ -1550,6 +1587,11 @@ static int stm32_fmc2_nfc_dma_setup(struct stm32_fmc2_nfc *nfc)
 		goto err_dma;
 	}
 
+	ret = dma_get_slave_caps(nfc->dma_tx_ch, &caps);
+	if (ret)
+		return ret;
+	nfc->tx_dma_max_burst = caps.max_burst;
+
 	nfc->dma_rx_ch = dma_request_chan(nfc->dev, "rx");
 	if (IS_ERR(nfc->dma_rx_ch)) {
 		ret = PTR_ERR(nfc->dma_rx_ch);
@@ -1560,6 +1602,11 @@ static int stm32_fmc2_nfc_dma_setup(struct stm32_fmc2_nfc *nfc)
 		goto err_dma;
 	}
 
+	ret = dma_get_slave_caps(nfc->dma_rx_ch, &caps);
+	if (ret)
+		return ret;
+	nfc->rx_dma_max_burst = caps.max_burst;
+
 	nfc->dma_ecc_ch = dma_request_chan(nfc->dev, "ecc");
 	if (IS_ERR(nfc->dma_ecc_ch)) {
 		ret = PTR_ERR(nfc->dma_ecc_ch);
@@ -1747,6 +1794,18 @@ static const struct nand_controller_ops stm32_fmc2_nfc_controller_ops = {
 	.setup_interface = stm32_fmc2_nfc_setup_interface,
 };
 
+static void stm32_fmc2_nfc_wp_enable(struct stm32_fmc2_nand *nand)
+{
+	if (nand->wp_gpio)
+		gpiod_set_value(nand->wp_gpio, 1);
+}
+
+static void stm32_fmc2_nfc_wp_disable(struct stm32_fmc2_nand *nand)
+{
+	if (nand->wp_gpio)
+		gpiod_set_value(nand->wp_gpio, 0);
+}
+
 static int stm32_fmc2_nfc_parse_child(struct stm32_fmc2_nfc *nfc,
 				      struct device_node *dn)
 {
@@ -1771,7 +1830,7 @@ static int stm32_fmc2_nfc_parse_child(struct stm32_fmc2_nfc *nfc,
 			return ret;
 		}
 
-		if (cs >= FMC2_MAX_CE) {
+		if (cs >= nfc->data->max_ncs) {
 			dev_err(nfc->dev, "invalid reg value: %d\n", cs);
 			return -EINVAL;
 		}
@@ -1785,6 +1844,18 @@ static int stm32_fmc2_nfc_parse_child(struct stm32_fmc2_nfc *nfc,
 		nand->cs_used[i] = cs;
 	}
 
+	nand->wp_gpio = devm_gpiod_get_from_of_node(nfc->dev, dn,
+						    "wp-gpios", 0,
+						    GPIOD_OUT_HIGH, "wp");
+	if (IS_ERR(nand->wp_gpio)) {
+		ret = PTR_ERR(nand->wp_gpio);
+		if (ret != -ENOENT)
+			return dev_err_probe(nfc->dev, ret,
+					     "failed to request WP GPIO\n");
+
+		nand->wp_gpio = NULL;
+	}
+
 	nand_set_flash_node(&nand->chip, dn);
 
 	return 0;
@@ -1823,11 +1894,14 @@ static int stm32_fmc2_nfc_set_cdev(struct stm32_fmc2_nfc *nfc)
 	struct device *dev = nfc->dev;
 	bool ebi_found = false;
 
-	if (dev->parent && of_device_is_compatible(dev->parent->of_node,
-						   "st,stm32mp1-fmc2-ebi"))
+	if (dev->parent && (of_device_is_compatible(dev->parent->of_node,
+						    "st,stm32mp1-fmc2-ebi") ||
+			    of_device_is_compatible(dev->parent->of_node,
+						    "st,stm32mp25-fmc2-ebi")))
 		ebi_found = true;
 
-	if (of_device_is_compatible(dev->of_node, "st,stm32mp1-fmc2-nfc")) {
+	if (of_device_is_compatible(dev->of_node, "st,stm32mp1-fmc2-nfc") ||
+	    of_device_is_compatible(dev->of_node, "st,stm32mp25-fmc2-nfc")) {
 		if (ebi_found) {
 			nfc->cdev = dev->parent;
 
@@ -1866,6 +1940,10 @@ static int stm32_fmc2_nfc_probe(struct platform_device *pdev)
 	nand_controller_init(&nfc->base);
 	nfc->base.ops = &stm32_fmc2_nfc_controller_ops;
 
+	nfc->data = of_device_get_match_data(dev);
+	if (!nfc->data)
+		return -EINVAL;
+
 	ret = stm32_fmc2_nfc_set_cdev(nfc);
 	if (ret)
 		return ret;
@@ -1887,7 +1965,7 @@ static int stm32_fmc2_nfc_probe(struct platform_device *pdev)
 	if (nfc->dev == nfc->cdev)
 		start_region = 1;
 
-	for (chip_cs = 0, mem_region = start_region; chip_cs < FMC2_MAX_CE;
+	for (chip_cs = 0, mem_region = start_region; chip_cs < nfc->data->max_ncs;
 	     chip_cs++, mem_region += 3) {
 		if (!(nfc->cs_assigned & BIT(chip_cs)))
 			continue;
@@ -1960,10 +2038,12 @@ static int stm32_fmc2_nfc_probe(struct platform_device *pdev)
 	chip->options |= NAND_BUSWIDTH_AUTO | NAND_NO_SUBPAGE_WRITE |
 			 NAND_USES_DMA;
 
+	stm32_fmc2_nfc_wp_disable(nand);
+
 	/* Scan to find existence of the device */
 	ret = nand_scan(chip, nand->ncs);
 	if (ret)
-		goto err_release_dma;
+		goto err_wp_enable;
 
 	ret = mtd_device_register(mtd, NULL, 0);
 	if (ret)
@@ -1976,6 +2056,9 @@ static int stm32_fmc2_nfc_probe(struct platform_device *pdev)
 err_nand_cleanup:
 	nand_cleanup(chip);
 
+err_wp_enable:
+	stm32_fmc2_nfc_wp_enable(nand);
+
 err_release_dma:
 	if (nfc->dma_ecc_ch)
 		dma_release_channel(nfc->dma_ecc_ch);
@@ -2016,15 +2099,20 @@ static int stm32_fmc2_nfc_remove(struct platform_device *pdev)
 
 	clk_disable_unprepare(nfc->clk);
 
+	stm32_fmc2_nfc_wp_enable(nand);
+
 	return 0;
 }
 
 static int __maybe_unused stm32_fmc2_nfc_suspend(struct device *dev)
 {
 	struct stm32_fmc2_nfc *nfc = dev_get_drvdata(dev);
+	struct stm32_fmc2_nand *nand = &nfc->nand;
 
 	clk_disable_unprepare(nfc->clk);
 
+	stm32_fmc2_nfc_wp_enable(nand);
+
 	pinctrl_pm_select_sleep_state(dev);
 
 	return 0;
@@ -2046,7 +2134,9 @@ static int __maybe_unused stm32_fmc2_nfc_resume(struct device *dev)
 
 	stm32_fmc2_nfc_init(nfc);
 
-	for (chip_cs = 0; chip_cs < FMC2_MAX_CE; chip_cs++) {
+	stm32_fmc2_nfc_wp_disable(nand);
+
+	for (chip_cs = 0; chip_cs < nfc->data->max_ncs; chip_cs++) {
 		if (!(nfc->cs_assigned & BIT(chip_cs)))
 			continue;
 
@@ -2059,9 +2149,31 @@ static int __maybe_unused stm32_fmc2_nfc_resume(struct device *dev)
 static SIMPLE_DEV_PM_OPS(stm32_fmc2_nfc_pm_ops, stm32_fmc2_nfc_suspend,
 			 stm32_fmc2_nfc_resume);
 
+static const struct stm32_fmc2_nfc_data stm32_fmc2_nfc_mp1_data = {
+	.max_ncs = 2,
+};
+
+static const struct stm32_fmc2_nfc_data stm32_fmc2_nfc_mp25_data = {
+	.max_ncs = 4,
+};
+
 static const struct of_device_id stm32_fmc2_nfc_match[] = {
-	{.compatible = "st,stm32mp15-fmc2"},
-	{.compatible = "st,stm32mp1-fmc2-nfc"},
+	{
+		.compatible = "st,stm32mp15-fmc2",
+		.data = &stm32_fmc2_nfc_mp1_data,
+	},
+	{
+		.compatible = "st,stm32mp1-fmc2-nfc",
+		.data = &stm32_fmc2_nfc_mp1_data,
+	},
+	{
+		.compatible = "st,stm32mp25-fmc2",
+		.data = &stm32_fmc2_nfc_mp25_data,
+	},
+	{
+		.compatible = "st,stm32mp25-fmc2-nfc",
+		.data = &stm32_fmc2_nfc_mp25_data,
+	},
 	{}
 };
 MODULE_DEVICE_TABLE(of, stm32_fmc2_nfc_match);
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c
index 2b38a499a..fc908f8f7 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c
@@ -15,6 +15,7 @@
 #include <linux/of_net.h>
 #include <linux/phy.h>
 #include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
 #include <linux/pm_wakeirq.h>
 #include <linux/regmap.h>
 #include <linux/slab.h>
@@ -22,13 +23,6 @@
 
 #include "stmmac_platform.h"
 
-#define SYSCFG_MCU_ETH_MASK		BIT(23)
-#define SYSCFG_MP1_ETH_MASK		GENMASK(23, 16)
-#define SYSCFG_PMCCLRR_OFFSET		0x40
-
-#define SYSCFG_PMCR_ETH_CLK_SEL		BIT(16)
-#define SYSCFG_PMCR_ETH_REF_CLK_SEL	BIT(17)
-
 /* CLOCK feed to PHY*/
 #define ETH_CK_F_25M	25000000
 #define ETH_CK_F_50M	50000000
@@ -47,14 +41,27 @@
  * RMII  |   1	 |   0	  |   0	   |  n/a  |
  *------------------------------------------
  */
-#define SYSCFG_PMCR_ETH_SEL_MII		BIT(20)
-#define SYSCFG_PMCR_ETH_SEL_RGMII	BIT(21)
-#define SYSCFG_PMCR_ETH_SEL_RMII	BIT(23)
+
+/* STM32MP1 register definitions */
+#define SYSCFG_MCU_ETH_MASK		BIT(23)
+#define SYSCFG_MP1_ETH_MASK		GENMASK(23, 16)
+
 #define SYSCFG_PMCR_ETH_SEL_GMII	0
 #define SYSCFG_MCU_ETH_SEL_MII		0
 #define SYSCFG_MCU_ETH_SEL_RMII		1
 
-/* STM32MP1 register definitions
+/* STM32MP2 register definitions */
+#define SYSCFG_MP2_ETH_MASK		GENMASK(31, 0)
+
+#define SYSCFG_ETHCR_ETH_PTP_CLK_SEL	BIT(2)
+#define SYSCFG_ETHCR_ETH_CLK_SEL	BIT(1)
+#define SYSCFG_ETHCR_ETH_REF_CLK_SEL	BIT(0)
+
+#define SYSCFG_ETHCR_ETH_SEL_MII	0
+#define SYSCFG_ETHCR_ETH_SEL_RGMII	BIT(4)
+#define SYSCFG_ETHCR_ETH_SEL_RMII	BIT(6)
+
+/* STM32MPx register definitions
  *
  * Below table summarizes the clock requirement and clock sources for
  * supported phy interface modes.
@@ -63,17 +70,17 @@
  *|         |        |      25MHz    |        50MHz       |                  |
  * ---------------------------------------------------------------------------
  *|  MII    |	 -   |     eth-ck    |	      n/a	  |	  n/a        |
- *|         |        | st,ext-phyclk |                    |		     |
+ *|         |        |	             |                    |		     |
  * ---------------------------------------------------------------------------
  *|  GMII   |	 -   |     eth-ck    |	      n/a	  |	  n/a        |
- *|         |        | st,ext-phyclk |                    |		     |
+ *|         |        |               |                    |		     |
  * ---------------------------------------------------------------------------
  *| RGMII   |	 -   |     eth-ck    |	      n/a	  |      eth-ck      |
- *|         |        | st,ext-phyclk |                    | st,eth-clk-sel or|
+ *|         |        |               |                    | st,eth-clk-sel or|
  *|         |        |               |                    | st,ext-phyclk    |
  * ---------------------------------------------------------------------------
  *| RMII    |	 -   |     eth-ck    |	    eth-ck        |	  n/a        |
- *|         |        | st,ext-phyclk | st,eth-ref-clk-sel |		     |
+ *|         |        |               | st,eth-ref-clk-sel |		     |
  *|         |        |               | or st,ext-phyclk   |		     |
  * ---------------------------------------------------------------------------
  *
@@ -88,15 +95,29 @@ struct stm32_dwmac {
 	int ext_phyclk;
 	int enable_eth_ck;
 	int eth_clk_sel_reg;
+	int eth_ptp_sel_reg;
 	int eth_ref_clk_sel_reg;
-	int irq_pwr_wakeup;
 	u32 mode_reg;		 /* MAC glue-logic mode register */
+	u32 mode_mask;
 	struct regmap *regmap;
+	struct regulator *regulator;
 	u32 speed;
 	const struct stm32_ops *ops;
 	struct device *dev;
 };
 
+struct stm32_syscfg_pmcsetr {
+	u32 eth1_clk_sel;
+	u32 eth1_ref_clk_sel;
+	u32 eth1_selmii;
+	u32 eth1_sel_rgmii;
+	u32 eth1_sel_rmii;
+	u32 eth2_clk_sel;
+	u32 eth2_ref_clk_sel;
+	u32 eth2_sel_rgmii;
+	u32 eth2_sel_rmii;
+};
+
 struct stm32_ops {
 	int (*set_mode)(struct plat_stmmacenet_data *plat_dat);
 	int (*clk_prepare)(struct stm32_dwmac *dwmac, bool prepare);
@@ -104,7 +125,9 @@ struct stm32_ops {
 	void (*resume)(struct stm32_dwmac *dwmac);
 	int (*parse_data)(struct stm32_dwmac *dwmac,
 			  struct device *dev);
+	u32 syscfg_clr_off;
 	u32 syscfg_eth_mask;
+	struct stm32_syscfg_pmcsetr pmcsetr;
 };
 
 static int stm32_dwmac_init(struct plat_stmmacenet_data *plat_dat)
@@ -174,26 +197,26 @@ static int stm32mp1_set_mode(struct plat_stmmacenet_data *plat_dat)
 	dwmac->enable_eth_ck = false;
 	switch (plat_dat->interface) {
 	case PHY_INTERFACE_MODE_MII:
-		if (clk_rate == ETH_CK_F_25M && dwmac->ext_phyclk)
+		if (clk_rate == ETH_CK_F_25M)
 			dwmac->enable_eth_ck = true;
-		val = SYSCFG_PMCR_ETH_SEL_MII;
+		val = dwmac->ops->pmcsetr.eth1_selmii;
 		pr_debug("SYSCFG init : PHY_INTERFACE_MODE_MII\n");
 		break;
 	case PHY_INTERFACE_MODE_GMII:
 		val = SYSCFG_PMCR_ETH_SEL_GMII;
-		if (clk_rate == ETH_CK_F_25M &&
-		    (dwmac->eth_clk_sel_reg || dwmac->ext_phyclk)) {
+		if (clk_rate == ETH_CK_F_25M)
 			dwmac->enable_eth_ck = true;
-			val |= SYSCFG_PMCR_ETH_CLK_SEL;
-		}
 		pr_debug("SYSCFG init : PHY_INTERFACE_MODE_GMII\n");
 		break;
 	case PHY_INTERFACE_MODE_RMII:
-		val = SYSCFG_PMCR_ETH_SEL_RMII;
-		if ((clk_rate == ETH_CK_F_25M || clk_rate == ETH_CK_F_50M) &&
+		val = dwmac->ops->pmcsetr.eth1_sel_rmii | dwmac->ops->pmcsetr.eth2_sel_rmii;
+		if (clk_rate == ETH_CK_F_25M)
+			dwmac->enable_eth_ck = true;
+		if ((clk_rate == ETH_CK_F_50M) &&
 		    (dwmac->eth_ref_clk_sel_reg || dwmac->ext_phyclk)) {
 			dwmac->enable_eth_ck = true;
-			val |= SYSCFG_PMCR_ETH_REF_CLK_SEL;
+			val |= dwmac->ops->pmcsetr.eth1_ref_clk_sel;
+			val |= dwmac->ops->pmcsetr.eth2_ref_clk_sel;
 		}
 		pr_debug("SYSCFG init : PHY_INTERFACE_MODE_RMII\n");
 		break;
@@ -201,11 +224,14 @@ static int stm32mp1_set_mode(struct plat_stmmacenet_data *plat_dat)
 	case PHY_INTERFACE_MODE_RGMII_ID:
 	case PHY_INTERFACE_MODE_RGMII_RXID:
 	case PHY_INTERFACE_MODE_RGMII_TXID:
-		val = SYSCFG_PMCR_ETH_SEL_RGMII;
-		if ((clk_rate == ETH_CK_F_25M || clk_rate == ETH_CK_F_125M) &&
+		val = dwmac->ops->pmcsetr.eth1_sel_rgmii | dwmac->ops->pmcsetr.eth2_sel_rgmii;
+		if (clk_rate == ETH_CK_F_25M)
+			dwmac->enable_eth_ck = true;
+		if ((clk_rate == ETH_CK_F_125M) &&
 		    (dwmac->eth_clk_sel_reg || dwmac->ext_phyclk)) {
 			dwmac->enable_eth_ck = true;
-			val |= SYSCFG_PMCR_ETH_CLK_SEL;
+			val |= dwmac->ops->pmcsetr.eth1_clk_sel;
+			val |= dwmac->ops->pmcsetr.eth2_clk_sel;
 		}
 		pr_debug("SYSCFG init : PHY_INTERFACE_MODE_RGMII\n");
 		break;
@@ -217,12 +243,74 @@ static int stm32mp1_set_mode(struct plat_stmmacenet_data *plat_dat)
 	}
 
 	/* Need to update PMCCLRR (clear register) */
-	regmap_write(dwmac->regmap, reg + SYSCFG_PMCCLRR_OFFSET,
-		     dwmac->ops->syscfg_eth_mask);
+	regmap_write(dwmac->regmap, dwmac->ops->syscfg_clr_off,
+		     dwmac->mode_mask);
 
 	/* Update PMCSETR (set register) */
 	return regmap_update_bits(dwmac->regmap, reg,
-				 dwmac->ops->syscfg_eth_mask, val);
+				  dwmac->mode_mask, val);
+}
+
+static int stm32mp2_set_mode(struct plat_stmmacenet_data *plat_dat)
+{
+	struct stm32_dwmac *dwmac = plat_dat->bsp_priv;
+	u32 reg = dwmac->mode_reg, clk_rate;
+	int val;
+
+	clk_rate = clk_get_rate(dwmac->clk_eth_ck);
+	dwmac->enable_eth_ck = false;
+	switch (plat_dat->interface) {
+	case PHY_INTERFACE_MODE_MII:
+		if (clk_rate == ETH_CK_F_25M)
+			dwmac->enable_eth_ck = true;
+		val = SYSCFG_ETHCR_ETH_SEL_MII;
+		dev_dbg(dwmac->dev, "SYSCFG init : PHY_INTERFACE_MODE_MII val =%d\n", val);
+		break;
+	case PHY_INTERFACE_MODE_GMII:
+		if (clk_rate == ETH_CK_F_25M) {
+			dwmac->enable_eth_ck = true;
+			val |= SYSCFG_ETHCR_ETH_CLK_SEL;
+		}
+		dev_dbg(dwmac->dev, "SYSCFG init : PHY_INTERFACE_MODE_GMII\n");
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		val = SYSCFG_ETHCR_ETH_SEL_RMII;
+		if (clk_rate == ETH_CK_F_25M)
+			dwmac->enable_eth_ck = true;
+		if ((clk_rate == ETH_CK_F_50M) &&
+		    (dwmac->eth_ref_clk_sel_reg || dwmac->ext_phyclk)) {
+			dwmac->enable_eth_ck = true;
+			val |= SYSCFG_ETHCR_ETH_REF_CLK_SEL;
+		}
+		dev_dbg(dwmac->dev, "SYSCFG init : PHY_INTERFACE_MODE_RMII\n");
+		break;
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_RGMII_ID:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+		val = SYSCFG_ETHCR_ETH_SEL_RGMII;
+		if (clk_rate == ETH_CK_F_25M)
+			dwmac->enable_eth_ck = true;
+		if ((clk_rate == ETH_CK_F_125M) &&
+		    (dwmac->eth_clk_sel_reg || dwmac->ext_phyclk)) {
+			dwmac->enable_eth_ck = true;
+			val |= SYSCFG_ETHCR_ETH_CLK_SEL;
+		}
+		dev_dbg(dwmac->dev, "SYSCFG init : PHY_INTERFACE_MODE_RGMII\n");
+		break;
+	default:
+		dev_err(dwmac->dev, "SYSCFG init :  Do not manage %d interface\n",
+			 plat_dat->interface);
+		/* Do not manage others interfaces */
+		return -EINVAL;
+	}
+
+	if (dwmac->eth_ptp_sel_reg)
+		val |= SYSCFG_ETHCR_ETH_PTP_CLK_SEL;
+
+	/* Update ETHCR (set register) */
+	return regmap_update_bits(dwmac->regmap, reg,
+				  dwmac->ops->syscfg_eth_mask, val);
 }
 
 static int stm32mcu_set_mode(struct plat_stmmacenet_data *plat_dat)
@@ -248,7 +336,7 @@ static int stm32mcu_set_mode(struct plat_stmmacenet_data *plat_dat)
 	}
 
 	return regmap_update_bits(dwmac->regmap, reg,
-				 dwmac->ops->syscfg_eth_mask, val << 23);
+				 SYSCFG_MCU_ETH_MASK, val << 23);
 }
 
 static void stm32_dwmac_clk_disable(struct stm32_dwmac *dwmac)
@@ -291,22 +379,40 @@ static int stm32_dwmac_parse_data(struct stm32_dwmac *dwmac,
 		return PTR_ERR(dwmac->regmap);
 
 	err = of_property_read_u32_index(np, "st,syscon", 1, &dwmac->mode_reg);
+	if (err) {
+		dev_err(dev, "Can't get sysconfig register offset (%d)\n", err);
+		return err;
+	}
+
+	dwmac->mode_mask = SYSCFG_MP1_ETH_MASK;
+	err = of_property_read_u32_index(np, "st,syscon", 2, &dwmac->mode_mask);
 	if (err)
-		dev_err(dev, "Can't get sysconfig mode offset (%d)\n", err);
+		pr_debug("Warning sysconfig register mask not set\n");
+
+	dwmac->regulator = devm_regulator_get_optional(dev, "phy");
+	if (IS_ERR(dwmac->regulator)) {
+		if (PTR_ERR(dwmac->regulator) == -EPROBE_DEFER) {
+			dev_dbg(dev, "phy regulator is not available yet, deferred probing\n");
+			return -EPROBE_DEFER;
+		}
+		dev_dbg(dev, "no regulator found\n");
+		dwmac->regulator = NULL;
+	}
 
-	return err;
+	return 0;
 }
 
 static int stm32mp1_parse_data(struct stm32_dwmac *dwmac,
 			       struct device *dev)
 {
-	struct platform_device *pdev = to_platform_device(dev);
 	struct device_node *np = dev->of_node;
-	int err = 0;
 
 	/* Ethernet PHY have no crystal */
 	dwmac->ext_phyclk = of_property_read_bool(np, "st,ext-phyclk");
 
+	/* PTP (IEEE1588) clock selection */
+	dwmac->eth_ptp_sel_reg = of_property_read_bool(np, "st,eth-ptp-from-rcc");
+
 	/* Gigabit Ethernet 125MHz clock selection. */
 	dwmac->eth_clk_sel_reg = of_property_read_bool(np, "st,eth-clk-sel");
 
@@ -317,7 +423,7 @@ static int stm32mp1_parse_data(struct stm32_dwmac *dwmac,
 	/*  Get ETH_CLK clocks */
 	dwmac->clk_eth_ck = devm_clk_get(dev, "eth-ck");
 	if (IS_ERR(dwmac->clk_eth_ck)) {
-		dev_info(dev, "No phy clock provided...\n");
+		dev_dbg(dev, "No phy clock provided...\n");
 		dwmac->clk_eth_ck = NULL;
 	}
 
@@ -334,29 +440,45 @@ static int stm32mp1_parse_data(struct stm32_dwmac *dwmac,
 	if (IS_ERR(dwmac->syscfg_clk))
 		dwmac->syscfg_clk = NULL;
 
-	/* Get IRQ information early to have an ability to ask for deferred
-	 * probe if needed before we went too far with resource allocation.
-	 */
-	dwmac->irq_pwr_wakeup = platform_get_irq_byname_optional(pdev,
-							"stm32_pwr_wakeup");
-	if (dwmac->irq_pwr_wakeup == -EPROBE_DEFER)
-		return -EPROBE_DEFER;
-
-	if (!dwmac->clk_eth_ck && dwmac->irq_pwr_wakeup >= 0) {
-		err = device_init_wakeup(&pdev->dev, true);
-		if (err) {
-			dev_err(&pdev->dev, "Failed to init wake up irq\n");
-			return err;
-		}
-		err = dev_pm_set_dedicated_wake_irq(&pdev->dev,
-						    dwmac->irq_pwr_wakeup);
-		if (err) {
-			dev_err(&pdev->dev, "Failed to set wake up irq\n");
-			device_init_wakeup(&pdev->dev, false);
-		}
-		device_set_wakeup_enable(&pdev->dev, false);
+	return 0;
+}
+
+static int stm32_dwmac_wake_init(struct device *dev,
+				 struct stmmac_resources *stmmac_res)
+{
+	int err;
+
+	device_set_wakeup_capable(dev, true);
+
+	err = dev_pm_set_wake_irq(dev, stmmac_res->wol_irq);
+	if (err) {
+		dev_err(dev, "Failed to set wake up irq\n");
+		device_set_wakeup_capable(dev, false);
+		return err;
 	}
-	return err;
+
+	return 0;
+}
+
+static int phy_power_on(struct stm32_dwmac *bsp_priv, bool enable)
+{
+	int ret;
+	struct device *dev = bsp_priv->dev;
+
+	if (!bsp_priv->regulator)
+		return 0;
+
+	if (enable) {
+		ret = regulator_enable(bsp_priv->regulator);
+		if (ret)
+			dev_err(dev, "fail to enable phy-supply\n");
+	} else {
+		ret = regulator_disable(bsp_priv->regulator);
+		if (ret)
+			dev_err(dev, "fail to disable phy-supply\n");
+	}
+
+	return 0;
 }
 
 static int stm32_dwmac_probe(struct platform_device *pdev)
@@ -397,23 +519,39 @@ static int stm32_dwmac_probe(struct platform_device *pdev)
 		goto err_remove_config_dt;
 	}
 
+	if (stmmac_res.wol_irq && !dwmac->clk_eth_ck) {
+		ret = stm32_dwmac_wake_init(&pdev->dev, &stmmac_res);
+		if (ret)
+			goto err_wake_init_disable;
+	}
+
 	plat_dat->bsp_priv = dwmac;
 
 	ret = stm32_dwmac_init(plat_dat);
 	if (ret)
-		goto err_remove_config_dt;
+		goto err_wake_init_disable;
 
-	ret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);
+	ret = phy_power_on(plat_dat->bsp_priv, true);
 	if (ret)
 		goto err_clk_disable;
 
+	ret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);
+	if (ret)
+		goto err_gmac_powerdown;
+
 	return 0;
 
+err_gmac_powerdown:
+	phy_power_on(plat_dat->bsp_priv, false);
 err_clk_disable:
 	stm32_dwmac_clk_disable(dwmac);
+err_wake_init_disable:
+	if (stmmac_res.wol_irq && !dwmac->clk_eth_ck) {
+		dev_pm_clear_wake_irq(&pdev->dev);
+		device_set_wakeup_capable(&pdev->dev, false);
+	}
 err_remove_config_dt:
 	stmmac_remove_config_dt(pdev, plat_dat);
-
 	return ret;
 }
 
@@ -422,14 +560,16 @@ static int stm32_dwmac_remove(struct platform_device *pdev)
 	struct net_device *ndev = platform_get_drvdata(pdev);
 	struct stmmac_priv *priv = netdev_priv(ndev);
 	int ret = stmmac_dvr_remove(&pdev->dev);
-	struct stm32_dwmac *dwmac = priv->plat->bsp_priv;
+
+	if (ret)
+		return ret;
 
 	stm32_dwmac_clk_disable(priv->plat->bsp_priv);
 
-	if (dwmac->irq_pwr_wakeup >= 0) {
-		dev_pm_clear_wake_irq(&pdev->dev);
-		device_init_wakeup(&pdev->dev, false);
-	}
+	dev_pm_clear_wake_irq(&pdev->dev);
+	ret = device_init_wakeup(&pdev->dev, false);
+
+	phy_power_on(priv->plat->bsp_priv, false);
 
 	return ret;
 }
@@ -447,12 +587,20 @@ static int stm32mp1_suspend(struct stm32_dwmac *dwmac)
 	if (dwmac->enable_eth_ck)
 		clk_disable_unprepare(dwmac->clk_eth_ck);
 
+	/* Keep the PHY up if we use Wake-on-Lan. */
+	if (!device_may_wakeup(dwmac->dev))
+		phy_power_on(dwmac, false);
+
 	return ret;
 }
 
 static void stm32mp1_resume(struct stm32_dwmac *dwmac)
 {
 	clk_disable_unprepare(dwmac->clk_ethstp);
+
+	/* The PHY was up for Wake-on-Lan. */
+	if (!device_may_wakeup(dwmac->dev))
+		phy_power_on(dwmac, true);
 }
 
 static int stm32mcu_suspend(struct stm32_dwmac *dwmac)
@@ -506,7 +654,6 @@ static SIMPLE_DEV_PM_OPS(stm32_dwmac_pm_ops,
 static struct stm32_ops stm32mcu_dwmac_data = {
 	.set_mode = stm32mcu_set_mode,
 	.suspend = stm32mcu_suspend,
-	.syscfg_eth_mask = SYSCFG_MCU_ETH_MASK
 };
 
 static struct stm32_ops stm32mp1_dwmac_data = {
@@ -515,12 +662,54 @@ static struct stm32_ops stm32mp1_dwmac_data = {
 	.suspend = stm32mp1_suspend,
 	.resume = stm32mp1_resume,
 	.parse_data = stm32mp1_parse_data,
-	.syscfg_eth_mask = SYSCFG_MP1_ETH_MASK
+	.syscfg_clr_off = 0x44,
+	.pmcsetr = {
+		.eth1_clk_sel		= BIT(16),
+		.eth1_ref_clk_sel	= BIT(17),
+		.eth1_selmii		= BIT(20),
+		.eth1_sel_rgmii		= BIT(21),
+		.eth1_sel_rmii		= BIT(23),
+		.eth2_clk_sel		= 0,
+		.eth2_ref_clk_sel	= 0,
+		.eth2_sel_rgmii		= 0,
+		.eth2_sel_rmii		= 0
+	}
+};
+
+static struct stm32_ops stm32mp13_dwmac_data = {
+	.set_mode = stm32mp1_set_mode,
+	.clk_prepare = stm32mp1_clk_prepare,
+	.suspend = stm32mp1_suspend,
+	.resume = stm32mp1_resume,
+	.parse_data = stm32mp1_parse_data,
+	.syscfg_clr_off = 0x08,
+	.pmcsetr = {
+		.eth1_clk_sel		= BIT(16),
+		.eth1_ref_clk_sel	= BIT(17),
+		.eth1_selmii		= 0,
+		.eth1_sel_rgmii		= BIT(21),
+		.eth1_sel_rmii		= BIT(23),
+		.eth2_clk_sel		= BIT(24),
+		.eth2_ref_clk_sel	= BIT(25),
+		.eth2_sel_rgmii		= BIT(29),
+		.eth2_sel_rmii		= BIT(31)
+	}
+};
+
+static struct stm32_ops stm32mp25_dwmac_data = {
+	.set_mode = stm32mp2_set_mode,
+	.clk_prepare = stm32mp1_clk_prepare,
+	.suspend = stm32mp1_suspend,
+	.resume = stm32mp1_resume,
+	.parse_data = stm32mp1_parse_data,
+	.syscfg_eth_mask = SYSCFG_MP2_ETH_MASK
 };
 
 static const struct of_device_id stm32_dwmac_match[] = {
 	{ .compatible = "st,stm32-dwmac", .data = &stm32mcu_dwmac_data},
 	{ .compatible = "st,stm32mp1-dwmac", .data = &stm32mp1_dwmac_data},
+	{ .compatible = "st,stm32mp13-dwmac", .data = &stm32mp13_dwmac_data},
+	{ .compatible = "st,stm32mp25-dwmac", .data = &stm32mp25_dwmac_data},
 	{ }
 };
 MODULE_DEVICE_TABLE(of, stm32_dwmac_match);
diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index b616f55ea..891fc76fe 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -319,7 +319,7 @@ static __maybe_unused int mdio_bus_phy_resume(struct device *dev)
 	 * PHY_HALTED nor PHY_READY this is an indication that something went wrong
 	 * and we should most likely be using MAC managed PM and we are not.
 	 */
-	WARN_ON(phydev->state != PHY_HALTED && phydev->state != PHY_READY);
+//	WARN_ON(phydev->state != PHY_HALTED && phydev->state != PHY_READY);
 
 	ret = phy_init_hw(phydev);
 	if (ret < 0)
diff --git a/drivers/net/phy/realtek.c b/drivers/net/phy/realtek.c
index 11be60333..b8c3476a4 100644
--- a/drivers/net/phy/realtek.c
+++ b/drivers/net/phy/realtek.c
@@ -116,6 +116,16 @@ static int rtl821x_probe(struct phy_device *phydev)
 	if (of_property_read_bool(dev->of_node, "realtek,clkout-disable"))
 		priv->phycr2 &= ~RTL8211F_CLKOUT_EN;
 
+	if (of_property_read_bool(dev->of_node, "realtek,eee-disable")) {
+		rtl821x_write_page(phydev, 0xa4b);
+		phy_write(phydev, 0x11, 0x1110);
+		rtl821x_write_page(phydev, 0);
+		phy_write(phydev, 0xd,7);
+		phy_write(phydev, 0xe,0x3c);
+		phy_write(phydev, 0xd,0x4007);
+		phy_write(phydev, 0xe,0x0);
+	}
+
 	phydev->priv = priv;
 
 	return 0;
@@ -336,14 +346,10 @@ static int rtl8211f_config_init(struct phy_device *phydev)
 	u16 val_txdly, val_rxdly;
 	int ret;
 
-	ret = phy_modify_paged_changed(phydev, 0xa43, RTL8211F_PHYCR1,
-				       RTL8211F_ALDPS_PLL_OFF | RTL8211F_ALDPS_ENABLE | RTL8211F_ALDPS_XTAL_OFF,
-				       priv->phycr1);
-	if (ret < 0) {
-		dev_err(dev, "aldps mode  configuration failed: %pe\n",
-			ERR_PTR(ret));
-		return ret;
-	}
+	/* Set green LED for Link, yellow LED for Active */
+	phy_write(phydev, RTL821x_PAGE_SELECT, 0xd04);
+	phy_write(phydev, 0x10, 0x617f);
+	phy_write(phydev, RTL821x_PAGE_SELECT, 0x0);
 
 	switch (phydev->interface) {
 	case PHY_INTERFACE_MODE_RGMII:
diff --git a/drivers/net/phy/smsc.c b/drivers/net/phy/smsc.c
index 636b0907a..634dd7f85 100644
--- a/drivers/net/phy/smsc.c
+++ b/drivers/net/phy/smsc.c
@@ -45,6 +45,7 @@ static struct smsc_hw_stat smsc_hw_stats[] = {
 
 struct smsc_phy_priv {
 	bool energy_enable;
+	bool wakeup_enable;
 	struct clk *refclk;
 };
 
@@ -69,6 +70,8 @@ static int smsc_phy_config_intr(struct phy_device *phydev)
 		intmask = MII_LAN83C185_ISF_INT4 | MII_LAN83C185_ISF_INT6;
 		if (priv->energy_enable)
 			intmask |= MII_LAN83C185_ISF_INT7;
+		if (priv->wakeup_enable)
+			intmask |= MII_LAN83C185_ISF_INT8;
 		rc = phy_write(phydev, MII_LAN83C185_IM, intmask);
 	} else {
 		rc = phy_write(phydev, MII_LAN83C185_IM, intmask);
@@ -105,11 +108,52 @@ static irqreturn_t smsc_phy_handle_interrupt(struct phy_device *phydev)
 	return IRQ_HANDLED;
 }
 
+static int smsc_phy_config_wol(struct phy_device *phydev)
+{
+	int i, wol_ctrl, wol_filter;
+	u16 pwd[3] = {0, 0, 0};
+
+	/* Write @MAC in LAN8742_MMD3_MAC_ADDRA/B/C registers */
+	u8 *mac_addr = phydev->attached_dev->dev_addr;
+	/* Store the device address for the magic packet */
+	for (i = 0; i < ARRAY_SIZE(pwd); i++)
+		pwd[i] = mac_addr[5 - i * 2] << 8 | mac_addr[5 - (i * 2 + 1)];
+
+	phy_write_mmd(phydev, 3, LAN8742_MMD3_MAC_ADDRA,
+		      pwd[0]);
+
+	phy_write_mmd(phydev, 3, LAN8742_MMD3_MAC_ADDRB,
+		      pwd[1]);
+
+	phy_write_mmd(phydev, 3, LAN8742_MMD3_MAC_ADDRC,
+		      pwd[2]);
+
+	/* Configure WoL */
+	wol_ctrl = phy_read_mmd(phydev, 3, LAN8742_MMD3_WAKEUP_CTRL);
+
+	/* Configure LED2 functions as nPME, WoL Configured, Magic Packet Enable */
+	wol_ctrl |= (LAN8742_MMD3_WUCSR_LED2_AS_NPME | LAN8742_MMD3_WUCSR_WOL | LAN8742_MMD3_WUCSR_MPEN);
+	phy_write_mmd(phydev, 3, LAN8742_MMD3_WAKEUP_CTRL,
+		      wol_ctrl);
+
+	wol_filter = phy_read_mmd(phydev, 3, LAN8742_MMD3_WAKEUP_FILTER);
+
+	/* Configure Filter enabled, Address Match Enable */
+	wol_filter |= (LAN8742_MMD3_WUF_CFGA_FE | LAN8742_MMD3_WUF_CFGA_AME);
+	phy_write_mmd(phydev, 3, LAN8742_MMD3_WAKEUP_FILTER,
+		      wol_filter);
+
+	return 0;
+}
+
 static int smsc_phy_config_init(struct phy_device *phydev)
 {
 	struct smsc_phy_priv *priv = phydev->priv;
 	int rc;
 
+	if (priv->wakeup_enable)
+		smsc_phy_config_wol(phydev);
+
 	if (!priv->energy_enable || phydev->irq != PHY_POLL)
 		return 0;
 
@@ -146,6 +190,17 @@ static int smsc_phy_reset(struct phy_device *phydev)
 	return genphy_soft_reset(phydev);
 }
 
+static int smsc_phy_suspend(struct phy_device *phydev)
+{
+	struct device *dev = &phydev->mdio.dev;
+
+	/* do not power down PHY when PHY enable power/wakeup */
+	if (!device_may_wakeup(dev))
+		return genphy_suspend(phydev);
+
+	return 0;
+}
+
 static int lan911x_config_init(struct phy_device *phydev)
 {
 	return smsc_phy_ack_interrupt(phydev);
@@ -251,6 +306,20 @@ static int lan87xx_read_status(struct phy_device *phydev)
 			return rc;
 	}
 
+	if (priv->wakeup_enable) {
+		/* Check status of WUCSR bits 7:4 : Perfect DA Frame, Remote Wakeup
+		 * Frame, Magic Packet, Broadcast Frame Received, if one of these bits
+		 * are 1, clearing them*/
+		int wol_ctrl = phy_read_mmd(phydev, 3, LAN8742_MMD3_WAKEUP_CTRL);
+
+		if ((wol_ctrl & (LAN8742_MMD3_WUCSR_PFDA_FR | LAN8742_MMD3_WUCSR_WUFR |
+				 LAN8742_MMD3_WUCSR_MPR | LAN8742_MMD3_WUCSR_BCAST_FR)) > 0) {
+			wol_ctrl |= (LAN8742_MMD3_WUCSR_PFDA_FR | LAN8742_MMD3_WUCSR_WUFR |
+				     LAN8742_MMD3_WUCSR_MPR | LAN8742_MMD3_WUCSR_BCAST_FR);
+			phy_write_mmd(phydev, 3, LAN8742_MMD3_WAKEUP_CTRL,
+				      wol_ctrl);
+		}
+	}
 	return err;
 }
 
@@ -313,10 +382,16 @@ static int smsc_phy_probe(struct phy_device *phydev)
 		return -ENOMEM;
 
 	priv->energy_enable = true;
+	priv->wakeup_enable = false;
 
 	if (of_property_read_bool(of_node, "smsc,disable-energy-detect"))
 		priv->energy_enable = false;
 
+	if (of_property_read_bool(of_node, "wakeup-source")) {
+		device_set_wakeup_capable(dev, true);
+		priv->wakeup_enable = true;
+	}
+
 	phydev->priv = priv;
 
 	/* Make clk optional to keep DTB backward compatibility. */
@@ -485,6 +560,32 @@ static struct phy_driver smsc_phy_driver[] = {
 
 	.suspend	= genphy_suspend,
 	.resume		= genphy_resume,
+}, {
+	.phy_id		= 0x0007c130,
+	.phy_id_mask	= 0xfffffff0,
+	.name		= "SMSC LAN8742A",
+
+	/* PHY_BASIC_FEATURES */
+	.flags		= PHY_RST_AFTER_CLK_EN,
+
+	.probe		= smsc_phy_probe,
+
+	/* basic functions */
+	.read_status	= lan87xx_read_status,
+	.config_init	= smsc_phy_config_init,
+	.soft_reset	= smsc_phy_reset,
+
+	/* IRQ related */
+	.config_intr	= smsc_phy_config_intr,
+	.handle_interrupt = smsc_phy_handle_interrupt,
+
+	/* Statistics */
+	.get_sset_count = smsc_get_sset_count,
+	.get_strings	= smsc_get_strings,
+	.get_stats	= smsc_get_stats,
+
+	.suspend	= smsc_phy_suspend,
+	.resume		= genphy_resume,
 } };
 
 module_phy_driver(smsc_phy_driver);
@@ -500,6 +601,7 @@ static struct mdio_device_id __maybe_unused smsc_tbl[] = {
 	{ 0x0007c0d0, 0xfffffff0 },
 	{ 0x0007c0f0, 0xfffffff0 },
 	{ 0x0007c110, 0xfffffff0 },
+	{ 0x0007c130, 0xfffffff0 },
 	{ }
 };
 
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
index ac02244a6..9c598ea97 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
@@ -1119,9 +1119,21 @@ void brcmf_sdio_wowl_config(struct device *dev, bool enabled)
 {
 	struct brcmf_bus *bus_if = dev_get_drvdata(dev);
 	struct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
+	mmc_pm_flag_t pm_caps = sdio_get_host_pm_caps(sdiodev->func1);
 
-	brcmf_dbg(SDIO, "Configuring WOWL, enabled=%d\n", enabled);
-	sdiodev->wowl_enabled = enabled;
+	/* Power must be preserved to be able to support WOWL. */
+	if (!(pm_caps & MMC_PM_KEEP_POWER))
+		goto notsup;
+
+	if (sdiodev->settings->bus.sdio.oob_irq_supported ||
+	    pm_caps & MMC_PM_WAKE_SDIO_IRQ) {
+		sdiodev->wowl_enabled = enabled;
+		brcmf_dbg(SDIO, "Configuring WOWL, enabled=%d\n", enabled);
+		return;
+	}
+
+notsup:
+	brcmf_dbg(SDIO, "WOWL not supported\n");
 }
 
 #ifdef CONFIG_PM_SLEEP
@@ -1130,7 +1142,7 @@ static int brcmf_ops_sdio_suspend(struct device *dev)
 	struct sdio_func *func;
 	struct brcmf_bus *bus_if;
 	struct brcmf_sdio_dev *sdiodev;
-	mmc_pm_flag_t pm_caps, sdio_flags;
+	mmc_pm_flag_t sdio_flags;
 	int ret = 0;
 
 	func = container_of(dev, struct sdio_func, dev);
@@ -1142,20 +1154,15 @@ static int brcmf_ops_sdio_suspend(struct device *dev)
 	bus_if = dev_get_drvdata(dev);
 	sdiodev = bus_if->bus_priv.sdio;
 
-	pm_caps = sdio_get_host_pm_caps(func);
-
-	if (pm_caps & MMC_PM_KEEP_POWER) {
-		/* preserve card power during suspend */
+	if (sdiodev->wowl_enabled) {
 		brcmf_sdiod_freezer_on(sdiodev);
 		brcmf_sdio_wd_timer(sdiodev->bus, 0);
 
 		sdio_flags = MMC_PM_KEEP_POWER;
-		if (sdiodev->wowl_enabled) {
-			if (sdiodev->settings->bus.sdio.oob_irq_supported)
-				enable_irq_wake(sdiodev->settings->bus.sdio.oob_irq_nr);
-			else
-				sdio_flags |= MMC_PM_WAKE_SDIO_IRQ;
-		}
+		if (sdiodev->settings->bus.sdio.oob_irq_supported)
+			enable_irq_wake(sdiodev->settings->bus.sdio.oob_irq_nr);
+		else
+			sdio_flags |= MMC_PM_WAKE_SDIO_IRQ;
 
 		if (sdio_set_host_pm_flags(sdiodev->func1, sdio_flags))
 			brcmf_err("Failed to set pm_flags %x\n", sdio_flags);
@@ -1176,21 +1183,19 @@ static int brcmf_ops_sdio_resume(struct device *dev)
 	struct brcmf_bus *bus_if = dev_get_drvdata(dev);
 	struct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
 	struct sdio_func *func = container_of(dev, struct sdio_func, dev);
-	mmc_pm_flag_t pm_caps = sdio_get_host_pm_caps(func);
 	int ret = 0;
 
 	brcmf_dbg(SDIO, "Enter: F%d\n", func->num);
 	if (func->num != 2)
 		return 0;
 
-	if (!(pm_caps & MMC_PM_KEEP_POWER)) {
+	if (!sdiodev->wowl_enabled) {
 		/* bus was powered off and device removed, probe again */
 		ret = brcmf_sdiod_probe(sdiodev);
 		if (ret)
 			brcmf_err("Failed to probe device on resume\n");
 	} else {
-		if (sdiodev->wowl_enabled &&
-		    sdiodev->settings->bus.sdio.oob_irq_supported)
+		if (sdiodev->settings->bus.sdio.oob_irq_supported)
 			disable_irq_wake(sdiodev->settings->bus.sdio.oob_irq_nr);
 
 		brcmf_sdiod_freezer_off(sdiodev);
diff --git a/drivers/nvmem/stm32-romem.c b/drivers/nvmem/stm32-romem.c
index 354be5268..a74e90ff3 100644
--- a/drivers/nvmem/stm32-romem.c
+++ b/drivers/nvmem/stm32-romem.c
@@ -2,15 +2,18 @@
 /*
  * STM32 Factory-programmed memory read access driver
  *
- * Copyright (C) 2017, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2017-2021, STMicroelectronics - All Rights Reserved
  * Author: Fabrice Gasnier <fabrice.gasnier@st.com> for STMicroelectronics.
  */
 
 #include <linux/arm-smccc.h>
+#include <linux/clk.h>
 #include <linux/io.h>
 #include <linux/module.h>
 #include <linux/nvmem-provider.h>
 #include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/tee_drv.h>
 
 /* BSEC secure service access from non-secure */
 #define STM32_SMC_BSEC			0x82001003
@@ -22,28 +25,46 @@
 /* shadow registers offest */
 #define STM32MP15_BSEC_DATA0		0x200
 
-/* 32 (x 32-bits) lower shadow registers */
-#define STM32MP15_BSEC_NUM_LOWER	32
+#define STM32_ROMEM_AUTOSUSPEND_DELAY_MS	50
 
 struct stm32_romem_cfg {
 	int size;
+	u8 lower;
+	bool ta;
 };
 
 struct stm32_romem_priv {
 	void __iomem *base;
 	struct nvmem_config cfg;
+	struct clk *clk;
+	struct device *ta;
+	u8 lower;
 };
 
+struct device *stm32_bsec_pta_find(struct device *dev);
+static int stm32_bsec_pta_read(void *context, unsigned int offset, void *buf,
+			       size_t bytes);
+static int stm32_bsec_pta_write(void *context, unsigned int offset, void *buf,
+				size_t bytes);
+
 static int stm32_romem_read(void *context, unsigned int offset, void *buf,
 			    size_t bytes)
 {
 	struct stm32_romem_priv *priv = context;
+	struct device *dev = priv->cfg.dev;
 	u8 *buf8 = buf;
-	int i;
+	int i, ret;
+
+	ret = pm_runtime_resume_and_get(dev);
+	if (ret < 0)
+		return ret;
 
 	for (i = offset; i < offset + bytes; i++)
 		*buf8++ = readb_relaxed(priv->base + i);
 
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
 	return 0;
 }
 
@@ -65,6 +86,17 @@ static int stm32_bsec_smc(u8 op, u32 otp, u32 data, u32 *result)
 #endif
 }
 
+static bool stm32_bsec_check(void)
+{
+	u32 val;
+	int ret;
+
+	/* check that the OP-TEE support the BSEC SMC (legacy mode) */
+	ret = stm32_bsec_smc(STM32_SMC_READ_SHADOW, 0, 0, &val);
+
+	return !ret;
+}
+
 static int stm32_bsec_read(void *context, unsigned int offset, void *buf,
 			   size_t bytes)
 {
@@ -74,18 +106,24 @@ static int stm32_bsec_read(void *context, unsigned int offset, void *buf,
 	u8 *buf8 = buf, *val8 = (u8 *)&val;
 	int i, j = 0, ret, skip_bytes, size;
 
+	ret = pm_runtime_resume_and_get(dev);
+	if (ret < 0)
+		return ret;
+
 	/* Round unaligned access to 32-bits */
 	roffset = rounddown(offset, 4);
 	skip_bytes = offset & 0x3;
 	rbytes = roundup(bytes + skip_bytes, 4);
 
-	if (roffset + rbytes > priv->cfg.size)
-		return -EINVAL;
+	if (roffset + rbytes > priv->cfg.size) {
+		ret = -EINVAL;
+		goto end_read;
+	}
 
 	for (i = roffset; (i < roffset + rbytes); i += 4) {
 		u32 otp = i >> 2;
 
-		if (otp < STM32MP15_BSEC_NUM_LOWER) {
+		if (otp < priv->lower) {
 			/* read lower data from shadow registers */
 			val = readl_relaxed(
 				priv->base + STM32MP15_BSEC_DATA0 + i);
@@ -95,7 +133,7 @@ static int stm32_bsec_read(void *context, unsigned int offset, void *buf,
 			if (ret) {
 				dev_err(dev, "Can't read data%d (%d)\n", otp,
 					ret);
-				return ret;
+				goto end_read;
 			}
 		}
 		/* skip first bytes in case of unaligned read */
@@ -109,7 +147,11 @@ static int stm32_bsec_read(void *context, unsigned int offset, void *buf,
 		skip_bytes = 0;
 	}
 
-	return 0;
+end_read:
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
+	return ret;
 }
 
 static int stm32_bsec_write(void *context, unsigned int offset, void *buf,
@@ -120,20 +162,61 @@ static int stm32_bsec_write(void *context, unsigned int offset, void *buf,
 	u32 *buf32 = buf;
 	int ret, i;
 
+	ret = pm_runtime_resume_and_get(dev);
+	if (ret < 0)
+		return ret;
+
 	/* Allow only writing complete 32-bits aligned words */
-	if ((bytes % 4) || (offset % 4))
-		return -EINVAL;
+	if ((bytes % 4) || (offset % 4)) {
+		ret = -EINVAL;
+		goto end_write;
+	}
 
 	for (i = offset; i < offset + bytes; i += 4) {
 		ret = stm32_bsec_smc(STM32_SMC_PROG_OTP, i >> 2, *buf32++,
 				     NULL);
 		if (ret) {
 			dev_err(dev, "Can't write data%d (%d)\n", i >> 2, ret);
-			return ret;
+			goto end_write;
 		}
 	}
 
-	return 0;
+	if (offset + bytes >= priv->lower * 4)
+		dev_warn(dev, "Update of upper OTPs with ECC protection (word programming, only once)\n");
+
+end_write:
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
+	return ret;
+}
+
+static bool optee_presence_check(void)
+{
+	struct device_node *np;
+	bool tee_detected = false;
+
+	/* check that the OP-TEE node is present and available. */
+	np = of_find_node_by_path("/firmware/optee");
+	if (np && of_device_is_available(np))
+		tee_detected = true;
+	of_node_put(np);
+
+	return tee_detected;
+}
+
+static void stm32_romem_disable_clk(void *data)
+{
+	struct stm32_romem_priv *priv = dev_get_drvdata(data);
+
+	pm_runtime_dont_use_autosuspend(data);
+	pm_runtime_get_sync(data);
+	pm_runtime_disable(data);
+	pm_runtime_set_suspended(data);
+	pm_runtime_put_noidle(data);
+
+	if (priv->clk)
+		clk_disable_unprepare(priv->clk);
 }
 
 static int stm32_romem_probe(struct platform_device *pdev)
@@ -142,6 +225,8 @@ static int stm32_romem_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct stm32_romem_priv *priv;
 	struct resource *res;
+	struct nvmem_device *nvmem;
+	int ret;
 
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
@@ -158,6 +243,9 @@ static int stm32_romem_probe(struct platform_device *pdev)
 	priv->cfg.dev = dev;
 	priv->cfg.priv = priv;
 	priv->cfg.owner = THIS_MODULE;
+	priv->cfg.type = NVMEM_TYPE_OTP;
+
+	priv->lower = 0;
 
 	cfg = (const struct stm32_romem_cfg *)
 		of_match_device(dev->driver->of_match_table, dev)->data;
@@ -167,15 +255,131 @@ static int stm32_romem_probe(struct platform_device *pdev)
 		priv->cfg.reg_read = stm32_romem_read;
 	} else {
 		priv->cfg.size = cfg->size;
-		priv->cfg.reg_read = stm32_bsec_read;
-		priv->cfg.reg_write = stm32_bsec_write;
+		priv->lower = cfg->lower;
+		if (cfg->ta || optee_presence_check()) {
+			priv->ta = stm32_bsec_pta_find(dev);
+			/* wait for OP-TEE client driver to be up and ready */
+			if (!priv->ta) {
+				/* BSEC PTA is required or SMC not ready */
+				if (cfg->ta || !stm32_bsec_check())
+					return -EPROBE_DEFER;
+			}
+		}
+		if (priv->ta) {
+			priv->cfg.reg_read = stm32_bsec_pta_read;
+			priv->cfg.reg_write = stm32_bsec_pta_write;
+		} else {
+			priv->cfg.reg_read = stm32_bsec_read;
+			priv->cfg.reg_write = stm32_bsec_write;
+		}
+	}
+
+	platform_set_drvdata(pdev, priv);
+
+	/* the clock / pm is required only without TA support, for direct BSEC access */
+	if (!priv->ta) {
+		priv->clk = devm_clk_get_optional(&pdev->dev, NULL);
+		if (IS_ERR(priv->clk))
+			return dev_err_probe(dev, PTR_ERR(priv->clk),
+					     "failed to get clock\n");
+
+		if (priv->clk) {
+			ret = clk_prepare_enable(priv->clk);
+			if (ret)
+				return dev_err_probe(dev, ret, "failed to enable clock\n");
+		}
+
+		pm_runtime_set_autosuspend_delay(dev, STM32_ROMEM_AUTOSUSPEND_DELAY_MS);
+		pm_runtime_use_autosuspend(dev);
+		pm_runtime_get_noresume(dev);
+		pm_runtime_set_active(dev);
+		pm_runtime_enable(dev);
+		pm_runtime_put(dev);
+
+		ret = devm_add_action_or_reset(dev, stm32_romem_disable_clk, dev);
+		if (ret)
+			return dev_err_probe(dev, ret,
+					     "unable to register cleanup action\n");
+	}
+
+	nvmem = devm_nvmem_register(dev, &priv->cfg);
+
+	return PTR_ERR_OR_ZERO(nvmem);
+}
+
+static int __maybe_unused stm32_romem_runtime_suspend(struct device *dev)
+{
+	struct stm32_romem_priv *priv;
+
+	priv = dev_get_drvdata(dev);
+	if (!priv)
+		return -ENODEV;
+
+	if (priv->clk)
+		clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+
+static int __maybe_unused stm32_romem_runtime_resume(struct device *dev)
+{
+	struct stm32_romem_priv *priv;
+	int ret;
+
+	priv = dev_get_drvdata(dev);
+	if (!priv)
+		return -ENODEV;
+
+	if (priv->clk) {
+		ret = clk_prepare_enable(priv->clk);
+		if (ret) {
+			dev_err(priv->cfg.dev,
+				"Failed to prepare_enable clock (%d)\n", ret);
+			return ret;
+		}
 	}
 
-	return PTR_ERR_OR_ZERO(devm_nvmem_register(dev, &priv->cfg));
+	return 0;
 }
 
+static const struct dev_pm_ops stm32_romem_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+	SET_RUNTIME_PM_OPS(stm32_romem_runtime_suspend,
+			   stm32_romem_runtime_resume, NULL)
+};
+
+/*
+ * STM32MP13/15 BSEC OTP regions: 4096 OTP bits (with 3072 effective bits)
+ * - Lower: 1K bits, 2:1 redundancy, incremental bit programming
+ *   => 32 (x 32-bits) lower shadow registers = words 0 to 31
+ * - Upper: 2K bits, ECC protection, word programming only
+ *   => 64 (x 32-bits) = words 32 to 95
+ */
+
 static const struct stm32_romem_cfg stm32mp15_bsec_cfg = {
 	.size = 384, /* 96 x 32-bits data words */
+	.lower = 32, /* 32 word with incremental bit programming */
+	.ta = false,
+};
+
+static const struct stm32_romem_cfg stm32mp13_bsec_cfg = {
+	.size = 384, /* 96 x 32-bits data words */
+	.lower = 32, /* 32 word with incremental bit programming */
+	.ta = true,
+};
+
+/*
+ * STM32MP25 BSEC OTP: 3 regions of 32-bits data words
+ *   lower OTP (OTP0 to OTP127), bitwise (1-bit) programmable
+ *   mid OTP (OTP128 to OTP255), bulk (32-bit) programmable
+ *   upper OTP (OTP256 to OTP383), bulk (32-bit) programmable
+ *              but no access to HWKEY and ECIES key: limited at 367
+ */
+static const struct stm32_romem_cfg stm32mp25_bsec_cfg = {
+	.size = 367 * 4,
+	.lower = 127,
+	.ta = true,
 };
 
 static const struct of_device_id stm32_romem_of_match[] = {
@@ -183,6 +387,11 @@ static const struct of_device_id stm32_romem_of_match[] = {
 		.compatible = "st,stm32mp15-bsec",
 		.data = (void *)&stm32mp15_bsec_cfg,
 	}, {
+		.compatible = "st,stm32mp13-bsec",
+		.data = (void *)&stm32mp13_bsec_cfg,
+	}, {
+		.compatible = "st,stm32mp25-bsec",
+		.data = (void *)&stm32mp25_bsec_cfg,
 	},
 };
 MODULE_DEVICE_TABLE(of, stm32_romem_of_match);
@@ -191,10 +400,425 @@ static struct platform_driver stm32_romem_driver = {
 	.probe = stm32_romem_probe,
 	.driver = {
 		.name = "stm32-romem",
+		.pm = &stm32_romem_pm_ops,
 		.of_match_table = of_match_ptr(stm32_romem_of_match),
 	},
 };
-module_platform_driver(stm32_romem_driver);
+
+#if IS_ENABLED(CONFIG_OPTEE)
+/*************************************************************************
+ * BSEC PTA : OP-TEE client driver to pseudo trusted application
+ *************************************************************************/
+
+/*
+ * Read OTP memory
+ *
+ * [in]		value[0].a		OTP start offset in byte
+ * [in]		value[0].b		Access type (0 : shadow,
+ *					1 : fuse, 2 : lock)
+ * [out]	memref[1].buffer	Output buffer to store read values
+ * [out]	memref[1].size		Size of OTP to be read
+ *
+ * Return codes:
+ * TEE_SUCCESS - Invoke command success
+ * TEE_ERROR_BAD_PARAMETERS - Incorrect input param
+ */
+#define PTA_BSEC_READ_MEM		0x0 /* Read OTP */
+
+/*
+ * Write OTP memory
+ *
+ * [in]		value[0].a		OTP start offset in byte
+ * [in]		value[0].b		Access type (0 : shadow,
+ *					1 : fuse, 2 : lock)
+ * [in]		memref[1].buffer	Input buffer to read values
+ * [in]		memref[1].size		Size of OTP to be written
+ *
+ * Return codes:
+ * TEE_SUCCESS - Invoke command success
+ * TEE_ERROR_BAD_PARAMETERS - Incorrect input param
+ */
+#define PTA_BSEC_WRITE_MEM		0x1	/* Write OTP */
+
+/* value of PTA_BSEC access type = value[in] b */
+#define SHADOW_ACCESS	0
+#define FUSE_ACCESS	1
+#define LOCK_ACCESS	2
+
+/* Bitfield definition for LOCK status */
+#define LOCK_PERM			BIT(30)
+
+/**
+ * struct stm32_bsec_pta_priv - OP-TEE BSEC TA private data
+ * @ctx:		OP-TEE context handler.
+ * @session_id:		TA session identifier.
+ */
+struct stm32_bsec_pta_priv {
+	struct tee_context *ctx;
+	u32 session_id;
+};
+
+/*
+ * Check whether this driver supports the BSEC TA in the TEE instance
+ * represented by the params (ver/data) to this function.
+ */
+static int stm32_bsec_pta_match(struct tee_ioctl_version_data *ver, const void *data)
+{
+	/*
+	 * Currently this driver only supports GP compliant, OP-TEE based TA
+	 */
+	if ((ver->impl_id == TEE_IMPL_ID_OPTEE) &&
+		(ver->gen_caps & TEE_GEN_CAP_GP))
+		return 1;
+	else
+		return 0;
+}
+
+/**
+ * stm32_bsec_pta_probe() - initialize the PTA BSEC
+ * @dev: the platform_device description.
+ *
+ * Return:
+ *	On success, 0. On failure, -errno.
+ */
+static int stm32_bsec_pta_probe(struct device *dev)
+{
+	int rc;
+	struct tee_ioctl_open_session_arg sess_arg;
+	struct tee_client_device *tee_device = to_tee_client_device(dev);
+	struct stm32_bsec_pta_priv *priv;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	/* Open context with TEE driver */
+	priv->ctx = tee_client_open_context(NULL, stm32_bsec_pta_match, NULL, NULL);
+	if (IS_ERR(priv->ctx)) {
+		if (PTR_ERR(priv->ctx) == -ENOENT)
+			return -EPROBE_DEFER;
+		dev_err(dev, "%s: tee_client_open_context failed\n", __func__);
+		return PTR_ERR(priv->ctx);
+	}
+
+	/* Open a session with BSEC TA */
+	memset(&sess_arg, 0, sizeof(sess_arg));
+	export_uuid(sess_arg.uuid, &tee_device->id.uuid);
+	sess_arg.clnt_login = TEE_IOCTL_LOGIN_REE_KERNEL;
+	sess_arg.num_params = 0;
+
+	rc = tee_client_open_session(priv->ctx, &sess_arg, NULL);
+	if ((rc < 0) || (sess_arg.ret != 0)) {
+		dev_err(dev, "%s: tee_client_open_session failed, err=%x\n",
+			__func__, sess_arg.ret);
+		rc = -EINVAL;
+		goto out_tee_session;
+	}
+	priv->session_id = sess_arg.session;
+	dev_set_drvdata(dev, priv);
+
+	return 0;
+
+out_tee_session:
+	tee_client_close_context(priv->ctx);
+	priv->ctx = NULL;
+
+	return rc;
+}
+
+/**
+ * stm32_bsec_pta_remove() - remove the BSEC TEE device
+ * @dev: the platform_device description.
+ *
+ * Return:
+ *	0 always.
+ */
+static int stm32_bsec_pta_remove(struct device *dev)
+{
+	struct stm32_bsec_pta_priv *priv = dev_get_drvdata(dev);
+
+	if (!IS_ERR_OR_NULL(priv->ctx)) {
+		tee_client_close_session(priv->ctx, priv->session_id);
+		tee_client_close_context(priv->ctx);
+	}
+
+	return 0;
+}
+
+/**
+ * stm32_bsec_pta_read() - nvmem read access using PTA client driver
+ * @context: nvmem context => romem privdate data
+ * @offset: nvmem offset
+ * @buf: buffer to fill with nvem values
+ * @bytes: number of bytes to read
+ *
+ * Return:
+ *	On success, 0. On failure, -errno.
+ */
+static int stm32_bsec_pta_read(void *context, unsigned int offset, void *buf,
+			       size_t bytes)
+{
+	struct stm32_romem_priv *romem_priv = context;
+	struct device *dev;
+	struct stm32_bsec_pta_priv *priv;
+	struct tee_shm *shm;
+	struct tee_ioctl_invoke_arg arg;
+	struct tee_param param[2];
+	u8 *shm_buf;
+	u32 start, num_bytes;
+	int ret;
+
+	dev = romem_priv->ta;
+	if (!dev) {
+		pr_err("TA_BSEC invoke with driver\n");
+		return -ENXIO;
+	}
+
+	priv = dev_get_drvdata(dev);
+
+	memset(&arg, 0, sizeof(arg));
+	memset(&param, 0, sizeof(param));
+
+	arg.func = PTA_BSEC_READ_MEM;
+	arg.session = priv->session_id;
+	arg.num_params = 2;
+
+	/* align access on 32bits */
+	start = ALIGN_DOWN(offset, 4);
+	num_bytes = round_up(offset + bytes - start, 4);
+	param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;
+	param[0].u.value.a = start;
+	param[0].u.value.b = SHADOW_ACCESS;
+
+	shm = tee_shm_alloc(priv->ctx, num_bytes, TEE_SHM_MAPPED | TEE_SHM_DMA_BUF);
+	if (IS_ERR(shm))
+		return PTR_ERR(shm);
+
+	param[1].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+	param[1].u.memref.shm = shm;
+	param[1].u.memref.size = num_bytes;
+
+	ret = tee_client_invoke_func(priv->ctx, &arg, param);
+	if (ret < 0 || arg.ret != 0) {
+		dev_err(dev, "TA_BSEC invoke failed TEE err: %x, ret:%x\n",
+			arg.ret, ret);
+		if (!ret)
+			ret = -EIO;
+	}
+	if (!ret) {
+		shm_buf = tee_shm_get_va(shm, 0);
+		if (IS_ERR(shm_buf)) {
+			dev_err(dev, "tee_shm_get_va failed for transmit\n");
+			ret = PTR_ERR(shm_buf);
+		} else {
+			ret = 0;
+			/* read data from 32 bits aligned buffer */
+			memcpy(buf, &shm_buf[offset % 4], bytes);
+		}
+	}
+
+	tee_shm_free(shm);
+
+	return ret;
+}
+
+/**
+ * stm32_bsec_pta_write() - nvmem write access using PTA client driver
+ * @context: nvmem context => romem privdate data
+ * @offset: nvmem offset
+ * @buf: buffer with nvem values
+ * @bytes: number of bytes to write
+ *
+ * Return:
+ *	On success, 0. On failure, -errno.
+ */
+static int stm32_bsec_pta_write(void *context, unsigned int offset, void *buf,
+				size_t bytes)
+{
+	struct stm32_romem_priv *romem_priv = context;
+	struct device *dev;
+	struct stm32_bsec_pta_priv *priv;
+	struct tee_shm *shm;
+	struct tee_ioctl_invoke_arg arg;
+	struct tee_param param[2];
+	u8 *shm_buf;
+	int ret;
+
+	dev = romem_priv->ta;
+	if (!dev) {
+		pr_err("TA_BSEC invoke with driver\n");
+		return -ENXIO;
+	}
+
+	/* Allow only writing complete 32-bits aligned words */
+	if ((bytes % 4) || (offset % 4))
+		return -EINVAL;
+
+	priv = dev_get_drvdata(dev);
+
+	memset(&arg, 0, sizeof(arg));
+	memset(&param, 0, sizeof(param));
+
+	arg.func = PTA_BSEC_WRITE_MEM;
+	arg.session = priv->session_id;
+	arg.num_params = 2;
+
+	param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;
+	param[0].u.value.a = offset;
+	param[0].u.value.b = FUSE_ACCESS;
+
+	shm = tee_shm_alloc(priv->ctx, bytes, TEE_SHM_MAPPED | TEE_SHM_DMA_BUF);
+	if (IS_ERR(shm))
+		return PTR_ERR(shm);
+
+	param[1].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+	param[1].u.memref.shm = shm;
+	param[1].u.memref.size = bytes;
+
+	shm_buf = tee_shm_get_va(shm, 0);
+	if (IS_ERR(shm_buf)) {
+		dev_err(dev, "tee_shm_get_va failed for transmit\n");
+		return PTR_ERR(shm_buf);
+	}
+
+	memcpy(shm_buf, buf, bytes);
+
+	ret = tee_client_invoke_func(priv->ctx, &arg, param);
+	if (ret < 0 || arg.ret != 0) {
+		dev_err(dev, "TA_BSEC invoke failed TEE err: %x, ret:%x\n",
+			arg.ret, ret);
+		if (!ret)
+			ret = -EIO;
+	}
+	dev_dbg(dev, "Write OTPs %d to %zu, ret=%d\n",
+		offset / 4, (offset + bytes) / 4, ret);
+
+	/* Lock the upper OTPs with ECC protection, word programming only */
+	if (!ret && ((offset + bytes) >= (romem_priv->lower * 4))) {
+		u32 start, nb_lock;
+		u32 *lock = (u32 *)shm_buf;
+		int i;
+
+		/*
+		 * don't lock the lower OTPs, no ECC protection and incremental
+		 * bit programming, a second write is allowed
+		 */
+		start = max_t(u32, offset, romem_priv->lower * 4);
+		nb_lock = (offset + bytes - start) / 4;
+
+		param[0].u.value.a = start;
+		param[0].u.value.b = LOCK_ACCESS;
+		param[1].u.memref.size = nb_lock * 4;
+
+		for (i = 0; i < nb_lock; i++)
+			lock[i] = LOCK_PERM;
+
+		ret = tee_client_invoke_func(priv->ctx, &arg, param);
+		if (ret < 0 || arg.ret != 0) {
+			dev_err(dev, "TA_BSEC invoke failed TEE err: %x, ret:%x\n",
+				arg.ret, ret);
+			if (!ret)
+				ret = -EIO;
+		}
+		dev_dbg(dev, "Lock upper OTPs %d to %d, ret=%d\n",
+			start / 4, start / 4 + nb_lock, ret);
+	}
+
+	tee_shm_free(shm);
+
+	return ret;
+}
+
+static const struct tee_client_device_id stm32_bsec_id_table[] = {
+	{
+		UUID_INIT(0x94cf71ad, 0x80e6, 0x40b5,
+			  0xa7, 0xc6, 0x3d, 0xc5, 0x01, 0xeb, 0x28, 0x03)
+	},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(tee, stm32_bsec_id_table);
+
+static struct tee_client_driver stm32_bsec_pta_driver = {
+	.id_table	= stm32_bsec_id_table,
+	.driver		= {
+		.name = "stm32-bsec-pta",
+		.bus = &tee_bus_type,
+		.probe = stm32_bsec_pta_probe,
+		.remove = stm32_bsec_pta_remove,
+	},
+};
+
+static void stm32_bsec_put_device(void *data)
+{
+	put_device(data);
+}
+
+struct device *stm32_bsec_pta_find(struct device *dev)
+{
+	struct device *pta_dev;
+
+	pta_dev = driver_find_next_device(&stm32_bsec_pta_driver.driver, NULL);
+
+	if (pta_dev && devm_add_action_or_reset(dev, stm32_bsec_put_device, pta_dev)) {
+		dev_err(dev, "unable to register cleanup action\n");
+
+		return NULL;
+	}
+
+	return pta_dev;
+}
+
+#else
+static int stm32_bsec_pta_read(void *context, unsigned int offset, void *buf,
+			       size_t bytes)
+{
+	pr_debug("%s: TA BSEC request without OPTEE support\n", __func__);
+
+	return -ENXIO;
+}
+
+static int stm32_bsec_pta_write(void *context, unsigned int offset, void *buf,
+				size_t bytes)
+{
+	pr_debug("%s: TA BSEC request without OPTEE support\n", __func__);
+
+	return -ENXIO;
+}
+
+struct device *stm32_bsec_pta_find(struct device *dev)
+{
+	pr_debug("%s: TA BSEC request without OPTEE support\n", __func__);
+
+	return NULL;
+}
+#endif
+
+static int __init stm32_romem_init(void)
+{
+	int rc;
+
+	rc = platform_driver_register(&stm32_romem_driver);
+	if (rc)
+		return rc;
+
+#if IS_ENABLED(CONFIG_OPTEE)
+	rc = driver_register(&stm32_bsec_pta_driver.driver);
+#endif
+
+	return rc;
+}
+
+static void __exit stm32_romem_exit(void)
+{
+	platform_driver_unregister(&stm32_romem_driver);
+#if IS_ENABLED(CONFIG_OPTEE)
+	driver_unregister(&stm32_bsec_pta_driver.driver);
+#endif
+}
+
+module_init(stm32_romem_init);
+module_exit(stm32_romem_exit);
 
 MODULE_AUTHOR("Fabrice Gasnier <fabrice.gasnier@st.com>");
 MODULE_DESCRIPTION("STMicroelectronics STM32 RO-MEM");
diff --git a/drivers/of/platform.c b/drivers/of/platform.c
index 74afbb7a4..654ca9e98 100644
--- a/drivers/of/platform.c
+++ b/drivers/of/platform.c
@@ -537,6 +537,10 @@ static int __init of_platform_default_populate_init(void)
 		of_node_put(node);
 	}
 
+	node = of_get_compatible_child(of_chosen, "simple-framebuffer");
+	of_platform_device_create(node, NULL, NULL);
+	of_node_put(node);
+
 	/* Populate everything else. */
 	of_platform_default_populate(NULL, NULL, NULL);
 
diff --git a/drivers/pci/controller/dwc/Kconfig b/drivers/pci/controller/dwc/Kconfig
index 76c0a63a3..2104b8daf 100644
--- a/drivers/pci/controller/dwc/Kconfig
+++ b/drivers/pci/controller/dwc/Kconfig
@@ -376,4 +376,17 @@ config PCIE_FU740
 	  Say Y here if you want PCIe controller support for the SiFive
 	  FU740.
 
+config PCIE_STM32
+       tristate
+
+config PCIE_STM32_HOST
+	tristate "STMicroelectronics PCIe Controller Host Mode for STM32 MP25"
+	depends on ARCH_STM32 || COMPILE_TEST
+	depends on PCI_MSI_IRQ_DOMAIN
+	select PCIE_DW_HOST
+	select PCIE_STM32
+	help
+	  Say Y here if you want support for DesignWare core based PCIe host
+	  controller found in STM32 MP25 Soc.
+
 endmenu
diff --git a/drivers/pci/controller/dwc/Makefile b/drivers/pci/controller/dwc/Makefile
index 732444097..4a7d87410 100644
--- a/drivers/pci/controller/dwc/Makefile
+++ b/drivers/pci/controller/dwc/Makefile
@@ -24,6 +24,7 @@ obj-$(CONFIG_PCIE_TEGRA194) += pcie-tegra194.o
 obj-$(CONFIG_PCIE_UNIPHIER) += pcie-uniphier.o
 obj-$(CONFIG_PCIE_UNIPHIER_EP) += pcie-uniphier-ep.o
 obj-$(CONFIG_PCIE_VISCONTI_HOST) += pcie-visconti.o
+obj-$(CONFIG_PCIE_STM32) += pcie-stm32.o
 
 # The following drivers are for devices that use the generic ACPI
 # pci_root.c driver but don't support standard ECAM config access.
diff --git a/drivers/pci/controller/dwc/pcie-stm32.c b/drivers/pci/controller/dwc/pcie-stm32.c
new file mode 100644
index 000000000..b3e10d117
--- /dev/null
+++ b/drivers/pci/controller/dwc/pcie-stm32.c
@@ -0,0 +1,368 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * ST PCIe driver for STM32-MP25 SoC
+ *
+ * Copyright (C) 2022 ST Microelectronics
+ * Author: Christian Bruel <christian.bruel@foss.st.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/phy/phy.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include "pcie-designware.h"
+
+#define to_stm32_pcie(x)	dev_get_drvdata((x)->dev)
+
+#define STM32MP25_PCIECR_TYPE_MASK GENMASK(11, 8)
+#define STM32MP25_PCIECR_EP	  0
+#define STM32MP25_PCIECR_LTSSM_EN  BIT(2)
+#define STM32MP25_PCIECR_LEG_EP	  BIT(8)
+#define STM32MP25_PCIECR_RC	  BIT(10)
+
+#define PCIESR_PHYLINK_UP	  BIT(3)
+#define PCIESR_LINK_UP		  BIT(5)
+#define PCIESR_EAR_INT		  BIT(13)
+
+#define PCIE_RC_LCSR              0x80
+
+#define SYSCFG_PCIECR             0x6000
+#define SYSCFG_PCIESR1            0x6100
+#define SYSCFG_PCIESR2            0x6104
+
+#define PCIE_DW_VERSION           0x570A
+
+#define PCIE_CAP_MAX_PAYLOAD_SIZE(x)	((x) << 5)
+#define PCIE_CAP_MAX_READ_REQ_SIZE(x)	((x) << 12)
+
+struct stm32_pcie {
+	struct dw_pcie *pci;
+	struct regmap *regmap;
+	struct reset_control *pci_reset;
+	struct phy *phy;
+	struct clk *pci_clk;
+	struct gpio_desc *reset_gpio;
+	u32     max_payload;
+	u32     max_readreq;
+};
+
+struct stm32_pcie_of_data {
+	enum dw_pcie_device_mode mode;
+};
+
+static const struct stm32_pcie_of_data stm32_pcie_rc_of_data = {
+	.mode = DW_PCIE_RC_TYPE,
+};
+
+static const struct of_device_id stm32_pcie_of_match[] = {
+	{ .compatible = "st,stm32mp25-pcie-rc",
+	  .data = &stm32_pcie_rc_of_data
+	},
+	{},
+};
+
+static int stm32_pcie_set_max_payload(struct dw_pcie *pci, u32 size)
+{
+	u32 val;
+	u16 exp_cap_off = dw_pcie_find_capability(pci, PCI_CAP_ID_EXP);
+	int max_payload_size = fls(size) - 8;
+	struct device *dev = pci->dev;
+
+	if (size != 128 && size != 256) {
+		dev_err(dev, "Unexpected payload size %d\n", size);
+		return -EINVAL;
+	}
+
+	val = dw_pcie_readl_dbi(pci, exp_cap_off + PCI_EXP_DEVCTL);
+
+	val &= ~PCI_EXP_DEVCTL_PAYLOAD;
+	val |= PCIE_CAP_MAX_PAYLOAD_SIZE(max_payload_size);
+	dw_pcie_writel_dbi(pci, exp_cap_off + PCI_EXP_DEVCTL, val);
+
+	return 0;
+}
+
+static int stm32_pcie_set_max_rd_req_size(struct dw_pcie *pci, u32 size)
+{
+	u32 val;
+	u16 exp_cap_off = dw_pcie_find_capability(pci, PCI_CAP_ID_EXP);
+	int max_readreq_size = fls(size) - 8;
+	struct device *dev = pci->dev;
+
+	if (!is_power_of_2(size) || size < 128 || size > 1024) {
+		dev_err(dev, "Unexpected read request size %d\n", size);
+		return -EINVAL;
+	}
+
+	val = dw_pcie_readl_dbi(pci, exp_cap_off + PCI_EXP_DEVCTL);
+
+	val &= ~PCI_EXP_DEVCTL_READRQ;
+	val |= PCIE_CAP_MAX_READ_REQ_SIZE(max_readreq_size);
+	dw_pcie_writel_dbi(pci, exp_cap_off + PCI_EXP_DEVCTL, val);
+
+	return 0;
+}
+
+static int stm32_pcie_host_init(struct pcie_port *pp)
+{
+	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
+	struct stm32_pcie *stm32_pcie = to_stm32_pcie(pci);
+	int ret = 0;
+
+	if (stm32_pcie->max_payload) {
+		ret = stm32_pcie_set_max_payload(pci, stm32_pcie->max_payload);
+		if (ret)
+			return ret;
+	}
+
+	if (stm32_pcie->max_readreq)
+		ret = stm32_pcie_set_max_rd_req_size(pci,
+						     stm32_pcie->max_readreq);
+
+	return ret;
+}
+
+static int stm32_pcie_msi_host_init(struct pcie_port *pp)
+{
+	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
+	struct device *dev = pci->dev;
+	struct device_node *np = dev->of_node;
+	struct device_node *msi_node;
+
+	/*
+	 * The MSI domain is set by the generic of_msi_configure().  This
+	 * .msi_host_init() function keeps us from doing the default MSI
+	 * domain setup in dw_pcie_host_init() and also enforces the
+	 * requirement that "msi-parent" exists.
+	 */
+	msi_node = of_parse_phandle(np, "msi-parent", 0);
+	if (!msi_node) {
+		dev_err(dev, "failed to find msi-parent\n");
+		return -EINVAL;
+	}
+
+	of_node_put(msi_node);
+
+	return 0;
+}
+
+static int stm32_pcie_start_link(struct dw_pcie *pci)
+{
+	struct stm32_pcie *stm32_pcie = to_stm32_pcie(pci);
+	u32 ret;
+
+	if (stm32_pcie->reset_gpio) {
+		/* Make sure PERST# is asserted. */
+		gpiod_set_value(stm32_pcie->reset_gpio, 1);
+
+		/* Deassert PERST# after 100us */
+		usleep_range(100, 200);
+		gpiod_set_value(stm32_pcie->reset_gpio, 0);
+	}
+
+	ret = regmap_update_bits(stm32_pcie->regmap, SYSCFG_PCIECR,
+				 STM32MP25_PCIECR_LTSSM_EN,
+				 STM32MP25_PCIECR_LTSSM_EN);
+
+	/*
+	 * PCIe specification states that you should not issue any config
+	 * requests until 100ms after asserting reset, so we enforce that here
+	 */
+	if (stm32_pcie->reset_gpio)
+		msleep(100);
+
+	return ret;
+}
+
+static void stm32_pcie_stop_link(struct dw_pcie *pci)
+{
+	struct stm32_pcie *stm32_pcie = to_stm32_pcie(pci);
+
+	regmap_update_bits(stm32_pcie->regmap, SYSCFG_PCIECR,
+				 STM32MP25_PCIECR_LTSSM_EN, 0);
+
+	/* Assert PERST# */
+	if (stm32_pcie->reset_gpio)
+		gpiod_set_value(stm32_pcie->reset_gpio, 1);
+}
+
+static const struct dw_pcie_host_ops stm32_pcie_host_ops = {
+	.msi_host_init = stm32_pcie_msi_host_init,
+	.host_init = stm32_pcie_host_init
+};
+
+static const struct dw_pcie_ops dw_pcie_ops = {
+	.start_link = stm32_pcie_start_link,
+	.stop_link = stm32_pcie_stop_link
+};
+
+static int stm32_add_pcie_port(struct stm32_pcie *stm32_pcie,
+			    struct platform_device *pdev)
+{
+	struct dw_pcie *pci = stm32_pcie->pci;
+	struct pcie_port *pp = &pci->pp;
+	int ret;
+
+	ret = regmap_update_bits(stm32_pcie->regmap, SYSCFG_PCIECR,
+				 STM32MP25_PCIECR_TYPE_MASK, STM32MP25_PCIECR_RC);
+	if (ret)
+		return ret;
+
+	ret = reset_control_reset(stm32_pcie->pci_reset);
+	if (ret) {
+		dev_err(&pdev->dev, "reset_control_reset failed %d", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(stm32_pcie->pci_clk);
+	if (ret)
+		return ret;
+
+	pp->ops = &stm32_pcie_host_ops;
+	ret = dw_pcie_host_init(pp);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to initialize host: %d\n", ret);
+		clk_disable_unprepare(stm32_pcie->pci_clk);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int stm32_pcie_probe(struct platform_device *pdev)
+{
+	struct stm32_pcie *stm32_pcie;
+	struct dw_pcie *dw;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	const struct stm32_pcie_of_data *data;
+	int ret;
+
+	data = of_device_get_match_data(dev);
+	if (!data)
+		return -ENODEV;
+
+	stm32_pcie = devm_kzalloc(dev, sizeof(*stm32_pcie), GFP_KERNEL);
+	if (!stm32_pcie)
+		return -ENOMEM;
+
+	dw = devm_kzalloc(dev, sizeof(*dw), GFP_KERNEL);
+	if (!dw)
+		return -ENOMEM;
+	stm32_pcie->pci = dw;
+
+	dw->dbi_base = devm_platform_ioremap_resource_byname(pdev, "dbi");
+
+	if (IS_ERR(dw->dbi_base))
+		return PTR_ERR(dw->dbi_base);
+
+	/* not used, but asserted */
+	dw->dbi_base2 = dw->dbi_base;
+
+	dw->dev = dev;
+	dw->ops = &dw_pcie_ops;
+	dw->version = PCIE_DW_VERSION;
+
+	/* regmap registers for PCIe IP configuration */
+	stm32_pcie->regmap = syscon_regmap_lookup_by_phandle(np, "st,syscfg");
+	if (IS_ERR(stm32_pcie->regmap))
+		return dev_err_probe(dev, PTR_ERR(stm32_pcie->regmap),
+				     "No syscfg phandle specified\n");
+
+	stm32_pcie->phy = devm_phy_get(dev, "pcie-phy");
+	if (IS_ERR(stm32_pcie->phy))
+		return dev_err_probe(dev, PTR_ERR(stm32_pcie->phy),
+				     "failed to get pcie-phy\n");
+
+	stm32_pcie->pci_clk = devm_clk_get(dev, "pcie-clk");
+	if (IS_ERR(stm32_pcie->pci_clk))
+		return dev_err_probe(dev, PTR_ERR(stm32_pcie->pci_clk),
+				     "Failed to get PCIe clock source\n");
+
+	stm32_pcie->pci_reset = devm_reset_control_get(dev, "pcie-rst");
+	if (IS_ERR(stm32_pcie->pci_reset))
+		return dev_err_probe(dev, PTR_ERR(stm32_pcie->pci_reset),
+				     "Failed to get PCIe reset\n");
+
+	/* Optionally limit payload */
+	ret = of_property_read_u32(np, "max-payload-size", &stm32_pcie->max_payload);
+	if (ret && ret != -EINVAL)
+		return dev_err_probe(dev, ret, "Error reading max-payload value\n");
+
+	/* Optionally limit readreq */
+	ret = of_property_read_u32(np, "max-readreq-size", &stm32_pcie->max_readreq);
+	if (ret && ret != -EINVAL)
+		return dev_err_probe(dev, ret, "Error reading max-readreq value\n");
+
+	stm32_pcie->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(stm32_pcie->reset_gpio)) {
+		return dev_err_probe(dev, PTR_ERR(stm32_pcie->reset_gpio),
+				     "Failed to get reset GPIO\n");
+	}
+
+	ret = phy_set_mode(stm32_pcie->phy, PHY_MODE_PCIE);
+	if (ret)
+		return ret;
+
+	ret = phy_init(stm32_pcie->phy);
+	if (ret)
+		return ret;
+
+	platform_set_drvdata(pdev, stm32_pcie);
+
+	switch (data->mode) {
+	case DW_PCIE_RC_TYPE:
+		if (!IS_ENABLED(CONFIG_PCIE_STM32_HOST))
+			return -ENODEV;
+		dev_dbg(dev, "Set RC mode\n");
+		ret = stm32_add_pcie_port(stm32_pcie, pdev);
+		if (ret)
+			goto phy_disable;
+		break;
+	case DW_PCIE_EP_TYPE:
+		dev_err(dev, "EP mode not supported\n");
+		ret = -EINVAL;
+		goto phy_disable;
+	default:
+		dev_err(dev, "INVALID device type %d\n", data->mode);
+		ret = -EINVAL;
+		goto phy_disable;
+	}
+
+	return 0;
+
+phy_disable:
+	phy_exit(stm32_pcie->phy);
+
+	return ret;
+}
+
+static int stm32_pcie_remove(struct platform_device *pdev)
+{
+	struct stm32_pcie *stm32_pcie = platform_get_drvdata(pdev);
+	struct pcie_port *pp = &stm32_pcie->pci->pp;
+
+	dw_pcie_host_deinit(pp);
+	clk_disable_unprepare(stm32_pcie->pci_clk);
+	phy_exit(stm32_pcie->phy);
+
+	return 0;
+}
+
+static struct platform_driver stm32_pcie_driver = {
+	.probe = stm32_pcie_probe,
+	.remove	= stm32_pcie_remove,
+	.driver = {
+		.name = "stm32-pcie",
+		.of_match_table = stm32_pcie_of_match,
+	},
+};
+
+module_platform_driver(stm32_pcie_driver);
+MODULE_DESCRIPTION("STM32MP25 PCIe Controller driver");
+MODULE_LICENSE("GPL v2");
+MODULE_DEVICE_TABLE(of, stm32_pcie_of_match);
diff --git a/drivers/perf/Kconfig b/drivers/perf/Kconfig
index 77522e5ef..fb55e0bbf 100644
--- a/drivers/perf/Kconfig
+++ b/drivers/perf/Kconfig
@@ -106,6 +106,13 @@ config QCOM_L3_PMU
 	   Adds the L3 cache PMU into the perf events subsystem for
 	   monitoring L3 cache events.
 
+config STM32_DDR_PMU
+	tristate "STM32 DDR PMU"
+	depends on ARCH_STM32
+	default m
+	help
+	  Support for STM32 DDR performance monitor (DDRPERFM).
+
 config THUNDERX2_PMU
 	tristate "Cavium ThunderX2 SoC PMU UNCORE"
 	depends on ARCH_THUNDER2 && ARM64 && ACPI && NUMA
diff --git a/drivers/perf/Makefile b/drivers/perf/Makefile
index 5260b116c..f1d363307 100644
--- a/drivers/perf/Makefile
+++ b/drivers/perf/Makefile
@@ -10,6 +10,7 @@ obj-$(CONFIG_FSL_IMX8_DDR_PMU) += fsl_imx8_ddr_perf.o
 obj-$(CONFIG_HISI_PMU) += hisilicon/
 obj-$(CONFIG_QCOM_L2_PMU)	+= qcom_l2_pmu.o
 obj-$(CONFIG_QCOM_L3_PMU) += qcom_l3_pmu.o
+obj-$(CONFIG_STM32_DDR_PMU) += stm32_ddr_pmu.o
 obj-$(CONFIG_THUNDERX2_PMU) += thunderx2_pmu.o
 obj-$(CONFIG_XGENE_PMU) += xgene_pmu.o
 obj-$(CONFIG_ARM_SPE_PMU) += arm_spe_pmu.o
diff --git a/drivers/perf/stm32_ddr_pmu.c b/drivers/perf/stm32_ddr_pmu.c
new file mode 100644
index 000000000..4e1245856
--- /dev/null
+++ b/drivers/perf/stm32_ddr_pmu.c
@@ -0,0 +1,560 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * This file is the STM32 DDR performance monitor (DDRPERFM) driver
+ *
+ * Copyright (C) 2020, STMicroelectronics - All Rights Reserved
+ * Author: Gerald Baeza <gerald.baeza@st.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/hrtimer.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/perf_event.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+/*
+ * The PMU is able to freeze all counters and generate an interrupt when there
+ * is a counter overflow. But, relying on this means that we lose all the
+ * events that occur between the freeze and the interrupt handler execution.
+ * So we use a polling mechanism to avoid this lose of information.
+ * The fastest counter can overflow in ~8s @533MHz (that is the maximum DDR
+ * frequency supported on STM32MP157), so we poll in 4s intervals to ensure
+ * we don't reach this limit.
+ */
+#define POLL_MS		4000
+
+#define DDRPERFM_CTL	0x000
+#define DDRPERFM_CFG	0x004
+#define DDRPERFM_STATUS 0x008
+#define DDRPERFM_CCR	0x00C
+#define DDRPERFM_TCNT	0x020
+#define DDRPERFM_CNT(X)	(0x030 + 8 * (X))
+
+#define CTL_START	0x00000001
+#define CTL_STOP	0x00000002
+#define CCR_CLEAR_ALL	0x8000000F
+#define CCR_TCLR	BIT(31)
+
+#define STATUS_TOVF	BIT(31)
+
+/* MP2 related */
+#define DDRPERFM_MP2_CTRL	0x000
+#define DDRPERFM_MP2_CLR	0x00C
+#define DDRPERFM_MP2_CFG0	0x010
+#define DDRPERFM_MP2_CFG5	0x024
+#define DDRPERFM_MP2_EVCNT(X)	(0x040 + 4 * (X))
+#define DDRPERFM_MP2_TCNT	0x060
+#define DDRPERFM_MP2_STATUS	0x080
+
+#define MP2_STATUS_TCNT		BIT(16)
+
+#define MP2_CTRL_START		BIT(0)
+#define MP2_CTRL_STOP		BIT(1)
+
+#define MP2_CLR_CLEAR_ALL	0x000001FF
+#define MP2_CLR_TNTCLR		BIT(8)
+
+#define MP2_EVT_PERF_ACT	32
+#define MP2_EVT_PERF_RD		33
+#define MP2_EVT_PERF_WR		34
+#define MP2_CFG0_EVENTS		(MP2_EVT_PERF_RD | MP2_EVT_PERF_WR << 8 | MP2_EVT_PERF_ACT << 16)
+
+enum {
+	READ_CNT,
+	WRITE_CNT,
+	ACTIVATE_CNT,
+	IDLE_CNT,
+	TIME_CNT,
+	PMU_NR_COUNTERS
+};
+
+struct stm32_ddr_pmu_reg {
+	int reg;
+	int mask;
+};
+
+struct stm32_ddr_pmu_regspec {
+	const struct stm32_ddr_pmu_reg stop;
+	const struct stm32_ddr_pmu_reg start;
+	const struct stm32_ddr_pmu_reg enable;
+	const struct stm32_ddr_pmu_reg status_time;
+	const struct stm32_ddr_pmu_reg status_evt;
+	const struct stm32_ddr_pmu_reg clear_time;
+	const struct stm32_ddr_pmu_reg clear_evt;
+	const struct stm32_ddr_pmu_reg clear_all;
+	const struct stm32_ddr_pmu_reg sel_evt;
+	const struct stm32_ddr_pmu_reg counter_time;
+	const struct stm32_ddr_pmu_reg counter_evt[];
+};
+
+struct stm32_ddr_pmu {
+	struct pmu pmu;
+	void __iomem *membase;
+	struct device *dev;
+	struct clk *clk;
+	struct hrtimer hrtimer;
+	cpumask_t pmu_cpu;
+	ktime_t poll_period;
+	struct perf_event *events[PMU_NR_COUNTERS];
+	u64 events_cnt[PMU_NR_COUNTERS];
+	const struct stm32_ddr_pmu_cfg *cfg;
+};
+
+struct stm32_ddr_pmu_cfg {
+	const struct stm32_ddr_pmu_regspec *regs;
+	void (*initialize)(struct stm32_ddr_pmu *stm32_ddr_pmu);
+	bool has_clk_rst;
+};
+
+static inline struct stm32_ddr_pmu *pmu_to_stm32_ddr_pmu(struct pmu *p)
+{
+	return container_of(p, struct stm32_ddr_pmu, pmu);
+}
+
+static inline struct stm32_ddr_pmu *hrtimer_to_stm32_ddr_pmu(struct hrtimer *h)
+{
+	return container_of(h, struct stm32_ddr_pmu, hrtimer);
+}
+
+static void stm32_ddr_pmu_event_configure(struct perf_event *event)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = pmu_to_stm32_ddr_pmu(event->pmu);
+	const struct stm32_ddr_pmu_regspec *r = stm32_ddr_pmu->cfg->regs;
+	unsigned long config_base = event->hw.config_base;
+	u32 val;
+
+	writel_relaxed(r->stop.mask, stm32_ddr_pmu->membase + r->stop.reg);
+
+	if (config_base < TIME_CNT) {
+		val = readl_relaxed(stm32_ddr_pmu->membase + r->enable.reg);
+		val |= BIT(config_base);
+		writel_relaxed(val, stm32_ddr_pmu->membase + r->enable.reg);
+	}
+}
+
+static void stm32_ddr_pmu_event_update(struct perf_event *event)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = pmu_to_stm32_ddr_pmu(event->pmu);
+	const struct stm32_ddr_pmu_regspec *r = stm32_ddr_pmu->cfg->regs;
+	unsigned long config_base = event->hw.config_base;
+	struct hw_perf_event *hw = &event->hw;
+	u64 prev_count, new_count, mask;
+	u32 val, offset, bit_status, bit_clear;
+
+	writel_relaxed(r->stop.mask, stm32_ddr_pmu->membase + r->stop.reg);
+
+	if (config_base == TIME_CNT) {
+		offset = r->counter_time.reg;
+		bit_status = r->status_time.mask;
+		bit_clear = r->clear_time.mask;
+		val = readl_relaxed(stm32_ddr_pmu->membase + r->status_time.reg);
+	} else {
+		offset = r->counter_evt[config_base].reg;
+		bit_status = BIT(config_base);
+		bit_clear = BIT(config_base);
+		val = readl_relaxed(stm32_ddr_pmu->membase + r->status_evt.reg);
+	}
+	if (val & bit_status)
+		dev_warn(stm32_ddr_pmu->dev, "hardware counter overflow\n");
+	val = readl_relaxed(stm32_ddr_pmu->membase + offset);
+	writel_relaxed(bit_clear, stm32_ddr_pmu->membase + r->clear_evt.reg);
+	writel_relaxed(r->start.mask, stm32_ddr_pmu->membase + r->start.reg);
+
+	do {
+		prev_count = local64_read(&hw->prev_count);
+		new_count = prev_count + val;
+	} while (local64_xchg(&hw->prev_count, new_count) != prev_count);
+
+	mask = GENMASK_ULL(31, 0);
+	local64_add(val & mask, &event->count);
+}
+
+static void stm32_ddr_pmu_event_read(struct perf_event *event)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = pmu_to_stm32_ddr_pmu(event->pmu);
+
+	hrtimer_start(&stm32_ddr_pmu->hrtimer, stm32_ddr_pmu->poll_period,
+		      HRTIMER_MODE_REL_PINNED);
+
+	stm32_ddr_pmu_event_update(event);
+}
+
+static void stm32_ddr_pmu_event_start(struct perf_event *event, int flags)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = pmu_to_stm32_ddr_pmu(event->pmu);
+	const struct stm32_ddr_pmu_regspec *r = stm32_ddr_pmu->cfg->regs;
+	struct hw_perf_event *hw = &event->hw;
+
+	if (WARN_ON_ONCE(!(hw->state & PERF_HES_STOPPED)))
+		return;
+
+	if (flags & PERF_EF_RELOAD)
+		WARN_ON_ONCE(!(hw->state & PERF_HES_UPTODATE));
+
+	stm32_ddr_pmu_event_configure(event);
+
+	/* Clear all counters to synchronize them, then start */
+	writel_relaxed(r->clear_all.mask, stm32_ddr_pmu->membase + r->clear_all.reg);
+	writel_relaxed(r->start.mask, stm32_ddr_pmu->membase + r->start.reg);
+	local64_set(&hw->prev_count, 0);
+	hw->state = 0;
+}
+
+static void stm32_ddr_pmu_event_stop(struct perf_event *event, int flags)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = pmu_to_stm32_ddr_pmu(event->pmu);
+	const struct stm32_ddr_pmu_regspec *r = stm32_ddr_pmu->cfg->regs;
+	unsigned long config_base = event->hw.config_base;
+	struct hw_perf_event *hw = &event->hw;
+	u32 val;
+
+	if (WARN_ON_ONCE(hw->state & PERF_HES_STOPPED))
+		return;
+
+	writel_relaxed(r->stop.mask, stm32_ddr_pmu->membase + r->stop.reg);
+	if (config_base < TIME_CNT) {
+		val = readl_relaxed(stm32_ddr_pmu->membase + r->enable.reg);
+		val &= ~BIT(config_base);
+		writel_relaxed(val, stm32_ddr_pmu->membase + r->enable.reg);
+	}
+
+	hw->state |= PERF_HES_STOPPED;
+
+	if (flags & PERF_EF_UPDATE) {
+		stm32_ddr_pmu_event_update(event);
+		hw->state |= PERF_HES_UPTODATE;
+	}
+}
+
+static int stm32_ddr_pmu_event_add(struct perf_event *event, int flags)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = pmu_to_stm32_ddr_pmu(event->pmu);
+	unsigned long config_base = event->hw.config_base;
+	struct hw_perf_event *hw = &event->hw;
+
+	stm32_ddr_pmu->events_cnt[config_base] = 0;
+	stm32_ddr_pmu->events[config_base] = event;
+
+	if (stm32_ddr_pmu->clk)
+		clk_enable(stm32_ddr_pmu->clk);
+	/*
+	 * Pin the timer, so that the overflows are handled by the chosen
+	 * event->cpu (this is the same one as presented in "cpumask"
+	 * attribute).
+	 */
+	hrtimer_start(&stm32_ddr_pmu->hrtimer, stm32_ddr_pmu->poll_period,
+		      HRTIMER_MODE_REL_PINNED);
+
+	stm32_ddr_pmu_event_configure(event);
+
+	hw->state = PERF_HES_STOPPED | PERF_HES_UPTODATE;
+
+	if (flags & PERF_EF_START)
+		stm32_ddr_pmu_event_start(event, 0);
+
+	return 0;
+}
+
+static void stm32_ddr_pmu_event_del(struct perf_event *event, int flags)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = pmu_to_stm32_ddr_pmu(event->pmu);
+	unsigned long config_base = event->hw.config_base;
+	int i;
+
+	stm32_ddr_pmu_event_stop(event, PERF_EF_UPDATE);
+
+	stm32_ddr_pmu->events_cnt[config_base] += local64_read(&event->count);
+	stm32_ddr_pmu->events[config_base] = NULL;
+
+	for (i = 0; i < PMU_NR_COUNTERS; i++)
+		if (stm32_ddr_pmu->events[i])
+			break;
+
+	if (i == PMU_NR_COUNTERS)
+		hrtimer_cancel(&stm32_ddr_pmu->hrtimer);
+
+	if (stm32_ddr_pmu->clk)
+		clk_disable(stm32_ddr_pmu->clk);
+}
+
+static int stm32_ddr_pmu_event_init(struct perf_event *event)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = pmu_to_stm32_ddr_pmu(event->pmu);
+	struct hw_perf_event *hw = &event->hw;
+
+	if (event->attr.type != event->pmu->type)
+		return -ENOENT;
+
+	if (event->attr.config >= PMU_NR_COUNTERS)
+		return -ENOENT;
+
+	if (is_sampling_event(event))
+		return -EINVAL;
+
+	if (event->attach_state & PERF_ATTACH_TASK)
+		return -EINVAL;
+
+	if (event->attr.exclude_user   ||
+	    event->attr.exclude_kernel ||
+	    event->attr.exclude_hv     ||
+	    event->attr.exclude_idle   ||
+	    event->attr.exclude_host   ||
+	    event->attr.exclude_guest)
+		return -EINVAL;
+
+	if (event->cpu < 0)
+		return -EINVAL;
+
+	hw->config_base = event->attr.config;
+	event->cpu = cpumask_first(&stm32_ddr_pmu->pmu_cpu);
+
+	return 0;
+}
+
+static enum hrtimer_restart stm32_ddr_pmu_poll(struct hrtimer *hrtimer)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = hrtimer_to_stm32_ddr_pmu(hrtimer);
+	int i;
+
+	for (i = 0; i < PMU_NR_COUNTERS; i++)
+		if (stm32_ddr_pmu->events[i])
+			stm32_ddr_pmu_event_update(stm32_ddr_pmu->events[i]);
+
+	hrtimer_forward_now(hrtimer, stm32_ddr_pmu->poll_period);
+
+	return HRTIMER_RESTART;
+}
+
+static ssize_t stm32_ddr_pmu_sysfs_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct dev_ext_attribute *eattr = container_of(attr, struct dev_ext_attribute, attr);
+	unsigned long cnt_id = (unsigned long)eattr->var;
+
+	return sprintf(buf, "config=%ld\n", cnt_id);
+}
+
+static void stm32mp2_ddr_pmu_initialize(struct stm32_ddr_pmu *stm32_ddr_pmu)
+{
+	const struct stm32_ddr_pmu_regspec *r = stm32_ddr_pmu->cfg->regs;
+
+	/* Map RD, WR, ACT logging signals on events 0, 1, 2 */
+	writel_relaxed(MP2_CFG0_EVENTS, stm32_ddr_pmu->membase + r->sel_evt.reg);
+}
+
+#define STM32_DDR_PMU_ATTR(_name, _func, _config)			\
+	(&((struct dev_ext_attribute[]) {				\
+		{ __ATTR(_name, 0444, _func, NULL), (void *)_config }   \
+	})[0].attr.attr)
+
+#define STM32_DDR_PMU_EVENT_ATTR(_name, _config)		\
+	STM32_DDR_PMU_ATTR(_name, stm32_ddr_pmu_sysfs_show,	\
+			   (unsigned long)_config)
+
+static struct attribute *stm32_ddr_pmu_event_attrs[] = {
+	STM32_DDR_PMU_EVENT_ATTR(read_cnt, READ_CNT),
+	STM32_DDR_PMU_EVENT_ATTR(write_cnt, WRITE_CNT),
+	STM32_DDR_PMU_EVENT_ATTR(activate_cnt, ACTIVATE_CNT),
+	STM32_DDR_PMU_EVENT_ATTR(idle_cnt, IDLE_CNT),
+	STM32_DDR_PMU_EVENT_ATTR(time_cnt, TIME_CNT),
+	NULL
+};
+
+static struct attribute_group stm32_ddr_pmu_event_attrs_group = {
+	.name = "events",
+	.attrs = stm32_ddr_pmu_event_attrs,
+};
+
+static const struct attribute_group *stm32_ddr_pmu_attr_groups[] = {
+	&stm32_ddr_pmu_event_attrs_group,
+	NULL,
+};
+
+static int stm32_ddr_pmu_device_probe(struct platform_device *pdev)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu;
+	struct reset_control *rst;
+	struct resource *res;
+	int i, ret;
+
+	stm32_ddr_pmu = devm_kzalloc(&pdev->dev, sizeof(struct stm32_ddr_pmu),
+				     GFP_KERNEL);
+	if (!stm32_ddr_pmu)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, stm32_ddr_pmu);
+	stm32_ddr_pmu->dev = &pdev->dev;
+
+	stm32_ddr_pmu->cfg = (const struct stm32_ddr_pmu_cfg *)
+		of_match_device(pdev->dev.driver->of_match_table, &pdev->dev)->data;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	stm32_ddr_pmu->membase = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(stm32_ddr_pmu->membase)) {
+		dev_err(&pdev->dev, "Unable to get membase\n");
+		return PTR_ERR(stm32_ddr_pmu->membase);
+	}
+
+	if (stm32_ddr_pmu->cfg->has_clk_rst) {
+		stm32_ddr_pmu->clk = devm_clk_get(&pdev->dev, NULL);
+		if (IS_ERR(stm32_ddr_pmu->clk)) {
+			dev_err(&pdev->dev, "unable to get the clock\n");
+			return PTR_ERR(stm32_ddr_pmu->clk);
+		}
+
+		ret = clk_prepare_enable(stm32_ddr_pmu->clk);
+		if (ret) {
+			dev_err(&pdev->dev, "unable to prepare the clock\n");
+			return ret;
+		}
+	}
+
+	stm32_ddr_pmu->poll_period = ms_to_ktime(POLL_MS);
+	hrtimer_init(&stm32_ddr_pmu->hrtimer, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	stm32_ddr_pmu->hrtimer.function = stm32_ddr_pmu_poll;
+
+	/*
+	 * The PMU is assigned to the cpu0 and there is no need to manage cpu
+	 * hot plug migration because cpu0 is always the first/last active cpu
+	 * during low power transitions.
+	 */
+	cpumask_set_cpu(0, &stm32_ddr_pmu->pmu_cpu);
+
+	for (i = 0; i < PMU_NR_COUNTERS; i++) {
+		stm32_ddr_pmu->events[i] = NULL;
+		stm32_ddr_pmu->events_cnt[i] = 0;
+	}
+
+	stm32_ddr_pmu->pmu = (struct pmu) {
+		.task_ctx_nr = perf_invalid_context,
+		.start = stm32_ddr_pmu_event_start,
+		.stop = stm32_ddr_pmu_event_stop,
+		.add = stm32_ddr_pmu_event_add,
+		.del = stm32_ddr_pmu_event_del,
+		.read = stm32_ddr_pmu_event_read,
+		.event_init = stm32_ddr_pmu_event_init,
+		.attr_groups = stm32_ddr_pmu_attr_groups,
+	};
+	ret = perf_pmu_register(&stm32_ddr_pmu->pmu, "stm32_ddr_pmu", -1);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to register the pmu\n");
+		goto err_pmu_register;
+	}
+
+	if (stm32_ddr_pmu->cfg->has_clk_rst) {
+		rst = devm_reset_control_get_exclusive(&pdev->dev, NULL);
+		if (IS_ERR(rst)) {
+			dev_err(&pdev->dev, "unable to get the reset\n");
+			ret = -ENOENT;
+			goto err_get_reset;
+		}
+		reset_control_assert(rst);
+		udelay(2);
+		reset_control_deassert(rst);
+	}
+
+	if (stm32_ddr_pmu->cfg->initialize)
+		stm32_ddr_pmu->cfg->initialize(stm32_ddr_pmu);
+
+	dev_info(&pdev->dev, "probed\n");
+
+	if (stm32_ddr_pmu->clk)
+		clk_disable(stm32_ddr_pmu->clk);
+
+	return 0;
+
+err_get_reset:
+	perf_pmu_unregister(&stm32_ddr_pmu->pmu);
+err_pmu_register:
+	if (stm32_ddr_pmu->clk)
+		clk_disable_unprepare(stm32_ddr_pmu->clk);
+	return ret;
+}
+
+static int stm32_ddr_pmu_device_remove(struct platform_device *pdev)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = platform_get_drvdata(pdev);
+
+	perf_pmu_unregister(&stm32_ddr_pmu->pmu);
+
+	if (stm32_ddr_pmu->clk)
+		clk_unprepare(stm32_ddr_pmu->clk);
+
+	return 0;
+}
+
+static const struct stm32_ddr_pmu_regspec stm32mp1_ddr_pmu_regspec = {
+	.stop =		{ DDRPERFM_CTL, CTL_STOP },
+	.start =	{ DDRPERFM_CTL, CTL_START },
+	.enable =	{ DDRPERFM_CFG },
+	.status_time =	{ DDRPERFM_STATUS, STATUS_TOVF },
+	.status_evt =	{ DDRPERFM_STATUS },
+	.clear_time =	{ DDRPERFM_CCR, CCR_TCLR },
+	.clear_evt =	{ DDRPERFM_CCR },
+	.clear_all =	{ DDRPERFM_CCR, CCR_CLEAR_ALL},
+	.counter_time =	{ DDRPERFM_TCNT },
+	.counter_evt =	{
+				{ DDRPERFM_CNT(0) },
+				{ DDRPERFM_CNT(1) },
+				{ DDRPERFM_CNT(2) },
+				{ DDRPERFM_CNT(3) },
+	},
+};
+
+static const struct stm32_ddr_pmu_regspec stm32mp2_ddr_pmu_regspec = {
+	.stop =		{ DDRPERFM_MP2_CTRL, MP2_CTRL_STOP },
+	.start =	{ DDRPERFM_MP2_CTRL, MP2_CTRL_START },
+	.enable =	{ DDRPERFM_MP2_CFG5 },
+	.status_time =	{ DDRPERFM_MP2_STATUS, MP2_STATUS_TCNT },
+	.status_evt =	{ DDRPERFM_MP2_STATUS },
+	.clear_time =	{ DDRPERFM_MP2_CLR, MP2_CLR_TNTCLR },
+	.clear_evt =	{ DDRPERFM_MP2_CLR },
+	.clear_all =	{ DDRPERFM_MP2_CLR, MP2_CLR_CLEAR_ALL},
+	.sel_evt =	{ DDRPERFM_MP2_CFG0 },
+	.counter_time =	{ DDRPERFM_MP2_TCNT },
+	.counter_evt =	{
+				{ DDRPERFM_MP2_EVCNT(0) },
+				{ DDRPERFM_MP2_EVCNT(1) },
+				{ DDRPERFM_MP2_EVCNT(2) },
+				{ DDRPERFM_MP2_EVCNT(3) },
+	},
+};
+
+static const struct stm32_ddr_pmu_cfg stm32mp1_ddr_pmu_cfg = {
+	.regs = &stm32mp1_ddr_pmu_regspec,
+	.has_clk_rst = true,
+};
+
+static const struct stm32_ddr_pmu_cfg stm32mp2_ddr_pmu_cfg = {
+	.regs = &stm32mp2_ddr_pmu_regspec,
+	.initialize = stm32mp2_ddr_pmu_initialize,
+	.has_clk_rst = false,
+};
+
+static const struct of_device_id stm32_ddr_pmu_of_match[] = {
+	{ .compatible = "st,stm32-ddr-pmu", .data = (void *)&stm32mp1_ddr_pmu_cfg },
+	{ .compatible = "st,stm32mp25-ddr-pmu", .data = (void *)&stm32mp2_ddr_pmu_cfg },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, stm32_ddr_pmu_of_match);
+
+static struct platform_driver stm32_ddr_pmu_driver = {
+	.driver = {
+		.name	= "stm32-ddr-pmu",
+		.of_match_table = of_match_ptr(stm32_ddr_pmu_of_match),
+	},
+	.probe = stm32_ddr_pmu_device_probe,
+	.remove = stm32_ddr_pmu_device_remove,
+};
+
+module_platform_driver(stm32_ddr_pmu_driver);
+
+MODULE_DESCRIPTION("Perf driver for STM32 DDR performance monitor");
+MODULE_AUTHOR("Gerald Baeza <gerald.baeza@st.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/phy/st/Kconfig b/drivers/phy/st/Kconfig
index 3fc3d0781..4aab0a7cc 100644
--- a/drivers/phy/st/Kconfig
+++ b/drivers/phy/st/Kconfig
@@ -47,3 +47,21 @@ config PHY_STM32_USBPHYC
 	  used by an HS USB Host controller, and the second one is shared
 	  between an HS USB OTG controller and an HS USB Host controller,
 	  selected by a USB switch.
+
+config PHY_STM32_COMBOPHY
+	tristate "STMicroelectronics ComboPHY driver for STM32 MP25"
+	depends on RESET_CONTROLLER
+	depends on ARCH_STM32 || COMPILE_TEST
+	select GENERIC_PHY
+	help
+	  Enable this to support the ComboPHY device used by USB3 or PCIe
+	  controllers on STMicroelectronics STM32MP25 SoC.
+
+config PHY_STM32_USB2FEMTO
+	tristate "STMicroelectronics STM32 USB2 FEMTO PHY Controller driver"
+	depends on ARCH_STM32 || COMPILE_TEST
+	select GENERIC_PHY
+	help
+	  Enable this to support the High-Speed USB2 transceivers that are part
+	  of some STMicroelectronics STM32 SoCs. The PHY integrated is from
+	  synopsys, and called FEMTO-PHY
diff --git a/drivers/phy/st/Makefile b/drivers/phy/st/Makefile
index c862dd937..1de1dddcc 100644
--- a/drivers/phy/st/Makefile
+++ b/drivers/phy/st/Makefile
@@ -4,3 +4,5 @@ obj-$(CONFIG_PHY_ST_SPEAR1310_MIPHY)	+= phy-spear1310-miphy.o
 obj-$(CONFIG_PHY_ST_SPEAR1340_MIPHY)	+= phy-spear1340-miphy.o
 obj-$(CONFIG_PHY_STIH407_USB)		+= phy-stih407-usb.o
 obj-$(CONFIG_PHY_STM32_USBPHYC) 	+= phy-stm32-usbphyc.o
+obj-$(CONFIG_PHY_STM32_COMBOPHY)	+= phy-stm32-combophy.o
+obj-$(CONFIG_PHY_STM32_USB2FEMTO)	+= phy-stm32-usb2femto.o
diff --git a/drivers/phy/st/phy-stm32-combophy.c b/drivers/phy/st/phy-stm32-combophy.c
new file mode 100644
index 000000000..f4d33f8e4
--- /dev/null
+++ b/drivers/phy/st/phy-stm32-combophy.c
@@ -0,0 +1,367 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics ComboPHY STM32MP25 Controller driver.
+ *
+ * Copyright (C) 2022 ST Microelectronics
+ * Author: Christian Bruel <christian.bruel@foss.st.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/phy/phy.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <dt-bindings/phy/phy.h>
+
+#define SYSCFG_COMBOPHY_CR1 0x4C00
+#define SYSCFG_COMBOPHY_CR2 0x4C04
+#define SYSCFG_COMBOPHY_SR  0x4C14
+#define SYSCFG_PCIEPRGCR    0x6080
+
+/* SYSCFG PCIEPRGCR */
+#define STM32MP25_PCIEPRGCR_EN	  BIT(0)
+
+/* SYSCFG SYSCFG_COMBOPHY_SR */
+#define STM32MP25_PIPE0_PHYSTATUS BIT(1)
+
+/* SYSCFG CR1 */
+#define SYSCFG_COMBOPHY_CR1_REFUSEPAD BIT(0)
+#define SYSCFG_COMBOPHY_CR1_MPLLMULT GENMASK(7, 1)
+#define SYSCFG_COMBOPHY_CR1_REFCLKSEL GENMASK(16, 8)
+#define SYSCFG_COMBOPHY_CR1_REFCLKDIV2 BIT(17)
+#define SYSCFG_COMBOPHY_CR1_REFSSPEN BIT(18)
+#define SYSCFG_COMBOPHY_CR1_SSCEN BIT(19)
+
+#define MPLLMULT_19_2 (0x02u << 1)
+#define MPLLMULT_20   (0x7Du << 1)
+#define MPLLMULT_24   (0x68u << 1)
+#define MPLLMULT_25   (0x64u << 1)
+#define MPLLMULT_26   (0x60u << 1)
+#define MPLLMULT_38_4 (0x41u << 1)
+#define MPLLMULT_48   (0x6Cu << 1)
+#define MPLLMULT_50   (0x32u << 1)
+#define MPLLMULT_52   (0x30u << 1)
+#define MPLLMULT_100  (0x19u << 1)
+
+#define REFCLKSEL_0   0
+#define REFCLKSEL_1   (0x108u << 8)
+
+#define REFCLDIV_0    0
+
+/* SYSCFG CR2 */
+#define SYSCFG_COMBOPHY_CR2_MODESEL GENMASK(1, 0)
+#define SYSCFG_COMBOPHY_CR2_ISO_DIS BIT(15)
+
+#define COMBOPHY_MODESEL_PCIE 0
+#define COMBOPHY_MODESEL_USB  3
+
+#define COMBOPHY_SUP_ANA_MPLL_LOOP_CTL 0xC0
+#define COMBOPHY_PROP_CNTRL GENMASK(7, 4)
+
+struct stm32_combophy {
+	struct phy *phy;
+	struct regmap *regmap;
+	struct device *dev;
+	void __iomem *base;
+	struct reset_control *phy_reset;
+	struct clk *phy_clk;
+	struct clk *ref_clk;
+	bool use_pad_clk;
+	unsigned int type;
+};
+
+static int stm32_combophy_pll_init(struct stm32_combophy *combophy)
+{
+	int ret;
+	u32 refclksel, pllmult, propcntrl, val;
+	u32 clk_rate = clk_get_rate(combophy->ref_clk);
+
+	reset_control_assert(combophy->phy_reset);
+
+	dev_dbg(combophy->dev, "%s pll init rate %d\n",
+		combophy->use_pad_clk ? "External" : "Ker", clk_rate);
+
+	/*
+	 * vddcombophy is interconnected with vddcore. Isolation bit should be unset
+	 * before using the ComboPHY.
+	 */
+	regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR2,
+			   SYSCFG_COMBOPHY_CR2_ISO_DIS, SYSCFG_COMBOPHY_CR2_ISO_DIS);
+
+	if (combophy->type != PHY_TYPE_PCIE)
+		regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR1,
+				   SYSCFG_COMBOPHY_CR1_REFSSPEN, SYSCFG_COMBOPHY_CR1_REFSSPEN);
+
+	if (!combophy->use_pad_clk)
+		regmap_update_bits(combophy->regmap, SYSCFG_PCIEPRGCR,
+				   STM32MP25_PCIEPRGCR_EN, STM32MP25_PCIEPRGCR_EN);
+
+	if (of_property_read_bool(combophy->dev->of_node, "st,scc-on")) {
+		dev_info(combophy->dev, "Enabling clock with SCC\n");
+		regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR1,
+				   SYSCFG_COMBOPHY_CR1_SSCEN, SYSCFG_COMBOPHY_CR1_SSCEN);
+	}
+
+	if (combophy->type == PHY_TYPE_PCIE)
+		regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR1,
+				   SYSCFG_COMBOPHY_CR1_REFUSEPAD,
+				   combophy->use_pad_clk ? SYSCFG_COMBOPHY_CR1_REFUSEPAD : 0);
+
+	switch (clk_rate) {
+	case 100000000:
+		pllmult = MPLLMULT_100;
+		refclksel = REFCLKSEL_0;
+		propcntrl = 0x8u << 4;
+		break;
+	case 19200000:
+		pllmult = MPLLMULT_19_2;
+		refclksel = REFCLKSEL_1;
+		propcntrl = 0x8u << 4;
+		break;
+	case 25000000:
+		pllmult = MPLLMULT_25;
+		refclksel = REFCLKSEL_0;
+		propcntrl = 0xEu << 4;
+		break;
+	case 24000000:
+		pllmult = MPLLMULT_24;
+		refclksel = REFCLKSEL_1;
+		propcntrl = 0xEu << 4;
+		break;
+	case 20000000:
+		pllmult = MPLLMULT_20;
+		refclksel = REFCLKSEL_0;
+		propcntrl = 0xEu << 4;
+		break;
+	default:
+		dev_err(combophy->dev, "Invalid rate 0x%x\n", clk_rate);
+		return -EINVAL;
+	};
+
+	regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR1,
+			   SYSCFG_COMBOPHY_CR1_REFCLKDIV2, REFCLDIV_0);
+	regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR1,
+			   SYSCFG_COMBOPHY_CR1_REFCLKSEL, refclksel);
+	regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR1,
+			   SYSCFG_COMBOPHY_CR1_MPLLMULT, pllmult);
+
+	reset_control_deassert(combophy->phy_reset);
+
+	ret = regmap_read_poll_timeout(combophy->regmap, SYSCFG_COMBOPHY_SR, val,
+				       !(val & STM32MP25_PIPE0_PHYSTATUS),
+				       10, 1000);
+	if (ret) {
+		dev_err(combophy->dev, "timeout, cannot lock PLL\n");
+		return ret;
+	}
+
+	if (combophy->type == PHY_TYPE_PCIE) {
+		val = readl_relaxed(combophy->base + COMBOPHY_SUP_ANA_MPLL_LOOP_CTL);
+		val &= ~COMBOPHY_PROP_CNTRL;
+		val |= propcntrl;
+		writel_relaxed(val, combophy->base + COMBOPHY_SUP_ANA_MPLL_LOOP_CTL);
+	}
+
+	return 0;
+}
+
+static struct phy *stm32_combophy_xlate(struct device *dev,
+				   struct of_phandle_args *args)
+{
+	struct stm32_combophy *combophy = dev_get_drvdata(dev);
+	unsigned int type;
+
+	if (args->args_count != 1) {
+		dev_err(dev, "invalid number of cells in 'phy' property\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	type = args->args[0];
+	if (type != PHY_TYPE_USB3 && type != PHY_TYPE_PCIE) {
+		dev_err(dev, "unsupported device type: %d\n", type);
+		return ERR_PTR(-EINVAL);
+	}
+
+	combophy->type = type;
+
+	return combophy->phy;
+}
+
+static int stm32_combophy_set_mode(struct stm32_combophy *combophy)
+{
+	int type = combophy->type;
+	u32 val;
+
+	switch (type) {
+	case PHY_TYPE_PCIE:
+		dev_dbg(combophy->dev, "setting PCIe ComboPHY\n");
+		val = COMBOPHY_MODESEL_PCIE;
+		break;
+	case PHY_TYPE_USB3:
+		dev_dbg(combophy->dev, "setting USB3 ComboPHY\n");
+		val = COMBOPHY_MODESEL_USB;
+		break;
+	default:
+		dev_err(combophy->dev, "Invalid PHY mode %d\n", type);
+		return -EINVAL;
+	}
+
+	return regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR2,
+				  SYSCFG_COMBOPHY_CR2_MODESEL, val);
+}
+
+static void stm32_combophy_disable_clocks(struct stm32_combophy *combophy)
+{
+	clk_disable_unprepare(combophy->ref_clk);
+	clk_disable_unprepare(combophy->phy_clk);
+}
+
+static int stm32_combophy_exit(struct phy *phy)
+{
+	struct stm32_combophy *combophy = phy_get_drvdata(phy);
+
+	if (!combophy->use_pad_clk)
+		regmap_update_bits(combophy->regmap, SYSCFG_PCIEPRGCR,
+				   STM32MP25_PCIEPRGCR_EN, 0);
+
+	if (combophy->type != PHY_TYPE_PCIE)
+		regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR1,
+				   SYSCFG_COMBOPHY_CR1_REFSSPEN, 0);
+
+	regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR2,
+			   SYSCFG_COMBOPHY_CR2_ISO_DIS, 0);
+
+	stm32_combophy_disable_clocks(combophy);
+
+	return 0;
+}
+
+static int stm32_combophy_init(struct phy *phy)
+{
+	struct stm32_combophy *combophy = phy_get_drvdata(phy);
+	int ret;
+
+	ret = clk_prepare_enable(combophy->phy_clk);
+	if (ret) {
+		dev_err(combophy->dev, "Core clock enable failed %d\n", ret);
+		return ret;
+	}
+
+	ret = stm32_combophy_set_mode(combophy);
+	if (ret) {
+		dev_err(combophy->dev, "combophy mode not set\n");
+		clk_disable_unprepare(combophy->phy_clk);
+		return ret;
+	}
+
+	if (combophy->use_pad_clk && combophy->type != PHY_TYPE_PCIE) {
+		dev_err(combophy->dev, "Invalid use of clk_pad for USB3 mode\n");
+		clk_disable_unprepare(combophy->phy_clk);
+		return -EINVAL;
+	}
+
+	ret = clk_prepare_enable(combophy->ref_clk);
+	if (ret) {
+		dev_err(combophy->dev, "%s clock enable failed %d\n",
+			combophy->use_pad_clk ? "External" : "Ker", ret);
+		clk_disable_unprepare(combophy->phy_clk);
+		return ret;
+	}
+
+	ret = stm32_combophy_pll_init(combophy);
+	if (ret)
+		stm32_combophy_disable_clocks(combophy);
+
+	return ret;
+}
+
+static const struct phy_ops stm32_combophy_phy_data = {
+	.init = stm32_combophy_init,
+	.exit = stm32_combophy_exit,
+	.owner = THIS_MODULE
+};
+
+static int stm32_combophy_probe(struct platform_device *pdev)
+{
+	struct stm32_combophy *combophy;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct phy *phy;
+	struct phy_provider *phy_provider;
+
+	combophy = devm_kzalloc(dev, sizeof(*combophy), GFP_KERNEL);
+	if (!combophy)
+		return -ENOMEM;
+
+	combophy->dev = dev;
+
+	dev_set_drvdata(dev, combophy);
+
+	combophy->base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(combophy->base))
+		return PTR_ERR(combophy->base);
+
+	combophy->phy_clk = devm_clk_get(dev, "apb-clk");
+	if (IS_ERR(combophy->phy_clk))
+		return dev_err_probe(dev, PTR_ERR(combophy->phy_clk),
+				     "Failed to get PHY clock source\n");
+
+	combophy->ref_clk = devm_clk_get_optional(dev, "pad-clk");
+	if (IS_ERR(combophy->ref_clk))
+		return dev_err_probe(dev, PTR_ERR(combophy->ref_clk),
+				     "Failed to get PHY external clock source\n");
+	if (combophy->ref_clk)
+		combophy->use_pad_clk = true;
+	else
+		combophy->ref_clk = devm_clk_get(dev, "ker-clk");
+
+	if (IS_ERR(combophy->ref_clk))
+		return dev_err_probe(dev, PTR_ERR(combophy->ref_clk),
+				     "Failed to get PHY internal clock source\n");
+
+	combophy->phy_reset = devm_reset_control_get(dev, "phy-rst");
+	if (IS_ERR(combophy->phy_reset))
+		return dev_err_probe(dev, PTR_ERR(combophy->phy_reset),
+				     "Failed to get PHY reset\n");
+
+	combophy->regmap = syscon_regmap_lookup_by_phandle(np, "st,syscfg");
+	if (IS_ERR(combophy->regmap))
+		return dev_err_probe(dev, PTR_ERR(combophy->regmap),
+				     "No syscfg phandle specified\n");
+
+	combophy->phy = devm_phy_create(dev, NULL, &stm32_combophy_phy_data);
+	if (IS_ERR(phy))
+		return dev_err_probe(dev, PTR_ERR(phy),
+				     "failed to create PCIe/USB3 ComboPHY\n");
+
+	phy_set_drvdata(combophy->phy, combophy);
+
+	phy_provider = devm_of_phy_provider_register(dev, stm32_combophy_xlate);
+
+	return PTR_ERR_OR_ZERO(phy_provider);
+}
+
+static const struct of_device_id stm32_combophy_of_match[] = {
+	{ .compatible = "st,stm32mp25-combophy", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, stm32_combophy_of_match);
+
+static struct platform_driver stm32_combophy_driver = {
+	.probe = stm32_combophy_probe,
+	.driver = {
+		   .name = "stm32-combophy",
+		   .of_match_table = stm32_combophy_of_match,
+	}
+};
+
+module_platform_driver(stm32_combophy_driver);
+
+MODULE_AUTHOR("Christian Bruel <christian.bruel@foss.st.com>");
+MODULE_DESCRIPTION("STM32MP25 Combophy USB3/PCIe controller driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/phy/st/phy-stm32-usb2femto.c b/drivers/phy/st/phy-stm32-usb2femto.c
new file mode 100644
index 000000000..dc905df9a
--- /dev/null
+++ b/drivers/phy/st/phy-stm32-usb2femto.c
@@ -0,0 +1,583 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics STM32 USB2 PHY Controller driver
+ * Currently Only supported for STM32MP25
+ *
+ * Copyright (C) 2022 STMicroelectronics
+ * Author(s): Pankaj Dev <pankaj.dev@st.com>.
+ */
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/mfd/syscon.h>
+
+#define PHY1CR_OFFSET		0x2400
+#define PHY1TRIM1_OFFSET	0x240C
+#define PHY1TRIM2_OFFSET	0x2410
+#define PHY2CR_OFFSET		0x2800
+#define PHY2TRIM1_OFFSET	0x2808
+#define PHY2TRIM2_OFFSET	0x280C
+
+#define PHYCR_REG      1
+
+/* Retention mode enable (active low) */
+#define SYSCFG_USB2PHY2CR_RETENABLEN2_MASK		BIT(0)
+/*
+ * Auto-resume mode enable. Enables auto-resume logic in femtoPHY so that the PHY automatically
+ * responds to a remote wake-up without initial involvement of the Host controller.
+ */
+#define SYSCFG_USB2PHY2CR_AUTORSMENB2_MASK		BIT(1)
+/* Controls the power down of analog blocks during Suspend and Sleep. */
+#define SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK		BIT(2)
+/* Controls vbus valid input of USB3 DRD controller when in Host mode */
+#define SYSCFG_USB2PHY2CR_VBUSVALID_MASK		BIT(4)
+/* Selects VBUS valid comparator that is used when USB3 DRD controller is in Device mode */
+#define SYSCFG_USB2PHY2CR_VBUSVLDEXTSEL_MASK		BIT(5)
+/* Voltage comparison result when an external voltage comparator is used */
+#define SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK		BIT(6)
+/*
+ * 0: internal debounce logic is enabled (default).
+ * Bit0: applies to utmiotg_vbusvalid,
+ * Bit1: applies to pipe3_PowerPresent,
+ * Bit2: applies to utmisrp_bvalid,
+ * Bit3: applies to utmiotg_iddig]. (default)
+ */
+#define SYSCFG_USB2PHY2CR_FILTER_BYPASS_MASK		GENMASK(10, 7)
+/* Voltage comparison result when an external voltage comparator is used */
+#define SYSCFG_USB2PHY2CR_OTGDISABLE0_MASK		BIT(16)
+/* Voltage comparison result when an external voltage comparator is used */
+#define SYSCFG_USB2PHY2CR_DRVVBUS0_MASK			BIT(17)
+
+#define SYSCFG_USB2PHYTRIM1_PLLITUNE_MASK		GENMASK(1, 0)
+#define SYSCFG_USB2PHYTRIM1_PLLPTUNE_MASK		GENMASK(5, 2)
+#define SYSCFG_USB2PHYTRIM1_COMPDISTUNE_MASK		GENMASK(8, 6)
+#define SYSCFG_USB2PHYTRIM1_SQRXTUNE_MASK		GENMASK(11, 9)
+#define SYSCFG_USB2PHYTRIM1_VDATREFTUNE_MASK		GENMASK(13, 12)
+#define SYSCFG_USB2PHYTRIM1_OTGTUNE_MASK		GENMASK(16, 14)
+#define SYSCFG_USB2PHYTRIM1_TXHSXVTUNE_MASK		GENMASK(18, 17)
+#define SYSCFG_USB2PHYTRIM1_TXFSLSTUNE_MASK		GENMASK(22, 19)
+#define SYSCFG_USB2PHYTRIM1_TXVREFTUNE_MASK		GENMASK(26, 23)
+#define SYSCFG_USB2PHYTRIM1_TXRISETUNE_MASK		GENMASK(28, 27)
+#define SYSCFG_USB2PHYTRIM1_TXRESTUNE_MASK		GENMASK(30, 29)
+
+#define SYSCFG_USB2PHYTRIM2_TXPREEMPAMPTUNE_MASK	GENMASK(1, 0)
+#define SYSCFG_USB2PHYTRIM2_TXPREEMPPULSETUNE_MASK	BIT(2)
+
+struct stm32_usb2_femtophy {
+	struct phy *phy;
+	struct regmap *regmap;
+	struct device *dev;
+	struct reset_control *rstc;
+	struct clk *phyref;
+	struct regulator *vdd33, *vdda18;
+	enum phy_mode mode;
+	const struct stm32mp2_usb2_femtophy_hw_data *hw_data;
+};
+
+enum stm32_usb2phy_mode {
+	USB2_MODE_HOST_ONLY,
+	USB2_MODE_DRD,
+};
+
+struct stm32mp2_usb2_femtophy_hw_data {
+	u32 phyrefsel_mask, phyrefsel_bitpos, cr_offset, trim1_offset, trim2_offset;
+	enum stm32_usb2phy_mode valid_mode;
+};
+
+static const struct stm32mp2_usb2_femtophy_hw_data stm32mp2_usb2phy_hwdata[] = {
+	{
+		.cr_offset = PHY1CR_OFFSET,
+		.trim1_offset = PHY1TRIM1_OFFSET,
+		.trim2_offset = PHY1TRIM2_OFFSET,
+		.valid_mode = USB2_MODE_HOST_ONLY,
+		.phyrefsel_mask = 0x7,
+		.phyrefsel_bitpos = 4,
+	},
+	{
+		.cr_offset = PHY2CR_OFFSET,
+		.trim1_offset = PHY2TRIM1_OFFSET,
+		.trim2_offset = PHY2TRIM2_OFFSET,
+		.valid_mode = USB2_MODE_DRD,
+		.phyrefsel_mask = 0x7,
+		.phyrefsel_bitpos = 12,
+	}
+};
+
+/*
+ * Two phy instances are found in mp25, and some bitfields are a bit different (shift...)
+ * depending on the instance. So identify the instance by using CR offset to report
+ * the correct bitfields & modes to use
+ */
+static const struct stm32mp2_usb2_femtophy_hw_data *stm32_usb2phy_get_hwdata(unsigned long offset)
+{
+	int i;
+
+	for (i = 0; i < sizeof(stm32mp2_usb2phy_hwdata); i++)
+		if (stm32mp2_usb2phy_hwdata[i].cr_offset == offset)
+			break;
+
+	if (i < sizeof(stm32mp2_usb2phy_hwdata))
+		return &stm32mp2_usb2phy_hwdata[i];
+
+	return NULL;
+}
+
+static int stm32_usb2phy_getrefsel(unsigned long rate)
+{
+	switch (rate) {
+	case 19200000:
+		return 0;
+	case 20000000:
+		return 1;
+	case 24000000:
+		return 2;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int stm32_usb2_femtophy_regulators_enable(struct stm32_usb2_femtophy *phy_dev)
+{
+	int ret;
+
+	ret = regulator_enable(phy_dev->vdd33);
+	if (ret)
+		return ret;
+
+	if (phy_dev->vdda18) {
+		ret = regulator_enable(phy_dev->vdda18);
+		if (ret)
+			goto vdd33_disable;
+	}
+
+	return 0;
+
+vdd33_disable:
+	regulator_disable(phy_dev->vdd33);
+
+	return ret;
+}
+
+static int stm32_usb2_femtophy_regulators_disable(struct stm32_usb2_femtophy *phy_dev)
+{
+	int ret;
+
+	if (phy_dev->vdda18) {
+		ret = regulator_disable(phy_dev->vdda18);
+		if (ret)
+			return ret;
+	}
+
+	ret = regulator_disable(phy_dev->vdd33);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int stm32_usb2_femtophy_init(struct phy *phy)
+{
+	int ret;
+	struct stm32_usb2_femtophy *phy_dev = phy_get_drvdata(phy);
+	struct device *dev = &phy->dev;
+	unsigned long phyref_rate;
+	u32 phyrefsel;
+	const struct stm32mp2_usb2_femtophy_hw_data *phy_data = phy_dev->hw_data;
+
+	ret = stm32_usb2_femtophy_regulators_enable(phy_dev);
+	if (ret) {
+		dev_err(dev, "can't enable regulators (%d)\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(phy_dev->phyref);
+	if (ret) {
+		dev_err(dev, "could not enable optional phyref: %d\n", ret);
+		goto error_regl_dis;
+	}
+
+	phyref_rate = clk_get_rate(phy_dev->phyref);
+
+	ret = stm32_usb2phy_getrefsel(phyref_rate);
+	if (ret < 0) {
+		dev_err(dev, "invalid phyref clk rate: %d\n", ret);
+		goto error_clk_dis;
+	}
+	phyrefsel = (u32)ret;
+	dev_dbg(dev, "phyrefsel value (%d)\n", phyrefsel);
+
+	ret = regmap_update_bits(phy_dev->regmap,
+				 phy_data->cr_offset,
+				 phy_data->phyrefsel_mask << phy_data->phyrefsel_bitpos,
+				 phyrefsel << phy_data->phyrefsel_bitpos);
+	if (ret) {
+		dev_err(dev, "can't set phyrefclksel (%d)\n", ret);
+		goto error_clk_dis;
+	}
+
+	ret = reset_control_deassert(phy_dev->rstc);
+	if (ret) {
+		dev_err(dev, "can't release reset (%d)\n", ret);
+		goto error_clk_dis;
+	}
+
+	return 0;
+
+error_clk_dis:
+	clk_disable_unprepare(phy_dev->phyref);
+error_regl_dis:
+	stm32_usb2_femtophy_regulators_disable(phy_dev);
+
+	return ret;
+}
+
+static int stm32_usb2_femtophy_exit(struct phy *phy)
+{
+	struct stm32_usb2_femtophy *phy_dev = phy_get_drvdata(phy);
+	int ret;
+
+	ret = reset_control_assert(phy_dev->rstc);
+	if (ret) {
+		dev_err(&phy->dev, "can't force reset (%d)\n", ret);
+		return ret;
+	}
+
+	clk_disable_unprepare(phy_dev->phyref);
+
+	ret = stm32_usb2_femtophy_regulators_disable(phy_dev);
+	if (ret) {
+		dev_err(&phy->dev, "can't disable regulators (%d)\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int stm32_usb2_femtophy_set_mode(struct phy *phy, enum phy_mode mode, int submode)
+{
+	int ret;
+	struct stm32_usb2_femtophy *phy_dev = phy_get_drvdata(phy);
+	const struct stm32mp2_usb2_femtophy_hw_data *phy_data = phy_dev->hw_data;
+	struct device *dev = &phy->dev;
+
+	switch (mode) {
+	case PHY_MODE_USB_HOST:
+		if (phy_data->valid_mode == USB2_MODE_HOST_ONLY)
+			ret = regmap_update_bits(phy_dev->regmap,
+						 phy_data->cr_offset,
+						 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK,
+						 0);
+		else
+			ret = regmap_update_bits(phy_dev->regmap,
+						 phy_data->cr_offset,
+						 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK |
+						 SYSCFG_USB2PHY2CR_VBUSVALID_MASK,
+						 SYSCFG_USB2PHY2CR_VBUSVALID_MASK);
+		if (ret) {
+			dev_err(dev, "can't set usb2phycr (%d)\n", ret);
+			return ret;
+		}
+		break;
+
+	case PHY_MODE_USB_DEVICE:
+		ret = regmap_update_bits(phy_dev->regmap,
+					 phy_data->cr_offset,
+					 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK,
+					 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK);
+		if (ret) {
+			dev_err(dev, "can't set usb2phycr (%d)\n", ret);
+			return ret;
+		}
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	phy_dev->mode = mode;
+
+	return 0;
+}
+
+static const struct phy_ops stm32_usb2_femtophy_data = {
+	.init = stm32_usb2_femtophy_init,
+	.exit = stm32_usb2_femtophy_exit,
+	.set_mode = stm32_usb2_femtophy_set_mode,
+	.owner = THIS_MODULE,
+};
+
+static int stm32_usb2_femtophy_tuning(struct phy *phy)
+{
+	int ret;
+	struct stm32_usb2_femtophy *phy_dev = phy_get_drvdata(phy);
+	struct device *dev = &phy->dev;
+	struct device_node *np = dev->of_node;
+	u32 mask_trim1 = 0, value_trim1 = 0, mask_trim2 = 0, value_trim2 = 0;
+	u8 val;
+
+	ret = of_property_read_u8(np, "st,pll-ipath-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val <= SYSCFG_USB2PHYTRIM1_PLLITUNE_MASK) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_PLLITUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_PLLITUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting pll-ipath-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,pll-ppath-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val <= SYSCFG_USB2PHYTRIM1_PLLPTUNE_MASK) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_PLLPTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_PLLPTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting pll-ppath-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,comp-dis-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val <= SYSCFG_USB2PHYTRIM1_COMPDISTUNE_MASK) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_COMPDISTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_COMPDISTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting comp-dis-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,sqrx-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val <= SYSCFG_USB2PHYTRIM1_SQRXTUNE_MASK) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_SQRXTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_SQRXTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting sqrx-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,vdatref-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val <= SYSCFG_USB2PHYTRIM1_VDATREFTUNE_MASK) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_VDATREFTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_VDATREFTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting vdatref-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,otg-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val <= SYSCFG_USB2PHYTRIM1_OTGTUNE_MASK) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_OTGTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_OTGTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting otg-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,txhsxv-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val <= SYSCFG_USB2PHYTRIM1_TXHSXVTUNE_MASK) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXHSXVTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXHSXVTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txhsxv-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,txfsls-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val <= SYSCFG_USB2PHYTRIM1_TXFSLSTUNE_MASK) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXFSLSTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXFSLSTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txfsls-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,txvref-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val <= SYSCFG_USB2PHYTRIM1_TXVREFTUNE_MASK) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXVREFTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXVREFTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txvref-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,txrise-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val <= SYSCFG_USB2PHYTRIM1_TXRISETUNE_MASK) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXRISETUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXRISETUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txrise-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,txres-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val <= SYSCFG_USB2PHYTRIM1_TXRESTUNE_MASK) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXRESTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXRESTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txres-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,txpreempamp-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val <= SYSCFG_USB2PHYTRIM2_TXPREEMPAMPTUNE_MASK) {
+			mask_trim2 |= SYSCFG_USB2PHYTRIM2_TXPREEMPAMPTUNE_MASK;
+			value_trim2 |= FIELD_PREP(SYSCFG_USB2PHYTRIM2_TXPREEMPAMPTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txpreempamp-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,txpreemppulse-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val <= SYSCFG_USB2PHYTRIM2_TXPREEMPPULSETUNE_MASK) {
+			mask_trim2 |= SYSCFG_USB2PHYTRIM2_TXPREEMPPULSETUNE_MASK;
+			value_trim2 |= FIELD_PREP(SYSCFG_USB2PHYTRIM2_TXPREEMPPULSETUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txpreemppulse-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	of_node_put(np);
+
+	if (mask_trim1) {
+		ret = regmap_update_bits(phy_dev->regmap, phy_dev->hw_data->trim1_offset,
+					 mask_trim1, value_trim1);
+		if (ret) {
+			dev_err(dev, "can't set usb2phytrim1 (%d)\n", ret);
+			return ret;
+		}
+		dev_dbg(dev, "usb2phytrim1 mask = %x value = %x\n", mask_trim1, value_trim1);
+	}
+
+	if (mask_trim2) {
+		ret = regmap_update_bits(phy_dev->regmap, phy_dev->hw_data->trim2_offset,
+					 mask_trim2, value_trim2);
+		if (ret) {
+			dev_err(dev, "can't set usb2phytrim2 (%d)\n", ret);
+			return ret;
+		}
+		dev_dbg(dev, "usb2phytrim2 mask = %x value = %x\n", mask_trim2, value_trim2);
+	}
+
+	return 0;
+}
+
+static int stm32_usb2_femtophy_probe(struct platform_device *pdev)
+{
+	struct stm32_usb2_femtophy *phy_dev;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct phy_provider *phy_provider;
+	struct phy *phy;
+	int ret;
+	u32 phycr;
+
+	phy_dev = devm_kzalloc(dev, sizeof(*phy_dev), GFP_KERNEL);
+	if (!phy_dev)
+		return -ENOMEM;
+
+	phy_dev->dev = dev;
+	dev_set_drvdata(dev, phy_dev);
+
+	phy_dev->rstc = devm_reset_control_get(dev, NULL);
+	if (IS_ERR(phy_dev->rstc))
+		return dev_err_probe(dev, PTR_ERR(phy_dev->rstc), "failed to get femtoPHY reset\n");
+
+	phy_dev->phyref = devm_clk_get(dev, NULL);
+	if (IS_ERR(phy_dev->phyref))
+		return dev_err_probe(dev, PTR_ERR(phy_dev->phyref), "failed to get phyref clk\n");
+
+	phy_dev->regmap = syscon_regmap_lookup_by_phandle(np, "st,syscfg");
+	if (IS_ERR(phy_dev->regmap))
+		return dev_err_probe(dev, PTR_ERR(phy_dev->regmap),
+				     "No syscfg phandle specified\n");
+
+	ret = of_property_read_u32_index(np, "st,syscfg", PHYCR_REG, &phycr);
+	if (ret)
+		return dev_err_probe(dev, ret, "can't get phycr offset\n");
+
+	phy_dev->vdd33 = devm_regulator_get_optional(dev, "vdd33");
+	if (IS_ERR(phy_dev->vdd33))
+		return dev_err_probe(dev, PTR_ERR(phy_dev->vdd33),
+				     "failed to get vdda3v3 supply\n");
+
+	phy_dev->vdda18 = devm_regulator_get_optional(dev, "vdda18");
+	if (IS_ERR(phy_dev->vdda18)) {
+		ret = PTR_ERR(phy_dev->vdda18);
+		if (ret != -ENODEV)
+			return dev_err_probe(dev, ret, "failed to get vdda1v8 supply\n");
+		phy_dev->vdda18 = NULL;
+	}
+
+	phy_dev->hw_data = stm32_usb2phy_get_hwdata(phycr);
+	if (!phy_dev->hw_data) {
+		dev_err(dev, "can't get matching stm32mp2_usb2_of_data\n");
+		return -EINVAL;
+	}
+
+	phy = devm_phy_create(dev, NULL, &stm32_usb2_femtophy_data);
+	if (IS_ERR(phy))
+		return dev_err_probe(dev, PTR_ERR(phy), "failed to create usb2 femto-PHY\n");
+
+	phy_dev->phy = phy;
+	phy_set_drvdata(phy, phy_dev);
+
+	/* Configure phy tuning */
+	ret = stm32_usb2_femtophy_tuning(phy);
+	if (ret)
+		return dev_err_probe(dev, ret, "can't set tuning parameters\n");
+
+	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+	if (IS_ERR(phy_provider))
+		return PTR_ERR(phy_provider);
+
+	return 0;
+}
+
+static const struct of_device_id stm32_usb2_femtophy_of_match[] = {
+	{ .compatible = "st,stm32mp25-usb2phy" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, stm32_usb2_femtophy_of_match);
+
+static struct platform_driver stm32_usb2_femtophy_driver = {
+	.probe = stm32_usb2_femtophy_probe,
+	.driver = {
+		.name = "stm32-usb-femtophy",
+		.of_match_table = stm32_usb2_femtophy_of_match
+	}
+};
+
+module_platform_driver(stm32_usb2_femtophy_driver);
+
+MODULE_AUTHOR("Pankaj Dev <pankaj.dev@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics Generic femtoPHY driver for stm32");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/phy/st/phy-stm32-usbphyc.c b/drivers/phy/st/phy-stm32-usbphyc.c
index cd0747ab6..af198f7c3 100644
--- a/drivers/phy/st/phy-stm32-usbphyc.c
+++ b/drivers/phy/st/phy-stm32-usbphyc.c
@@ -12,6 +12,7 @@
 #include <linux/iopoll.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/of_irq.h>
 #include <linux/of_platform.h>
 #include <linux/phy/phy.h>
 #include <linux/reset.h>
@@ -20,6 +21,7 @@
 #define STM32_USBPHYC_PLL	0x0
 #define STM32_USBPHYC_MISC	0x8
 #define STM32_USBPHYC_MONITOR(X) (0x108 + ((X) * 0x100))
+#define STM32_USBPHYC_TUNE(X)	(0x10C + ((X) * 0x100))
 #define STM32_USBPHYC_VERSION	0x3F4
 
 /* STM32_USBPHYC_PLL bit fields */
@@ -41,6 +43,83 @@
 #define STM32_USBPHYC_MON_SEL_LOCKP 0x1F
 #define STM32_USBPHYC_MON_OUT_LOCKP BIT(3)
 
+/* STM32_USBPHYC_TUNE bit fields */
+#define INCURREN		BIT(0)
+#define INCURRINT		BIT(1)
+#define LFSCAPEN		BIT(2)
+#define HSDRVSLEW		BIT(3)
+#define HSDRVDCCUR		BIT(4)
+#define HSDRVDCLEV		BIT(5)
+#define HSDRVCURINCR		BIT(6)
+#define FSDRVRFADJ		BIT(7)
+#define HSDRVRFRED		BIT(8)
+#define HSDRVCHKITRM		GENMASK(12, 9)
+#define HSDRVCHKZTRM		GENMASK(14, 13)
+#define OTPCOMP			GENMASK(19, 15)
+#define SQLCHCTL		GENMASK(21, 20)
+#define HDRXGNEQEN		BIT(22)
+#define HSRXOFF			GENMASK(24, 23)
+#define HSFALLPREEM		BIT(25)
+#define SHTCCTCTLPROT		BIT(26)
+#define STAGSEL			BIT(27)
+
+enum boosting_vals {
+	BOOST_1000_UA = 1000,
+	BOOST_2000_UA = 2000,
+};
+
+enum dc_level_vals {
+	DC_NOMINAL,
+	DC_PLUS_5_TO_7_MV,
+	DC_PLUS_10_TO_14_MV,
+	DC_MINUS_5_TO_7_MV,
+	DC_MAX,
+};
+
+enum current_trim {
+	CUR_NOMINAL,
+	CUR_PLUS_1_56_PCT,
+	CUR_PLUS_3_12_PCT,
+	CUR_PLUS_4_68_PCT,
+	CUR_PLUS_6_24_PCT,
+	CUR_PLUS_7_8_PCT,
+	CUR_PLUS_9_36_PCT,
+	CUR_PLUS_10_92_PCT,
+	CUR_PLUS_12_48_PCT,
+	CUR_PLUS_14_04_PCT,
+	CUR_PLUS_15_6_PCT,
+	CUR_PLUS_17_16_PCT,
+	CUR_PLUS_19_01_PCT,
+	CUR_PLUS_20_58_PCT,
+	CUR_PLUS_22_16_PCT,
+	CUR_PLUS_23_73_PCT,
+	CUR_MAX,
+};
+
+enum impedance_trim {
+	IMP_NOMINAL,
+	IMP_MINUS_2_OHMS,
+	IMP_MINUS_4_OMHS,
+	IMP_MINUS_6_OHMS,
+	IMP_MAX,
+};
+
+enum squelch_level {
+	SQLCH_NOMINAL,
+	SQLCH_PLUS_7_MV,
+	SQLCH_MINUS_5_MV,
+	SQLCH_PLUS_14_MV,
+	SQLCH_MAX,
+};
+
+enum rx_offset {
+	NO_RX_OFFSET,
+	RX_OFFSET_PLUS_5_MV,
+	RX_OFFSET_PLUS_10_MV,
+	RX_OFFSET_MINUS_5_MV,
+	RX_OFFSET_MAX,
+};
+
 /* STM32_USBPHYC_VERSION bit fields */
 #define MINREV			GENMASK(3, 0)
 #define MAJREV			GENMASK(7, 4)
@@ -58,8 +137,10 @@ struct stm32_usbphyc_phy {
 	struct phy *phy;
 	struct stm32_usbphyc *usbphyc;
 	struct regulator *vbus;
+	int wakeirq;
 	u32 index;
 	bool active;
+	u32 tune;
 };
 
 struct stm32_usbphyc {
@@ -297,6 +378,12 @@ static int stm32_usbphyc_phy_exit(struct phy *phy)
 static int stm32_usbphyc_phy_power_on(struct phy *phy)
 {
 	struct stm32_usbphyc_phy *usbphyc_phy = phy_get_drvdata(phy);
+	struct stm32_usbphyc *usbphyc = usbphyc_phy->usbphyc;
+
+	if (usbphyc_phy->wakeirq > 0)
+		if (enable_irq_wake(usbphyc_phy->wakeirq))
+			dev_warn(usbphyc->dev,
+				 "Wake irq for phy%d not enabled\n", usbphyc_phy->index);
 
 	if (usbphyc_phy->vbus)
 		return regulator_enable(usbphyc_phy->vbus);
@@ -307,6 +394,12 @@ static int stm32_usbphyc_phy_power_on(struct phy *phy)
 static int stm32_usbphyc_phy_power_off(struct phy *phy)
 {
 	struct stm32_usbphyc_phy *usbphyc_phy = phy_get_drvdata(phy);
+	struct stm32_usbphyc *usbphyc = usbphyc_phy->usbphyc;
+
+	if (usbphyc_phy->wakeirq > 0)
+		if (disable_irq_wake(usbphyc_phy->wakeirq))
+			dev_warn(usbphyc->dev,
+				 "Wake irq for phy%d not disabled\n", usbphyc_phy->index);
 
 	if (usbphyc_phy->vbus)
 		return regulator_disable(usbphyc_phy->vbus);
@@ -377,6 +470,107 @@ static int stm32_usbphyc_clk48_register(struct stm32_usbphyc *usbphyc)
 	return ret;
 }
 
+static void stm32_usbphyc_phy_tuning(struct stm32_usbphyc *usbphyc,
+				     struct device_node *np, u32 index)
+{
+	struct stm32_usbphyc_phy *usbphyc_phy = usbphyc->phys[index];
+	u32 reg = STM32_USBPHYC_TUNE(index);
+	u32 otpcomp, val;
+	int ret;
+
+	/* Backup OTP compensation code */
+	otpcomp = FIELD_GET(OTPCOMP, readl_relaxed(usbphyc->base + reg));
+
+	ret = of_property_read_u32(np, "st,current-boost-microamp", &val);
+	if (ret != -EINVAL) {
+		if (!ret && (val == BOOST_1000_UA || val == BOOST_2000_UA)) {
+			val = (val == BOOST_2000_UA) ? 1 : 0;
+			usbphyc_phy->tune |= INCURREN | FIELD_PREP(INCURRINT, val);
+		} else {
+			dev_warn(usbphyc->dev, "phy%d: invalid st,current-boost-microamp\n", index);
+		}
+	}
+
+	if (!of_property_read_bool(np, "st,no-lsfs-fb-cap"))
+		usbphyc_phy->tune |= LFSCAPEN;
+
+	if (of_property_read_bool(np, "st,decrease-hs-slew-rate"))
+		usbphyc_phy->tune |= HSDRVSLEW;
+
+	ret = of_property_read_u32(np, "st,tune-hs-dc-level", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val < DC_MAX) {
+			if (val == DC_MINUS_5_TO_7_MV) {/* Decreases HS driver DC level */
+				usbphyc_phy->tune |= HSDRVDCCUR;
+			} else if (val > 0) {		/* Increases HS driver DC level */
+				val = (val == DC_PLUS_10_TO_14_MV) ? 1 : 0;
+				usbphyc_phy->tune |= HSDRVCURINCR | FIELD_PREP(HSDRVDCLEV, val);
+			}
+		} else {
+			dev_warn(usbphyc->dev, "phy%d: invalid st,tune-hs-dc-level\n", index);
+		}
+	}
+
+	if (of_property_read_bool(np, "st,enable-fs-rftime-tuning"))
+		usbphyc_phy->tune |= FSDRVRFADJ;
+
+	if (of_property_read_bool(np, "st,enable-hs-rftime-reduction"))
+		usbphyc_phy->tune |= HSDRVRFRED;
+
+	ret = of_property_read_u32(np, "st,trim-hs-current", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val < CUR_MAX)
+			usbphyc_phy->tune |= FIELD_PREP(HSDRVCHKITRM, val);
+		else
+			dev_warn(usbphyc->dev, "phy%d: invalid st,trim-hs-current\n", index);
+	}
+
+	ret = of_property_read_u32(np, "st,trim-hs-impedance", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val < IMP_MAX)
+			usbphyc_phy->tune |= FIELD_PREP(HSDRVCHKZTRM, val);
+		else
+			dev_warn(usbphyc->dev, "phy%d: invalid st,trim-hs-impedance\n", index);
+	}
+
+	ret = of_property_read_u32(np, "st,tune-squelch-level", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val < SQLCH_MAX)
+			usbphyc_phy->tune |= FIELD_PREP(SQLCHCTL, val);
+		else
+			dev_warn(usbphyc->dev, "phy%d: invalid st,tune-squelch\n", index);
+	}
+
+	if (of_property_read_bool(np, "st,enable-hs-rx-gain-eq"))
+		usbphyc_phy->tune |= HDRXGNEQEN;
+
+	ret = of_property_read_u32(np, "st,tune-hs-rx-offset", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val < RX_OFFSET_MAX)
+			usbphyc_phy->tune |= FIELD_PREP(HSRXOFF, val);
+		else
+			dev_warn(usbphyc->dev, "phy%d: invalid st,tune-hs-rx-offset\n", index);
+	}
+
+	if (of_property_read_bool(np, "st,no-hs-ftime-ctrl"))
+		usbphyc_phy->tune |= HSFALLPREEM;
+
+	if (!of_property_read_bool(np, "st,no-lsfs-sc"))
+		usbphyc_phy->tune |= SHTCCTCTLPROT;
+
+	if (of_property_read_bool(np, "st,enable-hs-tx-staggering"))
+		usbphyc_phy->tune |= STAGSEL;
+
+	/* Restore OTP compensation code */
+	usbphyc_phy->tune |= FIELD_PREP(OTPCOMP, otpcomp);
+
+	/*
+	 * By default, if no st,xxx tuning property is used, usbphyc_phy->tune is equal to
+	 * STM32_USBPHYC_TUNE reset value (LFSCAPEN | SHTCCTCTLPROT | OTPCOMP).
+	 */
+	writel_relaxed(usbphyc_phy->tune, usbphyc->base + reg);
+}
+
 static void stm32_usbphyc_switch_setup(struct stm32_usbphyc *usbphyc,
 				       u32 utmi_switch)
 {
@@ -494,17 +688,15 @@ static int stm32_usbphyc_probe(struct platform_device *pdev)
 
 	usbphyc->vdda1v1 = devm_regulator_get(dev, "vdda1v1");
 	if (IS_ERR(usbphyc->vdda1v1)) {
-		ret = PTR_ERR(usbphyc->vdda1v1);
-		if (ret != -EPROBE_DEFER)
-			dev_err(dev, "failed to get vdda1v1 supply: %d\n", ret);
+		ret = dev_err_probe(dev, PTR_ERR(usbphyc->vdda1v1),
+				    "failed to get vdda1v1 supply\n");
 		goto clk_disable;
 	}
 
 	usbphyc->vdda1v8 = devm_regulator_get(dev, "vdda1v8");
 	if (IS_ERR(usbphyc->vdda1v8)) {
-		ret = PTR_ERR(usbphyc->vdda1v8);
-		if (ret != -EPROBE_DEFER)
-			dev_err(dev, "failed to get vdda1v8 supply: %d\n", ret);
+		ret = dev_err_probe(dev, PTR_ERR(usbphyc->vdda1v8),
+				    "failed to get vdda1v8 supply\n");
 		goto clk_disable;
 	}
 
@@ -552,6 +744,15 @@ static int stm32_usbphyc_probe(struct platform_device *pdev)
 			usbphyc->phys[port]->vbus = NULL;
 		}
 
+		/* Get optional wakeup interrupt */
+		ret = of_irq_get(child, 0);
+		if (ret == -EPROBE_DEFER)
+			goto put_child;
+		usbphyc->phys[port]->wakeirq = ret;
+
+		/* Configure phy tuning */
+		stm32_usbphyc_phy_tuning(usbphyc, child, index);
+
 		port++;
 	}
 
@@ -600,6 +801,25 @@ static int stm32_usbphyc_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static int __maybe_unused stm32_usbphyc_resume(struct device *dev)
+{
+	struct stm32_usbphyc *usbphyc = dev_get_drvdata(dev);
+	struct stm32_usbphyc_phy *usbphyc_phy;
+	int port;
+
+	if (usbphyc->switch_setup >= 0)
+		stm32_usbphyc_switch_setup(usbphyc, usbphyc->switch_setup);
+
+	for (port = 0; port < usbphyc->nphys; port++) {
+		usbphyc_phy = usbphyc->phys[port];
+		writel_relaxed(usbphyc_phy->tune, usbphyc->base + STM32_USBPHYC_TUNE(port));
+	}
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(stm32_usbphyc_pm_ops, NULL, stm32_usbphyc_resume);
+
 static const struct of_device_id stm32_usbphyc_of_match[] = {
 	{ .compatible = "st,stm32mp1-usbphyc", },
 	{ },
@@ -612,6 +832,7 @@ static struct platform_driver stm32_usbphyc_driver = {
 	.driver = {
 		.of_match_table = stm32_usbphyc_of_match,
 		.name = "stm32-usbphyc",
+		.pm = &stm32_usbphyc_pm_ops,
 	}
 };
 module_platform_driver(stm32_usbphyc_driver);
diff --git a/drivers/pinctrl/stm32/Kconfig b/drivers/pinctrl/stm32/Kconfig
index d532f3c6f..2656d3d3a 100644
--- a/drivers/pinctrl/stm32/Kconfig
+++ b/drivers/pinctrl/stm32/Kconfig
@@ -51,4 +51,10 @@ config PINCTRL_STM32MP157
 	depends on OF && HAS_IOMEM
 	default MACH_STM32MP157
 	select PINCTRL_STM32
+
+config PINCTRL_STM32MP257
+	bool "STMicroelectronics STM32MP257 pin control" if COMPILE_TEST && !MACH_STM32MP25
+	depends on OF && HAS_IOMEM
+	default MACH_STM32MP25
+	select PINCTRL_STM32
 endif
diff --git a/drivers/pinctrl/stm32/Makefile b/drivers/pinctrl/stm32/Makefile
index 619629ee9..7b17464d8 100644
--- a/drivers/pinctrl/stm32/Makefile
+++ b/drivers/pinctrl/stm32/Makefile
@@ -10,3 +10,4 @@ obj-$(CONFIG_PINCTRL_STM32F769)	+= pinctrl-stm32f769.o
 obj-$(CONFIG_PINCTRL_STM32H743)	+= pinctrl-stm32h743.o
 obj-$(CONFIG_PINCTRL_STM32MP135) += pinctrl-stm32mp135.o
 obj-$(CONFIG_PINCTRL_STM32MP157) += pinctrl-stm32mp157.o
+obj-$(CONFIG_PINCTRL_STM32MP257) += pinctrl-stm32mp257.o
diff --git a/drivers/pinctrl/stm32/pinctrl-stm32.c b/drivers/pinctrl/stm32/pinctrl-stm32.c
index d3fa8cf0d..111ed24b6 100644
--- a/drivers/pinctrl/stm32/pinctrl-stm32.c
+++ b/drivers/pinctrl/stm32/pinctrl-stm32.c
@@ -43,6 +43,14 @@
 #define STM32_GPIO_LCKR		0x1c
 #define STM32_GPIO_AFRL		0x20
 #define STM32_GPIO_AFRH		0x24
+#define STM32_GPIO_DELAYRL	0x40
+#define STM32_GPIO_PIOCFGRL	0x48
+#define STM32_GPIO_SECCFGR	0x30
+
+#define STM32_GPIO_PIOCFGR_DELAY_PATH_POS	0
+#define STM32_GPIO_PIOCFGR_CLK_EDGE_POS		1
+#define STM32_GPIO_PIOCFGR_CLK_TYPE_POS		2
+#define STM32_GPIO_PIOCFGR_RETIME_POS		3
 
 /* custom bitfield to backup pin status */
 #define STM32_GPIO_BKP_MODE_SHIFT	0
@@ -55,12 +63,23 @@
 #define STM32_GPIO_BKP_PUPD_MASK	GENMASK(9, 8)
 #define STM32_GPIO_BKP_TYPE		10
 #define STM32_GPIO_BKP_VAL		11
+#define STM32_GPIO_BKP_PIOCFG_SHIFT	12
+#define STM32_GPIO_BKP_PIOCFG_MASK	GENMASK(15, 12)
+#define STM32_GPIO_BKP_DELAY_SHIFT	16
+#define STM32_GPIO_BKP_DELAY_MASK	GENMASK(19, 16)
 
 #define STM32_GPIO_PINS_PER_BANK 16
 #define STM32_GPIO_IRQ_LINE	 16
 
 #define SYSCFG_IRQMUX_MASK GENMASK(3, 0)
 
+/* Vendor specific pin configurations */
+#define STM32_GPIO_PIN_CONFIG_DELAY_PATH	(PIN_CONFIG_END + 1)
+#define STM32_GPIO_PIN_CONFIG_CLK_EDGE		(PIN_CONFIG_END + 2)
+#define STM32_GPIO_PIN_CONFIG_CLK_TYPE		(PIN_CONFIG_END + 3)
+#define STM32_GPIO_PIN_CONFIG_RETIME		(PIN_CONFIG_END + 4)
+#define STM32_GPIO_PIN_CONFIG_DELAY		(PIN_CONFIG_END + 5)
+
 #define gpio_range_to_bank(chip) \
 		container_of(chip, struct stm32_gpio_bank, range)
 
@@ -73,6 +92,15 @@ static const char * const stm32_gpio_functions[] = {
 	"af8", "af9", "af10",
 	"af11", "af12", "af13",
 	"af14", "af15", "analog",
+	"reserved",
+};
+
+static const struct pinconf_generic_params stm32_gpio_bindings[] = {
+	{"st,io-delay-path",	STM32_GPIO_PIN_CONFIG_DELAY_PATH,	0},
+	{"st,io-clk-edge",	STM32_GPIO_PIN_CONFIG_CLK_EDGE,		0},
+	{"st,io-clk-type",	STM32_GPIO_PIN_CONFIG_CLK_TYPE,		0},
+	{"st,io-retime",	STM32_GPIO_PIN_CONFIG_RETIME,		0},
+	{"st,io-delay",		STM32_GPIO_PIN_CONFIG_DELAY,		0},
 };
 
 struct stm32_pinctrl_group {
@@ -94,6 +122,8 @@ struct stm32_gpio_bank {
 	u32 bank_ioport_nr;
 	u32 pin_backup[STM32_GPIO_PINS_PER_BANK];
 	u8 irq_type[STM32_GPIO_PINS_PER_BANK];
+	bool secure_control;
+	bool io_sync_control;
 };
 
 struct stm32_pinctrl {
@@ -187,6 +217,18 @@ static void stm32_gpio_backup_bias(struct stm32_gpio_bank *bank, u32 offset,
 	bank->pin_backup[offset] |= bias << STM32_GPIO_BKP_PUPD_SHIFT;
 }
 
+static void stm32_gpio_backup_piocfg(struct stm32_gpio_bank *bank, u32 offset, u32 bpos, u32 bval)
+{
+	bank->pin_backup[offset] &= ~BIT(STM32_GPIO_BKP_PIOCFG_SHIFT + bpos);
+	bank->pin_backup[offset] |= bval << (STM32_GPIO_BKP_PIOCFG_SHIFT + bpos);
+}
+
+static void stm32_gpio_backup_delay(struct stm32_gpio_bank *bank, u32 offset, u32 delay)
+{
+	bank->pin_backup[offset] &= ~STM32_GPIO_BKP_DELAY_MASK;
+	bank->pin_backup[offset] |= delay << STM32_GPIO_BKP_DELAY_SHIFT;
+}
+
 /* GPIO functions */
 
 static inline void __stm32_gpio_set(struct stm32_gpio_bank *bank,
@@ -197,11 +239,7 @@ static inline void __stm32_gpio_set(struct stm32_gpio_bank *bank,
 	if (!value)
 		offset += STM32_GPIO_PINS_PER_BANK;
 
-	clk_enable(bank->clk);
-
 	writel_relaxed(BIT(offset), bank->base + STM32_GPIO_BSRR);
-
-	clk_disable(bank->clk);
 }
 
 static int stm32_gpio_request(struct gpio_chip *chip, unsigned offset)
@@ -225,25 +263,11 @@ static void stm32_gpio_free(struct gpio_chip *chip, unsigned offset)
 	pinctrl_gpio_free(chip->base + offset);
 }
 
-static int stm32_gpio_get_noclk(struct gpio_chip *chip, unsigned int offset)
-{
-	struct stm32_gpio_bank *bank = gpiochip_get_data(chip);
-
-	return !!(readl_relaxed(bank->base + STM32_GPIO_IDR) & BIT(offset));
-}
-
 static int stm32_gpio_get(struct gpio_chip *chip, unsigned offset)
 {
 	struct stm32_gpio_bank *bank = gpiochip_get_data(chip);
-	int ret;
-
-	clk_enable(bank->clk);
-
-	ret = stm32_gpio_get_noclk(chip, offset);
 
-	clk_disable(bank->clk);
-
-	return ret;
+	return !!(readl_relaxed(bank->base + STM32_GPIO_IDR) & BIT(offset));
 }
 
 static void stm32_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
@@ -301,6 +325,33 @@ static int stm32_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)
 	return ret;
 }
 
+static int stm32_gpio_init_valid_mask(struct gpio_chip *chip,
+				      unsigned long *valid_mask,
+				      unsigned int ngpios)
+{
+	struct stm32_gpio_bank *bank = gpiochip_get_data(chip);
+	struct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);
+	unsigned int i;
+	u32 sec;
+
+	/* All gpio are valid per default */
+	bitmap_fill(valid_mask, ngpios);
+
+	if (bank->secure_control) {
+		/* Tag secured pins as invalid */
+		sec = readl_relaxed(bank->base + STM32_GPIO_SECCFGR);
+
+		for (i = 0; i < ngpios; i++) {
+			if (sec & BIT(i)) {
+				clear_bit(i, valid_mask);
+				dev_dbg(pctl->dev, "No access to gpio %d - %d\n", bank->bank_nr, i);
+			}
+		}
+	}
+
+	return 0;
+}
+
 static const struct gpio_chip stm32_gpio_template = {
 	.request		= stm32_gpio_request,
 	.free			= stm32_gpio_free,
@@ -311,6 +362,7 @@ static const struct gpio_chip stm32_gpio_template = {
 	.to_irq			= stm32_gpio_to_irq,
 	.get_direction		= stm32_gpio_get_direction,
 	.set_config		= gpiochip_generic_config,
+	.init_valid_mask	= stm32_gpio_init_valid_mask,
 };
 
 static void stm32_gpio_irq_trigger(struct irq_data *d)
@@ -323,7 +375,7 @@ static void stm32_gpio_irq_trigger(struct irq_data *d)
 		return;
 
 	/* If level interrupt type then retrig */
-	level = stm32_gpio_get_noclk(&bank->gpio_chip, d->hwirq);
+	level = stm32_gpio_get(&bank->gpio_chip, d->hwirq);
 	if ((level == 0 && bank->irq_type[d->hwirq] == IRQ_TYPE_LEVEL_LOW) ||
 	    (level == 1 && bank->irq_type[d->hwirq] == IRQ_TYPE_LEVEL_HIGH))
 		irq_chip_retrigger_hierarchy(d);
@@ -365,7 +417,6 @@ static int stm32_gpio_irq_request_resources(struct irq_data *irq_data)
 {
 	struct stm32_gpio_bank *bank = irq_data->domain->host_data;
 	struct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);
-	unsigned long flags;
 	int ret;
 
 	ret = stm32_gpio_direction_input(&bank->gpio_chip, irq_data->hwirq);
@@ -379,10 +430,6 @@ static int stm32_gpio_irq_request_resources(struct irq_data *irq_data)
 		return ret;
 	}
 
-	flags = irqd_get_trigger_type(irq_data);
-	if (flags & IRQ_TYPE_LEVEL_MASK)
-		clk_enable(bank->clk);
-
 	return 0;
 }
 
@@ -390,9 +437,6 @@ static void stm32_gpio_irq_release_resources(struct irq_data *irq_data)
 {
 	struct stm32_gpio_bank *bank = irq_data->domain->host_data;
 
-	if (bank->irq_type[irq_data->hwirq] & IRQ_TYPE_LEVEL_MASK)
-		clk_disable(bank->clk);
-
 	gpiochip_unlock_as_irq(&bank->gpio_chip, irq_data->hwirq);
 }
 
@@ -533,7 +577,7 @@ stm32_pctrl_find_group_by_pin(struct stm32_pinctrl *pctl, u32 pin)
 static bool stm32_pctrl_is_function_valid(struct stm32_pinctrl *pctl,
 		u32 pin_num, u32 fnum)
 {
-	int i;
+	int i, k;
 
 	for (i = 0; i < pctl->npins; i++) {
 		const struct stm32_desc_pin *pin = pctl->pins + i;
@@ -542,7 +586,10 @@ static bool stm32_pctrl_is_function_valid(struct stm32_pinctrl *pctl,
 		if (pin->pin.number != pin_num)
 			continue;
 
-		while (func && func->name) {
+		if (fnum == STM32_PIN_RSVD)
+			return true;
+
+		for (k = 0; k < STM32_CONFIG_NUM; k++) {
 			if (func->num == fnum)
 				return true;
 			func++;
@@ -769,7 +816,6 @@ static int stm32_pmx_set_mode(struct stm32_gpio_bank *bank,
 	unsigned long flags;
 	int err = 0;
 
-	clk_enable(bank->clk);
 	spin_lock_irqsave(&bank->lock, flags);
 
 	if (pctl->hwlock) {
@@ -798,7 +844,6 @@ static int stm32_pmx_set_mode(struct stm32_gpio_bank *bank,
 
 unlock:
 	spin_unlock_irqrestore(&bank->lock, flags);
-	clk_disable(bank->clk);
 
 	return err;
 }
@@ -811,7 +856,6 @@ void stm32_pmx_get_mode(struct stm32_gpio_bank *bank, int pin, u32 *mode,
 	int alt_offset = STM32_GPIO_AFRL + (pin / 8) * 4;
 	unsigned long flags;
 
-	clk_enable(bank->clk);
 	spin_lock_irqsave(&bank->lock, flags);
 
 	val = readl_relaxed(bank->base + alt_offset);
@@ -823,7 +867,6 @@ void stm32_pmx_get_mode(struct stm32_gpio_bank *bank, int pin, u32 *mode,
 	*mode = val >> (pin * 2);
 
 	spin_unlock_irqrestore(&bank->lock, flags);
-	clk_disable(bank->clk);
 }
 
 static int stm32_pmx_set_mux(struct pinctrl_dev *pctldev,
@@ -848,6 +891,11 @@ static int stm32_pmx_set_mux(struct pinctrl_dev *pctldev,
 		return -EINVAL;
 	}
 
+	if (function == STM32_PIN_RSVD) {
+		dev_dbg(pctl->dev, "Reserved pins, skipping HW update.\n");
+		return 0;
+	}
+
 	bank = gpiochip_get_data(range->gc);
 	pin = stm32_gpio_pin(g->pin);
 
@@ -867,12 +915,32 @@ static int stm32_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,
 	return stm32_pmx_set_mode(bank, pin, !input, 0);
 }
 
+static int stm32_pmx_request(struct pinctrl_dev *pctldev, unsigned gpio)
+{
+	struct stm32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct pinctrl_gpio_range *range;
+
+	range = pinctrl_find_gpio_range_from_pin_nolock(pctldev, gpio);
+	if (!range) {
+		dev_err(pctl->dev, "No gpio range defined.\n");
+		return -EINVAL;
+	}
+
+	if (!gpiochip_line_is_valid(range->gc, stm32_gpio_pin(gpio))) {
+		dev_warn(pctl->dev, "Can't access gpio %d\n", gpio);
+		return -EACCES;
+	}
+
+	return 0;
+}
+
 static const struct pinmux_ops stm32_pmx_ops = {
 	.get_functions_count	= stm32_pmx_get_funcs_cnt,
 	.get_function_name	= stm32_pmx_get_func_name,
 	.get_function_groups	= stm32_pmx_get_func_groups,
 	.set_mux		= stm32_pmx_set_mux,
 	.gpio_set_direction	= stm32_pmx_gpio_set_direction,
+	.request		= stm32_pmx_request,
 	.strict			= true,
 };
 
@@ -886,7 +954,6 @@ static int stm32_pconf_set_driving(struct stm32_gpio_bank *bank,
 	u32 val;
 	int err = 0;
 
-	clk_enable(bank->clk);
 	spin_lock_irqsave(&bank->lock, flags);
 
 	if (pctl->hwlock) {
@@ -910,7 +977,6 @@ static int stm32_pconf_set_driving(struct stm32_gpio_bank *bank,
 
 unlock:
 	spin_unlock_irqrestore(&bank->lock, flags);
-	clk_disable(bank->clk);
 
 	return err;
 }
@@ -921,14 +987,12 @@ static u32 stm32_pconf_get_driving(struct stm32_gpio_bank *bank,
 	unsigned long flags;
 	u32 val;
 
-	clk_enable(bank->clk);
 	spin_lock_irqsave(&bank->lock, flags);
 
 	val = readl_relaxed(bank->base + STM32_GPIO_TYPER);
 	val &= BIT(offset);
 
 	spin_unlock_irqrestore(&bank->lock, flags);
-	clk_disable(bank->clk);
 
 	return (val >> offset);
 }
@@ -941,7 +1005,6 @@ static int stm32_pconf_set_speed(struct stm32_gpio_bank *bank,
 	u32 val;
 	int err = 0;
 
-	clk_enable(bank->clk);
 	spin_lock_irqsave(&bank->lock, flags);
 
 	if (pctl->hwlock) {
@@ -965,7 +1028,6 @@ static int stm32_pconf_set_speed(struct stm32_gpio_bank *bank,
 
 unlock:
 	spin_unlock_irqrestore(&bank->lock, flags);
-	clk_disable(bank->clk);
 
 	return err;
 }
@@ -976,14 +1038,12 @@ static u32 stm32_pconf_get_speed(struct stm32_gpio_bank *bank,
 	unsigned long flags;
 	u32 val;
 
-	clk_enable(bank->clk);
 	spin_lock_irqsave(&bank->lock, flags);
 
 	val = readl_relaxed(bank->base + STM32_GPIO_SPEEDR);
 	val &= GENMASK(offset * 2 + 1, offset * 2);
 
 	spin_unlock_irqrestore(&bank->lock, flags);
-	clk_disable(bank->clk);
 
 	return (val >> (offset * 2));
 }
@@ -996,7 +1056,6 @@ static int stm32_pconf_set_bias(struct stm32_gpio_bank *bank,
 	u32 val;
 	int err = 0;
 
-	clk_enable(bank->clk);
 	spin_lock_irqsave(&bank->lock, flags);
 
 	if (pctl->hwlock) {
@@ -1020,7 +1079,6 @@ static int stm32_pconf_set_bias(struct stm32_gpio_bank *bank,
 
 unlock:
 	spin_unlock_irqrestore(&bank->lock, flags);
-	clk_disable(bank->clk);
 
 	return err;
 }
@@ -1031,25 +1089,130 @@ static u32 stm32_pconf_get_bias(struct stm32_gpio_bank *bank,
 	unsigned long flags;
 	u32 val;
 
-	clk_enable(bank->clk);
 	spin_lock_irqsave(&bank->lock, flags);
 
 	val = readl_relaxed(bank->base + STM32_GPIO_PUPDR);
 	val &= GENMASK(offset * 2 + 1, offset * 2);
 
 	spin_unlock_irqrestore(&bank->lock, flags);
-	clk_disable(bank->clk);
 
 	return (val >> (offset * 2));
 }
 
+static int stm32_pconf_set_piocfgr(struct stm32_gpio_bank *bank, int offset, u32 bpos, u32 bval)
+{
+	struct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);
+	int piocfgr_offset = STM32_GPIO_PIOCFGRL + (offset / 8) * 4;
+	int piocfgr_bit = bpos + (offset % 8) * 4;
+	unsigned long flags;
+	int err = 0;
+	u32 val;
+
+	if (!bank->io_sync_control)
+		return -ENOTSUPP;
+
+	spin_lock_irqsave(&bank->lock, flags);
+
+	if (pctl->hwlock) {
+		err = hwspin_lock_timeout_in_atomic(pctl->hwlock, HWSPNLCK_TIMEOUT);
+		if (err) {
+			dev_err(pctl->dev, "Can't get hwspinlock\n");
+			goto unlock;
+		}
+	}
+
+	val = readl_relaxed(bank->base + piocfgr_offset);
+	val &= ~BIT(piocfgr_bit);
+	val |= bval << piocfgr_bit;
+	writel_relaxed(val, bank->base + piocfgr_offset);
+
+	if (pctl->hwlock)
+		hwspin_unlock_in_atomic(pctl->hwlock);
+
+	stm32_gpio_backup_piocfg(bank, offset, bpos, bval);
+
+unlock:
+	spin_unlock_irqrestore(&bank->lock, flags);
+
+	return err;
+}
+
+static u32 stm32_pconf_get_piocfgr(struct stm32_gpio_bank *bank, int offset, u32 bpos)
+{
+	int piocfgr_offset = STM32_GPIO_PIOCFGRL + (offset / 8) * 4;
+	int piocfgr_bit = bpos + (offset % 8) * 4;
+	unsigned long flags;
+	u32 val;
+
+	spin_lock_irqsave(&bank->lock, flags);
+
+	val = readl_relaxed(bank->base + piocfgr_offset);
+	val &= BIT(piocfgr_bit);
+
+	spin_unlock_irqrestore(&bank->lock, flags);
+	return (val >> piocfgr_bit);
+}
+
+static int stm32_pconf_set_delay(struct stm32_gpio_bank *bank, int offset, u32 delay)
+{
+	struct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);
+	int delay_offset = STM32_GPIO_DELAYRL + (offset / 8) * 4;
+	int delay_shift = (offset % 8) * 4;
+	unsigned long flags;
+	int err = 0;
+	u32 val;
+
+	if (!bank->io_sync_control)
+		return -ENOTSUPP;
+
+	spin_lock_irqsave(&bank->lock, flags);
+
+	if (pctl->hwlock) {
+		err = hwspin_lock_timeout_in_atomic(pctl->hwlock, HWSPNLCK_TIMEOUT);
+		if (err) {
+			dev_err(pctl->dev, "Can't get hwspinlock\n");
+			goto unlock;
+		}
+	}
+
+	val = readl_relaxed(bank->base + delay_offset);
+	val &= ~GENMASK(delay_shift + 3, delay_shift);
+	val |= (delay << delay_shift);
+	writel_relaxed(val, bank->base + delay_offset);
+
+	if (pctl->hwlock)
+		hwspin_unlock_in_atomic(pctl->hwlock);
+
+	stm32_gpio_backup_delay(bank, offset, delay);
+
+unlock:
+	spin_unlock_irqrestore(&bank->lock, flags);
+
+	return err;
+}
+
+static u32 stm32_pconf_get_delay(struct stm32_gpio_bank *bank, int offset)
+{
+	int delay_offset = STM32_GPIO_DELAYRL + (offset / 8) * 4;
+	int delay_shift = (offset % 8) * 4;
+	unsigned long flags;
+	u32 val;
+
+	spin_lock_irqsave(&bank->lock, flags);
+
+	val = readl_relaxed(bank->base + delay_offset);
+	val &= GENMASK(delay_shift + 3, delay_shift);
+
+	spin_unlock_irqrestore(&bank->lock, flags);
+	return (val >> delay_shift);
+}
+
 static bool stm32_pconf_get(struct stm32_gpio_bank *bank,
 	unsigned int offset, bool dir)
 {
 	unsigned long flags;
 	u32 val;
 
-	clk_enable(bank->clk);
 	spin_lock_irqsave(&bank->lock, flags);
 
 	if (dir)
@@ -1060,7 +1223,6 @@ static bool stm32_pconf_get(struct stm32_gpio_bank *bank,
 			 BIT(offset));
 
 	spin_unlock_irqrestore(&bank->lock, flags);
-	clk_disable(bank->clk);
 
 	return val;
 }
@@ -1083,7 +1245,12 @@ static int stm32_pconf_parse_conf(struct pinctrl_dev *pctldev,
 	bank = gpiochip_get_data(range->gc);
 	offset = stm32_gpio_pin(pin);
 
-	switch (param) {
+	if (!gpiochip_line_is_valid(range->gc, offset)) {
+		dev_warn(pctl->dev, "Can't access gpio %d\n", pin);
+		return -EACCES;
+	}
+
+	switch ((unsigned int)param) {
 	case PIN_CONFIG_DRIVE_PUSH_PULL:
 		ret = stm32_pconf_set_driving(bank, offset, 0);
 		break;
@@ -1106,6 +1273,25 @@ static int stm32_pconf_parse_conf(struct pinctrl_dev *pctldev,
 		__stm32_gpio_set(bank, offset, arg);
 		ret = stm32_pmx_gpio_set_direction(pctldev, range, pin, false);
 		break;
+	case STM32_GPIO_PIN_CONFIG_DELAY_PATH:
+		ret = stm32_pconf_set_piocfgr(bank, offset,
+					      STM32_GPIO_PIOCFGR_DELAY_PATH_POS, arg);
+		break;
+	case STM32_GPIO_PIN_CONFIG_CLK_EDGE:
+		ret = stm32_pconf_set_piocfgr(bank, offset,
+					      STM32_GPIO_PIOCFGR_CLK_EDGE_POS, arg);
+		break;
+	case STM32_GPIO_PIN_CONFIG_CLK_TYPE:
+		ret = stm32_pconf_set_piocfgr(bank, offset,
+					      STM32_GPIO_PIOCFGR_CLK_TYPE_POS, arg);
+		break;
+	case STM32_GPIO_PIN_CONFIG_RETIME:
+		ret = stm32_pconf_set_piocfgr(bank, offset,
+					      STM32_GPIO_PIOCFGR_RETIME_POS, arg);
+		break;
+	case STM32_GPIO_PIN_CONFIG_DELAY:
+		ret = stm32_pconf_set_delay(bank, offset, arg);
+		break;
 	default:
 		ret = -ENOTSUPP;
 	}
@@ -1162,10 +1348,27 @@ static int stm32_pconf_set(struct pinctrl_dev *pctldev, unsigned int pin,
 	return 0;
 }
 
+static struct stm32_desc_pin *
+stm32_pconf_get_pin_desc_by_pin_number(struct stm32_pinctrl *pctl,
+				       unsigned int pin_number)
+{
+	struct stm32_desc_pin *pins = pctl->pins;
+	int i;
+
+	for (i = 0; i < pctl->npins; i++) {
+		if (pins->pin.number == pin_number)
+			return pins;
+		pins++;
+	}
+	return NULL;
+}
+
 static void stm32_pconf_dbg_show(struct pinctrl_dev *pctldev,
 				 struct seq_file *s,
 				 unsigned int pin)
 {
+	struct stm32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct stm32_desc_pin *pin_desc;
 	struct pinctrl_gpio_range *range;
 	struct stm32_gpio_bank *bank;
 	int offset;
@@ -1185,6 +1388,11 @@ static void stm32_pconf_dbg_show(struct pinctrl_dev *pctldev,
 	bank = gpiochip_get_data(range->gc);
 	offset = stm32_gpio_pin(pin);
 
+	if (!gpiochip_line_is_valid(range->gc, offset)) {
+		seq_puts(s, "NO ACCESS");
+		return;
+	}
+
 	stm32_pmx_get_mode(bank, offset, &mode, &alt);
 	bias = stm32_pconf_get_bias(bank, offset);
 
@@ -1215,7 +1423,12 @@ static void stm32_pconf_dbg_show(struct pinctrl_dev *pctldev,
 	case 2:
 		drive = stm32_pconf_get_driving(bank, offset);
 		speed = stm32_pconf_get_speed(bank, offset);
-		seq_printf(s, "%d - %s - %s - %s %s", alt,
+		pin_desc = stm32_pconf_get_pin_desc_by_pin_number(pctl, pin);
+		if (!pin_desc)
+			return;
+
+		seq_printf(s, "%d (%s) - %s - %s - %s %s", alt,
+			   pin_desc->functions[alt + 1].name,
 			   drive ? "open drain" : "push pull",
 			   biasing[bias],
 			   speeds[speed], "speed");
@@ -1225,6 +1438,26 @@ static void stm32_pconf_dbg_show(struct pinctrl_dev *pctldev,
 	case 3:
 		break;
 	}
+
+	if (bank->io_sync_control) {
+		u32 retime, clk_type, clk_edge, delay_path, delay;
+
+		retime = stm32_pconf_get_piocfgr(bank, offset,
+						 STM32_GPIO_PIOCFGR_RETIME_POS);
+		clk_type = stm32_pconf_get_piocfgr(bank, offset,
+						   STM32_GPIO_PIOCFGR_CLK_TYPE_POS);
+		clk_edge = stm32_pconf_get_piocfgr(bank, offset,
+						   STM32_GPIO_PIOCFGR_CLK_EDGE_POS);
+		delay_path = stm32_pconf_get_piocfgr(bank, offset,
+						     STM32_GPIO_PIOCFGR_DELAY_PATH_POS);
+		delay = stm32_pconf_get_delay(bank, offset);
+
+		if (retime || clk_type || clk_edge || delay_path || delay)
+			seq_printf(s, " - Retime:%d InvClk:%d DblEdge:%d DelayIn:%d",
+				   retime, clk_type, clk_edge, delay_path);
+		if (delay)
+			seq_printf(s, " - Delay: %d (%d ps)", delay, delay * 250);
+	}
 }
 
 static const struct pinconf_ops stm32_pconf_ops = {
@@ -1234,6 +1467,28 @@ static const struct pinconf_ops stm32_pconf_ops = {
 	.pin_config_dbg_show	= stm32_pconf_dbg_show,
 };
 
+static struct stm32_desc_pin *stm32_pctrl_get_desc_pin_from_gpio(struct stm32_pinctrl *pctl,
+								 struct stm32_gpio_bank *bank,
+								 unsigned int offset)
+{
+	unsigned int stm32_pin_nb = bank->bank_nr * STM32_GPIO_PINS_PER_BANK + offset;
+	struct stm32_desc_pin *pin_desc;
+	int i;
+
+	/* With few exceptions (e.g. bank 'Z'), pin number matches with pin index in array */
+	pin_desc = pctl->pins + stm32_pin_nb;
+	if (pin_desc->pin.number == stm32_pin_nb)
+		return pin_desc;
+
+	/* Otherwise, loop all array to find the pin with the right number */
+	for (i = 0; i < pctl->npins; i++) {
+		pin_desc = pctl->pins + i;
+		if (pin_desc->pin.number == stm32_pin_nb)
+			return pin_desc;
+	}
+	return NULL;
+}
+
 static int stm32_gpiolib_register_bank(struct stm32_pinctrl *pctl,
 	struct device_node *np)
 {
@@ -1245,6 +1500,8 @@ static int stm32_gpiolib_register_bank(struct stm32_pinctrl *pctl,
 	struct resource res;
 	int npins = STM32_GPIO_PINS_PER_BANK;
 	int bank_nr, err, i = 0;
+	struct stm32_desc_pin *stm32_pin;
+	char **names;
 
 	if (!IS_ERR(bank->rstc))
 		reset_control_deassert(bank->rstc);
@@ -1256,9 +1513,9 @@ static int stm32_gpiolib_register_bank(struct stm32_pinctrl *pctl,
 	if (IS_ERR(bank->base))
 		return PTR_ERR(bank->base);
 
-	err = clk_prepare(bank->clk);
+	err = clk_prepare_enable(bank->clk);
 	if (err) {
-		dev_err(dev, "failed to prepare clk (%d)\n", err);
+		dev_err(dev, "failed to prepare_enable clk (%d)\n", err);
 		return err;
 	}
 
@@ -1297,6 +1554,8 @@ static int stm32_gpiolib_register_bank(struct stm32_pinctrl *pctl,
 	bank->gpio_chip.parent = dev;
 	bank->bank_nr = bank_nr;
 	bank->bank_ioport_nr = bank_ioport_nr;
+	bank->secure_control = pctl->match_data->secure_control;
+	bank->io_sync_control = pctl->match_data->io_sync_control;
 	spin_lock_init(&bank->lock);
 
 	if (pctl->domain) {
@@ -1307,18 +1566,35 @@ static int stm32_gpiolib_register_bank(struct stm32_pinctrl *pctl,
 							   bank->fwnode, &stm32_gpio_domain_ops,
 							   bank);
 
-		if (!bank->domain)
-			return -ENODEV;
+		if (!bank->domain) {
+			err = -ENODEV;
+			goto err_clk;
+		}
+	}
+
+	names = devm_kcalloc(dev, npins, sizeof(char *), GFP_KERNEL);
+	for (i = 0; i < npins; i++) {
+		stm32_pin = stm32_pctrl_get_desc_pin_from_gpio(pctl, bank, i);
+		if (stm32_pin && stm32_pin->pin.name)
+			names[i] = devm_kasprintf(dev, GFP_KERNEL, "%s", stm32_pin->pin.name);
+		else
+			names[i] = NULL;
 	}
 
+	bank->gpio_chip.names = (const char * const *)names;
+
 	err = gpiochip_add_data(&bank->gpio_chip, bank);
 	if (err) {
 		dev_err(dev, "Failed to add gpiochip(%d)!\n", bank_nr);
-		return err;
+		goto err_clk;
 	}
 
 	dev_info(dev, "%s bank added\n", bank->gpio_chip.label);
 	return 0;
+
+err_clk:
+	clk_disable_unprepare(bank->clk);
+	return err;
 }
 
 static struct irq_domain *stm32_pctrl_get_irq_domain(struct device_node *np)
@@ -1426,7 +1702,8 @@ static int stm32_pctrl_create_pins_tab(struct stm32_pinctrl *pctl,
 		if (pctl->pkg && !(pctl->pkg & p->pkg))
 			continue;
 		pins->pin = p->pin;
-		pins->functions = p->functions;
+		memcpy((struct stm32_desc_pin *)pins->functions, p->functions,
+		       STM32_CONFIG_NUM * sizeof(struct stm32_desc_function));
 		pins++;
 		nb_pins_available++;
 	}
@@ -1436,17 +1713,6 @@ static int stm32_pctrl_create_pins_tab(struct stm32_pinctrl *pctl,
 	return 0;
 }
 
-static void stm32_pctl_get_package(struct device_node *np,
-				   struct stm32_pinctrl *pctl)
-{
-	if (of_property_read_u32(np, "st,package", &pctl->pkg)) {
-		pctl->pkg = 0;
-		dev_warn(pctl->dev, "No package detected, use default one\n");
-	} else {
-		dev_dbg(pctl->dev, "package detected: %x\n", pctl->pkg);
-	}
-}
-
 int stm32_pctl_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
@@ -1496,8 +1762,9 @@ int stm32_pctl_probe(struct platform_device *pdev)
 	pctl->dev = dev;
 	pctl->match_data = match->data;
 
-	/*  get package information */
-	stm32_pctl_get_package(np, pctl);
+	/*  get optional package information */
+	if (!of_property_read_u32(np, "st,package", &pctl->pkg))
+		dev_dbg(pctl->dev, "package detected: %x\n", pctl->pkg);
 
 	pctl->pins = devm_kcalloc(pctl->dev, pctl->match_data->npins,
 				  sizeof(*pctl->pins), GFP_KERNEL);
@@ -1536,6 +1803,8 @@ int stm32_pctl_probe(struct platform_device *pdev)
 	pctl->pctl_desc.confops = &stm32_pconf_ops;
 	pctl->pctl_desc.pctlops = &stm32_pctrl_ops;
 	pctl->pctl_desc.pmxops = &stm32_pmx_ops;
+	pctl->pctl_desc.num_custom_params = ARRAY_SIZE(stm32_gpio_bindings);
+	pctl->pctl_desc.custom_params = stm32_gpio_bindings;
 	pctl->dev = &pdev->dev;
 
 	pctl->pctl_dev = devm_pinctrl_register(&pdev->dev, &pctl->pctl_desc,
@@ -1589,6 +1858,10 @@ int stm32_pctl_probe(struct platform_device *pdev)
 			ret = stm32_gpiolib_register_bank(pctl, child);
 			if (ret) {
 				of_node_put(child);
+
+				for (i = 0; i < pctl->nbanks; i++)
+					clk_disable_unprepare(pctl->banks[i].clk);
+
 				return ret;
 			}
 
@@ -1601,6 +1874,16 @@ int stm32_pctl_probe(struct platform_device *pdev)
 	return 0;
 }
 
+static int __maybe_unused stm32_pinctrl_restore_piocfgr(struct stm32_gpio_bank *bank,
+							int offset, u32 bpos)
+{
+	u32 val;
+
+	val = bank->pin_backup[offset] & BIT(STM32_GPIO_BKP_PIOCFG_SHIFT + bpos);
+	val >>= (STM32_GPIO_BKP_PIOCFG_SHIFT + bpos);
+	return stm32_pconf_set_piocfgr(bank, offset, bpos, val);
+}
+
 static int __maybe_unused stm32_pinctrl_restore_gpio_regs(
 					struct stm32_pinctrl *pctl, u32 pin)
 {
@@ -1615,6 +1898,9 @@ static int __maybe_unused stm32_pinctrl_restore_gpio_regs(
 	if (!range)
 		return 0;
 
+	if (!gpiochip_line_is_valid(range->gc, offset))
+		return 0;
+
 	pin_is_irq = gpiochip_line_is_irq(range->gc, offset);
 
 	if (!desc || (!pin_is_irq && !desc->gpio_owner))
@@ -1655,18 +1941,60 @@ static int __maybe_unused stm32_pinctrl_restore_gpio_regs(
 	if (ret)
 		return ret;
 
+	if (bank->io_sync_control) {
+		ret = stm32_pinctrl_restore_piocfgr(bank, offset,
+						    STM32_GPIO_PIOCFGR_DELAY_PATH_POS);
+		if (ret)
+			return ret;
+
+		ret = stm32_pinctrl_restore_piocfgr(bank, offset,
+						    STM32_GPIO_PIOCFGR_CLK_EDGE_POS);
+		if (ret)
+			return ret;
+
+		ret = stm32_pinctrl_restore_piocfgr(bank, offset,
+						    STM32_GPIO_PIOCFGR_CLK_TYPE_POS);
+		if (ret)
+			return ret;
+
+		ret = stm32_pinctrl_restore_piocfgr(bank, offset,
+						    STM32_GPIO_PIOCFGR_RETIME_POS);
+		if (ret)
+			return ret;
+
+		val = bank->pin_backup[offset] & STM32_GPIO_BKP_DELAY_MASK;
+		val >>= STM32_GPIO_BKP_DELAY_SHIFT;
+		ret = stm32_pconf_set_delay(bank, offset, val);
+		if (ret)
+			return ret;
+	}
+
 	if (pin_is_irq)
 		regmap_field_write(pctl->irqmux[offset], bank->bank_ioport_nr);
 
 	return 0;
 }
 
+int __maybe_unused stm32_pinctrl_suspend(struct device *dev)
+{
+	struct stm32_pinctrl *pctl = dev_get_drvdata(dev);
+	int i;
+
+	for (i = 0; i < pctl->nbanks; i++)
+		clk_disable(pctl->banks[i].clk);
+
+	return 0;
+}
+
 int __maybe_unused stm32_pinctrl_resume(struct device *dev)
 {
 	struct stm32_pinctrl *pctl = dev_get_drvdata(dev);
 	struct stm32_pinctrl_group *g = pctl->groups;
 	int i;
 
+	for (i = 0; i < pctl->nbanks; i++)
+		clk_enable(pctl->banks[i].clk);
+
 	for (i = 0; i < pctl->ngroups; i++, g++)
 		stm32_pinctrl_restore_gpio_regs(pctl, g->pin);
 
diff --git a/drivers/pinctrl/stm32/pinctrl-stm32.h b/drivers/pinctrl/stm32/pinctrl-stm32.h
index b0882d120..106c9e6cd 100644
--- a/drivers/pinctrl/stm32/pinctrl-stm32.h
+++ b/drivers/pinctrl/stm32/pinctrl-stm32.h
@@ -17,12 +17,17 @@
 #define STM32_PIN_GPIO		0
 #define STM32_PIN_AF(x)		((x) + 1)
 #define STM32_PIN_ANALOG	(STM32_PIN_AF(15) + 1)
+#define STM32_PIN_RSVD		(STM32_PIN_ANALOG + 1)
+#define STM32_CONFIG_NUM	(STM32_PIN_RSVD + 1)
 
 /*  package information */
 #define STM32MP_PKG_AA		BIT(0)
 #define STM32MP_PKG_AB		BIT(1)
 #define STM32MP_PKG_AC		BIT(2)
 #define STM32MP_PKG_AD		BIT(3)
+#define STM32MP_PKG_AI		BIT(8)
+#define STM32MP_PKG_AK		BIT(10)
+#define STM32MP_PKG_AL		BIT(11)
 
 struct stm32_desc_function {
 	const char *name;
@@ -31,26 +36,26 @@ struct stm32_desc_function {
 
 struct stm32_desc_pin {
 	struct pinctrl_pin_desc pin;
-	const struct stm32_desc_function *functions;
+	const struct stm32_desc_function functions[STM32_CONFIG_NUM];
 	const unsigned int pkg;
 };
 
 #define STM32_PIN(_pin, ...)					\
 	{							\
 		.pin = _pin,					\
-		.functions = (struct stm32_desc_function[]){	\
-			__VA_ARGS__, { } },			\
+		.functions = {	\
+			__VA_ARGS__},			\
 	}
 
 #define STM32_PIN_PKG(_pin, _pkg, ...)					\
 	{							\
 		.pin = _pin,					\
 		.pkg  = _pkg,				\
-		.functions = (struct stm32_desc_function[]){	\
-			__VA_ARGS__, { } },			\
+		.functions = {	\
+			__VA_ARGS__},			\
 	}
 #define STM32_FUNCTION(_num, _name)		\
-	{							\
+	[_num] = {						\
 		.num = _num,					\
 		.name = _name,					\
 	}
@@ -58,6 +63,8 @@ struct stm32_desc_pin {
 struct stm32_pinctrl_match_data {
 	const struct stm32_desc_pin *pins;
 	const unsigned int npins;
+	bool secure_control;
+	bool io_sync_control;
 };
 
 struct stm32_gpio_bank;
@@ -65,6 +72,7 @@ struct stm32_gpio_bank;
 int stm32_pctl_probe(struct platform_device *pdev);
 void stm32_pmx_get_mode(struct stm32_gpio_bank *bank,
 			int pin, u32 *mode, u32 *alt);
+int stm32_pinctrl_suspend(struct device *dev);
 int stm32_pinctrl_resume(struct device *dev);
 
 #endif /* __PINCTRL_STM32_H */
diff --git a/drivers/pinctrl/stm32/pinctrl-stm32mp135.c b/drivers/pinctrl/stm32/pinctrl-stm32mp135.c
index 4ab03520c..fde1df191 100644
--- a/drivers/pinctrl/stm32/pinctrl-stm32mp135.c
+++ b/drivers/pinctrl/stm32/pinctrl-stm32mp135.c
@@ -1649,6 +1649,7 @@ static const struct stm32_desc_pin stm32mp135_pins[] = {
 static struct stm32_pinctrl_match_data stm32mp135_match_data = {
 	.pins = stm32mp135_pins,
 	.npins = ARRAY_SIZE(stm32mp135_pins),
+	.secure_control = true,
 };
 
 static const struct of_device_id stm32mp135_pctrl_match[] = {
@@ -1660,7 +1661,7 @@ static const struct of_device_id stm32mp135_pctrl_match[] = {
 };
 
 static const struct dev_pm_ops stm32_pinctrl_dev_pm_ops = {
-	 SET_LATE_SYSTEM_SLEEP_PM_OPS(NULL, stm32_pinctrl_resume)
+	 SET_LATE_SYSTEM_SLEEP_PM_OPS(stm32_pinctrl_suspend, stm32_pinctrl_resume)
 };
 
 static struct platform_driver stm32mp135_pinctrl_driver = {
diff --git a/drivers/pinctrl/stm32/pinctrl-stm32mp157.c b/drivers/pinctrl/stm32/pinctrl-stm32mp157.c
index 2ccb99d64..91b2fc8dd 100644
--- a/drivers/pinctrl/stm32/pinctrl-stm32mp157.c
+++ b/drivers/pinctrl/stm32/pinctrl-stm32mp157.c
@@ -2343,7 +2343,7 @@ static const struct of_device_id stm32mp157_pctrl_match[] = {
 };
 
 static const struct dev_pm_ops stm32_pinctrl_dev_pm_ops = {
-	 SET_LATE_SYSTEM_SLEEP_PM_OPS(NULL, stm32_pinctrl_resume)
+	 SET_LATE_SYSTEM_SLEEP_PM_OPS(stm32_pinctrl_suspend, stm32_pinctrl_resume)
 };
 
 static struct platform_driver stm32mp157_pinctrl_driver = {
diff --git a/drivers/pinctrl/stm32/pinctrl-stm32mp257.c b/drivers/pinctrl/stm32/pinctrl-stm32mp257.c
new file mode 100644
index 000000000..aefdf1bdf
--- /dev/null
+++ b/drivers/pinctrl/stm32/pinctrl-stm32mp257.c
@@ -0,0 +1,2583 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+#include <linux/init.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#include "pinctrl-stm32.h"
+
+static const struct stm32_desc_pin stm32mp257_pins[] = {
+	STM32_PIN_PKG(
+		PINCTRL_PIN(0, "PA0"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA0"),
+		STM32_FUNCTION(2, "LPTIM1_CH2"),
+		STM32_FUNCTION(3, "SPI5_RDY"),
+		STM32_FUNCTION(4, "UART8_CTS"),
+		STM32_FUNCTION(5, "SAI2_MCLK_B"),
+		STM32_FUNCTION(6, "UART5_TX"),
+		STM32_FUNCTION(7, "USART3_TX"),
+		STM32_FUNCTION(8, "TIM3_ETR"),
+		STM32_FUNCTION(9, "TIM5_CH2"),
+		STM32_FUNCTION(11, "ETH2_MII_RXD2 ETH2_RGMII_RXD2"),
+		STM32_FUNCTION(13, "FMC_NL"),
+		STM32_FUNCTION(15, "DCMI_D9 PSSI_D9 DCMIPP_D9"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(1, "PA1"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA1"),
+		STM32_FUNCTION(3, "SPI6_MISO"),
+		STM32_FUNCTION(5, "SAI3_SD_A"),
+		STM32_FUNCTION(6, "USART1_RTS"),
+		STM32_FUNCTION(7, "USART6_CK"),
+		STM32_FUNCTION(8, "TIM4_CH2"),
+		STM32_FUNCTION(9, "I2C4_SDA"),
+		STM32_FUNCTION(10, "I2C6_SDA"),
+		STM32_FUNCTION(12, "LCD_R3"),
+		STM32_FUNCTION(14, "DCMI_D5 PSSI_D5 DCMIPP_D5"),
+		STM32_FUNCTION(15, "ETH3_PHY_INTN"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(2, "PA2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA2"),
+		STM32_FUNCTION(2, "LPTIM2_IN1"),
+		STM32_FUNCTION(3, "SPI7_MISO"),
+		STM32_FUNCTION(6, "MDF1_SDI7"),
+		STM32_FUNCTION(7, "USART1_RX"),
+		STM32_FUNCTION(9, "I3C1_SDA"),
+		STM32_FUNCTION(11, "I2C1_SDA"),
+		STM32_FUNCTION(12, "LCD_B0"),
+		STM32_FUNCTION(14, "DCMI_D3 PSSI_D3 DCMIPP_D3"),
+		STM32_FUNCTION(15, "ETH3_RGMII_RX_CTL ETH3_RMII_CRS_DV"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(3, "PA3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA3"),
+		STM32_FUNCTION(2, "LPTIM2_ETR"),
+		STM32_FUNCTION(3, "SPI7_MOSI"),
+		STM32_FUNCTION(6, "MDF1_CKI7"),
+		STM32_FUNCTION(7, "USART1_TX"),
+		STM32_FUNCTION(9, "I3C1_SCL"),
+		STM32_FUNCTION(10, "I2C7_SMBA"),
+		STM32_FUNCTION(11, "I2C1_SCL"),
+		STM32_FUNCTION(12, "LCD_B1"),
+		STM32_FUNCTION(14, "DCMI_D2 PSSI_D2 DCMIPP_D2"),
+		STM32_FUNCTION(15, "ETH3_RGMII_TX_CTL ETH3_RMII_TX_EN"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(4, "PA4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA4"),
+		STM32_FUNCTION(7, "USART2_TX"),
+		STM32_FUNCTION(8, "FDCAN2_TX"),
+		STM32_FUNCTION(9, "TIM2_CH1"),
+		STM32_FUNCTION(11, "LCD_R1"),
+		STM32_FUNCTION(14, "ETH1_PTP_AUX_TS"),
+		STM32_FUNCTION(15, "ETH3_PPS_OUT"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(5, "PA5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA5"),
+		STM32_FUNCTION(4, "SPI4_MOSI"),
+		STM32_FUNCTION(5, "SAI2_MCLK_B"),
+		STM32_FUNCTION(6, "SAI2_SD_B"),
+		STM32_FUNCTION(7, "USART2_RTS"),
+		STM32_FUNCTION(8, "FDCAN2_RX"),
+		STM32_FUNCTION(9, "TIM2_CH4"),
+		STM32_FUNCTION(11, "LCD_G0"),
+		STM32_FUNCTION(13, "FMC_A0"),
+		STM32_FUNCTION(14, "DCMI_D13 PSSI_D13 DCMIPP_D13"),
+		STM32_FUNCTION(15, "ETH3_RGMII_RX_CLK ETH3_RMII_REF_CLK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(6, "PA6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA6"),
+		STM32_FUNCTION(4, "SPI4_SCK"),
+		STM32_FUNCTION(5, "SAI2_FS_B"),
+		STM32_FUNCTION(6, "MDF1_SDI6"),
+		STM32_FUNCTION(7, "USART2_CK"),
+		STM32_FUNCTION(8, "TIM13_CH1"),
+		STM32_FUNCTION(9, "TIM2_ETR"),
+		STM32_FUNCTION(11, "LCD_G4"),
+		STM32_FUNCTION(13, "FMC_NE1"),
+		STM32_FUNCTION(14, "DCMI_D12 PSSI_D12 DCMIPP_D12"),
+		STM32_FUNCTION(15, "ETH3_RGMII_TXD0 ETH3_RMII_TXD0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(7, "PA7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA7"),
+		STM32_FUNCTION(3, "AUDIOCLK"),
+		STM32_FUNCTION(4, "SPI6_RDY"),
+		STM32_FUNCTION(5, "PCIE_CLKREQN"),
+		STM32_FUNCTION(6, "MDF1_CCK0"),
+		STM32_FUNCTION(7, "USART1_CTS"),
+		STM32_FUNCTION(8, "TIM4_ETR"),
+		STM32_FUNCTION(9, "I2C2_SMBA"),
+		STM32_FUNCTION(10, "I2C6_SMBA"),
+		STM32_FUNCTION(11, "LCD_B5"),
+		STM32_FUNCTION(12, "I2C3_SMBA"),
+		STM32_FUNCTION(13, "I2C4_SMBA"),
+		STM32_FUNCTION(14, "DCMI_D6 PSSI_D6 DCMIPP_D6"),
+		STM32_FUNCTION(15, "ETH3_RGMII_TXD1 ETH3_RMII_TXD1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(8, "PA8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA8"),
+		STM32_FUNCTION(2, "LPTIM2_CH2"),
+		STM32_FUNCTION(3, "SPI7_NSS"),
+		STM32_FUNCTION(5, "SAI1_FS_B"),
+		STM32_FUNCTION(7, "USART1_CK"),
+		STM32_FUNCTION(9, "USART2_RX"),
+		STM32_FUNCTION(10, "I2C5_SCL"),
+		STM32_FUNCTION(13, "LCD_B2"),
+		STM32_FUNCTION(14, "DCMI_D4 PSSI_D4 DCMIPP_D4"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(9, "PA9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA9"),
+		STM32_FUNCTION(4, "SPI4_NSS"),
+		STM32_FUNCTION(5, "SAI2_SCK_B"),
+		STM32_FUNCTION(7, "USART2_CTS"),
+		STM32_FUNCTION(8, "LPTIM5_ETR"),
+		STM32_FUNCTION(9, "TIM2_CH3"),
+		STM32_FUNCTION(11, "ETH1_MDC"),
+		STM32_FUNCTION(13, "LCD_G7"),
+		STM32_FUNCTION(14, "PSSI_D14 DCMIPP_D14"),
+		STM32_FUNCTION(15, "ETH3_RGMII_RXD0 ETH3_RMII_RXD0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(10, "PA10"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA10"),
+		STM32_FUNCTION(4, "SPI4_MISO"),
+		STM32_FUNCTION(5, "SAI2_SD_B"),
+		STM32_FUNCTION(7, "USART2_RX"),
+		STM32_FUNCTION(8, "LPTIM5_IN1"),
+		STM32_FUNCTION(9, "TIM2_CH2"),
+		STM32_FUNCTION(11, "ETH1_MDIO"),
+		STM32_FUNCTION(13, "LCD_R6"),
+		STM32_FUNCTION(14, "PSSI_D15 DCMIPP_D15"),
+		STM32_FUNCTION(15, "ETH3_RGMII_RXD1 ETH3_RMII_RXD1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(11, "PA11"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA11"),
+		STM32_FUNCTION(2, "SPI8_SCK"),
+		STM32_FUNCTION(3, "LPTIM2_CH1"),
+		STM32_FUNCTION(5, "SAI4_SD_B"),
+		STM32_FUNCTION(6, "MDF1_SDI4"),
+		STM32_FUNCTION(11, "ETH1_MII_RX_DV ETH1_RGMII_RX_CTL ETH1_RMII_CRS_DV"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(12, "PA12"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA12"),
+		STM32_FUNCTION(3, "SPI6_MOSI"),
+		STM32_FUNCTION(5, "SAI3_FS_A"),
+		STM32_FUNCTION(8, "TIM4_CH1"),
+		STM32_FUNCTION(9, "I2C4_SCL"),
+		STM32_FUNCTION(10, "I2C6_SCL"),
+		STM32_FUNCTION(11, "ETH1_PHY_INTN"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(13, "PA13"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA13"),
+		STM32_FUNCTION(2, "SPI8_RDY"),
+		STM32_FUNCTION(3, "I2S3_MCK"),
+		STM32_FUNCTION(4, "LPTIM2_ETR"),
+		STM32_FUNCTION(6, "MDF1_CKI3"),
+		STM32_FUNCTION(7, "USART2_CTS"),
+		STM32_FUNCTION(10, "I2C7_SMBA"),
+		STM32_FUNCTION(11, "ETH1_MII_TX_EN ETH1_RGMII_TX_CTL ETH1_RMII_TX_EN"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(14, "PA14"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA14"),
+		STM32_FUNCTION(2, "SPI8_NSS"),
+		STM32_FUNCTION(3, "LPTIM2_CH2"),
+		STM32_FUNCTION(5, "SAI4_FS_B"),
+		STM32_FUNCTION(6, "MDF1_CCK1"),
+		STM32_FUNCTION(11, "ETH1_MII_RX_CLK ETH1_RGMII_RX_CLK ETH1_RMII_REF_CLK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(15, "PA15"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA15"),
+		STM32_FUNCTION(3, "SPI3_MISO I2S3_SDI"),
+		STM32_FUNCTION(7, "USART2_RX"),
+		STM32_FUNCTION(10, "I2C7_SDA"),
+		STM32_FUNCTION(11, "ETH1_MII_TXD0 ETH1_RGMII_TXD0 ETH1_RMII_TXD0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(16, "PB0"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB0"),
+		STM32_FUNCTION(3, "SPI2_SCK I2S2_CK"),
+		STM32_FUNCTION(7, "USART1_CK"),
+		STM32_FUNCTION(8, "TIM16_CH1"),
+		STM32_FUNCTION(9, "TIM20_CH4N"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_IO0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(17, "PB1"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB1"),
+		STM32_FUNCTION(2, "SPI3_NSS I2S3_WS"),
+		STM32_FUNCTION(8, "TIM16_CH1N"),
+		STM32_FUNCTION(9, "TIM20_CH3N"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_IO1"),
+		STM32_FUNCTION(13, "FMC_NCE4"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(18, "PB2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB2"),
+		STM32_FUNCTION(3, "SPI2_MOSI I2S2_SDO"),
+		STM32_FUNCTION(6, "MDF1_CKI3"),
+		STM32_FUNCTION(7, "TIM17_BKIN"),
+		STM32_FUNCTION(8, "TIM16_BKIN"),
+		STM32_FUNCTION(9, "TIM20_CH2N"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_IO2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(19, "PB3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB3"),
+		STM32_FUNCTION(3, "SPI2_NSS I2S2_WS"),
+		STM32_FUNCTION(6, "MDF1_SDI3"),
+		STM32_FUNCTION(9, "TIM20_CH3"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_IO3"),
+		STM32_FUNCTION(13, "FMC_NCE3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(20, "PB4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB4"),
+		STM32_FUNCTION(3, "SPI2_RDY"),
+		STM32_FUNCTION(4, "UART4_CTS"),
+		STM32_FUNCTION(5, "SAI4_FS_B"),
+		STM32_FUNCTION(6, "MDF1_SDI4"),
+		STM32_FUNCTION(7, "TIM14_CH1"),
+		STM32_FUNCTION(9, "TIM20_CH2"),
+		STM32_FUNCTION(10, "I2C2_SDA"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_IO4"),
+		STM32_FUNCTION(14, "I3C2_SDA"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(21, "PB5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB5"),
+		STM32_FUNCTION(3, "I2S2_MCK"),
+		STM32_FUNCTION(4, "UART4_RTS"),
+		STM32_FUNCTION(5, "SAI4_SD_B"),
+		STM32_FUNCTION(6, "MDF1_CKI4"),
+		STM32_FUNCTION(9, "TIM20_CH1"),
+		STM32_FUNCTION(10, "I2C2_SCL"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_IO5"),
+		STM32_FUNCTION(13, "FMC_AD8 FMC_D8"),
+		STM32_FUNCTION(14, "I3C2_SCL"),
+		STM32_FUNCTION(15, "SDMMC3_D123DIR"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(22, "PB6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB6"),
+		STM32_FUNCTION(3, "SPI2_MISO I2S2_SDI"),
+		STM32_FUNCTION(4, "UART4_RX"),
+		STM32_FUNCTION(5, "SAI4_SCK_B"),
+		STM32_FUNCTION(9, "TIM20_CH1N"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_IO6"),
+		STM32_FUNCTION(13, "FMC_AD9 FMC_D9"),
+		STM32_FUNCTION(15, "SDMMC3_D0DIR"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(23, "PB7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB7"),
+		STM32_FUNCTION(2, "SPI3_SCK I2S3_CK"),
+		STM32_FUNCTION(4, "UART4_TX"),
+		STM32_FUNCTION(5, "SAI4_MCLK_B"),
+		STM32_FUNCTION(9, "TIM20_ETR"),
+		STM32_FUNCTION(10, "TIM12_CH1"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_IO7"),
+		STM32_FUNCTION(13, "FMC_AD10 FMC_D10"),
+		STM32_FUNCTION(15, "SDMMC3_CDIR"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(24, "PB8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB8"),
+		STM32_FUNCTION(2, "SPI3_MOSI I2S3_SDO"),
+		STM32_FUNCTION(5, "PCIE_CLKREQN"),
+		STM32_FUNCTION(7, "USART1_TX"),
+		STM32_FUNCTION(8, "TIM17_CH1"),
+		STM32_FUNCTION(9, "TIM20_CH4"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_NCS1"),
+		STM32_FUNCTION(13, "FMC_AD12 FMC_D12"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(25, "PB9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB9"),
+		STM32_FUNCTION(2, "SPI3_RDY"),
+		STM32_FUNCTION(7, "USART1_RTS"),
+		STM32_FUNCTION(8, "FDCAN1_TX"),
+		STM32_FUNCTION(9, "TIM20_BKIN"),
+		STM32_FUNCTION(10, "TIM10_CH1"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_DQS"),
+		STM32_FUNCTION(12, "OCTOSPIM_P2_NCS2"),
+		STM32_FUNCTION(13, "FMC_AD13 FMC_D13"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(26, "PB10"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB10"),
+		STM32_FUNCTION(2, "SPI3_MISO I2S3_SDI"),
+		STM32_FUNCTION(7, "USART1_RX"),
+		STM32_FUNCTION(8, "TIM17_CH1N"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_CLK"),
+		STM32_FUNCTION(13, "FMC_AD15 FMC_D15"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(27, "PB11"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB11"),
+		STM32_FUNCTION(2, "I2S3_MCK"),
+		STM32_FUNCTION(7, "USART1_CTS"),
+		STM32_FUNCTION(8, "FDCAN1_RX"),
+		STM32_FUNCTION(9, "TIM20_BKIN2"),
+		STM32_FUNCTION(10, "TIM12_CH2"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_NCLK"),
+		STM32_FUNCTION(12, "OCTOSPIM_P2_NCS2"),
+		STM32_FUNCTION(13, "FMC_AD14 FMC_D14"),
+		STM32_FUNCTION(14, "OCTOSPIM_P1_NCS2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(28, "PB12"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB12"),
+		STM32_FUNCTION(6, "UART8_CTS"),
+		STM32_FUNCTION(8, "TIM13_CH1"),
+		STM32_FUNCTION(10, "DSI_TE"),
+		STM32_FUNCTION(11, "SDMMC3_D2"),
+		STM32_FUNCTION(12, "FMC_NWAIT"),
+		STM32_FUNCTION(15, "DCMI_D12 PSSI_D12 DCMIPP_D12"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(29, "PB13"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB13"),
+		STM32_FUNCTION(3, "SPI7_SCK"),
+		STM32_FUNCTION(5, "SAI1_SD_B"),
+		STM32_FUNCTION(6, "UART8_RX"),
+		STM32_FUNCTION(11, "SDMMC3_CK"),
+		STM32_FUNCTION(12, "FMC_AD5 FMC_D5"),
+		STM32_FUNCTION(13, "FMC_AD0 FMC_D0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(30, "PB14"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB14"),
+		STM32_FUNCTION(3, "SPI2_SCK I2S2_CK"),
+		STM32_FUNCTION(6, "MDF1_CKI7"),
+		STM32_FUNCTION(7, "UART9_RX"),
+		STM32_FUNCTION(10, "TIM4_CH2"),
+		STM32_FUNCTION(11, "SDMMC3_D0"),
+		STM32_FUNCTION(12, "FMC_AD7 FMC_D7"),
+		STM32_FUNCTION(13, "FMC_AD2 FMC_D2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(31, "PB15"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB15"),
+		STM32_FUNCTION(2, "LPTIM1_IN2"),
+		STM32_FUNCTION(3, "SPI5_SCK"),
+		STM32_FUNCTION(4, "UART8_RTS"),
+		STM32_FUNCTION(5, "SAI2_SD_B"),
+		STM32_FUNCTION(6, "UART5_RX"),
+		STM32_FUNCTION(8, "TIM3_CH2"),
+		STM32_FUNCTION(9, "TIM5_CH1"),
+		STM32_FUNCTION(11, "ETH1_PPS_OUT"),
+		STM32_FUNCTION(13, "FMC_A18"),
+		STM32_FUNCTION(14, "LCD_R4"),
+		STM32_FUNCTION(15, "DCMI_D8 PSSI_D8 DCMIPP_D8"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(32, "PC0"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC0"),
+		STM32_FUNCTION(2, "LPTIM1_CH1"),
+		STM32_FUNCTION(4, "SPI6_SCK"),
+		STM32_FUNCTION(5, "SAI3_MCLK_B"),
+		STM32_FUNCTION(6, "USART6_TX"),
+		STM32_FUNCTION(10, "DCMI_D0 PSSI_D0 DCMIPP_D0"),
+		STM32_FUNCTION(11, "ETH2_MII_RX_CLK ETH2_RGMII_RX_CLK ETH2_RMII_REF_CLK"),
+		STM32_FUNCTION(12, "ETH1_MII_TX_CLK"),
+		STM32_FUNCTION(13, "ETH1_RGMII_GTX_CLK"),
+		STM32_FUNCTION(14, "LCD_G7"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(33, "PC1"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC1"),
+		STM32_FUNCTION(3, "SPI3_MOSI I2S3_SDO"),
+		STM32_FUNCTION(7, "USART2_TX"),
+		STM32_FUNCTION(10, "I2C7_SCL"),
+		STM32_FUNCTION(11, "ETH1_MII_TXD1 ETH1_RGMII_TXD1 ETH1_RMII_TXD1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(34, "PC2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC2"),
+		STM32_FUNCTION(2, "SPI8_MOSI"),
+		STM32_FUNCTION(3, "LPTIM2_IN1"),
+		STM32_FUNCTION(5, "SAI4_MCLK_B"),
+		STM32_FUNCTION(6, "MDF1_SDI3"),
+		STM32_FUNCTION(7, "USART2_RTS"),
+		STM32_FUNCTION(11, "ETH1_MII_RXD1 ETH1_RGMII_RXD1 ETH1_RMII_RXD1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(35, "PC3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC3"),
+		STM32_FUNCTION(2, "LPTIM1_IN2"),
+		STM32_FUNCTION(3, "SPI3_NSS I2S3_WS"),
+		STM32_FUNCTION(4, "SPI6_RDY"),
+		STM32_FUNCTION(7, "USART6_RTS"),
+		STM32_FUNCTION(8, "FDCAN2_TX"),
+		STM32_FUNCTION(11, "ETH2_MII_RX_DV ETH2_RGMII_RX_CTL ETH2_RMII_CRS_DV"),
+		STM32_FUNCTION(12, "ETH1_MII_RX_ER"),
+		STM32_FUNCTION(14, "LCD_G6"),
+		STM32_FUNCTION(15, "DCMI_D3 PSSI_D3 DCMIPP_D3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(36, "PC4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC4"),
+		STM32_FUNCTION(4, "SPI6_MISO"),
+		STM32_FUNCTION(5, "SAI3_FS_B"),
+		STM32_FUNCTION(11, "ETH2_MII_TX_EN ETH2_RGMII_TX_CTL ETH2_RMII_TX_EN"),
+		STM32_FUNCTION(13, "ETH1_RGMII_CLK125"),
+		STM32_FUNCTION(14, "LCD_R0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(37, "PC5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC5"),
+		STM32_FUNCTION(3, "SPDIFRX1_IN1"),
+		STM32_FUNCTION(6, "MDF1_SDI1"),
+		STM32_FUNCTION(9, "TIM8_CH1N"),
+		STM32_FUNCTION(10, "I2C4_SDA"),
+		STM32_FUNCTION(11, "ETH2_MDIO"),
+		STM32_FUNCTION(12, "ETH1_MII_COL"),
+		STM32_FUNCTION(13, "FMC_A25"),
+		STM32_FUNCTION(14, "ETH1_PPS_OUT"),
+		STM32_FUNCTION(15, "LCD_DE"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(38, "PC6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC6"),
+		STM32_FUNCTION(2, "RTC_REFIN"),
+		STM32_FUNCTION(3, "SPDIFRX1_IN0"),
+		STM32_FUNCTION(6, "MDF1_CKI1"),
+		STM32_FUNCTION(9, "TIM8_CH1"),
+		STM32_FUNCTION(10, "I2C4_SCL"),
+		STM32_FUNCTION(11, "ETH2_MDC"),
+		STM32_FUNCTION(12, "ETH1_MII_CRS"),
+		STM32_FUNCTION(13, "FMC_A24"),
+		STM32_FUNCTION(14, "ETH1_PHY_INTN"),
+		STM32_FUNCTION(15, "LCD_CLK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(39, "PC7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC7"),
+		STM32_FUNCTION(4, "SPI6_MOSI"),
+		STM32_FUNCTION(5, "SAI3_SD_B"),
+		STM32_FUNCTION(9, "TIM8_CH2N"),
+		STM32_FUNCTION(11, "ETH2_MII_TXD0 ETH2_RGMII_TXD0 ETH2_RMII_TXD0"),
+		STM32_FUNCTION(12, "ETH1_MII_TXD2 ETH1_RGMII_TXD2"),
+		STM32_FUNCTION(14, "LCD_B4"),
+		STM32_FUNCTION(15, "DCMI_D1 PSSI_D1 DCMIPP_D1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(40, "PC8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC8"),
+		STM32_FUNCTION(2, "LPTIM1_ETR"),
+		STM32_FUNCTION(4, "SPI6_NSS"),
+		STM32_FUNCTION(5, "SAI3_SCK_B"),
+		STM32_FUNCTION(7, "USART6_CTS"),
+		STM32_FUNCTION(9, "TIM8_CH2"),
+		STM32_FUNCTION(11, "ETH2_MII_TXD1 ETH2_RGMII_TXD1 ETH2_RMII_TXD1"),
+		STM32_FUNCTION(12, "ETH1_MII_TXD3 ETH1_RGMII_TXD3"),
+		STM32_FUNCTION(14, "LCD_B3"),
+		STM32_FUNCTION(15, "DCMI_D2 PSSI_D2 DCMIPP_D2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(41, "PC9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC9"),
+		STM32_FUNCTION(2, "MCO1"),
+		STM32_FUNCTION(3, "SPI3_MISO I2S3_SDI"),
+		STM32_FUNCTION(5, "SAI2_SCK_A"),
+		STM32_FUNCTION(8, "TIM13_CH1"),
+		STM32_FUNCTION(9, "TIM8_CH4N"),
+		STM32_FUNCTION(10, "USBH_HS_OVRCUR"),
+		STM32_FUNCTION(11, "ETH2_MII_TXD2 ETH2_RGMII_TXD2"),
+		STM32_FUNCTION(12, "USB3DR_OVRCUR"),
+		STM32_FUNCTION(13, "FMC_A22"),
+		STM32_FUNCTION(14, "LCD_G2"),
+		STM32_FUNCTION(15, "DCMI_D7 PSSI_D7 DCMIPP_D7"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(42, "PC10"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC10"),
+		STM32_FUNCTION(3, "SPI3_MOSI I2S3_SDO"),
+		STM32_FUNCTION(8, "LPTIM4_ETR"),
+		STM32_FUNCTION(9, "TIM8_CH4"),
+		STM32_FUNCTION(10, "USBH_HS_VBUSEN"),
+		STM32_FUNCTION(11, "ETH2_MII_TXD3 ETH2_RGMII_TXD3"),
+		STM32_FUNCTION(12, "USB3DR_VBUSEN"),
+		STM32_FUNCTION(13, "FMC_A23"),
+		STM32_FUNCTION(14, "LCD_G3"),
+		STM32_FUNCTION(15, "DCMI_D6 PSSI_D6 DCMIPP_D6"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(43, "PC11"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC11"),
+		STM32_FUNCTION(2, "LPTIM1_CH1"),
+		STM32_FUNCTION(3, "SPI5_NSS"),
+		STM32_FUNCTION(5, "SAI2_MCLK_A"),
+		STM32_FUNCTION(6, "UART5_RTS"),
+		STM32_FUNCTION(7, "USART3_RTS"),
+		STM32_FUNCTION(8, "TIM3_CH1"),
+		STM32_FUNCTION(9, "TIM5_ETR"),
+		STM32_FUNCTION(11, "ETH2_MII_RXD3 ETH2_RGMII_RXD3"),
+		STM32_FUNCTION(13, "FMC_NBL1"),
+		STM32_FUNCTION(14, "LCD_R2"),
+		STM32_FUNCTION(15, "DCMI_D10 PSSI_D10 DCMIPP_D10"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(44, "PC12"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC12"),
+		STM32_FUNCTION(2, "LPTIM1_CH2"),
+		STM32_FUNCTION(4, "I3C3_SCL"),
+		STM32_FUNCTION(6, "MDF1_CKI2"),
+		STM32_FUNCTION(9, "TIM8_CH3"),
+		STM32_FUNCTION(10, "I2C3_SCL"),
+		STM32_FUNCTION(11, "ETH2_MII_RXD1 ETH2_RGMII_RXD1 ETH2_RMII_RXD1"),
+		STM32_FUNCTION(12, "ETH1_MII_RXD3 ETH1_RGMII_RXD3"),
+		STM32_FUNCTION(14, "LCD_G1"),
+		STM32_FUNCTION(15, "DCMI_D5 PSSI_D5 DCMIPP_D5"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(45, "PC13"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC13"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(48, "PD0"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD0"),
+		STM32_FUNCTION(1, "TRACECLK"),
+		STM32_FUNCTION(2, "HDP0"),
+		STM32_FUNCTION(3, "SPI7_RDY"),
+		STM32_FUNCTION(4, "SAI1_D2"),
+		STM32_FUNCTION(6, "SAI4_FS_A"),
+		STM32_FUNCTION(7, "UART7_RX"),
+		STM32_FUNCTION(8, "TIM15_CH2"),
+		STM32_FUNCTION(10, "SDVSEL1"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_CLK"),
+		STM32_FUNCTION(14, "DCMI_PIXCLK PSSI_PDCK DCMIPP_PIXCLK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(49, "PD1"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD1"),
+		STM32_FUNCTION(2, "HDP1"),
+		STM32_FUNCTION(3, "SPI1_MISO I2S1_SDI"),
+		STM32_FUNCTION(4, "SAI1_CK2"),
+		STM32_FUNCTION(6, "SAI4_SD_A"),
+		STM32_FUNCTION(7, "UART7_RTS"),
+		STM32_FUNCTION(8, "TIM15_CH1"),
+		STM32_FUNCTION(9, "TIM1_BKIN"),
+		STM32_FUNCTION(10, "FDCAN3_RX"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_NCLK"),
+		STM32_FUNCTION(12, "OCTOSPIM_P1_NCS2"),
+		STM32_FUNCTION(13, "OCTOSPIM_P2_NCS2"),
+		STM32_FUNCTION(14, "DCMI_HSYNC PSSI_DE DCMIPP_HSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(50, "PD2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD2"),
+		STM32_FUNCTION(2, "HDP2"),
+		STM32_FUNCTION(3, "SPI1_NSS I2S1_WS"),
+		STM32_FUNCTION(4, "SAI1_CK1"),
+		STM32_FUNCTION(6, "SAI4_SCK_A"),
+		STM32_FUNCTION(7, "UART7_CTS"),
+		STM32_FUNCTION(8, "TIM15_BKIN"),
+		STM32_FUNCTION(9, "TIM1_ETR"),
+		STM32_FUNCTION(10, "FDCAN3_TX"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_DQS"),
+		STM32_FUNCTION(12, "OCTOSPIM_P1_NCS2"),
+		STM32_FUNCTION(14, "DCMI_VSYNC PSSI_RDY DCMIPP_VSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(51, "PD3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD3"),
+		STM32_FUNCTION(2, "SAI1_MCLK_A"),
+		STM32_FUNCTION(3, "SPI2_SCK I2S2_CK"),
+		STM32_FUNCTION(4, "SAI1_D1"),
+		STM32_FUNCTION(6, "SAI4_MCLK_A"),
+		STM32_FUNCTION(7, "UART7_TX"),
+		STM32_FUNCTION(8, "TIM15_CH1N"),
+		STM32_FUNCTION(9, "TIM1_BKIN2"),
+		STM32_FUNCTION(10, "SDVSEL2"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_NCS1"),
+		STM32_FUNCTION(14, "PSSI_D15 DCMIPP_D15"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(52, "PD4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD4"),
+		STM32_FUNCTION(1, "TRACED0"),
+		STM32_FUNCTION(2, "SPI4_MISO"),
+		STM32_FUNCTION(3, "HDP3"),
+		STM32_FUNCTION(4, "SAI1_D3"),
+		STM32_FUNCTION(5, "SAI1_SD_B"),
+		STM32_FUNCTION(9, "TIM1_CH4N"),
+		STM32_FUNCTION(10, "TIM4_CH1"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_IO0"),
+		STM32_FUNCTION(14, "PSSI_D14 DCMIPP_D14"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(53, "PD5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD5"),
+		STM32_FUNCTION(1, "TRACED1"),
+		STM32_FUNCTION(2, "SPI4_NSS"),
+		STM32_FUNCTION(3, "HDP4"),
+		STM32_FUNCTION(4, "SAI1_D4"),
+		STM32_FUNCTION(5, "SAI1_FS_B"),
+		STM32_FUNCTION(9, "TIM1_CH3N"),
+		STM32_FUNCTION(10, "TIM4_CH2"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_IO1"),
+		STM32_FUNCTION(14, "DCMI_D13 PSSI_D13 DCMIPP_D13"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(54, "PD6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD6"),
+		STM32_FUNCTION(1, "TRACED2"),
+		STM32_FUNCTION(2, "SPI4_MOSI"),
+		STM32_FUNCTION(3, "HDP5"),
+		STM32_FUNCTION(5, "SAI1_SCK_B"),
+		STM32_FUNCTION(6, "MDF1_SDI2"),
+		STM32_FUNCTION(9, "TIM1_CH2N"),
+		STM32_FUNCTION(10, "TIM4_CH3"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_IO2"),
+		STM32_FUNCTION(14, "DCMI_D12 PSSI_D12 DCMIPP_D12"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(55, "PD7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD7"),
+		STM32_FUNCTION(1, "TRACED3"),
+		STM32_FUNCTION(2, "SPI4_SCK"),
+		STM32_FUNCTION(3, "SPI1_RDY"),
+		STM32_FUNCTION(5, "SAI1_MCLK_B"),
+		STM32_FUNCTION(6, "MDF1_CKI2"),
+		STM32_FUNCTION(9, "TIM1_CH1N"),
+		STM32_FUNCTION(10, "TIM4_CH4"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_IO3"),
+		STM32_FUNCTION(14, "DCMI_D11 PSSI_D11 DCMIPP_D11"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(56, "PD8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD8"),
+		STM32_FUNCTION(1, "TRACED4"),
+		STM32_FUNCTION(2, "SPI4_RDY"),
+		STM32_FUNCTION(3, "I2S1_MCK"),
+		STM32_FUNCTION(4, "SAI1_FS_A"),
+		STM32_FUNCTION(5, "UART4_CTS"),
+		STM32_FUNCTION(6, "MDF1_SDI1"),
+		STM32_FUNCTION(9, "TIM1_CH4"),
+		STM32_FUNCTION(10, "TIM4_ETR"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_IO4"),
+		STM32_FUNCTION(12, "SDMMC1_D7"),
+		STM32_FUNCTION(13, "SDMMC1_D123DIR"),
+		STM32_FUNCTION(14, "DCMI_D10 PSSI_D10 DCMIPP_D10"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(57, "PD9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD9"),
+		STM32_FUNCTION(1, "TRACED5"),
+		STM32_FUNCTION(2, "HDP6"),
+		STM32_FUNCTION(3, "SPI1_MOSI I2S1_SDO"),
+		STM32_FUNCTION(4, "SAI1_SD_A"),
+		STM32_FUNCTION(5, "UART4_RTS"),
+		STM32_FUNCTION(6, "MDF1_CKI1"),
+		STM32_FUNCTION(9, "TIM1_CH3"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_IO5"),
+		STM32_FUNCTION(12, "SDMMC1_D6"),
+		STM32_FUNCTION(13, "SDMMC1_D0DIR"),
+		STM32_FUNCTION(14, "DCMI_D9 PSSI_D9 DCMIPP_D9"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(58, "PD10"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD10"),
+		STM32_FUNCTION(1, "TRACED6"),
+		STM32_FUNCTION(2, "HDP7"),
+		STM32_FUNCTION(4, "SAI1_SCK_A"),
+		STM32_FUNCTION(5, "UART4_RX"),
+		STM32_FUNCTION(6, "MDF1_SDI0"),
+		STM32_FUNCTION(7, "I2C4_SDA"),
+		STM32_FUNCTION(9, "TIM1_CH2"),
+		STM32_FUNCTION(10, "TIM14_CH1"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_IO6"),
+		STM32_FUNCTION(12, "SDMMC1_D5"),
+		STM32_FUNCTION(13, "SDMMC1_CDIR"),
+		STM32_FUNCTION(14, "DCMI_D8 PSSI_D8 DCMIPP_D8"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(59, "PD11"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD11"),
+		STM32_FUNCTION(1, "TRACED7"),
+		STM32_FUNCTION(3, "SPI1_SCK I2S1_CK"),
+		STM32_FUNCTION(4, "SAI1_MCLK_A"),
+		STM32_FUNCTION(5, "UART4_TX"),
+		STM32_FUNCTION(6, "MDF1_CKI0"),
+		STM32_FUNCTION(7, "I2C4_SCL"),
+		STM32_FUNCTION(9, "TIM1_CH1"),
+		STM32_FUNCTION(10, "SDVSEL1"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_IO7"),
+		STM32_FUNCTION(12, "SDMMC1_D4"),
+		STM32_FUNCTION(13, "SDMMC1_CKIN"),
+		STM32_FUNCTION(14, "DCMI_D7 PSSI_D7 DCMIPP_D7"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(60, "PD12"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD12"),
+		STM32_FUNCTION(2, "SPI7_MISO"),
+		STM32_FUNCTION(3, "SPI2_MISO I2S2_SDI"),
+		STM32_FUNCTION(4, "SPDIFRX1_IN2"),
+		STM32_FUNCTION(6, "UART8_RTS"),
+		STM32_FUNCTION(10, "TIM4_ETR"),
+		STM32_FUNCTION(11, "SDMMC3_CMD"),
+		STM32_FUNCTION(12, "FMC_AD6 FMC_D6"),
+		STM32_FUNCTION(13, "FMC_AD1 FMC_D1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(61, "PD13"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD13"),
+		STM32_FUNCTION(3, "SPI2_NSS I2S2_WS"),
+		STM32_FUNCTION(6, "MDF1_SDI7"),
+		STM32_FUNCTION(7, "UART9_TX"),
+		STM32_FUNCTION(10, "TIM4_CH4"),
+		STM32_FUNCTION(11, "SDMMC3_D1"),
+		STM32_FUNCTION(12, "FMC_AD11 FMC_D11"),
+		STM32_FUNCTION(13, "FMC_NWE"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(62, "PD14"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD14"),
+		STM32_FUNCTION(3, "I2S1_MCK"),
+		STM32_FUNCTION(8, "FDCAN1_RX"),
+		STM32_FUNCTION(9, "TIM11_CH1"),
+		STM32_FUNCTION(11, "I2C7_SDA"),
+		STM32_FUNCTION(12, "FMC_AD4 FMC_D4"),
+		STM32_FUNCTION(13, "SDMMC3_D3"),
+		STM32_FUNCTION(14, "DCMI_D1 PSSI_D1 DCMIPP_D1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(63, "PD15"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD15"),
+		STM32_FUNCTION(2, "SPI1_RDY"),
+		STM32_FUNCTION(6, "DSI_TE"),
+		STM32_FUNCTION(7, "I2C5_SDA"),
+		STM32_FUNCTION(8, "FDCAN1_TX"),
+		STM32_FUNCTION(9, "TIM1_BKIN2"),
+		STM32_FUNCTION(10, "TIM5_ETR"),
+		STM32_FUNCTION(11, "I2C7_SCL"),
+		STM32_FUNCTION(12, "FMC_AD3 FMC_D3"),
+		STM32_FUNCTION(13, "SDMMC3_CKIN"),
+		STM32_FUNCTION(14, "DCMI_D0 PSSI_D0 DCMIPP_D0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(64, "PE0"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE0"),
+		STM32_FUNCTION(1, "TRACED2"),
+		STM32_FUNCTION(2, "LPTIM2_CH1"),
+		STM32_FUNCTION(3, "SPI1_SCK I2S1_CK"),
+		STM32_FUNCTION(4, "SPI3_RDY"),
+		STM32_FUNCTION(7, "USART3_CK"),
+		STM32_FUNCTION(11, "SDMMC1_D2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(65, "PE1"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE1"),
+		STM32_FUNCTION(1, "TRACED3"),
+		STM32_FUNCTION(2, "LPTIM2_CH2"),
+		STM32_FUNCTION(3, "I2S1_MCK"),
+		STM32_FUNCTION(4, "I2S3_MCK"),
+		STM32_FUNCTION(7, "USART3_RX"),
+		STM32_FUNCTION(11, "SDMMC1_D3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(66, "PE2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE2"),
+		STM32_FUNCTION(2, "LPTIM2_ETR"),
+		STM32_FUNCTION(3, "SPI1_MISO I2S1_SDI"),
+		STM32_FUNCTION(4, "SPI3_MOSI I2S3_SDO"),
+		STM32_FUNCTION(5, "SAI1_SCK_B"),
+		STM32_FUNCTION(9, "TIM10_CH1"),
+		STM32_FUNCTION(11, "SDMMC1_CMD"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(67, "PE3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE3"),
+		STM32_FUNCTION(1, "TRACECLK"),
+		STM32_FUNCTION(3, "SPI1_RDY"),
+		STM32_FUNCTION(4, "SPI3_SCK I2S3_CK"),
+		STM32_FUNCTION(5, "SAI1_MCLK_B"),
+		STM32_FUNCTION(7, "USART3_TX"),
+		STM32_FUNCTION(9, "TIM11_CH1"),
+		STM32_FUNCTION(11, "SDMMC1_CK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(68, "PE4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE4"),
+		STM32_FUNCTION(1, "TRACED0"),
+		STM32_FUNCTION(2, "LPTIM2_IN1"),
+		STM32_FUNCTION(3, "SPI1_MOSI I2S1_SDO"),
+		STM32_FUNCTION(4, "SPI3_MISO I2S3_SDI"),
+		STM32_FUNCTION(5, "SAI1_SD_B"),
+		STM32_FUNCTION(7, "USART3_CTS"),
+		STM32_FUNCTION(8, "FDCAN1_TX"),
+		STM32_FUNCTION(11, "SDMMC1_D0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(69, "PE5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE5"),
+		STM32_FUNCTION(1, "TRACED1"),
+		STM32_FUNCTION(2, "LPTIM2_IN2"),
+		STM32_FUNCTION(3, "SPI1_NSS I2S1_WS"),
+		STM32_FUNCTION(4, "SPI3_NSS I2S3_WS"),
+		STM32_FUNCTION(5, "SAI1_FS_B"),
+		STM32_FUNCTION(7, "USART3_RTS"),
+		STM32_FUNCTION(8, "FDCAN1_RX"),
+		STM32_FUNCTION(11, "SDMMC1_D1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(70, "PE6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE6"),
+		STM32_FUNCTION(2, "SPI4_RDY"),
+		STM32_FUNCTION(5, "SPDIFRX1_IN2"),
+		STM32_FUNCTION(7, "USART1_TX"),
+		STM32_FUNCTION(9, "TIM1_ETR"),
+		STM32_FUNCTION(12, "FMC_AD1 FMC_D1"),
+		STM32_FUNCTION(13, "SDMMC2_D6"),
+		STM32_FUNCTION(14, "SDMMC2_D0DIR"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(71, "PE7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE7"),
+		STM32_FUNCTION(4, "SAI4_D4"),
+		STM32_FUNCTION(5, "SPDIFRX1_IN3"),
+		STM32_FUNCTION(7, "USART1_RX"),
+		STM32_FUNCTION(9, "TIM1_CH4N"),
+		STM32_FUNCTION(11, "TIM14_CH1"),
+		STM32_FUNCTION(12, "FMC_AD2 FMC_D2"),
+		STM32_FUNCTION(13, "SDMMC2_D7"),
+		STM32_FUNCTION(14, "SDMMC2_D123DIR"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(72, "PE8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE8"),
+		STM32_FUNCTION(2, "SPI4_MOSI"),
+		STM32_FUNCTION(4, "SAI4_CK1"),
+		STM32_FUNCTION(5, "SAI4_MCLK_A"),
+		STM32_FUNCTION(6, "MDF1_CKI0"),
+		STM32_FUNCTION(9, "TIM1_CH1"),
+		STM32_FUNCTION(12, "FMC_A17 FMC_ALE"),
+		STM32_FUNCTION(13, "SDMMC2_D2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(73, "PE9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE9"),
+		STM32_FUNCTION(2, "SPI4_MISO"),
+		STM32_FUNCTION(4, "SAI4_D2"),
+		STM32_FUNCTION(5, "SAI4_FS_A"),
+		STM32_FUNCTION(7, "USART1_CK"),
+		STM32_FUNCTION(9, "TIM1_CH4"),
+		STM32_FUNCTION(12, "FMC_AD0 FMC_D0"),
+		STM32_FUNCTION(13, "SDMMC2_D5"),
+		STM32_FUNCTION(14, "SDMMC2_CDIR"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(74, "PE10"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE10"),
+		STM32_FUNCTION(2, "SPI4_SCK"),
+		STM32_FUNCTION(4, "SAI4_D1"),
+		STM32_FUNCTION(5, "SAI4_SD_A"),
+		STM32_FUNCTION(7, "USART1_CTS"),
+		STM32_FUNCTION(9, "TIM1_CH3"),
+		STM32_FUNCTION(11, "FMC_NE3"),
+		STM32_FUNCTION(12, "FMC_NCE2"),
+		STM32_FUNCTION(13, "SDMMC2_D4"),
+		STM32_FUNCTION(14, "SDMMC2_CKIN"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(75, "PE11"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE11"),
+		STM32_FUNCTION(3, "SPI7_SCK"),
+		STM32_FUNCTION(4, "SAI4_D3"),
+		STM32_FUNCTION(5, "SAI1_FS_A"),
+		STM32_FUNCTION(8, "TIM15_CH2"),
+		STM32_FUNCTION(9, "TIM1_CH3N"),
+		STM32_FUNCTION(12, "FMC_A16 FMC_CLE"),
+		STM32_FUNCTION(13, "SDMMC2_D1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(76, "PE12"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE12"),
+		STM32_FUNCTION(2, "SPI4_NSS"),
+		STM32_FUNCTION(4, "SAI4_CK2"),
+		STM32_FUNCTION(5, "SAI4_SCK_A"),
+		STM32_FUNCTION(6, "MDF1_SDI0"),
+		STM32_FUNCTION(7, "USART1_RTS"),
+		STM32_FUNCTION(9, "TIM1_CH2"),
+		STM32_FUNCTION(11, "FMC_NE2"),
+		STM32_FUNCTION(12, "FMC_NCE1"),
+		STM32_FUNCTION(13, "SDMMC2_D3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(77, "PE13"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE13"),
+		STM32_FUNCTION(3, "SPI7_MISO"),
+		STM32_FUNCTION(5, "SAI1_SD_A"),
+		STM32_FUNCTION(8, "TIM15_CH1"),
+		STM32_FUNCTION(9, "TIM1_CH2N"),
+		STM32_FUNCTION(12, "FMC_RNB"),
+		STM32_FUNCTION(13, "SDMMC2_D0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(78, "PE14"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE14"),
+		STM32_FUNCTION(3, "SPI7_NSS"),
+		STM32_FUNCTION(5, "SAI1_MCLK_A"),
+		STM32_FUNCTION(6, "MDF1_CKI6"),
+		STM32_FUNCTION(8, "TIM15_BKIN"),
+		STM32_FUNCTION(9, "TIM1_BKIN"),
+		STM32_FUNCTION(12, "FMC_NWE"),
+		STM32_FUNCTION(13, "SDMMC2_CK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(79, "PE15"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE15"),
+		STM32_FUNCTION(3, "SPI7_MOSI"),
+		STM32_FUNCTION(5, "SAI1_SCK_A"),
+		STM32_FUNCTION(6, "MDF1_SDI6"),
+		STM32_FUNCTION(8, "TIM15_CH1N"),
+		STM32_FUNCTION(9, "TIM1_CH1N"),
+		STM32_FUNCTION(12, "FMC_NOE"),
+		STM32_FUNCTION(13, "SDMMC2_CMD"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(80, "PF0"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF0"),
+		STM32_FUNCTION(3, "SPI3_SCK I2S3_CK"),
+		STM32_FUNCTION(8, "FDCAN2_RX"),
+		STM32_FUNCTION(9, "TIM12_CH2"),
+		STM32_FUNCTION(10, "I2C2_SDA"),
+		STM32_FUNCTION(11, "ETH1_MDC"),
+		STM32_FUNCTION(12, "ETH2_MII_CRS"),
+		STM32_FUNCTION(14, "I3C2_SDA"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(81, "PF1"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF1"),
+		STM32_FUNCTION(2, "SPI8_MISO"),
+		STM32_FUNCTION(3, "LPTIM2_IN2"),
+		STM32_FUNCTION(5, "SAI4_SCK_B"),
+		STM32_FUNCTION(6, "MDF1_CKI4"),
+		STM32_FUNCTION(7, "USART2_CK"),
+		STM32_FUNCTION(11, "ETH1_MII_RXD0 ETH1_RGMII_RXD0 ETH1_RMII_RXD0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(82, "PF2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF2"),
+		STM32_FUNCTION(3, "SPI3_RDY"),
+		STM32_FUNCTION(7, "I2C4_SMBA"),
+		STM32_FUNCTION(9, "TIM12_CH1"),
+		STM32_FUNCTION(10, "I2C2_SCL"),
+		STM32_FUNCTION(11, "ETH1_MDIO"),
+		STM32_FUNCTION(12, "ETH2_MII_COL"),
+		STM32_FUNCTION(13, "FMC_NE4"),
+		STM32_FUNCTION(14, "I3C2_SCL"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(83, "PF3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF3"),
+		STM32_FUNCTION(4, "UART8_RX"),
+		STM32_FUNCTION(5, "SAI2_SCK_B"),
+		STM32_FUNCTION(6, "MDF1_CCK0"),
+		STM32_FUNCTION(8, "TIM3_CH4"),
+		STM32_FUNCTION(9, "TIM8_BKIN2"),
+		STM32_FUNCTION(10, "ETH1_CLK"),
+		STM32_FUNCTION(11, "ETH2_PPS_OUT"),
+		STM32_FUNCTION(13, "FMC_A20"),
+		STM32_FUNCTION(14, "LCD_R6"),
+		STM32_FUNCTION(15, "DCMI_HSYNC PSSI_DE DCMIPP_HSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(84, "PF4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF4"),
+		STM32_FUNCTION(2, "RTC_OUT2"),
+		STM32_FUNCTION(3, "SPI6_NSS"),
+		STM32_FUNCTION(5, "SAI3_SCK_A"),
+		STM32_FUNCTION(7, "USART6_RX"),
+		STM32_FUNCTION(8, "TIM4_CH4"),
+		STM32_FUNCTION(9, "ETH1_MDC"),
+		STM32_FUNCTION(10, "ETH2_CLK"),
+		STM32_FUNCTION(11, "ETH2_PPS_OUT"),
+		STM32_FUNCTION(12, "ETH1_PPS_OUT"),
+		STM32_FUNCTION(14, "LCD_B7"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(85, "PF5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF5"),
+		STM32_FUNCTION(3, "SPI6_SCK"),
+		STM32_FUNCTION(5, "SAI3_MCLK_A"),
+		STM32_FUNCTION(7, "USART6_TX"),
+		STM32_FUNCTION(8, "TIM4_CH3"),
+		STM32_FUNCTION(9, "ETH1_MDIO"),
+		STM32_FUNCTION(10, "ETH1_CLK"),
+		STM32_FUNCTION(11, "ETH2_PHY_INTN"),
+		STM32_FUNCTION(12, "ETH1_PHY_INTN"),
+		STM32_FUNCTION(14, "LCD_B6"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(86, "PF6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF6"),
+		STM32_FUNCTION(2, "RTC_OUT2"),
+		STM32_FUNCTION(4, "SAI3_MCLK_B"),
+		STM32_FUNCTION(7, "USART6_CK"),
+		STM32_FUNCTION(8, "TIM12_CH1"),
+		STM32_FUNCTION(10, "I2C3_SMBA"),
+		STM32_FUNCTION(11, "ETH2_MII_RX_CLK ETH2_RGMII_RX_CLK ETH2_RMII_REF_CLK"),
+		STM32_FUNCTION(14, "LCD_B0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(87, "PF7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF7"),
+		STM32_FUNCTION(3, "SPDIFRX1_IN1"),
+		STM32_FUNCTION(4, "SPI6_SCK"),
+		STM32_FUNCTION(5, "SAI3_SD_A"),
+		STM32_FUNCTION(8, "TIM2_ETR"),
+		STM32_FUNCTION(11, "ETH2_RGMII_GTX_CLK"),
+		STM32_FUNCTION(12, "ETH2_MII_TX_CLK"),
+		STM32_FUNCTION(14, "LCD_R1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(88, "PF8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF8"),
+		STM32_FUNCTION(2, "RTC_REFIN"),
+		STM32_FUNCTION(4, "SAI3_SCK_B"),
+		STM32_FUNCTION(7, "USART3_RX"),
+		STM32_FUNCTION(8, "TIM12_CH2"),
+		STM32_FUNCTION(10, "ETH1_CLK"),
+		STM32_FUNCTION(11, "ETH2_RGMII_CLK125"),
+		STM32_FUNCTION(12, "ETH2_MII_RX_ER"),
+		STM32_FUNCTION(13, "ETH2_MII_RX_DV ETH2_RGMII_RX_CTL ETH2_RMII_CRS_DV"),
+		STM32_FUNCTION(14, "LCD_G0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(89, "PF9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF9"),
+		STM32_FUNCTION(4, "SAI3_SD_B"),
+		STM32_FUNCTION(5, "SAI2_SD_A"),
+		STM32_FUNCTION(6, "MDF1_SDI5"),
+		STM32_FUNCTION(7, "UART8_RTS"),
+		STM32_FUNCTION(8, "TIM2_CH2"),
+		STM32_FUNCTION(11, "ETH2_MII_RXD2 ETH2_RGMII_RXD2"),
+		STM32_FUNCTION(12, "ETH2_MDIO"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(90, "PF10"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF10"),
+		STM32_FUNCTION(2, "MCO2"),
+		STM32_FUNCTION(3, "SPI3_RDY"),
+		STM32_FUNCTION(5, "SAI2_MCLK_A"),
+		STM32_FUNCTION(6, "MDF1_CKI6"),
+		STM32_FUNCTION(7, "UART8_TX"),
+		STM32_FUNCTION(8, "TIM2_CH3"),
+		STM32_FUNCTION(11, "ETH2_MII_TXD2 ETH2_RGMII_TXD2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(91, "PF11"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF11"),
+		STM32_FUNCTION(2, "MCO1"),
+		STM32_FUNCTION(3, "SPDIFRX1_IN0"),
+		STM32_FUNCTION(4, "SPI6_RDY"),
+		STM32_FUNCTION(5, "SAI2_SCK_A"),
+		STM32_FUNCTION(6, "MDF1_SDI6"),
+		STM32_FUNCTION(7, "UART8_RX"),
+		STM32_FUNCTION(8, "TIM2_CH4"),
+		STM32_FUNCTION(11, "ETH2_MII_TXD3 ETH2_RGMII_TXD3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(92, "PF12"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF12"),
+		STM32_FUNCTION(1, "TRACECLK"),
+		STM32_FUNCTION(3, "SPI5_MISO"),
+		STM32_FUNCTION(4, "SPI1_MISO I2S1_SDI"),
+		STM32_FUNCTION(7, "UART9_RTS"),
+		STM32_FUNCTION(9, "TIM5_CH1"),
+		STM32_FUNCTION(14, "LCD_CLK"),
+		STM32_FUNCTION(15, "DCMI_D0 PSSI_D0 DCMIPP_D0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(93, "PF13"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF13"),
+		STM32_FUNCTION(1, "TRACED0"),
+		STM32_FUNCTION(2, "HDP0"),
+		STM32_FUNCTION(3, "AUDIOCLK"),
+		STM32_FUNCTION(4, "USART6_TX"),
+		STM32_FUNCTION(5, "SPI2_NSS I2S2_WS"),
+		STM32_FUNCTION(6, "MDF1_CKI7"),
+		STM32_FUNCTION(7, "USART3_CTS"),
+		STM32_FUNCTION(8, "FDCAN3_TX"),
+		STM32_FUNCTION(9, "TIM3_CH3"),
+		STM32_FUNCTION(14, "LCD_R2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(94, "PF14"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF14"),
+		STM32_FUNCTION(1, "TRACED1"),
+		STM32_FUNCTION(2, "HDP1"),
+		STM32_FUNCTION(4, "USART6_RX"),
+		STM32_FUNCTION(6, "MDF1_SDI7"),
+		STM32_FUNCTION(7, "USART3_RTS"),
+		STM32_FUNCTION(8, "FDCAN3_RX"),
+		STM32_FUNCTION(9, "TIM3_CH4"),
+		STM32_FUNCTION(14, "LCD_R3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(95, "PF15"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF15"),
+		STM32_FUNCTION(1, "TRACED2"),
+		STM32_FUNCTION(2, "HDP2"),
+		STM32_FUNCTION(3, "SPI2_RDY"),
+		STM32_FUNCTION(4, "USART6_CTS"),
+		STM32_FUNCTION(5, "SPI2_SCK I2S2_CK"),
+		STM32_FUNCTION(7, "USART3_CK"),
+		STM32_FUNCTION(8, "TIM2_CH2"),
+		STM32_FUNCTION(9, "TIM3_ETR"),
+		STM32_FUNCTION(10, "I2C6_SMBA"),
+		STM32_FUNCTION(14, "LCD_R4"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(96, "PG0"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG0"),
+		STM32_FUNCTION(2, "LPTIM1_IN1"),
+		STM32_FUNCTION(4, "I3C3_SDA"),
+		STM32_FUNCTION(6, "MDF1_SDI2"),
+		STM32_FUNCTION(9, "TIM8_CH3N"),
+		STM32_FUNCTION(10, "I2C3_SDA"),
+		STM32_FUNCTION(11, "ETH2_MII_RXD0 ETH2_RGMII_RXD0 ETH2_RMII_RXD0"),
+		STM32_FUNCTION(12, "ETH1_MII_RXD2 ETH1_RGMII_RXD2"),
+		STM32_FUNCTION(14, "LCD_G5"),
+		STM32_FUNCTION(15, "DCMI_D4 PSSI_D4 DCMIPP_D4"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(97, "PG1"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG1"),
+		STM32_FUNCTION(2, "LPTIM1_IN1"),
+		STM32_FUNCTION(3, "I2S3_MCK"),
+		STM32_FUNCTION(4, "I3C3_SCL"),
+		STM32_FUNCTION(5, "SAI2_SD_A"),
+		STM32_FUNCTION(6, "UART5_CTS"),
+		STM32_FUNCTION(7, "USART3_CTS"),
+		STM32_FUNCTION(9, "TIM5_CH4"),
+		STM32_FUNCTION(10, "I2C3_SCL"),
+		STM32_FUNCTION(11, "ETH2_MII_RX_ER"),
+		STM32_FUNCTION(12, "ETH2_MII_RXD3 ETH2_RGMII_RXD3"),
+		STM32_FUNCTION(13, "FMC_NBL0"),
+		STM32_FUNCTION(14, "LCD_VSYNC"),
+		STM32_FUNCTION(15, "DCMI_D11 PSSI_D11 DCMIPP_D11"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(98, "PG2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG2"),
+		STM32_FUNCTION(2, "RTC_REFIN"),
+		STM32_FUNCTION(3, "I2S3_MCK"),
+		STM32_FUNCTION(4, "I3C3_SDA"),
+		STM32_FUNCTION(5, "SAI2_FS_A"),
+		STM32_FUNCTION(7, "USART3_CK"),
+		STM32_FUNCTION(9, "TIM5_CH3"),
+		STM32_FUNCTION(10, "I2C3_SDA"),
+		STM32_FUNCTION(11, "ETH2_MII_TX_CLK"),
+		STM32_FUNCTION(12, "ETH2_RGMII_CLK125"),
+		STM32_FUNCTION(13, "FMC_CLK"),
+		STM32_FUNCTION(14, "LCD_HSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(99, "PG3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG3"),
+		STM32_FUNCTION(2, "LPTIM1_ETR"),
+		STM32_FUNCTION(3, "SPI5_MOSI"),
+		STM32_FUNCTION(4, "UART8_TX"),
+		STM32_FUNCTION(5, "SAI2_FS_B"),
+		STM32_FUNCTION(8, "TIM3_CH3"),
+		STM32_FUNCTION(9, "TIM8_ETR"),
+		STM32_FUNCTION(10, "ETH2_CLK"),
+		STM32_FUNCTION(11, "ETH2_PHY_INTN"),
+		STM32_FUNCTION(13, "FMC_A19"),
+		STM32_FUNCTION(14, "LCD_R5"),
+		STM32_FUNCTION(15, "DCMI_PIXCLK PSSI_PDCK DCMIPP_PIXCLK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(100, "PG4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG4"),
+		STM32_FUNCTION(3, "SPI5_MISO"),
+		STM32_FUNCTION(4, "SAI3_FS_B"),
+		STM32_FUNCTION(8, "LPTIM4_IN1"),
+		STM32_FUNCTION(9, "TIM8_BKIN"),
+		STM32_FUNCTION(11, "ETH2_PPS_OUT"),
+		STM32_FUNCTION(12, "ETH2_MDC"),
+		STM32_FUNCTION(13, "FMC_A21"),
+		STM32_FUNCTION(14, "LCD_R7"),
+		STM32_FUNCTION(15, "DCMI_VSYNC PSSI_RDY DCMIPP_VSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(101, "PG5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG5"),
+		STM32_FUNCTION(1, "TRACED3"),
+		STM32_FUNCTION(2, "HDP3"),
+		STM32_FUNCTION(4, "USART6_RTS"),
+		STM32_FUNCTION(8, "TIM2_CH3"),
+		STM32_FUNCTION(10, "I2C6_SDA"),
+		STM32_FUNCTION(14, "LCD_R5"),
+		STM32_FUNCTION(15, "DCMI_PIXCLK PSSI_PDCK DCMIPP_PIXCLK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(102, "PG6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG6"),
+		STM32_FUNCTION(1, "TRACED4"),
+		STM32_FUNCTION(2, "HDP4"),
+		STM32_FUNCTION(3, "SPI5_SCK"),
+		STM32_FUNCTION(4, "SPI1_SCK I2S1_CK"),
+		STM32_FUNCTION(8, "TIM2_CH4"),
+		STM32_FUNCTION(10, "I2C6_SCL"),
+		STM32_FUNCTION(14, "LCD_R6"),
+		STM32_FUNCTION(15, "DCMI_HSYNC PSSI_DE DCMIPP_HSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(103, "PG7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG7"),
+		STM32_FUNCTION(1, "TRACED5"),
+		STM32_FUNCTION(2, "HDP5"),
+		STM32_FUNCTION(3, "SPI5_NSS"),
+		STM32_FUNCTION(4, "SPI1_NSS I2S1_WS"),
+		STM32_FUNCTION(7, "UART9_CTS"),
+		STM32_FUNCTION(9, "TIM5_ETR"),
+		STM32_FUNCTION(14, "LCD_R7"),
+		STM32_FUNCTION(15, "DCMI_VSYNC PSSI_RDY DCMIPP_VSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(104, "PG8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG8"),
+		STM32_FUNCTION(1, "TRACED6"),
+		STM32_FUNCTION(2, "HDP6"),
+		STM32_FUNCTION(3, "SPI5_RDY"),
+		STM32_FUNCTION(4, "SPI1_RDY"),
+		STM32_FUNCTION(5, "USART6_CK"),
+		STM32_FUNCTION(6, "UART5_RTS"),
+		STM32_FUNCTION(7, "UART9_TX"),
+		STM32_FUNCTION(9, "TIM5_CH3"),
+		STM32_FUNCTION(14, "LCD_G2"),
+		STM32_FUNCTION(15, "DCMI_D2 PSSI_D2 DCMIPP_D2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(105, "PG9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG9"),
+		STM32_FUNCTION(1, "TRACED7"),
+		STM32_FUNCTION(6, "UART5_TX"),
+		STM32_FUNCTION(9, "TIM5_CH4"),
+		STM32_FUNCTION(14, "LCD_G3"),
+		STM32_FUNCTION(15, "DCMI_D3 PSSI_D3 DCMIPP_D3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(106, "PG10"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG10"),
+		STM32_FUNCTION(1, "TRACED8"),
+		STM32_FUNCTION(2, "HDP0"),
+		STM32_FUNCTION(6, "UART5_RX"),
+		STM32_FUNCTION(9, "TIM8_CH4N"),
+		STM32_FUNCTION(14, "LCD_G4"),
+		STM32_FUNCTION(15, "DCMI_D4 PSSI_D4 DCMIPP_D4"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(107, "PG11"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG11"),
+		STM32_FUNCTION(1, "TRACED9"),
+		STM32_FUNCTION(2, "HDP1"),
+		STM32_FUNCTION(3, "SPI7_MOSI"),
+		STM32_FUNCTION(8, "FDCAN1_TX"),
+		STM32_FUNCTION(9, "TIM8_CH4"),
+		STM32_FUNCTION(14, "LCD_G5"),
+		STM32_FUNCTION(15, "DCMI_D5 PSSI_D5 DCMIPP_D5"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(108, "PG12"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG12"),
+		STM32_FUNCTION(1, "TRACED10"),
+		STM32_FUNCTION(2, "HDP2"),
+		STM32_FUNCTION(3, "SPI7_MISO"),
+		STM32_FUNCTION(8, "FDCAN1_RX"),
+		STM32_FUNCTION(9, "TIM8_CH1N"),
+		STM32_FUNCTION(14, "LCD_G6"),
+		STM32_FUNCTION(15, "DCMI_D6 PSSI_D6 DCMIPP_D6"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(109, "PG13"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG13"),
+		STM32_FUNCTION(1, "TRACED11"),
+		STM32_FUNCTION(2, "HDP3"),
+		STM32_FUNCTION(3, "SPI7_SCK"),
+		STM32_FUNCTION(6, "MDF1_CKI6"),
+		STM32_FUNCTION(9, "TIM8_CH2N"),
+		STM32_FUNCTION(10, "I2C1_SCL"),
+		STM32_FUNCTION(11, "I3C1_SCL"),
+		STM32_FUNCTION(14, "LCD_G7"),
+		STM32_FUNCTION(15, "DCMI_D7 PSSI_D7 DCMIPP_D7"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(110, "PG14"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG14"),
+		STM32_FUNCTION(1, "TRACED12"),
+		STM32_FUNCTION(2, "HDP4"),
+		STM32_FUNCTION(3, "SPI7_RDY"),
+		STM32_FUNCTION(6, "MDF1_CKI5"),
+		STM32_FUNCTION(7, "USART1_TX"),
+		STM32_FUNCTION(9, "TIM8_BKIN2"),
+		STM32_FUNCTION(14, "LCD_B1"),
+		STM32_FUNCTION(15, "DCMI_D9 PSSI_D9 DCMIPP_D9"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(111, "PG15"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG15"),
+		STM32_FUNCTION(1, "TRACED13"),
+		STM32_FUNCTION(2, "HDP5"),
+		STM32_FUNCTION(4, "LPTIM1_CH2"),
+		STM32_FUNCTION(6, "MDF1_SDI5"),
+		STM32_FUNCTION(7, "USART1_RX"),
+		STM32_FUNCTION(9, "TIM8_ETR"),
+		STM32_FUNCTION(14, "LCD_B2"),
+		STM32_FUNCTION(15, "DCMI_D10 PSSI_D10 DCMIPP_D10"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(114, "PH2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH2"),
+		STM32_FUNCTION(2, "LPTIM2_CH1"),
+		STM32_FUNCTION(3, "SPI7_RDY"),
+		STM32_FUNCTION(4, "SPDIFRX1_IN3"),
+		STM32_FUNCTION(5, "SAI1_SCK_B"),
+		STM32_FUNCTION(6, "I3C3_SDA"),
+		STM32_FUNCTION(8, "TIM16_CH1"),
+		STM32_FUNCTION(9, "I2C5_SDA"),
+		STM32_FUNCTION(10, "I2C3_SDA"),
+		STM32_FUNCTION(15, "ETH3_RGMII_GTX_CLK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(115, "PH3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH3"),
+		STM32_FUNCTION(3, "SPI1_NSS I2S1_WS"),
+		STM32_FUNCTION(7, "UART7_RX"),
+		STM32_FUNCTION(8, "TIM17_CH1N"),
+		STM32_FUNCTION(10, "TIM5_CH3"),
+		STM32_FUNCTION(11, "I2C7_SCL"),
+		STM32_FUNCTION(15, "ETH3_RGMII_TXD3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(116, "PH4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH4"),
+		STM32_FUNCTION(7, "UART7_TX"),
+		STM32_FUNCTION(8, "TIM17_BKIN"),
+		STM32_FUNCTION(10, "TIM5_CH2"),
+		STM32_FUNCTION(11, "LCD_R0"),
+		STM32_FUNCTION(12, "USB3DR_OVRCUR"),
+		STM32_FUNCTION(13, "USBH_HS_OVRCUR"),
+		STM32_FUNCTION(14, "ETH1_PTP_AUX_TS"),
+		STM32_FUNCTION(15, "ETH3_PPS_OUT"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(117, "PH5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH5"),
+		STM32_FUNCTION(5, "SAI2_FS_A"),
+		STM32_FUNCTION(7, "UART8_CTS"),
+		STM32_FUNCTION(8, "TIM2_CH1"),
+		STM32_FUNCTION(9, "UART7_RX"),
+		STM32_FUNCTION(11, "LCD_G1"),
+		STM32_FUNCTION(12, "USB3DR_VBUSEN"),
+		STM32_FUNCTION(13, "USBH_HS_VBUSEN"),
+		STM32_FUNCTION(14, "ETH2_PTP_AUX_TS"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(118, "PH6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH6"),
+		STM32_FUNCTION(2, "LPTIM2_IN2"),
+		STM32_FUNCTION(5, "SAI1_MCLK_B"),
+		STM32_FUNCTION(6, "I3C3_SCL"),
+		STM32_FUNCTION(8, "TIM16_CH1N"),
+		STM32_FUNCTION(9, "I2C5_SCL"),
+		STM32_FUNCTION(10, "I2C3_SCL"),
+		STM32_FUNCTION(11, "I2C1_SMBA"),
+		STM32_FUNCTION(15, "ETH3_RGMII_TXD2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(119, "PH7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH7"),
+		STM32_FUNCTION(3, "SPI1_MOSI I2S1_SDO"),
+		STM32_FUNCTION(5, "UART4_TX"),
+		STM32_FUNCTION(7, "UART7_RTS"),
+		STM32_FUNCTION(8, "TIM17_CH1"),
+		STM32_FUNCTION(10, "TIM5_CH4"),
+		STM32_FUNCTION(11, "I2C7_SDA"),
+		STM32_FUNCTION(15, "ETH3_RGMII_RXD2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(120, "PH8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH8"),
+		STM32_FUNCTION(3, "SPI1_MISO I2S1_SDI"),
+		STM32_FUNCTION(4, "SPDIFRX1_IN3"),
+		STM32_FUNCTION(5, "UART4_RX"),
+		STM32_FUNCTION(7, "UART7_CTS"),
+		STM32_FUNCTION(10, "TIM5_CH1"),
+		STM32_FUNCTION(11, "I2C3_SMBA"),
+		STM32_FUNCTION(12, "I2C5_SMBA"),
+		STM32_FUNCTION(15, "ETH3_RGMII_RXD3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(121, "PH9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH9"),
+		STM32_FUNCTION(4, "SPI6_NSS"),
+		STM32_FUNCTION(5, "SAI3_MCLK_A"),
+		STM32_FUNCTION(7, "USART6_RX"),
+		STM32_FUNCTION(8, "TIM15_CH1N"),
+		STM32_FUNCTION(11, "ETH1_RGMII_CLK125"),
+		STM32_FUNCTION(12, "ETH1_MII_RX_ER"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(122, "PH10"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH10"),
+		STM32_FUNCTION(3, "SPI1_SCK I2S1_CK"),
+		STM32_FUNCTION(4, "SPI6_MOSI"),
+		STM32_FUNCTION(5, "SAI3_SCK_A"),
+		STM32_FUNCTION(8, "TIM15_CH1"),
+		STM32_FUNCTION(10, "ETH2_MDC"),
+		STM32_FUNCTION(11, "ETH1_MII_TXD2 ETH1_RGMII_TXD2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(123, "PH11"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH11"),
+		STM32_FUNCTION(4, "SPI6_MISO"),
+		STM32_FUNCTION(5, "SAI3_FS_A"),
+		STM32_FUNCTION(8, "TIM15_CH2"),
+		STM32_FUNCTION(10, "ETH2_MDIO"),
+		STM32_FUNCTION(11, "ETH1_MII_TXD3 ETH1_RGMII_TXD3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(124, "PH12"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH12"),
+		STM32_FUNCTION(3, "SPI3_NSS I2S3_WS"),
+		STM32_FUNCTION(4, "SPI6_MISO"),
+		STM32_FUNCTION(9, "TIM10_CH1"),
+		STM32_FUNCTION(11, "ETH1_MII_RXD2 ETH1_RGMII_RXD2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(125, "PH13"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH13"),
+		STM32_FUNCTION(3, "SPI3_SCK I2S3_CK"),
+		STM32_FUNCTION(4, "SPI6_MOSI"),
+		STM32_FUNCTION(8, "TIM15_BKIN"),
+		STM32_FUNCTION(9, "TIM11_CH1"),
+		STM32_FUNCTION(11, "ETH1_MII_RXD3 ETH1_RGMII_RXD3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(128, "PI0"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI0"),
+		STM32_FUNCTION(1, "TRACED14"),
+		STM32_FUNCTION(2, "HDP6"),
+		STM32_FUNCTION(4, "LPTIM1_IN1"),
+		STM32_FUNCTION(5, "SAI4_MCLK_B"),
+		STM32_FUNCTION(7, "USART1_CK"),
+		STM32_FUNCTION(9, "TIM8_BKIN"),
+		STM32_FUNCTION(14, "LCD_B3"),
+		STM32_FUNCTION(15, "DCMI_D11 PSSI_D11 DCMIPP_D11"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(129, "PI1"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI1"),
+		STM32_FUNCTION(1, "TRACED15"),
+		STM32_FUNCTION(2, "HDP7"),
+		STM32_FUNCTION(3, "SPI7_NSS"),
+		STM32_FUNCTION(6, "MDF1_SDI6"),
+		STM32_FUNCTION(9, "TIM8_CH3N"),
+		STM32_FUNCTION(10, "I2C1_SDA"),
+		STM32_FUNCTION(11, "I3C1_SDA"),
+		STM32_FUNCTION(14, "LCD_B4"),
+		STM32_FUNCTION(15, "DCMI_D8 PSSI_D8 DCMIPP_D8"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(130, "PI2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI2"),
+		STM32_FUNCTION(4, "LPTIM1_ETR"),
+		STM32_FUNCTION(5, "SAI4_SCK_B"),
+		STM32_FUNCTION(7, "USART1_RTS"),
+		STM32_FUNCTION(9, "TIM8_CH1"),
+		STM32_FUNCTION(14, "LCD_B5"),
+		STM32_FUNCTION(15, "DCMI_D13 PSSI_D13 DCMIPP_D13"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(131, "PI3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI3"),
+		STM32_FUNCTION(4, "LPTIM1_IN2"),
+		STM32_FUNCTION(5, "SAI4_SD_B"),
+		STM32_FUNCTION(7, "USART1_CTS"),
+		STM32_FUNCTION(9, "TIM8_CH2"),
+		STM32_FUNCTION(14, "LCD_B6"),
+		STM32_FUNCTION(15, "PSSI_D14 DCMIPP_D14"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(132, "PI4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI4"),
+		STM32_FUNCTION(4, "LPTIM1_CH1"),
+		STM32_FUNCTION(5, "SAI4_FS_B"),
+		STM32_FUNCTION(9, "TIM8_CH3"),
+		STM32_FUNCTION(14, "LCD_B7"),
+		STM32_FUNCTION(15, "PSSI_D15 DCMIPP_D15"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(133, "PI5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI5"),
+		STM32_FUNCTION(3, "SPI5_MOSI"),
+		STM32_FUNCTION(4, "SPI1_MOSI I2S1_SDO"),
+		STM32_FUNCTION(6, "UART5_CTS"),
+		STM32_FUNCTION(7, "UART9_RX"),
+		STM32_FUNCTION(9, "TIM5_CH2"),
+		STM32_FUNCTION(14, "LCD_DE"),
+		STM32_FUNCTION(15, "DCMI_D1 PSSI_D1 DCMIPP_D1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(134, "PI6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI6"),
+		STM32_FUNCTION(2, "MCO1"),
+		STM32_FUNCTION(7, "USART3_TX"),
+		STM32_FUNCTION(8, "TIM2_ETR"),
+		STM32_FUNCTION(9, "TIM3_CH1"),
+		STM32_FUNCTION(14, "LCD_VSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(135, "PI7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI7"),
+		STM32_FUNCTION(7, "USART3_RX"),
+		STM32_FUNCTION(8, "TIM2_CH1"),
+		STM32_FUNCTION(9, "TIM3_CH2"),
+		STM32_FUNCTION(14, "LCD_HSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(136, "PI8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI8"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(137, "PI9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI9"),
+		STM32_FUNCTION(2, "SPI7_MOSI"),
+		STM32_FUNCTION(3, "SPI2_MOSI I2S2_SDO"),
+		STM32_FUNCTION(5, "FDCAN2_TX"),
+		STM32_FUNCTION(7, "UART9_CTS"),
+		STM32_FUNCTION(9, "TIM16_BKIN"),
+		STM32_FUNCTION(10, "SDVSEL2"),
+		STM32_FUNCTION(11, "FMC_NWAIT"),
+		STM32_FUNCTION(13, "DSI_TE"),
+		STM32_FUNCTION(14, "LCD_B0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(138, "PI10"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI10"),
+		STM32_FUNCTION(2, "SAI1_SCK_A"),
+		STM32_FUNCTION(3, "SPI1_SCK I2S1_CK"),
+		STM32_FUNCTION(4, "SPDIFRX1_IN0"),
+		STM32_FUNCTION(5, "FDCAN2_RX"),
+		STM32_FUNCTION(6, "MDF1_CCK0"),
+		STM32_FUNCTION(9, "TIM4_CH1"),
+		STM32_FUNCTION(10, "SDVSEL1"),
+		STM32_FUNCTION(13, "FMC_AD12 FMC_D12"),
+		STM32_FUNCTION(14, "DSI_TE"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(139, "PI11"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI11"),
+		STM32_FUNCTION(3, "I2S2_MCK"),
+		STM32_FUNCTION(6, "UART8_TX"),
+		STM32_FUNCTION(7, "UART9_RTS"),
+		STM32_FUNCTION(10, "TIM4_CH3"),
+		STM32_FUNCTION(11, "SDMMC3_D3"),
+		STM32_FUNCTION(12, "FMC_AD15 FMC_D15"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(140, "PI12"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOI12"),
+		STM32_FUNCTION(3, "SPI4_NSS"),
+		STM32_FUNCTION(8, "FDCAN3_RX"),
+		STM32_FUNCTION(9, "TIM11_CH1"),
+		STM32_FUNCTION(13, "FMC_A2"),
+		STM32_FUNCTION(14, "LCD_G0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(141, "PI13"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOI13"),
+		STM32_FUNCTION(3, "SPI4_MOSI"),
+		STM32_FUNCTION(5, "FDCAN2_RX"),
+		STM32_FUNCTION(9, "TIM10_CH1"),
+		STM32_FUNCTION(13, "FMC_A3"),
+		STM32_FUNCTION(14, "LCD_G1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(142, "PI14"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOI14"),
+		STM32_FUNCTION(3, "SPI2_NSS I2S2_WS"),
+		STM32_FUNCTION(6, "MDF1_SDI1"),
+		STM32_FUNCTION(8, "TIM20_CH3"),
+		STM32_FUNCTION(9, "TIM1_CH3N"),
+		STM32_FUNCTION(11, "FMC_NWAIT"),
+		STM32_FUNCTION(13, "FMC_AD10 FMC_D10"),
+		STM32_FUNCTION(14, "DCMI_D4 PSSI_D4 DCMIPP_D4"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(143, "PI15"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOI15"),
+		STM32_FUNCTION(3, "I2S2_MCK"),
+		STM32_FUNCTION(4, "UART4_RX"),
+		STM32_FUNCTION(6, "MDF1_CKI2"),
+		STM32_FUNCTION(8, "TIM20_BKIN2"),
+		STM32_FUNCTION(9, "TIM1_BKIN2"),
+		STM32_FUNCTION(10, "SDVSEL1"),
+		STM32_FUNCTION(11, "SDMMC3_CDIR"),
+		STM32_FUNCTION(14, "DCMI_D9 PSSI_D9 DCMIPP_D9"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(144, "PJ0"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ0"),
+		STM32_FUNCTION(3, "SPI5_MOSI"),
+		STM32_FUNCTION(5, "PCIE_CLKREQN"),
+		STM32_FUNCTION(6, "SAI4_D2"),
+		STM32_FUNCTION(7, "USART6_CTS"),
+		STM32_FUNCTION(10, "USBH_HS_VBUSEN"),
+		STM32_FUNCTION(12, "ETH2_PTP_AUX_TS"),
+		STM32_FUNCTION(13, "FMC_A11"),
+		STM32_FUNCTION(14, "ETH3_PPS_OUT"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(145, "PJ1"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ1"),
+		STM32_FUNCTION(7, "USART6_RX"),
+		STM32_FUNCTION(9, "TIM8_CH1N"),
+		STM32_FUNCTION(10, "I2C1_SCL"),
+		STM32_FUNCTION(11, "I3C1_SCL"),
+		STM32_FUNCTION(13, "FMC_A7"),
+		STM32_FUNCTION(15, "DCMI_VSYNC PSSI_RDY DCMIPP_VSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(146, "PJ2"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ2"),
+		STM32_FUNCTION(5, "SAI2_SD_B"),
+		STM32_FUNCTION(7, "UART9_RTS"),
+		STM32_FUNCTION(9, "TIM8_CH4N"),
+		STM32_FUNCTION(10, "USBH_HS_OVRCUR"),
+		STM32_FUNCTION(13, "FMC_A14"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(147, "PJ3"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ3"),
+		STM32_FUNCTION(3, "SPI5_NSS"),
+		STM32_FUNCTION(4, "SAI2_FS_A"),
+		STM32_FUNCTION(6, "SAI4_D1"),
+		STM32_FUNCTION(7, "USART6_RTS"),
+		STM32_FUNCTION(9, "TIM8_CH3"),
+		STM32_FUNCTION(13, "FMC_A10"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(148, "PJ4"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ4"),
+		STM32_FUNCTION(4, "SAI2_FS_B"),
+		STM32_FUNCTION(6, "MDF1_CCK1"),
+		STM32_FUNCTION(7, "USART6_CK"),
+		STM32_FUNCTION(9, "TIM8_CH4"),
+		STM32_FUNCTION(10, "I2C2_SMBA"),
+		STM32_FUNCTION(11, "I2C5_SMBA"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(149, "PJ5"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ5"),
+		STM32_FUNCTION(3, "SPI5_MISO"),
+		STM32_FUNCTION(4, "SAI2_SCK_B"),
+		STM32_FUNCTION(6, "SAI4_CK1"),
+		STM32_FUNCTION(7, "USART6_TX"),
+		STM32_FUNCTION(9, "TIM8_CH1"),
+		STM32_FUNCTION(13, "FMC_A8"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(150, "PJ6"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ6"),
+		STM32_FUNCTION(3, "SPI7_MOSI"),
+		STM32_FUNCTION(5, "SAI4_SD_A"),
+		STM32_FUNCTION(7, "USART2_CK"),
+		STM32_FUNCTION(8, "TIM20_CH1N"),
+		STM32_FUNCTION(9, "TIM1_CH1"),
+		STM32_FUNCTION(10, "I2C6_SMBA"),
+		STM32_FUNCTION(14, "DCMI_D7 PSSI_D7 DCMIPP_D7"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(151, "PJ7"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ7"),
+		STM32_FUNCTION(3, "SPI5_MISO"),
+		STM32_FUNCTION(5, "SAI2_MCLK_B"),
+		STM32_FUNCTION(6, "SAI4_D3"),
+		STM32_FUNCTION(7, "USART6_CK"),
+		STM32_FUNCTION(9, "TIM8_CH2N"),
+		STM32_FUNCTION(10, "I2C1_SMBA"),
+		STM32_FUNCTION(13, "FMC_A12"),
+		STM32_FUNCTION(15, "DCMI_D0 PSSI_D0 DCMIPP_D0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(152, "PJ8"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ8"),
+		STM32_FUNCTION(3, "SPI5_SCK"),
+		STM32_FUNCTION(6, "SAI4_CK2"),
+		STM32_FUNCTION(7, "USART6_RX"),
+		STM32_FUNCTION(9, "TIM8_CH2"),
+		STM32_FUNCTION(13, "FMC_A9"),
+		STM32_FUNCTION(15, "PSSI_D14 DCMIPP_D14"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(153, "PJ9"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ9"),
+		STM32_FUNCTION(3, "SPI4_RDY"),
+		STM32_FUNCTION(8, "TIM12_CH1"),
+		STM32_FUNCTION(9, "TIM8_BKIN"),
+		STM32_FUNCTION(13, "FMC_A5"),
+		STM32_FUNCTION(15, "DCMI_PIXCLK PSSI_PDCK DCMIPP_PIXCLK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(154, "PJ10"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ10"),
+		STM32_FUNCTION(8, "TIM12_CH2"),
+		STM32_FUNCTION(9, "TIM8_ETR"),
+		STM32_FUNCTION(10, "I2C1_SDA"),
+		STM32_FUNCTION(11, "I3C1_SDA"),
+		STM32_FUNCTION(13, "FMC_A6"),
+		STM32_FUNCTION(15, "DCMI_HSYNC PSSI_DE DCMIPP_HSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(155, "PJ11"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ11"),
+		STM32_FUNCTION(3, "SPI5_RDY"),
+		STM32_FUNCTION(4, "SAI2_SCK_A"),
+		STM32_FUNCTION(6, "SAI4_D4"),
+		STM32_FUNCTION(7, "UART9_CTS"),
+		STM32_FUNCTION(9, "TIM8_CH3N"),
+		STM32_FUNCTION(13, "FMC_A13"),
+		STM32_FUNCTION(15, "DCMI_D12 PSSI_D12 DCMIPP_D12"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(156, "PJ12"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ12"),
+		STM32_FUNCTION(4, "SAI2_SD_A"),
+		STM32_FUNCTION(7, "UART9_RX"),
+		STM32_FUNCTION(8, "FDCAN1_TX"),
+		STM32_FUNCTION(9, "TIM8_BKIN2"),
+		STM32_FUNCTION(10, "I2C2_SCL"),
+		STM32_FUNCTION(11, "I3C2_SCL"),
+		STM32_FUNCTION(13, "FMC_A15"),
+		STM32_FUNCTION(15, "DCMI_D13 PSSI_D13 DCMIPP_D13"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(157, "PJ13"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ13"),
+		STM32_FUNCTION(4, "SAI2_MCLK_A"),
+		STM32_FUNCTION(7, "UART9_TX"),
+		STM32_FUNCTION(8, "FDCAN1_RX"),
+		STM32_FUNCTION(9, "TIM10_CH1"),
+		STM32_FUNCTION(10, "I2C2_SDA"),
+		STM32_FUNCTION(11, "I3C2_SDA"),
+		STM32_FUNCTION(15, "PSSI_D15 DCMIPP_D15"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(158, "PJ14"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ14"),
+		STM32_FUNCTION(3, "SPI4_SCK"),
+		STM32_FUNCTION(8, "FDCAN3_TX"),
+		STM32_FUNCTION(13, "FMC_A1"),
+		STM32_FUNCTION(14, "LCD_R0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(159, "PJ15"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ15"),
+		STM32_FUNCTION(1, "TRACED7"),
+		STM32_FUNCTION(2, "HDP7"),
+		STM32_FUNCTION(3, "SPI4_MISO"),
+		STM32_FUNCTION(5, "FDCAN2_TX"),
+		STM32_FUNCTION(9, "TIM11_CH1"),
+		STM32_FUNCTION(13, "FMC_A4"),
+		STM32_FUNCTION(14, "LCD_R1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(160, "PK0"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOK0"),
+		STM32_FUNCTION(3, "SPI2_MISO I2S2_SDI"),
+		STM32_FUNCTION(4, "SPDIFRX1_IN2"),
+		STM32_FUNCTION(6, "MDF1_CCK0"),
+		STM32_FUNCTION(8, "TIM20_ETR"),
+		STM32_FUNCTION(9, "TIM1_ETR"),
+		STM32_FUNCTION(11, "SDMMC3_D123DIR"),
+		STM32_FUNCTION(13, "FMC_AD11 FMC_D11"),
+		STM32_FUNCTION(14, "DCMI_D11 PSSI_D11 DCMIPP_D11"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(161, "PK1"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOK1"),
+		STM32_FUNCTION(3, "SPI2_MOSI I2S2_SDO"),
+		STM32_FUNCTION(6, "MDF1_SDI2"),
+		STM32_FUNCTION(8, "TIM20_BKIN"),
+		STM32_FUNCTION(9, "TIM1_BKIN"),
+		STM32_FUNCTION(10, "SDVSEL2"),
+		STM32_FUNCTION(11, "SDMMC3_D0DIR"),
+		STM32_FUNCTION(13, "FMC_AD13 FMC_D13"),
+		STM32_FUNCTION(14, "DCMI_D10 PSSI_D10 DCMIPP_D10"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(162, "PK2"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOK2"),
+		STM32_FUNCTION(3, "SPI7_NSS"),
+		STM32_FUNCTION(5, "SAI4_SCK_A"),
+		STM32_FUNCTION(7, "USART1_RTS"),
+		STM32_FUNCTION(8, "TIM20_CH2"),
+		STM32_FUNCTION(9, "TIM1_CH2N"),
+		STM32_FUNCTION(10, "I2C6_SDA"),
+		STM32_FUNCTION(13, "FMC_NCE3"),
+		STM32_FUNCTION(14, "DCMI_D6 PSSI_D6 DCMIPP_D6"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(163, "PK3"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOK3"),
+		STM32_FUNCTION(3, "SPI7_RDY"),
+		STM32_FUNCTION(6, "MDF1_CKI1"),
+		STM32_FUNCTION(8, "TIM20_CH3N"),
+		STM32_FUNCTION(9, "TIM1_CH3"),
+		STM32_FUNCTION(13, "FMC_AD8 FMC_D8"),
+		STM32_FUNCTION(14, "DCMI_D3 PSSI_D3 DCMIPP_D3"),
+		STM32_FUNCTION(15, "FMC_NCE4"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(164, "PK4"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOK4"),
+		STM32_FUNCTION(3, "SPI7_MISO"),
+		STM32_FUNCTION(4, "UART4_TX"),
+		STM32_FUNCTION(5, "SAI4_FS_A"),
+		STM32_FUNCTION(8, "TIM20_CH1"),
+		STM32_FUNCTION(9, "TIM1_CH1N"),
+		STM32_FUNCTION(11, "SDMMC3_CKIN"),
+		STM32_FUNCTION(13, "FMC_AD9 FMC_D9"),
+		STM32_FUNCTION(14, "DCMI_D8 PSSI_D8 DCMIPP_D8"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(165, "PK5"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOK5"),
+		STM32_FUNCTION(3, "SPI2_RDY"),
+		STM32_FUNCTION(6, "MDF1_CKI0"),
+		STM32_FUNCTION(7, "USART1_TX"),
+		STM32_FUNCTION(8, "TIM20_CH4N"),
+		STM32_FUNCTION(9, "TIM1_CH4"),
+		STM32_FUNCTION(11, "I2C5_SCL"),
+		STM32_FUNCTION(13, "FMC_AD5 FMC_D5"),
+		STM32_FUNCTION(14, "DCMI_D1 PSSI_D1 DCMIPP_D1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(166, "PK6"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOK6"),
+		STM32_FUNCTION(3, "SPI7_SCK"),
+		STM32_FUNCTION(5, "SAI4_MCLK_A"),
+		STM32_FUNCTION(7, "USART1_CTS"),
+		STM32_FUNCTION(8, "TIM20_CH2N"),
+		STM32_FUNCTION(9, "TIM1_CH2"),
+		STM32_FUNCTION(10, "I2C6_SCL"),
+		STM32_FUNCTION(12, "FMC_AD14 FMC_D14"),
+		STM32_FUNCTION(13, "FMC_AD7 FMC_D7"),
+		STM32_FUNCTION(14, "DCMI_D5 PSSI_D5 DCMIPP_D5"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(167, "PK7"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOK7"),
+		STM32_FUNCTION(6, "MDF1_SDI0"),
+		STM32_FUNCTION(7, "USART1_RX"),
+		STM32_FUNCTION(8, "TIM20_CH4"),
+		STM32_FUNCTION(9, "TIM1_CH4N"),
+		STM32_FUNCTION(11, "I2C5_SDA"),
+		STM32_FUNCTION(12, "FMC_NCE4"),
+		STM32_FUNCTION(13, "FMC_AD6 FMC_D6"),
+		STM32_FUNCTION(14, "DCMI_D2 PSSI_D2 DCMIPP_D2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+};
+
+static const struct stm32_desc_pin stm32mp257_z_pins[] = {
+	STM32_PIN_PKG(
+		PINCTRL_PIN(400, "PZ0"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ0"),
+		STM32_FUNCTION(3, "LPTIM3_IN1"),
+		STM32_FUNCTION(4, "SPI8_MOSI"),
+		STM32_FUNCTION(5, "TIM8_CH1"),
+		STM32_FUNCTION(7, "LPUART1_TX"),
+		STM32_FUNCTION(8, "LPTIM5_OUT"),
+		STM32_FUNCTION(9, "I2C8_SDA"),
+		STM32_FUNCTION(11, "LPTIM3_CH2"),
+		STM32_FUNCTION(12, "I3C4_SDA"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(401, "PZ1"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ1"),
+		STM32_FUNCTION(3, "LPTIM3_CH1"),
+		STM32_FUNCTION(4, "SPI8_MISO"),
+		STM32_FUNCTION(5, "TIM8_CH2"),
+		STM32_FUNCTION(7, "LPUART1_RX"),
+		STM32_FUNCTION(8, "LPTIM5_ETR"),
+		STM32_FUNCTION(9, "I2C8_SCL"),
+		STM32_FUNCTION(10, "I2C8_SMBA"),
+		STM32_FUNCTION(12, "I3C4_SCL"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(402, "PZ2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ2"),
+		STM32_FUNCTION(3, "LPTIM3_CH1"),
+		STM32_FUNCTION(4, "SPI8_SCK"),
+		STM32_FUNCTION(6, "ADF1_CCK0"),
+		STM32_FUNCTION(7, "LPUART1_RTS"),
+		STM32_FUNCTION(8, "LPTIM4_ETR"),
+		STM32_FUNCTION(9, "I2C8_SCL"),
+		STM32_FUNCTION(12, "I3C4_SCL"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(403, "PZ3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ3"),
+		STM32_FUNCTION(1, "DBTRGI"),
+		STM32_FUNCTION(2, "DBTRGO"),
+		STM32_FUNCTION(3, "LPTIM3_ETR"),
+		STM32_FUNCTION(4, "SPI8_NSS"),
+		STM32_FUNCTION(5, "MDF1_SDI5"),
+		STM32_FUNCTION(6, "ADF1_SDI0"),
+		STM32_FUNCTION(7, "LPUART1_CTS"),
+		STM32_FUNCTION(8, "LPTIM4_IN1"),
+		STM32_FUNCTION(9, "I2C8_SDA"),
+		STM32_FUNCTION(11, "LPTIM4_CH2"),
+		STM32_FUNCTION(12, "I3C4_SDA"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(404, "PZ4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ4"),
+		STM32_FUNCTION(1, "DBTRGI"),
+		STM32_FUNCTION(2, "DBTRGO"),
+		STM32_FUNCTION(3, "MCO2"),
+		STM32_FUNCTION(4, "SPI8_RDY"),
+		STM32_FUNCTION(5, "MDF1_CCK1"),
+		STM32_FUNCTION(6, "ADF1_CCK1"),
+		STM32_FUNCTION(7, "LPUART1_RX"),
+		STM32_FUNCTION(8, "LPTIM4_CH1"),
+		STM32_FUNCTION(9, "I2C8_SCL"),
+		STM32_FUNCTION(12, "I3C4_SCL"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(405, "PZ5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ5"),
+		STM32_FUNCTION(2, "MCO1"),
+		STM32_FUNCTION(3, "LPTIM3_ETR"),
+		STM32_FUNCTION(4, "SPI8_SCK"),
+		STM32_FUNCTION(6, "ADF1_CCK0"),
+		STM32_FUNCTION(7, "LPUART1_RTS"),
+		STM32_FUNCTION(8, "LPTIM5_IN1"),
+		STM32_FUNCTION(11, "LPTIM4_CH2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(406, "PZ6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ6"),
+		STM32_FUNCTION(1, "DBTRGI"),
+		STM32_FUNCTION(2, "DBTRGO"),
+		STM32_FUNCTION(4, "SPI8_NSS"),
+		STM32_FUNCTION(5, "TIM8_CH3"),
+		STM32_FUNCTION(6, "ADF1_SDI0"),
+		STM32_FUNCTION(7, "LPUART1_CTS"),
+		STM32_FUNCTION(8, "LPTIM5_OUT"),
+		STM32_FUNCTION(11, "LPTIM4_CH2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(407, "PZ7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ7"),
+		STM32_FUNCTION(4, "SPI8_MOSI"),
+		STM32_FUNCTION(5, "MDF1_CCK1"),
+		STM32_FUNCTION(6, "ADF1_CCK1"),
+		STM32_FUNCTION(7, "LPUART1_TX"),
+		STM32_FUNCTION(8, "LPTIM5_IN1"),
+		STM32_FUNCTION(11, "LPTIM3_CH2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(408, "PZ8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ8"),
+		STM32_FUNCTION(3, "LPTIM3_IN1"),
+		STM32_FUNCTION(4, "SPI8_MISO"),
+		STM32_FUNCTION(5, "MDF1_SDI5"),
+		STM32_FUNCTION(6, "ADF1_SDI0"),
+		STM32_FUNCTION(7, "LPUART1_RX"),
+		STM32_FUNCTION(8, "LPTIM4_CH1"),
+		STM32_FUNCTION(9, "I2C8_SMBA"),
+		STM32_FUNCTION(10, "LPTIM5_ETR"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(409, "PZ9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ9"),
+		STM32_FUNCTION(2, "MCO2"),
+		STM32_FUNCTION(4, "SPI8_RDY"),
+		STM32_FUNCTION(5, "MDF1_CKI5"),
+		STM32_FUNCTION(7, "LPUART1_TX"),
+		STM32_FUNCTION(8, "LPTIM4_ETR"),
+		STM32_FUNCTION(9, "I2C8_SDA"),
+		STM32_FUNCTION(11, "LPTIM3_CH2"),
+		STM32_FUNCTION(12, "I3C4_SDA"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+};
+
+static struct stm32_pinctrl_match_data stm32mp257_match_data = {
+	.pins = stm32mp257_pins,
+	.npins = ARRAY_SIZE(stm32mp257_pins),
+	.io_sync_control = true,
+};
+
+static struct stm32_pinctrl_match_data stm32mp257_z_match_data = {
+	.pins = stm32mp257_z_pins,
+	.npins = ARRAY_SIZE(stm32mp257_z_pins),
+	.io_sync_control = true,
+};
+
+static const struct of_device_id stm32mp257_pctrl_match[] = {
+	{
+		.compatible = "st,stm32mp257-pinctrl",
+		.data = &stm32mp257_match_data,
+	},
+	{
+		.compatible = "st,stm32mp257-z-pinctrl",
+		.data = &stm32mp257_z_match_data,
+	},
+	{ }
+};
+
+static const struct dev_pm_ops stm32_pinctrl_dev_pm_ops = {
+	 SET_LATE_SYSTEM_SLEEP_PM_OPS(NULL, stm32_pinctrl_resume)
+};
+
+static struct platform_driver stm32mp257_pinctrl_driver = {
+	.probe = stm32_pctl_probe,
+	.driver = {
+		.name = "stm32mp257-pinctrl",
+		.of_match_table = stm32mp257_pctrl_match,
+		.pm = &stm32_pinctrl_dev_pm_ops,
+	},
+};
+
+static int __init stm32mp257_pinctrl_init(void)
+{
+	return platform_driver_register(&stm32mp257_pinctrl_driver);
+}
+arch_initcall(stm32mp257_pinctrl_init);
diff --git a/drivers/ptp/ptp_chardev.c b/drivers/ptp/ptp_chardev.c
index af3bc65c4..a0abd0b3c 100644
--- a/drivers/ptp/ptp_chardev.c
+++ b/drivers/ptp/ptp_chardev.c
@@ -111,6 +111,8 @@ long ptp_ioctl(struct posix_clock *pc, unsigned int cmd, unsigned long arg)
 	struct ptp_clock *ptp = container_of(pc, struct ptp_clock, clock);
 	struct ptp_sys_offset_extended *extoff = NULL;
 	struct ptp_sys_offset_precise precise_offset;
+	struct ptp_ptp_offset_precise ptp_precise_offset;
+	struct device_device_crosststamp devxtstamp;
 	struct system_device_crosststamp xtstamp;
 	struct ptp_clock_info *ops = ptp->info;
 	struct ptp_sys_offset *sysoff = NULL;
@@ -137,6 +139,7 @@ long ptp_ioctl(struct posix_clock *pc, unsigned int cmd, unsigned long arg)
 		caps.n_pins = ptp->info->n_pins;
 		caps.cross_timestamping = ptp->info->getcrosststamp != NULL;
 		caps.adjust_phase = ptp->info->adjphase != NULL;
+		caps.peer_cross_timestamping = (ptp->info->getphcxtstamp != NULL) && (ptp->peer);
 		if (copy_to_user((void __user *)arg, &caps, sizeof(caps)))
 			err = -EFAULT;
 		break;
@@ -321,6 +324,26 @@ long ptp_ioctl(struct posix_clock *pc, unsigned int cmd, unsigned long arg)
 			err = -EFAULT;
 		break;
 
+	case PTP_PTP_OFFSET_PRECISE:
+		if ((!ptp->info->getphcxtstamp) || (!ptp->peer)) {
+			err = -EOPNOTSUPP;
+			break;
+		}
+		err = ptp->info->getphcxtstamp(ptp->info, ptp->peer->info,
+									   &devxtstamp);
+		if (err)
+			break;
+		ts = ktime_to_timespec64(devxtstamp.device);
+		ptp_precise_offset.device.sec = ts.tv_sec;
+		ptp_precise_offset.device.nsec = ts.tv_nsec;
+		ts = ktime_to_timespec64(devxtstamp.peer_device);
+		ptp_precise_offset.peer.sec = ts.tv_sec;
+		ptp_precise_offset.peer.nsec = ts.tv_nsec;
+		if (copy_to_user((void __user *)arg, &ptp_precise_offset,
+			sizeof(ptp_precise_offset)))
+			err = -EFAULT;
+		break;
+
 	case PTP_SYS_OFFSET:
 	case PTP_SYS_OFFSET2:
 		sysoff = memdup_user((void __user *)arg, sizeof(*sysoff));
diff --git a/drivers/ptp/ptp_clock.c b/drivers/ptp/ptp_clock.c
index 8a652a367..048479707 100644
--- a/drivers/ptp/ptp_clock.c
+++ b/drivers/ptp/ptp_clock.c
@@ -217,6 +217,7 @@ struct ptp_clock *ptp_clock_register(struct ptp_clock_info *info,
 
 	ptp->clock.ops = ptp_clock_ops;
 	ptp->info = info;
+	ptp->peer = NULL;
 	ptp->devid = MKDEV(major, index);
 	ptp->index = index;
 	spin_lock_init(&ptp->tsevq.lock);
@@ -325,6 +326,25 @@ static int unregister_vclock(struct device *dev, void *data)
 	return 0;
 }
 
+int ptp_clock_set_peer(struct ptp_clock *ptp, struct ptp_clock *peer)
+{
+	/* remove existing peer assignments */
+	if (ptp && ptp->peer)
+		ptp->peer->peer = NULL;
+	if (peer && peer->peer)
+		peer->peer->peer = NULL;
+
+	/* pair up the two clocks */
+	if (ptp)
+		ptp->peer = peer;
+	if (peer)
+		peer->peer = ptp;
+
+	return 0;
+}
+
+EXPORT_SYMBOL(ptp_clock_set_peer);
+
 int ptp_clock_unregister(struct ptp_clock *ptp)
 {
 	if (ptp_vclock_in_use(ptp)) {
diff --git a/drivers/ptp/ptp_private.h b/drivers/ptp/ptp_private.h
index dba6be477..3db06edf8 100644
--- a/drivers/ptp/ptp_private.h
+++ b/drivers/ptp/ptp_private.h
@@ -27,10 +27,13 @@ struct timestamp_event_queue {
 	spinlock_t lock;
 };
 
+struct ptp_clock;
+
 struct ptp_clock {
 	struct posix_clock clock;
 	struct device dev;
 	struct ptp_clock_info *info;
+	struct ptp_clock *peer;
 	dev_t devid;
 	int index; /* index into clocks.map */
 	struct pps_device *pps_source;
diff --git a/drivers/pwm/pwm-stm32-lp.c b/drivers/pwm/pwm-stm32-lp.c
index 3115abb3f..28dd7a197 100644
--- a/drivers/pwm/pwm-stm32-lp.c
+++ b/drivers/pwm/pwm-stm32-lp.c
@@ -21,6 +21,7 @@ struct stm32_pwm_lp {
 	struct pwm_chip chip;
 	struct clk *clk;
 	struct regmap *regmap;
+	unsigned int num_cc_chans;
 };
 
 static inline struct stm32_pwm_lp *to_stm32_pwm_lp(struct pwm_chip *chip)
@@ -31,13 +32,101 @@ static inline struct stm32_pwm_lp *to_stm32_pwm_lp(struct pwm_chip *chip)
 /* STM32 Low-Power Timer is preceded by a configurable power-of-2 prescaler */
 #define STM32_LPTIM_MAX_PRESCALER	128
 
+static int stm32_pwm_lp_update_allowed(struct stm32_pwm_lp *priv, int channel)
+{
+	int ret;
+	u32 ccmr1;
+	unsigned long ccmr;
+
+	/* Only one PWM on this LPTIMER: enable, prescaler and reload value can be changed */
+	if (!priv->num_cc_chans)
+		return true;
+
+	ret = regmap_read(priv->regmap, STM32MP25_LPTIM_CCMR1, &ccmr1);
+	if (ret)
+		return ret;
+	ccmr = ccmr1 & (STM32MP25_LPTIM_CC1E | STM32MP25_LPTIM_CC2E);
+
+	/* More than one channel enabled: enable, prescaler or ARR value can't be changed */
+	if (bitmap_weight(&ccmr, sizeof(u32) * BITS_PER_BYTE) > 1)
+		return false;
+
+	/*
+	 * Only one channel is enabled (or none): check status on the other channel, to
+	 * report if enable, prescaler or ARR value can be changed.
+	 */
+	if (channel)
+		return !(ccmr1 & STM32MP25_LPTIM_CC1E);
+	else
+		return !(ccmr1 & STM32MP25_LPTIM_CC2E);
+}
+
+static int stm32_pwm_lp_compare_channel_apply(struct stm32_pwm_lp *priv, int channel,
+					      bool enable, enum pwm_polarity polarity)
+{
+	u32 ccmr1, val, mask;
+	bool reenable;
+	int ret;
+
+	/* No dedicated CC channel: nothing to do */
+	if (!priv->num_cc_chans)
+		return 0;
+
+	ret = regmap_read(priv->regmap, STM32MP25_LPTIM_CCMR1, &ccmr1);
+	if (ret)
+		return ret;
+
+	if (channel) {
+		/* Must disable CC channel (CCxE) to modify polarity (CCxP), then reenable */
+		reenable = (enable && FIELD_GET(STM32MP25_LPTIM_CC2E, ccmr1)) &&
+			(polarity != FIELD_GET(STM32MP25_LPTIM_CC2P, ccmr1));
+
+		mask = STM32MP25_LPTIM_CC2SEL | STM32MP25_LPTIM_CC2E | STM32MP25_LPTIM_CC2P;
+		val = FIELD_PREP(STM32MP25_LPTIM_CC2P, polarity);
+		val |= FIELD_PREP(STM32MP25_LPTIM_CC2E, enable);
+	} else {
+		reenable = (enable && FIELD_GET(STM32MP25_LPTIM_CC1E, ccmr1)) &&
+			(polarity != FIELD_GET(STM32MP25_LPTIM_CC1P, ccmr1));
+
+		mask = STM32MP25_LPTIM_CC1SEL | STM32MP25_LPTIM_CC1E | STM32MP25_LPTIM_CC1P;
+		val = FIELD_PREP(STM32MP25_LPTIM_CC1P, polarity);
+		val |= FIELD_PREP(STM32MP25_LPTIM_CC1E, enable);
+	}
+
+	if (reenable) {
+		u32 cfgr, presc;
+		unsigned long rate;
+		unsigned int delay_us;
+
+		ret = regmap_update_bits(priv->regmap, STM32MP25_LPTIM_CCMR1,
+					 channel ? STM32MP25_LPTIM_CC2E : STM32MP25_LPTIM_CC1E, 0);
+		if (ret)
+			return ret;
+		/*
+		 * After a write to the LPTIM_CCMRx register, a new write operation can only be
+		 * performed after a delay of at least (PRESC × 3) clock cycles
+		 */
+		ret = regmap_read(priv->regmap, STM32_LPTIM_CFGR, &cfgr);
+		if (ret)
+			return ret;
+		presc = FIELD_GET(STM32_LPTIM_PRESC, cfgr);
+		rate = clk_get_rate(priv->clk) >> presc;
+		if (!rate)
+			return -EINVAL;
+		delay_us = 3 * DIV_ROUND_UP(USEC_PER_SEC, rate);
+		usleep_range(delay_us, delay_us * 2);
+	}
+
+	return regmap_update_bits(priv->regmap, STM32MP25_LPTIM_CCMR1, mask, val);
+}
+
 static int stm32_pwm_lp_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 			      const struct pwm_state *state)
 {
 	struct stm32_pwm_lp *priv = to_stm32_pwm_lp(chip);
 	unsigned long long prd, div, dty;
 	struct pwm_state cstate;
-	u32 val, mask, cfgr, presc = 0;
+	u32 arr, val, mask, cfgr, presc = 0;
 	bool reenable;
 	int ret;
 
@@ -46,10 +135,28 @@ static int stm32_pwm_lp_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 
 	if (!state->enabled) {
 		if (cstate.enabled) {
-			/* Disable LP timer */
-			ret = regmap_write(priv->regmap, STM32_LPTIM_CR, 0);
+			/* Disable CC channel if any */
+			ret = stm32_pwm_lp_compare_channel_apply(priv, pwm->hwpwm, false,
+								 state->polarity);
 			if (ret)
 				return ret;
+			ret = regmap_write(priv->regmap, pwm->hwpwm ?
+					   STM32MP25_LPTIM_CCR2 : STM32_LPTIM_CMP, 0);
+			if (ret)
+				return ret;
+
+			/* Check if the timer can be disabled */
+			ret = stm32_pwm_lp_update_allowed(priv, pwm->hwpwm);
+			if (ret < 0)
+				return ret;
+
+			if (ret) {
+				/* Disable LP timer */
+				ret = regmap_write(priv->regmap, STM32_LPTIM_CR, 0);
+				if (ret)
+					return ret;
+			}
+
 			/* disable clock to PWM counter */
 			clk_disable(priv->clk);
 		}
@@ -58,7 +165,7 @@ static int stm32_pwm_lp_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 
 	/* Calculate the period and prescaler value */
 	div = (unsigned long long)clk_get_rate(priv->clk) * state->period;
-	do_div(div, NSEC_PER_SEC);
+	div = DIV_ROUND_CLOSEST_ULL(div, NSEC_PER_SEC);
 	if (!div) {
 		/* Clock is too slow to achieve requested period. */
 		dev_dbg(priv->chip.dev, "Can't reach %llu ns\n", state->period);
@@ -78,7 +185,24 @@ static int stm32_pwm_lp_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 
 	/* Calculate the duty cycle */
 	dty = prd * state->duty_cycle;
-	do_div(dty, state->period);
+	dty = DIV_ROUND_CLOSEST_ULL(dty, state->period);
+
+	ret = regmap_read(priv->regmap, STM32_LPTIM_CFGR, &cfgr);
+	if (ret)
+		return ret;
+
+	/*
+	 * When there are several channels, they share the same prescaler and reload value.
+	 * Check if this can be changed, or the values are the same for all channels.
+	 */
+	if (!stm32_pwm_lp_update_allowed(priv, pwm->hwpwm)) {
+		ret = regmap_read(priv->regmap, STM32_LPTIM_ARR, &arr);
+		if (ret)
+			return ret;
+
+		if ((FIELD_GET(STM32_LPTIM_PRESC, cfgr) != presc) || (arr != prd - 1))
+			return -EBUSY;
+	}
 
 	if (!cstate.enabled) {
 		/* enable clock to drive PWM counter */
@@ -87,15 +211,20 @@ static int stm32_pwm_lp_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 			return ret;
 	}
 
-	ret = regmap_read(priv->regmap, STM32_LPTIM_CFGR, &cfgr);
-	if (ret)
-		goto err;
-
 	if ((FIELD_GET(STM32_LPTIM_PRESC, cfgr) != presc) ||
-	    (FIELD_GET(STM32_LPTIM_WAVPOL, cfgr) != state->polarity)) {
+	    ((FIELD_GET(STM32_LPTIM_WAVPOL, cfgr) != state->polarity) && !priv->num_cc_chans)) {
 		val = FIELD_PREP(STM32_LPTIM_PRESC, presc);
-		val |= FIELD_PREP(STM32_LPTIM_WAVPOL, state->polarity);
-		mask = STM32_LPTIM_PRESC | STM32_LPTIM_WAVPOL;
+		mask = STM32_LPTIM_PRESC;
+
+		if (!priv->num_cc_chans) {
+			/*
+			 * WAVPOL bit is only available when no capature compare channel is used,
+			 * e.g. on LPTIMER instances that have only one output channel. CCMR1 is
+			 * used otherwise.
+			 */
+			val |= FIELD_PREP(STM32_LPTIM_WAVPOL, state->polarity);
+			mask |= STM32_LPTIM_WAVPOL;
+		}
 
 		/* Must disable LP timer to modify CFGR */
 		reenable = true;
@@ -121,20 +250,27 @@ static int stm32_pwm_lp_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 	if (ret)
 		goto err;
 
-	ret = regmap_write(priv->regmap, STM32_LPTIM_CMP, prd - (1 + dty));
+	/* Write CMP/CCRx register and ensure it's been properly written */
+	ret = regmap_write(priv->regmap, pwm->hwpwm ? STM32MP25_LPTIM_CCR2 : STM32_LPTIM_CMP,
+			   prd - (1 + dty));
 	if (ret)
 		goto err;
 
-	/* ensure CMP & ARR registers are properly written */
-	ret = regmap_read_poll_timeout(priv->regmap, STM32_LPTIM_ISR, val,
-				       (val & STM32_LPTIM_CMPOK_ARROK),
+	/* ensure ARR and CMP/CCRx registers are properly written */
+	ret = regmap_read_poll_timeout(priv->regmap, STM32_LPTIM_ISR, val, pwm->hwpwm ?
+				       (val & STM32_LPTIM_CMP2_ARROK) == STM32_LPTIM_CMP2_ARROK :
+				       (val & STM32_LPTIM_CMPOK_ARROK) == STM32_LPTIM_CMPOK_ARROK,
 				       100, 1000);
 	if (ret) {
 		dev_err(priv->chip.dev, "ARR/CMP registers write issue\n");
 		goto err;
 	}
-	ret = regmap_write(priv->regmap, STM32_LPTIM_ICR,
-			   STM32_LPTIM_CMPOKCF_ARROKCF);
+	ret = regmap_write(priv->regmap, STM32_LPTIM_ICR, pwm->hwpwm ?
+			   STM32_LPTIM_CMP2OKCF_ARROKCF : STM32_LPTIM_CMPOKCF_ARROKCF);
+	if (ret)
+		goto err;
+
+	ret = stm32_pwm_lp_compare_channel_apply(priv, pwm->hwpwm, true, state->polarity);
 	if (ret)
 		goto err;
 
@@ -163,25 +299,43 @@ static void stm32_pwm_lp_get_state(struct pwm_chip *chip,
 {
 	struct stm32_pwm_lp *priv = to_stm32_pwm_lp(chip);
 	unsigned long rate = clk_get_rate(priv->clk);
-	u32 val, presc, prd;
+	u32 val, presc, prd, ccmr1;
+	bool enabled;
 	u64 tmp;
 
 	regmap_read(priv->regmap, STM32_LPTIM_CR, &val);
-	state->enabled = !!FIELD_GET(STM32_LPTIM_ENABLE, val);
+	enabled = !!FIELD_GET(STM32_LPTIM_ENABLE, val);
+	if (priv->num_cc_chans) {
+		/* There's a CC chan, need to also check if it's enabled */
+		regmap_read(priv->regmap, STM32MP25_LPTIM_CCMR1, &ccmr1);
+		if (pwm->hwpwm)
+			enabled &= !!FIELD_GET(STM32MP25_LPTIM_CC2E, ccmr1);
+		else
+			enabled &= !!FIELD_GET(STM32MP25_LPTIM_CC1E, ccmr1);
+	}
+	state->enabled = enabled;
+
 	/* Keep PWM counter clock refcount in sync with PWM initial state */
 	if (state->enabled)
 		clk_enable(priv->clk);
 
 	regmap_read(priv->regmap, STM32_LPTIM_CFGR, &val);
 	presc = FIELD_GET(STM32_LPTIM_PRESC, val);
-	state->polarity = FIELD_GET(STM32_LPTIM_WAVPOL, val);
+	if (priv->num_cc_chans) {
+		if (pwm->hwpwm)
+			state->polarity = FIELD_GET(STM32MP25_LPTIM_CC2P, ccmr1);
+		else
+			state->polarity = FIELD_GET(STM32MP25_LPTIM_CC1P, ccmr1);
+	} else {
+		state->polarity = FIELD_GET(STM32_LPTIM_WAVPOL, val);
+	}
 
 	regmap_read(priv->regmap, STM32_LPTIM_ARR, &prd);
 	tmp = prd + 1;
 	tmp = (tmp << presc) * NSEC_PER_SEC;
 	state->period = DIV_ROUND_CLOSEST_ULL(tmp, rate);
 
-	regmap_read(priv->regmap, STM32_LPTIM_CMP, &val);
+	regmap_read(priv->regmap, pwm->hwpwm ? STM32MP25_LPTIM_CCR2 : STM32_LPTIM_CMP, &val);
 	tmp = prd - val;
 	tmp = (tmp << presc) * NSEC_PER_SEC;
 	state->duty_cycle = DIV_ROUND_CLOSEST_ULL(tmp, rate);
@@ -206,8 +360,15 @@ static int stm32_pwm_lp_probe(struct platform_device *pdev)
 	priv->regmap = ddata->regmap;
 	priv->clk = ddata->clk;
 	priv->chip.dev = &pdev->dev;
+	priv->num_cc_chans = ddata->num_cc_chans;
 	priv->chip.ops = &stm32_pwm_lp_ops;
-	priv->chip.npwm = 1;
+	if (!ddata->num_cc_chans) {
+		/* No dedicated CC channel, so there's only one PWM channel */
+		priv->chip.npwm = 1;
+	} else {
+		/* There are dedicated CC channels, each with one PWM output */
+		priv->chip.npwm = ddata->num_cc_chans;
+	}
 
 	ret = devm_pwmchip_add(&pdev->dev, &priv->chip);
 	if (ret < 0)
@@ -222,12 +383,15 @@ static int __maybe_unused stm32_pwm_lp_suspend(struct device *dev)
 {
 	struct stm32_pwm_lp *priv = dev_get_drvdata(dev);
 	struct pwm_state state;
-
-	pwm_get_state(&priv->chip.pwms[0], &state);
-	if (state.enabled) {
-		dev_err(dev, "The consumer didn't stop us (%s)\n",
-			priv->chip.pwms[0].label);
-		return -EBUSY;
+	unsigned int i;
+
+	for (i = 0; i < priv->chip.npwm; i++) {
+		pwm_get_state(&priv->chip.pwms[i], &state);
+		if (state.enabled) {
+			dev_err(dev, "The consumer didn't stop us (%s)\n",
+				priv->chip.pwms[i].label);
+			return -EBUSY;
+		}
 	}
 
 	return pinctrl_pm_select_sleep_state(dev);
@@ -243,6 +407,7 @@ static SIMPLE_DEV_PM_OPS(stm32_pwm_lp_pm_ops, stm32_pwm_lp_suspend,
 
 static const struct of_device_id stm32_pwm_lp_of_match[] = {
 	{ .compatible = "st,stm32-pwm-lp", },
+	{ .compatible = "st,stm32mp25-pwm-lp", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32_pwm_lp_of_match);
diff --git a/drivers/pwm/pwm-stm32.c b/drivers/pwm/pwm-stm32.c
index 794ca5b02..24aab0450 100644
--- a/drivers/pwm/pwm-stm32.c
+++ b/drivers/pwm/pwm-stm32.c
@@ -207,6 +207,10 @@ static int stm32_pwm_capture(struct pwm_chip *chip, struct pwm_device *pwm,
 	regmap_write(priv->regmap, TIM_ARR, priv->max_arr);
 	regmap_write(priv->regmap, TIM_PSC, psc);
 
+	/* Reset input selector to its default input and disable slave mode */
+	regmap_write(priv->regmap, TIM_TISEL, 0x0);
+	regmap_write(priv->regmap, TIM_SMCR, 0x0);
+
 	/* Map TI1 or TI2 PWM input to IC1 & IC2 (or TI3/4 to IC3 & IC4) */
 	regmap_update_bits(priv->regmap,
 			   pwm->hwpwm < 2 ? TIM_CCMR1 : TIM_CCMR2,
diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index 4fd13b062..285931c18 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -37,6 +37,17 @@ config REGULATOR_FIXED_VOLTAGE
 	  useful for systems which use a combination of software
 	  managed regulators and simple non-configurable regulators.
 
+config REGULATOR_PROTECTION_CONSUMER
+	tristate "Regulator protection consumer"
+	depends on OF
+	help
+	  This driver handles regulator over-current detection in order to
+	  protect regulators from crashing. In case of over-current event
+	  or any IRQ, the protection consumer forces disable the regulator
+	  that was declared as supply.
+
+	  If unsure, say no.
+
 config REGULATOR_VIRTUAL_CONSUMER
 	tristate "Virtual regulator consumer support"
 	help
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index 9e382b50a..543e04fa2 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -7,6 +7,7 @@
 obj-$(CONFIG_REGULATOR) += core.o dummy.o fixed-helper.o helpers.o devres.o irq_helpers.o
 obj-$(CONFIG_OF) += of_regulator.o
 obj-$(CONFIG_REGULATOR_FIXED_VOLTAGE) += fixed.o
+obj-$(CONFIG_REGULATOR_PROTECTION_CONSUMER) += protection-consumer.o
 obj-$(CONFIG_REGULATOR_VIRTUAL_CONSUMER) += virtual.o
 obj-$(CONFIG_REGULATOR_USERSPACE_CONSUMER) += userspace-consumer.o
 
diff --git a/drivers/regulator/protection-consumer.c b/drivers/regulator/protection-consumer.c
new file mode 100644
index 000000000..a4d299f85
--- /dev/null
+++ b/drivers/regulator/protection-consumer.c
@@ -0,0 +1,137 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) STMicroelectronics 2021
+// Author: Pascal Paillet <p.paillet@foss.st.com> for STMicroelectronics.
+
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+
+/**
+ * struct protection_data - regulator driver data
+ * @reg: regulator consumer structure
+ * @nb: notifier_block structure
+ * @dev: device driver
+ */
+struct protection_data {
+	struct regulator *reg;
+	struct notifier_block nb;
+	struct device *dev;
+};
+
+/**
+ * protection_irq_handler() - irq handler
+ * @irq: irq number
+ * @dev: struct protection_data
+ *
+ * force disable the regulator
+ */
+static irqreturn_t protection_irq_handler(int irq, void *dev)
+{
+	struct protection_data *protection = (struct protection_data *)dev;
+
+	dev_warn(protection->dev, "Interrupt received on regulator\n");
+	if (regulator_is_enabled(protection->reg))
+		regulator_force_disable(protection->reg);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * regulator_event() - regulator framework callback
+ * @nb: notifier_block
+ * @event: regulator framework event
+ * @data: struct protection_data
+ *
+ * force disable the regulator in case of regulator event
+ *
+ * Return: 0 for successful probe else appropriate error
+ */
+static int regulator_event(struct notifier_block *nb, unsigned long event,
+			   void *data)
+{
+	struct protection_data *protection =
+	    container_of(nb, struct protection_data, nb);
+
+	if ((event & REGULATOR_EVENT_OVER_CURRENT) ||
+	    (event & REGULATOR_EVENT_OVER_TEMP)) {
+		dev_warn(protection->dev, "Event received on regulator\n");
+		if (regulator_is_enabled(protection->reg))
+			regulator_force_disable(protection->reg);
+	}
+
+	return 0;
+}
+
+/**
+ * protection_probe() - probe
+ * @pdev: platform_device
+ *
+ * Return: 0 for successful probe else appropriate error
+ */
+static int protection_probe(struct platform_device *pdev)
+{
+	struct protection_data *protection;
+	int irq, ret;
+
+	protection = devm_kzalloc(&pdev->dev, sizeof(struct protection_data),  GFP_KERNEL);
+	if (!protection)
+		return -ENOMEM;
+
+	protection->dev = &pdev->dev;
+
+	protection->reg = devm_regulator_get(&pdev->dev, "protection");
+	if (IS_ERR(protection->reg))
+		return PTR_ERR(protection->reg);
+
+	protection->nb.notifier_call = regulator_event;
+	ret = devm_regulator_register_notifier(protection->reg, &protection->nb);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Failed to register regulator notifier: %d\n", ret);
+		return ret;
+	}
+
+	/* irq is optional, the driver can be used with regulator events */
+	irq = platform_get_irq_optional(pdev, 0);
+	if (irq <= 0 && (irq != -ENXIO))
+		return irq ? : -ENOENT;
+
+	if (irq > 0) {
+		ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
+						protection_irq_handler,
+						IRQF_ONESHOT | IRQF_SHARED,
+						pdev->name, protection);
+		if (ret) {
+			dev_err(&pdev->dev, "Request IRQ failed\n");
+			return ret;
+		}
+	}
+	platform_set_drvdata(pdev, protection);
+	dev_dbg(&pdev->dev, "protection probed\n");
+
+	return 0;
+}
+
+static const struct of_device_id protection_dt_match[] = {
+	{ .compatible = "protection-consumer" },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(of, protection_dt_match);
+
+static struct platform_driver protection_driver = {
+	.driver = {
+		   .name = "protection-consumer",
+		   .owner = THIS_MODULE,
+		   .of_match_table = protection_dt_match,
+		   },
+	.probe = protection_probe,
+};
+
+module_platform_driver(protection_driver);
+
+MODULE_AUTHOR("<p.paillet@foss.st.com>");
+MODULE_DESCRIPTION("protection consumer driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/regulator/scmi-regulator.c b/drivers/regulator/scmi-regulator.c
index 41ae7ac27..fd884082c 100644
--- a/drivers/regulator/scmi-regulator.c
+++ b/drivers/regulator/scmi-regulator.c
@@ -219,10 +219,11 @@ static int scmi_regulator_common_init(struct scmi_regulator *sreg)
 	 */
 	if (vinfo->negative_volts_allowed) {
 		dev_warn(dev, "Negative voltages NOT supported...skip %s\n",
-			 sreg->of_node->full_name);
+			 vinfo->name);
 		return -EOPNOTSUPP;
 	}
 
+
 	sreg->desc.name = devm_kasprintf(dev, GFP_KERNEL, "%s", vinfo->name);
 	if (!sreg->desc.name)
 		return -ENOMEM;
@@ -230,8 +231,6 @@ static int scmi_regulator_common_init(struct scmi_regulator *sreg)
 	sreg->desc.id = sreg->id;
 	sreg->desc.type = REGULATOR_VOLTAGE;
 	sreg->desc.owner = THIS_MODULE;
-	sreg->desc.of_match_full_name = true;
-	sreg->desc.of_match = sreg->of_node->full_name;
 	sreg->desc.regulators_node = "regulators";
 	if (vinfo->segmented)
 		ret = scmi_config_linear_regulator_mappings(sreg, vinfo);
@@ -239,7 +238,6 @@ static int scmi_regulator_common_init(struct scmi_regulator *sreg)
 		ret = scmi_config_discrete_regulator_mappings(sreg, vinfo);
 	if (ret)
 		return ret;
-
 	/*
 	 * Using the scmi device here to have DT searched from Voltage
 	 * protocol node down.
@@ -252,40 +250,59 @@ static int scmi_regulator_common_init(struct scmi_regulator *sreg)
 	return 0;
 }
 
+static int scmi_find_domain_from_name(struct scmi_device *sdev,
+				      struct device_node *np,
+				      struct scmi_regulator_info *rinfo,
+				      u32 *dom)
+{
+	const char *name = of_get_property(np, "voltd-name", NULL);
+	int d;
+
+	if (!name)
+		return -EINVAL;
+
+	for (d = 0; d < rinfo->num_doms; d++) {
+		struct scmi_regulator *sreg = rinfo->sregv[d];
+
+		if (!sreg || !sreg->desc.name || strcmp(sreg->desc.name, name))
+			continue;
+
+		*dom=d;
+		return 0;
+	}
+
+	dev_warn(&sdev->dev, "scmi voltage domain %s not found\n", name);
+	return -ENODEV;
+}
+
 static int process_scmi_regulator_of_node(struct scmi_device *sdev,
-					  struct scmi_protocol_handle *ph,
 					  struct device_node *np,
 					  struct scmi_regulator_info *rinfo)
 {
 	u32 dom, ret;
 
 	ret = of_property_read_u32(np, "reg", &dom);
-	if (ret)
-		return ret;
+	if (ret == -EINVAL) {
+		ret = scmi_find_domain_from_name(sdev, np, rinfo, &dom);
+		if (ret < 0) {
+			return ret;
+		}
+	}
 
 	if (dom >= rinfo->num_doms)
 		return -ENODEV;
 
-	if (rinfo->sregv[dom]) {
-		dev_err(&sdev->dev,
-			"SCMI Voltage Domain %d already in use. Skipping: %s\n",
-			dom, np->full_name);
-		return -EINVAL;
-	}
-
-	rinfo->sregv[dom] = devm_kzalloc(&sdev->dev,
-					 sizeof(struct scmi_regulator),
-					 GFP_KERNEL);
 	if (!rinfo->sregv[dom])
-		return -ENOMEM;
+		return -EINVAL;
 
 	rinfo->sregv[dom]->id = dom;
 	rinfo->sregv[dom]->sdev = sdev;
-	rinfo->sregv[dom]->ph = ph;
 
 	/* get hold of good nodes */
 	of_node_get(np);
 	rinfo->sregv[dom]->of_node = np;
+	rinfo->sregv[dom]->desc.of_match_full_name = true;
+	rinfo->sregv[dom]->desc.of_match = rinfo->sregv[dom]->of_node->name;
 
 	dev_dbg(&sdev->dev,
 		"Found SCMI Regulator entry -- OF node [%d] -> %s\n",
@@ -338,21 +355,38 @@ static int scmi_regulator_probe(struct scmi_device *sdev)
 	rinfo->num_doms = num_doms;
 
 	/*
-	 * Start collecting into rinfo->sregv possibly good SCMI Regulators as
-	 * described by a well-formed DT entry and associated with an existing
-	 * plausible SCMI Voltage Domain number, all belonging to this SCMI
-	 * platform instance node (handle->dev->of_node).
+	 * Start collecting into rinfo->sregv for each regulator that we
+	 * can successfully reach via SCMI.
 	 */
-	np = of_find_node_by_name(handle->dev->of_node, "regulators");
-	for_each_child_of_node(np, child) {
-		ret = process_scmi_regulator_of_node(sdev, ph, child, rinfo);
-		/* abort on any mem issue */
-		if (ret == -ENOMEM) {
-			of_node_put(child);
-			return ret;
+	for (d = 0; d < num_doms; d++) {
+		struct scmi_regulator *sreg;
+
+		sreg = devm_kzalloc(&sdev->dev, sizeof(struct scmi_regulator),
+				    GFP_KERNEL);
+		if (!sreg)
+			return -ENOMEM;
+
+		sreg->sdev = sdev;
+		sreg->id = d;
+		sreg->ph = ph;
+
+		ret = scmi_regulator_common_init(sreg);
+		if (ret) {
+			devm_kfree(&sdev->dev, sreg);
+			continue;
 		}
+
+		rinfo->sregv[d] = sreg;
 	}
 	of_node_put(np);
+	/*
+	 * Map each DT entry with an existing SCMI Voltage Domain number
+	 * all belonging to this SCMI platform instance node (handle->dev->of_node).
+	 */
+	np = of_find_node_by_name(handle->dev->of_node, "regulators");
+	for_each_child_of_node(np, child)
+		process_scmi_regulator_of_node(sdev, child, rinfo);
+
 	/*
 	 * Register a regulator for each valid regulator-DT-entry that we
 	 * can successfully reach via SCMI and has a valid associated voltage
@@ -365,9 +399,8 @@ static int scmi_regulator_probe(struct scmi_device *sdev)
 		if (!sreg)
 			continue;
 
-		ret = scmi_regulator_common_init(sreg);
-		/* Skip invalid voltage domains */
-		if (ret)
+		/* Skip if not described in the device-tree */
+		if (!sreg->of_node)
 			continue;
 
 		sreg->rdev = devm_regulator_register(&sdev->dev, &sreg->desc,
diff --git a/drivers/regulator/stm32-pwr.c b/drivers/regulator/stm32-pwr.c
index 2a42acb7c..2b328b970 100644
--- a/drivers/regulator/stm32-pwr.c
+++ b/drivers/regulator/stm32-pwr.c
@@ -3,12 +3,15 @@
 // Authors: Gabriel Fernandez <gabriel.fernandez@st.com>
 //          Pascal Paillet <p.paillet@st.com>.
 
+#include <linux/arm-smccc.h>
 #include <linux/io.h>
 #include <linux/iopoll.h>
+#include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/of_address.h>
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
+#include <linux/regmap.h>
 #include <linux/regulator/driver.h>
 #include <linux/regulator/of_regulator.h>
 
@@ -24,6 +27,11 @@
 #define REG_1_1_EN BIT(30)
 #define REG_1_1_RDY BIT(31)
 
+#define STM32_SMC_PWR		0x82001001
+#define STM32_WRITE		0x1
+#define STM32_SMC_REG_SET	0x2
+#define STM32_SMC_REG_CLEAR	0x3
+
 /* list of supported regulators */
 enum {
 	PWR_REG11,
@@ -39,10 +47,18 @@ static u32 ready_mask_table[STM32PWR_REG_NUM_REGS] = {
 };
 
 struct stm32_pwr_reg {
+	int tzen;
 	void __iomem *base;
 	u32 ready_mask;
 };
 
+#define SMC(class, op, address, val)\
+	({\
+	struct arm_smccc_res res;\
+	arm_smccc_smc(class, op, address, val,\
+			0, 0, 0, 0, &res);\
+	})
+
 static int stm32_pwr_reg_is_ready(struct regulator_dev *rdev)
 {
 	struct stm32_pwr_reg *priv = rdev_get_drvdata(rdev);
@@ -69,9 +85,15 @@ static int stm32_pwr_reg_enable(struct regulator_dev *rdev)
 	int ret;
 	u32 val;
 
-	val = readl_relaxed(priv->base + REG_PWR_CR3);
-	val |= rdev->desc->enable_mask;
-	writel_relaxed(val, priv->base + REG_PWR_CR3);
+	if (priv->tzen) {
+		SMC(STM32_SMC_PWR, STM32_SMC_REG_SET, REG_PWR_CR3,
+		    rdev->desc->enable_mask);
+	} else {
+		val = readl_relaxed(priv->base + REG_PWR_CR3);
+		val |= rdev->desc->enable_mask;
+		writel_relaxed(val, priv->base + REG_PWR_CR3);
+	}
+
 
 	/* use an arbitrary timeout of 20ms */
 	ret = readx_poll_timeout(stm32_pwr_reg_is_ready, rdev, val, val,
@@ -88,9 +110,14 @@ static int stm32_pwr_reg_disable(struct regulator_dev *rdev)
 	int ret;
 	u32 val;
 
-	val = readl_relaxed(priv->base + REG_PWR_CR3);
-	val &= ~rdev->desc->enable_mask;
-	writel_relaxed(val, priv->base + REG_PWR_CR3);
+	if (priv->tzen) {
+		SMC(STM32_SMC_PWR, STM32_SMC_REG_CLEAR, REG_PWR_CR3,
+		    rdev->desc->enable_mask);
+	} else {
+		val = readl_relaxed(priv->base + REG_PWR_CR3);
+		val &= ~rdev->desc->enable_mask;
+		writel_relaxed(val, priv->base + REG_PWR_CR3);
+	}
 
 	/* use an arbitrary timeout of 20ms */
 	ret = readx_poll_timeout(stm32_pwr_reg_is_ready, rdev, val, !val,
@@ -121,12 +148,50 @@ static const struct regulator_ops stm32_pwr_reg_ops = {
 		.supply_name = _supply, \
 	} \
 
-static const struct regulator_desc stm32_pwr_desc[] = {
+static struct regulator_desc stm32_pwr_desc[] = {
 	PWR_REG(PWR_REG11, "reg11", 1100000, REG_1_1_EN, "vdd"),
 	PWR_REG(PWR_REG18, "reg18", 1800000, REG_1_8_EN, "vdd"),
 	PWR_REG(PWR_USB33, "usb33", 3300000, USB_3_3_EN, "vdd_3v3_usbfs"),
 };
 
+static int is_stm32_soc_secured(struct platform_device *pdev, int *val)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct regmap *syscon;
+	u32 reg, mask;
+	int tzc_val = 0;
+	int err;
+
+	syscon = syscon_regmap_lookup_by_phandle(np, "st,tzcr");
+	if (IS_ERR(syscon)) {
+		if (PTR_ERR(syscon) != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "tzcr syscon required\n");
+		return PTR_ERR(syscon);
+	}
+
+	err = of_property_read_u32_index(np, "st,tzcr", 1, &reg);
+	if (err) {
+		dev_err(&pdev->dev, "tzcr offset required !\n");
+		return err;
+	}
+
+	err = of_property_read_u32_index(np, "st,tzcr", 2, &mask);
+	if (err) {
+		dev_err(&pdev->dev, "tzcr mask required !\n");
+		return err;
+	}
+
+	err = regmap_read(syscon, reg, &tzc_val);
+	if (err) {
+		dev_err(&pdev->dev, "failed to read tzcr status !\n");
+		return err;
+	}
+
+	*val = tzc_val & mask;
+
+	return 0;
+}
+
 static int stm32_pwr_regulator_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
@@ -135,6 +200,11 @@ static int stm32_pwr_regulator_probe(struct platform_device *pdev)
 	struct regulator_dev *rdev;
 	struct regulator_config config = { };
 	int i, ret = 0;
+	int tzen = 0;
+
+	ret = is_stm32_soc_secured(pdev, &tzen);
+	if (ret)
+		return ret;
 
 	base = of_iomap(np, 0);
 	if (!base) {
@@ -149,6 +219,7 @@ static int stm32_pwr_regulator_probe(struct platform_device *pdev)
 				    GFP_KERNEL);
 		if (!priv)
 			return -ENOMEM;
+		priv->tzen = tzen;
 		priv->base = base;
 		priv->ready_mask = ready_mask_table[i];
 		config.driver_data = priv;
diff --git a/drivers/regulator/stm32-vrefbuf.c b/drivers/regulator/stm32-vrefbuf.c
index 161622ea7..d7eb7607b 100644
--- a/drivers/regulator/stm32-vrefbuf.c
+++ b/drivers/regulator/stm32-vrefbuf.c
@@ -31,6 +31,7 @@ struct stm32_vrefbuf {
 	void __iomem *base;
 	struct clk *clk;
 	struct device *dev;
+	u32 backup_val;
 };
 
 static const unsigned int stm32_vrefbuf_voltages[] = {
@@ -38,6 +39,11 @@ static const unsigned int stm32_vrefbuf_voltages[] = {
 	2500000, 2048000, 1800000, 1500000,
 };
 
+static const unsigned int stm32mp13_vrefbuf_voltages[] = {
+	/* Matches resp. VRS = 000b, 001b, 010b, 011b */
+	2500000, 2048000, 1800000, 1650000,
+};
+
 static int stm32_vrefbuf_enable(struct regulator_dev *rdev)
 {
 	struct stm32_vrefbuf *priv = rdev_get_drvdata(rdev);
@@ -180,11 +186,24 @@ static const struct regulator_desc stm32_vrefbuf_regu = {
 	.owner = THIS_MODULE,
 };
 
+static const struct regulator_desc stm32mp13_vrefbuf_regu = {
+	.name = "vref",
+	.supply_name = "vdda",
+	.volt_table = stm32mp13_vrefbuf_voltages,
+	.n_voltages = ARRAY_SIZE(stm32mp13_vrefbuf_voltages),
+	.ops = &stm32_vrefbuf_volt_ops,
+	.off_on_delay = 1000,
+	.type = REGULATOR_VOLTAGE,
+	.owner = THIS_MODULE,
+};
+
 static int stm32_vrefbuf_probe(struct platform_device *pdev)
 {
+	struct device *dev = &pdev->dev;
 	struct stm32_vrefbuf *priv;
 	struct regulator_config config = { };
 	struct regulator_dev *rdev;
+	const struct regulator_desc *desc;
 	int ret;
 
 	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
@@ -213,14 +232,19 @@ static int stm32_vrefbuf_probe(struct platform_device *pdev)
 		goto err_pm_stop;
 	}
 
+	desc = (const struct regulator_desc *)
+		of_match_device(dev->driver->of_match_table, dev)->data;
+	if (!desc)
+		return -EINVAL;
+
 	config.dev = &pdev->dev;
 	config.driver_data = priv;
 	config.of_node = pdev->dev.of_node;
 	config.init_data = of_get_regulator_init_data(&pdev->dev,
 						      pdev->dev.of_node,
-						      &stm32_vrefbuf_regu);
+						      desc);
 
-	rdev = regulator_register(&stm32_vrefbuf_regu, &config);
+	rdev = regulator_register(desc, &config);
 	if (IS_ERR(rdev)) {
 		ret = PTR_ERR(rdev);
 		dev_err(&pdev->dev, "register failed with error %d\n", ret);
@@ -276,16 +300,51 @@ static int __maybe_unused stm32_vrefbuf_runtime_resume(struct device *dev)
 	return clk_prepare_enable(priv->clk);
 }
 
+#if defined(CONFIG_PM_SLEEP)
+static int stm32_vrefbuf_suspend(struct device *dev)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct stm32_vrefbuf *priv = rdev_get_drvdata(rdev);
+	int ret;
+
+	ret = pm_runtime_get_sync(priv->dev);
+	if (ret < 0) {
+		pm_runtime_put_noidle(priv->dev);
+		return ret;
+	}
+
+	priv->backup_val = readl_relaxed(priv->base + STM32_VREFBUF_CSR);
+
+	return pm_runtime_force_suspend(dev);
+}
+
+static int stm32_vrefbuf_resume(struct device *dev)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct stm32_vrefbuf *priv = rdev_get_drvdata(rdev);
+	int ret;
+
+	ret = pm_runtime_force_resume(dev);
+	if (ret < 0)
+		return ret;
+
+	writel_relaxed(priv->backup_val, priv->base + STM32_VREFBUF_CSR);
+
+	return 0;
+}
+#endif
+
 static const struct dev_pm_ops stm32_vrefbuf_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
-				pm_runtime_force_resume)
+	SET_SYSTEM_SLEEP_PM_OPS(stm32_vrefbuf_suspend,
+				stm32_vrefbuf_resume)
 	SET_RUNTIME_PM_OPS(stm32_vrefbuf_runtime_suspend,
 			   stm32_vrefbuf_runtime_resume,
 			   NULL)
 };
 
 static const struct of_device_id __maybe_unused stm32_vrefbuf_of_match[] = {
-	{ .compatible = "st,stm32-vrefbuf", },
+	{ .compatible = "st,stm32-vrefbuf", .data = (void *)&stm32_vrefbuf_regu },
+	{ .compatible = "st,stm32mp13-vrefbuf", .data = (void *)&stm32mp13_vrefbuf_regu },
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32_vrefbuf_of_match);
diff --git a/drivers/regulator/stpmic1_regulator.c b/drivers/regulator/stpmic1_regulator.c
index 2d7597c76..c2cddba6d 100644
--- a/drivers/regulator/stpmic1_regulator.c
+++ b/drivers/regulator/stpmic1_regulator.c
@@ -2,7 +2,9 @@
 // Copyright (C) STMicroelectronics 2018
 // Author: Pascal Paillet <p.paillet@st.com> for STMicroelectronics.
 
+#include <linux/delay.h>
 #include <linux/interrupt.h>
+#include <linux/ktime.h>
 #include <linux/mfd/stpmic1.h>
 #include <linux/module.h>
 #include <linux/of_irq.h>
@@ -30,11 +32,27 @@ struct stpmic1_regulator_cfg {
 	u8 icc_mask;
 };
 
+/**
+ * struct boost_data - this structure is used as driver data for the usb boost
+ * @boost_rdev: device for boost regulator
+ * @vbus_otg_rdev: device for vbus_otg regulator
+ * @sw_out_rdev: device for sw_out regulator
+ * @occ_timeout: overcurrent detection timeout
+ */
+struct boost_data {
+	struct regulator_dev *boost_rdev;
+	struct regulator_dev *vbus_otg_rdev;
+	struct regulator_dev *sw_out_rdev;
+	ktime_t occ_timeout;
+};
+
 static int stpmic1_set_mode(struct regulator_dev *rdev, unsigned int mode);
 static unsigned int stpmic1_get_mode(struct regulator_dev *rdev);
 static int stpmic1_set_icc(struct regulator_dev *rdev, int lim, int severity,
 			   bool enable);
 static unsigned int stpmic1_map_mode(unsigned int mode);
+static int regulator_enable_boost(struct regulator_dev *rdev);
+static int regulator_disable_boost(struct regulator_dev *rdev);
 
 enum {
 	STPMIC1_BUCK1 = 0,
@@ -182,8 +200,8 @@ static const struct regulator_ops stpmic1_vref_ddr_ops = {
 
 static const struct regulator_ops stpmic1_boost_regul_ops = {
 	.is_enabled = regulator_is_enabled_regmap,
-	.enable = regulator_enable_regmap,
-	.disable = regulator_disable_regmap,
+	.enable = regulator_enable_boost,
+	.disable = regulator_disable_boost,
 	.set_over_current_protection = stpmic1_set_icc,
 };
 
@@ -529,6 +547,79 @@ static irqreturn_t stpmic1_curlim_irq_handler(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
+static int regulator_enable_boost(struct regulator_dev *rdev)
+{
+	struct boost_data *usb_data = rdev_get_drvdata(rdev);
+
+	usb_data->occ_timeout = ktime_add_us(ktime_get(), 100000);
+
+	return regulator_enable_regmap(rdev);
+}
+
+static int regulator_disable_boost(struct regulator_dev *rdev)
+{
+	struct boost_data *usb_data = rdev_get_drvdata(rdev);
+
+	usb_data->occ_timeout = 0;
+
+	return regulator_disable_regmap(rdev);
+}
+
+static void stpmic1_reset_boost(struct boost_data *usb_data)
+{
+	int otg_on = 0;
+	int sw_out_on = 0;
+
+	dev_dbg(rdev_get_dev(usb_data->boost_rdev), "reset usb boost\n");
+
+	/* the boost was actually disabled by the over-current protection */
+	regulator_disable_regmap(usb_data->boost_rdev);
+
+	if (usb_data->vbus_otg_rdev)
+		otg_on = regulator_is_enabled_regmap(usb_data->vbus_otg_rdev);
+	if (otg_on)
+		regulator_disable_regmap(usb_data->vbus_otg_rdev);
+
+	if (usb_data->sw_out_rdev)
+		sw_out_on = regulator_is_enabled_regmap(usb_data->sw_out_rdev);
+	if (sw_out_on)
+		regulator_disable_regmap(usb_data->sw_out_rdev);
+
+	regulator_enable_regmap(usb_data->boost_rdev);
+
+	/* sleep at least 5ms */
+	usleep_range(5000, 10000);
+
+	if (otg_on)
+		regulator_enable_regmap(usb_data->vbus_otg_rdev);
+
+	if (sw_out_on)
+		regulator_enable_regmap(usb_data->sw_out_rdev);
+
+}
+
+static irqreturn_t stpmic1_boost_irq_handler(int irq, void *data)
+{
+	struct boost_data *usb_data = (struct boost_data *)data;
+
+	dev_dbg(rdev_get_dev(usb_data->boost_rdev), "usb boost irq handler\n");
+
+	/* overcurrent detected on boost after timeout */
+	if (usb_data->occ_timeout != 0 &&
+	    ktime_compare(ktime_get(), usb_data->occ_timeout) > 0) {
+		/* reset usb boost and usb power switches */
+		stpmic1_reset_boost(usb_data);
+		return IRQ_HANDLED;
+	}
+
+	/* Send an overcurrent notification */
+	regulator_notifier_call_chain(usb_data->boost_rdev,
+				      REGULATOR_EVENT_OVER_CURRENT,
+				      NULL);
+
+	return IRQ_HANDLED;
+}
+
 #define MATCH(_name, _id) \
 	[STPMIC1_##_id] = { \
 		.name = #_name, \
@@ -552,9 +643,10 @@ static struct of_regulator_match stpmic1_matches[] = {
 	MATCH(pwr_sw2, SW_OUT),
 };
 
-static int stpmic1_regulator_register(struct platform_device *pdev, int id,
-				      struct of_regulator_match *match,
-				      const struct stpmic1_regulator_cfg *cfg)
+static struct regulator_dev *
+stpmic1_regulator_register(struct platform_device *pdev, int id,
+			   struct of_regulator_match *match,
+			   const struct stpmic1_regulator_cfg *cfg)
 {
 	struct stpmic1 *pmic_dev = dev_get_drvdata(pdev->dev.parent);
 	struct regulator_dev *rdev;
@@ -572,7 +664,7 @@ static int stpmic1_regulator_register(struct platform_device *pdev, int id,
 	if (IS_ERR(rdev)) {
 		dev_err(&pdev->dev, "failed to register %s regulator\n",
 			cfg->desc.name);
-		return PTR_ERR(rdev);
+		return rdev;
 	}
 
 	/* set mask reset */
@@ -584,7 +676,7 @@ static int stpmic1_regulator_register(struct platform_device *pdev, int id,
 					 cfg->mask_reset_mask);
 		if (ret) {
 			dev_err(&pdev->dev, "set mask reset failed\n");
-			return ret;
+			return ERR_PTR(ret);
 		}
 	}
 
@@ -598,15 +690,60 @@ static int stpmic1_regulator_register(struct platform_device *pdev, int id,
 						pdev->name, rdev);
 		if (ret) {
 			dev_err(&pdev->dev, "Request IRQ failed\n");
-			return ret;
+			return ERR_PTR(ret);
 		}
 	}
-	return 0;
+
+	return rdev;
+}
+
+static struct regulator_dev *
+stpmic1_boost_register(struct platform_device *pdev, int id,
+		       struct of_regulator_match *match,
+		       const struct stpmic1_regulator_cfg *cfg,
+		       struct boost_data *usb_data)
+{
+	struct stpmic1 *pmic_dev = dev_get_drvdata(pdev->dev.parent);
+	struct regulator_dev *rdev;
+	struct regulator_config config = {};
+	int ret = 0;
+	int irq;
+
+	config.dev = &pdev->dev;
+	config.init_data = match->init_data;
+	config.of_node = match->of_node;
+	config.regmap = pmic_dev->regmap;
+	config.driver_data = (void *)usb_data;
+
+	rdev = devm_regulator_register(&pdev->dev, &cfg->desc, &config);
+	if (IS_ERR(rdev)) {
+		dev_err(&pdev->dev, "failed to register %s regulator\n",
+			cfg->desc.name);
+		return rdev;
+	}
+
+	/* setup an irq handler for over-current detection */
+	irq = of_irq_get(config.of_node, 0);
+	if (irq > 0) {
+		ret = devm_request_threaded_irq(&pdev->dev,
+						irq, NULL,
+						stpmic1_boost_irq_handler,
+						IRQF_ONESHOT, pdev->name,
+						usb_data);
+		if (ret) {
+			dev_err(&pdev->dev, "Request IRQ failed\n");
+			return ERR_PTR(ret);
+		}
+	}
+
+	return rdev;
 }
 
 static int stpmic1_regulator_probe(struct platform_device *pdev)
 {
 	int i, ret;
+	struct boost_data *usb_data;
+	struct regulator_dev *rdev;
 
 	ret = of_regulator_match(&pdev->dev, pdev->dev.of_node, stpmic1_matches,
 				 ARRAY_SIZE(stpmic1_matches));
@@ -616,11 +753,30 @@ static int stpmic1_regulator_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	usb_data = devm_kzalloc(&pdev->dev, sizeof(*usb_data), GFP_KERNEL);
+	if (!usb_data)
+		return -ENOMEM;
+
 	for (i = 0; i < ARRAY_SIZE(stpmic1_regulator_cfgs); i++) {
-		ret = stpmic1_regulator_register(pdev, i, &stpmic1_matches[i],
-						 &stpmic1_regulator_cfgs[i]);
-		if (ret < 0)
-			return ret;
+		if (i == STPMIC1_BOOST) {
+			rdev =
+			stpmic1_boost_register(pdev, i, &stpmic1_matches[i],
+					       &stpmic1_regulator_cfgs[i],
+					       usb_data);
+
+			usb_data->boost_rdev = rdev;
+		} else {
+			rdev =
+			stpmic1_regulator_register(pdev, i, &stpmic1_matches[i],
+						   &stpmic1_regulator_cfgs[i]);
+
+			if (i == STPMIC1_VBUS_OTG)
+				usb_data->vbus_otg_rdev = rdev;
+			else if (i == STPMIC1_SW_OUT)
+				usb_data->sw_out_rdev = rdev;
+		}
+		if (IS_ERR(rdev))
+			return PTR_ERR(rdev);
 	}
 
 	dev_dbg(&pdev->dev, "stpmic1_regulator driver probed\n");
diff --git a/drivers/remoteproc/Kconfig b/drivers/remoteproc/Kconfig
index 9a6eedc39..33e96dd61 100644
--- a/drivers/remoteproc/Kconfig
+++ b/drivers/remoteproc/Kconfig
@@ -23,6 +23,25 @@ config REMOTEPROC_CDEV
 
 	  It's safe to say N if you don't want to use this interface.
 
+config REMOTEPROC_SRM_CORE
+	tristate "Remoteproc System Resource Manager core"
+	depends on RPMSG
+	help
+	  Say y here to enable the core driver of the remoteproc System Resource
+	  Manager (SRM).
+	  The SRM handles resources allocated to remote processors.
+	  The core part is in charge of controlling the device children.
+
+config REMOTEPROC_SRM_DEV
+	tristate "Remoteproc System Resource Manager device"
+	depends on REMOTEPROC_SRM_CORE
+	help
+	  Say y here to enable the device driver of the remoteproc System
+	  Resource Manager (SRM).
+	  The SRM handles resources allocated to remote processors.
+	  The device part is in charge of reserving and initializing resources
+	  for a peripheral assigned to a coprocessor.
+
 config IMX_REMOTEPROC
 	tristate "i.MX remoteproc support"
 	depends on ARCH_MXC
@@ -279,6 +298,7 @@ config STM32_RPROC
 	depends on ARCH_STM32
 	depends on REMOTEPROC
 	select MAILBOX
+	select TEE_REMOTEPROC
 	help
 	  Say y here to support STM32 MCU processors via the
 	  remote processor framework.
@@ -315,6 +335,15 @@ config TI_K3_R5_REMOTEPROC
 	  It's safe to say N here if you're not interested in utilizing
 	  a slave processor.
 
+
+config TEE_REMOTEPROC
+	tristate "trusted firmware support by a trusted application"
+	depends on OPTEE
+	help
+	  Support for trusted remote processors firmware. The firmware
+	  authentication and/or decryption are managed by a trusted application.
+	  This can be either built-in or a loadable module.
+
 endif # REMOTEPROC
 
 endmenu
diff --git a/drivers/remoteproc/Makefile b/drivers/remoteproc/Makefile
index bb26c9e4e..521dd3384 100644
--- a/drivers/remoteproc/Makefile
+++ b/drivers/remoteproc/Makefile
@@ -11,6 +11,9 @@ remoteproc-y				+= remoteproc_sysfs.o
 remoteproc-y				+= remoteproc_virtio.o
 remoteproc-y				+= remoteproc_elf_loader.o
 obj-$(CONFIG_REMOTEPROC_CDEV)		+= remoteproc_cdev.o
+obj-$(CONFIG_REMOTEPROC_SRM_CORE)	+= rproc_srm_core.o
+obj-$(CONFIG_REMOTEPROC_SRM_DEV)	+= rproc_srm_dev.o
+obj-$(CONFIG_TEE_REMOTEPROC)		+= tee_remoteproc.o
 obj-$(CONFIG_IMX_REMOTEPROC)		+= imx_rproc.o
 obj-$(CONFIG_INGENIC_VPU_RPROC)		+= ingenic_rproc.o
 obj-$(CONFIG_MTK_SCP)			+= mtk_scp.o mtk_scp_ipi.o
diff --git a/drivers/remoteproc/remoteproc_core.c b/drivers/remoteproc/remoteproc_core.c
index 775df165e..df31b9222 100644
--- a/drivers/remoteproc/remoteproc_core.c
+++ b/drivers/remoteproc/remoteproc_core.c
@@ -38,6 +38,7 @@
 #include <linux/of_reserved_mem.h>
 #include <linux/virtio_ids.h>
 #include <linux/virtio_ring.h>
+#include <linux/of_platform.h>
 #include <asm/byteorder.h>
 #include <linux/platform_device.h>
 
@@ -2356,6 +2357,11 @@ int rproc_add(struct rproc *rproc)
 	/* create debugfs entries */
 	rproc_create_debug_dir(rproc);
 
+	/* add resource manager device */
+	ret = devm_of_platform_populate(dev->parent);
+	if (ret < 0)
+		return ret;
+
 	/* if rproc is marked always-on, request it to boot */
 	if (rproc->auto_boot) {
 		ret = rproc_trigger_auto_boot(rproc);
@@ -2637,6 +2643,8 @@ int rproc_del(struct rproc *rproc)
 	list_del_rcu(&rproc->node);
 	mutex_unlock(&rproc_list_mutex);
 
+	of_platform_depopulate(rproc->dev.parent);
+
 	/* Ensure that no readers of rproc_list are still active */
 	synchronize_rcu();
 
diff --git a/drivers/remoteproc/remoteproc_sysfs.c b/drivers/remoteproc/remoteproc_sysfs.c
index ea8b89f97..82aceb1ac 100644
--- a/drivers/remoteproc/remoteproc_sysfs.c
+++ b/drivers/remoteproc/remoteproc_sysfs.c
@@ -174,6 +174,17 @@ static const char * const rproc_state_string[] = {
 	[RPROC_LAST]		= "invalid",
 };
 
+/*
+ * A firmware-format-to-string lookup table, for exposing a human readable
+ * supported firmware format via sysfs. Always keep in sync with enum
+ * rproc_fw_format.
+ */
+static const char * const rproc_format_string[] = {
+	[RPROC_FW_ELF]		= "ELF",
+	[RPROC_FW_TEE]		= "TEE",
+	[RPROC_FW_LAST]		= "invalid",
+};
+
 /* Expose the state of the remote processor via sysfs */
 static ssize_t state_show(struct device *dev, struct device_attribute *attr,
 			  char *buf)
@@ -230,12 +241,26 @@ static ssize_t name_show(struct device *dev, struct device_attribute *attr,
 }
 static DEVICE_ATTR_RO(name);
 
+/* Expose the format of the remote processor binary firmware via sysfs */
+static ssize_t fw_format_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
+{
+	struct rproc *rproc = to_rproc(dev);
+	unsigned int fw_format;
+
+	fw_format = rproc->fw_format > RPROC_FW_LAST ? RPROC_FW_LAST : rproc->fw_format;
+
+	return sprintf(buf, "%s\n", rproc_format_string[fw_format]);
+}
+static DEVICE_ATTR_RO(fw_format);
+
 static struct attribute *rproc_attrs[] = {
 	&dev_attr_coredump.attr,
 	&dev_attr_recovery.attr,
 	&dev_attr_firmware.attr,
 	&dev_attr_state.attr,
 	&dev_attr_name.attr,
+	&dev_attr_fw_format.attr,
 	NULL
 };
 
diff --git a/drivers/remoteproc/rproc_srm_core.c b/drivers/remoteproc/rproc_srm_core.c
new file mode 100644
index 000000000..fc61e8b35
--- /dev/null
+++ b/drivers/remoteproc/rproc_srm_core.c
@@ -0,0 +1,303 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Fabien Dessenne <fabien.dessenne@st.com> for STMicroelectronics.
+ */
+
+#include <linux/component.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/remoteproc.h>
+#include <linux/rpmsg.h>
+
+#include "rproc_srm_core.h"
+
+#define BIND_TIMEOUT 10000
+
+struct rproc_srm_core {
+	struct device *dev;
+	struct completion all_bound;
+	int bind_status;
+	atomic_t prepared;
+	struct rproc_subdev subdev;
+	struct rpmsg_driver rpdrv;
+	struct blocking_notifier_head notifier;
+};
+
+#define to_rproc_srm_core(s) container_of(s, struct rproc_srm_core, subdev)
+
+static struct rproc_srm_core *rpmsg_srm_to_core(struct rpmsg_device *rpdev)
+{
+	struct rpmsg_driver *rpdrv;
+	struct rproc_srm_core *core;
+
+	rpdrv = container_of(rpdev->dev.driver, struct rpmsg_driver, drv);
+	core = container_of(rpdrv, struct rproc_srm_core, rpdrv);
+
+	return core;
+}
+
+int rpmsg_srm_send(struct rpmsg_endpoint *ept, struct rpmsg_srm_msg *msg)
+{
+	int ret;
+
+	ret = rpmsg_send(ept, (void *)msg, sizeof(*msg));
+	if (ret)
+		dev_err(&ept->rpdev->dev, "rpmsg_send failed: %d\n", ret);
+
+	return ret;
+}
+EXPORT_SYMBOL(rpmsg_srm_send);
+
+static int rpmsg_srm_cb(struct rpmsg_device *rpdev, void *data, int len,
+			void *priv, u32 src)
+{
+	struct rproc_srm_core *core = rpmsg_srm_to_core(rpdev);
+	struct rpmsg_srm_msg_desc desc;
+	int ret;
+
+	desc.ept = rpdev->ept;
+	desc.msg = data;
+
+	ret = blocking_notifier_call_chain(&core->notifier, 0, &desc);
+
+	if (!(ret & NOTIFY_STOP_MASK)) {
+		dev_warn(&rpdev->dev, "unknown device\n");
+		desc.msg->message_type = RPROC_SRM_MSG_ERROR;
+		rpmsg_srm_send(desc.ept, desc.msg);
+	}
+
+	return 0;
+}
+
+static int rpmsg_srm_probe(struct rpmsg_device *rpdev)
+{
+	int ret;
+
+	dev_dbg(&rpdev->dev, "%s\n", __func__);
+
+	/* Send an empty message to complete the initialization */
+	ret = rpmsg_send(rpdev->ept, NULL, 0);
+	if (ret)
+		dev_err(&rpdev->dev, "failed to send init message\n");
+
+	return ret;
+}
+
+static void rpmsg_srm_remove(struct rpmsg_device *rpdev)
+{
+	/* Note : the remove ops is mandatory */
+	dev_dbg(&rpdev->dev, "%s\n", __func__);
+}
+
+static struct rpmsg_device_id rpmsg_srm_id_table[] = {
+	{ .name	= "rproc-srm" },
+	{ },
+};
+MODULE_DEVICE_TABLE(rpmsg, rpmsg_srm_id_table);
+
+static struct rpmsg_driver rpmsg_srm_drv = {
+	.drv.name	= "rpmsg_srm",
+	.id_table	= rpmsg_srm_id_table,
+	.probe		= rpmsg_srm_probe,
+	.callback	= rpmsg_srm_cb,
+	.remove		= rpmsg_srm_remove,
+};
+
+int rproc_srm_core_register_notifier(struct rproc_srm_core *core,
+				     struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&core->notifier, nb);
+}
+EXPORT_SYMBOL(rproc_srm_core_register_notifier);
+
+int rproc_srm_core_unregister_notifier(struct rproc_srm_core *core,
+				       struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&core->notifier, nb);
+}
+EXPORT_SYMBOL(rproc_srm_core_unregister_notifier);
+
+static int compare_of(struct device *dev, void *data)
+{
+	return dev->of_node == data;
+}
+
+static void release_of(struct device *dev, void *data)
+{
+	of_node_put(data);
+}
+
+static void rproc_srm_core_unbind(struct device *dev)
+{
+	component_unbind_all(dev, NULL);
+}
+
+static int rproc_srm_core_bind(struct device *dev)
+{
+	struct rproc_srm_core *rproc_srm_core = dev_get_drvdata(dev);
+
+	rproc_srm_core->bind_status = component_bind_all(dev, NULL);
+	complete(&rproc_srm_core->all_bound);
+
+	return rproc_srm_core->bind_status;
+}
+
+static const struct component_master_ops srm_comp_ops = {
+	.bind = rproc_srm_core_bind,
+	.unbind = rproc_srm_core_unbind,
+};
+
+static int rproc_srm_core_prepare(struct rproc_subdev *subdev)
+{
+	struct rproc_srm_core *rproc_srm_core = to_rproc_srm_core(subdev);
+	struct device *dev = rproc_srm_core->dev;
+	struct device_node *node = dev->of_node;
+	struct device_node *child_np;
+	struct component_match *match = NULL;
+	int ret;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	init_completion(&rproc_srm_core->all_bound);
+
+	ret = devm_of_platform_populate(dev);
+	if (ret) {
+		dev_err(dev, "cannot populate node (%d)\n", ret);
+		return ret;
+	}
+
+	child_np = of_get_next_available_child(node, NULL);
+
+	while (child_np) {
+		of_node_get(child_np);
+		component_match_add_release(dev, &match, release_of, compare_of,
+					    child_np);
+		child_np = of_get_next_available_child(node, child_np);
+	}
+
+	if (!match) {
+		dev_dbg(dev, "No available child\n");
+		goto done;
+	}
+
+	ret = component_master_add_with_match(dev, &srm_comp_ops, match);
+	if (ret)
+		goto depopulate;
+
+	/* Wait for every child to be bound */
+	if (!wait_for_completion_timeout(&rproc_srm_core->all_bound,
+					 msecs_to_jiffies(BIND_TIMEOUT))) {
+		dev_err(dev, "failed to bind one or more system resource device(s)\n");
+		ret = -ETIMEDOUT;
+		goto master;
+	}
+
+	ret = rproc_srm_core->bind_status;
+	if (ret) {
+		dev_err(dev, "failed to bind\n");
+		goto master;
+	}
+
+	/* Register rpmsg driver for dynamic management */
+	rproc_srm_core->rpdrv = rpmsg_srm_drv;
+	ret = register_rpmsg_driver(&rproc_srm_core->rpdrv);
+	if (ret) {
+		dev_err(dev, "failed to register rpmsg drv\n");
+		goto master;
+	}
+
+done:
+	atomic_inc(&rproc_srm_core->prepared);
+
+	return 0;
+
+master:
+	component_master_del(dev, &srm_comp_ops);
+depopulate:
+	devm_of_platform_depopulate(dev);
+	return ret;
+}
+
+static void rproc_srm_core_unprepare(struct rproc_subdev *subdev)
+{
+	struct rproc_srm_core *rproc_srm_core = to_rproc_srm_core(subdev);
+	struct device *dev = rproc_srm_core->dev;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	if (!atomic_read(&rproc_srm_core->prepared))
+		return;
+
+	atomic_dec(&rproc_srm_core->prepared);
+
+	unregister_rpmsg_driver(&rproc_srm_core->rpdrv);
+
+	component_master_del(dev, &srm_comp_ops);
+	devm_of_platform_depopulate(dev);
+}
+
+static int rproc_srm_core_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rproc *rproc = dev_get_drvdata(dev->parent);
+	struct rproc_srm_core *rproc_srm_core;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	rproc_srm_core = devm_kzalloc(dev, sizeof(struct rproc_srm_core),
+				      GFP_KERNEL);
+	if (!rproc_srm_core)
+		return -ENOMEM;
+
+	rproc_srm_core->dev = dev;
+	BLOCKING_INIT_NOTIFIER_HEAD(&rproc_srm_core->notifier);
+
+	/* Register rproc subdevice with (un)prepare ops */
+	rproc_srm_core->subdev.prepare = rproc_srm_core_prepare;
+	rproc_srm_core->subdev.unprepare = rproc_srm_core_unprepare;
+	rproc_add_subdev(rproc, &rproc_srm_core->subdev);
+
+	dev_set_drvdata(dev, rproc_srm_core);
+
+	return 0;
+}
+
+static int rproc_srm_core_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rproc_srm_core *rproc_srm_core = dev_get_drvdata(dev);
+	struct rproc *rproc = dev_get_drvdata(dev->parent);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	if (atomic_read(&rproc->power) > 0)
+		dev_warn(dev, "Releasing resources while firmware running!\n");
+
+	rproc_srm_core_unprepare(&rproc_srm_core->subdev);
+
+	return 0;
+}
+
+static const struct of_device_id rproc_srm_core_match[] = {
+	{ .compatible = "rproc-srm-core", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, rproc_srm_core_match);
+
+static struct platform_driver rproc_srm_core_driver = {
+	.probe = rproc_srm_core_probe,
+	.remove = rproc_srm_core_remove,
+	.driver = {
+		.name = "rproc-srm-core",
+		.of_match_table = of_match_ptr(rproc_srm_core_match),
+	},
+};
+
+module_platform_driver(rproc_srm_core_driver);
+
+MODULE_AUTHOR("Fabien Dessenne <fabien.dessenne@st.com>");
+MODULE_DESCRIPTION("Remoteproc System Resource Manager driver - core");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/remoteproc/rproc_srm_core.h b/drivers/remoteproc/rproc_srm_core.h
new file mode 100644
index 000000000..7dffdb38f
--- /dev/null
+++ b/drivers/remoteproc/rproc_srm_core.h
@@ -0,0 +1,98 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Fabien Dessenne <fabien.dessenne@st.com> for STMicroelectronics.
+ */
+
+#ifndef _RPROC_SRM_CORE_H_
+#define _RPROC_SRM_CORE_H_
+
+/**
+ * Message type used in resource manager rpmsg:
+ *  RPROC_SRM_MSG_GETCONFIG:    Request to get the configuration of a resource
+ *  RPROC_SRM_MSG_SETCONFIG:    Request to set the configuration of a resource
+ *  RPROC_SRM_MSG_ERROR:        Error when processing a request
+ */
+#define RPROC_SRM_MSG_GETCONFIG 0x00
+#define RPROC_SRM_MSG_SETCONFIG 0x01
+#define RPROC_SRM_MSG_ERROR     0xFF
+
+/**
+ * Resource type used in resource manager rpmsg:
+ *  RPROC_SRM_RSC_CLOCK:        clock resource
+ *  RPROC_SRM_RSC_REGU:         regulator resource
+ */
+#define RPROC_SRM_RSC_CLOCK     0x00
+#define RPROC_SRM_RSC_REGU      0x01
+
+/**
+ * struct clock_cfg - clock configuration used in resource manager rpmsg
+ * @index:      clock index
+ * @name:       clock name
+ * @rate:       clock rate request (in SetConfig message) or current status (in
+ *              GetConfig message)
+ */
+struct clock_cfg {
+	u32 index;
+	u8 name[16];
+	u32 rate;
+};
+
+/**
+ * struct regu_cfg - regu configuration used in resource manager rpmsg
+ * @index:      regulator index
+ * @name:       regulator name
+ * @enable:     regulator enable/disable request (in SetConfig message) or
+ *              current status (in GetConfig message)
+ * @curr_voltage_mv: current regulator voltage in mV (meaningful in
+ *                   SetConfig message)
+ * @min_voltage_mv:  regulator min voltage request in mV (meaningful in
+ *                   SetConfig message)
+ * @max_voltage_mv:  regulator max voltage request in mV (meaningful in
+ *                   SetConfig message)
+ */
+struct regu_cfg {
+	u32 index;
+	u8 name[16];
+	u32 enable;
+	u32 curr_voltage_mv;
+	u32 min_voltage_mv;
+	u32 max_voltage_mv;
+};
+
+/**
+ * struct rpmsg_srm_msg - message structure used between processors to
+ *                        dynamically update resources configuration
+ * @message_type: type of the message: see RPROC_SRM_MSG*
+ * @device_id:  an identifier specifying the device owning the resources.
+ *              This is implementation dependent. As example it may be the
+ *              device name or the device address.
+ * @rsc_type:   the type of the resource for which the configuration applies:
+ *              see RPROC_SRM_RSC*
+ * @clock_cfg:  clock config - relevant if &rsc_type is RPROC_SRM_RSC_CLOCK
+ * @regu_cfg:   regulator config - relevant if &rsc_type is RPROC_SRM_RSC_REGU
+ */
+struct rpmsg_srm_msg {
+	u32 message_type;
+	u8 device_id[32];
+	u32 rsc_type;
+	union {
+		struct clock_cfg clock_cfg;
+		struct regu_cfg regu_cfg;
+	};
+};
+
+struct rpmsg_srm_msg_desc {
+	struct rpmsg_endpoint *ept;
+	struct rpmsg_srm_msg *msg;
+};
+
+struct rproc_srm_core;
+
+int rproc_srm_core_register_notifier(struct rproc_srm_core *core,
+				     struct notifier_block *nb);
+int rproc_srm_core_unregister_notifier(struct rproc_srm_core *core,
+				       struct notifier_block *nb);
+int rpmsg_srm_send(struct rpmsg_endpoint *ept, struct rpmsg_srm_msg *msg);
+
+#endif
diff --git a/drivers/remoteproc/rproc_srm_dev.c b/drivers/remoteproc/rproc_srm_dev.c
new file mode 100644
index 000000000..e47654af3
--- /dev/null
+++ b/drivers/remoteproc/rproc_srm_dev.c
@@ -0,0 +1,744 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Fabien Dessenne <fabien.dessenne@st.com> for STMicroelectronics.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/component.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/remoteproc.h>
+
+#include "rproc_srm_core.h"
+
+struct rproc_srm_clk_info {
+	struct list_head list;
+	unsigned int index;
+	struct clk *clk;
+	const char *name;
+	bool parent_enabled;
+};
+
+struct rproc_srm_regu_info {
+	struct list_head list;
+	unsigned int index;
+	struct regulator *regu;
+	const char *name;
+	bool enabled;
+};
+
+struct rproc_srm_irq_info {
+	struct list_head list;
+	unsigned int index;
+	char *name;
+	int irq;
+	bool enabled;
+};
+
+struct rproc_srm_dev {
+	struct device *dev;
+	struct rproc_srm_core *core;
+	struct notifier_block nb;
+	bool early_boot;
+
+	struct list_head clk_list_head;
+	struct list_head regu_list_head;
+	struct list_head irq_list_head;
+};
+
+/* Irqs */
+static void rproc_srm_dev_irqs_put(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct device *dev = rproc_srm_dev->dev;
+	struct rproc_srm_irq_info *i, *tmp;
+
+	list_for_each_entry_safe(i, tmp, &rproc_srm_dev->irq_list_head, list) {
+		devm_free_irq(dev, i->irq, NULL);
+		dev_dbg(dev, "Put irq %d (%s)\n", i->irq, i->name);
+		list_del(&i->list);
+	}
+}
+
+static irqreturn_t rproc_srm_dev_irq_handler(int irq, void *dev)
+{
+	dev_warn(dev, "Spurious interrupt\n");
+	return IRQ_HANDLED;
+}
+
+static int rproc_srm_dev_irqs_get(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct device *dev = rproc_srm_dev->dev;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct device_node *np = dev->of_node;
+	struct rproc_srm_irq_info *info;
+	const char *name;
+	int nr, ret, irq;
+	unsigned int i;
+
+	if (!np)
+		return 0;
+
+	nr = platform_irq_count(pdev);
+	if (!nr)
+		return 0;
+
+	if (rproc_srm_dev->early_boot)
+		/*
+		 * Do not overwrite the irq configuration.
+		 * No need to parse irq from DT since the resource manager does
+		 * not offer any service to update the irq config.
+		 */
+		return 0;
+
+	for (i = 0; i < nr; i++) {
+		info = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);
+		if (!info) {
+			ret = -ENOMEM;
+			goto err;
+		}
+
+		irq = platform_get_irq(pdev, i);
+		if (irq <= 0) {
+			ret = irq;
+			dev_err(dev, "Failed to get irq (%d)\n", ret);
+			goto err;
+		}
+
+		info->irq = irq;
+
+		/* Register a dummy irq handleras not used by Linux */
+		ret = devm_request_irq(dev, info->irq,
+				       rproc_srm_dev_irq_handler, 0,
+				       dev_name(dev), NULL);
+		if (ret) {
+			dev_err(dev, "Failed to request irq (%d)\n", ret);
+			goto err;
+		}
+
+		/*
+		 * Disable IRQ. Since it is used by the remote processor we
+		 * must not use the 'irq lazy disable' optimization
+		 */
+		irq_set_status_flags(info->irq, IRQ_DISABLE_UNLAZY);
+		disable_irq(info->irq);
+
+		/* Note: "interrupt-names" is optional */
+		if (!of_property_read_string_index(np, "interrupt-names", i,
+						   &name))
+			info->name = devm_kstrdup(dev, name, GFP_KERNEL);
+		else
+			info->name = devm_kstrdup(dev, "", GFP_KERNEL);
+
+		info->index = i;
+
+		list_add_tail(&info->list, &rproc_srm_dev->irq_list_head);
+		dev_dbg(dev, "Got irq %d (%s)\n", info->irq, info->name);
+	}
+
+	return 0;
+
+err:
+	rproc_srm_dev_irqs_put(rproc_srm_dev);
+
+	return ret;
+}
+
+/* Clocks */
+static void rproc_srm_dev_clocks_unsetup(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct rproc_srm_clk_info *c;
+
+	list_for_each_entry(c, &rproc_srm_dev->clk_list_head, list) {
+		if (!c->parent_enabled)
+			continue;
+
+		clk_disable_unprepare(clk_get_parent(c->clk));
+		c->parent_enabled = false;
+		dev_dbg(rproc_srm_dev->dev, "clk %d (%s) unsetup\n",
+			c->index, c->name);
+	}
+}
+
+static int rproc_srm_dev_clocks_setup(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct rproc_srm_clk_info *c;
+	int ret;
+
+	/*
+	 * Prepare and enable the parent clocks.
+	 * Since the clock tree is under the exclusive control of the master
+	 * processor, we need to configure the clock tree of the targeted clock.
+	 * We do not want to enable the clock itself, which is under the
+	 * responsibility of the remote processor.
+	 * Hence we prepare and enable the parent clock.
+	 */
+
+	list_for_each_entry(c, &rproc_srm_dev->clk_list_head, list) {
+		if (c->parent_enabled)
+			continue;
+
+		ret = clk_prepare_enable(clk_get_parent(c->clk));
+		if (ret) {
+			dev_err(rproc_srm_dev->dev,
+				"clk %d (%s) parent enable failed\n",
+				c->index, c->name);
+			rproc_srm_dev_clocks_unsetup(rproc_srm_dev);
+			return ret;
+		}
+		c->parent_enabled = true;
+		dev_dbg(rproc_srm_dev->dev, "clk %d (%s) parent enabled\n",
+			c->index, c->name);
+	}
+
+	return 0;
+}
+
+static struct rproc_srm_clk_info
+	*rproc_srm_dev_clock_find(struct rproc_srm_dev *rproc_srm_dev,
+				  struct clock_cfg *cfg)
+{
+	struct rproc_srm_clk_info *ci;
+
+	/* Search by index (if valid value) otherwise search by name */
+	list_for_each_entry(ci, &rproc_srm_dev->clk_list_head, list) {
+		if (cfg->index != U32_MAX) {
+			if (ci->index == cfg->index)
+				return ci;
+		} else {
+			if (!strcmp(ci->name, cfg->name))
+				return ci;
+		}
+	}
+
+	return NULL;
+}
+
+static int rproc_srm_dev_clock_set_cfg(struct rproc_srm_dev *rproc_srm_dev,
+				       struct clock_cfg *cfg)
+{
+	struct rproc_srm_clk_info *c;
+	struct device *dev = rproc_srm_dev->dev;
+	int ret;
+
+	c = rproc_srm_dev_clock_find(rproc_srm_dev, cfg);
+
+	if (!c) {
+		dev_err(dev, "unknown clock (id %d)\n", cfg->index);
+		return -EINVAL;
+	}
+
+	if (cfg->rate && clk_get_rate(c->clk) != cfg->rate) {
+		ret = clk_set_rate(c->clk, cfg->rate);
+		if (ret) {
+			dev_err(dev, "clk set rate failed\n");
+			return ret;
+		}
+
+		dev_dbg(dev, "clk %d (%s) rate = %d\n", c->index, c->name,
+			cfg->rate);
+	}
+
+	return 0;
+}
+
+static int rproc_srm_dev_clock_get_cfg(struct rproc_srm_dev *rproc_srm_dev,
+				       struct clock_cfg *cfg)
+{
+	struct rproc_srm_clk_info *c;
+
+	c = rproc_srm_dev_clock_find(rproc_srm_dev, cfg);
+	if (!c) {
+		dev_err(rproc_srm_dev->dev, "unknown clock (%d)\n", cfg->index);
+		return -EINVAL;
+	}
+
+	strscpy(cfg->name, c->name, sizeof(cfg->name));
+	cfg->index = c->index;
+	cfg->rate = (u32)clk_get_rate(c->clk);
+
+	return 0;
+}
+
+static void rproc_srm_dev_clocks_put(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct device *dev = rproc_srm_dev->dev;
+	struct rproc_srm_clk_info *c, *tmp;
+
+	list_for_each_entry_safe(c, tmp, &rproc_srm_dev->clk_list_head, list) {
+		clk_put(c->clk);
+		dev_dbg(dev, "put clock %d (%s)\n", c->index, c->name);
+		list_del(&c->list);
+	}
+}
+
+static int rproc_srm_dev_clocks_get(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct device *dev = rproc_srm_dev->dev;
+	struct device_node *np = dev->of_node;
+	struct rproc_srm_clk_info *c;
+	const char *name;
+	int nb_c, ret;
+	unsigned int i;
+
+	if (!np)
+		return 0;
+
+	nb_c = of_clk_get_parent_count(np);
+	if (!nb_c)
+		return 0;
+
+	for (i = 0; i < nb_c; i++) {
+		c = devm_kzalloc(dev, sizeof(*c), GFP_KERNEL);
+		if (!c) {
+			ret = -ENOMEM;
+			goto err;
+		}
+
+		c->clk = of_clk_get(np, i);
+		if (IS_ERR(c->clk)) {
+			dev_err(dev, "clock %d KO (%ld)\n", i,
+				PTR_ERR(c->clk));
+			ret = -ENOMEM;
+			goto err;
+		}
+
+		/* Note: "clock-names" is optional */
+		if (!of_property_read_string_index(np, "clock-names", i,
+						   &name))
+			c->name = devm_kstrdup(dev, name, GFP_KERNEL);
+		else
+			c->name = devm_kstrdup(dev, "", GFP_KERNEL);
+
+		c->index = i;
+
+		list_add_tail(&c->list, &rproc_srm_dev->clk_list_head);
+		dev_dbg(dev, "got clock %d (%s)\n", c->index, c->name);
+	}
+
+	return 0;
+
+err:
+	rproc_srm_dev_clocks_put(rproc_srm_dev);
+	return ret;
+}
+
+/* Regulators */
+static void rproc_srm_dev_regus_unsetup(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct rproc_srm_regu_info *r;
+	struct device *dev = rproc_srm_dev->dev;
+
+	list_for_each_entry(r, &rproc_srm_dev->regu_list_head, list) {
+		if (!r->enabled)
+			continue;
+
+		if (regulator_disable(r->regu)) {
+			dev_warn(dev, "regu %d disabled failed\n", r->index);
+			continue;
+		}
+
+		r->enabled = false;
+		dev_dbg(dev, "regu %d (%s) disabled\n", r->index, r->name);
+	}
+}
+
+static int rproc_srm_dev_regus_setup(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct rproc_srm_regu_info *r;
+	int ret;
+
+	/* Enable all the regulators */
+	list_for_each_entry(r, &rproc_srm_dev->regu_list_head, list) {
+		if (r->enabled)
+			continue;
+
+		/* in early_boot mode sync on hw */
+		if (rproc_srm_dev->early_boot && !regulator_is_enabled(r->regu))
+			continue;
+
+		ret = regulator_enable(r->regu);
+		if (ret) {
+			dev_err(rproc_srm_dev->dev, "regu %d (%s) failed\n",
+				r->index, r->name);
+			rproc_srm_dev_regus_unsetup(rproc_srm_dev);
+			return ret;
+		}
+		r->enabled = true;
+		dev_dbg(rproc_srm_dev->dev, "regu %d (%s) enabled\n",
+			r->index, r->name);
+	}
+
+	return 0;
+}
+
+static struct rproc_srm_regu_info
+	*rproc_srm_dev_regu_find(struct rproc_srm_dev *rproc_srm_dev,
+				 struct regu_cfg *cfg)
+{
+	struct rproc_srm_regu_info *ri;
+
+	list_for_each_entry(ri, &rproc_srm_dev->regu_list_head, list) {
+		if (cfg->index != U32_MAX) {
+			if (ri->index == cfg->index)
+				return ri;
+		} else {
+			if (!strcmp(ri->name, cfg->name))
+				return ri;
+		}
+	}
+
+	return NULL;
+}
+
+static int rproc_srm_dev_regu_set_cfg(struct rproc_srm_dev *rproc_srm_dev,
+				      struct regu_cfg *cfg)
+{
+	struct rproc_srm_regu_info *r;
+	struct device *dev = rproc_srm_dev->dev;
+	int ret;
+
+	r = rproc_srm_dev_regu_find(rproc_srm_dev, cfg);
+	if (!r) {
+		dev_err(dev, "unknown regu (%d)\n", cfg->index);
+		return -EINVAL;
+	}
+
+	if (!r->enabled && cfg->enable) {
+		ret = regulator_enable(r->regu);
+		if (ret) {
+			dev_err(dev, "regu %d enable failed\n", r->index);
+			return ret;
+		}
+		r->enabled = true;
+		dev_dbg(dev, "regu %d (%s) enabled\n", r->index, r->name);
+	} else if (r->enabled && !cfg->enable) {
+		ret = regulator_disable(r->regu);
+		if (ret) {
+			dev_err(dev, "regu %d disable failed\n", r->index);
+			return ret;
+		}
+		r->enabled = false;
+		dev_dbg(dev, "regu %d (%s) disabled\n", r->index, r->name);
+	}
+
+	if (cfg->min_voltage_mv || cfg->max_voltage_mv) {
+		ret = regulator_set_voltage(r->regu, cfg->min_voltage_mv * 1000,
+					    cfg->max_voltage_mv * 1000);
+		if (ret) {
+			dev_err(dev, "regu %d set voltage failed\n", r->index);
+			return ret;
+		}
+
+		dev_dbg(dev, "regu %d (%s) voltage = [%d - %d] mv\n", r->index,
+			r->name, cfg->min_voltage_mv, cfg->max_voltage_mv);
+	}
+
+	return 0;
+}
+
+static int rproc_srm_dev_regu_get_cfg(struct rproc_srm_dev *rproc_srm_dev,
+				      struct regu_cfg *cfg)
+{
+	struct rproc_srm_regu_info *r;
+	struct device *dev = rproc_srm_dev->dev;
+	int v;
+
+	r = rproc_srm_dev_regu_find(rproc_srm_dev, cfg);
+	if (!r) {
+		dev_err(dev, "unknown regu (%d)\n", cfg->index);
+		return -EINVAL;
+	}
+
+	strscpy(cfg->name, r->name, sizeof(cfg->name));
+	cfg->index = r->index;
+	cfg->enable = r->enabled;
+	cfg->min_voltage_mv = 0;
+	cfg->max_voltage_mv = 0;
+
+	v = regulator_get_voltage(r->regu);
+	if (v < 0) {
+		dev_warn(dev, "cannot get %s voltage\n", r->name);
+		cfg->curr_voltage_mv = 0;
+	} else {
+		cfg->curr_voltage_mv = v / 1000;
+	}
+
+	return 0;
+}
+
+static void rproc_srm_dev_regus_put(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct device *dev = rproc_srm_dev->dev;
+	struct rproc_srm_regu_info *r, *tmp;
+
+	list_for_each_entry_safe(r, tmp, &rproc_srm_dev->regu_list_head, list) {
+		devm_regulator_put(r->regu);
+		dev_dbg(dev, "put regu %d (%s)\n", r->index, r->name);
+		list_del(&r->list);
+	}
+}
+
+static int rproc_srm_dev_regus_get(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct device *dev = rproc_srm_dev->dev;
+	struct device_node *np = dev->of_node;
+	struct property *p;
+	const char *n;
+	char *name;
+	struct rproc_srm_regu_info *r;
+	int ret, nb_s = 0;
+
+	if (!np)
+		return 0;
+
+	for_each_property_of_node(np, p) {
+		n = strstr(p->name, "-supply");
+		if (!n || n == p->name)
+			continue;
+
+		r = devm_kzalloc(dev, sizeof(*r), GFP_KERNEL);
+		if (!r) {
+			ret = -ENOMEM;
+			goto err_list;
+		}
+
+		name = devm_kstrdup(dev, p->name, GFP_KERNEL);
+		name[strlen(p->name) - strlen("-supply")] = '\0';
+		r->name = name;
+
+		r->regu = devm_regulator_get(dev, r->name);
+		if (IS_ERR(r->regu)) {
+			dev_err(dev, "cannot get regu %s\n", r->name);
+			ret = -EINVAL;
+			goto err_list;
+		}
+
+		r->index = nb_s++;
+
+		list_add_tail(&r->list, &rproc_srm_dev->regu_list_head);
+		dev_dbg(dev, "got regu %d (%s)\n", r->index, r->name);
+	}
+
+	return 0;
+
+err_list:
+	rproc_srm_dev_regus_put(rproc_srm_dev);
+	return ret;
+}
+
+/* Core */
+static int rproc_srm_dev_notify_cb(struct notifier_block *nb, unsigned long evt,
+				   void *data)
+{
+	struct rproc_srm_dev *rproc_srm_dev =
+			container_of(nb, struct rproc_srm_dev, nb);
+	struct device *dev = rproc_srm_dev->dev;
+	struct rpmsg_srm_msg_desc *desc;
+	struct rpmsg_srm_msg *i, o;
+	int ret = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	desc = (struct rpmsg_srm_msg_desc *)data;
+	i = desc->msg;
+	o = *i;
+
+	/* Check if 'device_id' (name / addr ) matches this device */
+	if (!strstr(dev_name(dev), i->device_id))
+		return NOTIFY_DONE;
+
+	switch (i->message_type) {
+	case RPROC_SRM_MSG_SETCONFIG:
+		switch (i->rsc_type) {
+		case RPROC_SRM_RSC_CLOCK:
+			ret = rproc_srm_dev_clock_set_cfg(rproc_srm_dev,
+							  &i->clock_cfg);
+			if (!ret)
+				ret = rproc_srm_dev_clock_get_cfg(rproc_srm_dev,
+								  &o.clock_cfg);
+			break;
+		case RPROC_SRM_RSC_REGU:
+			ret = rproc_srm_dev_regu_set_cfg(rproc_srm_dev,
+							 &i->regu_cfg);
+			if (!ret)
+				ret = rproc_srm_dev_regu_get_cfg(rproc_srm_dev,
+								 &o.regu_cfg);
+			break;
+		default:
+			dev_warn(dev, "bad rsc type (%d)\n", i->rsc_type);
+			ret = -EINVAL;
+			break;
+		}
+		break;
+	case RPROC_SRM_MSG_GETCONFIG:
+		switch (i->rsc_type) {
+		case RPROC_SRM_RSC_CLOCK:
+			ret = rproc_srm_dev_clock_get_cfg(rproc_srm_dev,
+							  &o.clock_cfg);
+			break;
+		case RPROC_SRM_RSC_REGU:
+			ret = rproc_srm_dev_regu_get_cfg(rproc_srm_dev,
+							 &o.regu_cfg);
+			break;
+		default:
+			dev_warn(dev, "bad rsc type (%d)\n", i->rsc_type);
+			ret = -EINVAL;
+			break;
+		}
+		break;
+	default:
+		dev_warn(dev, "bad msg type (%d)\n", i->message_type);
+		ret = -EINVAL;
+		break;
+	}
+
+	/* Send return msg */
+	if (ret)
+		o.message_type = RPROC_SRM_MSG_ERROR;
+
+	ret = rpmsg_srm_send(desc->ept, &o);
+
+	return ret ? NOTIFY_BAD : NOTIFY_STOP;
+}
+
+static void
+rproc_srm_dev_unbind(struct device *dev, struct device *master, void *data)
+{
+	struct rproc_srm_dev *rproc_srm_dev = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	rproc_srm_dev_regus_unsetup(rproc_srm_dev);
+	rproc_srm_dev_clocks_unsetup(rproc_srm_dev);
+
+	/* For IRQs: nothing to unsetup */
+}
+
+static int
+rproc_srm_dev_bind(struct device *dev, struct device *master, void *data)
+{
+	struct rproc_srm_dev *rproc_srm_dev = dev_get_drvdata(dev);
+	int ret;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	ret = rproc_srm_dev_clocks_setup(rproc_srm_dev);
+	if (ret)
+		return ret;
+
+	ret = rproc_srm_dev_regus_setup(rproc_srm_dev);
+	if (ret)
+		return ret;
+
+	/* For IRQs: nothing to setup */
+	return 0;
+}
+
+static const struct component_ops rproc_srm_dev_ops = {
+	.bind = rproc_srm_dev_bind,
+	.unbind = rproc_srm_dev_unbind,
+};
+
+static int rproc_srm_dev_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rproc_srm_dev *rproc_srm_dev;
+	struct rproc *rproc;
+	int ret;
+
+	dev_dbg(dev, "%s for node %s\n", __func__, dev->of_node->name);
+
+	rproc_srm_dev = devm_kzalloc(dev, sizeof(struct rproc_srm_dev),
+				     GFP_KERNEL);
+	if (!rproc_srm_dev)
+		return -ENOMEM;
+
+	rproc_srm_dev->dev = dev;
+	rproc = (struct rproc *)dev_get_drvdata(dev->parent->parent);
+	rproc_srm_dev->early_boot = (rproc->state == RPROC_DETACHED);
+	rproc_srm_dev->core = dev_get_drvdata(dev->parent);
+
+	INIT_LIST_HEAD(&rproc_srm_dev->clk_list_head);
+	INIT_LIST_HEAD(&rproc_srm_dev->regu_list_head);
+	INIT_LIST_HEAD(&rproc_srm_dev->irq_list_head);
+
+	/* Get clocks, regu and irqs */
+	ret = rproc_srm_dev_clocks_get(rproc_srm_dev);
+	if (ret)
+		return ret;
+
+	ret = rproc_srm_dev_regus_get(rproc_srm_dev);
+	if (ret)
+		goto err_get;
+
+	ret = rproc_srm_dev_irqs_get(rproc_srm_dev);
+	if (ret)
+		goto err_get;
+
+	rproc_srm_dev->nb.notifier_call = rproc_srm_dev_notify_cb;
+	ret = rproc_srm_core_register_notifier(rproc_srm_dev->core,
+					       &rproc_srm_dev->nb);
+	if (ret)
+		goto err_register;
+
+	dev_set_drvdata(dev, rproc_srm_dev);
+
+	return component_add(dev, &rproc_srm_dev_ops);
+
+err_register:
+	rproc_srm_core_unregister_notifier(rproc_srm_dev->core,
+					   &rproc_srm_dev->nb);
+err_get:
+	rproc_srm_dev_irqs_put(rproc_srm_dev);
+	rproc_srm_dev_regus_put(rproc_srm_dev);
+	rproc_srm_dev_clocks_put(rproc_srm_dev);
+	return ret;
+}
+
+static int rproc_srm_dev_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rproc_srm_dev *rproc_srm_dev = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	component_del(dev, &rproc_srm_dev_ops);
+
+	rproc_srm_core_unregister_notifier(rproc_srm_dev->core,
+					   &rproc_srm_dev->nb);
+
+	rproc_srm_dev_irqs_put(rproc_srm_dev);
+	rproc_srm_dev_regus_put(rproc_srm_dev);
+	rproc_srm_dev_clocks_put(rproc_srm_dev);
+
+	return 0;
+}
+
+static const struct of_device_id rproc_srm_dev_match[] = {
+	{ .compatible = "rproc-srm-dev", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, rproc_srm_dev_match);
+
+static struct platform_driver rproc_srm_dev_driver = {
+	.probe = rproc_srm_dev_probe,
+	.remove = rproc_srm_dev_remove,
+	.driver = {
+		.name = "rproc-srm-dev",
+		.of_match_table = of_match_ptr(rproc_srm_dev_match),
+	},
+};
+
+module_platform_driver(rproc_srm_dev_driver);
+
+MODULE_AUTHOR("Fabien Dessenne <fabien.dessenne@st.com>");
+MODULE_DESCRIPTION("Remoteproc System Resource Manager driver - dev");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/remoteproc/stm32_rproc.c b/drivers/remoteproc/stm32_rproc.c
index b643efcf9..c26501821 100644
--- a/drivers/remoteproc/stm32_rproc.c
+++ b/drivers/remoteproc/stm32_rproc.c
@@ -20,12 +20,11 @@
 #include <linux/remoteproc.h>
 #include <linux/reset.h>
 #include <linux/slab.h>
+#include <linux/tee_remoteproc.h>
 #include <linux/workqueue.h>
 
 #include "remoteproc_internal.h"
-
-#define HOLD_BOOT		0
-#define RELEASE_BOOT		1
+#include "remoteproc_elf_helpers.h"
 
 #define MBOX_NB_VQ		2
 #define MBOX_NB_MBX		4
@@ -40,14 +39,33 @@
 #define STM32_MBX_SHUTDOWN	"shutdown"
 #define STM32_MBX_DETACH	"detach"
 
-#define RSC_TBL_SIZE		1024
+#define RSC_TBL_SIZE		1024UL
+
+#define CM_STATE_OFF		0
+#define CM_STATE_INI		1
+#define CM_STATE_CRUN		2
+#define CM_STATE_CSTOP		3
+#define CM_STATE_STANDBY	4
+#define CM_STATE_CRASH		5
+
+/* PWR_CPU2D2SR register definitions */
+#define M33_STATE_FIELD_SHIFT   2
+#define M33_STATE_FIELD_MASK    0x3
 
-#define M4_STATE_OFF		0
-#define M4_STATE_INI		1
-#define M4_STATE_CRUN		2
-#define M4_STATE_CSTOP		3
-#define M4_STATE_STANDBY	4
-#define M4_STATE_CRASH		5
+#define M33_STATE_OFF		0
+#define M33_STATE_CRUN		1
+#define M33_STATE_CSLEEP	2
+#define M33_STATE_CSTOP		3
+
+/*
+ * Define a default index in future may come a global list of
+ * firmwares which list platforms and associated firmware(s)
+ */
+
+#define STM32_MP1_FW_ID    0
+#define STM32_MP2_FW_ID    1
+
+struct stm32_rproc;
 
 struct stm32_syscon {
 	struct regmap *map;
@@ -63,6 +81,11 @@ struct stm32_rproc_mem {
 	size_t size;
 };
 
+struct stm32_rproc_data {
+	int fw_id;
+	int (*get_status)(struct stm32_rproc *ddata, unsigned int *state);
+};
+
 struct stm32_rproc_mem_ranges {
 	u32 dev_addr;
 	u32 bus_addr;
@@ -79,25 +102,83 @@ struct stm32_mbox {
 
 struct stm32_rproc {
 	struct reset_control *rst;
-	struct stm32_syscon hold_boot;
+	struct reset_control *hold_boot;
 	struct stm32_syscon pdds;
-	struct stm32_syscon m4_state;
+	struct stm32_syscon cm_state;
 	struct stm32_syscon rsctbl;
+	struct stm32_syscon boot_vec;
 	int wdg_irq;
 	u32 nb_rmems;
 	struct stm32_rproc_mem *rmems;
 	struct stm32_mbox mb[MBOX_NB_MBX];
 	struct workqueue_struct *workqueue;
-	bool secured_soc;
+	bool fw_loaded;
+	struct tee_rproc *trproc;
+	const struct stm32_rproc_data *desc;
 	void __iomem *rsc_va;
 };
 
+static u64 stm32_rproc_get_vect_table(struct rproc *rproc, const struct firmware *fw)
+{
+	struct device *dev = rproc->dev.parent;
+	struct stm32_rproc *ddata = rproc->priv;
+	const void *shdr, *name_table_shdr;
+	const char *name_table;
+	const u8 *elf_data = (void *)fw->data;
+	const void *ehdr = elf_data;
+	size_t fw_size = fw->size;
+	int i;
+	u8 class = fw_elf_get_class(fw);
+	u32 elf_shdr_get_size = elf_size_of_shdr(class);
+	u16 shnum = elf_hdr_get_e_shnum(class, ehdr);
+	u16 shstrndx = elf_hdr_get_e_shstrndx(class, ehdr);
+
+	/*
+	 * If the platform does not support the boot address configuration set the boot address
+	 * to 0.
+	 */
+	if (!ddata->boot_vec.map)
+		return 0;
+
+	/* Look for the vector table */
+	/* First, get the section header according to the elf class */
+	shdr = elf_data + elf_hdr_get_e_shoff(class, ehdr);
+	/* Compute name table section header entry in shdr array */
+	name_table_shdr = shdr + (shstrndx * elf_shdr_get_size);
+	/* Finally, compute the name table section address in elf */
+	name_table = elf_data + elf_shdr_get_sh_offset(class, name_table_shdr);
+
+	for (i = 0; i < shnum; i++, shdr += elf_shdr_get_size) {
+		u64 size = elf_shdr_get_sh_size(class, shdr);
+		u64 offset = elf_shdr_get_sh_offset(class, shdr);
+		u32 name = elf_shdr_get_sh_name(class, shdr);
+
+		if (strcmp(name_table + name, ".isr_vectors"))
+			continue;
+
+		/* make sure we have the entire table */
+		if (offset + size > fw_size || offset + size < size) {
+			dev_err(dev, "vector table truncated\n");
+			return 0;
+		}
+
+		return elf_shdr_get_sh_addr(class, shdr);
+	}
+
+	return 0;
+}
+
 static int stm32_rproc_pa_to_da(struct rproc *rproc, phys_addr_t pa, u64 *da)
 {
 	unsigned int i;
 	struct stm32_rproc *ddata = rproc->priv;
 	struct stm32_rproc_mem *p_mem;
 
+	if (!ddata->rmems) {
+		*da = pa;
+		return 0;
+	}
+
 	for (i = 0; i < ddata->nb_rmems; i++) {
 		p_mem = &ddata->rmems[i];
 
@@ -118,10 +199,10 @@ static int stm32_rproc_mem_alloc(struct rproc *rproc,
 	struct device *dev = rproc->dev.parent;
 	void *va;
 
-	dev_dbg(dev, "map memory: %pa+%x\n", &mem->dma, mem->len);
+	dev_dbg(dev, "map memory: %pa+%zu\n", &mem->dma, mem->len);
 	va = ioremap_wc(mem->dma, mem->len);
 	if (IS_ERR_OR_NULL(va)) {
-		dev_err(dev, "Unable to map memory region: %pa+%x\n",
+		dev_err(dev, "Unable to map memory region: %pa+%zu\n",
 			&mem->dma, mem->len);
 		return -ENOMEM;
 	}
@@ -155,11 +236,19 @@ static int stm32_rproc_of_memory_translations(struct platform_device *pdev,
 
 	cnt = of_property_count_elems_of_size(np, "dma-ranges",
 					      sizeof(*mem_range));
-	if (cnt <= 0) {
+	if (cnt < 0) {
 		dev_err(dev, "%s: dma-ranges property not defined\n", __func__);
 		return -EINVAL;
 	}
 
+	if (!cnt) {
+		/*  If dma-ranges is empty no memory translation requested. */
+		dev_dbg(dev, "no memory translation\n");
+		ddata->rmems = NULL;
+		ddata->nb_rmems = 0;
+		return 0;
+	}
+
 	p_mems = devm_kcalloc(dev, cnt, sizeof(*p_mems), GFP_KERNEL);
 	if (!p_mems)
 		return -ENOMEM;
@@ -208,6 +297,139 @@ static int stm32_rproc_mbox_idx(struct rproc *rproc, const unsigned char *name)
 	return -EINVAL;
 }
 
+static void stm32_rproc_request_shutdown(struct rproc *rproc)
+{
+	struct stm32_rproc *ddata = rproc->priv;
+	int err, dummy_data, idx;
+
+	/* Request shutdown of the remote processor */
+	if (rproc->state != RPROC_OFFLINE && rproc->state != RPROC_CRASHED) {
+		idx = stm32_rproc_mbox_idx(rproc, STM32_MBX_SHUTDOWN);
+		if (idx >= 0 && ddata->mb[idx].chan) {
+			/* A dummy data is sent to allow to block on transmit. */
+			err = mbox_send_message(ddata->mb[idx].chan,
+						&dummy_data);
+			if (err < 0)
+				dev_warn(&rproc->dev, "warning: remote FW shutdown without ack\n");
+		}
+	}
+}
+
+static int stm32_rproc_release(struct rproc *rproc)
+{
+	struct stm32_rproc *ddata = rproc->priv;
+	unsigned int err = 0;
+
+	/* To allow platform Standby power mode, set remote proc Deep Sleep. */
+	if (ddata->pdds.map) {
+		err = regmap_update_bits(ddata->pdds.map, ddata->pdds.reg,
+					 ddata->pdds.mask, 1);
+		if (err) {
+			dev_err(&rproc->dev, "failed to set pdds\n");
+			return err;
+		}
+	}
+
+	/* Update coprocessor state to OFF if available. */
+	if (ddata->desc->fw_id == STM32_MP1_FW_ID && ddata->cm_state.map) {
+		err = regmap_update_bits(ddata->cm_state.map,
+					 ddata->cm_state.reg,
+					 ddata->cm_state.mask,
+					 CM_STATE_OFF);
+		if (err) {
+			dev_err(&rproc->dev, "failed to set copro state\n");
+			return err;
+		}
+	}
+
+	return err;
+}
+
+static int stm32_rproc_tee_elf_sanity_check(struct rproc *rproc,
+					    const struct firmware *fw)
+{
+	struct stm32_rproc *ddata = rproc->priv;
+	unsigned int ret = 0;
+
+	if (rproc->state == RPROC_DETACHED)
+		return 0;
+
+	ret = tee_rproc_load_fw(ddata->trproc, fw);
+	if (!ret)
+		ddata->fw_loaded = true;
+
+	return ret;
+}
+
+static int stm32_rproc_tee_elf_load(struct rproc *rproc,
+				    const struct firmware *fw)
+{
+	struct stm32_rproc *ddata = rproc->priv;
+	unsigned int ret;
+
+	/*
+	 * This function can be called by remote proc for recovery
+	 * without the sanity check. In this case we need to load the firmware
+	 * else nothing done here as the firmware has been preloaded for the
+	 * sanity check to be able to parse it for the resource table
+	 */
+	if (ddata->fw_loaded)
+		return 0;
+
+	ret =  tee_rproc_load_fw(ddata->trproc, fw);
+	if (ret)
+		return ret;
+	ddata->fw_loaded = true;
+
+	/* update the resource table parameters */
+	if (rproc_tee_get_rsc_table(ddata->trproc)) {
+		/* no resource table: reset the related fields */
+		rproc->cached_table = NULL;
+		rproc->table_ptr = NULL;
+		rproc->table_sz = 0;
+	}
+
+	return 0;
+}
+
+static struct resource_table *
+stm32_rproc_tee_elf_find_loaded_rsc_table(struct rproc *rproc,
+					  const struct firmware *fw)
+{
+	struct stm32_rproc *ddata = rproc->priv;
+
+	return tee_rproc_get_loaded_rsc_table(ddata->trproc);
+}
+
+static int stm32_rproc_tee_start(struct rproc *rproc)
+{
+	struct stm32_rproc *ddata = rproc->priv;
+
+	return tee_rproc_start(ddata->trproc);
+}
+
+static int stm32_rproc_tee_attach(struct rproc *rproc)
+{
+	/* Nothing to do, remote proc already started by the secured context */
+	return 0;
+}
+
+static int stm32_rproc_tee_stop(struct rproc *rproc)
+{
+	struct stm32_rproc *ddata = rproc->priv;
+	int err;
+
+	stm32_rproc_request_shutdown(rproc);
+
+	err = tee_rproc_stop(ddata->trproc);
+	if (err)
+		return err;
+
+	ddata->fw_loaded = false;
+
+	return stm32_rproc_release(rproc);
+}
+
 static int stm32_rproc_prepare(struct rproc *rproc)
 {
 	struct device *dev = rproc->dev.parent;
@@ -266,7 +488,14 @@ static int stm32_rproc_prepare(struct rproc *rproc)
 
 static int stm32_rproc_parse_fw(struct rproc *rproc, const struct firmware *fw)
 {
-	if (rproc_elf_load_rsc_table(rproc, fw))
+	struct stm32_rproc *ddata = rproc->priv;
+	int ret;
+
+	if (ddata->trproc)
+		ret = rproc_tee_get_rsc_table(ddata->trproc);
+	else
+		ret = rproc_elf_load_rsc_table(rproc, fw);
+	if (ret)
 		dev_warn(&rproc->dev, "no resource table found for this firmware\n");
 
 	return 0;
@@ -394,30 +623,6 @@ static int stm32_rproc_request_mbox(struct rproc *rproc)
 	return -EPROBE_DEFER;
 }
 
-static int stm32_rproc_set_hold_boot(struct rproc *rproc, bool hold)
-{
-	struct stm32_rproc *ddata = rproc->priv;
-	struct stm32_syscon hold_boot = ddata->hold_boot;
-	struct arm_smccc_res smc_res;
-	int val, err;
-
-	val = hold ? HOLD_BOOT : RELEASE_BOOT;
-
-	if (IS_ENABLED(CONFIG_HAVE_ARM_SMCCC) && ddata->secured_soc) {
-		arm_smccc_smc(STM32_SMC_RCC, STM32_SMC_REG_WRITE,
-			      hold_boot.reg, val, 0, 0, 0, 0, &smc_res);
-		err = smc_res.a0;
-	} else {
-		err = regmap_update_bits(hold_boot.map, hold_boot.reg,
-					 hold_boot.mask, val);
-	}
-
-	if (err)
-		dev_err(&rproc->dev, "failed to set hold boot\n");
-
-	return err;
-}
-
 static void stm32_rproc_add_coredump_trace(struct rproc *rproc)
 {
 	struct rproc_debug_trace *trace;
@@ -457,18 +662,36 @@ static int stm32_rproc_start(struct rproc *rproc)
 		}
 	}
 
-	err = stm32_rproc_set_hold_boot(rproc, false);
+	/* Configure the boot vector register with the vector table address read in the ELF. */
+	if (ddata->boot_vec.map) {
+		if (rproc->bootaddr & ~ddata->boot_vec.mask) {
+			dev_err(&rproc->dev, "Boot address is %#llx no aligned on mask %#x\n",
+				rproc->bootaddr, ddata->boot_vec.mask);
+			return err;
+		}
+		dev_dbg(&rproc->dev, "boot vector address = %#llx", rproc->bootaddr);
+		err = regmap_update_bits(ddata->boot_vec.map, ddata->boot_vec.reg,
+					 ddata->boot_vec.mask, rproc->bootaddr);
+		if (err) {
+			dev_err(&rproc->dev, "failed to set boot_vec\n");
+				return err;
+		}
+	}
+
+	err = reset_control_deassert(ddata->hold_boot);
 	if (err)
 		return err;
 
-	return stm32_rproc_set_hold_boot(rproc, true);
+	return reset_control_assert(ddata->hold_boot);
 }
 
 static int stm32_rproc_attach(struct rproc *rproc)
 {
+	struct stm32_rproc *ddata = rproc->priv;
+
 	stm32_rproc_add_coredump_trace(rproc);
 
-	return stm32_rproc_set_hold_boot(rproc, true);
+	return reset_control_assert(ddata->hold_boot);
 }
 
 static int stm32_rproc_detach(struct rproc *rproc)
@@ -485,27 +708,21 @@ static int stm32_rproc_detach(struct rproc *rproc)
 	}
 
 	/* Allow remote processor to auto-reboot */
-	return stm32_rproc_set_hold_boot(rproc, false);
+	return reset_control_deassert(ddata->hold_boot);
 }
 
 static int stm32_rproc_stop(struct rproc *rproc)
 {
 	struct stm32_rproc *ddata = rproc->priv;
-	int err, idx;
+	int err;
 
-	/* request shutdown of the remote processor */
-	if (rproc->state != RPROC_OFFLINE) {
-		idx = stm32_rproc_mbox_idx(rproc, STM32_MBX_SHUTDOWN);
-		if (idx >= 0 && ddata->mb[idx].chan) {
-			err = mbox_send_message(ddata->mb[idx].chan, "detach");
-			if (err < 0)
-				dev_warn(&rproc->dev, "warning: remote FW shutdown without ack\n");
-		}
-	}
+	stm32_rproc_request_shutdown(rproc);
 
-	err = stm32_rproc_set_hold_boot(rproc, true);
-	if (err)
+	err = reset_control_assert(ddata->hold_boot);
+	if (err) {
+		dev_err(&rproc->dev, "failed to assert the hold boot\n");
 		return err;
+	}
 
 	err = reset_control_assert(ddata->rst);
 	if (err) {
@@ -513,29 +730,8 @@ static int stm32_rproc_stop(struct rproc *rproc)
 		return err;
 	}
 
-	/* to allow platform Standby power mode, set remote proc Deep Sleep */
-	if (ddata->pdds.map) {
-		err = regmap_update_bits(ddata->pdds.map, ddata->pdds.reg,
-					 ddata->pdds.mask, 1);
-		if (err) {
-			dev_err(&rproc->dev, "failed to set pdds\n");
-			return err;
-		}
-	}
-
-	/* update coprocessor state to OFF if available */
-	if (ddata->m4_state.map) {
-		err = regmap_update_bits(ddata->m4_state.map,
-					 ddata->m4_state.reg,
-					 ddata->m4_state.mask,
-					 M4_STATE_OFF);
-		if (err) {
-			dev_err(&rproc->dev, "failed to set copro state\n");
-			return err;
-		}
-	}
 
-	return 0;
+	return stm32_rproc_release(rproc);
 }
 
 static void stm32_rproc_kick(struct rproc *rproc, int vqid)
@@ -568,6 +764,12 @@ static int stm32_rproc_da_to_pa(struct rproc *rproc,
 	struct stm32_rproc_mem *p_mem;
 	unsigned int i;
 
+
+	if (!ddata->rmems) {
+		*pa = da;
+		return 0;
+	}
+
 	for (i = 0; i < ddata->nb_rmems; i++) {
 		p_mem = &ddata->rmems[i];
 
@@ -644,11 +846,90 @@ static const struct rproc_ops st_rproc_ops = {
 	.find_loaded_rsc_table = rproc_elf_find_loaded_rsc_table,
 	.get_loaded_rsc_table = stm32_rproc_get_loaded_rsc_table,
 	.sanity_check	= rproc_elf_sanity_check,
-	.get_boot_addr	= rproc_elf_get_boot_addr,
+	.get_boot_addr = stm32_rproc_get_vect_table,
+};
+
+static const struct rproc_ops st_rproc_tee_ops = {
+	.prepare	= stm32_rproc_prepare,
+	.start		= stm32_rproc_tee_start,
+	.stop		= stm32_rproc_tee_stop,
+	.attach		= stm32_rproc_tee_attach,
+	.kick		= stm32_rproc_kick,
+	.parse_fw	= stm32_rproc_parse_fw,
+	.find_loaded_rsc_table = stm32_rproc_tee_elf_find_loaded_rsc_table,
+	.get_loaded_rsc_table = stm32_rproc_get_loaded_rsc_table,
+	.sanity_check	= stm32_rproc_tee_elf_sanity_check,
+	.load		= stm32_rproc_tee_elf_load,
+};
+
+static int stm32_rproc_get_m4_status(struct stm32_rproc *ddata,
+				     unsigned int *state)
+{
+	/* See stm32_rproc_parse_dt() */
+	if (!ddata->cm_state.map) {
+		/*
+		 * We couldn't get the coprocessor's state, assume
+		 * it is not running.
+		 */
+		*state = CM_STATE_OFF;
+		return 0;
+	}
+
+	return regmap_read(ddata->cm_state.map, ddata->cm_state.reg, state);
+}
+
+static int stm32_rproc_get_m33_status(struct stm32_rproc *ddata,
+				      unsigned int *state)
+{
+	int ret;
+	unsigned int cm_state;
+
+	if (!ddata->cm_state.map) {
+		/*
+		 * We couldn't get the coprocessor's state, assume
+		 * it is not running.
+		 */
+		*state = CM_STATE_OFF;
+		return 0;
+	}
+
+	ret = regmap_read(ddata->cm_state.map, ddata->cm_state.reg, &cm_state);
+	if (ret)
+		return ret;
+
+	switch ((cm_state >> M33_STATE_FIELD_SHIFT) & M33_STATE_FIELD_MASK) {
+	case M33_STATE_OFF:
+		*state = CM_STATE_OFF;
+		break;
+	case M33_STATE_CRUN:
+		*state = CM_STATE_CRUN;
+		break;
+	case M33_STATE_CSLEEP:
+		*state = CM_STATE_STANDBY;
+		break;
+	case M33_STATE_CSTOP:
+		*state = CM_STATE_CSTOP;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct stm32_rproc_data stm32_rproc_stm32pm15 = {
+	.fw_id = STM32_MP1_FW_ID,
+	.get_status = stm32_rproc_get_m4_status,
+};
+
+static const struct stm32_rproc_data stm32_rproc_stm32pm25 = {
+	.fw_id = STM32_MP2_FW_ID,
+	.get_status = stm32_rproc_get_m33_status,
 };
 
 static const struct of_device_id stm32_rproc_match[] = {
-	{ .compatible = "st,stm32mp1-m4" },
+	{.compatible = "st,stm32mp1-m4", .data = &stm32_rproc_stm32pm15},
+	{.compatible = "st,stm32mp2-m33", .data = &stm32_rproc_stm32pm25},
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32_rproc_match);
@@ -680,8 +961,6 @@ static int stm32_rproc_parse_dt(struct platform_device *pdev,
 {
 	struct device *dev = &pdev->dev;
 	struct device_node *np = dev->of_node;
-	struct stm32_syscon tz;
-	unsigned int tzen;
 	int err, irq;
 
 	irq = platform_get_irq(pdev, 0);
@@ -705,39 +984,19 @@ static int stm32_rproc_parse_dt(struct platform_device *pdev,
 		dev_info(dev, "wdg irq registered\n");
 	}
 
-	ddata->rst = devm_reset_control_get_by_index(dev, 0);
+	ddata->rst = devm_reset_control_get(dev, "mcu_rst");
 	if (IS_ERR(ddata->rst))
 		return dev_err_probe(dev, PTR_ERR(ddata->rst),
 				     "failed to get mcu_reset\n");
 
-	/*
-	 * if platform is secured the hold boot bit must be written by
-	 * smc call and read normally.
-	 * if not secure the hold boot bit could be read/write normally
-	 */
-	err = stm32_rproc_get_syscon(np, "st,syscfg-tz", &tz);
-	if (err) {
-		dev_err(dev, "failed to get tz syscfg\n");
-		return err;
-	}
-
-	err = regmap_read(tz.map, tz.reg, &tzen);
-	if (err) {
-		dev_err(dev, "failed to read tzen\n");
-		return err;
-	}
-	ddata->secured_soc = tzen & tz.mask;
-
-	err = stm32_rproc_get_syscon(np, "st,syscfg-holdboot",
-				     &ddata->hold_boot);
-	if (err) {
-		dev_err(dev, "failed to get hold boot\n");
-		return err;
-	}
+	ddata->hold_boot = devm_reset_control_get(dev, "hold_boot");
+	if (IS_ERR(ddata->hold_boot))
+		return dev_err_probe(dev, PTR_ERR(ddata->hold_boot),
+				      "failed to get mcu hold boot\n");
 
 	err = stm32_rproc_get_syscon(np, "st,syscfg-pdds", &ddata->pdds);
 	if (err)
-		dev_info(dev, "failed to get pdds\n");
+		dev_info(dev, "pdds sys config not defined\n");
 
 	*auto_boot = of_property_read_bool(np, "st,auto-boot");
 
@@ -745,11 +1004,11 @@ static int stm32_rproc_parse_dt(struct platform_device *pdev,
 	 * See if we can check the M4 status, i.e if it was started
 	 * from the boot loader or not.
 	 */
-	err = stm32_rproc_get_syscon(np, "st,syscfg-m4-state",
-				     &ddata->m4_state);
+	err = stm32_rproc_get_syscon(np, "st,syscfg-cm-state",
+				     &ddata->cm_state);
 	if (err) {
 		/* remember this */
-		ddata->m4_state.map = NULL;
+		ddata->cm_state.map = NULL;
 		/* no coprocessor state syscon (optional) */
 		dev_warn(dev, "m4 state not supported\n");
 
@@ -768,56 +1027,83 @@ static int stm32_rproc_parse_dt(struct platform_device *pdev,
 	return 0;
 }
 
-static int stm32_rproc_get_m4_status(struct stm32_rproc *ddata,
-				     unsigned int *state)
-{
-	/* See stm32_rproc_parse_dt() */
-	if (!ddata->m4_state.map) {
-		/*
-		 * We couldn't get the coprocessor's state, assume
-		 * it is not running.
-		 */
-		*state = M4_STATE_OFF;
-		return 0;
-	}
-
-	return regmap_read(ddata->m4_state.map, ddata->m4_state.reg, state);
-}
-
 static int stm32_rproc_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct stm32_rproc *ddata;
 	struct device_node *np = dev->of_node;
+	const struct stm32_rproc_data *desc;
+	struct tee_rproc *trproc = NULL;
 	struct rproc *rproc;
+	struct stm32_syscon boot_vec;
 	unsigned int state;
 	int ret;
 
+	desc = device_get_match_data(&pdev->dev);
+
 	ret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));
 	if (ret)
 		return ret;
 
-	rproc = rproc_alloc(dev, np->name, &st_rproc_ops, NULL, sizeof(*ddata));
-	if (!rproc)
-		return -ENOMEM;
+	/*
+	 * If the "st,syscfg-nsvtor" property is defined in DT, the Linux
+	 * remoteproc driver expects to load the firmware. In this case we don't
+	 * verify if we have to delegate the firmware management to the
+	 * secure context. Exception should be raised on secure context side in case
+	 * of issue.
+	 */
+	ret = stm32_rproc_get_syscon(np, "st,syscfg-nsvtor", &boot_vec);
+	if (ret)
+		dev_dbg(dev, "nsvector sys config not defined\n");
+
+	if (!boot_vec.map)
+		trproc = tee_rproc_register(dev, desc->fw_id);
+	if (IS_ERR(trproc)) {
+		if (PTR_ERR(trproc) == -EPROBE_DEFER)
+			return PTR_ERR(trproc);
+		trproc = NULL;
+	}
 
-	ddata = rproc->priv;
+	rproc = rproc_alloc(dev, np->name,
+			    trproc ? &st_rproc_tee_ops : &st_rproc_ops,
+			    NULL, sizeof(*ddata));
+	if (!rproc) {
+		ret = -ENOMEM;
+		goto free_tee;
+	}
 
-	rproc_coredump_set_elf_info(rproc, ELFCLASS32, EM_NONE);
+	ddata = rproc->priv;
+	ddata->desc = desc;
+	ddata->trproc = trproc;
+	ddata->boot_vec = boot_vec;
 
 	ret = stm32_rproc_parse_dt(pdev, ddata, &rproc->auto_boot);
 	if (ret)
 		goto free_rproc;
 
+	if (trproc) {
+		/*
+		 * Delegate the firmware management to the secure context. The
+		 * firmware loaded has to be signed.
+		 */
+		dev_info(dev, "Support of signed firmware only\n");
+		rproc->fw_format = RPROC_FW_TEE;
+		trproc->rproc = rproc;
+	} else {
+		rproc->fw_format = RPROC_FW_ELF;
+	}
+
+	rproc_coredump_set_elf_info(rproc, ELFCLASS32, EM_NONE);
+
 	ret = stm32_rproc_of_memory_translations(pdev, ddata);
 	if (ret)
 		goto free_rproc;
 
-	ret = stm32_rproc_get_m4_status(ddata, &state);
+	ret = ddata->desc->get_status(ddata, &state);
 	if (ret)
 		goto free_rproc;
 
-	if (state == M4_STATE_CRUN)
+	if (state != CM_STATE_OFF)
 		rproc->state = RPROC_DETACHED;
 
 	rproc->has_iommu = false;
@@ -852,6 +1138,10 @@ static int stm32_rproc_probe(struct platform_device *pdev)
 		device_init_wakeup(dev, false);
 	}
 	rproc_free(rproc);
+free_tee:
+	if (trproc)
+		tee_rproc_unregister(trproc);
+
 	return ret;
 }
 
@@ -873,10 +1163,21 @@ static int stm32_rproc_remove(struct platform_device *pdev)
 		device_init_wakeup(dev, false);
 	}
 	rproc_free(rproc);
+	if (ddata->trproc)
+		tee_rproc_unregister(ddata->trproc);
 
 	return 0;
 }
 
+static void stm32_rproc_shutdown(struct platform_device *pdev)
+{
+	struct rproc *rproc = platform_get_drvdata(pdev);
+
+	if (atomic_read(&rproc->power) > 0)
+		dev_warn(&pdev->dev,
+			 "Warning: remote fw is still running with possible side effect!!!\n");
+}
+
 static int __maybe_unused stm32_rproc_suspend(struct device *dev)
 {
 	struct rproc *rproc = dev_get_drvdata(dev);
@@ -905,6 +1206,7 @@ static SIMPLE_DEV_PM_OPS(stm32_rproc_pm_ops,
 static struct platform_driver stm32_rproc_driver = {
 	.probe = stm32_rproc_probe,
 	.remove = stm32_rproc_remove,
+	.shutdown = stm32_rproc_shutdown,
 	.driver = {
 		.name = "stm32-rproc",
 		.pm = &stm32_rproc_pm_ops,
diff --git a/drivers/remoteproc/tee_remoteproc.c b/drivers/remoteproc/tee_remoteproc.c
new file mode 100644
index 000000000..c4798bc5f
--- /dev/null
+++ b/drivers/remoteproc/tee_remoteproc.c
@@ -0,0 +1,385 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) STMicroelectronics 2020 - All Rights Reserved
+ * Authors: Arnaud Pouliquen <arnaud.pouliquen@st.com>
+ */
+
+#include <linux/firmware.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/remoteproc.h>
+#include <linux/slab.h>
+#include <linux/tee_drv.h>
+#include <linux/tee_remoteproc.h>
+
+#include "remoteproc_internal.h"
+
+#define MAX_TEE_PARAM_ARRY_MEMBER	4
+
+/*
+ * Authentication of the firmware and load in the remote processor memory
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ * [in]	 params[1].memref:	buffer containing the image of the buffer
+ */
+#define TA_RPROC_FW_CMD_LOAD_FW		1
+
+/*
+ * start the remote processor
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ */
+#define TA_RPROC_FW_CMD_START_FW	2
+
+/*
+ * stop the remote processor
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ */
+#define TA_RPROC_FW_CMD_STOP_FW		3
+
+/*
+ * return the address of the resource table, or 0 if not found
+ * No chech is done to verify that the address returned is accessible by
+ * the non secure context. If the resource table is loaded in a protected
+ * memory the acces by the non secure context will lead to a data abort.
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ * [out]  params[1].value.a:	32bit LSB resource table memory address
+ * [out]  params[1].value.b:	32bit MSB resource table memory address
+ * [out]  params[2].value.a:	32bit LSB resource table memory size
+ * [out]  params[2].value.b:	32bit MSB resource table memory size
+ */
+#define TA_RPROC_FW_CMD_GET_RSC_TABLE	4
+
+/*
+ * return the address of the core dump
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ * [out] params[1].memref:	address of the core dump image if exist,
+ *				else return Null
+ */
+#define TA_RPROC_FW_CMD_GET_COREDUMP	5
+
+struct tee_rproc_mem {
+	char name[20];
+	void __iomem *cpu_addr;
+	phys_addr_t bus_addr;
+	u32 dev_addr;
+	size_t size;
+};
+
+struct tee_rproc_context {
+	struct list_head sessions;
+	struct tee_context *ctx;
+	struct device *dev;
+};
+
+struct tee_rproc_context pvt_data;
+
+static void prepare_args(struct tee_rproc *trproc, int cmd,
+			 struct tee_ioctl_invoke_arg *arg,
+			 struct tee_param *param, unsigned int num_params)
+{
+	memset(arg, 0, sizeof(*arg));
+	memset(param, 0, MAX_TEE_PARAM_ARRY_MEMBER * sizeof(*param));
+
+	arg->func = cmd;
+	arg->session = trproc->session_id;
+	arg->num_params = num_params + 1;
+
+	param[0] = (struct tee_param) {
+		.attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT,
+		.u.value.a = trproc->fw_id,
+	};
+}
+
+int tee_rproc_load_fw(struct tee_rproc *trproc, const struct firmware *fw)
+{
+	struct tee_ioctl_invoke_arg arg;
+	struct tee_param param[MAX_TEE_PARAM_ARRY_MEMBER];
+	struct tee_shm *fw_shm;
+	int ret;
+
+	/*
+	 * useless copy waiting that tee_shm_register and tee well support
+	 * kernel buffers registration
+	 */
+
+	fw_shm = tee_shm_alloc(pvt_data.ctx, fw->size,
+			       TEE_SHM_MAPPED | TEE_SHM_DMA_BUF);
+	if (IS_ERR(fw_shm))
+		return PTR_ERR(fw_shm);
+
+	memcpy(tee_shm_get_va(fw_shm, 0), fw->data, fw->size);
+
+	prepare_args(trproc, TA_RPROC_FW_CMD_LOAD_FW, &arg, param, 1);
+
+	/* provide the address of the firmware image */
+	param[1] = (struct tee_param) {
+		.attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT,
+		.u.memref = {
+			.shm = fw_shm,
+			.size = fw->size,
+			.shm_offs = 0,
+		},
+	};
+
+	ret = tee_client_invoke_func(pvt_data.ctx, &arg, param);
+	if (ret < 0 || arg.ret != 0) {
+		dev_err(pvt_data.dev,
+			"TA_RPROC_FW_CMD_LOAD_FW invoke failed TEE err: %x, ret:%x\n",
+			arg.ret, ret);
+		if (!ret)
+			ret = -EIO;
+	}
+
+	tee_shm_free(fw_shm);
+
+	return ret;
+}
+EXPORT_SYMBOL(tee_rproc_load_fw);
+
+int rproc_tee_get_rsc_table(struct tee_rproc *trproc)
+{
+	struct tee_ioctl_invoke_arg arg;
+	struct tee_param param[MAX_TEE_PARAM_ARRY_MEMBER];
+	struct rproc *rproc = trproc->rproc;
+	size_t rsc_size;
+	int ret;
+
+	prepare_args(trproc, TA_RPROC_FW_CMD_GET_RSC_TABLE, &arg, param, 2);
+
+	param[1].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT;
+	param[2].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT;
+
+	ret = tee_client_invoke_func(pvt_data.ctx, &arg, param);
+	if (ret < 0 || arg.ret != 0) {
+		dev_err(pvt_data.dev,
+			"TA_RPROC_FW_CMD_GET_RSC_TABLE invoke failed TEE err: %x, ret:%x\n",
+			arg.ret, ret);
+		return -EIO;
+	}
+
+	rsc_size = param[2].u.value.a;
+
+	/*
+	 * Store the resource table address that would be updated by the remote
+	 * core and the virtio.
+	 */
+	trproc->rsc_va = ioremap_wc(param[1].u.value.a, rsc_size);
+	if (IS_ERR_OR_NULL(trproc->rsc_va)) {
+		dev_err(pvt_data.dev, "Unable to map memory region: %lld+%zx\n",
+			param[1].u.value.a, rsc_size);
+		trproc->rsc_va = NULL;
+		return -ENOMEM;
+	}
+
+	/*
+	 * A cached table is requested as the physical address is not mapped yet
+	 * but remoteproc need to parse the table for resources.
+	 */
+	rproc->cached_table = kmemdup(trproc->rsc_va, rsc_size, GFP_KERNEL);
+	if (!rproc->cached_table)
+		return -ENOMEM;
+
+	rproc->table_ptr = rproc->cached_table;
+	rproc->table_sz = rsc_size;
+
+	return 0;
+}
+EXPORT_SYMBOL(rproc_tee_get_rsc_table);
+
+struct resource_table *tee_rproc_get_loaded_rsc_table(struct tee_rproc *trproc)
+{
+	return (struct resource_table *)trproc->rsc_va;
+}
+EXPORT_SYMBOL(tee_rproc_get_loaded_rsc_table);
+
+int tee_rproc_start(struct tee_rproc *trproc)
+{
+	struct tee_ioctl_invoke_arg arg;
+	struct tee_param param[MAX_TEE_PARAM_ARRY_MEMBER];
+	int ret;
+
+	prepare_args(trproc, TA_RPROC_FW_CMD_START_FW, &arg, param, 0);
+
+	ret = tee_client_invoke_func(pvt_data.ctx, &arg, param);
+	if (ret < 0 || arg.ret != 0) {
+		dev_err(pvt_data.dev,
+			"TA_RPROC_FW_CMD_START_FW invoke failed TEE err: %x, ret:%x\n",
+			arg.ret, ret);
+		if (!ret)
+			ret = -EIO;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(tee_rproc_start);
+
+int tee_rproc_stop(struct tee_rproc *trproc)
+{
+	struct tee_ioctl_invoke_arg arg;
+	struct tee_param param[MAX_TEE_PARAM_ARRY_MEMBER];
+	int ret;
+
+	prepare_args(trproc, TA_RPROC_FW_CMD_STOP_FW, &arg, param, 0);
+
+	ret = tee_client_invoke_func(pvt_data.ctx, &arg, param);
+	if (ret < 0 || arg.ret != 0) {
+		dev_err(pvt_data.dev,
+			"TA_RPROC_FW_CMD_STOP_FW invoke failed TEE err: %x, ret:%x\n",
+			arg.ret, ret);
+		if (!ret)
+			ret = -EIO;
+	}
+	if (trproc->rsc_va)
+		iounmap(trproc->rsc_va);
+	trproc->rsc_va = NULL;
+
+	return ret;
+}
+EXPORT_SYMBOL(tee_rproc_stop);
+
+static const struct tee_client_device_id stm32_tee_fw_id_table[] = {
+	{UUID_INIT(0x80a4c275, 0x0a47, 0x4905,
+		   0x82, 0x85, 0x14, 0x86, 0xa9, 0x77, 0x1a, 0x08)},
+	{}
+};
+
+struct tee_rproc *tee_rproc_register(struct device *dev, unsigned int fw_id)
+{
+	struct tee_client_device *rproc_tee_device;
+	struct tee_ioctl_open_session_arg sess_arg;
+	struct tee_param param[MAX_TEE_PARAM_ARRY_MEMBER];
+	struct tee_rproc *trproc;
+	int ret;
+
+	if (!pvt_data.ctx)
+		return ERR_PTR(-ENODEV);
+
+	trproc =  devm_kzalloc(dev, sizeof(*trproc), GFP_KERNEL);
+	if (!trproc)
+		return ERR_PTR(-ENOMEM);
+
+	rproc_tee_device = to_tee_client_device(pvt_data.dev);
+	memset(&sess_arg, 0, sizeof(sess_arg));
+
+	/* Open session with rproc_tee load Trusted App */
+	memcpy(sess_arg.uuid, rproc_tee_device->id.uuid.b, TEE_IOCTL_UUID_LEN);
+
+	/*
+	 * TODO: should we replace TEE_IOCTL_LOGIN_PUBLIC by
+	 * TEE_IOCTL_LOGIN_REE_KERNEL?
+	 */
+	sess_arg.clnt_login = TEE_IOCTL_LOGIN_PUBLIC;
+	sess_arg.num_params = 1;
+
+	param[0] = (struct tee_param) {
+		.attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT,
+		.u.value.a = fw_id,
+	};
+
+
+	ret = tee_client_open_session(pvt_data.ctx, &sess_arg, param);
+	if (ret < 0 || sess_arg.ret != 0) {
+		dev_err(dev, "tee_client_open_session failed, err: %x\n",
+			sess_arg.ret);
+		return ERR_PTR(-EINVAL);
+	}
+
+	trproc->parent =  dev;
+	trproc->fw_id = fw_id;
+	trproc->session_id = sess_arg.session;
+
+	list_add_tail(&trproc->node, &pvt_data.sessions);
+
+	return trproc;
+}
+EXPORT_SYMBOL(tee_rproc_register);
+
+int tee_rproc_unregister(struct tee_rproc *trproc)
+{
+	int ret;
+
+	if (!pvt_data.ctx)
+		return -ENODEV;
+
+	ret = tee_client_close_session(pvt_data.ctx, trproc->session_id);
+	if (ret < 0) {
+		dev_err(trproc->parent,
+			"tee_client_close_session failed, err: %x\n", ret);
+	}
+
+	list_del(&trproc->node);
+
+	return ret;
+}
+EXPORT_SYMBOL(tee_rproc_unregister);
+
+static int tee_ctx_match(struct tee_ioctl_version_data *ver, const void *data)
+{
+	/* Today we support only the OP-TEE, could be extend to other tees */
+	return (ver->impl_id == TEE_IMPL_ID_OPTEE);
+}
+
+static int tee_rproc_probe(struct device *dev)
+{
+	/* Open context with TEE driver */
+	pvt_data.ctx = tee_client_open_context(NULL, tee_ctx_match, NULL,
+					       NULL);
+	if (IS_ERR(pvt_data.ctx))
+		return PTR_ERR(pvt_data.ctx);
+
+	pvt_data.dev = dev;
+	INIT_LIST_HEAD(&pvt_data.sessions);
+
+	return 0;
+}
+
+static int tee_rproc_remove(struct device *dev)
+{
+	struct tee_rproc *entry, *tmp;
+
+	list_for_each_entry_safe(entry, tmp, &pvt_data.sessions, node) {
+		tee_client_close_session(pvt_data.ctx, entry->session_id);
+		list_del(&entry->node);
+		kfree(entry);
+	}
+
+	tee_client_close_context(pvt_data.ctx);
+	return 0;
+}
+
+MODULE_DEVICE_TABLE(tee, stm32_tee_fw_id_table);
+
+static struct tee_client_driver tee_rproc_fw_driver = {
+	.id_table	= stm32_tee_fw_id_table,
+	.driver		= {
+		.name		= KBUILD_MODNAME,
+		.bus		= &tee_bus_type,
+		.probe		= tee_rproc_probe,
+		.remove		= tee_rproc_remove,
+	},
+};
+
+static int __init tee_rproc_fw_mod_init(void)
+{
+	return driver_register(&tee_rproc_fw_driver.driver);
+}
+
+static void __exit tee_rproc_fw_mod_exit(void)
+{
+	driver_unregister(&tee_rproc_fw_driver.driver);
+}
+
+module_init(tee_rproc_fw_mod_init);
+module_exit(tee_rproc_fw_mod_exit);
+
+MODULE_DESCRIPTION("secure remote processor control driver");
+MODULE_AUTHOR("Arnaud Pouliquen <arnaud.pouliquen@st.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/rpmsg/Kconfig b/drivers/rpmsg/Kconfig
index 0b4407abd..d3795860f 100644
--- a/drivers/rpmsg/Kconfig
+++ b/drivers/rpmsg/Kconfig
@@ -15,6 +15,14 @@ config RPMSG_CHAR
 	  in /dev. They make it possible for user-space programs to send and
 	  receive rpmsg packets.
 
+config RPMSG_CTRL
+	tristate "RPMSG control interface"
+	depends on RPMSG && ( RPMSG_CHAR || RPMSG_CHAR=n )
+	help
+	  Say Y here to enable the support of the /dev/rpmsg_ctrlX API. This API
+	  allows user-space programs to create endpoints with specific service name,
+	  source and destination addresses.
+
 config RPMSG_NS
 	tristate "RPMSG name service announcement"
 	depends on RPMSG
diff --git a/drivers/rpmsg/Makefile b/drivers/rpmsg/Makefile
index 8d452656f..58e3b382e 100644
--- a/drivers/rpmsg/Makefile
+++ b/drivers/rpmsg/Makefile
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_RPMSG)		+= rpmsg_core.o
 obj-$(CONFIG_RPMSG_CHAR)	+= rpmsg_char.o
+obj-$(CONFIG_RPMSG_CTRL)	+= rpmsg_ctrl.o
 obj-$(CONFIG_RPMSG_NS)		+= rpmsg_ns.o
 obj-$(CONFIG_RPMSG_MTK_SCP)	+= mtk_rpmsg.o
 qcom_glink-objs			:= qcom_glink_native.o qcom_glink_ssr.o
diff --git a/drivers/rpmsg/qcom_glink_native.c b/drivers/rpmsg/qcom_glink_native.c
index 05533c71b..7d7e80980 100644
--- a/drivers/rpmsg/qcom_glink_native.c
+++ b/drivers/rpmsg/qcom_glink_native.c
@@ -1642,7 +1642,7 @@ static int qcom_glink_create_chrdev(struct qcom_glink *glink)
 	rpdev->dev.parent = glink->dev;
 	rpdev->dev.release = qcom_glink_device_release;
 
-	return rpmsg_chrdev_register_device(rpdev);
+	return rpmsg_ctrldev_register_device(rpdev);
 }
 
 struct qcom_glink *qcom_glink_native_probe(struct device *dev,
diff --git a/drivers/rpmsg/qcom_smd.c b/drivers/rpmsg/qcom_smd.c
index c1c07ff39..b2cd71c35 100644
--- a/drivers/rpmsg/qcom_smd.c
+++ b/drivers/rpmsg/qcom_smd.c
@@ -1113,7 +1113,7 @@ static int qcom_smd_create_chrdev(struct qcom_smd_edge *edge)
 	qsdev->rpdev.dev.parent = &edge->dev;
 	qsdev->rpdev.dev.release = qcom_smd_release_device;
 
-	return rpmsg_chrdev_register_device(&qsdev->rpdev);
+	return rpmsg_ctrldev_register_device(&qsdev->rpdev);
 }
 
 /*
diff --git a/drivers/rpmsg/rpmsg_char.c b/drivers/rpmsg/rpmsg_char.c
index 88c985f9e..29a814eb1 100644
--- a/drivers/rpmsg/rpmsg_char.c
+++ b/drivers/rpmsg/rpmsg_char.c
@@ -1,5 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
+ * Copyright (C) 2022, STMicroelectronics
  * Copyright (c) 2016, Linaro Ltd.
  * Copyright (c) 2012, Michal Simek <monstr@monstr.eu>
  * Copyright (c) 2012, PetaLogix
@@ -22,35 +23,19 @@
 #include <linux/uaccess.h>
 #include <uapi/linux/rpmsg.h>
 
+#include "rpmsg_char.h"
 #include "rpmsg_internal.h"
 
 #define RPMSG_DEV_MAX	(MINORMASK + 1)
 
 static dev_t rpmsg_major;
-static struct class *rpmsg_class;
 
-static DEFINE_IDA(rpmsg_ctrl_ida);
 static DEFINE_IDA(rpmsg_ept_ida);
 static DEFINE_IDA(rpmsg_minor_ida);
 
 #define dev_to_eptdev(dev) container_of(dev, struct rpmsg_eptdev, dev)
 #define cdev_to_eptdev(i_cdev) container_of(i_cdev, struct rpmsg_eptdev, cdev)
 
-#define dev_to_ctrldev(dev) container_of(dev, struct rpmsg_ctrldev, dev)
-#define cdev_to_ctrldev(i_cdev) container_of(i_cdev, struct rpmsg_ctrldev, cdev)
-
-/**
- * struct rpmsg_ctrldev - control device for instantiating endpoint devices
- * @rpdev:	underlaying rpmsg device
- * @cdev:	cdev for the ctrl device
- * @dev:	device for the ctrl device
- */
-struct rpmsg_ctrldev {
-	struct rpmsg_device *rpdev;
-	struct cdev cdev;
-	struct device dev;
-};
-
 /**
  * struct rpmsg_eptdev - endpoint device context
  * @dev:	endpoint device
@@ -62,6 +47,8 @@ struct rpmsg_ctrldev {
  * @queue_lock:	synchronization of @queue operations
  * @queue:	incoming message queue
  * @readq:	wait object for incoming queue
+ * @default_ept: set to channel default endpoint if the default endpoint should be re-used
+ *              on device open to prevent endpoint address update.
  */
 struct rpmsg_eptdev {
 	struct device dev;
@@ -72,13 +59,15 @@ struct rpmsg_eptdev {
 
 	struct mutex ept_lock;
 	struct rpmsg_endpoint *ept;
+	struct rpmsg_endpoint *default_ept;
 
 	spinlock_t queue_lock;
 	struct sk_buff_head queue;
 	wait_queue_head_t readq;
+
 };
 
-static int rpmsg_eptdev_destroy(struct device *dev, void *data)
+int rpmsg_chrdev_eptdev_destroy(struct device *dev, void *data)
 {
 	struct rpmsg_eptdev *eptdev = dev_to_eptdev(dev);
 
@@ -97,6 +86,7 @@ static int rpmsg_eptdev_destroy(struct device *dev, void *data)
 
 	return 0;
 }
+EXPORT_SYMBOL(rpmsg_chrdev_eptdev_destroy);
 
 static int rpmsg_ept_cb(struct rpmsg_device *rpdev, void *buf, int len,
 			void *priv, u32 addr)
@@ -135,7 +125,15 @@ static int rpmsg_eptdev_open(struct inode *inode, struct file *filp)
 
 	get_device(dev);
 
-	ept = rpmsg_create_ept(rpdev, rpmsg_ept_cb, eptdev, eptdev->chinfo);
+	/*
+	 * If the default_ept is set, the rpmsg device default endpoint is used.
+	 * Else a new endpoint is created on open that will be destroyed on release.
+	 */
+	if (eptdev->default_ept)
+		ept = eptdev->default_ept;
+	else
+		ept = rpmsg_create_ept(rpdev, rpmsg_ept_cb, eptdev, eptdev->chinfo);
+
 	if (!ept) {
 		dev_err(dev, "failed to open %s\n", eptdev->chinfo.name);
 		put_device(dev);
@@ -158,7 +156,8 @@ static int rpmsg_eptdev_release(struct inode *inode, struct file *filp)
 	/* Close the endpoint, if it's not already destroyed by the parent */
 	mutex_lock(&eptdev->ept_lock);
 	if (eptdev->ept) {
-		rpmsg_destroy_ept(eptdev->ept);
+		if (!eptdev->default_ept)
+			rpmsg_destroy_ept(eptdev->ept);
 		eptdev->ept = NULL;
 	}
 	mutex_unlock(&eptdev->ept_lock);
@@ -285,7 +284,11 @@ static long rpmsg_eptdev_ioctl(struct file *fp, unsigned int cmd,
 	if (cmd != RPMSG_DESTROY_EPT_IOCTL)
 		return -EINVAL;
 
-	return rpmsg_eptdev_destroy(&eptdev->dev, NULL);
+	/* Don't allow to destroy a default endpoint. */
+	if (eptdev->default_ept)
+		return -EINVAL;
+
+	return rpmsg_chrdev_eptdev_destroy(&eptdev->dev, NULL);
 }
 
 static const struct file_operations rpmsg_eptdev_fops = {
@@ -343,21 +346,18 @@ static void rpmsg_eptdev_release_device(struct device *dev)
 	kfree(eptdev);
 }
 
-static int rpmsg_eptdev_create(struct rpmsg_ctrldev *ctrldev,
-			       struct rpmsg_channel_info chinfo)
+static struct rpmsg_eptdev *rpmsg_chrdev_eptdev_alloc(struct rpmsg_device *rpdev,
+						      struct device *parent)
 {
-	struct rpmsg_device *rpdev = ctrldev->rpdev;
 	struct rpmsg_eptdev *eptdev;
 	struct device *dev;
-	int ret;
 
 	eptdev = kzalloc(sizeof(*eptdev), GFP_KERNEL);
 	if (!eptdev)
-		return -ENOMEM;
+		return ERR_PTR(-ENOMEM);
 
 	dev = &eptdev->dev;
 	eptdev->rpdev = rpdev;
-	eptdev->chinfo = chinfo;
 
 	mutex_init(&eptdev->ept_lock);
 	spin_lock_init(&eptdev->queue_lock);
@@ -366,13 +366,23 @@ static int rpmsg_eptdev_create(struct rpmsg_ctrldev *ctrldev,
 
 	device_initialize(dev);
 	dev->class = rpmsg_class;
-	dev->parent = &ctrldev->dev;
+	dev->parent = parent;
 	dev->groups = rpmsg_eptdev_groups;
 	dev_set_drvdata(dev, eptdev);
 
 	cdev_init(&eptdev->cdev, &rpmsg_eptdev_fops);
 	eptdev->cdev.owner = THIS_MODULE;
 
+	return eptdev;
+}
+
+static int rpmsg_chrdev_eptdev_add(struct rpmsg_eptdev *eptdev, struct rpmsg_channel_info chinfo)
+{
+	struct device *dev = &eptdev->dev;
+	int ret;
+
+	eptdev->chinfo = chinfo;
+
 	ret = ida_simple_get(&rpmsg_minor_ida, 0, RPMSG_DEV_MAX, GFP_KERNEL);
 	if (ret < 0)
 		goto free_eptdev;
@@ -404,163 +414,91 @@ static int rpmsg_eptdev_create(struct rpmsg_ctrldev *ctrldev,
 	return ret;
 }
 
-static int rpmsg_ctrldev_open(struct inode *inode, struct file *filp)
-{
-	struct rpmsg_ctrldev *ctrldev = cdev_to_ctrldev(inode->i_cdev);
-
-	get_device(&ctrldev->dev);
-	filp->private_data = ctrldev;
-
-	return 0;
-}
-
-static int rpmsg_ctrldev_release(struct inode *inode, struct file *filp)
-{
-	struct rpmsg_ctrldev *ctrldev = cdev_to_ctrldev(inode->i_cdev);
-
-	put_device(&ctrldev->dev);
-
-	return 0;
-}
-
-static long rpmsg_ctrldev_ioctl(struct file *fp, unsigned int cmd,
-				unsigned long arg)
+int rpmsg_chrdev_eptdev_create(struct rpmsg_device *rpdev, struct device *parent,
+			       struct rpmsg_channel_info chinfo)
 {
-	struct rpmsg_ctrldev *ctrldev = fp->private_data;
-	void __user *argp = (void __user *)arg;
-	struct rpmsg_endpoint_info eptinfo;
-	struct rpmsg_channel_info chinfo;
-
-	if (cmd != RPMSG_CREATE_EPT_IOCTL)
-		return -EINVAL;
-
-	if (copy_from_user(&eptinfo, argp, sizeof(eptinfo)))
-		return -EFAULT;
-
-	memcpy(chinfo.name, eptinfo.name, RPMSG_NAME_SIZE);
-	chinfo.name[RPMSG_NAME_SIZE-1] = '\0';
-	chinfo.src = eptinfo.src;
-	chinfo.dst = eptinfo.dst;
-
-	return rpmsg_eptdev_create(ctrldev, chinfo);
-};
+	struct rpmsg_eptdev *eptdev;
+	int ret;
 
-static const struct file_operations rpmsg_ctrldev_fops = {
-	.owner = THIS_MODULE,
-	.open = rpmsg_ctrldev_open,
-	.release = rpmsg_ctrldev_release,
-	.unlocked_ioctl = rpmsg_ctrldev_ioctl,
-	.compat_ioctl = compat_ptr_ioctl,
-};
+	eptdev = rpmsg_chrdev_eptdev_alloc(rpdev, parent);
+	if (IS_ERR(eptdev))
+		return PTR_ERR(eptdev);
 
-static void rpmsg_ctrldev_release_device(struct device *dev)
-{
-	struct rpmsg_ctrldev *ctrldev = dev_to_ctrldev(dev);
+	ret = rpmsg_chrdev_eptdev_add(eptdev, chinfo);
 
-	ida_simple_remove(&rpmsg_ctrl_ida, dev->id);
-	ida_simple_remove(&rpmsg_minor_ida, MINOR(dev->devt));
-	kfree(ctrldev);
+	return ret;
 }
+EXPORT_SYMBOL(rpmsg_chrdev_eptdev_create);
 
 static int rpmsg_chrdev_probe(struct rpmsg_device *rpdev)
 {
-	struct rpmsg_ctrldev *ctrldev;
-	struct device *dev;
-	int ret;
-
-	ctrldev = kzalloc(sizeof(*ctrldev), GFP_KERNEL);
-	if (!ctrldev)
-		return -ENOMEM;
-
-	ctrldev->rpdev = rpdev;
-
-	dev = &ctrldev->dev;
-	device_initialize(dev);
-	dev->parent = &rpdev->dev;
-	dev->class = rpmsg_class;
-
-	cdev_init(&ctrldev->cdev, &rpmsg_ctrldev_fops);
-	ctrldev->cdev.owner = THIS_MODULE;
-
-	ret = ida_simple_get(&rpmsg_minor_ida, 0, RPMSG_DEV_MAX, GFP_KERNEL);
-	if (ret < 0)
-		goto free_ctrldev;
-	dev->devt = MKDEV(MAJOR(rpmsg_major), ret);
-
-	ret = ida_simple_get(&rpmsg_ctrl_ida, 0, 0, GFP_KERNEL);
-	if (ret < 0)
-		goto free_minor_ida;
-	dev->id = ret;
-	dev_set_name(&ctrldev->dev, "rpmsg_ctrl%d", ret);
+	struct rpmsg_channel_info chinfo;
+	struct rpmsg_eptdev *eptdev;
+	struct device *dev = &rpdev->dev;
 
-	ret = cdev_device_add(&ctrldev->cdev, &ctrldev->dev);
-	if (ret)
-		goto free_ctrl_ida;
+	memcpy(chinfo.name, rpdev->id.name, RPMSG_NAME_SIZE);
+	chinfo.src = rpdev->src;
+	chinfo.dst = rpdev->dst;
 
-	/* We can now rely on the release function for cleanup */
-	dev->release = rpmsg_ctrldev_release_device;
+	eptdev = rpmsg_chrdev_eptdev_alloc(rpdev, dev);
+	if (IS_ERR(eptdev))
+		return PTR_ERR(eptdev);
 
-	dev_set_drvdata(&rpdev->dev, ctrldev);
+	/* Set the default_ept to the rpmsg device endpoint */
+	eptdev->default_ept = rpdev->ept;
 
-	return ret;
+	/*
+	 * The rpmsg_ept_cb uses *priv parameter to get its rpmsg_eptdev context.
+	 * Storedit in default_ept *priv field.
+	 */
+	eptdev->default_ept->priv = eptdev;
 
-free_ctrl_ida:
-	ida_simple_remove(&rpmsg_ctrl_ida, dev->id);
-free_minor_ida:
-	ida_simple_remove(&rpmsg_minor_ida, MINOR(dev->devt));
-free_ctrldev:
-	put_device(dev);
-	kfree(ctrldev);
-
-	return ret;
+	return rpmsg_chrdev_eptdev_add(eptdev, chinfo);
 }
 
 static void rpmsg_chrdev_remove(struct rpmsg_device *rpdev)
 {
-	struct rpmsg_ctrldev *ctrldev = dev_get_drvdata(&rpdev->dev);
 	int ret;
 
-	/* Destroy all endpoints */
-	ret = device_for_each_child(&ctrldev->dev, NULL, rpmsg_eptdev_destroy);
+	ret = device_for_each_child(&rpdev->dev, NULL, rpmsg_chrdev_eptdev_destroy);
 	if (ret)
-		dev_warn(&rpdev->dev, "failed to nuke endpoints: %d\n", ret);
-
-	cdev_device_del(&ctrldev->cdev, &ctrldev->dev);
-	put_device(&ctrldev->dev);
+		dev_warn(&rpdev->dev, "failed to destroy endpoints: %d\n", ret);
 }
 
+static struct rpmsg_device_id rpmsg_chrdev_id_table[] = {
+	{ .name	= "rpmsg-raw" },
+	{ },
+};
+
 static struct rpmsg_driver rpmsg_chrdev_driver = {
 	.probe = rpmsg_chrdev_probe,
 	.remove = rpmsg_chrdev_remove,
-	.drv = {
-		.name = "rpmsg_chrdev",
-	},
+	.callback = rpmsg_ept_cb,
+	.id_table = rpmsg_chrdev_id_table,
+	.drv.name = "rpmsg_chrdev",
 };
 
 static int rpmsg_chrdev_init(void)
 {
 	int ret;
 
-	ret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, "rpmsg");
+	ret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, "rpmsg_char");
 	if (ret < 0) {
 		pr_err("rpmsg: failed to allocate char dev region\n");
 		return ret;
 	}
 
-	rpmsg_class = class_create(THIS_MODULE, "rpmsg");
-	if (IS_ERR(rpmsg_class)) {
-		pr_err("failed to create rpmsg class\n");
-		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
-		return PTR_ERR(rpmsg_class);
-	}
-
 	ret = register_rpmsg_driver(&rpmsg_chrdev_driver);
 	if (ret < 0) {
-		pr_err("rpmsgchr: failed to register rpmsg driver\n");
-		class_destroy(rpmsg_class);
-		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
+		pr_err("rpmsg: failed to register rpmsg raw driver\n");
+		goto free_region;
 	}
 
+	return 0;
+
+free_region:
+	unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
+
 	return ret;
 }
 postcore_initcall(rpmsg_chrdev_init);
@@ -568,7 +506,6 @@ postcore_initcall(rpmsg_chrdev_init);
 static void rpmsg_chrdev_exit(void)
 {
 	unregister_rpmsg_driver(&rpmsg_chrdev_driver);
-	class_destroy(rpmsg_class);
 	unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
 }
 module_exit(rpmsg_chrdev_exit);
diff --git a/drivers/rpmsg/rpmsg_char.h b/drivers/rpmsg/rpmsg_char.h
new file mode 100644
index 000000000..117d9cbc5
--- /dev/null
+++ b/drivers/rpmsg/rpmsg_char.h
@@ -0,0 +1,46 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022, STMicroelectronics
+ */
+
+#ifndef __RPMSG_CHRDEV_H__
+#define __RPMSG_CHRDEV_H__
+
+#if IS_ENABLED(CONFIG_RPMSG_CHAR)
+/**
+ * rpmsg_chrdev_eptdev_create() - register char device based on an endpoint
+ * @rpdev:  prepared rpdev to be used for creating endpoints
+ * @parent: parent device
+ * @chinfo: associated endpoint channel information.
+ *
+ * This function create a new rpmsg char endpoint device to instantiate a new
+ * endpoint based on chinfo information.
+ */
+int rpmsg_chrdev_eptdev_create(struct rpmsg_device *rpdev, struct device *parent,
+			       struct rpmsg_channel_info chinfo);
+
+/**
+ * rpmsg_chrdev_eptdev_destroy() - destroy created char device endpoint.
+ * @data: private data associated to the endpoint device
+ *
+ * This function destroys a rpmsg char endpoint device created by the RPMSG_DESTROY_EPT_IOCTL
+ * control.
+ */
+int rpmsg_chrdev_eptdev_destroy(struct device *dev, void *data);
+
+#else  /*IS_ENABLED(CONFIG_RPMSG_CHAR) */
+
+static inline int rpmsg_chrdev_eptdev_create(struct rpmsg_device *rpdev, struct device *parent,
+					     struct rpmsg_channel_info chinfo)
+{
+	return -ENXIO;
+}
+
+static inline int rpmsg_chrdev_eptdev_destroy(struct device *dev, void *data)
+{
+	return -ENXIO;
+}
+
+#endif /*IS_ENABLED(CONFIG_RPMSG_CHAR) */
+
+#endif /*__RPMSG_CHRDEV_H__ */
diff --git a/drivers/rpmsg/rpmsg_core.c b/drivers/rpmsg/rpmsg_core.c
index a71de08ac..41648ad9f 100644
--- a/drivers/rpmsg/rpmsg_core.c
+++ b/drivers/rpmsg/rpmsg_core.c
@@ -20,6 +20,9 @@
 
 #include "rpmsg_internal.h"
 
+struct class *rpmsg_class;
+EXPORT_SYMBOL(rpmsg_class);
+
 /**
  * rpmsg_create_channel() - create a new rpmsg channel
  * using its name and address info.
@@ -327,6 +330,27 @@ int rpmsg_trysend_offchannel(struct rpmsg_endpoint *ept, u32 src, u32 dst,
 }
 EXPORT_SYMBOL(rpmsg_trysend_offchannel);
 
+/**
+ * rpmsg_get_mtu() - get maximum transmission buffer size for sending message.
+ * @ept: the rpmsg endpoint
+ *
+ * This function returns maximum buffer size available for a single outgoing message.
+ *
+ * Return: the maximum transmission size on success and an appropriate error
+ * value on failure.
+ */
+
+ssize_t rpmsg_get_mtu(struct rpmsg_endpoint *ept)
+{
+	if (WARN_ON(!ept))
+		return -EINVAL;
+	if (!ept->ops->get_mtu)
+		return -ENOTSUPP;
+
+	return ept->ops->get_mtu(ept);
+}
+EXPORT_SYMBOL(rpmsg_get_mtu);
+
 /*
  * match a rpmsg channel with a channel info struct.
  * this is used to make sure we're not creating rpmsg devices for channels
@@ -641,10 +665,17 @@ static int __init rpmsg_init(void)
 {
 	int ret;
 
+	rpmsg_class = class_create(THIS_MODULE, "rpmsg");
+	if (IS_ERR(rpmsg_class)) {
+		pr_err("failed to create rpmsg class\n");
+		return PTR_ERR(rpmsg_class);
+	}
+
 	ret = bus_register(&rpmsg_bus);
-	if (ret)
+	if (ret) {
 		pr_err("failed to register rpmsg bus: %d\n", ret);
-
+		class_destroy(rpmsg_class);
+	}
 	return ret;
 }
 postcore_initcall(rpmsg_init);
@@ -652,6 +683,7 @@ postcore_initcall(rpmsg_init);
 static void __exit rpmsg_fini(void)
 {
 	bus_unregister(&rpmsg_bus);
+	class_destroy(rpmsg_class);
 }
 module_exit(rpmsg_fini);
 
diff --git a/drivers/rpmsg/rpmsg_ctrl.c b/drivers/rpmsg/rpmsg_ctrl.c
new file mode 100644
index 000000000..107da70fd
--- /dev/null
+++ b/drivers/rpmsg/rpmsg_ctrl.c
@@ -0,0 +1,243 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2022, STMicroelectronics
+ * Copyright (c) 2016, Linaro Ltd.
+ * Copyright (c) 2012, Michal Simek <monstr@monstr.eu>
+ * Copyright (c) 2012, PetaLogix
+ * Copyright (c) 2011, Texas Instruments, Inc.
+ * Copyright (c) 2011, Google, Inc.
+ *
+ * Based on rpmsg performance statistics driver by Michal Simek, which in turn
+ * was based on TI & Google OMX rpmsg driver.
+ */
+
+#define pr_fmt(fmt)		KBUILD_MODNAME ": " fmt
+
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/idr.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/rpmsg.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <uapi/linux/rpmsg.h>
+
+#include "rpmsg_char.h"
+#include "rpmsg_internal.h"
+
+#define RPMSG_DEV_MAX	(MINORMASK + 1)
+
+static dev_t rpmsg_major;
+
+static DEFINE_IDA(rpmsg_ctrl_ida);
+static DEFINE_IDA(rpmsg_minor_ida);
+
+#define dev_to_ctrldev(dev) container_of(dev, struct rpmsg_ctrldev, dev)
+#define cdev_to_ctrldev(i_cdev) container_of(i_cdev, struct rpmsg_ctrldev, cdev)
+
+/**
+ * struct rpmsg_ctrldev - control device for instantiating endpoint devices
+ * @rpdev:	underlaying rpmsg device
+ * @cdev:	cdev for the ctrl device
+ * @dev:	device for the ctrl device
+ * @ctrl_lock:	serialize the ioctrls.
+ */
+struct rpmsg_ctrldev {
+	struct rpmsg_device *rpdev;
+	struct cdev cdev;
+	struct device dev;
+	struct mutex ctrl_lock;
+};
+
+static int rpmsg_ctrldev_open(struct inode *inode, struct file *filp)
+{
+	struct rpmsg_ctrldev *ctrldev = cdev_to_ctrldev(inode->i_cdev);
+
+	get_device(&ctrldev->dev);
+	filp->private_data = ctrldev;
+
+	return 0;
+}
+
+static int rpmsg_ctrldev_release(struct inode *inode, struct file *filp)
+{
+	struct rpmsg_ctrldev *ctrldev = cdev_to_ctrldev(inode->i_cdev);
+
+	put_device(&ctrldev->dev);
+
+	return 0;
+}
+
+static long rpmsg_ctrldev_ioctl(struct file *fp, unsigned int cmd,
+				unsigned long arg)
+{
+	struct rpmsg_ctrldev *ctrldev = fp->private_data;
+	void __user *argp = (void __user *)arg;
+	struct rpmsg_endpoint_info eptinfo;
+	struct rpmsg_channel_info chinfo;
+	struct rpmsg_device *rpdev;
+	int ret = 0;
+
+	if (copy_from_user(&eptinfo, argp, sizeof(eptinfo)))
+		return -EFAULT;
+
+	memcpy(chinfo.name, eptinfo.name, RPMSG_NAME_SIZE);
+	chinfo.name[RPMSG_NAME_SIZE - 1] = '\0';
+	chinfo.src = eptinfo.src;
+	chinfo.dst = eptinfo.dst;
+
+	mutex_lock(&ctrldev->ctrl_lock);
+	switch (cmd) {
+	case RPMSG_CREATE_EPT_IOCTL:
+		ret = rpmsg_chrdev_eptdev_create(ctrldev->rpdev, &ctrldev->dev, chinfo);
+		break;
+
+	case RPMSG_CREATE_DEV_IOCTL:
+		rpdev = rpmsg_create_channel(ctrldev->rpdev, &chinfo);
+		if (!rpdev) {
+			dev_err(&ctrldev->dev, "failed to create %s channel\n", chinfo.name);
+			ret = -ENXIO;
+		}
+		break;
+
+	case RPMSG_RELEASE_DEV_IOCTL:
+		ret = rpmsg_release_channel(ctrldev->rpdev, &chinfo);
+		if (ret)
+			dev_err(&ctrldev->dev, "failed to release %s channel (%d)\n",
+				chinfo.name, ret);
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+	mutex_unlock(&ctrldev->ctrl_lock);
+
+	return ret;
+};
+
+static const struct file_operations rpmsg_ctrldev_fops = {
+	.owner = THIS_MODULE,
+	.open = rpmsg_ctrldev_open,
+	.release = rpmsg_ctrldev_release,
+	.unlocked_ioctl = rpmsg_ctrldev_ioctl,
+	.compat_ioctl = compat_ptr_ioctl,
+};
+
+static void rpmsg_ctrldev_release_device(struct device *dev)
+{
+	struct rpmsg_ctrldev *ctrldev = dev_to_ctrldev(dev);
+
+	ida_simple_remove(&rpmsg_ctrl_ida, dev->id);
+	ida_simple_remove(&rpmsg_minor_ida, MINOR(dev->devt));
+	kfree(ctrldev);
+}
+
+static int rpmsg_ctrldev_probe(struct rpmsg_device *rpdev)
+{
+	struct rpmsg_ctrldev *ctrldev;
+	struct device *dev;
+	int ret;
+
+	ctrldev = kzalloc(sizeof(*ctrldev), GFP_KERNEL);
+	if (!ctrldev)
+		return -ENOMEM;
+
+	ctrldev->rpdev = rpdev;
+
+	dev = &ctrldev->dev;
+	device_initialize(dev);
+	dev->parent = &rpdev->dev;
+	dev->class = rpmsg_class;
+
+	mutex_init(&ctrldev->ctrl_lock);
+	cdev_init(&ctrldev->cdev, &rpmsg_ctrldev_fops);
+	ctrldev->cdev.owner = THIS_MODULE;
+
+	ret = ida_simple_get(&rpmsg_minor_ida, 0, RPMSG_DEV_MAX, GFP_KERNEL);
+	if (ret < 0)
+		goto free_ctrldev;
+	dev->devt = MKDEV(MAJOR(rpmsg_major), ret);
+
+	ret = ida_simple_get(&rpmsg_ctrl_ida, 0, 0, GFP_KERNEL);
+	if (ret < 0)
+		goto free_minor_ida;
+	dev->id = ret;
+	dev_set_name(&ctrldev->dev, "rpmsg_ctrl%d", ret);
+
+	ret = cdev_device_add(&ctrldev->cdev, &ctrldev->dev);
+	if (ret)
+		goto free_ctrl_ida;
+
+	/* We can now rely on the release function for cleanup */
+	dev->release = rpmsg_ctrldev_release_device;
+
+	dev_set_drvdata(&rpdev->dev, ctrldev);
+
+	return ret;
+
+free_ctrl_ida:
+	ida_simple_remove(&rpmsg_ctrl_ida, dev->id);
+free_minor_ida:
+	ida_simple_remove(&rpmsg_minor_ida, MINOR(dev->devt));
+free_ctrldev:
+	put_device(dev);
+	kfree(ctrldev);
+
+	return ret;
+}
+
+static void rpmsg_ctrldev_remove(struct rpmsg_device *rpdev)
+{
+	struct rpmsg_ctrldev *ctrldev = dev_get_drvdata(&rpdev->dev);
+	int ret;
+
+	/* Destroy all endpoints */
+	ret = device_for_each_child(&ctrldev->dev, NULL, rpmsg_chrdev_eptdev_destroy);
+	if (ret)
+		dev_warn(&rpdev->dev, "failed to nuke endpoints: %d\n", ret);
+
+	cdev_device_del(&ctrldev->cdev, &ctrldev->dev);
+	put_device(&ctrldev->dev);
+}
+
+static struct rpmsg_driver rpmsg_ctrldev_driver = {
+	.probe = rpmsg_ctrldev_probe,
+	.remove = rpmsg_ctrldev_remove,
+	.drv = {
+		.name = "rpmsg_ctrl",
+	},
+};
+
+static int rpmsg_ctrldev_init(void)
+{
+	int ret;
+
+	ret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, "rpmsg_ctrl");
+	if (ret < 0) {
+		pr_err("failed to allocate char dev region\n");
+		return ret;
+	}
+
+	ret = register_rpmsg_driver(&rpmsg_ctrldev_driver);
+	if (ret < 0) {
+		pr_err("failed to register rpmsg driver\n");
+		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
+	}
+
+	return ret;
+}
+postcore_initcall(rpmsg_ctrldev_init);
+
+static void rpmsg_ctrldev_exit(void)
+{
+	unregister_rpmsg_driver(&rpmsg_ctrldev_driver);
+	unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
+}
+module_exit(rpmsg_ctrldev_exit);
+
+MODULE_DESCRIPTION("rpmsg control interface");
+MODULE_ALIAS("rpmsg:" KBUILD_MODNAME);
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/rpmsg/rpmsg_internal.h b/drivers/rpmsg/rpmsg_internal.h
index a76c34425..d4b23fd01 100644
--- a/drivers/rpmsg/rpmsg_internal.h
+++ b/drivers/rpmsg/rpmsg_internal.h
@@ -18,6 +18,8 @@
 #define to_rpmsg_device(d) container_of(d, struct rpmsg_device, dev)
 #define to_rpmsg_driver(d) container_of(d, struct rpmsg_driver, drv)
 
+extern struct class *rpmsg_class;
+
 /**
  * struct rpmsg_device_ops - indirection table for the rpmsg_device operations
  * @create_channel:	create backend-specific channel, optional
@@ -53,6 +55,7 @@ struct rpmsg_device_ops {
  * @trysendto:		see @rpmsg_trysendto(), optional
  * @trysend_offchannel:	see @rpmsg_trysend_offchannel(), optional
  * @poll:		see @rpmsg_poll(), optional
+ * @get_mtu:		see @rpmsg_get_mtu(), optional
  *
  * Indirection table for the operations that a rpmsg backend should implement.
  * In addition to @destroy_ept, the backend must at least implement @send and
@@ -72,6 +75,7 @@ struct rpmsg_endpoint_ops {
 			     void *data, int len);
 	__poll_t (*poll)(struct rpmsg_endpoint *ept, struct file *filp,
 			     poll_table *wait);
+	ssize_t (*get_mtu)(struct rpmsg_endpoint *ept);
 };
 
 struct device *rpmsg_find_device(struct device *parent,
@@ -82,16 +86,16 @@ struct rpmsg_device *rpmsg_create_channel(struct rpmsg_device *rpdev,
 int rpmsg_release_channel(struct rpmsg_device *rpdev,
 			  struct rpmsg_channel_info *chinfo);
 /**
- * rpmsg_chrdev_register_device() - register chrdev device based on rpdev
+ * rpmsg_ctrldev_register_device() - register a char device for control based on rpdev
  * @rpdev:	prepared rpdev to be used for creating endpoints
  *
  * This function wraps rpmsg_register_device() preparing the rpdev for use as
  * basis for the rpmsg chrdev.
  */
-static inline int rpmsg_chrdev_register_device(struct rpmsg_device *rpdev)
+static inline int rpmsg_ctrldev_register_device(struct rpmsg_device *rpdev)
 {
-	strcpy(rpdev->id.name, "rpmsg_chrdev");
-	rpdev->driver_override = "rpmsg_chrdev";
+	strcpy(rpdev->id.name, "rpmsg_ctrl");
+	rpdev->driver_override = "rpmsg_ctrl";
 
 	return rpmsg_register_device(rpdev);
 }
diff --git a/drivers/rpmsg/virtio_rpmsg_bus.c b/drivers/rpmsg/virtio_rpmsg_bus.c
index b03e74042..1c54fe2fa 100644
--- a/drivers/rpmsg/virtio_rpmsg_bus.c
+++ b/drivers/rpmsg/virtio_rpmsg_bus.c
@@ -149,6 +149,7 @@ static int virtio_rpmsg_trysendto(struct rpmsg_endpoint *ept, void *data,
 				  int len, u32 dst);
 static int virtio_rpmsg_trysend_offchannel(struct rpmsg_endpoint *ept, u32 src,
 					   u32 dst, void *data, int len);
+static ssize_t virtio_rpmsg_get_mtu(struct rpmsg_endpoint *ept);
 static struct rpmsg_device *__rpmsg_create_channel(struct virtproc_info *vrp,
 						   struct rpmsg_channel_info *chinfo);
 
@@ -160,6 +161,7 @@ static const struct rpmsg_endpoint_ops virtio_endpoint_ops = {
 	.trysend = virtio_rpmsg_trysend,
 	.trysendto = virtio_rpmsg_trysendto,
 	.trysend_offchannel = virtio_rpmsg_trysend_offchannel,
+	.get_mtu = virtio_rpmsg_get_mtu,
 };
 
 /**
@@ -696,6 +698,14 @@ static int virtio_rpmsg_trysend_offchannel(struct rpmsg_endpoint *ept, u32 src,
 	return rpmsg_send_offchannel_raw(rpdev, src, dst, data, len, false);
 }
 
+static ssize_t virtio_rpmsg_get_mtu(struct rpmsg_endpoint *ept)
+{
+	struct rpmsg_device *rpdev = ept->rpdev;
+	struct virtio_rpmsg_channel *vch = to_virtio_rpmsg_channel(rpdev);
+
+	return vch->vrp->buf_size - sizeof(struct rpmsg_hdr);
+}
+
 static int rpmsg_recv_single(struct virtproc_info *vrp, struct device *dev,
 			     struct rpmsg_hdr *msg, unsigned int len)
 {
@@ -840,7 +850,7 @@ static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev
 	rpdev_ctrl->dev.release = virtio_rpmsg_release_device;
 	rpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);
 
-	err = rpmsg_chrdev_register_device(rpdev_ctrl);
+	err = rpmsg_ctrldev_register_device(rpdev_ctrl);
 	if (err) {
 		/* vch will be free in virtio_rpmsg_release_device() */
 		return ERR_PTR(err);
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index e1bc52144..57ef1efdf 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -1867,6 +1867,7 @@ config RTC_DRV_R7301
 config RTC_DRV_STM32
 	tristate "STM32 RTC"
 	select REGMAP_MMIO
+	depends on COMMON_CLK
 	depends on ARCH_STM32 || COMPILE_TEST
 	help
 	   If you say yes here you get support for the STM32 On-Chip
diff --git a/drivers/rtc/rtc-stm32.c b/drivers/rtc/rtc-stm32.c
index ac9e228b5..20896b4b4 100644
--- a/drivers/rtc/rtc-stm32.c
+++ b/drivers/rtc/rtc-stm32.c
@@ -5,7 +5,10 @@
  */
 
 #include <linux/bcd.h>
+#include <linux/bitfield.h>
 #include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/errno.h>
 #include <linux/iopoll.h>
 #include <linux/ioport.h>
 #include <linux/mfd/syscon.h>
@@ -15,6 +18,8 @@
 #include <linux/regmap.h>
 #include <linux/rtc.h>
 
+#include <dt-bindings/rtc/rtc-stm32.h>
+
 #define DRIVER_NAME "stm32_rtc"
 
 /* STM32_RTC_TR bit fields  */
@@ -39,6 +44,13 @@
 #define STM32_RTC_CR_FMT		BIT(6)
 #define STM32_RTC_CR_ALRAE		BIT(8)
 #define STM32_RTC_CR_ALRAIE		BIT(12)
+#define STM32_RTC_CR_COSEL		BIT(19)
+#define STM32_RTC_CR_OSEL		GENMASK(22, 21)
+#define STM32_RTC_CR_OSEL_ALARM_A	FIELD_PREP(STM32_RTC_CR_OSEL, 0x01)
+#define STM32_RTC_CR_COE		BIT(23)
+#define STM32_RTC_CR_TAMPOE		BIT(26)
+#define STM32_RTC_CR_TAMPALRM_TYPE	BIT(30)
+#define STM32_RTC_CR_OUT2EN		BIT(31)
 
 /* STM32_RTC_ISR/STM32_RTC_ICSR bit fields */
 #define STM32_RTC_ISR_ALRAWF		BIT(0)
@@ -75,6 +87,12 @@
 /* STM32_RTC_SR/_SCR bit fields */
 #define STM32_RTC_SR_ALRA		BIT(0)
 
+/* STM32_RTC_CFGR bit fields */
+#define STM32_RTC_CFGR_OUT2_RMP		BIT(0)
+#define STM32_RTC_CFGR_LSCOEN		GENMASK(2, 1)
+#define STM32_RTC_CFGR_LSCOEN_OUT1	1
+#define STM32_RTC_CFGR_LSCOEN_OUT2_RMP	2
+
 /* STM32_RTC_VERR bit fields */
 #define STM32_RTC_VERR_MINREV_SHIFT	0
 #define STM32_RTC_VERR_MINREV		GENMASK(3, 0)
@@ -89,6 +107,9 @@
 /* Max STM32 RTC register offset is 0x3FC */
 #define UNDEF_REG			0xFFFF
 
+/* STM32 RTC driver time helpers */
+#define SEC_PER_DAY		(24 * 60 * 60)
+
 struct stm32_rtc;
 
 struct stm32_rtc_registers {
@@ -101,6 +122,7 @@ struct stm32_rtc_registers {
 	u16 wpr;
 	u16 sr;
 	u16 scr;
+	u16 cfgr;
 	u16 verr;
 };
 
@@ -114,7 +136,9 @@ struct stm32_rtc_data {
 	void (*clear_events)(struct stm32_rtc *rtc, unsigned int flags);
 	bool has_pclk;
 	bool need_dbp;
-	bool has_wakeirq;
+	bool has_lsco;
+	bool has_alarm_out;
+	bool need_accuracy;
 };
 
 struct stm32_rtc {
@@ -127,9 +151,88 @@ struct stm32_rtc {
 	struct clk *rtc_ck;
 	const struct stm32_rtc_data *data;
 	int irq_alarm;
-	int wakeirq_alarm;
+	int lsco;
+	struct clk *clk_lsco;
+	int out_alarm;
 };
 
+/*
+ *  -------------------------------------------------------------------------
+ * | TAMPOE | OSEL[1:0] | COE | OUT2EN |     RTC_OUT1     |     RTC_OUT2     |
+ * |	    |           |     |        |                  | or RTC_OUT2_RMP  |
+ * |-------------------------------------------------------------------------|
+ * |    0   |     00    |  0  | 0 or 1 |         -        |         -        |
+ * |--------|-----------|-----|--------|------------------|------------------|
+ * |    0   |     00    |  1  |    0   |      CALIB       |         -        |
+ * |--------|-----------|-----|--------|------------------|------------------|
+ * | 0 or 1 |    !=00   |  0  |    0   |     TAMPALRM     |         -        |
+ * |--------|-----------|-----|--------|------------------|------------------|
+ * |    0   |     00    |  1  |    1   |         -        |      CALIB       |
+ * |--------|-----------|-----|--------|------------------|------------------|
+ * | 0 or 1 |    !=00   |  0  |    1   |         -        |     TAMPALRM     |
+ * |--------|-----------|-----|--------|------------------|------------------|
+ * | 0 or 1 |    !=00   |  1  |    1   |     TAMPALRM     |      CALIB       |
+ *  -------------------------------------------------------------------------
+ */
+static int stm32_rtc_clk_lsco_check_availability(struct stm32_rtc *rtc)
+{
+	struct stm32_rtc_registers regs = rtc->data->regs;
+	unsigned int cr = readl_relaxed(rtc->base + regs.cr);
+	unsigned int cfgr = readl_relaxed(rtc->base + regs.cfgr);
+	unsigned int calib = STM32_RTC_CR_COE;
+	unsigned int tampalrm = STM32_RTC_CR_TAMPOE | STM32_RTC_CR_OSEL;
+
+	switch (rtc->lsco) {
+	case RTC_OUT1:
+		if ((!(cr & STM32_RTC_CR_OUT2EN) &&
+		     ((cr & calib) || cr & tampalrm)) ||
+		     ((cr & calib) && (cr & tampalrm)))
+			return -EBUSY;
+		break;
+	case RTC_OUT2_RMP:
+		if ((cr & STM32_RTC_CR_OUT2EN) &&
+		    (cfgr & STM32_RTC_CFGR_OUT2_RMP) &&
+		    ((cr & calib) || (cr & tampalrm)))
+			return -EBUSY;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (clk_get_rate(rtc->rtc_ck) != 32768)
+		return -ERANGE;
+
+	return 0;
+}
+
+static int stm32_rtc_clk_lsco_register(struct platform_device *pdev)
+{
+	struct stm32_rtc *rtc = platform_get_drvdata(pdev);
+	struct stm32_rtc_registers regs = rtc->data->regs;
+	u8 lscoen;
+	int ret;
+
+	ret = stm32_rtc_clk_lsco_check_availability(rtc);
+	if (ret)
+		return ret;
+
+	lscoen = (rtc->lsco == RTC_OUT1) ? STM32_RTC_CFGR_LSCOEN_OUT1 :
+					   STM32_RTC_CFGR_LSCOEN_OUT2_RMP;
+
+	rtc->clk_lsco = clk_register_gate(&pdev->dev, "rtc_lsco",
+					  __clk_get_name(rtc->rtc_ck),
+					  CLK_IGNORE_UNUSED | CLK_IS_CRITICAL,
+					  rtc->base + regs.cfgr, lscoen,
+					  0, NULL);
+	if (IS_ERR(rtc->clk_lsco))
+		return PTR_ERR(rtc->clk_lsco);
+
+	of_clk_add_provider(pdev->dev.of_node,
+			    of_clk_src_simple_get, rtc->clk_lsco);
+
+	return 0;
+}
+
 static void stm32_rtc_wpr_unlock(struct stm32_rtc *rtc)
 {
 	const struct stm32_rtc_registers *regs = &rtc->data->regs;
@@ -145,6 +248,73 @@ static void stm32_rtc_wpr_lock(struct stm32_rtc *rtc)
 	writel_relaxed(RTC_WPR_WRONG_KEY, rtc->base + regs->wpr);
 }
 
+static void stm32_rtc_clk_lsco_disable(struct platform_device *pdev)
+{
+	struct stm32_rtc *rtc = platform_get_drvdata(pdev);
+	struct stm32_rtc_registers regs = rtc->data->regs;
+	unsigned int cfgr = readl_relaxed(rtc->base + regs.cfgr);
+
+	writel_relaxed(cfgr &= ~STM32_RTC_CFGR_LSCOEN, rtc->base + regs.cfgr);
+}
+
+static int stm32_rtc_out_alarm_config(struct platform_device *pdev)
+{
+	struct stm32_rtc *rtc = platform_get_drvdata(pdev);
+	struct stm32_rtc_registers regs = rtc->data->regs;
+	unsigned int cr = readl_relaxed(rtc->base + regs.cr);
+	unsigned int cfgr = readl_relaxed(rtc->base + regs.cfgr);
+
+	cr &= ~STM32_RTC_CR_OSEL;
+	cr |= STM32_RTC_CR_OSEL_ALARM_A;
+	cr &= ~STM32_RTC_CR_TAMPOE;
+	cr &= ~STM32_RTC_CR_COE;
+	cr &= ~STM32_RTC_CR_TAMPALRM_TYPE;
+
+	switch (rtc->out_alarm) {
+	case RTC_OUT1:
+		cr &= ~STM32_RTC_CR_OUT2EN;
+		cfgr &= ~STM32_RTC_CFGR_OUT2_RMP;
+		break;
+	case RTC_OUT2:
+		cr |= STM32_RTC_CR_OUT2EN;
+		cfgr &= ~STM32_RTC_CFGR_OUT2_RMP;
+		break;
+	case RTC_OUT2_RMP:
+		cr |= STM32_RTC_CR_OUT2EN;
+		cfgr |= STM32_RTC_CFGR_OUT2_RMP;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	stm32_rtc_wpr_unlock(rtc);
+	writel_relaxed(cr, rtc->base + regs.cr);
+	writel_relaxed(cfgr, rtc->base + regs.cfgr);
+	stm32_rtc_wpr_lock(rtc);
+
+	return 0;
+}
+
+static void stm32_rtc_out_alarm_disable(struct platform_device *pdev)
+{
+	struct stm32_rtc *rtc = platform_get_drvdata(pdev);
+	struct stm32_rtc_registers regs = rtc->data->regs;
+	unsigned int cr = readl_relaxed(rtc->base + regs.cr);
+	unsigned int cfgr = readl_relaxed(rtc->base + regs.cfgr);
+
+	cr &= ~STM32_RTC_CR_OSEL;
+	cr &= ~STM32_RTC_CR_TAMPOE;
+	cr &= ~STM32_RTC_CR_COE;
+	cr &= ~STM32_RTC_CR_TAMPALRM_TYPE;
+	cr &= ~STM32_RTC_CR_OUT2EN;
+	cfgr &= ~STM32_RTC_CFGR_OUT2_RMP;
+
+	stm32_rtc_wpr_unlock(rtc);
+	writel_relaxed(cr, rtc->base + regs.cr);
+	writel_relaxed(cfgr, rtc->base + regs.cfgr);
+	stm32_rtc_wpr_lock(rtc);
+}
+
 static int stm32_rtc_enter_init_mode(struct stm32_rtc *rtc)
 {
 	const struct stm32_rtc_registers *regs = &rtc->data->regs;
@@ -160,10 +330,9 @@ static int stm32_rtc_enter_init_mode(struct stm32_rtc *rtc)
 		 * slowest rtc_ck frequency may be 32kHz and highest should be
 		 * 1MHz, we poll every 10 us with a timeout of 100ms.
 		 */
-		return readl_relaxed_poll_timeout_atomic(
-					rtc->base + regs->isr,
-					isr, (isr & STM32_RTC_ISR_INITF),
-					10, 100000);
+		return readl_relaxed_poll_timeout_atomic(rtc->base + regs->isr, isr,
+							 (isr & STM32_RTC_ISR_INITF),
+							 10, 100000);
 	}
 
 	return 0;
@@ -427,40 +596,42 @@ static int stm32_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)
 	return 0;
 }
 
-static int stm32_rtc_valid_alrm(struct stm32_rtc *rtc, struct rtc_time *tm)
+static int stm32_rtc_valid_alrm(struct device *dev, struct rtc_time *tm)
 {
-	const struct stm32_rtc_registers *regs = &rtc->data->regs;
-	int cur_day, cur_mon, cur_year, cur_hour, cur_min, cur_sec;
-	unsigned int dr = readl_relaxed(rtc->base + regs->dr);
-	unsigned int tr = readl_relaxed(rtc->base + regs->tr);
-
-	cur_day = (dr & STM32_RTC_DR_DATE) >> STM32_RTC_DR_DATE_SHIFT;
-	cur_mon = (dr & STM32_RTC_DR_MONTH) >> STM32_RTC_DR_MONTH_SHIFT;
-	cur_year = (dr & STM32_RTC_DR_YEAR) >> STM32_RTC_DR_YEAR_SHIFT;
-	cur_sec = (tr & STM32_RTC_TR_SEC) >> STM32_RTC_TR_SEC_SHIFT;
-	cur_min = (tr & STM32_RTC_TR_MIN) >> STM32_RTC_TR_MIN_SHIFT;
-	cur_hour = (tr & STM32_RTC_TR_HOUR) >> STM32_RTC_TR_HOUR_SHIFT;
+	static struct rtc_time now;
+	time64_t max_alarm_time64;
+	int max_day_forward;
+	int next_month;
+	int next_year;
 
 	/*
 	 * Assuming current date is M-D-Y H:M:S.
 	 * RTC alarm can't be set on a specific month and year.
 	 * So the valid alarm range is:
 	 *	M-D-Y H:M:S < alarm <= (M+1)-D-Y H:M:S
-	 * with a specific case for December...
 	 */
-	if ((((tm->tm_year > cur_year) &&
-	      (tm->tm_mon == 0x1) && (cur_mon == 0x12)) ||
-	     ((tm->tm_year == cur_year) &&
-	      (tm->tm_mon <= cur_mon + 1))) &&
-	    ((tm->tm_mday > cur_day) ||
-	     ((tm->tm_mday == cur_day) &&
-	     ((tm->tm_hour > cur_hour) ||
-	      ((tm->tm_hour == cur_hour) && (tm->tm_min > cur_min)) ||
-	      ((tm->tm_hour == cur_hour) && (tm->tm_min == cur_min) &&
-	       (tm->tm_sec >= cur_sec))))))
-		return 0;
+	stm32_rtc_read_time(dev, &now);
 
-	return -EINVAL;
+	/*
+	 * Find the next month and the year of the next month.
+	 * Note: tm_mon and next_month are from 0 to 11
+	 */
+	next_month = now.tm_mon + 1;
+	if (next_month == 12) {
+		next_month = 0;
+		next_year = now.tm_year + 1;
+	} else {
+		next_year = now.tm_year;
+	}
+
+	/* Find the maximum limit of alarm in days. */
+	max_day_forward = rtc_month_days(now.tm_mon, now.tm_year)
+			 - now.tm_mday
+			 + min(rtc_month_days(next_month, next_year), now.tm_mday);
+
+	/* Convert to timestamp and compare the alarm time and its upper limit */
+	max_alarm_time64 = rtc_tm_to_time64(&now) + max_day_forward * SEC_PER_DAY;
+	return rtc_tm_to_time64(tm) <= max_alarm_time64 ? 0 : -EINVAL;
 }
 
 static int stm32_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
@@ -471,17 +642,17 @@ static int stm32_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
 	unsigned int cr, isr, alrmar;
 	int ret = 0;
 
-	tm2bcd(tm);
-
 	/*
 	 * RTC alarm can't be set on a specific date, unless this date is
 	 * up to the same day of month next month.
 	 */
-	if (stm32_rtc_valid_alrm(rtc, tm) < 0) {
+	if (stm32_rtc_valid_alrm(dev, tm) < 0) {
 		dev_err(dev, "Alarm can be set only on upcoming month.\n");
 		return -EINVAL;
 	}
 
+	tm2bcd(tm);
+
 	alrmar = 0;
 	/* tm_year and tm_mon are not used because not supported by RTC */
 	alrmar |= (tm->tm_mday << STM32_RTC_ALRMXR_DATE_SHIFT) &
@@ -547,7 +718,9 @@ static void stm32_rtc_clear_events(struct stm32_rtc *rtc,
 static const struct stm32_rtc_data stm32_rtc_data = {
 	.has_pclk = false,
 	.need_dbp = true,
-	.has_wakeirq = false,
+	.has_lsco = false,
+	.has_alarm_out = false,
+	.need_accuracy = false,
 	.regs = {
 		.tr = 0x00,
 		.dr = 0x04,
@@ -558,6 +731,7 @@ static const struct stm32_rtc_data stm32_rtc_data = {
 		.wpr = 0x24,
 		.sr = 0x0C, /* set to ISR offset to ease alarm management */
 		.scr = UNDEF_REG,
+		.cfgr = UNDEF_REG,
 		.verr = UNDEF_REG,
 	},
 	.events = {
@@ -569,7 +743,9 @@ static const struct stm32_rtc_data stm32_rtc_data = {
 static const struct stm32_rtc_data stm32h7_rtc_data = {
 	.has_pclk = true,
 	.need_dbp = true,
-	.has_wakeirq = false,
+	.has_lsco = false,
+	.has_alarm_out = false,
+	.need_accuracy = false,
 	.regs = {
 		.tr = 0x00,
 		.dr = 0x04,
@@ -580,6 +756,7 @@ static const struct stm32_rtc_data stm32h7_rtc_data = {
 		.wpr = 0x24,
 		.sr = 0x0C, /* set to ISR offset to ease alarm management */
 		.scr = UNDEF_REG,
+		.cfgr = UNDEF_REG,
 		.verr = UNDEF_REG,
 	},
 	.events = {
@@ -600,7 +777,9 @@ static void stm32mp1_rtc_clear_events(struct stm32_rtc *rtc,
 static const struct stm32_rtc_data stm32mp1_data = {
 	.has_pclk = true,
 	.need_dbp = false,
-	.has_wakeirq = true,
+	.has_lsco = true,
+	.has_alarm_out = true,
+	.need_accuracy = true,
 	.regs = {
 		.tr = 0x00,
 		.dr = 0x04,
@@ -611,6 +790,7 @@ static const struct stm32_rtc_data stm32mp1_data = {
 		.wpr = 0x24,
 		.sr = 0x50,
 		.scr = 0x5C,
+		.cfgr = 0x60,
 		.verr = 0x3F4,
 	},
 	.events = {
@@ -633,7 +813,7 @@ static int stm32_rtc_init(struct platform_device *pdev,
 	const struct stm32_rtc_registers *regs = &rtc->data->regs;
 	unsigned int prer, pred_a, pred_s, pred_a_max, pred_s_max, cr;
 	unsigned int rate;
-	int ret = 0;
+	int ret;
 
 	rate = clk_get_rate(rtc->rtc_ck);
 
@@ -641,18 +821,32 @@ static int stm32_rtc_init(struct platform_device *pdev,
 	pred_a_max = STM32_RTC_PRER_PRED_A >> STM32_RTC_PRER_PRED_A_SHIFT;
 	pred_s_max = STM32_RTC_PRER_PRED_S >> STM32_RTC_PRER_PRED_S_SHIFT;
 
-	for (pred_a = pred_a_max; pred_a + 1 > 0; pred_a--) {
-		pred_s = (rate / (pred_a + 1)) - 1;
+	if (rate > (pred_a_max + 1) * (pred_s_max + 1)) {
+		dev_err(&pdev->dev, "rtc_ck rate is too high: %dHz\n", rate);
+		return -EINVAL;
+	}
+
+	if (rtc->data->need_accuracy) {
+		for (pred_a = 0; pred_a <= pred_a_max; pred_a++) {
+			pred_s = (rate / (pred_a + 1)) - 1;
+
+			if (pred_s <= pred_s_max && ((pred_s + 1) * (pred_a + 1)) == rate)
+				break;
+		}
+	} else {
+		for (pred_a = pred_a_max; pred_a + 1 > 0; pred_a--) {
+			pred_s = (rate / (pred_a + 1)) - 1;
 
-		if (((pred_s + 1) * (pred_a + 1)) == rate)
-			break;
+			if (((pred_s + 1) * (pred_a + 1)) == rate)
+				break;
+		}
 	}
 
 	/*
 	 * Can't find a 1Hz, so give priority to RTC power consumption
 	 * by choosing the higher possible value for prediv_a
 	 */
-	if ((pred_s > pred_s_max) || (pred_a > pred_a_max)) {
+	if (pred_s > pred_s_max || pred_a > pred_a_max) {
 		pred_a = pred_a_max;
 		pred_s = (rate / (pred_a + 1)) - 1;
 
@@ -661,6 +855,20 @@ static int stm32_rtc_init(struct platform_device *pdev,
 			 "fast" : "slow");
 	}
 
+	cr = readl_relaxed(rtc->base + regs->cr);
+
+	prer = readl_relaxed(rtc->base + regs->prer);
+	prer &= STM32_RTC_PRER_PRED_S | STM32_RTC_PRER_PRED_A;
+
+	pred_s = (pred_s << STM32_RTC_PRER_PRED_S_SHIFT) &
+		 STM32_RTC_PRER_PRED_S;
+	pred_a = (pred_a << STM32_RTC_PRER_PRED_A_SHIFT) &
+		 STM32_RTC_PRER_PRED_A;
+
+	/* quit if there is nothing to initialize */
+	if ((cr & STM32_RTC_CR_FMT) == 0 && prer == (pred_s | pred_a))
+		return 0;
+
 	stm32_rtc_wpr_unlock(rtc);
 
 	ret = stm32_rtc_enter_init_mode(rtc);
@@ -670,13 +878,10 @@ static int stm32_rtc_init(struct platform_device *pdev,
 		goto end;
 	}
 
-	prer = (pred_s << STM32_RTC_PRER_PRED_S_SHIFT) & STM32_RTC_PRER_PRED_S;
-	writel_relaxed(prer, rtc->base + regs->prer);
-	prer |= (pred_a << STM32_RTC_PRER_PRED_A_SHIFT) & STM32_RTC_PRER_PRED_A;
-	writel_relaxed(prer, rtc->base + regs->prer);
+	writel_relaxed(pred_s, rtc->base + regs->prer);
+	writel_relaxed(pred_a | pred_s, rtc->base + regs->prer);
 
 	/* Force 24h time format */
-	cr = readl_relaxed(rtc->base + regs->cr);
 	cr &= ~STM32_RTC_CR_FMT;
 	writel_relaxed(cr, rtc->base + regs->cr);
 
@@ -736,13 +941,15 @@ static int stm32_rtc_probe(struct platform_device *pdev)
 	} else {
 		rtc->pclk = devm_clk_get(&pdev->dev, "pclk");
 		if (IS_ERR(rtc->pclk)) {
-			dev_err(&pdev->dev, "no pclk clock");
+			if (PTR_ERR(rtc->pclk) != -EPROBE_DEFER)
+				dev_err(&pdev->dev, "no pclk clock");
 			return PTR_ERR(rtc->pclk);
 		}
 		rtc->rtc_ck = devm_clk_get(&pdev->dev, "rtc_ck");
 	}
 	if (IS_ERR(rtc->rtc_ck)) {
-		dev_err(&pdev->dev, "no rtc_ck clock");
+		if (PTR_ERR(rtc->rtc_ck) != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "no rtc_ck clock");
 		return PTR_ERR(rtc->rtc_ck);
 	}
 
@@ -779,19 +986,12 @@ static int stm32_rtc_probe(struct platform_device *pdev)
 	}
 
 	ret = device_init_wakeup(&pdev->dev, true);
-	if (rtc->data->has_wakeirq) {
-		rtc->wakeirq_alarm = platform_get_irq(pdev, 1);
-		if (rtc->wakeirq_alarm > 0) {
-			ret = dev_pm_set_dedicated_wake_irq(&pdev->dev,
-							    rtc->wakeirq_alarm);
-		} else {
-			ret = rtc->wakeirq_alarm;
-			if (rtc->wakeirq_alarm == -EPROBE_DEFER)
-				goto err;
-		}
-	}
 	if (ret)
-		dev_warn(&pdev->dev, "alarm can't wake up the system: %d", ret);
+		goto err;
+
+	ret = dev_pm_set_wake_irq(&pdev->dev, rtc->irq_alarm);
+	if (ret)
+		goto err;
 
 	platform_set_drvdata(pdev, rtc);
 
@@ -814,6 +1014,33 @@ static int stm32_rtc_probe(struct platform_device *pdev)
 		goto err;
 	}
 
+	if (rtc->data->has_alarm_out) {
+		ret = of_property_read_s32(pdev->dev.of_node, "st,alarm", &rtc->out_alarm);
+		if (!ret) {
+			ret = stm32_rtc_out_alarm_config(pdev);
+		} else {
+			stm32_rtc_out_alarm_disable(pdev);
+			rtc->out_alarm = ret;
+			dev_dbg(&pdev->dev, "No alarm out: %d\n", ret);
+		}
+	}
+
+	if (rtc->data->has_lsco) {
+		ret = of_property_read_s32(pdev->dev.of_node,
+					   "st,lsco", &rtc->lsco);
+		if (!ret) {
+			ret = stm32_rtc_clk_lsco_register(pdev);
+			if (ret)
+				dev_warn(&pdev->dev,
+					 "LSCO clock registration failed: %d\n",
+					 ret);
+		} else {
+			stm32_rtc_clk_lsco_disable(pdev);
+			rtc->lsco = ret;
+			dev_dbg(&pdev->dev, "No LSCO clock: %d\n", ret);
+		}
+	}
+
 	/*
 	 * If INITS flag is reset (calendar year field set to 0x00), calendar
 	 * must be initialized
@@ -852,6 +1079,9 @@ static int stm32_rtc_remove(struct platform_device *pdev)
 	const struct stm32_rtc_registers *regs = &rtc->data->regs;
 	unsigned int cr;
 
+	if (!IS_ERR_OR_NULL(rtc->clk_lsco))
+		clk_unregister_gate(rtc->clk_lsco);
+
 	/* Disable interrupts */
 	stm32_rtc_wpr_unlock(rtc);
 	cr = readl_relaxed(rtc->base + regs->cr);
@@ -881,9 +1111,6 @@ static int stm32_rtc_suspend(struct device *dev)
 	if (rtc->data->has_pclk)
 		clk_disable_unprepare(rtc->pclk);
 
-	if (device_may_wakeup(dev))
-		return enable_irq_wake(rtc->irq_alarm);
-
 	return 0;
 }
 
@@ -905,15 +1132,13 @@ static int stm32_rtc_resume(struct device *dev)
 		return ret;
 	}
 
-	if (device_may_wakeup(dev))
-		return disable_irq_wake(rtc->irq_alarm);
-
 	return ret;
 }
 #endif
 
-static SIMPLE_DEV_PM_OPS(stm32_rtc_pm_ops,
-			 stm32_rtc_suspend, stm32_rtc_resume);
+static const struct dev_pm_ops stm32_rtc_pm_ops = {
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(stm32_rtc_suspend, stm32_rtc_resume)
+};
 
 static struct platform_driver stm32_rtc_driver = {
 	.probe		= stm32_rtc_probe,
diff --git a/drivers/soc/Kconfig b/drivers/soc/Kconfig
index e8a30c4c5..c73f79a37 100644
--- a/drivers/soc/Kconfig
+++ b/drivers/soc/Kconfig
@@ -17,6 +17,7 @@ source "drivers/soc/renesas/Kconfig"
 source "drivers/soc/rockchip/Kconfig"
 source "drivers/soc/samsung/Kconfig"
 source "drivers/soc/sifive/Kconfig"
+source "drivers/soc/st/Kconfig"
 source "drivers/soc/sunxi/Kconfig"
 source "drivers/soc/tegra/Kconfig"
 source "drivers/soc/ti/Kconfig"
diff --git a/drivers/soc/Makefile b/drivers/soc/Makefile
index a05e9fbcd..e4909f646 100644
--- a/drivers/soc/Makefile
+++ b/drivers/soc/Makefile
@@ -23,6 +23,7 @@ obj-y				+= renesas/
 obj-$(CONFIG_ARCH_ROCKCHIP)	+= rockchip/
 obj-$(CONFIG_SOC_SAMSUNG)	+= samsung/
 obj-$(CONFIG_SOC_SIFIVE)	+= sifive/
+obj-$(CONFIG_ARCH_STM32)	+= st/
 obj-y				+= sunxi/
 obj-$(CONFIG_ARCH_TEGRA)	+= tegra/
 obj-y				+= ti/
diff --git a/drivers/soc/st/Kconfig b/drivers/soc/st/Kconfig
new file mode 100644
index 000000000..8fde9d232
--- /dev/null
+++ b/drivers/soc/st/Kconfig
@@ -0,0 +1,25 @@
+if ARCH_STM32
+
+config STM32_HDP
+	bool "STMicroelectronics STM32MP157 Hardware Debug Port (HDP) pin control"
+	depends on MACH_STM32MP157 || MACH_STM32MP13
+	default n if MACH_STM32MP157 || MACH_STM32MP13
+	help
+	  The Hardware Debug Port allows the observation of internal signals. By using multiplexers,
+	  up to 16 signals for each of 8-bit output can be observed.
+
+config STM32_HSLV
+	tristate "STMicroelectronics STM32 HSLV driver"
+	depends on OF && MACH_STM32MP13
+	default MACH_STM32MP13
+	help
+	  This driver supports internal high speed low voltage configuration
+	  in the STMicroelectronics STM32 chips.
+
+config STM32_PM_DOMAINS
+	bool "STM32 PM domains"
+	depends on MACH_STM32MP157
+	select PM_GENERIC_DOMAINS
+	default y if MACH_STM32MP157
+
+endif # ARCH_STM32
diff --git a/drivers/soc/st/Makefile b/drivers/soc/st/Makefile
new file mode 100644
index 000000000..b57d95080
--- /dev/null
+++ b/drivers/soc/st/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_STM32_HDP) += stm32_hdp.o
+obj-$(CONFIG_STM32_HSLV) += stm32-hslv.o
+obj-$(CONFIG_STM32_PM_DOMAINS) += stm32_pm_domain.o
diff --git a/drivers/soc/st/stm32-hslv.c b/drivers/soc/st/stm32-hslv.c
new file mode 100644
index 000000000..224b0cbd8
--- /dev/null
+++ b/drivers/soc/st/stm32-hslv.c
@@ -0,0 +1,157 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) STMicroelectronics 2021
+// Authors: Pascal Paillet <p.paillet@st.com>.
+
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+
+#define MAX_HS_VOLTAGE 2700000
+
+struct stm32_hslv_data {
+	struct device *dev;
+	struct regmap *regmap;
+	u32 reg, mask;
+
+	struct regulator *regu;
+	struct notifier_block hslv_nb;
+};
+
+static int hslv_set_speed(struct stm32_hslv_data *priv, int uV)
+{
+	int ret;
+	unsigned int val;
+
+	if (uV < MAX_HS_VOLTAGE) {
+		dev_info(priv->dev, "HSLV high speed\n");
+		ret = regmap_write(priv->regmap, priv->reg, priv->mask);
+		if (ret) {
+			dev_err(priv->dev, "set hslv failed\n");
+			return ret;
+		}
+	} else {
+		/* Check that high speed is not set while voltage is high */
+		ret = regmap_read(priv->regmap, priv->reg, &val);
+		if (ret) {
+			dev_err(priv->dev, "hslv read failed\n");
+			return ret;
+		}
+		WARN_ON(val != 0);
+	}
+
+	return 0;
+}
+
+static int hslv_event(struct notifier_block *nb, unsigned long event,
+		      void *data)
+{
+	struct stm32_hslv_data *priv = container_of(nb, struct stm32_hslv_data,
+						    hslv_nb);
+	int ret;
+
+	if (event & REGULATOR_EVENT_PRE_VOLTAGE_CHANGE) {
+		/* Prevent forbidden high voltage + high speed configuration */
+		dev_info(priv->dev, "HSLV low speed\n");
+		ret = regmap_write(priv->regmap, priv->reg, 0);
+		if (ret) {
+			dev_err(priv->dev, "set hslv failed\n");
+			return ret;
+		}
+	}
+
+	if ((event & REGULATOR_EVENT_VOLTAGE_CHANGE) ||
+	    (event & REGULATOR_EVENT_ABORT_VOLTAGE_CHANGE)) {
+		int uV = (unsigned long)data;
+
+		ret = hslv_set_speed(priv, uV);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int stm32_hslv_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct stm32_hslv_data *priv;
+	int ret, uV;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(struct stm32_hslv_data),
+			    GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->dev = &pdev->dev;
+
+	priv->regu = devm_regulator_get(&pdev->dev, "hslv");
+	if (IS_ERR(priv->regu)) {
+		ret = PTR_ERR(priv->regu);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "cannot get regulator: %d\n", ret);
+		return ret;
+	}
+
+	priv->regmap = syscon_regmap_lookup_by_phandle(np, "st,syscon");
+	if (IS_ERR(priv->regmap)) {
+		if (PTR_ERR(priv->regmap) != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "syscon required\n");
+		return PTR_ERR(priv->regmap);
+	}
+
+	ret = of_property_read_u32_index(np, "st,syscon", 1, &priv->reg);
+	if (ret) {
+		dev_err(&pdev->dev, "syscon offset required !\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32_index(np, "st,syscon", 2, &priv->mask);
+	if (ret) {
+		dev_err(&pdev->dev, "syscon mask required !\n");
+		return ret;
+	}
+
+	uV = regulator_get_voltage(priv->regu);
+	if (uV < 0) {
+		dev_err(priv->dev, "get voltage failed\n");
+		return ret;
+	}
+
+	/* Set initial state */
+	ret = hslv_set_speed(priv, uV);
+	if (ret)
+		return ret;
+
+	priv->hslv_nb.notifier_call = hslv_event;
+
+	ret = devm_regulator_register_notifier(priv->regu,
+					       &priv->hslv_nb);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register HSLV notifier: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct of_device_id __maybe_unused stm32_hslv_of_match[] = {
+	{ .compatible = "st,stm32mp13,hslv", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, stm32_hslv_of_match);
+
+static struct platform_driver stm32_hslv_driver = {
+	.probe = stm32_hslv_probe,
+	.driver = {
+		.name  = "stm32mp13-hslv",
+		.of_match_table = of_match_ptr(stm32_hslv_of_match),
+	},
+};
+module_platform_driver(stm32_hslv_driver);
+
+MODULE_DESCRIPTION("STM32MP1 HSLV config assistant driver");
+MODULE_AUTHOR("Pascal Paillet <p.paillet@st.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/soc/st/stm32_hdp.c b/drivers/soc/st/stm32_hdp.c
new file mode 100644
index 000000000..47687ebd1
--- /dev/null
+++ b/drivers/soc/st/stm32_hdp.c
@@ -0,0 +1,242 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Christophe Roullier <christophe.roullier@st.com>
+ * for STMicroelectronics.
+ */
+
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/init.h>
+#include <linux/of.h>
+#include <linux/module.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinconf-generic.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/suspend.h>
+
+#define HDP_CTRL_ENABLE 1
+#define HDP_CTRL_DISABLE 0
+
+enum {
+	HDP_CTRL = 0,
+	HDP_MUX = 0x4,
+	HDP_VAL = 0x10,
+	HDP_GPOSET = 0x14,
+	HDP_GPOCLR = 0x18,
+	HDP_GPOVAL = 0x1c,
+	HDP_VERR = 0x3f4,
+	HDP_IPIDR = 0x3f8,
+	HDP_SIDR = 0x3fc
+} HDP_register_offsets;
+
+struct data_priv {
+	struct clk *clk;
+	int clk_is_enabled;
+	struct dentry *pwr_dentry;
+	unsigned char __iomem *hdp_membase;
+	unsigned int hdp_ctrl;
+	unsigned int hdp_mux;
+};
+
+/* enable/disable */
+static int stm32_hdp_enable_set(void *data, int val)
+{
+	struct data_priv *e = (struct data_priv *)data;
+
+	if (!e->clk)
+		return -EPERM;
+
+	if (val == 1) {
+		if (clk_prepare_enable(e->clk) < 0) {
+			pr_err("Failed to enable HDP clock\n");
+			return -EPERM;
+		}
+		e->clk_is_enabled = 1;
+	} else {
+		clk_disable_unprepare(e->clk);
+		e->clk_is_enabled = 0;
+	}
+	return 0;
+}
+
+static int stm32_hdp_fops_set(void *data, u64 val)
+{
+	unsigned char __iomem *addr = (unsigned char __iomem *)data;
+
+	writel_relaxed(val, addr);
+
+	return 0;
+}
+
+static int stm32_hdp_fops_get(void *data, u64 *val)
+{
+	unsigned char __iomem *addr = (unsigned char __iomem *)data;
+
+	*val = readl_relaxed(addr);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(stm32_hdp_fops, stm32_hdp_fops_get,
+			stm32_hdp_fops_set, "0x%llx\n");
+
+static int stm32_hdp_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+
+	struct data_priv *data;
+	struct dentry *r;
+
+	int ret;
+	const __be32 *getmuxing;
+	u32 muxing, version;
+
+	if (!np)
+		return -ENODEV;
+
+	data = devm_kzalloc(&pdev->dev, sizeof(struct data_priv), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	data->hdp_membase = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(data->hdp_membase))
+		return PTR_ERR(data->hdp_membase);
+
+	/*  Get HDP clocks */
+	data->clk = devm_clk_get(dev, "hdp");
+	if (IS_ERR(data->clk)) {
+		dev_err(dev, "No HDP CK clock provided...\n");
+		return PTR_ERR(data->clk);
+	}
+
+	/* Enable clock */
+	ret = stm32_hdp_enable_set(data, 1);
+	if (ret != 0)
+		return ret;
+
+	getmuxing = of_get_property(np, "muxing-hdp", NULL);
+	if (!getmuxing) {
+		dev_err(dev,
+			"no muxing-hdp property in node\n");
+		/* Disable clock */
+		ret = stm32_hdp_enable_set(data, 0);
+		if (ret != 0)
+			return ret;
+
+		return -EINVAL;
+	}
+
+	/* add hdp directory */
+	r = debugfs_create_dir("hdp", NULL);
+	if (!r) {
+		dev_err(dev, "Unable to create HDP debugFS\n");
+		/* Disable clock */
+		ret = stm32_hdp_enable_set(data, 0);
+		if (ret != 0)
+			return ret;
+
+		return -ENODEV;
+	}
+
+	debugfs_create_file("ctrl", 0644, r,
+			    data->hdp_membase + HDP_CTRL, &stm32_hdp_fops);
+	debugfs_create_file("mux", 0644, r,
+			    data->hdp_membase + HDP_MUX, &stm32_hdp_fops);
+	debugfs_create_file("val", 0644, r,
+			    data->hdp_membase + HDP_VAL, &stm32_hdp_fops);
+	debugfs_create_file("gposet", 0644, r,
+			    data->hdp_membase + HDP_GPOSET, &stm32_hdp_fops);
+	debugfs_create_file("gpoclr", 0644, r,
+			    data->hdp_membase + HDP_GPOCLR, &stm32_hdp_fops);
+	debugfs_create_file("gpoval", 0644, r,
+			    data->hdp_membase + HDP_GPOVAL, &stm32_hdp_fops);
+
+	/* Enable HDP */
+	writel(HDP_CTRL_ENABLE, data->hdp_membase + HDP_CTRL);
+
+	/* HDP Multiplexing */
+	muxing = of_read_number(getmuxing,
+				of_n_addr_cells(np));
+
+	writel(muxing, data->hdp_membase + HDP_MUX);
+
+	platform_set_drvdata(pdev, data);
+
+	/* Get Majeur, Minor version */
+	version = readl(data->hdp_membase + HDP_VERR);
+
+	dev_info(dev, "STM32 HDP version %d.%d initialized\n",
+		 version >> 4, version & 0x0F);
+
+	return 0;
+}
+
+static int stm32_hdp_remove(struct platform_device *pdev)
+{
+	struct data_priv *data = platform_get_drvdata(pdev);
+
+	/* Disable HDP */
+	writel(HDP_CTRL_DISABLE, data->hdp_membase + HDP_CTRL);
+
+	if (data->clk) {
+		if (data->clk_is_enabled)
+			clk_disable_unprepare(data->clk);
+	}
+
+	pr_info("driver STM32 HDP removed\n");
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int stm32_hdp_suspend(struct device *dev)
+{
+	struct data_priv *data = dev_get_drvdata(dev);
+
+	data->hdp_ctrl = readl_relaxed(data->hdp_membase + HDP_CTRL);
+	data->hdp_mux = readl_relaxed(data->hdp_membase + HDP_MUX);
+
+	pinctrl_pm_select_sleep_state(dev);
+
+	return 0;
+}
+
+static int stm32_hdp_resume(struct device *dev)
+{
+	struct data_priv *data = dev_get_drvdata(dev);
+
+	writel_relaxed(data->hdp_ctrl, data->hdp_membase + HDP_CTRL);
+	writel_relaxed(data->hdp_mux, data->hdp_membase + HDP_MUX);
+
+	pinctrl_pm_select_default_state(dev);
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static SIMPLE_DEV_PM_OPS(stm32_hdp_pm_ops,
+			 stm32_hdp_suspend,
+			 stm32_hdp_resume);
+
+static const struct of_device_id hdp_match[] = {
+	{	.compatible = "st,stm32mp1-hdp",},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, hdp_match);
+
+static struct platform_driver hdp_driver = {
+	.probe = stm32_hdp_probe,
+	.remove = stm32_hdp_remove,
+	.driver = {
+		.name = "hdp",
+		.of_match_table = hdp_match,
+		.pm = &stm32_hdp_pm_ops,
+	},
+};
+
+module_platform_driver(hdp_driver);
diff --git a/drivers/soc/st/stm32_pm_domain.c b/drivers/soc/st/stm32_pm_domain.c
new file mode 100644
index 000000000..0386624c2
--- /dev/null
+++ b/drivers/soc/st/stm32_pm_domain.c
@@ -0,0 +1,212 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ * Author: Olivier Bideau <olivier.bideau@st.com> for STMicroelectronics.
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/pm_domain.h>
+#include <linux/printk.h>
+#include <linux/slab.h>
+
+#define SMC(domain, state)				\
+{							\
+	struct arm_smccc_res res;			\
+	arm_smccc_smc(0x82001008, domain, state, 0,	\
+		      0, 0, 0, 0, &res);		\
+}
+
+#define STM32_SMC_PD_DOMAIN_ON	0
+#define STM32_SMC_PD_DOMAIN_OFF	1
+
+struct stm32_pm_domain {
+	struct device *dev;
+	struct generic_pm_domain genpd;
+	int id;
+};
+
+static int stm32_pd_power_off(struct generic_pm_domain *domain)
+{
+	struct stm32_pm_domain *priv = container_of(domain,
+						    struct stm32_pm_domain,
+						    genpd);
+
+	SMC(priv->id, STM32_SMC_PD_DOMAIN_OFF);
+
+	dev_dbg(priv->dev, "%s OFF\n", domain->name);
+
+	return 0;
+}
+
+static int stm32_pd_power_on(struct generic_pm_domain *domain)
+{
+	struct stm32_pm_domain *priv = container_of(domain,
+						    struct stm32_pm_domain,
+						    genpd);
+
+	SMC(priv->id, STM32_SMC_PD_DOMAIN_ON);
+
+	dev_dbg(priv->dev, "%s ON\n", domain->name);
+
+	return 0;
+}
+
+static void stm32_pm_domain_remove(struct stm32_pm_domain *domain)
+{
+	int ret;
+
+	ret = pm_genpd_remove(&domain->genpd);
+	if (ret)
+		dev_err(domain->dev, "failed to remove PM domain %s: %d\n",
+			domain->genpd.name, ret);
+}
+
+static int stm32_pm_domain_add(struct stm32_pm_domain *domain,
+			       struct device *dev,
+			       struct device_node *np)
+{
+	int ret;
+
+	domain->dev = dev;
+	domain->genpd.name = np->name;
+	domain->genpd.power_off = stm32_pd_power_off;
+	domain->genpd.power_on = stm32_pd_power_on;
+	domain->genpd.flags |= GENPD_FLAG_ACTIVE_WAKEUP;
+
+	ret = of_property_read_u32(np, "reg", &domain->id);
+	if (ret) {
+		dev_err(domain->dev, "no domain ID\n");
+		return ret;
+	}
+
+	ret = pm_genpd_init(&domain->genpd, NULL, 0);
+	if (ret < 0) {
+		dev_err(domain->dev, "failed to initialise PM domain %s: %d\n",
+			np->name, ret);
+		return ret;
+	}
+
+	ret = of_genpd_add_provider_simple(np, &domain->genpd);
+	if (ret < 0) {
+		dev_err(domain->dev, "failed to register PM domain %s: %d\n",
+			np->name, ret);
+		stm32_pm_domain_remove(domain);
+		return ret;
+	}
+
+	dev_info(domain->dev, "domain %s registered\n", np->name);
+
+	return 0;
+}
+
+static void stm32_pm_subdomain_add(struct stm32_pm_domain *domain,
+				   struct device *dev,
+				   struct device_node *np)
+{
+	struct device_node *np_child;
+	int ret;
+
+	for_each_child_of_node(np, np_child) {
+		struct stm32_pm_domain *sub_domain;
+
+		sub_domain = devm_kzalloc(dev, sizeof(*sub_domain), GFP_KERNEL);
+		if (!sub_domain)
+			continue;
+
+		sub_domain->dev = dev;
+		sub_domain->genpd.name = np_child->name;
+		sub_domain->genpd.power_off = stm32_pd_power_off;
+		sub_domain->genpd.power_on = stm32_pd_power_on;
+		sub_domain->genpd.flags |= GENPD_FLAG_ACTIVE_WAKEUP;
+
+		ret = of_property_read_u32(np_child, "reg", &sub_domain->id);
+		if (ret) {
+			dev_err(sub_domain->dev, "no domain ID\n");
+			devm_kfree(dev, sub_domain);
+			continue;
+		}
+
+		ret = pm_genpd_init(&sub_domain->genpd, NULL, 0);
+		if (ret < 0) {
+			dev_err(sub_domain->dev, "failed to initialise PM domain %s: %d\n"
+				, np_child->name, ret);
+			devm_kfree(dev, sub_domain);
+			continue;
+		}
+
+		ret = of_genpd_add_provider_simple(np_child,
+						   &sub_domain->genpd);
+		if (ret < 0) {
+			dev_err(sub_domain->dev, "failed to register PM domain %s: %d\n"
+				, np_child->name, ret);
+			stm32_pm_domain_remove(sub_domain);
+			devm_kfree(dev, sub_domain);
+			continue;
+		}
+
+		ret = pm_genpd_add_subdomain(&domain->genpd,
+					     &sub_domain->genpd);
+
+		if (ret < 0) {
+			dev_err(sub_domain->dev, "failed to add Sub PM domain %s: %d\n"
+				, np_child->name, ret);
+			stm32_pm_domain_remove(sub_domain);
+			devm_kfree(dev, sub_domain);
+			continue;
+		}
+
+		dev_info(sub_domain->dev, "subdomain %s registered\n",
+			 np_child->name);
+	}
+}
+
+static int stm32_pm_domain_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node, *child_np;
+	int ret;
+
+	for_each_child_of_node(np, child_np) {
+		struct stm32_pm_domain *domain;
+
+		domain = devm_kzalloc(dev, sizeof(*domain), GFP_KERNEL);
+		if (!domain)
+			continue;
+
+		ret = stm32_pm_domain_add(domain, dev, child_np);
+		if (ret) {
+			devm_kfree(dev, domain);
+			continue;
+		}
+
+		stm32_pm_subdomain_add(domain, dev, child_np);
+	}
+
+	dev_info(dev, "domains probed\n");
+
+	return 0;
+}
+
+static const struct of_device_id stm32_pm_domain_matches[] = {
+	{ .compatible = "st,stm32mp157c-pd", },
+	{ },
+};
+
+static struct platform_driver stm32_pm_domains_driver = {
+	.probe = stm32_pm_domain_probe,
+	.driver = {
+		.name   = "stm32-pm-domain",
+		.of_match_table = stm32_pm_domain_matches,
+	},
+};
+
+static int __init stm32_pm_domains_init(void)
+{
+	return platform_driver_register(&stm32_pm_domains_driver);
+}
+core_initcall(stm32_pm_domains_init);
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 83e352b0c..bbf6804ac 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -807,6 +807,7 @@ config SPI_SPRD_ADI
 config SPI_STM32
 	tristate "STMicroelectronics STM32 SPI controller"
 	depends on ARCH_STM32 || COMPILE_TEST
+	select SPI_SLAVE
 	help
 	  SPI driver for STMicroelectronics STM32 SoCs.
 
@@ -814,6 +815,17 @@ config SPI_STM32
 	  is not available, the driver automatically falls back to
 	  PIO mode.
 
+config SPI_STM32_OSPI
+	tristate "STMicroelectronics STM32 OCTO SPI controller"
+	depends on ARCH_STM32 || COMPILE_TEST
+	depends on OF
+	depends on SPI_MEM
+	depends on STM32_OMI
+	help
+	  This enables support for the Octo SPI controller in master mode.
+	  This driver does not support generic SPI. The implementation only
+	  supports spi-mem interface.
+
 config SPI_STM32_QSPI
 	tristate "STMicroelectronics STM32 QUAD SPI controller"
 	depends on ARCH_STM32 || COMPILE_TEST
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 699db95c8..4fb30d93f 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -114,6 +114,7 @@ obj-$(CONFIG_SPI_SPRD)			+= spi-sprd.o
 obj-$(CONFIG_SPI_SPRD_ADI)		+= spi-sprd-adi.o
 obj-$(CONFIG_SPI_STM32) 		+= spi-stm32.o
 obj-$(CONFIG_SPI_STM32_QSPI) 		+= spi-stm32-qspi.o
+obj-$(CONFIG_SPI_STM32_OSPI) 		+= spi-stm32-ospi.o
 obj-$(CONFIG_SPI_ST_SSC4)		+= spi-st-ssc4.o
 obj-$(CONFIG_SPI_SUN4I)			+= spi-sun4i.o
 obj-$(CONFIG_SPI_SUN6I)			+= spi-sun6i.o
diff --git a/drivers/spi/spi-mem.c b/drivers/spi/spi-mem.c
index 37f4443ce..96f718634 100644
--- a/drivers/spi/spi-mem.c
+++ b/drivers/spi/spi-mem.c
@@ -795,7 +795,7 @@ int spi_mem_poll_status(struct spi_mem *mem,
 	    op->data.dir != SPI_MEM_DATA_IN)
 		return -EINVAL;
 
-	if (ctlr->mem_ops && ctlr->mem_ops->poll_status) {
+	if (ctlr->mem_ops && ctlr->mem_ops->poll_status && !mem->spi->cs_gpiod) {
 		ret = spi_mem_access_start(mem);
 		if (ret)
 			return ret;
diff --git a/drivers/spi/spi-stm32-ospi.c b/drivers/spi/spi-stm32-ospi.c
new file mode 100644
index 000000000..2eec10abc
--- /dev/null
+++ b/drivers/spi/spi-stm32-ospi.c
@@ -0,0 +1,615 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author(s): Patrice Chotard <patrice.chotard@foss.st.com> for STMicroelectronics.
+ */
+
+#include <memory/stm32-omi.h>
+
+#define STM32_AUTOSUSPEND_DELAY -1
+
+struct stm32_ospi_flash {
+	u32 cs;
+	u32 presc;
+};
+
+struct stm32_ospi {
+	struct device *dev;
+	struct spi_controller *ctrl;
+	struct stm32_omi omi;
+	struct stm32_ospi_flash flash[STM32_OMI_MAX_NORCHIP];
+
+	u32 cr_reg;
+	u32 dcr_reg;
+	unsigned long status_timeout;
+
+	/*
+	 * to protect device configuration, could be different between
+	 * 2 flash access
+	 */
+	struct mutex lock;
+};
+
+static int stm32_ospi_tx_mm(struct stm32_ospi *ospi,
+			    const struct spi_mem_op *op)
+{
+	memcpy_fromio(op->data.buf.in, ospi->omi.mm_base + op->addr.val,
+		      op->data.nbytes);
+	return 0;
+}
+
+static int stm32_ospi_tx_dma(struct stm32_ospi *ospi,
+			     const struct spi_mem_op *op)
+{
+	struct dma_async_tx_descriptor *desc;
+	struct stm32_omi *omi = &ospi->omi;
+	void __iomem *regs_base = omi->regs_base;
+	enum dma_transfer_direction dma_dir;
+	struct dma_chan *dma_ch;
+	struct sg_table sgt;
+	dma_cookie_t cookie;
+	u32 cr, t_out;
+	int err;
+
+	if (op->data.dir == SPI_MEM_DATA_IN) {
+		dma_dir = DMA_DEV_TO_MEM;
+		dma_ch = omi->dma_chrx;
+	} else {
+		dma_dir = DMA_MEM_TO_DEV;
+		dma_ch = omi->dma_chtx;
+	}
+
+	/*
+	 * spi_map_buf return -EINVAL if the buffer is not DMA-able
+	 * (DMA-able: in vmalloc | kmap | virt_addr_valid)
+	 */
+	err = spi_controller_dma_map_mem_op_data(ospi->ctrl, op, &sgt);
+	if (err)
+		return err;
+
+	desc = dmaengine_prep_slave_sg(dma_ch, sgt.sgl, sgt.nents,
+				       dma_dir, DMA_PREP_INTERRUPT);
+	if (!desc) {
+		err = -ENOMEM;
+		goto out_unmap;
+	}
+
+	cr = readl_relaxed(regs_base + OSPI_CR);
+
+	reinit_completion(&omi->dma_completion);
+	desc->callback = stm32_omi_dma_callback;
+	desc->callback_param = &omi->dma_completion;
+	cookie = dmaengine_submit(desc);
+	err = dma_submit_error(cookie);
+	if (err)
+		goto out;
+
+	dma_async_issue_pending(dma_ch);
+
+	writel_relaxed(cr | CR_DMAEN, regs_base + OSPI_CR);
+
+	t_out = sgt.nents * STM32_COMP_TIMEOUT_MS;
+	if (!wait_for_completion_timeout(&omi->dma_completion,
+					 msecs_to_jiffies(t_out)))
+		err = -ETIMEDOUT;
+
+	if (err)
+		dmaengine_terminate_all(dma_ch);
+
+out:
+	writel_relaxed(cr & ~CR_DMAEN, regs_base + OSPI_CR);
+out_unmap:
+	spi_controller_dma_unmap_mem_op_data(ospi->ctrl, op, &sgt);
+
+	return err;
+}
+
+static int stm32_ospi_tx(struct stm32_ospi *ospi, const struct spi_mem_op *op)
+{
+	struct stm32_omi *omi = &ospi->omi;
+	u8 *buf;
+
+	if (!op->data.nbytes)
+		return 0;
+
+	if (ospi->omi.fmode == CR_FMODE_MM)
+		return stm32_ospi_tx_mm(ospi, op);
+	else if (((op->data.dir == SPI_MEM_DATA_IN && omi->dma_chrx) ||
+		 (op->data.dir == SPI_MEM_DATA_OUT && omi->dma_chtx)) &&
+		  op->data.nbytes > 4)
+		if (!stm32_ospi_tx_dma(ospi, op))
+			return 0;
+
+	if (op->data.dir == SPI_MEM_DATA_IN)
+		buf = op->data.buf.in;
+	else
+		buf = (u8 *)op->data.buf.out;
+
+	return stm32_omi_tx_poll(&ospi->omi, buf, op->data.nbytes,
+				 op->data.dir == SPI_MEM_DATA_IN);
+}
+
+static int stm32_ospi_wait_poll_status(struct stm32_ospi *ospi,
+				       const struct spi_mem_op *op)
+{
+	struct stm32_omi *omi = &ospi->omi;
+	void __iomem *regs_base = omi->regs_base;
+	u32 cr;
+
+	reinit_completion(&omi->match_completion);
+	cr = readl_relaxed(regs_base + OSPI_CR);
+	writel_relaxed(cr | CR_SMIE, regs_base + OSPI_CR);
+
+	if (!wait_for_completion_timeout(&omi->match_completion,
+					 msecs_to_jiffies(ospi->status_timeout)))
+		return -ETIMEDOUT;
+
+	writel_relaxed(FCR_CSMF, regs_base + OSPI_FCR);
+
+	return 0;
+}
+
+static int stm32_ospi_get_mode(u8 buswidth)
+{
+	switch (buswidth) {
+	case 8:
+		return CCR_BUSWIDTH_8;
+	case 4:
+		return CCR_BUSWIDTH_4;
+	default:
+		return buswidth;
+	}
+}
+
+static int stm32_ospi_send(struct spi_mem *mem, const struct spi_mem_op *op)
+{
+	struct stm32_ospi *ospi = spi_controller_get_devdata(mem->spi->master);
+	struct stm32_ospi_flash *flash = &ospi->flash[mem->spi->chip_select];
+	void __iomem *regs_base = ospi->omi.regs_base;
+	struct stm32_omi *omi = &ospi->omi;
+	u32 ccr, cr, dcr2, tcr;
+	int timeout, err = 0, err_poll_status = 0;
+
+	dev_dbg(ospi->dev, "cmd:%#x mode:%d.%d.%d.%d addr:%#llx len:%#x\n",
+		op->cmd.opcode, op->cmd.buswidth, op->addr.buswidth,
+		op->dummy.buswidth, op->data.buswidth,
+		op->addr.val, op->data.nbytes);
+
+	cr = readl_relaxed(regs_base + OSPI_CR);
+	cr &= ~CR_CSSEL;
+	cr |= FIELD_PREP(CR_CSSEL, flash->cs);
+	cr &= ~CR_FMODE_MASK;
+	cr |= FIELD_PREP(CR_FMODE_MASK, omi->fmode);
+	writel_relaxed(cr, regs_base + OSPI_CR);
+
+	if (op->data.nbytes)
+		writel_relaxed(op->data.nbytes - 1, regs_base + OSPI_DLR);
+
+	/* set prescaler */
+	dcr2 = readl_relaxed(regs_base + OSPI_DCR2);
+	dcr2 |= FIELD_PREP(DCR2_PRESC_MASK, flash->presc);
+	writel_relaxed(dcr2, regs_base + OSPI_DCR2);
+
+	ccr = FIELD_PREP(CCR_IMODE_MASK, stm32_ospi_get_mode(op->cmd.buswidth));
+
+	if (op->addr.nbytes) {
+		ccr |= FIELD_PREP(CCR_ADMODE_MASK,
+				  stm32_ospi_get_mode(op->addr.buswidth));
+		ccr |= FIELD_PREP(CCR_ADSIZE_MASK, op->addr.nbytes - 1);
+	}
+
+	tcr = TCR_SSHIFT;
+	if (op->dummy.buswidth && op->dummy.nbytes) {
+		tcr |= FIELD_PREP(TCR_DCYC_MASK,
+				  op->dummy.nbytes * 8 / op->dummy.buswidth);
+	}
+	writel_relaxed(tcr, regs_base + OSPI_TCR);
+
+	if (op->data.nbytes) {
+		ccr |= FIELD_PREP(CCR_DMODE_MASK,
+				  stm32_ospi_get_mode(op->data.buswidth));
+	}
+
+	writel_relaxed(ccr, regs_base + OSPI_CCR);
+
+	/* set instruction, must be set after ccr register update */
+	writel_relaxed(op->cmd.opcode, regs_base + OSPI_IR);
+
+	if (op->addr.nbytes && omi->fmode != CR_FMODE_MM)
+		writel_relaxed(op->addr.val, regs_base + OSPI_AR);
+
+	if (omi->fmode == CR_FMODE_APM)
+		err_poll_status = stm32_ospi_wait_poll_status(ospi, op);
+
+	err = stm32_ospi_tx(ospi, op);
+
+	/*
+	 * Abort in:
+	 * -error case
+	 * -read memory map: prefetching must be stopped if we read the last
+	 *  byte of device (device size - fifo size). like device size is not
+	 *  knows, the prefetching is always stop.
+	 */
+	if (err || err_poll_status || omi->fmode == CR_FMODE_MM)
+		goto abort;
+
+	/* wait end of tx in indirect mode */
+	err = stm32_omi_wait_cmd(omi);
+	if (err)
+		goto abort;
+
+	return 0;
+
+abort:
+	timeout = stm32_omi_abort(omi);
+	writel_relaxed(FCR_CTCF | FCR_CSMF, regs_base + OSPI_FCR);
+
+	if (err || err_poll_status || timeout)
+		dev_err(ospi->dev, "%s err:%d err_poll_status:%d abort timeout:%d\n",
+			__func__, err, err_poll_status, timeout);
+
+	return err;
+}
+
+static int stm32_ospi_poll_status(struct spi_mem *mem,
+				  const struct spi_mem_op *op,
+				  u16 mask, u16 match,
+				  unsigned long initial_delay_us,
+				  unsigned long polling_rate_us,
+				  unsigned long timeout_ms)
+{
+	struct stm32_ospi *ospi = spi_controller_get_devdata(mem->spi->master);
+	void __iomem *regs_base = ospi->omi.regs_base;
+	int ret;
+
+	ret = pm_runtime_get_sync(ospi->dev);
+	if (ret < 0) {
+		pm_runtime_put_noidle(ospi->dev);
+		return ret;
+	}
+
+	mutex_lock(&ospi->lock);
+
+	writel_relaxed(mask, regs_base + OSPI_PSMKR);
+	writel_relaxed(match, regs_base + OSPI_PSMAR);
+	ospi->omi.fmode = CR_FMODE_APM;
+	ospi->status_timeout = timeout_ms;
+
+	ret = stm32_ospi_send(mem, op);
+	mutex_unlock(&ospi->lock);
+
+	pm_runtime_mark_last_busy(ospi->dev);
+	pm_runtime_put_autosuspend(ospi->dev);
+
+	return ret;
+}
+
+static int stm32_ospi_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)
+{
+	struct stm32_ospi *ospi = spi_controller_get_devdata(mem->spi->master);
+	int ret;
+
+	ret = pm_runtime_get_sync(ospi->dev);
+	if (ret < 0) {
+		pm_runtime_put_noidle(ospi->dev);
+		return ret;
+	}
+
+	mutex_lock(&ospi->lock);
+	if (op->data.dir == SPI_MEM_DATA_IN && op->data.nbytes)
+		ospi->omi.fmode = CR_FMODE_INDR;
+	else
+		ospi->omi.fmode = CR_FMODE_INDW;
+
+	ret = stm32_ospi_send(mem, op);
+	mutex_unlock(&ospi->lock);
+
+	pm_runtime_mark_last_busy(ospi->dev);
+	pm_runtime_put_autosuspend(ospi->dev);
+
+	return ret;
+}
+
+static int stm32_ospi_dirmap_create(struct spi_mem_dirmap_desc *desc)
+{
+	struct stm32_ospi *ospi = spi_controller_get_devdata(desc->mem->spi->master);
+	struct stm32_omi *omi = &ospi->omi;
+
+	if (desc->info.op_tmpl.data.dir == SPI_MEM_DATA_OUT)
+		return -EOPNOTSUPP;
+
+	/* should never happen, as mm_base == null is an error probe exit condition */
+	if (!omi->mm_base && desc->info.op_tmpl.data.dir == SPI_MEM_DATA_IN)
+		return -EOPNOTSUPP;
+
+	if (!omi->mm_size)
+		return -EOPNOTSUPP;
+
+	return 0;
+}
+
+static ssize_t stm32_ospi_dirmap_read(struct spi_mem_dirmap_desc *desc,
+				      u64 offs, size_t len, void *buf)
+{
+	struct stm32_ospi *ospi = spi_controller_get_devdata(desc->mem->spi->master);
+	struct spi_mem_op op;
+	u32 addr_max;
+	int ret;
+
+	ret = pm_runtime_get_sync(ospi->dev);
+	if (ret < 0) {
+		pm_runtime_put_noidle(ospi->dev);
+		return ret;
+	}
+
+	mutex_lock(&ospi->lock);
+	/* make a local copy of desc op_tmpl and complete dirmap rdesc
+	 * spi_mem_op template with offs, len and *buf in  order to get
+	 * all needed transfer information into struct spi_mem_op
+	 */
+	memcpy(&op, &desc->info.op_tmpl, sizeof(struct spi_mem_op));
+	dev_dbg(ospi->dev, "%s len = 0x%zx offs = 0x%llx buf = 0x%p\n", __func__, len, offs, buf);
+
+	op.data.nbytes = len;
+	op.addr.val = desc->info.offset + offs;
+	op.data.buf.in = buf;
+
+	addr_max = op.addr.val + op.data.nbytes + 1;
+	if (addr_max < ospi->omi.mm_size && op.addr.buswidth)
+		ospi->omi.fmode = CR_FMODE_MM;
+	else
+		ospi->omi.fmode = CR_FMODE_INDR;
+
+	ret = stm32_ospi_send(desc->mem, &op);
+	mutex_unlock(&ospi->lock);
+
+	pm_runtime_mark_last_busy(ospi->dev);
+	pm_runtime_put_autosuspend(ospi->dev);
+
+	return ret ?: len;
+}
+
+static int stm32_ospi_setup(struct spi_device *spi)
+{
+	struct spi_controller *ctrl = spi->master;
+	struct stm32_ospi *ospi = spi_controller_get_devdata(ctrl);
+	struct stm32_ospi_flash *flash;
+	void __iomem *regs_base = ospi->omi.regs_base;
+	u32 presc;
+	int ret;
+
+	if (ctrl->busy)
+		return -EBUSY;
+
+	if (!spi->max_speed_hz)
+		return -EINVAL;
+
+	ret = pm_runtime_get_sync(ospi->dev);
+	if (ret < 0) {
+		pm_runtime_put_noidle(ospi->dev);
+		return ret;
+	}
+
+	presc = DIV_ROUND_UP(ospi->omi.clk_rate, spi->max_speed_hz) - 1;
+
+	flash = &ospi->flash[spi->chip_select];
+	flash->cs = spi->chip_select;
+	flash->presc = presc;
+
+	mutex_lock(&ospi->lock);
+
+	ospi->cr_reg = CR_APMS | 3 << CR_FTHRES_SHIFT | CR_EN;
+	writel_relaxed(ospi->cr_reg, regs_base + OSPI_CR);
+
+	/* set dcr fsize to max address */
+	ospi->dcr_reg = DCR1_DEVSIZE_MASK | DCR1_DLYBYP;
+	writel_relaxed(ospi->dcr_reg, regs_base + OSPI_DCR1);
+
+	mutex_unlock(&ospi->lock);
+
+	pm_runtime_mark_last_busy(ospi->dev);
+	pm_runtime_put_autosuspend(ospi->dev);
+
+	return 0;
+}
+
+/*
+ * no special host constraint, so use default spi_mem_default_supports_op
+ * to check supported mode.
+ */
+static const struct spi_controller_mem_ops stm32_ospi_mem_ops = {
+	.exec_op	= stm32_ospi_exec_op,
+	.dirmap_create	= stm32_ospi_dirmap_create,
+	.dirmap_read	= stm32_ospi_dirmap_read,
+	.poll_status	= stm32_ospi_poll_status,
+};
+
+static int stm32_ospi_probe(struct platform_device *pdev)
+{
+	struct device *parent = pdev->dev.parent;
+	struct platform_device *ppdev = to_platform_device(parent);
+	struct device *dev = &ppdev->dev;
+	struct spi_controller *ctrl;
+	struct stm32_ospi *ospi;
+	struct stm32_omi *omi;
+	struct dma_slave_config dma_cfg;
+	int ret;
+
+	ctrl = devm_spi_alloc_master(&ppdev->dev, sizeof(*ospi));
+	if (!ctrl)
+		return -ENOMEM;
+
+	ospi = spi_controller_get_devdata(ctrl);
+	ospi->ctrl = ctrl;
+	omi = &ospi->omi;
+	omi->dev = &pdev->dev;
+
+	ret = stm32_omi_get_resources(omi, parent);
+	if (ret)
+		return ret;
+
+	omi->clk_rate = clk_get_rate(omi->clk);
+	if (!omi->clk_rate) {
+		dev_err(dev, "Invalid clock rate\n");
+		return -EINVAL;
+	}
+
+	ret = clk_prepare_enable(omi->clk);
+	if (ret) {
+		dev_err(dev, "Can not enable clock\n");
+		return ret;
+	}
+
+	ret = devm_request_irq(dev, omi->irq, stm32_omi_irq, 0,
+			       dev_name(dev), omi);
+	if (ret) {
+		dev_err(dev, "Failed to request irq\n");
+		goto err_clk_disable;
+	}
+
+	init_completion(&omi->data_completion);
+	init_completion(&omi->match_completion);
+
+	ospi->dev = dev;
+	platform_set_drvdata(pdev, ospi);
+
+	memset(&dma_cfg, 0, sizeof(dma_cfg));
+	dma_cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+	dma_cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+	dma_cfg.src_addr = ospi->omi.regs_phys_base + OSPI_DR;
+	dma_cfg.dst_addr = ospi->omi.regs_phys_base + OSPI_DR;
+	dma_cfg.src_maxburst = 4;
+	dma_cfg.dst_maxburst = 4;
+
+	ret = stm32_omi_dma_setup(omi, dev, &dma_cfg);
+	if (ret)
+		goto err_dma_free;
+
+	mutex_init(&ospi->lock);
+
+	ctrl->mode_bits = SPI_RX_DUAL | SPI_RX_QUAD |
+			  SPI_TX_DUAL | SPI_TX_QUAD |
+			  SPI_TX_OCTAL | SPI_RX_OCTAL;
+	ctrl->setup = stm32_ospi_setup;
+	ctrl->bus_num = -1;
+	ctrl->mem_ops = &stm32_ospi_mem_ops;
+	ctrl->num_chipselect = STM32_OMI_MAX_NORCHIP;
+	ctrl->dev.of_node = ospi->dev->of_node;
+
+	pm_runtime_set_autosuspend_delay(ospi->dev, STM32_AUTOSUSPEND_DELAY);
+	pm_runtime_use_autosuspend(ospi->dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_get_noresume(dev);
+
+	ret = spi_register_master(ctrl);
+	if (ret)
+		goto err_pm_runtime_free;
+
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
+	return 0;
+
+err_pm_runtime_free:
+	pm_runtime_get_sync(dev);
+	/* disable ospi */
+	writel_relaxed(0, omi->regs_base + OSPI_CR);
+	mutex_destroy(&ospi->lock);
+	pm_runtime_put_noidle(dev);
+	pm_runtime_disable(dev);
+	pm_runtime_set_suspended(dev);
+	pm_runtime_dont_use_autosuspend(dev);
+err_dma_free:
+	stm32_omi_dma_free(omi);
+err_clk_disable:
+	clk_disable_unprepare(omi->clk);
+
+	return ret;
+}
+
+static int stm32_ospi_remove(struct platform_device *pdev)
+{
+	struct stm32_ospi *ospi = platform_get_drvdata(pdev);
+
+	pm_runtime_get_sync(ospi->dev);
+	spi_unregister_master(ospi->ctrl);
+	/* disable ospi */
+	writel_relaxed(0, ospi->omi.regs_base + OSPI_CR);
+	stm32_omi_dma_free(&ospi->omi);
+	mutex_destroy(&ospi->lock);
+	pm_runtime_put_noidle(ospi->dev);
+	pm_runtime_disable(ospi->dev);
+	pm_runtime_set_suspended(ospi->dev);
+	pm_runtime_dont_use_autosuspend(ospi->dev);
+	clk_disable_unprepare(ospi->omi.clk);
+
+	return 0;
+}
+
+static int __maybe_unused stm32_ospi_runtime_suspend(struct device *dev)
+{
+	struct stm32_ospi *ospi = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(ospi->omi.clk);
+
+	return 0;
+}
+
+static int __maybe_unused stm32_ospi_runtime_resume(struct device *dev)
+{
+	struct stm32_ospi *ospi = dev_get_drvdata(dev);
+
+	return clk_prepare_enable(ospi->omi.clk);
+}
+
+static int __maybe_unused stm32_ospi_suspend(struct device *dev)
+{
+	pinctrl_pm_select_sleep_state(dev);
+
+	return pm_runtime_force_suspend(dev);
+}
+
+static int __maybe_unused stm32_ospi_resume(struct device *dev)
+{
+	struct stm32_ospi *ospi = dev_get_drvdata(dev);
+	void __iomem *regs_base = ospi->omi.regs_base;
+	int ret;
+
+	ret = pm_runtime_force_resume(dev);
+	if (ret < 0)
+		return ret;
+
+	pinctrl_pm_select_default_state(dev);
+
+	ret = pm_runtime_resume_and_get(dev);
+	if (ret < 0)
+		return ret;
+
+	writel_relaxed(ospi->cr_reg, regs_base + OSPI_CR);
+	writel_relaxed(ospi->dcr_reg, regs_base + OSPI_DCR1);
+
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
+	return 0;
+}
+
+static const struct dev_pm_ops stm32_ospi_pm_ops = {
+	SET_RUNTIME_PM_OPS(stm32_ospi_runtime_suspend,
+			   stm32_ospi_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(stm32_ospi_suspend, stm32_ospi_resume)
+};
+
+static struct platform_driver stm32_ospi_driver = {
+	.probe	= stm32_ospi_probe,
+	.remove	= stm32_ospi_remove,
+	.driver	= {
+		.name = "stm32-ospi",
+		.pm = &stm32_ospi_pm_ops,
+	},
+};
+module_platform_driver(stm32_ospi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics STM32 OCTO SPI driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/spi/spi-stm32-qspi.c b/drivers/spi/spi-stm32-qspi.c
index dd38cb8ff..00e84f3cb 100644
--- a/drivers/spi/spi-stm32-qspi.c
+++ b/drivers/spi/spi-stm32-qspi.c
@@ -15,6 +15,7 @@
 #include <linux/mutex.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
+#include <linux/of_gpio.h>
 #include <linux/pinctrl/consumer.h>
 #include <linux/pm_runtime.h>
 #include <linux/platform_device.h>
@@ -299,15 +300,11 @@ static int stm32_qspi_wait_nobusy(struct stm32_qspi *qspi)
 						 STM32_BUSY_TIMEOUT_US);
 }
 
-static int stm32_qspi_wait_cmd(struct stm32_qspi *qspi,
-			       const struct spi_mem_op *op)
+static int stm32_qspi_wait_cmd(struct stm32_qspi *qspi)
 {
 	u32 cr, sr;
 	int err = 0;
 
-	if (!op->data.nbytes)
-		goto wait_nobusy;
-
 	if ((readl_relaxed(qspi->io_base + QSPI_SR) & SR_TCF) ||
 	    qspi->fmode == CCR_FMODE_APM)
 		goto out;
@@ -328,15 +325,13 @@ static int stm32_qspi_wait_cmd(struct stm32_qspi *qspi,
 out:
 	/* clear flags */
 	writel_relaxed(FCR_CTCF | FCR_CTEF, qspi->io_base + QSPI_FCR);
-wait_nobusy:
 	if (!err)
 		err = stm32_qspi_wait_nobusy(qspi);
 
 	return err;
 }
 
-static int stm32_qspi_wait_poll_status(struct stm32_qspi *qspi,
-				       const struct spi_mem_op *op)
+static int stm32_qspi_wait_poll_status(struct stm32_qspi *qspi)
 {
 	u32 cr;
 
@@ -353,7 +348,7 @@ static int stm32_qspi_wait_poll_status(struct stm32_qspi *qspi,
 	return 0;
 }
 
-static int stm32_qspi_get_mode(struct stm32_qspi *qspi, u8 buswidth)
+static int stm32_qspi_get_mode(u8 buswidth)
 {
 	if (buswidth == 4)
 		return CCR_BUSWIDTH_4;
@@ -361,10 +356,10 @@ static int stm32_qspi_get_mode(struct stm32_qspi *qspi, u8 buswidth)
 	return buswidth;
 }
 
-static int stm32_qspi_send(struct spi_mem *mem, const struct spi_mem_op *op)
+static int stm32_qspi_send(struct spi_device *spi, const struct spi_mem_op *op)
 {
-	struct stm32_qspi *qspi = spi_controller_get_devdata(mem->spi->master);
-	struct stm32_qspi_flash *flash = &qspi->flash[mem->spi->chip_select];
+	struct stm32_qspi *qspi = spi_controller_get_devdata(spi->master);
+	struct stm32_qspi_flash *flash = &qspi->flash[spi->chip_select];
 	u32 ccr, cr;
 	int timeout, err = 0, err_poll_status = 0;
 
@@ -373,10 +368,6 @@ static int stm32_qspi_send(struct spi_mem *mem, const struct spi_mem_op *op)
 		op->dummy.buswidth, op->data.buswidth,
 		op->addr.val, op->data.nbytes);
 
-	err = stm32_qspi_wait_nobusy(qspi);
-	if (err)
-		goto abort;
-
 	cr = readl_relaxed(qspi->io_base + QSPI_CR);
 	cr &= ~CR_PRESC_MASK & ~CR_FSEL;
 	cr |= FIELD_PREP(CR_PRESC_MASK, flash->presc);
@@ -390,11 +381,11 @@ static int stm32_qspi_send(struct spi_mem *mem, const struct spi_mem_op *op)
 	ccr = qspi->fmode;
 	ccr |= FIELD_PREP(CCR_INST_MASK, op->cmd.opcode);
 	ccr |= FIELD_PREP(CCR_IMODE_MASK,
-			  stm32_qspi_get_mode(qspi, op->cmd.buswidth));
+			  stm32_qspi_get_mode(op->cmd.buswidth));
 
 	if (op->addr.nbytes) {
 		ccr |= FIELD_PREP(CCR_ADMODE_MASK,
-				  stm32_qspi_get_mode(qspi, op->addr.buswidth));
+				  stm32_qspi_get_mode(op->addr.buswidth));
 		ccr |= FIELD_PREP(CCR_ADSIZE_MASK, op->addr.nbytes - 1);
 	}
 
@@ -404,7 +395,7 @@ static int stm32_qspi_send(struct spi_mem *mem, const struct spi_mem_op *op)
 
 	if (op->data.nbytes) {
 		ccr |= FIELD_PREP(CCR_DMODE_MASK,
-				  stm32_qspi_get_mode(qspi, op->data.buswidth));
+				  stm32_qspi_get_mode(op->data.buswidth));
 	}
 
 	writel_relaxed(ccr, qspi->io_base + QSPI_CCR);
@@ -413,7 +404,7 @@ static int stm32_qspi_send(struct spi_mem *mem, const struct spi_mem_op *op)
 		writel_relaxed(op->addr.val, qspi->io_base + QSPI_AR);
 
 	if (qspi->fmode == CCR_FMODE_APM)
-		err_poll_status = stm32_qspi_wait_poll_status(qspi, op);
+		err_poll_status = stm32_qspi_wait_poll_status(qspi);
 
 	err = stm32_qspi_tx(qspi, op);
 
@@ -428,7 +419,7 @@ static int stm32_qspi_send(struct spi_mem *mem, const struct spi_mem_op *op)
 		goto abort;
 
 	/* wait end of tx in indirect mode */
-	err = stm32_qspi_wait_cmd(qspi, op);
+	err = stm32_qspi_wait_cmd(qspi);
 	if (err)
 		goto abort;
 
@@ -477,7 +468,7 @@ static int stm32_qspi_poll_status(struct spi_mem *mem, const struct spi_mem_op *
 	qspi->fmode = CCR_FMODE_APM;
 	qspi->status_timeout = timeout_ms;
 
-	ret = stm32_qspi_send(mem, op);
+	ret = stm32_qspi_send(mem->spi, op);
 	mutex_unlock(&qspi->lock);
 
 	pm_runtime_mark_last_busy(qspi->dev);
@@ -503,7 +494,7 @@ static int stm32_qspi_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)
 	else
 		qspi->fmode = CCR_FMODE_INDW;
 
-	ret = stm32_qspi_send(mem, op);
+	ret = stm32_qspi_send(mem->spi, op);
 	mutex_unlock(&qspi->lock);
 
 	pm_runtime_mark_last_busy(qspi->dev);
@@ -561,7 +552,7 @@ static ssize_t stm32_qspi_dirmap_read(struct spi_mem_dirmap_desc *desc,
 	else
 		qspi->fmode = CCR_FMODE_INDR;
 
-	ret = stm32_qspi_send(desc->mem, &op);
+	ret = stm32_qspi_send(desc->mem->spi, &op);
 	mutex_unlock(&qspi->lock);
 
 	pm_runtime_mark_last_busy(qspi->dev);
@@ -570,12 +561,96 @@ static ssize_t stm32_qspi_dirmap_read(struct spi_mem_dirmap_desc *desc,
 	return ret ?: len;
 }
 
+static int stm32_qspi_transfer_one_message(struct spi_controller *ctrl,
+					   struct spi_message *msg)
+{
+	struct stm32_qspi *qspi = spi_controller_get_devdata(ctrl);
+	struct spi_transfer *transfer;
+	struct spi_device *spi = msg->spi;
+	struct spi_mem_op op;
+	int ret = 0;
+
+	if (!spi->cs_gpiod)
+		return -EOPNOTSUPP;
+
+	ret = pm_runtime_resume_and_get(qspi->dev);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&qspi->lock);
+
+	gpiod_set_value_cansleep(spi->cs_gpiod, true);
+
+	list_for_each_entry(transfer, &msg->transfers, transfer_list) {
+		u8 dummy_bytes = 0;
+
+		memset(&op, 0, sizeof(op));
+
+		dev_dbg(qspi->dev, "tx_buf:%p tx_nbits:%d rx_buf:%p rx_nbits:%d len:%d dummy_data:%d\n",
+			transfer->tx_buf, transfer->tx_nbits,
+			transfer->rx_buf, transfer->rx_nbits,
+			transfer->len, transfer->dummy_data);
+
+		/*
+		 * QSPI hardware supports dummy bytes transfer.
+		 * If current transfer is dummy byte, merge it with the next
+		 * transfer in order to take into account QSPI block constraint
+		 */
+		if (transfer->dummy_data) {
+			op.dummy.buswidth = transfer->tx_nbits;
+			op.dummy.nbytes = transfer->len;
+			dummy_bytes = transfer->len;
+
+			/* if happens, means that message is not correctly built */
+			if (list_is_last(&transfer->transfer_list, &msg->transfers)) {
+				ret = -EINVAL;
+				goto end_of_transfer;
+			}
+
+			transfer = list_next_entry(transfer, transfer_list);
+		}
+
+		op.data.nbytes = transfer->len;
+
+		if (transfer->rx_buf) {
+			qspi->fmode = CCR_FMODE_INDR;
+			op.data.buswidth = transfer->rx_nbits;
+			op.data.dir = SPI_MEM_DATA_IN;
+			op.data.buf.in = transfer->rx_buf;
+		} else {
+			qspi->fmode = CCR_FMODE_INDW;
+			op.data.buswidth = transfer->tx_nbits;
+			op.data.dir = SPI_MEM_DATA_OUT;
+			op.data.buf.out = transfer->tx_buf;
+		}
+
+		ret = stm32_qspi_send(spi, &op);
+		if (ret)
+			goto end_of_transfer;
+
+		msg->actual_length += transfer->len + dummy_bytes;
+	}
+
+end_of_transfer:
+	gpiod_set_value_cansleep(spi->cs_gpiod, false);
+
+	mutex_unlock(&qspi->lock);
+
+	msg->status = ret;
+	spi_finalize_current_message(ctrl);
+
+	pm_runtime_mark_last_busy(qspi->dev);
+	pm_runtime_put_autosuspend(qspi->dev);
+
+	return ret;
+}
+
 static int stm32_qspi_setup(struct spi_device *spi)
 {
 	struct spi_controller *ctrl = spi->master;
 	struct stm32_qspi *qspi = spi_controller_get_devdata(ctrl);
 	struct stm32_qspi_flash *flash;
-	u32 presc;
+	u32 presc, mode;
 	int ret;
 
 	if (ctrl->busy)
@@ -584,6 +659,16 @@ static int stm32_qspi_setup(struct spi_device *spi)
 	if (!spi->max_speed_hz)
 		return -EINVAL;
 
+	mode = spi->mode & (SPI_TX_OCTAL | SPI_RX_OCTAL);
+	if ((mode == SPI_TX_OCTAL || mode == SPI_RX_OCTAL) ||
+	    ((mode == (SPI_TX_OCTAL | SPI_RX_OCTAL)) &&
+	    gpiod_count(qspi->dev, "cs") == -ENOENT)) {
+		dev_err(qspi->dev, "spi-rx-bus-width\\/spi-tx-bus-width\\/cs-gpios\n");
+		dev_err(qspi->dev, "configuration not supported\n");
+
+		return -EINVAL;
+	}
+
 	ret = pm_runtime_get_sync(qspi->dev);
 	if (ret < 0) {
 		pm_runtime_put_noidle(qspi->dev);
@@ -598,6 +683,16 @@ static int stm32_qspi_setup(struct spi_device *spi)
 
 	mutex_lock(&qspi->lock);
 	qspi->cr_reg = CR_APMS | 3 << CR_FTHRES_SHIFT | CR_SSHIFT | CR_EN;
+
+	/*
+	 * Dual flash mode is only enable in case SPI_TX_OCTAL and SPI_TX_OCTAL
+	 * are both set in spi->mode and "cs-gpios" properties is found in DT
+	 */
+	if (mode == (SPI_TX_OCTAL | SPI_RX_OCTAL)) {
+		qspi->cr_reg |= CR_DFM;
+		dev_dbg(qspi->dev, "Dual flash mode enable");
+	}
+
 	writel_relaxed(qspi->cr_reg, qspi->io_base + QSPI_CR);
 
 	/* set dcr fsize to max address */
@@ -759,11 +854,13 @@ static int stm32_qspi_probe(struct platform_device *pdev)
 
 	mutex_init(&qspi->lock);
 
-	ctrl->mode_bits = SPI_RX_DUAL | SPI_RX_QUAD
-		| SPI_TX_DUAL | SPI_TX_QUAD;
+	ctrl->mode_bits = SPI_RX_DUAL | SPI_RX_QUAD | SPI_TX_OCTAL
+		| SPI_TX_DUAL | SPI_TX_QUAD | SPI_RX_OCTAL;
 	ctrl->setup = stm32_qspi_setup;
 	ctrl->bus_num = -1;
 	ctrl->mem_ops = &stm32_qspi_mem_ops;
+	ctrl->use_gpio_descriptors = true;
+	ctrl->transfer_one_message = stm32_qspi_transfer_one_message;
 	ctrl->num_chipselect = STM32_QSPI_MAX_NORCHIP;
 	ctrl->dev.of_node = dev->of_node;
 
diff --git a/drivers/spi/spi-stm32.c b/drivers/spi/spi-stm32.c
index 9bd3fd165..55af692f5 100644
--- a/drivers/spi/spi-stm32.c
+++ b/drivers/spi/spi-stm32.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 //
-// STMicroelectronics STM32 SPI Controller driver (master mode only)
+// STMicroelectronics STM32 SPI Controller driver
 //
 // Copyright (C) 2017, STMicroelectronics - All Rights Reserved
 // Author(s): Amelie Delaunay <amelie.delaunay@st.com> for STMicroelectronics.
@@ -18,6 +18,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/reset.h>
 #include <linux/spi/spi.h>
+#include <dt-bindings/spi/spi-stm32.h>
 
 #define DRIVER_NAME "spi_stm32"
 
@@ -84,6 +85,7 @@
 #define STM32H7_SPI_IFCR		0x18
 #define STM32H7_SPI_TXDR		0x20
 #define STM32H7_SPI_RXDR		0x30
+#define STM32H7_SPI_UDRDR		0x4C
 #define STM32H7_SPI_I2SCFGR		0x50
 
 /* STM32H7_SPI_CR1 bit fields */
@@ -101,6 +103,14 @@
 /* STM32H7_SPI_CFG1 bit fields */
 #define STM32H7_SPI_CFG1_DSIZE		GENMASK(4, 0)
 #define STM32H7_SPI_CFG1_FTHLV		GENMASK(8, 5)
+#define STM32H7_SPI_CFG1_UDRDET		GENMASK(12, 11)
+#define STM32H7_SPI_CFG1_UDRDET_BEGIN	0
+#define STM32H7_SPI_CFG1_UDRDET_LAST	1
+#define STM32H7_SPI_CFG1_UDRDET_SS	2
+#define STM32H7_SPI_CFG1_UDRCFG		GENMASK(10, 9)
+#define STM32H7_SPI_CFG1_UDRCFG_PTRN	0
+#define STM32H7_SPI_CFG1_UDRCFG_LAST_R	1
+#define STM32H7_SPI_CFG1_UDRCFG_LAST_T	2
 #define STM32H7_SPI_CFG1_RXDMAEN	BIT(14)
 #define STM32H7_SPI_CFG1_TXDMAEN	BIT(15)
 #define STM32H7_SPI_CFG1_MBR		GENMASK(30, 28)
@@ -117,6 +127,7 @@
 #define STM32H7_SPI_CFG2_CPHA		BIT(24)
 #define STM32H7_SPI_CFG2_CPOL		BIT(25)
 #define STM32H7_SPI_CFG2_SSM		BIT(26)
+#define STM32H7_SPI_CFG2_SSIOP		BIT(28)
 #define STM32H7_SPI_CFG2_AFCNTR		BIT(31)
 
 /* STM32H7_SPI_IER bit fields */
@@ -125,6 +136,7 @@
 #define STM32H7_SPI_IER_DXPIE		BIT(2)
 #define STM32H7_SPI_IER_EOTIE		BIT(3)
 #define STM32H7_SPI_IER_TXTFIE		BIT(4)
+#define STM32H7_SPI_IER_UDRIE		BIT(5)
 #define STM32H7_SPI_IER_OVRIE		BIT(6)
 #define STM32H7_SPI_IER_MODFIE		BIT(9)
 #define STM32H7_SPI_IER_ALL		GENMASK(10, 0)
@@ -133,6 +145,7 @@
 #define STM32H7_SPI_SR_RXP		BIT(0)
 #define STM32H7_SPI_SR_TXP		BIT(1)
 #define STM32H7_SPI_SR_EOT		BIT(3)
+#define STM32H7_SPI_SR_UDR		BIT(5)
 #define STM32H7_SPI_SR_OVR		BIT(6)
 #define STM32H7_SPI_SR_MODF		BIT(9)
 #define STM32H7_SPI_SR_SUSP		BIT(11)
@@ -170,6 +183,10 @@
  */
 #define SPI_DMA_MIN_BYTES	16
 
+/* STM32 SPI driver helpers */
+#define STM32_SPI_MASTER_MODE(stm32_spi) (!(stm32_spi)->slave_mode)
+#define STM32_SPI_SLAVE_MODE(stm32_spi) ((stm32_spi)->slave_mode)
+
 /**
  * struct stm32_spi_reg - stm32 SPI register & bitfield desc
  * @reg:		register offset
@@ -190,6 +207,7 @@ struct stm32_spi_reg {
  * @cpol: clock polarity register and polarity bit
  * @cpha: clock phase register and phase bit
  * @lsb_first: LSB transmitted first register and bit
+ * @cs_high: chips select active value
  * @br: baud rate register and bitfields
  * @rx: SPI RX data register
  * @tx: SPI TX data register
@@ -201,6 +219,7 @@ struct stm32_spi_regspec {
 	const struct stm32_spi_reg cpol;
 	const struct stm32_spi_reg cpha;
 	const struct stm32_spi_reg lsb_first;
+	const struct stm32_spi_reg cs_high;
 	const struct stm32_spi_reg br;
 	const struct stm32_spi_reg rx;
 	const struct stm32_spi_reg tx;
@@ -221,7 +240,6 @@ struct stm32_spi;
  * time between frames (if driver has this functionality)
  * @set_number_of_data: optional routine to configure registers to desired
  * number of data (if driver has this functionality)
- * @can_dma: routine to determine if the transfer is eligible for DMA use
  * @transfer_one_dma_start: routine to start transfer a single spi_transfer
  * using DMA
  * @dma_rx_cb: routine to call after DMA RX channel operation is complete
@@ -232,7 +250,10 @@ struct stm32_spi;
  * @baud_rate_div_min: minimum baud rate divisor
  * @baud_rate_div_max: maximum baud rate divisor
  * @has_fifo: boolean to know if fifo is used for driver
- * @has_startbit: boolean to know if start bit is used to start transfer
+ * @set_slave_udr: routine to configure registers to desired slave underrun
+ * behavior (if driver has this functionality)
+ * @flags: compatible specific SPI controller flags used at registration time
+ * @prevent_dma_burst: boolean to indicate to prevent DMA burst
  */
 struct stm32_spi_cfg {
 	const struct stm32_spi_regspec *regs;
@@ -253,12 +274,15 @@ struct stm32_spi_cfg {
 	unsigned int baud_rate_div_min;
 	unsigned int baud_rate_div_max;
 	bool has_fifo;
+	void (*set_slave_udr)(struct stm32_spi *spi);
+	u16 flags;
+	bool prevent_dma_burst;
 };
 
 /**
  * struct stm32_spi - private data of the SPI controller
  * @dev: driver model representation of the controller
- * @master: controller master interface
+ * @ctrl: controller interface
  * @cfg: compatible configuration data
  * @base: virtual memory area
  * @clk: hw kernel clock feeding the SPI clock generator
@@ -280,10 +304,13 @@ struct stm32_spi_cfg {
  * @dma_tx: dma channel for TX transfer
  * @dma_rx: dma channel for RX transfer
  * @phys_addr: SPI registers physical base address
+ * @slave_mode: the controller is configured as SPI slave
+ * @slave_udr_mode: slave underrun behavior
+ * @slave_udr_pattern: slave underrun pattern parameter
  */
 struct stm32_spi {
 	struct device *dev;
-	struct spi_master *master;
+	struct spi_controller *ctrl;
 	const struct stm32_spi_cfg *cfg;
 	void __iomem *base;
 	struct clk *clk;
@@ -307,6 +334,10 @@ struct stm32_spi {
 	struct dma_chan *dma_tx;
 	struct dma_chan *dma_rx;
 	dma_addr_t phys_addr;
+
+	bool slave_mode;
+	u32 slave_udr_mode;
+	u32 slave_udr_pattern;
 };
 
 static const struct stm32_spi_regspec stm32f4_spi_regspec = {
@@ -318,6 +349,7 @@ static const struct stm32_spi_regspec stm32f4_spi_regspec = {
 	.cpol = { STM32F4_SPI_CR1, STM32F4_SPI_CR1_CPOL },
 	.cpha = { STM32F4_SPI_CR1, STM32F4_SPI_CR1_CPHA },
 	.lsb_first = { STM32F4_SPI_CR1, STM32F4_SPI_CR1_LSBFRST },
+	.cs_high = {},
 	.br = { STM32F4_SPI_CR1, STM32F4_SPI_CR1_BR, STM32F4_SPI_CR1_BR_SHIFT },
 
 	.rx = { STM32F4_SPI_DR },
@@ -336,6 +368,7 @@ static const struct stm32_spi_regspec stm32h7_spi_regspec = {
 	.cpol = { STM32H7_SPI_CFG2, STM32H7_SPI_CFG2_CPOL },
 	.cpha = { STM32H7_SPI_CFG2, STM32H7_SPI_CFG2_CPHA },
 	.lsb_first = { STM32H7_SPI_CFG2, STM32H7_SPI_CFG2_LSBFRST },
+	.cs_high = { STM32H7_SPI_CFG2, STM32H7_SPI_CFG2_SSIOP },
 	.br = { STM32H7_SPI_CFG1, STM32H7_SPI_CFG1_MBR,
 		STM32H7_SPI_CFG1_MBR_SHIFT },
 
@@ -437,9 +470,9 @@ static int stm32_spi_prepare_mbr(struct stm32_spi *spi, u32 speed_hz,
 	div = DIV_ROUND_UP(spi->clk_rate & ~0x1, speed_hz);
 
 	/*
-	 * SPI framework set xfer->speed_hz to master->max_speed_hz if
-	 * xfer->speed_hz is greater than master->max_speed_hz, and it returns
-	 * an error when xfer->speed_hz is lower than master->min_speed_hz, so
+	 * SPI framework set xfer->speed_hz to ctrl->max_speed_hz if
+	 * xfer->speed_hz is greater than ctrl->max_speed_hz, and it returns
+	 * an error when xfer->speed_hz is lower than ctrl->min_speed_hz, so
 	 * no need to check it there.
 	 * However, we need to ensure the following calculations.
 	 */
@@ -657,9 +690,9 @@ static void stm32f4_spi_disable(struct stm32_spi *spi)
 	}
 
 	if (spi->cur_usedma && spi->dma_tx)
-		dmaengine_terminate_all(spi->dma_tx);
+		dmaengine_terminate_async(spi->dma_tx);
 	if (spi->cur_usedma && spi->dma_rx)
-		dmaengine_terminate_all(spi->dma_rx);
+		dmaengine_terminate_async(spi->dma_rx);
 
 	stm32_spi_clr_bits(spi, STM32F4_SPI_CR1, STM32F4_SPI_CR1_SPE);
 
@@ -696,9 +729,9 @@ static void stm32h7_spi_disable(struct stm32_spi *spi)
 	}
 
 	if (spi->cur_usedma && spi->dma_tx)
-		dmaengine_terminate_all(spi->dma_tx);
+		dmaengine_terminate_async(spi->dma_tx);
 	if (spi->cur_usedma && spi->dma_rx)
-		dmaengine_terminate_all(spi->dma_rx);
+		dmaengine_terminate_async(spi->dma_rx);
 
 	stm32_spi_clr_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_SPE);
 
@@ -714,19 +747,19 @@ static void stm32h7_spi_disable(struct stm32_spi *spi)
 
 /**
  * stm32_spi_can_dma - Determine if the transfer is eligible for DMA use
- * @master: controller master interface
+ * @ctrl: controller interface
  * @spi_dev: pointer to the spi device
  * @transfer: pointer to spi transfer
  *
  * If driver has fifo and the current transfer size is greater than fifo size,
  * use DMA. Otherwise use DMA for transfer longer than defined DMA min bytes.
  */
-static bool stm32_spi_can_dma(struct spi_master *master,
+static bool stm32_spi_can_dma(struct spi_controller *ctrl,
 			      struct spi_device *spi_dev,
 			      struct spi_transfer *transfer)
 {
 	unsigned int dma_size;
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 
 	if (spi->cfg->has_fifo)
 		dma_size = spi->fifo_size;
@@ -742,12 +775,12 @@ static bool stm32_spi_can_dma(struct spi_master *master,
 /**
  * stm32f4_spi_irq_event - Interrupt handler for SPI controller events
  * @irq: interrupt line
- * @dev_id: SPI controller master interface
+ * @dev_id: SPI controller ctrl interface
  */
 static irqreturn_t stm32f4_spi_irq_event(int irq, void *dev_id)
 {
-	struct spi_master *master = dev_id;
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct spi_controller *ctrl = dev_id;
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 	u32 sr, mask = 0;
 	bool end = false;
 
@@ -830,14 +863,14 @@ static irqreturn_t stm32f4_spi_irq_event(int irq, void *dev_id)
 /**
  * stm32f4_spi_irq_thread - Thread of interrupt handler for SPI controller
  * @irq: interrupt line
- * @dev_id: SPI controller master interface
+ * @dev_id: SPI controller interface
  */
 static irqreturn_t stm32f4_spi_irq_thread(int irq, void *dev_id)
 {
-	struct spi_master *master = dev_id;
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct spi_controller *ctrl = dev_id;
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 
-	spi_finalize_current_transfer(master);
+	spi_finalize_current_transfer(ctrl);
 	stm32f4_spi_disable(spi);
 
 	return IRQ_HANDLED;
@@ -846,12 +879,12 @@ static irqreturn_t stm32f4_spi_irq_thread(int irq, void *dev_id)
 /**
  * stm32h7_spi_irq_thread - Thread of interrupt handler for SPI controller
  * @irq: interrupt line
- * @dev_id: SPI controller master interface
+ * @dev_id: SPI controller interface
  */
 static irqreturn_t stm32h7_spi_irq_thread(int irq, void *dev_id)
 {
-	struct spi_master *master = dev_id;
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct spi_controller *ctrl = dev_id;
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 	u32 sr, ier, mask;
 	unsigned long flags;
 	bool end = false;
@@ -908,6 +941,14 @@ static irqreturn_t stm32h7_spi_irq_thread(int irq, void *dev_id)
 		end = true;
 	}
 
+	if (sr & STM32H7_SPI_SR_UDR) {
+		static DEFINE_RATELIMIT_STATE(rs,
+					      DEFAULT_RATELIMIT_INTERVAL * 10,
+					      1);
+		if (__ratelimit(&rs))
+			dev_dbg_ratelimited(spi->dev, "Underrun detected\n");
+	}
+
 	if (sr & STM32H7_SPI_SR_EOT) {
 		if (!spi->cur_usedma && (spi->rx_buf && (spi->rx_len > 0)))
 			stm32h7_spi_read_rxfifo(spi);
@@ -930,7 +971,7 @@ static irqreturn_t stm32h7_spi_irq_thread(int irq, void *dev_id)
 
 	if (end) {
 		stm32h7_spi_disable(spi);
-		spi_finalize_current_transfer(master);
+		spi_finalize_current_transfer(ctrl);
 	}
 
 	return IRQ_HANDLED;
@@ -938,13 +979,13 @@ static irqreturn_t stm32h7_spi_irq_thread(int irq, void *dev_id)
 
 /**
  * stm32_spi_prepare_msg - set up the controller to transfer a single message
- * @master: controller master interface
+ * @ctrl: controller interface
  * @msg: pointer to spi message
  */
-static int stm32_spi_prepare_msg(struct spi_master *master,
+static int stm32_spi_prepare_msg(struct spi_controller *ctrl,
 				 struct spi_message *msg)
 {
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 	struct spi_device *spi_dev = msg->spi;
 	struct device_node *np = spi_dev->dev.of_node;
 	unsigned long flags;
@@ -970,6 +1011,11 @@ static int stm32_spi_prepare_msg(struct spi_master *master,
 	else
 		clrb |= spi->cfg->regs->lsb_first.mask;
 
+	if (STM32_SPI_SLAVE_MODE(spi) && spi_dev->mode & SPI_CS_HIGH)
+		setb |= spi->cfg->regs->cs_high.mask;
+	else
+		clrb |= spi->cfg->regs->cs_high.mask;
+
 	dev_dbg(spi->dev, "cpol=%d cpha=%d lsb_first=%d cs_high=%d\n",
 		!!(spi_dev->mode & SPI_CPOL),
 		!!(spi_dev->mode & SPI_CPHA),
@@ -983,7 +1029,7 @@ static int stm32_spi_prepare_msg(struct spi_master *master,
 	if (spi->cfg->set_number_of_data) {
 		int ret;
 
-		ret = spi_split_transfers_maxsize(master, msg,
+		ret = spi_split_transfers_maxsize(ctrl, msg,
 						  STM32H7_SPI_TSIZE_MAX,
 						  GFP_KERNEL | GFP_DMA);
 		if (ret)
@@ -1015,7 +1061,7 @@ static void stm32f4_spi_dma_tx_cb(void *data)
 	struct stm32_spi *spi = data;
 
 	if (spi->cur_comm == SPI_SIMPLEX_TX || spi->cur_comm == SPI_3WIRE_TX) {
-		spi_finalize_current_transfer(spi->master);
+		spi_finalize_current_transfer(spi->ctrl);
 		stm32f4_spi_disable(spi);
 	}
 }
@@ -1030,7 +1076,7 @@ static void stm32_spi_dma_rx_cb(void *data)
 {
 	struct stm32_spi *spi = data;
 
-	spi_finalize_current_transfer(spi->master);
+	spi_finalize_current_transfer(spi->ctrl);
 	spi->cfg->disable(spi);
 }
 
@@ -1038,15 +1084,19 @@ static void stm32_spi_dma_rx_cb(void *data)
  * stm32_spi_dma_config - configure dma slave channel depending on current
  *			  transfer bits_per_word.
  * @spi: pointer to the spi controller data structure
+ * @dma_chan: pointer to the DMA channel
  * @dma_conf: pointer to the dma_slave_config structure
  * @dir: direction of the dma transfer
  */
 static void stm32_spi_dma_config(struct stm32_spi *spi,
+				 struct dma_chan *dma_chan,
 				 struct dma_slave_config *dma_conf,
 				 enum dma_transfer_direction dir)
 {
 	enum dma_slave_buswidth buswidth;
-	u32 maxburst;
+	struct dma_slave_caps caps;
+	u32 maxburst = 1;
+	int ret;
 
 	if (spi->cur_bpw <= 8)
 		buswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;
@@ -1055,15 +1105,14 @@ static void stm32_spi_dma_config(struct stm32_spi *spi,
 	else
 		buswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;
 
-	if (spi->cfg->has_fifo) {
-		/* Valid for DMA Half or Full Fifo threshold */
-		if (spi->cur_fthlv == 2)
-			maxburst = 1;
-		else
-			maxburst = spi->cur_fthlv;
-	} else {
-		maxburst = 1;
-	}
+	/* Valid for DMA Half or Full Fifo threshold */
+	if (!spi->cfg->prevent_dma_burst && spi->cfg->has_fifo && spi->cur_fthlv != 2)
+		maxburst = spi->cur_fthlv;
+
+	/* Get the DMA channel caps, and adjust maxburst if possible */
+	ret = dma_get_slave_caps(dma_chan, &caps);
+	if (!ret)
+		maxburst = min(maxburst, caps.max_burst);
 
 	memset(dma_conf, 0, sizeof(struct dma_slave_config));
 	dma_conf->direction = dir;
@@ -1160,7 +1209,11 @@ static int stm32h7_spi_transfer_one_irq(struct stm32_spi *spi)
 	if (spi->tx_buf)
 		stm32h7_spi_write_txfifo(spi);
 
-	stm32_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_CSTART);
+	if (STM32_SPI_SLAVE_MODE(spi) && spi->slave_udr_mode != SPI_NO_ACTION)
+		ier |= STM32H7_SPI_IER_UDRIE;
+
+	if (STM32_SPI_MASTER_MODE(spi))
+		stm32_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_CSTART);
 
 	writel_relaxed(ier, spi->base + STM32H7_SPI_IER);
 
@@ -1203,11 +1256,15 @@ static void stm32h7_spi_transfer_one_dma_start(struct stm32_spi *spi)
 	if (spi->cur_comm == SPI_SIMPLEX_TX || spi->cur_comm == SPI_3WIRE_TX)
 		ier |= STM32H7_SPI_IER_EOTIE | STM32H7_SPI_IER_TXTFIE;
 
+	if (STM32_SPI_SLAVE_MODE(spi) && spi->slave_udr_mode != SPI_NO_ACTION)
+		ier |= STM32H7_SPI_IER_UDRIE;
+
 	stm32_spi_set_bits(spi, STM32H7_SPI_IER, ier);
 
 	stm32_spi_enable(spi);
 
-	stm32_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_CSTART);
+	if (STM32_SPI_MASTER_MODE(spi))
+		stm32_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_CSTART);
 }
 
 /**
@@ -1229,7 +1286,7 @@ static int stm32_spi_transfer_one_dma(struct stm32_spi *spi,
 
 	rx_dma_desc = NULL;
 	if (spi->rx_buf && spi->dma_rx) {
-		stm32_spi_dma_config(spi, &rx_dma_conf, DMA_DEV_TO_MEM);
+		stm32_spi_dma_config(spi, spi->dma_rx, &rx_dma_conf, DMA_DEV_TO_MEM);
 		dmaengine_slave_config(spi->dma_rx, &rx_dma_conf);
 
 		/* Enable Rx DMA request */
@@ -1245,7 +1302,7 @@ static int stm32_spi_transfer_one_dma(struct stm32_spi *spi,
 
 	tx_dma_desc = NULL;
 	if (spi->tx_buf && spi->dma_tx) {
-		stm32_spi_dma_config(spi, &tx_dma_conf, DMA_MEM_TO_DEV);
+		stm32_spi_dma_config(spi, spi->dma_tx, &tx_dma_conf, DMA_MEM_TO_DEV);
 		dmaengine_slave_config(spi->dma_tx, &tx_dma_conf);
 
 		tx_dma_desc = dmaengine_prep_slave_sg(
@@ -1301,7 +1358,7 @@ static int stm32_spi_transfer_one_dma(struct stm32_spi *spi,
 
 dma_submit_error:
 	if (spi->dma_rx)
-		dmaengine_terminate_all(spi->dma_rx);
+		dmaengine_terminate_sync(spi->dma_rx);
 
 dma_desc_error:
 	stm32_spi_clr_bits(spi, spi->cfg->regs->dma_rx_en.reg,
@@ -1333,7 +1390,7 @@ static void stm32f4_spi_set_bpw(struct stm32_spi *spi)
  */
 static void stm32h7_spi_set_bpw(struct stm32_spi *spi)
 {
-	u32 bpw, fthlv;
+	u32 bpw, fthlv = 0;
 	u32 cfg1_clrb = 0, cfg1_setb = 0;
 
 	bpw = spi->cur_bpw - 1;
@@ -1341,8 +1398,10 @@ static void stm32h7_spi_set_bpw(struct stm32_spi *spi)
 	cfg1_clrb |= STM32H7_SPI_CFG1_DSIZE;
 	cfg1_setb |= FIELD_PREP(STM32H7_SPI_CFG1_DSIZE, bpw);
 
-	spi->cur_fthlv = stm32h7_spi_prepare_fthlv(spi, spi->cur_xferlen);
-	fthlv = spi->cur_fthlv - 1;
+	if (spi->cfg->has_fifo) {
+		spi->cur_fthlv = stm32h7_spi_prepare_fthlv(spi, spi->cur_xferlen);
+		fthlv = spi->cur_fthlv - 1;
+	}
 
 	cfg1_clrb |= STM32H7_SPI_CFG1_FTHLV;
 	cfg1_setb |= FIELD_PREP(STM32H7_SPI_CFG1_FTHLV, fthlv);
@@ -1510,6 +1569,53 @@ static int stm32h7_spi_number_of_data(struct stm32_spi *spi, u32 nb_words)
 	return 0;
 }
 
+/**
+ * stm32h7_spi_set_slave_udr - configure slave underrun detection and reaction
+ * @spi: pointer to the spi controller data structure
+ */
+static void stm32h7_spi_set_slave_udr(struct stm32_spi *spi)
+{
+	u32 max_udr_ptrn, udr_ptrn, cfg1_setb = 0;
+
+	if (spi->slave_udr_mode == SPI_NO_ACTION)
+		return;
+
+	switch (spi->slave_udr_mode) {
+	case SPI_SEND_PATTERN:
+		max_udr_ptrn = (1 << spi->cur_bpw) - 1;
+		if (spi->slave_udr_pattern > max_udr_ptrn) {
+			udr_ptrn = spi->slave_udr_pattern & max_udr_ptrn;
+			dev_warn(spi->dev,
+				 "force slave underrun pattern to data width (> 0x%x, set 0x%x)\n",
+				 max_udr_ptrn, udr_ptrn);
+		} else {
+			udr_ptrn = spi->slave_udr_pattern;
+			dev_dbg(spi->dev, "spi slave underrun: send pattern (0x%x)\n",
+				spi->slave_udr_pattern);
+		}
+		writel_relaxed(udr_ptrn, spi->base + STM32H7_SPI_UDRDR);
+		cfg1_setb |= FIELD_PREP(STM32H7_SPI_CFG1_UDRCFG, STM32H7_SPI_CFG1_UDRCFG_PTRN);
+		break;
+	case SPI_REPEAT_LAST_RECEIVED_DATA:
+		cfg1_setb |= FIELD_PREP(STM32H7_SPI_CFG1_UDRCFG, STM32H7_SPI_CFG1_UDRCFG_LAST_R);
+		dev_dbg(spi->dev, "spi slave underrun: repeat received data\n");
+		break;
+	case SPI_REPEAT_LAST_TRANSMITTED_DATA:
+		cfg1_setb |= FIELD_PREP(STM32H7_SPI_CFG1_UDRCFG, STM32H7_SPI_CFG1_UDRCFG_LAST_T);
+		dev_dbg(spi->dev, "spi slave underrun: repeat transmitted data\n");
+		break;
+	default:
+		dev_warn(spi->dev, "slave underrun detection disabled\n");
+		spi->slave_udr_mode = SPI_NO_ACTION;
+	}
+
+	if (spi->slave_udr_mode != SPI_NO_ACTION) {
+		cfg1_setb |= FIELD_PREP(STM32H7_SPI_CFG1_UDRDET, STM32H7_SPI_CFG1_UDRDET_LAST);
+
+		stm32_spi_set_bits(spi,  STM32H7_SPI_CFG1, cfg1_setb);
+	}
+}
+
 /**
  * stm32_spi_transfer_one_setup - common setup to transfer a single
  *				  spi_transfer either using DMA or
@@ -1535,16 +1641,18 @@ static int stm32_spi_transfer_one_setup(struct stm32_spi *spi,
 	spi->cfg->set_bpw(spi);
 
 	/* Update spi->cur_speed with real clock speed */
-	mbr = stm32_spi_prepare_mbr(spi, transfer->speed_hz,
-				    spi->cfg->baud_rate_div_min,
-				    spi->cfg->baud_rate_div_max);
-	if (mbr < 0) {
-		ret = mbr;
-		goto out;
-	}
+	if (STM32_SPI_MASTER_MODE(spi)) {
+		mbr = stm32_spi_prepare_mbr(spi, transfer->speed_hz,
+					    spi->cfg->baud_rate_div_min,
+					    spi->cfg->baud_rate_div_max);
+		if (mbr < 0) {
+			ret = mbr;
+			goto out;
+		}
 
-	transfer->speed_hz = spi->cur_speed;
-	stm32_spi_set_mbr(spi, mbr);
+		transfer->speed_hz = spi->cur_speed;
+		stm32_spi_set_mbr(spi, mbr);
+	}
 
 	comm_type = stm32_spi_communication_type(spi_dev, transfer);
 	ret = spi->cfg->set_mode(spi, comm_type);
@@ -1553,7 +1661,7 @@ static int stm32_spi_transfer_one_setup(struct stm32_spi *spi,
 
 	spi->cur_comm = comm_type;
 
-	if (spi->cfg->set_data_idleness)
+	if (STM32_SPI_MASTER_MODE(spi) && spi->cfg->set_data_idleness)
 		spi->cfg->set_data_idleness(spi, transfer->len);
 
 	if (spi->cur_bpw <= 8)
@@ -1569,12 +1677,16 @@ static int stm32_spi_transfer_one_setup(struct stm32_spi *spi,
 			goto out;
 	}
 
+	if (STM32_SPI_SLAVE_MODE(spi) && spi->cfg->set_slave_udr)
+		spi->cfg->set_slave_udr(spi);
+
 	dev_dbg(spi->dev, "transfer communication mode set to %d\n",
 		spi->cur_comm);
 	dev_dbg(spi->dev,
 		"data frame of %d-bit, data packet of %d data frames\n",
 		spi->cur_bpw, spi->cur_fthlv);
-	dev_dbg(spi->dev, "speed set to %dHz\n", spi->cur_speed);
+	if (STM32_SPI_MASTER_MODE(spi))
+		dev_dbg(spi->dev, "speed set to %dHz\n", spi->cur_speed);
 	dev_dbg(spi->dev, "transfer of %d bytes (%d data frames)\n",
 		spi->cur_xferlen, nb_words);
 	dev_dbg(spi->dev, "dma %s\n",
@@ -1588,18 +1700,18 @@ static int stm32_spi_transfer_one_setup(struct stm32_spi *spi,
 
 /**
  * stm32_spi_transfer_one - transfer a single spi_transfer
- * @master: controller master interface
+ * @ctrl: controller interface
  * @spi_dev: pointer to the spi device
  * @transfer: pointer to spi transfer
  *
  * It must return 0 if the transfer is finished or 1 if the transfer is still
  * in progress.
  */
-static int stm32_spi_transfer_one(struct spi_master *master,
+static int stm32_spi_transfer_one(struct spi_controller *ctrl,
 				  struct spi_device *spi_dev,
 				  struct spi_transfer *transfer)
 {
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 	int ret;
 
 	spi->tx_buf = transfer->tx_buf;
@@ -1607,8 +1719,8 @@ static int stm32_spi_transfer_one(struct spi_master *master,
 	spi->tx_len = spi->tx_buf ? transfer->len : 0;
 	spi->rx_len = spi->rx_buf ? transfer->len : 0;
 
-	spi->cur_usedma = (master->can_dma &&
-			   master->can_dma(master, spi_dev, transfer));
+	spi->cur_usedma = (ctrl->can_dma &&
+			   ctrl->can_dma(ctrl, spi_dev, transfer));
 
 	ret = stm32_spi_transfer_one_setup(spi, spi_dev, transfer);
 	if (ret) {
@@ -1624,13 +1736,13 @@ static int stm32_spi_transfer_one(struct spi_master *master,
 
 /**
  * stm32_spi_unprepare_msg - relax the hardware
- * @master: controller master interface
+ * @ctrl: controller interface
  * @msg: pointer to the spi message
  */
-static int stm32_spi_unprepare_msg(struct spi_master *master,
+static int stm32_spi_unprepare_msg(struct spi_controller *ctrl,
 				   struct spi_message *msg)
 {
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 
 	spi->cfg->disable(spi);
 
@@ -1669,12 +1781,13 @@ static int stm32f4_spi_config(struct stm32_spi *spi)
 }
 
 /**
- * stm32h7_spi_config - Configure SPI controller as SPI master
+ * stm32h7_spi_config - Configure SPI controller
  * @spi: pointer to the spi controller data structure
  */
 static int stm32h7_spi_config(struct stm32_spi *spi)
 {
 	unsigned long flags;
+	u32 cr1 = 0, cfg2 = 0;
 
 	spin_lock_irqsave(&spi->lock, flags);
 
@@ -1682,24 +1795,28 @@ static int stm32h7_spi_config(struct stm32_spi *spi)
 	stm32_spi_clr_bits(spi, STM32H7_SPI_I2SCFGR,
 			   STM32H7_SPI_I2SCFGR_I2SMOD);
 
-	/*
-	 * - SS input value high
-	 * - transmitter half duplex direction
-	 * - automatic communication suspend when RX-Fifo is full
-	 */
-	stm32_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_SSI |
-						 STM32H7_SPI_CR1_HDDIR |
-						 STM32H7_SPI_CR1_MASRX);
+	if (STM32_SPI_SLAVE_MODE(spi)) {
+		/* Use native slave select */
+		cfg2 &= ~STM32H7_SPI_CFG2_SSM;
+	} else {
+		/*
+		 * - Transmitter half duplex direction
+		 * - Automatic communication suspend when RX-Fifo is full
+		 * - SS input value high
+		 */
+		cr1 |= STM32H7_SPI_CR1_HDDIR | STM32H7_SPI_CR1_MASRX | STM32H7_SPI_CR1_SSI;
 
-	/*
-	 * - Set the master mode (default Motorola mode)
-	 * - Consider 1 master/n slaves configuration and
-	 *   SS input value is determined by the SSI bit
-	 * - keep control of all associated GPIOs
-	 */
-	stm32_spi_set_bits(spi, STM32H7_SPI_CFG2, STM32H7_SPI_CFG2_MASTER |
-						  STM32H7_SPI_CFG2_SSM |
-						  STM32H7_SPI_CFG2_AFCNTR);
+		/*
+		 * - Set the master mode (default Motorola mode)
+		 * - Consider 1 master/n slaves configuration and
+		 *   SS input value is determined by the SSI bit
+		 * - keep control of all associated GPIOs
+		 */
+		cfg2 |= STM32H7_SPI_CFG2_MASTER | STM32H7_SPI_CFG2_SSM | STM32H7_SPI_CFG2_AFCNTR;
+	}
+
+	stm32_spi_set_bits(spi, STM32H7_SPI_CR1, cr1);
+	stm32_spi_set_bits(spi, STM32H7_SPI_CFG2, cfg2);
 
 	spin_unlock_irqrestore(&spi->lock, flags);
 
@@ -1722,6 +1839,7 @@ static const struct stm32_spi_cfg stm32f4_spi_cfg = {
 	.baud_rate_div_min = STM32F4_SPI_BR_DIV_MIN,
 	.baud_rate_div_max = STM32F4_SPI_BR_DIV_MAX,
 	.has_fifo = false,
+	.flags = SPI_MASTER_MUST_TX,
 };
 
 static const struct stm32_spi_cfg stm32h7_spi_cfg = {
@@ -1745,33 +1863,104 @@ static const struct stm32_spi_cfg stm32h7_spi_cfg = {
 	.baud_rate_div_min = STM32H7_SPI_MBR_DIV_MIN,
 	.baud_rate_div_max = STM32H7_SPI_MBR_DIV_MAX,
 	.has_fifo = true,
+	.set_slave_udr = stm32h7_spi_set_slave_udr,
+};
+
+/*
+ * STM32MP2 is compatible with the STM32H7 except that we force
+ * the has_fifo = false for the time being to ensure that DMA
+ * burst is kept = 1
+ */
+static const struct stm32_spi_cfg stm32mp2_spi_cfg = {
+	.regs = &stm32h7_spi_regspec,
+	.get_fifo_size = stm32h7_spi_get_fifo_size,
+	.get_bpw_mask = stm32h7_spi_get_bpw_mask,
+	.disable = stm32h7_spi_disable,
+	.config = stm32h7_spi_config,
+	.set_bpw = stm32h7_spi_set_bpw,
+	.set_mode = stm32h7_spi_set_mode,
+	.set_data_idleness = stm32h7_spi_data_idleness,
+	.set_number_of_data = stm32h7_spi_number_of_data,
+	.transfer_one_dma_start = stm32h7_spi_transfer_one_dma_start,
+	.dma_rx_cb = stm32_spi_dma_rx_cb,
+	/*
+	 * dma_tx_cb is not necessary since in case of TX, dma is followed by
+	 * SPI access hence handling is performed within the SPI interrupt
+	 */
+	.transfer_one_irq = stm32h7_spi_transfer_one_irq,
+	.irq_handler_thread = stm32h7_spi_irq_thread,
+	.baud_rate_div_min = STM32H7_SPI_MBR_DIV_MIN,
+	.baud_rate_div_max = STM32H7_SPI_MBR_DIV_MAX,
+	.has_fifo = true,
+	.prevent_dma_burst = true,
 };
 
 static const struct of_device_id stm32_spi_of_match[] = {
+	{ .compatible = "st,stm32mp2-spi", .data = (void *)&stm32mp2_spi_cfg },
 	{ .compatible = "st,stm32h7-spi", .data = (void *)&stm32h7_spi_cfg },
 	{ .compatible = "st,stm32f4-spi", .data = (void *)&stm32f4_spi_cfg },
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32_spi_of_match);
 
+static int stm32h7_spi_slave_abort(struct spi_controller *ctrl)
+{
+	spi_finalize_current_transfer(ctrl);
+
+	return 0;
+}
+
+static void stm32h7_spi_parse_slave_config(struct stm32_spi *spi, struct device_node *np)
+{
+	u32 udr_configs[2] = { 0, 0 };
+	int count, ret;
+
+	count = of_property_count_elems_of_size(np, "st,spi-slave-underrun", sizeof(u32));
+	if (count <= 0) {
+		if (count != -EINVAL)
+			dev_err(spi->dev, "Invalid st,spi-slave-underrun property\n");
+		return;
+	}
+
+	ret = of_property_read_u32_array(np, "st,spi-slave-underrun", udr_configs, count);
+	if (ret)
+		return;
+
+	spi->slave_udr_mode = udr_configs[0];
+	if (spi->slave_udr_mode == SPI_SEND_PATTERN) {
+		if (count > 1)
+			spi->slave_udr_pattern = udr_configs[1];
+		else
+			dev_warn(spi->dev, "Missing pattern in st,spi-slave-underrun property\n");
+	}
+}
+
 static int stm32_spi_probe(struct platform_device *pdev)
 {
-	struct spi_master *master;
+	struct spi_controller *ctrl;
 	struct stm32_spi *spi;
 	struct resource *res;
 	struct reset_control *rst;
+	struct device_node *np = pdev->dev.of_node;
+	bool slave_mode;
 	int ret;
 
-	master = devm_spi_alloc_master(&pdev->dev, sizeof(struct stm32_spi));
-	if (!master) {
-		dev_err(&pdev->dev, "spi master allocation failed\n");
+	slave_mode = of_property_read_bool(np, "spi-slave");
+
+	if (slave_mode)
+		ctrl = devm_spi_alloc_slave(&pdev->dev, sizeof(struct stm32_spi));
+	else
+		ctrl = devm_spi_alloc_master(&pdev->dev, sizeof(struct stm32_spi));
+	if (!ctrl) {
+		dev_err(&pdev->dev, "spi controller allocation failed\n");
 		return -ENOMEM;
 	}
-	platform_set_drvdata(pdev, master);
+	platform_set_drvdata(pdev, ctrl);
 
-	spi = spi_master_get_devdata(master);
+	spi = spi_controller_get_devdata(ctrl);
 	spi->dev = &pdev->dev;
-	spi->master = master;
+	spi->ctrl = ctrl;
+	spi->slave_mode = slave_mode;
 	spin_lock_init(&spi->lock);
 
 	spi->cfg = (const struct stm32_spi_cfg *)
@@ -1793,13 +1982,16 @@ static int stm32_spi_probe(struct platform_device *pdev)
 	ret = devm_request_threaded_irq(&pdev->dev, spi->irq,
 					spi->cfg->irq_handler_event,
 					spi->cfg->irq_handler_thread,
-					IRQF_ONESHOT, pdev->name, master);
+					IRQF_ONESHOT, pdev->name, ctrl);
 	if (ret) {
 		dev_err(&pdev->dev, "irq%d request failed: %d\n", spi->irq,
 			ret);
 		return ret;
 	}
 
+	if (STM32_SPI_SLAVE_MODE(spi))
+		stm32h7_spi_parse_slave_config(spi, np);
+
 	spi->clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(spi->clk)) {
 		ret = PTR_ERR(spi->clk);
@@ -1842,19 +2034,21 @@ static int stm32_spi_probe(struct platform_device *pdev)
 		goto err_clk_disable;
 	}
 
-	master->dev.of_node = pdev->dev.of_node;
-	master->auto_runtime_pm = true;
-	master->bus_num = pdev->id;
-	master->mode_bits = SPI_CPHA | SPI_CPOL | SPI_CS_HIGH | SPI_LSB_FIRST |
-			    SPI_3WIRE;
-	master->bits_per_word_mask = spi->cfg->get_bpw_mask(spi);
-	master->max_speed_hz = spi->clk_rate / spi->cfg->baud_rate_div_min;
-	master->min_speed_hz = spi->clk_rate / spi->cfg->baud_rate_div_max;
-	master->use_gpio_descriptors = true;
-	master->prepare_message = stm32_spi_prepare_msg;
-	master->transfer_one = stm32_spi_transfer_one;
-	master->unprepare_message = stm32_spi_unprepare_msg;
-	master->flags = SPI_MASTER_MUST_TX;
+	ctrl->dev.of_node = pdev->dev.of_node;
+	ctrl->auto_runtime_pm = true;
+	ctrl->bus_num = pdev->id;
+	ctrl->mode_bits = SPI_CPHA | SPI_CPOL | SPI_CS_HIGH | SPI_LSB_FIRST |
+			  SPI_3WIRE;
+	ctrl->bits_per_word_mask = spi->cfg->get_bpw_mask(spi);
+	ctrl->max_speed_hz = spi->clk_rate / spi->cfg->baud_rate_div_min;
+	ctrl->min_speed_hz = spi->clk_rate / spi->cfg->baud_rate_div_max;
+	ctrl->use_gpio_descriptors = true;
+	ctrl->prepare_message = stm32_spi_prepare_msg;
+	ctrl->transfer_one = stm32_spi_transfer_one;
+	ctrl->unprepare_message = stm32_spi_unprepare_msg;
+	ctrl->flags = spi->cfg->flags;
+	if (STM32_SPI_SLAVE_MODE(spi))
+		ctrl->slave_abort = stm32h7_spi_slave_abort;
 
 	spi->dma_tx = dma_request_chan(spi->dev, "tx");
 	if (IS_ERR(spi->dma_tx)) {
@@ -1865,7 +2059,7 @@ static int stm32_spi_probe(struct platform_device *pdev)
 
 		dev_warn(&pdev->dev, "failed to request tx dma channel\n");
 	} else {
-		master->dma_tx = spi->dma_tx;
+		ctrl->dma_tx = spi->dma_tx;
 	}
 
 	spi->dma_rx = dma_request_chan(spi->dev, "rx");
@@ -1877,11 +2071,11 @@ static int stm32_spi_probe(struct platform_device *pdev)
 
 		dev_warn(&pdev->dev, "failed to request rx dma channel\n");
 	} else {
-		master->dma_rx = spi->dma_rx;
+		ctrl->dma_rx = spi->dma_rx;
 	}
 
 	if (spi->dma_tx || spi->dma_rx)
-		master->can_dma = stm32_spi_can_dma;
+		ctrl->can_dma = stm32_spi_can_dma;
 
 	pm_runtime_set_autosuspend_delay(&pdev->dev,
 					 STM32_SPI_AUTOSUSPEND_DELAY);
@@ -1890,9 +2084,9 @@ static int stm32_spi_probe(struct platform_device *pdev)
 	pm_runtime_get_noresume(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
 
-	ret = spi_register_master(master);
+	ret = spi_register_controller(ctrl);
 	if (ret) {
-		dev_err(&pdev->dev, "spi master registration failed: %d\n",
+		dev_err(&pdev->dev, "spi controller registration failed: %d\n",
 			ret);
 		goto err_pm_disable;
 	}
@@ -1900,7 +2094,8 @@ static int stm32_spi_probe(struct platform_device *pdev)
 	pm_runtime_mark_last_busy(&pdev->dev);
 	pm_runtime_put_autosuspend(&pdev->dev);
 
-	dev_info(&pdev->dev, "driver initialized\n");
+	dev_info(&pdev->dev, "driver initialized (%s mode)\n",
+		 STM32_SPI_MASTER_MODE(spi) ? "master" : "slave");
 
 	return 0;
 
@@ -1922,12 +2117,12 @@ static int stm32_spi_probe(struct platform_device *pdev)
 
 static int stm32_spi_remove(struct platform_device *pdev)
 {
-	struct spi_master *master = platform_get_drvdata(pdev);
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct spi_controller *ctrl = platform_get_drvdata(pdev);
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 
 	pm_runtime_get_sync(&pdev->dev);
 
-	spi_unregister_master(master);
+	spi_unregister_controller(ctrl);
 	spi->cfg->disable(spi);
 
 	pm_runtime_disable(&pdev->dev);
@@ -1935,10 +2130,10 @@ static int stm32_spi_remove(struct platform_device *pdev)
 	pm_runtime_set_suspended(&pdev->dev);
 	pm_runtime_dont_use_autosuspend(&pdev->dev);
 
-	if (master->dma_tx)
-		dma_release_channel(master->dma_tx);
-	if (master->dma_rx)
-		dma_release_channel(master->dma_rx);
+	if (ctrl->dma_tx)
+		dma_release_channel(ctrl->dma_tx);
+	if (ctrl->dma_rx)
+		dma_release_channel(ctrl->dma_rx);
 
 	clk_disable_unprepare(spi->clk);
 
@@ -1950,8 +2145,8 @@ static int stm32_spi_remove(struct platform_device *pdev)
 
 static int __maybe_unused stm32_spi_runtime_suspend(struct device *dev)
 {
-	struct spi_master *master = dev_get_drvdata(dev);
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct spi_controller *ctrl = dev_get_drvdata(dev);
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 
 	clk_disable_unprepare(spi->clk);
 
@@ -1960,8 +2155,8 @@ static int __maybe_unused stm32_spi_runtime_suspend(struct device *dev)
 
 static int __maybe_unused stm32_spi_runtime_resume(struct device *dev)
 {
-	struct spi_master *master = dev_get_drvdata(dev);
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct spi_controller *ctrl = dev_get_drvdata(dev);
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 	int ret;
 
 	ret = pinctrl_pm_select_default_state(dev);
@@ -1973,10 +2168,10 @@ static int __maybe_unused stm32_spi_runtime_resume(struct device *dev)
 
 static int __maybe_unused stm32_spi_suspend(struct device *dev)
 {
-	struct spi_master *master = dev_get_drvdata(dev);
+	struct spi_controller *ctrl = dev_get_drvdata(dev);
 	int ret;
 
-	ret = spi_master_suspend(master);
+	ret = spi_controller_suspend(ctrl);
 	if (ret)
 		return ret;
 
@@ -1985,15 +2180,15 @@ static int __maybe_unused stm32_spi_suspend(struct device *dev)
 
 static int __maybe_unused stm32_spi_resume(struct device *dev)
 {
-	struct spi_master *master = dev_get_drvdata(dev);
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct spi_controller *ctrl = dev_get_drvdata(dev);
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 	int ret;
 
 	ret = pm_runtime_force_resume(dev);
 	if (ret)
 		return ret;
 
-	ret = spi_master_resume(master);
+	ret = spi_controller_resume(ctrl);
 	if (ret) {
 		clk_disable_unprepare(spi->clk);
 		return ret;
diff --git a/drivers/staging/media/hantro/Kconfig b/drivers/staging/media/hantro/Kconfig
index 20b1f6d7b..7da208ecb 100644
--- a/drivers/staging/media/hantro/Kconfig
+++ b/drivers/staging/media/hantro/Kconfig
@@ -1,7 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 config VIDEO_HANTRO
 	tristate "Hantro VPU driver"
-	depends on ARCH_MXC || ARCH_ROCKCHIP || ARCH_AT91 || COMPILE_TEST
+	depends on ARCH_MXC || ARCH_ROCKCHIP || ARCH_AT91 || ARCH_STM32 || COMPILE_TEST
 	depends on VIDEO_DEV && VIDEO_V4L2
 	select MEDIA_CONTROLLER
 	select MEDIA_CONTROLLER_REQUEST_API
@@ -11,8 +11,8 @@ config VIDEO_HANTRO
 	select V4L2_H264
 	help
 	  Support for the Hantro IP based Video Processing Units present on
-	  Rockchip and NXP i.MX8M SoCs, which accelerate video and image
-	  encoding and decoding.
+	  Rockchip, NXP i.MX8M and STMicroelectronics STM32MP25 SoCs,
+	  which accelerate video and image encoding and decoding.
 	  To compile this driver as a module, choose M here: the module
 	  will be called hantro-vpu.
 
@@ -39,3 +39,11 @@ config VIDEO_HANTRO_ROCKCHIP
 	default y
 	help
 	  Enable support for RK3288, RK3328, and RK3399 SoCs.
+
+config VIDEO_HANTRO_STM32MP25
+	bool "Hantro STM32MP25 support"
+	depends on VIDEO_HANTRO
+	depends on ARCH_STM32 || COMPILE_TEST
+	default y
+	help
+	  Enable support for STM32MP25 SoCs.
diff --git a/drivers/staging/media/hantro/Makefile b/drivers/staging/media/hantro/Makefile
index 90036831f..9aadcd3ac 100644
--- a/drivers/staging/media/hantro/Makefile
+++ b/drivers/staging/media/hantro/Makefile
@@ -30,3 +30,7 @@ hantro-vpu-$(CONFIG_VIDEO_HANTRO_SAMA5D4) += \
 
 hantro-vpu-$(CONFIG_VIDEO_HANTRO_ROCKCHIP) += \
 		rockchip_vpu_hw.o
+
+hantro-vpu-$(CONFIG_VIDEO_HANTRO_STM32MP25) += \
+		stm32mp25_vdec_hw.o \
+		stm32mp25_venc_hw.o
diff --git a/drivers/staging/media/hantro/hantro.h b/drivers/staging/media/hantro/hantro.h
index 88792c863..4368f03c3 100644
--- a/drivers/staging/media/hantro/hantro.h
+++ b/drivers/staging/media/hantro/hantro.h
@@ -190,6 +190,8 @@ struct hantro_dev {
 	void __iomem *enc_base;
 	void __iomem *dec_base;
 	void __iomem *ctrl_base;
+	struct reset_control *rstc;
+	u32 max_burst_length;
 
 	struct mutex vpu_mutex;	/* video_device lock */
 	spinlock_t irqlock;
diff --git a/drivers/staging/media/hantro/hantro_drv.c b/drivers/staging/media/hantro/hantro_drv.c
index 281aa585e..db662fb3a 100644
--- a/drivers/staging/media/hantro/hantro_drv.c
+++ b/drivers/staging/media/hantro/hantro_drv.c
@@ -11,11 +11,13 @@
  */
 
 #include <linux/clk.h>
+#include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
 #include <linux/pm.h>
 #include <linux/pm_runtime.h>
+#include <linux/reset.h>
 #include <linux/slab.h>
 #include <linux/videodev2.h>
 #include <linux/workqueue.h>
@@ -170,6 +172,8 @@ static void device_run(void *priv)
 
 	v4l2_m2m_buf_copy_metadata(src, dst, true);
 
+	ctx->codec_ops->reset(ctx);
+
 	if (ctx->codec_ops->run(ctx))
 		goto err_cancel_job;
 
@@ -595,6 +599,10 @@ static const struct of_device_id of_hantro_match[] = {
 #endif
 #ifdef CONFIG_VIDEO_HANTRO_SAMA5D4
 	{ .compatible = "microchip,sama5d4-vdec", .data = &sama5d4_vdec_variant, },
+#endif
+#ifdef CONFIG_VIDEO_HANTRO_STM32MP25
+	{ .compatible = "st,stm32mp25-vdec", .data = &stm32mp25_vdec_variant, },
+	{ .compatible = "st,stm32mp25-venc", .data = &stm32mp25_venc_variant, },
 #endif
 	{ /* sentinel */ }
 };
@@ -847,13 +855,15 @@ static int hantro_probe(struct platform_device *pdev)
 	const struct of_device_id *match;
 	struct hantro_dev *vpu;
 	struct resource *res;
+	struct device_node *np;
 	int num_bases;
-	int i, ret;
+	int i, ret, mbl;
 
 	vpu = devm_kzalloc(&pdev->dev, sizeof(*vpu), GFP_KERNEL);
 	if (!vpu)
 		return -ENOMEM;
 
+	np = pdev->dev.of_node;
 	vpu->dev = &pdev->dev;
 	vpu->pdev = pdev;
 	mutex_init(&vpu->vpu_mutex);
@@ -864,6 +874,10 @@ static int hantro_probe(struct platform_device *pdev)
 
 	INIT_DELAYED_WORK(&vpu->watchdog_work, hantro_watchdog);
 
+	vpu->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);
+	if (IS_ERR(vpu->rstc))
+		vpu->rstc = NULL;
+
 	vpu->clocks = devm_kcalloc(&pdev->dev, vpu->variant->num_clocks,
 				   sizeof(*vpu->clocks), GFP_KERNEL);
 	if (!vpu->clocks)
@@ -912,6 +926,14 @@ static int hantro_probe(struct platform_device *pdev)
 	}
 	vb2_dma_contig_set_max_seg_size(&pdev->dev, DMA_BIT_MASK(32));
 
+	/* get max burst length */
+	ret = of_property_read_u32(np, "maxburstlen", &mbl);
+	if (ret)
+		/* Set to max value if not DT properties */
+		mbl = 64;
+
+	vpu->max_burst_length = mbl / 8;
+
 	for (i = 0; i < vpu->variant->num_irqs; i++) {
 		const char *irq_name;
 		int irq;
diff --git a/drivers/staging/media/hantro/hantro_g1_h264_dec.c b/drivers/staging/media/hantro/hantro_g1_h264_dec.c
index 236ce24ca..c2e497f42 100644
--- a/drivers/staging/media/hantro/hantro_g1_h264_dec.c
+++ b/drivers/staging/media/hantro/hantro_g1_h264_dec.c
@@ -252,6 +252,7 @@ int hantro_g1_h264_dec_run(struct hantro_ctx *ctx)
 	struct hantro_dev *vpu = ctx->dev;
 	struct vb2_v4l2_buffer *src_buf;
 	int ret;
+	u32 reg;
 
 	/* Prepare the H264 decoder context. */
 	ret = hantro_h264_dec_prepare_run(ctx);
@@ -267,17 +268,18 @@ int hantro_g1_h264_dec_run(struct hantro_ctx *ctx)
 	hantro_end_prepare_run(ctx);
 
 	/* Start decoding! */
-	vdpu_write_relaxed(vpu,
-			   G1_REG_CONFIG_DEC_AXI_RD_ID(0xffu) |
-			   G1_REG_CONFIG_DEC_TIMEOUT_E |
-			   G1_REG_CONFIG_DEC_OUT_ENDIAN |
-			   G1_REG_CONFIG_DEC_STRENDIAN_E |
-			   G1_REG_CONFIG_DEC_MAX_BURST(16) |
-			   G1_REG_CONFIG_DEC_OUTSWAP32_E |
-			   G1_REG_CONFIG_DEC_INSWAP32_E |
-			   G1_REG_CONFIG_DEC_STRSWAP32_E |
-			   G1_REG_CONFIG_DEC_CLK_GATE_E,
-			   G1_REG_CONFIG);
+		   reg = G1_REG_CONFIG_DEC_AXI_RD_ID(0xffu) |
+		   G1_REG_CONFIG_DEC_OUT_ENDIAN |
+		   G1_REG_CONFIG_DEC_STRENDIAN_E |
+		   G1_REG_CONFIG_DEC_MAX_BURST(vpu->max_burst_length) |
+		   G1_REG_CONFIG_DEC_OUTSWAP32_E |
+		   G1_REG_CONFIG_DEC_INSWAP32_E |
+		   G1_REG_CONFIG_DEC_STRSWAP32_E |
+		   G1_REG_CONFIG_DEC_2CHAN_DIS |
+		   G1_REG_CONFIG_DEC_SCMD_DIS |
+		   G1_REG_CONFIG_DEC_ADV_PRE_DIS;
+
+	vdpu_write_relaxed(vpu, reg, G1_REG_CONFIG);
 	vdpu_write(vpu, G1_REG_INTERRUPT_DEC_E, G1_REG_INTERRUPT);
 
 	return 0;
diff --git a/drivers/staging/media/hantro/hantro_g1_mpeg2_dec.c b/drivers/staging/media/hantro/hantro_g1_mpeg2_dec.c
index 9aea331e1..5ab203272 100644
--- a/drivers/staging/media/hantro/hantro_g1_mpeg2_dec.c
+++ b/drivers/staging/media/hantro/hantro_g1_mpeg2_dec.c
@@ -177,7 +177,7 @@ int hantro_g1_mpeg2_dec_run(struct hantro_ctx *ctx)
 	      G1_REG_DEC_OUT_ENDIAN(1) |
 	      G1_REG_DEC_ADV_PRE_DIS(0) |
 	      G1_REG_DEC_SCMD_DIS(0) |
-	      G1_REG_DEC_MAX_BURST(16);
+	      G1_REG_DEC_MAX_BURST(vpu->max_burst_length);
 	vdpu_write_relaxed(vpu, reg, G1_SWREG(2));
 
 	reg = G1_REG_DEC_MODE(5) |
diff --git a/drivers/staging/media/hantro/hantro_g1_regs.h b/drivers/staging/media/hantro/hantro_g1_regs.h
index c1756e3d5..baba54201 100644
--- a/drivers/staging/media/hantro/hantro_g1_regs.h
+++ b/drivers/staging/media/hantro/hantro_g1_regs.h
@@ -32,6 +32,7 @@
 #define     G1_REG_CONFIG_DEC_INSWAP32_E		BIT(20)
 #define     G1_REG_CONFIG_DEC_OUTSWAP32_E		BIT(19)
 #define     G1_REG_CONFIG_DEC_DATA_DISC_E		BIT(18)
+#define     G1_REG_CONFIG_DEC_2CHAN_DIS			BIT(18)
 #define     G1_REG_CONFIG_TILED_MODE_MSB		BIT(17)
 #define     G1_REG_CONFIG_DEC_OUT_TILED_E		BIT(17)
 #define     G1_REG_CONFIG_DEC_LATENCY(x)		(((x) & 0x3f) << 11)
diff --git a/drivers/staging/media/hantro/hantro_g1_vp8_dec.c b/drivers/staging/media/hantro/hantro_g1_vp8_dec.c
index 6180b23e7..738c364c4 100644
--- a/drivers/staging/media/hantro/hantro_g1_vp8_dec.c
+++ b/drivers/staging/media/hantro/hantro_g1_vp8_dec.c
@@ -452,15 +452,17 @@ int hantro_g1_vp8_dec_run(struct hantro_ctx *ctx)
 
 	hantro_vp8_prob_update(ctx, hdr);
 
-	reg = G1_REG_CONFIG_DEC_TIMEOUT_E |
+	reg = G1_REG_CONFIG_DEC_AXI_RD_ID(0xffu) |
 	      G1_REG_CONFIG_DEC_STRENDIAN_E |
 	      G1_REG_CONFIG_DEC_INSWAP32_E |
 	      G1_REG_CONFIG_DEC_STRSWAP32_E |
 	      G1_REG_CONFIG_DEC_OUTSWAP32_E |
-	      G1_REG_CONFIG_DEC_CLK_GATE_E |
 	      G1_REG_CONFIG_DEC_IN_ENDIAN |
 	      G1_REG_CONFIG_DEC_OUT_ENDIAN |
-	      G1_REG_CONFIG_DEC_MAX_BURST(16);
+	      G1_REG_CONFIG_DEC_2CHAN_DIS |
+	      G1_REG_CONFIG_DEC_MAX_BURST(vpu->max_burst_length) |
+	      G1_REG_CONFIG_DEC_SCMD_DIS |
+	      G1_REG_CONFIG_DEC_ADV_PRE_DIS;
 	vdpu_write_relaxed(vpu, reg, G1_REG_CONFIG);
 
 	reg = G1_REG_DEC_CTRL0_DEC_MODE(10);
diff --git a/drivers/staging/media/hantro/hantro_h1_jpeg_enc.c b/drivers/staging/media/hantro/hantro_h1_jpeg_enc.c
index 686d813f5..684921fa4 100644
--- a/drivers/staging/media/hantro/hantro_h1_jpeg_enc.c
+++ b/drivers/staging/media/hantro/hantro_h1_jpeg_enc.c
@@ -119,7 +119,7 @@ int hantro_h1_jpeg_enc_run(struct hantro_ctx *ctx)
 
 	reg = H1_REG_AXI_CTRL_OUTPUT_SWAP16
 		| H1_REG_AXI_CTRL_INPUT_SWAP16
-		| H1_REG_AXI_CTRL_BURST_LEN(16)
+		| H1_REG_AXI_CTRL_BURST_LEN(vpu->max_burst_length)
 		| H1_REG_AXI_CTRL_OUTPUT_SWAP32
 		| H1_REG_AXI_CTRL_INPUT_SWAP32
 		| H1_REG_AXI_CTRL_OUTPUT_SWAP8
diff --git a/drivers/staging/media/hantro/hantro_h1_regs.h b/drivers/staging/media/hantro/hantro_h1_regs.h
index 30e7e7b92..bdc806583 100644
--- a/drivers/staging/media/hantro/hantro_h1_regs.h
+++ b/drivers/staging/media/hantro/hantro_h1_regs.h
@@ -23,6 +23,9 @@
 #define     H1_REG_AXI_CTRL_INPUT_SWAP32		BIT(2)
 #define     H1_REG_AXI_CTRL_OUTPUT_SWAP8		BIT(1)
 #define     H1_REG_AXI_CTRL_INPUT_SWAP8			BIT(0)
+#define H1_REG_DEVICE_CONFIG				0x00c
+#define     H1_REG_DEVICE_CONFIG_AXI_DUAL_CHAN_DIS	BIT(20)
+
 #define H1_REG_ADDR_OUTPUT_STREAM			0x014
 #define H1_REG_ADDR_OUTPUT_CTRL				0x018
 #define H1_REG_ADDR_REF_LUMA				0x01c
diff --git a/drivers/staging/media/hantro/hantro_hw.h b/drivers/staging/media/hantro/hantro_hw.h
index fd738653a..e79ee0e13 100644
--- a/drivers/staging/media/hantro/hantro_hw.h
+++ b/drivers/staging/media/hantro/hantro_hw.h
@@ -216,6 +216,8 @@ extern const struct hantro_variant rk3288_vpu_variant;
 extern const struct hantro_variant rk3328_vpu_variant;
 extern const struct hantro_variant rk3399_vpu_variant;
 extern const struct hantro_variant sama5d4_vdec_variant;
+extern const struct hantro_variant stm32mp25_vdec_variant;
+extern const struct hantro_variant stm32mp25_venc_variant;
 
 extern const struct hantro_postproc_regs hantro_g1_postproc_regs;
 
diff --git a/drivers/staging/media/hantro/stm32mp25_vdec_hw.c b/drivers/staging/media/hantro/stm32mp25_vdec_hw.c
new file mode 100644
index 000000000..17c1e46e2
--- /dev/null
+++ b/drivers/staging/media/hantro/stm32mp25_vdec_hw.c
@@ -0,0 +1,84 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * STM32MP25 VDEC video decoder driver
+ *
+ * Copyright (C) STMicroelectronics SA 2022
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          for STMicroelectronics.
+ *
+ */
+
+#include "hantro.h"
+
+/*
+ * Supported formats.
+ */
+
+static const struct hantro_fmt stm32mp25_vdec_fmts[] = {
+	{
+		.fourcc = V4L2_PIX_FMT_NV12,
+		.codec_mode = HANTRO_MODE_NONE,
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_VP8_FRAME,
+		.codec_mode = HANTRO_MODE_VP8_DEC,
+		.max_depth = 2,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 4080,
+			.step_width = MB_DIM,
+			.min_height = 96,
+			.max_height = 4080,
+			.step_height = MB_DIM,
+		},
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_H264_SLICE,
+		.codec_mode = HANTRO_MODE_H264_DEC,
+		.max_depth = 2,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 4080,
+			.step_width = MB_DIM,
+			.min_height = 96,
+			.max_height = 4080,
+			.step_height = MB_DIM,
+		},
+	},
+};
+
+/*
+ * Supported codec ops.
+ */
+
+static const struct hantro_codec_ops stm32mp25_vdec_codec_ops[] = {
+	[HANTRO_MODE_VP8_DEC] = {
+		.run = hantro_g1_vp8_dec_run,
+		.reset = hantro_g1_reset,
+		.init = hantro_vp8_dec_init,
+		.exit = hantro_vp8_dec_exit,
+	},
+	[HANTRO_MODE_H264_DEC] = {
+		.run = hantro_g1_h264_dec_run,
+		.reset = hantro_g1_reset,
+		.init = hantro_h264_dec_init,
+		.exit = hantro_h264_dec_exit,
+	},
+};
+
+static const struct hantro_irq stm32mp25_irqs[] = {
+	{ "vdec", hantro_g1_irq },
+};
+
+static const char * const stm32mp25_clk_names[] = { "vdec-clk" };
+
+const struct hantro_variant stm32mp25_vdec_variant = {
+	.dec_fmts = stm32mp25_vdec_fmts,
+	.num_dec_fmts = ARRAY_SIZE(stm32mp25_vdec_fmts),
+	.codec = HANTRO_VP8_DECODER | HANTRO_H264_DECODER,
+	.codec_ops = stm32mp25_vdec_codec_ops,
+	.irqs = stm32mp25_irqs,
+	.num_irqs = ARRAY_SIZE(stm32mp25_irqs),
+	.clk_names = stm32mp25_clk_names,
+	.num_clocks = ARRAY_SIZE(stm32mp25_clk_names),
+};
diff --git a/drivers/staging/media/hantro/stm32mp25_venc_hw.c b/drivers/staging/media/hantro/stm32mp25_venc_hw.c
new file mode 100644
index 000000000..b23e40ad5
--- /dev/null
+++ b/drivers/staging/media/hantro/stm32mp25_venc_hw.c
@@ -0,0 +1,129 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * STM32MP25 VENC video encoder driver
+ *
+ * Copyright (C) STMicroelectronics SA 2022
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          for STMicroelectronics.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/reset.h>
+
+#include "hantro.h"
+#include "hantro_jpeg.h"
+#include "hantro_h1_regs.h"
+
+/*
+ * Supported formats.
+ */
+
+static const struct hantro_fmt stm32mp25_venc_fmts[] = {
+	{
+		.fourcc = V4L2_PIX_FMT_YUV420M,
+		.codec_mode = HANTRO_MODE_NONE,
+		.enc_fmt = ROCKCHIP_VPU_ENC_FMT_YUV420P,
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_NV12M,
+		.codec_mode = HANTRO_MODE_NONE,
+		.enc_fmt = ROCKCHIP_VPU_ENC_FMT_YUV420SP,
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_YUYV,
+		.codec_mode = HANTRO_MODE_NONE,
+		.enc_fmt = ROCKCHIP_VPU_ENC_FMT_YUYV422,
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_UYVY,
+		.codec_mode = HANTRO_MODE_NONE,
+		.enc_fmt = ROCKCHIP_VPU_ENC_FMT_UYVY422,
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_JPEG,
+		.codec_mode = HANTRO_MODE_JPEG_ENC,
+		.max_depth = 2,
+		.header_size = JPEG_HEADER_SIZE,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 8176,
+			.step_width = MB_DIM,
+			.min_height = 32,
+			.max_height = 8176,
+			.step_height = MB_DIM,
+		},
+	},
+};
+
+static irqreturn_t stm32mp25_venc_irq(int irq, void *dev_id)
+{
+	struct hantro_dev *vpu = dev_id;
+	enum vb2_buffer_state state;
+	u32 status;
+
+	status = vepu_read(vpu, H1_REG_INTERRUPT);
+	state = (status & H1_REG_INTERRUPT_FRAME_RDY) ?
+		VB2_BUF_STATE_DONE : VB2_BUF_STATE_ERROR;
+
+	vepu_write(vpu, H1_REG_INTERRUPT_BIT, H1_REG_INTERRUPT);
+
+	hantro_irq_done(vpu, state);
+
+	return IRQ_HANDLED;
+}
+
+static void stm32mp25_venc_reset(struct hantro_ctx *ctx)
+{
+	struct hantro_dev *vpu = ctx->dev;
+
+	if (vpu->rstc) {
+		/* Reset device */
+		reset_control_assert(vpu->rstc);
+		usleep_range(3000, 5000);
+		reset_control_deassert(vpu->rstc);
+		usleep_range(3000, 5000);
+	}
+
+	/* Disable Dual channel */
+	vepu_write(vpu, H1_REG_DEVICE_CONFIG_AXI_DUAL_CHAN_DIS, H1_REG_DEVICE_CONFIG);
+}
+
+/*
+ * Supported codec ops.
+ */
+
+static const struct hantro_codec_ops stm32mp25_venc_codec_ops[] = {
+	[HANTRO_MODE_JPEG_ENC] = {
+		.run = hantro_h1_jpeg_enc_run,
+		.reset = stm32mp25_venc_reset,
+		.init = hantro_jpeg_enc_init,
+		.done = hantro_h1_jpeg_enc_done,
+		.exit = hantro_jpeg_enc_exit,
+	},
+};
+
+/*
+ * Variants.
+ */
+
+static const struct hantro_irq stm32mp25_venc_irqs[] = {
+	{ "venc", stm32mp25_venc_irq },
+};
+
+static const char * const stm32mp25_venc_clk_names[] = {
+	"venc-clk"
+};
+
+const struct hantro_variant stm32mp25_venc_variant = {
+	.enc_fmts = stm32mp25_venc_fmts,
+	.num_enc_fmts = ARRAY_SIZE(stm32mp25_venc_fmts),
+	.codec = HANTRO_JPEG_ENCODER,
+	.codec_ops = stm32mp25_venc_codec_ops,
+	.irqs = stm32mp25_venc_irqs,
+	.num_irqs = ARRAY_SIZE(stm32mp25_venc_irqs),
+	.clk_names = stm32mp25_venc_clk_names,
+	.num_clocks = ARRAY_SIZE(stm32mp25_venc_clk_names)
+};
+
diff --git a/drivers/tee/amdtee/amdtee_private.h b/drivers/tee/amdtee/amdtee_private.h
index 6d0f7062b..73c183510 100644
--- a/drivers/tee/amdtee/amdtee_private.h
+++ b/drivers/tee/amdtee/amdtee_private.h
@@ -135,13 +135,17 @@ static inline u32 get_session_index(u32 session)
 
 int amdtee_open_session(struct tee_context *ctx,
 			struct tee_ioctl_open_session_arg *arg,
-			struct tee_param *param);
+			struct tee_param *normal_param,
+			u32 num_normal_params,
+			struct tee_param *ocall_param);
 
 int amdtee_close_session(struct tee_context *ctx, u32 session);
 
 int amdtee_invoke_func(struct tee_context *ctx,
 		       struct tee_ioctl_invoke_arg *arg,
-		       struct tee_param *param);
+		       struct tee_param *normal_param,
+		       u32 num_normal_params,
+		       struct tee_param *ocall_param);
 
 int amdtee_cancel_req(struct tee_context *ctx, u32 cancel_id, u32 session);
 
diff --git a/drivers/tee/amdtee/core.c b/drivers/tee/amdtee/core.c
index 297dc62bc..e6f1e331d 100644
--- a/drivers/tee/amdtee/core.c
+++ b/drivers/tee/amdtee/core.c
@@ -230,7 +230,9 @@ static void destroy_session(struct kref *ref)
 
 int amdtee_open_session(struct tee_context *ctx,
 			struct tee_ioctl_open_session_arg *arg,
-			struct tee_param *param)
+			struct tee_param *normal_param,
+			u32 num_normal_params,
+			struct tee_param *ocall_param)
 {
 	struct amdtee_context_data *ctxdata = ctx->data;
 	struct amdtee_session *sess = NULL;
@@ -239,6 +241,11 @@ int amdtee_open_session(struct tee_context *ctx,
 	int rc, i;
 	void *ta;
 
+	if (ocall_param) {
+		pr_err("OCALLs not supported\n");
+		return -EOPNOTSUPP;
+	}
+
 	if (arg->clnt_login != TEE_IOCTL_LOGIN_PUBLIC) {
 		pr_err("unsupported client login method\n");
 		return -EINVAL;
@@ -283,7 +290,7 @@ int amdtee_open_session(struct tee_context *ctx,
 	}
 
 	/* Open session with loaded TA */
-	handle_open_session(arg, &session_info, param);
+	handle_open_session(arg, &session_info, normal_param);
 	if (arg->ret != TEEC_SUCCESS) {
 		pr_err("open_session failed %d\n", arg->ret);
 		spin_lock(&sess->lock);
@@ -405,12 +412,19 @@ void amdtee_unmap_shmem(struct tee_shm *shm)
 
 int amdtee_invoke_func(struct tee_context *ctx,
 		       struct tee_ioctl_invoke_arg *arg,
-		       struct tee_param *param)
+		       struct tee_param *normal_param,
+		       u32 num_normal_params,
+		       struct tee_param *ocall_param)
 {
 	struct amdtee_context_data *ctxdata = ctx->data;
 	struct amdtee_session *sess;
 	u32 i, session_info;
 
+	if (ocall_param) {
+		pr_err("OCALLs not supported\n");
+		return -EOPNOTSUPP;
+	}
+
 	/* Check that the session is valid */
 	mutex_lock(&session_list_mutex);
 	sess = find_session(ctxdata, arg->session);
@@ -423,7 +437,7 @@ int amdtee_invoke_func(struct tee_context *ctx,
 	if (!sess)
 		return -EINVAL;
 
-	handle_invoke_cmd(arg, session_info, param);
+	handle_invoke_cmd(arg, session_info, normal_param);
 
 	return 0;
 }
diff --git a/drivers/tee/optee/Makefile b/drivers/tee/optee/Makefile
index 3aa33ea9e..446d65dc8 100644
--- a/drivers/tee/optee/Makefile
+++ b/drivers/tee/optee/Makefile
@@ -1,7 +1,9 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_OPTEE) += optee.o
 optee-objs += core.o
+optee-objs += call_queue.o
 optee-objs += call.o
+optee-objs += notif.o
 optee-objs += rpc.o
 optee-objs += supp.o
 optee-objs += shm_pool.o
diff --git a/drivers/tee/optee/call.c b/drivers/tee/optee/call.c
index 945f03da0..f2b495ee8 100644
--- a/drivers/tee/optee/call.c
+++ b/drivers/tee/optee/call.c
@@ -17,126 +17,289 @@
 #define CREATE_TRACE_POINTS
 #include "optee_trace.h"
 
-struct optee_call_waiter {
-	struct list_head list_node;
-	struct completion c;
-};
-
-static void optee_cq_wait_init(struct optee_call_queue *cq,
-			       struct optee_call_waiter *w)
+/* Requires the filpstate mutex to be held */
+static struct optee_session *find_session(struct optee_context_data *ctxdata,
+					  u32 session_id)
 {
-	/*
-	 * We're preparing to make a call to secure world. In case we can't
-	 * allocate a thread in secure world we'll end up waiting in
-	 * optee_cq_wait_for_completion().
-	 *
-	 * Normally if there's no contention in secure world the call will
-	 * complete and we can cleanup directly with optee_cq_wait_final().
-	 */
-	mutex_lock(&cq->mutex);
+	struct optee_session *sess;
 
-	/*
-	 * We add ourselves to the queue, but we don't wait. This
-	 * guarantees that we don't lose a completion if secure world
-	 * returns busy and another thread just exited and try to complete
-	 * someone.
-	 */
-	init_completion(&w->c);
-	list_add_tail(&w->list_node, &cq->waiters);
+	list_for_each_entry(sess, &ctxdata->sess_list, list_node)
+		if (sess->session_id == session_id)
+			return sess;
 
-	mutex_unlock(&cq->mutex);
+	return NULL;
 }
 
-static void optee_cq_wait_for_completion(struct optee_call_queue *cq,
-					 struct optee_call_waiter *w)
+static void param_clear_ocall(struct tee_param *ocall)
 {
-	wait_for_completion(&w->c);
+	if (ocall)
+		memset(&ocall->u, 0, sizeof(ocall->u));
+}
 
-	mutex_lock(&cq->mutex);
+static u64 param_get_ocall_func(struct tee_param *param)
+{
+	return TEE_IOCTL_OCALL_GET_FUNC(param->u.value.a);
+}
 
-	/* Move to end of list to get out of the way for other waiters */
-	list_del(&w->list_node);
-	reinit_completion(&w->c);
-	list_add_tail(&w->list_node, &cq->waiters);
+/* Requires @sem in the parent struct optee_session to be held */
+static int verify_ocall_request(u32 num_params, struct optee_call_ctx *call_ctx)
+{
+	struct optee_msg_arg *arg = call_ctx->rpc_arg;
+
+	switch (arg->cmd) {
+	case OPTEE_MSG_RPC_CMD_OCALL:
+		/* 'num_params' is checked later */
+
+		/* These parameters carry the OCALL descriptors */
+		if (arg->num_params < 2 ||
+		    arg->params[0].attr != OPTEE_MSG_ATTR_TYPE_VALUE_INOUT ||
+		    arg->params[1].attr != OPTEE_MSG_ATTR_TYPE_VALUE_INPUT ||
+		    arg->params[0].u.value.a > U32_MAX ||  /* OCALL Cmd Id */
+		    arg->params[1].u.value.c != 0)  /* TA UUID (128 bytes) */
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
 
-	mutex_unlock(&cq->mutex);
+	return 0;
 }
 
-static void optee_cq_complete_one(struct optee_call_queue *cq)
+/* Requires @sem in the parent struct optee_session to be held */
+static int verify_ocall_reply(u64 func, struct tee_param *params,
+			      u32 num_params, struct optee_call_ctx *call_ctx)
 {
-	struct optee_call_waiter *w;
+	size_t n;
+
+	switch (func) {
+	case TEE_IOCTL_OCALL_CMD_INVOKE:
+		if (call_ctx->rpc_arg->cmd != OPTEE_MSG_RPC_CMD_OCALL)
+			return -EINVAL;
+
+		/* Skip the loop below */
+		return 0;
+	default:
+		return -EINVAL;
+	}
+
+	/* The remaining parameters are unused */
+	for (n = 1; n < num_params; n++)
+		if (params[n].attr != TEE_IOCTL_PARAM_ATTR_TYPE_NONE)
+			return -EINVAL;
+
+	return 0;
+}
 
-	list_for_each_entry(w, &cq->waiters, list_node) {
-		if (!completion_done(&w->c)) {
-			complete(&w->c);
+/* Requires @sem in the parent struct optee_session to be held */
+static void process_ocall_memrefs(struct optee_msg_param *params,
+				  u32 num_params, bool increment)
+{
+	size_t n;
+
+	for (n = 0; n < num_params; n++) {
+		struct tee_shm *shm;
+		const struct optee_msg_param *mp = params + n;
+		u32 attr = mp->attr & OPTEE_MSG_ATTR_TYPE_MASK;
+
+		switch (attr) {
+		case OPTEE_MSG_ATTR_TYPE_RMEM_INPUT:
+		case OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:
+		case OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:
+			shm = (struct tee_shm *)(uintptr_t)mp->u.rmem.shm_ref;
+			break;
+		default:
+			shm = NULL;
 			break;
 		}
+
+		if (!shm)
+			continue;
+
+		if (increment)
+			tee_shm_get(shm);
+		else
+			tee_shm_put(shm);
 	}
 }
 
-static void optee_cq_wait_final(struct optee_call_queue *cq,
-				struct optee_call_waiter *w)
+/*
+ * Requires @sem in the parent struct optee_session to be held (if OCALLs are
+ * expected)
+ */
+static void call_prologue(struct optee_call_ctx *call_ctx)
+{
+	struct optee *optee = tee_get_drvdata(call_ctx->ctx->teedev);
+
+	/* Initialize waiter */
+	optee_cq_wait_init(&optee->call_queue, &call_ctx->waiter);
+}
+
+/*
+ * Requires @sem in the parent struct optee_session to be held (if OCALLs are
+ * expected)
+ */
+static void call_epilogue(struct optee_call_ctx *call_ctx)
 {
+	struct optee *optee = tee_get_drvdata(call_ctx->ctx->teedev);
+
+	optee_rpc_finalize_call(call_ctx);
+
 	/*
-	 * We're done with the call to secure world. The thread in secure
-	 * world that was used for this call is now available for some
-	 * other task to use.
+	 * We're done with our thread in secure world, if there's any
+	 * thread waiters wake up one.
 	 */
-	mutex_lock(&cq->mutex);
+	optee_cq_wait_final(&optee->call_queue, &call_ctx->waiter);
+}
+
+/* Requires @sem in the parent struct optee_session to be held */
+static int process_ocall_request(struct tee_param *params, u32 num_params,
+				 struct tee_param *ocall,
+				 struct optee_call_ctx *call_ctx)
+{
+	u32 cmd_id;
+	struct optee_msg_param *msg_param;
+	u32 msg_num_params;
+	int rc = 0;
 
-	/* Get out of the list */
-	list_del(&w->list_node);
+	/*
+	 * Points to the octets of the UUID corresponding to the TA requesting
+	 * the OCALL, if applicable for this call.
+	 */
+	void *clnt_id;
 
-	/* Wake up one eventual waiting task */
-	optee_cq_complete_one(cq);
+	rc = verify_ocall_request(num_params, call_ctx);
+	if (rc)
+		goto exit_set_ret;
 
 	/*
-	 * If we're completed we've got a completion from another task that
-	 * was just done with its call to secure world. Since yet another
-	 * thread now is available in secure world wake up another eventual
-	 * waiting task.
+	 * Clear out the parameters of the original function invocation. The
+	 * original contents are backed up in call_ctx->msg_arg and will be
+	 * restored elsewhere once the OCALL is over.
 	 */
-	if (completion_done(&w->c))
-		optee_cq_complete_one(cq);
+	memset(params, 0, num_params * sizeof(*params));
+
+	/* Set up the OCALL request */
+	switch (call_ctx->rpc_arg->cmd) {
+	case OPTEE_MSG_RPC_CMD_OCALL:
+		/* -2 here and +2 below to skip the OCALL descriptors */
+		msg_num_params = call_ctx->rpc_arg->num_params - 2;
+		if (num_params < msg_num_params) {
+			rc = -EINVAL;
+			goto exit_set_ret;
+		}
+
+		msg_param = call_ctx->rpc_arg->params + 2;
+		rc = optee_from_msg_param(params, msg_num_params, msg_param);
+		if (rc)
+			goto exit_set_ret;
+
+		process_ocall_memrefs(msg_param, msg_num_params, true);
+		call_ctx->rpc_must_release = true;
 
-	mutex_unlock(&cq->mutex);
+		cmd_id = (u32)call_ctx->rpc_arg->params[0].u.value.a;
+		ocall->u.value.a =
+			TEE_IOCTL_OCALL_MAKE_PAIR(TEE_IOCTL_OCALL_CMD_INVOKE,
+						  cmd_id);
+
+		clnt_id = &call_ctx->rpc_arg->params[1].u.value;
+		memcpy(&ocall->u.value.b, clnt_id, TEE_IOCTL_UUID_LEN);
+		break;
+	default:
+		/* NOT REACHED */
+		rc = -EINVAL;
+		goto exit_set_ret;
+	}
+
+	return rc;
+
+exit_set_ret:
+	call_ctx->rpc_arg->ret = TEEC_ERROR_BAD_PARAMETERS;
+	call_ctx->rpc_arg->ret_origin = TEEC_ORIGIN_COMMS;
+	return rc;
 }
 
-/* Requires the filpstate mutex to be held */
-static struct optee_session *find_session(struct optee_context_data *ctxdata,
-					  u32 session_id)
+/* Requires @sem in the parent struct optee_session to be held */
+static int process_ocall_reply(u32 ret, u32 ret_origin,
+			       struct tee_param *params, u32 num_params,
+			       struct tee_param *ocall,
+			       struct optee_call_ctx *call_ctx)
 {
-	struct optee_session *sess;
+	const u64 func = param_get_ocall_func(ocall);
+	struct optee_msg_param *msg_param;
+	u32 msg_num_params;
+	int rc = 0;
 
-	list_for_each_entry(sess, &ctxdata->sess_list, list_node)
-		if (sess->session_id == session_id)
-			return sess;
+	rc = verify_ocall_reply(func, params, num_params, call_ctx);
+	if (rc)
+		goto exit_set_ret;
+
+	switch (func) {
+	case TEE_IOCTL_OCALL_CMD_INVOKE:
+		/* -2 here and +2 below to skip the OCALL descriptors */
+		msg_num_params = call_ctx->rpc_arg->num_params - 2;
+		if (num_params < msg_num_params) {
+			rc = -EINVAL;
+			goto exit_set_ret;
+		}
 
-	return NULL;
+		msg_param = call_ctx->rpc_arg->params + 2;
+		rc = optee_to_msg_param(msg_param, msg_num_params, params);
+		if (rc)
+			goto exit_set_ret;
+
+		process_ocall_memrefs(msg_param, msg_num_params, false);
+		call_ctx->rpc_must_release = false;
+
+		call_ctx->rpc_arg->params[0].u.value.b = ret;
+		call_ctx->rpc_arg->params[0].u.value.c = ret_origin;
+		break;
+	default:
+		rc = -EINVAL;
+		goto exit_set_ret;
+	}
+
+	call_ctx->rpc_arg->ret = TEEC_SUCCESS;
+	call_ctx->rpc_arg->ret_origin = TEEC_ORIGIN_COMMS;
+
+	return rc;
+
+exit_set_ret:
+	call_ctx->rpc_arg->ret = TEEC_ERROR_BAD_PARAMETERS;
+	call_ctx->rpc_arg->ret_origin = TEEC_ORIGIN_COMMS;
+	return rc;
+}
+
+static void clear_call_ctx(struct optee_call_ctx *call_ctx)
+{
+	memset(call_ctx, 0, sizeof(*call_ctx));
 }
 
 /**
- * optee_do_call_with_arg() - Do an SMC to OP-TEE in secure world
- * @ctx:	calling context
- * @parg:	physical address of message to pass to secure world
+ * optee_do_call_with_ctx() - Invoke OP-TEE in secure world
+ * @call_ctx:	calling context
  *
  * Does and SMC to OP-TEE in secure world and handles eventual resulting
  * Remote Procedure Calls (RPC) from OP-TEE.
  *
- * Returns return code from secure world, 0 is OK
+ * Returns return code from secure world, 0 is OK, -EAGAIN means an OCALL
+ * request was received.
  */
-u32 optee_do_call_with_arg(struct tee_context *ctx, phys_addr_t parg)
+static u32 optee_do_call_with_ctx(struct optee_call_ctx *call_ctx)
 {
-	struct optee *optee = tee_get_drvdata(ctx->teedev);
-	struct optee_call_waiter w;
+	struct optee *optee = tee_get_drvdata(call_ctx->ctx->teedev);
 	struct optee_rpc_param param = { };
-	struct optee_call_ctx call_ctx = { };
 	u32 ret;
 
-	param.a0 = OPTEE_SMC_CALL_WITH_ARG;
-	reg_pair_from_64(&param.a1, &param.a2, parg);
-	/* Initialize waiter */
-	optee_cq_wait_init(&optee->call_queue, &w);
+	if (call_ctx->rpc_shm) {
+		param.a0 = OPTEE_SMC_CALL_RETURN_FROM_RPC;
+		reg_pair_from_64(&param.a1, &param.a2,
+				 (uintptr_t)call_ctx->rpc_shm);
+		param.a3 = call_ctx->thread_id;
+	} else {
+		param.a0 = OPTEE_SMC_CALL_WITH_ARG;
+		reg_pair_from_64(&param.a1, &param.a2, call_ctx->msg_parg);
+	}
+
 	while (true) {
 		struct arm_smccc_res res;
 
@@ -148,36 +311,68 @@ u32 optee_do_call_with_arg(struct tee_context *ctx, phys_addr_t parg)
 
 		if (res.a0 == OPTEE_SMC_RETURN_ETHREAD_LIMIT) {
 			/*
-			 * Out of threads in secure world, wait for a thread
+			 * Out of threads in secure world, wait for a thread to
 			 * become available.
 			 */
-			optee_cq_wait_for_completion(&optee->call_queue, &w);
+			optee_cq_wait_for_completion(&optee->call_queue,
+						     &call_ctx->waiter);
 		} else if (OPTEE_SMC_RETURN_IS_RPC(res.a0)) {
-			cond_resched();
+			if (need_resched())
+				cond_resched();
 			param.a0 = res.a0;
 			param.a1 = res.a1;
 			param.a2 = res.a2;
 			param.a3 = res.a3;
-			optee_handle_rpc(ctx, &param, &call_ctx);
+
+			if (optee_rpc_is_ocall(&param, call_ctx))
+				return -EAGAIN;
+
+			optee_handle_rpc(call_ctx->ctx, &param, call_ctx);
 		} else {
 			ret = res.a0;
 			break;
 		}
 	}
 
-	optee_rpc_finalize_call(&call_ctx);
-	/*
-	 * We're done with our thread in secure world, if there's any
-	 * thread waiters wake up one.
-	 */
-	optee_cq_wait_final(&optee->call_queue, &w);
-
 	return ret;
 }
 
-static struct tee_shm *get_msg_arg(struct tee_context *ctx, size_t num_params,
-				   struct optee_msg_arg **msg_arg,
-				   phys_addr_t *msg_parg)
+/**
+ * optee_do_call_with_arg() - Invoke OP-TEE in secure world
+ * @ctx:	calling context
+ * @parg:	physical address of message to pass to secure world
+ *
+ * Wraps a call to optee_do_call_with_ctx that sets up the calling context on
+ * behalf of a caller that does not expect OCALLs.
+ *
+ * Returns return code from secure world, 0 is OK
+ */
+u32 optee_do_call_with_arg(struct tee_context *ctx, phys_addr_t parg)
+{
+	struct optee_call_ctx call_ctx = { };
+	int rc;
+
+	call_ctx.ctx = ctx;
+	call_ctx.msg_parg = parg;
+
+	call_prologue(&call_ctx);
+
+	rc = optee_do_call_with_ctx(&call_ctx);
+	if (rc == -EAGAIN) {
+		pr_warn("received an unexpected OCALL, cancelling it now");
+		call_ctx.rpc_arg->ret = TEEC_ERROR_NOT_SUPPORTED;
+		call_ctx.rpc_arg->ret_origin = TEEC_ORIGIN_COMMS;
+		optee_do_call_with_ctx(&call_ctx);
+	}
+
+	call_epilogue(&call_ctx);
+
+	return rc;
+}
+
+struct tee_shm *optee_get_msg_arg(struct tee_context *ctx, size_t num_params,
+				  struct optee_msg_arg **msg_arg,
+				  phys_addr_t *msg_parg)
 {
 	int rc;
 	struct tee_shm *shm;
@@ -210,90 +405,249 @@ static struct tee_shm *get_msg_arg(struct tee_context *ctx, size_t num_params,
 	return shm;
 }
 
-int optee_open_session(struct tee_context *ctx,
-		       struct tee_ioctl_open_session_arg *arg,
-		       struct tee_param *param)
+/*
+ * Requires @sem in the parent struct optee_session to be held; the caller is
+ * expected to have filled in the ret and ret_origin elements of rpc_arg.
+ */
+static int cancel_ocall(struct optee_call_ctx *call_ctx)
 {
-	struct optee_context_data *ctxdata = ctx->data;
 	int rc;
+
+	/* +2 and -2 to skip the OCALL descriptors */
+	if (call_ctx->rpc_must_release) {
+		process_ocall_memrefs(call_ctx->rpc_arg->params + 2,
+				      call_ctx->rpc_arg->num_params - 2, false);
+		call_ctx->rpc_must_release = false;
+	}
+
+	rc = optee_do_call_with_ctx(call_ctx);
+	if (rc == -EAGAIN)
+		pr_warn("received an OCALL while cancelling an OCALL");
+
+	call_epilogue(call_ctx);
+
+	return rc;
+}
+
+static int close_session(struct tee_context *ctx, u32 session)
+{
 	struct tee_shm *shm;
 	struct optee_msg_arg *msg_arg;
 	phys_addr_t msg_parg;
-	struct optee_session *sess = NULL;
-	uuid_t client_uuid;
 
-	/* +2 for the meta parameters added below */
-	shm = get_msg_arg(ctx, arg->num_params + 2, &msg_arg, &msg_parg);
+	shm = optee_get_msg_arg(ctx, 0, &msg_arg, &msg_parg);
 	if (IS_ERR(shm))
 		return PTR_ERR(shm);
 
-	msg_arg->cmd = OPTEE_MSG_CMD_OPEN_SESSION;
-	msg_arg->cancel_id = arg->cancel_id;
+	msg_arg->cmd = OPTEE_MSG_CMD_CLOSE_SESSION;
+	msg_arg->session = session;
+	optee_do_call_with_arg(ctx, msg_parg);
 
-	/*
-	 * Initialize and add the meta parameters needed when opening a
-	 * session.
-	 */
-	msg_arg->params[0].attr = OPTEE_MSG_ATTR_TYPE_VALUE_INPUT |
-				  OPTEE_MSG_ATTR_META;
-	msg_arg->params[1].attr = OPTEE_MSG_ATTR_TYPE_VALUE_INPUT |
-				  OPTEE_MSG_ATTR_META;
-	memcpy(&msg_arg->params[0].u.value, arg->uuid, sizeof(arg->uuid));
-	msg_arg->params[1].u.value.c = arg->clnt_login;
-
-	rc = tee_session_calc_client_uuid(&client_uuid, arg->clnt_login,
-					  arg->clnt_uuid);
-	if (rc)
-		goto out;
-	export_uuid(msg_arg->params[1].u.octets, &client_uuid);
+	tee_shm_free(shm);
+	return 0;
+}
 
-	rc = optee_to_msg_param(msg_arg->params + 2, arg->num_params, param);
-	if (rc)
-		goto out;
+int optee_open_session(struct tee_context *ctx,
+		       struct tee_ioctl_open_session_arg *arg,
+		       struct tee_param *normal_param, u32 num_normal_params,
+		       struct tee_param *ocall_param)
+{
+	struct optee_context_data *ctxdata = ctx->data;
+	struct optee_session *sess = NULL;
+	struct optee_call_ctx *call_ctx = NULL;
+	int sess_tmp_id;
+	u64 ocall_func;
+	int rc = 0;
 
-	sess = kzalloc(sizeof(*sess), GFP_KERNEL);
-	if (!sess) {
-		rc = -ENOMEM;
-		goto out;
-	}
+	if (ocall_param && !ctx->cap_ocall)
+		return -EOPNOTSUPP;
 
-	if (optee_do_call_with_arg(ctx, msg_parg)) {
-		msg_arg->ret = TEEC_ERROR_COMMUNICATION;
-		msg_arg->ret_origin = TEEC_ORIGIN_COMMS;
-	}
+	ocall_func = ocall_param ? param_get_ocall_func(ocall_param) : 0;
+	if (ocall_func) {
+		if (arg->session > INT_MAX)
+			return -EINVAL;
 
-	if (msg_arg->ret == TEEC_SUCCESS) {
-		/* A new session has been created, add it to the list. */
-		sess->session_id = msg_arg->session;
+		sess_tmp_id = (int)arg->session;
 		mutex_lock(&ctxdata->mutex);
-		list_add(&sess->list_node, &ctxdata->sess_list);
+		sess = idr_remove(&ctxdata->tmp_sess_list, sess_tmp_id);
 		mutex_unlock(&ctxdata->mutex);
+		if (!sess)
+			return -EINVAL;
+
+		call_ctx = &sess->call_ctx;
+		if (!call_ctx->rpc_shm) {
+			rc = -EINVAL;
+			call_ctx->rpc_arg->ret = TEEC_ERROR_BAD_PARAMETERS;
+			call_ctx->rpc_arg->ret_origin = TEEC_ORIGIN_COMMS;
+			goto exit_cancel;
+		}
+
+		rc = process_ocall_reply(arg->ret, arg->ret_origin,
+					 normal_param, num_normal_params,
+					 ocall_param, call_ctx);
+		if (rc)
+			goto exit_cancel;
 	} else {
-		kfree(sess);
+		sess = kzalloc(sizeof(*sess), GFP_KERNEL);
+		if (!sess)
+			return -ENOMEM;
+
+		call_ctx = &sess->call_ctx;
+		/* +2 for the meta parameters added below */
+		call_ctx->msg_shm = optee_get_msg_arg(ctx,
+						      num_normal_params + 2,
+						      &call_ctx->msg_arg,
+						      &call_ctx->msg_parg);
+		if (IS_ERR(call_ctx->msg_shm)) {
+			rc = PTR_ERR(call_ctx->msg_shm);
+			goto exit_free;
+		}
+
+		call_ctx->ctx = ctx;
+		call_ctx->msg_arg->cmd = OPTEE_MSG_CMD_OPEN_SESSION;
+		call_ctx->msg_arg->cancel_id = arg->cancel_id;
+
+		/*
+		 * Initialize and add the meta parameters needed when opening a
+		 * session.
+		 */
+		call_ctx->msg_arg->params[0].attr =
+			OPTEE_MSG_ATTR_TYPE_VALUE_INPUT | OPTEE_MSG_ATTR_META;
+		call_ctx->msg_arg->params[1].attr =
+			OPTEE_MSG_ATTR_TYPE_VALUE_INPUT | OPTEE_MSG_ATTR_META;
+		memcpy(&call_ctx->msg_arg->params[0].u.value, arg->uuid,
+		       sizeof(arg->uuid));
+		call_ctx->msg_arg->params[1].u.value.c = arg->clnt_login;
+		rc = tee_session_calc_client_uuid((uuid_t *)
+			&call_ctx->msg_arg->params[1].u.value,
+			arg->clnt_login, arg->clnt_uuid);
+		if (rc)
+			goto exit_free_shm;
+
+		rc = optee_to_msg_param(call_ctx->msg_arg->params + 2,
+					num_normal_params, normal_param);
+		if (rc)
+			goto exit_free_shm;
+
+		call_prologue(call_ctx);
 	}
 
-	if (optee_from_msg_param(param, arg->num_params, msg_arg->params + 2)) {
-		arg->ret = TEEC_ERROR_COMMUNICATION;
-		arg->ret_origin = TEEC_ORIGIN_COMMS;
-		/* Close session again to avoid leakage */
-		optee_close_session(ctx, msg_arg->session);
+	rc = optee_do_call_with_ctx(call_ctx);
+	if (rc == -EAGAIN) {
+		rc = process_ocall_request(normal_param, num_normal_params,
+					   ocall_param, call_ctx);
+		if (rc)
+			goto exit_cancel;
+
+		/*
+		 * 'sess' becomes globally visible after adding it to the IDR,
+		 * so do not touch it once the mutex is unlocked.
+		 */
+		mutex_lock(&ctxdata->mutex);
+		sess_tmp_id = idr_alloc(&ctxdata->tmp_sess_list, sess, 1, 0,
+					GFP_KERNEL);
+		if (sess_tmp_id >= 1)
+			sess->session_id = sess_tmp_id;
+		mutex_unlock(&ctxdata->mutex);
+		if (sess_tmp_id < 0) {
+			rc = sess_tmp_id;
+			call_ctx->rpc_arg->ret = TEEC_ERROR_OUT_OF_MEMORY;
+			call_ctx->rpc_arg->ret_origin = TEEC_ORIGIN_COMMS;
+			goto exit_cancel;
+		}
+
+		arg->session = sess_tmp_id;
 	} else {
-		arg->session = msg_arg->session;
-		arg->ret = msg_arg->ret;
-		arg->ret_origin = msg_arg->ret_origin;
+		call_epilogue(call_ctx);
+
+		if (rc) {
+			arg->ret = TEEC_ERROR_COMMUNICATION;
+			arg->ret_origin = TEEC_ORIGIN_COMMS;
+		} else {
+			arg->ret = call_ctx->msg_arg->ret;
+			arg->ret_origin = call_ctx->msg_arg->ret_origin;
+		}
+
+		if (optee_from_msg_param(normal_param, num_normal_params,
+					 call_ctx->msg_arg->params + 2)) {
+			if (arg->ret == TEEC_SUCCESS)
+				close_session(ctx, call_ctx->msg_arg->session);
+
+			arg->ret = TEEC_ERROR_COMMUNICATION;
+			arg->ret_origin = TEEC_ORIGIN_COMMS;
+		}
+
+		if (arg->ret)
+			goto exit_clear_free_all;
+
+		/*
+		 * A new session has been created, initialize it and add it to
+		 * the list.
+		 */
+		sema_init(&sess->sem, 1);
+		arg->session = call_ctx->msg_arg->session;
+		sess->session_id = call_ctx->msg_arg->session;
+
+		tee_shm_free(call_ctx->msg_shm);
+		clear_call_ctx(call_ctx);
+
+		mutex_lock(&ctxdata->mutex);
+		list_add(&sess->list_node, &ctxdata->sess_list);
+		mutex_unlock(&ctxdata->mutex);
+
+		param_clear_ocall(ocall_param);
 	}
-out:
-	tee_shm_free(shm);
 
 	return rc;
+
+exit_cancel:
+	/* See comment in optee_cancel_open_session_ocall */
+	if (cancel_ocall(call_ctx) == 0 &&
+	    call_ctx->msg_arg->ret == TEEC_SUCCESS)
+		close_session(ctx, call_ctx->msg_arg->session);
+	optee_from_msg_param(normal_param, num_normal_params,
+			     call_ctx->msg_arg->params);
+exit_clear_free_all:
+	param_clear_ocall(ocall_param);
+exit_free_shm:
+	tee_shm_free(call_ctx->msg_shm);
+exit_free:
+	kfree(sess);
+	return rc;
+}
+
+void optee_cancel_open_session_ocall(struct optee_session *sess)
+{
+	struct optee_call_ctx *call_ctx = &sess->call_ctx;
+
+	call_ctx->rpc_arg->ret = TEEC_ERROR_TARGET_DEAD;
+	call_ctx->rpc_arg->ret_origin = TEEC_ORIGIN_COMMS;
+
+	/*
+	 * Reaching this function means an OCALL is pending during session open
+	 * but the CA has terminated abnormally. As such, the OCALL is
+	 * cancelled. However, there is a chance that the TA's session open
+	 * handler ignores the cancellation and lets the session open anyway. If
+	 * that happens, close it.
+	 */
+	if (cancel_ocall(&sess->call_ctx) == 0 &&
+	    call_ctx->msg_arg->ret == TEEC_SUCCESS)
+		close_session(call_ctx->ctx, call_ctx->msg_arg->session);
+
+	/*
+	 * Decrease the ref count on all shared memory pointers passed into the
+	 * original function invocation.
+	 */
+	process_ocall_memrefs(call_ctx->msg_arg->params,
+			      call_ctx->msg_arg->num_params, false);
+
+	tee_shm_free(call_ctx->msg_shm);
+	kfree(sess);
 }
 
 int optee_close_session(struct tee_context *ctx, u32 session)
 {
 	struct optee_context_data *ctxdata = ctx->data;
-	struct tee_shm *shm;
-	struct optee_msg_arg *msg_arg;
-	phys_addr_t msg_parg;
 	struct optee_session *sess;
 
 	/* Check that the session is valid and remove it from the list */
@@ -304,66 +658,162 @@ int optee_close_session(struct tee_context *ctx, u32 session)
 	mutex_unlock(&ctxdata->mutex);
 	if (!sess)
 		return -EINVAL;
-	kfree(sess);
 
-	shm = get_msg_arg(ctx, 0, &msg_arg, &msg_parg);
-	if (IS_ERR(shm))
-		return PTR_ERR(shm);
+	/*
+	 * If another thread found the session before we removed it from the
+	 * list and that thread is operating on the session object itself, wait
+	 * until it is done before we destroy it.
+	 */
+	down(&sess->sem);
 
-	msg_arg->cmd = OPTEE_MSG_CMD_CLOSE_SESSION;
-	msg_arg->session = session;
-	optee_do_call_with_arg(ctx, msg_parg);
+	if (sess->call_ctx.rpc_shm)
+		optee_cancel_invoke_function_ocall(&sess->call_ctx);
+
+	kfree(sess);
+	close_session(ctx, session);
 
-	tee_shm_free(shm);
 	return 0;
 }
 
 int optee_invoke_func(struct tee_context *ctx, struct tee_ioctl_invoke_arg *arg,
-		      struct tee_param *param)
+		      struct tee_param *normal_param, u32 num_normal_params,
+		      struct tee_param *ocall_param)
 {
 	struct optee_context_data *ctxdata = ctx->data;
-	struct tee_shm *shm;
-	struct optee_msg_arg *msg_arg;
-	phys_addr_t msg_parg;
+	struct optee_call_ctx *call_ctx;
 	struct optee_session *sess;
-	int rc;
+	u64 ocall_func;
+	int rc = 0;
+
+	if (ocall_param && !ctx->cap_ocall) {
+		rc = -EOPNOTSUPP;
+		goto exit;
+	}
 
 	/* Check that the session is valid */
 	mutex_lock(&ctxdata->mutex);
 	sess = find_session(ctxdata, arg->session);
+	if (sess)
+		down(&sess->sem);
 	mutex_unlock(&ctxdata->mutex);
 	if (!sess)
 		return -EINVAL;
 
-	shm = get_msg_arg(ctx, arg->num_params, &msg_arg, &msg_parg);
-	if (IS_ERR(shm))
-		return PTR_ERR(shm);
-	msg_arg->cmd = OPTEE_MSG_CMD_INVOKE_COMMAND;
-	msg_arg->func = arg->func;
-	msg_arg->session = arg->session;
-	msg_arg->cancel_id = arg->cancel_id;
+	call_ctx = &sess->call_ctx;
+	ocall_func = ocall_param ? param_get_ocall_func(ocall_param) : 0;
+	if (ocall_func) {
+		/* The current call is a reply to an OCALL request */
 
-	rc = optee_to_msg_param(msg_arg->params, arg->num_params, param);
-	if (rc)
-		goto out;
+		if (!call_ctx->rpc_shm) {
+			rc = -EINVAL;
+			goto exit;
+		}
+
+		rc = process_ocall_reply(arg->ret, arg->ret_origin,
+					 normal_param, num_normal_params,
+					 ocall_param, call_ctx);
+		if (rc)
+			goto exit_cancel;
+	} else {
+		/*
+		 * The current call is an invocation that may result in an OCALL
+		 * request.
+		 */
+
+		if (call_ctx->rpc_shm) {
+			rc = -EINVAL;
+			call_ctx->rpc_arg->ret = TEEC_ERROR_BAD_PARAMETERS;
+			call_ctx->rpc_arg->ret_origin = TEEC_ORIGIN_COMMS;
+			goto exit_cancel;
+		}
 
-	if (optee_do_call_with_arg(ctx, msg_parg)) {
-		msg_arg->ret = TEEC_ERROR_COMMUNICATION;
-		msg_arg->ret_origin = TEEC_ORIGIN_COMMS;
+		call_ctx->msg_shm = optee_get_msg_arg(ctx, num_normal_params,
+						      &call_ctx->msg_arg,
+						      &call_ctx->msg_parg);
+		if (IS_ERR(call_ctx->msg_shm)) {
+			rc = PTR_ERR(call_ctx->msg_shm);
+			goto exit_clear;
+		}
+
+		call_ctx->ctx = ctx;
+		call_ctx->msg_arg->cmd = OPTEE_MSG_CMD_INVOKE_COMMAND;
+		call_ctx->msg_arg->func = arg->func;
+		call_ctx->msg_arg->session = arg->session;
+		call_ctx->msg_arg->cancel_id = arg->cancel_id;
+
+		rc = optee_to_msg_param(call_ctx->msg_arg->params,
+					num_normal_params, normal_param);
+		if (rc) {
+			tee_shm_free(call_ctx->msg_shm);
+			goto exit_clear;
+		}
+
+		call_prologue(call_ctx);
 	}
 
-	if (optee_from_msg_param(param, arg->num_params, msg_arg->params)) {
-		msg_arg->ret = TEEC_ERROR_COMMUNICATION;
-		msg_arg->ret_origin = TEEC_ORIGIN_COMMS;
+	rc = optee_do_call_with_ctx(call_ctx);
+	if (rc == -EAGAIN) {
+		rc = process_ocall_request(normal_param, num_normal_params,
+					   ocall_param, call_ctx);
+		if (rc)
+			goto exit_cancel;
+	} else {
+		call_epilogue(call_ctx);
+
+		arg->ret = call_ctx->msg_arg->ret;
+		arg->ret_origin = call_ctx->msg_arg->ret_origin;
+
+		if (rc) {
+			arg->ret = TEEC_ERROR_COMMUNICATION;
+			arg->ret_origin = TEEC_ORIGIN_COMMS;
+		}
+
+		if (optee_from_msg_param(normal_param, num_normal_params,
+					 call_ctx->msg_arg->params)) {
+			arg->ret = TEEC_ERROR_COMMUNICATION;
+			arg->ret_origin = TEEC_ORIGIN_COMMS;
+		}
+
+		tee_shm_free(call_ctx->msg_shm);
+		clear_call_ctx(call_ctx);
+		param_clear_ocall(ocall_param);
 	}
 
-	arg->ret = msg_arg->ret;
-	arg->ret_origin = msg_arg->ret_origin;
-out:
-	tee_shm_free(shm);
+	up(&sess->sem);
+	return rc;
+
+exit_cancel:
+	cancel_ocall(call_ctx);
+	optee_from_msg_param(normal_param, num_normal_params,
+			     call_ctx->msg_arg->params);
+	tee_shm_free(call_ctx->msg_shm);
+	param_clear_ocall(ocall_param);
+exit_clear:
+	clear_call_ctx(call_ctx);
+exit:
+	up(&sess->sem);
 	return rc;
 }
 
+/* Requires @sem in the parent struct optee_session to be held */
+void optee_cancel_invoke_function_ocall(struct optee_call_ctx *call_ctx)
+{
+	call_ctx->rpc_arg->ret = TEEC_ERROR_TARGET_DEAD;
+	call_ctx->rpc_arg->ret_origin = TEEC_ORIGIN_COMMS;
+
+	cancel_ocall(call_ctx);
+
+	/*
+	 * Decrease the ref count on all shared memory pointers passed into the
+	 * original function invocation.
+	 */
+	process_ocall_memrefs(call_ctx->msg_arg->params,
+			      call_ctx->msg_arg->num_params, false);
+
+	tee_shm_free(call_ctx->msg_shm);
+	clear_call_ctx(call_ctx);
+}
+
 int optee_cancel_req(struct tee_context *ctx, u32 cancel_id, u32 session)
 {
 	struct optee_context_data *ctxdata = ctx->data;
@@ -379,7 +829,7 @@ int optee_cancel_req(struct tee_context *ctx, u32 cancel_id, u32 session)
 	if (!sess)
 		return -EINVAL;
 
-	shm = get_msg_arg(ctx, 0, &msg_arg, &msg_parg);
+	shm = optee_get_msg_arg(ctx, 0, &msg_arg, &msg_parg);
 	if (IS_ERR(shm))
 		return PTR_ERR(shm);
 
@@ -632,7 +1082,7 @@ int optee_shm_register(struct tee_context *ctx, struct tee_shm *shm,
 	if (!pages_list)
 		return -ENOMEM;
 
-	shm_arg = get_msg_arg(ctx, 1, &msg_arg, &msg_parg);
+	shm_arg = optee_get_msg_arg(ctx, 1, &msg_arg, &msg_parg);
 	if (IS_ERR(shm_arg)) {
 		rc = PTR_ERR(shm_arg);
 		goto out;
@@ -670,7 +1120,7 @@ int optee_shm_unregister(struct tee_context *ctx, struct tee_shm *shm)
 	phys_addr_t msg_parg;
 	int rc = 0;
 
-	shm_arg = get_msg_arg(ctx, 1, &msg_arg, &msg_parg);
+	shm_arg = optee_get_msg_arg(ctx, 1, &msg_arg, &msg_parg);
 	if (IS_ERR(shm_arg))
 		return PTR_ERR(shm_arg);
 
diff --git a/drivers/tee/optee/call_queue.c b/drivers/tee/optee/call_queue.c
new file mode 100644
index 000000000..70922c040
--- /dev/null
+++ b/drivers/tee/optee/call_queue.c
@@ -0,0 +1,86 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2015, Linaro Limited
+ */
+
+#include "optee_private.h"
+
+void optee_cq_wait_init(struct optee_call_queue *cq,
+			struct optee_call_waiter *w)
+{
+	/*
+	 * We're preparing to make a call to secure world. In case we can't
+	 * allocate a thread in secure world we'll end up waiting in
+	 * optee_cq_wait_for_completion().
+	 *
+	 * Normally if there's no contention in secure world the call will
+	 * complete and we can cleanup directly with optee_cq_wait_final().
+	 */
+	mutex_lock(&cq->mutex);
+
+	/*
+	 * We add ourselves to the queue, but we don't wait. This
+	 * guarantees that we don't lose a completion if secure world
+	 * returns busy and another thread just exited and try to complete
+	 * someone.
+	 */
+	init_completion(&w->c);
+	list_add_tail(&w->list_node, &cq->waiters);
+
+	mutex_unlock(&cq->mutex);
+}
+
+void optee_cq_wait_for_completion(struct optee_call_queue *cq,
+				  struct optee_call_waiter *w)
+{
+	wait_for_completion(&w->c);
+
+	mutex_lock(&cq->mutex);
+
+	/* Move to end of list to get out of the way for other waiters */
+	list_del(&w->list_node);
+	reinit_completion(&w->c);
+	list_add_tail(&w->list_node, &cq->waiters);
+
+	mutex_unlock(&cq->mutex);
+}
+
+void optee_cq_complete_one(struct optee_call_queue *cq)
+{
+	struct optee_call_waiter *w;
+
+	list_for_each_entry(w, &cq->waiters, list_node) {
+		if (!completion_done(&w->c)) {
+			complete(&w->c);
+			break;
+		}
+	}
+}
+
+void optee_cq_wait_final(struct optee_call_queue *cq,
+			 struct optee_call_waiter *w)
+{
+	/*
+	 * We're done with the call to secure world. The thread in secure
+	 * world that was used for this call is now available for some
+	 * other task to use.
+	 */
+	mutex_lock(&cq->mutex);
+
+	/* Get out of the list */
+	list_del(&w->list_node);
+
+	/* Wake up one eventual waiting task */
+	optee_cq_complete_one(cq);
+
+	/*
+	 * If we're completed we've got a completion from another task that
+	 * was just done with its call to secure world. Since yet another
+	 * thread now is available in secure world wake up another eventual
+	 * waiting task.
+	 */
+	if (completion_done(&w->c))
+		optee_cq_complete_one(cq);
+
+	mutex_unlock(&cq->mutex);
+}
diff --git a/drivers/tee/optee/core.c b/drivers/tee/optee/core.c
index 50c0d839f..ab3e5d65e 100644
--- a/drivers/tee/optee/core.c
+++ b/drivers/tee/optee/core.c
@@ -8,17 +8,22 @@
 #include <linux/arm-smccc.h>
 #include <linux/crash_dump.h>
 #include <linux/errno.h>
+#include <linux/interrupt.h>
 #include <linux/io.h>
+#include <linux/irqdomain.h>
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/of_irq.h>
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
+#include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/tee_drv.h>
 #include <linux/types.h>
 #include <linux/uaccess.h>
 #include <linux/workqueue.h>
+#include <linux/xarray.h>
 #include "optee_private.h"
 #include "optee_smc.h"
 #include "shm_pool.h"
@@ -209,6 +214,8 @@ static void optee_get_version(struct tee_device *teedev,
 		v.gen_caps |= TEE_GEN_CAP_REG_MEM;
 	if (optee->sec_caps & OPTEE_SMC_SEC_CAP_MEMREF_NULL)
 		v.gen_caps |= TEE_GEN_CAP_MEMREF_NULL;
+	if (optee->sec_caps & OPTEE_SMC_SEC_CAP_OCALL)
+		v.gen_caps |= TEE_GEN_CAP_OCALL;
 	*vers = v;
 }
 
@@ -254,11 +261,10 @@ static int optee_open(struct tee_context *ctx)
 	}
 	mutex_init(&ctxdata->mutex);
 	INIT_LIST_HEAD(&ctxdata->sess_list);
+	idr_init(&ctxdata->tmp_sess_list);
 
-	if (optee->sec_caps & OPTEE_SMC_SEC_CAP_MEMREF_NULL)
-		ctx->cap_memref_null  = true;
-	else
-		ctx->cap_memref_null = false;
+	ctx->cap_memref_null = optee->sec_caps & OPTEE_SMC_SEC_CAP_MEMREF_NULL;
+	ctx->cap_ocall = optee->sec_caps & OPTEE_SMC_SEC_CAP_OCALL;
 
 	ctx->data = ctxdata;
 	return 0;
@@ -304,6 +310,7 @@ static void optee_release(struct tee_context *ctx)
 		}
 		kfree(sess);
 	}
+	idr_destroy(&ctxdata->tmp_sess_list);
 	kfree(ctxdata);
 
 	if (!IS_ERR(shm))
@@ -355,6 +362,345 @@ static const struct tee_desc optee_supp_desc = {
 	.flags = TEE_DESC_PRIVILEGED,
 };
 
+static int simple_call_with_arg(struct tee_context *ctx, u32 cmd)
+{
+	struct optee_msg_arg *msg_arg;
+	struct tee_shm *shm;
+	phys_addr_t msg_parg;
+
+	shm = optee_get_msg_arg(ctx, 0, &msg_arg, &msg_parg);
+	if (IS_ERR(shm))
+		return PTR_ERR(shm);
+
+	msg_arg->cmd = cmd;
+	optee_do_call_with_arg(ctx, msg_parg);
+
+	tee_shm_free(shm);
+	return 0;
+}
+
+static u32 get_it_value(optee_invoke_fn *invoke_fn, bool *value_valid,
+			bool *value_pending)
+{
+	struct arm_smccc_res res;
+
+	invoke_fn(OPTEE_SMC_GET_IT_NOTIF_VALUE, 0, 0, 0, 0, 0, 0, 0, &res);
+
+	if (res.a0)
+		return 0;
+	*value_valid = (res.a2 & OPTEE_SMC_IT_NOTIF_VALUE_VALID);
+	*value_pending = (res.a2 & OPTEE_SMC_IT_NOTIF_VALUE_PENDING);
+	return res.a1;
+}
+
+static u32 set_it_mask(optee_invoke_fn *invoke_fn, u32 it_value, bool mask)
+{
+	struct arm_smccc_res res;
+
+	invoke_fn(OPTEE_SMC_SET_IT_NOTIF_MASK, it_value, mask, 0, 0, 0, 0, 0, &res);
+
+	if (res.a0)
+		return 0;
+
+	return res.a1;
+}
+
+static int handle_optee_it(struct optee *optee)
+{
+	bool value_valid;
+	bool value_pending;
+	u32 it;
+
+	do {
+		struct irq_desc *desc;
+
+		it = get_it_value(optee->invoke_fn, &value_valid,
+				  &value_pending);
+		if (!value_valid)
+			break;
+
+		desc = irq_to_desc(irq_find_mapping(optee->domain, it));
+		if (!desc) {
+			pr_err("no desc for optee IT:%d\n", it);
+			return -EIO;
+		}
+
+		handle_simple_irq(desc);
+
+	} while (value_pending);
+
+	return 0;
+}
+
+static void optee_it_irq_mask(struct irq_data *d)
+{
+	struct optee *optee = d->domain->host_data;
+
+	set_it_mask(optee->invoke_fn, d->hwirq, true);
+}
+
+static void optee_it_irq_unmask(struct irq_data *d)
+{
+	struct optee *optee = d->domain->host_data;
+
+	set_it_mask(optee->invoke_fn, d->hwirq, false);
+}
+
+static struct irq_chip optee_it_irq_chip = {
+	.name = "optee-it",
+	.irq_disable = optee_it_irq_mask,
+	.irq_enable = optee_it_irq_unmask,
+	.flags = IRQCHIP_SKIP_SET_WAKE,
+};
+
+static int optee_it_alloc(struct irq_domain *d, unsigned int virq,
+			  unsigned int nr_irqs, void *data)
+{
+	struct irq_fwspec *fwspec = data;
+	irq_hw_number_t hwirq;
+
+	hwirq = fwspec->param[0];
+
+	irq_domain_set_hwirq_and_chip(d, virq, hwirq, &optee_it_irq_chip, d->host_data);
+
+	return 0;
+}
+
+static const struct irq_domain_ops optee_it_irq_domain_ops = {
+	.alloc = optee_it_alloc,
+	.free = irq_domain_free_irqs_common,
+};
+
+static int optee_irq_domain_init(struct platform_device *pdev, struct optee *optee)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+
+	optee->domain = irq_domain_add_linear(np, OPTEE_MAX_IT,
+					      &optee_it_irq_domain_ops,
+					      optee);
+	if (!optee->domain) {
+		pr_err("Unable to add irq domain!\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void optee_irq_domain_uninit(struct optee *optee)
+{
+	irq_domain_remove(optee->domain);
+}
+
+static int optee_smc_do_bottom_half(struct tee_context *ctx)
+{
+	return simple_call_with_arg(ctx, OPTEE_MSG_CMD_DO_BOTTOM_HALF);
+}
+
+static int optee_smc_stop_async_notif(struct tee_context *ctx)
+{
+	return simple_call_with_arg(ctx, OPTEE_MSG_CMD_STOP_ASYNC_NOTIF);
+}
+
+static u32 get_async_notif_value(optee_invoke_fn *invoke_fn, bool *value_valid,
+				 bool *value_pending)
+{
+	struct arm_smccc_res res;
+
+	invoke_fn(OPTEE_SMC_GET_ASYNC_NOTIF_VALUE, 0, 0, 0, 0, 0, 0, 0, &res);
+
+	if (res.a0)
+		return 0;
+	*value_valid = (res.a2 & OPTEE_SMC_ASYNC_NOTIF_VALUE_VALID);
+	*value_pending = (res.a2 & OPTEE_SMC_ASYNC_NOTIF_VALUE_PENDING);
+	return res.a1;
+}
+
+static irqreturn_t notif_irq_handler(int irq, void *dev_id)
+{
+	struct optee_pcpu *optee_pcpu;
+	struct optee *optee;
+	bool do_bottom_half = false;
+	bool value_valid;
+	bool value_pending;
+	u32 value;
+
+	if (irq_is_percpu_devid(irq)) {
+		optee_pcpu = (struct optee_pcpu *)dev_id;
+		optee = optee_pcpu->optee;
+	} else {
+		optee = dev_id;
+	}
+
+	do {
+		value = get_async_notif_value(optee->invoke_fn,
+					      &value_valid, &value_pending);
+		if (!value_valid)
+			break;
+
+		if (value == OPTEE_SMC_ASYNC_NOTIF_VALUE_DO_BOTTOM_HALF)
+			do_bottom_half = true;
+		else if (value == OPTEE_SMC_ASYNC_NOTIF_VALUE_DO_IT)
+			handle_optee_it(optee);
+		else
+			optee_notif_send(optee, value);
+	} while (value_pending);
+
+	if (do_bottom_half) {
+		if (irq_is_percpu_devid(irq))
+			queue_work(optee->notif_pcpu_wq, &optee->notif_pcpu_work);
+		else
+			return IRQ_WAKE_THREAD;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t notif_irq_thread_fn(int irq, void *dev_id)
+{
+	struct optee *optee = dev_id;
+
+	optee_smc_do_bottom_half(optee->notif.ctx);
+
+	return IRQ_HANDLED;
+}
+
+static void optee_pcpu_notif(struct work_struct *work)
+{
+	struct optee *optee = container_of(work, struct optee, notif_pcpu_work);
+
+	optee_smc_do_bottom_half(optee->notif.ctx);
+}
+
+static int optee_smc_notif_init_irq(struct optee *optee, u_int irq)
+{
+	struct tee_context *ctx;
+	int rc;
+
+	ctx = teedev_open(optee->teedev);
+	if (IS_ERR(ctx))
+		return PTR_ERR(ctx);
+
+	optee->notif.ctx = ctx;
+	rc = request_threaded_irq(irq, notif_irq_handler,
+				  notif_irq_thread_fn,
+				  0, "optee_notification", optee);
+	if (rc)
+		goto err_close_ctx;
+
+	optee->notif_irq = irq;
+
+	return 0;
+
+err_close_ctx:
+	teedev_close_context(optee->notif.ctx);
+	optee->notif.ctx = NULL;
+
+	return rc;
+}
+
+static int optee_smc_notif_pcpu_init_irq(struct optee *optee, u_int irq)
+{
+	struct optee_pcpu *optee_pcpu;
+	struct tee_context *ctx;
+	spinlock_t lock;
+	int cpu;
+	int rc;
+
+	/* Alloc per-cpu port structure */
+	optee_pcpu = alloc_percpu(struct optee_pcpu);
+	if (!optee_pcpu)
+		return -ENOMEM;
+
+	for_each_present_cpu(cpu) {
+		struct optee_pcpu *p = per_cpu_ptr(optee_pcpu, cpu);
+
+		p->optee = optee;
+	}
+
+	ctx = teedev_open(optee->teedev);
+	if (IS_ERR(ctx)) {
+		rc = PTR_ERR(ctx);
+		goto err_free_pcpu;
+	}
+
+	optee->notif.ctx = ctx;
+
+	rc = request_percpu_irq(irq, notif_irq_handler, "optee_pcpu_notification",
+				optee_pcpu);
+	if (rc) {
+		rc = PTR_ERR(ctx);
+		goto err_close_ctx;
+	}
+
+	spin_lock_init(&lock);
+
+	spin_lock(&lock);
+	enable_percpu_irq(irq, 0);
+	spin_unlock(&lock);
+
+	INIT_WORK(&optee->notif_pcpu_work, optee_pcpu_notif);
+	optee->notif_pcpu_wq = create_workqueue("optee_pcpu_notification");
+	if (!optee->notif_pcpu_wq) {
+		rc = -EINVAL;
+		goto err_free_pcpu_irq;
+	}
+
+	optee->optee_pcpu = optee_pcpu;
+	optee->notif_pcpu_irq = irq;
+
+	return 0;
+
+err_free_pcpu_irq:
+	spin_lock(&lock);
+	disable_percpu_irq(irq);
+	spin_unlock(&lock);
+	free_percpu_irq(irq, optee_pcpu);
+err_close_ctx:
+	teedev_close_context(optee->notif.ctx);
+	optee->notif.ctx = NULL;
+err_free_pcpu:
+	free_percpu(optee_pcpu);
+
+	return rc;
+}
+
+static void optee_smc_notif_uninit_irq(struct optee *optee)
+{
+	if (optee->notif.ctx) {
+		optee_smc_stop_async_notif(optee->notif.ctx);
+		if (optee->notif_irq) {
+			free_irq(optee->notif_irq, optee);
+			irq_dispose_mapping(optee->notif_irq);
+		} else if (optee->notif_pcpu_irq) {
+			free_percpu_irq(optee->notif_irq, optee->optee_pcpu);
+			irq_dispose_mapping(optee->notif_irq);
+		}
+
+		/*
+		 * The thread normally working with optee->notif.ctx was
+		 * stopped with free_irq() above.
+		 *
+		 * Note we're not using teedev_close_context() or
+		 * tee_client_close_context() since we have already called
+		 * tee_device_put() while initializing to avoid a circular
+		 * reference counting.
+		 */
+		teedev_close_context(optee->notif.ctx);
+	}
+}
+
+static int enable_async_notif(optee_invoke_fn *invoke_fn)
+{
+	struct arm_smccc_res res;
+
+	invoke_fn(OPTEE_SMC_ENABLE_ASYNC_NOTIF, 0, 0, 0, 0, 0, 0, 0, &res);
+
+	if (res.a0)
+		return -EINVAL;
+	return 0;
+}
+
 static bool optee_msg_api_uid_is_optee_api(optee_invoke_fn *invoke_fn)
 {
 	struct arm_smccc_res res;
@@ -404,7 +750,7 @@ static bool optee_msg_api_revision_is_compatible(optee_invoke_fn *invoke_fn)
 }
 
 static bool optee_msg_exchange_capabilities(optee_invoke_fn *invoke_fn,
-					    u32 *sec_caps)
+					    u32 *sec_caps, u32 *max_notif_value)
 {
 	union {
 		struct arm_smccc_res smccc;
@@ -427,6 +773,12 @@ static bool optee_msg_exchange_capabilities(optee_invoke_fn *invoke_fn,
 		return false;
 
 	*sec_caps = res.result.capabilities;
+
+	if (*sec_caps & OPTEE_SMC_SEC_CAP_ASYNC_NOTIF)
+		*max_notif_value = res.result.max_notif_value;
+	else
+		*max_notif_value = OPTEE_DEFAULT_MAX_NOTIF_VALUE;
+
 	return true;
 }
 
@@ -596,6 +948,10 @@ static int optee_remove(struct platform_device *pdev)
 	 */
 	optee_disable_shm_cache(optee);
 
+	optee_irq_domain_uninit(optee);
+
+	optee_smc_notif_uninit_irq(optee);
+
 	/*
 	 * The two devices have to be unregistered before we can free the
 	 * other resources.
@@ -606,7 +962,6 @@ static int optee_remove(struct platform_device *pdev)
 	tee_shm_pool_free(optee->pool);
 	if (optee->memremaped_shm)
 		memunmap(optee->memremaped_shm);
-	optee_wait_queue_exit(&optee->wait_queue);
 	optee_supp_uninit(&optee->supp);
 	mutex_destroy(&optee->call_queue.mutex);
 
@@ -635,6 +990,7 @@ static int optee_probe(struct platform_device *pdev)
 	void *memremaped_shm = NULL;
 	struct tee_device *teedev;
 	struct tee_context *ctx;
+	u32 max_notif_value;
 	u32 sec_caps;
 	int rc;
 
@@ -664,7 +1020,8 @@ static int optee_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
-	if (!optee_msg_exchange_capabilities(invoke_fn, &sec_caps)) {
+	if (!optee_msg_exchange_capabilities(invoke_fn, &sec_caps,
+					     &max_notif_value)) {
 		pr_warn("capabilities mismatch\n");
 		return -EINVAL;
 	}
@@ -687,7 +1044,7 @@ static int optee_probe(struct platform_device *pdev)
 	optee = kzalloc(sizeof(*optee), GFP_KERNEL);
 	if (!optee) {
 		rc = -ENOMEM;
-		goto err;
+		goto err_free_pool;
 	}
 
 	optee->invoke_fn = invoke_fn;
@@ -696,38 +1053,73 @@ static int optee_probe(struct platform_device *pdev)
 	teedev = tee_device_alloc(&optee_desc, NULL, pool, optee);
 	if (IS_ERR(teedev)) {
 		rc = PTR_ERR(teedev);
-		goto err;
+		goto err_free_optee;
 	}
 	optee->teedev = teedev;
 
 	teedev = tee_device_alloc(&optee_supp_desc, NULL, pool, optee);
 	if (IS_ERR(teedev)) {
 		rc = PTR_ERR(teedev);
-		goto err;
+		goto err_unreg_teedev;
 	}
 	optee->supp_teedev = teedev;
 
 	rc = tee_device_register(optee->teedev);
 	if (rc)
-		goto err;
+		goto err_unreg_supp_teedev;
 
 	rc = tee_device_register(optee->supp_teedev);
 	if (rc)
-		goto err;
+		goto err_unreg_supp_teedev;
 
 	mutex_init(&optee->call_queue.mutex);
 	INIT_LIST_HEAD(&optee->call_queue.waiters);
-	optee_wait_queue_init(&optee->wait_queue);
 	optee_supp_init(&optee->supp);
 	optee->memremaped_shm = memremaped_shm;
 	optee->pool = pool;
+
 	ctx = teedev_open(optee->teedev);
 	if (IS_ERR(ctx)) {
 		rc = PTR_ERR(ctx);
-		goto err;
+		goto err_supp_uninit;
 	}
 	optee->ctx = ctx;
 
+	platform_set_drvdata(pdev, optee);
+	rc = optee_notif_init(optee, max_notif_value);
+	if (rc)
+		goto err_close_ctx;
+
+	if (sec_caps & OPTEE_SMC_SEC_CAP_ASYNC_NOTIF) {
+		unsigned int irq;
+
+		rc = platform_get_irq(pdev, 0);
+		if (rc < 0) {
+			pr_err("platform_get_irq: ret %d\n", rc);
+			goto err_notif_uninit;
+		}
+		irq = rc;
+
+		if (irq_is_percpu_devid(irq))
+			rc = optee_smc_notif_pcpu_init_irq(optee, irq);
+		else
+			rc = optee_smc_notif_init_irq(optee, irq);
+
+		if (rc) {
+			irq_dispose_mapping(irq);
+			goto err_notif_uninit;
+		}
+
+		rc = optee_irq_domain_init(pdev, optee);
+		if (rc) {
+			irq_dispose_mapping(irq);
+			goto err_notif_uninit;
+		}
+
+		enable_async_notif(optee->invoke_fn);
+		pr_info("Asynchronous notifications enabled\n");
+	}
+
 	/*
 	 * Ensure that there are no pre-existing shm objects before enabling
 	 * the shm cache so that there's no chance of receiving an invalid
@@ -742,31 +1134,36 @@ static int optee_probe(struct platform_device *pdev)
 	if (optee->sec_caps & OPTEE_SMC_SEC_CAP_DYNAMIC_SHM)
 		pr_info("dynamic shared memory is enabled\n");
 
-	platform_set_drvdata(pdev, optee);
-
 	rc = optee_enumerate_devices(PTA_CMD_GET_DEVICES);
-	if (rc) {
-		optee_remove(pdev);
-		return rc;
-	}
+	if (rc)
+		goto err_disable_shm_cache;
 
 	pr_info("initialized driver\n");
 	return 0;
-err:
-	if (optee) {
-		/*
-		 * tee_device_unregister() is safe to call even if the
-		 * devices hasn't been registered with
-		 * tee_device_register() yet.
-		 */
-		tee_device_unregister(optee->supp_teedev);
-		tee_device_unregister(optee->teedev);
-		kfree(optee);
-	}
-	if (pool)
-		tee_shm_pool_free(pool);
+
+err_disable_shm_cache:
+	optee_disable_shm_cache(optee);
+	optee_smc_notif_uninit_irq(optee);
+	optee_unregister_devices();
+	optee_irq_domain_uninit(optee);
+err_notif_uninit:
+	optee_notif_uninit(optee);
+err_close_ctx:
+	teedev_close_context(optee->ctx);
+err_supp_uninit:
+	optee_supp_uninit(&optee->supp);
+	mutex_destroy(&optee->call_queue.mutex);
+err_unreg_supp_teedev:
+	tee_device_unregister(optee->supp_teedev);
+err_unreg_teedev:
+	tee_device_unregister(optee->teedev);
+err_free_optee:
+	kfree(optee);
+err_free_pool:
+	tee_shm_pool_free(pool);
 	if (memremaped_shm)
 		memunmap(memremaped_shm);
+
 	return rc;
 }
 
diff --git a/drivers/tee/optee/notif.c b/drivers/tee/optee/notif.c
new file mode 100644
index 000000000..a28fa03dc
--- /dev/null
+++ b/drivers/tee/optee/notif.c
@@ -0,0 +1,125 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2015-2021, Linaro Limited
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/arm-smccc.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/tee_drv.h>
+#include "optee_private.h"
+
+struct notif_entry {
+	struct list_head link;
+	struct completion c;
+	u_int key;
+};
+
+static bool have_key(struct optee *optee, u_int key)
+{
+	struct notif_entry *entry;
+
+	list_for_each_entry(entry, &optee->notif.db, link)
+		if (entry->key == key)
+			return true;
+
+	return false;
+}
+
+int optee_notif_wait(struct optee *optee, u_int key)
+{
+	unsigned long flags;
+	struct notif_entry *entry;
+	int rc = 0;
+
+	if (key > optee->notif.max_key)
+		return -EINVAL;
+
+	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		return -ENOMEM;
+	init_completion(&entry->c);
+	entry->key = key;
+
+	spin_lock_irqsave(&optee->notif.lock, flags);
+
+	/*
+	 * If the bit is already set it means that the key has already
+	 * been posted and we must not wait.
+	 */
+	if (test_bit(key, optee->notif.bitmap)) {
+		clear_bit(key, optee->notif.bitmap);
+		goto out;
+	}
+
+	/*
+	 * Check if someone is already waiting for this key. If there is
+	 * it's a programming error.
+	 */
+	if (have_key(optee, key)) {
+		rc = -EBUSY;
+		goto out;
+	}
+
+	list_add_tail(&entry->link, &optee->notif.db);
+
+	/*
+	 * Unlock temporarily and wait for completion.
+	 */
+	spin_unlock_irqrestore(&optee->notif.lock, flags);
+	wait_for_completion(&entry->c);
+	spin_lock_irqsave(&optee->notif.lock, flags);
+
+	list_del(&entry->link);
+out:
+	spin_unlock_irqrestore(&optee->notif.lock, flags);
+
+	kfree(entry);
+
+	return rc;
+}
+
+int optee_notif_send(struct optee *optee, u_int key)
+{
+	unsigned long flags;
+	struct notif_entry *entry;
+
+	if (key > optee->notif.max_key)
+		return -EINVAL;
+
+	spin_lock_irqsave(&optee->notif.lock, flags);
+
+	list_for_each_entry(entry, &optee->notif.db, link)
+		if (entry->key == key) {
+			complete(&entry->c);
+			goto out;
+		}
+
+	/* Only set the bit in case there where nobody waiting */
+	set_bit(key, optee->notif.bitmap);
+out:
+	spin_unlock_irqrestore(&optee->notif.lock, flags);
+
+	return 0;
+}
+
+int optee_notif_init(struct optee *optee, u_int max_key)
+{
+	spin_lock_init(&optee->notif.lock);
+	INIT_LIST_HEAD(&optee->notif.db);
+	optee->notif.bitmap = bitmap_zalloc(max_key, GFP_KERNEL);
+	if (!optee->notif.bitmap)
+		return -ENOMEM;
+
+	optee->notif.max_key = max_key;
+
+	return 0;
+}
+
+void optee_notif_uninit(struct optee *optee)
+{
+	kfree(optee->notif.bitmap);
+}
diff --git a/drivers/tee/optee/optee_msg.h b/drivers/tee/optee/optee_msg.h
index e3d72d09c..e247cbce8 100644
--- a/drivers/tee/optee/optee_msg.h
+++ b/drivers/tee/optee/optee_msg.h
@@ -12,9 +12,11 @@
  * This file defines the OP-TEE message protocol (ABI) used to communicate
  * with an instance of OP-TEE running in secure world.
  *
- * This file is divided into two sections.
+ * This file is divided into three sections.
  * 1. Formatting of messages.
  * 2. Requests from normal world
+ * 3. Requests from secure world, Remote Procedure Call (RPC), handled by
+ *    tee-supplicant.
  */
 
 /*****************************************************************************
@@ -52,8 +54,8 @@
  * Every entry in buffer should point to a 4k page beginning (12 least
  * significant bits must be equal to zero).
  *
- * 12 least significant bits of optee_msg_param.u.tmem.buf_ptr should hold
- * page offset of user buffer.
+ * 12 least significant bints of optee_msg_param.u.tmem.buf_ptr should hold page
+ * offset of the user buffer.
  *
  * So, entries should be placed like members of this structure:
  *
@@ -293,6 +295,13 @@ struct optee_msg_arg {
  * [in] param[0].u.rmem.shm_ref		holds shared memory reference
  * [in] param[0].u.rmem.offs		0
  * [in] param[0].u.rmem.size		0
+ *
+ * OPTEE_MSG_CMD_DO_BOTTOM_HALF does the scheduled bottom half processing
+ * of a driver.
+ *
+ * OPTEE_MSG_CMD_STOP_ASYNC_NOTIF informs secure world that from now is
+ * normal world unable to process asynchronous notifications. Typically
+ * used when the driver is shut down.
  */
 #define OPTEE_MSG_CMD_OPEN_SESSION	0
 #define OPTEE_MSG_CMD_INVOKE_COMMAND	1
@@ -300,6 +309,151 @@ struct optee_msg_arg {
 #define OPTEE_MSG_CMD_CANCEL		3
 #define OPTEE_MSG_CMD_REGISTER_SHM	4
 #define OPTEE_MSG_CMD_UNREGISTER_SHM	5
+#define OPTEE_MSG_CMD_DO_BOTTOM_HALF	6
+#define OPTEE_MSG_CMD_STOP_ASYNC_NOTIF	7
 #define OPTEE_MSG_FUNCID_CALL_WITH_ARG	0x0004
 
+/*****************************************************************************
+ * Part 3 - Requests from secure world, RPC
+ *****************************************************************************/
+
+/*
+ * All RPC is done with a struct optee_msg_arg as bearer of information,
+ * struct optee_msg_arg::arg holds values defined by OPTEE_MSG_RPC_CMD_* below
+ *
+ * RPC communication with tee-supplicant is reversed compared to normal
+ * client communication desribed above. The supplicant receives requests
+ * and sends responses.
+ */
+
+/*
+ * Load a TA into memory, defined in tee-supplicant
+ */
+#define OPTEE_MSG_RPC_CMD_LOAD_TA	0
+
+/*
+ * Reserved
+ */
+#define OPTEE_MSG_RPC_CMD_RPMB		1
+
+/*
+ * File system access, defined in tee-supplicant
+ */
+#define OPTEE_MSG_RPC_CMD_FS		2
+
+/*
+ * Get time
+ *
+ * Returns number of seconds and nano seconds since the Epoch,
+ * 1970-01-01 00:00:00 +0000 (UTC).
+ *
+ * [out] param[0].u.value.a	Number of seconds
+ * [out] param[0].u.value.b	Number of nano seconds.
+ */
+#define OPTEE_MSG_RPC_CMD_GET_TIME	3
+
+/*
+ * Wait queue primitive, helper for secure world to implement a wait queue.
+ *
+ * If secure world need to wait for a secure world mutex it issues a sleep
+ * request instead of spinning in secure world. Conversely is a wakeup
+ * request issued when a secure world mutex with a thread waiting thread is
+ * unlocked.
+ *
+ * Waiting on a key
+ * [in] param[0].u.value.a OPTEE_MSG_RPC_WAIT_QUEUE_SLEEP
+ * [in] param[0].u.value.b wait key
+ *
+ * Waking up a key
+ * [in] param[0].u.value.a OPTEE_MSG_RPC_WAIT_QUEUE_WAKEUP
+ * [in] param[0].u.value.b wakeup key
+ */
+#define OPTEE_MSG_RPC_CMD_WAIT_QUEUE	4
+#define OPTEE_MSG_RPC_WAIT_QUEUE_SLEEP	0
+#define OPTEE_MSG_RPC_WAIT_QUEUE_WAKEUP	1
+
+/*
+ * Suspend execution
+ *
+ * [in] param[0].value	.a number of milliseconds to suspend
+ */
+#define OPTEE_MSG_RPC_CMD_SUSPEND	5
+
+/*
+ * Allocate a piece of shared memory
+ *
+ * Shared memory can optionally be fragmented, to support that additional
+ * spare param entries are allocated to make room for eventual fragments.
+ * The spare param entries has .attr = OPTEE_MSG_ATTR_TYPE_NONE when
+ * unused. All returned temp memrefs except the last should have the
+ * OPTEE_MSG_ATTR_FRAGMENT bit set in the attr field.
+ *
+ * [in]  param[0].u.value.a		type of memory one of
+ *					OPTEE_MSG_RPC_SHM_TYPE_* below
+ * [in]  param[0].u.value.b		requested size
+ * [in]  param[0].u.value.c		required alignment
+ *
+ * [out] param[0].u.tmem.buf_ptr	physical address (of first fragment)
+ * [out] param[0].u.tmem.size		size (of first fragment)
+ * [out] param[0].u.tmem.shm_ref	shared memory reference
+ * ...
+ * [out] param[n].u.tmem.buf_ptr	physical address
+ * [out] param[n].u.tmem.size		size
+ * [out] param[n].u.tmem.shm_ref	shared memory reference (same value
+ *					as in param[n-1].u.tmem.shm_ref)
+ */
+#define OPTEE_MSG_RPC_CMD_SHM_ALLOC	6
+/* Memory that can be shared with a non-secure user space application */
+#define OPTEE_MSG_RPC_SHM_TYPE_APPL		0
+/* Memory only shared with non-secure kernel */
+#define OPTEE_MSG_RPC_SHM_TYPE_KERNEL		1
+#define OPTEE_MSG_RPC_SHM_TYPE_GLOBAL		2
+/* Memory shared with the requesting TA's Client Application */
+#define OPTEE_MSG_RPC_SHM_TYPE_CLIENT_APPL	3
+
+/*
+ * Free shared memory previously allocated with OPTEE_MSG_RPC_CMD_SHM_ALLOC
+ *
+ * [in]  param[0].u.value.a		type of memory one of
+ *					OPTEE_MSG_RPC_SHM_TYPE_* above
+ * [in]  param[0].u.value.b		value of shared memory reference
+ *					returned in param[0].u.tmem.shm_ref
+ *					above
+ */
+#define OPTEE_MSG_RPC_CMD_SHM_FREE	7
+
+/*
+ * Access a device on an i2c bus
+ *
+ * [in]  param[0].u.value.a		mode: RD(0), WR(1)
+ * [in]  param[0].u.value.b		i2c adapter
+ * [in]  param[0].u.value.c		i2c chip
+ *
+ * [in]  param[1].u.value.a		i2c control flags
+ *
+ * [in/out] memref[2]			buffer to exchange the transfer data
+ *					with the secure world
+ *
+ * [out]  param[3].u.value.a		bytes transferred by the driver
+ */
+#define OPTEE_MSG_RPC_CMD_I2C_TRANSFER 21
+/* I2C master transfer modes */
+#define OPTEE_MSG_RPC_CMD_I2C_TRANSFER_RD 0
+#define OPTEE_MSG_RPC_CMD_I2C_TRANSFER_WR 1
+/* I2C master control flags */
+#define OPTEE_MSG_RPC_CMD_I2C_FLAGS_TEN_BIT  BIT(0)
+
+/*
+ * Send a command to the Client Application.
+ *
+ * [in]  param[0].u.value[0].a		command Id
+ * [out] param[0].u.value[0].b		OCALL return value
+ * [out] param[0].u.value[0].c		OCALL return value origin
+ * [in]  param[0].u.value[1].a		UUID of TA whence OCALL originated (Hi)
+ * [out] param[0].u.value[1].b		UUID of TA whence OCALL originated (Lo)
+ *
+ * [in/out] any[2..5].*	    OCALL parameters as specified by the TA, if any
+ */
+#define OPTEE_MSG_RPC_CMD_OCALL		22
+
 #endif /* _OPTEE_MSG_H */
diff --git a/drivers/tee/optee/optee_private.h b/drivers/tee/optee/optee_private.h
index ea09533e3..37ab55cc1 100644
--- a/drivers/tee/optee/optee_private.h
+++ b/drivers/tee/optee/optee_private.h
@@ -16,14 +16,25 @@
 
 /* Some Global Platform error codes used in this driver */
 #define TEEC_SUCCESS			0x00000000
+#define TEEC_ERROR_CANCEL		0xFFFF0002
 #define TEEC_ERROR_BAD_PARAMETERS	0xFFFF0006
 #define TEEC_ERROR_NOT_SUPPORTED	0xFFFF000A
 #define TEEC_ERROR_COMMUNICATION	0xFFFF000E
 #define TEEC_ERROR_OUT_OF_MEMORY	0xFFFF000C
 #define TEEC_ERROR_SHORT_BUFFER		0xFFFF0010
+#define TEEC_ERROR_TARGET_DEAD		0xFFFF3024
 
 #define TEEC_ORIGIN_COMMS		0x00000002
 
+/*
+ * This value should be larger than the number threads in secure world to
+ * meet the need from secure world. The number of threads in secure world
+ * are usually not even close to 255 so we should be safe for now.
+ */
+#define OPTEE_DEFAULT_MAX_NOTIF_VALUE	255
+
+#define OPTEE_MAX_IT 32
+
 typedef void (optee_invoke_fn)(unsigned long, unsigned long, unsigned long,
 				unsigned long, unsigned long, unsigned long,
 				unsigned long, unsigned long,
@@ -35,10 +46,13 @@ struct optee_call_queue {
 	struct list_head waiters;
 };
 
-struct optee_wait_queue {
-	/* Serializes access to this struct */
-	struct mutex mu;
+struct optee_notif {
+	u_int max_key;
+	struct tee_context *ctx;
+	/* Serializes access to the elements below in this struct */
+	spinlock_t lock;
 	struct list_head db;
+	u_long *bitmap;
 };
 
 /**
@@ -73,8 +87,7 @@ struct optee_supp {
  * @ctx:		driver internal TEE context
  * @invoke_fn:		function to issue smc or hvc
  * @call_queue:		queue of threads waiting to call @invoke_fn
- * @wait_queue:		queue of threads from secure world waiting for a
- *			secure world sync object
+ * @notif:		notification synchronization struct
  * @supp:		supplicant synchronization struct for RPC to supplicant
  * @pool:		shared memory pool
  * @memremaped_shm	virtual address of memory in shared memory pool
@@ -83,6 +96,9 @@ struct optee_supp {
  * @scan_bus_done	flag if device registation was already done.
  * @scan_bus_wq		workqueue to scan optee bus and register optee drivers
  * @scan_bus_work	workq to scan optee bus and register optee drivers
+ * @optee_pcpu		per_cpu optee instance
+ * @notif_pcpu_wq	workqueue for per cpu aynchronous notification
+ * @notif_pcpu_work	work for per cpu asynchronous notification
  */
 struct optee {
 	struct tee_device *supp_teedev;
@@ -90,7 +106,7 @@ struct optee {
 	optee_invoke_fn *invoke_fn;
 	struct tee_context *ctx;
 	struct optee_call_queue call_queue;
-	struct optee_wait_queue wait_queue;
+	struct optee_notif notif;
 	struct optee_supp supp;
 	struct tee_shm_pool *pool;
 	void *memremaped_shm;
@@ -98,17 +114,81 @@ struct optee {
 	bool   scan_bus_done;
 	struct workqueue_struct *scan_bus_wq;
 	struct work_struct scan_bus_work;
+	unsigned int notif_irq;
+	unsigned int notif_pcpu_irq;
+	struct optee_pcpu __percpu *optee_pcpu;
+	struct workqueue_struct *notif_pcpu_wq;
+	struct work_struct notif_pcpu_work;
+	struct irq_domain *domain;
+};
+
+struct optee_call_waiter {
+	struct list_head list_node;
+	struct completion c;
+};
+
+struct optee_pcpu {
+	struct optee *optee;
+};
+
+/**
+ * struct optee_call_ctx - holds context that is preserved during one STD call
+ * @pages_list:		list of pages allocated for RPC requests
+ * @num_entries:	number of pages in 'pages_list'
+ * @ctx:		TEE context whence the OCALL originated, if any
+ * @msg_shm:		shared memory object used for calling into OP-TEE
+ * @msg_arg:		arguments used for calling into OP-TEE, namely the data
+ *			behind 'msg_shm'
+ * @msg_parg:		physical pointer underlying 'msg_shm'
+ * @rpc_must_release:	indicates that OCALL parameters have had their refcount
+ *			increased and must be decreased on cancellation
+ * @rpc_shm:		shared memory object used for responding to RPCs
+ * @rpc_arg:		arguments used for responding to RPCs, namely the data
+ *			behind 'rpc_shm'
+ * @thread_id:		secure thread Id whence the OCALL originated and which
+ *			must be resumed when replying to the OCALL
+ * @waiter:		object used to wait until a secure thread becomes
+ *			available is the previous call into OP-TEE failed
+ *			because all secure threads are in use
+ * @ocall_pages_list:   list of pages allocated for OCALL requests
+ * @ocall_num_entries:  number of pages in 'ocall_pages_list'
+ */
+struct optee_call_ctx {
+	/* Information about pages list used in last allocation */
+	void *pages_list;
+	size_t num_entries;
+
+	/* OCALL support */
+	struct tee_context *ctx;
+
+	struct tee_shm *msg_shm;
+	struct optee_msg_arg *msg_arg;
+	phys_addr_t msg_parg;
+
+	bool rpc_must_release;
+	struct tee_shm *rpc_shm;
+	struct optee_msg_arg *rpc_arg;
+
+	u32 thread_id;
+	struct optee_call_waiter waiter;
+
+	void *ocall_pages_list;
+	size_t ocall_num_entries;
 };
 
 struct optee_session {
+	/* Serializes access to this struct */
+	struct semaphore sem;
 	struct list_head list_node;
 	u32 session_id;
+	struct optee_call_ctx call_ctx;
 };
 
 struct optee_context_data {
 	/* Serializes access to this struct */
 	struct mutex mutex;
 	struct list_head sess_list;
+	struct idr tmp_sess_list;
 };
 
 struct optee_rpc_param {
@@ -122,19 +202,40 @@ struct optee_rpc_param {
 	u32	a7;
 };
 
-/* Holds context that is preserved during one STD call */
-struct optee_call_ctx {
-	/* information about pages list used in last allocation */
-	void *pages_list;
-	size_t num_entries;
-};
+/*
+ * RPC support
+ */
 
 void optee_handle_rpc(struct tee_context *ctx, struct optee_rpc_param *param,
 		      struct optee_call_ctx *call_ctx);
+bool optee_rpc_is_ocall(struct optee_rpc_param *param,
+			struct optee_call_ctx *call_ctx);
 void optee_rpc_finalize_call(struct optee_call_ctx *call_ctx);
 
-void optee_wait_queue_init(struct optee_wait_queue *wq);
-void optee_wait_queue_exit(struct optee_wait_queue *wq);
+/*
+ * Wait queue
+ */
+
+int optee_notif_init(struct optee *optee, u_int max_key);
+void optee_notif_uninit(struct optee *optee);
+int optee_notif_wait(struct optee *optee, u_int key);
+int optee_notif_send(struct optee *optee, u_int key);
+
+/*
+ * Call queue
+ */
+
+void optee_cq_wait_init(struct optee_call_queue *cq,
+			struct optee_call_waiter *w);
+void optee_cq_wait_for_completion(struct optee_call_queue *cq,
+				  struct optee_call_waiter *w);
+void optee_cq_complete_one(struct optee_call_queue *cq);
+void optee_cq_wait_final(struct optee_call_queue *cq,
+			 struct optee_call_waiter *w);
+
+/*
+ * Supplicant
+ */
 
 u32 optee_supp_thrd_req(struct tee_context *ctx, u32 func, size_t num_params,
 			struct tee_param *param);
@@ -150,15 +251,40 @@ int optee_supp_recv(struct tee_context *ctx, u32 *func, u32 *num_params,
 int optee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params,
 		    struct tee_param *param);
 
+/*
+ * Calls into OP-TEE
+ */
+
 u32 optee_do_call_with_arg(struct tee_context *ctx, phys_addr_t parg);
+
+/*
+ * Sessions
+ */
+
 int optee_open_session(struct tee_context *ctx,
 		       struct tee_ioctl_open_session_arg *arg,
-		       struct tee_param *param);
+		       struct tee_param *normal_param, u32 num_normal_params,
+		       struct tee_param *ocall_param);
 int optee_close_session(struct tee_context *ctx, u32 session);
+
+/*
+ * Function invocations
+ */
+
 int optee_invoke_func(struct tee_context *ctx, struct tee_ioctl_invoke_arg *arg,
-		      struct tee_param *param);
+		      struct tee_param *normal_param, u32 num_normal_params,
+		      struct tee_param *ocall_param);
+
+/*
+ * Cancellations
+ */
+
 int optee_cancel_req(struct tee_context *ctx, u32 cancel_id, u32 session);
 
+/*
+ * Shared memory
+ */
+
 void optee_enable_shm_cache(struct optee *optee);
 void optee_disable_shm_cache(struct optee *optee);
 void optee_disable_unmapped_shm_cache(struct optee *optee);
@@ -173,21 +299,43 @@ int optee_shm_register_supp(struct tee_context *ctx, struct tee_shm *shm,
 			    unsigned long start);
 int optee_shm_unregister_supp(struct tee_context *ctx, struct tee_shm *shm);
 
+/*
+ * Paremeters
+ */
+
 int optee_from_msg_param(struct tee_param *params, size_t num_params,
 			 const struct optee_msg_param *msg_params);
 int optee_to_msg_param(struct optee_msg_param *msg_params, size_t num_params,
 		       const struct tee_param *params);
+struct tee_shm *optee_get_msg_arg(struct tee_context *ctx, size_t num_params,
+				  struct optee_msg_arg **msg_arg,
+				  phys_addr_t *msg_parg);
+
+/*
+ * RPC memory
+ */
 
 u64 *optee_allocate_pages_list(size_t num_entries);
 void optee_free_pages_list(void *array, size_t num_entries);
 void optee_fill_pages_list(u64 *dst, struct page **pages, int num_pages,
 			   size_t page_offset);
 
+/*
+ * Devices
+ */
+
 #define PTA_CMD_GET_DEVICES		0x0
 #define PTA_CMD_GET_DEVICES_SUPP	0x1
 int optee_enumerate_devices(u32 func);
 void optee_unregister_devices(void);
 
+/*
+ * OCALLs
+ */
+
+void optee_cancel_open_session_ocall(struct optee_session *sess);
+void optee_cancel_invoke_function_ocall(struct optee_call_ctx *call_ctx);
+
 /*
  * Small helpers
  */
diff --git a/drivers/tee/optee/optee_rpc_cmd.h b/drivers/tee/optee/optee_rpc_cmd.h
index b8275140c..f3f06e099 100644
--- a/drivers/tee/optee/optee_rpc_cmd.h
+++ b/drivers/tee/optee/optee_rpc_cmd.h
@@ -28,24 +28,27 @@
 #define OPTEE_RPC_CMD_GET_TIME		3
 
 /*
- * Wait queue primitive, helper for secure world to implement a wait queue.
+ * Notification from/to secure world.
  *
- * If secure world needs to wait for a secure world mutex it issues a sleep
- * request instead of spinning in secure world. Conversely is a wakeup
- * request issued when a secure world mutex with a thread waiting thread is
- * unlocked.
+ * If secure world needs to wait for something, for instance a mutex, it
+ * does a notification wait request instead of spinning in secure world.
+ * Conversely can a synchronous notification can be sent when a secure
+ * world mutex with a thread waiting thread is unlocked.
  *
- * Waiting on a key
- * [in]    value[0].a	    OPTEE_RPC_WAIT_QUEUE_SLEEP
- * [in]    value[0].b	    Wait key
+ * This interface can also be used to wait for a asynchronous notification
+ * which instead is sent via a non-secure interrupt.
  *
- * Waking up a key
- * [in]    value[0].a	    OPTEE_RPC_WAIT_QUEUE_WAKEUP
- * [in]    value[0].b	    Wakeup key
+ * Waiting on notification
+ * [in]    value[0].a	    OPTEE_RPC_NOTIFICATION_WAIT
+ * [in]    value[0].b	    notification value
+ *
+ * Sending a synchronous notification
+ * [in]    value[0].a	    OPTEE_RPC_NOTIFICATION_SEND
+ * [in]    value[0].b	    notification value
  */
-#define OPTEE_RPC_CMD_WAIT_QUEUE	4
-#define OPTEE_RPC_WAIT_QUEUE_SLEEP	0
-#define OPTEE_RPC_WAIT_QUEUE_WAKEUP	1
+#define OPTEE_RPC_CMD_NOTIFICATION	4
+#define OPTEE_RPC_NOTIFICATION_WAIT	0
+#define OPTEE_RPC_NOTIFICATION_SEND	1
 
 /*
  * Suspend execution
diff --git a/drivers/tee/optee/optee_smc.h b/drivers/tee/optee/optee_smc.h
index 80eb763a8..6fd5c2cd8 100644
--- a/drivers/tee/optee/optee_smc.h
+++ b/drivers/tee/optee/optee_smc.h
@@ -107,6 +107,12 @@ struct optee_smc_call_get_os_revision_result {
 /*
  * Call with struct optee_msg_arg as argument
  *
+ * When calling this function normal world has a few responsibilities:
+ * 1. It must be able to handle eventual RPCs
+ * 2. Non-secure interrupts should not be masked
+ * 3. If asynchronous notifications has been negotiated successfully, then
+ *    asynchronous notifications should be unmasked during this call.
+ *
  * Call register usage:
  * a0	SMC Function ID, OPTEE_SMC*CALL_WITH_ARG
  * a1	Upper 32 bits of a 64-bit physical pointer to a struct optee_msg_arg
@@ -195,7 +201,8 @@ struct optee_smc_get_shm_config_result {
  * Normal return register usage:
  * a0	OPTEE_SMC_RETURN_OK
  * a1	bitfield of secure world capabilities OPTEE_SMC_SEC_CAP_*
- * a2-7	Preserved
+ * a2	The maximum secure world notification number
+ * a3-7	Preserved
  *
  * Error return register usage:
  * a0	OPTEE_SMC_RETURN_ENOTAVAIL, can't use the capabilities from normal world
@@ -218,6 +225,11 @@ struct optee_smc_get_shm_config_result {
 #define OPTEE_SMC_SEC_CAP_VIRTUALIZATION	BIT(3)
 /* Secure world supports Shared Memory with a NULL reference */
 #define OPTEE_SMC_SEC_CAP_MEMREF_NULL		BIT(4)
+/* Secure world supports asynchronous notification of normal world */
+#define OPTEE_SMC_SEC_CAP_ASYNC_NOTIF		BIT(5)
+
+/* Secure world is built with OCALL support */
+#define OPTEE_SMC_SEC_CAP_OCALL			BIT(31)
 
 #define OPTEE_SMC_FUNCID_EXCHANGE_CAPABILITIES	9
 #define OPTEE_SMC_EXCHANGE_CAPABILITIES \
@@ -226,8 +238,8 @@ struct optee_smc_get_shm_config_result {
 struct optee_smc_exchange_capabilities_result {
 	unsigned long status;
 	unsigned long capabilities;
+	unsigned long max_notif_value;
 	unsigned long reserved0;
-	unsigned long reserved1;
 };
 
 /*
@@ -319,6 +331,84 @@ struct optee_smc_disable_shm_cache_result {
 #define OPTEE_SMC_GET_THREAD_COUNT \
 	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_GET_THREAD_COUNT)
 
+/*
+ * Inform OP-TEE that normal world is able to receive asynchronous
+ * notifications.
+ *
+ * Call requests usage:
+ * a0	SMC Function ID, OPTEE_SMC_ENABLE_ASYNC_NOTIF
+ * a1-6	Not used
+ * a7	Hypervisor Client ID register
+ *
+ * Normal return register usage:
+ * a0	OPTEE_SMC_RETURN_OK
+ * a1-7	Preserved
+ *
+ * Not supported return register usage:
+ * a0	OPTEE_SMC_RETURN_ENOTAVAIL
+ * a1-7	Preserved
+ */
+#define OPTEE_SMC_FUNCID_ENABLE_ASYNC_NOTIF	16
+#define OPTEE_SMC_ENABLE_ASYNC_NOTIF \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_ENABLE_ASYNC_NOTIF)
+
+/*
+ * Retrieve a value of notifications pending since the last call of this
+ * function.
+ *
+ * OP-TEE keeps a record of all posted values. When an interrupt is
+ * received which indicates that there are posted values this function
+ * should be called until all pended values have been retrieved. When a
+ * value is retrieved, it's cleared from the record in secure world.
+ *
+ * Call requests usage:
+ * a0	SMC Function ID, OPTEE_SMC_GET_ASYNC_NOTIF_VALUE
+ * a1-6	Not used
+ * a7	Hypervisor Client ID register
+ *
+ * Normal return register usage:
+ * a0	OPTEE_SMC_RETURN_OK
+ * a1	value
+ * a2	Bit[0]: OPTEE_SMC_ASYNC_NOTIF_VALUE_VALID if the value in a1 is
+ *		valid, else 0 if no values where pending
+ * a2	Bit[1]: OPTEE_SMC_ASYNC_NOTIF_VALUE_PENDING if another value is
+ *		pending, else 0.
+ *	Bit[31:2]: MBZ
+ * a3-7	Preserved
+ *
+ * Not supported return register usage:
+ * a0	OPTEE_SMC_RETURN_ENOTAVAIL
+ * a1-7	Preserved
+ */
+#define OPTEE_SMC_ASYNC_NOTIF_VALUE_VALID	BIT(0)
+#define OPTEE_SMC_ASYNC_NOTIF_VALUE_PENDING	BIT(1)
+
+/*
+ * Notification that OP-TEE expects a yielding call to do some bottom half
+ * work in a driver.
+ */
+#define OPTEE_SMC_ASYNC_NOTIF_VALUE_DO_BOTTOM_HALF	0
+
+#define OPTEE_SMC_FUNCID_GET_ASYNC_NOTIF_VALUE	17
+#define OPTEE_SMC_GET_ASYNC_NOTIF_VALUE \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_GET_ASYNC_NOTIF_VALUE)
+
+#define OPTEE_SMC_ASYNC_NOTIF_VALUE_DO_IT		1
+
+#define OPTEE_SMC_IT_NOTIF_VALUE_VALID		BIT(0)
+#define OPTEE_SMC_IT_NOTIF_VALUE_PENDING		BIT(1)
+
+/*
+ * Notification that OP-TEE generates and interruption.
+ */
+#define OPTEE_SMC_FUNCID_GET_IT_NOTIF_VALUE	53
+#define OPTEE_SMC_GET_IT_NOTIF_VALUE \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_GET_IT_NOTIF_VALUE)
+
+#define OPTEE_SMC_FUNCID_SET_IT_NOTIF_MASK	54
+#define OPTEE_SMC_SET_IT_NOTIF_MASK \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_SET_IT_NOTIF_MASK)
+
 /*
  * Resume from RPC (for example after processing a foreign interrupt)
  *
diff --git a/drivers/tee/optee/rpc.c b/drivers/tee/optee/rpc.c
index 456833d82..ae41f4e64 100644
--- a/drivers/tee/optee/rpc.c
+++ b/drivers/tee/optee/rpc.c
@@ -14,23 +14,6 @@
 #include "optee_smc.h"
 #include "optee_rpc_cmd.h"
 
-struct wq_entry {
-	struct list_head link;
-	struct completion c;
-	u32 key;
-};
-
-void optee_wait_queue_init(struct optee_wait_queue *priv)
-{
-	mutex_init(&priv->mu);
-	INIT_LIST_HEAD(&priv->db);
-}
-
-void optee_wait_queue_exit(struct optee_wait_queue *priv)
-{
-	mutex_destroy(&priv->mu);
-}
-
 static void handle_rpc_func_cmd_get_time(struct optee_msg_arg *arg)
 {
 	struct timespec64 ts;
@@ -143,48 +126,6 @@ static void handle_rpc_func_cmd_i2c_transfer(struct tee_context *ctx,
 }
 #endif
 
-static struct wq_entry *wq_entry_get(struct optee_wait_queue *wq, u32 key)
-{
-	struct wq_entry *w;
-
-	mutex_lock(&wq->mu);
-
-	list_for_each_entry(w, &wq->db, link)
-		if (w->key == key)
-			goto out;
-
-	w = kmalloc(sizeof(*w), GFP_KERNEL);
-	if (w) {
-		init_completion(&w->c);
-		w->key = key;
-		list_add_tail(&w->link, &wq->db);
-	}
-out:
-	mutex_unlock(&wq->mu);
-	return w;
-}
-
-static void wq_sleep(struct optee_wait_queue *wq, u32 key)
-{
-	struct wq_entry *w = wq_entry_get(wq, key);
-
-	if (w) {
-		wait_for_completion(&w->c);
-		mutex_lock(&wq->mu);
-		list_del(&w->link);
-		mutex_unlock(&wq->mu);
-		kfree(w);
-	}
-}
-
-static void wq_wakeup(struct optee_wait_queue *wq, u32 key)
-{
-	struct wq_entry *w = wq_entry_get(wq, key);
-
-	if (w)
-		complete(&w->c);
-}
-
 static void handle_rpc_func_cmd_wq(struct optee *optee,
 				   struct optee_msg_arg *arg)
 {
@@ -196,11 +137,13 @@ static void handle_rpc_func_cmd_wq(struct optee *optee,
 		goto bad;
 
 	switch (arg->params[0].u.value.a) {
-	case OPTEE_RPC_WAIT_QUEUE_SLEEP:
-		wq_sleep(&optee->wait_queue, arg->params[0].u.value.b);
+	case OPTEE_RPC_NOTIFICATION_WAIT:
+		if (optee_notif_wait(optee, arg->params[0].u.value.b))
+			goto bad;
 		break;
-	case OPTEE_RPC_WAIT_QUEUE_WAKEUP:
-		wq_wakeup(&optee->wait_queue, arg->params[0].u.value.b);
+	case OPTEE_RPC_NOTIFICATION_SEND:
+		if (optee_notif_send(optee, arg->params[0].u.value.b))
+			goto bad;
 		break;
 	default:
 		goto bad;
@@ -465,7 +408,7 @@ static void handle_rpc_func_cmd(struct tee_context *ctx, struct optee *optee,
 	case OPTEE_RPC_CMD_GET_TIME:
 		handle_rpc_func_cmd_get_time(arg);
 		break;
-	case OPTEE_RPC_CMD_WAIT_QUEUE:
+	case OPTEE_RPC_CMD_NOTIFICATION:
 		handle_rpc_func_cmd_wq(optee, arg);
 		break;
 	case OPTEE_RPC_CMD_SUSPEND:
@@ -541,3 +484,31 @@ void optee_handle_rpc(struct tee_context *ctx, struct optee_rpc_param *param,
 
 	param->a0 = OPTEE_SMC_CALL_RETURN_FROM_RPC;
 }
+
+bool optee_rpc_is_ocall(struct optee_rpc_param *param,
+			struct optee_call_ctx *call_ctx)
+{
+	u32 func;
+
+	struct tee_shm *shm;
+	struct optee_msg_arg *arg;
+
+	func = OPTEE_SMC_RETURN_GET_RPC_FUNC(param->a0);
+	if (func != OPTEE_SMC_RPC_FUNC_CMD)
+		return false;
+
+	shm = reg_pair_to_ptr(param->a1, param->a2);
+	arg = tee_shm_get_va(shm, 0);
+
+	switch (arg->cmd) {
+	case OPTEE_MSG_RPC_CMD_OCALL:
+		call_ctx->rpc_shm = shm;
+		call_ctx->rpc_arg = arg;
+		call_ctx->thread_id = param->a3;
+		return true;
+	default:
+		break;
+	}
+
+	return false;
+}
diff --git a/drivers/tee/tee_core.c b/drivers/tee/tee_core.c
index 3fc426dad..705bb4e53 100644
--- a/drivers/tee/tee_core.c
+++ b/drivers/tee/tee_core.c
@@ -356,6 +356,14 @@ tee_ioctl_shm_register(struct tee_context *ctx,
 	return ret;
 }
 
+static bool param_is_ocall(struct tee_param *param)
+{
+	u64 type = param->attr & TEE_IOCTL_PARAM_ATTR_TYPE_MASK;
+
+	return param->attr & TEE_IOCTL_PARAM_ATTR_OCALL &&
+	       type == TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT;
+}
+
 static int params_from_user(struct tee_context *ctx, struct tee_param *params,
 			    size_t num_params,
 			    struct tee_ioctl_param __user *uparams)
@@ -464,6 +472,33 @@ static int params_to_user(struct tee_ioctl_param __user *uparams,
 	return 0;
 }
 
+static inline int find_ocall_param(struct tee_param *params, u32 num_params,
+				   struct tee_param **normal_params,
+				   u32 *num_normal_params,
+				   struct tee_param **ocall_param)
+{
+	size_t n;
+
+	for (n = 0; n < num_params; n++) {
+		if (param_is_ocall(params + n)) {
+			if (n == 0) {
+				*normal_params = params + 1;
+				*num_normal_params = num_params - 1;
+				*ocall_param = params;
+				return 0;
+			} else {
+				return -EINVAL;
+			}
+		}
+	}
+
+	*normal_params = params;
+	*num_normal_params = num_params;
+	*ocall_param = NULL;
+
+	return 0;
+}
+
 static int tee_ioctl_open_session(struct tee_context *ctx,
 				  struct tee_ioctl_buf_data __user *ubuf)
 {
@@ -511,7 +546,9 @@ static int tee_ioctl_open_session(struct tee_context *ctx,
 		goto out;
 	}
 
-	rc = ctx->teedev->desc->ops->open_session(ctx, &arg, params);
+	rc = ctx->teedev->desc->ops->open_session(ctx, &arg, params,
+						  arg.num_params,
+						  NULL /*ocall_param*/);
 	if (rc)
 		goto out;
 	have_session = true;
@@ -582,7 +619,9 @@ static int tee_ioctl_invoke(struct tee_context *ctx,
 			goto out;
 	}
 
-	rc = ctx->teedev->desc->ops->invoke_func(ctx, &arg, params);
+	rc = ctx->teedev->desc->ops->invoke_func(ctx, &arg, params,
+						 arg.num_params,
+						 NULL /*ocall_param*/);
 	if (rc)
 		goto out;
 
@@ -1159,9 +1198,22 @@ int tee_client_open_session(struct tee_context *ctx,
 			    struct tee_ioctl_open_session_arg *arg,
 			    struct tee_param *param)
 {
+	struct tee_param *ocall_param = NULL;
+	struct tee_param *normal_params = NULL;
+	u32 num_normal_params = 0;
+	int rc;
+
 	if (!ctx->teedev->desc->ops->open_session)
 		return -EINVAL;
-	return ctx->teedev->desc->ops->open_session(ctx, arg, param);
+
+	rc = find_ocall_param(param, arg->num_params, &normal_params,
+			      &num_normal_params, &ocall_param);
+	if (rc)
+		return rc;
+
+	return ctx->teedev->desc->ops->open_session(ctx, arg, normal_params,
+						    num_normal_params,
+						    ocall_param);
 }
 EXPORT_SYMBOL_GPL(tee_client_open_session);
 
@@ -1177,9 +1229,22 @@ int tee_client_invoke_func(struct tee_context *ctx,
 			   struct tee_ioctl_invoke_arg *arg,
 			   struct tee_param *param)
 {
+	struct tee_param *ocall_param = NULL;
+	struct tee_param *normal_params = NULL;
+	u32 num_normal_params = 0;
+	int rc;
+
 	if (!ctx->teedev->desc->ops->invoke_func)
 		return -EINVAL;
-	return ctx->teedev->desc->ops->invoke_func(ctx, arg, param);
+
+	rc = find_ocall_param(param, arg->num_params, &normal_params,
+			      &num_normal_params, &ocall_param);
+	if (rc)
+		return rc;
+
+	return ctx->teedev->desc->ops->invoke_func(ctx, arg, normal_params,
+						   num_normal_params,
+						   ocall_param);
 }
 EXPORT_SYMBOL_GPL(tee_client_invoke_func);
 
diff --git a/drivers/tee/tee_shm.c b/drivers/tee/tee_shm.c
index 6e662fb13..94282f2bb 100644
--- a/drivers/tee/tee_shm.c
+++ b/drivers/tee/tee_shm.c
@@ -157,7 +157,8 @@ struct tee_shm *tee_shm_register(struct tee_context *ctx, unsigned long addr,
 	int num_pages;
 	unsigned long start;
 
-	if (flags != req_user_flags && flags != req_kernel_flags)
+	if (((flags & req_user_flags) != req_user_flags) &&
+	    ((flags & req_kernel_flags) != req_kernel_flags))
 		return ERR_PTR(-ENOTSUPP);
 
 	if (!tee_device_get(teedev))
@@ -434,6 +435,16 @@ struct tee_shm *tee_shm_get_from_id(struct tee_context *ctx, int id)
 }
 EXPORT_SYMBOL_GPL(tee_shm_get_from_id);
 
+/**
+ * tee_shm_get() - Increase reference count on a shared memory handle
+ * @shm:	Shared memory handle
+ */
+void tee_shm_get(struct tee_shm *shm)
+{
+	refcount_inc(&shm->refcount);
+}
+EXPORT_SYMBOL_GPL(tee_shm_get);
+
 /**
  * tee_shm_put() - Decrease reference count on a shared memory handle
  * @shm:	Shared memory handle
diff --git a/drivers/thermal/st/stm_thermal.c b/drivers/thermal/st/stm_thermal.c
index 5fd3fb891..1e065a332 100644
--- a/drivers/thermal/st/stm_thermal.c
+++ b/drivers/thermal/st/stm_thermal.c
@@ -82,8 +82,7 @@
 #define ONE_MHZ			1000000
 #define POLL_TIMEOUT		5000
 #define STARTUP_TIME		40
-#define TS1_T0_VAL0		30000  /* 30 celsius */
-#define TS1_T0_VAL1		130000 /* 130 celsius */
+#define T0			30000  /* 30 celsius */
 #define NO_HW_TRIG		0
 #define SAMPLING_TIME		15
 
@@ -96,7 +95,7 @@ struct stm_thermal_sensor {
 	unsigned int high_temp_enabled;
 	int irq;
 	void __iomem *base;
-	int t0, fmt0, ramp_coeff;
+	int fmt0, ramp_coeff;
 };
 
 static int stm_enable_irq(struct stm_thermal_sensor *sensor)
@@ -243,14 +242,6 @@ static int stm_thermal_calibration(struct stm_thermal_sensor *sensor)
 /* Fill in DTS structure with factory sensor values */
 static int stm_thermal_read_factory_settings(struct stm_thermal_sensor *sensor)
 {
-	/* Retrieve engineering calibration temperature */
-	sensor->t0 = readl_relaxed(sensor->base + DTS_T0VALR1_OFFSET) &
-					TS1_T0_MASK;
-	if (!sensor->t0)
-		sensor->t0 = TS1_T0_VAL0;
-	else
-		sensor->t0 = TS1_T0_VAL1;
-
 	/* Retrieve fmt0 and put it on Hz */
 	sensor->fmt0 = ADJUST * (readl_relaxed(sensor->base +
 				 DTS_T0VALR1_OFFSET) & TS1_FMT0_MASK);
@@ -264,8 +255,8 @@ static int stm_thermal_read_factory_settings(struct stm_thermal_sensor *sensor)
 		return -EINVAL;
 	}
 
-	dev_dbg(sensor->dev, "%s: T0 = %doC, FMT0 = %dHz, RAMP_COEFF = %dHz/oC",
-		__func__, sensor->t0, sensor->fmt0, sensor->ramp_coeff);
+	dev_dbg(sensor->dev, "%s: FMT0 = %dHz, RAMP_COEFF = %dHz/oC",
+		__func__, sensor->fmt0, sensor->ramp_coeff);
 
 	return 0;
 }
@@ -276,8 +267,7 @@ static int stm_thermal_calculate_threshold(struct stm_thermal_sensor *sensor,
 	int freqM;
 
 	/* Figure out the CLK_PTAT frequency for a given temperature */
-	freqM = ((temp - sensor->t0) * sensor->ramp_coeff) / 1000 +
-		sensor->fmt0;
+	freqM = ((temp - T0) * sensor->ramp_coeff) / 1000 + sensor->fmt0;
 
 	/* Figure out the threshold sample number */
 	*th = clk_get_rate(sensor->clk) * SAMPLING_TIME / freqM;
@@ -372,7 +362,7 @@ static int stm_thermal_get_temp(void *data, int *temp)
 		return -EINVAL;
 
 	/* Figure out the temperature in mili celsius */
-	*temp = (freqM - sensor->fmt0) * 1000 / sensor->ramp_coeff + sensor->t0;
+	*temp = (freqM - sensor->fmt0) * 1000 / sensor->ramp_coeff + T0;
 
 	return 0;
 }
@@ -515,11 +505,9 @@ static int stm_thermal_probe(struct platform_device *pdev)
 	sensor->base = base;
 
 	sensor->clk = devm_clk_get(&pdev->dev, "pclk");
-	if (IS_ERR(sensor->clk)) {
-		dev_err(&pdev->dev, "%s: failed to fetch PCLK clock\n",
-			__func__);
-		return PTR_ERR(sensor->clk);
-	}
+	if (IS_ERR(sensor->clk))
+		return dev_err_probe(&pdev->dev, PTR_ERR(sensor->clk),
+				     "Failed to get PCLK clock\n");
 
 	stm_disable_irq(sensor);
 
diff --git a/drivers/tty/Kconfig b/drivers/tty/Kconfig
index 23cc988c6..cc30ff93e 100644
--- a/drivers/tty/Kconfig
+++ b/drivers/tty/Kconfig
@@ -368,6 +368,18 @@ config VCC
 
 source "drivers/tty/hvc/Kconfig"
 
+config RPMSG_TTY
+	tristate "RPMSG tty driver"
+	depends on RPMSG
+	help
+	  Say y here to export rpmsg endpoints as tty devices, usually found
+	  in /dev/ttyRPMSGx.
+	  This makes it possible for user-space programs to send and receive
+	  rpmsg messages as a standard tty protocol.
+
+	  To compile this driver as a module, choose M here: the module will be
+	  called rpmsg_tty.
+
 endif # TTY
 
 source "drivers/tty/serdev/Kconfig"
diff --git a/drivers/tty/Makefile b/drivers/tty/Makefile
index a2bd75fba..07aca5184 100644
--- a/drivers/tty/Makefile
+++ b/drivers/tty/Makefile
@@ -26,5 +26,6 @@ obj-$(CONFIG_PPC_EPAPR_HV_BYTECHAN) += ehv_bytechan.o
 obj-$(CONFIG_GOLDFISH_TTY)	+= goldfish.o
 obj-$(CONFIG_MIPS_EJTAG_FDC_TTY) += mips_ejtag_fdc.o
 obj-$(CONFIG_VCC)		+= vcc.o
+obj-$(CONFIG_RPMSG_TTY)		+= rpmsg_tty.o
 
 obj-y += ipwireless/
diff --git a/drivers/tty/rpmsg_tty.c b/drivers/tty/rpmsg_tty.c
new file mode 100644
index 000000000..29db413bb
--- /dev/null
+++ b/drivers/tty/rpmsg_tty.c
@@ -0,0 +1,287 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 STMicroelectronics - All Rights Reserved
+ *
+ * The rpmsg tty driver implements serial communication on the RPMsg bus to makes
+ * possible for user-space programs to send and receive rpmsg messages as a standard
+ * tty protocol.
+ *
+ * The remote processor can instantiate a new tty by requesting a "rpmsg-tty" RPMsg service.
+ * The "rpmsg-tty" service is directly used for data exchange. No flow control is implemented yet.
+ */
+
+#define pr_fmt(fmt)		KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/rpmsg.h>
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+
+#define RPMSG_TTY_NAME	"ttyRPMSG"
+#define MAX_TTY_RPMSG	32
+
+static DEFINE_IDR(tty_idr);	/* tty instance id */
+static DEFINE_MUTEX(idr_lock);	/* protects tty_idr */
+
+static struct tty_driver *rpmsg_tty_driver;
+
+struct rpmsg_tty_port {
+	struct tty_port		port;	 /* TTY port data */
+	int			id;	 /* TTY rpmsg index */
+	struct rpmsg_device	*rpdev;	 /* rpmsg device */
+};
+
+static int rpmsg_tty_cb(struct rpmsg_device *rpdev, void *data, int len, void *priv, u32 src)
+{
+	struct rpmsg_tty_port *cport = dev_get_drvdata(&rpdev->dev);
+	int copied;
+
+	if (!len)
+		return -EINVAL;
+	copied = tty_insert_flip_string(&cport->port, data, len);
+	if (copied != len)
+		dev_err_ratelimited(&rpdev->dev, "Trunc buffer: available space is %d\n", copied);
+	tty_flip_buffer_push(&cport->port);
+
+	return 0;
+}
+
+static int rpmsg_tty_install(struct tty_driver *driver, struct tty_struct *tty)
+{
+	struct rpmsg_tty_port *cport = idr_find(&tty_idr, tty->index);
+	struct tty_port *port;
+
+	tty->driver_data = cport;
+
+	port = tty_port_get(&cport->port);
+	return tty_port_install(port, driver, tty);
+}
+
+static void rpmsg_tty_cleanup(struct tty_struct *tty)
+{
+	tty_port_put(tty->port);
+}
+
+static int rpmsg_tty_open(struct tty_struct *tty, struct file *filp)
+{
+	return tty_port_open(tty->port, tty, filp);
+}
+
+static void rpmsg_tty_close(struct tty_struct *tty, struct file *filp)
+{
+	return tty_port_close(tty->port, tty, filp);
+}
+
+static int rpmsg_tty_write(struct tty_struct *tty, const u8 *buf, int len)
+{
+	struct rpmsg_tty_port *cport = tty->driver_data;
+	struct rpmsg_device *rpdev;
+	int msg_max_size, msg_size;
+	int ret;
+
+	rpdev = cport->rpdev;
+
+	msg_max_size = rpmsg_get_mtu(rpdev->ept);
+	if (msg_max_size < 0)
+		return msg_max_size;
+
+	msg_size = min(len, msg_max_size);
+
+	/*
+	 * Use rpmsg_trysend instead of rpmsg_send to send the message so the caller is not
+	 * hung until a rpmsg buffer is available. In such case rpmsg_trysend returns -ENOMEM.
+	 */
+	ret = rpmsg_trysend(rpdev->ept, (void *)buf, msg_size);
+	if (ret) {
+		dev_dbg_ratelimited(&rpdev->dev, "rpmsg_send failed: %d\n", ret);
+		return ret;
+	}
+
+	return msg_size;
+}
+
+static unsigned int rpmsg_tty_write_room(struct tty_struct *tty)
+{
+	struct rpmsg_tty_port *cport = tty->driver_data;
+	int size;
+
+	size = rpmsg_get_mtu(cport->rpdev->ept);
+	if (size < 0)
+		return 0;
+
+	return size;
+}
+
+static void rpmsg_tty_hangup(struct tty_struct *tty)
+{
+	tty_port_hangup(tty->port);
+}
+
+static const struct tty_operations rpmsg_tty_ops = {
+	.install	= rpmsg_tty_install,
+	.open		= rpmsg_tty_open,
+	.close		= rpmsg_tty_close,
+	.write		= rpmsg_tty_write,
+	.write_room	= rpmsg_tty_write_room,
+	.hangup		= rpmsg_tty_hangup,
+	.cleanup	= rpmsg_tty_cleanup,
+};
+
+static struct rpmsg_tty_port *rpmsg_tty_alloc_cport(void)
+{
+	struct rpmsg_tty_port *cport;
+	int ret;
+
+	cport = kzalloc(sizeof(*cport), GFP_KERNEL);
+	if (!cport)
+		return ERR_PTR(-ENOMEM);
+
+	mutex_lock(&idr_lock);
+	ret = idr_alloc(&tty_idr, cport, 0, MAX_TTY_RPMSG, GFP_KERNEL);
+	mutex_unlock(&idr_lock);
+
+	if (ret < 0) {
+		kfree(cport);
+		return ERR_PTR(ret);
+	}
+
+	cport->id = ret;
+
+	return cport;
+}
+
+static void rpmsg_tty_destruct_port(struct tty_port *port)
+{
+	struct rpmsg_tty_port *cport = container_of(port, struct rpmsg_tty_port, port);
+
+	mutex_lock(&idr_lock);
+	idr_remove(&tty_idr, cport->id);
+	mutex_unlock(&idr_lock);
+
+	kfree(cport);
+}
+
+static const struct tty_port_operations rpmsg_tty_port_ops = {
+	.destruct = rpmsg_tty_destruct_port,
+};
+
+
+static int rpmsg_tty_probe(struct rpmsg_device *rpdev)
+{
+	struct rpmsg_tty_port *cport;
+	struct device *dev = &rpdev->dev;
+	struct device *tty_dev;
+	int ret;
+
+	cport = rpmsg_tty_alloc_cport();
+	if (IS_ERR(cport))
+		return dev_err_probe(dev, PTR_ERR(cport), "Failed to alloc tty port\n");
+
+	tty_port_init(&cport->port);
+	cport->port.ops = &rpmsg_tty_port_ops;
+
+	tty_dev = tty_port_register_device(&cport->port, rpmsg_tty_driver,
+					   cport->id, dev);
+	if (IS_ERR(tty_dev)) {
+		ret = dev_err_probe(dev, PTR_ERR(tty_dev), "Failed to register tty port\n");
+		tty_port_put(&cport->port);
+		return ret;
+	}
+
+	cport->rpdev = rpdev;
+
+	dev_set_drvdata(dev, cport);
+
+	dev_dbg(dev, "New channel: 0x%x -> 0x%x: " RPMSG_TTY_NAME "%d\n",
+		rpdev->src, rpdev->dst, cport->id);
+
+	return 0;
+}
+
+static void rpmsg_tty_remove(struct rpmsg_device *rpdev)
+{
+	struct rpmsg_tty_port *cport = dev_get_drvdata(&rpdev->dev);
+
+	dev_dbg(&rpdev->dev, "Removing rpmsg tty device %d\n", cport->id);
+
+	/* User hang up to release the tty */
+	tty_port_tty_hangup(&cport->port, false);
+
+	tty_unregister_device(rpmsg_tty_driver, cport->id);
+
+	tty_port_put(&cport->port);
+}
+
+static struct rpmsg_device_id rpmsg_driver_tty_id_table[] = {
+	{ .name	= "rpmsg-tty" },
+	{ },
+};
+MODULE_DEVICE_TABLE(rpmsg, rpmsg_driver_tty_id_table);
+
+static struct rpmsg_driver rpmsg_tty_rpmsg_drv = {
+	.drv.name	= KBUILD_MODNAME,
+	.id_table	= rpmsg_driver_tty_id_table,
+	.probe		= rpmsg_tty_probe,
+	.callback	= rpmsg_tty_cb,
+	.remove		= rpmsg_tty_remove,
+};
+
+static int __init rpmsg_tty_init(void)
+{
+	int ret;
+
+	rpmsg_tty_driver = tty_alloc_driver(MAX_TTY_RPMSG, TTY_DRIVER_REAL_RAW |
+					    TTY_DRIVER_DYNAMIC_DEV);
+	if (IS_ERR(rpmsg_tty_driver))
+		return PTR_ERR(rpmsg_tty_driver);
+
+	rpmsg_tty_driver->driver_name = "rpmsg_tty";
+	rpmsg_tty_driver->name = RPMSG_TTY_NAME;
+	rpmsg_tty_driver->major = 0;
+	rpmsg_tty_driver->type = TTY_DRIVER_TYPE_CONSOLE;
+
+	/* Disable unused mode by default */
+	rpmsg_tty_driver->init_termios = tty_std_termios;
+	rpmsg_tty_driver->init_termios.c_lflag &= ~(ECHO | ICANON);
+	rpmsg_tty_driver->init_termios.c_oflag &= ~(OPOST | ONLCR);
+
+	tty_set_operations(rpmsg_tty_driver, &rpmsg_tty_ops);
+
+	ret = tty_register_driver(rpmsg_tty_driver);
+	if (ret < 0) {
+		pr_err("Couldn't install driver: %d\n", ret);
+		goto error_put;
+	}
+
+	ret = register_rpmsg_driver(&rpmsg_tty_rpmsg_drv);
+	if (ret < 0) {
+		pr_err("Couldn't register driver: %d\n", ret);
+		goto error_unregister;
+	}
+
+	return 0;
+
+error_unregister:
+	tty_unregister_driver(rpmsg_tty_driver);
+
+error_put:
+	tty_driver_kref_put(rpmsg_tty_driver);
+
+	return ret;
+}
+
+static void __exit rpmsg_tty_exit(void)
+{
+	unregister_rpmsg_driver(&rpmsg_tty_rpmsg_drv);
+	tty_unregister_driver(rpmsg_tty_driver);
+	tty_driver_kref_put(rpmsg_tty_driver);
+	idr_destroy(&tty_idr);
+}
+
+module_init(rpmsg_tty_init);
+module_exit(rpmsg_tty_exit);
+
+MODULE_AUTHOR("Arnaud Pouliquen <arnaud.pouliquen@foss.st.com>");
+MODULE_DESCRIPTION("remote processor messaging tty driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index 131a6a587..a1dea5888 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -1440,6 +1440,7 @@ config SERIAL_STM32_CONSOLE
 	bool "Support for console on STM32"
 	depends on SERIAL_STM32=y
 	select SERIAL_CORE_CONSOLE
+	select SERIAL_EARLYCON
 
 config SERIAL_MVEBU_UART
 	bool "Marvell EBU serial port support"
diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index 82ddbb92d..596e76f49 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -3237,6 +3237,16 @@ int uart_get_rs485_mode(struct uart_port *port)
 	u32 rs485_delay[2];
 	int ret;
 
+	ret = device_property_read_u32_array(dev, "rs485-rts-delay-ns",
+					     rs485_delay, 2);
+	if (!ret) {
+		rs485conf->delay_rts_before_send_ns = rs485_delay[0];
+		rs485conf->delay_rts_after_send_ns = rs485_delay[1];
+	} else {
+		rs485conf->delay_rts_before_send_ns = 0;
+		rs485conf->delay_rts_after_send_ns = 0;
+	}
+
 	ret = device_property_read_u32_array(dev, "rs485-rts-delay",
 					     rs485_delay, 2);
 	if (!ret) {
diff --git a/drivers/tty/serial/serial_mctrl_gpio.c b/drivers/tty/serial/serial_mctrl_gpio.c
index c41d8911c..1663b3afc 100644
--- a/drivers/tty/serial/serial_mctrl_gpio.c
+++ b/drivers/tty/serial/serial_mctrl_gpio.c
@@ -299,4 +299,42 @@ void mctrl_gpio_disable_ms(struct mctrl_gpios *gpios)
 }
 EXPORT_SYMBOL_GPL(mctrl_gpio_disable_ms);
 
+void mctrl_gpio_enable_irq_wake(struct mctrl_gpios *gpios)
+{
+	enum mctrl_gpio_idx i;
+
+	if (!gpios)
+		return;
+
+	if (!gpios->mctrl_on)
+		return;
+
+	for (i = 0; i < UART_GPIO_MAX; ++i) {
+		if (!gpios->irq[i])
+			continue;
+
+		enable_irq_wake(gpios->irq[i]);
+	}
+}
+EXPORT_SYMBOL_GPL(mctrl_gpio_enable_irq_wake);
+
+void mctrl_gpio_disable_irq_wake(struct mctrl_gpios *gpios)
+{
+	enum mctrl_gpio_idx i;
+
+	if (!gpios)
+		return;
+
+	if (!gpios->mctrl_on)
+		return;
+
+	for (i = 0; i < UART_GPIO_MAX; ++i) {
+		if (!gpios->irq[i])
+			continue;
+
+		disable_irq_wake(gpios->irq[i]);
+	}
+}
+EXPORT_SYMBOL_GPL(mctrl_gpio_disable_irq_wake);
+
 MODULE_LICENSE("GPL");
diff --git a/drivers/tty/serial/serial_mctrl_gpio.h b/drivers/tty/serial/serial_mctrl_gpio.h
index b134a0ffc..fc76910fb 100644
--- a/drivers/tty/serial/serial_mctrl_gpio.h
+++ b/drivers/tty/serial/serial_mctrl_gpio.h
@@ -91,6 +91,16 @@ void mctrl_gpio_enable_ms(struct mctrl_gpios *gpios);
  */
 void mctrl_gpio_disable_ms(struct mctrl_gpios *gpios);
 
+/*
+ * Enable gpio wakeup interrupts to enable wake up source.
+ */
+void mctrl_gpio_enable_irq_wake(struct mctrl_gpios *gpios);
+
+/*
+ * Disable gpio wakeup interrupts to enable wake up source.
+ */
+void mctrl_gpio_disable_irq_wake(struct mctrl_gpios *gpios);
+
 #else /* GPIOLIB */
 
 static inline
@@ -142,6 +152,14 @@ static inline void mctrl_gpio_disable_ms(struct mctrl_gpios *gpios)
 {
 }
 
+static inline void mctrl_gpio_enable_irq_wake(struct mctrl_gpios *gpios)
+{
+}
+
+static inline void mctrl_gpio_disable_irq_wake(struct mctrl_gpios *gpios)
+{
+}
+
 #endif /* GPIOLIB */
 
 #endif
diff --git a/drivers/tty/serial/stm32-usart.c b/drivers/tty/serial/stm32-usart.c
index fc166cc2c..4d7a31664 100644
--- a/drivers/tty/serial/stm32-usart.c
+++ b/drivers/tty/serial/stm32-usart.c
@@ -61,40 +61,67 @@ static void stm32_usart_clr_bits(struct uart_port *port, u32 reg, u32 bits)
 	writel_relaxed(val, port->membase + reg);
 }
 
-static void stm32_usart_config_reg_rs485(u32 *cr1, u32 *cr3, u32 delay_ADE,
-					 u32 delay_DDE, u32 baud)
+static u32 stm32_usart_config_delay_rs485(u32 *cr1, u32 delay, u32 baud,
+					  bool over8, u32 rs485_deat_dedt_max,
+					  struct serial_rs485 *rs485conf)
 {
-	u32 rs485_deat_dedt;
+	u64 tmp;
+
+	/*
+	 * Compute (de)assertion time by using the delay (in ns), the baud rate
+	 * (in bits/s) and the oversampling (in 1/8 or 1/16 bit)
+	 */
+	tmp = (u64)delay * (u64)baud * 8ULL;
+
+	/* Handle oversampling 16 */
+	if (!over8)
+		tmp = tmp * 2ULL;
+
+	tmp = DIV_ROUND_CLOSEST_ULL(tmp, NSEC_PER_SEC);
+
+	/* Set delay to max value if result is higher than max value */
+	tmp = tmp > rs485_deat_dedt_max ? rs485_deat_dedt_max : tmp;
+
+	return tmp;
+}
+
+static void stm32_usart_config_reg_rs485(u32 *cr1, u32 *cr3,  u32 baud,
+					 struct serial_rs485 *rs485conf)
+{
+	u32 delay_ADE, delay_DDE, rs485_deat_dedt;
 	u32 rs485_deat_dedt_max = (USART_CR1_DEAT_MASK >> USART_CR1_DEAT_SHIFT);
 	bool over8;
+	u32 tmp;
+
+	/*
+	 * Assertion and deassertion delays (in ns) are computed by the
+	 * selection of rs485-rts-delay-ns (in ns) or rs485-rts-delay (in ms)
+	 * provided by device tree
+	 */
+	if (rs485conf->delay_rts_before_send_ns != 0 ||
+	    rs485conf->delay_rts_after_send_ns != 0) {
+		delay_ADE = rs485conf->delay_rts_before_send_ns;
+		delay_DDE = rs485conf->delay_rts_after_send_ns;
+	} else {
+		delay_ADE = rs485conf->delay_rts_before_send * NSEC_PER_MSEC;
+		delay_DDE = rs485conf->delay_rts_after_send * NSEC_PER_MSEC;
+	}
 
 	*cr3 |= USART_CR3_DEM;
 	over8 = *cr1 & USART_CR1_OVER8;
 
 	*cr1 &= ~(USART_CR1_DEDT_MASK | USART_CR1_DEAT_MASK);
 
-	if (over8)
-		rs485_deat_dedt = delay_ADE * baud * 8;
-	else
-		rs485_deat_dedt = delay_ADE * baud * 16;
-
-	rs485_deat_dedt = DIV_ROUND_CLOSEST(rs485_deat_dedt, 1000);
-	rs485_deat_dedt = rs485_deat_dedt > rs485_deat_dedt_max ?
-			  rs485_deat_dedt_max : rs485_deat_dedt;
-	rs485_deat_dedt = (rs485_deat_dedt << USART_CR1_DEAT_SHIFT) &
-			   USART_CR1_DEAT_MASK;
+	/* Assertion time */
+	tmp = stm32_usart_config_delay_rs485(cr1, delay_ADE, baud, over8,
+					     rs485_deat_dedt_max, rs485conf);
+	rs485_deat_dedt = (tmp << USART_CR1_DEAT_SHIFT) & USART_CR1_DEAT_MASK;
 	*cr1 |= rs485_deat_dedt;
 
-	if (over8)
-		rs485_deat_dedt = delay_DDE * baud * 8;
-	else
-		rs485_deat_dedt = delay_DDE * baud * 16;
-
-	rs485_deat_dedt = DIV_ROUND_CLOSEST(rs485_deat_dedt, 1000);
-	rs485_deat_dedt = rs485_deat_dedt > rs485_deat_dedt_max ?
-			  rs485_deat_dedt_max : rs485_deat_dedt;
-	rs485_deat_dedt = (rs485_deat_dedt << USART_CR1_DEDT_SHIFT) &
-			   USART_CR1_DEDT_MASK;
+	/* Deassertion time */
+	tmp = stm32_usart_config_delay_rs485(cr1, delay_DDE, baud, over8,
+					     rs485_deat_dedt_max, rs485conf);
+	rs485_deat_dedt = (tmp << USART_CR1_DEDT_SHIFT) & USART_CR1_DEDT_MASK;
 	*cr1 |= rs485_deat_dedt;
 }
 
@@ -125,10 +152,7 @@ static int stm32_usart_config_rs485(struct uart_port *port,
 				   << USART_BRR_04_R_SHIFT;
 
 		baud = DIV_ROUND_CLOSEST(port->uartclk, usartdiv);
-		stm32_usart_config_reg_rs485(&cr1, &cr3,
-					     rs485conf->delay_rts_before_send,
-					     rs485conf->delay_rts_after_send,
-					     baud);
+		stm32_usart_config_reg_rs485(&cr1, &cr3, baud, rs485conf);
 
 		if (rs485conf->flags & SER_RS485_RTS_ON_SEND) {
 			cr3 &= ~USART_CR3_DEP;
@@ -167,63 +191,103 @@ static int stm32_usart_init_rs485(struct uart_port *port,
 	return uart_get_rs485_mode(port);
 }
 
-static int stm32_usart_pending_rx(struct uart_port *port, u32 *sr,
-				  int *last_res, bool threaded)
+static bool stm32_usart_rx_dma_started(struct stm32_port *stm32_port)
+{
+	return stm32_port->rx_ch ? stm32_port->rx_dma_busy : false;
+}
+
+static void stm32_usart_rx_dma_terminate(struct stm32_port *stm32_port)
+{
+	dmaengine_terminate_async(stm32_port->rx_ch);
+	stm32_port->rx_dma_busy = false;
+}
+
+static int stm32_usart_dma_pause_resume(struct stm32_port *stm32_port,
+					struct dma_chan *chan,
+					enum dma_status expected_status,
+					int (*dma_action)(struct dma_chan *chan),
+					bool (*dma_started)(struct stm32_port *stm32_port),
+					void (*dma_terminate)(struct stm32_port *stm32_port))
+{
+	struct uart_port *port = &stm32_port->port;
+	enum dma_status dma_status;
+	int ret;
+
+	if (!(*dma_started)(stm32_port))
+		return -EPERM;
+
+	dma_status = dmaengine_tx_status(chan, chan->cookie, NULL);
+	if (dma_status != expected_status)
+		return -EAGAIN;
+
+	ret = (*dma_action)(chan);
+	if (ret) {
+		dev_err(port->dev, "DMA failed with error code: %d\n", ret);
+		(*dma_terminate)(stm32_port);
+	}
+	return ret;
+}
+
+static int stm32_usart_rx_dma_pause(struct stm32_port *stm32_port)
+{
+	return stm32_usart_dma_pause_resume(stm32_port, stm32_port->rx_ch,
+					    DMA_IN_PROGRESS, dmaengine_pause,
+					    stm32_usart_rx_dma_started,
+					    stm32_usart_rx_dma_terminate);
+}
+
+static int stm32_usart_rx_dma_resume(struct stm32_port *stm32_port)
+{
+	return stm32_usart_dma_pause_resume(stm32_port, stm32_port->rx_ch,
+					    DMA_PAUSED, dmaengine_resume,
+					    stm32_usart_rx_dma_started,
+					    stm32_usart_rx_dma_terminate);
+}
+
+/* Return true when data is pending (in pio mode), and false when no data is pending. */
+static bool stm32_usart_pending_rx_pio(struct uart_port *port, u32 *sr)
 {
 	struct stm32_port *stm32_port = to_stm32_port(port);
 	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
-	enum dma_status status;
-	struct dma_tx_state state;
 
 	*sr = readl_relaxed(port->membase + ofs->isr);
-
-	if (threaded && stm32_port->rx_ch) {
-		status = dmaengine_tx_status(stm32_port->rx_ch,
-					     stm32_port->rx_ch->cookie,
-					     &state);
-		if (status == DMA_IN_PROGRESS && (*last_res != state.residue))
-			return 1;
-		else
-			return 0;
-	} else if (*sr & USART_SR_RXNE) {
-		return 1;
+	/* Get pending characters in RDR or FIFO */
+	if (*sr & USART_SR_RXNE) {
+		/* Get all pending characters from the RDR or the FIFO when using interrupts */
+		if (!stm32_usart_rx_dma_started(stm32_port))
+			return true;
+
+		/* Handle only RX data errors when using DMA */
+		if (*sr & USART_SR_ERR_MASK)
+			return true;
 	}
-	return 0;
+
+	return false;
 }
 
-static unsigned long stm32_usart_get_char(struct uart_port *port, u32 *sr,
-					  int *last_res)
+static unsigned long stm32_usart_get_char_pio(struct uart_port *port)
 {
 	struct stm32_port *stm32_port = to_stm32_port(port);
 	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
 	unsigned long c;
 
-	if (stm32_port->rx_ch) {
-		c = stm32_port->rx_buf[RX_BUF_L - (*last_res)--];
-		if ((*last_res) == 0)
-			*last_res = RX_BUF_L;
-	} else {
-		c = readl_relaxed(port->membase + ofs->rdr);
-		/* apply RDR data mask */
-		c &= stm32_port->rdr_mask;
-	}
+	c = readl_relaxed(port->membase + ofs->rdr);
+	/* Apply RDR data mask */
+	c &= stm32_port->rdr_mask;
 
 	return c;
 }
 
-static void stm32_usart_receive_chars(struct uart_port *port, bool threaded)
+static unsigned int stm32_usart_receive_chars_pio(struct uart_port *port)
 {
-	struct tty_port *tport = &port->state->port;
 	struct stm32_port *stm32_port = to_stm32_port(port);
 	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
 	unsigned long c;
+	unsigned int size = 0;
 	u32 sr;
 	char flag;
 
-	spin_lock(&port->lock);
-
-	while (stm32_usart_pending_rx(port, &sr, &stm32_port->last_res,
-				      threaded)) {
+	while (stm32_usart_pending_rx_pio(port, &sr)) {
 		sr |= USART_SR_DUMMY_RX;
 		flag = TTY_NORMAL;
 
@@ -242,8 +306,9 @@ static void stm32_usart_receive_chars(struct uart_port *port, bool threaded)
 			writel_relaxed(sr & USART_SR_ERR_MASK,
 				       port->membase + ofs->icr);
 
-		c = stm32_usart_get_char(port, &sr, &stm32_port->last_res);
+		c = stm32_usart_get_char_pio(port);
 		port->icount.rx++;
+		size++;
 		if (sr & USART_SR_ERR_MASK) {
 			if (sr & USART_SR_ORE) {
 				port->icount.overrun++;
@@ -277,21 +342,208 @@ static void stm32_usart_receive_chars(struct uart_port *port, bool threaded)
 		uart_insert_char(port, sr, USART_SR_ORE, c, flag);
 	}
 
-	uart_unlock_and_check_sysrq(port);
+	return size;
+}
+
+static void stm32_usart_push_buffer_dma(struct uart_port *port, unsigned int dma_size)
+{
+	struct stm32_port *stm32_port = to_stm32_port(port);
+	struct tty_port *ttyport = &stm32_port->port.state->port;
+	unsigned char *dma_start;
+	int dma_count, i;
+
+	dma_start = stm32_port->rx_buf + (RX_BUF_L - stm32_port->last_res);
+
+	/*
+	 * Apply rdr_mask on buffer in order to mask parity bit.
+	 * This loop is useless in cs8 mode because DMA copies only
+	 * 8 bits and already ignores parity bit.
+	 */
+	if (!(stm32_port->rdr_mask == (BIT(8) - 1)))
+		for (i = 0; i < dma_size; i++)
+			*(dma_start + i) &= stm32_port->rdr_mask;
+
+	dma_count = tty_insert_flip_string(ttyport, dma_start, dma_size);
+	port->icount.rx += dma_count;
+	if (dma_count != dma_size)
+		port->icount.buf_overrun++;
+	stm32_port->last_res -= dma_count;
+	if (stm32_port->last_res == 0)
+		stm32_port->last_res = RX_BUF_L;
+}
+
+static unsigned int stm32_usart_receive_chars_dma(struct uart_port *port)
+{
+	struct stm32_port *stm32_port = to_stm32_port(port);
+	unsigned int dma_size, size = 0;
+
+	/* DMA buffer is configured in cyclic mode and handles the rollback of the buffer. */
+	if (stm32_port->rx_dma_state.residue > stm32_port->last_res) {
+		/* Conditional first part: from last_res to end of DMA buffer */
+		dma_size = stm32_port->last_res;
+		stm32_usart_push_buffer_dma(port, dma_size);
+		size = dma_size;
+	}
+
+	dma_size = stm32_port->last_res - stm32_port->rx_dma_state.residue;
+	stm32_usart_push_buffer_dma(port, dma_size);
+	size += dma_size;
+
+	return size;
+}
+
+static unsigned int stm32_usart_receive_chars(struct uart_port *port, bool force_dma_flush)
+{
+	struct stm32_port *stm32_port = to_stm32_port(port);
+	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
+	enum dma_status rx_dma_status;
+	u32 sr;
+	unsigned int size = 0;
+
+	if (stm32_usart_rx_dma_started(stm32_port) || force_dma_flush) {
+		rx_dma_status = dmaengine_tx_status(stm32_port->rx_ch,
+						    stm32_port->rx_ch->cookie,
+						    &stm32_port->rx_dma_state);
+		if (rx_dma_status == DMA_IN_PROGRESS ||
+		    rx_dma_status == DMA_PAUSED) {
+			/* Empty DMA buffer */
+			size = stm32_usart_receive_chars_dma(port);
+			sr = readl_relaxed(port->membase + ofs->isr);
+			if (sr & USART_SR_ERR_MASK) {
+				/* Disable DMA request line */
+				stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAR);
+
+				/* Switch to PIO mode to handle the errors */
+				size += stm32_usart_receive_chars_pio(port);
+
+				/* Switch back to DMA mode */
+				stm32_usart_set_bits(port, ofs->cr3, USART_CR3_DMAR);
+			}
+		} else {
+			/* Disable RX DMA */
+			stm32_usart_rx_dma_terminate(stm32_port);
+			/* Fall back to interrupt mode */
+			dev_dbg(port->dev, "DMA error, fallback to irq mode\n");
+			size = stm32_usart_receive_chars_pio(port);
+		}
+	} else {
+		size = stm32_usart_receive_chars_pio(port);
+	}
+
+	return size;
+}
+
+static void stm32_usart_rx_dma_complete(void *arg)
+{
+	struct uart_port *port = arg;
+	struct tty_port *tport = &port->state->port;
+	unsigned int size;
+	unsigned long flags;
 
-	tty_flip_buffer_push(tport);
+	spin_lock_irqsave(&port->lock, flags);
+	size = stm32_usart_receive_chars(port, false);
+	uart_unlock_and_check_sysrq_irqrestore(port, flags);
+	if (size)
+		tty_flip_buffer_push(tport);
+}
+
+static int stm32_usart_rx_dma_start_or_resume(struct uart_port *port)
+{
+	struct stm32_port *stm32_port = to_stm32_port(port);
+	struct dma_async_tx_descriptor *desc;
+	enum dma_status rx_dma_status;
+	int ret;
+
+	if (stm32_port->throttled)
+		return 0;
+
+	if (stm32_port->rx_dma_busy) {
+		rx_dma_status = dmaengine_tx_status(stm32_port->rx_ch,
+						    stm32_port->rx_ch->cookie,
+						    NULL);
+		if (rx_dma_status == DMA_IN_PROGRESS)
+			return 0;
+
+		if (rx_dma_status == DMA_PAUSED && !stm32_usart_rx_dma_resume(stm32_port))
+			return 0;
+
+		dev_err(port->dev, "DMA failed : status error.\n");
+		stm32_usart_rx_dma_terminate(stm32_port);
+	}
+
+	stm32_port->rx_dma_busy = true;
+
+	stm32_port->last_res = RX_BUF_L;
+	/* Prepare a DMA cyclic transaction */
+	desc = dmaengine_prep_dma_cyclic(stm32_port->rx_ch,
+					 stm32_port->rx_dma_buf,
+					 RX_BUF_L, RX_BUF_P,
+					 DMA_DEV_TO_MEM,
+					 DMA_PREP_INTERRUPT);
+	if (!desc) {
+		dev_err(port->dev, "rx dma prep cyclic failed\n");
+		stm32_port->rx_dma_busy = false;
+		return -ENODEV;
+	}
+
+	desc->callback = stm32_usart_rx_dma_complete;
+	desc->callback_param = port;
+
+	/* Push current DMA transaction in the pending queue */
+	ret = dma_submit_error(dmaengine_submit(desc));
+	if (ret) {
+		dmaengine_terminate_sync(stm32_port->rx_ch);
+		stm32_port->rx_dma_busy = false;
+		return ret;
+	}
+
+	/* Issue pending DMA requests */
+	dma_async_issue_pending(stm32_port->rx_ch);
+
+	return 0;
+}
+
+static void stm32_usart_tx_dma_terminate(struct stm32_port *stm32_port)
+{
+	dmaengine_terminate_async(stm32_port->tx_ch);
+	stm32_port->tx_dma_busy = false;
+}
+
+static bool stm32_usart_tx_dma_started(struct stm32_port *stm32_port)
+{
+	/*
+	 * We cannot use the function "dmaengine_tx_status" to know the
+	 * status of DMA. This function does not show if the "dma complete"
+	 * callback of the DMA transaction have been called. So we prefer
+	 * to use "tx_dma_busy" flag to prevent dual dma transaction at the
+	 * same time.
+	 */
+	return stm32_port->tx_dma_busy;
+}
+
+static int stm32_usart_tx_dma_pause(struct stm32_port *stm32_port)
+{
+	return stm32_usart_dma_pause_resume(stm32_port, stm32_port->tx_ch,
+					    DMA_IN_PROGRESS, dmaengine_pause,
+					    stm32_usart_tx_dma_started,
+					    stm32_usart_tx_dma_terminate);
+}
+
+static int stm32_usart_tx_dma_resume(struct stm32_port *stm32_port)
+{
+	return stm32_usart_dma_pause_resume(stm32_port, stm32_port->tx_ch,
+					    DMA_PAUSED, dmaengine_resume,
+					    stm32_usart_tx_dma_started,
+					    stm32_usart_tx_dma_terminate);
 }
 
 static void stm32_usart_tx_dma_complete(void *arg)
 {
 	struct uart_port *port = arg;
 	struct stm32_port *stm32port = to_stm32_port(port);
-	const struct stm32_usart_offsets *ofs = &stm32port->info->ofs;
 	unsigned long flags;
 
-	dmaengine_terminate_async(stm32port->tx_ch);
-	stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAT);
-	stm32port->tx_dma_busy = false;
+	stm32_usart_tx_dma_terminate(stm32port);
 
 	/* Let's see if we have pending data to send */
 	spin_lock_irqsave(&port->lock, flags);
@@ -331,11 +583,6 @@ static void stm32_usart_transmit_chars_pio(struct uart_port *port)
 	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
 	struct circ_buf *xmit = &port->state->xmit;
 
-	if (stm32_port->tx_dma_busy) {
-		stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAT);
-		stm32_port->tx_dma_busy = false;
-	}
-
 	while (!uart_circ_empty(xmit)) {
 		/* Check that TDR is empty before filling FIFO */
 		if (!(readl_relaxed(port->membase + ofs->isr) & USART_SR_TXE))
@@ -355,15 +602,17 @@ static void stm32_usart_transmit_chars_pio(struct uart_port *port)
 static void stm32_usart_transmit_chars_dma(struct uart_port *port)
 {
 	struct stm32_port *stm32port = to_stm32_port(port);
-	const struct stm32_usart_offsets *ofs = &stm32port->info->ofs;
 	struct circ_buf *xmit = &port->state->xmit;
 	struct dma_async_tx_descriptor *desc = NULL;
-	unsigned int count, i;
+	unsigned int count;
+	int ret;
 
-	if (stm32port->tx_dma_busy)
+	if (stm32_usart_tx_dma_started(stm32port)) {
+		ret = stm32_usart_tx_dma_resume(stm32port);
+		if (ret < 0 && ret != -EAGAIN)
+			goto fallback_err;
 		return;
-
-	stm32port->tx_dma_busy = true;
+	}
 
 	count = uart_circ_chars_pending(xmit);
 
@@ -394,28 +643,35 @@ static void stm32_usart_transmit_chars_dma(struct uart_port *port)
 	if (!desc)
 		goto fallback_err;
 
+	/*
+	 * Set "tx_dma_busy" flag. This flag will be release when
+	 * dmaengine_terminate_async will be called. This flag helps
+	 * transmit_chars_dma not to start another dma transaction
+	 * if the callback of the previous is not yet called.
+	 */
+	stm32port->tx_dma_busy = true;
+
 	desc->callback = stm32_usart_tx_dma_complete;
 	desc->callback_param = port;
 
 	/* Push current DMA TX transaction in the pending queue */
-	if (dma_submit_error(dmaengine_submit(desc))) {
-		/* dma no yet started, safe to free resources */
-		dmaengine_terminate_async(stm32port->tx_ch);
+	/* DMA no yet started, safe to free resources */
+	ret = dma_submit_error(dmaengine_submit(desc));
+	if (ret) {
+		dev_err(port->dev, "DMA failed with error code: %d\n", ret);
+		stm32_usart_tx_dma_terminate(stm32port);
 		goto fallback_err;
 	}
 
 	/* Issue pending DMA TX requests */
 	dma_async_issue_pending(stm32port->tx_ch);
 
-	stm32_usart_set_bits(port, ofs->cr3, USART_CR3_DMAT);
-
 	xmit->tail = (xmit->tail + count) & (UART_XMIT_SIZE - 1);
 	port->icount.tx += count;
 	return;
 
 fallback_err:
-	for (i = count; i > 0; i--)
-		stm32_usart_transmit_chars_pio(port);
+	stm32_usart_transmit_chars_pio(port);
 }
 
 static void stm32_usart_transmit_chars(struct uart_port *port)
@@ -427,8 +683,8 @@ static void stm32_usart_transmit_chars(struct uart_port *port)
 	int ret;
 
 	if (port->x_char) {
-		if (stm32_port->tx_dma_busy)
-			stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAT);
+		/* dma terminate may have been called in case of dma pause failure */
+		stm32_usart_tx_dma_pause(stm32_port);
 
 		/* Check that TDR is empty before filling FIFO */
 		ret =
@@ -442,8 +698,9 @@ static void stm32_usart_transmit_chars(struct uart_port *port)
 		writel_relaxed(port->x_char, port->membase + ofs->tdr);
 		port->x_char = 0;
 		port->icount.tx++;
-		if (stm32_port->tx_dma_busy)
-			stm32_usart_set_bits(port, ofs->cr3, USART_CR3_DMAT);
+
+		/* dma terminate may have been called in case of dma resume failure */
+		stm32_usart_tx_dma_resume(stm32_port);
 		return;
 	}
 
@@ -476,6 +733,7 @@ static irqreturn_t stm32_usart_interrupt(int irq, void *ptr)
 	struct stm32_port *stm32_port = to_stm32_port(port);
 	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
 	u32 sr;
+	unsigned int size;
 
 	sr = readl_relaxed(port->membase + ofs->isr);
 
@@ -492,8 +750,20 @@ static irqreturn_t stm32_usart_interrupt(int irq, void *ptr)
 			pm_wakeup_event(tport->tty->dev, 0);
 	}
 
-	if ((sr & USART_SR_RXNE) && !(stm32_port->rx_ch))
-		stm32_usart_receive_chars(port, false);
+	/*
+	 * rx errors in dma mode has to be handled ASAP to avoid overrun as the DMA request
+	 * line has been masked by HW and rx data are stacking in FIFO.
+	 */
+	if (!stm32_port->throttled) {
+		if (((sr & USART_SR_RXNE) && !stm32_usart_rx_dma_started(stm32_port)) ||
+		    ((sr & USART_SR_ERR_MASK) && stm32_usart_rx_dma_started(stm32_port))) {
+			spin_lock(&port->lock);
+			size = stm32_usart_receive_chars(port, false);
+			uart_unlock_and_check_sysrq(port);
+			if (size)
+				tty_flip_buffer_push(tport);
+		}
+	}
 
 	if ((sr & USART_SR_TXE) && !(stm32_port->tx_ch)) {
 		spin_lock(&port->lock);
@@ -501,7 +771,8 @@ static irqreturn_t stm32_usart_interrupt(int irq, void *ptr)
 		spin_unlock(&port->lock);
 	}
 
-	if (stm32_port->rx_ch)
+	if ((sr & USART_SR_RTOF) && !(stm32_port->throttled) &&
+	    stm32_usart_rx_dma_started(stm32_port))
 		return IRQ_WAKE_THREAD;
 	else
 		return IRQ_HANDLED;
@@ -510,10 +781,16 @@ static irqreturn_t stm32_usart_interrupt(int irq, void *ptr)
 static irqreturn_t stm32_usart_threaded_interrupt(int irq, void *ptr)
 {
 	struct uart_port *port = ptr;
-	struct stm32_port *stm32_port = to_stm32_port(port);
+	struct tty_port *tport = &port->state->port;
+	unsigned int size;
+	unsigned long flags;
 
-	if (stm32_port->rx_ch)
-		stm32_usart_receive_chars(port, true);
+	/* Receiver timeout irq for DMA RX */
+	spin_lock_irqsave(&port->lock, flags);
+	size = stm32_usart_receive_chars(port, false);
+	uart_unlock_and_check_sysrq_irqrestore(port, flags);
+	if (size)
+		tty_flip_buffer_push(tport);
 
 	return IRQ_HANDLED;
 }
@@ -571,6 +848,9 @@ static void stm32_usart_stop_tx(struct uart_port *port)
 
 	stm32_usart_tx_interrupt_disable(port);
 
+	/* dma terminate may have been called in case of dma pause failure */
+	stm32_usart_tx_dma_pause(stm32_port);
+
 	if (rs485conf->flags & SER_RS485_ENABLED) {
 		if (rs485conf->flags & SER_RS485_RTS_ON_SEND) {
 			mctrl_gpio_set(stm32_port->gpios,
@@ -609,13 +889,9 @@ static void stm32_usart_start_tx(struct uart_port *port)
 static void stm32_usart_flush_buffer(struct uart_port *port)
 {
 	struct stm32_port *stm32_port = to_stm32_port(port);
-	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
 
-	if (stm32_port->tx_ch) {
-		dmaengine_terminate_async(stm32_port->tx_ch);
-		stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAT);
-		stm32_port->tx_dma_busy = false;
-	}
+	if (stm32_port->tx_ch)
+		stm32_usart_tx_dma_terminate(stm32_port);
 }
 
 /* Throttle the remote when input buffer is about to overflow. */
@@ -626,10 +902,18 @@ static void stm32_usart_throttle(struct uart_port *port)
 	unsigned long flags;
 
 	spin_lock_irqsave(&port->lock, flags);
+
+	/*
+	 * Pause DMA transfer, so the RX data gets queued into the FIFO.
+	 * Hardware flow control is triggered when RX FIFO is full.
+	 */
+	stm32_usart_rx_dma_pause(stm32_port);
+
 	stm32_usart_clr_bits(port, ofs->cr1, stm32_port->cr1_irq);
 	if (stm32_port->cr3_irq)
 		stm32_usart_clr_bits(port, ofs->cr3, stm32_port->cr3_irq);
 
+	stm32_port->throttled = true;
 	spin_unlock_irqrestore(&port->lock, flags);
 }
 
@@ -645,6 +929,15 @@ static void stm32_usart_unthrottle(struct uart_port *port)
 	if (stm32_port->cr3_irq)
 		stm32_usart_set_bits(port, ofs->cr3, stm32_port->cr3_irq);
 
+	stm32_port->throttled = false;
+
+	/*
+	 * Switch back to DMA mode (resume DMA).
+	 * Hardware flow control is stopped when FIFO is not full any more.
+	 */
+	if (stm32_port->rx_ch)
+		stm32_usart_rx_dma_start_or_resume(port);
+
 	spin_unlock_irqrestore(&port->lock, flags);
 }
 
@@ -654,14 +947,28 @@ static void stm32_usart_stop_rx(struct uart_port *port)
 	struct stm32_port *stm32_port = to_stm32_port(port);
 	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
 
+	/* Disable DMA request line. */
+	stm32_usart_rx_dma_pause(stm32_port);
+
 	stm32_usart_clr_bits(port, ofs->cr1, stm32_port->cr1_irq);
 	if (stm32_port->cr3_irq)
 		stm32_usart_clr_bits(port, ofs->cr3, stm32_port->cr3_irq);
 }
 
-/* Handle breaks - ignored by us */
 static void stm32_usart_break_ctl(struct uart_port *port, int break_state)
 {
+	struct stm32_port *stm32_port = to_stm32_port(port);
+	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	if (break_state)
+		stm32_usart_set_bits(port, ofs->rqr, USART_RQR_SBKRQ);
+	else
+		stm32_usart_clr_bits(port, ofs->rqr, USART_RQR_SBKRQ);
+
+	spin_unlock_irqrestore(&port->lock, flags);
 }
 
 static int stm32_usart_startup(struct uart_port *port)
@@ -690,6 +997,14 @@ static int stm32_usart_startup(struct uart_port *port)
 	if (ofs->rqr != UNDEF_REG)
 		writel_relaxed(USART_RQR_RXFRQ, port->membase + ofs->rqr);
 
+	if (stm32_port->rx_ch) {
+		ret = stm32_usart_rx_dma_start_or_resume(port);
+		if (ret) {
+			free_irq(port->irq, port);
+			return ret;
+		}
+	}
+
 	/* RX enabling */
 	val = stm32_port->cr1_irq | USART_CR1_RE | BIT(cfg->uart_enable_bit);
 	stm32_usart_set_bits(port, ofs->cr1, val);
@@ -705,10 +1020,11 @@ static void stm32_usart_shutdown(struct uart_port *port)
 	u32 val, isr;
 	int ret;
 
-	if (stm32_port->tx_dma_busy) {
-		dmaengine_terminate_async(stm32_port->tx_ch);
+	if (stm32_usart_tx_dma_started(stm32_port))
+		stm32_usart_tx_dma_terminate(stm32_port);
+
+	if (stm32_port->tx_ch)
 		stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAT);
-	}
 
 	/* Disable modem control interrupts */
 	stm32_usart_disable_ms(port);
@@ -727,6 +1043,12 @@ static void stm32_usart_shutdown(struct uart_port *port)
 	if (ret)
 		dev_err(port->dev, "Transmission is not complete\n");
 
+	/* Disable RX DMA. */
+	if (stm32_port->rx_ch) {
+		stm32_usart_rx_dma_terminate(stm32_port);
+		dmaengine_synchronize(stm32_port->rx_ch);
+	}
+
 	/* flush RX & TX FIFO */
 	if (ofs->rqr != UNDEF_REG)
 		writel_relaxed(USART_RQR_TXFRQ | USART_RQR_RXFRQ,
@@ -838,9 +1160,11 @@ static void stm32_usart_set_termios(struct uart_port *port,
 		stm32_port->cr1_irq = USART_CR1_RTOIE;
 		writel_relaxed(bits, port->membase + ofs->rtor);
 		cr2 |= USART_CR2_RTOEN;
-		/* Not using dma, enable fifo threshold irq */
-		if (!stm32_port->rx_ch)
-			stm32_port->cr3_irq =  USART_CR3_RXFTIE;
+		/*
+		 * Enable fifo threshold irq in two cases, either when there is no DMA, or when
+		 * wake up over usart, from low power until the DMA gets re-enabled by resume.
+		 */
+		stm32_port->cr3_irq =  USART_CR3_RXFTIE;
 	}
 
 	cr1 |= stm32_port->cr1_irq;
@@ -903,14 +1227,22 @@ static void stm32_usart_set_termios(struct uart_port *port,
 	if ((termios->c_cflag & CREAD) == 0)
 		port->ignore_status_mask |= USART_SR_DUMMY_RX;
 
-	if (stm32_port->rx_ch)
+	if (stm32_port->rx_ch) {
+		/*
+		 * Setup DMA to collect only valid data and enable error irqs.
+		 * This also enables break reception when using DMA.
+		 */
+		cr1 |= USART_CR1_PEIE;
+		cr3 |= USART_CR3_EIE;
 		cr3 |= USART_CR3_DMAR;
+		cr3 |= USART_CR3_DDRE;
+	}
+
+	if (stm32_port->tx_ch)
+		cr3 |= USART_CR3_DMAT;
 
 	if (rs485conf->flags & SER_RS485_ENABLED) {
-		stm32_usart_config_reg_rs485(&cr1, &cr3,
-					     rs485conf->delay_rts_before_send,
-					     rs485conf->delay_rts_after_send,
-					     baud);
+		stm32_usart_config_reg_rs485(&cr1, &cr3, baud, rs485conf);
 		if (rs485conf->flags & SER_RS485_RTS_ON_SEND) {
 			cr3 &= ~USART_CR3_DEP;
 			rs485conf->flags &= ~SER_RS485_RTS_AFTER_SEND;
@@ -993,6 +1325,40 @@ static void stm32_usart_pm(struct uart_port *port, unsigned int state,
 	}
 }
 
+#if defined(CONFIG_CONSOLE_POLL)
+
+ /* Callbacks for characters polling in debug context (i.e. KGDB). */
+static int stm32_usart_poll_init(struct uart_port *port)
+{
+	struct stm32_port *stm32_port = to_stm32_port(port);
+
+	return clk_prepare_enable(stm32_port->clk);
+}
+
+static int stm32_usart_poll_get_char(struct uart_port *port)
+{
+	struct stm32_port *stm32_port = to_stm32_port(port);
+	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
+	unsigned int ret;
+
+	if (!(readl_relaxed(port->membase + ofs->isr) & USART_SR_RXNE))
+		return NO_POLL_CHAR;
+
+	ret = readl_relaxed(port->membase + ofs->rdr);
+	/* Apply RDR data mask */
+	ret &= stm32_port->rdr_mask;
+
+	return ret;
+}
+
+static void __maybe_unused stm32_usart_console_putchar(struct uart_port *port, int ch);
+
+static void stm32_usart_poll_put_char(struct uart_port *port, unsigned char ch)
+{
+	stm32_usart_console_putchar(port, (int)ch);
+}
+#endif
+
 static const struct uart_ops stm32_uart_ops = {
 	.tx_empty	= stm32_usart_tx_empty,
 	.set_mctrl	= stm32_usart_set_mctrl,
@@ -1014,6 +1380,12 @@ static const struct uart_ops stm32_uart_ops = {
 	.request_port	= stm32_usart_request_port,
 	.config_port	= stm32_usart_config_port,
 	.verify_port	= stm32_usart_verify_port,
+#if defined(CONFIG_CONSOLE_POLL)
+	.poll_init      = stm32_usart_poll_init,
+	.poll_get_char	= stm32_usart_poll_get_char,
+	.poll_put_char	= stm32_usart_poll_put_char,
+#endif /* CONFIG_CONSOLE_POLL */
+
 };
 
 /*
@@ -1194,7 +1566,6 @@ static int stm32_usart_of_dma_rx_probe(struct stm32_port *stm32port,
 	struct uart_port *port = &stm32port->port;
 	struct device *dev = &pdev->dev;
 	struct dma_slave_config config;
-	struct dma_async_tx_descriptor *desc = NULL;
 	int ret;
 
 	/*
@@ -1222,32 +1593,6 @@ static int stm32_usart_of_dma_rx_probe(struct stm32_port *stm32port,
 		return ret;
 	}
 
-	/* Prepare a DMA cyclic transaction */
-	desc = dmaengine_prep_dma_cyclic(stm32port->rx_ch,
-					 stm32port->rx_dma_buf,
-					 RX_BUF_L, RX_BUF_P, DMA_DEV_TO_MEM,
-					 DMA_PREP_INTERRUPT);
-	if (!desc) {
-		dev_err(dev, "rx dma prep cyclic failed\n");
-		stm32_usart_of_dma_rx_remove(stm32port, pdev);
-		return -ENODEV;
-	}
-
-	/* No callback as dma buffer is drained on usart interrupt */
-	desc->callback = NULL;
-	desc->callback_param = NULL;
-
-	/* Push current DMA transaction in the pending queue */
-	ret = dma_submit_error(dmaengine_submit(desc));
-	if (ret) {
-		dmaengine_terminate_sync(stm32port->rx_ch);
-		stm32_usart_of_dma_rx_remove(stm32port, pdev);
-		return ret;
-	}
-
-	/* Issue pending DMA requests */
-	dma_async_issue_pending(stm32port->rx_ch);
-
 	return 0;
 }
 
@@ -1268,8 +1613,6 @@ static int stm32_usart_of_dma_tx_probe(struct stm32_port *stm32port,
 	struct dma_slave_config config;
 	int ret;
 
-	stm32port->tx_dma_busy = false;
-
 	stm32port->tx_buf = dma_alloc_coherent(dev, TX_BUF_L,
 					       &stm32port->tx_dma_buf,
 					       GFP_KERNEL);
@@ -1400,6 +1743,7 @@ static int stm32_usart_serial_remove(struct platform_device *pdev)
 	struct stm32_port *stm32_port = to_stm32_port(port);
 	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
 	int err;
+	u32 cr3;
 
 	pm_runtime_get_sync(&pdev->dev);
 	err = uart_remove_one_port(&stm32_usart_driver, port);
@@ -1410,7 +1754,7 @@ static int stm32_usart_serial_remove(struct platform_device *pdev)
 	pm_runtime_set_suspended(&pdev->dev);
 	pm_runtime_put_noidle(&pdev->dev);
 
-	stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAR);
+	stm32_usart_clr_bits(port, ofs->cr1, USART_CR1_PEIE);
 
 	if (stm32_port->tx_ch) {
 		stm32_usart_of_dma_tx_remove(stm32_port, pdev);
@@ -1418,12 +1762,16 @@ static int stm32_usart_serial_remove(struct platform_device *pdev)
 	}
 
 	if (stm32_port->rx_ch) {
-		dmaengine_terminate_async(stm32_port->rx_ch);
 		stm32_usart_of_dma_rx_remove(stm32_port, pdev);
 		dma_release_channel(stm32_port->rx_ch);
 	}
 
-	stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAT);
+	cr3 = readl_relaxed(port->membase + ofs->cr3);
+	cr3 &= ~USART_CR3_EIE;
+	cr3 &= ~USART_CR3_DMAR;
+	cr3 &= ~USART_CR3_DMAT;
+	cr3 &= ~USART_CR3_DDRE;
+	writel_relaxed(cr3, port->membase + ofs->cr3);
 
 	if (stm32_port->wakeup_src) {
 		dev_pm_clear_wake_irq(&pdev->dev);
@@ -1435,18 +1783,24 @@ static int stm32_usart_serial_remove(struct platform_device *pdev)
 	return 0;
 }
 
-#ifdef CONFIG_SERIAL_STM32_CONSOLE
-static void stm32_usart_console_putchar(struct uart_port *port, int ch)
+static void __maybe_unused stm32_usart_console_putchar(struct uart_port *port, int ch)
 {
 	struct stm32_port *stm32_port = to_stm32_port(port);
 	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
+	u32 isr;
+	int ret;
 
-	while (!(readl_relaxed(port->membase + ofs->isr) & USART_SR_TXE))
-		cpu_relax();
-
+	ret = readl_relaxed_poll_timeout_atomic(port->membase + ofs->isr, isr,
+						(isr & USART_SR_TXE), 100,
+						STM32_USART_TIMEOUT_USEC);
+	if (ret != 0) {
+		dev_err(port->dev, "Error while sending data in UART TX : %d\n", ret);
+		return;
+	}
 	writel_relaxed(ch, port->membase + ofs->tdr);
 }
 
+#ifdef CONFIG_SERIAL_STM32_CONSOLE
 static void stm32_usart_console_write(struct console *co, const char *s,
 				      unsigned int cnt)
 {
@@ -1522,6 +1876,57 @@ static struct console stm32_console = {
 #define STM32_SERIAL_CONSOLE NULL
 #endif /* CONFIG_SERIAL_STM32_CONSOLE */
 
+#ifdef CONFIG_SERIAL_EARLYCON
+static void early_stm32_usart_console_putchar(struct uart_port *port, int ch)
+{
+	struct stm32_usart_info *info = port->private_data;
+
+	while (!(readl_relaxed(port->membase + info->ofs.isr) & USART_SR_TXE))
+		cpu_relax();
+
+	writel_relaxed(ch, port->membase + info->ofs.tdr);
+}
+
+static void early_stm32_serial_write(struct console *console, const char *s, unsigned int count)
+{
+	struct earlycon_device *device = console->data;
+	struct uart_port *port = &device->port;
+
+	uart_console_write(port, s, count, early_stm32_usart_console_putchar);
+}
+
+static int __init early_stm32_h7_serial_setup(struct earlycon_device *device, const char *options)
+{
+	if (!(device->port.membase || device->port.iobase))
+		return -ENODEV;
+	device->port.private_data = &stm32h7_info;
+	device->con->write = early_stm32_serial_write;
+	return 0;
+}
+
+static int __init early_stm32_f7_serial_setup(struct earlycon_device *device, const char *options)
+{
+	if (!(device->port.membase || device->port.iobase))
+		return -ENODEV;
+	device->port.private_data = &stm32f7_info;
+	device->con->write = early_stm32_serial_write;
+	return 0;
+}
+
+static int __init early_stm32_f4_serial_setup(struct earlycon_device *device, const char *options)
+{
+	if (!(device->port.membase || device->port.iobase))
+		return -ENODEV;
+	device->port.private_data = &stm32f4_info;
+	device->con->write = early_stm32_serial_write;
+	return 0;
+}
+
+OF_EARLYCON_DECLARE(stm32h7serial, "st,stm32h7-uart", early_stm32_h7_serial_setup);
+OF_EARLYCON_DECLARE(stm32f7serial, "st,stm32f7-uart", early_stm32_f7_serial_setup);
+OF_EARLYCON_DECLARE(stm32f4serial, "st,stm32-uart", early_stm32_f4_serial_setup);
+#endif /* CONFIG_SERIAL_EARLYCON */
+
 static struct uart_driver stm32_usart_driver = {
 	.driver_name	= DRIVER_NAME,
 	.dev_name	= STM32_SERIAL_NAME,
@@ -1531,14 +1936,18 @@ static struct uart_driver stm32_usart_driver = {
 	.cons		= STM32_SERIAL_CONSOLE,
 };
 
-static void __maybe_unused stm32_usart_serial_en_wakeup(struct uart_port *port,
-							bool enable)
+static int __maybe_unused stm32_usart_serial_en_wakeup(struct uart_port *port,
+						       bool enable)
 {
 	struct stm32_port *stm32_port = to_stm32_port(port);
 	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
+	struct tty_port *tport = &port->state->port;
+	int ret;
+	unsigned int size = 0;
+	unsigned long flags;
 
-	if (!stm32_port->wakeup_src)
-		return;
+	if (!stm32_port->wakeup_src || !tty_port_initialized(tport))
+		return 0;
 
 	/*
 	 * Enable low-power wake-up and wake-up irq if argument is set to
@@ -1547,20 +1956,52 @@ static void __maybe_unused stm32_usart_serial_en_wakeup(struct uart_port *port,
 	if (enable) {
 		stm32_usart_set_bits(port, ofs->cr1, USART_CR1_UESM);
 		stm32_usart_set_bits(port, ofs->cr3, USART_CR3_WUFIE);
+		mctrl_gpio_enable_irq_wake(stm32_port->gpios);
+
+		/*
+		 * When DMA is used for reception, it must be disabled before
+		 * entering low-power mode and re-enabled when exiting from
+		 * low-power mode.
+		 */
+		if (stm32_port->rx_ch) {
+			spin_lock_irqsave(&port->lock, flags);
+			/* Poll data from DMA RX buffer if any */
+			if (!stm32_usart_rx_dma_pause(stm32_port))
+				size += stm32_usart_receive_chars(port, true);
+			stm32_usart_rx_dma_terminate(stm32_port);
+			uart_unlock_and_check_sysrq_irqrestore(port, flags);
+			if (size)
+				tty_flip_buffer_push(tport);
+		}
+
+		/* Poll data from RX FIFO if any */
+		stm32_usart_receive_chars(port, false);
 	} else {
+		if (stm32_port->rx_ch) {
+			ret = stm32_usart_rx_dma_start_or_resume(port);
+			if (ret)
+				return ret;
+		}
+		mctrl_gpio_disable_irq_wake(stm32_port->gpios);
 		stm32_usart_clr_bits(port, ofs->cr1, USART_CR1_UESM);
 		stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_WUFIE);
 	}
+
+	return 0;
 }
 
 static int __maybe_unused stm32_usart_serial_suspend(struct device *dev)
 {
 	struct uart_port *port = dev_get_drvdata(dev);
+	int ret;
 
 	uart_suspend_port(&stm32_usart_driver, port);
 
-	if (device_may_wakeup(dev) || device_wakeup_path(dev))
-		stm32_usart_serial_en_wakeup(port, true);
+	if (device_may_wakeup(dev) || device_wakeup_path(dev)) {
+		ret = stm32_usart_serial_en_wakeup(port, true);
+		if (ret)
+			return ret;
+	}
 
 	/*
 	 * When "no_console_suspend" is enabled, keep the pinctrl default state
@@ -1581,11 +2022,15 @@ static int __maybe_unused stm32_usart_serial_suspend(struct device *dev)
 static int __maybe_unused stm32_usart_serial_resume(struct device *dev)
 {
 	struct uart_port *port = dev_get_drvdata(dev);
+	int ret;
 
 	pinctrl_pm_select_default_state(dev);
 
-	if (device_may_wakeup(dev) || device_wakeup_path(dev))
-		stm32_usart_serial_en_wakeup(port, false);
+	if (device_may_wakeup(dev) || device_wakeup_path(dev)) {
+		ret = stm32_usart_serial_en_wakeup(port, false);
+		if (ret)
+			return ret;
+	}
 
 	return uart_resume_port(&stm32_usart_driver, port);
 }
diff --git a/drivers/tty/serial/stm32-usart.h b/drivers/tty/serial/stm32-usart.h
index 07ac29132..9c7ddb906 100644
--- a/drivers/tty/serial/stm32-usart.h
+++ b/drivers/tty/serial/stm32-usart.h
@@ -109,7 +109,7 @@ struct stm32_usart_info stm32h7_info = {
 /* USART_SR (F4) / USART_ISR (F7) */
 #define USART_SR_PE		BIT(0)
 #define USART_SR_FE		BIT(1)
-#define USART_SR_NF		BIT(2)
+#define USART_SR_NE		BIT(2)		/* F7 (NF for F4) */
 #define USART_SR_ORE		BIT(3)
 #define USART_SR_IDLE		BIT(4)
 #define USART_SR_RXNE		BIT(5)
@@ -126,7 +126,8 @@ struct stm32_usart_info stm32h7_info = {
 #define USART_SR_SBKF		BIT(18)		/* F7 */
 #define USART_SR_WUF		BIT(20)		/* H7 */
 #define USART_SR_TEACK		BIT(21)		/* F7 */
-#define USART_SR_ERR_MASK	(USART_SR_ORE | USART_SR_FE | USART_SR_PE)
+#define USART_SR_ERR_MASK	(USART_SR_ORE | USART_SR_NE | USART_SR_FE |\
+				 USART_SR_PE)
 /* Dummy bits */
 #define USART_SR_DUMMY_RX	BIT(16)
 
@@ -246,9 +247,11 @@ struct stm32_usart_info stm32h7_info = {
 #define STM32_SERIAL_NAME "ttySTM"
 #define STM32_MAX_PORTS 8
 
-#define RX_BUF_L 200		 /* dma rx buffer length     */
-#define RX_BUF_P RX_BUF_L	 /* dma rx buffer period     */
-#define TX_BUF_L 200		 /* dma tx buffer length     */
+#define RX_BUF_L 4096		 /* dma rx buffer length     */
+#define RX_BUF_P (RX_BUF_L / 2)	 /* dma rx buffer period     */
+#define TX_BUF_L RX_BUF_L	 /* dma tx buffer length     */
+
+#define STM32_USART_TIMEOUT_USEC USEC_PER_SEC /* 1s timeout in µs */
 
 struct stm32_port {
 	struct uart_port port;
@@ -263,7 +266,9 @@ struct stm32_port {
 	u32 cr1_irq;		 /* USART_CR1_RXNEIE or RTOIE */
 	u32 cr3_irq;		 /* USART_CR3_RXFTIE */
 	int last_res;
-	bool tx_dma_busy;	 /* dma tx busy               */
+	bool tx_dma_busy;	 /* dma tx transaction in progress */
+	bool rx_dma_busy;	 /* dma rx transaction in progress */
+	bool throttled;		 /* port throttled            */
 	bool hw_flow_control;
 	bool swap;		 /* swap RX & TX pins */
 	bool fifoen;
@@ -272,6 +277,7 @@ struct stm32_port {
 	bool wakeup_src;
 	int rdr_mask;		/* receive data register mask */
 	struct mctrl_gpios *gpios; /* modem control gpios */
+	struct dma_tx_state rx_dma_state;
 };
 
 static struct stm32_port stm32_ports[STM32_MAX_PORTS];
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 6c5934dbe..ee16e33b4 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -2295,7 +2295,8 @@ int hcd_bus_suspend(struct usb_device *rhdev, pm_message_t msg)
 
 		if (!PMSG_IS_AUTO(msg))
 			usb_phy_roothub_suspend(hcd->self.sysdev,
-						hcd->phy_roothub);
+						hcd->phy_roothub,
+						usb_wakeup_enabled_descendants(rhdev));
 
 		/* Did we race with a root-hub wakeup event? */
 		if (rhdev->do_remote_wakeup) {
@@ -2336,7 +2337,8 @@ int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg)
 
 	if (!PMSG_IS_AUTO(msg)) {
 		status = usb_phy_roothub_resume(hcd->self.sysdev,
-						hcd->phy_roothub);
+						hcd->phy_roothub,
+						usb_wakeup_enabled_descendants(rhdev));
 		if (status)
 			return status;
 	}
@@ -2381,7 +2383,8 @@ int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg)
 		}
 	} else {
 		hcd->state = old_state;
-		usb_phy_roothub_suspend(hcd->self.sysdev, hcd->phy_roothub);
+		usb_phy_roothub_suspend(hcd->self.sysdev, hcd->phy_roothub,
+					usb_wakeup_enabled_descendants(rhdev));
 		dev_dbg(&rhdev->dev, "bus %s fail, err %d\n",
 				"resume", status);
 		if (status != -ESHUTDOWN)
diff --git a/drivers/usb/core/phy.c b/drivers/usb/core/phy.c
index fb1588e7c..746615aa1 100644
--- a/drivers/usb/core/phy.c
+++ b/drivers/usb/core/phy.c
@@ -212,34 +212,36 @@ void usb_phy_roothub_power_off(struct usb_phy_roothub *phy_roothub)
 EXPORT_SYMBOL_GPL(usb_phy_roothub_power_off);
 
 int usb_phy_roothub_suspend(struct device *controller_dev,
-			    struct usb_phy_roothub *phy_roothub)
+			    struct usb_phy_roothub *phy_roothub,
+			    unsigned wakeup_enabled_descendants)
 {
-	usb_phy_roothub_power_off(phy_roothub);
-
 	/* keep the PHYs initialized so the device can wake up the system */
-	if (device_may_wakeup(controller_dev))
+	if (device_may_wakeup(controller_dev) || wakeup_enabled_descendants)
 		return 0;
 
+	usb_phy_roothub_power_off(phy_roothub);
+
 	return usb_phy_roothub_exit(phy_roothub);
 }
 EXPORT_SYMBOL_GPL(usb_phy_roothub_suspend);
 
 int usb_phy_roothub_resume(struct device *controller_dev,
-			   struct usb_phy_roothub *phy_roothub)
+			   struct usb_phy_roothub *phy_roothub,
+			   unsigned wakeup_enabled_descendants)
 {
-	int err;
+	int err = 0;
 
 	/* if the device can't wake up the system _exit was called */
-	if (!device_may_wakeup(controller_dev)) {
+	if (!device_may_wakeup(controller_dev) && !wakeup_enabled_descendants) {
 		err = usb_phy_roothub_init(phy_roothub);
 		if (err)
 			return err;
-	}
 
-	err = usb_phy_roothub_power_on(phy_roothub);
+		err = usb_phy_roothub_power_on(phy_roothub);
+	}
 
 	/* undo _init if _power_on failed */
-	if (err && !device_may_wakeup(controller_dev))
+	if (err && !device_may_wakeup(controller_dev) && !wakeup_enabled_descendants)
 		usb_phy_roothub_exit(phy_roothub);
 
 	return err;
diff --git a/drivers/usb/core/phy.h b/drivers/usb/core/phy.h
index 20a267cd9..3df4ddbb6 100644
--- a/drivers/usb/core/phy.h
+++ b/drivers/usb/core/phy.h
@@ -23,8 +23,10 @@ int usb_phy_roothub_power_on(struct usb_phy_roothub *phy_roothub);
 void usb_phy_roothub_power_off(struct usb_phy_roothub *phy_roothub);
 
 int usb_phy_roothub_suspend(struct device *controller_dev,
-			    struct usb_phy_roothub *phy_roothub);
+			    struct usb_phy_roothub *phy_roothub,
+			    unsigned wakeup_enabled_descendants);
 int usb_phy_roothub_resume(struct device *controller_dev,
-			   struct usb_phy_roothub *phy_roothub);
+			   struct usb_phy_roothub *phy_roothub,
+			   unsigned wakeup_enabled_descendants);
 
 #endif /* __USB_CORE_PHY_H_ */
diff --git a/drivers/usb/dwc2/core.h b/drivers/usb/dwc2/core.h
index 71e62b308..255fca4e8 100644
--- a/drivers/usb/dwc2/core.h
+++ b/drivers/usb/dwc2/core.h
@@ -238,11 +238,14 @@ enum dwc2_ep0_state {
 /**
  * struct dwc2_core_params - Parameters for configuring the core
  *
- * @otg_cap:            Specifies the OTG capabilities.
- *                       0 - HNP and SRP capable
- *                       1 - SRP Only capable
- *                       2 - No HNP/SRP capable (always available)
- *                      Defaults to best available option (0, 1, then 2)
+ * @otg_caps:           Specifies the OTG capabilities. OTG caps from the platform parameters,
+ *                      used to setup the:
+ *                       - HNP and SRP capable
+ *                       - SRP Only capable
+ *                       - No HNP/SRP capable (always available)
+ *                       Defaults to best available option
+ *                       - OTG revision number the device is compliant with, in binary-coded
+ *                         decimal (i.e. 2.0 is 0200H). (see struct usb_otg_caps)
  * @host_dma:           Specifies whether to use slave or DMA mode for accessing
  *                      the data FIFOs. The driver will automatically detect the
  *                      value for this parameter if none is specified.
@@ -453,11 +456,7 @@ enum dwc2_ep0_state {
  * default described above.
  */
 struct dwc2_core_params {
-	u8 otg_cap;
-#define DWC2_CAP_PARAM_HNP_SRP_CAPABLE		0
-#define DWC2_CAP_PARAM_SRP_ONLY_CAPABLE		1
-#define DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE	2
-
+	struct usb_otg_caps otg_caps;
 	u8 phy_type;
 #define DWC2_PHY_TYPE_PARAM_FS		0
 #define DWC2_PHY_TYPE_PARAM_UTMI	1
@@ -870,6 +869,8 @@ struct dwc2_hregs_backup {
  *                      - USB_DR_MODE_HOST
  *                      - USB_DR_MODE_OTG
  * @role_sw:		usb_role_switch handle
+ * @role_sw_default_mode: default operation mode of controller while usb role
+ *			is USB_ROLE_NONE
  * @hcd_enabled:	Host mode sub-driver initialization indicator.
  * @gadget_enabled:	Peripheral mode sub-driver initialization indicator.
  * @ll_hw_enabled:	Status of low-level hardware resources.
@@ -1066,6 +1067,7 @@ struct dwc2_hsotg {
 	enum usb_otg_state op_state;
 	enum usb_dr_mode dr_mode;
 	struct usb_role_switch *role_sw;
+	enum usb_dr_mode role_sw_default_mode;
 	unsigned int hcd_enabled:1;
 	unsigned int gadget_enabled:1;
 	unsigned int ll_hw_enabled:1;
diff --git a/drivers/usb/dwc2/core_intr.c b/drivers/usb/dwc2/core_intr.c
index a5c52b237..c786560fb 100644
--- a/drivers/usb/dwc2/core_intr.c
+++ b/drivers/usb/dwc2/core_intr.c
@@ -433,13 +433,14 @@ static void dwc2_handle_wakeup_detected_intr(struct dwc2_hsotg *hsotg)
 				if (ret)
 					dev_err(hsotg->dev,
 						"exit partial_power_down failed\n");
-				call_gadget(hsotg, resume);
 			}
 
 			/* Exit gadget mode clock gating. */
 			if (hsotg->params.power_down ==
 			    DWC2_POWER_DOWN_PARAM_NONE && hsotg->bus_suspended)
 				dwc2_gadget_exit_clock_gating(hsotg, 0);
+
+			call_gadget(hsotg, resume);
 		} else {
 			/* Change to L0 state */
 			hsotg->lx_state = DWC2_L0;
diff --git a/drivers/usb/dwc2/debugfs.c b/drivers/usb/dwc2/debugfs.c
index f13eed423..1d72ece9c 100644
--- a/drivers/usb/dwc2/debugfs.c
+++ b/drivers/usb/dwc2/debugfs.c
@@ -670,7 +670,9 @@ static int params_show(struct seq_file *seq, void *v)
 	struct dwc2_core_params *p = &hsotg->params;
 	int i;
 
-	print_param(seq, p, otg_cap);
+	print_param(seq, p, otg_caps.hnp_support);
+	print_param(seq, p, otg_caps.srp_support);
+	print_param(seq, p, otg_caps.otg_rev);
 	print_param(seq, p, dma_desc_enable);
 	print_param(seq, p, dma_desc_fs_enable);
 	print_param(seq, p, speed);
diff --git a/drivers/usb/dwc2/drd.c b/drivers/usb/dwc2/drd.c
index 36f2c3841..c64701307 100644
--- a/drivers/usb/dwc2/drd.c
+++ b/drivers/usb/dwc2/drd.c
@@ -13,6 +13,10 @@
 #include <linux/usb/role.h>
 #include "core.h"
 
+#define dwc2_ovr_gotgctl(gotgctl) \
+	((gotgctl) |= GOTGCTL_BVALOEN | GOTGCTL_AVALOEN | GOTGCTL_VBVALOEN | \
+	 GOTGCTL_DBNCE_FLTR_BYPASS)
+
 static void dwc2_ovr_init(struct dwc2_hsotg *hsotg)
 {
 	unsigned long flags;
@@ -21,9 +25,12 @@ static void dwc2_ovr_init(struct dwc2_hsotg *hsotg)
 	spin_lock_irqsave(&hsotg->lock, flags);
 
 	gotgctl = dwc2_readl(hsotg, GOTGCTL);
-	gotgctl |= GOTGCTL_BVALOEN | GOTGCTL_AVALOEN | GOTGCTL_VBVALOEN;
-	gotgctl |= GOTGCTL_DBNCE_FLTR_BYPASS;
+	dwc2_ovr_gotgctl(gotgctl);
 	gotgctl &= ~(GOTGCTL_BVALOVAL | GOTGCTL_AVALOVAL | GOTGCTL_VBVALOVAL);
+	if (hsotg->role_sw_default_mode == USB_DR_MODE_HOST)
+		gotgctl |= GOTGCTL_AVALOVAL | GOTGCTL_VBVALOVAL;
+	else if (hsotg->role_sw_default_mode == USB_DR_MODE_PERIPHERAL)
+		gotgctl |= GOTGCTL_BVALOVAL | GOTGCTL_VBVALOVAL;
 	dwc2_writel(hsotg, gotgctl, GOTGCTL);
 
 	spin_unlock_irqrestore(&hsotg->lock, flags);
@@ -36,10 +43,13 @@ static int dwc2_ovr_avalid(struct dwc2_hsotg *hsotg, bool valid)
 	u32 gotgctl = dwc2_readl(hsotg, GOTGCTL);
 
 	/* Check if A-Session is already in the right state */
-	if ((valid && (gotgctl & GOTGCTL_ASESVLD)) ||
-	    (!valid && !(gotgctl & GOTGCTL_ASESVLD)))
+	if ((valid && (gotgctl & GOTGCTL_AVALOVAL) && (gotgctl & GOTGCTL_VBVALOVAL)) ||
+	    (!valid && !(gotgctl & (GOTGCTL_AVALOVAL | GOTGCTL_VBVALOVAL))))
 		return -EALREADY;
 
+	/* Always enable overrides to handle the resume case */
+	dwc2_ovr_gotgctl(gotgctl);
+
 	gotgctl &= ~GOTGCTL_BVALOVAL;
 	if (valid)
 		gotgctl |= GOTGCTL_AVALOVAL | GOTGCTL_VBVALOVAL;
@@ -55,10 +65,13 @@ static int dwc2_ovr_bvalid(struct dwc2_hsotg *hsotg, bool valid)
 	u32 gotgctl = dwc2_readl(hsotg, GOTGCTL);
 
 	/* Check if B-Session is already in the right state */
-	if ((valid && (gotgctl & GOTGCTL_BSESVLD)) ||
-	    (!valid && !(gotgctl & GOTGCTL_BSESVLD)))
+	if ((valid && (gotgctl & GOTGCTL_BVALOVAL) && (gotgctl & GOTGCTL_VBVALOVAL)) ||
+	    (!valid && !(gotgctl & (GOTGCTL_BVALOVAL | GOTGCTL_VBVALOVAL))))
 		return -EALREADY;
 
+	/* Always enable overrides to handle the resume case */
+	dwc2_ovr_gotgctl(gotgctl);
+
 	gotgctl &= ~GOTGCTL_AVALOVAL;
 	if (valid)
 		gotgctl |= GOTGCTL_BVALOVAL | GOTGCTL_VBVALOVAL;
@@ -105,6 +118,14 @@ static int dwc2_drd_role_sw_set(struct usb_role_switch *sw, enum usb_role role)
 
 	spin_lock_irqsave(&hsotg->lock, flags);
 
+	if (role == USB_ROLE_NONE) {
+		/* default operation mode when usb role is USB_ROLE_NONE */
+		if (hsotg->role_sw_default_mode == USB_DR_MODE_HOST)
+			role = USB_ROLE_HOST;
+		else if (hsotg->role_sw_default_mode == USB_DR_MODE_PERIPHERAL)
+			role = USB_ROLE_DEVICE;
+	}
+
 	if (role == USB_ROLE_HOST) {
 		already = dwc2_ovr_avalid(hsotg, true);
 	} else if (role == USB_ROLE_DEVICE) {
@@ -125,9 +146,18 @@ static int dwc2_drd_role_sw_set(struct usb_role_switch *sw, enum usb_role role)
 
 	spin_unlock_irqrestore(&hsotg->lock, flags);
 
-	if (!already && hsotg->dr_mode == USB_DR_MODE_OTG)
+	if (!already && hsotg->dr_mode == USB_DR_MODE_OTG) {
+		/*
+		 * The bus may have been suspended (typically in hcd), need to resume as the HW
+		 * may not be HW accessible. Schedule work to call dwc2_conn_id_status_change
+		 * to handle the port resume before switching mode.
+		 */
+		if (hsotg->bus_suspended && hsotg->wq_otg)
+			queue_work(hsotg->wq_otg, &hsotg->wf_otg);
+
 		/* This will raise a Connector ID Status Change Interrupt */
 		dwc2_force_mode(hsotg, role == USB_ROLE_HOST);
+	}
 
 	if (!hsotg->ll_hw_enabled && hsotg->clk)
 		clk_disable_unprepare(hsotg->clk);
@@ -143,11 +173,21 @@ int dwc2_drd_init(struct dwc2_hsotg *hsotg)
 {
 	struct usb_role_switch_desc role_sw_desc = {0};
 	struct usb_role_switch *role_sw;
+	const char *str;
 	int ret;
 
 	if (!device_property_read_bool(hsotg->dev, "usb-role-switch"))
 		return 0;
 
+	hsotg->role_sw_default_mode = USB_DR_MODE_UNKNOWN;
+	ret = device_property_read_string(hsotg->dev, "role-switch-default-mode", &str);
+	if (!ret) {
+		if (!strncmp(str, "host", strlen("host")))
+			hsotg->role_sw_default_mode = USB_DR_MODE_HOST;
+		else if (!strncmp(str, "peripheral", strlen("peripheral")))
+			hsotg->role_sw_default_mode = USB_DR_MODE_PERIPHERAL;
+	}
+
 	role_sw_desc.driver_data = hsotg;
 	role_sw_desc.fwnode = dev_fwnode(hsotg->dev);
 	role_sw_desc.set = dwc2_drd_role_sw_set;
@@ -185,6 +225,31 @@ void dwc2_drd_suspend(struct dwc2_hsotg *hsotg)
 void dwc2_drd_resume(struct dwc2_hsotg *hsotg)
 {
 	u32 gintsts, gintmsk;
+	enum usb_role role;
+
+	if (hsotg->role_sw) {
+		/* get last known role (as the get ops isn't implemented by this driver) */
+		role = usb_role_switch_get_role(hsotg->role_sw);
+
+		if (role == USB_ROLE_NONE) {
+			if (hsotg->role_sw_default_mode == USB_DR_MODE_HOST)
+				role = USB_ROLE_HOST;
+			else if (hsotg->role_sw_default_mode == USB_DR_MODE_PERIPHERAL)
+				role = USB_ROLE_DEVICE;
+		}
+
+		/* restore last role that may have been lost */
+		if (role == USB_ROLE_HOST)
+			dwc2_ovr_avalid(hsotg, true);
+		else if (role == USB_ROLE_DEVICE)
+			dwc2_ovr_bvalid(hsotg, true);
+
+		dwc2_force_mode(hsotg, role == USB_ROLE_HOST);
+
+		dev_dbg(hsotg->dev, "resuming %s-session valid\n",
+			role == USB_ROLE_NONE ? "No" :
+			role == USB_ROLE_HOST ? "A" : "B");
+	}
 
 	if (hsotg->role_sw && !hsotg->params.external_id_pin_ctl) {
 		gintsts = dwc2_readl(hsotg, GINTSTS);
diff --git a/drivers/usb/dwc2/gadget.c b/drivers/usb/dwc2/gadget.c
index 519bb82b0..b171fac12 100644
--- a/drivers/usb/dwc2/gadget.c
+++ b/drivers/usb/dwc2/gadget.c
@@ -4988,6 +4988,7 @@ int dwc2_gadget_init(struct dwc2_hsotg *hsotg)
 
 	hsotg->gadget.ops = &dwc2_hsotg_gadget_ops;
 	hsotg->gadget.name = dev_name(dev);
+	hsotg->gadget.otg_caps = &hsotg->params.otg_caps;
 	hsotg->remote_wakeup_allowed = 0;
 
 	if (hsotg->params.lpm)
@@ -5670,7 +5671,6 @@ void dwc2_gadget_exit_clock_gating(struct dwc2_hsotg *hsotg, int rem_wakeup)
 	}
 
 	/* Change to L0 state */
-	call_gadget(hsotg, resume);
 	hsotg->lx_state = DWC2_L0;
 	hsotg->bus_suspended = false;
 }
diff --git a/drivers/usb/dwc2/hcd.c b/drivers/usb/dwc2/hcd.c
index 82322696b..c0dc708cc 100644
--- a/drivers/usb/dwc2/hcd.c
+++ b/drivers/usb/dwc2/hcd.c
@@ -138,19 +138,15 @@ static void dwc2_gusbcfg_init(struct dwc2_hsotg *hsotg)
 
 	switch (hsotg->hw_params.op_mode) {
 	case GHWCFG2_OP_MODE_HNP_SRP_CAPABLE:
-		if (hsotg->params.otg_cap ==
-				DWC2_CAP_PARAM_HNP_SRP_CAPABLE)
+		if (hsotg->params.otg_caps.hnp_support &&
+		    hsotg->params.otg_caps.srp_support)
 			usbcfg |= GUSBCFG_HNPCAP;
-		if (hsotg->params.otg_cap !=
-				DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE)
-			usbcfg |= GUSBCFG_SRPCAP;
-		break;
+		fallthrough;
 
 	case GHWCFG2_OP_MODE_SRP_ONLY_CAPABLE:
 	case GHWCFG2_OP_MODE_SRP_CAPABLE_DEVICE:
 	case GHWCFG2_OP_MODE_SRP_CAPABLE_HOST:
-		if (hsotg->params.otg_cap !=
-				DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE)
+		if (hsotg->params.otg_caps.srp_support)
 			usbcfg |= GUSBCFG_SRPCAP;
 		break;
 
@@ -1734,7 +1730,8 @@ static void dwc2_hcd_cleanup_channels(struct dwc2_hsotg *hsotg)
 		 * release_channel_ddma(), which is called from ep_disable when
 		 * device disconnects
 		 */
-		channel->qh = NULL;
+		if (hsotg->params.host_dma && hsotg->params.dma_desc_enable)
+			channel->qh = NULL;
 	}
 	/* All channels have been freed, mark them available */
 	if (hsotg->params.uframe_sched) {
@@ -3647,7 +3644,8 @@ static int dwc2_hcd_hub_control(struct dwc2_hsotg *hsotg, u16 typereq,
 		if (wvalue != USB_PORT_FEAT_TEST && (!windex || windex > 1))
 			goto error;
 
-		if (!hsotg->flags.b.port_connect_status) {
+		if (!hsotg->flags.b.port_connect_status &&
+		    !dwc2_is_host_mode(hsotg)) {
 			/*
 			 * The port is disconnected, which means the core is
 			 * either in device mode or it soon will be. Just
@@ -3749,6 +3747,7 @@ static int dwc2_hcd_hub_control(struct dwc2_hsotg *hsotg, u16 typereq,
 			hprt0 &= ~HPRT0_TSTCTL_MASK;
 			hprt0 |= (windex >> 8) << HPRT0_TSTCTL_SHIFT;
 			dwc2_writel(hsotg, hprt0, HPRT0);
+			hsotg->test_mode = windex >> 8;
 			break;
 
 		default:
@@ -4293,9 +4292,11 @@ static int _dwc2_hcd_start(struct usb_hcd *hcd)
 		return 0;	/* why 0 ?? */
 	}
 
+	hprt0 = dwc2_read_hprt0(hsotg);
+
 	dwc2_hcd_reinit(hsotg);
 
-	hprt0 = dwc2_read_hprt0(hsotg);
+	hprt0 ^= dwc2_read_hprt0(hsotg);
 	/* Has vbus power been turned on in dwc2_core_host_init ? */
 	if (hprt0 & HPRT0_PWR) {
 		/* Enable external vbus supply before resuming root hub */
@@ -4399,6 +4400,7 @@ static int _dwc2_hcd_suspend(struct usb_hcd *hcd)
 		clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
 		break;
 	case DWC2_POWER_DOWN_PARAM_NONE:
+		dwc2_disable_global_interrupts(hsotg);
 		/*
 		 * If not hibernation nor partial power down are supported,
 		 * clock gating is used to save power.
@@ -4414,10 +4416,6 @@ static int _dwc2_hcd_suspend(struct usb_hcd *hcd)
 		goto skip_power_saving;
 	}
 
-	spin_unlock_irqrestore(&hsotg->lock, flags);
-	dwc2_vbus_supply_exit(hsotg);
-	spin_lock_irqsave(&hsotg->lock, flags);
-
 	/* Ask phy to be suspended */
 	if (!IS_ERR_OR_NULL(hsotg->uphy)) {
 		spin_unlock_irqrestore(&hsotg->lock, flags);
@@ -4448,20 +4446,20 @@ static int _dwc2_hcd_resume(struct usb_hcd *hcd)
 	if (hsotg->lx_state != DWC2_L2)
 		goto unlock;
 
-	hprt0 = dwc2_read_hprt0(hsotg);
-
-	/*
-	 * Added port connection status checking which prevents exiting from
-	 * Partial Power Down mode from _dwc2_hcd_resume() if not in Partial
-	 * Power Down mode.
-	 */
-	if (hprt0 & HPRT0_CONNSTS) {
-		hsotg->lx_state = DWC2_L0;
-		goto unlock;
-	}
-
 	switch (hsotg->params.power_down) {
 	case DWC2_POWER_DOWN_PARAM_PARTIAL:
+		hprt0 = dwc2_read_hprt0(hsotg);
+
+		/*
+		 * Added port connection status checking which prevents exiting from
+		 * Partial Power Down mode from _dwc2_hcd_resume() if not in Partial
+		 * Power Down mode.
+		 */
+		if (hprt0 & HPRT0_CONNSTS) {
+			hsotg->lx_state = DWC2_L0;
+			goto unlock;
+		}
+
 		ret = dwc2_exit_partial_power_down(hsotg, 0, true);
 		if (ret)
 			dev_err(hsotg->dev,
@@ -4496,7 +4494,6 @@ static int _dwc2_hcd_resume(struct usb_hcd *hcd)
 		 * the global interrupts are disabled.
 		 */
 		dwc2_core_init(hsotg, false);
-		dwc2_enable_global_interrupts(hsotg);
 		dwc2_hcd_reinit(hsotg);
 		spin_lock_irqsave(&hsotg->lock, flags);
 
@@ -4505,15 +4502,14 @@ static int _dwc2_hcd_resume(struct usb_hcd *hcd)
 		 * since an interrupt may rise.
 		 */
 		set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+		dwc2_enable_global_interrupts(hsotg);
+
 		break;
 	default:
 		hsotg->lx_state = DWC2_L0;
 		goto unlock;
 	}
 
-	/* Change Root port status, as port status change occurred after resume.*/
-	hsotg->flags.b.port_suspend_change = 1;
-
 	/*
 	 * Enable power if not already done.
 	 * This must not be spinlocked since duration
@@ -4525,10 +4521,7 @@ static int _dwc2_hcd_resume(struct usb_hcd *hcd)
 		spin_lock_irqsave(&hsotg->lock, flags);
 	}
 
-	/* Enable external vbus supply after resuming the port. */
 	spin_unlock_irqrestore(&hsotg->lock, flags);
-	dwc2_vbus_supply_init(hsotg);
-
 	/* Wait for controller to correctly update D+/D- level */
 	usleep_range(3000, 5000);
 	spin_lock_irqsave(&hsotg->lock, flags);
diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 59e119345..d300ae3d9 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -36,6 +36,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
+#include <linux/usb/of.h>
 
 #include "core.h"
 
@@ -53,7 +54,8 @@ static void dwc2_set_his_params(struct dwc2_hsotg *hsotg)
 {
 	struct dwc2_core_params *p = &hsotg->params;
 
-	p->otg_cap = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
+	p->otg_caps.hnp_support = false;
+	p->otg_caps.srp_support = false;
 	p->speed = DWC2_SPEED_PARAM_HIGH;
 	p->host_rx_fifo_size = 512;
 	p->host_nperio_tx_fifo_size = 512;
@@ -84,7 +86,8 @@ static void dwc2_set_rk_params(struct dwc2_hsotg *hsotg)
 {
 	struct dwc2_core_params *p = &hsotg->params;
 
-	p->otg_cap = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
+	p->otg_caps.hnp_support = false;
+	p->otg_caps.srp_support = false;
 	p->host_rx_fifo_size = 525;
 	p->host_nperio_tx_fifo_size = 128;
 	p->host_perio_tx_fifo_size = 256;
@@ -97,7 +100,8 @@ static void dwc2_set_ltq_params(struct dwc2_hsotg *hsotg)
 {
 	struct dwc2_core_params *p = &hsotg->params;
 
-	p->otg_cap = 2;
+	p->otg_caps.hnp_support = false;
+	p->otg_caps.srp_support = false;
 	p->host_rx_fifo_size = 288;
 	p->host_nperio_tx_fifo_size = 128;
 	p->host_perio_tx_fifo_size = 96;
@@ -111,7 +115,8 @@ static void dwc2_set_amlogic_params(struct dwc2_hsotg *hsotg)
 {
 	struct dwc2_core_params *p = &hsotg->params;
 
-	p->otg_cap = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
+	p->otg_caps.hnp_support = false;
+	p->otg_caps.srp_support = false;
 	p->speed = DWC2_SPEED_PARAM_HIGH;
 	p->host_rx_fifo_size = 512;
 	p->host_nperio_tx_fifo_size = 500;
@@ -144,7 +149,8 @@ static void dwc2_set_stm32f4x9_fsotg_params(struct dwc2_hsotg *hsotg)
 {
 	struct dwc2_core_params *p = &hsotg->params;
 
-	p->otg_cap = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
+	p->otg_caps.hnp_support = false;
+	p->otg_caps.srp_support = false;
 	p->speed = DWC2_SPEED_PARAM_FULL;
 	p->host_rx_fifo_size = 128;
 	p->host_nperio_tx_fifo_size = 96;
@@ -168,7 +174,9 @@ static void dwc2_set_stm32mp15_fsotg_params(struct dwc2_hsotg *hsotg)
 {
 	struct dwc2_core_params *p = &hsotg->params;
 
-	p->otg_cap = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
+	p->otg_caps.hnp_support = false;
+	p->otg_caps.srp_support = false;
+	p->otg_caps.otg_rev = 0x200;
 	p->speed = DWC2_SPEED_PARAM_FULL;
 	p->host_rx_fifo_size = 128;
 	p->host_nperio_tx_fifo_size = 96;
@@ -188,7 +196,9 @@ static void dwc2_set_stm32mp15_hsotg_params(struct dwc2_hsotg *hsotg)
 {
 	struct dwc2_core_params *p = &hsotg->params;
 
-	p->otg_cap = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
+	p->otg_caps.hnp_support = false;
+	p->otg_caps.srp_support = false;
+	p->otg_caps.otg_rev = 0x200;
 	p->activate_stm_id_vb_detection = !device_property_read_bool(hsotg->dev, "usb-role-switch");
 	p->host_rx_fifo_size = 440;
 	p->host_nperio_tx_fifo_size = 256;
@@ -241,23 +251,22 @@ MODULE_DEVICE_TABLE(acpi, dwc2_acpi_match);
 
 static void dwc2_set_param_otg_cap(struct dwc2_hsotg *hsotg)
 {
-	u8 val;
-
 	switch (hsotg->hw_params.op_mode) {
 	case GHWCFG2_OP_MODE_HNP_SRP_CAPABLE:
-		val = DWC2_CAP_PARAM_HNP_SRP_CAPABLE;
+		hsotg->params.otg_caps.hnp_support = true;
+		hsotg->params.otg_caps.srp_support = true;
 		break;
 	case GHWCFG2_OP_MODE_SRP_ONLY_CAPABLE:
 	case GHWCFG2_OP_MODE_SRP_CAPABLE_DEVICE:
 	case GHWCFG2_OP_MODE_SRP_CAPABLE_HOST:
-		val = DWC2_CAP_PARAM_SRP_ONLY_CAPABLE;
+		hsotg->params.otg_caps.hnp_support = false;
+		hsotg->params.otg_caps.srp_support = true;
 		break;
 	default:
-		val = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
+		hsotg->params.otg_caps.hnp_support = false;
+		hsotg->params.otg_caps.srp_support = false;
 		break;
 	}
-
-	hsotg->params.otg_cap = val;
 }
 
 static void dwc2_set_param_phy_type(struct dwc2_hsotg *hsotg)
@@ -463,6 +472,8 @@ static void dwc2_get_device_properties(struct dwc2_hsotg *hsotg)
 						       &p->g_tx_fifo_size[1],
 						       num);
 		}
+
+		of_usb_update_otg_caps(hsotg->dev->of_node, &p->otg_caps);
 	}
 
 	if (of_find_property(hsotg->dev->of_node, "disable-over-current", NULL))
@@ -473,29 +484,27 @@ static void dwc2_check_param_otg_cap(struct dwc2_hsotg *hsotg)
 {
 	int valid = 1;
 
-	switch (hsotg->params.otg_cap) {
-	case DWC2_CAP_PARAM_HNP_SRP_CAPABLE:
+	if (hsotg->params.otg_caps.hnp_support && hsotg->params.otg_caps.srp_support) {
+		/* check HNP && SRP capable */
 		if (hsotg->hw_params.op_mode != GHWCFG2_OP_MODE_HNP_SRP_CAPABLE)
 			valid = 0;
-		break;
-	case DWC2_CAP_PARAM_SRP_ONLY_CAPABLE:
-		switch (hsotg->hw_params.op_mode) {
-		case GHWCFG2_OP_MODE_HNP_SRP_CAPABLE:
-		case GHWCFG2_OP_MODE_SRP_ONLY_CAPABLE:
-		case GHWCFG2_OP_MODE_SRP_CAPABLE_DEVICE:
-		case GHWCFG2_OP_MODE_SRP_CAPABLE_HOST:
-			break;
-		default:
-			valid = 0;
-			break;
+	} else if (!hsotg->params.otg_caps.hnp_support) {
+		/* check SRP only capable */
+		if (hsotg->params.otg_caps.srp_support) {
+			switch (hsotg->hw_params.op_mode) {
+			case GHWCFG2_OP_MODE_HNP_SRP_CAPABLE:
+			case GHWCFG2_OP_MODE_SRP_ONLY_CAPABLE:
+			case GHWCFG2_OP_MODE_SRP_CAPABLE_DEVICE:
+			case GHWCFG2_OP_MODE_SRP_CAPABLE_HOST:
+				break;
+			default:
+				valid = 0;
+				break;
+			}
 		}
-		break;
-	case DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE:
-		/* always valid */
-		break;
-	default:
+		/* else: NO HNP && NO SRP capable: always valid */
+	} else {
 		valid = 0;
-		break;
 	}
 
 	if (!valid)
diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 265d437ca..d16a69355 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -222,20 +222,16 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 	int i, ret;
 
 	hsotg->reset = devm_reset_control_get_optional(hsotg->dev, "dwc2");
-	if (IS_ERR(hsotg->reset)) {
-		ret = PTR_ERR(hsotg->reset);
-		dev_err(hsotg->dev, "error getting reset control %d\n", ret);
-		return ret;
-	}
+	if (IS_ERR(hsotg->reset))
+		return dev_err_probe(hsotg->dev, PTR_ERR(hsotg->reset),
+				     "error getting reset control\n");
 
 	reset_control_deassert(hsotg->reset);
 
 	hsotg->reset_ecc = devm_reset_control_get_optional(hsotg->dev, "dwc2-ecc");
-	if (IS_ERR(hsotg->reset_ecc)) {
-		ret = PTR_ERR(hsotg->reset_ecc);
-		dev_err(hsotg->dev, "error getting reset control for ecc %d\n", ret);
-		return ret;
-	}
+	if (IS_ERR(hsotg->reset_ecc))
+		return dev_err_probe(hsotg->dev, PTR_ERR(hsotg->reset_ecc),
+				     "error getting reset control for ecc\n");
 
 	reset_control_deassert(hsotg->reset_ecc);
 
@@ -251,11 +247,8 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 		case -ENOSYS:
 			hsotg->phy = NULL;
 			break;
-		case -EPROBE_DEFER:
-			return ret;
 		default:
-			dev_err(hsotg->dev, "error getting phy %d\n", ret);
-			return ret;
+			return dev_err_probe(hsotg->dev, ret, "error getting phy\n");
 		}
 	}
 
@@ -268,12 +261,8 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 			case -ENXIO:
 				hsotg->uphy = NULL;
 				break;
-			case -EPROBE_DEFER:
-				return ret;
 			default:
-				dev_err(hsotg->dev, "error getting usb phy %d\n",
-					ret);
-				return ret;
+				return dev_err_probe(hsotg->dev, ret, "error getting usb phy\n");
 			}
 		}
 	}
@@ -282,10 +271,8 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 
 	/* Clock */
 	hsotg->clk = devm_clk_get_optional(hsotg->dev, "otg");
-	if (IS_ERR(hsotg->clk)) {
-		dev_err(hsotg->dev, "cannot get otg clock\n");
-		return PTR_ERR(hsotg->clk);
-	}
+	if (IS_ERR(hsotg->clk))
+		return dev_err_probe(hsotg->dev, PTR_ERR(hsotg->clk), "cannot get otg clock\n");
 
 	/* Regulators */
 	for (i = 0; i < ARRAY_SIZE(hsotg->supplies); i++)
@@ -293,12 +280,9 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 
 	ret = devm_regulator_bulk_get(hsotg->dev, ARRAY_SIZE(hsotg->supplies),
 				      hsotg->supplies);
-	if (ret) {
-		if (ret != -EPROBE_DEFER)
-			dev_err(hsotg->dev, "failed to request supplies: %d\n",
-				ret);
-		return ret;
-	}
+	if (ret)
+		return dev_err_probe(hsotg->dev, ret, "failed to request supplies\n");
+
 	return 0;
 }
 
@@ -558,16 +542,12 @@ static int dwc2_driver_probe(struct platform_device *dev)
 		hsotg->usb33d = devm_regulator_get(hsotg->dev, "usb33d");
 		if (IS_ERR(hsotg->usb33d)) {
 			retval = PTR_ERR(hsotg->usb33d);
-			if (retval != -EPROBE_DEFER)
-				dev_err(hsotg->dev,
-					"failed to request usb33d supply: %d\n",
-					retval);
+			dev_err_probe(hsotg->dev, retval, "failed to request usb33d supply\n");
 			goto error;
 		}
 		retval = regulator_enable(hsotg->usb33d);
 		if (retval) {
-			dev_err(hsotg->dev,
-				"failed to enable usb33d supply: %d\n", retval);
+			dev_err_probe(hsotg->dev, retval, "failed to enable usb33d supply\n");
 			goto error;
 		}
 
@@ -582,8 +562,7 @@ static int dwc2_driver_probe(struct platform_device *dev)
 
 	retval = dwc2_drd_init(hsotg);
 	if (retval) {
-		if (retval != -EPROBE_DEFER)
-			dev_err(hsotg->dev, "failed to initialize dual-role\n");
+		dev_err_probe(hsotg->dev, retval, "failed to initialize dual-role\n");
 		goto error_init;
 	}
 
@@ -669,8 +648,19 @@ static int __maybe_unused dwc2_suspend(struct device *dev)
 	bool is_device_mode = dwc2_is_device_mode(dwc2);
 	int ret = 0;
 
-	if (is_device_mode)
+	if (is_device_mode) {
+		/*
+		 * Handle the case when bus has been suspended prior to platform suspend.
+		 * As the lx_state is DWC2_L2, dwc2_hsotg_suspend() is then a no-op.
+		 * So need to exit clock gating first, so the gadget can be suspended and
+		 * resumed later on.
+		 */
+		if (dwc2->params.power_down == DWC2_POWER_DOWN_PARAM_NONE &&
+		    dwc2->bus_suspended)
+			dwc2_gadget_exit_clock_gating(dwc2, 0);
+
 		dwc2_hsotg_suspend(dwc2);
+	}
 
 	dwc2_drd_suspend(dwc2);
 
@@ -711,6 +701,9 @@ static int __maybe_unused dwc2_suspend(struct device *dev)
 		dwc2->phy_off_for_suspend = true;
 	}
 
+	if (device_may_wakeup(dev) || device_wakeup_path(dev))
+		enable_irq_wake(dwc2->irq);
+
 	return ret;
 }
 
@@ -719,6 +712,9 @@ static int __maybe_unused dwc2_resume(struct device *dev)
 	struct dwc2_hsotg *dwc2 = dev_get_drvdata(dev);
 	int ret = 0;
 
+	if (device_may_wakeup(dev) || device_wakeup_path(dev))
+		disable_irq_wake(dwc2->irq);
+
 	if (dwc2->phy_off_for_suspend && dwc2->ll_hw_enabled) {
 		ret = __dwc2_lowlevel_hw_enable(dwc2);
 		if (ret)
@@ -751,10 +747,12 @@ static int __maybe_unused dwc2_resume(struct device *dev)
 		spin_unlock_irqrestore(&dwc2->lock, flags);
 	}
 
-	/* Need to restore FORCEDEVMODE/FORCEHOSTMODE */
-	dwc2_force_dr_mode(dwc2);
-
-	dwc2_drd_resume(dwc2);
+	if (!dwc2->role_sw) {
+		/* Need to restore FORCEDEVMODE/FORCEHOSTMODE */
+		dwc2_force_dr_mode(dwc2);
+	} else {
+		dwc2_drd_resume(dwc2);
+	}
 
 	if (dwc2_is_device_mode(dwc2))
 		ret = dwc2_hsotg_resume(dwc2);
diff --git a/drivers/usb/dwc3/Kconfig b/drivers/usb/dwc3/Kconfig
index 66b1454c4..40b9236a9 100644
--- a/drivers/usb/dwc3/Kconfig
+++ b/drivers/usb/dwc3/Kconfig
@@ -126,6 +126,17 @@ config USB_DWC3_ST
 	  inside (i.e. STiH407).
 	  Say 'Y' or 'M' if you have one such device.
 
+config USB_DWC3_STM32
+        tristate "STM32 DWC3 support"
+        depends on (ARCH_STM32 || COMPILE_TEST) && OF
+        default USB_DWC3
+        help
+          Support for DesignWare Core USB3 controller on STM32 SOCs.
+
+          This selects STM32 SoC glue layer support for the DWC3
+          device driver. This driver is used on for the STM32 series
+          SOCs DWC3 USB controller.
+
 config USB_DWC3_QCOM
 	tristate "Qualcomm Platform"
 	depends on ARCH_QCOM || COMPILE_TEST
diff --git a/drivers/usb/dwc3/Makefile b/drivers/usb/dwc3/Makefile
index 2d499de6f..3b475b60b 100644
--- a/drivers/usb/dwc3/Makefile
+++ b/drivers/usb/dwc3/Makefile
@@ -50,6 +50,7 @@ obj-$(CONFIG_USB_DWC3_KEYSTONE)		+= dwc3-keystone.o
 obj-$(CONFIG_USB_DWC3_MESON_G12A)	+= dwc3-meson-g12a.o
 obj-$(CONFIG_USB_DWC3_OF_SIMPLE)	+= dwc3-of-simple.o
 obj-$(CONFIG_USB_DWC3_ST)		+= dwc3-st.o
+obj-$(CONFIG_USB_DWC3_STM32)		+= dwc3-stm32.o
 obj-$(CONFIG_USB_DWC3_QCOM)		+= dwc3-qcom.o
 obj-$(CONFIG_USB_DWC3_IMX8MP)		+= dwc3-imx8mp.o
 obj-$(CONFIG_USB_DWC3_XILINX)		+= dwc3-xilinx.o
diff --git a/drivers/usb/dwc3/dwc3-stm32.c b/drivers/usb/dwc3/dwc3-stm32.c
new file mode 100644
index 000000000..86945c047
--- /dev/null
+++ b/drivers/usb/dwc3/dwc3-stm32.c
@@ -0,0 +1,197 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * dwc3-stm32.c - DWC3 Specific Glue layer for STM32
+ *
+ * Copyright (C) 2022 STMicroelectronics – All Rights Reserved
+ *
+ * Author: Pankaj Dev <pankaj.dev@st.com> for STMicroelectronics.
+ *
+ * Inspired by dwc3-st.c
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+#include <linux/usb/of.h>
+
+#include "core.h"
+#include "io.h"
+
+#define SYSCFG_USB3DRCR_OVRCUR_POLARITY_MASK     BIT(1)
+#define SYSCFG_USB3DRCR_VBUSEN_POLARITY_MASK     BIT(2)
+#define SYSCFG_USB3DRCR_USB2ONLYH_MASK           BIT(3)             // USB2-only Mode for Host
+#define SYSCFG_USB3DRCR_USB2ONLYD_MASK           BIT(4)             // USB2-only Mode for Device
+
+/**
+ * struct stm32_dwc3 - dwc3-stm32 driver private structure
+ * @dev:		device pointer
+ * @regmap:		regmap pointer for getting syscfg
+ * @syscfg_usb3drcr_reg_off:	usb3drcr syscfg control offset
+ * @usb2only_conf:	If only usb2-phy is present
+ * @vbusen_polarity_low:	vbusen signal polarity
+ * @ovrcur_polarity_low:	ovrcur signal polarity
+ */
+struct stm32_dwc3 {
+	struct device *dev;
+	struct regmap *regmap;
+	int syscfg_usb3drcr_reg_off;
+	bool usb2only_conf;
+	bool vbusen_polarity_low;
+	bool ovrcur_polarity_low;
+};
+
+/**
+ * stm32_dwc3_init: init the controller via glue logic
+ * @dwc3_data: driver private structure
+ */
+static int stm32_dwc3_init(struct stm32_dwc3 *dwc3_data)
+{
+	int err = 0;
+
+	if (dwc3_data->usb2only_conf) {
+		// set USB2-only mode for Device and Host
+		err = regmap_update_bits(dwc3_data->regmap, dwc3_data->syscfg_usb3drcr_reg_off,
+					 SYSCFG_USB3DRCR_USB2ONLYD_MASK |
+					 SYSCFG_USB3DRCR_USB2ONLYH_MASK,
+					 FIELD_PREP(SYSCFG_USB3DRCR_USB2ONLYD_MASK, 0x1) |
+					 FIELD_PREP(SYSCFG_USB3DRCR_USB2ONLYH_MASK, 0x1));
+		if (err)
+			return err;
+	}
+
+	return regmap_update_bits(dwc3_data->regmap, dwc3_data->syscfg_usb3drcr_reg_off,
+				  SYSCFG_USB3DRCR_OVRCUR_POLARITY_MASK |
+				  SYSCFG_USB3DRCR_OVRCUR_POLARITY_MASK,
+				  FIELD_PREP(SYSCFG_USB3DRCR_OVRCUR_POLARITY_MASK,
+					     dwc3_data->ovrcur_polarity_low) |
+				  FIELD_PREP(SYSCFG_USB3DRCR_VBUSEN_POLARITY_MASK,
+					     dwc3_data->vbusen_polarity_low));
+}
+
+static int stm32_dwc3_probe(struct platform_device *pdev)
+{
+	struct stm32_dwc3 *dwc3_data;
+	struct device *dev = &pdev->dev;
+	struct device_node *node = dev->of_node, *child;
+	struct regmap *regmap;
+	int ret;
+
+	dwc3_data = devm_kzalloc(dev, sizeof(*dwc3_data), GFP_KERNEL);
+	if (!dwc3_data)
+		return -ENOMEM;
+
+	regmap = syscon_regmap_lookup_by_phandle(node, "st,syscfg");
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	ret = of_property_read_u32_index(node, "st,syscfg", 1,
+					 &dwc3_data->syscfg_usb3drcr_reg_off);
+	if (ret) {
+		dev_err(dev, "can't get usb3drcr offset (%d)\n", ret);
+		return ret;
+	}
+	dev_vdbg(&pdev->dev, "syscfg-usb3drcr-reg offset 0x%x\n",
+		 dwc3_data->syscfg_usb3drcr_reg_off);
+
+	dwc3_data->dev = dev;
+	dwc3_data->regmap = regmap;
+
+	if (device_property_read_bool(dev, "st,vbusen-active-low"))
+		dwc3_data->vbusen_polarity_low = true;
+	if (device_property_read_bool(dev, "st,ovrcur-active-low"))
+		dwc3_data->ovrcur_polarity_low = true;
+
+	child = of_get_child_by_name(node, "usb");
+	if (!child)
+		return dev_err_probe(dev, -ENODEV, "failed to find dwc3 core node\n");
+
+	/* check if usb3-phy present, means NO usb2only mode */
+	dwc3_data->usb2only_conf = true;
+	if (of_count_phandle_with_args(child, "usb-phy", NULL) == 2) {
+		dwc3_data->usb2only_conf = false;
+	} else {
+		if (of_property_match_string(child, "phy-names", "usb3-phy") >= 0)
+			dwc3_data->usb2only_conf = false;
+	}
+
+	if (dwc3_data->usb2only_conf)
+		dev_info(&pdev->dev, "configured in usb2only mode\n");
+
+	of_node_put(child);
+
+	/* ST glue logic init */
+	ret = stm32_dwc3_init(dwc3_data);
+	if (ret)
+		return dev_err_probe(dev, ret, "dwc3 glue init failed\n");
+
+	/* Allocate and initialize the core */
+	ret = devm_of_platform_populate(dev);
+	if (ret)
+		return dev_err_probe(dev, ret, "failed to add dwc3 core\n");
+
+	platform_set_drvdata(pdev, dwc3_data);
+
+	return 0;
+}
+
+static int __maybe_unused stm32_dwc3_suspend(struct device *dev)
+{
+	return pinctrl_pm_select_sleep_state(dev);
+}
+
+static int __maybe_unused stm32_dwc3_resume(struct device *dev)
+{
+	struct stm32_dwc3 *dwc3_data = dev_get_drvdata(dev);
+	int ret;
+
+	ret = pinctrl_pm_select_default_state(dev);
+	if (ret) {
+		dev_err(dev, "pinctrl select during resume (%d)\n", ret);
+		return ret;
+	}
+
+	/* ST glue logic init */
+	ret = stm32_dwc3_init(dwc3_data);
+	if (ret) {
+		dev_err(dev, "err setting syscfg_usb3drcr_reg (%d)\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(stm32_dwc3_dev_pm_ops, stm32_dwc3_suspend, stm32_dwc3_resume);
+
+static const struct of_device_id stm32_dwc3_match[] = {
+	{ .compatible = "st,stm32mp25-dwc3" },
+	{ /* sentinel */ },
+};
+
+MODULE_DEVICE_TABLE(of, stm32_dwc3_match);
+
+static struct platform_driver stm32_dwc3_driver = {
+	.probe = stm32_dwc3_probe,
+	.driver = {
+		.name = "usb-stm32-dwc3",
+		.of_match_table = stm32_dwc3_match,
+		.pm = &stm32_dwc3_dev_pm_ops,
+	},
+};
+
+module_platform_driver(stm32_dwc3_driver);
+
+MODULE_AUTHOR("Pankaj Dev <pankaj.dev@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 DWC3 Specific Glue layer");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index c4736d1d0..98c147567 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -126,6 +126,19 @@ config USB_BRCMSTB
 	  Disabling this will keep the controllers and corresponding
 	  PHYs powered down.
 
+config USB_STM32_USB2H
+	tristate "STM32 USB2 Host Glue support"
+	depends on ARCH_STM32 || COMPILE_TEST
+	select USB_OHCI_HCD_PLATFORM if USB_OHCI_HCD
+	select USB_EHCI_HCD_PLATFORM if USB_EHCI_HCD
+	help
+	  Enables support for USB2 Host controller on STM32MP25, configures
+	  glue logic around EHCI and OHCI host controller handled via
+          ehci-platform.o and ohci-platform.o
+
+	  Disabling this will keep the controllers and corresponding
+	  PHYs powered down.
+
 config USB_EHCI_HCD
 	tristate "EHCI HCD (USB 2.0) support"
 	depends on HAS_DMA && HAS_IOMEM
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 171de4df5..6fa28cc64 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -85,3 +85,4 @@ obj-$(CONFIG_USB_HCD_BCMA)	+= bcma-hcd.o
 obj-$(CONFIG_USB_HCD_SSB)	+= ssb-hcd.o
 obj-$(CONFIG_USB_FOTG210_HCD)	+= fotg210-hcd.o
 obj-$(CONFIG_USB_MAX3421_HCD)	+= max3421-hcd.o
+obj-$(CONFIG_USB_STM32_USB2H)	+= usb2h-stm32.o
diff --git a/drivers/usb/host/ehci-platform.c b/drivers/usb/host/ehci-platform.c
index c3dc90627..92401d01d 100644
--- a/drivers/usb/host/ehci-platform.c
+++ b/drivers/usb/host/ehci-platform.c
@@ -35,6 +35,7 @@
 #include <linux/usb/hcd.h>
 #include <linux/usb/ehci_pdriver.h>
 #include <linux/usb/of.h>
+#include <linux/pm_wakeirq.h>
 
 #include "ehci.h"
 
@@ -375,7 +376,9 @@ static int ehci_platform_probe(struct platform_device *dev)
 	if (err)
 		goto err_power;
 
-	device_wakeup_enable(hcd->self.controller);
+	if (of_property_read_bool(dev->dev.of_node, "wakeup-source"))
+		device_set_wakeup_capable(hcd->self.controller, true);
+
 	device_enable_async_suspend(hcd->self.controller);
 	platform_set_drvdata(dev, hcd);
 
@@ -411,6 +414,9 @@ static int ehci_platform_remove(struct platform_device *dev)
 	if (priv->quirk_poll)
 		quirk_poll_end(priv);
 
+	if (of_property_read_bool(dev->dev.of_node, "wakeup-source"))
+		device_set_wakeup_capable(hcd->self.controller, false);
+
 	usb_remove_hcd(hcd);
 
 	if (pdata->power_off)
@@ -435,7 +441,7 @@ static int __maybe_unused ehci_platform_suspend(struct device *dev)
 	struct usb_ehci_pdata *pdata = dev_get_platdata(dev);
 	struct platform_device *pdev = to_platform_device(dev);
 	struct ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);
-	bool do_wakeup = device_may_wakeup(dev);
+	bool do_wakeup = device_may_wakeup(dev) || device_wakeup_path(dev);
 	int ret;
 
 	if (priv->quirk_poll)
@@ -448,6 +454,9 @@ static int __maybe_unused ehci_platform_suspend(struct device *dev)
 	if (pdata->power_suspend)
 		pdata->power_suspend(pdev);
 
+	if (do_wakeup)
+		enable_irq_wake(hcd->irq);
+
 	return ret;
 }
 
@@ -459,6 +468,9 @@ static int __maybe_unused ehci_platform_resume(struct device *dev)
 	struct ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);
 	struct device *companion_dev;
 
+	if (device_may_wakeup(dev) || device_wakeup_path(dev))
+		disable_irq_wake(hcd->irq);
+
 	if (pdata->power_on) {
 		int err = pdata->power_on(pdev);
 		if (err < 0)
diff --git a/drivers/usb/host/ohci-platform.c b/drivers/usb/host/ohci-platform.c
index 4a8456f12..f2e0c78cc 100644
--- a/drivers/usb/host/ohci-platform.c
+++ b/drivers/usb/host/ohci-platform.c
@@ -214,7 +214,8 @@ static int ohci_platform_probe(struct platform_device *dev)
 	if (err)
 		goto err_power;
 
-	device_wakeup_enable(hcd->self.controller);
+	if (of_property_read_bool(dev->dev.of_node, "wakeup-source"))
+		device_set_wakeup_capable(hcd->self.controller, true);
 
 	platform_set_drvdata(dev, hcd);
 
@@ -245,6 +246,9 @@ static int ohci_platform_remove(struct platform_device *dev)
 	struct ohci_platform_priv *priv = hcd_to_ohci_priv(hcd);
 	int clk;
 
+	if (of_property_read_bool(dev->dev.of_node, "wakeup-source"))
+		device_set_wakeup_capable(hcd->self.controller, false);
+
 	pm_runtime_get_sync(&dev->dev);
 	usb_remove_hcd(hcd);
 
@@ -273,7 +277,7 @@ static int ohci_platform_suspend(struct device *dev)
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
 	struct usb_ohci_pdata *pdata = dev->platform_data;
 	struct platform_device *pdev = to_platform_device(dev);
-	bool do_wakeup = device_may_wakeup(dev);
+	bool do_wakeup = device_may_wakeup(dev) || device_wakeup_path(dev);
 	int ret;
 
 	ret = ohci_suspend(hcd, do_wakeup);
@@ -283,6 +287,9 @@ static int ohci_platform_suspend(struct device *dev)
 	if (pdata->power_suspend)
 		pdata->power_suspend(pdev);
 
+	if (do_wakeup)
+		enable_irq_wake(hcd->irq);
+
 	return ret;
 }
 
@@ -292,6 +299,9 @@ static int ohci_platform_resume(struct device *dev)
 	struct usb_ohci_pdata *pdata = dev_get_platdata(dev);
 	struct platform_device *pdev = to_platform_device(dev);
 
+	if (device_may_wakeup(dev) || device_wakeup_path(dev))
+		disable_irq_wake(hcd->irq);
+
 	if (pdata->power_on) {
 		int err = pdata->power_on(pdev);
 		if (err < 0)
diff --git a/drivers/usb/host/usb2h-stm32.c b/drivers/usb/host/usb2h-stm32.c
new file mode 100644
index 000000000..b3868d079
--- /dev/null
+++ b/drivers/usb/host/usb2h-stm32.c
@@ -0,0 +1,154 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STM32 USB2 EHCI/OHCI (USBH) controller glue driver
+ *
+ * Copyright (C) 2022 STMicroelectronics – All Rights Reserved
+ *
+ * Author: Pankaj Dev <pankaj.dev@st.com>
+ */
+
+#include <linux/usb.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/regmap.h>
+
+#define SYSCFG_USBHCR_OVRCUR_POLARITY_MASK      BIT(0)
+#define SYSCFG_USBHCR_VBUSEN_POLARITY_MASK      BIT(1)
+
+/**
+ * struct stm32_usb2h - usb2h-stm32 driver private structure
+ * @dev:		device pointer
+ * @regmap:		regmap pointer for getting syscfg
+ * @syscfg_usbhcr_reg_off:	usbhcr syscfg control offset
+ * @vbusen_polarity_low:	vbusen signal polarity
+ * @ovrcur_polarity_low:	ovrcur signal polarity
+ */
+struct stm32_usb2h {
+	struct device *dev;
+	struct regmap *regmap;
+	int syscfg_usbhcr_reg_off;
+	bool vbusen_polarity_low;
+	bool ovrcur_polarity_low;
+};
+
+/**
+ * stm32_usb2h_init: init the controller via glue logic
+ * @usb2h_data: driver private structure
+ */
+static int stm32_usb2h_init(struct stm32_usb2h *usb2h_data)
+{
+	return regmap_update_bits(usb2h_data->regmap, usb2h_data->syscfg_usbhcr_reg_off,
+				  SYSCFG_USBHCR_OVRCUR_POLARITY_MASK |
+				  SYSCFG_USBHCR_OVRCUR_POLARITY_MASK,
+				  FIELD_PREP(SYSCFG_USBHCR_OVRCUR_POLARITY_MASK,
+					     usb2h_data->ovrcur_polarity_low) |
+				  FIELD_PREP(SYSCFG_USBHCR_VBUSEN_POLARITY_MASK,
+					     usb2h_data->vbusen_polarity_low));
+}
+
+static int stm32_usb2h_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *node = dev->of_node;
+	struct regmap *regmap;
+	struct stm32_usb2h *usb2h_data;
+	int ret;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	usb2h_data = devm_kzalloc(dev, sizeof(*usb2h_data), GFP_KERNEL);
+	if (!usb2h_data)
+		return -ENOMEM;
+
+	regmap = syscon_regmap_lookup_by_phandle(node, "st,syscfg");
+	if (IS_ERR(regmap))
+		return dev_err_probe(&pdev->dev, PTR_ERR(regmap), "no st,syscfg node found\n");
+
+	ret = of_property_read_u32_index(node, "st,syscfg", 1, &usb2h_data->syscfg_usbhcr_reg_off);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "can't get usbhcr offset\n");
+
+	dev_vdbg(&pdev->dev, "syscfg-usbhcr-reg offset 0x%x\n", usb2h_data->syscfg_usbhcr_reg_off);
+
+	usb2h_data->dev = dev;
+	usb2h_data->regmap = regmap;
+
+	if (device_property_read_bool(dev, "st,vbusen-active-low"))
+		usb2h_data->vbusen_polarity_low = true;
+	if (device_property_read_bool(dev, "st,ovrcur-active-low"))
+		usb2h_data->ovrcur_polarity_low = true;
+
+	/* ST USB2H glue logic init */
+	ret = stm32_usb2h_init(usb2h_data);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "err setting syscfg_usbhcr_reg\n");
+
+	/* Populate the ehci and ohci child nodes */
+	ret = devm_of_platform_populate(dev);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "failed to add ehci/ohci devices\n");
+
+	platform_set_drvdata(pdev, usb2h_data);
+
+	return 0;
+}
+
+static int __maybe_unused stm32_usb2h_suspend(struct device *dev)
+{
+	if (device_may_wakeup(dev) || device_wakeup_path(dev))
+		return 0;
+
+	return pinctrl_pm_select_sleep_state(dev);
+}
+
+static int __maybe_unused stm32_usb2h_resume(struct device *dev)
+{
+	struct stm32_usb2h *usb2h_data = dev_get_drvdata(dev);
+	int err;
+
+	if (device_may_wakeup(dev) || device_wakeup_path(dev))
+		return 0;
+
+	err = pinctrl_pm_select_default_state(dev);
+	if (err) {
+		dev_err(dev, "pinctrl select during resume error:%d\n", err);
+		return err;
+	}
+
+	/* ST USB2H glue logic init */
+	err = stm32_usb2h_init(usb2h_data);
+	if (err) {
+		dev_err(dev, "err setting syscfg_usbhcr_reg (%d)\n", err);
+		return err;
+	}
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(stm32_usb2h_pm_ops, stm32_usb2h_suspend, stm32_usb2h_resume);
+
+static const struct of_device_id stm32_usb2h_match[] = {
+	{ .compatible = "st,stm32mp25-usb2h" },
+	{ /* sentinel */ },
+};
+
+MODULE_DEVICE_TABLE(of, stm32_usb2h_match);
+
+static struct platform_driver stm32_usb2h_driver = {
+	.probe = stm32_usb2h_probe,
+	.driver = {
+		.name = "stm32-usb2h",
+		.of_match_table = stm32_usb2h_match,
+		.pm = &stm32_usb2h_pm_ops,
+	},
+};
+
+module_platform_driver(stm32_usb2h_driver);
+
+MODULE_AUTHOR("Pankaj Dev <pankaj.dev@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 EHCI/OHCI Specific Glue layer");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/usb/typec/ucsi/Kconfig b/drivers/usb/typec/ucsi/Kconfig
index 5e9b37b3f..8f9c4b9f3 100644
--- a/drivers/usb/typec/ucsi/Kconfig
+++ b/drivers/usb/typec/ucsi/Kconfig
@@ -48,4 +48,14 @@ config UCSI_ACPI
 	  To compile the driver as a module, choose M here: the module will be
 	  called ucsi_acpi
 
+config UCSI_STM32G0
+	tristate "UCSI Interface Driver for STM32G0"
+	depends on I2C
+	help
+	  This driver enables UCSI support on platforms that expose a STM32G0
+	  Type-C controller over I2C interface.
+
+	  To compile the driver as a module, choose M here: the module will be
+	  called ucsi_stm32g0.
+
 endif
diff --git a/drivers/usb/typec/ucsi/Makefile b/drivers/usb/typec/ucsi/Makefile
index 8a8eb5cb8..480d533d7 100644
--- a/drivers/usb/typec/ucsi/Makefile
+++ b/drivers/usb/typec/ucsi/Makefile
@@ -17,3 +17,4 @@ endif
 
 obj-$(CONFIG_UCSI_ACPI)			+= ucsi_acpi.o
 obj-$(CONFIG_UCSI_CCG)			+= ucsi_ccg.o
+obj-$(CONFIG_UCSI_STM32G0)		+= ucsi_stm32g0.o
diff --git a/drivers/usb/typec/ucsi/ucsi.c b/drivers/usb/typec/ucsi/ucsi.c
index 1f23eb543..9659819ca 100644
--- a/drivers/usb/typec/ucsi/ucsi.c
+++ b/drivers/usb/typec/ucsi/ucsi.c
@@ -205,8 +205,11 @@ void ucsi_altmode_update_active(struct ucsi_connector *con)
 	ret = ucsi_send_command(con->ucsi, command, &cur, sizeof(cur));
 	if (ret < 0) {
 		if (con->ucsi->version > 0x0100) {
-			dev_err(con->ucsi->dev,
-				"GET_CURRENT_CAM command failed\n");
+			if (ret != -EOPNOTSUPP)
+				dev_err(con->ucsi->dev,
+					"GET_CURRENT_CAM command failed %d\n", ret);
+			else
+				dev_dbg(con->ucsi->dev, "GET_CURRENT_CAM not supported\n");
 			return;
 		}
 		cur = 0xff;
@@ -1156,12 +1159,8 @@ static int ucsi_register_port(struct ucsi *ucsi, int index)
 		ucsi_port_psy_changed(con);
 	}
 
-	con->usb_role_sw = fwnode_usb_role_switch_get(cap->fwnode);
-	if (IS_ERR(con->usb_role_sw)) {
-		dev_err(ucsi->dev, "con%d: failed to get usb role switch\n",
-			con->num);
-		con->usb_role_sw = NULL;
-	}
+	if (index < ucsi->usb_role_sw_count)
+		con->usb_role_sw = ucsi->usb_role_sw[index];
 
 	/* Only notify USB controller if partner supports USB data */
 	if (!(UCSI_CONSTAT_PARTNER_FLAGS(con->status.flags) & UCSI_CONSTAT_PARTNER_FLAG_USB))
@@ -1345,7 +1344,9 @@ EXPORT_SYMBOL_GPL(ucsi_destroy);
  */
 int ucsi_register(struct ucsi *ucsi)
 {
-	int ret;
+	struct fwnode_handle *fwnode;
+	int i = 0, ret;
+	struct usb_role_switch **usb_role_sw;
 
 	ret = ucsi->ops->read(ucsi, UCSI_VERSION, &ucsi->version,
 			      sizeof(ucsi->version));
@@ -1355,6 +1356,33 @@ int ucsi_register(struct ucsi *ucsi)
 	if (!ucsi->version)
 		return -ENODEV;
 
+	ucsi->usb_role_sw_count = device_get_child_node_count(ucsi->dev);
+	if (ucsi->usb_role_sw_count) {
+
+		usb_role_sw = kcalloc(ucsi->usb_role_sw_count, sizeof(struct usb_role_switch *),
+				      GFP_KERNEL);
+		if (!usb_role_sw)
+			return -ENOMEM;
+
+		device_for_each_child_node(ucsi->dev, fwnode) {
+			fw_devlink_purge_absent_suppliers(fwnode);
+			usb_role_sw[i] = fwnode_usb_role_switch_get(fwnode);
+			fwnode_handle_put(fwnode);
+			if (IS_ERR(usb_role_sw[i])) {
+				ret = PTR_ERR(usb_role_sw[i]);
+				dev_err_probe(ucsi->dev, ret,
+					      "con%d: failed to get usb role switch\n", i);
+				if (ret == -EPROBE_DEFER)
+					return -EPROBE_DEFER;
+				else
+					usb_role_sw[i] = NULL;
+			}
+			i++;
+		}
+
+		ucsi->usb_role_sw = usb_role_sw;
+	}
+
 	queue_work(system_long_wq, &ucsi->work);
 
 	return 0;
@@ -1388,6 +1416,9 @@ void ucsi_unregister(struct ucsi *ucsi)
 	}
 
 	kfree(ucsi->connector);
+
+	if (ucsi->usb_role_sw_count)
+		kfree(ucsi->usb_role_sw);
 }
 EXPORT_SYMBOL_GPL(ucsi_unregister);
 
diff --git a/drivers/usb/typec/ucsi/ucsi.h b/drivers/usb/typec/ucsi/ucsi.h
index cee666790..26572e953 100644
--- a/drivers/usb/typec/ucsi/ucsi.h
+++ b/drivers/usb/typec/ucsi/ucsi.h
@@ -286,6 +286,8 @@ struct ucsi {
 
 	struct ucsi_capability cap;
 	struct ucsi_connector *connector;
+	struct usb_role_switch **usb_role_sw;
+	int usb_role_sw_count;
 
 	struct work_struct work;
 
diff --git a/drivers/usb/typec/ucsi/ucsi_stm32g0.c b/drivers/usb/typec/ucsi/ucsi_stm32g0.c
new file mode 100644
index 000000000..a107f2eb9
--- /dev/null
+++ b/drivers/usb/typec/ucsi/ucsi_stm32g0.c
@@ -0,0 +1,770 @@
+// SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause
+/*
+ * UCSI driver for STMicroelectronics STM32G0 Type-C controller
+ *
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ * Author: Fabrice Gasnier <fabrice.gasnier@foss.st.com>.
+ */
+
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <asm/unaligned.h>
+
+#include "ucsi.h"
+
+/* STM32G0 I2C bootloader addr: 0b1010001x (See AN2606) */
+#define STM32G0_I2C_BL_ADDR	(0xa2 >> 1)
+
+/* STM32G0 I2C bootloader max data size */
+#define STM32G0_I2C_BL_SZ	256
+
+/* STM32 I2C bootloader commands (See AN4221) */
+#define STM32_CMD_GVR		0x01	/* Gets the bootloader version */
+#define STM32_CMD_GVR_LEN	1
+#define STM32_CMD_RM		0x11	/* Reag memory */
+#define STM32_CMD_WM		0x31	/* Write memory */
+#define STM32_CMD_ADDR_LEN	5	/* Address len for go, mem write... */
+#define STM32_CMD_ERASE		0x44	/* Erase page, bank or all */
+#define STM32_CMD_ERASE_SPECIAL_LEN	3
+#define STM32_CMD_GLOBAL_MASS_ERASE	0xffff /* All-bank erase */
+
+/* STM32 I2C bootloader answer status */
+#define STM32G0_I2C_BL_ACK	0x79
+#define STM32G0_I2C_BL_NACK	0x1f
+#define STM32G0_I2C_BL_BUSY	0x76
+
+/* STM32G0 flash definitions */
+#define STM32G0_USER_OPTION_BYTES	0x1fff7800
+#define STM32G0_USER_OB_NBOOT0		BIT(26)
+#define STM32G0_USER_OB_NBOOT_SEL	BIT(24)
+#define STM32G0_USER_OB_BOOT_MAIN	(STM32G0_USER_OB_NBOOT0 | STM32G0_USER_OB_NBOOT_SEL)
+#define STM32G0_MAIN_MEM_ADDR		0x08000000
+
+/* STM32 Firmware definitions: additional commands */
+#define STM32G0_FW_GETVER	0x00	/* Gets the firmware version */
+#define STM32G0_FW_GETVER_LEN	4
+#define STM32G0_FW_RSTGOBL	0x21	/* Reset and go to bootloader */
+#define STM32G0_FW_KEYWORD	0xa56959a6
+
+/* ucsi_stm32g0_fw_info located at the end of the firmware */
+struct ucsi_stm32g0_fw_info {
+	u32 version;
+	u32 keyword;
+};
+
+struct ucsi_stm32g0 {
+	struct i2c_client *client;
+	struct i2c_client *i2c_bl;
+	bool in_bootloader;
+	u8 bl_version;
+	struct completion complete;
+	struct device *dev;
+	unsigned long flags;
+	const char *fw_name;
+	struct ucsi *ucsi;
+	bool suspended;
+	bool wakeup_event;
+};
+
+/*
+ * Bootloader commands helpers:
+ * - send command (2 bytes)
+ * - check ack
+ * Then either:
+ * - receive data
+ * - receive data + check ack
+ * - send data + check ack
+ * These operations depends on the command and have various length.
+ */
+static int ucsi_stm32g0_bl_check_ack(struct ucsi *ucsi)
+{
+	struct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);
+	struct i2c_client *client = g0->i2c_bl;
+	unsigned char ack;
+	struct i2c_msg msg[] = {
+		{
+			.addr	= client->addr,
+			.flags  = I2C_M_RD,
+			.len	= 1,
+			.buf	= &ack,
+		},
+	};
+	int ret;
+
+	ret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));
+	if (ret != ARRAY_SIZE(msg)) {
+		dev_err(g0->dev, "i2c bl ack (%02x), error: %d\n", client->addr, ret);
+
+		return ret < 0 ? ret : -EIO;
+	}
+
+	/* The 'ack' byte should contain bootloader answer: ack/nack/busy */
+	switch (ack) {
+	case STM32G0_I2C_BL_ACK:
+		return 0;
+	case STM32G0_I2C_BL_NACK:
+		return -ENOENT;
+	case STM32G0_I2C_BL_BUSY:
+		return -EBUSY;
+	default:
+		dev_err(g0->dev, "i2c bl ack (%02x), invalid byte: %02x\n",
+			client->addr, ack);
+		return -EINVAL;
+	}
+}
+
+static int ucsi_stm32g0_bl_cmd_check_ack(struct ucsi *ucsi, unsigned int cmd, bool check_ack)
+{
+	struct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);
+	struct i2c_client *client = g0->i2c_bl;
+	unsigned char buf[2];
+	struct i2c_msg msg[] = {
+		{
+			.addr	= client->addr,
+			.flags  = 0,
+			.len	= sizeof(buf),
+			.buf	= buf,
+		},
+	};
+	int ret;
+
+	/*
+	 * Send STM32 bootloader command format is two bytes:
+	 * - command code
+	 * - XOR'ed command code
+	 */
+	buf[0] = cmd;
+	buf[1] = cmd ^ 0xff;
+
+	ret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));
+	if (ret != ARRAY_SIZE(msg)) {
+		dev_dbg(g0->dev, "i2c bl cmd %d (%02x), error: %d\n", cmd, client->addr, ret);
+
+		return ret < 0 ? ret : -EIO;
+	}
+
+	if (check_ack)
+		return ucsi_stm32g0_bl_check_ack(ucsi);
+
+	return 0;
+}
+
+static int ucsi_stm32g0_bl_cmd(struct ucsi *ucsi, unsigned int cmd)
+{
+	return ucsi_stm32g0_bl_cmd_check_ack(ucsi, cmd, true);
+}
+
+static int ucsi_stm32g0_bl_rcv_check_ack(struct ucsi *ucsi, void *data, size_t len, bool check_ack)
+{
+	struct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);
+	struct i2c_client *client = g0->i2c_bl;
+	struct i2c_msg msg[] = {
+		{
+			.addr	= client->addr,
+			.flags  = I2C_M_RD,
+			.len	= len,
+			.buf	= data,
+		},
+	};
+	int ret;
+
+	ret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));
+	if (ret != ARRAY_SIZE(msg)) {
+		dev_err(g0->dev, "i2c bl rcv %02x, error: %d\n", client->addr, ret);
+
+		return ret < 0 ? ret : -EIO;
+	}
+
+	if (check_ack)
+		return ucsi_stm32g0_bl_check_ack(ucsi);
+
+	return 0;
+}
+
+static int ucsi_stm32g0_bl_rcv(struct ucsi *ucsi, void *data, size_t len)
+{
+	return ucsi_stm32g0_bl_rcv_check_ack(ucsi, data, len, true);
+}
+
+static int ucsi_stm32g0_bl_rcv_woack(struct ucsi *ucsi, void *data, size_t len)
+{
+	return ucsi_stm32g0_bl_rcv_check_ack(ucsi, data, len, false);
+}
+
+static int ucsi_stm32g0_bl_send(struct ucsi *ucsi, void *data, size_t len)
+{
+	struct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);
+	struct i2c_client *client = g0->i2c_bl;
+	struct i2c_msg msg[] = {
+		{
+			.addr	= client->addr,
+			.flags  = 0,
+			.len	= len,
+			.buf	= data,
+		},
+	};
+	int ret;
+
+	ret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));
+	if (ret != ARRAY_SIZE(msg)) {
+		dev_err(g0->dev, "i2c bl send %02x, error: %d\n", client->addr, ret);
+
+		return ret < 0 ? ret : -EIO;
+	}
+
+	return ucsi_stm32g0_bl_check_ack(ucsi);
+}
+
+/* Bootloader commands */
+static int ucsi_stm32g0_bl_get_version(struct ucsi *ucsi, u8 *bl_version)
+{
+	int ret;
+
+	ret = ucsi_stm32g0_bl_cmd(ucsi, STM32_CMD_GVR);
+	if (ret)
+		return ret;
+
+	return ucsi_stm32g0_bl_rcv(ucsi, bl_version, STM32_CMD_GVR_LEN);
+}
+
+static int ucsi_stm32g0_bl_send_addr(struct ucsi *ucsi, u32 addr)
+{
+	u8 data8[STM32_CMD_ADDR_LEN];
+
+	/* Address format: 4 bytes addr (MSB first) + XOR'ed addr bytes */
+	put_unaligned_be32(addr, data8);
+	data8[4] = data8[0] ^ data8[1] ^ data8[2] ^ data8[3];
+
+	return ucsi_stm32g0_bl_send(ucsi, data8, STM32_CMD_ADDR_LEN);
+}
+
+static int ucsi_stm32g0_bl_global_mass_erase(struct ucsi *ucsi)
+{
+	u8 data8[4];
+	u16 *data16 = (u16 *)&data8[0];
+	int ret;
+
+	data16[0] = STM32_CMD_GLOBAL_MASS_ERASE;
+	data8[2] = data8[0] ^ data8[1];
+
+	ret = ucsi_stm32g0_bl_cmd(ucsi, STM32_CMD_ERASE);
+	if (ret)
+		return ret;
+
+	return ucsi_stm32g0_bl_send(ucsi, data8, STM32_CMD_ERASE_SPECIAL_LEN);
+}
+
+static int ucsi_stm32g0_bl_write(struct ucsi *ucsi, u32 addr, const void *data, size_t len)
+{
+	u8 *data8;
+	int i, ret;
+
+	if (!len || len > STM32G0_I2C_BL_SZ)
+		return -EINVAL;
+
+	/* Write memory: len bytes -1, data up to 256 bytes + XOR'ed bytes */
+	data8 = kzalloc(STM32G0_I2C_BL_SZ + 2, GFP_KERNEL);
+	if (!data8)
+		return -ENOMEM;
+
+	ret = ucsi_stm32g0_bl_cmd(ucsi, STM32_CMD_WM);
+	if (ret)
+		goto free;
+
+	ret = ucsi_stm32g0_bl_send_addr(ucsi, addr);
+	if (ret)
+		goto free;
+
+	data8[0] = len - 1;
+	memcpy(data8 + 1, data, len);
+	data8[len + 1] = data8[0];
+	for (i = 1; i <= len; i++)
+		data8[len + 1] ^= data8[i];
+
+	ret = ucsi_stm32g0_bl_send(ucsi, data8, len + 2);
+free:
+	kfree(data8);
+
+	return ret;
+}
+
+static int ucsi_stm32g0_bl_read(struct ucsi *ucsi, u32 addr, void *data, size_t len)
+{
+	int ret;
+
+	if (!len || len > STM32G0_I2C_BL_SZ)
+		return -EINVAL;
+
+	ret = ucsi_stm32g0_bl_cmd(ucsi, STM32_CMD_RM);
+	if (ret)
+		return ret;
+
+	ret = ucsi_stm32g0_bl_send_addr(ucsi, addr);
+	if (ret)
+		return ret;
+
+	ret = ucsi_stm32g0_bl_cmd(ucsi, len - 1);
+	if (ret)
+		return ret;
+
+	return ucsi_stm32g0_bl_rcv_woack(ucsi, data, len);
+}
+
+/* Firmware commands (the same address as the bootloader) */
+static int ucsi_stm32g0_fw_cmd(struct ucsi *ucsi, unsigned int cmd)
+{
+	return ucsi_stm32g0_bl_cmd_check_ack(ucsi, cmd, false);
+}
+
+static int ucsi_stm32g0_fw_rcv(struct ucsi *ucsi, void *data, size_t len)
+{
+	return ucsi_stm32g0_bl_rcv_woack(ucsi, data, len);
+}
+
+/* UCSI ops */
+static int ucsi_stm32g0_read(struct ucsi *ucsi, unsigned int offset, void *val, size_t len)
+{
+	struct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);
+	struct i2c_client *client = g0->client;
+	u8 reg = offset;
+	struct i2c_msg msg[] = {
+		{
+			.addr	= client->addr,
+			.flags  = 0,
+			.len	= 1,
+			.buf	= &reg,
+		},
+		{
+			.addr	= client->addr,
+			.flags  = I2C_M_RD,
+			.len	= len,
+			.buf	= val,
+		},
+	};
+	int ret;
+
+	ret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));
+	if (ret != ARRAY_SIZE(msg)) {
+		dev_err(g0->dev, "i2c read %02x, %02x error: %d\n", client->addr, reg, ret);
+
+		return ret < 0 ? ret : -EIO;
+	}
+
+	return 0;
+}
+
+static int ucsi_stm32g0_async_write(struct ucsi *ucsi, unsigned int offset, const void *val,
+				    size_t len)
+{
+	struct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);
+	struct i2c_client *client = g0->client;
+	struct i2c_msg msg[] = {
+		{
+			.addr	= client->addr,
+			.flags  = 0,
+		}
+	};
+	unsigned char *buf;
+	int ret;
+
+	buf = kzalloc(len + 1, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	buf[0] = offset;
+	memcpy(&buf[1], val, len);
+	msg[0].len = len + 1;
+	msg[0].buf = buf;
+
+	ret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));
+	kfree(buf);
+	if (ret != ARRAY_SIZE(msg)) {
+		dev_err(g0->dev, "i2c write %02x, %02x error: %d\n", client->addr, buf[0], ret);
+
+		return ret < 0 ? ret : -EIO;
+	}
+
+	return 0;
+}
+
+static int ucsi_stm32g0_sync_write(struct ucsi *ucsi, unsigned int offset, const void *val,
+				   size_t len)
+{
+	struct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);
+	int ret;
+
+	set_bit(COMMAND_PENDING, &g0->flags);
+
+	ret = ucsi_stm32g0_async_write(ucsi, offset, val, len);
+	if (ret)
+		goto out_clear_bit;
+
+	if (!wait_for_completion_timeout(&g0->complete, msecs_to_jiffies(5000)))
+		ret = -ETIMEDOUT;
+
+out_clear_bit:
+	clear_bit(COMMAND_PENDING, &g0->flags);
+
+	return ret;
+}
+
+static irqreturn_t ucsi_stm32g0_irq_handler(int irq, void *data)
+{
+	struct ucsi_stm32g0 *g0 = data;
+	u32 cci;
+	int ret;
+
+	if (g0->suspended)
+		g0->wakeup_event = true;
+
+	ret = ucsi_stm32g0_read(g0->ucsi, UCSI_CCI, &cci, sizeof(cci));
+	if (ret)
+		return IRQ_NONE;
+
+	if (UCSI_CCI_CONNECTOR(cci))
+		ucsi_connector_change(g0->ucsi, UCSI_CCI_CONNECTOR(cci));
+
+	if (test_bit(COMMAND_PENDING, &g0->flags) &&
+	    cci & (UCSI_CCI_ACK_COMPLETE | UCSI_CCI_COMMAND_COMPLETE))
+		complete(&g0->complete);
+
+	return IRQ_HANDLED;
+}
+
+static const struct ucsi_operations ucsi_stm32g0_ops = {
+	.read = ucsi_stm32g0_read,
+	.sync_write = ucsi_stm32g0_sync_write,
+	.async_write = ucsi_stm32g0_async_write,
+};
+
+static int ucsi_stm32g0_register(struct ucsi *ucsi)
+{
+	struct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);
+	struct i2c_client *client = g0->client;
+	int ret;
+
+	/* Request alert interrupt */
+	ret = request_threaded_irq(client->irq, NULL, ucsi_stm32g0_irq_handler, IRQF_ONESHOT,
+				   dev_name(g0->dev), g0);
+	if (ret) {
+		dev_err(g0->dev, "request IRQ failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = ucsi_register(ucsi);
+	if (ret) {
+		dev_err_probe(g0->dev, ret, "ucsi_register failed\n");
+		free_irq(client->irq, g0);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void ucsi_stm32g0_unregister(struct ucsi *ucsi)
+{
+	struct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);
+	struct i2c_client *client = g0->client;
+
+	ucsi_unregister(ucsi);
+	free_irq(client->irq, g0);
+}
+
+static void ucsi_stm32g0_fw_cb(const struct firmware *fw, void *context)
+{
+	struct ucsi_stm32g0 *g0;
+	const u8 *data, *end;
+	const struct ucsi_stm32g0_fw_info *fw_info;
+	u32 addr = STM32G0_MAIN_MEM_ADDR, ob, fw_version;
+	int ret, size;
+
+	if (!context)
+		return;
+
+	g0 = ucsi_get_drvdata(context);
+
+	if (!fw)
+		goto fw_release;
+
+	fw_info = (struct ucsi_stm32g0_fw_info *)(fw->data + fw->size - sizeof(*fw_info));
+
+	if (!g0->in_bootloader) {
+		/* Read running firmware version */
+		ret = ucsi_stm32g0_fw_cmd(g0->ucsi, STM32G0_FW_GETVER);
+		if (ret) {
+			dev_err(g0->dev, "Get version cmd failed %d\n", ret);
+			goto fw_release;
+		}
+		ret = ucsi_stm32g0_fw_rcv(g0->ucsi, &fw_version,
+					  STM32G0_FW_GETVER_LEN);
+		if (ret) {
+			dev_err(g0->dev, "Get version failed %d\n", ret);
+			goto fw_release;
+		}
+
+		/* Sanity check on keyword and firmware version */
+		if (fw_info->keyword != STM32G0_FW_KEYWORD || fw_info->version == fw_version)
+			goto fw_release;
+
+		dev_info(g0->dev, "Flashing FW: %08x (%08x cur)\n", fw_info->version, fw_version);
+
+		/* Switch to bootloader mode */
+		ucsi_stm32g0_unregister(g0->ucsi);
+		ret = ucsi_stm32g0_fw_cmd(g0->ucsi, STM32G0_FW_RSTGOBL);
+		if (ret) {
+			dev_err(g0->dev, "bootloader cmd failed %d\n", ret);
+			goto fw_release;
+		}
+		g0->in_bootloader = true;
+
+		/* STM32G0 reboot delay */
+		msleep(100);
+	}
+
+	ret = ucsi_stm32g0_bl_global_mass_erase(g0->ucsi);
+	if (ret) {
+		dev_err(g0->dev, "Erase failed %d\n", ret);
+		goto fw_release;
+	}
+
+	data = fw->data;
+	end = fw->data + fw->size;
+	while (data < end) {
+		if ((end - data) < STM32G0_I2C_BL_SZ)
+			size = end - data;
+		else
+			size = STM32G0_I2C_BL_SZ;
+
+		ret = ucsi_stm32g0_bl_write(g0->ucsi, addr, data, size);
+		if (ret) {
+			dev_err(g0->dev, "Write failed %d\n", ret);
+			goto fw_release;
+		}
+		addr += size;
+		data += size;
+	}
+
+	dev_dbg(g0->dev, "Configure to boot from main flash\n");
+
+	ret = ucsi_stm32g0_bl_read(g0->ucsi, STM32G0_USER_OPTION_BYTES, &ob, sizeof(ob));
+	if (ret) {
+		dev_err(g0->dev, "read user option bytes failed %d\n", ret);
+		goto fw_release;
+	}
+
+	dev_dbg(g0->dev, "STM32G0_USER_OPTION_BYTES 0x%08x\n", ob);
+
+	/* Configure user option bytes to boot from main flash next time */
+	ob |= STM32G0_USER_OB_BOOT_MAIN;
+
+	/* Writing option bytes will also reset G0 for updates to be loaded */
+	ret = ucsi_stm32g0_bl_write(g0->ucsi, STM32G0_USER_OPTION_BYTES, &ob, sizeof(ob));
+	if (ret) {
+		dev_err(g0->dev, "write user option bytes failed %d\n", ret);
+		goto fw_release;
+	}
+
+	dev_info(g0->dev, "Starting, option bytes:0x%08x\n", ob);
+
+	/* STM32G0 FW boot delay */
+	msleep(500);
+
+	/* Register UCSI interface */
+	if (!ucsi_stm32g0_register(g0->ucsi))
+		g0->in_bootloader = false;
+
+fw_release:
+	release_firmware(fw);
+}
+
+static int ucsi_stm32g0_probe_bootloader(struct ucsi *ucsi)
+{
+	struct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);
+	int ret;
+	u16 ucsi_version;
+
+	/*
+	 * Try to guess if the STM32G0 is running a UCSI firmware. Probe first the UCSI FW at its
+	 * specified i2c address.
+	 */
+	ret = ucsi_stm32g0_read(ucsi, UCSI_VERSION, &ucsi_version, sizeof(ucsi_version));
+	if (!ret)
+		return 0;
+
+	/* Speculatively read the bootloader version that has a known length. */
+	ret = ucsi_stm32g0_bl_get_version(ucsi, &g0->bl_version);
+	if (ret < 0)
+		return ret;
+
+	/* Device in bootloader mode */
+	g0->in_bootloader = true;
+	dev_info(g0->dev, "Bootloader Version 0x%02x\n", g0->bl_version);
+
+	return 0;
+}
+
+static int ucsi_stm32g0_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct ucsi_stm32g0 *g0;
+	int ret;
+
+	g0 = devm_kzalloc(dev, sizeof(*g0), GFP_KERNEL);
+	if (!g0)
+		return -ENOMEM;
+
+	g0->dev = dev;
+	g0->client = client;
+	init_completion(&g0->complete);
+	i2c_set_clientdata(client, g0);
+
+	g0->ucsi = ucsi_create(dev, &ucsi_stm32g0_ops);
+	if (IS_ERR(g0->ucsi))
+		return PTR_ERR(g0->ucsi);
+
+	ucsi_set_drvdata(g0->ucsi, g0);
+
+	/* STM32G0 in bootloader mode communicates at reserved address 0x51 */
+	g0->i2c_bl = i2c_new_dummy_device(client->adapter, STM32G0_I2C_BL_ADDR);
+	if (IS_ERR(g0->i2c_bl)) {
+		ret = dev_err_probe(dev, PTR_ERR(g0->i2c_bl), "Failed to register booloader I2C\n");
+		goto destroy;
+	}
+
+	ret = ucsi_stm32g0_probe_bootloader(g0->ucsi);
+	if (ret < 0)
+		goto freei2c;
+
+	/*
+	 * Don't register in bootloader mode: wait for the firmware to be loaded and started before
+	 * registering UCSI device.
+	 */
+	if (!g0->in_bootloader) {
+		ret = ucsi_stm32g0_register(g0->ucsi);
+		if (ret < 0)
+			goto freei2c;
+	}
+
+	ret = of_property_read_string(dev->of_node, "firmware-name", &g0->fw_name);
+	if (ret) {
+		/* firmware-name is optional, but report an error when found in bootloader mode */
+		if (g0->in_bootloader) {
+			dev_err_probe(dev, ret, "firmware-name not specified\n");
+			goto freei2c;
+		}
+	} else {
+		/*
+		 * Asynchronously flash (e.g. bootloader mode) or update the running firmware,
+		 * not to hang the boot process
+		 */
+		ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_UEVENT, g0->fw_name, g0->dev,
+					      GFP_KERNEL, g0->ucsi, ucsi_stm32g0_fw_cb);
+		if (ret < 0) {
+			dev_err_probe(dev, ret, "firmware request failed\n");
+			goto unregister;
+		}
+	}
+
+	return 0;
+
+unregister:
+	if (!g0->in_bootloader)
+		ucsi_stm32g0_unregister(g0->ucsi);
+freei2c:
+	i2c_unregister_device(g0->i2c_bl);
+destroy:
+	ucsi_destroy(g0->ucsi);
+
+	return ret;
+}
+
+static int ucsi_stm32g0_remove(struct i2c_client *client)
+{
+	struct ucsi_stm32g0 *g0 = i2c_get_clientdata(client);
+
+	if (!g0->in_bootloader)
+		ucsi_stm32g0_unregister(g0->ucsi);
+	i2c_unregister_device(g0->i2c_bl);
+	ucsi_destroy(g0->ucsi);
+
+	return 0;
+}
+
+static int __maybe_unused ucsi_stm32g0_suspend(struct device *dev)
+{
+	struct ucsi_stm32g0 *g0 = dev_get_drvdata(dev);
+	struct i2c_client *client = g0->client;
+
+	if (g0->in_bootloader)
+		return 0;
+
+	/* Keep the interrupt disabled until the i2c bus has been resumed */
+	disable_irq(client->irq);
+
+	g0->suspended = true;
+	g0->wakeup_event = false;
+
+	if (device_may_wakeup(dev) || device_wakeup_path(dev))
+		enable_irq_wake(client->irq);
+
+	return 0;
+}
+
+static int __maybe_unused ucsi_stm32g0_resume(struct device *dev)
+{
+	struct ucsi_stm32g0 *g0 = dev_get_drvdata(dev);
+	struct i2c_client *client = g0->client;
+
+	if (g0->in_bootloader)
+		return 0;
+
+	if (device_may_wakeup(dev) || device_wakeup_path(dev))
+		disable_irq_wake(client->irq);
+
+	enable_irq(client->irq);
+
+	/* Enforce any pending handler gets called to signal a wakeup_event */
+	synchronize_irq(client->irq);
+
+	if (g0->wakeup_event)
+		pm_wakeup_event(g0->dev, 0);
+
+	g0->suspended = false;
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(ucsi_stm32g0_pm_ops, ucsi_stm32g0_suspend, ucsi_stm32g0_resume);
+
+static const struct of_device_id __maybe_unused ucsi_stm32g0_typec_of_match[] = {
+	{ .compatible = "st,stm32g0-typec" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ucsi_stm32g0_typec_of_match);
+
+static const struct i2c_device_id ucsi_stm32g0_typec_i2c_devid[] = {
+	{"stm32g0-typec", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, ucsi_stm32g0_typec_i2c_devid);
+
+static struct i2c_driver ucsi_stm32g0_i2c_driver = {
+	.driver = {
+		.name = "ucsi-stm32g0-i2c",
+		.of_match_table = of_match_ptr(ucsi_stm32g0_typec_of_match),
+		.pm = &ucsi_stm32g0_pm_ops,
+	},
+	.probe = ucsi_stm32g0_probe,
+	.remove = ucsi_stm32g0_remove,
+	.id_table = ucsi_stm32g0_typec_i2c_devid
+};
+module_i2c_driver(ucsi_stm32g0_i2c_driver);
+
+MODULE_AUTHOR("Fabrice Gasnier <fabrice.gasnier@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32G0 Type-C controller");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:ucsi-stm32g0");
diff --git a/drivers/video/backlight/gpio_backlight.c b/drivers/video/backlight/gpio_backlight.c
index 6f78d928f..d3fa3a8be 100644
--- a/drivers/video/backlight/gpio_backlight.c
+++ b/drivers/video/backlight/gpio_backlight.c
@@ -53,6 +53,7 @@ static int gpio_backlight_probe(struct platform_device *pdev)
 	struct backlight_device *bl;
 	struct gpio_backlight *gbl;
 	int ret, init_brightness, def_value;
+	u32 value;
 
 	gbl = devm_kzalloc(dev, sizeof(*gbl), GFP_KERNEL);
 	if (gbl == NULL)
@@ -93,7 +94,11 @@ static int gpio_backlight_probe(struct platform_device *pdev)
 	else
 		bl->props.power = FB_BLANK_UNBLANK;
 
-	bl->props.brightness = 1;
+	ret = device_property_read_u32(dev, "default-brightness-level", &value);
+	if (!ret && value <= props.max_brightness)
+		bl->props.brightness = value;
+	else
+		bl->props.brightness = 1;
 
 	init_brightness = backlight_get_brightness(bl);
 	ret = gpiod_direction_output(gbl->gpiod, init_brightness);
diff --git a/drivers/video/fbdev/simplefb.c b/drivers/video/fbdev/simplefb.c
index a2e3a4690..efce6ef85 100644
--- a/drivers/video/fbdev/simplefb.c
+++ b/drivers/video/fbdev/simplefb.c
@@ -547,26 +547,7 @@ static struct platform_driver simplefb_driver = {
 	.remove = simplefb_remove,
 };
 
-static int __init simplefb_init(void)
-{
-	int ret;
-	struct device_node *np;
-
-	ret = platform_driver_register(&simplefb_driver);
-	if (ret)
-		return ret;
-
-	if (IS_ENABLED(CONFIG_OF_ADDRESS) && of_chosen) {
-		for_each_child_of_node(of_chosen, np) {
-			if (of_device_is_compatible(np, "simple-framebuffer"))
-				of_platform_device_create(np, NULL, NULL);
-		}
-	}
-
-	return 0;
-}
-
-fs_initcall(simplefb_init);
+module_platform_driver(simplefb_driver);
 
 MODULE_AUTHOR("Stephen Warren <swarren@wwwdotorg.org>");
 MODULE_DESCRIPTION("Simple framebuffer driver");
diff --git a/include/drm/bridge/dw_mipi_dsi.h b/include/drm/bridge/dw_mipi_dsi.h
index bda8aa7c2..5286a53a1 100644
--- a/include/drm/bridge/dw_mipi_dsi.h
+++ b/include/drm/bridge/dw_mipi_dsi.h
@@ -51,7 +51,9 @@ struct dw_mipi_dsi_plat_data {
 	unsigned int max_data_lanes;
 
 	enum drm_mode_status (*mode_valid)(void *priv_data,
-					   const struct drm_display_mode *mode);
+					   const struct drm_display_mode *mode,
+					   unsigned long mode_flags,
+					   u32 lanes, u32 format);
 
 	const struct dw_mipi_dsi_phy_ops *phy_ops;
 	const struct dw_mipi_dsi_host_ops *host_ops;
diff --git a/include/drm/drm_connector.h b/include/drm/drm_connector.h
index 1f43d7c67..ea40115df 100644
--- a/include/drm/drm_connector.h
+++ b/include/drm/drm_connector.h
@@ -749,6 +749,12 @@ struct drm_connector_state {
 	 */
 	unsigned int scaling_mode;
 
+	/**
+	 * @dithering: Connector property to control the
+	 * dithering.
+	 */
+	unsigned int dithering;
+
 	/**
 	 * @content_protection: Connector property to request content
 	 * protection. This is most commonly used for HDCP.
@@ -1360,6 +1366,12 @@ struct drm_connector {
 	 */
 	struct drm_property *scaling_mode_property;
 
+	/**
+	 * @dithering_property: Optional atomic property to control the
+	 * dithering.
+	 */
+	struct drm_property *dithering_property;
+
 	/**
 	 * @vrr_capable_property: Optional property to help userspace
 	 * query hardware support for variable refresh rate on a connector.
@@ -1680,6 +1692,8 @@ int drm_mode_create_scaling_mode_property(struct drm_device *dev);
 int drm_connector_attach_content_type_property(struct drm_connector *dev);
 int drm_connector_attach_scaling_mode_property(struct drm_connector *connector,
 					       u32 scaling_mode_mask);
+int drm_connector_attach_dithering_property(struct drm_connector *connector,
+					    u32 dithering_mask);
 int drm_connector_attach_vrr_capable_property(
 		struct drm_connector *connector);
 int drm_connector_attach_colorspace_property(struct drm_connector *connector);
diff --git a/include/dt-bindings/clock/stm32mp1-clks.h b/include/dt-bindings/clock/stm32mp1-clks.h
index e02770b98..2e23e0384 100644
--- a/include/dt-bindings/clock/stm32mp1-clks.h
+++ b/include/dt-bindings/clock/stm32mp1-clks.h
@@ -179,6 +179,12 @@
 #define DAC12_K		168
 #define ETHPTP_K	169
 
+#define PCLK1		170
+#define PCLK2		171
+#define PCLK3		172
+#define PCLK4		173
+#define PCLK5		174
+
 /* PLL */
 #define PLL1		176
 #define PLL2		177
@@ -249,30 +255,26 @@
 #define STM32MP1_LAST_CLK 232
 
 /* SCMI clock identifiers */
-#define CK_SCMI0_HSE		0
-#define CK_SCMI0_HSI		1
-#define CK_SCMI0_CSI		2
-#define CK_SCMI0_LSE		3
-#define CK_SCMI0_LSI		4
-#define CK_SCMI0_PLL2_Q		5
-#define CK_SCMI0_PLL2_R		6
-#define CK_SCMI0_MPU		7
-#define CK_SCMI0_AXI		8
-#define CK_SCMI0_BSEC		9
-#define CK_SCMI0_CRYP1		10
-#define CK_SCMI0_GPIOZ		11
-#define CK_SCMI0_HASH1		12
-#define CK_SCMI0_I2C4		13
-#define CK_SCMI0_I2C6		14
-#define CK_SCMI0_IWDG1		15
-#define CK_SCMI0_RNG1		16
-#define CK_SCMI0_RTC		17
-#define CK_SCMI0_RTCAPB		18
-#define CK_SCMI0_SPI6		19
-#define CK_SCMI0_USART1		20
-
-#define CK_SCMI1_PLL3_Q		0
-#define CK_SCMI1_PLL3_R		1
-#define CK_SCMI1_MCU		2
+#define CK_SCMI_HSE		0
+#define CK_SCMI_HSI		1
+#define CK_SCMI_CSI		2
+#define CK_SCMI_LSE		3
+#define CK_SCMI_LSI		4
+#define CK_SCMI_PLL2_Q		5
+#define CK_SCMI_PLL2_R		6
+#define CK_SCMI_MPU		7
+#define CK_SCMI_AXI		8
+#define CK_SCMI_BSEC		9
+#define CK_SCMI_CRYP1		10
+#define CK_SCMI_GPIOZ		11
+#define CK_SCMI_HASH1		12
+#define CK_SCMI_I2C4		13
+#define CK_SCMI_I2C6		14
+#define CK_SCMI_IWDG1		15
+#define CK_SCMI_RNG1		16
+#define CK_SCMI_RTC		17
+#define CK_SCMI_RTCAPB		18
+#define CK_SCMI_SPI6		19
+#define CK_SCMI_USART1		20
 
 #endif /* _DT_BINDINGS_STM32MP1_CLKS_H_ */
diff --git a/include/dt-bindings/clock/stm32mp13-clks.h b/include/dt-bindings/clock/stm32mp13-clks.h
new file mode 100644
index 000000000..2a110340f
--- /dev/null
+++ b/include/dt-bindings/clock/stm32mp13-clks.h
@@ -0,0 +1,235 @@
+/* SPDX-License-Identifier: GPL-2.0+ or BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2020 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32MP13_CLKS_H_
+#define _DT_BINDINGS_STM32MP13_CLKS_H_
+
+/* OSCILLATOR clocks */
+#define CK_HSE		0
+#define CK_CSI		1
+#define CK_LSI		2
+#define CK_LSE		3
+#define CK_HSI		4
+#define CK_HSE_DIV2	5
+
+/* PLL */
+#define PLL1		6
+#define PLL2		7
+#define PLL3		8
+#define PLL4		9
+
+/* ODF */
+#define PLL1_P		10
+#define PLL1_Q		11
+#define PLL1_R		12
+#define PLL2_P		13
+#define PLL2_Q		14
+#define PLL2_R		15
+#define PLL3_P		16
+#define PLL3_Q		17
+#define PLL3_R		18
+#define PLL4_P		19
+#define PLL4_Q		20
+#define PLL4_R		21
+
+#define PCLK1		22
+#define PCLK2		23
+#define PCLK3		24
+#define PCLK4		25
+#define PCLK5		26
+#define PCLK6		27
+
+/* SYSTEM CLOCK */
+#define CK_PER		28
+#define CK_MPU		29
+#define CK_AXI		30
+#define CK_MLAHB	31
+
+/* BASE TIMER */
+#define CK_TIMG1	32
+#define CK_TIMG2	33
+#define CK_TIMG3	34
+
+/* AUX */
+#define RTC		35
+
+/* TRACE & DEBUG clocks */
+#define CK_DBG		36
+#define CK_TRACE	37
+
+/* MCO clocks */
+#define CK_MCO1		38
+#define CK_MCO2		39
+
+/*  IP clocks */
+#define SYSCFG		40
+#define VREF		41
+#define DTS		42
+#define PMBCTRL		43
+#define HDP		44
+#define IWDG2		45
+#define STGENRO		46
+#define USART1		47
+#define RTCAPB		48
+#define TZC		49
+#define TZPC		50
+#define IWDG1		51
+#define BSEC		52
+#define DMA1		53
+#define DMA2		54
+#define DMAMUX1		55
+#define DMAMUX2		56
+#define GPIOA		57
+#define GPIOB		58
+#define GPIOC		59
+#define GPIOD		60
+#define GPIOE		61
+#define GPIOF		62
+#define GPIOG		63
+#define GPIOH		64
+#define GPIOI		65
+#define CRYP1		66
+#define HASH1		67
+#define BKPSRAM		68
+#define MDMA		69
+#define CRC1		70
+#define USBH		71
+#define DMA3		72
+#define TSC		73
+#define PKA		74
+#define AXIMC		75
+#define MCE		76
+#define ETH1TX		77
+#define ETH2TX		78
+#define ETH1RX		79
+#define ETH2RX		80
+#define ETH1MAC		81
+#define ETH2MAC		82
+#define ETH1STP		83
+#define ETH2STP		84
+
+/* IP clocks with parents */
+#define SDMMC1_K	85
+#define SDMMC2_K	86
+#define ADC1_K		87
+#define ADC2_K		88
+#define FMC_K		89
+#define QSPI_K		90
+#define RNG1_K		91
+#define USBPHY_K	92
+#define STGEN_K		93
+#define SPDIF_K		94
+#define SPI1_K		95
+#define SPI2_K		96
+#define SPI3_K		97
+#define SPI4_K		98
+#define SPI5_K		99
+#define I2C1_K		100
+#define I2C2_K		101
+#define I2C3_K		102
+#define I2C4_K		103
+#define I2C5_K		104
+#define TIM2_K		105
+#define TIM3_K		106
+#define TIM4_K		107
+#define TIM5_K		108
+#define TIM6_K		109
+#define TIM7_K		110
+#define TIM12_K		111
+#define TIM13_K		112
+#define TIM14_K		113
+#define TIM1_K		114
+#define TIM8_K		115
+#define TIM15_K		116
+#define TIM16_K		117
+#define TIM17_K		118
+#define LPTIM1_K	119
+#define LPTIM2_K	120
+#define LPTIM3_K	121
+#define LPTIM4_K	122
+#define LPTIM5_K	123
+#define USART1_K	124
+#define USART2_K	125
+#define USART3_K	126
+#define UART4_K		127
+#define UART5_K		128
+#define USART6_K	129
+#define UART7_K		130
+#define UART8_K		131
+#define DFSDM_K		132
+#define FDCAN_K		133
+#define SAI1_K		134
+#define SAI2_K		135
+#define ADFSDM_K	136
+#define USBO_K		137
+#define LTDC_PX		138
+#define ETH1CK_K	139
+#define ETH1PTP_K	140
+#define ETH2CK_K	141
+#define ETH2PTP_K	142
+#define DCMIPP_K	143
+#define SAES_K		144
+#define DTS_K		145
+
+/* DDR */
+#define DDRC1		146
+#define DDRC1LP		147
+#define DDRC2		148
+#define DDRC2LP		149
+#define DDRPHYC		150
+#define DDRPHYCLP	151
+#define DDRCAPB		152
+#define DDRCAPBLP	153
+#define AXIDCG		154
+#define DDRPHYCAPB	155
+#define DDRPHYCAPBLP	156
+#define DDRPERFM	157
+
+#define ADC1		158
+#define ADC2		159
+#define SAI1		160
+#define SAI2		161
+
+#define SPI1		162
+#define SPI2		163
+#define SPI3		164
+#define SPI4		165
+#define SPI5		166
+
+#define STM32MP1_LAST_CLK 167
+
+/* SCMI clock identifiers */
+#define CK_SCMI_HSE		0
+#define CK_SCMI_HSI		1
+#define CK_SCMI_CSI		2
+#define CK_SCMI_LSE		3
+#define CK_SCMI_LSI		4
+#define CK_SCMI_HSE_DIV2	5
+#define CK_SCMI_PLL2_Q		6
+#define CK_SCMI_PLL2_R		7
+#define CK_SCMI_PLL3_P		8
+#define CK_SCMI_PLL3_Q		9
+#define CK_SCMI_PLL3_R		10
+#define CK_SCMI_PLL4_P		11
+#define CK_SCMI_PLL4_Q		12
+#define CK_SCMI_PLL4_R		13
+#define CK_SCMI_MPU		14
+#define CK_SCMI_AXI		15
+#define CK_SCMI_MLAHB		16
+#define CK_SCMI_CKPER		17
+#define CK_SCMI_PCLK1		18
+#define CK_SCMI_PCLK2		19
+#define CK_SCMI_PCLK3		20
+#define CK_SCMI_PCLK4		21
+#define CK_SCMI_PCLK5		22
+#define CK_SCMI_PCLK6		23
+#define CK_SCMI_CKTIMG1		24
+#define CK_SCMI_CKTIMG2		25
+#define CK_SCMI_CKTIMG3		26
+#define CK_SCMI_RTC		27
+#define CK_SCMI_RTCAPB		28
+
+#endif /* _DT_BINDINGS_STM32MP13_CLKS_H_ */
diff --git a/include/dt-bindings/clock/stm32mp2-clks.h b/include/dt-bindings/clock/stm32mp2-clks.h
new file mode 100644
index 000000000..4caa3dea7
--- /dev/null
+++ b/include/dt-bindings/clock/stm32mp2-clks.h
@@ -0,0 +1,506 @@
+/* SPDX-License-Identifier: GPL-2.0 or BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32MP2_CLKS_H_
+#define _DT_BINDINGS_STM32MP2_CLKS_H_
+
+/* INTERNAL/EXTERNAL OSCILLATORS */
+#define HSI_CK			0
+#define HSE_CK			1
+#define MSI_CK			2
+#define LSI_CK			3
+#define LSE_CK			4
+#define I2S_CK			5
+#define RTC_CK			6
+#define SPDIF_CK_SYMB		7
+
+/* PLL CLOCKS */
+#define PLL1_CK			8
+#define PLL2_CK			9
+#define PLL3_CK			10
+#define PLL4_CK			11
+#define PLL5_CK			12
+#define PLL6_CK			13
+#define PLL7_CK			14
+#define PLL8_CK			15
+
+#define CK_CPU1			16
+
+/* LOW SPEEP MCU CLOCK */
+#define CK_ICN_LS_MCU		20
+
+/* APB DIV CLOCKS */
+#define CK_ICN_APB1		21
+#define CK_ICN_APB2		22
+#define CK_ICN_APB3		23
+#define CK_ICN_APB4		24
+#define CK_ICN_APBDBG		25
+
+/* GLOBAL TIMER */
+#define TIMG1_CK		26
+#define TIMG2_CK		27
+
+/* FLEXGEN CLOCKS */
+#define CK_ICN_HS_MCU		28
+#define CK_ICN_SDMMC		29
+#define CK_ICN_DDR		30
+#define CK_ICN_DISPLAY		31
+#define CK_ICN_HSL		32
+#define CK_ICN_NIC		33
+#define CK_ICN_VID		34
+
+#define CK_FLEXGEN_07		35
+#define CK_FLEXGEN_08		36
+#define CK_FLEXGEN_09		37
+#define CK_FLEXGEN_10		38
+#define CK_FLEXGEN_11		39
+#define CK_FLEXGEN_12		40
+#define CK_FLEXGEN_13		41
+#define CK_FLEXGEN_14		42
+#define CK_FLEXGEN_15		43
+#define CK_FLEXGEN_16		44
+#define CK_FLEXGEN_17		45
+#define CK_FLEXGEN_18		46
+#define CK_FLEXGEN_19		47
+#define CK_FLEXGEN_20		48
+#define CK_FLEXGEN_21		49
+#define CK_FLEXGEN_22		50
+#define CK_FLEXGEN_23		51
+#define CK_FLEXGEN_24		52
+#define CK_FLEXGEN_25		53
+#define CK_FLEXGEN_26		54
+#define CK_FLEXGEN_27		55
+#define CK_FLEXGEN_28		56
+#define CK_FLEXGEN_29		57
+#define CK_FLEXGEN_30		58
+#define CK_FLEXGEN_31		59
+#define CK_FLEXGEN_32		60
+#define CK_FLEXGEN_33		61
+#define CK_FLEXGEN_34		62
+#define CK_FLEXGEN_35		63
+#define CK_FLEXGEN_36		64
+#define CK_FLEXGEN_37		65
+#define CK_FLEXGEN_38		66
+#define CK_FLEXGEN_39		67
+#define CK_FLEXGEN_40		68
+#define CK_FLEXGEN_41		69
+#define CK_FLEXGEN_42		70
+#define CK_FLEXGEN_43		71
+#define CK_FLEXGEN_44		72
+#define CK_FLEXGEN_45		73
+#define CK_FLEXGEN_46		74
+#define CK_FLEXGEN_47		75
+#define CK_FLEXGEN_48		76
+#define CK_FLEXGEN_49		77
+#define CK_FLEXGEN_50		78
+#define CK_FLEXGEN_51		79
+#define CK_FLEXGEN_52		80
+#define CK_FLEXGEN_53		81
+#define CK_FLEXGEN_54		82
+#define CK_FLEXGEN_55		83
+#define CK_FLEXGEN_56		84
+#define CK_FLEXGEN_57		85
+#define CK_FLEXGEN_58		86
+#define CK_FLEXGEN_59		87
+#define CK_FLEXGEN_60		88
+#define CK_FLEXGEN_61		89
+#define CK_FLEXGEN_62		90
+#define CK_FLEXGEN_63		91
+
+#define CK_BUS_STM500		92
+#define CK_BUS_FMC		93
+#define CK_BUS_GPU		94
+#define CK_BUS_ETH1		95
+#define CK_BUS_ETH2		96
+#define CK_BUS_PCIE		97
+#define CK_BUS_DDRPHYC		98
+#define CK_BUS_SYSCPU1		99
+#define CK_BUS_ETHSW		100
+#define CK_BUS_HPDMA1		101
+#define CK_BUS_HPDMA2		102
+#define CK_BUS_HPDMA3		103
+#define CK_BUS_ADC12		104
+#define CK_BUS_ADC3		105
+#define CK_BUS_IPCC1		106
+#define CK_BUS_CCI		107
+#define CK_BUS_CRC		108
+#define CK_BUS_MDF1		109
+#define CK_BUS_OSPIIOM		110
+#define CK_BUS_BKPSRAM		111
+#define CK_BUS_HASH		112
+#define CK_BUS_RNG		113
+#define CK_BUS_CRYP1		114
+#define CK_BUS_CRYP2		115
+#define CK_BUS_SAES		116
+#define CK_BUS_PKA		117
+#define CK_BUS_RISAF1		118
+#define CK_BUS_RISAF5		119
+#define CK_BUS_RISAB1		120
+#define CK_BUS_RISAB2		121
+#define CK_BUS_RISAB6		122
+#define CK_BUS_GPIOA		123
+#define CK_BUS_GPIOB		124
+#define CK_BUS_GPIOC		125
+#define CK_BUS_GPIOD		126
+#define CK_BUS_GPIOE		127
+#define CK_BUS_GPIOF		128
+#define CK_BUS_GPIOG		129
+#define CK_BUS_GPIOH		130
+#define CK_BUS_GPIOI		131
+#define CK_BUS_GPIOJ		132
+#define CK_BUS_GPIOK		133
+#define CK_BUS_LPSRAM1		134
+#define CK_BUS_LPSRAM2		135
+#define CK_BUS_LPSRAM3		136
+#define CK_BUS_GPIOZ		137
+#define CK_BUS_LPDMA		138
+#define CK_BUS_MDF2		139
+#define CK_BUS_HSEM		140
+#define CK_BUS_IPCC2		141
+#define CK_BUS_C3H		142
+#define CK_BUS_C3S		143
+#define CK_BUS_C3D		144
+#define CK_BUS_RTC		145
+#define CK_BUS_SPI8		146
+#define CK_BUS_LPUART1		147
+#define CK_BUS_I2C8		148
+#define CK_BUS_LPTIM3		149
+#define CK_BUS_LPTIM4		150
+#define CK_BUS_LPTIM5		151
+#define CK_BUS_IWDG5		152
+#define CK_BUS_WWDG2		153
+#define CK_BUS_I3C4		154
+#define CK_BUS_TIM2		155
+#define CK_BUS_TIM3		156
+#define CK_BUS_TIM4		157
+#define CK_BUS_TIM5		158
+#define CK_BUS_TIM6		159
+#define CK_BUS_TIM7		160
+#define CK_BUS_TIM10		161
+#define CK_BUS_TIM11		162
+#define CK_BUS_TIM12		163
+#define CK_BUS_TIM13		164
+#define CK_BUS_TIM14		165
+#define CK_BUS_LPTIM1		166
+#define CK_BUS_LPTIM2		167
+#define CK_BUS_SPI2		168
+#define CK_BUS_SPI3		169
+#define CK_BUS_SPDIFRX		170
+#define CK_BUS_USART2		171
+#define CK_BUS_USART3		172
+#define CK_BUS_UART4		173
+#define CK_BUS_UART5		174
+#define CK_BUS_I2C1		175
+#define CK_BUS_I2C2		176
+#define CK_BUS_I2C3		177
+#define CK_BUS_I2C4		178
+#define CK_BUS_I2C5		179
+#define CK_BUS_I2C6		180
+#define CK_BUS_I2C7		181
+#define CK_BUS_I3C1		182
+#define CK_BUS_I3C2		183
+#define CK_BUS_I3C3		184
+#define CK_BUS_TIM1		185
+#define CK_BUS_TIM8		186
+#define CK_BUS_TIM15		187
+#define CK_BUS_TIM16		188
+#define CK_BUS_TIM17		189
+#define CK_BUS_TIM20		190
+#define CK_BUS_SAI1		191
+#define CK_BUS_SAI2		192
+#define CK_BUS_SAI3		193
+#define CK_BUS_SAI4		194
+#define CK_BUS_USART1		195
+#define CK_BUS_USART6		196
+#define CK_BUS_UART7		197
+#define CK_BUS_UART8		198
+#define CK_BUS_UART9		199
+#define CK_BUS_FDCAN		200
+#define CK_BUS_SPI1		201
+#define CK_BUS_SPI4		202
+#define CK_BUS_SPI5		203
+#define CK_BUS_SPI6		204
+#define CK_BUS_SPI7		205
+#define CK_BUS_BSEC		206
+#define CK_BUS_IWDG1		207
+#define CK_BUS_IWDG2		208
+#define CK_BUS_IWDG3		209
+#define CK_BUS_IWDG4		210
+#define CK_BUS_WWDG1		211
+#define CK_BUS_VREF		212
+#define CK_BUS_DTS		213
+#define CK_BUS_SERC		214
+#define CK_BUS_HDP		215
+#define CK_BUS_IS2M		216
+#define CK_BUS_DSI		217
+#define CK_BUS_LTDC		218
+#define CK_BUS_CSI		219
+#define CK_BUS_DCMIPP		220
+#define CK_BUS_DDRC		221
+#define CK_BUS_DDRCFG		222
+#define CK_BUS_LDIT		223
+#define CK_BUS_GICV2M		224
+#define CK_BUS_USBTC		225
+#define CK_BUS_BUSPERFM		226
+#define CK_BUS_USB3PCIEPHY	227
+#define CK_BUS_STGEN		228
+#define CK_BUS_VDEC		229
+#define CK_BUS_VENC		230
+#define CK_SYSDBG		231
+#define CK_KER_TIM2		232
+#define CK_KER_TIM3		233
+#define CK_KER_TIM4		234
+#define CK_KER_TIM5		235
+#define CK_KER_TIM6		236
+#define CK_KER_TIM7		237
+#define CK_KER_TIM10		238
+#define CK_KER_TIM11		239
+#define CK_KER_TIM12		240
+#define CK_KER_TIM13		241
+#define CK_KER_TIM14		242
+#define CK_KER_TIM1		243
+#define CK_KER_TIM8		244
+#define CK_KER_TIM15		245
+#define CK_KER_TIM16		246
+#define CK_KER_TIM17		247
+#define CK_KER_TIM20		248
+#define CK_BUS_SYSRAM		249
+#define CK_BUS_VDERAM		250
+#define CK_BUS_RETRAM		251
+#define CK_BUS_OSPI1		252
+#define CK_BUS_OSPI2		253
+#define CK_BUS_OTFD1		254
+#define CK_BUS_OTFD2		255
+#define CK_BUS_SRAM1		256
+#define CK_BUS_SRAM2		257
+#define CK_BUS_RISAB3		258
+#define CK_BUS_RISAB4		259
+#define CK_BUS_RISAB5		260
+#define CK_BUS_SDMMC1		261
+#define CK_BUS_SDMMC2		262
+#define CK_BUS_SDMMC3		263
+#define CK_BUS_DDR		264
+#define CK_BUS_RISAF4		265
+#define CK_BUS_USB2OHCI		268
+#define CK_BUS_USB2EHCI		269
+#define CK_BUS_USB3DRD		270
+#define CK_KER_LPTIM1		273
+#define CK_KER_LPTIM2		274
+#define CK_KER_USART2		275
+#define CK_KER_UART4		276
+#define CK_KER_USART3		277
+#define CK_KER_UART5		278
+#define CK_KER_SPI2		279
+#define CK_KER_SPI3		280
+#define CK_KER_SPDIFRX		281
+#define CK_KER_I2C1		282
+#define CK_KER_I2C2		283
+#define CK_KER_I3C1		284
+#define CK_KER_I3C2		285
+#define CK_KER_I2C3		286
+#define CK_KER_I2C5		287
+#define CK_KER_I3C3		288
+#define CK_KER_I2C4		289
+#define CK_KER_I2C6		290
+#define CK_KER_I2C7		291
+#define CK_KER_SPI1		292
+#define CK_KER_SPI4		293
+#define CK_KER_SPI5		294
+#define CK_KER_SPI6		295
+#define CK_KER_SPI7		296
+#define CK_KER_USART1		297
+#define CK_KER_USART6		298
+#define CK_KER_UART7		299
+#define CK_KER_UART8		300
+#define CK_KER_UART9		301
+#define CK_KER_MDF1		302
+#define CK_KER_SAI1		303
+#define CK_KER_SAI2		304
+#define CK_KER_SAI3		305
+#define CK_KER_SAI4		306
+#define CK_KER_FDCAN		307
+#define CK_KER_DSIBLANE		308
+#define CK_KER_DSIPHY		309
+#define CK_KER_CSI		310
+#define CK_KER_CSITXESC		311
+#define CK_KER_CSIPHY		312
+#define CK_KER_LVDSPHY		313
+#define CK_KER_STGEN		314
+#define CK_KER_USB3PCIEPHY	315
+#define CK_KER_USB2PHY2EN	316
+#define CK_KER_I3C4		317
+#define CK_KER_SPI8		318
+#define CK_KER_I2C8		319
+#define CK_KER_LPUART1		320
+#define CK_KER_LPTIM3		321
+#define CK_KER_LPTIM4		322
+#define CK_KER_LPTIM5		323
+#define CK_KER_MDF2		324
+#define CK_KER_TSDBG		325
+#define CK_KER_TPIU		326
+#define CK_BUS_ETR		327
+#define CK_BUS_SYSATB		328
+#define CK_KER_ADC12		329
+#define CK_KER_ADC3		330
+#define CK_KER_OSPI1		331
+#define CK_KER_OSPI2		332
+#define CK_KER_FMC		333
+#define CK_KER_SDMMC1		334
+#define CK_KER_SDMMC2		335
+#define CK_KER_SDMMC3		336
+#define CK_KER_ETH1		337
+#define CK_KER_ETH2		338
+#define CK_KER_ETH1PTP		339
+#define CK_KER_ETH2PTP		340
+#define CK_KER_USB2PHY1		341
+#define CK_KER_USB2PHY2		342
+#define CK_KER_ETHSW		343
+#define CK_KER_ETHSWREF		344
+#define CK_MCO1			345
+#define CK_MCO2			346
+#define CK_KER_DTS		347
+
+#define CK_ETH1_RX		348
+#define CK_ETH1_TX		349
+#define CK_ETH1_MAC		350
+
+#define CK_ETH2_RX		351
+#define CK_ETH2_TX		352
+#define CK_ETH2_MAC		353
+
+#define CK_ETH1_STP		354
+#define CK_ETH2_STP		355
+#define CK_KER_USBTC		356
+#define CK_BUS_ADF1		357
+#define CK_KER_ADF1		358
+#define CK_BUS_LVDS		359
+#define CK_KER_LTDC		360
+#define CK_KER_GPU		361
+#define CK_BUS_ETHSWACMCFG	362
+#define CK_BUS_ETHSWACMMSG	363
+#define HSE_DIV2_CK		364
+
+#define STM32MP2_LAST_CLK	365
+
+#define CK_SCMI0_ICN_HS_MCU	0
+#define CK_SCMI0_ICN_SDMMC	1
+#define CK_SCMI0_ICN_DDR	2
+#define CK_SCMI0_ICN_DISPLAY	3
+#define CK_SCMI0_ICN_HSL	4
+#define CK_SCMI0_ICN_NIC	5
+#define CK_SCMI0_ICN_VID	6
+#define CK_SCMI0_FLEXGEN_07	7
+#define CK_SCMI0_FLEXGEN_08	8
+#define CK_SCMI0_FLEXGEN_09	9
+#define CK_SCMI0_FLEXGEN_10	10
+#define CK_SCMI0_FLEXGEN_11	11
+#define CK_SCMI0_FLEXGEN_12	12
+#define CK_SCMI0_FLEXGEN_13	13
+#define CK_SCMI0_FLEXGEN_14	14
+#define CK_SCMI0_FLEXGEN_15	15
+#define CK_SCMI0_FLEXGEN_16	16
+#define CK_SCMI0_FLEXGEN_17	17
+#define CK_SCMI0_FLEXGEN_18	18
+#define CK_SCMI0_FLEXGEN_19	19
+#define CK_SCMI0_FLEXGEN_20	20
+#define CK_SCMI0_FLEXGEN_21	21
+#define CK_SCMI0_FLEXGEN_22	22
+#define CK_SCMI0_FLEXGEN_23	23
+#define CK_SCMI0_FLEXGEN_24	24
+#define CK_SCMI0_FLEXGEN_25	25
+#define CK_SCMI0_FLEXGEN_26	26
+#define CK_SCMI0_FLEXGEN_27	27
+#define CK_SCMI0_FLEXGEN_28	28
+#define CK_SCMI0_FLEXGEN_29	29
+#define CK_SCMI0_FLEXGEN_30	30
+#define CK_SCMI0_FLEXGEN_31	31
+#define CK_SCMI0_FLEXGEN_32	32
+#define CK_SCMI0_FLEXGEN_33	33
+#define CK_SCMI0_FLEXGEN_34	34
+#define CK_SCMI0_FLEXGEN_35	35
+#define CK_SCMI0_FLEXGEN_36	36
+#define CK_SCMI0_FLEXGEN_37	37
+#define CK_SCMI0_FLEXGEN_38	38
+#define CK_SCMI0_FLEXGEN_39	39
+#define CK_SCMI0_FLEXGEN_40	40
+#define CK_SCMI0_FLEXGEN_41	41
+#define CK_SCMI0_FLEXGEN_42	42
+#define CK_SCMI0_FLEXGEN_43	43
+#define CK_SCMI0_FLEXGEN_44	44
+#define CK_SCMI0_FLEXGEN_45	45
+#define CK_SCMI0_FLEXGEN_46	46
+#define CK_SCMI0_FLEXGEN_47	47
+#define CK_SCMI0_FLEXGEN_48	48
+#define CK_SCMI0_FLEXGEN_49	49
+#define CK_SCMI0_FLEXGEN_50	50
+#define CK_SCMI0_FLEXGEN_51	51
+#define CK_SCMI0_FLEXGEN_52	52
+#define CK_SCMI0_FLEXGEN_53	53
+#define CK_SCMI0_FLEXGEN_54	54
+#define CK_SCMI0_FLEXGEN_55	55
+#define CK_SCMI0_FLEXGEN_56	56
+#define CK_SCMI0_FLEXGEN_57	57
+#define CK_SCMI0_FLEXGEN_58	58
+#define CK_SCMI0_FLEXGEN_59	59
+#define CK_SCMI0_FLEXGEN_60	60
+#define CK_SCMI0_FLEXGEN_61	61
+#define CK_SCMI0_FLEXGEN_62	62
+#define CK_SCMI0_FLEXGEN_63	63
+
+#define CK_SCMI0_ICN_LS_MCU	64
+
+#define CK_SCMI0_HSE		65
+#define CK_SCMI0_LSE		66
+#define CK_SCMI0_HSI		67
+#define CK_SCMI0_LSI		68
+#define CK_SCMI0_MSI		69
+
+#define CK_SCMI0_RTC		70
+
+#define CK_SCMI0_ICN_APB1	71
+#define CK_SCMI0_ICN_APB2	72
+#define CK_SCMI0_ICN_APB3	73
+#define CK_SCMI0_ICN_APB4	74
+
+#define CK_SCMI0_ICN_APBDBG	75
+
+#define CK_SCMI0_TIMG1		76
+#define CK_SCMI0_TIMG2		77
+
+#define CK_SCMI0_BKPSRAM	78
+#define CK_SCMI0_BSEC		79
+#define CK_SCMI0_BUSPERFM	80
+#define CK_SCMI0_ETR		81
+#define CK_SCMI0_FMC		82
+#define CK_SCMI0_GPIOA		83
+#define CK_SCMI0_GPIOB		84
+#define CK_SCMI0_GPIOC		85
+#define CK_SCMI0_GPIOD		86
+#define CK_SCMI0_GPIOE		87
+#define CK_SCMI0_GPIOF		88
+#define CK_SCMI0_GPIOG		89
+#define CK_SCMI0_GPIOH		90
+#define CK_SCMI0_GPIOI		91
+#define CK_SCMI0_GPIOJ		92
+#define CK_SCMI0_GPIOK		93
+#define CK_SCMI0_GPIOZ		94
+#define CK_SCMI0_HPDMA1		95
+#define CK_SCMI0_HPDMA2		96
+#define CK_SCMI0_HPDMA3		97
+#define CK_SCMI0_HSEM		98
+#define CK_SCMI0_IPCC1		99
+#define CK_SCMI0_IPCC2		100
+#define CK_SCMI0_LPDMA		101
+#define CK_SCMI0_RETRAM		102
+#define CK_SCMI0_RTCCK		103
+#define CK_SCMI0_SRAM1		104
+#define CK_SCMI0_SRAM2		105
+#define CK_SCMI0_SYSCPU1	106
+#define CK_SCMI0_CPU1		107
+#define CK_SCMI0_GPU		108
+#define CK_SCMI0_HSE_DIV2	109
+
+#endif /* _DT_BINDINGS_STM32MP2_CLKS_H_ */
diff --git a/include/dt-bindings/pinctrl/stm32-pinfunc.h b/include/dt-bindings/pinctrl/stm32-pinfunc.h
index e6fb8ada3..af3fd3883 100644
--- a/include/dt-bindings/pinctrl/stm32-pinfunc.h
+++ b/include/dt-bindings/pinctrl/stm32-pinfunc.h
@@ -26,6 +26,7 @@
 #define AF14	0xf
 #define AF15	0x10
 #define ANALOG	0x11
+#define RSVD	0x12
 
 /* define Pins number*/
 #define PIN_NO(port, line)	(((port) - 'A') * 0x10 + (line))
@@ -37,6 +38,9 @@
 #define STM32MP_PKG_AB	0x2
 #define STM32MP_PKG_AC	0x4
 #define STM32MP_PKG_AD	0x8
+#define STM32MP_PKG_AI	0x100
+#define STM32MP_PKG_AK	0x400
+#define STM32MP_PKG_AL	0x800
 
 #endif /* _DT_BINDINGS_STM32_PINFUNC_H */
 
diff --git a/include/dt-bindings/reset/stm32mp1-resets.h b/include/dt-bindings/reset/stm32mp1-resets.h
index f3a0ed317..bdbf9e253 100644
--- a/include/dt-bindings/reset/stm32mp1-resets.h
+++ b/include/dt-bindings/reset/stm32mp1-resets.h
@@ -107,17 +107,17 @@
 #define GPIOK_R		19786
 
 /* SCMI reset domain identifiers */
-#define RST_SCMI0_SPI6		0
-#define RST_SCMI0_I2C4		1
-#define RST_SCMI0_I2C6		2
-#define RST_SCMI0_USART1	3
-#define RST_SCMI0_STGEN		4
-#define RST_SCMI0_GPIOZ		5
-#define RST_SCMI0_CRYP1		6
-#define RST_SCMI0_HASH1		7
-#define RST_SCMI0_RNG1		8
-#define RST_SCMI0_MDMA		9
-#define RST_SCMI0_MCU		10
-#define RST_SCMI0_MCU_HOLD_BOOT	11
+#define RST_SCMI_SPI6		0
+#define RST_SCMI_I2C4		1
+#define RST_SCMI_I2C6		2
+#define RST_SCMI_USART1		3
+#define RST_SCMI_STGEN		4
+#define RST_SCMI_GPIOZ		5
+#define RST_SCMI_CRYP1		6
+#define RST_SCMI_HASH1		7
+#define RST_SCMI_RNG1		8
+#define RST_SCMI_MDMA		9
+#define RST_SCMI_MCU		10
+#define RST_SCMI_MCU_HOLD_BOOT	11
 
 #endif /* _DT_BINDINGS_STM32MP1_RESET_H_ */
diff --git a/include/dt-bindings/reset/stm32mp13-resets.h b/include/dt-bindings/reset/stm32mp13-resets.h
new file mode 100644
index 000000000..934864e90
--- /dev/null
+++ b/include/dt-bindings/reset/stm32mp13-resets.h
@@ -0,0 +1,100 @@
+/* SPDX-License-Identifier: GPL-2.0 or BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32MP13_RESET_H_
+#define _DT_BINDINGS_STM32MP13_RESET_H_
+
+#define TIM2_R		13568
+#define TIM3_R		13569
+#define TIM4_R		13570
+#define TIM5_R		13571
+#define TIM6_R		13572
+#define TIM7_R		13573
+#define LPTIM1_R	13577
+#define SPI2_R		13579
+#define SPI3_R		13580
+#define USART3_R	13583
+#define UART4_R		13584
+#define UART5_R		13585
+#define UART7_R		13586
+#define UART8_R		13587
+#define I2C1_R		13589
+#define I2C2_R		13590
+#define SPDIF_R		13594
+#define TIM1_R		13632
+#define TIM8_R		13633
+#define SPI1_R		13640
+#define USART6_R	13645
+#define SAI1_R		13648
+#define SAI2_R		13649
+#define DFSDM_R		13652
+#define FDCAN_R		13656
+#define LPTIM2_R	13696
+#define LPTIM3_R	13697
+#define LPTIM4_R	13698
+#define LPTIM5_R	13699
+#define SYSCFG_R	13707
+#define VREF_R		13709
+#define DTS_R		13712
+#define PMBCTRL_R	13713
+#define LTDC_R		13760
+#define DCMIPP_R	13761
+#define DDRPERFM_R	13768
+#define USBPHY_R	13776
+#define STGEN_R		13844
+#define USART1_R	13888
+#define USART2_R	13889
+#define SPI4_R		13890
+#define SPI5_R		13891
+#define I2C3_R		13892
+#define I2C4_R		13893
+#define I2C5_R		13894
+#define TIM12_R		13895
+#define TIM13_R		13896
+#define TIM14_R		13897
+#define TIM15_R		13898
+#define TIM16_R		13899
+#define TIM17_R		13900
+#define DMA1_R		13952
+#define DMA2_R		13953
+#define DMAMUX1_R	13954
+#define DMA3_R		13955
+#define DMAMUX2_R	13956
+#define ADC1_R		13957
+#define ADC2_R		13958
+#define USBO_R		13960
+#define GPIOA_R		14080
+#define GPIOB_R		14081
+#define GPIOC_R		14082
+#define GPIOD_R		14083
+#define GPIOE_R		14084
+#define GPIOF_R		14085
+#define GPIOG_R		14086
+#define GPIOH_R		14087
+#define GPIOI_R		14088
+#define TSC_R		14095
+#define PKA_R		14146
+#define SAES_R		14147
+#define CRYP1_R		14148
+#define HASH1_R		14149
+#define RNG1_R		14150
+#define AXIMC_R		14160
+#define MDMA_R		14208
+#define MCE_R		14209
+#define ETH1MAC_R	14218
+#define FMC_R		14220
+#define QSPI_R		14222
+#define SDMMC1_R	14224
+#define SDMMC2_R	14225
+#define CRC1_R		14228
+#define USBH_R		14232
+#define ETH2MAC_R	14238
+
+/* SCMI reset domain identifiers */
+#define RST_SCMI_LTDC		0
+#define RST_SCMI_MDMA		1
+
+#endif /* _DT_BINDINGS_STM32MP13_RESET_H_ */
diff --git a/include/dt-bindings/reset/stm32mp2-resets.h b/include/dt-bindings/reset/stm32mp2-resets.h
new file mode 100644
index 000000000..4e13b8d44
--- /dev/null
+++ b/include/dt-bindings/reset/stm32mp2-resets.h
@@ -0,0 +1,165 @@
+/* SPDX-License-Identifier: GPL-2.0 or BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author(s): Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
+ *	      Yann Gautier <yann.gautier@st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32MP25_RESET_H_
+#define _DT_BINDINGS_STM32MP25_RESET_H_
+
+#define SYS_R		8192
+#define C1_R		8224
+#define C1P1POR_R	8256
+#define C1P1_R		8257
+#define C2_R		8288
+#define C2_HOLDBOOT_R	8608
+#define C1_HOLDBOOT_R	8609
+#define VSW_R		8703
+#define C1MS_R		8808
+#define IWDG2_KER_R	9074
+#define IWDG4_KER_R	9202
+#define C3_R		9312
+#define DDRCP_R		9856
+#define DDRCAPB_R	9888
+#define DDRPHYCAPB_R	9920
+#define DDRCFG_R	9984
+#define DDR_R		10016
+#define OSPI1_R		10400
+#define OSPI1DLL_R	10416
+#define OSPI2_R		10432
+#define OSPI2DLL_R	10448
+#define FMC_R		10464
+#define DBG_R		10508
+#define GPIOA_R		10592
+#define GPIOB_R		10624
+#define GPIOC_R		10656
+#define GPIOD_R		10688
+#define GPIOE_R		10720
+#define GPIOF_R		10752
+#define GPIOG_R		10784
+#define GPIOH_R		10816
+#define GPIOI_R		10848
+#define GPIOJ_R		10880
+#define GPIOK_R		10912
+#define GPIOZ_R		10944
+#define HPDMA1_R	10976
+#define HPDMA2_R	11008
+#define HPDMA3_R	11040
+#define LPDMA_R		11072
+#define HSEM_R		11104
+#define IPCC1_R		11136
+#define IPCC2_R		11168
+#define IS2M_R		11360
+#define SSMOD_R		11392
+#define TIM1_R		14336
+#define TIM2_R		14368
+#define TIM3_R		14400
+#define TIM4_R		14432
+#define TIM5_R		14464
+#define TIM6_R		14496
+#define TIM7_R		14528
+#define TIM8_R		14560
+#define TIM10_R		14592
+#define TIM11_R		14624
+#define TIM12_R		14656
+#define TIM13_R		14688
+#define TIM14_R		14720
+#define TIM15_R		14752
+#define TIM16_R		14784
+#define TIM17_R		14816
+#define TIM20_R		14848
+#define LPTIM1_R	14880
+#define LPTIM2_R	14912
+#define LPTIM3_R	14944
+#define LPTIM4_R	14976
+#define LPTIM5_R	15008
+#define SPI1_R		15040
+#define SPI2_R		15072
+#define SPI3_R		15104
+#define SPI4_R		15136
+#define SPI5_R		15168
+#define SPI6_R		15200
+#define SPI7_R		15232
+#define SPI8_R		15264
+#define SPDIFRX_R	15296
+#define USART1_R	15328
+#define USART2_R	15360
+#define USART3_R	15392
+#define UART4_R		15424
+#define UART5_R		15456
+#define USART6_R	15488
+#define UART7_R		15520
+#define UART8_R		15552
+#define UART9_R		15584
+#define LPUART1_R	15616
+#define I2C1_R		15648
+#define I2C2_R		15680
+#define I2C3_R		15712
+#define I2C4_R		15744
+#define I2C5_R		15776
+#define I2C6_R		15808
+#define I2C7_R		15840
+#define I2C8_R		15872
+#define SAI1_R		15904
+#define SAI2_R		15936
+#define SAI3_R		15968
+#define SAI4_R		16000
+#define MDF1_R		16064
+#define MDF2_R		16096
+#define FDCAN_R		16128
+#define HDP_R		16160
+#define ADC12_R		16192
+#define ADC3_R		16224
+#define ETH1_R		16256
+#define ETH2_R		16288
+#define USB2_R		16352
+#define USB2PHY1_R	16384
+#define USB2PHY2_R	16416
+#define USB3DRD_R	16448
+#define USB3PCIEPHY_R	16480
+#define PCIE_R		16512
+#define USBTC_R		16544
+#define ETHSW_R		16576
+#define SDMMC1_R	16768
+#define SDMMC1DLL_R	16784
+#define SDMMC2_R	16800
+#define SDMMC2DLL_R	16816
+#define SDMMC3_R	16832
+#define SDMMC3DLL_R	16848
+#define GPU_R		16864
+#define LTDC_R		16896
+#define DSI_R		16928
+#define LVDS_R		17024
+#define CSI_R		17088
+#define DCMIPP_R	17120
+#define CCI_R		17152
+#define VDEC_R		17184
+#define VENC_R		17216
+#define RNG_R		17280
+#define PKA_R		17312
+#define SAES_R		17344
+#define HASH_R		17376
+#define CRYP1_R		17408
+#define CRYP2_R		17440
+#define WWDG1_R		17632
+#define WWDG2_R		17664
+#define BUSPERFM_R	17696
+#define VREF_R		17728
+#define DTS_R		17760
+#define CRC_R		17824
+#define SERC_R		17856
+#define OSPIIOM_R	17888
+#define I3C1_R		17984
+#define I3C2_R		18016
+#define I3C3_R		18048
+#define I3C4_R		18080
+
+#define RST_SCMI0_C1_R		0
+#define RST_SCMI0_C2_R		1
+#define RST_SCMI0_C1_HOLDBOOT_R	2
+#define RST_SCMI0_C2_HOLDBOOT_R	3
+#define RST_SCMI0_FMC		4
+#define RST_SCMI0_PCIE		5
+
+#endif /* _DT_BINDINGS_STM32MP25_RESET_H_ */
diff --git a/include/dt-bindings/rtc/rtc-stm32.h b/include/dt-bindings/rtc/rtc-stm32.h
new file mode 100644
index 000000000..2fd78c2e6
--- /dev/null
+++ b/include/dt-bindings/rtc/rtc-stm32.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * This header provides constants for STM32_RTC bindings.
+ */
+
+#ifndef _DT_BINDINGS_RTC_RTC_STM32_H
+#define _DT_BINDINGS_RTC_RTC_STM32_H
+
+#define RTC_NO_OUT	0
+#define RTC_OUT1	1
+#define RTC_OUT2	2
+#define RTC_OUT2_RMP	3
+
+#endif
diff --git a/include/dt-bindings/soc/stm32-hdp.h b/include/dt-bindings/soc/stm32-hdp.h
new file mode 100644
index 000000000..d98665327
--- /dev/null
+++ b/include/dt-bindings/soc/stm32-hdp.h
@@ -0,0 +1,108 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Roullier Christophe <christophe.roullier@st.com>
+ * for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32_HDP_H
+#define _DT_BINDINGS_STM32_HDP_H
+
+#define STM32_HDP(port, value) ((value) << ((port) * 4))
+
+/* define HDP Pins number*/
+#define HDP0_PWR_PWRWAKE_SYS			0
+#define HDP0_CM4_SLEEPDEEP			1
+#define HDP0_PWR_STDBY_WKUP			2
+#define HDP0_PWR_ENCOMP_VDDCORE			3
+#define HDP0_BSEC_OUT_SEC_NIDEN			4
+#define HDP0_RCC_CM4_SLEEPDEEP			6
+#define HDP0_GPU_DBG7				7
+#define HDP0_DDRCTRL_LP_REQ			8
+#define HDP0_PWR_DDR_RET_ENABLE_N		9
+#define HDP0_GPOVAL_0				15
+
+#define HDP1_PWR_PWRWAKE_MCU			0
+#define HDP1_CM4_HALTED				1
+#define HDP1_CA7_NAXIERRIRQ			2
+#define HDP1_PWR_OKIN_MR			3
+#define HDP1_BSEC_OUT_SEC_DBGEN			4
+#define HDP1_EXTI_SYS_WAKEUP			5
+#define HDP1_RCC_PWRDS_MPU			6
+#define HDP1_GPU_DBG6				7
+#define HDP1_DDRCTRL_DFI_CTRLUPD_REQ		8
+#define HDP1_DDRCTRL_CACTIVE_DDRC_ASR		9
+#define HDP1_GPOVAL_1				15
+
+#define HDP2_PWR_PWRWAKE_MPU			0
+#define HDP2_CM4_RXEV				1
+#define HDP2_CA7_NPMUIRQ1			2
+#define HDP2_CA7_NFIQOUT1			3
+#define HDP2_BSEC_IN_RSTCORE_N			4
+#define HDP2_EXTI_C2_WAKEUP			5
+#define HDP2_RCC_PWRDS_MCU			6
+#define HDP2_GPU_DBG5				7
+#define HDP2_DDRCTRL_DFI_INIT_COMPLETE		8
+#define HDP2_DDRCTRL_PERF_OP_IS_REFRESH		9
+#define HDP2_DDRCTRL_GSKP_DFI_LP_REQ		10
+#define HDP2_GPOVAL_2				15
+
+#define HDP3_PWR_SEL_VTH_VDD_CORE		0
+#define HDP3_CM4_TXEV				1
+#define HDP3_CA7_NPMUIRQ0			2
+#define HDP3_CA7_NFIQOUT0			3
+#define HDP3_BSEC_OUT_SEC_DFTLOCK		4
+#define HDP3_EXTI_C1_WAKEUP			5
+#define HDP3_RCC_PWRDS_SYS			6
+#define HDP3_GPU_DBG4				7
+#define HDP3_DDRCTRL_STAT_DDRC_REG_SELREF_TYPE0	8
+#define HDP3_DDRCTRL_CACTIVE_1			9
+#define HDP3_GPOVAL_3				15
+
+#define HDP4_PWR_PDDS				0
+#define HDP4_CM4_SLEEPING			1
+#define HDP4_CA7_NRESET1			2
+#define HDP4_CA7_NIRQOUT1			3
+#define HDP4_BSEC_OUT_SEC_DFTEN			4
+#define HDP4_BSEC_OUT_SEC_DBGSWENABLE		5
+#define HDP4_ETH_OUT_PMT_INTR_O			6
+#define HDP4_GPU_DBG3				7
+#define HDP4_DDRCTRL_STAT_DDRC_REG_SELREF_TYPE1	8
+#define HDP4_DDRCTRL_CACTIVE_0			9
+#define HDP4_GPOVAL_4				15
+
+#define HDP5_CA7_STANDBYWFIL2			0
+#define HDP5_PWR_VTH_VDDCORE_ACK		1
+#define HDP5_CA7_NRESET0			2
+#define HDP5_CA7_NIRQOUT0			3
+#define HDP5_BSEC_IN_PWROK			4
+#define HDP5_BSEC_OUT_SEC_DEVICEEN		5
+#define HDP5_ETH_OUT_LPI_INTR_O			6
+#define HDP5_GPU_DBG2				7
+#define HDP5_DDRCTRL_CACTIVE_DDRC		8
+#define HDP5_DDRCTRL_WR_CREDIT_CNT		9
+#define HDP5_GPOVAL_5				15
+
+#define HDP6_CA7_STANDBYWFI1			0
+#define HDP6_CA7_STANDBYWFE1			1
+#define HDP6_CA7_EVENT0				2
+#define HDP6_CA7_DBGACK1			3
+#define HDP6_BSEC_OUT_SEC_SPNIDEN		5
+#define HDP6_ETH_OUT_MAC_SPEED_O1		6
+#define HDP6_GPU_DBG1				7
+#define HDP6_DDRCTRL_CSYSACK_DDRC		8
+#define HDP6_DDRCTRL_LPR_CREDIT_CNT		9
+#define HDP6_GPOVAL_6				15
+
+#define HDP7_CA7_STANDBYWFI0			0
+#define HDP7_CA7_STANDBYWFE0			1
+#define HDP7_CA7_DBGACK0			3
+#define HDP7_BSEC_OUT_FUSE_OK			4
+#define HDP7_BSEC_OUT_SEC_SPIDEN		5
+#define HDP7_ETH_OUT_MAC_SPEED_O0		6
+#define HDP7_GPU_DBG0				7
+#define HDP7_DDRCTRL_CSYSREQ_DDRC		8
+#define HDP7_DDRCTRL_HPR_CREDIT_CNT		9
+#define HDP7_GPOVAL_7				15
+
+#endif /* _DT_BINDINGS_STM32_HDP_H */
diff --git a/include/dt-bindings/soc/stm32mp13-hdp.h b/include/dt-bindings/soc/stm32mp13-hdp.h
new file mode 100644
index 000000000..091c1c835
--- /dev/null
+++ b/include/dt-bindings/soc/stm32mp13-hdp.h
@@ -0,0 +1,133 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Roullier Christophe <christophe.roullier@st.com>
+ * for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32_HDP_H
+#define _DT_BINDINGS_STM32_HDP_H
+
+#define STM32_HDP(port, value) ((value) << ((port) * 4))
+
+/* define HDP Pins number*/
+#define HDP0_PWR_PWRWAKE_SYS			0
+#define HDP0_PWR_STOP_FORBIDDEN			1
+#define HDP0_PWR_STDBY_WKUP			2
+#define HDP0_PWR_ENCOMP_VDDCORE			3
+#define HDP0_BSEC_OUT_SEC_NIDEN			4
+#define HDP0_AIEC_SYS_WAKEUP			5
+#define HDP0_DDRCTRL_LP_REQ			8
+#define HDP0_PWR_DDR_RET_ENABLE_N		9
+#define HDP0_DTS_CLK_PTAT			10
+#define HDP0_SRAM3CTRL_TAMP_ERASE_ACT		12
+#define HDP0_GPOVAL_0				15
+
+#define HDP1_PWR_SEL_VTH_VDDCPU			0
+#define HDP1_PWR_MPU_RAM_LOWSPEED		1
+#define HDP1_CA7_NAXIERRIRQ			2
+#define HDP1_PWR_OKIN_MR			3
+#define HDP1_BSEC_OUT_SEC_DBGEN			4
+#define HDP1_AIEC_C1_WAKEUP			5
+#define HDP1_RCC_PWRDS_MPU			6
+#define HDP1_DDRCTRL_DFI_CTRLUPD_REQ		8
+#define HDP1_DDRCTRL_CACTIVE_DDRC_ASR		9
+#define HDP1_SRAM3CTRL_HW_ERASE_ACT		12
+#define HDP1_NIC400_S0_BREADY			13
+#define HDP1_GPOVAL_1				15
+
+#define HDP2_PWR_PWRWAKE_MPU			0
+#define HDP2_PWR_MPU_CLOCK_DISABLE_ACK		1
+#define HDP2_CA7_NDGBRESET_I			2
+#define HDP2_BSEC_IN_RSTCORE_N			4
+#define HDP2_BSEC_OUT_SEC_BSC_DIS		5
+#define HDP2_DDRCTRL_DFI_INIT_COMPLETE		8
+#define HDP2_DDRCTRL_PERF_OP_IS_REFRESH		9
+#define HDP2_DDRCTRL_GSKP_DFI_LP_REQ		10
+#define HDP2_SRAM3CTRL_SW_ERASE_ACT		12
+#define HDP2_NIC400_S0_BVALID			13
+#define HDP2_GPOVAL_2				15
+
+#define HDP3_PWR_SEL_VTH_VDD_CORE		0
+#define HDP3_PWR_MPU_CLOCK_DISABLE_REQ		1
+#define HDP3_CA7_NPMUIRQ0			2
+#define HDP3_CA7_NFIQOUT0			3
+#define HDP3_BSEC_OUT_SEC_DFTLOCK		4
+#define HDP3_BSEC_OUT_SEC_JTAG_DIS		5
+#define HDP3_RCC_PWRDS_SYS			6
+#define HDP3_SRAM3CTRL_TAMP_ERASE_REQ		7
+#define HDP3_DDRCTRL_STAT_DDRC_REG_SELREF_TYPE0	8
+#define HDP3_DTS_VALOBUS1_0			10
+#define HDP3_DTS_VALOBUS2_0			11
+#define HDP3_TAMP_POTENTIAL_TAMP_ERFCFG		12
+#define HDP3_NIC400_S0_WREADY			13
+#define HDP3_NIC400_S0_RREADY			14
+#define HDP3_GPOVAL_3				15
+
+#define HDP4_PWR_STOP2_ACTIVE			1
+#define HDP4_CA7_NL2RESET1			2
+#define HDP4_CA7_NPORESET_VARM_I		3
+#define HDP4_BSEC_OUT_SEC_DFTEN			4
+#define HDP4_BSEC_OUT_SEC_DBGSWENABLE		5
+#define HDP4_ETH1_OUT_PMT_INTR_O		6
+#define HDP4_ETH2_OUT_PMT_INTR_O		7
+#define HDP4_DDRCTRL_STAT_DDRC_REG_SELREF_TYPE1	8
+#define HDP4_DDRCTRL_CACTIVE_0			9
+#define HDP4_DTS_VALOBUS1_1			10
+#define HDP4_DTS_VALOBUS2_1			11
+#define HDP4_TAMP_NRESET_SRAM_ERCFG		12
+#define HDP4_NIC400_S0_WLAST			13
+#define HDP4_NIC400_S0_RLAST			14
+#define HDP4_GPOVAL_4				15
+
+#define HDP5_CA7_STANDBYWFIL2			0
+#define HDP5_PWR_VTH_VDDCORE_ACK		1
+#define HDP5_CA7_NCORERESET_I			2
+#define HDP5_CA7_NIRQOUT0			3
+#define HDP5_BSEC_IN_PWROK			4
+#define HDP5_BSEC_OUT_SEC_DEVICEEN		5
+#define HDP5_ETH1_OUT_LPI_INTR_O		6
+#define HDP5_ETH2_OUT_LPI_INTR_O		7
+#define HDP5_DDRCTRL_CACTIVE_DDRC		8
+#define HDP5_DDRCTRL_WR_CREDIT_CNT		9
+#define HDP5_DTS_VALOBUS1_2			10
+#define HDP5_DTS_VALOBUS2_2			11
+#define HDP5_PKA_PKA_ITAMP_OUT			12
+#define HDP5_NIC400_S0_WVALID			13
+#define HDP5_NIC400_S0_RVALID			14
+#define HDP5_GPOVAL_5				15
+
+#define HDP6_CA7_STANDBYWFE0			0
+#define HDP6_PWR_VTH_VDDCPU_ACK			1
+#define HDP6_CA7_EVENT0				2
+#define HDP6_BSEC_IN_TAMPER_DET			4
+#define HDP6_BSEC_OUT_SEC_SPNIDEN		5
+#define HDP6_ETH1_OUT_MAC_SPEED_O1		6
+#define HDP6_ETH2_OUT_MAC_SPEED_O1		7
+#define HDP6_DDRCTRL_CSYSACK_DDRC		8
+#define HDP6_DDRCTRL_LPR_CREDIT_CNT		9
+#define HDP6_DTS_VALOBUS1_3			10
+#define HDP6_DTS_VALOBUS2_3			11
+#define HDP6_SAES_TAMPER_OUT			12
+#define HDP6_NIC400_S0_AWREADY			13
+#define HDP6_NIC400_S0_ARREADY			14
+#define HDP6_GPOVAL_6				15
+
+#define HDP7_CA7_STANDBYWFI0			0
+#define HDP7_PWR_RCC_VCPU_RDY			1
+#define HDP7_CA7_EVENTI				2
+#define HDP7_CA7_DBGACK0			3
+#define HDP7_BSEC_OUT_FUSE_OK			4
+#define HDP7_BSEC_OUT_SEC_SPIDEN		5
+#define HDP7_ETH1_OUT_MAC_SPEED_O0		6
+#define HDP7_ETH2_OUT_MAC_SPEED_O0		7
+#define HDP7_DDRCTRL_CSYSREQ_DDRC		8
+#define HDP7_DDRCTRL_HPR_CREDIT_CNT		9
+#define HDP7_DTS_VALOBUS1_4			10
+#define HDP7_DTS_VALOBUS2_4			11
+#define HDP7_RNG_TAMPER_OUT			12
+#define HDP7_NIC400_S0_AWVALID			13
+#define HDP7_NIC400_S0_ARVALID			14
+#define HDP7_GPOVAL_7				15
+
+#endif /* _DT_BINDINGS_STM32_HDP_H */
diff --git a/include/dt-bindings/soc/stm32mp25-hdp.h b/include/dt-bindings/soc/stm32mp25-hdp.h
new file mode 100644
index 000000000..684348e2c
--- /dev/null
+++ b/include/dt-bindings/soc/stm32mp25-hdp.h
@@ -0,0 +1,147 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Roullier Christophe <christophe.roullier@st.com>
+ * for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32_HDP_H
+#define _DT_BINDINGS_STM32_HDP_H
+
+#define STM32_HDP(port, value) ((value) << ((port) * 4))
+
+/* define HDP Pins number*/
+#define HDP0_PWR_PWRWAKE_SYS			0
+#define HDP0_CPU2_SLEEPDEEP			1
+#define HDP0_BSEC_OUT_TEST_SDR_UNLOCK		2
+#define HDP0_BSEC_OUT_NIDENM			3
+#define HDP0_BSEC_OUT_NIDENA			4
+#define HDP0_CPU2_STATE_0			5
+#define HDP0_RCC_PWRDS_SYS			6
+#define HDP0_GPU_DBG7				7
+#define HDP0_DDRSS_CSYSREQ_DDRC			8
+#define HDP0_DDRSS_DFI_PHYUPD_REQ		9
+#define HDP0_CPU3_SLEEPDEEP			10
+#define HDP0_D2_GBL_PER_CLK_BUS_REQ		11
+#define HDP0_PCIE_USB_CXPL_DEBUG_INFO_EI_0	12
+#define HDP0_PCIE_USB_CXPL_DEBUG_INFO_EI_8	13
+#define HDP0_D3_STATE_0				14
+#define HDP0_GPOVAL_0				15
+
+#define HDP1_PWR_PWRWAKE_CPU2			0
+#define HDP1_CPU2_HALTED			1
+#define HDP1_CPU2_STATE_1			2
+#define HDP1_BSEC_OUT_DBGENM			3
+#define HDP1_BSEC_OUT_DBGENA			4
+#define HDP1_EXTI1_SYS_WAKEUP			5
+#define HDP1_RCC_PWRDS_CPU2			6
+#define HDP1_GPU_DBG6				7
+#define HDP1_DDRSS_CSYSACK_DDRC			8
+#define HDP1_DDRSS_DFI_PHYMSTR_REQ		9
+#define HDP1_CPU3_HALTED			10
+#define HDP1_D2_GBL_PER_DMA_REQ			11
+#define HDP1_PCIE_USB_CXPL_DEBUG_INFO_EI_1	12
+#define HDP1_PCIE_USB_CXPL_DEBUG_INFO_EI_9	13
+#define HDP1_D3_STATE_1				14
+#define HDP1_GPOVAL_1				15
+
+#define HDP2_PWR_PWRWAKE_CPU1			0
+#define HDP2_CPU2_RXEV				1
+#define HDP2_CPU1_NPMUIRQ1			2
+#define HDP2_CPU1_NFIQOUT1			3
+#define HDP2_BSEC_OUT_SHDBGEN			4
+#define HDP2_EXTI1_CPU2_WAKEUP			5
+#define HDP2_RCC_PWRDS_CPU1			6
+#define HDP2_GPU_DBG5				7
+#define HDP2_DDRSS_CACTIVE_DDRC			8
+#define HDP2_DDRSS_DFI_LP_REQ			9
+#define HDP2_CPU3_RXEV				10
+#define HDP2_HPDMA1_CLK_BUS_REQ			11
+#define HDP2_PCIE_USB_CXPL_DEBUG_INFO_EI_2	12
+#define HDP2_PCIE_USB_CXPL_DEBUG_INFO_EI_10	13
+#define HDP2_D3_STATE_2				14
+#define HDP2_GPOVAL_2				15
+
+#define HDP3_PWR_SEL_VTH_VDD_CPU		0
+#define HDP3_CPU2_TXEV				1
+#define HDP3_CPU1_NPMUIRQ0			2
+#define HDP3_CPU1_NFIQOUT0			3
+#define HDP3_BSEC_OUT_DDBGEN			4
+#define HDP3_EXTI1_CPU1_WAKEUP			5
+#define HDP3_CPU3_STATE_0			6
+#define HDP3_GPU_DBG4				7
+#define HDP3_DDRSS_MCDCG_EN			8
+#define HDP3_DDRSS_DFI_FREQ_0			9
+#define HDP3_CPU3_TXEV				10
+#define HDP3_HPDMA2_CLK_BUS_REQ			11
+#define HDP3_PCIE_USB_CXPL_DEBUG_INFO_EI_3	12
+#define HDP3_PCIE_USB_CXPL_DEBUG_INFO_EI_11	13
+#define HDP3_D1_STATE_0				14
+#define HDP3_GPOVAL_3				15
+
+#define HDP4_PWR_SEL_VTH_VDDCORE		0
+#define HDP4_CPU2_SLEEPING			1
+#define HDP4_CPU1_EVENT0			2
+#define HDP4_CPU1_NIRQOUT_1			3
+#define HDP4_BSEC_OUT_SPNIDENA			4
+#define HDP4_EXTI2_D3_WAKEUP			5
+#define HDP4_ETH1_OUT_PMT_INTR_O		6
+#define HDP4_GPU_DBG3				7
+#define HDP4_DDRSS_DPHYCG_EN			8
+#define HDP4_DDRSS_OBSP_0			9
+#define HDP4_CPU3_SLEEPING			10
+#define HDP4_HPDMA3_CLK_BUS_REQ			11
+#define HDP4_PCIE_USB_CXPL_DEBUG_INFO_EI_4	12
+#define HDP4_PCIE_USB_CXPL_DEBUG_INFO_EI_12	13
+#define HDP4_D1_STATE_1				14
+#define HDP4_GPOVAL_4				15
+
+#define HDP5_CPU1_STANDBYWFIL_2			0
+#define HDP5_CPU1_NIRQOUT_0			3
+#define HDP5_BSEC_OUT_SPIDENA			4
+#define HDP5_EXTI2_CPU3_WAKEUP			5
+#define HDP5_ETH1_OUT_LPI_INTR_O		6
+#define HDP5_GPU_DBG2				7
+#define HDP5_DDRCTRL_DFI_INIT_START		8
+#define HDP5_DDRSS_OBSP_1			9
+#define HDP5_CPU3_STATE_1			10
+#define HDP5_D3_GBL_PER_CLK_BUS_REQ		11
+#define HDP5_PCIE_USB_CXPL_DEBUG_INFO_EI_5	12
+#define HDP5_PCIE_USB_CXPL_DEBUG_INFO_EI_13	13
+#define HDP5_D1_STATE_2				14
+#define HDP5_GPOVAL_5				15
+
+#define HDP6_CPU1_STANDBYWFI_1			0
+#define HDP6_CPU1_STANDBYWFE_1			1
+#define HDP6_CPU1_HALTED_1			2
+#define HDP6_CPU1_NAXIERRIRQ			3
+#define HDP6_BSEC_OUT_SPNIDENM			4
+#define HDP6_EXTI2_CPU2_WAKEUP			5
+#define HDP6_ETH2_OUT_PMT_INTR_0		6
+#define HDP6_GPU_DBG1				7
+#define HDP6_DDRSS_DFI_INIT_COMPLETE		8
+#define HDP6_DDRSS_OBSP_2			9
+#define HDP6_D2_STATE_0				10
+#define HDP6_D3_GBL_PER_DMA_REQ			11
+#define HDP6_PCIE_USB_CXPL_DEBUG_INFO_EI_6	12
+#define HDP6_PCIE_USB_CXPL_DEBUG_INFO_EI_14	13
+#define HDP6_CPU1_STATE_0			14
+#define HDP6_GPOVAL_6				15
+
+#define HDP7_CPU1_STANDBYWFI_0			0
+#define HDP7_CPU1_STANDBYWFE_0			1
+#define HDP7_CPU1_HALTED_0			2
+#define HDP7_BSEC_OUT_SPIDENM			4
+#define HDP7_EXTI2_CPU1_WAKEUP			5
+#define HDP7_ETH2_OUT_LPI_INTR_0		6
+#define HDP7_GPU_DBG0				7
+#define HDP7_DDRSS_DFI_CTRLUPD_REQ		8
+#define HDP7_DDRSS_OBSP_3			9
+#define HDP7_D2_STATE_1				10
+#define HDP7_LPDMA_CLK_BUS_REQ			11
+#define HDP7_PCIE_USB_CXPL_DEBUG_INFO_EI_7	12
+#define HDP7_PCIE_USB_CXPL_DEBUG_INFO_EI_15	13
+#define HDP7_CPU1_STATE_1			14
+#define HDP7_GPOVAL_7				15
+
+#endif /* _DT_BINDINGS_STM32_HDP_H */
diff --git a/include/dt-bindings/spi/spi-stm32.h b/include/dt-bindings/spi/spi-stm32.h
new file mode 100644
index 000000000..7c818a399
--- /dev/null
+++ b/include/dt-bindings/spi/spi-stm32.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+/*
+ * This header provides constants for STM32_SPI bindings.
+ */
+
+#ifndef _DT_BINDINGS_SPI_SPI_STM32_H
+#define _DT_BINDINGS_SPI_SPI_STM32_H
+
+/* st,spi-slave-underrun first parameter */
+#define SPI_NO_ACTION			        0
+#define SPI_SEND_PATTERN		        1
+#define SPI_REPEAT_LAST_RECEIVED_DATA	        2
+#define SPI_REPEAT_LAST_TRANSMITTED_DATA        3
+
+#endif
diff --git a/include/linux/iio/timer/stm32-lptim-trigger.h b/include/linux/iio/timer/stm32-lptim-trigger.h
index a34dcf6a6..1a0b7e3e1 100644
--- a/include/linux/iio/timer/stm32-lptim-trigger.h
+++ b/include/linux/iio/timer/stm32-lptim-trigger.h
@@ -14,6 +14,8 @@
 #define LPTIM1_OUT	"lptim1_out"
 #define LPTIM2_OUT	"lptim2_out"
 #define LPTIM3_OUT	"lptim3_out"
+#define LPTIM4_OUT	"lptim4_out"
+#define LPTIM5_OUT	"lptim5_out"
 
 #if IS_REACHABLE(CONFIG_IIO_STM32_LPTIMER_TRIGGER)
 bool is_stm32_lptim_trigger(struct iio_trigger *trig);
diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 9ee238ad2..553da4899 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -64,6 +64,10 @@ struct irq_fwspec {
 	u32 param[IRQ_DOMAIN_IRQ_SPEC_PARAMS];
 };
 
+/* Conversion function from of_phandle_args fields to fwspec  */
+void of_phandle_args_to_fwspec(struct device_node *np, const u32 *args,
+			       unsigned int count, struct irq_fwspec *fwspec);
+
 /*
  * Should several domains have the same device node, but serve
  * different purposes (for example one domain is for PCI/MSI, and the
diff --git a/include/linux/mfd/stm32-lptimer.h b/include/linux/mfd/stm32-lptimer.h
index 90b20550c..5a6affc9b 100644
--- a/include/linux/mfd/stm32-lptimer.h
+++ b/include/linux/mfd/stm32-lptimer.h
@@ -17,18 +17,26 @@
 #define STM32_LPTIM_IER		0x08	/* Interrupt Enable Reg      */
 #define STM32_LPTIM_CFGR	0x0C	/* Configuration Reg         */
 #define STM32_LPTIM_CR		0x10	/* Control Reg               */
-#define STM32_LPTIM_CMP		0x14	/* Compare Reg               */
+#define STM32_LPTIM_CMP		0x14	/* Compare Reg (CCR1 on mp25)*/
 #define STM32_LPTIM_ARR		0x18	/* Autoreload Reg            */
 #define STM32_LPTIM_CNT		0x1C	/* Counter Reg               */
+#define STM32MP25_LPTIM_CCMR1	0x2C	/* Capture/Compare Mode Reg  */
+#define STM32MP25_LPTIM_CCR2	0x34	/* Compare Reg2              */
+
+#define STM32MP25_LPTIM_HWCFGR2	0x3EC	/* Hardware configuration register 2 */
+#define STM32MP15_LPTIM_HWCFGR	0x3F0	/* Hardware configuration register 1 */
+#define STM32MP15_LPTIM_VERR	0x3F4	/* Version identification register   */
 
 /* STM32_LPTIM_ISR - bit fields */
+#define STM32_LPTIM_CMP2_ARROK		(BIT(19) | BIT(4))
 #define STM32_LPTIM_CMPOK_ARROK		GENMASK(4, 3)
 #define STM32_LPTIM_ARROK		BIT(4)
 #define STM32_LPTIM_CMPOK		BIT(3)
 
 /* STM32_LPTIM_ICR - bit fields */
-#define STM32_LPTIM_ARRMCF		BIT(1)
+#define STM32_LPTIM_CMP2OKCF_ARROKCF	(BIT(19) | BIT(4))
 #define STM32_LPTIM_CMPOKCF_ARROKCF	GENMASK(4, 3)
+#define STM32_LPTIM_ARRMCF		BIT(1)
 
 /* STM32_LPTIM_IER - bit flieds */
 #define STM32_LPTIM_ARRMIE	BIT(1)
@@ -48,16 +56,36 @@
 /* STM32_LPTIM_ARR */
 #define STM32_LPTIM_MAX_ARR	0xFFFF
 
+/* STM32MP25_LPTIM_CCMR1 */
+#define STM32MP25_LPTIM_CC2P	GENMASK(19, 18)
+#define STM32MP25_LPTIM_CC2E	BIT(17)
+#define STM32MP25_LPTIM_CC2SEL	BIT(16)
+#define STM32MP25_LPTIM_CC1P	GENMASK(3, 2)
+#define STM32MP25_LPTIM_CC1E	BIT(1)
+#define STM32MP25_LPTIM_CC1SEL	BIT(0)
+
+/* STM32MP15_LPTIM_HWCFGR */
+#define STM32MP15_LPTIM_HWCFGR_ENCODER	BIT(16)
+
+/* STM32MP25_LPTIM_HWCFGR2 */
+#define STM32MP25_LPTIM_HWCFGR2_CHAN_NUM	GENMASK(3, 0)
+
+/* STM32MP15_LPTIM_VERR */
+#define STM32MP15_MINREV_MASK		GENMASK(3, 0)
+#define STM32MP15_MAJREV_MASK		GENMASK(7, 4)
+
 /**
  * struct stm32_lptimer - STM32 Low-Power Timer data assigned by parent device
  * @clk: clock reference for this instance
  * @regmap: register map reference for this instance
  * @has_encoder: indicates this Low-Power Timer supports encoder mode
+ * @num_cc_chans: indicates the number of capture/compare channels
  */
 struct stm32_lptimer {
 	struct clk *clk;
 	struct regmap *regmap;
 	bool has_encoder;
+	unsigned int num_cc_chans;
 };
 
 #endif
diff --git a/include/linux/mfd/stm32-timers.h b/include/linux/mfd/stm32-timers.h
index f8db83aed..f48f04dc4 100644
--- a/include/linux/mfd/stm32-timers.h
+++ b/include/linux/mfd/stm32-timers.h
@@ -31,6 +31,7 @@
 #define TIM_BDTR	0x44	/* Break and Dead-Time Reg */
 #define TIM_DCR		0x48	/* DMA control register    */
 #define TIM_DMAR	0x4C	/* DMA register for transfer */
+#define TIM_TISEL	0x68	/* Input Selection         */
 
 #define TIM_CR1_CEN	BIT(0)	/* Counter Enable	   */
 #define TIM_CR1_DIR	BIT(4)  /* Counter Direction	   */
diff --git a/include/linux/ptp_clock_kernel.h b/include/linux/ptp_clock_kernel.h
index 554454cb8..193e15066 100644
--- a/include/linux/ptp_clock_kernel.h
+++ b/include/linux/ptp_clock_kernel.h
@@ -160,6 +160,9 @@ struct ptp_clock_info {
 	int (*verify)(struct ptp_clock_info *ptp, unsigned int pin,
 		      enum ptp_pin_function func, unsigned int chan);
 	long (*do_aux_work)(struct ptp_clock_info *ptp);
+	int (*getphcxtstamp)(struct ptp_clock_info *ptp,
+						 struct ptp_clock_info *ptp_peer,
+						 struct device_device_crosststamp *cts);
 };
 
 struct ptp_clock;
@@ -232,6 +235,8 @@ static inline long scaled_ppm_to_ppb(long ppm)
 extern struct ptp_clock *ptp_clock_register(struct ptp_clock_info *info,
 					    struct device *parent);
 
+extern int ptp_clock_set_peer(struct ptp_clock *ptp, struct ptp_clock *peer);
+
 /**
  * ptp_clock_unregister() - unregister a PTP hardware clock driver
  *
diff --git a/include/linux/remoteproc.h b/include/linux/remoteproc.h
index 83c09ac36..bc498717c 100644
--- a/include/linux/remoteproc.h
+++ b/include/linux/remoteproc.h
@@ -467,6 +467,18 @@ enum rproc_dump_mechanism {
 	RPROC_COREDUMP_INLINE,
 };
 
+/**
+ * enum rproc_fw_format - firmware image format supported
+ * @RPROC_FW_ELF:    the firmware image must be in ELF format
+ * @RPROC_FW_TEE:    the firmware image must be in format that will be treated by the TEE
+ * @RPROC_FW_LAST:   just keep this one at the end
+ */
+enum rproc_fw_format {
+	RPROC_FW_ELF,
+	RPROC_FW_TEE,
+	RPROC_FW_LAST,
+};
+
 /**
  * struct rproc_dump_segment - segment info from ELF header
  * @node:	list node related to the rproc segment list
@@ -568,6 +580,7 @@ struct rproc {
 	u16 elf_machine;
 	struct cdev cdev;
 	bool cdev_put_on_release;
+	unsigned int fw_format;
 };
 
 /**
diff --git a/include/linux/rpmsg.h b/include/linux/rpmsg.h
index a8dcf8a9a..02fa9116c 100644
--- a/include/linux/rpmsg.h
+++ b/include/linux/rpmsg.h
@@ -186,6 +186,8 @@ int rpmsg_trysend_offchannel(struct rpmsg_endpoint *ept, u32 src, u32 dst,
 __poll_t rpmsg_poll(struct rpmsg_endpoint *ept, struct file *filp,
 			poll_table *wait);
 
+ssize_t rpmsg_get_mtu(struct rpmsg_endpoint *ept);
+
 #else
 
 static inline int rpmsg_register_device(struct rpmsg_device *rpdev)
@@ -296,6 +298,14 @@ static inline __poll_t rpmsg_poll(struct rpmsg_endpoint *ept,
 	return 0;
 }
 
+static inline ssize_t rpmsg_get_mtu(struct rpmsg_endpoint *ept)
+{
+	/* This shouldn't be possible */
+	WARN_ON(1);
+
+	return -ENXIO;
+}
+
 #endif /* IS_ENABLED(CONFIG_RPMSG) */
 
 /* use a macro to avoid include chaining to get THIS_MODULE */
diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index 80e781c51..f0b8bc4cf 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -82,6 +82,10 @@ struct scmi_clk_proto_ops {
 			u64 rate);
 	int (*enable)(const struct scmi_protocol_handle *ph, u32 clk_id);
 	int (*disable)(const struct scmi_protocol_handle *ph, u32 clk_id);
+	int (*get_duty_cycle)(const struct scmi_protocol_handle *ph,
+			      u32 clk_id, int *num, int *den);
+	int (*round_rate_get)(const struct scmi_protocol_handle *ph,
+			      u32 clk_id, u64 *rate);
 };
 
 /**
diff --git a/include/linux/smscphy.h b/include/linux/smscphy.h
index 1a136271b..00884908e 100644
--- a/include/linux/smscphy.h
+++ b/include/linux/smscphy.h
@@ -14,6 +14,7 @@
 #define MII_LAN83C185_ISF_INT5 (1<<5) /* Remote Fault Detected */
 #define MII_LAN83C185_ISF_INT6 (1<<6) /* Auto-Negotiation complete */
 #define MII_LAN83C185_ISF_INT7 (1<<7) /* ENERGYON */
+#define MII_LAN83C185_ISF_INT8 (1<<8) /* Wake on LAN */
 
 #define MII_LAN83C185_ISF_INT_ALL (0x0e)
 
@@ -28,4 +29,23 @@
 #define MII_LAN83C185_MODE_POWERDOWN 0xC0 /* Power Down mode */
 #define MII_LAN83C185_MODE_ALL       0xE0 /* All capable mode */
 
+/* MMD 3 Registers */
+#define	LAN8742_MMD3_WAKEUP_CTRL	(32784)
+#define	LAN8742_MMD3_WUCSR_LED2_AS_NPME BIT(12)
+#define	LAN8742_MMD3_WUCSR_WOL		BIT(8)
+#define	LAN8742_MMD3_WUCSR_PFDA_FR	BIT(7)
+#define	LAN8742_MMD3_WUCSR_WUFR		BIT(6)
+#define	LAN8742_MMD3_WUCSR_MPR		BIT(5)
+#define	LAN8742_MMD3_WUCSR_BCAST_FR	BIT(4)
+#define	LAN8742_MMD3_WUCSR_MPEN		BIT(1)
+
+#define	LAN8742_MMD3_WAKEUP_FILTER	(32785)
+#define	LAN8742_MMD3_WUF_CFGA_FE	BIT(15)
+#define	LAN8742_MMD3_WUF_CFGA_AME	BIT(10)
+
+#define	LAN8742_MMD3_MAC_ADDRA		(32865)
+#define	LAN8742_MMD3_MAC_ADDRB		(32866)
+#define	LAN8742_MMD3_MAC_ADDRC		(32867)
+#define	LAN8742_MMD3_PME_ASSERT_DELAY	(32868)
+
 #endif /* __LINUX_SMSCPHY_H__ */
diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index 38b701b7a..7501b9bf6 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -50,6 +50,8 @@ struct tee_shm_pool;
  *              non-blocking in nature.
  * @cap_memref_null: flag indicating if the TEE Client support shared
  *                   memory buffer with a NULL pointer.
+ * @cap_ocall:       flag indicating that OP-TEE supports OCALLs, allowing TAs
+ *                   to invoke commands on their CA.
  */
 struct tee_context {
 	struct tee_device *teedev;
@@ -58,6 +60,7 @@ struct tee_context {
 	bool releasing;
 	bool supp_nowait;
 	bool cap_memref_null;
+	bool cap_ocall;
 };
 
 struct tee_param_memref {
@@ -101,11 +104,15 @@ struct tee_driver_ops {
 	void (*release)(struct tee_context *ctx);
 	int (*open_session)(struct tee_context *ctx,
 			    struct tee_ioctl_open_session_arg *arg,
-			    struct tee_param *param);
+			    struct tee_param *normal_param,
+			    u32 num_normal_params,
+			    struct tee_param *ocall_param);
 	int (*close_session)(struct tee_context *ctx, u32 session);
 	int (*invoke_func)(struct tee_context *ctx,
 			   struct tee_ioctl_invoke_arg *arg,
-			   struct tee_param *param);
+			   struct tee_param *normal_param,
+			   u32 num_normal_params,
+			   struct tee_param *ocall_param);
 	int (*cancel_req)(struct tee_context *ctx, u32 cancel_id, u32 session);
 	int (*supp_recv)(struct tee_context *ctx, u32 *func, u32 *num_params,
 			 struct tee_param *param);
@@ -363,6 +370,12 @@ static inline bool tee_shm_is_registered(struct tee_shm *shm)
  */
 void tee_shm_free(struct tee_shm *shm);
 
+/**
+ * tee_shm_get() - Increase reference count on a shared memory handle
+ * @shm:	Shared memory handle
+ */
+void tee_shm_get(struct tee_shm *shm);
+
 /**
  * tee_shm_put() - Decrease reference count on a shared memory handle
  * @shm:	Shared memory handle
diff --git a/include/linux/tee_remoteproc.h b/include/linux/tee_remoteproc.h
new file mode 100644
index 000000000..5ba0b6116
--- /dev/null
+++ b/include/linux/tee_remoteproc.h
@@ -0,0 +1,101 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright(c) 2020 STMicroelectronics 2020
+ */
+
+#ifndef TEE_REMOTEPROC_H
+#define TEE_REMOTEPROC_H
+
+#include <linux/remoteproc.h>
+#include <linux/tee_drv.h>
+
+/**
+ * struct tee_rproc - TEE remoteproc structure
+ * @node:		Reference in list
+ * @rproc:		Remoteproc reference
+ * @parent:		Parent device
+ * @fw_id:		Identifier of the target firmware
+ * @session_id:		TEE session identifier
+ * @rsc_va:		Resource table virtual address.
+ */
+struct tee_rproc {
+	struct list_head node;
+
+	struct rproc *rproc;
+	struct device *parent;
+	u32 fw_id;
+	u32 session_id;
+	void *rsc_va;
+};
+
+#if IS_ENABLED(CONFIG_TEE_REMOTEPROC)
+
+struct tee_rproc *tee_rproc_register(struct device *dev, unsigned int fw_id);
+int tee_rproc_unregister(struct tee_rproc *trproc);
+
+int tee_rproc_load_fw(struct tee_rproc *trproc, const struct firmware *fw);
+int rproc_tee_get_rsc_table(struct tee_rproc *trproc);
+struct resource_table *tee_rproc_get_loaded_rsc_table(struct tee_rproc *trproc);
+int tee_rproc_start(struct tee_rproc *trproc);
+int tee_rproc_stop(struct tee_rproc *trproc);
+
+#else
+
+static inline struct tee_rproc *tee_rproc_register(struct device *dev,
+						   unsigned int fw_id)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline int tee_rproc_unregister(struct tee_rproc *trproc)
+{
+	/* This shouldn't be possible */
+	WARN_ON(1);
+
+	return 0;
+}
+
+static inline int tee_rproc_load_fw(struct tee_rproc *trproc,
+				    const struct firmware *fw)
+{
+	/* This shouldn't be possible */
+	WARN_ON(1);
+
+	return 0;
+}
+
+static inline int tee_rproc_start(struct tee_rproc *trproc)
+{
+	/* This shouldn't be possible */
+	WARN_ON(1);
+
+	return 0;
+}
+
+static inline int tee_rproc_stop(struct tee_rproc *trproc)
+{
+	/* This shouldn't be possible */
+	WARN_ON(1);
+
+	return 0;
+}
+
+static inline int rproc_tee_get_rsc_table(struct tee_rproc *trproc)
+{
+	/* This shouldn't be possible */
+	WARN_ON(1);
+
+	return 0;
+}
+
+static inline struct resource_table *
+	tee_rproc_get_loaded_rsc_table(struct tee_rproc *trproc)
+{
+	/* This shouldn't be possible */
+	WARN_ON(1);
+
+	return NULL;
+}
+
+#endif /* CONFIG_TEE_REMOTEPROC */
+#endif /* TEE_REMOTEPROC_H */
diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 78a98bdff..de104e30b 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -265,6 +265,11 @@ struct system_device_crosststamp {
 	ktime_t sys_monoraw;
 };
 
+struct device_device_crosststamp {
+	ktime_t device;
+	ktime_t peer_device;
+};
+
 /**
  * struct system_counterval_t - system counter value with the pointer to the
  *				corresponding clocksource
diff --git a/include/media/mipi-csi2.h b/include/media/mipi-csi2.h
new file mode 100644
index 000000000..392794e5b
--- /dev/null
+++ b/include/media/mipi-csi2.h
@@ -0,0 +1,45 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * MIPI CSI-2 Data Types
+ *
+ * Copyright (C) 2022 Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ */
+
+#ifndef _MEDIA_MIPI_CSI2_H
+#define _MEDIA_MIPI_CSI2_H
+
+/* Short packet data types */
+#define MIPI_CSI2_DT_FS			0x00
+#define MIPI_CSI2_DT_FE			0x01
+#define MIPI_CSI2_DT_LS			0x02
+#define MIPI_CSI2_DT_LE			0x03
+#define MIPI_CSI2_DT_GENERIC_SHORT(n)	(0x08 + (n))	/* 0..7 */
+
+/* Long packet data types */
+#define MIPI_CSI2_DT_NULL		0x10
+#define MIPI_CSI2_DT_BLANKING		0x11
+#define MIPI_CSI2_DT_EMBEDDED_8B	0x12
+#define MIPI_CSI2_DT_YUV420_8B		0x18
+#define MIPI_CSI2_DT_YUV420_10B		0x19
+#define MIPI_CSI2_DT_YUV420_8B_LEGACY	0x1a
+#define MIPI_CSI2_DT_YUV420_8B_CS	0x1c
+#define MIPI_CSI2_DT_YUV420_10B_CS	0x1d
+#define MIPI_CSI2_DT_YUV422_8B		0x1e
+#define MIPI_CSI2_DT_YUV422_10B		0x1f
+#define MIPI_CSI2_DT_RGB444		0x20
+#define MIPI_CSI2_DT_RGB555		0x21
+#define MIPI_CSI2_DT_RGB565		0x22
+#define MIPI_CSI2_DT_RGB666		0x23
+#define MIPI_CSI2_DT_RGB888		0x24
+#define MIPI_CSI2_DT_RAW24		0x27
+#define MIPI_CSI2_DT_RAW6		0x28
+#define MIPI_CSI2_DT_RAW7		0x29
+#define MIPI_CSI2_DT_RAW8		0x2a
+#define MIPI_CSI2_DT_RAW10		0x2b
+#define MIPI_CSI2_DT_RAW12		0x2c
+#define MIPI_CSI2_DT_RAW14		0x2d
+#define MIPI_CSI2_DT_RAW16		0x2e
+#define MIPI_CSI2_DT_RAW20		0x2f
+#define MIPI_CSI2_DT_USER_DEFINED(n)	(0x30 + (n))	/* 0..7 */
+
+#endif /* _MEDIA_MIPI_CSI2_H */
diff --git a/include/media/v4l2-fwnode.h b/include/media/v4l2-fwnode.h
index 7ab033b81..065ce8d26 100644
--- a/include/media/v4l2-fwnode.h
+++ b/include/media/v4l2-fwnode.h
@@ -49,11 +49,13 @@ struct v4l2_fwnode_bus_mipi_csi2 {
  * @flags: media bus (V4L2_MBUS_*) flags
  * @bus_width: bus width in bits
  * @data_shift: data shift in bits
+ * @max_pclk_frequency: maximum pixel clock in hertz
  */
 struct v4l2_fwnode_bus_parallel {
 	unsigned int flags;
 	unsigned char bus_width;
 	unsigned char data_shift;
+	unsigned int pclk_max_frequency;
 };
 
 /**
diff --git a/include/memory/stm32-omi.h b/include/memory/stm32-omi.h
new file mode 100644
index 000000000..114db13ba
--- /dev/null
+++ b/include/memory/stm32-omi.h
@@ -0,0 +1,196 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ * Author(s): Patrice Chotard <patrice.chotard@foss.st.com> for STMicroelectronics.
+ */
+
+#ifndef __STM32_OMI_H
+#define __STM32_OMI_H
+
+#include <linux/bitfield.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/mtd/hyperbus.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/sizes.h>
+#include <linux/spi/spi-mem.h>
+#include <linux/types.h>
+
+#define OSPI_CR			0x00
+#define CR_EN			BIT(0)
+#define CR_ABORT		BIT(1)
+#define CR_DMAEN		BIT(2)
+#define CR_TCEN			BIT(3)
+#define CR_FTHRES_SHIFT		8
+#define CR_TEIE			BIT(16)
+#define CR_TCIE			BIT(17)
+#define CR_SMIE			BIT(19)
+#define CR_APMS			BIT(22)
+#define CR_CSSEL		BIT(24)
+#define CR_FMODE_MASK		GENMASK(29, 28)
+#define CR_FMODE_INDW		(0U)
+#define CR_FMODE_INDR		(1U)
+#define CR_FMODE_APM		(2U)
+#define CR_FMODE_MM		(3U)
+
+#define OSPI_DCR1		0x08
+#define DCR1_FRCK		BIT(1)
+#define DCR1_DLYBYP		BIT(3)
+#define DCR1_DEVSIZE_MASK	GENMASK(20, 16)
+#define DCR1_MTYP_MASK		GENMASK(26, 24)
+#define DCR1_MTYP_HP_MEMMODE	4
+
+#define OSPI_DCR2		0x0c
+#define DCR2_PRESC_MASK		GENMASK(7, 0)
+
+#define OSPI_SR			0x20
+#define SR_TEF			BIT(0)
+#define SR_TCF			BIT(1)
+#define SR_FTF			BIT(2)
+#define SR_SMF			BIT(3)
+#define SR_BUSY			BIT(5)
+
+#define OSPI_FCR		0x24
+#define FCR_CTEF		BIT(0)
+#define FCR_CTCF		BIT(1)
+#define FCR_CSMF		BIT(3)
+
+#define OSPI_DLR		0x40
+#define OSPI_AR			0x48
+#define OSPI_DR			0x50
+#define OSPI_PSMKR		0x80
+#define OSPI_PSMAR		0x88
+
+#define OSPI_CCR		0x100
+#define CCR_IMODE_MASK		GENMASK(2, 0)
+#define CCR_ADMODE_MASK		GENMASK(10, 8)
+#define CCR_ADMODE_8LINES	4
+#define CCR_ADDTR		BIT(11)
+#define CCR_ADSIZE_MASK		GENMASK(13, 12)
+#define CCR_ADSIZE_32BITS	3
+#define CCR_DMODE_MASK		GENMASK(26, 24)
+#define CCR_DMODE_8LINES	4
+#define CCR_DQSE		BIT(29)
+#define CCR_DDTR		BIT(27)
+#define CCR_BUSWIDTH_0		0x0
+#define CCR_BUSWIDTH_1		0x1
+#define CCR_BUSWIDTH_2		0x2
+#define CCR_BUSWIDTH_4		0x3
+#define CCR_BUSWIDTH_8		0x4
+
+#define OSPI_TCR		0x108
+#define TCR_DCYC_MASK		GENMASK(4, 0)
+#define TCR_DHQC		BIT(28)
+#define TCR_SSHIFT		BIT(30)
+
+#define OSPI_IR			0x110
+
+#define OSPI_LPTR		0x130
+#define LPTR_TIMEOUT_MASK	GENMASK(15, 0)
+
+#define OSPI_WCCR		0x180
+#define WCCR_DQSE		BIT(29)
+#define WCCR_DDTR		BIT(27)
+#define WCCR_DMODE_MASK		GENMASK(26, 24)
+#define WCCR_DMODE_8LINES	4
+#define WCCR_ADSIZE_MASK	GENMASK(13, 12)
+#define WCCR_ADSIZE_32BITS	3
+#define WCCR_ADDTR		BIT(11)
+#define WCCR_ADMODE_MASK	GENMASK(10, 8)
+#define WCCR_ADMODE_8LINES	4
+
+#define OSPI_HLCR		0x200
+#define HLCR_WZL		BIT(1)
+#define HLCR_TACC_MASK		GENMASK(15, 8)
+
+#define SYSCFG_DLYBOS_CR		0
+#define DLYBOS_CR_EN			BIT(0)
+#define DLYBOS_CR_RXTAPSEL_SHIFT	1
+#define DLYBOS_CR_RXTAPSEL_MASK		GENMASK(6, 1)
+#define DLYBOS_CR_TXTAPSEL_SHIFT	7
+#define DLYBOS_CR_TXTAPSEL_MASK		GENMASK(12, 7)
+#define DLYBOS_TAPSEL_NB		33
+#define DLYBOS_BYP_EN			BIT(16)
+#define DLYBOS_BYP_CMD_MASK		GENMASK(21, 17)
+
+#define SYSCFG_DLYBOS_SR	4
+#define DLYBOS_SR_LOCK		BIT(0)
+#define DLYBOS_SR_RXTAPSEL_ACK	BIT(1)
+#define DLYBOS_SR_TXTAPSEL_ACK	BIT(2)
+
+#define STM32_OMI_MAX_MMAP_SZ	SZ_256M
+#define STM32_OMI_MAX_NORCHIP	2
+
+#define STM32_FIFO_TIMEOUT_US		30000
+#define STM32_ABT_TIMEOUT_US		100000
+#define STM32_COMP_TIMEOUT_MS		1000
+#define STM32_BUSY_TIMEOUT_US		100000
+#define STM32_DLYB_FREQ_THRESHOLD	50000000
+#define STM32_DLYBOS_TIMEOUT_MS		1000
+#define STM32_DLYBOS_DELAY_NB		24
+
+struct stm32_omi {
+	struct device *dev;
+	struct clk *clk;
+	struct regmap *regmap;
+
+	struct completion data_completion;
+	struct completion match_completion;
+
+	struct dma_chan *dma_chtx;
+	struct dma_chan *dma_chrx;
+	struct completion dma_completion;
+
+	void __iomem *regs_base;
+	void __iomem *mm_base;
+	phys_addr_t mm_phys_base;
+	phys_addr_t regs_phys_base;
+	resource_size_t mm_size;
+	u32 clk_rate;
+	u32 fmode;
+	u32 dlyb_base;
+	int irq;
+	bool dlyb_byp;
+
+	int (*check_transfer)(struct stm32_omi *omi);
+};
+
+struct stm32_tap_window {
+	u8 end;
+	u8 length;
+};
+
+int stm32_omi_abort(struct stm32_omi *omi);
+int stm32_omi_dlyb_configure(struct stm32_omi *omi, bool bypass_mode,
+			     u16 period_ps);
+int stm32_omi_dlyb_find_tap(struct stm32_omi *omi, bool rx_only);
+int stm32_omi_dlyb_set_tap(struct stm32_omi *omi, u8 tap, bool rx_tap);
+void stm32_omi_dma_callback(void *arg);
+void stm32_omi_dma_free(struct stm32_omi *omi);
+int stm32_omi_dma_setup(struct stm32_omi *omi, struct device *dev,
+			struct dma_slave_config *dma_cfg);
+int stm32_omi_get_resources(struct stm32_omi *omi, struct device *dev);
+irqreturn_t stm32_omi_irq(int irq, void *dev_id);
+int stm32_omi_tx_poll(struct stm32_omi *omi, u8 *buf, u32 len, bool read);
+int stm32_omi_wait_cmd(struct stm32_omi *omi);
+int stm32_omi_wait_nobusy(struct stm32_omi *omi);
+
+#endif /* __STM32_OMI_H */
diff --git a/include/uapi/linux/ethtool.h b/include/uapi/linux/ethtool.h
index b6db6590b..16da6e7fd 100644
--- a/include/uapi/linux/ethtool.h
+++ b/include/uapi/linux/ethtool.h
@@ -1340,7 +1340,9 @@ struct ethtool_ts_info {
 	__u32	tx_types;
 	__u32	tx_reserved[3];
 	__u32	rx_filters;
-	__u32	rx_reserved[3];
+	__s32   phc_index_2nd;
+	__s32   phc_worker;
+	__s32   phc_timestamper;
 };
 
 /*
@@ -2063,4 +2065,10 @@ struct ethtool_link_settings {
 	 * __u32 map_lp_advertising[link_mode_masks_nwords];
 	 */
 };
+
+struct ethtool_clock {
+	__u32   cmd;
+	__s32   phc_index;
+};
+
 #endif /* _UAPI_LINUX_ETHTOOL_H */
diff --git a/include/uapi/linux/ptp_clock.h b/include/uapi/linux/ptp_clock.h
index 1d108d597..bc03da16d 100644
--- a/include/uapi/linux/ptp_clock.h
+++ b/include/uapi/linux/ptp_clock.h
@@ -95,7 +95,9 @@ struct ptp_clock_caps {
 	int cross_timestamping;
 	/* Whether the clock supports adjust phase */
 	int adjust_phase;
-	int rsv[12];   /* Reserved for future use. */
+	/* Whether the clock supports precise cross timestamps with peer clock */
+	int peer_cross_timestamping;
+	int rsv[11];   /* Reserved for future use. */
 };
 
 struct ptp_extts_request {
@@ -104,6 +106,12 @@ struct ptp_extts_request {
 	unsigned int rsv[2]; /* Reserved for future use. */
 };
 
+struct ptp_ptp_offset_precise {
+	struct ptp_clock_time device;
+	struct ptp_clock_time peer;
+	unsigned int rsv[4];    /* Reserved for future use. */
+};
+
 struct ptp_perout_request {
 	union {
 		/*
@@ -223,6 +231,8 @@ struct ptp_pin_desc {
 	_IOWR(PTP_CLK_MAGIC, 17, struct ptp_sys_offset_precise)
 #define PTP_SYS_OFFSET_EXTENDED2 \
 	_IOWR(PTP_CLK_MAGIC, 18, struct ptp_sys_offset_extended)
+#define PTP_PTP_OFFSET_PRECISE \
+	_IOWR(PTP_CLK_MAGIC, 19, struct ptp_ptp_offset_precise)
 
 struct ptp_extts_event {
 	struct ptp_clock_time t; /* Time event occured. */
diff --git a/include/uapi/linux/rpmsg.h b/include/uapi/linux/rpmsg.h
index f5ca8740f..1637e6817 100644
--- a/include/uapi/linux/rpmsg.h
+++ b/include/uapi/linux/rpmsg.h
@@ -33,4 +33,14 @@ struct rpmsg_endpoint_info {
  */
 #define RPMSG_DESTROY_EPT_IOCTL	_IO(0xb5, 0x2)
 
+/**
+ * Instantiate a new local rpmsg service device.
+ */
+#define RPMSG_CREATE_DEV_IOCTL	_IOW(0xb5, 0x3, struct rpmsg_endpoint_info)
+
+/**
+ * Release a local rpmsg device.
+ */
+#define RPMSG_RELEASE_DEV_IOCTL	_IOW(0xb5, 0x4, struct rpmsg_endpoint_info)
+
 #endif
diff --git a/include/uapi/linux/serial.h b/include/uapi/linux/serial.h
index fa6b16e5f..e79080578 100644
--- a/include/uapi/linux/serial.h
+++ b/include/uapi/linux/serial.h
@@ -128,7 +128,9 @@ struct serial_rs485 {
 							   (if supported) */
 	__u32	delay_rts_before_send;	/* Delay before send (milliseconds) */
 	__u32	delay_rts_after_send;	/* Delay after send (milliseconds) */
-	__u32	padding[5];		/* Memory is cheap, new structs
+	__u32	delay_rts_before_send_ns;	/* Delay (nanoseconds) */
+	__u32	delay_rts_after_send_ns;	/* Delay (nanoseconds) */
+	__u32	padding[3];		/* Memory is cheap, new structs
 					   are a royal PITA .. */
 };
 
diff --git a/include/uapi/linux/tee.h b/include/uapi/linux/tee.h
index 25a6c534b..157ec3dbd 100644
--- a/include/uapi/linux/tee.h
+++ b/include/uapi/linux/tee.h
@@ -52,6 +52,7 @@
 #define TEE_GEN_CAP_PRIVILEGED	(1 << 1)/* Privileged device (for supplicant) */
 #define TEE_GEN_CAP_REG_MEM	(1 << 2)/* Supports registering shared memory */
 #define TEE_GEN_CAP_MEMREF_NULL	(1 << 3)/* NULL MemRef support */
+#define TEE_GEN_CAP_OCALL	(1 << 30)/* Supports calls from TA to CA */
 
 #define TEE_MEMREF_NULL		(__u64)(-1) /* NULL MemRef Buffer */
 
@@ -162,9 +163,14 @@ struct tee_ioctl_buf_data {
 /* Meta parameter carrying extra information about the message. */
 #define TEE_IOCTL_PARAM_ATTR_META		0x100
 
+/* Parameter carrying information about an OCALL reply or request. */
+#define TEE_IOCTL_PARAM_ATTR_OCALL		0x200
+
 /* Mask of all known attr bits */
 #define TEE_IOCTL_PARAM_ATTR_MASK \
-	(TEE_IOCTL_PARAM_ATTR_TYPE_MASK | TEE_IOCTL_PARAM_ATTR_META)
+	(TEE_IOCTL_PARAM_ATTR_TYPE_MASK | \
+	 TEE_IOCTL_PARAM_ATTR_META      | \
+	 TEE_IOCTL_PARAM_ATTR_OCALL)
 
 /*
  * Matches TEEC_LOGIN_* in GP TEE Client API
@@ -257,6 +263,34 @@ struct tee_ioctl_open_session_arg {
 #define TEE_IOC_OPEN_SESSION	_IOR(TEE_IOC_MAGIC, TEE_IOC_BASE + 2, \
 				     struct tee_ioctl_buf_data)
 
+/*
+ * Command sent to the CA to execute an OCALL by Id.
+ *
+ * [any] param[0..3].u.*		carry OCALL parameters
+ */
+#define TEE_IOCTL_OCALL_CMD_INVOKE	3
+
+/*
+ * Join the Id of the function that the TEE Client API must execute on behalf of
+ * the CA with the Id of the command that the CA must execute
+ *
+ * As an example, TEE_IOCTL_OCALL_MAKE_PAIR(TEE_IOCTL_OCALL_CMD_INVOKE, 10)
+ * means that the Client API must forward a function invocation to a CA-provided
+ * handler, and the handler must execute command Id '10', whose meaning is up to
+ * the user-defined contract between the CA & TA.
+ */
+#define TEE_IOCTL_OCALL_MAKE_PAIR(func, cmd)	\
+	(((__u64)(func) << 32) | (__u32)(cmd))
+
+/*
+ * Get the Id of the function that the TEE Client API must execute on behalf of
+ * the CA
+ */
+#define TEE_IOCTL_OCALL_GET_FUNC(x)		((__u32)((x) >> 32))
+
+/* Get the Id of the command that the CA must execute */
+#define TEE_IOCTL_OCALL_GET_CMD(x)		((__u32)(x))
+
 /**
  * struct tee_ioctl_invoke_func_arg - Invokes a function in a Trusted
  * Application
diff --git a/kernel/irq/irqdomain.c b/kernel/irq/irqdomain.c
index 035e3038c..5c74ebb13 100644
--- a/kernel/irq/irqdomain.c
+++ b/kernel/irq/irqdomain.c
@@ -744,9 +744,8 @@ static int irq_domain_translate(struct irq_domain *d,
 	return 0;
 }
 
-static void of_phandle_args_to_fwspec(struct device_node *np, const u32 *args,
-				      unsigned int count,
-				      struct irq_fwspec *fwspec)
+void of_phandle_args_to_fwspec(struct device_node *np, const u32 *args,
+			       unsigned int count, struct irq_fwspec *fwspec)
 {
 	int i;
 
@@ -756,6 +755,7 @@ static void of_phandle_args_to_fwspec(struct device_node *np, const u32 *args,
 	for (i = 0; i < count; i++)
 		fwspec->param[i] = args[i];
 }
+EXPORT_SYMBOL_GPL(of_phandle_args_to_fwspec);
 
 unsigned int irq_create_fwspec_mapping(struct irq_fwspec *fwspec)
 {
diff --git a/kernel/power/suspend.c b/kernel/power/suspend.c
index 13d905dd3..371f2765d 100644
--- a/kernel/power/suspend.c
+++ b/kernel/power/suspend.c
@@ -34,7 +34,6 @@
 #include "power.h"
 
 const char * const pm_labels[] = {
-	[PM_SUSPEND_TO_IDLE] = "freeze",
 	[PM_SUSPEND_STANDBY] = "standby",
 	[PM_SUSPEND_MEM] = "mem",
 };
diff --git a/net/ethtool/common.c b/net/ethtool/common.c
index c63e0739d..8c97b80e1 100644
--- a/net/ethtool/common.c
+++ b/net/ethtool/common.c
@@ -543,6 +543,10 @@ int __ethtool_get_ts_info(struct net_device *dev, struct ethtool_ts_info *info)
 
 	memset(info, 0, sizeof(*info));
 	info->cmd = ETHTOOL_GET_TS_INFO;
+	info->phc_index       = -1;
+	info->phc_index_2nd   = -1;
+	info->phc_worker      = -1;
+	info->phc_timestamper = -1;
 
 	if (phy_has_tsinfo(phydev))
 		return phy_ts_info(phydev, info);
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index d59a7e99c..31ed450b4 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -1774,7 +1774,7 @@ config SND_SOC_WM8993
 	depends on I2C
 
 config SND_SOC_WM8994
-	tristate
+	tristate "Wolfson Microelectronics WM8994 codec"
 
 config SND_SOC_WM8995
 	tristate
diff --git a/sound/soc/codecs/wm8994.c b/sound/soc/codecs/wm8994.c
index f117ec0c4..98e803516 100644
--- a/sound/soc/codecs/wm8994.c
+++ b/sound/soc/codecs/wm8994.c
@@ -7,6 +7,7 @@
  * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
  */
 
+#include <linux/clk.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
@@ -838,6 +839,37 @@ static int clk_sys_event(struct snd_soc_dapm_widget *w,
 	return 0;
 }
 
+static int mclk_event(struct snd_soc_dapm_widget *w,
+		      struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);
+	struct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(comp);
+	int ret, mclk_id = 0;
+
+	if (!strncmp(w->name, "MCLK2", 5))
+		mclk_id = 1;
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		dev_dbg(comp->dev, "Enable master clock %s\n",
+			mclk_id ? "MCLK2" : "MCLK1");
+
+		ret = clk_prepare_enable(wm8994->mclk[mclk_id].clk);
+		if (ret < 0) {
+			dev_err(comp->dev, "Failed to enable clock: %d\n", ret);
+			return ret;
+		}
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		dev_dbg(comp->dev, "Disable master clock %s\n",
+			mclk_id ? "MCLK2" : "MCLK1");
+		clk_disable_unprepare(wm8994->mclk[mclk_id].clk);
+		break;
+	}
+
+	return 0;
+}
+
 static void vmid_reference(struct snd_soc_component *component)
 {
 	struct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);
@@ -1225,7 +1257,6 @@ static int aif2clk_ev(struct snd_soc_dapm_widget *w,
 		else
 			adc = WM8994_AIF2ADCL_ENA | WM8994_AIF2ADCR_ENA;
 
-
 		val = snd_soc_component_read(component, WM8994_AIF2_CONTROL_2);
 		if ((val & WM8994_AIF2DACL_SRC) &&
 		    (val & WM8994_AIF2DACR_SRC))
@@ -1847,6 +1878,16 @@ static const struct snd_soc_dapm_widget wm8994_specific_dapm_widgets[] = {
 SND_SOC_DAPM_MUX("AIF3ADC Mux", SND_SOC_NOPM, 0, 0, &wm8994_aif3adc_mux),
 };
 
+static const struct snd_soc_dapm_widget wm8994_mclk1_dapm_widgets[] = {
+SND_SOC_DAPM_SUPPLY("MCLK1", SND_SOC_NOPM, 0, 0, mclk_event,
+		    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+};
+
+static const struct snd_soc_dapm_widget wm8994_mclk2_dapm_widgets[] = {
+SND_SOC_DAPM_SUPPLY("MCLK2", SND_SOC_NOPM, 0, 0, mclk_event,
+		    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+};
+
 static const struct snd_soc_dapm_widget wm8958_dapm_widgets[] = {
 SND_SOC_DAPM_SUPPLY("AIF3", WM8994_POWER_MANAGEMENT_6, 5, 1, NULL, 0),
 SND_SOC_DAPM_MUX("Mono PCM Out Mux", SND_SOC_NOPM, 0, 0, &mono_pcm_out_mux),
@@ -2071,10 +2112,10 @@ static const struct snd_soc_dapm_route wm8994_lateclk_intercon[] = {
 };
 
 static const struct snd_soc_dapm_route wm8994_revd_intercon[] = {
-	{ "AIF1DACDAT", NULL, "AIF2DACDAT" },
-	{ "AIF2DACDAT", NULL, "AIF1DACDAT" },
-	{ "AIF1ADCDAT", NULL, "AIF2ADCDAT" },
-	{ "AIF2ADCDAT", NULL, "AIF1ADCDAT" },
+//	{ "AIF1DACDAT", NULL, "AIF2DACDAT" },
+//	{ "AIF2DACDAT", NULL, "AIF1DACDAT" },
+//	{ "AIF1ADCDAT", NULL, "AIF2ADCDAT" },
+//	{ "AIF2ADCDAT", NULL, "AIF1ADCDAT" },
 	{ "MICBIAS1", NULL, "CLK_SYS" },
 	{ "MICBIAS1", NULL, "MICBIAS Supply" },
 	{ "MICBIAS2", NULL, "CLK_SYS" },
@@ -2506,11 +2547,24 @@ static int wm8994_set_dai_sysclk(struct snd_soc_dai *dai,
 {
 	struct snd_soc_component *component = dai->component;
 	struct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);
-	int ret, i;
+	int i, ret;
 
+	/*
+	 * Simple card provides unconditionnaly clock_id = 0.
+	 * Workaround to select master clock for aif1/2
+	 */
 	switch (dai->id) {
 	case 1:
+		if (wm8994->mclk[0].clk)
+			clk_id = WM8994_SYSCLK_MCLK1;
+		else if (wm8994->mclk[1].clk)
+			clk_id = WM8994_SYSCLK_MCLK2;
+		break;
 	case 2:
+		if (wm8994->mclk[1].clk)
+			clk_id = WM8994_SYSCLK_MCLK2;
+		else if (wm8994->mclk[0].clk)
+			clk_id = WM8994_SYSCLK_MCLK1;
 		break;
 
 	default:
@@ -2522,6 +2576,10 @@ static int wm8994_set_dai_sysclk(struct snd_soc_dai *dai,
 	case WM8994_SYSCLK_MCLK1:
 		wm8994->sysclk[dai->id - 1] = WM8994_SYSCLK_MCLK1;
 
+		/* Avoid busy error on exclusive rate change request */
+		if (!freq)
+			break;
+
 		ret = wm8994_set_mclk_rate(wm8994, dai->id - 1, &freq);
 		if (ret < 0)
 			return ret;
@@ -2535,6 +2593,9 @@ static int wm8994_set_dai_sysclk(struct snd_soc_dai *dai,
 		/* TODO: Set GPIO AF */
 		wm8994->sysclk[dai->id - 1] = WM8994_SYSCLK_MCLK2;
 
+		if (!freq)
+			break;
+
 		ret = wm8994_set_mclk_rate(wm8994, dai->id - 1, &freq);
 		if (ret < 0)
 			return ret;
@@ -4438,6 +4499,14 @@ static int wm8994_component_probe(struct snd_soc_component *component)
 					       ARRAY_SIZE(wm8994_snd_controls));
 		snd_soc_dapm_new_controls(dapm, wm8994_specific_dapm_widgets,
 					  ARRAY_SIZE(wm8994_specific_dapm_widgets));
+		if (wm8994->mclk[0].clk)
+			snd_soc_dapm_new_controls(dapm, wm8994_mclk1_dapm_widgets,
+						  ARRAY_SIZE(wm8994_mclk1_dapm_widgets));
+
+		if (wm8994->mclk[1].clk)
+			snd_soc_dapm_new_controls(dapm, wm8994_mclk2_dapm_widgets,
+						  ARRAY_SIZE(wm8994_mclk2_dapm_widgets));
+
 		if (control->revision < 4) {
 			snd_soc_dapm_new_controls(dapm, wm8994_lateclk_revd_widgets,
 						  ARRAY_SIZE(wm8994_lateclk_revd_widgets));
diff --git a/sound/soc/stm/stm32_adfsdm.c b/sound/soc/stm/stm32_adfsdm.c
index e6078f50e..75e75cc7f 100644
--- a/sound/soc/stm/stm32_adfsdm.c
+++ b/sound/soc/stm/stm32_adfsdm.c
@@ -12,7 +12,7 @@
 #include <linux/mutex.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
-
+#include <linux/pm_runtime.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/consumer.h>
 #include <linux/iio/adc/stm32-dfsdm-adc.h>
@@ -303,6 +303,11 @@ static int stm32_adfsdm_dummy_cb(const void *data, void *private)
 	return 0;
 }
 
+static void stm32_adfsdm_cleanup(void *data)
+{
+	iio_channel_release_all_cb(data);
+}
+
 static struct snd_soc_component_driver stm32_adfsdm_soc_platform = {
 	.open		= stm32_adfsdm_pcm_open,
 	.close		= stm32_adfsdm_pcm_close,
@@ -349,6 +354,12 @@ static int stm32_adfsdm_probe(struct platform_device *pdev)
 	if (IS_ERR(priv->iio_cb))
 		return PTR_ERR(priv->iio_cb);
 
+	ret = devm_add_action_or_reset(&pdev->dev, stm32_adfsdm_cleanup, priv->iio_cb);
+	if (ret < 0)  {
+		dev_err(&pdev->dev, "Unable to add action\n");
+		return ret;
+	}
+
 	component = devm_kzalloc(&pdev->dev, sizeof(*component), GFP_KERNEL);
 	if (!component)
 		return -ENOMEM;
@@ -363,15 +374,20 @@ static int stm32_adfsdm_probe(struct platform_device *pdev)
 #endif
 
 	ret = snd_soc_add_component(component, NULL, 0);
-	if (ret < 0)
+	if (ret < 0) {
 		dev_err(&pdev->dev, "%s: Failed to register PCM platform\n",
 			__func__);
+		return ret;
+	}
 
-	return ret;
+	pm_runtime_enable(&pdev->dev);
+
+	return 0;
 }
 
 static int stm32_adfsdm_remove(struct platform_device *pdev)
 {
+	pm_runtime_disable(&pdev->dev);
 	snd_soc_unregister_component(&pdev->dev);
 
 	return 0;
diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 717f45a83..f16dd7608 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -13,6 +13,7 @@
 #include <linux/module.h>
 #include <linux/of_irq.h>
 #include <linux/of_platform.h>
+#include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/reset.h>
 #include <linux/spinlock.h>
@@ -1087,7 +1088,7 @@ static int stm32_i2s_parse_dt(struct platform_device *pdev,
 	if (irq < 0)
 		return irq;
 
-	ret = devm_request_irq(&pdev->dev, irq, stm32_i2s_isr, IRQF_ONESHOT,
+	ret = devm_request_irq(&pdev->dev, irq, stm32_i2s_isr, 0,
 			       dev_name(&pdev->dev), i2s);
 	if (ret) {
 		dev_err(&pdev->dev, "irq request returned %d\n", ret);
@@ -1113,6 +1114,7 @@ static int stm32_i2s_remove(struct platform_device *pdev)
 {
 	snd_dmaengine_pcm_unregister(&pdev->dev);
 	snd_soc_unregister_component(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
 
 	return 0;
 }
@@ -1195,6 +1197,8 @@ static int stm32_i2s_probe(struct platform_device *pdev)
 			FIELD_GET(I2S_VERR_MIN_MASK, val));
 	}
 
+	pm_runtime_enable(&pdev->dev);
+
 	return ret;
 
 error:
diff --git a/sound/soc/stm/stm32_sai.c b/sound/soc/stm/stm32_sai.c
index 058757c72..a78f2ea60 100644
--- a/sound/soc/stm/stm32_sai.c
+++ b/sound/soc/stm/stm32_sai.c
@@ -19,26 +19,42 @@
 
 #include "stm32_sai.h"
 
+static int stm32_sai_get_parent_clk(struct stm32_sai_data *sai);
+
 static const struct stm32_sai_conf stm32_sai_conf_f4 = {
 	.version = STM_SAI_STM32F4,
 	.fifo_size = 8,
 	.has_spdif_pdm = false,
+	.get_sai_ck_parent = stm32_sai_get_parent_clk,
 };
 
 /*
- * Default settings for stm32 H7 socs and next.
+ * Default settings for STM32H7x socs and STM32MP1x.
  * These default settings will be overridden if the soc provides
  * support of hardware configuration registers.
+ * - STM32H7: rely on default settings
+ * - STM32MP1: retrieve settings from registers
  */
 static const struct stm32_sai_conf stm32_sai_conf_h7 = {
 	.version = STM_SAI_STM32H7,
 	.fifo_size = 8,
 	.has_spdif_pdm = true,
+	.get_sai_ck_parent = stm32_sai_get_parent_clk,
+};
+
+/*
+ * STM32MP25:
+ * - do not use SAI parent clock source selection
+ * - do not use DMA burst mode
+ */
+static const struct stm32_sai_conf stm32_sai_conf_mp25 = {
+	.no_dma_burst = true,
 };
 
 static const struct of_device_id stm32_sai_ids[] = {
 	{ .compatible = "st,stm32f4-sai", .data = (void *)&stm32_sai_conf_f4 },
 	{ .compatible = "st,stm32h7-sai", .data = (void *)&stm32_sai_conf_h7 },
+	{ .compatible = "st,stm32mp25-sai", .data = (void *)&stm32_sai_conf_mp25 },
 	{}
 };
 
@@ -148,6 +164,29 @@ static int stm32_sai_set_sync(struct stm32_sai_data *sai_client,
 	return ret;
 }
 
+static int stm32_sai_get_parent_clk(struct stm32_sai_data *sai)
+{
+	struct device *dev = &sai->pdev->dev;
+
+	sai->clk_x8k = devm_clk_get(dev, "x8k");
+	if (IS_ERR(sai->clk_x8k)) {
+		if (PTR_ERR(sai->clk_x8k) != -EPROBE_DEFER)
+			dev_err(dev, "missing x8k parent clock: %ld\n",
+				PTR_ERR(sai->clk_x8k));
+		return PTR_ERR(sai->clk_x8k);
+	}
+
+	sai->clk_x11k = devm_clk_get(dev, "x11k");
+	if (IS_ERR(sai->clk_x11k)) {
+		if (PTR_ERR(sai->clk_x11k) != -EPROBE_DEFER)
+			dev_err(dev, "missing x11k parent clock: %ld\n",
+				PTR_ERR(sai->clk_x11k));
+		return PTR_ERR(sai->clk_x11k);
+	}
+
+	return 0;
+}
+
 static int stm32_sai_probe(struct platform_device *pdev)
 {
 	struct stm32_sai_data *sai;
@@ -160,6 +199,8 @@ static int stm32_sai_probe(struct platform_device *pdev)
 	if (!sai)
 		return -ENOMEM;
 
+	sai->pdev = pdev;
+
 	sai->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(sai->base))
 		return PTR_ERR(sai->base);
@@ -181,20 +222,10 @@ static int stm32_sai_probe(struct platform_device *pdev)
 		}
 	}
 
-	sai->clk_x8k = devm_clk_get(&pdev->dev, "x8k");
-	if (IS_ERR(sai->clk_x8k)) {
-		if (PTR_ERR(sai->clk_x8k) != -EPROBE_DEFER)
-			dev_err(&pdev->dev, "missing x8k parent clock: %ld\n",
-				PTR_ERR(sai->clk_x8k));
-		return PTR_ERR(sai->clk_x8k);
-	}
-
-	sai->clk_x11k = devm_clk_get(&pdev->dev, "x11k");
-	if (IS_ERR(sai->clk_x11k)) {
-		if (PTR_ERR(sai->clk_x11k) != -EPROBE_DEFER)
-			dev_err(&pdev->dev, "missing x11k parent clock: %ld\n",
-				PTR_ERR(sai->clk_x11k));
-		return PTR_ERR(sai->clk_x11k);
+	if (sai->conf.get_sai_ck_parent) {
+		ret = sai->conf.get_sai_ck_parent(sai);
+		if (ret)
+			return ret;
 	}
 
 	/* init irqs */
@@ -238,7 +269,6 @@ static int stm32_sai_probe(struct platform_device *pdev)
 	}
 	clk_disable_unprepare(sai->pclk);
 
-	sai->pdev = pdev;
 	sai->set_sync = &stm32_sai_set_sync;
 	platform_set_drvdata(pdev, sai);
 
diff --git a/sound/soc/stm/stm32_sai.h b/sound/soc/stm/stm32_sai.h
index 33e4bff8c..07b71133d 100644
--- a/sound/soc/stm/stm32_sai.h
+++ b/sound/soc/stm/stm32_sai.h
@@ -264,16 +264,22 @@ enum stm32_sai_syncout {
 	STM_SAI_SYNC_OUT_B,
 };
 
+struct stm32_sai_data;
+
 /**
  * struct stm32_sai_conf - SAI configuration
+ * @get_sai_ck_parent: get parent clock of SAI kernel clock
  * @version: SAI version
  * @fifo_size: SAI fifo size as words number
  * @has_spdif_pdm: SAI S/PDIF and PDM features support flag
+ * @no_dma_burst: Support only DMA single transfers if set
  */
 struct stm32_sai_conf {
+	int (*get_sai_ck_parent)(struct stm32_sai_data *sai);
 	u32 version;
 	u32 fifo_size;
 	bool has_spdif_pdm;
+	bool no_dma_burst;
 };
 
 /**
diff --git a/sound/soc/stm/stm32_sai_sub.c b/sound/soc/stm/stm32_sai_sub.c
index 9c3b8e209..dab5653d0 100644
--- a/sound/soc/stm/stm32_sai_sub.c
+++ b/sound/soc/stm/stm32_sai_sub.c
@@ -62,6 +62,9 @@
 
 #define SAI_MCLK_NAME_LEN		32
 #define SAI_RATE_11K			11025
+#define SAI_MAX_SAMPLE_RATE_8K		192000
+#define SAI_MAX_SAMPLE_RATE_11K		176400
+#define SAI_CK_RATE_TOLERANCE		1000 /* ppm */
 
 /**
  * struct stm32_sai_sub_data - private data of SAI sub block (block A or B)
@@ -82,6 +85,7 @@
  * @dir: SAI block direction (playback or capture). set at init
  * @master: SAI block mode flag. (true=master, false=slave) set at init
  * @spdif: SAI S/PDIF iec60958 mode flag. set at init
+ * @sai_ck_used: flag set while exclusivity on SAI kernel clock is active
  * @fmt: SAI block format. relevant only for custom protocols. set at init
  * @sync: SAI block synchronization mode. (none, internal or external)
  * @synco: SAI block ext sync source (provider setting). (none, sub-block A/B)
@@ -95,6 +99,8 @@
  * @iec958: iec958 data
  * @ctrl_lock: control lock
  * @irq_lock: prevent race condition with IRQ
+ * @set_sai_ck_rate: set SAI kernel clock rate
+ * @put_sai_ck_rate: put SAI kernel clock rate
  */
 struct stm32_sai_sub_data {
 	struct platform_device *pdev;
@@ -114,6 +120,7 @@ struct stm32_sai_sub_data {
 	int dir;
 	bool master;
 	bool spdif;
+	bool sai_ck_used;
 	int fmt;
 	int sync;
 	int synco;
@@ -127,6 +134,8 @@ struct stm32_sai_sub_data {
 	struct snd_aes_iec958 iec958;
 	struct mutex ctrl_lock; /* protect resources accessed by controls */
 	spinlock_t irq_lock; /* used to prevent race condition with IRQ */
+	int (*set_sai_ck_rate)(struct stm32_sai_sub_data *sai, unsigned int rate);
+	void (*put_sai_ck_rate)(struct stm32_sai_sub_data *sai);
 };
 
 enum stm32_sai_fifo_th {
@@ -353,8 +362,26 @@ static int stm32_sai_set_clk_div(struct stm32_sai_sub_data *sai,
 	return ret;
 }
 
-static int stm32_sai_set_parent_clock(struct stm32_sai_sub_data *sai,
-				      unsigned int rate)
+static bool stm32_sai_rate_accurate(unsigned int max_rate, unsigned int rate)
+{
+	u64 delta, dividend;
+	int ratio;
+
+	ratio = DIV_ROUND_CLOSEST(max_rate, rate);
+	if (!ratio)
+		return false;
+
+	dividend = mul_u32_u32(1000000, abs(max_rate - (ratio * rate)));
+	delta = div_u64(dividend, max_rate);
+
+	if (delta <= SAI_CK_RATE_TOLERANCE)
+		return true;
+
+	return false;
+}
+
+static int stm32_sai_set_parent_clk(struct stm32_sai_sub_data *sai,
+				    unsigned int rate)
 {
 	struct platform_device *pdev = sai->pdev;
 	struct clk *parent_clk = sai->pdata->clk_x8k;
@@ -372,6 +399,92 @@ static int stm32_sai_set_parent_clock(struct stm32_sai_sub_data *sai,
 	return ret;
 }
 
+static void stm32_sai_put_parent_rate(struct stm32_sai_sub_data *sai)
+{
+	if (sai->sai_ck_used) {
+		sai->sai_ck_used = false;
+		clk_rate_exclusive_put(sai->sai_ck);
+	}
+}
+
+static int stm32_sai_set_parent_rate(struct stm32_sai_sub_data *sai,
+				     unsigned int rate)
+{
+	struct platform_device *pdev = sai->pdev;
+	unsigned int sai_ck_rate, sai_ck_max_rate, sai_curr_rate, sai_new_rate;
+	int div, ret;
+
+	/*
+	 * Set maximum expected kernel clock frequency
+	 * - mclk on or spdif:
+	 *   f_sai_ck = MCKDIV * mclk-fs * fs
+	 *   Here typical 256 ratio is assumed for mclk-fs
+	 * - mclk off:
+	 *   f_sai_ck = MCKDIV * FRL * fs
+	 *   Where FRL=[8..256], MCKDIV=[1..n] (n depends on SAI version)
+	 *   Set constraint MCKDIV * FRL <= 256, to ensure MCKDIV is in available range
+	 *   f_sai_ck = sai_ck_max_rate * pow_of_two(FRL) / 256
+	 */
+	if (!(rate % SAI_RATE_11K))
+		sai_ck_max_rate = SAI_MAX_SAMPLE_RATE_11K * 256;
+	else
+		sai_ck_max_rate = SAI_MAX_SAMPLE_RATE_8K * 256;
+
+	if (!sai->sai_mclk && !STM_SAI_PROTOCOL_IS_SPDIF(sai))
+		sai_ck_max_rate /= DIV_ROUND_CLOSEST(256, roundup_pow_of_two(sai->fs_length));
+
+	/*
+	 * Request exclusivity, as the clock is shared by SAI sub-blocks and by
+	 * some SAI instances. This allows to ensure that the rate cannot be
+	 * changed while one or more SAIs are using the clock.
+	 */
+	clk_rate_exclusive_get(sai->sai_ck);
+	sai->sai_ck_used = true;
+
+	/*
+	 * Check current kernel clock rate. If it gives the expected accuracy
+	 * return immediately.
+	 */
+	sai_curr_rate = clk_get_rate(sai->sai_ck);
+	if (stm32_sai_rate_accurate(sai_ck_max_rate, sai_curr_rate))
+		return 0;
+
+	/*
+	 * Otherwise try to set the maximum rate and check the new actual rate.
+	 * If the new rate does not give the expected accuracy, try to set
+	 * lower rates for the kernel clock.
+	 */
+	sai_ck_rate = sai_ck_max_rate;
+	div = 1;
+	do {
+		/* Check new rate accuracy. Return if ok */
+		sai_new_rate = clk_round_rate(sai->sai_ck, sai_ck_rate);
+		if (stm32_sai_rate_accurate(sai_ck_rate, sai_new_rate)) {
+			ret = clk_set_rate(sai->sai_ck, sai_ck_rate);
+			if (ret) {
+				dev_err(&pdev->dev, "Error %d setting sai_ck rate. %s",
+					ret, ret == -EBUSY ?
+					"Active stream rates may be in conflict\n" : "\n");
+				goto err;
+			}
+
+			return 0;
+		}
+
+		/* Try a lower frequency */
+		div++;
+		sai_ck_rate = sai_ck_max_rate / div;
+	} while (sai_ck_rate > rate);
+
+	/* No accurate rate found */
+	dev_err(&pdev->dev, "Failed to find an accurate rate");
+
+err:
+	stm32_sai_put_parent_rate(sai);
+
+	return -EINVAL;
+}
+
 static long stm32_sai_mclk_round_rate(struct clk_hw *hw, unsigned long rate,
 				      unsigned long *prate)
 {
@@ -567,11 +680,15 @@ static int stm32_sai_set_sysclk(struct snd_soc_dai *cpu_dai,
 				clk_rate_exclusive_put(sai->sai_mclk);
 				sai->mclk_rate = 0;
 			}
+
+			if (sai->put_sai_ck_rate)
+				sai->put_sai_ck_rate(sai);
+
 			return 0;
 		}
 
-		/* If master clock is used, set parent clock now */
-		ret = stm32_sai_set_parent_clock(sai, freq);
+		/* If master clock is used, configure SAI kernel clock now */
+		ret = sai->set_sai_ck_rate(sai, freq);
 		if (ret)
 			return ret;
 
@@ -995,7 +1112,7 @@ static int stm32_sai_configure_clock(struct snd_soc_dai *cpu_dai,
 	int ret;
 
 	if (!sai->sai_mclk) {
-		ret = stm32_sai_set_parent_clock(sai, rate);
+		ret = sai->set_sai_ck_rate(sai, rate);
 		if (ret)
 			return ret;
 	}
@@ -1156,6 +1273,14 @@ static void stm32_sai_shutdown(struct snd_pcm_substream *substream,
 
 	clk_disable_unprepare(sai->sai_ck);
 
+	/*
+	 * Release kernel clock if following conditions are fulfilled
+	 * - Master clock is not used. Kernel clock won't be released trough sysclk
+	 * - Put handler is defined. Involve that clock is managed exclusively
+	 */
+	if (!sai->sai_mclk && sai->put_sai_ck_rate)
+		sai->put_sai_ck_rate(sai);
+
 	spin_lock_irqsave(&sai->irq_lock, flags);
 	sai->substream = NULL;
 	spin_unlock_irqrestore(&sai->irq_lock, flags);
@@ -1190,7 +1315,7 @@ static int stm32_sai_dai_probe(struct snd_soc_dai *cpu_dai)
 	 * constraints).
 	 */
 	sai->dma_params.maxburst = 4;
-	if (sai->pdata->conf.fifo_size < 8)
+	if (sai->pdata->conf.fifo_size < 8 || sai->pdata->conf.no_dma_burst)
 		sai->dma_params.maxburst = 1;
 	/* Buswidth will be set by framework at runtime */
 	sai->dma_params.addr_width = DMA_SLAVE_BUSWIDTH_UNDEFINED;
@@ -1294,7 +1419,7 @@ static struct snd_soc_dai_driver stm32_sai_playback_dai = {
 		.id = 1, /* avoid call to fmt_single_name() */
 		.playback = {
 			.channels_min = 1,
-			.channels_max = 2,
+			.channels_max = 16,
 			.rate_min = 8000,
 			.rate_max = 192000,
 			.rates = SNDRV_PCM_RATE_CONTINUOUS,
@@ -1312,7 +1437,7 @@ static struct snd_soc_dai_driver stm32_sai_capture_dai = {
 		.id = 1, /* avoid call to fmt_single_name() */
 		.capture = {
 			.channels_min = 1,
-			.channels_max = 2,
+			.channels_max = 16,
 			.rate_min = 8000,
 			.rate_max = 192000,
 			.rates = SNDRV_PCM_RATE_CONTINUOUS,
@@ -1530,6 +1655,13 @@ static int stm32_sai_sub_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
+	if (sai->pdata->conf.get_sai_ck_parent) {
+		sai->set_sai_ck_rate = stm32_sai_set_parent_clk;
+	} else {
+		sai->set_sai_ck_rate = stm32_sai_set_parent_rate;
+		sai->put_sai_ck_rate = stm32_sai_put_parent_rate;
+	}
+
 	ret = stm32_sai_sub_parse_of(pdev, sai);
 	if (ret)
 		return ret;
diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index 48145f553..e885796ca 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -12,6 +12,7 @@
 #include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/of_platform.h>
+#include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/reset.h>
 
@@ -955,6 +956,7 @@ static int stm32_spdifrx_remove(struct platform_device *pdev)
 
 	snd_dmaengine_pcm_unregister(&pdev->dev);
 	snd_soc_unregister_component(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
 
 	return 0;
 }
@@ -1045,6 +1047,8 @@ static int stm32_spdifrx_probe(struct platform_device *pdev)
 			FIELD_GET(SPDIFRX_VERR_MIN_MASK, ver));
 	}
 
+	pm_runtime_enable(&pdev->dev);
+
 	return ret;
 
 error:
-- 
2.25.1

