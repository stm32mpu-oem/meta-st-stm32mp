From 718836329861d872b6d28a93161d3b0315b92cb5 Mon Sep 17 00:00:00 2001
From: Christophe Priouzeau <christophe.priouzeau@foss.st.com>
Date: Fri, 17 Jun 2022 14:14:14 +0200
Subject: [PATCH] v0.11.0-stm32mp25-r1

---
 .gitmodules                                   |    4 +-
 config_subdir.m4                              |    2 +-
 configure.ac                                  |   36 +-
 contrib/60-openocd.rules                      |    2 +
 contrib/cross-build.sh                        |    2 +-
 contrib/loaders/flash/gd32vf103/Makefile      |   28 +
 contrib/loaders/flash/gd32vf103/gd32vf103.c   |   33 +
 contrib/loaders/flash/gd32vf103/gd32vf103.inc |    4 +
 contrib/rpc_examples/ocd_rpc_example.py       |   18 +-
 doc/manual/primer/tcl.txt                     |    2 +-
 doc/openocd.texi                              |  392 +-
 src/flash/nor/atsame5.c                       |    3 +
 src/flash/nor/bluenrg-x.c                     |   19 +-
 src/flash/nor/efm32.c                         |  322 +-
 src/flash/nor/sim3x.c                         |    2 +-
 src/flash/nor/stm32f1x.c                      |  486 ++-
 src/flash/nor/stm32f2x.c                      |   18 +-
 src/flash/nor/stm32h7x.c                      |   12 +-
 src/flash/nor/stm32l4x.c                      |   44 +-
 src/helper/bits.h                             |    4 +
 src/helper/command.c                          |    1 +
 src/helper/jim-nvp.c                          |    4 +
 src/helper/list.h                             |   14 +
 src/helper/log.c                              |   51 +-
 src/helper/log.h                              |    1 +
 src/jtag/core.c                               |    2 +-
 src/jtag/drivers/Makefile.am                  |    3 +
 src/jtag/drivers/bcm2835gpio.c                |   13 +-
 src/jtag/drivers/cmsis_dap.c                  |   31 +-
 src/jtag/drivers/jlink.c                      |    2 -
 src/jtag/drivers/jtag_vpi.c                   |   41 +-
 src/jtag/drivers/libusb_helper.h              |   14 +
 src/jtag/drivers/linuxgpiod.c                 |   47 +
 src/jtag/drivers/nulink_usb.c                 |    4 +-
 src/jtag/drivers/rlink.c                      |   30 +-
 src/jtag/drivers/stlink_usb.c                 |   33 +-
 src/jtag/drivers/ti_icdi_usb.c                |    4 +-
 src/jtag/drivers/ulink.c                      |   13 +-
 src/jtag/drivers/vdebug.c                     | 1076 ++++++
 src/jtag/drivers/vsllink.c                    |    1 +
 src/jtag/hla/hla_tcl.c                        |    2 +
 src/jtag/interfaces.c                         |    6 +
 src/jtag/jtag.h                               |    6 +-
 src/jtag/tcl.c                                |    6 +
 src/openocd.c                                 |    2 +
 src/rtos/ThreadX.c                            |   12 +
 src/rtos/chromium-ec.c                        |    6 +-
 src/rtos/hwthread.c                           |    8 +-
 src/rtos/linux.c                              |   16 +-
 src/rtos/zephyr.c                             |    6 +-
 src/rtt/rtt.c                                 |    4 +
 src/rtt/tcl.c                                 |    4 +
 src/server/Makefile.am                        |    1 -
 src/server/gdb_server.c                       |  327 +-
 src/server/ipdbg.c                            |   12 +-
 src/server/rtt_server.c                       |   16 +-
 src/server/server.c                           |   34 +-
 src/server/server.h                           |   47 +-
 src/server/server_stubs.c                     |   30 -
 src/server/tcl_server.c                       |   13 +-
 src/server/telnet_server.c                    |   12 +-
 src/target/a64_disassembler.c                 |    2 +-
 src/target/aarch64.c                          |   90 +-
 src/target/arc.c                              |   38 +-
 src/target/arm7_9_common.c                    |   49 +-
 src/target/arm_cti.c                          |    7 +-
 src/target/arm_disassembler.c                 |    2 +-
 src/target/arm_dpm.c                          |    6 +-
 src/target/arm_semihosting.c                  |    7 +-
 src/target/arm_tpiu_swo.c                     |   39 +-
 src/target/armv7a.c                           |    9 +-
 src/target/armv7a_cache.c                     |    9 +-
 src/target/armv7a_cache_l2x.c                 |    9 +-
 src/target/armv7m.h                           |   37 +-
 src/target/armv8.c                            |   20 +-
 src/target/armv8_cache.c                      |    8 +-
 src/target/armv8_dpm.c                        |    6 +-
 src/target/breakpoints.c                      |   99 +-
 src/target/breakpoints.h                      |   18 +-
 src/target/cortex_a.c                         |   74 +-
 src/target/cortex_m.c                         |  250 +-
 src/target/cortex_m.h                         |   59 +-
 src/target/esirisc.c                          |   16 +-
 src/target/image.c                            |    4 +-
 src/target/image.h                            |    4 +-
 src/target/lakemont.c                         |    4 +-
 src/target/mips_m4k.c                         |   56 +-
 src/target/mips_mips64.c                      |   33 +-
 src/target/nds32.c                            |    2 +-
 src/target/nds32_v3_common.c                  |    6 +-
 src/target/openrisc/jsp_server.c              |   17 +-
 src/target/openrisc/or1k.c                    |    8 +-
 src/target/riscv/riscv-013.c                  |    8 +-
 src/target/riscv/riscv.c                      |   48 +-
 src/target/riscv/riscv.h                      |    5 -
 src/target/riscv/riscv_semihosting.c          |    4 +-
 src/target/rtt.c                              |    4 +
 src/target/semihosting_common.c               |  491 ++-
 src/target/semihosting_common.h               |   23 +
 src/target/smp.c                              |   17 +-
 src/target/smp.h                              |    8 +-
 src/target/startup.tcl                        |   26 +
 src/target/stm8.c                             |   34 +-
 src/target/target.c                           |  616 ++-
 src/target/target.h                           |   15 +-
 src/target/target_type.h                      |   11 +
 src/target/x86_32_common.c                    |   30 +-
 src/target/xscale.c                           |   42 +-
 tcl/board/at91cap7a-stk-sdram.cfg             |    3 +-
 tcl/board/at91sam9g20-ek.cfg                  |    4 +-
 tcl/board/embedded-artists_lpc2478-32.cfg     |    4 +-
 tcl/board/evb-lan9255.cfg                     |   11 +
 tcl/board/hilscher_nxhx10.cfg                 |    4 +-
 tcl/board/icnova_sam9g45_sodimm.cfg           |    4 +-
 tcl/board/lemaker_hikey.cfg                   |    2 +-
 tcl/board/nxp_frdm-k64f.cfg                   |   15 +
 tcl/board/nxp_rdb-ls1046a.cfg                 |   17 +
 tcl/board/nxp_rdb-ls1088a.cfg                 |   14 +
 tcl/board/steval-idb012v1.cfg                 |    5 +
 tcl/board/stm32mp25x_dk.cfg                   |   23 +
 tcl/board/stm32mp25x_fpga_stlink_jtag.cfg     |   31 +
 tcl/board/stm32mp25x_fpga_stlink_swd.cfg      |   13 +
 tcl/board/stm32mp25x_fpga_ulink_jtag.cfg      |   31 +
 tcl/board/stm32mp25x_fpga_ulink_swd.cfg       |   31 +
 tcl/board/ti_am625evm.cfg                     |   25 +
 tcl/board/ti_j721s2evm.cfg                    |   25 +
 tcl/board/tocoding_poplar.cfg                 |    2 +-
 tcl/board/vd_a53x2_jtag.cfg                   |   31 +
 tcl/board/vd_m4_jtag.cfg                      |   30 +
 tcl/board/vd_pulpissimo_jtag.cfg              |   32 +
 tcl/board/vd_swerv_jtag.cfg                   |   32 +
 tcl/chip/atmel/at91/aic.tcl                   |   20 +-
 tcl/cpld/altera-epm240.cfg                    |   19 +-
 tcl/cpu/arc/common.tcl                        |    5 +-
 tcl/interface/vdebug.cfg                      |   33 +
 tcl/mem_helper.tcl                            |   12 +-
 tcl/memory.tcl                                |   60 +-
 tcl/target/bluefield.cfg                      |    2 +-
 tcl/target/bluenrg-x.cfg                      |    7 +-
 tcl/target/c100helper.tcl                     |   24 +-
 tcl/target/efm32.cfg                          |    2 +
 tcl/target/gd32vf103.cfg                      |   16 +-
 tcl/target/hilscher_netx500.cfg               |    4 +-
 tcl/target/ls1046a.cfg                        |   56 +
 tcl/target/ls1088a.cfg                        |   74 +
 tcl/target/psoc4.cfg                          |   18 +-
 tcl/target/stm32f4x.cfg                       |    2 +-
 tcl/target/stm32h7x.cfg                       |    4 +-
 tcl/target/stm32l4x.cfg                       |   69 +-
 tcl/target/stm32l5x.cfg                       |  162 +-
 tcl/target/stm32mp13x.cfg                     |   13 +-
 tcl/target/stm32mp15x.cfg                     |   17 +-
 tcl/target/stm32mp25x_cubeide.cfg             |  283 ++
 tcl/target/stm32mp25x_misc.cfg                | 3431 +++++++++++++++++
 tcl/target/stm32mp25x_oe.cfg                  |  143 +
 tcl/target/stm32u5x.cfg                       |  184 +-
 tcl/target/stm32wlx.cfg                       |    4 +-
 tcl/target/stm32x5x_common.cfg                |  154 +
 tcl/target/ti_cc3220sf.cfg                    |    8 +-
 tcl/target/ti_k3.cfg                          |  229 +-
 tcl/target/vd_aarch64.cfg                     |   37 +
 tcl/target/vd_cortex_m.cfg                    |   12 +
 tcl/target/vd_riscv.cfg                       |   18 +
 tcl/target/xilinx_zynqmp.cfg                  |    2 +-
 tcl/tools/test_cpu_speed.tcl                  |   50 +
 testing/examples/cortex/cm3-ftest.cfg         |    2 +-
 166 files changed, 9459 insertions(+), 1864 deletions(-)
 create mode 100644 contrib/loaders/flash/gd32vf103/Makefile
 create mode 100644 contrib/loaders/flash/gd32vf103/gd32vf103.c
 create mode 100644 contrib/loaders/flash/gd32vf103/gd32vf103.inc
 create mode 100644 src/jtag/drivers/vdebug.c
 delete mode 100644 src/server/server_stubs.c
 create mode 100644 tcl/board/evb-lan9255.cfg
 create mode 100644 tcl/board/nxp_frdm-k64f.cfg
 create mode 100644 tcl/board/nxp_rdb-ls1046a.cfg
 create mode 100644 tcl/board/nxp_rdb-ls1088a.cfg
 create mode 100644 tcl/board/steval-idb012v1.cfg
 create mode 100644 tcl/board/stm32mp25x_dk.cfg
 create mode 100644 tcl/board/stm32mp25x_fpga_stlink_jtag.cfg
 create mode 100644 tcl/board/stm32mp25x_fpga_stlink_swd.cfg
 create mode 100644 tcl/board/stm32mp25x_fpga_ulink_jtag.cfg
 create mode 100644 tcl/board/stm32mp25x_fpga_ulink_swd.cfg
 create mode 100644 tcl/board/ti_am625evm.cfg
 create mode 100644 tcl/board/ti_j721s2evm.cfg
 create mode 100644 tcl/board/vd_a53x2_jtag.cfg
 create mode 100644 tcl/board/vd_m4_jtag.cfg
 create mode 100644 tcl/board/vd_pulpissimo_jtag.cfg
 create mode 100644 tcl/board/vd_swerv_jtag.cfg
 create mode 100644 tcl/interface/vdebug.cfg
 create mode 100644 tcl/target/ls1046a.cfg
 create mode 100644 tcl/target/ls1088a.cfg
 create mode 100644 tcl/target/stm32mp25x_cubeide.cfg
 create mode 100644 tcl/target/stm32mp25x_misc.cfg
 create mode 100644 tcl/target/stm32mp25x_oe.cfg
 create mode 100644 tcl/target/stm32x5x_common.cfg
 create mode 100644 tcl/target/vd_aarch64.cfg
 create mode 100644 tcl/target/vd_cortex_m.cfg
 create mode 100644 tcl/target/vd_riscv.cfg
 create mode 100644 tcl/tools/test_cpu_speed.tcl

diff --git a/.gitmodules b/.gitmodules
index 23ffa2543..f2da17ed7 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,9 +1,9 @@
 [submodule "tools/git2cl"]
 	path = tools/git2cl
-	url = https://repo.or.cz/git2cl.git
+	url = https://git.savannah.nongnu.org/git/git2cl.git
 [submodule "jimtcl"]
 	path = jimtcl
 	url = https://github.com/msteveb/jimtcl.git
 [submodule "src/jtag/drivers/libjaylink"]
 	path = src/jtag/drivers/libjaylink
-	url = https://repo.or.cz/libjaylink.git
+	url = https://gitlab.zapb.de/libjaylink/libjaylink.git
diff --git a/config_subdir.m4 b/config_subdir.m4
index 45a1c6c4f..2be590e44 100644
--- a/config_subdir.m4
+++ b/config_subdir.m4
@@ -7,6 +7,6 @@ AC_DEFUN([AX_CONFIG_SUBDIR_OPTION],
 AC_CONFIG_SUBDIRS([$1])
 
 m4_ifblank([$2], [rm -f $srcdir/$1/configure.gnu],
-[echo -e '#!/bin/sh\nexec "`dirname "'\$'0"`/configure" $2 "'\$'@"' > "$srcdir/$1/configure.gnu"
+[echo -e '#!/bin/sh\nexec "`dirname "'\$'0"`/configure" '"$2"' "'\$'@"' > "$srcdir/$1/configure.gnu"
 ])
 ])
diff --git a/configure.ac b/configure.ac
index a178284ee..7037656ae 100644
--- a/configure.ac
+++ b/configure.ac
@@ -122,8 +122,10 @@ m4_define([USB1_ADAPTERS],
 	[[opendous], [eStick/opendous JTAG Programmer], [OPENDOUS]],
 	[[armjtagew], [Olimex ARM-JTAG-EW Programmer], [ARMJTAGEW]],
 	[[rlink], [Raisonance RLink JTAG Programmer], [RLINK]],
-	[[usbprog], [USBProg JTAG Programmer], [USBPROG]],
-	[[aice], [Andes JTAG Programmer], [AICE]]])
+	[[usbprog], [USBProg JTAG Programmer], [USBPROG]]])
+
+m4_define([DEPRECATED_USB1_ADAPTERS],
+	[[[aice], [Andes JTAG Programmer (deprecated)], [AICE]]])
 
 m4_define([HIDAPI_ADAPTERS],
 	[[[cmsis_dap], [CMSIS-DAP Compliant Debugger], [CMSIS_DAP_HID]],
@@ -256,6 +258,8 @@ AC_ARG_ADAPTERS([
   LIBJAYLINK_ADAPTERS
   ],[auto])
 
+AC_ARG_ADAPTERS([DEPRECATED_USB1_ADAPTERS],[no])
+
 AC_ARG_ENABLE([parport],
   AS_HELP_STRING([--enable-parport], [Enable building the pc parallel port driver]),
   [build_parport=$enableval], [build_parport=no])
@@ -274,6 +278,10 @@ AC_ARG_ENABLE([jtag_vpi],
   AS_HELP_STRING([--enable-jtag_vpi], [Enable building support for JTAG VPI]),
   [build_jtag_vpi=$enableval], [build_jtag_vpi=no])
 
+AC_ARG_ENABLE([vdebug],
+  AS_HELP_STRING([--enable-vdebug], [Enable building support for Cadence Virtual Debug Interface]),
+  [build_vdebug=$enableval], [build_vdebug=no])
+
 AC_ARG_ENABLE([jtag_dpi],
   AS_HELP_STRING([--enable-jtag_dpi], [Enable building support for JTAG DPI]),
   [build_jtag_dpi=$enableval], [build_jtag_dpi=no])
@@ -350,6 +358,10 @@ AC_ARG_ENABLE([internal-jimtcl],
   AS_HELP_STRING([--disable-internal-jimtcl], [Disable building internal jimtcl]),
   [use_internal_jimtcl=$enableval], [use_internal_jimtcl=yes])
 
+AC_ARG_ENABLE([jimtcl-maintainer],
+  AS_HELP_STRING([--enable-jimtcl-maintainer], [Enable maintainer mode when building internal jimtcl]),
+  [use_internal_jimtcl_maintainer=$enableval], [use_internal_jimtcl_maintainer=no])
+
 AC_ARG_ENABLE([internal-libjaylink],
   AS_HELP_STRING([--disable-internal-libjaylink],
   [Disable building internal libjaylink]),
@@ -513,6 +525,12 @@ AS_IF([test "x$build_jtag_vpi" = "xyes"], [
   AC_DEFINE([BUILD_JTAG_VPI], [0], [0 if you don't want JTAG VPI.])
 ])
 
+AS_IF([test "x$build_vdebug" = "xyes"], [
+  AC_DEFINE([BUILD_VDEBUG], [1], [1 if you want Cadence vdebug interface.])
+], [
+  AC_DEFINE([BUILD_VDEBUG], [0], [0 if you don't want Cadence vdebug interface.])
+])
+
 AS_IF([test "x$build_jtag_dpi" = "xyes"], [
   AC_DEFINE([BUILD_JTAG_DPI], [1], [1 if you want JTAG DPI.])
 ], [
@@ -540,7 +558,12 @@ AS_IF([test "x$enable_buspirate" != "xno"], [
 
 AS_IF([test "x$use_internal_jimtcl" = "xyes"], [
   AS_IF([test -f "$srcdir/jimtcl/configure.ac"], [
-    AX_CONFIG_SUBDIR_OPTION([jimtcl], [--disable-install-jim])
+    AS_IF([test "x$use_internal_jimtcl_maintainer" = "xyes"], [
+      jimtcl_config_options="--disable-install-jim --maintainer"
+    ], [
+      jimtcl_config_options="--disable-install-jim"
+    ])
+    AX_CONFIG_SUBDIR_OPTION([jimtcl], [$jimtcl_config_options])
   ], [
     AC_MSG_ERROR([jimtcl not found, run git submodule init and git submodule update.])
   ])
@@ -641,6 +664,7 @@ m4_define([PROCESS_ADAPTERS], [
 ])
 
 PROCESS_ADAPTERS([USB1_ADAPTERS], ["x$use_libusb1" = "xyes"], [libusb-1.x])
+PROCESS_ADAPTERS([DEPRECATED_USB1_ADAPTERS], ["x$use_libusb1" = "xyes"], [libusb-1.x])
 PROCESS_ADAPTERS([HIDAPI_ADAPTERS], ["x$use_hidapi" = "xyes"], [hidapi])
 PROCESS_ADAPTERS([HIDAPI_USB1_ADAPTERS], ["x$use_hidapi" = "xyes" -a "x$use_libusb1" = "xyes"], [hidapi and libusb-1.x])
 PROCESS_ADAPTERS([LIBFTDI_ADAPTERS], ["x$use_libftdi" = "xyes"], [libftdi])
@@ -688,8 +712,9 @@ AM_CONDITIONAL([AT91RM9200], [test "x$build_at91rm9200" = "xyes"])
 AM_CONDITIONAL([BCM2835GPIO], [test "x$build_bcm2835gpio" = "xyes"])
 AM_CONDITIONAL([IMX_GPIO], [test "x$build_imx_gpio" = "xyes"])
 AM_CONDITIONAL([BITBANG], [test "x$build_bitbang" = "xyes"])
-AM_CONDITIONAL([JTAG_VPI], [test "x$build_jtag_vpi" = "xyes" -o "x$build_jtag_vpi" = "xyes"])
-AM_CONDITIONAL([JTAG_DPI], [test "x$build_jtag_dpi" = "xyes" -o "x$build_jtag_dpi" = "xyes"])
+AM_CONDITIONAL([JTAG_VPI], [test "x$build_jtag_vpi" = "xyes"])
+AM_CONDITIONAL([VDEBUG], [test "x$build_vdebug" = "xyes"])
+AM_CONDITIONAL([JTAG_DPI], [test "x$build_jtag_dpi" = "xyes"])
 AM_CONDITIONAL([USB_BLASTER_DRIVER], [test "x$enable_usb_blaster" != "xno" -o "x$enable_usb_blaster_2" != "xno"])
 AM_CONDITIONAL([AMTJTAGACCEL], [test "x$build_amtjtagaccel" = "xyes"])
 AM_CONDITIONAL([GW16012], [test "x$build_gw16012" = "xyes"])
@@ -778,6 +803,7 @@ echo
 echo OpenOCD configuration summary
 echo --------------------------------------------------
 m4_foreach([adapter], [USB1_ADAPTERS,
+	DEPRECATED_USB1_ADAPTERS,
 	HIDAPI_ADAPTERS, HIDAPI_USB1_ADAPTERS, LIBFTDI_ADAPTERS,
 	LIBFTDI_USB1_ADAPTERS,
 	LIBGPIOD_ADAPTERS,
diff --git a/contrib/60-openocd.rules b/contrib/60-openocd.rules
index 4ecb485b1..34defada0 100644
--- a/contrib/60-openocd.rules
+++ b/contrib/60-openocd.rules
@@ -154,7 +154,9 @@ ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1015", MODE="660", GROUP="plugdev",
 ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1016", MODE="660", GROUP="plugdev", TAG+="uaccess"
 ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1017", MODE="660", GROUP="plugdev", TAG+="uaccess"
 ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1018", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1020", MODE="660", GROUP="plugdev", TAG+="uaccess"
 ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1051", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1055", MODE="660", GROUP="plugdev", TAG+="uaccess"
 ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1061", MODE="660", GROUP="plugdev", TAG+="uaccess"
 
 # Raisonance RLink
diff --git a/contrib/cross-build.sh b/contrib/cross-build.sh
index 8b31a3f00..7c572f55d 100755
--- a/contrib/cross-build.sh
+++ b/contrib/cross-build.sh
@@ -148,7 +148,7 @@ if [ -d $CAPSTONE_SRC ] ; then
   sed -i '1s;^;prefix=/usr \
 exec_prefix=${prefix} \
 libdir=${exec_prefix}/lib \
-includedir=${prefix}/include\n\n;' $CAPSTONE_PC_FILE
+includedir=${prefix}/include/capstone\n\n;' $CAPSTONE_PC_FILE
 fi
 
 
diff --git a/contrib/loaders/flash/gd32vf103/Makefile b/contrib/loaders/flash/gd32vf103/Makefile
new file mode 100644
index 000000000..2c34e08c0
--- /dev/null
+++ b/contrib/loaders/flash/gd32vf103/Makefile
@@ -0,0 +1,28 @@
+BIN2C = ../../../../src/helper/bin2char.sh
+
+CROSS_COMPILE ?= riscv-none-embed-
+
+CC=$(CROSS_COMPILE)gcc
+OBJCOPY=$(CROSS_COMPILE)objcopy
+OBJDUMP=$(CROSS_COMPILE)objdump
+
+CFLAGS = -march=rv32i -mabi=ilp32 -static -nostartfiles -nostdlib -Os -g -fPIC
+
+all: gd32vf103.inc
+
+.PHONY: clean
+
+%.elf: %.c
+	$(CC) $(CFLAGS) $< -o $@
+
+%.lst: %.elf
+	$(OBJDUMP) -S $< > $@
+
+%.bin: %.elf
+	$(OBJCOPY) -Obinary $< $@
+
+%.inc: %.bin
+	$(BIN2C) < $< > $@
+
+clean:
+	-rm -f *.elf *.lst *.bin *.inc
diff --git a/contrib/loaders/flash/gd32vf103/gd32vf103.c b/contrib/loaders/flash/gd32vf103/gd32vf103.c
new file mode 100644
index 000000000..69225a026
--- /dev/null
+++ b/contrib/loaders/flash/gd32vf103/gd32vf103.c
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#include <stdint.h>
+
+#define FLASH_BSY	(1 << 0)
+#define FLASH_PGERR	(1 << 2)
+#define FLASH_WRPRTERR	(1 << 4)
+
+void flash_write(volatile uint32_t *flash_sr,
+		uint32_t hwords_count,
+		uint16_t *buffer,
+		uint16_t *target_addr) __attribute__((naked));
+
+void flash_write(volatile uint32_t *flash_sr,
+		uint32_t hwords_count,
+		uint16_t *buffer,
+		uint16_t *target_addr)
+{
+	do {
+		*target_addr = *buffer++;
+
+		register uint32_t sr;
+		do {
+			sr = *flash_sr;
+		} while (sr & FLASH_BSY);
+
+		if (sr & (FLASH_PGERR | FLASH_WRPRTERR))
+			break;
+
+		target_addr++;
+	} while (--hwords_count);
+	asm("ebreak");
+}
diff --git a/contrib/loaders/flash/gd32vf103/gd32vf103.inc b/contrib/loaders/flash/gd32vf103/gd32vf103.inc
new file mode 100644
index 000000000..05eabff21
--- /dev/null
+++ b/contrib/loaders/flash/gd32vf103/gd32vf103.inc
@@ -0,0 +1,4 @@
+/* Autogenerated with ../../../../src/helper/bin2char.sh */
+0x83,0x57,0x06,0x00,0x13,0x06,0x26,0x00,0x23,0x90,0xf6,0x00,0x83,0x27,0x05,0x00,
+0x13,0xf7,0x17,0x00,0xe3,0x1c,0x07,0xfe,0x93,0xf7,0x47,0x01,0x63,0x98,0x07,0x00,
+0x93,0x85,0xf5,0xff,0x93,0x86,0x26,0x00,0xe3,0x9c,0x05,0xfc,0x73,0x00,0x10,0x00,
diff --git a/contrib/rpc_examples/ocd_rpc_example.py b/contrib/rpc_examples/ocd_rpc_example.py
index 3470d848b..e6146f617 100755
--- a/contrib/rpc_examples/ocd_rpc_example.py
+++ b/contrib/rpc_examples/ocd_rpc_example.py
@@ -95,24 +95,16 @@ class OpenOcd:
         return None if (len(raw) < 2) else strToHex(raw[1])
 
     def readMemory(self, wordLen, address, n):
-        self.send("array unset output") # better to clear the array before
-        self.send("mem2array output %d 0x%x %d" % (wordLen, address, n))
-
-        output = [*map(int, self.send("return $output").split(" "))]
-        d = dict([tuple(output[i:i + 2]) for i in range(0, len(output), 2)])
-
-        return [d[k] for k in sorted(d.keys())]
+        output = self.send("read_memory 0x%x %d %d" % (address, wordLen, n))
+        return [*map(lambda x: int(x, 16), output.split(" "))]
 
     def writeVariable(self, address, value):
         assert value is not None
         self.send("mww 0x%x 0x%x" % (address, value))
 
-    def writeMemory(self, wordLen, address, n, data):
-        array = " ".join(["%d 0x%x" % (a, b) for a, b in enumerate(data)])
-
-        self.send("array unset 1986ве1т") # better to clear the array before
-        self.send("array set 1986ве1т { %s }" % array)
-        self.send("array2mem 1986ве1т 0x%x %s %d" % (wordLen, address, n))
+    def writeMemory(self, wordLen, address, data):
+        data = "{" + ' '.join(['0x%x' % x for x in data]) + "}"
+        self.send("write_memory 0x%x %d %s" % (address, wordLen, data))
 
 if __name__ == "__main__":
 
diff --git a/doc/manual/primer/tcl.txt b/doc/manual/primer/tcl.txt
index 868a75ba0..eba2f552d 100644
--- a/doc/manual/primer/tcl.txt
+++ b/doc/manual/primer/tcl.txt
@@ -174,7 +174,7 @@ them. It is similar to this bash statement.
        EXPORT vn=`date`
 
 LINE 2 & 3
-       set $vn [expr (1024 * $x)]
+       set $vn [expr {1024 * $x}]
        global $vn
 
 In line 1, we dynamically created a variable name.  Here, we are
diff --git a/doc/openocd.texi b/doc/openocd.texi
index 61d398738..b87e87f87 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -588,6 +588,12 @@ produced, PDF schematics are easily found and it is easy to make.
 @* A JTAG driver acting as a client for the JTAG VPI server interface.
 @* Link: @url{http://github.com/fjullien/jtag_vpi}
 
+@item @b{vdebug}
+@* A driver for Cadence virtual Debug Interface to emulated or simulated targets.
+It implements a client connecting to the vdebug server, which in turn communicates
+with the emulated or simulated RTL model through a transactor. The current version
+supports only JTAG as a transport, but other virtual transports, like DAP are planned.
+
 @item @b{jtag_dpi}
 @* A JTAG driver acting as a client for the SystemVerilog Direct Programming
 Interface (DPI) for JTAG devices. DPI allows OpenOCD to connect to the JTAG
@@ -2009,9 +2015,9 @@ proc setc15 @{regs value@} @{
 
     echo [format "set p15 0x%04x, 0x%08x" $regs $value]
 
-    arm mcr 15 [expr ($regs>>12)&0x7] \
-        [expr ($regs>>0)&0xf] [expr ($regs>>4)&0xf] \
-        [expr ($regs>>8)&0x7] $value
+    arm mcr 15 [expr @{($regs >> 12) & 0x7@}] \
+        [expr @{($regs >> 0) & 0xf@}] [expr @{($regs >> 4) & 0xf@}] \
+        [expr @{($regs >> 8) & 0x7@}] $value
 @}
 @end example
 
@@ -3157,7 +3163,9 @@ the target's supply voltage.
 The result can be converted to Volts (ignoring the most significant bytes, always zero)
 @example
 > set a [st-link cmd 8 0xf7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
-> echo [expr 2*1.2*([lindex $a 4]+256*[lindex $a 5])/([lindex $a 0]+256*[lindex $a 1])]
+> set n [expr @{[lindex $a 4] + 256 * [lindex $a 5]@}]
+> set d [expr @{[lindex $a 0] + 256 * [lindex $a 1]@}]
+> echo [expr @{2 * 1.2 * $n / $d@}]
 3.24891518738
 @end example
 @end deffn
@@ -3343,6 +3351,41 @@ This value is only used with the standard variant.
 @end deffn
 
 
+@deffn {Interface Driver} {vdebug}
+Cadence Virtual Debug Interface driver.
+
+@deffn {Config Command} {vdebug server} host:port
+Specifies the host and TCP port number where the vdebug server runs.
+@end deffn
+
+@deffn {Config Command} {vdebug batching} value
+Specifies the batching method for the vdebug request. Possible values are
+0 for no batching
+1 or wr to batch write transactions together (default)
+2 or rw to batch both read and write transactions
+@end deffn
+
+@deffn {Config Command} {vdebug polling} min max
+Takes two values, representing the polling interval in ms. Lower values mean faster
+debugger responsiveness, but lower emulation performance. The minimum should be
+around 10, maximum should not exceed 1000, which is the default gdb and keepalive
+timeout value.
+@end deffn
+
+@deffn {Config Command} {vdebug bfm_path} path clk_period
+Specifies the hierarchical path and input clk period of the vdebug BFM in the design.
+The hierarchical path uses Verilog notation top.inst.inst
+The clock period must include the unit, for instance 40ns.
+@end deffn
+
+@deffn {Config Command} {vdebug mem_path} path base size
+Specifies the hierarchical path to the design memory instance for backdoor access.
+Up to 4 memories can be specified. The hierarchical path uses Verilog notation.
+The base specifies start address in the design address space, size its size in bytes.
+Both values can use hexadecimal notation with prefix 0x.
+@end deffn
+@end deffn
+
 @deffn {Interface Driver} {jtag_dpi}
 SystemVerilog Direct Programming Interface (DPI) compatible driver for
 JTAG devices in emulation. The driver acts as a client for the SystemVerilog
@@ -4151,6 +4194,10 @@ option. When vendors put out multiple versions of a chip, or use the same
 JTAG-level ID for several largely-compatible chips, it may be more practical
 to ignore the version field than to update config files to handle all of
 the various chip IDs. The version field is defined as bit 28-31 of the IDCODE.
+@item @code{-ignore-bypass}
+@*Specify this to ignore the 'bypass' bit of the idcode. Some vendor put
+an invalid idcode regarding this bit. Specify this to ignore this bit and
+to not consider this tap in bypass mode.
 @item @code{-ircapture} @var{NUMBER}
 @*The bit pattern loaded by the TAP into the JTAG shift register
 on entry to the @sc{ircapture} state, such as 0x01.
@@ -4523,13 +4570,13 @@ where the mask bit is 1. The following example sets HPROT3 (cacheable)
 and leaves the rest of the pattern intact. It configures memory access through
 DCache on Cortex-M7.
 @example
-set CSW_HPROT3_CACHEABLE [expr 1 << 27]
+set CSW_HPROT3_CACHEABLE [expr @{1 << 27@}]
 samv.dap apcsw $CSW_HPROT3_CACHEABLE $CSW_HPROT3_CACHEABLE
 @end example
 
 Another example clears SPROT bit and leaves the rest of pattern intact:
 @example
-set CSW_SPROT [expr 1 << 30]
+set CSW_SPROT [expr @{1 << 30@}]
 samv.dap apcsw 0 $CSW_SPROT
 @end example
 
@@ -4681,9 +4728,9 @@ specified, @xref{gdbportoverride,,option -gdb-port}.), and a fake ARM core will
 be emulated to comply to GDB remote protocol.
 @item @code{mips_m4k} -- a MIPS core.
 @item @code{mips_mips64} -- a MIPS64 core.
-@item @code{nds32_v2} -- this is an Andes NDS32 v2 core.
-@item @code{nds32_v3} -- this is an Andes NDS32 v3 core.
-@item @code{nds32_v3m} -- this is an Andes NDS32 v3m core.
+@item @code{nds32_v2} -- this is an Andes NDS32 v2 core (deprecated; would be removed in v0.13.0).
+@item @code{nds32_v3} -- this is an Andes NDS32 v3 core (deprecated; would be removed in v0.13.0).
+@item @code{nds32_v3m} -- this is an Andes NDS32 v3m core (deprecated; would be removed in v0.13.0).
 @item @code{or1k} -- this is an OpenRISC 1000 core.
 The current implementation supports three JTAG TAP cores:
 @itemize @minus
@@ -4933,27 +4980,76 @@ use these to deal with specific reset cases.
 They are not otherwise documented here.
 @end deffn
 
-@deffn {Command} {$target_name array2mem} arrayname width address count
-@deffnx {Command} {$target_name mem2array} arrayname width address count
-These provide an efficient script-oriented interface to memory.
-The @code{array2mem} primitive writes bytes, halfwords, words
-or double-words; while @code{mem2array} reads them.
-In both cases, the TCL side uses an array, and
-the target side uses raw memory.
+@deffn {Command} {$target_name set_reg} dict
+Set register values of the target.
+
+@itemize
+@item @var{dict} ... Tcl dictionary with pairs of register names and values.
+@end itemize
+
+For example, the following command sets the value 0 to the program counter (pc)
+register and 0x1000 to the stack pointer (sp) register:
+
+@example
+set_reg @{pc 0 sp 0x1000@}
+@end example
+@end deffn
+
+@deffn {Command} {$target_name get_reg} [-force] list
+Get register values from the target and return them as Tcl dictionary with pairs
+of register names and values.
+If option "-force" is set, the register values are read directly from the
+target, bypassing any caching.
+
+@itemize
+@item @var{list} ... List of register names
+@end itemize
+
+For example, the following command retrieves the values from the program
+counter (pc) and stack pointer (sp) register:
+
+@example
+get_reg @{pc sp@}
+@end example
+@end deffn
+
+@deffn {Command} {$target_name write_memory} address width data ['phys']
+This function provides an efficient way to write to the target memory from a Tcl
+script.
+
+@itemize
+@item @var{address} ... target memory address
+@item @var{width} ... memory access bit size, can be 8, 16, 32 or 64
+@item @var{data} ... Tcl list with the elements to write
+@item ['phys'] ... treat the memory address as physical instead of virtual address
+@end itemize
 
-The efficiency comes from enabling the use of
-bulk JTAG data transfer operations.
-The script orientation comes from working with data
-values that are packaged for use by TCL scripts;
-@command{mdw} type primitives only print data they retrieve,
-and neither store nor return those values.
+For example, the following command writes two 32 bit words into the target
+memory at address 0x20000000:
+
+@example
+write_memory 0x20000000 32 @{0xdeadbeef 0x00230500@}
+@end example
+@end deffn
+
+@deffn {Command} {$target_name read_memory} address width count ['phys']
+This function provides an efficient way to read the target memory from a Tcl
+script.
+A Tcl list containing the requested memory elements is returned by this function.
 
 @itemize
-@item @var{arrayname} ... is the name of an array variable
-@item @var{width} ... is 8/16/32/64 - indicating the memory access size
-@item @var{address} ... is the target memory address
-@item @var{count} ... is the number of elements to process
+@item @var{address} ... target memory address
+@item @var{width} ... memory access bit size, can be 8, 16, 32 or 64
+@item @var{count} ... number of elements to read
+@item ['phys'] ... treat the memory address as physical instead of virtual address
 @end itemize
+
+For example, the following command reads two 32 bit words from the target
+memory at address 0x20000000:
+
+@example
+read_memory 0x20000000 32 2
+@end example
 @end deffn
 
 @deffn {Command} {$target_name cget} queryparm
@@ -5023,8 +5119,8 @@ When the current target has an MMU which is present and active,
 Otherwise, or if the optional @var{phys} flag is specified,
 @var{addr} is interpreted as a physical address.
 If @var{count} is specified, displays that many units.
-(If you want to manipulate the data instead of displaying it,
-see the @code{mem2array} primitives.)
+(If you want to process the data instead of displaying it,
+see the @code{read_memory} primitives.)
 @end deffn
 
 @deffn {Command} {$target_name mwd} [phys] addr doubleword [count]
@@ -5179,6 +5275,22 @@ when reset disables PLLs needed to use a fast clock.
 @* After single-step has completed
 @item @b{trace-config}
 @* After target hardware trace configuration was changed
+@item @b{semihosting-user-cmd-0x100}
+@* The target made a semihosting call with user-defined operation number 0x100
+@item @b{semihosting-user-cmd-0x101}
+@* The target made a semihosting call with user-defined operation number 0x101
+@item @b{semihosting-user-cmd-0x102}
+@* The target made a semihosting call with user-defined operation number 0x102
+@item @b{semihosting-user-cmd-0x103}
+@* The target made a semihosting call with user-defined operation number 0x103
+@item @b{semihosting-user-cmd-0x104}
+@* The target made a semihosting call with user-defined operation number 0x104
+@item @b{semihosting-user-cmd-0x105}
+@* The target made a semihosting call with user-defined operation number 0x105
+@item @b{semihosting-user-cmd-0x106}
+@* The target made a semihosting call with user-defined operation number 0x106
+@item @b{semihosting-user-cmd-0x107}
+@* The target made a semihosting call with user-defined operation number 0x107
 @end itemize
 
 @quotation Note
@@ -6306,7 +6418,7 @@ The AVR 8-bit microcontrollers from Atmel integrate flash memory.
 @end deffn
 
 @deffn {Flash Driver} {bluenrg-x}
-STMicroelectronics BlueNRG-1, BlueNRG-2 and BlueNRG-LP Bluetooth low energy wireless system-on-chip. They include ARM Cortex-M0/M0+ core and internal flash memory.
+STMicroelectronics BlueNRG-1, BlueNRG-2 and BlueNRG-LP/LPS Bluetooth low energy wireless system-on-chip. They include ARM Cortex-M0/M0+ core and internal flash memory.
 The driver automatically recognizes these chips using
 the chip identification registers, and autoconfigures itself.
 
@@ -6351,13 +6463,22 @@ flash bank $_FLASHNAME cc3220sf 0 0 0 0 $_TARGETNAME
 @end deffn
 
 @deffn {Flash Driver} {efm32}
-All members of the EFM32 microcontroller family from Energy Micro include
-internal flash and use ARM Cortex-M3 cores. The driver automatically recognizes
-a number of these chips using the chip identification register, and
+All members of the EFM32/EFR32 microcontroller family from Energy Micro (now Silicon Labs)
+include internal flash and use Arm Cortex-M3 or Cortex-M4 cores. The driver automatically
+recognizes a number of these chips using the chip identification register, and
 autoconfigures itself.
 @example
 flash bank $_FLASHNAME efm32 0 0 0 0 $_TARGETNAME
 @end example
+It supports writing to the user data page, as well as the portion of the lockbits page
+past 512 bytes on chips with larger page sizes. The latter is used by the SiLabs
+bootloader/AppLoader system for encryption keys. Setting protection on these pages is
+currently not supported.
+@example
+flash bank userdata.flash efm32 0x0FE00000 0 0 0 $_TARGETNAME
+flash bank lockbits.flash efm32 0x0FE04000 0 0 0 $_TARGETNAME
+@end example
+
 A special feature of efm32 controllers is that it is possible to completely disable the
 debug interface by writing the correct values to the 'Debug Lock Word'. OpenOCD supports
 this via the following command:
@@ -7172,6 +7293,7 @@ applied to all of them.
 All members of the STM32F0, STM32F1 and STM32F3 microcontroller families
 from STMicroelectronics and all members of the GD32F1x0, GD32F3x0 and GD32E23x microcontroller
 families from GigaDevice include internal flash and use ARM Cortex-M0/M3/M4/M23 cores.
+The driver also works with GD32VF103 powered by RISC-V core.
 The driver automatically recognizes a number of these chips using
 the chip identification register, and autoconfigures itself.
 
@@ -8419,6 +8541,78 @@ Debug and trace infrastructure:
 @end example
 @end deffn
 
+@deffn {Command} {set_reg} dict
+Set register values of the target.
+
+@itemize
+@item @var{dict} ... Tcl dictionary with pairs of register names and values.
+@end itemize
+
+For example, the following command sets the value 0 to the program counter (pc)
+register and 0x1000 to the stack pointer (sp) register:
+
+@example
+set_reg @{pc 0 sp 0x1000@}
+@end example
+@end deffn
+
+@deffn {Command} {get_reg} [-force] list
+Get register values from the target and return them as Tcl dictionary with pairs
+of register names and values.
+If option "-force" is set, the register values are read directly from the
+target, bypassing any caching.
+
+@itemize
+@item @var{list} ... List of register names
+@end itemize
+
+For example, the following command retrieves the values from the program
+counter (pc) and stack pointer (sp) register:
+
+@example
+get_reg @{pc sp@}
+@end example
+@end deffn
+
+@deffn {Command} {write_memory} address width data ['phys']
+This function provides an efficient way to write to the target memory from a Tcl
+script.
+
+@itemize
+@item @var{address} ... target memory address
+@item @var{width} ... memory access bit size, can be 8, 16, 32 or 64
+@item @var{data} ... Tcl list with the elements to write
+@item ['phys'] ... treat the memory address as physical instead of virtual address
+@end itemize
+
+For example, the following command writes two 32 bit words into the target
+memory at address 0x20000000:
+
+@example
+write_memory 0x20000000 32 @{0xdeadbeef 0x00230500@}
+@end example
+@end deffn
+
+@deffn {Command} {read_memory} address width count ['phys']
+This function provides an efficient way to read the target memory from a Tcl
+script.
+A Tcl list containing the requested memory elements is returned by this function.
+
+@itemize
+@item @var{address} ... target memory address
+@item @var{width} ... memory access bit size, can be 8, 16, 32 or 64
+@item @var{count} ... number of elements to read
+@item ['phys'] ... treat the memory address as physical instead of virtual address
+@end itemize
+
+For example, the following command reads two 32 bit words from the target
+memory at address 0x20000000:
+
+@example
+read_memory 0x20000000 32 2
+@end example
+@end deffn
+
 @deffn {Command} {halt} [ms]
 @deffnx {Command} {wait_halt} [ms]
 The @command{halt} command first sends a halt request to the target,
@@ -8556,8 +8750,8 @@ When the current target has an MMU which is present and active,
 Otherwise, or if the optional @var{phys} flag is specified,
 @var{addr} is interpreted as a physical address.
 If @var{count} is specified, displays that many units.
-(If you want to manipulate the data instead of displaying it,
-see the @code{mem2array} primitives.)
+(If you want to process the data instead of displaying it,
+see the @code{read_memory} primitives.)
 @end deffn
 
 @deffn {Command} {mwd} [phys] addr doubleword [count]
@@ -8611,7 +8805,7 @@ In addition the following arguments may be specified:
 proc load_image_bin @{fname foffset address length @} @{
     # Load data from fname filename at foffset offset to
     # target at address. Load at most length bytes.
-    load_image $fname [expr $address - $foffset] bin \
+    load_image $fname [expr @{$address - $foffset@}] bin \
                $address $length
 @}
 @end example
@@ -9177,6 +9371,17 @@ requests by using a special SVC instruction that is trapped at the
 Supervisor Call vector by OpenOCD.
 @end deffn
 
+@deffn {Command} {arm semihosting_redirect} (@option{disable} | @option{tcp} <port>
+[@option{debug}|@option{stdio}|@option{all})
+@cindex ARM semihosting
+Redirect semihosting messages to a specified TCP port.
+
+This command redirects debug (READC, WRITEC and WRITE0) and stdio (READ, WRITE)
+semihosting operations to the specified TCP port.
+The command allows to select which type of operations to redirect (debug, stdio, all (default)).
+Note: for stdio operations, only I/O from/to ':tt' file descriptors are redirected.
+@end deffn
+
 @deffn {Command} {arm semihosting_cmdline} [@option{enable}|@option{disable}]
 @cindex ARM semihosting
 Set the command line to be passed to the debugger.
@@ -9226,6 +9431,17 @@ To make the SEMIHOSTING_SYS_EXIT call return normally, enable
 this option (default: disabled).
 @end deffn
 
+@deffn {Command} {arm semihosting_read_user_param}
+@cindex ARM semihosting
+Read parameter of the semihosting call from the target. Usable in
+semihosting-user-cmd-0x10* event handlers, returning a string.
+
+When the target makes semihosting call with operation number from range 0x100-
+0x107, an optional string parameter can be passed to the server. This parameter
+is valid during the run of the event handlers and is accessible with this
+command.
+@end deffn
+
 @section ARMv4 and ARMv5 Architecture
 @cindex ARMv4
 @cindex ARMv5
@@ -10212,6 +10428,43 @@ A @emph{hart} is a hardware thread. A hart may share resources (eg. FPU) with
 another hart, or may be a separate core.  RISC-V treats those the same, and
 OpenOCD exposes each hart as a separate core.
 
+@subsection Vector Registers
+
+For harts that implement the vector extension, OpenOCD provides access to the
+relevant CSRs, as well as the vector registers (v0-v31). The size of each
+vector register is dependent on the value of vlenb. RISC-V allows each vector
+register to be divided into selected-width elements, and this division can be
+changed at run-time. Because OpenOCD cannot update register definitions at
+run-time, it exposes each vector register to gdb as a union of fields of
+vectors so that users can easily access individual bytes, shorts, words,
+longs, and quads inside each vector register. It is left to gdb or
+higher-level debuggers to present this data in a more intuitive format.
+
+In the XML register description, the vector registers (when vlenb=16) look as
+follows:
+
+@example
+<feature name="org.gnu.gdb.riscv.vector">
+<vector id="bytes" type="uint8" count="16"/>
+<vector id="shorts" type="uint16" count="8"/>
+<vector id="words" type="uint32" count="4"/>
+<vector id="longs" type="uint64" count="2"/>
+<vector id="quads" type="uint128" count="1"/>
+<union id="riscv_vector">
+<field name="b" type="bytes"/>
+<field name="s" type="shorts"/>
+<field name="w" type="words"/>
+<field name="l" type="longs"/>
+<field name="q" type="quads"/>
+</union>
+<reg name="v0" bitsize="128" regnum="4162" save-restore="no"
+        type="riscv_vector" group="vector"/>
+...
+<reg name="v31" bitsize="128" regnum="4193" save-restore="no"
+        type="riscv_vector" group="vector"/>
+</feature>
+@end example
+
 @subsection RISC-V Debug Configuration Commands
 
 @deffn {Config Command} {riscv expose_csrs} n[-m|=name] [...]
@@ -10356,7 +10609,7 @@ trivial challenge-response protocol could be implemented as follows in a
 configuration file, immediately following @command{init}:
 @example
 set challenge [riscv authdata_read]
-riscv authdata_write [expr $challenge + 1]
+riscv authdata_write [expr @{$challenge + 1@}]
 @end example
 
 @deffn {Command} {riscv authdata_read}
@@ -11315,57 +11568,6 @@ The @command{step} and @command{stepi} commands can be used to step a specific c
 while other cores are free-running or remain halted, depending on the
 scheduler-locking mode configured in GDB.
 
-@section Legacy SMP core switching support
-@quotation Note
-This method is deprecated in favor of the @emph{hwthread} pseudo RTOS.
-@end quotation
-
-For SMP support following GDB serial protocol packet have been defined :
-@itemize @bullet
-@item j - smp status request
-@item J - smp set request
-@end itemize
-
-OpenOCD implements :
-@itemize @bullet
-@item @option{jc} packet for reading core id displayed by
-GDB connection. Reply is @option{XXXXXXXX} (8 hex digits giving core id) or
- @option{E01} for target not smp.
-@item @option{JcXXXXXXXX} (8 hex digits) packet for setting core id displayed at next GDB continue
-(core id -1 is reserved for returning to normal resume mode). Reply @option{E01}
-for target not smp or @option{OK} on success.
-@end itemize
-
-Handling of this packet within GDB can be done :
-@itemize @bullet
-@item by the creation of an internal variable (i.e @option{_core}) by mean
-of function allocate_computed_value allowing following GDB command.
-@example
-set $_core 1
-#Jc01 packet is sent
-print $_core
-#jc packet is sent and result is affected in $
-@end example
-
-@item by the usage of GDB maintenance command as described in following example (2 cpus in SMP with
-core id 0 and 1 @pxref{definecputargetsworkinginsmp,,Define CPU targets working in SMP}).
-
-@example
-# toggle0 : force display of coreid 0
-define toggle0
-maint packet Jc0
-continue
-main packet Jc-1
-end
-# toggle1 : force display of coreid 1
-define toggle1
-maint packet Jc1
-continue
-main packet Jc-1
-end
-@end example
-@end itemize
-
 @node Tcl Scripting API
 @chapter Tcl Scripting API
 @cindex Tcl Scripting API
@@ -11417,13 +11619,7 @@ should be passed in to the proc in question.
 By "low-level", we mean commands that a human would typically not
 invoke directly.
 
-@itemize @bullet
-@item @b{mem2array} <@var{varname}> <@var{width}> <@var{addr}> <@var{nelems}>
-
-Read memory and return as a Tcl array for script processing
-@item @b{array2mem} <@var{varname}> <@var{width}> <@var{addr}> <@var{nelems}>
-
-Convert a Tcl array to memory locations and write the values
+@itemize
 @item @b{flash banks} <@var{driver}> <@var{base}> <@var{size}> <@var{chip_width}> <@var{bus_width}> <@var{target}> [@option{driver options} ...]
 
 Return information about the flash banks
@@ -11939,7 +12135,7 @@ It sort of works like this:
 When the command ``proc'' is parsed (which creates a procedure
 function) it gets 3 parameters on the command line. @b{1} the name of
 the proc (function), @b{2} the list of parameters, and @b{3} the body
-of the function. Not the choice of words: LIST and BODY. The PROC
+of the function. Note the choice of words: LIST and BODY. The PROC
 command stores these items in a table somewhere so it can be found by
 ``LookupCommand()''
 
@@ -12065,7 +12261,7 @@ it reads a file and executes as a script.
 @example
     set x 6
     set y 7
-    puts [format "The answer: %d" [expr $x * $y]]
+    puts [format "The answer: %d" [expr @{$x * $y@}]]
 @end example
 @enumerate
 @item The SET command creates 2 variables, X and Y.
@@ -12136,13 +12332,13 @@ proc myproc @{ @} @{
 @b{Dynamic variable creation}
 @example
 # Dynamically create a bunch of variables.
-for @{ set x 0 @} @{ $x < 32 @} @{ set x [expr $x + 1]@} @{
+for @{ set x 0 @} @{ $x < 32 @} @{ set x [expr @{$x + 1@}]@} @{
     # Create var name
     set vn [format "BIT%d" $x]
     # Make it a global
     global $vn
     # Set it.
-    set $vn [expr (1 << $x)]
+    set $vn [expr @{1 << $x@}]
 @}
 @end example
 @b{Dynamic proc/command creation}
diff --git a/src/flash/nor/atsame5.c b/src/flash/nor/atsame5.c
index 9ab0e8113..fbf0fb2ed 100644
--- a/src/flash/nor/atsame5.c
+++ b/src/flash/nor/atsame5.c
@@ -146,6 +146,9 @@ static const struct samd_part same53_parts[] = {
 	{ 0x04, "SAME53J20A", 1024, 256 },
 	{ 0x05, "SAME53J19A", 512, 192 },
 	{ 0x06, "SAME53J18A", 256, 128 },
+	{ 0x55, "LAN9255/ZMX020", 1024, 256 },
+	{ 0x56, "LAN9255/ZMX019", 512, 192 },
+	{ 0x57, "LAN9255/ZMX018", 256, 128 },
 };
 
 /* Known SAME54 parts. */
diff --git a/src/flash/nor/bluenrg-x.c b/src/flash/nor/bluenrg-x.c
index 60eccefaf..16075ec4c 100644
--- a/src/flash/nor/bluenrg-x.c
+++ b/src/flash/nor/bluenrg-x.c
@@ -35,6 +35,8 @@
 #define JTAG_IDCODE_REG(bluenrgx_info)      (bluenrgx_info->flash_ptr->jtag_idcode_reg)
 #define FLASH_PAGE_SIZE(bluenrgx_info)      (bluenrgx_info->flash_ptr->flash_page_size)
 
+#define FLASH_SIZE_REG_MASK (0xFFFF)
+
 struct flash_ctrl_priv_data {
 	uint32_t die_id_reg;
 	uint32_t jtag_idcode_reg;
@@ -75,6 +77,16 @@ static const struct flash_ctrl_priv_data flash_priv_data_lp = {
 	.part_name = "BLUENRG-LP",
 };
 
+static const struct flash_ctrl_priv_data flash_priv_data_lps = {
+	.die_id_reg = 0x40000000,
+	.jtag_idcode_reg = 0x40000004,
+	.flash_base = 0x10040000,
+	.flash_regs_base = 0x40001000,
+	.flash_page_size = 2048,
+	.jtag_idcode = 0x02028041,
+	.part_name = "BLUENRG-LPS",
+};
+
 struct bluenrgx_flash_bank {
 	bool probed;
 	uint32_t die_id;
@@ -84,8 +96,8 @@ struct bluenrgx_flash_bank {
 static const struct flash_ctrl_priv_data *flash_ctrl[] = {
 	&flash_priv_data_1,
 	&flash_priv_data_2,
-	&flash_priv_data_lp
-};
+	&flash_priv_data_lp,
+	&flash_priv_data_lps};
 
 /* flash_bank bluenrg-x 0 0 0 0 <target#> */
 FLASH_BANK_COMMAND_HANDLER(bluenrgx_flash_bank_command)
@@ -377,7 +389,7 @@ static int bluenrgx_probe(struct flash_bank *bank)
 	if (retval != ERROR_OK)
 		return retval;
 
-	if (idcode != flash_priv_data_lp.jtag_idcode) {
+	if ((idcode != flash_priv_data_lp.jtag_idcode) && (idcode != flash_priv_data_lps.jtag_idcode)) {
 		retval = target_read_u32(bank->target, BLUENRG2_JTAG_REG, &idcode);
 		if (retval != ERROR_OK)
 			return retval;
@@ -395,6 +407,7 @@ static int bluenrgx_probe(struct flash_bank *bank)
 		}
 	}
 	retval = bluenrgx_read_flash_reg(bank, FLASH_SIZE_REG, &size_info);
+	size_info = size_info & FLASH_SIZE_REG_MASK;
 	if (retval != ERROR_OK)
 		return retval;
 
diff --git a/src/flash/nor/efm32.c b/src/flash/nor/efm32.c
index fb4b09624..2c5a5020e 100644
--- a/src/flash/nor/efm32.c
+++ b/src/flash/nor/efm32.c
@@ -14,6 +14,9 @@
  *   Copyright (C) 2014 Nemui Trinomius                                    *
  *   nemuisan_kawausogasuki@live.jp                                        *
  *                                                                         *
+ *   Copyright (C) 2021 Doug Brunner                                       *
+ *   doug.a.brunner@gmail.com                                              *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -45,13 +48,16 @@
 #define EFM32_FLASH_WDATAREADY_TMO      100
 #define EFM32_FLASH_WRITE_TMO           100
 
+#define EFM32_FLASH_BASE                0
+
 /* size in bytes, not words; must fit all Gecko devices */
-#define LOCKBITS_PAGE_SZ                512
+#define LOCKWORDS_SZ                512
 
 #define EFM32_MSC_INFO_BASE             0x0fe00000
 
 #define EFM32_MSC_USER_DATA             EFM32_MSC_INFO_BASE
 #define EFM32_MSC_LOCK_BITS             (EFM32_MSC_INFO_BASE+0x4000)
+#define EFM32_MSC_LOCK_BITS_EXTRA       (EFM32_MSC_LOCK_BITS+LOCKWORDS_SZ)
 #define EFM32_MSC_DEV_INFO              (EFM32_MSC_INFO_BASE+0x8000)
 
 /* PAGE_SIZE is not present in Zero, Happy and the original Gecko MCU */
@@ -83,6 +89,27 @@
 #define EFM32_MSC_REG_LOCK_SERIES1      0x040
 #define EFM32_MSC_LOCK_LOCKKEY          0x1b71
 
+enum efm32_bank_index {
+	EFM32_BANK_INDEX_MAIN,
+	EFM32_BANK_INDEX_USER_DATA,
+	EFM32_BANK_INDEX_LOCK_BITS,
+	EFM32_N_BANKS
+};
+
+static int efm32x_get_bank_index(target_addr_t base)
+{
+	switch (base) {
+		case EFM32_FLASH_BASE:
+			return EFM32_BANK_INDEX_MAIN;
+		case EFM32_MSC_USER_DATA:
+			return EFM32_BANK_INDEX_USER_DATA;
+		case EFM32_MSC_LOCK_BITS:
+			return EFM32_BANK_INDEX_LOCK_BITS;
+		default:
+			return ERROR_FAIL;
+	}
+}
+
 struct efm32_family_data {
 	int family_id;
 	const char *name;
@@ -98,13 +125,6 @@ struct efm32_family_data {
 	uint32_t msc_regbase;
 };
 
-struct efm32x_flash_bank {
-	bool probed;
-	uint32_t lb_page[LOCKBITS_PAGE_SZ/4];
-	uint32_t reg_base;
-	uint32_t reg_lock;
-};
-
 struct efm32_info {
 	const struct efm32_family_data *family_data;
 	uint16_t flash_sz_kib;
@@ -115,6 +135,15 @@ struct efm32_info {
 	uint16_t page_size;
 };
 
+struct efm32x_flash_chip {
+	struct efm32_info info;
+	bool probed[EFM32_N_BANKS];
+	uint32_t lb_page[LOCKWORDS_SZ/4];
+	uint32_t reg_base;
+	uint32_t reg_lock;
+	uint32_t refcount;
+};
+
 static const struct efm32_family_data efm32_families[] = {
 		{ 16, "EFR32MG1P Mighty", .series = 1 },
 		{ 17, "EFR32MG1B Mighty", .series = 1 },
@@ -175,9 +204,12 @@ static const struct efm32_family_data efm32_families[] = {
 		{ 122, "EZR32HG Happy", .series = 0, .page_size = 1024 },
 };
 
+const struct flash_driver efm32_flash;
 
-static int efm32x_write(struct flash_bank *bank, const uint8_t *buffer,
-	uint32_t offset, uint32_t count);
+static int efm32x_priv_write(struct flash_bank *bank, const uint8_t *buffer,
+	uint32_t addr, uint32_t count);
+
+static int efm32x_write_only_lockbits(struct flash_bank *bank);
 
 static int efm32x_get_flash_size(struct flash_bank *bank, uint16_t *flash_sz)
 {
@@ -207,7 +239,7 @@ static int efm32x_get_prod_rev(struct flash_bank *bank, uint8_t *prev)
 static int efm32x_read_reg_u32(struct flash_bank *bank, target_addr_t offset,
 			       uint32_t *value)
 {
-	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
+	struct efm32x_flash_chip *efm32x_info = bank->driver_priv;
 	uint32_t base = efm32x_info->reg_base;
 
 	return target_read_u32(bank->target, base + offset, value);
@@ -216,32 +248,28 @@ static int efm32x_read_reg_u32(struct flash_bank *bank, target_addr_t offset,
 static int efm32x_write_reg_u32(struct flash_bank *bank, target_addr_t offset,
 			       uint32_t value)
 {
-	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
+	struct efm32x_flash_chip *efm32x_info = bank->driver_priv;
 	uint32_t base = efm32x_info->reg_base;
 
 	return target_write_u32(bank->target, base + offset, value);
 }
 
-static int efm32x_read_info(struct flash_bank *bank,
-	struct efm32_info *efm32_info)
+static int efm32x_read_info(struct flash_bank *bank)
 {
 	int ret;
-	uint32_t cpuid = 0;
-	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
+	struct efm32x_flash_chip *efm32x_info = bank->driver_priv;
+	struct efm32_info *efm32_info = &(efm32x_info->info);
 
 	memset(efm32_info, 0, sizeof(struct efm32_info));
 
-	ret = target_read_u32(bank->target, CPUID, &cpuid);
-	if (ret != ERROR_OK)
-		return ret;
+	const struct cortex_m_common *cortex_m = target_to_cm(bank->target);
 
-	if (((cpuid >> 4) & 0xfff) == 0xc23) {
-		/* Cortex-M3 device */
-	} else if (((cpuid >> 4) & 0xfff) == 0xc24) {
-		/* Cortex-M4 device (WONDER GECKO) */
-	} else if (((cpuid >> 4) & 0xfff) == 0xc60) {
-		/* Cortex-M0+ device */
-	} else {
+	switch (cortex_m->core_info->partno) {
+	case CORTEX_M3_PARTNO:
+	case CORTEX_M4_PARTNO:
+	case CORTEX_M0P_PARTNO:
+		break;
+	default:
 		LOG_ERROR("Target is not Cortex-Mx Device");
 		return ERROR_FAIL;
 	}
@@ -327,20 +355,61 @@ static int efm32x_read_info(struct flash_bank *bank,
 /* flash bank efm32 <base> <size> 0 0 <target#> */
 FLASH_BANK_COMMAND_HANDLER(efm32x_flash_bank_command)
 {
-	struct efm32x_flash_bank *efm32x_info;
+	struct efm32x_flash_chip *efm32x_info = NULL;
 
 	if (CMD_ARGC < 6)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	efm32x_info = malloc(sizeof(struct efm32x_flash_bank));
+	int bank_index = efm32x_get_bank_index(bank->base);
+	if (bank_index < 0) {
+		LOG_ERROR("Flash bank with base address %" PRIx32 " is not supported",
+			(uint32_t) bank->base);
+		return ERROR_FAIL;
+	}
+
+	/* look for an existing flash structure matching target */
+	for (struct flash_bank *bank_iter = flash_bank_list(); bank_iter; bank_iter = bank_iter->next) {
+		if (bank_iter->driver == &efm32_flash
+			&& bank_iter->target == bank->target
+			&& bank->driver_priv) {
+			efm32x_info = bank->driver_priv;
+			break;
+		}
+	}
 
+	if (!efm32x_info) {
+		/* target not matched, make a new one */
+		efm32x_info = calloc(1, sizeof(struct efm32x_flash_chip));
+
+		memset(efm32x_info->lb_page, 0xff, LOCKWORDS_SZ);
+	}
+
+	++efm32x_info->refcount;
 	bank->driver_priv = efm32x_info;
-	efm32x_info->probed = false;
-	memset(efm32x_info->lb_page, 0xff, LOCKBITS_PAGE_SZ);
 
 	return ERROR_OK;
 }
 
+/**
+ * Remove flash structure corresponding to this bank,
+ * if and only if it's not used by any others
+ */
+static void efm32x_free_driver_priv(struct flash_bank *bank)
+{
+	struct efm32x_flash_chip *efm32x_info = bank->driver_priv;
+
+	if (efm32x_info) {
+		/* Use ref count to determine if it can be freed; scanning bank list doesn't work,
+		 * because this function can be called after some banks in the list have been
+		 * already destroyed */
+		--efm32x_info->refcount;
+		if (efm32x_info->refcount == 0) {
+			free(efm32x_info);
+			bank->driver_priv = NULL;
+		}
+	}
+}
+
 /* set or reset given bits in a register */
 static int efm32x_set_reg_bits(struct flash_bank *bank, uint32_t reg,
 	uint32_t bitmask, int set)
@@ -368,7 +437,7 @@ static int efm32x_set_wren(struct flash_bank *bank, int write_enable)
 
 static int efm32x_msc_lock(struct flash_bank *bank, int lock)
 {
-	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
+	struct efm32x_flash_chip *efm32x_info = bank->driver_priv;
 	return efm32x_write_reg_u32(bank, efm32x_info->reg_lock,
 		(lock ? 0 : EFM32_MSC_LOCK_LOCKKEY));
 }
@@ -416,7 +485,6 @@ static int efm32x_erase_page(struct flash_bank *bank, uint32_t addr)
 	 */
 	int ret = 0;
 	uint32_t status = 0;
-	addr += bank->base;
 	LOG_DEBUG("erasing flash page at 0x%08" PRIx32, addr);
 
 	ret = efm32x_write_reg_u32(bank, EFM32_MSC_REG_ADDRB, addr);
@@ -470,20 +538,28 @@ static int efm32x_erase(struct flash_bank *bank, unsigned int first,
 	}
 
 	for (unsigned int i = first; i <= last; i++) {
-		ret = efm32x_erase_page(bank, bank->sectors[i].offset);
+		ret = efm32x_erase_page(bank, bank->base + bank->sectors[i].offset);
 		if (ret != ERROR_OK)
 			LOG_ERROR("Failed to erase page %d", i);
 	}
 
 	ret = efm32x_set_wren(bank, 0);
 	efm32x_msc_lock(bank, 1);
+	if (ret != ERROR_OK)
+		return ret;
+
+	if (bank->base == EFM32_MSC_LOCK_BITS) {
+		ret = efm32x_write_only_lockbits(bank);
+		if (ret != ERROR_OK)
+			LOG_ERROR("Failed to restore lockbits after erase");
+	}
 
 	return ret;
 }
 
 static int efm32x_read_lock_data(struct flash_bank *bank)
 {
-	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
+	struct efm32x_flash_chip *efm32x_info = bank->driver_priv;
 	struct target *target = bank->target;
 	int data_size = 0;
 	uint32_t *ptr = NULL;
@@ -557,35 +633,84 @@ static int efm32x_read_lock_data(struct flash_bank *bank)
 	return ERROR_OK;
 }
 
+static int efm32x_write_only_lockbits(struct flash_bank *bank)
+{
+	struct efm32x_flash_chip *efm32x_info = bank->driver_priv;
+	return efm32x_priv_write(bank, (uint8_t *)efm32x_info->lb_page, EFM32_MSC_LOCK_BITS, LOCKWORDS_SZ);
+}
+
 static int efm32x_write_lock_data(struct flash_bank *bank)
 {
-	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
+	struct efm32x_flash_chip *efm32x_info = bank->driver_priv;
 	int ret = 0;
 
+	/* Preserve any data written to the high portion of the lockbits page */
+	assert(efm32x_info->info.page_size >= LOCKWORDS_SZ);
+	uint32_t extra_bytes = efm32x_info->info.page_size - LOCKWORDS_SZ;
+	uint8_t *extra_data = NULL;
+	if (extra_bytes) {
+		extra_data = malloc(extra_bytes);
+		ret = target_read_buffer(bank->target, EFM32_MSC_LOCK_BITS_EXTRA, extra_bytes, extra_data);
+		if (ret != ERROR_OK) {
+			LOG_ERROR("Failed to read extra contents of LB page");
+			free(extra_data);
+			return ret;
+		}
+	}
+
 	ret = efm32x_erase_page(bank, EFM32_MSC_LOCK_BITS);
 	if (ret != ERROR_OK) {
 		LOG_ERROR("Failed to erase LB page");
+		if (extra_data)
+			free(extra_data);
 		return ret;
 	}
 
-	return efm32x_write(bank, (uint8_t *)efm32x_info->lb_page, EFM32_MSC_LOCK_BITS,
-		LOCKBITS_PAGE_SZ);
+	if (extra_data) {
+		ret = efm32x_priv_write(bank, extra_data, EFM32_MSC_LOCK_BITS_EXTRA, extra_bytes);
+		free(extra_data);
+		if (ret != ERROR_OK) {
+			LOG_ERROR("Failed to restore extra contents of LB page");
+			return ret;
+		}
+	}
+
+	return efm32x_write_only_lockbits(bank);
 }
 
 static int efm32x_get_page_lock(struct flash_bank *bank, size_t page)
 {
-	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
-	uint32_t dw = efm32x_info->lb_page[page >> 5];
+	struct efm32x_flash_chip *efm32x_info = bank->driver_priv;
+	uint32_t dw = 0;
 	uint32_t mask = 0;
 
-	mask = 1 << (page & 0x1f);
+	switch (bank->base) {
+		case EFM32_FLASH_BASE:
+			dw = efm32x_info->lb_page[page >> 5];
+			mask = 1 << (page & 0x1f);
+			break;
+		case EFM32_MSC_USER_DATA:
+			dw = efm32x_info->lb_page[126];
+			mask = 0x1;
+			break;
+		case EFM32_MSC_LOCK_BITS:
+			dw = efm32x_info->lb_page[126];
+			mask = 0x2;
+			break;
+	}
 
 	return (dw & mask) ? 0 : 1;
 }
 
 static int efm32x_set_page_lock(struct flash_bank *bank, size_t page, int set)
 {
-	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
+	struct efm32x_flash_chip *efm32x_info = bank->driver_priv;
+
+	if (bank->base != EFM32_FLASH_BASE) {
+		LOG_ERROR("Locking user and lockbits pages is not supported yet");
+		return ERROR_FAIL;
+	}
+
 	uint32_t *dw = &efm32x_info->lb_page[page >> 5];
 	uint32_t mask = 0;
 
@@ -605,11 +730,6 @@ static int efm32x_protect(struct flash_bank *bank, int set, unsigned int first,
 	struct target *target = bank->target;
 	int ret = 0;
 
-	if (!set) {
-		LOG_ERROR("Erase device data to reset page locks");
-		return ERROR_FAIL;
-	}
-
 	if (target->state != TARGET_HALTED) {
 		LOG_ERROR("Target not halted");
 		return ERROR_TARGET_NOT_HALTED;
@@ -633,16 +753,15 @@ static int efm32x_protect(struct flash_bank *bank, int set, unsigned int first,
 }
 
 static int efm32x_write_block(struct flash_bank *bank, const uint8_t *buf,
-	uint32_t offset, uint32_t count)
+	uint32_t address, uint32_t count)
 {
 	struct target *target = bank->target;
 	uint32_t buffer_size = 16384;
 	struct working_area *write_algorithm;
 	struct working_area *source;
-	uint32_t address = bank->base + offset;
 	struct reg_param reg_params[5];
 	struct armv7m_algorithm armv7m_info;
-	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
+	struct efm32x_flash_chip *efm32x_info = bank->driver_priv;
 	int ret = ERROR_OK;
 
 	/* see contrib/loaders/flash/efm32.S for src */
@@ -864,8 +983,8 @@ static int efm32x_write_word(struct flash_bank *bank, uint32_t addr,
 	return ERROR_OK;
 }
 
-static int efm32x_write(struct flash_bank *bank, const uint8_t *buffer,
-		uint32_t offset, uint32_t count)
+static int efm32x_priv_write(struct flash_bank *bank, const uint8_t *buffer,
+		uint32_t addr, uint32_t count)
 {
 	struct target *target = bank->target;
 	uint8_t *new_buffer = NULL;
@@ -875,9 +994,9 @@ static int efm32x_write(struct flash_bank *bank, const uint8_t *buffer,
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if (offset & 0x3) {
-		LOG_ERROR("offset 0x%" PRIx32 " breaks required 4-byte "
-			"alignment", offset);
+	if (addr & 0x3) {
+		LOG_ERROR("addr 0x%" PRIx32 " breaks required 4-byte "
+			"alignment", addr);
 		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
 	}
 
@@ -906,7 +1025,7 @@ static int efm32x_write(struct flash_bank *bank, const uint8_t *buffer,
 		goto cleanup;
 
 	/* try using a block write */
-	retval = efm32x_write_block(bank, buffer, offset, words_remaining);
+	retval = efm32x_write_block(bank, buffer, addr, words_remaining);
 
 	if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE) {
 		/* if block write failed (no sufficient working area),
@@ -918,13 +1037,13 @@ static int efm32x_write(struct flash_bank *bank, const uint8_t *buffer,
 			uint32_t value;
 			memcpy(&value, buffer, sizeof(uint32_t));
 
-			retval = efm32x_write_word(bank, offset, value);
+			retval = efm32x_write_word(bank, addr, value);
 			if (retval != ERROR_OK)
 				goto reset_pg_and_lock;
 
 			words_remaining--;
 			buffer += 4;
-			offset += 4;
+			addr += 4;
 		}
 	}
 
@@ -939,63 +1058,77 @@ cleanup:
 	return retval;
 }
 
+static int efm32x_write(struct flash_bank *bank, const uint8_t *buffer,
+		uint32_t offset, uint32_t count)
+{
+	if (bank->base == EFM32_MSC_LOCK_BITS && offset < LOCKWORDS_SZ) {
+		LOG_ERROR("Cannot write to lock words");
+		return ERROR_FAIL;
+	}
+	return efm32x_priv_write(bank, buffer, bank->base + offset, count);
+}
+
 static int efm32x_probe(struct flash_bank *bank)
 {
-	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
-	struct efm32_info efm32_mcu_info;
+	struct efm32x_flash_chip *efm32x_info = bank->driver_priv;
+	struct efm32_info *efm32_mcu_info = &(efm32x_info->info);
 	int ret;
-	uint32_t base_address = 0x00000000;
 
-	efm32x_info->probed = false;
-	memset(efm32x_info->lb_page, 0xff, LOCKBITS_PAGE_SZ);
+	int bank_index = efm32x_get_bank_index(bank->base);
+	assert(bank_index >= 0);
+
+	efm32x_info->probed[bank_index] = false;
+	memset(efm32x_info->lb_page, 0xff, LOCKWORDS_SZ);
 
-	ret = efm32x_read_info(bank, &efm32_mcu_info);
+	ret = efm32x_read_info(bank);
 	if (ret != ERROR_OK)
 		return ret;
 
 	LOG_INFO("detected part: %s Gecko, rev %d",
-			efm32_mcu_info.family_data->name, efm32_mcu_info.prod_rev);
-	LOG_INFO("flash size = %dkbytes", efm32_mcu_info.flash_sz_kib);
-	LOG_INFO("flash page size = %dbytes", efm32_mcu_info.page_size);
-
-	assert(efm32_mcu_info.page_size != 0);
+			efm32_mcu_info->family_data->name, efm32_mcu_info->prod_rev);
+	LOG_INFO("flash size = %dkbytes", efm32_mcu_info->flash_sz_kib);
+	LOG_INFO("flash page size = %dbytes", efm32_mcu_info->page_size);
 
-	int num_pages = efm32_mcu_info.flash_sz_kib * 1024 /
-		efm32_mcu_info.page_size;
-
-	assert(num_pages > 0);
+	assert(efm32_mcu_info->page_size != 0);
 
 	free(bank->sectors);
 	bank->sectors = NULL;
 
-	bank->base = base_address;
-	bank->size = (num_pages * efm32_mcu_info.page_size);
-	bank->num_sectors = num_pages;
+	if (bank->base == EFM32_FLASH_BASE) {
+		bank->num_sectors = efm32_mcu_info->flash_sz_kib * 1024 /
+			efm32_mcu_info->page_size;
+		assert(bank->num_sectors > 0);
 
-	ret = efm32x_read_lock_data(bank);
-	if (ret != ERROR_OK) {
-		LOG_ERROR("Failed to read LB data");
-		return ret;
-	}
-
-	bank->sectors = malloc(sizeof(struct flash_sector) * num_pages);
-
-	for (int i = 0; i < num_pages; i++) {
-		bank->sectors[i].offset = i * efm32_mcu_info.page_size;
-		bank->sectors[i].size = efm32_mcu_info.page_size;
+		ret = efm32x_read_lock_data(bank);
+		if (ret != ERROR_OK) {
+			LOG_ERROR("Failed to read LB data");
+			return ret;
+		}
+	} else
+		bank->num_sectors = 1;
+	bank->size = bank->num_sectors * efm32_mcu_info->page_size;
+	bank->sectors = malloc(sizeof(struct flash_sector) * bank->num_sectors);
+
+	for (uint32_t i = 0; i < bank->num_sectors; i++) {
+		bank->sectors[i].offset = i * efm32_mcu_info->page_size;
+		bank->sectors[i].size = efm32_mcu_info->page_size;
 		bank->sectors[i].is_erased = -1;
 		bank->sectors[i].is_protected = 1;
 	}
 
-	efm32x_info->probed = true;
+	efm32x_info->probed[bank_index] = true;
 
 	return ERROR_OK;
 }
 
 static int efm32x_auto_probe(struct flash_bank *bank)
 {
-	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
-	if (efm32x_info->probed)
+	struct efm32x_flash_chip *efm32x_info = bank->driver_priv;
+
+	int bank_index = efm32x_get_bank_index(bank->base);
+	assert(bank_index >= 0);
+
+	if (efm32x_info->probed[bank_index])
 		return ERROR_OK;
 	return efm32x_probe(bank);
 }
@@ -1026,16 +1159,17 @@ static int efm32x_protect_check(struct flash_bank *bank)
 
 static int get_efm32x_info(struct flash_bank *bank, struct command_invocation *cmd)
 {
-	struct efm32_info info;
+	struct efm32x_flash_chip *efm32x_info = bank->driver_priv;
 	int ret;
 
-	ret = efm32x_read_info(bank, &info);
+	ret = efm32x_read_info(bank);
 	if (ret != ERROR_OK) {
 		LOG_ERROR("Failed to read EFM32 info");
 		return ret;
 	}
 
-	command_print_sameline(cmd, "%s Gecko, rev %d", info.family_data->name, info.prod_rev);
+	command_print_sameline(cmd, "%s Gecko, rev %d", efm32x_info->info.family_data->name,
+		efm32x_info->info.prod_rev);
 	return ERROR_OK;
 }
 
@@ -1051,7 +1185,7 @@ COMMAND_HANDLER(efm32x_handle_debuglock_command)
 	if (retval != ERROR_OK)
 		return retval;
 
-	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
+	struct efm32x_flash_chip *efm32x_info = bank->driver_priv;
 
 	target = bank->target;
 
@@ -1110,5 +1244,5 @@ const struct flash_driver efm32_flash = {
 	.erase_check = default_flash_blank_check,
 	.protect_check = efm32x_protect_check,
 	.info = get_efm32x_info,
-	.free_driver_priv = default_flash_free_driver_priv,
+	.free_driver_priv = efm32x_free_driver_priv,
 };
diff --git a/src/flash/nor/sim3x.c b/src/flash/nor/sim3x.c
index 2938ed1ab..891383860 100644
--- a/src/flash/nor/sim3x.c
+++ b/src/flash/nor/sim3x.c
@@ -983,7 +983,7 @@ COMMAND_HANDLER(sim3x_lock)
 
 	if (!dap) {
 		/* Used debug interface doesn't support direct DAP access */
-		LOG_INFO("Target can't by unlocked by this debug interface");
+		LOG_INFO("Target can't be unlocked by this debug interface");
 
 		/* Core check */
 		ret = target_read_u32(target, CPUID, &val);
diff --git a/src/flash/nor/stm32f1x.c b/src/flash/nor/stm32f1x.c
index 90cee6412..c750ff080 100644
--- a/src/flash/nor/stm32f1x.c
+++ b/src/flash/nor/stm32f1x.c
@@ -26,6 +26,8 @@
 #include "config.h"
 #endif
 
+#include <string.h>
+
 #include "imp.h"
 #include <helper/binarybuffer.h>
 #include <target/algorithm.h>
@@ -129,9 +131,8 @@ struct stm32x_flash_bank {
 };
 
 static int stm32x_mass_erase(struct flash_bank *bank);
-static int stm32x_get_device_id(struct flash_bank *bank, uint32_t *device_id);
 static int stm32x_write_block(struct flash_bank *bank, const uint8_t *buffer,
-		uint32_t address, uint32_t count);
+		uint32_t address, uint32_t hwords_count);
 
 /* flash bank stm32x <base> <size> 0 0 <target#>
  */
@@ -151,6 +152,9 @@ FLASH_BANK_COMMAND_HANDLER(stm32x_flash_bank_command)
 	stm32x_info->register_base = FLASH_REG_BASE_B0;
 	stm32x_info->user_bank_size = bank->size;
 
+	/* The flash write must be aligned to a halfword boundary */
+	bank->write_start_alignment = bank->write_end_alignment = 2;
+
 	return ERROR_OK;
 }
 
@@ -182,19 +186,19 @@ static int stm32x_wait_status_busy(struct flash_bank *bank, int timeout)
 			break;
 		if (timeout-- <= 0) {
 			LOG_ERROR("timed out waiting for flash");
-			return ERROR_FAIL;
+			return ERROR_FLASH_BUSY;
 		}
 		alive_sleep(1);
 	}
 
 	if (status & FLASH_WRPRTERR) {
 		LOG_ERROR("stm32x device protected");
-		retval = ERROR_FAIL;
+		retval = ERROR_FLASH_PROTECTED;
 	}
 
 	if (status & FLASH_PGERR) {
-		LOG_ERROR("stm32x device programming failed");
-		retval = ERROR_FAIL;
+		LOG_ERROR("stm32x device programming failed / flash not erased");
+		retval = ERROR_FLASH_OPERATION_FAILED;
 	}
 
 	/* Clear but report errors */
@@ -258,36 +262,39 @@ static int stm32x_erase_options(struct flash_bank *bank)
 	int retval = target_write_u32(target, STM32_FLASH_KEYR_B0, KEY1);
 	if (retval != ERROR_OK)
 		return retval;
-
 	retval = target_write_u32(target, STM32_FLASH_KEYR_B0, KEY2);
 	if (retval != ERROR_OK)
-		return retval;
+		goto flash_lock;
 
 	/* unlock option flash registers */
 	retval = target_write_u32(target, STM32_FLASH_OPTKEYR_B0, KEY1);
 	if (retval != ERROR_OK)
-		return retval;
+		goto flash_lock;
 	retval = target_write_u32(target, STM32_FLASH_OPTKEYR_B0, KEY2);
 	if (retval != ERROR_OK)
-		return retval;
+		goto flash_lock;
 
 	/* erase option bytes */
 	retval = target_write_u32(target, STM32_FLASH_CR_B0, FLASH_OPTER | FLASH_OPTWRE);
 	if (retval != ERROR_OK)
-		return retval;
+		goto flash_lock;
 	retval = target_write_u32(target, STM32_FLASH_CR_B0, FLASH_OPTER | FLASH_STRT | FLASH_OPTWRE);
 	if (retval != ERROR_OK)
-		return retval;
+		goto flash_lock;
 
 	retval = stm32x_wait_status_busy(bank, FLASH_ERASE_TIMEOUT);
 	if (retval != ERROR_OK)
-		return retval;
+		goto flash_lock;
 
 	/* clear read protection option byte
 	 * this will also force a device unlock if set */
 	stm32x_info->option_bytes.rdp = stm32x_info->default_rdp;
 
 	return ERROR_OK;
+
+flash_lock:
+	target_write_u32(target, STM32_FLASH_CR_B0, FLASH_LOCK);
+	return retval;
 }
 
 static int stm32x_write_options(struct flash_bank *bank)
@@ -303,20 +310,20 @@ static int stm32x_write_options(struct flash_bank *bank)
 		return retval;
 	retval = target_write_u32(target, STM32_FLASH_KEYR_B0, KEY2);
 	if (retval != ERROR_OK)
-		return retval;
+		goto flash_lock;
 
 	/* unlock option flash registers */
 	retval = target_write_u32(target, STM32_FLASH_OPTKEYR_B0, KEY1);
 	if (retval != ERROR_OK)
-		return retval;
+		goto flash_lock;
 	retval = target_write_u32(target, STM32_FLASH_OPTKEYR_B0, KEY2);
 	if (retval != ERROR_OK)
-		return retval;
+		goto flash_lock;
 
 	/* program option bytes */
 	retval = target_write_u32(target, STM32_FLASH_CR_B0, FLASH_OPTPG | FLASH_OPTWRE);
 	if (retval != ERROR_OK)
-		return retval;
+		goto flash_lock;
 
 	uint8_t opt_bytes[16];
 
@@ -329,18 +336,20 @@ static int stm32x_write_options(struct flash_bank *bank)
 	target_buffer_set_u16(target, opt_bytes + 12, (stm32x_info->option_bytes.protection >> 16) & 0xff);
 	target_buffer_set_u16(target, opt_bytes + 14, (stm32x_info->option_bytes.protection >> 24) & 0xff);
 
+	/* Block write is preferred in favour of operation with ancient ST-Link
+	 * firmwares without 16-bit memory access. See
+	 * 480: flash: stm32f1x: write option bytes using the loader
+	 * https://review.openocd.org/c/openocd/+/480
+	 */
 	retval = stm32x_write_block(bank, opt_bytes, STM32_OB_RDP, sizeof(opt_bytes) / 2);
-	if (retval != ERROR_OK) {
-		if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
-			LOG_ERROR("working area required to erase options bytes");
-		return retval;
-	}
-
-	retval = target_write_u32(target, STM32_FLASH_CR_B0, FLASH_LOCK);
-	if (retval != ERROR_OK)
-		return retval;
 
-	return ERROR_OK;
+flash_lock:
+	{
+		int retval2 = target_write_u32(target, STM32_FLASH_CR_B0, FLASH_LOCK);
+		if (retval == ERROR_OK)
+			retval = retval2;
+	}
+	return retval;
 }
 
 static int stm32x_protect_check(struct flash_bank *bank)
@@ -384,31 +393,33 @@ static int stm32x_erase(struct flash_bank *bank, unsigned int first,
 		return retval;
 	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY2);
 	if (retval != ERROR_OK)
-		return retval;
+		goto flash_lock;
 
 	for (unsigned int i = first; i <= last; i++) {
 		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_PER);
 		if (retval != ERROR_OK)
-			return retval;
+			goto flash_lock;
 		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_AR),
 				bank->base + bank->sectors[i].offset);
 		if (retval != ERROR_OK)
-			return retval;
+			goto flash_lock;
 		retval = target_write_u32(target,
 				stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_PER | FLASH_STRT);
 		if (retval != ERROR_OK)
-			return retval;
+			goto flash_lock;
 
 		retval = stm32x_wait_status_busy(bank, FLASH_ERASE_TIMEOUT);
 		if (retval != ERROR_OK)
-			return retval;
+			goto flash_lock;
 	}
 
-	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_LOCK);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return ERROR_OK;
+flash_lock:
+	{
+		int retval2 = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_LOCK);
+		if (retval == ERROR_OK)
+			retval = retval2;
+	}
+	return retval;
 }
 
 static int stm32x_protect(struct flash_bank *bank, int set, unsigned int first,
@@ -442,17 +453,16 @@ static int stm32x_protect(struct flash_bank *bank, int set, unsigned int first,
 	return stm32x_write_options(bank);
 }
 
-static int stm32x_write_block(struct flash_bank *bank, const uint8_t *buffer,
-		uint32_t address, uint32_t count)
+static int stm32x_write_block_async(struct flash_bank *bank, const uint8_t *buffer,
+		uint32_t address, uint32_t hwords_count)
 {
 	struct stm32x_flash_bank *stm32x_info = bank->driver_priv;
 	struct target *target = bank->target;
-	uint32_t buffer_size = 16384;
+	uint32_t buffer_size;
 	struct working_area *write_algorithm;
 	struct working_area *source;
-	struct reg_param reg_params[5];
 	struct armv7m_algorithm armv7m_info;
-	int retval = ERROR_OK;
+	int retval;
 
 	static const uint8_t stm32x_flash_write_code[] = {
 #include "../../../contrib/loaders/flash/stm32/stm32f1x.inc"
@@ -473,19 +483,28 @@ static int stm32x_write_block(struct flash_bank *bank, const uint8_t *buffer,
 	}
 
 	/* memory buffer */
-	while (target_alloc_working_area_try(target, buffer_size, &source) != ERROR_OK) {
-		buffer_size /= 2;
-		buffer_size &= ~3UL; /* Make sure it's 4 byte aligned */
-		if (buffer_size <= 256) {
-			/* we already allocated the writing code, but failed to get a
-			 * buffer, free the algorithm */
-			target_free_working_area(target, write_algorithm);
-
-			LOG_WARNING("no large enough working area available, can't do block memory writes");
-			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-		}
+	buffer_size = target_get_working_area_avail(target);
+	buffer_size = MIN(hwords_count * 2, MAX(buffer_size, 256));
+	/* Normally we allocate all available working area.
+	 * MIN shrinks buffer_size if the size of the written block is smaller.
+	 * MAX prevents using async algo if the available working area is smaller
+	 * than 256, the following allocation fails with
+	 * ERROR_TARGET_RESOURCE_NOT_AVAILABLE and slow flashing takes place.
+	 */
+
+	retval = target_alloc_working_area(target, buffer_size, &source);
+	/* Allocated size is always 32-bit word aligned */
+	if (retval != ERROR_OK) {
+		target_free_working_area(target, write_algorithm);
+		LOG_WARNING("no large enough working area available, can't do block memory writes");
+		/* target_alloc_working_area() may return ERROR_FAIL if area backup fails:
+		 * convert any error to ERROR_TARGET_RESOURCE_NOT_AVAILABLE
+		 */
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
 
+	struct reg_param reg_params[5];
+
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT);	/* flash base (in), status (out) */
 	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);	/* count (halfword-16bit) */
 	init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);	/* buffer start */
@@ -493,7 +512,7 @@ static int stm32x_write_block(struct flash_bank *bank, const uint8_t *buffer,
 	init_reg_param(&reg_params[4], "r4", 32, PARAM_IN_OUT);	/* target address */
 
 	buf_set_u32(reg_params[0].value, 0, 32, stm32x_info->register_base);
-	buf_set_u32(reg_params[1].value, 0, 32, count);
+	buf_set_u32(reg_params[1].value, 0, 32, hwords_count);
 	buf_set_u32(reg_params[2].value, 0, 32, source->address);
 	buf_set_u32(reg_params[3].value, 0, 32, source->address + source->size);
 	buf_set_u32(reg_params[4].value, 0, 32, address);
@@ -501,195 +520,297 @@ static int stm32x_write_block(struct flash_bank *bank, const uint8_t *buffer,
 	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
 
-	retval = target_run_flash_async_algorithm(target, buffer, count, 2,
+	retval = target_run_flash_async_algorithm(target, buffer, hwords_count, 2,
 			0, NULL,
-			5, reg_params,
+			ARRAY_SIZE(reg_params), reg_params,
 			source->address, source->size,
 			write_algorithm->address, 0,
 			&armv7m_info);
 
 	if (retval == ERROR_FLASH_OPERATION_FAILED) {
-		LOG_ERROR("flash write failed at address 0x%"PRIx32,
-				buf_get_u32(reg_params[4].value, 0, 32));
-
-		if (buf_get_u32(reg_params[0].value, 0, 32) & FLASH_PGERR) {
-			LOG_ERROR("flash memory not erased before writing");
-			/* Clear but report errors */
-			target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_SR), FLASH_PGERR);
-		}
+		/* Actually we just need to check for programming errors
+		 * stm32x_wait_status_busy also reports error and clears status bits.
+		 *
+		 * Target algo returns flash status in r0 only if properly finished.
+		 * It is safer to re-read status register.
+		 */
+		int retval2 = stm32x_wait_status_busy(bank, 5);
+		if (retval2 != ERROR_OK)
+			retval = retval2;
 
-		if (buf_get_u32(reg_params[0].value, 0, 32) & FLASH_WRPRTERR) {
-			LOG_ERROR("flash memory write protected");
-			/* Clear but report errors */
-			target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_SR), FLASH_WRPRTERR);
-		}
+		LOG_ERROR("flash write failed just before address 0x%"PRIx32,
+				buf_get_u32(reg_params[4].value, 0, 32));
 	}
 
+	for (unsigned int i = 0; i < ARRAY_SIZE(reg_params); i++)
+		destroy_reg_param(&reg_params[i]);
+
 	target_free_working_area(target, source);
 	target_free_working_area(target, write_algorithm);
 
-	destroy_reg_param(&reg_params[0]);
-	destroy_reg_param(&reg_params[1]);
-	destroy_reg_param(&reg_params[2]);
-	destroy_reg_param(&reg_params[3]);
-	destroy_reg_param(&reg_params[4]);
-
 	return retval;
 }
 
-static int stm32x_write(struct flash_bank *bank, const uint8_t *buffer,
-		uint32_t offset, uint32_t count)
+static int stm32x_write_block_riscv(struct flash_bank *bank, const uint8_t *buffer,
+		uint32_t address, uint32_t hwords_count)
 {
 	struct target *target = bank->target;
-	uint8_t *new_buffer = NULL;
+	uint32_t buffer_size;
+	struct working_area *write_algorithm;
+	struct working_area *source;
+	static const uint8_t gd32vf103_flash_write_code[] = {
+#include "../../../contrib/loaders/flash/gd32vf103/gd32vf103.inc"
+	};
 
-	if (bank->target->state != TARGET_HALTED) {
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
+	/* flash write code */
+	if (target_alloc_working_area(target, sizeof(gd32vf103_flash_write_code),
+			&write_algorithm) != ERROR_OK) {
+		LOG_WARNING("no working area available, can't do block memory writes");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
 
-	if (offset & 0x1) {
-		LOG_ERROR("offset 0x%" PRIx32 " breaks required 2-byte alignment", offset);
-		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+	int retval = target_write_buffer(target, write_algorithm->address,
+			sizeof(gd32vf103_flash_write_code), gd32vf103_flash_write_code);
+	if (retval != ERROR_OK) {
+		target_free_working_area(target, write_algorithm);
+		return retval;
 	}
 
-	/* If there's an odd number of bytes, the data has to be padded. Duplicate
-	 * the buffer and use the normal code path with a single block write since
-	 * it's probably cheaper than to special case the last odd write using
-	 * discrete accesses. */
-	if (count & 1) {
-		new_buffer = malloc(count + 1);
-		if (!new_buffer) {
-			LOG_ERROR("odd number of bytes to write and no memory for padding buffer");
-			return ERROR_FAIL;
+	/* memory buffer */
+	buffer_size = target_get_working_area_avail(target);
+	buffer_size = MIN(hwords_count * 2, MAX(buffer_size, 256));
+
+	retval = target_alloc_working_area(target, buffer_size, &source);
+	/* Allocated size is always word aligned */
+	if (retval != ERROR_OK) {
+		target_free_working_area(target, write_algorithm);
+		LOG_WARNING("no large enough working area available, can't do block memory writes");
+		/* target_alloc_working_area() may return ERROR_FAIL if area backup fails:
+		 * convert any error to ERROR_TARGET_RESOURCE_NOT_AVAILABLE
+		 */
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	struct reg_param reg_params[4];
+
+	init_reg_param(&reg_params[0], "a0", 32, PARAM_OUT);	/* poiner to FLASH_SR */
+	init_reg_param(&reg_params[1], "a1", 32, PARAM_OUT);	/* count (halfword-16bit) */
+	init_reg_param(&reg_params[2], "a2", 32, PARAM_OUT);	/* buffer start */
+	init_reg_param(&reg_params[3], "a3", 32, PARAM_IN_OUT);	/* target address */
+
+	while (hwords_count > 0) {
+		uint32_t thisrun_hwords = source->size / 2;
+
+		/* Limit to the amount of data we actually want to write */
+		if (thisrun_hwords > hwords_count)
+			thisrun_hwords = hwords_count;
+
+		/* Write data to buffer */
+		retval = target_write_buffer(target, source->address,
+					thisrun_hwords * 2, buffer);
+		if (retval != ERROR_OK)
+			break;
+
+		buf_set_u32(reg_params[0].value, 0, 32, stm32x_get_flash_reg(bank, STM32_FLASH_SR));
+		buf_set_u32(reg_params[1].value, 0, 32, thisrun_hwords);
+		buf_set_u32(reg_params[2].value, 0, 32, source->address);
+		buf_set_u32(reg_params[3].value, 0, 32, address);
+
+		retval = target_run_algorithm(target,
+				0, NULL,
+				ARRAY_SIZE(reg_params), reg_params,
+				write_algorithm->address,
+				write_algorithm->address + sizeof(gd32vf103_flash_write_code) - 4,
+				10000, NULL);
+
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Failed to execute algorithm at 0x%" TARGET_PRIxADDR ": %d",
+					write_algorithm->address, retval);
+			break;
 		}
-		LOG_INFO("odd number of bytes to write, padding with 0xff");
-		buffer = memcpy(new_buffer, buffer, count);
-		new_buffer[count++] = 0xff;
+
+		/* Actually we just need to check for programming errors
+		 * stm32x_wait_status_busy also reports error and clears status bits
+		 */
+		retval = stm32x_wait_status_busy(bank, 5);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("flash write failed at address 0x%"PRIx32,
+					buf_get_u32(reg_params[3].value, 0, 32));
+			break;
+		}
+
+		/* Update counters */
+		buffer += thisrun_hwords * 2;
+		address += thisrun_hwords * 2;
+		hwords_count -= thisrun_hwords;
 	}
 
-	uint32_t words_remaining = count / 2;
-	int retval, retval2;
+	for (unsigned int i = 0; i < ARRAY_SIZE(reg_params); i++)
+		destroy_reg_param(&reg_params[i]);
 
-	/* unlock flash registers */
-	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY1);
-	if (retval != ERROR_OK)
-		goto cleanup;
-	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY2);
-	if (retval != ERROR_OK)
-		goto cleanup;
+	target_free_working_area(target, source);
+	target_free_working_area(target, write_algorithm);
 
-	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_PG);
-	if (retval != ERROR_OK)
-		goto cleanup;
+	return retval;
+}
 
-	/* try using a block write */
-	retval = stm32x_write_block(bank, buffer, bank->base + offset, words_remaining);
+/** Writes a block to flash either using target algorithm
+ *  or use fallback, host controlled halfword-by-halfword access.
+ *  Flash controller must be unlocked before this call.
+ */
+static int stm32x_write_block(struct flash_bank *bank,
+		const uint8_t *buffer, uint32_t address, uint32_t hwords_count)
+{
+	struct target *target = bank->target;
+
+	/* The flash write must be aligned to a halfword boundary.
+	 * The flash infrastructure ensures it, do just a security check
+	 */
+	assert(address % 2 == 0);
+
+	int retval;
+	struct arm *arm = target_to_arm(target);
+	if (is_arm(arm)) {
+		/* try using a block write - on ARM architecture or... */
+		retval = stm32x_write_block_async(bank, buffer, address, hwords_count);
+	} else {
+		/* ... RISC-V architecture */
+		retval = stm32x_write_block_riscv(bank, buffer, address, hwords_count);
+	}
 
 	if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE) {
 		/* if block write failed (no sufficient working area),
 		 * we use normal (slow) single halfword accesses */
 		LOG_WARNING("couldn't use block writes, falling back to single memory accesses");
 
-		while (words_remaining > 0) {
-			uint16_t value;
-			memcpy(&value, buffer, sizeof(uint16_t));
-
-			retval = target_write_u16(target, bank->base + offset, value);
+		while (hwords_count > 0) {
+			retval = target_write_memory(target, address, 2, 1, buffer);
 			if (retval != ERROR_OK)
-				goto reset_pg_and_lock;
+				return retval;
 
 			retval = stm32x_wait_status_busy(bank, 5);
 			if (retval != ERROR_OK)
-				goto reset_pg_and_lock;
+				return retval;
 
-			words_remaining--;
+			hwords_count--;
 			buffer += 2;
-			offset += 2;
+			address += 2;
 		}
 	}
+	return retval;
+}
+
+static int stm32x_write(struct flash_bank *bank, const uint8_t *buffer,
+		uint32_t offset, uint32_t count)
+{
+	struct target *target = bank->target;
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* The flash write must be aligned to a halfword boundary.
+	 * The flash infrastructure ensures it, do just a security check
+	 */
+	assert(offset % 2 == 0);
+	assert(count % 2 == 0);
+
+	int retval, retval2;
+
+	/* unlock flash registers */
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY2);
+	if (retval != ERROR_OK)
+		goto reset_pg_and_lock;
+
+	/* enable flash programming */
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_PG);
+	if (retval != ERROR_OK)
+		goto reset_pg_and_lock;
+
+	/* write to flash */
+	retval = stm32x_write_block(bank, buffer, bank->base + offset, count / 2);
 
 reset_pg_and_lock:
 	retval2 = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_LOCK);
 	if (retval == ERROR_OK)
 		retval = retval2;
 
-cleanup:
-	free(new_buffer);
 	return retval;
 }
 
-static int stm32x_get_device_id(struct flash_bank *bank, uint32_t *device_id)
-{
-	struct target *target = bank->target;
-	struct cortex_m_common *cortex_m = target_to_cm(target);
-	uint32_t device_id_register = 0;
+struct stm32x_property_addr {
+	uint32_t device_id;
+	uint32_t flash_size;
+};
 
+static int stm32x_get_property_addr(struct target *target, struct stm32x_property_addr *addr)
+{
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
-		return ERROR_FAIL;
+		return ERROR_TARGET_NOT_EXAMINED;
 	}
 
-	switch (cortex_m->core_info->partno) {
+	switch (cortex_m_get_partno_safe(target)) {
 	case CORTEX_M0_PARTNO: /* STM32F0x devices */
-		device_id_register = 0x40015800;
-		break;
+		addr->device_id = 0x40015800;
+		addr->flash_size = 0x1FFFF7CC;
+		return ERROR_OK;
 	case CORTEX_M3_PARTNO: /* STM32F1x devices */
-		device_id_register = 0xE0042000;
-		break;
+		addr->device_id = 0xE0042000;
+		addr->flash_size = 0x1FFFF7E0;
+		return ERROR_OK;
 	case CORTEX_M4_PARTNO: /* STM32F3x devices */
-		device_id_register = 0xE0042000;
-		break;
+		addr->device_id = 0xE0042000;
+		addr->flash_size = 0x1FFFF7CC;
+		return ERROR_OK;
 	case CORTEX_M23_PARTNO: /* GD32E23x devices */
-		device_id_register = 0x40015800;
-		break;
+		addr->device_id = 0x40015800;
+		addr->flash_size = 0x1FFFF7E0;
+		return ERROR_OK;
+	case CORTEX_M_PARTNO_INVALID:
+		/* Check for GD32VF103 with RISC-V CPU */
+		if (strcmp(target_type_name(target), "riscv") == 0
+				&& target_address_bits(target) == 32) {
+			/* There is nothing like arm common_magic in riscv_info_t
+			 * check text name of target and if target is 32-bit
+			 */
+			addr->device_id = 0xE0042000;
+			addr->flash_size = 0x1FFFF7E0;
+			return ERROR_OK;
+		}
+		/* fallthrough */
 	default:
 		LOG_ERROR("Cannot identify target as a stm32x");
 		return ERROR_FAIL;
 	}
+}
 
-	/* read stm32 device id register */
-	int retval = target_read_u32(target, device_id_register, device_id);
+static int stm32x_get_device_id(struct flash_bank *bank, uint32_t *device_id)
+{
+	struct target *target = bank->target;
+	struct stm32x_property_addr addr;
+
+	int retval = stm32x_get_property_addr(target, &addr);
 	if (retval != ERROR_OK)
 		return retval;
 
-	return retval;
+	return target_read_u32(target, addr.device_id, device_id);
 }
 
 static int stm32x_get_flash_size(struct flash_bank *bank, uint16_t *flash_size_in_kb)
 {
 	struct target *target = bank->target;
-	struct cortex_m_common *cortex_m = target_to_cm(target);
-	uint32_t flash_size_reg;
+	struct stm32x_property_addr addr;
 
-	if (!target_was_examined(target)) {
-		LOG_ERROR("Target not examined yet");
-		return ERROR_FAIL;
-	}
-
-	switch (cortex_m->core_info->partno) {
-	case CORTEX_M0_PARTNO: /* STM32F0x devices */
-		flash_size_reg = 0x1FFFF7CC;
-		break;
-	case CORTEX_M3_PARTNO: /* STM32F1x devices */
-		flash_size_reg = 0x1FFFF7E0;
-		break;
-	case CORTEX_M4_PARTNO: /* STM32F3x devices */
-		flash_size_reg = 0x1FFFF7CC;
-		break;
-	case CORTEX_M23_PARTNO: /* GD32E23x devices */
-		flash_size_reg = 0x1FFFF7E0;
-		break;
-	default:
-		LOG_ERROR("Cannot identify target as a stm32x");
-		return ERROR_FAIL;
-	}
-
-	int retval = target_read_u16(target, flash_size_reg, flash_size_in_kb);
+	int retval = stm32x_get_property_addr(target, &addr);
 	if (retval != ERROR_OK)
 		return retval;
 
-	return retval;
+	return target_read_u16(target, addr.flash_size, flash_size_in_kb);
 }
 
 static int stm32x_probe(struct flash_bank *bank)
@@ -775,15 +896,20 @@ static int stm32x_probe(struct flash_bank *bank)
 			stm32x_info->user_data_offset = 16;
 			stm32x_info->option_offset = 6;
 			max_flash_size_in_kb = 64;
+			stm32x_info->can_load_options = true;
 			break;
 		case 0x1704: /* gd32f3x0 */
 			stm32x_info->user_data_offset = 16;
 			stm32x_info->option_offset = 6;
+			stm32x_info->can_load_options = true;
+			break;
+		case 0x1906: /* gd32vf103 */
 			break;
 		case 0x1909: /* gd32e23x */
 			stm32x_info->user_data_offset = 16;
 			stm32x_info->option_offset = 6;
 			max_flash_size_in_kb = 64;
+			stm32x_info->can_load_options = true;
 			break;
 		}
 		break;
@@ -995,6 +1121,10 @@ static int get_stm32x_info(struct flash_bank *bank, struct command_invocation *c
 			device_str = "GD32F3x0";
 			break;
 
+		case 0x1906:
+			device_str = "GD32VF103";
+			break;
+
 		case 0x1909: /* gd32e23x */
 			device_str = "GD32E23x";
 			break;
@@ -1478,8 +1608,10 @@ COMMAND_HANDLER(stm32x_handle_options_load_command)
 	if (retval != ERROR_OK)
 		return retval;
 	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY2);
-	if (retval != ERROR_OK)
+	if (retval != ERROR_OK) {
+		(void)target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_LOCK);
 		return retval;
+	}
 
 	/* force re-load of option bytes - generates software reset */
 	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_OBL_LAUNCH);
@@ -1504,26 +1636,26 @@ static int stm32x_mass_erase(struct flash_bank *bank)
 		return retval;
 	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY2);
 	if (retval != ERROR_OK)
-		return retval;
+		goto flash_lock;
 
 	/* mass erase flash memory */
 	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_MER);
 	if (retval != ERROR_OK)
-		return retval;
+		goto flash_lock;
 	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR),
 			FLASH_MER | FLASH_STRT);
 	if (retval != ERROR_OK)
-		return retval;
+		goto flash_lock;
 
 	retval = stm32x_wait_status_busy(bank, FLASH_ERASE_TIMEOUT);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_LOCK);
-	if (retval != ERROR_OK)
-		return retval;
 
-	return ERROR_OK;
+flash_lock:
+	{
+		int retval2 = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_LOCK);
+		if (retval == ERROR_OK)
+			retval = retval2;
+	}
+	return retval;
 }
 
 COMMAND_HANDLER(stm32x_handle_mass_erase_command)
diff --git a/src/flash/nor/stm32f2x.c b/src/flash/nor/stm32f2x.c
index d3e7d709c..622ef3423 100644
--- a/src/flash/nor/stm32f2x.c
+++ b/src/flash/nor/stm32f2x.c
@@ -636,8 +636,8 @@ static int stm32x_erase(struct flash_bank *bank, unsigned int first,
 
 	for (unsigned int i = first; i <= last; i++) {
 		unsigned int snb;
-		if (stm32x_info->has_large_mem && i >= 12)
-			snb = (i - 12) | 0x10;
+		if (stm32x_info->has_large_mem && i >= (bank->num_sectors / 2))
+			snb = (i - (bank->num_sectors / 2)) | 0x10;
 		else
 			snb = i;
 
@@ -856,15 +856,12 @@ static int stm32x_write(struct flash_bank *bank, const uint8_t *buffer,
 	Wait for the BSY bit to be cleared
 	*/
 	while (words_remaining > 0) {
-		uint16_t value;
-		memcpy(&value, buffer + bytes_written, sizeof(uint16_t));
-
 		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR),
 				FLASH_PG | FLASH_PSIZE_16);
 		if (retval != ERROR_OK)
 			return retval;
 
-		retval = target_write_u16(target, address, value);
+		retval = target_write_memory(target, address, 2, 1, buffer + bytes_written);
 		if (retval != ERROR_OK)
 			return retval;
 
@@ -966,14 +963,14 @@ static int stm32x_get_device_id(struct flash_bank *bank, uint32_t *device_id)
 	 * Only effects Rev A silicon */
 
 	struct target *target = bank->target;
-	struct cortex_m_common *cortex_m = target_to_cm(target);
 
 	/* read stm32 device id register */
 	int retval = target_read_u32(target, 0xE0042000, device_id);
 	if (retval != ERROR_OK)
 		return retval;
 
-	if ((*device_id & 0xfff) == 0x411 && cortex_m->core_info->partno == CORTEX_M4_PARTNO) {
+	if ((*device_id & 0xfff) == 0x411
+			&& cortex_m_get_partno_safe(target) == CORTEX_M4_PARTNO) {
 		*device_id &= ~((0xFFFF << 16) | 0xfff);
 		*device_id |= (0x1000 << 16) | 0x413;
 		LOG_INFO("stm32f4x errata detected - fixing incorrect MCU_IDCODE");
@@ -1011,6 +1008,11 @@ static int stm32x_probe(struct flash_bank *bank)
 	bank->num_prot_blocks = 0;
 	bank->prot_blocks = NULL;
 
+	if (!target_was_examined(target)) {
+		LOG_ERROR("Target not examined yet");
+		return ERROR_TARGET_NOT_EXAMINED;
+	}
+
 	/* if explicitly called out as OTP bank, short circuit probe */
 	if (stm32x_is_otp(bank)) {
 		if (stm32x_otp_is_f7(bank)) {
diff --git a/src/flash/nor/stm32h7x.c b/src/flash/nor/stm32h7x.c
index d3f17b2b1..d2914eb39 100644
--- a/src/flash/nor/stm32h7x.c
+++ b/src/flash/nor/stm32h7x.c
@@ -531,6 +531,7 @@ static int stm32x_protect(struct flash_bank *bank, int set, unsigned int first,
 		unsigned int last)
 {
 	struct target *target = bank->target;
+	struct stm32h7x_flash_bank *stm32x_info = bank->driver_priv;
 	uint32_t protection;
 
 	if (target->state != TARGET_HALTED) {
@@ -553,7 +554,7 @@ static int stm32x_protect(struct flash_bank *bank, int set, unsigned int first,
 	}
 
 	/* apply WRPSN mask */
-	protection &= 0xff;
+	protection &= stm32x_info->part_info->wps_mask;
 
 	LOG_DEBUG("stm32x_protect, option_bytes written WPSN 0x%" PRIx32, protection);
 
@@ -759,7 +760,6 @@ static int stm32x_read_id_code(struct flash_bank *bank, uint32_t *id)
 static int stm32x_probe(struct flash_bank *bank)
 {
 	struct target *target = bank->target;
-	struct cortex_m_common *cortex_m = target_to_cm(target);
 	struct stm32h7x_flash_bank *stm32x_info = bank->driver_priv;
 	uint16_t flash_size_in_kb;
 	uint32_t device_id;
@@ -767,6 +767,11 @@ static int stm32x_probe(struct flash_bank *bank)
 	stm32x_info->probed = false;
 	stm32x_info->part_info = NULL;
 
+	if (!target_was_examined(target)) {
+		LOG_ERROR("Target not examined yet");
+		return ERROR_TARGET_NOT_EXAMINED;
+	}
+
 	int retval = stm32x_read_id_code(bank, &stm32x_info->idcode);
 	if (retval != ERROR_OK)
 		return retval;
@@ -800,7 +805,8 @@ static int stm32x_probe(struct flash_bank *bank)
 	/* get flash size from target */
 	/* STM32H74x/H75x, the second core (Cortex-M4) cannot read the flash size */
 	retval = ERROR_FAIL;
-	if (device_id == DEVID_STM32H74_H75XX && cortex_m->core_info->partno == CORTEX_M4_PARTNO)
+	if (device_id == DEVID_STM32H74_H75XX
+			&& cortex_m_get_partno_safe(target) == CORTEX_M4_PARTNO)
 		LOG_WARNING("%s cannot read the flash size register", target_name(target));
 	else
 		retval = target_read_u16(target, stm32x_info->part_info->fsize_addr, &flash_size_in_kb);
diff --git a/src/flash/nor/stm32l4x.c b/src/flash/nor/stm32l4x.c
index e5100a015..7b35a0635 100644
--- a/src/flash/nor/stm32l4x.c
+++ b/src/flash/nor/stm32l4x.c
@@ -1632,13 +1632,14 @@ err_lock:
 
 static int stm32l4_read_idcode(struct flash_bank *bank, uint32_t *id)
 {
-	int retval;
+	int retval = ERROR_OK;
+	struct target *target = bank->target;
 
 	/* try reading possible IDCODE registers, in the following order */
 	uint32_t dbgmcu_idcode[] = {DBGMCU_IDCODE_L4_G4, DBGMCU_IDCODE_G0, DBGMCU_IDCODE_L5};
 
 	for (unsigned int i = 0; i < ARRAY_SIZE(dbgmcu_idcode); i++) {
-		retval = target_read_u32(bank->target, dbgmcu_idcode[i], id);
+		retval = target_read_u32(target, dbgmcu_idcode[i], id);
 		if ((retval == ERROR_OK) && ((*id & 0xfff) != 0) && ((*id & 0xfff) != 0xfff))
 			return ERROR_OK;
 	}
@@ -1647,12 +1648,16 @@ static int stm32l4_read_idcode(struct flash_bank *bank, uint32_t *id)
 	 * DBGMCU_IDCODE cannot be read using CPU1 (Cortex-M0+) at AP1,
 	 * to solve this read the UID64 (IEEE 64-bit unique device ID register) */
 
-	struct cortex_m_common *cortex_m = target_to_cm(bank->target);
+	struct armv7m_common *armv7m = target_to_armv7m_safe(target);
+	if (!armv7m) {
+		LOG_ERROR("Flash requires Cortex-M target");
+		return ERROR_TARGET_INVALID;
+	}
 
 	/* CPU2 (Cortex-M0+) is supported only with non-hla adapters because it is on AP1.
 	 * Using HLA adapters armv7m.debug_ap is null, and checking ap_num triggers a segfault */
-	if (cortex_m->core_info->partno == CORTEX_M0P_PARTNO &&
-			cortex_m->armv7m.debug_ap && cortex_m->armv7m.debug_ap->ap_num == 1) {
+	if (cortex_m_get_partno_safe(target) == CORTEX_M0P_PARTNO &&
+			armv7m->debug_ap && armv7m->debug_ap->ap_num == 1) {
 		uint32_t uid64_ids;
 
 		/* UID64 is contains
@@ -1662,7 +1667,7 @@ static int stm32l4_read_idcode(struct flash_bank *bank, uint32_t *id)
 		 *
 		 *  read only the fixed values {STID,DEVID} from UID64_IDS to identify the device as STM32WLx
 		 */
-		retval = target_read_u32(bank->target, UID64_IDS, &uid64_ids);
+		retval = target_read_u32(target, UID64_IDS, &uid64_ids);
 		if (retval == ERROR_OK && uid64_ids == UID64_IDS_STM32WL) {
 			/* force the DEV_ID to DEVID_STM32WLE_WL5XX and the REV_ID to unknown */
 			*id = DEVID_STM32WLE_WL5XX;
@@ -1700,11 +1705,21 @@ static const char *get_stm32l4_bank_type_str(struct flash_bank *bank)
 static int stm32l4_probe(struct flash_bank *bank)
 {
 	struct target *target = bank->target;
-	struct armv7m_common *armv7m = target_to_armv7m(target);
 	struct stm32l4_flash_bank *stm32l4_info = bank->driver_priv;
 	const struct stm32l4_part_info *part_info;
 	uint16_t flash_size_kb = 0xffff;
 
+	if (!target_was_examined(target)) {
+		LOG_ERROR("Target not examined yet");
+		return ERROR_TARGET_NOT_EXAMINED;
+	}
+
+	struct armv7m_common *armv7m = target_to_armv7m_safe(target);
+	if (!armv7m) {
+		LOG_ERROR("Flash requires Cortex-M target");
+		return ERROR_TARGET_INVALID;
+	}
+
 	stm32l4_info->probed = false;
 
 	/* read stm32 device id registers */
@@ -1742,7 +1757,7 @@ static int stm32l4_probe(struct flash_bank *bank)
 	 * Ask the flash infrastructure to ensure required alignment */
 	bank->write_start_alignment = bank->write_end_alignment = stm32l4_info->data_width;
 
-	/* initialise the flash registers layout */
+	/* Initialize the flash registers layout */
 	if (part_info->flags & F_HAS_L5_FLASH_REGS)
 		stm32l4_info->flash_regs = stm32l5_ns_flash_regs;
 	else
@@ -1755,7 +1770,7 @@ static int stm32l4_probe(struct flash_bank *bank)
 
 	stm32l4_sync_rdp_tzen(bank);
 
-	/* for devices with trustzone, use flash secure registers when TZEN=1 and RDP is LEVEL_0 */
+	/* for devices with TrustZone, use flash secure registers when TZEN=1 and RDP is LEVEL_0 */
 	if (stm32l4_info->tzen && (stm32l4_info->rdp == RDP_LEVEL_0)) {
 		if (part_info->flags & F_HAS_L5_FLASH_REGS) {
 			stm32l4_info->flash_regs_base |= STM32L5_REGS_SEC_OFFSET;
@@ -2031,8 +2046,19 @@ static int stm32l4_auto_probe(struct flash_bank *bank)
 	if (stm32l4_info->probed) {
 		uint32_t optr_cur;
 
+		/* save flash_regs_base */
+		uint32_t saved_flash_regs_base = stm32l4_info->flash_regs_base;
+
+		/* for devices with TrustZone, use NS flash registers to read OPTR */
+		if (stm32l4_info->part_info->flags & F_HAS_L5_FLASH_REGS)
+			stm32l4_info->flash_regs_base &= ~STM32L5_REGS_SEC_OFFSET;
+
 		/* read flash option register and re-probe if optr value is changed */
 		int retval = stm32l4_read_flash_reg_by_index(bank, STM32_FLASH_OPTR_INDEX, &optr_cur);
+
+		/* restore saved flash_regs_base */
+		stm32l4_info->flash_regs_base = saved_flash_regs_base;
+
 		if (retval != ERROR_OK)
 			return retval;
 
diff --git a/src/helper/bits.h b/src/helper/bits.h
index 00d3c0270..6151b3340 100644
--- a/src/helper/bits.h
+++ b/src/helper/bits.h
@@ -28,8 +28,12 @@
 #include <helper/types.h>
 
 #define BIT(nr)                     (1UL << (nr))
+#define BIT_ULL(nr)                 (1ULL << (nr))
 #define BITS_PER_BYTE               8
 #define BITS_PER_LONG               (BITS_PER_BYTE * sizeof(long))
+#define BITS_PER_LONG_LONG          (BITS_PER_BYTE * sizeof(long long))
+#define GENMASK(h, l)               (((~0UL) - (1UL << (l)) + 1) & (~0UL >> (BITS_PER_LONG - 1 - (h))))
+#define GENMASK_ULL(h, l)           (((~0ULL) - (1ULL << (l)) + 1) & (~0ULL >> (BITS_PER_LONG_LONG - 1 - (h))))
 #define BITS_TO_LONGS(nr)           DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
 #define BIT_MASK(nr)                (1UL << ((nr) % BITS_PER_LONG))
 #define BIT_WORD(nr)                ((nr) / BITS_PER_LONG)
diff --git a/src/helper/command.c b/src/helper/command.c
index 53ee2508a..1e769d719 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -1145,6 +1145,7 @@ COMMAND_HANDLER(handle_sleep_command)
 		int64_t then = timeval_ms();
 		while (timeval_ms() - then < (int64_t)duration) {
 			target_call_timer_callbacks_now();
+			keep_alive();
 			usleep(1000);
 		}
 	} else
diff --git a/src/helper/jim-nvp.c b/src/helper/jim-nvp.c
index 738ed7943..0409a83cd 100644
--- a/src/helper/jim-nvp.c
+++ b/src/helper/jim-nvp.c
@@ -41,6 +41,10 @@
  * official policies, either expressed or implied, of the Jim Tcl Project.
  */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include "jim-nvp.h"
 #include <string.h>
 
diff --git a/src/helper/list.h b/src/helper/list.h
index a7cd4ad37..552a3202a 100644
--- a/src/helper/list.h
+++ b/src/helper/list.h
@@ -656,6 +656,20 @@ static inline void list_splice_tail_init(struct list_head *list,
 	     !list_entry_is_head(pos, head, member);			\
 	     pos = list_prev_entry(pos, member))
 
+/**
+ * list_for_each_entry_direction - iterate forward/backward over list of given type
+ * @param forward the iterate direction, true for forward, false for backward.
+ * @param pos     the type * to use as a loop cursor.
+ * @param head    the head for your list.
+ * @param member  the name of the list_head within the struct.
+ */
+#define list_for_each_entry_direction(forward, pos, head, member)		\
+	for (pos = forward ? list_first_entry(head, typeof(*pos), member)	\
+					   : list_last_entry(head, typeof(*pos), member);	\
+		 !list_entry_is_head(pos, head, member);						\
+		 pos = forward ? list_next_entry(pos, member)					\
+					   : list_prev_entry(pos, member))
+
 /**
  * list_prepare_entry - prepare a pos entry for use in list_for_each_entry_continue()
  * @param pos    the type * to use as a start point
diff --git a/src/helper/log.c b/src/helper/log.c
index caa0a66bf..106d22867 100644
--- a/src/helper/log.c
+++ b/src/helper/log.c
@@ -30,6 +30,7 @@
 #include "command.h"
 #include "replacements.h"
 #include "time_support.h"
+#include <server/server.h>
 
 #include <stdarg.h>
 
@@ -47,7 +48,6 @@ static FILE *log_output;
 static struct log_callback *log_callbacks;
 
 static int64_t last_time;
-static int64_t current_time;
 
 static int64_t start;
 
@@ -111,32 +111,27 @@ static void log_puts(enum log_levels level,
 	if (f)
 		file = f + 1;
 
-	if (strlen(string) > 0) {
-		if (debug_level >= LOG_LVL_DEBUG) {
-			/* print with count and time information */
-			int64_t t = timeval_ms() - start;
+	if (debug_level >= LOG_LVL_DEBUG) {
+		/* print with count and time information */
+		int64_t t = timeval_ms() - start;
 #ifdef _DEBUG_FREE_SPACE_
-			struct mallinfo info;
-			info = mallinfo();
+		struct mallinfo info;
+		info = mallinfo();
 #endif
-			fprintf(log_output, "%s%d %" PRId64 " %s:%d %s()"
+		fprintf(log_output, "%s%d %" PRId64 " %s:%d %s()"
 #ifdef _DEBUG_FREE_SPACE_
-				" %d"
+			" %d"
 #endif
-				": %s", log_strings[level + 1], count, t, file, line, function,
+			": %s", log_strings[level + 1], count, t, file, line, function,
 #ifdef _DEBUG_FREE_SPACE_
-				info.fordblks,
+			info.fordblks,
 #endif
-				string);
-		} else {
-			/* if we are using gdb through pipes then we do not want any output
-			 * to the pipe otherwise we get repeated strings */
-			fprintf(log_output, "%s%s",
-				(level > LOG_LVL_USER) ? log_strings[level + 1] : "", string);
-		}
+			string);
 	} else {
-		/* Empty strings are sent to log callbacks to keep e.g. gdbserver alive, here we do
-		 *nothing. */
+		/* if we are using gdb through pipes then we do not want any output
+		 * to the pipe otherwise we get repeated strings */
+		fprintf(log_output, "%s%s",
+			(level > LOG_LVL_USER) ? log_strings[level + 1] : "", string);
 	}
 
 	fflush(log_output);
@@ -302,6 +297,15 @@ void log_init(void)
 	start = last_time = timeval_ms();
 }
 
+void log_exit(void)
+{
+	if (log_output && log_output != stderr) {
+		/* Close log file, if it was open and wasn't stderr. */
+		fclose(log_output);
+	}
+	log_output = NULL;
+}
+
 int set_log_output(struct command_context *cmd_ctx, FILE *output)
 {
 	log_output = output;
@@ -431,8 +435,7 @@ static void gdb_timeout_warning(int64_t delta_time)
 
 void keep_alive(void)
 {
-	current_time = timeval_ms();
-
+	int64_t current_time = timeval_ms();
 	int64_t delta_time = current_time - last_time;
 
 	if (delta_time > KEEP_ALIVE_TIMEOUT_MS) {
@@ -445,7 +448,7 @@ void keep_alive(void)
 		last_time = current_time;
 
 		/* this will keep the GDB connection alive */
-		LOG_USER_N("%s", "");
+		server_keep_clients_alive();
 
 		/* DANGER!!!! do not add code to invoke e.g. target event processing,
 		 * jim timer processing, etc. it can cause infinite recursion +
@@ -460,7 +463,7 @@ void keep_alive(void)
 /* reset keep alive timer without sending message */
 void kept_alive(void)
 {
-	current_time = timeval_ms();
+	int64_t current_time = timeval_ms();
 
 	int64_t delta_time = current_time - last_time;
 
diff --git a/src/helper/log.h b/src/helper/log.h
index 621d467b4..f0378ae79 100644
--- a/src/helper/log.h
+++ b/src/helper/log.h
@@ -72,6 +72,7 @@ __attribute__ ((format (PRINTF_ATTRIBUTE_FORMAT, 5, 6)));
  * Initialize logging module.  Call during program startup.
  */
 void log_init(void);
+void log_exit(void);
 int set_log_output(struct command_context *cmd_ctx, FILE *output);
 
 int log_register_commands(struct command_context *cmd_ctx);
diff --git a/src/jtag/core.c b/src/jtag/core.c
index 29ab6cc1c..bbc9877ee 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -1273,7 +1273,7 @@ static int jtag_examine_chain(void)
 			jtag_tap_init(tap);
 		}
 
-		if ((idcode & 1) == 0) {
+		if ((idcode & 1) == 0 && !tap->ignore_bypass) {
 			/* Zero for LSB indicates a device in bypass */
 			LOG_INFO("TAP %s does not have valid IDCODE (idcode=0x%" PRIx32 ")",
 					tap->dotted_name, idcode);
diff --git a/src/jtag/drivers/Makefile.am b/src/jtag/drivers/Makefile.am
index c2161523d..887f99bcd 100644
--- a/src/jtag/drivers/Makefile.am
+++ b/src/jtag/drivers/Makefile.am
@@ -75,6 +75,9 @@ endif
 if JTAG_VPI
 DRIVERFILES += %D%/jtag_vpi.c
 endif
+if VDEBUG
+DRIVERFILES += %D%/vdebug.c
+endif
 if JTAG_DPI
 DRIVERFILES += %D%/jtag_dpi.c
 endif
diff --git a/src/jtag/drivers/bcm2835gpio.c b/src/jtag/drivers/bcm2835gpio.c
index fd6c28b96..b7a4d998c 100644
--- a/src/jtag/drivers/bcm2835gpio.c
+++ b/src/jtag/drivers/bcm2835gpio.c
@@ -565,6 +565,13 @@ static int bcm2835gpio_init(void)
 	}
 
 	if (transport_is_swd()) {
+		/* Make buffer an output before the GPIO connected to it */
+		if (swdio_dir_gpio != -1) {
+			swdio_dir_gpio_mode = MODE_GPIO(swdio_dir_gpio);
+			GPIO_SET = 1 << swdio_dir_gpio;
+			OUT_GPIO(swdio_dir_gpio);
+		}
+
 		swclk_gpio_mode = MODE_GPIO(swclk_gpio);
 		swdio_gpio_mode = MODE_GPIO(swdio_gpio);
 
@@ -580,12 +587,6 @@ static int bcm2835gpio_init(void)
 		OUT_GPIO(srst_gpio);
 	}
 
-	if (swdio_dir_gpio != -1) {
-		swdio_dir_gpio_mode = MODE_GPIO(swdio_dir_gpio);
-		GPIO_SET = 1 << swdio_dir_gpio;
-		OUT_GPIO(swdio_dir_gpio);
-	}
-
 	LOG_DEBUG("saved pinmux settings: tck %d tms %d tdi %d "
 		  "tdo %d trst %d srst %d", tck_gpio_mode, tms_gpio_mode,
 		  tdi_gpio_mode, tdo_gpio_mode, trst_gpio_mode, srst_gpio_mode);
diff --git a/src/jtag/drivers/cmsis_dap.c b/src/jtag/drivers/cmsis_dap.c
index e7562d087..eaa65abc6 100644
--- a/src/jtag/drivers/cmsis_dap.c
+++ b/src/jtag/drivers/cmsis_dap.c
@@ -48,6 +48,7 @@
 #include <target/cortex_m.h>
 
 #include "cmsis_dap.h"
+#include "libusb_helper.h"
 
 static const struct cmsis_dap_backend *const cmsis_dap_backends[] = {
 #if BUILD_CMSIS_DAP_USB == 1
@@ -79,8 +80,6 @@ static uint16_t cmsis_dap_pid[MAX_USB_IDS + 1] = { 0 };
 static int cmsis_dap_backend = -1;
 static bool swd_mode;
 
-#define USB_TIMEOUT       1000
-
 /* CMSIS-DAP General Commands */
 #define CMD_DAP_INFO              0x00
 #define CMD_DAP_LED               0x01
@@ -210,7 +209,7 @@ static bool swd_mode;
  * None as yet... */
 
 static const char * const info_caps_str[INFO_CAPS__NUM_CAPS] = {
-	"SWD  supported",
+	"SWD supported",
 	"JTAG supported",
 	"SWO-UART supported",
 	"SWO-MANCHESTER supported",
@@ -360,12 +359,12 @@ static int cmsis_dap_xfer(struct cmsis_dap *dap, int txlen)
 	}
 
 	uint8_t current_cmd = cmsis_dap_handle->command[0];
-	int retval = dap->backend->write(dap, txlen, USB_TIMEOUT);
+	int retval = dap->backend->write(dap, txlen, LIBUSB_TIMEOUT_MS);
 	if (retval < 0)
 		return retval;
 
 	/* get reply */
-	retval = dap->backend->read(dap, USB_TIMEOUT);
+	retval = dap->backend->read(dap, LIBUSB_TIMEOUT_MS);
 	if (retval < 0)
 		return retval;
 
@@ -826,7 +825,7 @@ static void cmsis_dap_swd_write_from_queue(struct cmsis_dap *dap)
 		}
 	}
 
-	int retval = dap->backend->write(dap, idx, USB_TIMEOUT);
+	int retval = dap->backend->write(dap, idx, LIBUSB_TIMEOUT_MS);
 	if (retval < 0) {
 		queued_retval = retval;
 		goto skip;
@@ -854,7 +853,7 @@ static void cmsis_dap_swd_read_process(struct cmsis_dap *dap, int timeout_ms)
 
 	/* get reply */
 	int retval = dap->backend->read(dap, timeout_ms);
-	if (retval == ERROR_TIMEOUT_REACHED && timeout_ms < USB_TIMEOUT)
+	if (retval == ERROR_TIMEOUT_REACHED && timeout_ms < LIBUSB_TIMEOUT_MS)
 		return;
 
 	if (retval <= 0) {
@@ -929,7 +928,7 @@ static int cmsis_dap_swd_run_queue(void)
 	cmsis_dap_swd_write_from_queue(cmsis_dap_handle);
 
 	while (pending_fifo_block_count)
-		cmsis_dap_swd_read_process(cmsis_dap_handle, USB_TIMEOUT);
+		cmsis_dap_swd_read_process(cmsis_dap_handle, LIBUSB_TIMEOUT_MS);
 
 	pending_fifo_put_idx = 0;
 	pending_fifo_get_idx = 0;
@@ -953,7 +952,7 @@ static void cmsis_dap_swd_queue_cmd(uint8_t cmd, uint32_t *dst, uint32_t data)
 		cmsis_dap_swd_write_from_queue(cmsis_dap_handle);
 
 		if (pending_fifo_block_count >= cmsis_dap_handle->packet_count)
-			cmsis_dap_swd_read_process(cmsis_dap_handle, USB_TIMEOUT);
+			cmsis_dap_swd_read_process(cmsis_dap_handle, LIBUSB_TIMEOUT_MS);
 	}
 
 	if (queued_retval != ERROR_OK)
@@ -1406,18 +1405,18 @@ static void debug_parse_cmsis_buf(const uint8_t *cmd, int cmdlen)
 	for (int i = 0; i < cmdlen; ++i)
 		printf(" %02x", cmd[i]);
 	printf("\n");
-	switch (cmd[1]) {
+	switch (cmd[0]) {
 		case CMD_DAP_JTAG_SEQ: {
-			printf("cmsis-dap jtag sequence command %02x (n=%d)\n", cmd[1], cmd[2]);
+			printf("cmsis-dap jtag sequence command %02x (n=%d)\n", cmd[0], cmd[1]);
 			/*
-			 * #2 = number of sequences
-			 * #3 = sequence info 1
-			 * #4...4+n_bytes-1 = sequence 1
+			 * #1 = number of sequences
+			 * #2 = sequence info 1
+			 * #3...4+n_bytes-1 = sequence 1
 			 * #4+n_bytes = sequence info 2
 			 * #5+n_bytes = sequence 2 (single bit)
 			 */
-			int pos = 3;
-			for (int seq = 0; seq < cmd[2]; ++seq) {
+			int pos = 2;
+			for (int seq = 0; seq < cmd[1]; ++seq) {
 				uint8_t info = cmd[pos++];
 				int len = info & DAP_JTAG_SEQ_TCK;
 				if (len == 0)
diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index fdf4ae778..5c218742b 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -114,8 +114,6 @@ static int jlink_flush(void);
  * @param in A pointer to store TDO data to, if NULL the data will be discarded.
  * @param in_offset A bit offset for TDO data.
  * @param length Amount of bits to transfer out and in.
- *
- * @retval This function doesn't return any value.
  */
 static void jlink_clock_data(const uint8_t *out, unsigned out_offset,
 			     const uint8_t *tms_out, unsigned tms_offset,
diff --git a/src/jtag/drivers/jtag_vpi.c b/src/jtag/drivers/jtag_vpi.c
index 0fc688edf..eb53a5b06 100644
--- a/src/jtag/drivers/jtag_vpi.c
+++ b/src/jtag/drivers/jtag_vpi.c
@@ -38,8 +38,8 @@
 #define NO_TAP_SHIFT	0
 #define TAP_SHIFT	1
 
-#define SERVER_ADDRESS	"127.0.0.1"
-#define SERVER_PORT	5555
+#define DEFAULT_SERVER_ADDRESS	"127.0.0.1"
+#define DEFAULT_SERVER_PORT	5555
 
 #define	XFERT_MAX_SIZE		512
 
@@ -50,7 +50,7 @@
 #define CMD_STOP_SIMU		4
 
 /* jtag_vpi server port and address to connect to */
-static int server_port = SERVER_PORT;
+static int server_port = DEFAULT_SERVER_PORT;
 static char *server_address;
 
 /* Send CMD_STOP_SIMU to server when OpenOCD exits? */
@@ -551,7 +551,7 @@ static int jtag_vpi_init(void)
 	serv_addr.sin_port = htons(server_port);
 
 	if (!server_address)
-		server_address = strdup(SERVER_ADDRESS);
+		server_address = strdup(DEFAULT_SERVER_ADDRESS);
 
 	serv_addr.sin_addr.s_addr = inet_addr(server_address);
 
@@ -604,27 +604,28 @@ static int jtag_vpi_quit(void)
 
 COMMAND_HANDLER(jtag_vpi_set_port)
 {
-	if (CMD_ARGC == 0)
-		LOG_WARNING("You need to set a port number");
-	else
-		COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], server_port);
+	if (CMD_ARGC == 0) {
+		LOG_ERROR("Command \"jtag_vpi set_port\" expects 1 argument (TCP port number)");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
 
-	LOG_INFO("Set server port to %u", server_port);
+	COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], server_port);
+	LOG_INFO("jtag_vpi: server port set to %u", server_port);
 
 	return ERROR_OK;
 }
 
 COMMAND_HANDLER(jtag_vpi_set_address)
 {
-	free(server_address);
 
 	if (CMD_ARGC == 0) {
-		LOG_WARNING("You need to set an address");
-		server_address = strdup(SERVER_ADDRESS);
-	} else
-		server_address = strdup(CMD_ARGV[0]);
+		LOG_ERROR("Command \"jtag_vpi set_address\" expects 1 argument (IP address)");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
 
-	LOG_INFO("Set server address to %s", server_address);
+	free(server_address);
+	server_address = strdup(CMD_ARGV[0]);
+	LOG_INFO("jtag_vpi: server address set to %s", server_address);
 
 	return ERROR_OK;
 }
@@ -632,11 +633,11 @@ COMMAND_HANDLER(jtag_vpi_set_address)
 COMMAND_HANDLER(jtag_vpi_stop_sim_on_exit_handler)
 {
 	if (CMD_ARGC != 1) {
-		LOG_ERROR("jtag_vpi_stop_sim_on_exit expects 1 argument (on|off)");
+		LOG_ERROR("Command \"jtag_vpi stop_sim_on_exit\" expects 1 argument (on|off)");
 		return ERROR_COMMAND_SYNTAX_ERROR;
-	} else {
-		COMMAND_PARSE_ON_OFF(CMD_ARGV[0], stop_sim_on_exit);
 	}
+
+	COMMAND_PARSE_ON_OFF(CMD_ARGV[0], stop_sim_on_exit);
 	return ERROR_OK;
 }
 
@@ -645,14 +646,14 @@ static const struct command_registration jtag_vpi_subcommand_handlers[] = {
 		.name = "set_port",
 		.handler = &jtag_vpi_set_port,
 		.mode = COMMAND_CONFIG,
-		.help = "set the port of the VPI server",
+		.help = "set the TCP port number of the jtag_vpi server (default: 5555)",
 		.usage = "tcp_port_num",
 	},
 	{
 		.name = "set_address",
 		.handler = &jtag_vpi_set_address,
 		.mode = COMMAND_CONFIG,
-		.help = "set the address of the VPI server",
+		.help = "set the IP address of the jtag_vpi server (default: 127.0.0.1)",
 		.usage = "ipv4_addr",
 	},
 	{
diff --git a/src/jtag/drivers/libusb_helper.h b/src/jtag/drivers/libusb_helper.h
index 2ddb246b3..9d51464a7 100644
--- a/src/jtag/drivers/libusb_helper.h
+++ b/src/jtag/drivers/libusb_helper.h
@@ -22,6 +22,20 @@
 
 #include <libusb.h>
 
+/* When we debug a target that works as a USB device, halting the target causes the
+ * USB communication with the USB host to become unresponsive. The host will try
+ * to reconnect/reset/setup the unresponsive device during which communication
+ * with other devices on the same USB bus can get stalled for several seconds.
+ * If the JTAG adapter is on the same bus, we need to make sure openOCD will wait
+ * for packets at least as long as the host USB stack. Otherwise the USB stack
+ * might deliver a valid packet, but openOCD would ignore it due to the timeout.
+ * The xHCI spec uses 5 sec timeouts, so let's use that in openOCD with some margin.
+ *
+ * Use this value in all libusb calls. HID API might have a libusb backend and
+ * would probably be victim to the same bug, so it should use this timeout, too.
+ */
+#define LIBUSB_TIMEOUT_MS	(6000)
+
 /* this callback should return a non NULL value only when the serial could not
  * be retrieved by the standard 'libusb_get_string_descriptor_ascii' */
 typedef char * (*adapter_get_alternate_serial_fn)(struct libusb_device_handle *device,
diff --git a/src/jtag/drivers/linuxgpiod.c b/src/jtag/drivers/linuxgpiod.c
index 9f9f27a9f..288035f2e 100644
--- a/src/jtag/drivers/linuxgpiod.c
+++ b/src/jtag/drivers/linuxgpiod.c
@@ -27,6 +27,7 @@ static int trst_gpio = -1;
 static int srst_gpio = -1;
 static int swclk_gpio = -1;
 static int swdio_gpio = -1;
+static int swdio_dir_gpio = -1;
 static int led_gpio = -1;
 static int gpiochip = -1;
 static int tck_gpiochip = -1;
@@ -37,6 +38,7 @@ static int trst_gpiochip = -1;
 static int srst_gpiochip = -1;
 static int swclk_gpiochip = -1;
 static int swdio_gpiochip = -1;
+static int swdio_dir_gpiochip = -1;
 static int led_gpiochip = -1;
 
 static struct gpiod_chip *gpiod_chip_tck;
@@ -47,6 +49,7 @@ static struct gpiod_chip *gpiod_chip_trst;
 static struct gpiod_chip *gpiod_chip_srst;
 static struct gpiod_chip *gpiod_chip_swclk;
 static struct gpiod_chip *gpiod_chip_swdio;
+static struct gpiod_chip *gpiod_chip_swdio_dir;
 static struct gpiod_chip *gpiod_chip_led;
 
 static struct gpiod_line *gpiod_tck;
@@ -56,6 +59,7 @@ static struct gpiod_line *gpiod_tdo;
 static struct gpiod_line *gpiod_trst;
 static struct gpiod_line *gpiod_swclk;
 static struct gpiod_line *gpiod_swdio;
+static struct gpiod_line *gpiod_swdio_dir;
 static struct gpiod_line *gpiod_srst;
 static struct gpiod_line *gpiod_led;
 
@@ -63,6 +67,7 @@ static int last_swclk;
 static int last_swdio;
 static bool last_stored;
 static bool swdio_input;
+static bool swdio_dir_is_active_high = true;
 
 /* Bitbang interface read of TDO */
 static bb_value_t linuxgpiod_read(void)
@@ -152,6 +157,11 @@ static void linuxgpiod_swdio_drive(bool is_output)
 	gpiod_line_release(gpiod_swdio);
 
 	if (is_output) {
+		if (gpiod_swdio_dir) {
+			retval = gpiod_line_set_value(gpiod_swdio_dir, swdio_dir_is_active_high ? 1 : 0);
+			if (retval < 0)
+				LOG_WARNING("Fail set swdio_dir");
+		}
 		retval = gpiod_line_request_output(gpiod_swdio, "OpenOCD", 1);
 		if (retval < 0)
 			LOG_WARNING("Fail request_output line swdio");
@@ -159,6 +169,11 @@ static void linuxgpiod_swdio_drive(bool is_output)
 		retval = gpiod_line_request_input(gpiod_swdio, "OpenOCD");
 		if (retval < 0)
 			LOG_WARNING("Fail request_input line swdio");
+		if (gpiod_swdio_dir) {
+			retval = gpiod_line_set_value(gpiod_swdio_dir, swdio_dir_is_active_high ? 0 : 1);
+			if (retval < 0)
+				LOG_WARNING("Fail set swdio_dir");
+		}
 	}
 
 	last_stored = false;
@@ -297,6 +312,8 @@ static int linuxgpiod_quit(void)
 		gpiod_chip_close(gpiod_chip_srst);
 	if (gpiod_chip_swdio != NULL)
 		gpiod_chip_close(gpiod_chip_swdio);
+	if (gpiod_chip_swdio_dir != NULL)
+		gpiod_chip_close(gpiod_chip_swdio_dir);
 	if (gpiod_chip_swclk != NULL)
 		gpiod_chip_close(gpiod_chip_swclk);
 	if (gpiod_chip_trst != NULL)
@@ -451,10 +468,26 @@ static int linuxgpiod_init(void)
 			goto out_error;
 		}
 
+		if (is_gpio_valid(swdio_dir_gpio)) {
+			gpiod_chip_swdio_dir = gpiod_chip_open_by_number(swdio_dir_gpiochip);
+			if (!gpiod_chip_swdio_dir) {
+				LOG_ERROR("Cannot open LinuxGPIOD swdio_dir_gpiochip %d", swdio_dir_gpiochip);
+				goto out_error;
+			}
+		}
+
 		gpiod_swclk = helper_get_output_line("swclk", gpiod_chip_swclk, swclk_gpio, 1);
 		if (!gpiod_swclk)
 			goto out_error;
 
+		/* Set buffer direction before making SWDIO an output */
+		if (is_gpio_valid(swdio_dir_gpio)) {
+			gpiod_swdio_dir = helper_get_output_line("swdio_dir", gpiod_chip_swdio_dir, swdio_dir_gpio,
+					swdio_dir_is_active_high ? 1 : 0);
+			if (!gpiod_swdio_dir)
+				goto out_error;
+		}
+
 		gpiod_swdio = helper_get_output_line("swdio", gpiod_chip_swdio, swdio_gpio, 1);
 		if (!gpiod_swdio)
 			goto out_error;
@@ -593,6 +626,12 @@ COMMAND_HANDLER(linuxgpiod_handle_swd_gpionum_swdio)
 			&swdio_gpio);
 }
 
+COMMAND_HANDLER(linuxgpiod_handle_swd_gpionum_swdio_dir)
+{
+	return CALL_COMMAND_HANDLER(linuxgpiod_helper_gpionum, "swdio_dir", &swdio_dir_gpiochip,
+			&swdio_dir_gpio);
+}
+
 COMMAND_HANDLER(linuxgpiod_handle_gpionum_led)
 {
 	return CALL_COMMAND_HANDLER(linuxgpiod_helper_gpionum, "led", &led_gpiochip,
@@ -611,6 +650,7 @@ COMMAND_HANDLER(linuxgpiod_handle_gpiochip)
 		srst_gpiochip = gpiochip;
 		swclk_gpiochip = gpiochip;
 		swdio_gpiochip = gpiochip;
+		swdio_dir_gpiochip = gpiochip;
 		led_gpiochip = gpiochip;
 	}
 
@@ -689,6 +729,13 @@ static const struct command_registration linuxgpiod_subcommand_handlers[] = {
 		.help = "gpio chip number (optional) and gpio number for swdio.",
 		.usage = "[chip] swdio",
 	},
+	{
+		.name = "swdio_dir_num",
+		.handler = linuxgpiod_handle_swd_gpionum_swdio_dir,
+		.mode = COMMAND_CONFIG,
+		.help = "gpio chip number (optional) and gpio number for swdio_dir.",
+		.usage = "[chip] swdio_dir",
+	},
 	{
 		.name = "led_num",
 		.handler = linuxgpiod_handle_gpionum_led,
diff --git a/src/jtag/drivers/nulink_usb.c b/src/jtag/drivers/nulink_usb.c
index d4b8b53bc..84a4420e8 100644
--- a/src/jtag/drivers/nulink_usb.c
+++ b/src/jtag/drivers/nulink_usb.c
@@ -33,7 +33,9 @@
 
 #include <hidapi.h>
 
-#define NULINK_READ_TIMEOUT  1000
+#include "libusb_helper.h"
+
+#define NULINK_READ_TIMEOUT  LIBUSB_TIMEOUT_MS
 
 #define NULINK_HID_MAX_SIZE   (64)
 #define NULINK2_HID_MAX_SIZE   (1024)
diff --git a/src/jtag/drivers/rlink.c b/src/jtag/drivers/rlink.c
index 73be3c57e..0cf9dbbb2 100644
--- a/src/jtag/drivers/rlink.c
+++ b/src/jtag/drivers/rlink.c
@@ -59,8 +59,6 @@
 #define USB_EP2IN_SIZE          (USB_EP2OUT_SIZE)
 #define USB_EP2BANK_SIZE        (512)
 
-#define USB_TIMEOUT_MS          (3 * 1000)
-
 #define DTC_STATUS_POLL_BYTE    (ST7_USB_BUF_EP0OUT + 0xff)
 
 #define ST7_PD_NBUSY_LED                ST7_PD0
@@ -133,7 +131,7 @@ static int ep1_generic_commandl(struct libusb_device_handle *hdev_param, size_t
 			hdev_param,
 			USB_EP1OUT_ADDR,
 			(char *)usb_buffer, sizeof(usb_buffer),
-			USB_TIMEOUT_MS,
+			LIBUSB_TIMEOUT_MS,
 			&transferred
 			);
 
@@ -176,7 +174,7 @@ static ssize_t ep1_memory_read(
 		usb_ret = jtag_libusb_bulk_write(
 				hdev_param, USB_EP1OUT_ADDR,
 				(char *)usb_buffer, sizeof(usb_buffer),
-				USB_TIMEOUT_MS,
+				LIBUSB_TIMEOUT_MS,
 				&transferred
 				);
 
@@ -186,7 +184,7 @@ static ssize_t ep1_memory_read(
 		usb_ret = jtag_libusb_bulk_read(
 				hdev_param, USB_EP1IN_ADDR,
 				(char *)buffer, length,
-				USB_TIMEOUT_MS,
+				LIBUSB_TIMEOUT_MS,
 				&transferred
 				);
 
@@ -241,7 +239,7 @@ static ssize_t ep1_memory_write(struct libusb_device_handle *hdev_param, uint16_
 		usb_ret = jtag_libusb_bulk_write(
 				hdev_param, USB_EP1OUT_ADDR,
 				(char *)usb_buffer, sizeof(usb_buffer),
-				USB_TIMEOUT_MS,
+				LIBUSB_TIMEOUT_MS,
 				&transferred
 				);
 
@@ -432,7 +430,7 @@ static int dtc_start_download(void)
 	usb_err = jtag_libusb_bulk_read(
 			hdev, USB_EP1IN_ADDR,
 			(char *)&ep2txr, 1,
-			USB_TIMEOUT_MS,
+			LIBUSB_TIMEOUT_MS,
 			&transferred
 			);
 	if (usb_err != ERROR_OK)
@@ -462,7 +460,7 @@ static int dtc_start_download(void)
 	usb_err = jtag_libusb_bulk_read(
 			hdev, USB_EP1IN_ADDR,
 			(char *)&ep2txr, 1,
-			USB_TIMEOUT_MS,
+			LIBUSB_TIMEOUT_MS,
 			&transferred
 			);
 
@@ -488,7 +486,7 @@ static int dtc_run_download(
 			hdev_param,
 			USB_EP2OUT_ADDR,
 			(char *)command_buffer, USB_EP2BANK_SIZE,
-			USB_TIMEOUT_MS,
+			LIBUSB_TIMEOUT_MS,
 			&transferred
 			);
 	if (usb_err < 0)
@@ -512,7 +510,7 @@ static int dtc_run_download(
 				hdev_param,
 				USB_EP1IN_ADDR,
 				&dtc_status, 1,
-				USB_TIMEOUT_MS,
+				LIBUSB_TIMEOUT_MS,
 				&transferred
 				);
 		if (usb_err < 0)
@@ -533,7 +531,7 @@ static int dtc_run_download(
 				hdev_param,
 				USB_EP2IN_ADDR,
 				(char *)reply_buffer, reply_buffer_size,
-				USB_TIMEOUT_MS,
+				LIBUSB_TIMEOUT_MS,
 				&transferred
 				);
 
@@ -954,7 +952,7 @@ static void rlink_reset(int trst, int srst)
 	usb_err = jtag_libusb_bulk_read(
 			hdev, USB_EP1IN_ADDR,
 			(char *)&bitmap, 1,
-			USB_TIMEOUT_MS,
+			LIBUSB_TIMEOUT_MS,
 			&transferred
 			);
 	if (usb_err != ERROR_OK || transferred < 1) {
@@ -990,7 +988,7 @@ static void rlink_reset(int trst, int srst)
 	usb_err = jtag_libusb_bulk_read(
 			hdev, USB_EP1IN_ADDR,
 			(char *)&bitmap, 1,
-			USB_TIMEOUT_MS,
+			LIBUSB_TIMEOUT_MS,
 			&transferred
 			);
 	if (usb_err != ERROR_OK || transferred < 1) {
@@ -1021,7 +1019,7 @@ static void rlink_reset(int trst, int srst)
 	usb_err = jtag_libusb_bulk_read(
 			hdev, USB_EP1IN_ADDR,
 			(char *)&bitmap, 1,
-			USB_TIMEOUT_MS,
+			LIBUSB_TIMEOUT_MS,
 			&transferred
 			);
 	if (usb_err != ERROR_OK || transferred < 1) {
@@ -1576,7 +1574,7 @@ static int rlink_init(void)
 	jtag_libusb_bulk_read(
 		hdev, USB_EP1IN_ADDR,
 		(char *)reply_buffer, 1,
-		USB_TIMEOUT_MS,
+		LIBUSB_TIMEOUT_MS,
 		&transferred
 		);
 
@@ -1601,7 +1599,7 @@ static int rlink_init(void)
 	jtag_libusb_bulk_read(
 		hdev, USB_EP1IN_ADDR,
 		(char *)reply_buffer, 1,
-		USB_TIMEOUT_MS,
+		LIBUSB_TIMEOUT_MS,
 		&transferred
 		);
 
diff --git a/src/jtag/drivers/stlink_usb.c b/src/jtag/drivers/stlink_usb.c
index 2f61bf946..2785d9b96 100644
--- a/src/jtag/drivers/stlink_usb.c
+++ b/src/jtag/drivers/stlink_usb.c
@@ -71,8 +71,8 @@
 #define ENDPOINT_IN  0x80
 #define ENDPOINT_OUT 0x00
 
-#define STLINK_WRITE_TIMEOUT 1000
-#define STLINK_READ_TIMEOUT 1000
+#define STLINK_WRITE_TIMEOUT  (LIBUSB_TIMEOUT_MS)
+#define STLINK_READ_TIMEOUT   (LIBUSB_TIMEOUT_MS)
 
 #define STLINK_RX_EP          (1|ENDPOINT_IN)
 #define STLINK_TX_EP          (2|ENDPOINT_OUT)
@@ -156,6 +156,13 @@ struct stlink_usb_priv_s {
 	struct libusb_transfer *trans;
 };
 
+struct stlink_tcp_version {
+	uint32_t api;
+	uint32_t major;
+	uint32_t minor;
+	uint32_t build;
+};
+
 struct stlink_tcp_priv_s {
 	/** */
 	int fd;
@@ -169,6 +176,8 @@ struct stlink_tcp_priv_s {
 	uint8_t *send_buf;
 	/** */
 	uint8_t *recv_buf;
+	/** */
+	struct stlink_tcp_version version;
 };
 
 struct stlink_backend_s {
@@ -3532,16 +3541,19 @@ static int stlink_tcp_open(void *handle, struct hl_interface_param_s *param)
 		return ERROR_FAIL;
 	}
 
-	uint32_t api_ver = le_to_h_u32(&h->tcp_backend_priv.recv_buf[0]);
-	uint32_t ver_major = le_to_h_u32(&h->tcp_backend_priv.recv_buf[4]);
-	uint32_t ver_minor = le_to_h_u32(&h->tcp_backend_priv.recv_buf[8]);
-	uint32_t ver_build = le_to_h_u32(&h->tcp_backend_priv.recv_buf[12]);
+	h->tcp_backend_priv.version.api = le_to_h_u32(&h->tcp_backend_priv.recv_buf[0]);
+	h->tcp_backend_priv.version.major = le_to_h_u32(&h->tcp_backend_priv.recv_buf[4]);
+	h->tcp_backend_priv.version.minor = le_to_h_u32(&h->tcp_backend_priv.recv_buf[8]);
+	h->tcp_backend_priv.version.build = le_to_h_u32(&h->tcp_backend_priv.recv_buf[12]);
 	LOG_INFO("stlink-server API v%d, version %d.%d.%d",
-			api_ver, ver_major, ver_minor, ver_build);
+			h->tcp_backend_priv.version.api,
+			h->tcp_backend_priv.version.major,
+			h->tcp_backend_priv.version.minor,
+			h->tcp_backend_priv.version.build);
 
 	/* in stlink-server API v1 sending more than 1428 bytes will cause stlink-server
 	 * to crash in windows: select a safe default value (1K) */
-	if (api_ver < 2)
+	if (h->tcp_backend_priv.version.api < 2)
 		h->max_mem_packet = (1 << 10);
 
 	/* refresh stlink list (re-enumerate) */
@@ -4468,11 +4480,12 @@ static int stlink_usb_count_misc_rw_queue(void *handle, const struct dap_queue *
 	if (!(h->version.flags & STLINK_F_HAS_RW_MISC))
 		return 0;
 	/*
-	 * RW_MISC sequence doesn't lock the st-link, so are not safe in shared mode.
+	 * Before stlink-server API v3, RW_MISC sequence doesn't lock the st-link,
+	 * so are not safe in shared mode.
 	 * Don't use it with TCP backend to prevent any issue in case of sharing.
 	 * This further degrades the performance, on top of TCP server overhead.
 	 */
-	if (h->backend == &stlink_tcp_backend)
+	if (h->backend == &stlink_tcp_backend && h->tcp_backend_priv.version.api < 3)
 		return 0;
 
 	for (i = 0; i < len; i++) {
diff --git a/src/jtag/drivers/ti_icdi_usb.c b/src/jtag/drivers/ti_icdi_usb.c
index c94a1102f..e48d0e269 100644
--- a/src/jtag/drivers/ti_icdi_usb.c
+++ b/src/jtag/drivers/ti_icdi_usb.c
@@ -37,8 +37,8 @@
 #define ICDI_WRITE_ENDPOINT 0x02
 #define ICDI_READ_ENDPOINT 0x83
 
-#define ICDI_WRITE_TIMEOUT 1000
-#define ICDI_READ_TIMEOUT 1000
+#define ICDI_WRITE_TIMEOUT (LIBUSB_TIMEOUT_MS)
+#define ICDI_READ_TIMEOUT (LIBUSB_TIMEOUT_MS)
 #define ICDI_PACKET_SIZE 2048
 
 #define PACKET_START "$"
diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
index 3ae5cac62..50609a64b 100644
--- a/src/jtag/drivers/ulink.c
+++ b/src/jtag/drivers/ulink.c
@@ -56,9 +56,6 @@
 /** USB interface number */
 #define USB_INTERFACE            0
 
-/** libusb timeout in ms */
-#define USB_TIMEOUT              5000
-
 /** Delay (in microseconds) to wait while EZ-USB performs ReNumeration. */
 #define ULINK_RENUMERATION_DELAY 1500000
 
@@ -335,7 +332,7 @@ static int ulink_cpu_reset(struct ulink *device, unsigned char reset_bit)
 
 	ret = libusb_control_transfer(device->usb_device_handle,
 			(LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE),
-			REQUEST_FIRMWARE_LOAD, CPUCS_REG, 0, &reset_bit, 1, USB_TIMEOUT);
+			REQUEST_FIRMWARE_LOAD, CPUCS_REG, 0, &reset_bit, 1, LIBUSB_TIMEOUT_MS);
 
 	/* usb_control_msg() returns the number of bytes transferred during the
 	 * DATA stage of the control transfer - must be exactly 1 in this case! */
@@ -478,7 +475,7 @@ static int ulink_write_firmware_section(struct ulink *device,
 		ret = libusb_control_transfer(device->usb_device_handle,
 				(LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE),
 				REQUEST_FIRMWARE_LOAD, addr, FIRMWARE_ADDR, (unsigned char *)data_ptr,
-				chunk_size, USB_TIMEOUT);
+				chunk_size, LIBUSB_TIMEOUT_MS);
 
 		if (ret != (int)chunk_size) {
 			/* Abort if libusb sent less data than requested */
@@ -604,8 +601,6 @@ static int ulink_get_queue_size(struct ulink *device,
  * Clear the OpenULINK command queue.
  *
  * @param device pointer to struct ulink identifying ULINK driver instance.
- * @return on success: ERROR_OK
- * @return on failure: ERROR_FAIL
  */
 static void ulink_clear_queue(struct ulink *device)
 {
@@ -664,7 +659,7 @@ static int ulink_append_queue(struct ulink *device, struct ulink_cmd *ulink_cmd)
 	if ((newsize_out > 64) || (newsize_in > 64)) {
 		/* New command does not fit. Execute all commands in queue before starting
 		 * new queue with the current command as first entry. */
-		ret = ulink_execute_queued_commands(device, USB_TIMEOUT);
+		ret = ulink_execute_queued_commands(device, LIBUSB_TIMEOUT_MS);
 
 		if (ret == ERROR_OK)
 			ret = ulink_post_process_queue(device);
@@ -1962,7 +1957,7 @@ static int ulink_execute_queue(void)
 	}
 
 	if (ulink_handle->commands_in_queue > 0) {
-		ret = ulink_execute_queued_commands(ulink_handle, USB_TIMEOUT);
+		ret = ulink_execute_queued_commands(ulink_handle, LIBUSB_TIMEOUT_MS);
 		if (ret != ERROR_OK)
 			return ret;
 
diff --git a/src/jtag/drivers/vdebug.c b/src/jtag/drivers/vdebug.c
new file mode 100644
index 000000000..a81740cb1
--- /dev/null
+++ b/src/jtag/drivers/vdebug.c
@@ -0,0 +1,1076 @@
+/* SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause) */
+/*----------------------------------------------------------------------------
+ * Copyright 2020-2021 Cadence Design Systems, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *----------------------------------------------------------------------------
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *----------------------------------------------------------------------------
+*/
+
+/*!
+ * @file
+ *
+ * @brief the virtual debug interface provides a connection between a sw debugger
+ * and the simulated, emulated core over a soft connection, implemented by DPI
+ * The vdebug debug driver currently supports JTAG transport
+ * TODO: implement support and test big endian platforms
+ *
+*/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef _WIN32
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#else
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>          /* close */
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#ifdef HAVE_ARPA_INET_H
+#include <arpa/inet.h>
+#endif
+#ifdef HAVE_NETDB_H
+#include <netdb.h>
+#endif
+#endif
+#include <stdio.h>
+#ifdef HAVE_STDINT_H
+#include <stdint.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#include <stdarg.h>
+#include <string.h>
+#include <errno.h>
+
+#include "jtag/interface.h"
+#include "jtag/commands.h"
+#include "transport/transport.h"
+#include "helper/time_support.h"
+#include "helper/replacements.h"
+#include "helper/log.h"
+
+#define VD_VERSION 43
+#define VD_BUFFER_LEN 4024
+#define VD_CHEADER_LEN 24
+#define VD_SHEADER_LEN 16
+
+#define VD_MAX_MEMORIES 4
+#define VD_POLL_INTERVAL 500
+#define VD_SCALE_PSTOMS 1000000000
+
+/**
+ * @brief List of transactor types
+ */
+enum {
+	VD_BFM_JTDP   = 0x0001,  /* transactor DAP JTAG DP */
+	VD_BFM_SWDP   = 0x0002,  /* transactor DAP SWD DP */
+	VD_BFM_AHB    = 0x0003,  /* transactor AMBA AHB */
+	VD_BFM_APB    = 0x0004,  /* transactor AMBA APB */
+	VD_BFM_AXI    = 0x0005,  /* transactor AMBA AXI */
+	VD_BFM_JTAG   = 0x0006,  /* transactor serial JTAG */
+	VD_BFM_SWD    = 0x0007,  /* transactor serial SWD */
+};
+
+/**
+ * @brief List of signals that can be read or written by the debugger
+ */
+enum {
+	VD_SIG_TCK    = 0x0001,  /* JTAG clock; tclk */
+	VD_SIG_TDI    = 0x0002,  /* JTAG TDI;   tdi */
+	VD_SIG_TMS    = 0x0004,  /* JTAG TMS;   tms */
+	VD_SIG_RESET  = 0x0008,  /* DUT reset;  rst */
+	VD_SIG_TRST   = 0x0010,  /* JTAG Reset; trstn */
+	VD_SIG_TDO    = 0x0020,  /* JTAG TDO;   tdo */
+	VD_SIG_POWER  = 0x0100,  /* BFM power;  bfm_up */
+	VD_SIG_TCKDIV = 0x0200,  /* JTAG clock divider; tclkdiv */
+	VD_SIG_BUF    = 0x1000,  /* memory buffer; mem */
+};
+
+/**
+ * @brief List of errors
+ */
+enum {
+	VD_ERR_NONE       = 0x0000,  /* no error */
+	VD_ERR_NOT_IMPL   = 0x0100,  /* feature not implemented */
+	VD_ERR_USAGE      = 0x0101,  /* incorrect usage */
+	VD_ERR_PARAM      = 0x0102,  /* incorrect parameter */
+	VD_ERR_CONFIG     = 0x0107,  /* incorrect configuration */
+	VD_ERR_NO_MEMORY  = 0x0104,  /* out of memory */
+	VD_ERR_SHM_OPEN   = 0x010a,  /* cannot open shared memory */
+	VD_ERR_SHM_MAP    = 0x010b,  /* cannot map shared memory */
+	VD_ERR_SOC_OPEN   = 0x011a,  /* cannot open socket */
+	VD_ERR_SOC_OPT    = 0x011b,  /* cannot set socket option */
+	VD_ERR_SOC_ADDR   = 0x011c,  /* cannot resolve host address */
+	VD_ERR_SOC_CONN   = 0x011d,  /* cannot connect to host */
+	VD_ERR_SOC_SEND   = 0x011e,  /* error sending data on socket */
+	VD_ERR_SOC_RECV   = 0x011f,  /* error receiving data from socket */
+	VD_ERR_LOCKED     = 0x0202,  /* device locked */
+	VD_ERR_NOT_RUN    = 0x0204,  /* transactor not running */
+	VD_ERR_NOT_OPEN   = 0x0205,  /* transactor not open/connected */
+	VD_ERR_LICENSE    = 0x0206,  /* cannot check out the license */
+	VD_ERR_VERSION    = 0x0207,  /* transactor version mismatch */
+	VD_ERR_TIME_OUT   = 0x0301,  /* time out, waiting */
+	VD_ERR_NO_POWER   = 0x0302,  /* power out error */
+	VD_ERR_BUS_ERROR  = 0x0304,  /* bus protocol error, like pslverr */
+	VD_ERR_NO_ACCESS  = 0x0306,  /* no access to an object */
+	VD_ERR_INV_HANDLE = 0x0307,  /* invalid object handle */
+	VD_ERR_INV_SCOPE  = 0x0308,  /* invalid scope */
+};
+
+enum {
+	VD_CMD_OPEN       = 0x01,
+	VD_CMD_CLOSE      = 0x02,
+	VD_CMD_CONNECT    = 0x04,
+	VD_CMD_DISCONNECT = 0x05,
+	VD_CMD_WAIT       = 0x09,
+	VD_CMD_SIGSET     = 0x0a,
+	VD_CMD_SIGGET     = 0x0b,
+	VD_CMD_JTAGCLOCK  = 0x0f,
+	VD_CMD_JTAGSHTAP  = 0x1a,
+	VD_CMD_MEMOPEN    = 0x21,
+	VD_CMD_MEMCLOSE   = 0x22,
+	VD_CMD_MEMWRITE   = 0x23,
+};
+
+enum {
+	VD_BATCH_NO       = 0,
+	VD_BATCH_WO       = 1,
+	VD_BATCH_WR       = 2,
+};
+
+struct vd_shm {
+	struct {                     /* VD_CHEADER_LEN written by client */
+		uint8_t cmd;             /* 000; command */
+		uint8_t type;            /* 001; interface type */
+		uint16_t waddr;          /* 002; write pointer */
+		uint16_t wbytes;         /* 004; data bytes */
+		uint16_t rbytes;         /* 006; data bytes to read */
+		uint16_t wwords;         /* 008; data words */
+		uint16_t rwords;         /* 00a; data words to read */
+		uint32_t rwdata;         /* 00c; read/write data */
+		uint32_t offset;         /* 010; address offset */
+		uint16_t offseth;        /* 014; address offset 47:32 */
+		uint16_t wid;            /* 016; request id*/
+	};
+	union {                      /* 018; */
+		uint8_t wd8[VD_BUFFER_LEN];
+		uint16_t wd16[VD_BUFFER_LEN / 2];
+		uint32_t wd32[VD_BUFFER_LEN / 4];
+		uint64_t wd64[VD_BUFFER_LEN / 8];
+	};
+	struct {                     /* VD_SHEADER_LEN written by server */
+		uint16_t rid;            /* fd0: request id read */
+		uint16_t awords;         /* fd2: actual data words read back */
+		int32_t  status;         /* fd4; */
+		uint64_t duttime;        /* fd8; */
+	};
+	union {                      /* fe0: */
+		uint8_t rd8[VD_BUFFER_LEN];
+		uint16_t rd16[VD_BUFFER_LEN / 2];
+		uint32_t rd32[VD_BUFFER_LEN / 4];
+		uint64_t rd64[VD_BUFFER_LEN / 8];
+	};
+	uint32_t state;              /* 1f98; connection state */
+	uint32_t count;              /* 1f9c; */
+	uint8_t dummy[96];           /* 1fa0; 48+40B+8B; */
+};
+
+struct vd_client {
+	uint8_t trans_batch;
+	bool trans_first;
+	bool trans_last;
+	uint8_t mem_ndx;
+	uint8_t buf_width;
+	uint8_t addr_bits;
+	uint8_t bfm_type;
+	uint16_t sig_read;
+	uint16_t sig_write;
+	uint32_t bfm_period;
+	uint32_t mem_base[VD_MAX_MEMORIES];
+	uint32_t mem_size[VD_MAX_MEMORIES];
+	uint32_t mem_width[VD_MAX_MEMORIES];
+	uint32_t mem_depth[VD_MAX_MEMORIES];
+	uint16_t server_port;
+	uint32_t poll_cycles;
+	uint32_t poll_min;
+	uint32_t poll_max;
+	uint32_t targ_time;
+	int hsocket;
+	char server_name[32];
+	char bfm_path[128];
+	char mem_path[VD_MAX_MEMORIES][128];
+	uint8_t *tdo;
+};
+
+struct vd_jtag_hdr {
+	uint64_t tlen:24;
+	uint64_t post:3;
+	uint64_t pre:3;
+	uint64_t cmd:2;
+	uint64_t wlen:16;
+	uint64_t rlen:16;
+};
+
+static struct vd_shm *pbuf;
+static struct vd_client vdc;
+
+static int vdebug_socket_error(void)
+{
+#ifdef _WIN32
+	return WSAGetLastError();
+#else
+	return errno;
+#endif
+}
+
+static int vdebug_socket_open(char *server_addr, uint32_t port)
+{
+	int hsock;
+	int rc = 0;
+	uint32_t buflen = sizeof(struct vd_shm); /* size of the send and rcv buffer */
+	struct addrinfo *ainfo = NULL;
+	struct addrinfo ahint = { 0, AF_INET, SOCK_STREAM, 0, 0, NULL, NULL, NULL };
+
+#ifdef _WIN32
+	hsock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
+	if (hsock == INVALID_SOCKET)
+		rc = vdebug_socket_error();
+#else
+	uint32_t rcvwat = VD_SHEADER_LEN;    /* size of the rcv header, as rcv min watermark */
+	hsock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
+	if (hsock < 0)
+		rc = errno;
+	else if (setsockopt(hsock, SOL_SOCKET, SO_RCVLOWAT, &rcvwat, sizeof(rcvwat)) < 0)
+		rc = errno;
+#endif
+	else if (setsockopt(hsock, SOL_SOCKET, SO_SNDBUF, (const char *)&buflen, sizeof(buflen)) < 0)
+		rc = vdebug_socket_error();
+	else if (setsockopt(hsock, SOL_SOCKET, SO_RCVBUF, (const char *)&buflen, sizeof(buflen)) < 0)
+		rc = vdebug_socket_error();
+
+	if (rc) {
+		LOG_ERROR("socket_open: cannot set socket option, error %d", rc);
+	} else if (getaddrinfo(server_addr, NULL, &ahint, &ainfo) != 0) {
+		LOG_ERROR("socket_open: cannot resolve address %s, error %d", server_addr, vdebug_socket_error());
+		rc = VD_ERR_SOC_ADDR;
+	} else {
+		((struct sockaddr_in *)(ainfo->ai_addr))->sin_port = htons(port);
+		if (connect(hsock, ainfo->ai_addr, sizeof(struct sockaddr)) < 0) {
+			LOG_ERROR("socket_open: cannot connect to %s:%d, error %d", server_addr, port, vdebug_socket_error());
+			rc = VD_ERR_SOC_CONN;
+		}
+	}
+
+	if (rc) {
+		close_socket(hsock);
+		hsock = 0;
+	}
+
+	if (ainfo)
+		freeaddrinfo(ainfo);
+
+	return hsock;
+}
+
+static int vdebug_socket_receive(int hsock, struct vd_shm *pmem)
+{
+	int rc;
+	int dreceived = 0;
+	int offset = (uint8_t *)&pmem->rid - &pmem->cmd;
+	int to_receive = VD_SHEADER_LEN + pmem->rbytes;
+	char *pb = (char *)pmem;
+
+	do {
+		rc = recv(hsock, pb + offset, to_receive, 0);
+		if (rc <= 0) {
+			LOG_WARNING("socket_receive: recv failed, error %d", rc < 0 ? vdebug_socket_error() : 0);
+			return rc;
+		}
+		to_receive -= rc;
+		offset += rc;
+		LOG_DEBUG_IO("socket_receive: received %d, to receive %d", rc, to_receive);
+		dreceived += rc;
+	} while (to_receive);
+
+	return dreceived;
+}
+
+static int vdebug_socket_send(int hsock, struct vd_shm *pmem)
+{
+	int rc = send(hsock, (const char *)&pmem->cmd, VD_CHEADER_LEN + pmem->wbytes, 0);
+	if (rc <= 0)
+		LOG_WARNING("socket_send: send failed, error %d", vdebug_socket_error());
+	else
+		LOG_DEBUG_IO("socket_send: sent %d, to send 0", rc);
+
+	return rc;
+}
+
+static uint32_t vdebug_wait_server(int hsock, struct vd_shm *pmem)
+{
+	if (!hsock)
+		return VD_ERR_SOC_OPEN;
+	int st = vdebug_socket_send(hsock, pmem);
+	if (st <= 0)
+		return VD_ERR_SOC_SEND;
+
+	int rd = vdebug_socket_receive(hsock, pmem);
+	if (rd  <= 0)
+		return VD_ERR_SOC_RECV;
+
+	int rc = pmem->status;
+	LOG_DEBUG_IO("wait_server: cmd %02" PRIx8 " done, sent %d, rcvd %d, status %d",
+					pmem->cmd, st, rd, rc);
+
+	return rc;
+}
+
+int vdebug_run_jtag_queue(int hsock, struct vd_shm *pm, unsigned int count)
+{
+	uint8_t  num_pre, num_post, tdi, tms;
+	unsigned int num, anum, bytes, hwords, words;
+	unsigned int req, waddr, rwords;
+	int64_t ts, te;
+	uint8_t *tdo;
+	int rc;
+	struct vd_jtag_hdr *hdr;
+
+	req = 0;                            /* beginning of request */
+	waddr = 0;
+	rwords = 0;
+	pm->wbytes = pm->wwords * vdc.buf_width;
+	pm->rbytes = pm->rwords * vdc.buf_width;
+	ts = timeval_ms();
+	rc = vdebug_wait_server(hsock, pm);
+	while (!rc && (req < count)) {      /* loop over requests to read data and print out */
+		hdr = (struct vd_jtag_hdr *)&pm->wd8[waddr * 4];
+		hwords = hdr->wlen;
+		words = hdr->rlen;
+		anum = hdr->tlen;
+		num_pre = hdr->pre;
+		num_post = hdr->post;
+		if (num_post)
+			num = anum - num_pre - num_post + 1;
+		else
+			num = anum - num_pre;
+		bytes = (num + 7) / 8;
+		vdc.trans_last = (req + 1) < count ? 0 : 1;
+		vdc.trans_first = waddr ? 0 : 1;
+		if (hdr->cmd == 3) { /* read */
+			tdo = vdc.tdo;
+			for (unsigned int j = 0; j < bytes; j++) {
+				tdo[j] = (pm->rd8[rwords * 8 + j] >> num_pre) | (pm->rd8[rwords * 8 + j + 1] << (8 - num_pre));
+				LOG_DEBUG_IO("%04x D0[%02x]:%02x", pm->wid - count + req, j, tdo[j]);
+			}
+			rwords += words;           /* read data offset */
+		} else {
+			tdo = NULL;
+		}
+		waddr += sizeof(struct vd_jtag_hdr) / 4; /* waddr past header */
+		tdi = (pm->wd8[waddr * 4] >> num_pre) | (pm->wd8[waddr * 4 + 1] << (8 - num_pre));
+		tms = (pm->wd8[waddr * 4 + 4] >> num_pre) | (pm->wd8[waddr * 4 + 4 + 1] << (8 - num_pre));
+		LOG_DEBUG("%04x L:%02d O:%05x @%03x DI:%02x MS:%02x DO:%02x",
+			pm->wid - count + req, num, (vdc.trans_first << 14) | (vdc.trans_last << 15),
+			waddr - 2, tdi, tms, (tdo ? tdo[0] : 0xdd));
+		waddr += hwords * 2;           /* start of next request */
+		req += 1;
+	}
+
+	if (rc) {
+		LOG_ERROR("0x%x executing transaction", rc);
+		rc = ERROR_FAIL;
+	}
+
+	te = timeval_ms();
+	vdc.targ_time += (uint32_t)(te - ts);
+	pm->offseth = 0;     /* reset buffer write address */
+	pm->offset = 0;
+	pm->rwords = 0;
+	pm->waddr = 0;
+
+	return rc;
+}
+
+static int vdebug_open(int hsock, struct vd_shm *pm, const char *path,
+						uint8_t type, uint32_t period_ps, uint32_t sig_mask)
+{
+	int rc = VD_ERR_NOT_OPEN;
+
+	pm->cmd = VD_CMD_OPEN;
+	pm->wid = VD_VERSION;              /* client version */
+	pm->wbytes = 0;
+	pm->rbytes = 0;
+	pm->wwords = 0;
+	pm->rwords = 0;
+	rc = vdebug_wait_server(hsock, pm);
+	if (rc != 0) {                     /* communication problem */
+		LOG_ERROR("0x%x connecting to server", rc);
+	} else if (pm->rid < pm->wid) {
+		LOG_ERROR("server version %d too old for the client %d", pm->rid, pm->wid);
+		pm->cmd = VD_CMD_CLOSE;        /* let server close the connection */
+		vdebug_wait_server(hsock, pm);
+		rc = VD_ERR_VERSION;
+	} else {
+		pm->cmd = VD_CMD_CONNECT;
+		pm->type = type;               /* BFM type to connect to, here JTAG */
+		pm->rwdata = sig_mask | VD_SIG_BUF | (VD_SIG_BUF << 16);
+		pm->wbytes = strlen(path) + 1;
+		pm->rbytes = 12;
+		pm->wid = 0;              /* reset wid for transaction ID */
+		pm->wwords = 0;
+		pm->rwords = 0;
+		memcpy(pm->wd8, path, pm->wbytes + 1);
+		rc = vdebug_wait_server(hsock, pm);
+		vdc.sig_read = pm->rwdata >> 16;  /* signal read mask */
+		vdc.sig_write = pm->rwdata;     /* signal write mask */
+		vdc.bfm_period = period_ps;
+		vdc.buf_width = pm->rd32[0] / 8;/* access width in bytes */
+		vdc.addr_bits = pm->rd32[2];    /* supported address bits */
+	}
+
+	if (rc) {
+		LOG_ERROR("0x%x connecting to BFM %s", rc, path);
+		return ERROR_FAIL;
+	}
+
+	LOG_DEBUG("%s type %0x, period %dps, buffer %dx%dB signals r%04xw%04x",
+		path, type, vdc.bfm_period, VD_BUFFER_LEN / vdc.buf_width,
+		vdc.buf_width, vdc.sig_read, vdc.sig_write);
+
+	return ERROR_OK;
+}
+
+static int vdebug_close(int hsock, struct vd_shm *pm, uint8_t type)
+{
+	pm->cmd = VD_CMD_DISCONNECT;
+	pm->type = type;              /* BFM type, here JTAG */
+	pm->wbytes = 0;
+	pm->rbytes = 0;
+	pm->wwords = 0;
+	pm->rwords = 0;
+	vdebug_wait_server(hsock, pm);
+	pm->cmd = VD_CMD_CLOSE;
+	pm->wid = VD_VERSION;    /* client version */
+	pm->wbytes = 0;
+	pm->rbytes = 0;
+	pm->wwords = 0;
+	pm->rwords = 0;
+	vdebug_wait_server(hsock, pm);
+	LOG_DEBUG("type %0x", type);
+
+	return ERROR_OK;
+}
+
+static int vdebug_wait(int hsock, struct vd_shm *pm, uint32_t cycles)
+{
+	if (cycles) {
+		pm->cmd = VD_CMD_WAIT;
+		pm->wbytes = 0;
+		pm->rbytes = 0;
+		pm->rwdata = cycles;  /* clock sycles to wait */
+		int rc = vdebug_wait_server(hsock, pm);
+		if (rc) {
+			LOG_ERROR("0x%x waiting %" PRIx32 " cycles", rc, cycles);
+			return ERROR_FAIL;
+		}
+		LOG_DEBUG("%d cycles", cycles);
+	}
+
+	return ERROR_OK;
+}
+
+static int vdebug_sig_set(int hsock, struct vd_shm *pm, uint32_t write_mask, uint32_t value)
+{
+	pm->cmd = VD_CMD_SIGSET;
+	pm->wbytes = 0;
+	pm->rbytes = 0;
+	pm->rwdata = (write_mask << 16) | (value & 0xffff); /* mask and value of signals to set */
+	int rc = vdebug_wait_server(hsock, pm);
+	if (rc) {
+		LOG_ERROR("0x%x setting signals %04" PRIx32, rc, write_mask);
+		return ERROR_FAIL;
+	}
+
+	LOG_DEBUG("setting signals %04" PRIx32 " to %04" PRIx32, write_mask, value);
+
+	return ERROR_OK;
+}
+
+static int vdebug_jtag_clock(int hsock, struct vd_shm *pm, uint32_t value)
+{
+	pm->cmd = VD_CMD_JTAGCLOCK;
+	pm->wbytes = 0;
+	pm->rbytes = 0;
+	pm->rwdata = value;  /* divider value */
+	int rc = vdebug_wait_server(hsock, pm);
+	if (rc) {
+		LOG_ERROR("0x%x setting jtag_clock", rc);
+		return ERROR_FAIL;
+	}
+
+	LOG_DEBUG("setting jtag clock divider to %" PRIx32, value);
+
+	return ERROR_OK;
+}
+
+static int vdebug_jtag_shift_tap(int hsock, struct vd_shm *pm, uint8_t num_pre,
+								 const uint8_t tms_pre, uint32_t num, const uint8_t *tdi,
+								 uint8_t num_post, const uint8_t tms_post, uint8_t *tdo,
+								 uint8_t f_last)
+{
+	const uint32_t tobits = 8;
+	uint16_t bytes, hwords, anum, words, waddr;
+	int rc = 0;
+
+	pm->cmd = VD_CMD_JTAGSHTAP;
+	vdc.trans_last = f_last || (vdc.trans_batch == VD_BATCH_NO) || tdo;
+	if (vdc.trans_first)
+		waddr = 0;             /* reset buffer offset */
+	else
+		waddr = pm->offseth;   /* continue from the previous transaction */
+	if (num_post)          /* actual number of bits to shift */
+		anum = num + num_pre + num_post - 1;
+	else
+		anum = num + num_pre;
+	hwords = (anum + 4 * vdc.buf_width - 1) / (4 * vdc.buf_width); /* in 4B TDI/TMS words */
+	words = (hwords + 1) / 2;    /* in 8B TDO words to read */
+	bytes = (num + 7) / 8;       /* data only portion in bytes */
+	/* buffer overflow check and flush */
+	if (4 * waddr + sizeof(struct vd_jtag_hdr) + 8 * hwords + 64 > VD_BUFFER_LEN) {
+		vdc.trans_last = 1;        /* force flush within 64B of buffer end */
+	} else if (4 * waddr + sizeof(struct vd_jtag_hdr) + 8 * hwords > VD_BUFFER_LEN) {
+		/* this req does not fit, discard it */
+		LOG_ERROR("%04x L:%02d O:%05x @%04x too many bits to shift",
+			pm->wid, anum, (vdc.trans_first << 14) | (vdc.trans_last << 15), waddr);
+		rc = ERROR_FAIL;
+	}
+
+	if (!rc && anum) {
+		uint16_t i, j;
+		struct vd_jtag_hdr *hdr = (struct vd_jtag_hdr *)&pm->wd8[4 * waddr]; /* 8 bytes header */
+		hdr->cmd = (tdo ? 3 : 1); /* R and W bits */
+		hdr->pre = num_pre;
+		hdr->post = num_post;
+		hdr->tlen = anum;
+		hdr->wlen = hwords;
+		hdr->rlen = words;
+		pm->wid++;               /* transaction ID */
+		waddr += 2;              /* waddr past header */
+		/* TDI/TMS data follows as 32 bit word pairs {TMS,TDI} */
+		pm->wd8[4 * waddr] = (tdi ? (tdi[0] << num_pre) : 0);
+		pm->wd8[4 * waddr + 4] = tms_pre;    /* init with tms_pre */
+		if (num + num_pre <= 8)            /* and tms_post for num <=4 */
+			pm->wd8[4 * waddr + 4] |= (tms_post << (num + num_pre - 1));
+		for (i = 1, j = 4 * waddr; i < bytes; i++) {
+			if (i == bytes - 1 && num + num_pre <= bytes * tobits)
+				pm->wd8[j + i + 4] = tms_post << ((num + num_pre - 1) % 8);
+			else
+				pm->wd8[j + i + 4] = 0x0;/* placing 4 bytes of TMS bits into high word */
+			if (!tdi)             /* placing 4 bytes of TDI bits into low word */
+				pm->wd8[j + i] = 0x0;
+			else
+				pm->wd8[j + i] = (tdi[i] << num_pre) | (tdi[i - 1] >> (8 - num_pre));
+			if (i % 4 == 3)
+				j += 4;
+		}
+
+		if (tdi)
+			if (num + num_pre > bytes * tobits) /* in case 1 additional byte needed for TDI */
+				pm->wd8[j + i] = (tdi[i - 1] >> (8 - num_pre)); /* put last TDI bits there */
+
+		if (num + num_pre <= bytes * tobits) { /* in case no or 1 additional byte needed */
+			pm->wd8[j + i + 4] = tms_post >> (8 - (num + num_pre - 1) % 8); /* may need to add higher part */
+		/* in case exactly 1 additional byte needed */
+		} else if (num + num_pre > bytes * tobits && anum <= (bytes + 1) * tobits) {
+			pm->wd8[j + i + 4] = tms_post << ((num + num_pre - 1) % 8); /* add whole tms_post */
+		} else {                           /* in case 2 additional bytes, tms_post split */
+			pm->wd8[j + i + 4] = tms_post << ((num + num_pre - 1) % 8);/* add lower part of tms_post */
+			if (i % 4 == 3)              /* next byte is in the next 32b word */
+				pm->wd8[j + i + 4 + 5] = tms_post >> (8 - (num + num_pre - 1) % 8); /* and higher part */
+			else                         /* next byte is in the same 32b word */
+				pm->wd8[j + i + 4 + 1] = tms_post >> (8 - (num + num_pre - 1) % 8); /* and higher part */
+		}
+
+		if (tdo) {
+			pm->rwords += words;       /* keep track of the words to read */
+			vdc.tdo = tdo;
+		}
+		pm->wwords = waddr / 2 + hwords;   /* payload size *2 to include both TDI and TMS data */
+		pm->waddr++;
+	}
+
+	if (!waddr)                        /* flush issued, but buffer empty */
+		;
+	else if (!vdc.trans_last)          /* buffered request */
+		pm->offseth = waddr + hwords * 2;  /* offset for next transaction, must be even */
+	else                               /* execute batch of requests */
+		rc = vdebug_run_jtag_queue(hsock, pm, pm->waddr);
+	vdc.trans_first = vdc.trans_last; /* flush forces trans_first flag */
+
+	return rc;
+}
+
+static int vdebug_mem_open(int hsock, struct vd_shm *pm, const char *path, uint8_t ndx)
+{
+	int rc;
+
+	if (!path)
+		return ERROR_OK;
+
+	pm->cmd = VD_CMD_MEMOPEN;
+	pm->wbytes = strlen(path) + 1;   /* includes terminating 0 */
+	pm->rbytes = 8;
+	pm->wwords = 0;
+	pm->rwords = 0;
+	memcpy(pm->wd8, path, pm->wbytes);
+	rc = vdebug_wait_server(hsock, pm);
+	if (rc) {
+		LOG_ERROR("0x%x opening memory %s", rc, path);
+	} else if (ndx != pm->rd16[1]) {
+		LOG_WARNING("Invalid memory index %" PRIu16 " returned. Direct memory access disabled", pm->rd16[1]);
+	} else {
+		vdc.mem_width[ndx] = pm->rd16[0] / 8;   /* memory width in bytes */
+		vdc.mem_depth[ndx] = pm->rd32[1];       /* memory depth in words */
+		LOG_DEBUG("%" PRIx8 ": %s memory %" PRIu32 "x%" PRIu32 "B, buffer %" PRIu32 "x%" PRIu32 "B", ndx, path,
+			vdc.mem_depth[ndx], vdc.mem_width[ndx], VD_BUFFER_LEN / vdc.mem_width[ndx], vdc.mem_width[ndx]);
+	}
+
+	return ERROR_OK;
+}
+
+static void vdebug_mem_close(int hsock, struct vd_shm *pm, uint8_t ndx)
+{
+	pm->cmd = VD_CMD_MEMCLOSE;
+	pm->rwdata = ndx;        /* which memory */
+	pm->wbytes = 0;
+	pm->rbytes = 0;
+	pm->wwords = 0;
+	pm->rwords = 0;
+	vdebug_wait_server(hsock, pm);
+	LOG_DEBUG("%" PRIx8 ": %s", ndx, vdc.mem_path[ndx]);
+}
+
+static int vdebug_init(void)
+{
+	vdc.hsocket = vdebug_socket_open(vdc.server_name, vdc.server_port);
+	pbuf = calloc(1, sizeof(struct vd_shm));
+	if (!pbuf) {
+		close_socket(vdc.hsocket);
+		vdc.hsocket = 0;
+		LOG_ERROR("cannot allocate %lu bytes", sizeof(struct vd_shm));
+		return ERROR_FAIL;
+	}
+	if (vdc.hsocket <= 0) {
+		free(pbuf);
+		pbuf = NULL;
+		LOG_ERROR("cannot connect to vdebug server %s:%" PRIu16,
+			vdc.server_name, vdc.server_port);
+		return ERROR_FAIL;
+	}
+	vdc.trans_first = 1;
+	vdc.poll_cycles = vdc.poll_max;
+	uint32_t sig_mask = VD_SIG_RESET | VD_SIG_TRST | VD_SIG_TCKDIV;
+	int rc = vdebug_open(vdc.hsocket, pbuf, vdc.bfm_path, vdc.bfm_type, vdc.bfm_period, sig_mask);
+	if (rc != 0) {
+		LOG_ERROR("cannot connect to %s, rc 0x%x", vdc.bfm_path, rc);
+		close_socket(vdc.hsocket);
+		vdc.hsocket = 0;
+		free(pbuf);
+		pbuf = NULL;
+	} else {
+		for (uint8_t i = 0; i < vdc.mem_ndx; i++) {
+			rc = vdebug_mem_open(vdc.hsocket, pbuf, vdc.mem_path[i], i);
+			if (rc != 0)
+				LOG_ERROR("cannot connect to %s, rc 0x%x", vdc.mem_path[i], rc);
+		}
+
+		LOG_INFO("vdebug %d connected to %s through %s:%" PRIu16,
+				 VD_VERSION, vdc.bfm_path, vdc.server_name, vdc.server_port);
+	}
+
+	return rc;
+}
+
+static int vdebug_quit(void)
+{
+	for (uint8_t i = 0; i < vdc.mem_ndx; i++)
+		if (vdc.mem_width[i])
+			vdebug_mem_close(vdc.hsocket, pbuf, i);
+	int rc = vdebug_close(vdc.hsocket, pbuf, vdc.bfm_type);
+	LOG_INFO("vdebug %d disconnected from %s through %s:%" PRIu16 " rc:%d", VD_VERSION,
+		vdc.bfm_path, vdc.server_name, vdc.server_port, rc);
+	if (vdc.hsocket)
+		close_socket(vdc.hsocket);
+	free(pbuf);
+	pbuf = NULL;
+
+	return ERROR_OK;
+}
+
+static int vdebug_reset(int trst, int srst)
+{
+	uint16_t sig_val = 0xffff;
+	uint16_t sig_mask = 0;
+
+	sig_mask |= VD_SIG_RESET;
+	if (srst)
+		sig_val &= ~VD_SIG_RESET;/* active low */
+	if (transport_is_jtag()) {
+		sig_mask |= VD_SIG_TRST;
+		if (trst)
+			sig_val &= ~VD_SIG_TRST; /* active low */
+	}
+
+	LOG_INFO("rst trst:%d srst:%d mask:%" PRIx16 " val:%" PRIx16, trst, srst, sig_mask, sig_val);
+	int rc = vdebug_sig_set(vdc.hsocket, pbuf, sig_mask, sig_val);
+	if (rc == 0)
+		rc = vdebug_wait(vdc.hsocket, pbuf, 20); /* 20 clock cycles pulse */
+
+	return rc;
+}
+
+static int vdebug_jtag_tms_seq(const uint8_t *tms, int num, uint8_t f_flush)
+{
+	LOG_INFO("tms  len:%d tms:%x", num, *(const uint32_t *)tms);
+
+	return vdebug_jtag_shift_tap(vdc.hsocket, pbuf, num, *tms, 0, NULL, 0, 0, NULL, f_flush);
+}
+
+static int vdebug_jtag_path_move(struct pathmove_command *cmd, uint8_t f_flush)
+{
+	uint8_t tms[DIV_ROUND_UP(cmd->num_states, 8)];
+	LOG_INFO("path num states %d", cmd->num_states);
+
+	memset(tms, 0, DIV_ROUND_UP(cmd->num_states, 8));
+
+	for (uint8_t i = 0; i < cmd->num_states; i++) {
+		if (tap_state_transition(tap_get_state(), true) == cmd->path[i])
+			buf_set_u32(tms, i, 1, 1);
+		tap_set_state(cmd->path[i]);
+	}
+
+	return vdebug_jtag_tms_seq(tms, cmd->num_states, f_flush);
+}
+
+static int vdebug_jtag_tlr(tap_state_t state, uint8_t f_flush)
+{
+	int rc = ERROR_OK;
+
+	uint8_t cur = tap_get_state();
+	uint8_t tms_pre = tap_get_tms_path(cur, state);
+	uint8_t num_pre = tap_get_tms_path_len(cur, state);
+	LOG_INFO("tlr  from %" PRIx8 " to %" PRIx8, cur, state);
+	if (cur != state) {
+		rc = vdebug_jtag_shift_tap(vdc.hsocket, pbuf, num_pre, tms_pre, 0, NULL, 0, 0, NULL, f_flush);
+		tap_set_state(state);
+	}
+
+	return rc;
+}
+
+static int vdebug_jtag_scan(struct scan_command *cmd, uint8_t f_flush)
+{
+	int rc = ERROR_OK;
+
+	uint8_t cur = tap_get_state();
+	uint8_t state = cmd->ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT;
+	uint8_t tms_pre = tap_get_tms_path(cur, state);
+	uint8_t num_pre = tap_get_tms_path_len(cur, state);
+	uint8_t tms_post = tap_get_tms_path(state, cmd->end_state);
+	uint8_t num_post = tap_get_tms_path_len(state, cmd->end_state);
+	int num_bits = jtag_scan_size(cmd);
+	LOG_DEBUG("scan len:%d fields:%d ir/!dr:%d state cur:%x end:%x",
+			  num_bits, cmd->num_fields, cmd->ir_scan, cur, cmd->end_state);
+	for (int i = 0; i < cmd->num_fields; i++) {
+		uint8_t cur_num_pre = i == 0 ? num_pre : 0;
+		uint8_t cur_tms_pre = i == 0 ? tms_pre : 0;
+		uint8_t cur_num_post = i == cmd->num_fields - 1 ? num_post : 0;
+		uint8_t cur_tms_post = i == cmd->num_fields - 1 ? tms_post : 0;
+		uint8_t cur_flush = i == cmd->num_fields - 1 ? f_flush : 0;
+		rc = vdebug_jtag_shift_tap(vdc.hsocket, pbuf, cur_num_pre, cur_tms_pre,
+			cmd->fields[i].num_bits, cmd->fields[i].out_value, cur_num_post, cur_tms_post,
+			cmd->fields[i].in_value, cur_flush);
+		if (rc)
+			break;
+	}
+
+	if (cur != cmd->end_state)
+		tap_set_state(cmd->end_state);
+
+	return rc;
+}
+
+static int vdebug_jtag_runtest(int cycles, tap_state_t state, uint8_t f_flush)
+{
+	uint8_t cur = tap_get_state();
+	uint8_t tms_pre = tap_get_tms_path(cur, state);
+	uint8_t num_pre = tap_get_tms_path_len(cur, state);
+	LOG_DEBUG("idle len:%d state cur:%x end:%x", cycles, cur, state);
+	int rc = vdebug_jtag_shift_tap(vdc.hsocket, pbuf, num_pre, tms_pre, cycles, NULL, 0, 0, NULL, f_flush);
+	if (cur != state)
+		tap_set_state(state);
+
+	return rc;
+}
+
+static int vdebug_jtag_stableclocks(int num, uint8_t f_flush)
+{
+	LOG_INFO("stab len:%d state cur:%x", num, tap_get_state());
+
+	return vdebug_jtag_shift_tap(vdc.hsocket, pbuf, 0, 0, num, NULL, 0, 0, NULL, f_flush);
+}
+
+static int vdebug_sleep(int us)
+{
+	LOG_INFO("sleep %d us", us);
+
+	return vdebug_wait(vdc.hsocket, pbuf, us / 1000);
+}
+
+static int vdebug_jtag_speed(int speed)
+{
+	unsigned int clkmax = VD_SCALE_PSTOMS / (vdc.bfm_period * 2); /* kHz */
+	unsigned int divval = clkmax / speed;
+	LOG_INFO("jclk speed:%d kHz set, BFM divider %u", speed, divval);
+
+	return vdebug_jtag_clock(vdc.hsocket, pbuf, divval);
+}
+
+static int vdebug_jtag_khz(int khz, int *jtag_speed)
+{
+	unsigned int clkmax = VD_SCALE_PSTOMS / (vdc.bfm_period * 2); /* kHz */
+	unsigned int divval = khz ? clkmax / khz : 1;
+	*jtag_speed = clkmax / divval;
+	LOG_DEBUG("khz  speed:%d from khz:%d", *jtag_speed, khz);
+
+	return ERROR_OK;
+}
+
+static int vdebug_jtag_div(int speed, int *khz)
+{
+	*khz = speed;
+	LOG_DEBUG("div  khz:%d from speed:%d", *khz, speed);
+
+	return ERROR_OK;
+}
+
+static int vdebug_jtag_execute_queue(void)
+{
+	int rc = ERROR_OK;
+
+	for (struct jtag_command *cmd = jtag_command_queue; rc == ERROR_OK && cmd; cmd = cmd->next) {
+		switch (cmd->type) {
+		case JTAG_RUNTEST:
+			rc = vdebug_jtag_runtest(cmd->cmd.runtest->num_cycles, cmd->cmd.runtest->end_state, !cmd->next);
+			break;
+		case JTAG_STABLECLOCKS:
+			rc = vdebug_jtag_stableclocks(cmd->cmd.stableclocks->num_cycles, !cmd->next);
+			break;
+		case JTAG_TLR_RESET:
+			rc = vdebug_jtag_tlr(cmd->cmd.statemove->end_state, !cmd->next);
+			break;
+		case JTAG_PATHMOVE:
+			rc = vdebug_jtag_path_move(cmd->cmd.pathmove, !cmd->next);
+			break;
+		case JTAG_TMS:
+			rc = vdebug_jtag_tms_seq(cmd->cmd.tms->bits, cmd->cmd.tms->num_bits, !cmd->next);
+			break;
+		case JTAG_SLEEP:
+			rc = vdebug_sleep(cmd->cmd.sleep->us);
+			break;
+		case JTAG_SCAN:
+			rc = vdebug_jtag_scan(cmd->cmd.scan, !cmd->next);
+			break;
+		default:
+			LOG_ERROR("Unknown JTAG command type 0x%x encountered", cmd->type);
+			rc = ERROR_FAIL;
+		}
+	}
+
+	return rc;
+}
+
+COMMAND_HANDLER(vdebug_set_server)
+{
+	if ((CMD_ARGC != 1) || !strchr(CMD_ARGV[0], ':'))
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	char *pchar = strchr(CMD_ARGV[0], ':');
+	*pchar = '\0';
+	strncpy(vdc.server_name, CMD_ARGV[0], sizeof(vdc.server_name) - 1);
+	int port = atoi(++pchar);
+	if (port < 0 || port > UINT16_MAX) {
+		LOG_ERROR("invalid port number %d specified", port);
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+	vdc.server_port = port;
+	LOG_DEBUG("server: %s port %u", vdc.server_name, vdc.server_port);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(vdebug_set_bfm)
+{
+	char prefix;
+
+	if ((CMD_ARGC != 2) || (sscanf(CMD_ARGV[1], "%u%c", &vdc.bfm_period, &prefix) != 2))
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	strncpy(vdc.bfm_path, CMD_ARGV[0], sizeof(vdc.bfm_path) - 1);
+	switch (prefix) {
+	case 'u':
+		vdc.bfm_period *= 1000000;
+		break;
+	case 'n':
+		vdc.bfm_period *= 1000;
+		break;
+	case 'p':
+	default:
+		break;
+	}
+	vdc.bfm_type = VD_BFM_JTAG;
+	LOG_DEBUG("bfm_path: %s clk_period %ups", vdc.bfm_path, vdc.bfm_period);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(vdebug_set_mem)
+{
+	if (CMD_ARGC != 3)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (vdc.mem_ndx >= VD_MAX_MEMORIES) {
+		LOG_ERROR("mem_path declared more than %d allowed times", VD_MAX_MEMORIES);
+		return ERROR_FAIL;
+	}
+
+	strncpy(vdc.mem_path[vdc.mem_ndx], CMD_ARGV[0], sizeof(vdc.mem_path[vdc.mem_ndx]) - 1);
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], vdc.mem_base[vdc.mem_ndx]);
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], vdc.mem_size[vdc.mem_ndx]);
+	LOG_DEBUG("mem_path: set %s @ 0x%08x+0x%08x", vdc.mem_path[vdc.mem_ndx],
+		vdc.mem_base[vdc.mem_ndx], vdc.mem_size[vdc.mem_ndx]);
+	vdc.mem_ndx++;
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(vdebug_set_batching)
+{
+	if (CMD_ARGC != 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (isdigit((unsigned char)CMD_ARGV[0][0]))
+		vdc.trans_batch = (CMD_ARGV[0][0] == '0' ? 0 : (CMD_ARGV[0][0] == '1' ? 1 : 2));
+	else if (CMD_ARGV[0][0] == 'r')
+		vdc.trans_batch = VD_BATCH_WR;
+	else if (CMD_ARGV[0][0] == 'w')
+		vdc.trans_batch = VD_BATCH_WO;
+	else
+		vdc.trans_batch = VD_BATCH_NO;
+	LOG_DEBUG("batching: set to %u", vdc.trans_batch);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(vdebug_set_polling)
+{
+	if (CMD_ARGC != 2)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	vdc.poll_min = atoi(CMD_ARGV[0]);
+	vdc.poll_max = atoi(CMD_ARGV[1]);
+	LOG_DEBUG("polling: set min %u max %u", vdc.poll_min, vdc.poll_max);
+
+	return ERROR_OK;
+}
+
+static const struct command_registration vdebug_command_handlers[] = {
+	{
+		.name = "server",
+		.handler = &vdebug_set_server,
+		.mode = COMMAND_CONFIG,
+		.help = "set the vdebug server name or address",
+		.usage = "<host:port>",
+	},
+	{
+		.name = "bfm_path",
+		.handler = &vdebug_set_bfm,
+		.mode = COMMAND_CONFIG,
+		.help = "set the vdebug BFM hierarchical path",
+		.usage = "<path> <clk_period[p|n|u]s>",
+	},
+	{
+		.name = "mem_path",
+		.handler = &vdebug_set_mem,
+		.mode = COMMAND_ANY,
+		.help = "set the design memory for the code load",
+		.usage = "<path> <base_address> <size>",
+	},
+	{
+		.name = "batching",
+		.handler = &vdebug_set_batching,
+		.mode = COMMAND_CONFIG,
+		.help = "set the transaction batching no|wr|rd [0|1|2]",
+		.usage = "<level>",
+	},
+	{
+		.name = "polling",
+		.handler = &vdebug_set_polling,
+		.mode = COMMAND_CONFIG,
+		.help = "set the polling pause, executing hardware cycles between min and max",
+		.usage = "<min cycles> <max cycles>",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+static const struct command_registration vdebug_command[] = {
+	{
+		.name = "vdebug",
+		.chain = vdebug_command_handlers,
+		.mode = COMMAND_ANY,
+		.help = "vdebug command group",
+		.usage = "",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+static struct jtag_interface vdebug_jtag_ops = {
+	.supported = DEBUG_CAP_TMS_SEQ,
+	.execute_queue = vdebug_jtag_execute_queue,
+};
+
+struct adapter_driver vdebug_adapter_driver = {
+	.name = "vdebug",
+	.transports = jtag_only,
+	.speed = vdebug_jtag_speed,
+	.khz = vdebug_jtag_khz,
+	.speed_div = vdebug_jtag_div,
+	.commands = vdebug_command,
+	.init = vdebug_init,
+	.quit = vdebug_quit,
+	.reset = vdebug_reset,
+	.jtag_ops = &vdebug_jtag_ops,
+};
diff --git a/src/jtag/drivers/vsllink.c b/src/jtag/drivers/vsllink.c
index f59a7033e..dbbdef4ba 100644
--- a/src/jtag/drivers/vsllink.c
+++ b/src/jtag/drivers/vsllink.c
@@ -273,6 +273,7 @@ static int vsllink_quit(void)
 	vsllink_free_buffer();
 	vsllink_usb_close(vsllink_handle);
 
+	libusb_exit(vsllink_handle->libusb_ctx);
 	free(vsllink_handle);
 
 	return ERROR_OK;
diff --git a/src/jtag/hla/hla_tcl.c b/src/jtag/hla/hla_tcl.c
index 5aa330145..6b206d231 100644
--- a/src/jtag/hla/hla_tcl.c
+++ b/src/jtag/hla/hla_tcl.c
@@ -59,6 +59,7 @@ static int jim_newtap_expected_id(struct jim_nvp *n, struct jim_getopt_info *goi
 #define NTAP_OPT_DISABLED  4
 #define NTAP_OPT_EXPECTED_ID 5
 #define NTAP_OPT_VERSION   6
+#define NTAP_OPT_BYPASS    7
 
 static int jim_hl_newtap_cmd(struct jim_getopt_info *goi)
 {
@@ -75,6 +76,7 @@ static int jim_hl_newtap_cmd(struct jim_getopt_info *goi)
 		{ .name = "-disable",       .value = NTAP_OPT_DISABLED },
 		{ .name = "-expected-id",       .value = NTAP_OPT_EXPECTED_ID },
 		{ .name = "-ignore-version",       .value = NTAP_OPT_VERSION },
+		{ .name = "-ignore-bypass",       .value = NTAP_OPT_BYPASS },
 		{ .name = NULL, .value = -1},
 	};
 
diff --git a/src/jtag/interfaces.c b/src/jtag/interfaces.c
index 63faa9561..ddf70cc24 100644
--- a/src/jtag/interfaces.c
+++ b/src/jtag/interfaces.c
@@ -57,6 +57,9 @@ extern struct adapter_driver usb_blaster_adapter_driver;
 #if BUILD_JTAG_VPI == 1
 extern struct adapter_driver jtag_vpi_adapter_driver;
 #endif
+#if BUILD_VDEBUG == 1
+extern struct adapter_driver vdebug_adapter_driver;
+#endif
 #if BUILD_JTAG_DPI == 1
 extern struct adapter_driver jtag_dpi_adapter_driver;
 #endif
@@ -168,6 +171,9 @@ struct adapter_driver *adapter_drivers[] = {
 #if BUILD_JTAG_VPI == 1
 		&jtag_vpi_adapter_driver,
 #endif
+#if BUILD_VDEBUG == 1
+		&vdebug_adapter_driver,
+#endif
 #if BUILD_JTAG_DPI == 1
 		&jtag_dpi_adapter_driver,
 #endif
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index d7d7d977c..4ec2f1e31 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -135,6 +135,9 @@ struct jtag_tap {
 	/** Flag saying whether to ignore version field in expected_ids[] */
 	bool ignore_version;
 
+	/** Flag saying whether to ignore the bypass bit in the code */
+	bool ignore_bypass;
+
 	/** current instruction */
 	uint8_t *cur_instr;
 	/** Bypass register selected */
@@ -543,7 +546,8 @@ int jtag_srst_asserted(int *srst_asserted);
  * @param field Pointer to scan field.
  * @param value Pointer to scan value.
  * @param mask Pointer to scan mask; may be NULL.
- * @returns Nothing, but calls jtag_set_error() on any error.
+ *
+ * returns Nothing, but calls jtag_set_error() on any error.
  */
 void jtag_check_value_mask(struct scan_field *field, uint8_t *value, uint8_t *mask);
 
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index 566c406b9..e6e976d77 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -470,6 +470,7 @@ static int jim_newtap_expected_id(struct jim_nvp *n, struct jim_getopt_info *goi
 #define NTAP_OPT_DISABLED  4
 #define NTAP_OPT_EXPECTED_ID 5
 #define NTAP_OPT_VERSION   6
+#define NTAP_OPT_BYPASS    7
 
 static int jim_newtap_ir_param(struct jim_nvp *n, struct jim_getopt_info *goi,
 	struct jtag_tap *tap)
@@ -532,6 +533,7 @@ static int jim_newtap_cmd(struct jim_getopt_info *goi)
 		{ .name = "-disable",       .value = NTAP_OPT_DISABLED },
 		{ .name = "-expected-id",       .value = NTAP_OPT_EXPECTED_ID },
 		{ .name = "-ignore-version",       .value = NTAP_OPT_VERSION },
+		{ .name = "-ignore-bypass",       .value = NTAP_OPT_BYPASS },
 		{ .name = NULL,       .value = -1 },
 	};
 
@@ -617,6 +619,9 @@ static int jim_newtap_cmd(struct jim_getopt_info *goi)
 		    case NTAP_OPT_VERSION:
 			    tap->ignore_version = true;
 			    break;
+		    case NTAP_OPT_BYPASS:
+			    tap->ignore_bypass = true;
+			    break;
 		}	/* switch (n->value) */
 	}	/* while (goi->argc) */
 
@@ -887,6 +892,7 @@ static const struct command_registration jtag_subcommand_handlers[] = {
 			"['-enable'|'-disable'] "
 			"['-expected_id' number] "
 			"['-ignore-version'] "
+			"['-ignore-bypass'] "
 			"['-ircapture' number] "
 			"['-mask' number]",
 	},
diff --git a/src/openocd.c b/src/openocd.c
index 0292ba445..3c96d3214 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -437,6 +437,8 @@ int openocd_main(int argc, char *argv[])
 	rtt_exit();
 	free_config();
 
+	log_exit();
+
 	if (ret == ERROR_FAIL)
 		return EXIT_FAILURE;
 	else if (ret != ERROR_OK)
diff --git a/src/rtos/ThreadX.c b/src/rtos/ThreadX.c
index 441b7abc5..4161e63fa 100644
--- a/src/rtos/ThreadX.c
+++ b/src/rtos/ThreadX.c
@@ -175,6 +175,18 @@ static const struct threadx_params threadx_params_list[] = {
 	get_stacking_info_arm926ejs,		/* fn_get_stacking_info */
 	is_thread_id_valid_arm926ejs,		/* fn_is_thread_id_valid */
 	},
+	{
+	"hla_target",				/* target_name */
+	4,							/* pointer_width; */
+	8,							/* thread_stack_offset; */
+	40,							/* thread_name_offset; */
+	48,							/* thread_state_offset; */
+	136,						/* thread_next_offset */
+	&rtos_standard_cortex_m3_stacking,	/* stacking_info */
+	1,							/* stacking_info_nb */
+	NULL,						/* fn_get_stacking_info */
+	NULL,						/* fn_is_thread_id_valid */
+	},
 };
 
 enum threadx_symbol_values {
diff --git a/src/rtos/chromium-ec.c b/src/rtos/chromium-ec.c
index 1c8f4e3f4..95a228d0d 100644
--- a/src/rtos/chromium-ec.c
+++ b/src/rtos/chromium-ec.c
@@ -7,6 +7,11 @@
  * Chromium-EC RTOS Task Awareness
  */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <helper/bits.h>
 #include <rtos/rtos.h>
 #include <target/target.h>
 #include <target/target_type.h>
@@ -16,7 +21,6 @@
 #define CROS_EC_MAX_TASKS 32
 #define CROS_EC_MAX_NAME 200
 #define CROS_EC_IDLE_STRING "<< idle >>"
-#define BIT(x) (1 << (x))
 
 struct chromium_ec_params {
 	const char *target_name;
diff --git a/src/rtos/hwthread.c b/src/rtos/hwthread.c
index 3702b0b47..7c998861f 100644
--- a/src/rtos/hwthread.c
+++ b/src/rtos/hwthread.c
@@ -23,6 +23,7 @@
 #include "target/target.h"
 #include "target/target_type.h"
 #include "target/register.h"
+#include <target/smp.h>
 #include "rtos.h"
 #include "helper/log.h"
 #include "helper/types.h"
@@ -107,7 +108,7 @@ static int hwthread_update_threads(struct rtos *rtos)
 
 	/* determine the number of "threads" */
 	if (target->smp) {
-		for (head = target->head; head; head = head->next) {
+		foreach_smp_target(head, target->smp_targets) {
 			struct target *curr = head->target;
 
 			if (!target_was_examined(curr))
@@ -123,7 +124,7 @@ static int hwthread_update_threads(struct rtos *rtos)
 
 	if (target->smp) {
 		/* loop over all threads */
-		for (head = target->head; head; head = head->next) {
+		foreach_smp_target(head, target->smp_targets) {
 			struct target *curr = head->target;
 
 			if (!target_was_examined(curr))
@@ -218,7 +219,8 @@ static struct target *hwthread_find_thread(struct target *target, int64_t thread
 	if (!target)
 		return NULL;
 	if (target->smp) {
-		for (struct target_list *head = target->head; head; head = head->next) {
+		struct target_list *head;
+		foreach_smp_target(head, target->smp_targets) {
 			if (thread_id == threadid_from_target(head->target))
 				return head->target;
 		}
diff --git a/src/rtos/linux.c b/src/rtos/linux.c
index 84b4c6524..d147c1cf0 100644
--- a/src/rtos/linux.c
+++ b/src/rtos/linux.c
@@ -30,6 +30,7 @@
 #include "rtos.h"
 #include "rtos_standard_stackings.h"
 #include <target/register.h>
+#include <target/smp.h>
 #include "server/gdb_server.h"
 
 #define LINUX_USER_KERNEL_BORDER 0xc0000000
@@ -191,16 +192,14 @@ static int linux_os_thread_reg_list(struct rtos *rtos,
 	/*  search target to perform the access  */
 	struct reg **gdb_reg_list;
 	struct target_list *head;
-	head = target->head;
 	found = 0;
-	do {
+	foreach_smp_target(head, target->smp_targets) {
 		if (head->target->coreid == next->core_id) {
 			target = head->target;
 			found = 1;
 			break;
 		}
-		head = head->next;
-	} while (head);
+	}
 
 	if (found == 0) {
 		LOG_ERROR
@@ -397,7 +396,6 @@ static int get_name(struct target *target, struct threads *t)
 static int get_current(struct target *target, int create)
 {
 	struct target_list *head;
-	head = target->head;
 	uint8_t *buf;
 	uint32_t val;
 	uint32_t ti_addr;
@@ -413,7 +411,7 @@ static int get_current(struct target *target, int create)
 		ctt = ctt->next;
 	}
 
-	while (head) {
+	foreach_smp_target(head, target->smp_targets) {
 		struct reg **reg_list;
 		int reg_list_size;
 		int retval;
@@ -474,7 +472,6 @@ static int get_current(struct target *target, int create)
 		}
 
 		free(reg_list);
-		head = head->next;
 	}
 
 	free(buffer);
@@ -1394,9 +1391,8 @@ static int linux_os_smp_init(struct target *target)
 	struct linux_os *os_linux =
 		(struct linux_os *)rtos->rtos_specific_params;
 	struct current_thread *ct;
-	head = target->head;
 
-	while (head) {
+	foreach_smp_target(head, target->smp_targets) {
 		if (head->target->rtos != rtos) {
 			struct linux_os *smp_os_linux =
 				(struct linux_os *)head->target->rtos->rtos_specific_params;
@@ -1413,8 +1409,6 @@ static int linux_os_smp_init(struct target *target)
 			os_linux->nr_cpus++;
 			free(smp_os_linux);
 		}
-
-		head = head->next;
 	}
 
 	return ERROR_OK;
diff --git a/src/rtos/zephyr.c b/src/rtos/zephyr.c
index 630511636..7f3325fea 100644
--- a/src/rtos/zephyr.c
+++ b/src/rtos/zephyr.c
@@ -375,15 +375,15 @@ static const struct symbol_table_elem zephyr_symbol_list[] = {
 		.optional = false
 	},
 	{
-		.symbol_name = "_kernel_openocd_offsets",
+		.symbol_name = "_kernel_thread_info_offsets",
 		.optional = false
 	},
 	{
-		.symbol_name = "_kernel_openocd_size_t_size",
+		.symbol_name = "_kernel_thread_info_size_t_size",
 		.optional = false
 	},
 	{
-		.symbol_name = "_kernel_openocd_num_offsets",
+		.symbol_name = "_kernel_thread_info_num_offsets",
 		.optional = true
 	},
 	{
diff --git a/src/rtt/rtt.c b/src/rtt/rtt.c
index bf3cca51b..3da3cce81 100644
--- a/src/rtt/rtt.c
+++ b/src/rtt/rtt.c
@@ -15,6 +15,10 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include <stdint.h>
 #include <stdbool.h>
 #include <string.h>
diff --git a/src/rtt/tcl.c b/src/rtt/tcl.c
index f5abf2e5e..4a34d8b98 100644
--- a/src/rtt/tcl.c
+++ b/src/rtt/tcl.c
@@ -15,6 +15,10 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include <helper/log.h>
 #include <target/rtt.h>
 
diff --git a/src/server/Makefile.am b/src/server/Makefile.am
index fb5248bfd..e3699f181 100644
--- a/src/server/Makefile.am
+++ b/src/server/Makefile.am
@@ -6,7 +6,6 @@ noinst_LTLIBRARIES += %D%/libserver.la
 	%D%/server.h \
 	%D%/telnet_server.h \
 	%D%/gdb_server.h \
-	%D%/server_stubs.c \
 	%D%/tcl_server.c \
 	%D%/tcl_server.h \
 	%D%/rtt_server.c \
diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 0d2d1ae2c..4efdc1ee7 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -61,6 +61,13 @@
  * found in most modern embedded processors.
  */
 
+enum gdb_output_flag {
+	/* GDB doesn't accept 'O' packets */
+	GDB_OUTPUT_NO,
+	/* GDB accepts 'O' packets */
+	GDB_OUTPUT_ALL,
+};
+
 struct target_desc_format {
 	char *tdesc;
 	uint32_t tdesc_length;
@@ -97,6 +104,8 @@ struct gdb_connection {
 	struct target_desc_format target_desc;
 	/* temporarily used for thread list support */
 	char *thread_list;
+	/* flag to mask the output from gdb_log_callback() */
+	enum gdb_output_flag output_flag;
 };
 
 #if 0
@@ -362,11 +371,13 @@ static int gdb_write(struct connection *connection, void *data, int len)
 	return ERROR_SERVER_REMOTE_CLOSED;
 }
 
-static void gdb_log_incoming_packet(char *packet)
+static void gdb_log_incoming_packet(struct connection *connection, char *packet)
 {
 	if (!LOG_LEVEL_IS(LOG_LVL_DEBUG))
 		return;
 
+	struct target *target = get_target_from_connection(connection);
+
 	/* Avoid dumping non-printable characters to the terminal */
 	const unsigned packet_len = strlen(packet);
 	const char *nonprint = find_nonprint_char(packet, packet_len);
@@ -380,25 +391,31 @@ static void gdb_log_incoming_packet(char *packet)
 		if (packet_prefix_printable) {
 			const unsigned int prefix_len = colon - packet + 1;  /* + 1 to include the ':' */
 			const unsigned int payload_len = packet_len - prefix_len;
-			LOG_DEBUG("received packet: %.*s<binary-data-%u-bytes>", prefix_len, packet, payload_len);
+			LOG_TARGET_DEBUG(target, "received packet: %.*s<binary-data-%u-bytes>", prefix_len,
+				packet, payload_len);
 		} else {
-			LOG_DEBUG("received packet: <binary-data-%u-bytes>", packet_len);
+			LOG_TARGET_DEBUG(target, "received packet: <binary-data-%u-bytes>", packet_len);
 		}
 	} else {
 		/* All chars printable, dump the packet as is */
-		LOG_DEBUG("received packet: %s", packet);
+		LOG_TARGET_DEBUG(target, "received packet: %s", packet);
 	}
 }
 
-static void gdb_log_outgoing_packet(char *packet_buf, unsigned int packet_len, unsigned char checksum)
+static void gdb_log_outgoing_packet(struct connection *connection, char *packet_buf,
+	unsigned int packet_len, unsigned char checksum)
 {
 	if (!LOG_LEVEL_IS(LOG_LVL_DEBUG))
 		return;
 
+	struct target *target = get_target_from_connection(connection);
+
 	if (find_nonprint_char(packet_buf, packet_len))
-		LOG_DEBUG("sending packet: $<binary-data-%u-bytes>#%2.2x", packet_len, checksum);
+		LOG_TARGET_DEBUG(target, "sending packet: $<binary-data-%u-bytes>#%2.2x",
+			packet_len, checksum);
 	else
-		LOG_DEBUG("sending packet: $%.*s#%2.2x'", packet_len, packet_buf, checksum);
+		LOG_TARGET_DEBUG(target, "sending packet: $%.*s#%2.2x", packet_len, packet_buf,
+			checksum);
 }
 
 static int gdb_put_packet_inner(struct connection *connection,
@@ -441,7 +458,7 @@ static int gdb_put_packet_inner(struct connection *connection,
 #endif
 
 	while (1) {
-		gdb_log_outgoing_packet(buffer, len, my_checksum);
+		gdb_log_outgoing_packet(connection, buffer, len, my_checksum);
 
 		char local_buffer[1024];
 		local_buffer[0] = '$';
@@ -474,22 +491,27 @@ static int gdb_put_packet_inner(struct connection *connection,
 		if (retval != ERROR_OK)
 			return retval;
 
-		if (reply == '+')
+		if (reply == '+') {
+			gdb_log_incoming_packet(connection, "+");
 			break;
-		else if (reply == '-') {
+		} else if (reply == '-') {
 			/* Stop sending output packets for now */
-			log_remove_callback(gdb_log_callback, connection);
+			gdb_con->output_flag = GDB_OUTPUT_NO;
+			gdb_log_incoming_packet(connection, "-");
 			LOG_WARNING("negative reply, retrying");
 		} else if (reply == 0x3) {
 			gdb_con->ctrl_c = true;
+			gdb_log_incoming_packet(connection, "<Ctrl-C>");
 			retval = gdb_get_char(connection, &reply);
 			if (retval != ERROR_OK)
 				return retval;
-			if (reply == '+')
+			if (reply == '+') {
+				gdb_log_incoming_packet(connection, "+");
 				break;
-			else if (reply == '-') {
+			} else if (reply == '-') {
 				/* Stop sending output packets for now */
-				log_remove_callback(gdb_log_callback, connection);
+				gdb_con->output_flag = GDB_OUTPUT_NO;
+				gdb_log_incoming_packet(connection, "-");
 				LOG_WARNING("negative reply, retrying");
 			} else if (reply == '$') {
 				LOG_ERROR("GDB missing ack(1) - assumed good");
@@ -666,6 +688,7 @@ static int gdb_get_packet_inner(struct connection *connection,
 				case '$':
 					break;
 				case '+':
+					gdb_log_incoming_packet(connection, "+");
 					/* According to the GDB documentation
 					 * (https://sourceware.org/gdb/onlinedocs/gdb/Packet-Acknowledgment.html):
 					 * "gdb sends a final `+` acknowledgment of the stub's `OK`
@@ -683,9 +706,11 @@ static int gdb_get_packet_inner(struct connection *connection,
 					}
 					break;
 				case '-':
+					gdb_log_incoming_packet(connection, "-");
 					LOG_WARNING("negative acknowledgment, but no packet pending");
 					break;
 				case 0x3:
+					gdb_log_incoming_packet(connection, "<Ctrl-C>");
 					gdb_con->ctrl_c = true;
 					*len = 0;
 					return ERROR_OK;
@@ -932,7 +957,7 @@ static void gdb_frontend_halted(struct target *target, struct connection *connec
 	 */
 	if (gdb_connection->frontend_state == TARGET_RUNNING) {
 		/* stop forwarding log packets! */
-		log_remove_callback(gdb_log_callback, connection);
+		gdb_connection->output_flag = GDB_OUTPUT_NO;
 
 		/* check fileio first */
 		if (target_get_gdb_fileio_info(target, target->fileio_info) == ERROR_OK)
@@ -992,6 +1017,7 @@ static int gdb_new_connection(struct connection *connection)
 	gdb_connection->target_desc.tdesc = NULL;
 	gdb_connection->target_desc.tdesc_length = 0;
 	gdb_connection->thread_list = NULL;
+	gdb_connection->output_flag = GDB_OUTPUT_NO;
 
 	/* send ACK to GDB for debug request */
 	gdb_write(connection, "+", 1);
@@ -1006,16 +1032,19 @@ static int gdb_new_connection(struct connection *connection)
 	breakpoint_clear_target(target);
 	watchpoint_clear_target(target);
 
-	/* remove the initial ACK from the incoming buffer */
+	/* Since version 3.95 (gdb-19990504), with the exclusion of 6.5~6.8, GDB
+	 * sends an ACK at connection with the following comment in its source code:
+	 * "Ack any packet which the remote side has already sent."
+	 * LLDB does the same since the first gdb-remote implementation.
+	 * Remove the initial ACK from the incoming buffer.
+	 */
 	retval = gdb_get_char(connection, &initial_ack);
 	if (retval != ERROR_OK)
 		return retval;
 
-	/* FIX!!!??? would we actually ever receive a + here???
-	 * Not observed.
-	 */
 	if (initial_ack != '+')
 		gdb_putback_char(connection, initial_ack);
+
 	target_call_event_callbacks(target, TARGET_EVENT_GDB_ATTACH);
 
 	if (target->rtos) {
@@ -1073,6 +1102,8 @@ static int gdb_new_connection(struct connection *connection)
 	 * register callback to be informed about target events */
 	target_register_event_callback(gdb_target_callback_event_handler, connection);
 
+	log_add_callback(gdb_log_callback, connection);
+
 	return ERROR_OK;
 }
 
@@ -2256,6 +2287,122 @@ static int get_reg_features_list(struct target *target, char const **feature_lis
 	return ERROR_OK;
 }
 
+/* Create a register list that's the union of all the registers of the SMP
+ * group this target is in. If the target is not part of an SMP group, this
+ * returns the same as target_get_gdb_reg_list_noread().
+ */
+static int smp_reg_list_noread(struct target *target,
+		struct reg **combined_list[], int *combined_list_size,
+		enum target_register_class reg_class)
+{
+	if (!target->smp)
+		return target_get_gdb_reg_list_noread(target, combined_list,
+				combined_list_size, REG_CLASS_ALL);
+
+	unsigned int combined_allocated = 256;
+	struct reg **local_list = malloc(combined_allocated * sizeof(struct reg *));
+	if (!local_list) {
+		LOG_ERROR("malloc(%zu) failed", combined_allocated * sizeof(struct reg *));
+		return ERROR_FAIL;
+	}
+	unsigned int local_list_size = 0;
+
+	struct target_list *head;
+	foreach_smp_target(head, target->smp_targets) {
+		if (!target_was_examined(head->target))
+			continue;
+
+		struct reg **reg_list = NULL;
+		int reg_list_size;
+		int result = target_get_gdb_reg_list_noread(head->target, &reg_list,
+				&reg_list_size, reg_class);
+		if (result != ERROR_OK) {
+			free(local_list);
+			return result;
+		}
+		for (int i = 0; i < reg_list_size; i++) {
+			bool found = false;
+			struct reg *a = reg_list[i];
+			if (a->exist) {
+				/* Nested loop makes this O(n^2), but this entire function with
+				 * 5 RISC-V targets takes just 2ms on my computer. Fast enough
+				 * for me. */
+				for (unsigned int j = 0; j < local_list_size; j++) {
+					struct reg *b = local_list[j];
+					if (!strcmp(a->name, b->name)) {
+						found = true;
+						if (a->size != b->size) {
+							LOG_ERROR("SMP register %s is %d bits on one "
+									"target, but %d bits on another target.",
+									a->name, a->size, b->size);
+							free(reg_list);
+							free(local_list);
+							return ERROR_FAIL;
+						}
+						break;
+					}
+				}
+				if (!found) {
+					LOG_DEBUG("[%s] %s not found in combined list", target_name(target), a->name);
+					if (local_list_size >= combined_allocated) {
+						combined_allocated *= 2;
+						local_list = realloc(local_list, combined_allocated * sizeof(struct reg *));
+						if (!local_list) {
+							LOG_ERROR("realloc(%zu) failed", combined_allocated * sizeof(struct reg *));
+							return ERROR_FAIL;
+						}
+					}
+					local_list[local_list_size] = a;
+					local_list_size++;
+				}
+			}
+		}
+		free(reg_list);
+	}
+
+	if (local_list_size == 0) {
+		LOG_ERROR("Unable to get register list");
+		free(local_list);
+		return ERROR_FAIL;
+	}
+
+	/* Now warn the user about any registers that weren't found in every target. */
+	foreach_smp_target(head, target->smp_targets) {
+		if (!target_was_examined(head->target))
+			continue;
+
+		struct reg **reg_list = NULL;
+		int reg_list_size;
+		int result = target_get_gdb_reg_list_noread(head->target, &reg_list,
+				&reg_list_size, reg_class);
+		if (result != ERROR_OK) {
+			free(local_list);
+			return result;
+		}
+		for (unsigned int i = 0; i < local_list_size; i++) {
+			bool found = false;
+			struct reg *a = local_list[i];
+			for (int j = 0; j < reg_list_size; j++) {
+				struct reg *b = reg_list[j];
+				if (b->exist && !strcmp(a->name, b->name)) {
+					found = true;
+					break;
+				}
+			}
+			if (!found) {
+				LOG_WARNING("Register %s does not exist in %s, which is part of an SMP group where "
+					    "this register does exist.",
+					    a->name, target_name(head->target));
+			}
+		}
+		free(reg_list);
+	}
+
+	*combined_list = local_list;
+	*combined_list_size = local_list_size;
+	return ERROR_OK;
+}
+
 static int gdb_generate_target_description(struct target *target, char **tdesc_out)
 {
 	int retval = ERROR_OK;
@@ -2269,8 +2416,8 @@ static int gdb_generate_target_description(struct target *target, char **tdesc_o
 	int size = 0;
 
 
-	retval = target_get_gdb_reg_list_noread(target, &reg_list,
-			&reg_list_size, REG_CLASS_ALL);
+	retval = smp_reg_list_noread(target, &reg_list, &reg_list_size,
+			REG_CLASS_ALL);
 
 	if (retval != ERROR_OK) {
 		LOG_ERROR("get register list failed");
@@ -2514,8 +2661,14 @@ static int gdb_generate_thread_list(struct target *target, char **thread_list_ou
 			if (!thread_detail->exists)
 				continue;
 
-			xml_printf(&retval, &thread_list, &pos, &size,
-				   "<thread id=\"%" PRIx64 "\">", thread_detail->threadid);
+			if (thread_detail->thread_name_str)
+				xml_printf(&retval, &thread_list, &pos, &size,
+					   "<thread id=\"%" PRIx64 "\" name=\"%s\">",
+					   thread_detail->threadid,
+					   thread_detail->thread_name_str);
+			else
+				xml_printf(&retval, &thread_list, &pos, &size,
+					   "<thread id=\"%" PRIx64 "\">", thread_detail->threadid);
 
 			if (thread_detail->thread_name_str)
 				xml_printf(&retval, &thread_list, &pos, &size,
@@ -2597,22 +2750,75 @@ static int gdb_query_packet(struct connection *connection,
 
 	if (strncmp(packet, "qRcmd,", 6) == 0) {
 		if (packet_size > 6) {
+			Jim_Interp *interp = cmd_ctx->interp;
 			char *cmd;
 			cmd = malloc((packet_size - 6) / 2 + 1);
 			size_t len = unhexify((uint8_t *)cmd, packet + 6, (packet_size - 6) / 2);
 			cmd[len] = 0;
 
 			/* We want to print all debug output to GDB connection */
-			log_add_callback(gdb_log_callback, connection);
+			gdb_connection->output_flag = GDB_OUTPUT_ALL;
 			target_call_timer_callbacks_now();
 			/* some commands need to know the GDB connection, make note of current
 			 * GDB connection. */
 			current_gdb_connection = gdb_connection;
-			command_run_line(cmd_ctx, cmd);
+
+			struct target *saved_target_override = cmd_ctx->current_target_override;
+			cmd_ctx->current_target_override = NULL;
+
+			struct command_context *old_context = Jim_GetAssocData(interp, "context");
+			Jim_DeleteAssocData(interp, "context");
+			int retval = Jim_SetAssocData(interp, "context", NULL, cmd_ctx);
+			if (retval == JIM_OK) {
+				retval = Jim_EvalObj(interp, Jim_NewStringObj(interp, cmd, -1));
+				Jim_DeleteAssocData(interp, "context");
+			}
+			int inner_retval = Jim_SetAssocData(interp, "context", NULL, old_context);
+			if (retval == JIM_OK)
+				retval = inner_retval;
+
+			cmd_ctx->current_target_override = saved_target_override;
+
 			current_gdb_connection = NULL;
 			target_call_timer_callbacks_now();
-			log_remove_callback(gdb_log_callback, connection);
+			gdb_connection->output_flag = GDB_OUTPUT_NO;
 			free(cmd);
+			if (retval == JIM_RETURN)
+				retval = interp->returnCode;
+			int lenmsg;
+			const char *cretmsg = Jim_GetString(Jim_GetResult(interp), &lenmsg);
+			char *retmsg;
+			if (lenmsg && cretmsg[lenmsg - 1] != '\n') {
+				retmsg = alloc_printf("%s\n", cretmsg);
+				lenmsg++;
+			} else {
+				retmsg = strdup(cretmsg);
+			}
+			if (!retmsg)
+				return ERROR_GDB_BUFFER_TOO_SMALL;
+
+			if (retval == JIM_OK) {
+				if (lenmsg) {
+					char *hex_buffer = malloc(lenmsg * 2 + 1);
+					if (!hex_buffer) {
+						free(retmsg);
+						return ERROR_GDB_BUFFER_TOO_SMALL;
+					}
+
+					size_t pkt_len = hexify(hex_buffer, (const uint8_t *)retmsg, lenmsg,
+											lenmsg * 2 + 1);
+					gdb_put_packet(connection, hex_buffer, pkt_len);
+					free(hex_buffer);
+				} else {
+					gdb_put_packet(connection, "OK", 2);
+				}
+			} else {
+				if (lenmsg)
+					gdb_output_con(connection, retmsg);
+				gdb_send_error(connection, retval);
+			}
+			free(retmsg);
+			return ERROR_OK;
 		}
 		gdb_put_packet(connection, "OK", 2);
 		return ERROR_OK;
@@ -2792,7 +2998,7 @@ static bool gdb_handle_vcont_packet(struct connection *connection, const char *p
 	if (parse[0] == 'c') {
 		gdb_running_type = 'c';
 		LOG_DEBUG("target %s continue", target_name(target));
-		log_add_callback(gdb_log_callback, connection);
+		gdb_connection->output_flag = GDB_OUTPUT_ALL;
 		retval = target_resume(target, 1, 0, 0, 0);
 		if (retval == ERROR_TARGET_NOT_HALTED)
 			LOG_INFO("target %s was not halted when resume was requested", target_name(target));
@@ -2881,7 +3087,7 @@ static bool gdb_handle_vcont_packet(struct connection *connection, const char *p
 			}
 
 			LOG_DEBUG("target %s single-step thread %"PRIx64, target_name(ct), thread_id);
-			log_add_callback(gdb_log_callback, connection);
+			gdb_connection->output_flag = GDB_OUTPUT_ALL;
 			target_call_event_callbacks(ct, TARGET_EVENT_GDB_START);
 
 			/*
@@ -2902,7 +3108,7 @@ static bool gdb_handle_vcont_packet(struct connection *connection, const char *p
 										 "T05thread:%016"PRIx64";", thread_id);
 
 				gdb_put_packet(connection, sig_reply, sig_reply_len);
-				log_remove_callback(gdb_log_callback, connection);
+				gdb_connection->output_flag = GDB_OUTPUT_NO;
 
 				return true;
 			}
@@ -2914,7 +3120,7 @@ static bool gdb_handle_vcont_packet(struct connection *connection, const char *p
 					LOG_DEBUG("stepi ignored. GDB will now fetch the register state "
 									"from the target.");
 					gdb_sig_halted(connection);
-					log_remove_callback(gdb_log_callback, connection);
+					gdb_connection->output_flag = GDB_OUTPUT_NO;
 				} else
 					gdb_connection->frontend_state = TARGET_RUNNING;
 				return true;
@@ -2932,7 +3138,7 @@ static bool gdb_handle_vcont_packet(struct connection *connection, const char *p
 				/* send back signal information */
 				gdb_signal_reply(ct, connection);
 				/* stop forwarding log packets! */
-				log_remove_callback(gdb_log_callback, connection);
+				gdb_connection->output_flag = GDB_OUTPUT_NO;
 			} else
 				gdb_connection->frontend_state = TARGET_RUNNING;
 		} else {
@@ -3262,6 +3468,10 @@ static void gdb_log_callback(void *priv, const char *file, unsigned line,
 	struct connection *connection = priv;
 	struct gdb_connection *gdb_con = connection->priv;
 
+	if (gdb_con->output_flag == GDB_OUTPUT_NO)
+		/* No out allowed */
+		return;
+
 	if (gdb_con->busy) {
 		/* do not reply this using the O packet */
 		return;
@@ -3311,9 +3521,10 @@ static int gdb_input_inner(struct connection *connection)
 		/* terminate with zero */
 		gdb_packet_buffer[packet_size] = '\0';
 
-		gdb_log_incoming_packet(gdb_packet_buffer);
-
 		if (packet_size > 0) {
+
+			gdb_log_incoming_packet(connection, gdb_packet_buffer);
+
 			retval = ERROR_OK;
 			switch (packet[0]) {
 				case 'T':	/* Is thread alive? */
@@ -3364,7 +3575,7 @@ static int gdb_input_inner(struct connection *connection)
 				case 's':
 				{
 					gdb_thread_packet(connection, packet, packet_size);
-					log_add_callback(gdb_log_callback, connection);
+					gdb_con->output_flag = GDB_OUTPUT_ALL;
 
 					if (gdb_con->mem_write_error) {
 						LOG_ERROR("Memory write failure!");
@@ -3407,7 +3618,7 @@ static int gdb_input_inner(struct connection *connection)
 						gdb_sig_halted(connection);
 
 						/* stop forwarding log packets! */
-						log_remove_callback(gdb_log_callback, connection);
+						gdb_con->output_flag = GDB_OUTPUT_NO;
 					} else {
 						/* We're running/stepping, in which case we can
 						 * forward log output until the target is halted
@@ -3458,12 +3669,14 @@ static int gdb_input_inner(struct connection *connection)
 					break;
 
 				case 'j':
+					/* DEPRECATED */
 					/* packet supported only by smp target i.e cortex_a.c*/
 					/* handle smp packet replying coreid played to gbd */
 					gdb_read_smp_packet(connection, packet, packet_size);
 					break;
 
 				case 'J':
+					/* DEPRECATED */
 					/* packet supported only by smp target i.e cortex_a.c */
 					/* handle smp packet setting coreid to be played at next
 					 * resume to gdb */
@@ -3479,7 +3692,7 @@ static int gdb_input_inner(struct connection *connection)
 					 * Fretcode,errno,Ctrl-C flag;call-specific attachment
 					 */
 					gdb_con->frontend_state = TARGET_RUNNING;
-					log_add_callback(gdb_log_callback, connection);
+					gdb_con->output_flag = GDB_OUTPUT_ALL;
 					gdb_fileio_response_packet(connection, packet, packet_size);
 					break;
 
@@ -3532,6 +3745,37 @@ static int gdb_input(struct connection *connection)
 	return ERROR_OK;
 }
 
+static void gdb_keep_client_alive(struct connection *connection)
+{
+	struct gdb_connection *gdb_con = connection->priv;
+
+	if (gdb_con->busy) {
+		/* do not send packets, retry asap */
+		return;
+	}
+
+	switch (gdb_con->output_flag) {
+	case GDB_OUTPUT_NO:
+		/* no need for keep-alive */
+		break;
+	case GDB_OUTPUT_ALL:
+		/* send an empty O packet */
+		gdb_output_con(connection, "");
+		break;
+	default:
+		break;
+	}
+}
+
+static const struct service_driver gdb_service_driver = {
+	.name = "gdb",
+	.new_connection_during_keep_alive_handler = NULL,
+	.new_connection_handler = gdb_new_connection,
+	.input_handler = gdb_input,
+	.connection_closed_handler = gdb_connection_closed,
+	.keep_client_alive_handler = gdb_keep_client_alive,
+};
+
 static int gdb_target_start(struct target *target, const char *port)
 {
 	struct gdb_service *gdb_service;
@@ -3548,19 +3792,14 @@ static int gdb_target_start(struct target *target, const char *port)
 	gdb_service->core[1] = -1;
 	target->gdb_service = gdb_service;
 
-	ret = add_service("gdb",
-			port, target->gdb_max_connections, &gdb_new_connection, &gdb_input,
-			&gdb_connection_closed, gdb_service);
+	ret = add_service(&gdb_service_driver, port, target->gdb_max_connections, gdb_service);
 	/* initialize all targets gdb service with the same pointer */
 	{
 		struct target_list *head;
-		struct target *curr;
-		head = target->head;
-		while (head) {
-			curr = head->target;
+		foreach_smp_target(head, target->smp_targets) {
+			struct target *curr = head->target;
 			if (curr != target)
 				curr->gdb_service = gdb_service;
-			head = head->next;
 		}
 	}
 	return ret;
diff --git a/src/server/ipdbg.c b/src/server/ipdbg.c
index ec2fae8c0..3bbcf0714 100644
--- a/src/server/ipdbg.c
+++ b/src/server/ipdbg.c
@@ -587,6 +587,15 @@ static int ipdbg_on_connection_closed(struct connection *connection)
 	return ipdbg_stop_polling(connection->service->priv);
 }
 
+static const struct service_driver ipdbg_service_driver = {
+	.name = "ipdbg",
+	.new_connection_during_keep_alive_handler = NULL,
+	.new_connection_handler = ipdbg_on_new_connection,
+	.input_handler = ipdbg_on_connection_input,
+	.connection_closed_handler = ipdbg_on_connection_closed,
+	.keep_client_alive_handler = NULL,
+};
+
 static int ipdbg_start(uint16_t port, struct jtag_tap *tap, uint32_t user_instruction,
 					uint8_t data_register_length, struct ipdbg_virtual_ir_info *virtual_ir, uint8_t tool)
 {
@@ -618,8 +627,7 @@ static int ipdbg_start(uint16_t port, struct jtag_tap *tap, uint32_t user_instru
 
 	char port_str_buffer[IPDBG_TCP_PORT_STR_MAX_LENGTH];
 	snprintf(port_str_buffer, IPDBG_TCP_PORT_STR_MAX_LENGTH, "%u", port);
-	retval = add_service("ipdbg", port_str_buffer, 1, &ipdbg_on_new_connection,
-		&ipdbg_on_connection_input, &ipdbg_on_connection_closed, service);
+	retval = add_service(&ipdbg_service_driver, port_str_buffer, 1, service);
 	if (retval == ERROR_OK) {
 		ipdbg_add_service(service);
 		if (hub->active_services == 0 && hub->active_connections == 0)
diff --git a/src/server/rtt_server.c b/src/server/rtt_server.c
index d49e4d000..3850c2687 100644
--- a/src/server/rtt_server.c
+++ b/src/server/rtt_server.c
@@ -15,6 +15,10 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include <stdint.h>
 #include <rtt/rtt.h>
 
@@ -110,6 +114,15 @@ static int rtt_input(struct connection *connection)
 	return ERROR_OK;
 }
 
+static const struct service_driver rtt_service_driver = {
+	.name = "rtt",
+	.new_connection_during_keep_alive_handler = NULL,
+	.new_connection_handler = rtt_new_connection,
+	.input_handler = rtt_input,
+	.connection_closed_handler = rtt_connection_closed,
+	.keep_client_alive_handler = NULL,
+};
+
 COMMAND_HANDLER(handle_rtt_start_command)
 {
 	int ret;
@@ -125,8 +138,7 @@ COMMAND_HANDLER(handle_rtt_start_command)
 
 	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[1], service->channel);
 
-	ret = add_service("rtt", CMD_ARGV[0], CONNECTION_LIMIT_UNLIMITED,
-		rtt_new_connection, rtt_input, rtt_connection_closed, service);
+	ret = add_service(&rtt_service_driver, CMD_ARGV[0], CONNECTION_LIMIT_UNLIMITED, service);
 
 	if (ret != ERROR_OK) {
 		free(service);
diff --git a/src/server/server.c b/src/server/server.c
index 3f579bfc6..dd408048c 100644
--- a/src/server/server.c
+++ b/src/server/server.c
@@ -205,13 +205,8 @@ static void free_service(struct service *c)
 	free(c);
 }
 
-int add_service(char *name,
-	const char *port,
-	int max_connections,
-	new_connection_handler_t new_connection_handler,
-	input_handler_t input_handler,
-	connection_closed_handler_t connection_closed_handler,
-	void *priv)
+int add_service(const struct service_driver *driver, const char *port,
+		int max_connections, void *priv)
 {
 	struct service *c, **p;
 	struct hostent *hp;
@@ -219,14 +214,16 @@ int add_service(char *name,
 
 	c = malloc(sizeof(struct service));
 
-	c->name = strdup(name);
+	c->name = strdup(driver->name);
 	c->port = strdup(port);
 	c->max_connections = 1;	/* Only TCP/IP ports can support more than one connection */
 	c->fd = -1;
 	c->connections = NULL;
-	c->new_connection = new_connection_handler;
-	c->input = input_handler;
-	c->connection_closed = connection_closed_handler;
+	c->new_connection_during_keep_alive = driver->new_connection_during_keep_alive_handler;
+	c->new_connection = driver->new_connection_handler;
+	c->input = driver->input_handler;
+	c->connection_closed = driver->connection_closed_handler;
+	c->keep_client_alive = driver->keep_client_alive_handler;
 	c->priv = priv;
 	c->next = NULL;
 	long portnumber;
@@ -278,7 +275,7 @@ int add_service(char *name,
 		c->sin.sin_port = htons(c->portnumber);
 
 		if (bind(c->fd, (struct sockaddr *)&c->sin, sizeof(c->sin)) == -1) {
-			LOG_ERROR("couldn't bind %s to socket on port %d: %s", name, c->portnumber, strerror(errno));
+			LOG_ERROR("couldn't bind %s to socket on port %d: %s", c->name, c->portnumber, strerror(errno));
 			close_socket(c->fd);
 			free_service(c);
 			return ERROR_FAIL;
@@ -309,7 +306,7 @@ int add_service(char *name,
 		socklen_t addr_in_size = sizeof(addr_in);
 		if (getsockname(c->fd, (struct sockaddr *)&addr_in, &addr_in_size) == 0)
 			LOG_INFO("Listening on port %hu for %s connections",
-				 ntohs(addr_in.sin_port), name);
+				 ntohs(addr_in.sin_port), c->name);
 	} else if (c->type == CONNECTION_STDINOUT) {
 		c->fd = fileno(stdin);
 
@@ -424,6 +421,14 @@ static int remove_services(void)
 	return ERROR_OK;
 }
 
+void server_keep_clients_alive(void)
+{
+	for (struct service *s = services; s; s = s->next)
+		if (s->keep_client_alive)
+			for (struct connection *c = s->connections; c; c = c->next)
+				s->keep_client_alive(c);
+}
+
 int server_loop(struct command_context *command_context)
 {
 	struct service *service;
@@ -487,10 +492,7 @@ int server_loop(struct command_context *command_context)
 				timeout_ms = polling_period;
 			tv.tv_usec = timeout_ms * 1000;
 			/* Only while we're sleeping we'll let others run */
-			openocd_sleep_prelude();
-			kept_alive();
 			retval = socket_select(fd_max + 1, &read_fds, NULL, NULL, &tv);
-			openocd_sleep_postlude();
 		}
 
 		if (retval == -1) {
diff --git a/src/server/server.h b/src/server/server.h
index de18d2b4b..a6b1963a6 100644
--- a/src/server/server.h
+++ b/src/server/server.h
@@ -55,9 +55,25 @@ struct connection {
 	struct connection *next;
 };
 
-typedef int (*new_connection_handler_t)(struct connection *connection);
-typedef int (*input_handler_t)(struct connection *connection);
-typedef int (*connection_closed_handler_t)(struct connection *connection);
+struct service_driver {
+	/** the name of the server */
+	const char *name;
+	/** optional minimal setup to accept a connection during keep-alive */
+	int (*new_connection_during_keep_alive_handler)(struct connection *connection);
+	/**
+	 * complete code to accept a new connection.
+	 * If 'new_connection_during_keep_alive_handler' above is present, this can be
+	 * either called alone during the server_loop, or after the function above.
+	 * Check the implementation in gdb_server.
+	 * */
+	int (*new_connection_handler)(struct connection *connection);
+	/** callback to handle incoming data */
+	int (*input_handler)(struct connection *connection);
+	/** callback to tear down the connection */
+	int (*connection_closed_handler)(struct connection *connection);
+	/** called periodically to send keep-alive messages on the connection */
+	void (*keep_client_alive_handler)(struct connection *connection);
+};
 
 struct service {
 	char *name;
@@ -68,17 +84,17 @@ struct service {
 	struct sockaddr_in sin;
 	int max_connections;
 	struct connection *connections;
-	new_connection_handler_t new_connection;
-	input_handler_t input;
-	connection_closed_handler_t connection_closed;
+	int (*new_connection_during_keep_alive)(struct connection *connection);
+	int (*new_connection)(struct connection *connection);
+	int (*input)(struct connection *connection);
+	int (*connection_closed)(struct connection *connection);
+	void (*keep_client_alive)(struct connection *connection);
 	void *priv;
 	struct service *next;
 };
 
-int add_service(char *name, const char *port,
-		int max_connections, new_connection_handler_t new_connection_handler,
-		input_handler_t in_handler, connection_closed_handler_t close_handler,
-		void *priv);
+int add_service(const struct service_driver *driver, const char *port,
+		int max_connections, void *priv);
 int remove_service(const char *name, const char *port);
 
 int server_host_os_entry(void);
@@ -90,6 +106,8 @@ int server_quit(void);
 void server_free(void);
 void exit_on_signal(int sig);
 
+void server_keep_clients_alive(void);
+
 int server_loop(struct command_context *command_context);
 
 int server_register_commands(struct command_context *context);
@@ -97,15 +115,6 @@ int server_register_commands(struct command_context *context);
 int connection_write(struct connection *connection, const void *data, int len);
 int connection_read(struct connection *connection, void *data, int len);
 
-/**
- * Used by server_loop(), defined in server_stubs.c
- */
-void openocd_sleep_prelude(void);
-/**
- * Used by server_loop(), defined in server_stubs.c
- */
-void openocd_sleep_postlude(void);
-
 /**
  * Defines an extended command handler function declaration to enable
  * access to (and manipulation of) the server port number.
diff --git a/src/server/server_stubs.c b/src/server/server_stubs.c
deleted file mode 100644
index a4c017289..000000000
--- a/src/server/server_stubs.c
+++ /dev/null
@@ -1,30 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2009 Zachary T Welch <zw@superlucidity.net>             *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
- ***************************************************************************/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-#include "server.h"
-
-void openocd_sleep_prelude(void)
-{
-	/* no-op */
-}
-void openocd_sleep_postlude(void)
-{
-	/* no-op */
-}
diff --git a/src/server/tcl_server.c b/src/server/tcl_server.c
index e08823224..458d7eada 100644
--- a/src/server/tcl_server.c
+++ b/src/server/tcl_server.c
@@ -276,6 +276,15 @@ static int tcl_closed(struct connection *connection)
 	return ERROR_OK;
 }
 
+static const struct service_driver tcl_service_driver = {
+	.name = "tcl",
+	.new_connection_during_keep_alive_handler = NULL,
+	.new_connection_handler = tcl_new_connection,
+	.input_handler = tcl_input,
+	.connection_closed_handler = tcl_closed,
+	.keep_client_alive_handler = NULL,
+};
+
 int tcl_init(void)
 {
 	if (strcmp(tcl_port, "disabled") == 0) {
@@ -283,9 +292,7 @@ int tcl_init(void)
 		return ERROR_OK;
 	}
 
-	return add_service("tcl", tcl_port, CONNECTION_LIMIT_UNLIMITED,
-		&tcl_new_connection, &tcl_input,
-		&tcl_closed, NULL);
+	return add_service(&tcl_service_driver, tcl_port, CONNECTION_LIMIT_UNLIMITED, NULL);
 }
 
 COMMAND_HANDLER(handle_tcl_port_command)
diff --git a/src/server/telnet_server.c b/src/server/telnet_server.c
index 2ebcff163..791a1a548 100644
--- a/src/server/telnet_server.c
+++ b/src/server/telnet_server.c
@@ -946,6 +946,15 @@ static int telnet_connection_closed(struct connection *connection)
 	return ERROR_OK;
 }
 
+static const struct service_driver telnet_service_driver = {
+	.name = "telnet",
+	.new_connection_during_keep_alive_handler = NULL,
+	.new_connection_handler = telnet_new_connection,
+	.input_handler = telnet_input,
+	.connection_closed_handler = telnet_connection_closed,
+	.keep_client_alive_handler = NULL,
+};
+
 int telnet_init(char *banner)
 {
 	if (strcmp(telnet_port, "disabled") == 0) {
@@ -963,8 +972,7 @@ int telnet_init(char *banner)
 
 	telnet_service->banner = banner;
 
-	int ret = add_service("telnet", telnet_port, CONNECTION_LIMIT_UNLIMITED,
-		telnet_new_connection, telnet_input, telnet_connection_closed,
+	int ret = add_service(&telnet_service_driver, telnet_port, CONNECTION_LIMIT_UNLIMITED,
 		telnet_service);
 
 	if (ret != ERROR_OK) {
diff --git a/src/target/a64_disassembler.c b/src/target/a64_disassembler.c
index bd78129dd..58ddf603e 100644
--- a/src/target/a64_disassembler.c
+++ b/src/target/a64_disassembler.c
@@ -26,7 +26,7 @@
 
 #if HAVE_CAPSTONE
 
-#include <capstone/capstone.h>
+#include <capstone.h>
 
 static void print_opcode(struct command_invocation *cmd, const cs_insn *insn)
 {
diff --git a/src/target/aarch64.c b/src/target/aarch64.c
index fc6bd6b30..14cdb98a0 100644
--- a/src/target/aarch64.c
+++ b/src/target/aarch64.c
@@ -102,6 +102,7 @@ static int aarch64_restore_system_control_reg(struct target *target)
 		case ARM_MODE_FIQ:
 		case ARM_MODE_IRQ:
 		case ARM_MODE_HYP:
+		case ARM_MODE_UND:
 		case ARM_MODE_SYS:
 			instr = ARMV4_5_MCR(15, 0, 0, 1, 0, 0);
 			break;
@@ -180,6 +181,7 @@ static int aarch64_mmu_modify(struct target *target, int enable)
 	case ARM_MODE_FIQ:
 	case ARM_MODE_IRQ:
 	case ARM_MODE_HYP:
+	case ARM_MODE_UND:
 	case ARM_MODE_SYS:
 		instr = ARMV4_5_MCR(15, 0, 0, 1, 0, 0);
 		break;
@@ -331,15 +333,14 @@ static int aarch64_wait_halt_one(struct target *target)
 static int aarch64_prepare_halt_smp(struct target *target, bool exc_target, struct target **p_first)
 {
 	int retval = ERROR_OK;
-	struct target_list *head = target->head;
+	struct target_list *head;
 	struct target *first = NULL;
 
 	LOG_DEBUG("target %s exc %i", target_name(target), exc_target);
 
-	while (head) {
+	foreach_smp_target(head, target->smp_targets) {
 		struct target *curr = head->target;
 		struct armv8_common *armv8 = target_to_armv8(curr);
-		head = head->next;
 
 		if (exc_target && curr == target)
 			continue;
@@ -428,7 +429,7 @@ static int aarch64_halt_smp(struct target *target, bool exc_target)
 		struct target_list *head;
 		struct target *curr;
 
-		foreach_smp_target(head, target->head) {
+		foreach_smp_target(head, target->smp_targets) {
 			int halted;
 
 			curr = head->target;
@@ -478,7 +479,7 @@ static int update_halt_gdb(struct target *target, enum target_debug_reason debug
 	}
 
 	/* poll all targets in the group, but skip the target that serves GDB */
-	foreach_smp_target(head, target->head) {
+	foreach_smp_target(head, target->smp_targets) {
 		curr = head->target;
 		/* skip calling context */
 		if (curr == target)
@@ -743,7 +744,7 @@ static int aarch64_prep_restart_smp(struct target *target, int handle_breakpoint
 	struct target *first = NULL;
 	uint64_t address;
 
-	foreach_smp_target(head, target->head) {
+	foreach_smp_target(head, target->smp_targets) {
 		struct target *curr = head->target;
 
 		/* skip calling target */
@@ -798,7 +799,7 @@ static int aarch64_step_restart_smp(struct target *target)
 		struct target *curr = target;
 		bool all_resumed = true;
 
-		foreach_smp_target(head, target->head) {
+		foreach_smp_target(head, target->smp_targets) {
 			uint32_t prsr;
 			int resumed;
 
@@ -886,7 +887,7 @@ static int aarch64_resume(struct target *target, int current,
 			struct target_list *head;
 			bool all_resumed = true;
 
-			foreach_smp_target(head, target->head) {
+			foreach_smp_target(head, target->smp_targets) {
 				uint32_t prsr;
 				int resumed;
 
@@ -1049,6 +1050,7 @@ static int aarch64_post_debug_entry(struct target *target)
 	case ARM_MODE_FIQ:
 	case ARM_MODE_IRQ:
 	case ARM_MODE_HYP:
+	case ARM_MODE_UND:
 	case ARM_MODE_SYS:
 		instr = ARMV4_5_MRC(15, 0, 0, 1, 0, 0);
 		break;
@@ -1234,7 +1236,7 @@ static int aarch64_set_breakpoint(struct target *target,
 	struct armv8_common *armv8 = &aarch64->armv8_common;
 	struct aarch64_brp *brp_list = aarch64->brp_list;
 
-	if (breakpoint->set) {
+	if (breakpoint->is_set) {
 		LOG_WARNING("breakpoint already set");
 		return ERROR_OK;
 	}
@@ -1247,7 +1249,7 @@ static int aarch64_set_breakpoint(struct target *target,
 			LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
-		breakpoint->set = brp_i + 1;
+		breakpoint_hw_set(breakpoint, brp_i);
 		if (breakpoint->length == 2)
 			byte_addr_select = (3 << (breakpoint->address & 0x02));
 		control = ((matchmode & 0x7) << 20)
@@ -1331,7 +1333,7 @@ static int aarch64_set_breakpoint(struct target *target,
 				breakpoint->address & 0xFFFFFFFFFFFFFFFE,
 				breakpoint->length);
 
-		breakpoint->set = 0x11;	/* Any nice value but 0 */
+		breakpoint->is_set = true;
 	}
 
 	/* Ensure that halting debug mode is enable */
@@ -1355,7 +1357,7 @@ static int aarch64_set_context_breakpoint(struct target *target,
 	struct armv8_common *armv8 = &aarch64->armv8_common;
 	struct aarch64_brp *brp_list = aarch64->brp_list;
 
-	if (breakpoint->set) {
+	if (breakpoint->is_set) {
 		LOG_WARNING("breakpoint already set");
 		return retval;
 	}
@@ -1369,7 +1371,7 @@ static int aarch64_set_context_breakpoint(struct target *target,
 		return ERROR_FAIL;
 	}
 
-	breakpoint->set = brp_i + 1;
+	breakpoint_hw_set(breakpoint, brp_i);
 	control = ((matchmode & 0x7) << 20)
 		| (1 << 13)
 		| (byte_addr_select << 5)
@@ -1408,7 +1410,7 @@ static int aarch64_set_hybrid_breakpoint(struct target *target, struct breakpoin
 	struct armv8_common *armv8 = &aarch64->armv8_common;
 	struct aarch64_brp *brp_list = aarch64->brp_list;
 
-	if (breakpoint->set) {
+	if (breakpoint->is_set) {
 		LOG_WARNING("breakpoint already set");
 		return retval;
 	}
@@ -1433,7 +1435,7 @@ static int aarch64_set_hybrid_breakpoint(struct target *target, struct breakpoin
 		return ERROR_FAIL;
 	}
 
-	breakpoint->set = brp_1 + 1;
+	breakpoint_hw_set(breakpoint, brp_1);
 	breakpoint->linked_brp = brp_2;
 	control_ctx = ((ctx_machmode & 0x7) << 20)
 		| (brp_2 << 16)
@@ -1488,16 +1490,16 @@ static int aarch64_unset_breakpoint(struct target *target, struct breakpoint *br
 	struct armv8_common *armv8 = &aarch64->armv8_common;
 	struct aarch64_brp *brp_list = aarch64->brp_list;
 
-	if (!breakpoint->set) {
+	if (!breakpoint->is_set) {
 		LOG_WARNING("breakpoint not set");
 		return ERROR_OK;
 	}
 
 	if (breakpoint->type == BKPT_HARD) {
 		if ((breakpoint->address != 0) && (breakpoint->asid != 0)) {
-			int brp_i = breakpoint->set - 1;
+			int brp_i = breakpoint->number;
 			int brp_j = breakpoint->linked_brp;
-			if ((brp_i < 0) || (brp_i >= aarch64->brp_num)) {
+			if (brp_i >= aarch64->brp_num) {
 				LOG_DEBUG("Invalid BRP number in breakpoint");
 				return ERROR_OK;
 			}
@@ -1547,12 +1549,12 @@ static int aarch64_unset_breakpoint(struct target *target, struct breakpoint *br
 				return retval;
 
 			breakpoint->linked_brp = 0;
-			breakpoint->set = 0;
+			breakpoint->is_set = false;
 			return ERROR_OK;
 
 		} else {
-			int brp_i = breakpoint->set - 1;
-			if ((brp_i < 0) || (brp_i >= aarch64->brp_num)) {
+			int brp_i = breakpoint->number;
+			if (brp_i >= aarch64->brp_num) {
 				LOG_DEBUG("Invalid BRP number in breakpoint");
 				return ERROR_OK;
 			}
@@ -1577,7 +1579,7 @@ static int aarch64_unset_breakpoint(struct target *target, struct breakpoint *br
 					(uint32_t)brp_list[brp_i].value);
 			if (retval != ERROR_OK)
 				return retval;
-			breakpoint->set = 0;
+			breakpoint->is_set = false;
 			return ERROR_OK;
 		}
 	} else {
@@ -1609,7 +1611,7 @@ static int aarch64_unset_breakpoint(struct target *target, struct breakpoint *br
 				breakpoint->address & 0xFFFFFFFFFFFFFFFE,
 				breakpoint->length);
 	}
-	breakpoint->set = 0;
+	breakpoint->is_set = false;
 
 	return ERROR_OK;
 }
@@ -1674,7 +1676,7 @@ static int aarch64_remove_breakpoint(struct target *target, struct breakpoint *b
 	}
 #endif
 
-	if (breakpoint->set) {
+	if (breakpoint->is_set) {
 		aarch64_unset_breakpoint(target, breakpoint);
 		if (breakpoint->type == BKPT_HARD)
 			aarch64->brp_num_available++;
@@ -1694,7 +1696,7 @@ static int aarch64_set_watchpoint(struct target *target,
 	struct armv8_common *armv8 = &aarch64->armv8_common;
 	struct aarch64_brp *wp_list = aarch64->wp_list;
 
-	if (watchpoint->set) {
+	if (watchpoint->is_set) {
 		LOG_WARNING("watchpoint already set");
 		return ERROR_OK;
 	}
@@ -1762,7 +1764,7 @@ static int aarch64_set_watchpoint(struct target *target,
 	}
 
 	wp_list[wp_i].used = 1;
-	watchpoint->set = wp_i + 1;
+	watchpoint_set(watchpoint, wp_i);
 
 	return ERROR_OK;
 }
@@ -1771,18 +1773,18 @@ static int aarch64_set_watchpoint(struct target *target,
 static int aarch64_unset_watchpoint(struct target *target,
 	struct watchpoint *watchpoint)
 {
-	int retval, wp_i;
+	int retval;
 	struct aarch64_common *aarch64 = target_to_aarch64(target);
 	struct armv8_common *armv8 = &aarch64->armv8_common;
 	struct aarch64_brp *wp_list = aarch64->wp_list;
 
-	if (!watchpoint->set) {
+	if (!watchpoint->is_set) {
 		LOG_WARNING("watchpoint not set");
 		return ERROR_OK;
 	}
 
-	wp_i = watchpoint->set - 1;
-	if ((wp_i < 0) || (wp_i >= aarch64->wp_num)) {
+	int wp_i = watchpoint->number;
+	if (wp_i >= aarch64->wp_num) {
 		LOG_DEBUG("Invalid WP number in watchpoint");
 		return ERROR_OK;
 	}
@@ -1807,7 +1809,7 @@ static int aarch64_unset_watchpoint(struct target *target,
 			(uint32_t)wp_list[wp_i].value);
 	if (retval != ERROR_OK)
 		return retval;
-	watchpoint->set = 0;
+	watchpoint->is_set = false;
 
 	return ERROR_OK;
 }
@@ -1835,7 +1837,7 @@ static int aarch64_remove_watchpoint(struct target *target,
 {
 	struct aarch64_common *aarch64 = target_to_aarch64(target);
 
-	if (watchpoint->set) {
+	if (watchpoint->is_set) {
 		aarch64_unset_watchpoint(target, watchpoint);
 		aarch64->wp_num_available++;
 	}
@@ -1940,7 +1942,7 @@ static int aarch64_assert_reset(struct target *target)
 	else if (reset_config & RESET_HAS_SRST) {
 		bool srst_asserted = false;
 
-		if (target->reset_halt) {
+		if (target->reset_halt && !(reset_config & RESET_SRST_PULLS_TRST)) {
 			if (target_was_examined(target)) {
 
 				if (reset_config & RESET_SRST_NO_GATING) {
@@ -1950,12 +1952,12 @@ static int aarch64_assert_reset(struct target *target)
 					 */
 					adapter_assert_reset();
 					srst_asserted = true;
-
-					/* make sure to clear all sticky errors */
-					mem_ap_write_atomic_u32(armv8->debug_ap,
-							armv8->debug_base + CPUV8_DBG_DRCR, DRCR_CSE);
 				}
 
+				/* make sure to clear all sticky errors */
+				mem_ap_write_atomic_u32(armv8->debug_ap,
+						armv8->debug_base + CPUV8_DBG_DRCR, DRCR_CSE);
+
 				/* set up Reset Catch debug event to halt the CPU after reset */
 				retval = aarch64_enable_reset_catch(target, true);
 				if (retval != ERROR_OK)
@@ -2024,9 +2026,13 @@ static int aarch64_deassert_reset(struct target *target)
 		if (target->state != TARGET_HALTED) {
 			LOG_WARNING("%s: ran after reset and before halt ...",
 				target_name(target));
-			retval = target_halt(target);
-			if (retval != ERROR_OK)
-				return retval;
+			if (target_was_examined(target)) {
+				retval = aarch64_halt_one(target, HALT_LAZY);
+				if (retval != ERROR_OK)
+					return retval;
+			} else {
+				target->state = TARGET_UNKNOWN;
+			}
 		}
 	}
 
@@ -2635,8 +2641,10 @@ static int aarch64_examine_first(struct target *target)
 	LOG_DEBUG("ttypr = 0x%08" PRIx64, ttypr);
 	LOG_DEBUG("debug = 0x%08" PRIx64, debug);
 
-	if (!pc->cti)
+	if (!pc->cti) {
+		LOG_TARGET_ERROR(target, "CTI not specified");
 		return ERROR_FAIL;
+	}
 
 	armv8->cti = pc->cti;
 
diff --git a/src/target/arc.c b/src/target/arc.c
index 4b546c3b4..471f16a98 100644
--- a/src/target/arc.c
+++ b/src/target/arc.c
@@ -1500,7 +1500,7 @@ static int arc_configure_actionpoint(struct target *target, uint32_t ap_num,
 static int arc_set_breakpoint(struct target *target,
 		struct breakpoint *breakpoint)
 {
-	if (breakpoint->set) {
+	if (breakpoint->is_set) {
 		LOG_WARNING("breakpoint already set");
 		return ERROR_OK;
 	}
@@ -1542,7 +1542,7 @@ static int arc_set_breakpoint(struct target *target,
 			return ERROR_COMMAND_ARGUMENT_INVALID;
 		}
 
-		breakpoint->set = 64; /* Any nice value but 0 */
+		breakpoint->is_set = true;
 	} else if (breakpoint->type == BKPT_HARD) {
 		struct arc_common *arc = target_to_arc(target);
 		struct arc_actionpoint *ap_list = arc->actionpoints_list;
@@ -1563,7 +1563,7 @@ static int arc_set_breakpoint(struct target *target,
 				breakpoint->address, AP_AC_TT_READWRITE, AP_AC_AT_INST_ADDR);
 
 		if (retval == ERROR_OK) {
-			breakpoint->set = bp_num + 1;
+			breakpoint_hw_set(breakpoint, bp_num);
 			ap_list[bp_num].used = 1;
 			ap_list[bp_num].bp_value = breakpoint->address;
 			ap_list[bp_num].type = ARC_AP_BREAKPOINT;
@@ -1588,7 +1588,7 @@ static int arc_unset_breakpoint(struct target *target,
 {
 	int retval = ERROR_OK;
 
-	if (!breakpoint->set) {
+	if (!breakpoint->is_set) {
 		LOG_WARNING("breakpoint not set");
 		return ERROR_OK;
 	}
@@ -1633,14 +1633,14 @@ static int arc_unset_breakpoint(struct target *target,
 			LOG_ERROR("Invalid breakpoint length: target supports only 2 or 4");
 			return ERROR_COMMAND_ARGUMENT_INVALID;
 		}
-		breakpoint->set = 0;
+		breakpoint->is_set = false;
 
 	}	else if (breakpoint->type == BKPT_HARD) {
 		struct arc_common *arc = target_to_arc(target);
 		struct arc_actionpoint *ap_list = arc->actionpoints_list;
-		unsigned int bp_num = breakpoint->set - 1;
+		unsigned int bp_num = breakpoint->number;
 
-		if ((breakpoint->set == 0) || (bp_num >= arc->actionpoints_num)) {
+		if (bp_num >= arc->actionpoints_num) {
 			LOG_DEBUG("Invalid actionpoint ID: %u in breakpoint: %" PRIu32,
 					  bp_num, breakpoint->unique_id);
 			return ERROR_OK;
@@ -1650,11 +1650,11 @@ static int arc_unset_breakpoint(struct target *target,
 						breakpoint->address, AP_AC_TT_DISABLE, AP_AC_AT_INST_ADDR);
 
 		if (retval == ERROR_OK) {
-			breakpoint->set = 0;
+			breakpoint->is_set = false;
 			ap_list[bp_num].used = 0;
 			ap_list[bp_num].bp_value = 0;
 
-			LOG_DEBUG("bpid: %" PRIu32 " - released actionpoint ID: %i",
+			LOG_DEBUG("bpid: %" PRIu32 " - released actionpoint ID: %u",
 					breakpoint->unique_id, bp_num);
 		}
 	} else {
@@ -1684,7 +1684,7 @@ static int arc_remove_breakpoint(struct target *target,
 	struct breakpoint *breakpoint)
 {
 	if (target->state == TARGET_HALTED) {
-		if (breakpoint->set)
+		if (breakpoint->is_set)
 			CHECK_RETVAL(arc_unset_breakpoint(target, breakpoint));
 	} else {
 		LOG_WARNING("target not halted");
@@ -1818,7 +1818,7 @@ static int arc_set_watchpoint(struct target *target,
 	struct arc_common *arc = target_to_arc(target);
 	struct arc_actionpoint *ap_list = arc->actionpoints_list;
 
-	if (watchpoint->set) {
+	if (watchpoint->is_set) {
 		LOG_WARNING("watchpoint already set");
 		return ERROR_OK;
 	}
@@ -1859,7 +1859,7 @@ static int arc_set_watchpoint(struct target *target,
 					watchpoint->address, enable, AP_AC_AT_MEMORY_ADDR);
 
 	if (retval == ERROR_OK) {
-		watchpoint->set = wp_num + 1;
+		watchpoint_set(watchpoint, wp_num);
 		ap_list[wp_num].used = 1;
 		ap_list[wp_num].bp_value = watchpoint->address;
 		ap_list[wp_num].type = ARC_AP_WATCHPOINT;
@@ -1878,13 +1878,13 @@ static int arc_unset_watchpoint(struct target *target,
 	struct arc_common *arc = target_to_arc(target);
 	struct arc_actionpoint *ap_list = arc->actionpoints_list;
 
-	if (!watchpoint->set) {
+	if (!watchpoint->is_set) {
 		LOG_WARNING("watchpoint not set");
 		return ERROR_OK;
 	}
 
-	unsigned int wp_num = watchpoint->set - 1;
-	if ((watchpoint->set == 0) || (wp_num >= arc->actionpoints_num)) {
+	unsigned int wp_num = watchpoint->number;
+	if (wp_num >= arc->actionpoints_num) {
 		LOG_DEBUG("Invalid actionpoint ID: %u in watchpoint: %" PRIu32,
 				wp_num, watchpoint->unique_id);
 		return ERROR_OK;
@@ -1894,7 +1894,7 @@ static int arc_unset_watchpoint(struct target *target,
 				watchpoint->address, AP_AC_TT_DISABLE, AP_AC_AT_MEMORY_ADDR);
 
 	if (retval == ERROR_OK) {
-		watchpoint->set = 0;
+		watchpoint->is_set = false;
 		ap_list[wp_num].used = 0;
 		ap_list[wp_num].bp_value = 0;
 
@@ -1926,7 +1926,7 @@ static int arc_remove_watchpoint(struct target *target,
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if (watchpoint->set)
+	if (watchpoint->is_set)
 		CHECK_RETVAL(arc_unset_watchpoint(target, watchpoint));
 
 	return ERROR_OK;
@@ -1953,8 +1953,8 @@ static int arc_hit_watchpoint(struct target *target, struct watchpoint **hit_wat
 				watchpoint = watchpoint->next) {
 			if (actionpoint->bp_value == watchpoint->address) {
 				*hit_watchpoint = watchpoint;
-				LOG_DEBUG("Hit watchpoint, wpid: %" PRIu32 ", watchpoint num: %i",
-							watchpoint->unique_id, watchpoint->set - 1);
+				LOG_DEBUG("Hit watchpoint, wpid: %" PRIu32 ", watchpoint num: %u",
+							watchpoint->unique_id, watchpoint->number);
 				return ERROR_OK;
 			}
 		}
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index cf77a81a7..da047c3d0 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -93,19 +93,20 @@ static void arm7_9_assign_wp(struct arm7_9_common *arm7_9, struct breakpoint *br
 {
 	if (!arm7_9->wp0_used) {
 		arm7_9->wp0_used = 1;
-		breakpoint->set = 1;
+		breakpoint_hw_set(breakpoint, 0);
 		arm7_9->wp_available--;
 	} else if (!arm7_9->wp1_used) {
 		arm7_9->wp1_used = 1;
-		breakpoint->set = 2;
+		breakpoint_hw_set(breakpoint, 1);
 		arm7_9->wp_available--;
-	} else
+	} else {
 		LOG_ERROR("BUG: no hardware comparator available");
+	}
 
-	LOG_DEBUG("BPID: %" PRIu32 " (0x%08" TARGET_PRIxADDR ") using hw wp: %d",
+	LOG_DEBUG("BPID: %" PRIu32 " (0x%08" TARGET_PRIxADDR ") using hw wp: %u",
 			breakpoint->unique_id,
 			breakpoint->address,
-			breakpoint->set);
+			breakpoint->number);
 }
 
 /**
@@ -203,16 +204,16 @@ static int arm7_9_set_breakpoint(struct target *target, struct breakpoint *break
 		uint32_t mask = (breakpoint->length == 4) ? 0x3u : 0x1u;
 
 		/* reassign a hw breakpoint */
-		if (breakpoint->set == 0)
+		if (!breakpoint->is_set)
 			arm7_9_assign_wp(arm7_9, breakpoint);
 
-		if (breakpoint->set == 1) {
+		if (breakpoint->number == 0) {
 			embeddedice_set_reg(&arm7_9->eice_cache->reg_list[EICE_W0_ADDR_VALUE], breakpoint->address);
 			embeddedice_set_reg(&arm7_9->eice_cache->reg_list[EICE_W0_ADDR_MASK], mask);
 			embeddedice_set_reg(&arm7_9->eice_cache->reg_list[EICE_W0_DATA_MASK], 0xffffffffu);
 			embeddedice_set_reg(&arm7_9->eice_cache->reg_list[EICE_W0_CONTROL_MASK], ~EICE_W_CTRL_NOPC & 0xff);
 			embeddedice_set_reg(&arm7_9->eice_cache->reg_list[EICE_W0_CONTROL_VALUE], EICE_W_CTRL_ENABLE);
-		} else if (breakpoint->set == 2) {
+		} else if (breakpoint->number == 1) {
 			embeddedice_set_reg(&arm7_9->eice_cache->reg_list[EICE_W1_ADDR_VALUE], breakpoint->address);
 			embeddedice_set_reg(&arm7_9->eice_cache->reg_list[EICE_W1_ADDR_MASK], mask);
 			embeddedice_set_reg(&arm7_9->eice_cache->reg_list[EICE_W1_DATA_MASK], 0xffffffffu);
@@ -226,7 +227,7 @@ static int arm7_9_set_breakpoint(struct target *target, struct breakpoint *break
 		retval = jtag_execute_queue();
 	} else if (breakpoint->type == BKPT_SOFT) {
 		/* did we already set this breakpoint? */
-		if (breakpoint->set)
+		if (breakpoint->is_set)
 			return ERROR_OK;
 
 		if (breakpoint->length == 4) {
@@ -277,7 +278,7 @@ static int arm7_9_set_breakpoint(struct target *target, struct breakpoint *break
 
 		arm7_9->sw_breakpoint_count++;
 
-		breakpoint->set = 1;
+		breakpoint->is_set = true;
 	}
 
 	return retval;
@@ -304,7 +305,7 @@ static int arm7_9_unset_breakpoint(struct target *target, struct breakpoint *bre
 		breakpoint->unique_id,
 		breakpoint->address);
 
-	if (!breakpoint->set) {
+	if (!breakpoint->is_set) {
 		LOG_WARNING("breakpoint not set");
 		return ERROR_OK;
 	}
@@ -312,18 +313,18 @@ static int arm7_9_unset_breakpoint(struct target *target, struct breakpoint *bre
 	if (breakpoint->type == BKPT_HARD) {
 		LOG_DEBUG("BPID: %" PRIu32 " Releasing hw wp: %d",
 			breakpoint->unique_id,
-			breakpoint->set);
-		if (breakpoint->set == 1) {
+			breakpoint->is_set);
+		if (breakpoint->number == 0) {
 			embeddedice_set_reg(&arm7_9->eice_cache->reg_list[EICE_W0_CONTROL_VALUE], 0x0);
 			arm7_9->wp0_used = 0;
 			arm7_9->wp_available++;
-		} else if (breakpoint->set == 2) {
+		} else if (breakpoint->number == 1) {
 			embeddedice_set_reg(&arm7_9->eice_cache->reg_list[EICE_W1_CONTROL_VALUE], 0x0);
 			arm7_9->wp1_used = 0;
 			arm7_9->wp_available++;
 		}
 		retval = jtag_execute_queue();
-		breakpoint->set = 0;
+		breakpoint->is_set = false;
 	} else {
 		/* restore original instruction (kept in target endianness) */
 		if (breakpoint->length == 4) {
@@ -368,7 +369,7 @@ static int arm7_9_unset_breakpoint(struct target *target, struct breakpoint *bre
 						EICE_W1_CONTROL_VALUE], 0);
 		}
 
-		breakpoint->set = 0;
+		breakpoint->is_set = false;
 	}
 
 	return retval;
@@ -491,7 +492,7 @@ static int arm7_9_set_watchpoint(struct target *target, struct watchpoint *watch
 		retval = jtag_execute_queue();
 		if (retval != ERROR_OK)
 			return retval;
-		watchpoint->set = 1;
+		watchpoint_set(watchpoint, 1);
 		arm7_9->wp0_used = 2;
 	} else if (!arm7_9->wp1_used) {
 		embeddedice_set_reg(&arm7_9->eice_cache->reg_list[EICE_W1_ADDR_VALUE],
@@ -510,7 +511,7 @@ static int arm7_9_set_watchpoint(struct target *target, struct watchpoint *watch
 		retval = jtag_execute_queue();
 		if (retval != ERROR_OK)
 			return retval;
-		watchpoint->set = 2;
+		watchpoint_set(watchpoint, 2);
 		arm7_9->wp1_used = 2;
 	} else {
 		LOG_ERROR("BUG: no hardware comparator available");
@@ -538,25 +539,25 @@ static int arm7_9_unset_watchpoint(struct target *target, struct watchpoint *wat
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if (!watchpoint->set) {
+	if (!watchpoint->is_set) {
 		LOG_WARNING("breakpoint not set");
 		return ERROR_OK;
 	}
 
-	if (watchpoint->set == 1) {
+	if (watchpoint->number == 1) {
 		embeddedice_set_reg(&arm7_9->eice_cache->reg_list[EICE_W0_CONTROL_VALUE], 0x0);
 		retval = jtag_execute_queue();
 		if (retval != ERROR_OK)
 			return retval;
 		arm7_9->wp0_used = 0;
-	} else if (watchpoint->set == 2) {
+	} else if (watchpoint->number == 2) {
 		embeddedice_set_reg(&arm7_9->eice_cache->reg_list[EICE_W1_CONTROL_VALUE], 0x0);
 		retval = jtag_execute_queue();
 		if (retval != ERROR_OK)
 			return retval;
 		arm7_9->wp1_used = 0;
 	}
-	watchpoint->set = 0;
+	watchpoint->is_set = false;
 
 	return ERROR_OK;
 }
@@ -597,7 +598,7 @@ int arm7_9_remove_watchpoint(struct target *target, struct watchpoint *watchpoin
 	int retval = ERROR_OK;
 	struct arm7_9_common *arm7_9 = target_to_arm7_9(target);
 
-	if (watchpoint->set) {
+	if (watchpoint->is_set) {
 		retval = arm7_9_unset_watchpoint(target, watchpoint);
 		if (retval != ERROR_OK)
 			return retval;
@@ -1684,7 +1685,7 @@ static void arm7_9_enable_watchpoints(struct target *target)
 	struct watchpoint *watchpoint = target->watchpoints;
 
 	while (watchpoint) {
-		if (watchpoint->set == 0)
+		if (!watchpoint->is_set)
 			arm7_9_set_watchpoint(target, watchpoint);
 		watchpoint = watchpoint->next;
 	}
diff --git a/src/target/arm_cti.c b/src/target/arm_cti.c
index c776e9c2a..96927bf94 100644
--- a/src/target/arm_cti.c
+++ b/src/target/arm_cti.c
@@ -435,8 +435,13 @@ static int cti_configure(struct jim_getopt_info *goi, struct arm_cti *cti)
 	/* parse config or cget options ... */
 	while (goi->argc > 0) {
 		int e = adiv5_jim_mem_ap_spot_configure(&cti->spot, goi);
+
+		if (e == JIM_CONTINUE)
+			Jim_SetResultFormatted(goi->interp, "unknown option '%s'",
+				Jim_String(goi->argv[0]));
+
 		if (e != JIM_OK)
-			return e;
+			return JIM_ERR;
 	}
 
 	if (!cti->spot.dap) {
diff --git a/src/target/arm_disassembler.c b/src/target/arm_disassembler.c
index 661859379..d3d27a93c 100644
--- a/src/target/arm_disassembler.c
+++ b/src/target/arm_disassembler.c
@@ -27,7 +27,7 @@
 #include <helper/log.h>
 
 #if HAVE_CAPSTONE
-#include <capstone/capstone.h>
+#include <capstone.h>
 #endif
 
 /*
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index 3e55e2e3a..e60ef225d 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -398,7 +398,7 @@ fail:
  * or running debugger code.
  */
 static int dpm_maybe_update_bpwp(struct arm_dpm *dpm, bool bpwp,
-	struct dpm_bpwp *xp, int *set_p)
+	struct dpm_bpwp *xp, bool *set_p)
 {
 	int retval = ERROR_OK;
 	bool disable;
@@ -473,7 +473,7 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 			struct breakpoint *bp = dbp->bp;
 
 			retval = dpm_maybe_update_bpwp(dpm, bpwp, &dbp->bpwp,
-					bp ? &bp->set : NULL);
+					bp ? &bp->is_set : NULL);
 			if (retval != ERROR_OK)
 				goto done;
 		}
@@ -485,7 +485,7 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 		struct watchpoint *wp = dwp->wp;
 
 		retval = dpm_maybe_update_bpwp(dpm, bpwp, &dwp->bpwp,
-				wp ? &wp->set : NULL);
+				wp ? &wp->is_set : NULL);
 		if (retval != ERROR_OK)
 			goto done;
 	}
diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
index 792474acf..507d1cd2c 100644
--- a/src/target/arm_semihosting.c
+++ b/src/target/arm_semihosting.c
@@ -367,10 +367,13 @@ int arm_semihosting(struct target *target, int *retval)
 		}
 
 		/* Check for ARM operation numbers. */
-		if (semihosting->op >= 0 && semihosting->op <= 0x31) {
+		if ((semihosting->op >= 0 && semihosting->op <= 0x31) ||
+			(semihosting->op >= 0x100 && semihosting->op <= 0x107)) {
+
 			*retval = semihosting_common(target);
 			if (*retval != ERROR_OK) {
-				LOG_ERROR("Failed semihosting operation (0x%02X)", semihosting->op);
+				LOG_ERROR("Failed semihosting operation (0x%02X)",
+						semihosting->op);
 				return 0;
 			}
 		} else {
diff --git a/src/target/arm_tpiu_swo.c b/src/target/arm_tpiu_swo.c
index 024521364..fba3fec4f 100644
--- a/src/target/arm_tpiu_swo.c
+++ b/src/target/arm_tpiu_swo.c
@@ -582,6 +582,15 @@ static int wrap_read_u32(struct target *target, struct adiv5_ap *tpiu_ap,
 		return mem_ap_read_atomic_u32(tpiu_ap, address, value);
 }
 
+static const struct service_driver arm_tpiu_swo_service_driver = {
+	.name = "tpiu_swo_trace",
+	.new_connection_during_keep_alive_handler = NULL,
+	.new_connection_handler = arm_tpiu_swo_service_new_connection,
+	.input_handler = arm_tpiu_swo_service_input,
+	.connection_closed_handler = arm_tpiu_swo_service_connection_closed,
+	.keep_client_alive_handler = NULL,
+};
+
 static int jim_arm_tpiu_swo_enable(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
 	struct command *c = jim_to_command(interp);
@@ -616,10 +625,8 @@ static int jim_arm_tpiu_swo_enable(Jim_Interp *interp, int argc, Jim_Obj *const
 	}
 
 	if (obj->pin_protocol == TPIU_SPPR_PROTOCOL_MANCHESTER || obj->pin_protocol == TPIU_SPPR_PROTOCOL_UART)
-		if (!obj->swo_pin_freq) {
-			LOG_ERROR("SWO pin frequency not set");
-			return JIM_ERR;
-		}
+		if (!obj->swo_pin_freq)
+			LOG_DEBUG("SWO pin frequency not set, will be autodetected by the adapter");
 
 	struct target *target = get_current_target(cmd_ctx);
 
@@ -700,10 +707,8 @@ static int jim_arm_tpiu_swo_enable(Jim_Interp *interp, int argc, Jim_Obj *const
 			}
 			priv->obj = obj;
 			LOG_INFO("starting trace server for %s on %s", obj->name, &obj->out_filename[1]);
-			retval = add_service("tpiu_swo_trace", &obj->out_filename[1],
-				CONNECTION_LIMIT_UNLIMITED, arm_tpiu_swo_service_new_connection,
-				arm_tpiu_swo_service_input, arm_tpiu_swo_service_connection_closed,
-				priv);
+			retval = add_service(&arm_tpiu_swo_service_driver, &obj->out_filename[1],
+				CONNECTION_LIMIT_UNLIMITED, priv);
 			if (retval != ERROR_OK) {
 				LOG_ERROR("Can't configure trace TCP port %s", &obj->out_filename[1]);
 				return JIM_ERR;
@@ -724,6 +729,17 @@ static int jim_arm_tpiu_swo_enable(Jim_Interp *interp, int argc, Jim_Obj *const
 			return JIM_ERR;
 		}
 
+		if (obj->pin_protocol == TPIU_SPPR_PROTOCOL_MANCHESTER || obj->pin_protocol == TPIU_SPPR_PROTOCOL_UART)
+			if (!swo_pin_freq) {
+				if (obj->swo_pin_freq)
+					LOG_ERROR("Adapter rejected SWO pin frequency %d Hz", obj->swo_pin_freq);
+				else
+					LOG_ERROR("Adapter does not support auto-detection of SWO pin frequency nor a default value");
+
+				arm_tpiu_swo_close_output(obj);
+				return JIM_ERR;
+			}
+
 		if (obj->swo_pin_freq != swo_pin_freq)
 			LOG_INFO("SWO pin data rate adjusted by adapter to %d Hz", swo_pin_freq);
 		obj->swo_pin_freq = swo_pin_freq;
@@ -886,7 +902,8 @@ static int arm_tpiu_swo_create(Jim_Interp *interp, struct arm_tpiu_swo_object *o
 	/* does this command exist? */
 	cmd = Jim_GetCommand(interp, Jim_NewStringObj(interp, obj->name, -1), JIM_NONE);
 	if (cmd) {
-		Jim_SetResultFormatted(interp, "Command: %s Exists", obj->name);
+		Jim_SetResultFormatted(interp, "cannot create TPIU object because a command with name '%s' already exists",
+			obj->name);
 		return JIM_ERR;
 	}
 
@@ -915,7 +932,7 @@ static int jim_arm_tpiu_swo_create(Jim_Interp *interp, int argc, Jim_Obj *const
 	struct jim_getopt_info goi;
 	jim_getopt_setup(&goi, interp, argc - 1, argv + 1);
 	if (goi.argc < 1) {
-		Jim_WrongNumArgs(goi.interp, 1, goi.argv, "?name? ..options...");
+		Jim_WrongNumArgs(interp, 1, argv, "name ?option option ...?");
 		return JIM_ERR;
 	}
 
@@ -1160,7 +1177,7 @@ static const struct command_registration arm_tpiu_swo_subcommand_handlers[] = {
 		.name = "create",
 		.mode = COMMAND_ANY,
 		.jim_handler = jim_arm_tpiu_swo_create,
-		.usage = "name [-dap dap] [-ap-num num] [-address baseaddr]",
+		.usage = "name [-dap dap] [-ap-num num] [-baseaddr baseaddr]",
 		.help = "Creates a new TPIU or SWO object",
 	},
 	{
diff --git a/src/target/armv7a.c b/src/target/armv7a.c
index 2259fa560..d564f19ae 100644
--- a/src/target/armv7a.c
+++ b/src/target/armv7a.c
@@ -38,6 +38,7 @@
 #include "arm_opcodes.h"
 #include "target.h"
 #include "target_type.h"
+#include "smp.h"
 
 static void armv7a_show_fault_registers(struct target *target)
 {
@@ -193,8 +194,7 @@ done:
 static int armv7a_l2x_cache_init(struct target *target, uint32_t base, uint32_t way)
 {
 	struct armv7a_l2x_cache *l2x_cache;
-	struct target_list *head = target->head;
-	struct target *curr;
+	struct target_list *head;
 
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	l2x_cache = calloc(1, sizeof(struct armv7a_l2x_cache));
@@ -207,15 +207,14 @@ static int armv7a_l2x_cache_init(struct target *target, uint32_t base, uint32_t
 	armv7a->armv7a_mmu.armv7a_cache.outer_cache = l2x_cache;
 	/*  initialize all target in this cluster (smp target)
 	 *  l2 cache must be configured after smp declaration */
-	while (head) {
-		curr = head->target;
+	foreach_smp_target(head, target->smp_targets) {
+		struct target *curr = head->target;
 		if (curr != target) {
 			armv7a = target_to_armv7a(curr);
 			if (armv7a->armv7a_mmu.armv7a_cache.outer_cache)
 				LOG_ERROR("smp target : outer cache already initialized\n");
 			armv7a->armv7a_mmu.armv7a_cache.outer_cache = l2x_cache;
 		}
-		head = head->next;
 	}
 	return JIM_OK;
 }
diff --git a/src/target/armv7a_cache.c b/src/target/armv7a_cache.c
index 4078fdde2..ba6f076f0 100644
--- a/src/target/armv7a_cache.c
+++ b/src/target/armv7a_cache.c
@@ -26,6 +26,7 @@
 #include "armv7a_cache.h"
 #include <helper/time_support.h>
 #include "arm_opcodes.h"
+#include "smp.h"
 
 static int armv7a_l1_d_cache_sanity_check(struct target *target)
 {
@@ -138,14 +139,10 @@ int armv7a_cache_auto_flush_all_data(struct target *target)
 
 	if (target->smp) {
 		struct target_list *head;
-		struct target *curr;
-		head = target->head;
-		while (head) {
-			curr = head->target;
+		foreach_smp_target(head, target->smp_targets) {
+			struct target *curr = head->target;
 			if (curr->state == TARGET_HALTED)
 				retval = armv7a_l1_d_cache_clean_inval_all(curr);
-
-			head = head->next;
 		}
 	} else
 		retval = armv7a_l1_d_cache_clean_inval_all(target);
diff --git a/src/target/armv7a_cache_l2x.c b/src/target/armv7a_cache_l2x.c
index 6b42fae53..c26d05173 100644
--- a/src/target/armv7a_cache_l2x.c
+++ b/src/target/armv7a_cache_l2x.c
@@ -27,6 +27,7 @@
 #include <helper/time_support.h>
 #include "target.h"
 #include "target_type.h"
+#include "smp.h"
 
 static int arm7a_l2x_sanity_check(struct target *target)
 {
@@ -194,8 +195,7 @@ static int arm7a_handle_l2x_cache_info_command(struct command_invocation *cmd,
 static int armv7a_l2x_cache_init(struct target *target, uint32_t base, uint32_t way)
 {
 	struct armv7a_l2x_cache *l2x_cache;
-	struct target_list *head = target->head;
-	struct target *curr;
+	struct target_list *head;
 
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	if (armv7a->armv7a_mmu.armv7a_cache.outer_cache) {
@@ -210,8 +210,8 @@ static int armv7a_l2x_cache_init(struct target *target, uint32_t base, uint32_t
 
 	/*  initialize all targets in this cluster (smp target)
 	 *  l2 cache must be configured after smp declaration */
-	while (head) {
-		curr = head->target;
+	foreach_smp_target(head, target->smp_targets) {
+		struct target *curr = head->target;
 		if (curr != target) {
 			armv7a = target_to_armv7a(curr);
 			if (armv7a->armv7a_mmu.armv7a_cache.outer_cache) {
@@ -220,7 +220,6 @@ static int armv7a_l2x_cache_init(struct target *target, uint32_t base, uint32_t
 			}
 			armv7a->armv7a_mmu.armv7a_cache.outer_cache = l2x_cache;
 		}
-		head = head->next;
 	}
 	return ERROR_OK;
 }
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index d33e57492..9ac121ac3 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -255,15 +255,48 @@ struct armv7m_common {
 	void (*pre_restore_context)(struct target *target);
 };
 
+static inline bool is_armv7m(const struct armv7m_common *armv7m)
+{
+	return armv7m->common_magic == ARMV7M_COMMON_MAGIC;
+}
+
+/**
+ * @returns the pointer to the target specific struct
+ * without matching a magic number.
+ * Use in target specific service routines, where the correct
+ * type of arch_info is certain.
+ */
 static inline struct armv7m_common *
 target_to_armv7m(struct target *target)
 {
 	return container_of(target->arch_info, struct armv7m_common, arm);
 }
 
-static inline bool is_armv7m(const struct armv7m_common *armv7m)
+/**
+ * @returns the pointer to the target specific struct
+ * or NULL if the magic number does not match.
+ * Use in a flash driver or any place where mismatch of the arch_info
+ * type can happen.
+ */
+static inline struct armv7m_common *
+target_to_armv7m_safe(struct target *target)
 {
-	return armv7m->common_magic == ARMV7M_COMMON_MAGIC;
+	if (!target)
+		return NULL;
+
+	if (!target->arch_info)
+		return NULL;
+
+	/* Check the parent type first to prevent peeking memory too far
+	 * from arch_info pointer */
+	if (!is_arm(target_to_arm(target)))
+		return NULL;
+
+	struct armv7m_common *armv7m = target_to_armv7m(target);
+	if (!is_armv7m(armv7m))
+		return NULL;
+
+	return armv7m;
 }
 
 struct armv7m_algorithm {
diff --git a/src/target/armv8.c b/src/target/armv8.c
index 26116bb33..1b01ba6fa 100644
--- a/src/target/armv8.c
+++ b/src/target/armv8.c
@@ -77,6 +77,10 @@ static const struct {
 		.name = "HYP",
 		.psr = ARM_MODE_HYP,
 	},
+	{
+		.name = "UND",
+		.psr = ARM_MODE_UND,
+	},
 	{
 		.name = "SYS",
 		.psr = ARM_MODE_SYS,
@@ -402,8 +406,12 @@ static int armv8_read_reg32(struct armv8_common *armv8, int regnum, uint64_t *re
 				ARMV4_5_MRC(15, 4, 0, 5, 2, 0),
 				&value);
 		break;
-	case ARMV8_ESR_EL3: /* FIXME: no equivalent in aarch32? */
-		retval = ERROR_FAIL;
+	case ARMV8_ESR_EL3:
+		/* for Cortex-A53 as example, the ARMV8_ESR_EL3 is mapped to DFSR(S),
+		 * but this mapping is not architecturally mandated.
+		 * avoid false errors in state polling, and unneeded target re-examination.
+		 */
+		retval = ERROR_OK;
 		break;
 	case ARMV8_SPSR_EL1: /* mapped to SPSR_svc */
 		retval = dpm->instr_read_data_r0(dpm,
@@ -538,8 +546,12 @@ static int armv8_write_reg32(struct armv8_common *armv8, int regnum, uint64_t va
 				ARMV4_5_MCR(15, 4, 0, 5, 2, 0),
 				value);
 		break;
-	case ARMV8_ESR_EL3: /* FIXME: no equivalent in aarch32? */
-		retval = ERROR_FAIL;
+	case ARMV8_ESR_EL3:
+		/* for Cortex-A53 as example, the ARMV8_ESR_EL3 is mapped to DFSR(S),
+		 * but this mapping is not architecturally mandated.
+		 * avoid false errors in state polling, and unneeded target re-examination.
+		 */
+		retval = ERROR_OK;
 		break;
 	case ARMV8_SPSR_EL1: /* mapped to SPSR_svc */
 		retval = dpm->instr_write_data_r0(dpm,
diff --git a/src/target/armv8_cache.c b/src/target/armv8_cache.c
index f05ac07cd..5b58d3f9f 100644
--- a/src/target/armv8_cache.c
+++ b/src/target/armv8_cache.c
@@ -23,6 +23,7 @@
 #include "armv8_cache.h"
 #include "armv8_dpm.h"
 #include "armv8_opcodes.h"
+#include "smp.h"
 
 /* CLIDR cache types */
 #define CACHE_LEVEL_HAS_UNIFIED_CACHE	0x4
@@ -250,15 +251,12 @@ static int  armv8_flush_all_data(struct target *target)
 		/*  look if all the other target have been flushed in order to flush level
 		 *  2 */
 		struct target_list *head;
-		struct target *curr;
-		head = target->head;
-		while (head) {
-			curr = head->target;
+		foreach_smp_target(head, target->smp_targets) {
+			struct target *curr = head->target;
 			if (curr->state == TARGET_HALTED) {
 				LOG_INFO("Wait flushing data l1 on core %" PRId32, curr->coreid);
 				retval = _armv8_flush_all_data(curr);
 			}
-			head = head->next;
 		}
 	} else
 		retval = _armv8_flush_all_data(target);
diff --git a/src/target/armv8_dpm.c b/src/target/armv8_dpm.c
index 188e58822..765f1b777 100644
--- a/src/target/armv8_dpm.c
+++ b/src/target/armv8_dpm.c
@@ -818,7 +818,7 @@ fail:
  * or running debugger code.
  */
 static int dpmv8_maybe_update_bpwp(struct arm_dpm *dpm, bool bpwp,
-	struct dpm_bpwp *xp, int *set_p)
+	struct dpm_bpwp *xp, bool *set_p)
 {
 	int retval = ERROR_OK;
 	bool disable;
@@ -892,7 +892,7 @@ int armv8_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 			struct breakpoint *bp = dbp->bp;
 
 			retval = dpmv8_maybe_update_bpwp(dpm, bpwp, &dbp->bpwp,
-					bp ? &bp->set : NULL);
+					bp ? &bp->is_set : NULL);
 			if (retval != ERROR_OK)
 				goto done;
 		}
@@ -904,7 +904,7 @@ int armv8_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 		struct watchpoint *wp = dwp->wp;
 
 		retval = dpmv8_maybe_update_bpwp(dpm, bpwp, &dwp->bpwp,
-				wp ? &wp->set : NULL);
+				wp ? &wp->is_set : NULL);
 		if (retval != ERROR_OK)
 			goto done;
 	}
diff --git a/src/target/breakpoints.c b/src/target/breakpoints.c
index dd901ef25..79c68fea8 100644
--- a/src/target/breakpoints.c
+++ b/src/target/breakpoints.c
@@ -26,6 +26,7 @@
 #include "target.h"
 #include <helper/log.h>
 #include "breakpoints.h"
+#include "smp.h"
 
 static const char * const breakpoint_type_strings[] = {
 	"hardware",
@@ -70,7 +71,7 @@ static int breakpoint_add_internal(struct target *target,
 	(*breakpoint_p)->asid = 0;
 	(*breakpoint_p)->length = length;
 	(*breakpoint_p)->type = type;
-	(*breakpoint_p)->set = 0;
+	(*breakpoint_p)->is_set = false;
 	(*breakpoint_p)->orig_instr = malloc(length);
 	(*breakpoint_p)->next = NULL;
 	(*breakpoint_p)->unique_id = bpwp_unique_id++;
@@ -133,7 +134,7 @@ static int context_breakpoint_add_internal(struct target *target,
 	(*breakpoint_p)->asid = asid;
 	(*breakpoint_p)->length = length;
 	(*breakpoint_p)->type = type;
-	(*breakpoint_p)->set = 0;
+	(*breakpoint_p)->is_set = false;
 	(*breakpoint_p)->orig_instr = malloc(length);
 	(*breakpoint_p)->next = NULL;
 	(*breakpoint_p)->unique_id = bpwp_unique_id++;
@@ -187,7 +188,7 @@ static int hybrid_breakpoint_add_internal(struct target *target,
 	(*breakpoint_p)->asid = asid;
 	(*breakpoint_p)->length = length;
 	(*breakpoint_p)->type = type;
-	(*breakpoint_p)->set = 0;
+	(*breakpoint_p)->is_set = false;
 	(*breakpoint_p)->orig_instr = malloc(length);
 	(*breakpoint_p)->next = NULL;
 	(*breakpoint_p)->unique_id = bpwp_unique_id++;
@@ -216,22 +217,22 @@ int breakpoint_add(struct target *target,
 	uint32_t length,
 	enum breakpoint_type type)
 {
-	int retval = ERROR_OK;
 	if (target->smp) {
 		struct target_list *head;
-		struct target *curr;
-		head = target->head;
-		if (type == BKPT_SOFT)
+
+		if (type == BKPT_SOFT) {
+			head = list_first_entry(target->smp_targets, struct target_list, lh);
 			return breakpoint_add_internal(head->target, address, length, type);
+		}
 
-		while (head) {
-			curr = head->target;
-			retval = breakpoint_add_internal(curr, address, length, type);
+		foreach_smp_target(head, target->smp_targets) {
+			struct target *curr = head->target;
+			int retval = breakpoint_add_internal(curr, address, length, type);
 			if (retval != ERROR_OK)
 				return retval;
-			head = head->next;
 		}
-		return retval;
+
+		return ERROR_OK;
 	} else {
 		return breakpoint_add_internal(target, address, length, type);
 	}
@@ -242,19 +243,17 @@ int context_breakpoint_add(struct target *target,
 	uint32_t length,
 	enum breakpoint_type type)
 {
-	int retval = ERROR_OK;
 	if (target->smp) {
 		struct target_list *head;
-		struct target *curr;
-		head = target->head;
-		while (head) {
-			curr = head->target;
-			retval = context_breakpoint_add_internal(curr, asid, length, type);
+
+		foreach_smp_target(head, target->smp_targets) {
+			struct target *curr = head->target;
+			int retval = context_breakpoint_add_internal(curr, asid, length, type);
 			if (retval != ERROR_OK)
 				return retval;
-			head = head->next;
 		}
-		return retval;
+
+		return ERROR_OK;
 	} else {
 		return context_breakpoint_add_internal(target, asid, length, type);
 	}
@@ -266,19 +265,17 @@ int hybrid_breakpoint_add(struct target *target,
 	uint32_t length,
 	enum breakpoint_type type)
 {
-	int retval = ERROR_OK;
 	if (target->smp) {
 		struct target_list *head;
-		struct target *curr;
-		head = target->head;
-		while (head) {
-			curr = head->target;
-			retval = hybrid_breakpoint_add_internal(curr, address, asid, length, type);
+
+		foreach_smp_target(head, target->smp_targets) {
+			struct target *curr = head->target;
+			int retval = hybrid_breakpoint_add_internal(curr, address, asid, length, type);
 			if (retval != ERROR_OK)
 				return retval;
-			head = head->next;
 		}
-		return retval;
+
+		return ERROR_OK;
 	} else
 		return hybrid_breakpoint_add_internal(target, address, asid, length, type);
 }
@@ -345,12 +342,10 @@ void breakpoint_remove(struct target *target, target_addr_t address)
 	if (target->smp) {
 		unsigned int num_breakpoints = 0;
 		struct target_list *head;
-		struct target *curr;
-		head = target->head;
-		while (head) {
-			curr = head->target;
+
+		foreach_smp_target(head, target->smp_targets) {
+			struct target *curr = head->target;
 			num_breakpoints += breakpoint_remove_internal(curr, address);
-			head = head->next;
 		}
 		if (!num_breakpoints)
 			LOG_ERROR("no breakpoint at address " TARGET_ADDR_FMT " found", address);
@@ -363,12 +358,10 @@ void breakpoint_remove_all(struct target *target)
 {
 	if (target->smp) {
 		struct target_list *head;
-		struct target *curr;
-		head = target->head;
-		while (head) {
-			curr = head->target;
+
+		foreach_smp_target(head, target->smp_targets) {
+			struct target *curr = head->target;
 			breakpoint_remove_all_internal(curr);
-			head = head->next;
 		}
 	} else {
 		breakpoint_remove_all_internal(target);
@@ -387,12 +380,10 @@ void breakpoint_clear_target(struct target *target)
 {
 	if (target->smp) {
 		struct target_list *head;
-		struct target *curr;
-		head = target->head;
-		while (head) {
-			curr = head->target;
+
+		foreach_smp_target(head, target->smp_targets) {
+			struct target *curr = head->target;
 			breakpoint_clear_target_internal(curr);
-			head = head->next;
 		}
 	} else {
 		breakpoint_clear_target_internal(target);
@@ -482,21 +473,17 @@ bye:
 int watchpoint_add(struct target *target, target_addr_t address,
 		uint32_t length, enum watchpoint_rw rw, uint32_t value, uint32_t mask)
 {
-	int retval = ERROR_OK;
 	if (target->smp) {
 		struct target_list *head;
-		struct target *curr;
-		head = target->head;
 
-		while (head != (struct target_list *)NULL) {
-			curr = head->target;
-			retval = watchpoint_add_internal(curr, address, length, rw, value,
-					mask);
+		foreach_smp_target(head, target->smp_targets) {
+			struct target *curr = head->target;
+			int retval = watchpoint_add_internal(curr, address, length, rw, value, mask);
 			if (retval != ERROR_OK)
 				return retval;
-			head = head->next;
 		}
-		return retval;
+
+		return ERROR_OK;
 	} else {
 		return watchpoint_add_internal(target, address, length, rw, value,
 				mask);
@@ -549,12 +536,10 @@ void watchpoint_remove(struct target *target, target_addr_t address)
 	if (target->smp) {
 		unsigned int num_watchpoints = 0;
 		struct target_list *head;
-		struct target *curr;
-		head = target->head;
-		while (head) {
-			curr = head->target;
+
+		foreach_smp_target(head, target->smp_targets) {
+			struct target *curr = head->target;
 			num_watchpoints += watchpoint_remove_internal(curr, address);
-			head = head->next;
 		}
 		if (num_watchpoints == 0)
 			LOG_ERROR("no watchpoint at address " TARGET_ADDR_FMT " num_watchpoints", address);
diff --git a/src/target/breakpoints.h b/src/target/breakpoints.h
index b4a3511d2..0a5949594 100644
--- a/src/target/breakpoints.h
+++ b/src/target/breakpoints.h
@@ -39,7 +39,8 @@ struct breakpoint {
 	uint32_t asid;
 	int length;
 	enum breakpoint_type type;
-	int set;
+	bool is_set;
+	unsigned int number;
 	uint8_t *orig_instr;
 	struct breakpoint *next;
 	uint32_t unique_id;
@@ -52,7 +53,8 @@ struct watchpoint {
 	uint32_t mask;
 	uint32_t value;
 	enum watchpoint_rw rw;
-	int set;
+	bool is_set;
+	unsigned int number;
 	struct watchpoint *next;
 	int unique_id;
 };
@@ -69,6 +71,12 @@ void breakpoint_remove_all(struct target *target);
 
 struct breakpoint *breakpoint_find(struct target *target, target_addr_t address);
 
+static inline void breakpoint_hw_set(struct breakpoint *breakpoint, unsigned int hw_number)
+{
+	breakpoint->is_set = true;
+	breakpoint->number = hw_number;
+}
+
 void watchpoint_clear_target(struct target *target);
 int watchpoint_add(struct target *target,
 		target_addr_t address, uint32_t length,
@@ -79,4 +87,10 @@ void watchpoint_remove(struct target *target, target_addr_t address);
 int watchpoint_hit(struct target *target, enum watchpoint_rw *rw,
 		target_addr_t *address);
 
+static inline void watchpoint_set(struct watchpoint *watchpoint, unsigned int number)
+{
+	watchpoint->is_set = true;
+	watchpoint->number = number;
+}
+
 #endif /* OPENOCD_TARGET_BREAKPOINTS_H */
diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
index bf65544f5..2dc109108 100644
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -639,14 +639,11 @@ static int cortex_a_dpm_setup(struct cortex_a_common *a, uint32_t didr)
 static struct target *get_cortex_a(struct target *target, int32_t coreid)
 {
 	struct target_list *head;
-	struct target *curr;
 
-	head = target->head;
-	while (head) {
-		curr = head->target;
+	foreach_smp_target(head, target->smp_targets) {
+		struct target *curr = head->target;
 		if ((curr->coreid == coreid) && (curr->state == TARGET_HALTED))
 			return curr;
-		head = head->next;
 	}
 	return target;
 }
@@ -656,14 +653,12 @@ static int cortex_a_halt_smp(struct target *target)
 {
 	int retval = 0;
 	struct target_list *head;
-	struct target *curr;
-	head = target->head;
-	while (head) {
-		curr = head->target;
+
+	foreach_smp_target(head, target->smp_targets) {
+		struct target *curr = head->target;
 		if ((curr != target) && (curr->state != TARGET_HALTED)
 			&& target_was_examined(curr))
 			retval += cortex_a_halt(curr);
-		head = head->next;
 	}
 	return retval;
 }
@@ -684,7 +679,7 @@ static int update_halt_gdb(struct target *target)
 	if (target->gdb_service)
 		gdb_target = target->gdb_service->target;
 
-	foreach_smp_target(head, target->head) {
+	foreach_smp_target(head, target->smp_targets) {
 		curr = head->target;
 		/* skip calling context */
 		if (curr == target)
@@ -951,11 +946,10 @@ static int cortex_a_restore_smp(struct target *target, int handle_breakpoints)
 {
 	int retval = 0;
 	struct target_list *head;
-	struct target *curr;
 	target_addr_t address;
-	head = target->head;
-	while (head) {
-		curr = head->target;
+
+	foreach_smp_target(head, target->smp_targets) {
+		struct target *curr = head->target;
 		if ((curr != target) && (curr->state != TARGET_RUNNING)
 			&& target_was_examined(curr)) {
 			/*  resume current address , not in step mode */
@@ -963,8 +957,6 @@ static int cortex_a_restore_smp(struct target *target, int handle_breakpoints)
 					handle_breakpoints, 0);
 			retval += cortex_a_internal_restart(curr);
 		}
-		head = head->next;
-
 	}
 	return retval;
 }
@@ -1193,7 +1185,7 @@ static int cortex_a_step(struct target *target, int current, target_addr_t addre
 	stepbreakpoint.length = (arm->core_state == ARM_STATE_THUMB)
 		? 2 : 4;
 	stepbreakpoint.type = BKPT_HARD;
-	stepbreakpoint.set = 0;
+	stepbreakpoint.is_set = false;
 
 	/* Disable interrupts during single step if requested */
 	if (cortex_a->isrmasking_mode == CORTEX_A_ISRMASK_ON) {
@@ -1273,7 +1265,7 @@ static int cortex_a_set_breakpoint(struct target *target,
 	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
 	struct cortex_a_brp *brp_list = cortex_a->brp_list;
 
-	if (breakpoint->set) {
+	if (breakpoint->is_set) {
 		LOG_WARNING("breakpoint already set");
 		return ERROR_OK;
 	}
@@ -1285,7 +1277,7 @@ static int cortex_a_set_breakpoint(struct target *target,
 			LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
-		breakpoint->set = brp_i + 1;
+		breakpoint_hw_set(breakpoint, brp_i);
 		if (breakpoint->length == 2)
 			byte_addr_select = (3 << (breakpoint->address & 0x02));
 		control = ((matchmode & 0x7) << 20)
@@ -1350,7 +1342,7 @@ static int cortex_a_set_breakpoint(struct target *target,
 		armv7a_l1_i_cache_inval_virt(target, breakpoint->address,
 						 breakpoint->length);
 
-		breakpoint->set = 0x11;	/* Any nice value but 0 */
+		breakpoint->is_set = true;
 	}
 
 	return ERROR_OK;
@@ -1367,7 +1359,7 @@ static int cortex_a_set_context_breakpoint(struct target *target,
 	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
 	struct cortex_a_brp *brp_list = cortex_a->brp_list;
 
-	if (breakpoint->set) {
+	if (breakpoint->is_set) {
 		LOG_WARNING("breakpoint already set");
 		return retval;
 	}
@@ -1381,7 +1373,7 @@ static int cortex_a_set_context_breakpoint(struct target *target,
 		return ERROR_FAIL;
 	}
 
-	breakpoint->set = brp_i + 1;
+	breakpoint_hw_set(breakpoint, brp_i);
 	control = ((matchmode & 0x7) << 20)
 		| (byte_addr_select << 5)
 		| (3 << 1) | 1;
@@ -1419,7 +1411,7 @@ static int cortex_a_set_hybrid_breakpoint(struct target *target, struct breakpoi
 	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
 	struct cortex_a_brp *brp_list = cortex_a->brp_list;
 
-	if (breakpoint->set) {
+	if (breakpoint->is_set) {
 		LOG_WARNING("breakpoint already set");
 		return retval;
 	}
@@ -1444,7 +1436,7 @@ static int cortex_a_set_hybrid_breakpoint(struct target *target, struct breakpoi
 		return ERROR_FAIL;
 	}
 
-	breakpoint->set = brp_1 + 1;
+	breakpoint_hw_set(breakpoint, brp_1);
 	breakpoint->linked_brp = brp_2;
 	control_ctx = ((ctx_machmode & 0x7) << 20)
 		| (brp_2 << 16)
@@ -1493,16 +1485,16 @@ static int cortex_a_unset_breakpoint(struct target *target, struct breakpoint *b
 	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
 	struct cortex_a_brp *brp_list = cortex_a->brp_list;
 
-	if (!breakpoint->set) {
+	if (!breakpoint->is_set) {
 		LOG_WARNING("breakpoint not set");
 		return ERROR_OK;
 	}
 
 	if (breakpoint->type == BKPT_HARD) {
 		if ((breakpoint->address != 0) && (breakpoint->asid != 0)) {
-			int brp_i = breakpoint->set - 1;
+			int brp_i = breakpoint->number;
 			int brp_j = breakpoint->linked_brp;
-			if ((brp_i < 0) || (brp_i >= cortex_a->brp_num)) {
+			if (brp_i >= cortex_a->brp_num) {
 				LOG_DEBUG("Invalid BRP number in breakpoint");
 				return ERROR_OK;
 			}
@@ -1541,12 +1533,12 @@ static int cortex_a_unset_breakpoint(struct target *target, struct breakpoint *b
 			if (retval != ERROR_OK)
 				return retval;
 			breakpoint->linked_brp = 0;
-			breakpoint->set = 0;
+			breakpoint->is_set = false;
 			return ERROR_OK;
 
 		} else {
-			int brp_i = breakpoint->set - 1;
-			if ((brp_i < 0) || (brp_i >= cortex_a->brp_num)) {
+			int brp_i = breakpoint->number;
+			if (brp_i >= cortex_a->brp_num) {
 				LOG_DEBUG("Invalid BRP number in breakpoint");
 				return ERROR_OK;
 			}
@@ -1565,7 +1557,7 @@ static int cortex_a_unset_breakpoint(struct target *target, struct breakpoint *b
 					brp_list[brp_i].value);
 			if (retval != ERROR_OK)
 				return retval;
-			breakpoint->set = 0;
+			breakpoint->is_set = false;
 			return ERROR_OK;
 		}
 	} else {
@@ -1597,7 +1589,7 @@ static int cortex_a_unset_breakpoint(struct target *target, struct breakpoint *b
 		armv7a_l1_i_cache_inval_virt(target, breakpoint->address,
 						 breakpoint->length);
 	}
-	breakpoint->set = 0;
+	breakpoint->is_set = false;
 
 	return ERROR_OK;
 }
@@ -1663,7 +1655,7 @@ static int cortex_a_remove_breakpoint(struct target *target, struct breakpoint *
 	}
 #endif
 
-	if (breakpoint->set) {
+	if (breakpoint->is_set) {
 		cortex_a_unset_breakpoint(target, breakpoint);
 		if (breakpoint->type == BKPT_HARD)
 			cortex_a->brp_num_available++;
@@ -1696,7 +1688,7 @@ static int cortex_a_set_watchpoint(struct target *target, struct watchpoint *wat
 	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
 	struct cortex_a_wrp *wrp_list = cortex_a->wrp_list;
 
-	if (watchpoint->set) {
+	if (watchpoint->is_set) {
 		LOG_WARNING("watchpoint already set");
 		return retval;
 	}
@@ -1749,7 +1741,7 @@ static int cortex_a_set_watchpoint(struct target *target, struct watchpoint *wat
 		break;
 	}
 
-	watchpoint->set = wrp_i + 1;
+	watchpoint_set(watchpoint, wrp_i);
 	control = (address_mask << 24) |
 		(byte_address_select << 5) |
 		(load_store_access_control << 3) |
@@ -1792,13 +1784,13 @@ static int cortex_a_unset_watchpoint(struct target *target, struct watchpoint *w
 	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
 	struct cortex_a_wrp *wrp_list = cortex_a->wrp_list;
 
-	if (!watchpoint->set) {
+	if (!watchpoint->is_set) {
 		LOG_WARNING("watchpoint not set");
 		return ERROR_OK;
 	}
 
-	int wrp_i = watchpoint->set - 1;
-	if (wrp_i < 0 || wrp_i >= cortex_a->wrp_num) {
+	int wrp_i = watchpoint->number;
+	if (wrp_i >= cortex_a->wrp_num) {
 		LOG_DEBUG("Invalid WRP number in watchpoint");
 		return ERROR_OK;
 	}
@@ -1817,7 +1809,7 @@ static int cortex_a_unset_watchpoint(struct target *target, struct watchpoint *w
 			wrp_list[wrp_i].value);
 	if (retval != ERROR_OK)
 		return retval;
-	watchpoint->set = 0;
+	watchpoint->is_set = false;
 
 	return ERROR_OK;
 }
@@ -1859,7 +1851,7 @@ static int cortex_a_remove_watchpoint(struct target *target, struct watchpoint *
 {
 	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
 
-	if (watchpoint->set) {
+	if (watchpoint->is_set) {
 		cortex_a->wrp_num_available++;
 		cortex_a_unset_watchpoint(target, watchpoint);
 	}
diff --git a/src/target/cortex_m.c b/src/target/cortex_m.c
index 5605dd080..344cfcf61 100644
--- a/src/target/cortex_m.c
+++ b/src/target/cortex_m.c
@@ -185,7 +185,7 @@ static int cortex_m_load_core_reg_u32(struct target *target,
 			break;
 		cortex_m->slow_register_read = true; /* Polling (still) needed. */
 		if (timeval_ms() > then + DHCSR_S_REGRDY_TIMEOUT) {
-			LOG_ERROR("Timeout waiting for DCRDR transfer ready");
+			LOG_TARGET_ERROR(target, "Timeout waiting for DCRDR transfer ready");
 			return ERROR_TIMEOUT_REACHED;
 		}
 		keep_alive();
@@ -223,7 +223,7 @@ static int cortex_m_slow_read_all_regs(struct target *target)
 	}
 
 	if (!cortex_m->slow_register_read)
-		LOG_DEBUG("Switching back to fast register reads");
+		LOG_TARGET_DEBUG(target, "Switching back to fast register reads");
 
 	return ERROR_OK;
 }
@@ -319,7 +319,7 @@ static int cortex_m_fast_read_all_regs(struct target *target)
 	for (unsigned int i = 0; i < wi; i++) {
 		if ((dhcsr[i] & S_REGRDY) == 0) {
 			not_ready = true;
-			LOG_DEBUG("Register %u was not ready during fast read", i);
+			LOG_TARGET_DEBUG(target, "Register %u was not ready during fast read", i);
 		}
 		cortex_m_cumulate_dhcsr_sticky(cortex_m, dhcsr[i]);
 	}
@@ -330,7 +330,7 @@ static int cortex_m_fast_read_all_regs(struct target *target)
 		return ERROR_TIMEOUT_REACHED;
 	}
 
-	LOG_DEBUG("read %u 32-bit registers", wi);
+	LOG_TARGET_DEBUG(target, "read %u 32-bit registers", wi);
 
 	unsigned int ri = 0; /* read index from r_vals array */
 	for (reg_id = 0; reg_id < num_regs; reg_id++) {
@@ -397,15 +397,13 @@ static int cortex_m_store_core_reg_u32(struct target *target,
 	/* check if value is written into register */
 	then = timeval_ms();
 	while (1) {
-		retval = mem_ap_read_atomic_u32(armv7m->debug_ap, DCB_DHCSR,
-										&cortex_m->dcb_dhcsr);
+		retval = cortex_m_read_dhcsr_atomic_sticky(target);
 		if (retval != ERROR_OK)
 			return retval;
-		cortex_m_cumulate_dhcsr_sticky(cortex_m, cortex_m->dcb_dhcsr);
 		if (cortex_m->dcb_dhcsr & S_REGRDY)
 			break;
 		if (timeval_ms() > then + DHCSR_S_REGRDY_TIMEOUT) {
-			LOG_ERROR("Timeout waiting for DCRDR transfer ready");
+			LOG_TARGET_ERROR(target, "Timeout waiting for DCRDR transfer ready");
 			return ERROR_TIMEOUT_REACHED;
 		}
 		keep_alive();
@@ -530,7 +528,7 @@ static int cortex_m_clear_halt(struct target *target)
 	retval = mem_ap_write_atomic_u32(armv7m->debug_ap, NVIC_DFSR, cortex_m->nvic_dfsr);
 	if (retval != ERROR_OK)
 		return retval;
-	LOG_DEBUG(" NVIC_DFSR 0x%" PRIx32 "", cortex_m->nvic_dfsr);
+	LOG_TARGET_DEBUG(target, "NVIC_DFSR 0x%" PRIx32 "", cortex_m->nvic_dfsr);
 
 	return ERROR_OK;
 }
@@ -552,7 +550,7 @@ static int cortex_m_single_step_core(struct target *target)
 	retval = cortex_m_write_debug_halt_mask(target, C_STEP, C_HALT);
 	if (retval != ERROR_OK)
 		return retval;
-	LOG_DEBUG(" ");
+	LOG_TARGET_DEBUG(target, "single step");
 
 	/* restore dhcsr reg */
 	cortex_m_clear_halt(target);
@@ -592,7 +590,7 @@ static int cortex_m_endreset_event(struct target *target)
 	retval = mem_ap_read_atomic_u32(armv7m->debug_ap, DCB_DEMCR, &dcb_demcr);
 	if (retval != ERROR_OK)
 		return retval;
-	LOG_DEBUG("DCB_DEMCR = 0x%8.8" PRIx32 "", dcb_demcr);
+	LOG_TARGET_DEBUG(target, "DCB_DEMCR = 0x%8.8" PRIx32 "", dcb_demcr);
 
 	/* this register is used for emulated dcc channel */
 	retval = mem_ap_write_u32(armv7m->debug_ap, DCB_DCRDR, 0);
@@ -631,7 +629,7 @@ static int cortex_m_endreset_event(struct target *target)
 	/* Enable FPB */
 	retval = cortex_m_enable_fpb(target);
 	if (retval != ERROR_OK) {
-		LOG_ERROR("Failed to enable the FPB");
+		LOG_TARGET_ERROR(target, "Failed to enable the FPB");
 		return retval;
 	}
 
@@ -768,7 +766,7 @@ static int cortex_m_examine_exception_reason(struct target *target)
 	}
 	retval = dap_run(swjdp);
 	if (retval == ERROR_OK)
-		LOG_DEBUG("%s SHCSR 0x%" PRIx32 ", SR 0x%" PRIx32
+		LOG_TARGET_DEBUG(target, "%s SHCSR 0x%" PRIx32 ", SR 0x%" PRIx32
 			", CFSR 0x%" PRIx32 ", AR 0x%" PRIx32,
 			armv7m_exception_string(armv7m->exception_number),
 			shcsr, except_sr, cfsr, except_ar);
@@ -784,7 +782,7 @@ static int cortex_m_debug_entry(struct target *target)
 	struct arm *arm = &armv7m->arm;
 	struct reg *r;
 
-	LOG_DEBUG(" ");
+	LOG_TARGET_DEBUG(target, " ");
 
 	/* Do this really early to minimize the window where the MASKINTS erratum
 	 * can pile up pending interrupts. */
@@ -817,7 +815,7 @@ static int cortex_m_debug_entry(struct target *target)
 		retval = cortex_m_fast_read_all_regs(target);
 		if (retval == ERROR_TIMEOUT_REACHED) {
 			cortex_m->slow_register_read = true;
-			LOG_DEBUG("Switched to slow register read");
+			LOG_TARGET_DEBUG(target, "Switched to slow register read");
 		}
 	}
 
@@ -857,7 +855,8 @@ static int cortex_m_debug_entry(struct target *target)
 	if (armv7m->exception_number)
 		cortex_m_examine_exception_reason(target);
 
-	LOG_DEBUG("entered debug state in core mode: %s at PC 0x%" PRIx32 ", cpu in %s state, target->state: %s",
+	LOG_TARGET_DEBUG(target, "entered debug state in core mode: %s at PC 0x%" PRIx32
+			", cpu in %s state, target->state: %s",
 		arm_mode_name(arm->core_mode),
 		buf_get_u32(arm->pc->value, 0, 32),
 		secure_state ? "Secure" : "Non-Secure",
@@ -891,8 +890,7 @@ static int cortex_m_poll(struct target *target)
 	 * section B1.5.15 "Unrecoverable exception cases".
 	 */
 	if (cortex_m->dcb_dhcsr & S_LOCKUP) {
-		LOG_ERROR("%s -- clearing lockup after double fault",
-			target_name(target));
+		LOG_TARGET_ERROR(target, "clearing lockup after double fault");
 		cortex_m_write_debug_halt_mask(target, C_HALT, 0);
 		target->debug_reason = DBG_REASON_DBGRQ;
 
@@ -911,7 +909,7 @@ static int cortex_m_poll(struct target *target)
 		cortex_m->dcb_dhcsr_cumulated_sticky &= ~S_RESET_ST;
 		if (target->state != TARGET_RESET) {
 			target->state = TARGET_RESET;
-			LOG_INFO("%s: external reset detected", target_name(target));
+			LOG_TARGET_INFO(target, "external reset detected");
 		}
 		return ERROR_OK;
 	}
@@ -920,7 +918,7 @@ static int cortex_m_poll(struct target *target)
 		/* Cannot switch context while running so endreset is
 		 * called with target->state == TARGET_RESET
 		 */
-		LOG_DEBUG("Exit from reset with dcb_dhcsr 0x%" PRIx32,
+		LOG_TARGET_DEBUG(target, "Exit from reset with dcb_dhcsr 0x%" PRIx32,
 			cortex_m->dcb_dhcsr);
 		retval = cortex_m_endreset_event(target);
 		if (retval != ERROR_OK) {
@@ -945,7 +943,6 @@ static int cortex_m_poll(struct target *target)
 			target_call_event_callbacks(target, TARGET_EVENT_HALTED);
 		}
 		if (prev_target_state == TARGET_DEBUG_RUNNING) {
-			LOG_DEBUG(" ");
 			retval = cortex_m_debug_entry(target);
 			if (retval != ERROR_OK)
 				return retval;
@@ -973,7 +970,7 @@ static int cortex_m_poll(struct target *target)
 		register_cache_invalidate(armv7m->arm.core_cache);
 
 		target->state = TARGET_RUNNING;
-		LOG_WARNING("%s: external resume detected", target_name(target));
+		LOG_TARGET_WARNING(target, "external resume detected");
 		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
 		retval = ERROR_OK;
 	}
@@ -986,20 +983,19 @@ static int cortex_m_poll(struct target *target)
 
 static int cortex_m_halt(struct target *target)
 {
-	LOG_DEBUG("target->state: %s",
-		target_state_name(target));
+	LOG_TARGET_DEBUG(target, "target->state: %s", target_state_name(target));
 
 	if (target->state == TARGET_HALTED) {
-		LOG_DEBUG("target was already halted");
+		LOG_TARGET_DEBUG(target, "target was already halted");
 		return ERROR_OK;
 	}
 
 	if (target->state == TARGET_UNKNOWN)
-		LOG_WARNING("target was in unknown state when halt was requested");
+		LOG_TARGET_WARNING(target, "target was in unknown state when halt was requested");
 
 	if (target->state == TARGET_RESET) {
 		if ((jtag_get_reset_config() & RESET_SRST_PULLS_TRST) && jtag_get_srst()) {
-			LOG_ERROR("can't request a halt while in reset if nSRST pulls nTRST");
+			LOG_TARGET_ERROR(target, "can't request a halt while in reset if nSRST pulls nTRST");
 			return ERROR_TARGET_FAILURE;
 		} else {
 			/* we came here in a reset_halt or reset_init sequence
@@ -1033,10 +1029,10 @@ static int cortex_m_soft_reset_halt(struct target *target)
 	 * can be obtained by using 'reset halt' and 'cortex_m reset_config vectreset'.
 	 * As this reset only uses VC_CORERESET it would only ever reset the cortex_m
 	 * core, not the peripherals */
-	LOG_DEBUG("soft_reset_halt is discouraged, please use 'reset halt' instead.");
+	LOG_TARGET_DEBUG(target, "soft_reset_halt is discouraged, please use 'reset halt' instead.");
 
 	if (!cortex_m->vectreset_supported) {
-		LOG_ERROR("VECTRESET is not supported on this Cortex-M core");
+		LOG_TARGET_ERROR(target, "VECTRESET is not supported on this Cortex-M core");
 		return ERROR_FAIL;
 	}
 
@@ -1070,15 +1066,16 @@ static int cortex_m_soft_reset_halt(struct target *target)
 				return retval;
 			if ((cortex_m->dcb_dhcsr & S_HALT)
 				&& (cortex_m->nvic_dfsr & DFSR_VCATCH)) {
-				LOG_DEBUG("system reset-halted, DHCSR 0x%08" PRIx32 ", DFSR 0x%08" PRIx32,
-					cortex_m->dcb_dhcsr, cortex_m->nvic_dfsr);
+				LOG_TARGET_DEBUG(target, "system reset-halted, DHCSR 0x%08" PRIx32 ", DFSR 0x%08" PRIx32,
+						cortex_m->dcb_dhcsr, cortex_m->nvic_dfsr);
 				cortex_m_poll(target);
 				/* FIXME restore user's vector catch config */
 				return ERROR_OK;
-			} else
-				LOG_DEBUG("waiting for system reset-halt, "
+			} else {
+				LOG_TARGET_DEBUG(target, "waiting for system reset-halt, "
 					"DHCSR 0x%08" PRIx32 ", %d ms",
 					cortex_m->dcb_dhcsr, timeout);
+			}
 		}
 		timeout++;
 		alive_sleep(1);
@@ -1093,7 +1090,7 @@ void cortex_m_enable_breakpoints(struct target *target)
 
 	/* set any pending breakpoints */
 	while (breakpoint) {
-		if (!breakpoint->set)
+		if (!breakpoint->is_set)
 			cortex_m_set_breakpoint(target, breakpoint);
 		breakpoint = breakpoint->next;
 	}
@@ -1108,7 +1105,7 @@ static int cortex_m_resume(struct target *target, int current,
 	struct reg *r;
 
 	if (target->state != TARGET_HALTED) {
-		LOG_WARNING("target not halted");
+		LOG_TARGET_WARNING(target, "target not halted");
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
@@ -1172,7 +1169,7 @@ static int cortex_m_resume(struct target *target, int current,
 		/* Single step past breakpoint at current address */
 		breakpoint = breakpoint_find(target, resume_pc);
 		if (breakpoint) {
-			LOG_DEBUG("unset breakpoint at " TARGET_ADDR_FMT " (ID: %" PRIu32 ")",
+			LOG_TARGET_DEBUG(target, "unset breakpoint at " TARGET_ADDR_FMT " (ID: %" PRIu32 ")",
 				breakpoint->address,
 				breakpoint->unique_id);
 			cortex_m_unset_breakpoint(target, breakpoint);
@@ -1193,11 +1190,11 @@ static int cortex_m_resume(struct target *target, int current,
 	if (!debug_execution) {
 		target->state = TARGET_RUNNING;
 		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
-		LOG_DEBUG("target resumed at 0x%" PRIx32 "", resume_pc);
+		LOG_TARGET_DEBUG(target, "target resumed at 0x%" PRIx32 "", resume_pc);
 	} else {
 		target->state = TARGET_DEBUG_RUNNING;
 		target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
-		LOG_DEBUG("target debug resumed at 0x%" PRIx32 "", resume_pc);
+		LOG_TARGET_DEBUG(target, "target debug resumed at 0x%" PRIx32 "", resume_pc);
 	}
 
 	return ERROR_OK;
@@ -1216,7 +1213,7 @@ static int cortex_m_step(struct target *target, int current,
 	bool isr_timed_out = false;
 
 	if (target->state != TARGET_HALTED) {
-		LOG_WARNING("target not halted");
+		LOG_TARGET_WARNING(target, "target not halted");
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
@@ -1289,7 +1286,7 @@ static int cortex_m_step(struct target *target, int current,
 			 *
 			 */
 			if ((pc_value & 0x02) && breakpoint_find(target, pc_value & ~0x03)) {
-				LOG_DEBUG("Stepping over next instruction with interrupts disabled");
+				LOG_TARGET_DEBUG(target, "Stepping over next instruction with interrupts disabled");
 				cortex_m_write_debug_halt_mask(target, C_HALT | C_MASKINTS, 0);
 				cortex_m_write_debug_halt_mask(target, C_STEP, C_HALT);
 				/* Re-enable interrupts if appropriate */
@@ -1320,7 +1317,7 @@ static int cortex_m_step(struct target *target, int current,
 					cortex_m_set_maskints_for_halt(target);
 				} else {
 					/* Start the core */
-					LOG_DEBUG("Starting core to serve pending interrupts");
+					LOG_TARGET_DEBUG(target, "Starting core to serve pending interrupts");
 					int64_t t_start = timeval_ms();
 					cortex_m_set_maskints_for_run(target);
 					cortex_m_write_debug_halt_mask(target, 0, C_HALT | C_STEP);
@@ -1344,7 +1341,7 @@ static int cortex_m_step(struct target *target, int current,
 					}
 
 					if (isr_timed_out) {
-						LOG_DEBUG("Interrupt handlers didn't complete within time, "
+						LOG_TARGET_DEBUG(target, "Interrupt handlers didn't complete within time, "
 							"leaving target running");
 					} else {
 						/* Step over next instruction with interrupts disabled */
@@ -1379,7 +1376,7 @@ static int cortex_m_step(struct target *target, int current,
 		return ERROR_OK;
 	}
 
-	LOG_DEBUG("target stepped dcb_dhcsr = 0x%" PRIx32
+	LOG_TARGET_DEBUG(target, "target stepped dcb_dhcsr = 0x%" PRIx32
 		" nvic_icsr = 0x%" PRIx32,
 		cortex_m->dcb_dhcsr, cortex_m->nvic_icsr);
 
@@ -1388,7 +1385,7 @@ static int cortex_m_step(struct target *target, int current,
 		return retval;
 	target_call_event_callbacks(target, TARGET_EVENT_HALTED);
 
-	LOG_DEBUG("target stepped dcb_dhcsr = 0x%" PRIx32
+	LOG_TARGET_DEBUG(target, "target stepped dcb_dhcsr = 0x%" PRIx32
 		" nvic_icsr = 0x%" PRIx32,
 		cortex_m->dcb_dhcsr, cortex_m->nvic_icsr);
 
@@ -1401,7 +1398,7 @@ static int cortex_m_assert_reset(struct target *target)
 	struct armv7m_common *armv7m = &cortex_m->armv7m;
 	enum cortex_m_soft_reset_config reset_config = cortex_m->soft_reset_config;
 
-	LOG_DEBUG("target->state: %s",
+	LOG_TARGET_DEBUG(target, "target->state: %s",
 		target_state_name(target));
 
 	enum reset_types jtag_reset_config = jtag_get_reset_config();
@@ -1425,10 +1422,10 @@ static int cortex_m_assert_reset(struct target *target)
 		if (jtag_reset_config & RESET_HAS_SRST) {
 			adapter_assert_reset();
 			if (target->reset_halt)
-				LOG_ERROR("Target not examined, will not halt after reset!");
+				LOG_TARGET_ERROR(target, "Target not examined, will not halt after reset!");
 			return ERROR_OK;
 		} else {
-			LOG_ERROR("Target not examined, reset NOT asserted!");
+			LOG_TARGET_ERROR(target, "Target not examined, reset NOT asserted!");
 			return ERROR_FAIL;
 		}
 	}
@@ -1475,7 +1472,7 @@ static int cortex_m_assert_reset(struct target *target)
 		retval2 = mem_ap_write_atomic_u32(armv7m->debug_ap, DCB_DEMCR,
 				TRCENA | VC_HARDERR | VC_BUSERR | VC_CORERESET);
 		if (retval != ERROR_OK || retval2 != ERROR_OK)
-			LOG_INFO("AP write error, reset will not halt");
+			LOG_TARGET_INFO(target, "AP write error, reset will not halt");
 	}
 
 	if (jtag_reset_config & RESET_HAS_SRST) {
@@ -1495,15 +1492,15 @@ static int cortex_m_assert_reset(struct target *target)
 		if (!cortex_m->vectreset_supported
 				&& reset_config == CORTEX_M_RESET_VECTRESET) {
 			reset_config = CORTEX_M_RESET_SYSRESETREQ;
-			LOG_WARNING("VECTRESET is not supported on this Cortex-M core, using SYSRESETREQ instead.");
-			LOG_WARNING("Set 'cortex_m reset_config sysresetreq'.");
+			LOG_TARGET_WARNING(target, "VECTRESET is not supported on this Cortex-M core, using SYSRESETREQ instead.");
+			LOG_TARGET_WARNING(target, "Set 'cortex_m reset_config sysresetreq'.");
 		}
 
-		LOG_DEBUG("Using Cortex-M %s", (reset_config == CORTEX_M_RESET_SYSRESETREQ)
+		LOG_TARGET_DEBUG(target, "Using Cortex-M %s", (reset_config == CORTEX_M_RESET_SYSRESETREQ)
 			? "SYSRESETREQ" : "VECTRESET");
 
 		if (reset_config == CORTEX_M_RESET_VECTRESET) {
-			LOG_WARNING("Only resetting the Cortex-M core, use a reset-init event "
+			LOG_TARGET_WARNING(target, "Only resetting the Cortex-M core, use a reset-init event "
 				"handler to reset any peripherals or configure hardware srst support.");
 		}
 
@@ -1512,11 +1509,11 @@ static int cortex_m_assert_reset(struct target *target)
 				AIRCR_VECTKEY | ((reset_config == CORTEX_M_RESET_SYSRESETREQ)
 				? AIRCR_SYSRESETREQ : AIRCR_VECTRESET));
 		if (retval3 != ERROR_OK)
-			LOG_DEBUG("Ignoring AP write error right after reset");
+			LOG_TARGET_DEBUG(target, "Ignoring AP write error right after reset");
 
 		retval3 = dap_dp_init_or_reconnect(armv7m->debug_ap->dap);
 		if (retval3 != ERROR_OK) {
-			LOG_ERROR("DP initialisation failed");
+			LOG_TARGET_ERROR(target, "DP initialisation failed");
 			/* The error return value must not be propagated in this case.
 			 * SYSRESETREQ or VECTRESET have been possibly triggered
 			 * so reset processing should continue */
@@ -1552,7 +1549,7 @@ static int cortex_m_deassert_reset(struct target *target)
 {
 	struct armv7m_common *armv7m = &target_to_cm(target)->armv7m;
 
-	LOG_DEBUG("target->state: %s",
+	LOG_TARGET_DEBUG(target, "target->state: %s",
 		target_state_name(target));
 
 	/* deassert reset lines */
@@ -1566,7 +1563,7 @@ static int cortex_m_deassert_reset(struct target *target)
 
 		int retval = dap_dp_init_or_reconnect(armv7m->debug_ap->dap);
 		if (retval != ERROR_OK) {
-			LOG_ERROR("DP initialisation failed");
+			LOG_TARGET_ERROR(target, "DP initialisation failed");
 			return retval;
 		}
 	}
@@ -1581,8 +1578,8 @@ int cortex_m_set_breakpoint(struct target *target, struct breakpoint *breakpoint
 	struct cortex_m_common *cortex_m = target_to_cm(target);
 	struct cortex_m_fp_comparator *comparator_list = cortex_m->fp_comparator_list;
 
-	if (breakpoint->set) {
-		LOG_WARNING("breakpoint (BPID: %" PRIu32 ") already set", breakpoint->unique_id);
+	if (breakpoint->is_set) {
+		LOG_TARGET_WARNING(target, "breakpoint (BPID: %" PRIu32 ") already set", breakpoint->unique_id);
 		return ERROR_OK;
 	}
 
@@ -1591,35 +1588,36 @@ int cortex_m_set_breakpoint(struct target *target, struct breakpoint *breakpoint
 		while (comparator_list[fp_num].used && (fp_num < cortex_m->fp_num_code))
 			fp_num++;
 		if (fp_num >= cortex_m->fp_num_code) {
-			LOG_ERROR("Can not find free FPB Comparator!");
+			LOG_TARGET_ERROR(target, "Can not find free FPB Comparator!");
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
-		breakpoint->set = fp_num + 1;
+		breakpoint_hw_set(breakpoint, fp_num);
 		fpcr_value = breakpoint->address | 1;
 		if (cortex_m->fp_rev == 0) {
 			if (breakpoint->address > 0x1FFFFFFF) {
-				LOG_ERROR("Cortex-M Flash Patch Breakpoint rev.1 cannot handle HW breakpoint above address 0x1FFFFFFE");
+				LOG_TARGET_ERROR(target, "Cortex-M Flash Patch Breakpoint rev.1 "
+						"cannot handle HW breakpoint above address 0x1FFFFFFE");
 				return ERROR_FAIL;
 			}
 			uint32_t hilo;
 			hilo = (breakpoint->address & 0x2) ? FPCR_REPLACE_BKPT_HIGH : FPCR_REPLACE_BKPT_LOW;
 			fpcr_value = (fpcr_value & 0x1FFFFFFC) | hilo | 1;
 		} else if (cortex_m->fp_rev > 1) {
-			LOG_ERROR("Unhandled Cortex-M Flash Patch Breakpoint architecture revision");
+			LOG_TARGET_ERROR(target, "Unhandled Cortex-M Flash Patch Breakpoint architecture revision");
 			return ERROR_FAIL;
 		}
 		comparator_list[fp_num].used = true;
 		comparator_list[fp_num].fpcr_value = fpcr_value;
 		target_write_u32(target, comparator_list[fp_num].fpcr_address,
 			comparator_list[fp_num].fpcr_value);
-		LOG_DEBUG("fpc_num %i fpcr_value 0x%" PRIx32 "",
+		LOG_TARGET_DEBUG(target, "fpc_num %i fpcr_value 0x%" PRIx32 "",
 			fp_num,
 			comparator_list[fp_num].fpcr_value);
 		if (!cortex_m->fpb_enabled) {
-			LOG_DEBUG("FPB wasn't enabled, do it now");
+			LOG_TARGET_DEBUG(target, "FPB wasn't enabled, do it now");
 			retval = cortex_m_enable_fpb(target);
 			if (retval != ERROR_OK) {
-				LOG_ERROR("Failed to enable the FPB");
+				LOG_TARGET_ERROR(target, "Failed to enable the FPB");
 				return retval;
 			}
 
@@ -1645,15 +1643,15 @@ int cortex_m_set_breakpoint(struct target *target, struct breakpoint *breakpoint
 				code);
 		if (retval != ERROR_OK)
 			return retval;
-		breakpoint->set = true;
+		breakpoint->is_set = true;
 	}
 
-	LOG_DEBUG("BPID: %" PRIu32 ", Type: %d, Address: " TARGET_ADDR_FMT " Length: %d (set=%d)",
+	LOG_TARGET_DEBUG(target, "BPID: %" PRIu32 ", Type: %d, Address: " TARGET_ADDR_FMT " Length: %d (n=%u)",
 		breakpoint->unique_id,
 		(int)(breakpoint->type),
 		breakpoint->address,
 		breakpoint->length,
-		breakpoint->set);
+		(breakpoint->type == BKPT_SOFT) ? 0 : breakpoint->number);
 
 	return ERROR_OK;
 }
@@ -1664,22 +1662,22 @@ int cortex_m_unset_breakpoint(struct target *target, struct breakpoint *breakpoi
 	struct cortex_m_common *cortex_m = target_to_cm(target);
 	struct cortex_m_fp_comparator *comparator_list = cortex_m->fp_comparator_list;
 
-	if (breakpoint->set <= 0) {
-		LOG_WARNING("breakpoint not set");
+	if (!breakpoint->is_set) {
+		LOG_TARGET_WARNING(target, "breakpoint not set");
 		return ERROR_OK;
 	}
 
-	LOG_DEBUG("BPID: %" PRIu32 ", Type: %d, Address: " TARGET_ADDR_FMT " Length: %d (set=%d)",
+	LOG_TARGET_DEBUG(target, "BPID: %" PRIu32 ", Type: %d, Address: " TARGET_ADDR_FMT " Length: %d (n=%u)",
 		breakpoint->unique_id,
 		(int)(breakpoint->type),
 		breakpoint->address,
 		breakpoint->length,
-		breakpoint->set);
+		(breakpoint->type == BKPT_SOFT) ? 0 : breakpoint->number);
 
 	if (breakpoint->type == BKPT_HARD) {
-		unsigned int fp_num = breakpoint->set - 1;
+		unsigned int fp_num = breakpoint->number;
 		if (fp_num >= cortex_m->fp_num_code) {
-			LOG_DEBUG("Invalid FP Comparator number in breakpoint");
+			LOG_TARGET_DEBUG(target, "Invalid FP Comparator number in breakpoint");
 			return ERROR_OK;
 		}
 		comparator_list[fp_num].used = false;
@@ -1694,7 +1692,7 @@ int cortex_m_unset_breakpoint(struct target *target, struct breakpoint *breakpoi
 		if (retval != ERROR_OK)
 			return retval;
 	}
-	breakpoint->set = false;
+	breakpoint->is_set = false;
 
 	return ERROR_OK;
 }
@@ -1702,12 +1700,12 @@ int cortex_m_unset_breakpoint(struct target *target, struct breakpoint *breakpoi
 int cortex_m_add_breakpoint(struct target *target, struct breakpoint *breakpoint)
 {
 	if (breakpoint->length == 3) {
-		LOG_DEBUG("Using a two byte breakpoint for 32bit Thumb-2 request");
+		LOG_TARGET_DEBUG(target, "Using a two byte breakpoint for 32bit Thumb-2 request");
 		breakpoint->length = 2;
 	}
 
 	if ((breakpoint->length != 2)) {
-		LOG_INFO("only breakpoints of two bytes length supported");
+		LOG_TARGET_INFO(target, "only breakpoints of two bytes length supported");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
 
@@ -1716,7 +1714,7 @@ int cortex_m_add_breakpoint(struct target *target, struct breakpoint *breakpoint
 
 int cortex_m_remove_breakpoint(struct target *target, struct breakpoint *breakpoint)
 {
-	if (!breakpoint->set)
+	if (!breakpoint->is_set)
 		return ERROR_OK;
 
 	return cortex_m_unset_breakpoint(target, breakpoint);
@@ -1739,11 +1737,11 @@ static int cortex_m_set_watchpoint(struct target *target, struct watchpoint *wat
 		comparator++, dwt_num++)
 		continue;
 	if (dwt_num >= cortex_m->dwt_num_comp) {
-		LOG_ERROR("Can not find free DWT Comparator");
+		LOG_TARGET_ERROR(target, "Can not find free DWT Comparator");
 		return ERROR_FAIL;
 	}
 	comparator->used = true;
-	watchpoint->set = dwt_num + 1;
+	watchpoint_set(watchpoint, dwt_num);
 
 	comparator->comp = watchpoint->address;
 	target_write_u32(target, comparator->dwt_comparator_address + 0,
@@ -1797,7 +1795,7 @@ static int cortex_m_set_watchpoint(struct target *target, struct watchpoint *wat
 	target_write_u32(target, comparator->dwt_comparator_address + 8,
 		comparator->function);
 
-	LOG_DEBUG("Watchpoint (ID %d) DWT%d 0x%08x 0x%x 0x%05x",
+	LOG_TARGET_DEBUG(target, "Watchpoint (ID %d) DWT%d 0x%08x 0x%x 0x%05x",
 		watchpoint->unique_id, dwt_num,
 		(unsigned) comparator->comp,
 		(unsigned) comparator->mask,
@@ -1810,20 +1808,20 @@ static int cortex_m_unset_watchpoint(struct target *target, struct watchpoint *w
 	struct cortex_m_common *cortex_m = target_to_cm(target);
 	struct cortex_m_dwt_comparator *comparator;
 
-	if (watchpoint->set <= 0) {
-		LOG_WARNING("watchpoint (wpid: %d) not set",
+	if (!watchpoint->is_set) {
+		LOG_TARGET_WARNING(target, "watchpoint (wpid: %d) not set",
 			watchpoint->unique_id);
 		return ERROR_OK;
 	}
 
-	unsigned int dwt_num = watchpoint->set - 1;
+	unsigned int dwt_num = watchpoint->number;
 
-	LOG_DEBUG("Watchpoint (ID %d) DWT%d address: 0x%08x clear",
+	LOG_TARGET_DEBUG(target, "Watchpoint (ID %d) DWT%u address: 0x%08x clear",
 		watchpoint->unique_id, dwt_num,
 		(unsigned) watchpoint->address);
 
 	if (dwt_num >= cortex_m->dwt_num_comp) {
-		LOG_DEBUG("Invalid DWT Comparator number in watchpoint");
+		LOG_TARGET_DEBUG(target, "Invalid DWT Comparator number in watchpoint");
 		return ERROR_OK;
 	}
 
@@ -1833,7 +1831,7 @@ static int cortex_m_unset_watchpoint(struct target *target, struct watchpoint *w
 	target_write_u32(target, comparator->dwt_comparator_address + 8,
 		comparator->function);
 
-	watchpoint->set = false;
+	watchpoint->is_set = false;
 
 	return ERROR_OK;
 }
@@ -1843,13 +1841,13 @@ int cortex_m_add_watchpoint(struct target *target, struct watchpoint *watchpoint
 	struct cortex_m_common *cortex_m = target_to_cm(target);
 
 	if (cortex_m->dwt_comp_available < 1) {
-		LOG_DEBUG("no comparators?");
+		LOG_TARGET_DEBUG(target, "no comparators?");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
 
 	/* hardware doesn't support data value masking */
 	if (watchpoint->mask != ~(uint32_t)0) {
-		LOG_DEBUG("watchpoint value masks not supported");
+		LOG_TARGET_DEBUG(target, "watchpoint value masks not supported");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
 
@@ -1861,11 +1859,11 @@ int cortex_m_add_watchpoint(struct target *target, struct watchpoint *watchpoint
 			break;
 	}
 	if (mask == 16) {
-		LOG_DEBUG("unsupported watchpoint length");
+		LOG_TARGET_DEBUG(target, "unsupported watchpoint length");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
 	if (watchpoint->address & ((1 << mask) - 1)) {
-		LOG_DEBUG("watchpoint address is unaligned");
+		LOG_TARGET_DEBUG(target, "watchpoint address is unaligned");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
 
@@ -1877,12 +1875,12 @@ int cortex_m_add_watchpoint(struct target *target, struct watchpoint *watchpoint
 	 * the data, and another comparator (DATAVADDR0) matching addr.
 	 */
 	if (watchpoint->value) {
-		LOG_DEBUG("data value watchpoint not YET supported");
+		LOG_TARGET_DEBUG(target, "data value watchpoint not YET supported");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
 
 	cortex_m->dwt_comp_available--;
-	LOG_DEBUG("dwt_comp_available: %d", cortex_m->dwt_comp_available);
+	LOG_TARGET_DEBUG(target, "dwt_comp_available: %d", cortex_m->dwt_comp_available);
 
 	return ERROR_OK;
 }
@@ -1893,15 +1891,15 @@ int cortex_m_remove_watchpoint(struct target *target, struct watchpoint *watchpo
 
 	/* REVISIT why check? DWT can be updated with core running ... */
 	if (target->state != TARGET_HALTED) {
-		LOG_WARNING("target not halted");
+		LOG_TARGET_WARNING(target, "target not halted");
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if (watchpoint->set)
+	if (watchpoint->is_set)
 		cortex_m_unset_watchpoint(target, watchpoint);
 
 	cortex_m->dwt_comp_available++;
-	LOG_DEBUG("dwt_comp_available: %d", cortex_m->dwt_comp_available);
+	LOG_TARGET_DEBUG(target, "dwt_comp_available: %d", cortex_m->dwt_comp_available);
 
 	return ERROR_OK;
 }
@@ -1914,10 +1912,10 @@ int cortex_m_hit_watchpoint(struct target *target, struct watchpoint **hit_watch
 	struct cortex_m_common *cortex_m = target_to_cm(target);
 
 	for (struct watchpoint *wp = target->watchpoints; wp; wp = wp->next) {
-		if (!wp->set)
+		if (!wp->is_set)
 			continue;
 
-		unsigned int dwt_num = wp->set - 1;
+		unsigned int dwt_num = wp->number;
 		struct cortex_m_dwt_comparator *comparator = cortex_m->dwt_comparator_list + dwt_num;
 
 		uint32_t dwt_function;
@@ -1941,7 +1939,7 @@ void cortex_m_enable_watchpoints(struct target *target)
 
 	/* set any pending watchpoints */
 	while (watchpoint) {
-		if (!watchpoint->set)
+		if (!watchpoint->is_set)
 			cortex_m_set_watchpoint(target, watchpoint);
 		watchpoint = watchpoint->next;
 	}
@@ -2006,18 +2004,18 @@ int cortex_m_profiling(struct target *target, uint32_t *samples,
 
 	retval = target_read_u32(target, DWT_PCSR, &reg_value);
 	if (retval != ERROR_OK) {
-		LOG_ERROR("Error while reading PCSR");
+		LOG_TARGET_ERROR(target, "Error while reading PCSR");
 		return retval;
 	}
 	if (reg_value == 0) {
-		LOG_INFO("PCSR sampling not supported on this processor.");
+		LOG_TARGET_INFO(target, "PCSR sampling not supported on this processor.");
 		return target_profiling_default(target, samples, max_num_samples, num_samples, seconds);
 	}
 
 	gettimeofday(&timeout, NULL);
 	timeval_add_time(&timeout, seconds, 0);
 
-	LOG_INFO("Starting Cortex-M profiling. Sampling DWT_PCSR as fast as we can...");
+	LOG_TARGET_INFO(target, "Starting Cortex-M profiling. Sampling DWT_PCSR as fast as we can...");
 
 	/* Make sure the target is running */
 	target_poll(target);
@@ -2025,7 +2023,7 @@ int cortex_m_profiling(struct target *target, uint32_t *samples,
 		retval = target_resume(target, 1, 0, 0, 0);
 
 	if (retval != ERROR_OK) {
-		LOG_ERROR("Error while resuming target");
+		LOG_TARGET_ERROR(target, "Error while resuming target");
 		return retval;
 	}
 
@@ -2046,14 +2044,14 @@ int cortex_m_profiling(struct target *target, uint32_t *samples,
 		}
 
 		if (retval != ERROR_OK) {
-			LOG_ERROR("Error while reading PCSR");
+			LOG_TARGET_ERROR(target, "Error while reading PCSR");
 			return retval;
 		}
 
 
 		gettimeofday(&now, NULL);
 		if (sample_count >= max_num_samples || timeval_compare(&now, &timeout) > 0) {
-			LOG_INFO("Profiling completed. %" PRIu32 " samples.", sample_count);
+			LOG_TARGET_INFO(target, "Profiling completed. %" PRIu32 " samples.", sample_count);
 			break;
 		}
 	}
@@ -2164,14 +2162,14 @@ static void cortex_m_dwt_setup(struct cortex_m_common *cm, struct target *target
 	int reg;
 
 	target_read_u32(target, DWT_CTRL, &dwtcr);
-	LOG_DEBUG("DWT_CTRL: 0x%" PRIx32, dwtcr);
+	LOG_TARGET_DEBUG(target, "DWT_CTRL: 0x%" PRIx32, dwtcr);
 	if (!dwtcr) {
-		LOG_DEBUG("no DWT");
+		LOG_TARGET_DEBUG(target, "no DWT");
 		return;
 	}
 
 	target_read_u32(target, DWT_DEVARCH, &cm->dwt_devarch);
-	LOG_DEBUG("DWT_DEVARCH: 0x%" PRIx32, cm->dwt_devarch);
+	LOG_TARGET_DEBUG(target, "DWT_DEVARCH: 0x%" PRIx32, cm->dwt_devarch);
 
 	cm->dwt_num_comp = (dwtcr >> 28) & 0xF;
 	cm->dwt_comp_available = cm->dwt_num_comp;
@@ -2180,7 +2178,7 @@ static void cortex_m_dwt_setup(struct cortex_m_common *cm, struct target *target
 	if (!cm->dwt_comparator_list) {
 fail0:
 		cm->dwt_num_comp = 0;
-		LOG_ERROR("out of mem");
+		LOG_TARGET_ERROR(target, "out of mem");
 		return;
 	}
 
@@ -2218,7 +2216,7 @@ fail1:
 	*register_get_last_cache_p(&target->reg_cache) = cache;
 	cm->dwt_cache = cache;
 
-	LOG_DEBUG("DWT dwtcr 0x%" PRIx32 ", comp %d, watch%s",
+	LOG_TARGET_DEBUG(target, "DWT dwtcr 0x%" PRIx32 ", comp %d, watch%s",
 		dwtcr, cm->dwt_num_comp,
 		(dwtcr & (0xf << 24)) ? " only" : "/trigger");
 
@@ -2285,7 +2283,7 @@ int cortex_m_examine(struct target *target)
 			/* Search for the MEM-AP */
 			retval = cortex_m_find_mem_ap(swjdp, &armv7m->debug_ap);
 			if (retval != ERROR_OK) {
-				LOG_ERROR("Could not find MEM-AP to control the core");
+				LOG_TARGET_ERROR(target, "Could not find MEM-AP to control the core");
 				return retval;
 			}
 		} else {
@@ -2318,14 +2316,13 @@ int cortex_m_examine(struct target *target)
 		}
 
 		if (!cortex_m->core_info) {
-			LOG_ERROR("Cortex-M PARTNO 0x%x is unrecognized", core_partno);
+			LOG_TARGET_ERROR(target, "Cortex-M PARTNO 0x%x is unrecognized", core_partno);
 			return ERROR_FAIL;
 		}
 
 		armv7m->arm.arch = cortex_m->core_info->arch;
 
-		LOG_INFO("%s: %s r%" PRId8 "p%" PRId8 " processor detected",
-				target_name(target),
+		LOG_TARGET_INFO(target, "%s r%" PRId8 "p%" PRId8 " processor detected",
 				cortex_m->core_info->name,
 				(uint8_t)((cpuid >> 20) & 0xf),
 				(uint8_t)((cpuid >> 0) & 0xf));
@@ -2336,11 +2333,11 @@ int cortex_m_examine(struct target *target)
 			rev = (cpuid >> 20) & 0xf;
 			patch = (cpuid >> 0) & 0xf;
 			if ((rev == 0) && (patch < 2)) {
-				LOG_WARNING("Silicon bug: single stepping may enter pending exception handler!");
+				LOG_TARGET_WARNING(target, "Silicon bug: single stepping may enter pending exception handler!");
 				cortex_m->maskints_erratum = true;
 			}
 		}
-		LOG_DEBUG("cpuid: 0x%8.8" PRIx32 "", cpuid);
+		LOG_TARGET_DEBUG(target, "cpuid: 0x%8.8" PRIx32 "", cpuid);
 
 		if (cortex_m->core_info->flags & CORTEX_M_F_HAS_FPV4) {
 			target_read_u32(target, MVFR0, &mvfr0);
@@ -2348,7 +2345,7 @@ int cortex_m_examine(struct target *target)
 
 			/* test for floating point feature on Cortex-M4 */
 			if ((mvfr0 == MVFR0_DEFAULT_M4) && (mvfr1 == MVFR1_DEFAULT_M4)) {
-				LOG_DEBUG("%s floating point feature FPv4_SP found", cortex_m->core_info->name);
+				LOG_TARGET_DEBUG(target, "%s floating point feature FPv4_SP found", cortex_m->core_info->name);
 				armv7m->fp_feature = FPV4_SP;
 			}
 		} else if (cortex_m->core_info->flags & CORTEX_M_F_HAS_FPV5) {
@@ -2357,10 +2354,10 @@ int cortex_m_examine(struct target *target)
 
 			/* test for floating point features on Cortex-M7 */
 			if ((mvfr0 == MVFR0_DEFAULT_M7_SP) && (mvfr1 == MVFR1_DEFAULT_M7_SP)) {
-				LOG_DEBUG("%s floating point feature FPv5_SP found", cortex_m->core_info->name);
+				LOG_TARGET_DEBUG(target, "%s floating point feature FPv5_SP found", cortex_m->core_info->name);
 				armv7m->fp_feature = FPV5_SP;
 			} else if ((mvfr0 == MVFR0_DEFAULT_M7_DP) && (mvfr1 == MVFR1_DEFAULT_M7_DP)) {
-				LOG_DEBUG("%s floating point feature FPv5_DP found", cortex_m->core_info->name);
+				LOG_TARGET_DEBUG(target, "%s floating point feature FPv5_DP found", cortex_m->core_info->name);
 				armv7m->fp_feature = FPV5_DP;
 			}
 		}
@@ -2430,7 +2427,7 @@ int cortex_m_examine(struct target *target)
 			/* make sure we clear any breakpoints enabled on the target */
 			target_write_u32(target, cortex_m->fp_comparator_list[i].fpcr_address, 0);
 		}
-		LOG_DEBUG("FPB fpcr 0x%" PRIx32 ", numcode %i, numlit %i",
+		LOG_TARGET_DEBUG(target, "FPB fpcr 0x%" PRIx32 ", numcode %i, numlit %i",
 			fpcr,
 			cortex_m->fp_num_code,
 			cortex_m->fp_num_lit);
@@ -2440,8 +2437,7 @@ int cortex_m_examine(struct target *target)
 		cortex_m_dwt_setup(cortex_m, target);
 
 		/* These hardware breakpoints only work for code in flash! */
-		LOG_INFO("%s: target has %d breakpoints, %d watchpoints",
-			target_name(target),
+		LOG_TARGET_INFO(target, "target has %d breakpoints, %d watchpoints",
 			cortex_m->fp_num_code,
 			cortex_m->dwt_num_comp);
 	}
@@ -2464,7 +2460,7 @@ static int cortex_m_dcc_read(struct target *target, uint8_t *value, uint8_t *ctr
 	*ctrl = (uint8_t)dcrdr;
 	*value = (uint8_t)(dcrdr >> 8);
 
-	LOG_DEBUG("data 0x%x ctrl 0x%x", *value, *ctrl);
+	LOG_TARGET_DEBUG(target, "data 0x%x ctrl 0x%x", *value, *ctrl);
 
 	/* write ack back to software dcc register
 	 * signify we have read data */
@@ -2571,7 +2567,7 @@ static int cortex_m_target_create(struct target *target, Jim_Interp *interp)
 
 	struct cortex_m_common *cortex_m = calloc(1, sizeof(struct cortex_m_common));
 	if (!cortex_m) {
-		LOG_ERROR("No memory creating target");
+		LOG_TARGET_ERROR(target, "No memory creating target");
 		return ERROR_FAIL;
 	}
 
@@ -2628,7 +2624,7 @@ COMMAND_HANDLER(handle_cortex_m_vector_catch_command)
 		return retval;
 
 	if (!target_was_examined(target)) {
-		LOG_ERROR("Target not examined yet");
+		LOG_TARGET_ERROR(target, "Target not examined yet");
 		return ERROR_FAIL;
 	}
 
@@ -2657,7 +2653,7 @@ COMMAND_HANDLER(handle_cortex_m_vector_catch_command)
 				break;
 			}
 			if (i == ARRAY_SIZE(vec_ids)) {
-				LOG_ERROR("No CM3 vector '%s'", CMD_ARGV[CMD_ARGC]);
+				LOG_TARGET_ERROR(target, "No CM3 vector '%s'", CMD_ARGV[CMD_ARGC]);
 				return ERROR_COMMAND_SYNTAX_ERROR;
 			}
 		}
@@ -2747,7 +2743,7 @@ COMMAND_HANDLER(handle_cortex_m_reset_config_command)
 		else if (strcmp(*CMD_ARGV, "vectreset") == 0) {
 			if (target_was_examined(target)
 					&& !cortex_m->vectreset_supported)
-				LOG_WARNING("VECTRESET is not supported on your Cortex-M core!");
+				LOG_TARGET_WARNING(target, "VECTRESET is not supported on your Cortex-M core!");
 			else
 				cortex_m->soft_reset_config = CORTEX_M_RESET_VECTRESET;
 
diff --git a/src/target/cortex_m.h b/src/target/cortex_m.h
index c2f836a35..555401416 100644
--- a/src/target/cortex_m.h
+++ b/src/target/cortex_m.h
@@ -46,6 +46,7 @@
 #define ARM_CPUID_PARTNO_MASK	(0xFFF << ARM_CPUID_PARTNO_POS)
 
 enum cortex_m_partno {
+	CORTEX_M_PARTNO_INVALID,
 	CORTEX_M0_PARTNO   = 0xC20,
 	CORTEX_M1_PARTNO   = 0xC21,
 	CORTEX_M3_PARTNO   = 0xC23,
@@ -247,13 +248,6 @@ struct cortex_m_common {
 	bool maskints_erratum;
 };
 
-static inline struct cortex_m_common *
-target_to_cm(struct target *target)
-{
-	return container_of(target->arch_info,
-			struct cortex_m_common, armv7m);
-}
-
 static inline bool is_cortex_m_or_hla(const struct cortex_m_common *cortex_m)
 {
 	return cortex_m->common_magic == CORTEX_M_COMMON_MAGIC;
@@ -267,6 +261,57 @@ static inline bool is_cortex_m_with_dap_access(const struct cortex_m_common *cor
 	return !cortex_m->armv7m.is_hla_target;
 }
 
+/**
+ * @returns the pointer to the target specific struct
+ * without matching a magic number.
+ * Use in target specific service routines, where the correct
+ * type of arch_info is certain.
+ */
+static inline struct cortex_m_common *
+target_to_cm(struct target *target)
+{
+	return container_of(target->arch_info,
+			struct cortex_m_common, armv7m.arm);
+}
+
+/**
+ * @returns the pointer to the target specific struct
+ * or NULL if the magic number does not match.
+ * Use in a flash driver or any place where mismatch of the arch_info
+ * type can happen.
+ */
+static inline struct cortex_m_common *
+target_to_cortex_m_safe(struct target *target)
+{
+	/* Check the parent types first to prevent peeking memory too far
+	 * from arch_info pointer */
+	if (!target_to_armv7m_safe(target))
+		return NULL;
+
+	struct cortex_m_common *cortex_m = target_to_cm(target);
+	if (!is_cortex_m_or_hla(cortex_m))
+		return NULL;
+
+	return cortex_m;
+}
+
+/**
+ * @returns cached value of Cortex-M part number
+ * or CORTEX_M_PARTNO_INVALID if the magic number does not match
+ * or core_info is not initialised.
+ */
+static inline enum cortex_m_partno cortex_m_get_partno_safe(struct target *target)
+{
+	struct cortex_m_common *cortex_m = target_to_cortex_m_safe(target);
+	if (!cortex_m)
+		return CORTEX_M_PARTNO_INVALID;
+
+	if (!cortex_m->core_info)
+		return CORTEX_M_PARTNO_INVALID;
+
+	return cortex_m->core_info->partno;
+}
+
 int cortex_m_examine(struct target *target);
 int cortex_m_set_breakpoint(struct target *target, struct breakpoint *breakpoint);
 int cortex_m_unset_breakpoint(struct target *target, struct breakpoint *breakpoint);
diff --git a/src/target/esirisc.c b/src/target/esirisc.c
index e49f5f659..aadd111ee 100644
--- a/src/target/esirisc.c
+++ b/src/target/esirisc.c
@@ -504,7 +504,7 @@ static int esirisc_add_breakpoint(struct target *target, struct breakpoint *brea
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
 
-	breakpoint->set = bp_index + 1;
+	breakpoint_hw_set(breakpoint, bp_index);
 	esirisc->breakpoints_p[bp_index] = breakpoint;
 
 	/* specify instruction breakpoint address */
@@ -540,7 +540,7 @@ static int esirisc_add_breakpoints(struct target *target)
 	LOG_DEBUG("-");
 
 	while (breakpoint) {
-		if (breakpoint->set == 0)
+		if (!breakpoint->is_set)
 			esirisc_add_breakpoint(target, breakpoint);
 
 		breakpoint = breakpoint->next;
@@ -553,7 +553,7 @@ static int esirisc_remove_breakpoint(struct target *target, struct breakpoint *b
 {
 	struct esirisc_common *esirisc = target_to_esirisc(target);
 	struct esirisc_jtag *jtag_info = &esirisc->jtag_info;
-	int bp_index = breakpoint->set - 1;
+	unsigned int bp_index = breakpoint->number;
 	uint32_t ibc;
 	int retval;
 
@@ -575,7 +575,7 @@ static int esirisc_remove_breakpoint(struct target *target, struct breakpoint *b
 	}
 
 	esirisc->breakpoints_p[bp_index] = NULL;
-	breakpoint->set = 0;
+	breakpoint->is_set = false;
 
 	return ERROR_OK;
 }
@@ -630,7 +630,7 @@ static int esirisc_add_watchpoint(struct target *target, struct watchpoint *watc
 		return ERROR_FAIL;
 	}
 
-	watchpoint->set = wp_index + 1;
+	watchpoint_set(watchpoint, wp_index);
 	esirisc->watchpoints_p[wp_index] = watchpoint;
 
 	/* specify data breakpoint address */
@@ -724,7 +724,7 @@ static int esirisc_add_watchpoints(struct target *target)
 	LOG_DEBUG("-");
 
 	while (watchpoint) {
-		if (watchpoint->set == 0)
+		if (!watchpoint->is_set)
 			esirisc_add_watchpoint(target, watchpoint);
 
 		watchpoint = watchpoint->next;
@@ -737,7 +737,7 @@ static int esirisc_remove_watchpoint(struct target *target, struct watchpoint *w
 {
 	struct esirisc_common *esirisc = target_to_esirisc(target);
 	struct esirisc_jtag *jtag_info = &esirisc->jtag_info;
-	int wp_index = watchpoint->set - 1;
+	unsigned int wp_index = watchpoint->number;
 	uint32_t dbc;
 	int retval;
 
@@ -759,7 +759,7 @@ static int esirisc_remove_watchpoint(struct target *target, struct watchpoint *w
 	}
 
 	esirisc->watchpoints_p[wp_index] = NULL;
-	watchpoint->set = 0;
+	watchpoint->is_set = false;
 
 	return ERROR_OK;
 }
diff --git a/src/target/image.c b/src/target/image.c
index eafa73eaa..130ea6c1f 100644
--- a/src/target/image.c
+++ b/src/target/image.c
@@ -596,7 +596,7 @@ static int image_elf64_read_headers(struct image *image)
 				image->sections[j].base_address = field64(elf,
 						elf->segments64[i].p_paddr);
 			image->sections[j].private = &elf->segments64[i];
-			image->sections[j].flags = field32(elf, elf->segments64[i].p_flags);
+			image->sections[j].flags = field64(elf, elf->segments64[i].p_flags);
 			j++;
 		}
 	}
@@ -1168,7 +1168,7 @@ int image_read_section(struct image *image,
 	return ERROR_OK;
 }
 
-int image_add_section(struct image *image, target_addr_t base, uint32_t size, int flags, uint8_t const *data)
+int image_add_section(struct image *image, target_addr_t base, uint32_t size, uint64_t flags, uint8_t const *data)
 {
 	struct imagesection *section;
 
diff --git a/src/target/image.h b/src/target/image.h
index 5b5d11f6b..bf06064ac 100644
--- a/src/target/image.h
+++ b/src/target/image.h
@@ -52,7 +52,7 @@ enum image_type {
 struct imagesection {
 	target_addr_t base_address;
 	uint32_t size;
-	int flags;
+	uint64_t flags;
 	void *private;		/* private data */
 };
 
@@ -108,7 +108,7 @@ int image_read_section(struct image *image, int section, target_addr_t offset,
 void image_close(struct image *image);
 
 int image_add_section(struct image *image, target_addr_t base, uint32_t size,
-		int flags, uint8_t const *data);
+		uint64_t flags, uint8_t const *data);
 
 int image_calculate_checksum(const uint8_t *buffer, uint32_t nbytes,
 		uint32_t *checksum);
diff --git a/src/target/lakemont.c b/src/target/lakemont.c
index e46ee5cf8..230f53fe0 100644
--- a/src/target/lakemont.c
+++ b/src/target/lakemont.c
@@ -1024,10 +1024,10 @@ int lakemont_resume(struct target *t, int current, target_addr_t address,
 
 		/* if breakpoints are enabled, we need to redirect these into probe mode */
 		struct breakpoint *activeswbp = t->breakpoints;
-		while (activeswbp && activeswbp->set == 0)
+		while (activeswbp && !activeswbp->is_set)
 			activeswbp = activeswbp->next;
 		struct watchpoint *activehwbp = t->watchpoints;
-		while (activehwbp && activehwbp->set == 0)
+		while (activehwbp && !activehwbp->is_set)
 			activehwbp = activehwbp->next;
 		if (activeswbp || activehwbp)
 			buf_set_u32(x86_32->cache->reg_list[PMCR].value, 0, 32, 1);
diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index ca4416981..860119345 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -128,14 +128,11 @@ static int mips_m4k_debug_entry(struct target *target)
 static struct target *get_mips_m4k(struct target *target, int32_t coreid)
 {
 	struct target_list *head;
-	struct target *curr;
 
-	head = target->head;
-	while (head) {
-		curr = head->target;
+	foreach_smp_target(head, target->smp_targets) {
+		struct target *curr = head->target;
 		if ((curr->coreid == coreid) && (curr->state == TARGET_HALTED))
 			return curr;
-		head = head->next;
 	}
 	return target;
 }
@@ -144,11 +141,10 @@ static int mips_m4k_halt_smp(struct target *target)
 {
 	int retval = ERROR_OK;
 	struct target_list *head;
-	struct target *curr;
-	head = target->head;
-	while (head) {
+
+	foreach_smp_target(head, target->smp_targets) {
 		int ret = ERROR_OK;
-		curr = head->target;
+		struct target *curr = head->target;
 		if ((curr != target) && (curr->state != TARGET_HALTED))
 			ret = mips_m4k_halt(curr);
 
@@ -156,7 +152,6 @@ static int mips_m4k_halt_smp(struct target *target)
 			LOG_ERROR("halt failed target->coreid: %" PRId32, curr->coreid);
 			retval = ret;
 		}
-		head = head->next;
 	}
 	return retval;
 }
@@ -414,12 +409,10 @@ static int mips_m4k_restore_smp(struct target *target, uint32_t address, int han
 {
 	int retval = ERROR_OK;
 	struct target_list *head;
-	struct target *curr;
 
-	head = target->head;
-	while (head) {
+	foreach_smp_target(head, target->smp_targets) {
 		int ret = ERROR_OK;
-		curr = head->target;
+		struct target *curr = head->target;
 		if ((curr != target) && (curr->state != TARGET_RUNNING)) {
 			/*  resume current address , not in step mode */
 			ret = mips_m4k_internal_restore(curr, 1, address,
@@ -431,7 +424,6 @@ static int mips_m4k_restore_smp(struct target *target, uint32_t address, int han
 				retval = ret;
 			}
 		}
-		head = head->next;
 	}
 	return retval;
 }
@@ -601,7 +593,7 @@ static void mips_m4k_enable_breakpoints(struct target *target)
 
 	/* set any pending breakpoints */
 	while (breakpoint) {
-		if (breakpoint->set == 0)
+		if (!breakpoint->is_set)
 			mips_m4k_set_breakpoint(target, breakpoint);
 		breakpoint = breakpoint->next;
 	}
@@ -615,7 +607,7 @@ static int mips_m4k_set_breakpoint(struct target *target,
 	struct mips32_comparator *comparator_list = mips32->inst_break_list;
 	int retval;
 
-	if (breakpoint->set) {
+	if (breakpoint->is_set) {
 		LOG_WARNING("breakpoint already set");
 		return ERROR_OK;
 	}
@@ -630,7 +622,7 @@ static int mips_m4k_set_breakpoint(struct target *target,
 					breakpoint->unique_id);
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
-		breakpoint->set = bp_num + 1;
+		breakpoint_hw_set(breakpoint, bp_num);
 		comparator_list[bp_num].used = 1;
 		comparator_list[bp_num].bp_value = breakpoint->address;
 
@@ -732,7 +724,7 @@ static int mips_m4k_set_breakpoint(struct target *target,
 			}
 		}
 
-		breakpoint->set = 20; /* Any nice value but 0 */
+		breakpoint->is_set = true;
 	}
 
 	return ERROR_OK;
@@ -747,14 +739,14 @@ static int mips_m4k_unset_breakpoint(struct target *target,
 	struct mips32_comparator *comparator_list = mips32->inst_break_list;
 	int retval;
 
-	if (!breakpoint->set) {
+	if (!breakpoint->is_set) {
 		LOG_WARNING("breakpoint not set");
 		return ERROR_OK;
 	}
 
 	if (breakpoint->type == BKPT_HARD) {
-		int bp_num = breakpoint->set - 1;
-		if ((bp_num < 0) || (bp_num >= mips32->num_inst_bpoints)) {
+		int bp_num = breakpoint->number;
+		if (bp_num >= mips32->num_inst_bpoints) {
 			LOG_DEBUG("Invalid FP Comparator number in breakpoint (bpid: %" PRIu32 ")",
 					  breakpoint->unique_id);
 			return ERROR_OK;
@@ -821,7 +813,7 @@ static int mips_m4k_unset_breakpoint(struct target *target,
 		}
 	}
 
-	breakpoint->set = 0;
+	breakpoint->is_set = false;
 
 	return ERROR_OK;
 }
@@ -859,7 +851,7 @@ static int mips_m4k_remove_breakpoint(struct target *target,
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if (breakpoint->set)
+	if (breakpoint->is_set)
 		mips_m4k_unset_breakpoint(target, breakpoint);
 
 	if (breakpoint->type == BKPT_HARD)
@@ -883,7 +875,7 @@ static int mips_m4k_set_watchpoint(struct target *target,
 	int enable = EJTAG_DBCN_NOSB | EJTAG_DBCN_NOLB | EJTAG_DBCN_BE |
 			(0xff << EJTAG_DBCN_BLM_SHIFT);
 
-	if (watchpoint->set) {
+	if (watchpoint->is_set) {
 		LOG_WARNING("watchpoint already set");
 		return ERROR_OK;
 	}
@@ -919,7 +911,7 @@ static int mips_m4k_set_watchpoint(struct target *target,
 			LOG_ERROR("BUG: watchpoint->rw neither read, write nor access");
 	}
 
-	watchpoint->set = wp_num + 1;
+	watchpoint->number = wp_num;
 	comparator_list[wp_num].used = 1;
 	comparator_list[wp_num].bp_value = watchpoint->address;
 
@@ -954,13 +946,13 @@ static int mips_m4k_unset_watchpoint(struct target *target,
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
 	struct mips32_comparator *comparator_list = mips32->data_break_list;
 
-	if (!watchpoint->set) {
+	if (!watchpoint->is_set) {
 		LOG_WARNING("watchpoint not set");
 		return ERROR_OK;
 	}
 
-	int wp_num = watchpoint->set - 1;
-	if ((wp_num < 0) || (wp_num >= mips32->num_data_bpoints)) {
+	int wp_num = watchpoint->number;
+	if (wp_num >= mips32->num_data_bpoints) {
 		LOG_DEBUG("Invalid FP Comparator number in watchpoint");
 		return ERROR_OK;
 	}
@@ -968,7 +960,7 @@ static int mips_m4k_unset_watchpoint(struct target *target,
 	comparator_list[wp_num].bp_value = 0;
 	target_write_u32(target, comparator_list[wp_num].reg_address +
 			 ejtag_info->ejtag_dbc_offs, 0);
-	watchpoint->set = 0;
+	watchpoint->is_set = false;
 
 	return ERROR_OK;
 }
@@ -999,7 +991,7 @@ static int mips_m4k_remove_watchpoint(struct target *target,
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if (watchpoint->set)
+	if (watchpoint->is_set)
 		mips_m4k_unset_watchpoint(target, watchpoint);
 
 	mips32->num_data_bpoints_avail++;
@@ -1013,7 +1005,7 @@ static void mips_m4k_enable_watchpoints(struct target *target)
 
 	/* set any pending watchpoints */
 	while (watchpoint) {
-		if (watchpoint->set == 0)
+		if (!watchpoint->is_set)
 			mips_m4k_set_watchpoint(target, watchpoint);
 		watchpoint = watchpoint->next;
 	}
diff --git a/src/target/mips_mips64.c b/src/target/mips_mips64.c
index 56b0194e7..5d821d7cb 100644
--- a/src/target/mips_mips64.c
+++ b/src/target/mips_mips64.c
@@ -346,7 +346,7 @@ static int mips_mips64_set_breakpoint(struct target *target,
 {
 	int retval;
 
-	if (bp->set) {
+	if (bp->is_set) {
 		LOG_WARNING("breakpoint already set");
 		return ERROR_OK;
 	}
@@ -373,7 +373,7 @@ static int mips_mips64_set_breakpoint(struct target *target,
 		return retval;
 	}
 
-	bp->set = true;
+	bp->is_set = true;
 
 	return ERROR_OK;
 }
@@ -385,7 +385,7 @@ static int mips_mips64_enable_breakpoints(struct target *target)
 
 	/* set any pending breakpoints */
 	while (bp) {
-		if (!bp->set) {
+		if (!bp->is_set) {
 			retval = mips_mips64_set_breakpoint(target, bp);
 			if (retval != ERROR_OK)
 				return retval;
@@ -413,7 +413,7 @@ static int mips_mips64_set_watchpoint(struct target *target,
 	int enable = EJTAG_DBCN_NOSB | EJTAG_DBCN_NOLB | EJTAG_DBCN_BE
 		| (0xff << EJTAG_DBCN_BLM_SHIFT);
 
-	if (watchpoint->set) {
+	if (watchpoint->is_set) {
 		LOG_WARNING("watchpoint already set");
 		return ERROR_OK;
 	}
@@ -451,7 +451,7 @@ static int mips_mips64_set_watchpoint(struct target *target,
 	}
 
 	c = &cl[wp_num];
-	watchpoint->set = wp_num + 1;
+	watchpoint_set(watchpoint, wp_num);
 	c->used = true;
 	c->bp_value = watchpoint->address;
 
@@ -491,7 +491,7 @@ static int mips_mips64_enable_watchpoints(struct target *target)
 
 	/* set any pending watchpoints */
 	while (watchpoint) {
-		if (watchpoint->set == 0) {
+		if (!watchpoint->is_set) {
 			retval = mips_mips64_set_watchpoint(target, watchpoint);
 			if (retval != ERROR_OK)
 				return retval;
@@ -506,11 +506,10 @@ static int mips_mips64_unset_hwbp(struct target *target, struct breakpoint *bp)
 {
 	struct mips64_common *mips64 = target->arch_info;
 	struct mips64_comparator *comparator_list = mips64->inst_break_list;
-	int bp_num;
 
-	bp_num = bp->set - 1;
+	int bp_num = bp->number;
 
-	if ((bp_num < 0) || (bp_num >= mips64->num_inst_bpoints)) {
+	if (bp_num >= mips64->num_inst_bpoints) {
 		LOG_DEBUG("Invalid FP Comparator number in breakpoint (bpid: %" PRIu32 ")",
 			  bp->unique_id);
 		return ERROR_OK;
@@ -568,7 +567,7 @@ static int mips_mips64_unset_breakpoint(struct target *target,
 	/* get pointers to arch-specific information */
 	int retval;
 
-	if (!bp->set) {
+	if (!bp->is_set) {
 		LOG_WARNING("breakpoint not set");
 		return ERROR_OK;
 	}
@@ -594,7 +593,7 @@ static int mips_mips64_unset_breakpoint(struct target *target,
 		return retval;
 	}
 
-	bp->set = false;
+	bp->is_set = false;
 
 	return ERROR_OK;
 }
@@ -815,7 +814,7 @@ static int mips_mips64_remove_breakpoint(struct target *target,
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if (bp->set)
+	if (bp->is_set)
 		retval = mips_mips64_unset_breakpoint(target, bp);
 
 	if (bp->type == BKPT_HARD)
@@ -831,20 +830,20 @@ static int mips_mips64_unset_watchpoint(struct target *target,
 	struct mips64_common *mips64 = target->arch_info;
 	struct mips64_comparator *comparator_list = mips64->data_break_list;
 
-	if (!watchpoint->set) {
+	if (!watchpoint->is_set) {
 		LOG_WARNING("watchpoint not set");
 		return ERROR_OK;
 	}
 
-	int wp_num = watchpoint->set - 1;
-	if ((wp_num < 0) || (wp_num >= mips64->num_data_bpoints)) {
+	int wp_num = watchpoint->number;
+	if (wp_num >= mips64->num_data_bpoints) {
 		LOG_DEBUG("Invalid FP Comparator number in watchpoint");
 		return ERROR_OK;
 	}
 	comparator_list[wp_num].used = false;
 	comparator_list[wp_num].bp_value = 0;
 	target_write_u64(target, comparator_list[wp_num].reg_address + 0x18, 0);
-	watchpoint->set = 0;
+	watchpoint->is_set = false;
 
 	return ERROR_OK;
 }
@@ -876,7 +875,7 @@ static int mips_mips64_remove_watchpoint(struct target *target,
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if (watchpoint->set)
+	if (watchpoint->is_set)
 		retval = mips_mips64_unset_watchpoint(target, watchpoint);
 
 	mips64->num_data_bpoints_avail++;
diff --git a/src/target/nds32.c b/src/target/nds32.c
index 12340ac2c..f0fb74d31 100644
--- a/src/target/nds32.c
+++ b/src/target/nds32.c
@@ -1653,7 +1653,7 @@ int nds32_init_arch_info(struct target *target, struct nds32 *nds32)
 
 	nds32->syscall_break.asid = 0;
 	nds32->syscall_break.length = 4;
-	nds32->syscall_break.set = 0;
+	nds32->syscall_break.is_set = false;
 	nds32->syscall_break.orig_instr = NULL;
 	nds32->syscall_break.next = NULL;
 	nds32->syscall_break.unique_id = 0x515CAll + target->target_number;
diff --git a/src/target/nds32_v3_common.c b/src/target/nds32_v3_common.c
index b0c3de622..8ff8e30c6 100644
--- a/src/target/nds32_v3_common.c
+++ b/src/target/nds32_v3_common.c
@@ -78,12 +78,12 @@ static int nds32_v3_debug_entry(struct nds32 *nds32, bool enable_watchpoint)
 
 	struct breakpoint *syscall_break = &(nds32->syscall_break);
 	if (nds32->virtual_hosting) {
-		if (syscall_break->set) {
+		if (syscall_break->is_set) {
 			/** disable virtual hosting */
 
 			/* remove breakpoint at syscall entry */
 			target_remove_breakpoint(nds32->target, syscall_break);
-			syscall_break->set = 0;
+			syscall_break->is_set = false;
 
 			uint32_t value_pc;
 			nds32_get_mapped_reg(nds32, PC, &value_pc);
@@ -209,7 +209,7 @@ static int nds32_v3_leave_debug_state(struct nds32 *nds32, bool enable_watchpoin
 
 		syscall_break->address = syscall_address;
 		syscall_break->type = BKPT_SOFT;
-		syscall_break->set = 1;
+		syscall_break->is_set = true;
 		target_add_breakpoint(target, syscall_break);
 	}
 
diff --git a/src/target/openrisc/jsp_server.c b/src/target/openrisc/jsp_server.c
index e0a4475cf..54c969424 100644
--- a/src/target/openrisc/jsp_server.c
+++ b/src/target/openrisc/jsp_server.c
@@ -195,19 +195,22 @@ static int jsp_connection_closed(struct connection *connection)
 	return ERROR_OK;
 }
 
+static const struct service_driver jsp_service_driver = {
+	.name = "jsp",
+	.new_connection_during_keep_alive_handler = NULL,
+	.new_connection_handler = jsp_new_connection,
+	.input_handler = jsp_input,
+	.connection_closed_handler = jsp_connection_closed,
+	.keep_client_alive_handler = NULL,
+};
+
 int jsp_init(struct or1k_jtag *jtag_info, char *banner)
 {
 	struct jsp_service *jsp_service = malloc(sizeof(struct jsp_service));
 	jsp_service->banner = banner;
 	jsp_service->jtag_info = jtag_info;
 
-	return add_service("jsp",
-		jsp_port,
-		1,
-		jsp_new_connection,
-		jsp_input,
-		jsp_connection_closed,
-		jsp_service);
+	return add_service(&jsp_service_driver, jsp_port, 1, jsp_service);
 }
 
 COMMAND_HANDLER(handle_jsp_port_command)
diff --git a/src/target/openrisc/or1k.c b/src/target/openrisc/or1k.c
index 8fbcd9620..77fa15d50 100644
--- a/src/target/openrisc/or1k.c
+++ b/src/target/openrisc/or1k.c
@@ -923,9 +923,9 @@ static int or1k_add_breakpoint(struct target *target,
 	struct or1k_du *du_core = or1k_to_du(or1k);
 	uint8_t data;
 
-	LOG_DEBUG("Adding breakpoint: addr 0x%08" TARGET_PRIxADDR ", len %d, type %d, set: %d, id: %" PRIu32,
+	LOG_DEBUG("Adding breakpoint: addr 0x%08" TARGET_PRIxADDR ", len %d, type %d, id: %" PRIu32,
 		  breakpoint->address, breakpoint->length, breakpoint->type,
-		  breakpoint->set, breakpoint->unique_id);
+		  breakpoint->unique_id);
 
 	/* Only support SW breakpoints for now. */
 	if (breakpoint->type == BKPT_HARD)
@@ -981,9 +981,9 @@ static int or1k_remove_breakpoint(struct target *target,
 	struct or1k_common *or1k = target_to_or1k(target);
 	struct or1k_du *du_core = or1k_to_du(or1k);
 
-	LOG_DEBUG("Removing breakpoint: addr 0x%08" TARGET_PRIxADDR ", len %d, type %d, set: %d, id: %" PRIu32,
+	LOG_DEBUG("Removing breakpoint: addr 0x%08" TARGET_PRIxADDR ", len %d, type %d, id: %" PRIu32,
 		  breakpoint->address, breakpoint->length, breakpoint->type,
-		  breakpoint->set, breakpoint->unique_id);
+		  breakpoint->unique_id);
 
 	/* Only support SW breakpoints for now. */
 	if (breakpoint->type == BKPT_HARD)
diff --git a/src/target/riscv/riscv-013.c b/src/target/riscv/riscv-013.c
index 7af460241..2b9179d53 100644
--- a/src/target/riscv/riscv-013.c
+++ b/src/target/riscv/riscv-013.c
@@ -2308,9 +2308,11 @@ static int init_target(struct command_context *cmd_ctx,
 	generic_info->hart_count = &riscv013_hart_count;
 	generic_info->data_bits = &riscv013_data_bits;
 	generic_info->print_info = &riscv013_print_info;
-	generic_info->version_specific = calloc(1, sizeof(riscv013_info_t));
-	if (!generic_info->version_specific)
-		return ERROR_FAIL;
+	if (!generic_info->version_specific) {
+		generic_info->version_specific = calloc(1, sizeof(riscv013_info_t));
+		if (!generic_info->version_specific)
+			return ERROR_FAIL;
+	}
 	generic_info->sample_memory = sample_memory;
 	riscv013_info_t *info = get_info(target);
 
diff --git a/src/target/riscv/riscv.c b/src/target/riscv/riscv.c
index 407b7e279..a266f5da3 100644
--- a/src/target/riscv/riscv.c
+++ b/src/target/riscv/riscv.c
@@ -13,6 +13,7 @@
 #include "target/target.h"
 #include "target/algorithm.h"
 #include "target/target_type.h"
+#include <target/smp.h>
 #include "jtag/jtag.h"
 #include "target/register.h"
 #include "target/breakpoints.h"
@@ -476,6 +477,8 @@ static void riscv_free_registers(struct target *target)
 			/* Free the ones we allocated separately. */
 			for (unsigned i = GDB_REGNO_COUNT; i < target->reg_cache->num_regs; i++)
 				free(target->reg_cache->reg_list[i].arch_info);
+			for (unsigned int i = 0; i < target->reg_cache->num_regs; i++)
+				free(target->reg_cache->reg_list[i].value);
 			free(target->reg_cache->reg_list);
 		}
 		free(target->reg_cache);
@@ -900,7 +903,7 @@ int riscv_add_breakpoint(struct target *target, struct breakpoint *breakpoint)
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
 
-	breakpoint->set = true;
+	breakpoint->is_set = true;
 	return ERROR_OK;
 }
 
@@ -960,7 +963,7 @@ int riscv_remove_breakpoint(struct target *target,
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
 
-	breakpoint->set = false;
+	breakpoint->is_set = false;
 
 	return ERROR_OK;
 }
@@ -987,7 +990,7 @@ int riscv_add_watchpoint(struct target *target, struct watchpoint *watchpoint)
 	int result = add_trigger(target, &trigger);
 	if (result != ERROR_OK)
 		return result;
-	watchpoint->set = true;
+	watchpoint->is_set = true;
 
 	return ERROR_OK;
 }
@@ -1003,7 +1006,7 @@ int riscv_remove_watchpoint(struct target *target,
 	int result = remove_trigger(target, &trigger);
 	if (result != ERROR_OK)
 		return result;
-	watchpoint->set = false;
+	watchpoint->is_set = false;
 
 	return ERROR_OK;
 }
@@ -1230,13 +1233,14 @@ int riscv_halt(struct target *target)
 
 	int result = ERROR_OK;
 	if (target->smp) {
-		for (struct target_list *tlist = target->head; tlist; tlist = tlist->next) {
+		struct target_list *tlist;
+		foreach_smp_target(tlist, target->smp_targets) {
 			struct target *t = tlist->target;
 			if (halt_prep(t) != ERROR_OK)
 				result = ERROR_FAIL;
 		}
 
-		for (struct target_list *tlist = target->head; tlist; tlist = tlist->next) {
+		foreach_smp_target(tlist, target->smp_targets) {
 			struct target *t = tlist->target;
 			riscv_info_t *i = riscv_info(t);
 			if (i->prepped) {
@@ -1245,7 +1249,7 @@ int riscv_halt(struct target *target)
 			}
 		}
 
-		for (struct target_list *tlist = target->head; tlist; tlist = tlist->next) {
+		foreach_smp_target(tlist, target->smp_targets) {
 			struct target *t = tlist->target;
 			if (halt_finish(t) != ERROR_OK)
 				return ERROR_FAIL;
@@ -1334,9 +1338,9 @@ static int disable_triggers(struct target *target, riscv_reg_t *state)
 		struct watchpoint *watchpoint = target->watchpoints;
 		int i = 0;
 		while (watchpoint) {
-			LOG_DEBUG("watchpoint %d: set=%d", i, watchpoint->set);
-			state[i] = watchpoint->set;
-			if (watchpoint->set) {
+			LOG_DEBUG("watchpoint %d: set=%d", i, watchpoint->is_set);
+			state[i] = watchpoint->is_set;
+			if (watchpoint->is_set) {
 				if (riscv_remove_watchpoint(target, watchpoint) != ERROR_OK)
 					return ERROR_FAIL;
 			}
@@ -1467,14 +1471,17 @@ int riscv_resume(
 	LOG_DEBUG("handle_breakpoints=%d", handle_breakpoints);
 	int result = ERROR_OK;
 	if (target->smp && !single_hart) {
-		for (struct target_list *tlist = target->head; tlist; tlist = tlist->next) {
+		struct target_list *tlist;
+		foreach_smp_target_direction(resume_order == RO_NORMAL,
+									 tlist, target->smp_targets) {
 			struct target *t = tlist->target;
 			if (resume_prep(t, current, address, handle_breakpoints,
 						debug_execution) != ERROR_OK)
 				result = ERROR_FAIL;
 		}
 
-		for (struct target_list *tlist = target->head; tlist; tlist = tlist->next) {
+		foreach_smp_target_direction(resume_order == RO_NORMAL,
+									 tlist, target->smp_targets) {
 			struct target *t = tlist->target;
 			riscv_info_t *i = riscv_info(t);
 			if (i->prepped) {
@@ -1484,7 +1491,8 @@ int riscv_resume(
 			}
 		}
 
-		for (struct target_list *tlist = target->head; tlist; tlist = tlist->next) {
+		foreach_smp_target_direction(resume_order == RO_NORMAL,
+									 tlist, target->smp_targets) {
 			struct target *t = tlist->target;
 			if (resume_finish(t) != ERROR_OK)
 				return ERROR_FAIL;
@@ -1749,8 +1757,8 @@ static int riscv_get_gdb_reg_list_internal(struct target *target,
 		enum target_register_class reg_class, bool read)
 {
 	RISCV_INFO(r);
-	LOG_DEBUG("current_hartid=%d, reg_class=%d, read=%d",
-			r->current_hartid, reg_class, read);
+	LOG_DEBUG("[%s] {%d} reg_class=%d, read=%d",
+			target_name(target), r->current_hartid, reg_class, read);
 
 	if (!target->reg_cache) {
 		LOG_ERROR("Target not initialized. Return ERROR_FAIL.");
@@ -2178,9 +2186,8 @@ int riscv_openocd_poll(struct target *target)
 		unsigned halts_discovered = 0;
 		unsigned should_remain_halted = 0;
 		unsigned should_resume = 0;
-		unsigned i = 0;
-		for (struct target_list *list = target->head; list;
-				list = list->next, i++) {
+		struct target_list *list;
+		foreach_smp_target(list, target->smp_targets) {
 			struct target *t = list->target;
 			riscv_info_t *r = riscv_info(t);
 			enum riscv_poll_hart out = riscv_poll_hart(t, r->current_hartid);
@@ -2240,8 +2247,7 @@ int riscv_openocd_poll(struct target *target)
 		}
 
 		/* Sample memory if any target is running. */
-		for (struct target_list *list = target->head; list;
-				list = list->next, i++) {
+		foreach_smp_target(list, target->smp_targets) {
 			struct target *t = list->target;
 			if (t->state == TARGET_RUNNING) {
 				sample_memory(target);
@@ -4479,7 +4485,7 @@ int riscv_init_registers(struct target *target)
 			assert(reg_name < info->reg_names + target->reg_cache->num_regs *
 					max_reg_name_len);
 		}
-		r->value = info->reg_cache_values[number];
+		r->value = calloc(1, DIV_ROUND_UP(r->size, 8));
 	}
 
 	return ERROR_OK;
diff --git a/src/target/riscv/riscv.h b/src/target/riscv/riscv.h
index d0f4f6ec0..0ae8945da 100644
--- a/src/target/riscv/riscv.h
+++ b/src/target/riscv/riscv.h
@@ -96,11 +96,6 @@ typedef struct {
 	 * every function than an actual */
 	int current_hartid;
 
-	/* OpenOCD's register cache points into here. This is not per-hart because
-	 * we just invalidate the entire cache when we change which hart is
-	 * selected. Use an array of 8 uint8_t per register. */
-	uint8_t reg_cache_values[RISCV_MAX_REGISTERS][8];
-
 	/* Single buffer that contains all register names, instead of calling
 	 * malloc for each register. Needs to be freed when reg_list is freed. */
 	char *reg_names;
diff --git a/src/target/riscv/riscv_semihosting.c b/src/target/riscv/riscv_semihosting.c
index b347212d3..1dd8e7791 100644
--- a/src/target/riscv/riscv_semihosting.c
+++ b/src/target/riscv/riscv_semihosting.c
@@ -140,7 +140,9 @@ semihosting_result_t riscv_semihosting(struct target *target, int *retval)
 		semihosting->word_size_bytes = riscv_xlen(target) / 8;
 
 		/* Check for ARM operation numbers. */
-		if (semihosting->op >= 0 && semihosting->op <= 0x31) {
+		if ((semihosting->op >= 0 && semihosting->op <= 0x31) ||
+			(semihosting->op >= 0x100 && semihosting->op <= 0x107)) {
+
 			*retval = semihosting_common(target);
 			if (*retval != ERROR_OK) {
 				LOG_ERROR("Failed semihosting operation (0x%02X)", semihosting->op);
diff --git a/src/target/rtt.c b/src/target/rtt.c
index 7e556e1cb..41830213d 100644
--- a/src/target/rtt.c
+++ b/src/target/rtt.c
@@ -15,6 +15,10 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include <stddef.h>
 #include <stdint.h>
 #include <helper/log.h>
diff --git a/src/target/semihosting_common.c b/src/target/semihosting_common.c
index 5c96e1cd6..bc1f417ef 100644
--- a/src/target/semihosting_common.c
+++ b/src/target/semihosting_common.c
@@ -52,19 +52,50 @@
 #include <helper/log.h>
 #include <sys/stat.h>
 
-static const int open_modeflags[12] = {
+/**
+ * It is not possible to use O_... flags defined in sys/stat.h because they
+ * are not guaranteed to match the values defined by the GDB Remote Protocol.
+ * See https://sourceware.org/gdb/onlinedocs/gdb/Open-Flags.html#Open-Flags
+ */
+enum {
+	TARGET_O_RDONLY = 0x000,
+	TARGET_O_WRONLY = 0x001,
+	TARGET_O_RDWR   = 0x002,
+	TARGET_O_APPEND = 0x008,
+	TARGET_O_CREAT  = 0x200,
+	TARGET_O_TRUNC  = 0x400,
+	/* O_EXCL=0x800 is not required in this implementation. */
+};
+
+/* GDB remote protocol does not differentiate between text and binary open modes. */
+static const int open_gdb_modeflags[12] = {
+	TARGET_O_RDONLY,
+	TARGET_O_RDONLY,
+	TARGET_O_RDWR,
+	TARGET_O_RDWR,
+	TARGET_O_WRONLY | TARGET_O_CREAT | TARGET_O_TRUNC,
+	TARGET_O_WRONLY | TARGET_O_CREAT | TARGET_O_TRUNC,
+	TARGET_O_RDWR   | TARGET_O_CREAT | TARGET_O_TRUNC,
+	TARGET_O_RDWR   | TARGET_O_CREAT | TARGET_O_TRUNC,
+	TARGET_O_WRONLY | TARGET_O_CREAT | TARGET_O_APPEND,
+	TARGET_O_WRONLY | TARGET_O_CREAT | TARGET_O_APPEND,
+	TARGET_O_RDWR   | TARGET_O_CREAT | TARGET_O_APPEND,
+	TARGET_O_RDWR   | TARGET_O_CREAT | TARGET_O_APPEND
+};
+
+static const int open_host_modeflags[12] = {
 	O_RDONLY,
 	O_RDONLY | O_BINARY,
 	O_RDWR,
-	O_RDWR | O_BINARY,
+	O_RDWR   | O_BINARY,
 	O_WRONLY | O_CREAT | O_TRUNC,
-	O_WRONLY | O_CREAT | O_TRUNC | O_BINARY,
-	O_RDWR | O_CREAT | O_TRUNC,
-	O_RDWR | O_CREAT | O_TRUNC | O_BINARY,
+	O_WRONLY | O_CREAT | O_TRUNC  | O_BINARY,
+	O_RDWR   | O_CREAT | O_TRUNC,
+	O_RDWR   | O_CREAT | O_TRUNC  | O_BINARY,
 	O_WRONLY | O_CREAT | O_APPEND,
 	O_WRONLY | O_CREAT | O_APPEND | O_BINARY,
-	O_RDWR | O_CREAT | O_APPEND,
-	O_RDWR | O_CREAT | O_APPEND | O_BINARY
+	O_RDWR   | O_CREAT | O_APPEND,
+	O_RDWR   | O_CREAT | O_APPEND | O_BINARY
 };
 
 static int semihosting_common_fileio_info(struct target *target,
@@ -113,6 +144,11 @@ int semihosting_common_init(struct target *target, void *setup,
 	}
 
 	semihosting->is_active = false;
+	semihosting->redirect_cfg = SEMIHOSTING_REDIRECT_CFG_NONE;
+	semihosting->tcp_connection = NULL;
+	semihosting->stdin_fd = -1;
+	semihosting->stdout_fd = -1;
+	semihosting->stderr_fd = -1;
 	semihosting->is_fileio = false;
 	semihosting->hit_fileio = false;
 	semihosting->is_resumable = false;
@@ -138,6 +174,147 @@ int semihosting_common_init(struct target *target, void *setup,
 	return ERROR_OK;
 }
 
+struct semihosting_tcp_service {
+	struct semihosting *semihosting;
+	char *name;
+	int error;
+};
+
+static bool semihosting_is_redirected(struct semihosting *semihosting, int fd)
+{
+	if (semihosting->redirect_cfg == SEMIHOSTING_REDIRECT_CFG_NONE)
+		return false;
+
+	bool is_read_op = false;
+
+	switch (semihosting->op) {
+	/* check debug semihosting operations: READC, WRITEC and WRITE0 */
+	case SEMIHOSTING_SYS_READC:
+		is_read_op = true;
+		/* fall through */
+	case SEMIHOSTING_SYS_WRITEC:
+	case SEMIHOSTING_SYS_WRITE0:
+		/* debug operations are redirected when CFG is either DEBUG or ALL */
+		if (semihosting->redirect_cfg == SEMIHOSTING_REDIRECT_CFG_STDIO)
+			return false;
+		break;
+
+	/* check stdio semihosting operations: READ and WRITE */
+	case SEMIHOSTING_SYS_READ:
+		is_read_op = true;
+		/* fall through */
+	case SEMIHOSTING_SYS_WRITE:
+		/* stdio operations are redirected when CFG is either STDIO or ALL */
+		if (semihosting->redirect_cfg == SEMIHOSTING_REDIRECT_CFG_DEBUG)
+			return false;
+		break;
+
+	default:
+		return false;
+	}
+
+	if (is_read_op)
+		return fd == semihosting->stdin_fd;
+
+	/* write operation */
+	return fd == semihosting->stdout_fd || fd == semihosting->stderr_fd;
+}
+
+static ssize_t semihosting_redirect_write(struct semihosting *semihosting, void *buf, int size)
+{
+	if (!semihosting->tcp_connection) {
+		LOG_ERROR("No connected TCP client for semihosting");
+		semihosting->sys_errno = EBADF; /* Bad file number */
+		return -1;
+	}
+
+	struct semihosting_tcp_service *service = semihosting->tcp_connection->service->priv;
+
+	int retval = connection_write(semihosting->tcp_connection, buf, size);
+
+	if (retval < 0)
+		log_socket_error(service->name);
+
+	return retval;
+}
+
+static ssize_t semihosting_write(struct semihosting *semihosting, int fd, void *buf, int size)
+{
+	if (semihosting_is_redirected(semihosting, fd))
+		return semihosting_redirect_write(semihosting, buf, size);
+
+	/* default write */
+	return write(fd, buf, size);
+}
+
+static ssize_t semihosting_redirect_read(struct semihosting *semihosting, void *buf, int size)
+{
+	if (!semihosting->tcp_connection) {
+		LOG_ERROR("No connected TCP client for semihosting");
+		semihosting->sys_errno = EBADF; /* Bad file number */
+		return -1;
+	}
+
+	struct semihosting_tcp_service *service = semihosting->tcp_connection->service->priv;
+
+	service->error = ERROR_OK;
+	semihosting->tcp_connection->input_pending = true;
+
+	int retval = connection_read(semihosting->tcp_connection, buf, size);
+
+	if (retval <= 0)
+		service->error = ERROR_SERVER_REMOTE_CLOSED;
+
+	if (retval < 0)
+		log_socket_error(service->name);
+
+	semihosting->tcp_connection->input_pending = false;
+
+	return retval;
+}
+
+static inline int semihosting_putchar(struct semihosting *semihosting, int fd, int c)
+{
+	if (semihosting_is_redirected(semihosting, fd))
+		return semihosting_redirect_write(semihosting, &c, 1);
+
+	/* default putchar */
+	return putchar(c);
+}
+
+static inline ssize_t semihosting_read(struct semihosting *semihosting, int fd, void *buf, int size)
+{
+	if (semihosting_is_redirected(semihosting, fd))
+		return semihosting_redirect_read(semihosting, buf, size);
+
+	/* default read */
+	ssize_t result = read(fd, buf, size);
+	semihosting->sys_errno = errno;
+
+	return result;
+}
+
+static inline int semihosting_getchar(struct semihosting *semihosting, int fd)
+{
+	if (semihosting_is_redirected(semihosting, fd)) {
+		unsigned char c;
+
+		if (semihosting_redirect_read(semihosting, &c, 1) > 0)
+			return c;
+
+		return EOF;
+	}
+
+	/* default getchar */
+	return getchar();
+}
+
+/**
+ * User operation parameter string storage buffer. Contains valid data when the
+ * TARGET_EVENT_SEMIHOSTING_USER_CMD_xxxxx event callbacks are running.
+ */
+static char *semihosting_user_op_params;
+
 /**
  * Portable implementation of ARM semihosting calls.
  * Performs the currently pending semihosting operation
@@ -167,7 +344,7 @@ int semihosting_common(struct target *target)
 	/* Enough space to hold 4 long words. */
 	uint8_t fields[4*8];
 
-	LOG_DEBUG("op=0x%x, param=0x%" PRIx64, (int)semihosting->op,
+	LOG_DEBUG("op=0x%x, param=0x%" PRIx64, semihosting->op,
 		semihosting->param);
 
 	switch (semihosting->op) {
@@ -724,7 +901,7 @@ int semihosting_common(struct target *target)
 							fileio_info->identifier = "open";
 							fileio_info->param_1 = addr;
 							fileio_info->param_2 = len;
-							fileio_info->param_3 = open_modeflags[mode];
+							fileio_info->param_3 = open_gdb_modeflags[mode];
 							fileio_info->param_4 = 0644;
 						}
 					} else {
@@ -734,20 +911,23 @@ int semihosting_common(struct target *target)
 							 * - 4-7 ("w") for stdout,
 							 * - 8-11 ("a") for stderr */
 							if (mode < 4) {
-								semihosting->result = dup(
-										STDIN_FILENO);
+								int fd = dup(STDIN_FILENO);
+								semihosting->result = fd;
+								semihosting->stdin_fd = fd;
 								semihosting->sys_errno = errno;
 								LOG_DEBUG("dup(STDIN)=%d",
 									(int)semihosting->result);
 							} else if (mode < 8) {
-								semihosting->result = dup(
-										STDOUT_FILENO);
+								int fd = dup(STDOUT_FILENO);
+								semihosting->result = fd;
+								semihosting->stdout_fd = fd;
 								semihosting->sys_errno = errno;
 								LOG_DEBUG("dup(STDOUT)=%d",
 									(int)semihosting->result);
 							} else {
-								semihosting->result = dup(
-										STDERR_FILENO);
+								int fd = dup(STDERR_FILENO);
+								semihosting->result = fd;
+								semihosting->stderr_fd = fd;
 								semihosting->sys_errno = errno;
 								LOG_DEBUG("dup(STDERR)=%d",
 									(int)semihosting->result);
@@ -757,7 +937,7 @@ int semihosting_common(struct target *target)
 							 * otherwise it will fail to reopen a previously
 							 * written file */
 							semihosting->result = open((char *)fn,
-									open_modeflags[mode],
+									open_host_modeflags[mode],
 									0644);
 							semihosting->sys_errno = errno;
 							LOG_DEBUG("open('%s')=%d", fn,
@@ -823,8 +1003,7 @@ int semihosting_common(struct target *target)
 						semihosting->result = -1;
 						semihosting->sys_errno = ENOMEM;
 					} else {
-						semihosting->result = read(fd, buf, len);
-						semihosting->sys_errno = errno;
+						semihosting->result = semihosting_read(semihosting, fd, buf, len);
 						LOG_DEBUG("read(%d, 0x%" PRIx64 ", %zu)=%d",
 							fd,
 							addr,
@@ -864,7 +1043,7 @@ int semihosting_common(struct target *target)
 				LOG_ERROR("SYS_READC not supported by semihosting fileio");
 				return ERROR_FAIL;
 			}
-			semihosting->result = getchar();
+			semihosting->result = semihosting_getchar(semihosting, semihosting->stdin_fd);
 			LOG_DEBUG("getchar()=%d", (int)semihosting->result);
 			break;
 
@@ -1167,7 +1346,7 @@ int semihosting_common(struct target *target)
 							free(buf);
 							return retval;
 						}
-						semihosting->result = write(fd, buf, len);
+						semihosting->result = semihosting_write(semihosting, fd, buf, len);
 						semihosting->sys_errno = errno;
 						LOG_DEBUG("write(%d, 0x%" PRIx64 ", %zu)=%d",
 							fd,
@@ -1212,7 +1391,7 @@ int semihosting_common(struct target *target)
 				retval = target_read_memory(target, addr, 1, 1, &c);
 				if (retval != ERROR_OK)
 					return retval;
-				putchar(c);
+				semihosting_putchar(semihosting, semihosting->stdout_fd, c);
 				semihosting->result = 0;
 			}
 			break;
@@ -1256,12 +1435,77 @@ int semihosting_common(struct target *target)
 						return retval;
 					if (!c)
 						break;
-					putchar(c);
+					semihosting_putchar(semihosting, semihosting->stdout_fd, c);
 				} while (1);
 				semihosting->result = 0;
 			}
 			break;
 
+		case SEMIHOSTING_USER_CMD_0x100 ... SEMIHOSTING_USER_CMD_0x107:
+			/**
+			 * This is a user defined operation (while user cmds 0x100-0x1ff
+			 * are possible, only 0x100-0x107 are currently implemented).
+			 *
+			 * Reads the user operation parameters from target, then fires the
+			 * corresponding target event. When the target callbacks returned,
+			 * cleans up the command parameter buffer.
+			 *
+			 * Entry
+			 * On entry, the PARAMETER REGISTER contains a pointer to a
+			 * two-field data block:
+			 * - field 1 Contains a pointer to the bound command parameter
+			 * string
+			 * - field 2 Contains the command parameter string length
+			 *
+			 * Return
+			 * On exit, the RETURN REGISTER contains the return status.
+			 */
+		{
+			assert(!semihosting_user_op_params);
+
+			retval = semihosting_read_fields(target, 2, fields);
+			if (retval != ERROR_OK) {
+				LOG_ERROR("Failed to read fields for user defined command"
+						" op=0x%x", semihosting->op);
+				return retval;
+			}
+
+			uint64_t addr = semihosting_get_field(target, 0, fields);
+
+			size_t len = semihosting_get_field(target, 1, fields);
+			if (len > SEMIHOSTING_MAX_TCL_COMMAND_FIELD_LENGTH) {
+				LOG_ERROR("The maximum length for user defined command "
+						"parameter is %u, received length is %zu (op=0x%x)",
+						SEMIHOSTING_MAX_TCL_COMMAND_FIELD_LENGTH,
+						len,
+						semihosting->op);
+				return ERROR_FAIL;
+			}
+
+			semihosting_user_op_params = malloc(len + 1);
+			if (!semihosting_user_op_params)
+				return ERROR_FAIL;
+			semihosting_user_op_params[len] = 0;
+
+			retval = target_read_buffer(target, addr, len,
+					(uint8_t *)(semihosting_user_op_params));
+			if (retval != ERROR_OK) {
+				LOG_ERROR("Failed to read from target, semihosting op=0x%x",
+						semihosting->op);
+				free(semihosting_user_op_params);
+				semihosting_user_op_params = NULL;
+				return retval;
+			}
+
+			target_handle_event(target, semihosting->op);
+			free(semihosting_user_op_params);
+			semihosting_user_op_params = NULL;
+
+			semihosting->result = 0;
+			break;
+		}
+
+
 		case SEMIHOSTING_SYS_ELAPSED:	/* 0x30 */
 		/*
 		 * Returns the number of elapsed target ticks since execution
@@ -1470,11 +1714,75 @@ static void semihosting_set_field(struct target *target, uint64_t value,
 		target_buffer_set_u32(target, fields + (index * 4), value);
 }
 
+/* -------------------------------------------------------------------------
+ * Semihosting redirect over TCP structs and functions */
+
+static int semihosting_service_new_connection_handler(struct connection *connection)
+{
+	struct semihosting_tcp_service *service = connection->service->priv;
+	service->semihosting->tcp_connection = connection;
+
+	return ERROR_OK;
+}
+
+static int semihosting_service_input_handler(struct connection *connection)
+{
+	struct semihosting_tcp_service *service = connection->service->priv;
+
+	if (!connection->input_pending) {
+		/* consume received data, not for semihosting IO */
+		const int buf_len = 100;
+		char buf[buf_len];
+		int bytes_read = connection_read(connection, buf, buf_len);
+
+		if (bytes_read == 0) {
+			return ERROR_SERVER_REMOTE_CLOSED;
+		} else if (bytes_read == -1) {
+			LOG_ERROR("error during read: %s", strerror(errno));
+			return ERROR_SERVER_REMOTE_CLOSED;
+		}
+	} else if (service->error != ERROR_OK) {
+		return ERROR_SERVER_REMOTE_CLOSED;
+	}
+
+	return ERROR_OK;
+}
+
+static int semihosting_service_connection_closed_handler(struct connection *connection)
+{
+	struct semihosting_tcp_service *service = connection->service->priv;
+	if (service) {
+		free(service->name);
+		free(service);
+	}
+
+	return ERROR_OK;
+}
+
+static void semihosting_tcp_close_cnx(struct semihosting *semihosting)
+{
+	if (!semihosting->tcp_connection)
+		return;
+
+	struct service *service = semihosting->tcp_connection->service;
+	remove_service(service->name, service->port);
+	semihosting->tcp_connection = NULL;
+
+}
+
+static const struct service_driver semihosting_service_driver = {
+	.name = "semihosting",
+	.new_connection_during_keep_alive_handler = NULL,
+	.new_connection_handler = semihosting_service_new_connection_handler,
+	.input_handler = semihosting_service_input_handler,
+	.connection_closed_handler = semihosting_service_connection_closed_handler,
+	.keep_client_alive_handler = NULL,
+};
 
 /* -------------------------------------------------------------------------
  * Common semihosting commands handlers. */
 
-static __COMMAND_HANDLER(handle_common_semihosting_command)
+COMMAND_HANDLER(handle_common_semihosting_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
 
@@ -1515,7 +1823,92 @@ static __COMMAND_HANDLER(handle_common_semihosting_command)
 	return ERROR_OK;
 }
 
-static __COMMAND_HANDLER(handle_common_semihosting_fileio_command)
+COMMAND_HANDLER(handle_common_semihosting_redirect_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+
+	if (target == NULL) {
+		LOG_ERROR("No target selected");
+		return ERROR_FAIL;
+	}
+
+	struct semihosting *semihosting = target->semihosting;
+	if (!semihosting) {
+		command_print(CMD, "semihosting not supported for current target");
+		return ERROR_FAIL;
+	}
+
+	if (!semihosting->is_active) {
+		command_print(CMD, "semihosting not yet enabled for current target");
+		return ERROR_FAIL;
+	}
+
+	enum semihosting_redirect_config cfg;
+	const char *port;
+
+	if (CMD_ARGC < 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (strcmp(CMD_ARGV[0], "disable") == 0) {
+		cfg = SEMIHOSTING_REDIRECT_CFG_NONE;
+		if (CMD_ARGC > 1)
+			return ERROR_COMMAND_SYNTAX_ERROR;
+	} else if (strcmp(CMD_ARGV[0], "tcp") == 0) {
+		if (CMD_ARGC < 2 || CMD_ARGC > 3)
+			return ERROR_COMMAND_SYNTAX_ERROR;
+
+		port = CMD_ARGV[1];
+
+		cfg = SEMIHOSTING_REDIRECT_CFG_ALL;
+		if (CMD_ARGC == 3) {
+			if (strcmp(CMD_ARGV[2], "debug") == 0)
+				cfg = SEMIHOSTING_REDIRECT_CFG_DEBUG;
+			else if (strcmp(CMD_ARGV[2], "stdio") == 0)
+				cfg = SEMIHOSTING_REDIRECT_CFG_STDIO;
+			else if (strcmp(CMD_ARGV[2], "all") != 0)
+				return ERROR_COMMAND_SYNTAX_ERROR;
+		}
+	} else {
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	semihosting_tcp_close_cnx(semihosting);
+	semihosting->redirect_cfg = SEMIHOSTING_REDIRECT_CFG_NONE;
+
+	if (cfg != SEMIHOSTING_REDIRECT_CFG_NONE) {
+		struct semihosting_tcp_service *service =
+				calloc(1, sizeof(struct semihosting_tcp_service));
+		if (!service) {
+			LOG_ERROR("Failed to allocate semihosting TCP service.");
+			return ERROR_FAIL;
+		}
+
+		service->semihosting = semihosting;
+
+		service->name = alloc_printf("%s semihosting service", target_name(target));
+		if (!service->name) {
+			LOG_ERROR("Out of memory");
+			free(service);
+			return ERROR_FAIL;
+		}
+
+		int ret = add_service(&semihosting_service_driver,
+				port, 1, service);
+
+		if (ret != ERROR_OK) {
+			LOG_ERROR("failed to initialize %s", service->name);
+			free(service->name);
+			free(service);
+			return ERROR_FAIL;
+		}
+	}
+
+	semihosting->redirect_cfg = cfg;
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_common_semihosting_fileio_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
 
@@ -1545,7 +1938,7 @@ static __COMMAND_HANDLER(handle_common_semihosting_fileio_command)
 	return ERROR_OK;
 }
 
-static __COMMAND_HANDLER(handle_common_semihosting_cmdline)
+COMMAND_HANDLER(handle_common_semihosting_cmdline)
 {
 	struct target *target = get_current_target(CMD_CTX);
 	unsigned int i;
@@ -1578,7 +1971,7 @@ static __COMMAND_HANDLER(handle_common_semihosting_cmdline)
 	return ERROR_OK;
 }
 
-static __COMMAND_HANDLER(handle_common_semihosting_resumable_exit_command)
+COMMAND_HANDLER(handle_common_semihosting_resumable_exit_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
 
@@ -1608,34 +2001,72 @@ static __COMMAND_HANDLER(handle_common_semihosting_resumable_exit_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(handle_common_semihosting_read_user_param_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct semihosting *semihosting = target->semihosting;
+
+	if (CMD_ARGC)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (!semihosting->is_active) {
+		LOG_ERROR("semihosting not yet enabled for current target");
+		return ERROR_FAIL;
+	}
+
+	if (!semihosting_user_op_params) {
+		LOG_ERROR("This command is usable only from a registered user "
+				"semihosting event callback.");
+		return ERROR_FAIL;
+	}
+
+	command_print_sameline(CMD, "%s", semihosting_user_op_params);
+
+	return ERROR_OK;
+}
+
 const struct command_registration semihosting_common_handlers[] = {
 	{
-		"semihosting",
+		.name = "semihosting",
 		.handler = handle_common_semihosting_command,
 		.mode = COMMAND_EXEC,
 		.usage = "['enable'|'disable']",
 		.help = "activate support for semihosting operations",
 	},
 	{
-		"semihosting_cmdline",
+		.name = "semihosting_redirect",
+		.handler = handle_common_semihosting_redirect_command,
+		.mode = COMMAND_EXEC,
+		.usage = "(disable | tcp <port> ['debug'|'stdio'|'all'])",
+		.help = "redirect semihosting IO",
+	},
+	{
+		.name = "semihosting_cmdline",
 		.handler = handle_common_semihosting_cmdline,
 		.mode = COMMAND_EXEC,
 		.usage = "arguments",
 		.help = "command line arguments to be passed to program",
 	},
 	{
-		"semihosting_fileio",
+		.name = "semihosting_fileio",
 		.handler = handle_common_semihosting_fileio_command,
 		.mode = COMMAND_EXEC,
 		.usage = "['enable'|'disable']",
 		.help = "activate support for semihosting fileio operations",
 	},
 	{
-		"semihosting_resexit",
+		.name = "semihosting_resexit",
 		.handler = handle_common_semihosting_resumable_exit_command,
 		.mode = COMMAND_EXEC,
 		.usage = "['enable'|'disable']",
 		.help = "activate support for semihosting resumable exit",
 	},
+	{
+		.name = "semihosting_read_user_param",
+		.handler = handle_common_semihosting_read_user_param_command,
+		.mode = COMMAND_EXEC,
+		.usage = "",
+		.help = "read parameters in semihosting-user-cmd-0x10X callbacks",
+	},
 	COMMAND_REGISTRATION_DONE
 };
diff --git a/src/target/semihosting_common.h b/src/target/semihosting_common.h
index b83464ed5..459faf656 100644
--- a/src/target/semihosting_common.h
+++ b/src/target/semihosting_common.h
@@ -26,6 +26,7 @@
 #include <stdbool.h>
 #include <time.h>
 #include "helper/replacements.h"
+#include <server/server.h>
 
 /*
  * According to:
@@ -75,8 +76,14 @@ enum semihosting_operation_numbers {
 	SEMIHOSTING_SYS_WRITE = 0x05,
 	SEMIHOSTING_SYS_WRITEC = 0x03,
 	SEMIHOSTING_SYS_WRITE0 = 0x04,
+	SEMIHOSTING_USER_CMD_0x100 = 0x100, /* First user cmd op code */
+	SEMIHOSTING_USER_CMD_0x107 = 0x107, /* Last supported user cmd op code */
+	SEMIHOSTING_USER_CMD_0x1FF = 0x1FF, /* Last user cmd op code */
 };
 
+/** Maximum allowed Tcl command segment length in bytes*/
+#define SEMIHOSTING_MAX_TCL_COMMAND_FIELD_LENGTH (1024 * 1024)
+
 /*
  * Codes used by SEMIHOSTING_SYS_EXIT (formerly
  * SEMIHOSTING_REPORT_EXCEPTION).
@@ -89,6 +96,13 @@ enum semihosting_reported_exceptions {
 	ADP_STOPPED_RUN_TIME_ERROR = ((2 << 16) + 35),
 };
 
+enum semihosting_redirect_config {
+	SEMIHOSTING_REDIRECT_CFG_NONE,
+	SEMIHOSTING_REDIRECT_CFG_DEBUG,
+	SEMIHOSTING_REDIRECT_CFG_STDIO,
+	SEMIHOSTING_REDIRECT_CFG_ALL,
+};
+
 struct target;
 
 /*
@@ -99,6 +113,15 @@ struct semihosting {
 	/** A flag reporting whether semihosting is active. */
 	bool is_active;
 
+	/** Semihosting STDIO file descriptors */
+	int stdin_fd, stdout_fd, stderr_fd;
+
+	/** redirection configuration, NONE by default */
+	enum semihosting_redirect_config redirect_cfg;
+
+	/** Handle to redirect semihosting print via tcp */
+	struct connection *tcp_connection;
+
 	/** A flag reporting whether semihosting fileio is active. */
 	bool is_fileio;
 
diff --git a/src/target/smp.c b/src/target/smp.c
index 518f6e458..569abd786 100644
--- a/src/target/smp.c
+++ b/src/target/smp.c
@@ -28,6 +28,7 @@
 #include "smp.h"
 #include "helper/binarybuffer.h"
 
+/* DEPRECATED: gdb_read_smp_packet/gdb_write_smp_packet to be removed      */
 /*  implementation of new packet in gdb interface for smp feature          */
 /*                                                                         */
 /*   j : smp  status request                                               */
@@ -53,11 +54,15 @@
 /*  maint packet jc                                                        */
 
 /* packet j :smp status request */
+#define DEPRECATED_MSG "DEPRECATED: This method is deprecated in favor of the hwthread pseudo RTOS"
 int gdb_read_smp_packet(struct connection *connection,
 		char const *packet, int packet_size)
 {
 	struct target *target = get_target_from_connection(connection);
 	int retval = ERROR_OK;
+
+	LOG_WARNING(DEPRECATED_MSG);
+
 	if (target->smp) {
 		if (strncmp(packet, "jc", 2) == 0) {
 			const uint32_t len = sizeof(target->gdb_service->core[0]);
@@ -83,6 +88,8 @@ int gdb_write_smp_packet(struct connection *connection,
 	int coreid = 0;
 	int retval = ERROR_OK;
 
+	LOG_WARNING(DEPRECATED_MSG);
+
 	/* skip command character */
 	if (target->smp) {
 		if (strncmp(packet, "Jc", 2) == 0) {
@@ -111,18 +118,18 @@ COMMAND_HANDLER(default_handle_smp_command)
 	}
 
 	if (!strcmp(CMD_ARGV[0], "on")) {
-		foreach_smp_target(head, target->head)
+		foreach_smp_target(head, target->smp_targets)
 			head->target->smp = 1;
 
 		return ERROR_OK;
 	}
 
 	if (!strcmp(CMD_ARGV[0], "off")) {
-		foreach_smp_target(head, target->head)
+		foreach_smp_target(head, target->smp_targets)
 			head->target->smp = 0;
 
 		/* fixes the target display to the debugger */
-		if (target->head)
+		if (!list_empty(target->smp_targets))
 			target->gdb_service->target = target;
 
 		return ERROR_OK;
@@ -135,9 +142,7 @@ COMMAND_HANDLER(handle_smp_gdb_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
 	int retval = ERROR_OK;
-	struct target_list *head;
-	head = target->head;
-	if (head) {
+	if (!list_empty(target->smp_targets)) {
 		if (CMD_ARGC == 1) {
 			int coreid = 0;
 			COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], coreid);
diff --git a/src/target/smp.h b/src/target/smp.h
index 3338240ad..d373c90bc 100644
--- a/src/target/smp.h
+++ b/src/target/smp.h
@@ -19,15 +19,21 @@
 #ifndef OPENOCD_TARGET_SMP_H
 #define OPENOCD_TARGET_SMP_H
 
+#include <helper/list.h>
 #include "server/server.h"
 
 #define foreach_smp_target(pos, head) \
-	for (pos = head; (pos); pos = pos->next)
+	list_for_each_entry(pos, head, lh)
+
+#define foreach_smp_target_direction(forward, pos, head) \
+	list_for_each_entry_direction(forward, pos, head, lh)
 
 extern const struct command_registration smp_command_handlers[];
 
+/* DEPRECATED */
 int gdb_read_smp_packet(struct connection *connection,
 		char const *packet, int packet_size);
+/* DEPRECATED */
 int gdb_write_smp_packet(struct connection *connection,
 		char const *packet, int packet_size);
 
diff --git a/src/target/startup.tcl b/src/target/startup.tcl
index cd98d68e4..0e46992b7 100644
--- a/src/target/startup.tcl
+++ b/src/target/startup.tcl
@@ -206,6 +206,32 @@ proc init_target_events {} {
 proc init_board {} {
 }
 
+proc mem2array {arrayname bitwidth address count {phys ""}} {
+	echo "DEPRECATED! use 'read_memory' not 'mem2array'"
+
+	upvar $arrayname $arrayname
+	set $arrayname ""
+	set i 0
+
+	foreach elem [read_memory $address $bitwidth $count {*}$phys] {
+		set ${arrayname}($i) $elem
+		incr i
+	}
+}
+
+proc array2mem {arrayname bitwidth address count {phys ""}} {
+	echo "DEPRECATED! use 'write_memory' not 'array2mem'"
+
+	upvar $arrayname $arrayname
+	set data ""
+
+	for {set i 0} {$i < $count} {incr i} {
+		lappend data [expr $${arrayname}($i)]
+	}
+
+	write_memory $address $bitwidth $data {*}$phys
+}
+
 # smp_on/smp_off were already DEPRECATED in v0.11.0 through http://openocd.zylin.com/4615
 lappend _telnet_autocomplete_skip "aarch64 smp_on"
 proc "aarch64 smp_on" {args} {
diff --git a/src/target/stm8.c b/src/target/stm8.c
index 21fc8c54f..4102082ff 100644
--- a/src/target/stm8.c
+++ b/src/target/stm8.c
@@ -1370,7 +1370,7 @@ static void stm8_enable_breakpoints(struct target *target)
 
 	/* set any pending breakpoints */
 	while (breakpoint) {
-		if (breakpoint->set == 0)
+		if (!breakpoint->is_set)
 			stm8_set_breakpoint(target, breakpoint);
 		breakpoint = breakpoint->next;
 	}
@@ -1383,7 +1383,7 @@ static int stm8_set_breakpoint(struct target *target,
 	struct stm8_comparator *comparator_list = stm8->hw_break_list;
 	int retval;
 
-	if (breakpoint->set) {
+	if (breakpoint->is_set) {
 		LOG_WARNING("breakpoint already set");
 		return ERROR_OK;
 	}
@@ -1398,7 +1398,7 @@ static int stm8_set_breakpoint(struct target *target,
 					breakpoint->unique_id);
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
-		breakpoint->set = bp_num + 1;
+		breakpoint_hw_set(breakpoint, bp_num);
 		comparator_list[bp_num].used = true;
 		comparator_list[bp_num].bp_value = breakpoint->address;
 		comparator_list[bp_num].type = HWBRK_EXEC;
@@ -1435,7 +1435,7 @@ static int stm8_set_breakpoint(struct target *target,
 		} else {
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
-		breakpoint->set = 1; /* Any nice value but 0 */
+		breakpoint->is_set = true;
 	}
 
 	return ERROR_OK;
@@ -1476,14 +1476,14 @@ static int stm8_unset_breakpoint(struct target *target,
 	struct stm8_comparator *comparator_list = stm8->hw_break_list;
 	int retval;
 
-	if (!breakpoint->set) {
+	if (!breakpoint->is_set) {
 		LOG_WARNING("breakpoint not set");
 		return ERROR_OK;
 	}
 
 	if (breakpoint->type == BKPT_HARD) {
-		int bp_num = breakpoint->set - 1;
-		if ((bp_num < 0) || (bp_num >= stm8->num_hw_bpoints)) {
+		int bp_num = breakpoint->number;
+		if (bp_num >= stm8->num_hw_bpoints) {
 			LOG_DEBUG("Invalid comparator number in breakpoint (bpid: %" PRIu32 ")",
 					  breakpoint->unique_id);
 			return ERROR_OK;
@@ -1517,7 +1517,7 @@ static int stm8_unset_breakpoint(struct target *target,
 		} else
 			return ERROR_FAIL;
 	}
-	breakpoint->set = 0;
+	breakpoint->is_set = false;
 
 	return ERROR_OK;
 }
@@ -1533,7 +1533,7 @@ static int stm8_remove_breakpoint(struct target *target,
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if (breakpoint->set)
+	if (breakpoint->is_set)
 		stm8_unset_breakpoint(target, breakpoint);
 
 	if (breakpoint->type == BKPT_HARD)
@@ -1550,7 +1550,7 @@ static int stm8_set_watchpoint(struct target *target,
 	int wp_num = 0;
 	int ret;
 
-	if (watchpoint->set) {
+	if (watchpoint->is_set) {
 		LOG_WARNING("watchpoint already set");
 		return ERROR_OK;
 	}
@@ -1593,7 +1593,7 @@ static int stm8_set_watchpoint(struct target *target,
 		return ret;
 	}
 
-	watchpoint->set = wp_num + 1;
+	watchpoint_set(watchpoint, wp_num);
 
 	LOG_DEBUG("wp_num %i bp_value 0x%" PRIx32 "",
 			wp_num,
@@ -1627,7 +1627,7 @@ static void stm8_enable_watchpoints(struct target *target)
 
 	/* set any pending watchpoints */
 	while (watchpoint) {
-		if (watchpoint->set == 0)
+		if (!watchpoint->is_set)
 			stm8_set_watchpoint(target, watchpoint);
 		watchpoint = watchpoint->next;
 	}
@@ -1640,18 +1640,18 @@ static int stm8_unset_watchpoint(struct target *target,
 	struct stm8_common *stm8 = target_to_stm8(target);
 	struct stm8_comparator *comparator_list = stm8->hw_break_list;
 
-	if (!watchpoint->set) {
+	if (!watchpoint->is_set) {
 		LOG_WARNING("watchpoint not set");
 		return ERROR_OK;
 	}
 
-	int wp_num = watchpoint->set - 1;
-	if ((wp_num < 0) || (wp_num >= stm8->num_hw_bpoints)) {
+	int wp_num = watchpoint->number;
+	if (wp_num >= stm8->num_hw_bpoints) {
 		LOG_DEBUG("Invalid hw comparator number in watchpoint");
 		return ERROR_OK;
 	}
 	comparator_list[wp_num].used = false;
-	watchpoint->set = 0;
+	watchpoint->is_set = false;
 
 	stm8_set_hwbreak(target, comparator_list);
 
@@ -1669,7 +1669,7 @@ static int stm8_remove_watchpoint(struct target *target,
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if (watchpoint->set)
+	if (watchpoint->is_set)
 		stm8_unset_watchpoint(target, watchpoint);
 
 	stm8->num_hw_bpoints_avail++;
diff --git a/src/target/target.c b/src/target/target.c
index e9cbe39b7..d2dff111a 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -56,6 +56,7 @@
 #include "rtos/rtos.h"
 #include "transport/transport.h"
 #include "arm_cti.h"
+#include "smp.h"
 
 /* default halt wait timeout (ms) */
 #define DEFAULT_HALT_TIMEOUT 5000
@@ -159,6 +160,7 @@ static int64_t target_timer_next_event_value;
 static LIST_HEAD(target_reset_callback_list);
 static LIST_HEAD(target_trace_callback_list);
 static const int polling_interval = TARGET_DEFAULT_POLLING_INTERVAL;
+static LIST_HEAD(empty_smp_targets);
 
 static const struct jim_nvp nvp_assert[] = {
 	{ .name = "assert", NVP_ASSERT },
@@ -236,6 +238,15 @@ static const struct jim_nvp nvp_target_event[] = {
 
 	{ .value = TARGET_EVENT_TRACE_CONFIG, .name = "trace-config" },
 
+	{ .value = TARGET_EVENT_SEMIHOSTING_USER_CMD_0x100, .name = "semihosting-user-cmd-0x100" },
+	{ .value = TARGET_EVENT_SEMIHOSTING_USER_CMD_0x101, .name = "semihosting-user-cmd-0x101" },
+	{ .value = TARGET_EVENT_SEMIHOSTING_USER_CMD_0x102, .name = "semihosting-user-cmd-0x102" },
+	{ .value = TARGET_EVENT_SEMIHOSTING_USER_CMD_0x103, .name = "semihosting-user-cmd-0x103" },
+	{ .value = TARGET_EVENT_SEMIHOSTING_USER_CMD_0x104, .name = "semihosting-user-cmd-0x104" },
+	{ .value = TARGET_EVENT_SEMIHOSTING_USER_CMD_0x105, .name = "semihosting-user-cmd-0x105" },
+	{ .value = TARGET_EVENT_SEMIHOSTING_USER_CMD_0x106, .name = "semihosting-user-cmd-0x106" },
+	{ .value = TARGET_EVENT_SEMIHOSTING_USER_CMD_0x107, .name = "semihosting-user-cmd-0x107" },
+
 	{ .name = NULL, .value = -1 }
 };
 
@@ -1834,7 +1845,7 @@ int target_call_event_callbacks(struct target *target, enum target_event event)
 	}
 
 	LOG_DEBUG("target event %i (%s) for core %s", event,
-			jim_nvp_value2name_simple(nvp_target_event, event)->name,
+			target_event_name(event),
 			target_name(target));
 
 	target_handle_event(target, event);
@@ -2263,13 +2274,15 @@ static void target_destroy(struct target *target)
 
 	/* release the targets SMP list */
 	if (target->smp) {
-		struct target_list *head = target->head;
-		while (head) {
-			struct target_list *pos = head->next;
+		struct target_list *head, *tmp;
+
+		list_for_each_entry_safe(head, tmp, target->smp_targets, lh) {
+			list_del(&head->lh);
 			head->target->smp = 0;
 			free(head);
-			head = pos;
 		}
+		if (target->smp_targets != &empty_smp_targets)
+			free(target->smp_targets);
 		target->smp = 0;
 	}
 
@@ -3954,26 +3967,26 @@ static int handle_bp_command_list(struct command_invocation *cmd)
 		if (breakpoint->type == BKPT_SOFT) {
 			char *buf = buf_to_hex_str(breakpoint->orig_instr,
 					breakpoint->length);
-			command_print(cmd, "IVA breakpoint: " TARGET_ADDR_FMT ", 0x%x, %i, 0x%s",
+			command_print(cmd, "IVA breakpoint: " TARGET_ADDR_FMT ", 0x%x, 0x%s",
 					breakpoint->address,
 					breakpoint->length,
-					breakpoint->set, buf);
+					buf);
 			free(buf);
 		} else {
 			if ((breakpoint->address == 0) && (breakpoint->asid != 0))
-				command_print(cmd, "Context breakpoint: 0x%8.8" PRIx32 ", 0x%x, %i",
+				command_print(cmd, "Context breakpoint: 0x%8.8" PRIx32 ", 0x%x, %u",
 							breakpoint->asid,
-							breakpoint->length, breakpoint->set);
+							breakpoint->length, breakpoint->number);
 			else if ((breakpoint->address != 0) && (breakpoint->asid != 0)) {
-				command_print(cmd, "Hybrid breakpoint(IVA): " TARGET_ADDR_FMT ", 0x%x, %i",
+				command_print(cmd, "Hybrid breakpoint(IVA): " TARGET_ADDR_FMT ", 0x%x, %u",
 							breakpoint->address,
-							breakpoint->length, breakpoint->set);
+							breakpoint->length, breakpoint->number);
 				command_print(cmd, "\t|--->linked with ContextID: 0x%8.8" PRIx32,
 							breakpoint->asid);
 			} else
-				command_print(cmd, "Breakpoint(IVA): " TARGET_ADDR_FMT ", 0x%x, %i",
+				command_print(cmd, "Breakpoint(IVA): " TARGET_ADDR_FMT ", 0x%x, %u",
 							breakpoint->address,
-							breakpoint->length, breakpoint->set);
+							breakpoint->length, breakpoint->number);
 		}
 
 		breakpoint = breakpoint->next;
@@ -4418,27 +4431,12 @@ static int new_u64_array_element(Jim_Interp *interp, const char *varname, int id
 	return result;
 }
 
-static int jim_mem2array(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
-{
-	struct command_context *context;
-	struct target *target;
-
-	context = current_command_context(interp);
-	assert(context);
-
-	target = get_current_target(context);
-	if (!target) {
-		LOG_ERROR("mem2array: no current target");
-		return JIM_ERR;
-	}
-
-	return target_mem2array(interp, target, argc - 1, argv + 1);
-}
-
 static int target_mem2array(Jim_Interp *interp, struct target *target, int argc, Jim_Obj *const *argv)
 {
 	int e;
 
+	LOG_WARNING("DEPRECATED! use 'read_memory' not 'mem2array'");
+
 	/* argv[0] = name of array to receive the data
 	 * argv[1] = desired element width in bits
 	 * argv[2] = memory address
@@ -4591,6 +4589,161 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 	return e;
 }
 
+static int target_jim_read_memory(Jim_Interp *interp, int argc,
+		Jim_Obj * const *argv)
+{
+	/*
+	 * argv[1] = memory address
+	 * argv[2] = desired element width in bits
+	 * argv[3] = number of elements to read
+	 * argv[4] = optional "phys"
+	 */
+
+	if (argc < 4 || argc > 5) {
+		Jim_WrongNumArgs(interp, 1, argv, "address width count ['phys']");
+		return JIM_ERR;
+	}
+
+	/* Arg 1: Memory address. */
+	jim_wide wide_addr;
+	int e;
+	e = Jim_GetWide(interp, argv[1], &wide_addr);
+
+	if (e != JIM_OK)
+		return e;
+
+	target_addr_t addr = (target_addr_t)wide_addr;
+
+	/* Arg 2: Bit width of one element. */
+	long l;
+	e = Jim_GetLong(interp, argv[2], &l);
+
+	if (e != JIM_OK)
+		return e;
+
+	const unsigned int width_bits = l;
+
+	/* Arg 3: Number of elements to read. */
+	e = Jim_GetLong(interp, argv[3], &l);
+
+	if (e != JIM_OK)
+		return e;
+
+	size_t count = l;
+
+	/* Arg 4: Optional 'phys'. */
+	bool is_phys = false;
+
+	if (argc > 4) {
+		const char *phys = Jim_GetString(argv[4], NULL);
+
+		if (strcmp(phys, "phys")) {
+			Jim_SetResultFormatted(interp, "invalid argument '%s', must be 'phys'", phys);
+			return JIM_ERR;
+		}
+
+		is_phys = true;
+	}
+
+	switch (width_bits) {
+	case 8:
+	case 16:
+	case 32:
+	case 64:
+		break;
+	default:
+		Jim_SetResultString(interp, "invalid width, must be 8, 16, 32 or 64", -1);
+		return JIM_ERR;
+	}
+
+	const unsigned int width = width_bits / 8;
+
+	if ((addr + (count * width)) < addr) {
+		Jim_SetResultString(interp, "read_memory: addr + count wraps to zero", -1);
+		return JIM_ERR;
+	}
+
+	if (count > 65536) {
+		Jim_SetResultString(interp, "read_memory: too large read request, exeeds 64K elements", -1);
+		return JIM_ERR;
+	}
+
+	struct command_context *cmd_ctx = current_command_context(interp);
+	assert(cmd_ctx != NULL);
+	struct target *target = get_current_target(cmd_ctx);
+
+	const size_t buffersize = 4096;
+	uint8_t *buffer = malloc(buffersize);
+
+	if (!buffer) {
+		LOG_ERROR("Failed to allocate memory");
+		return JIM_ERR;
+	}
+
+	Jim_Obj *result_list = Jim_NewListObj(interp, NULL, 0);
+	Jim_IncrRefCount(result_list);
+
+	while (count > 0) {
+		const unsigned int max_chunk_len = buffersize / width;
+		const size_t chunk_len = MIN(count, max_chunk_len);
+
+		int retval;
+
+		if (is_phys)
+			retval = target_read_phys_memory(target, addr, width, chunk_len, buffer);
+		else
+			retval = target_read_memory(target, addr, width, chunk_len, buffer);
+
+		if (retval != ERROR_OK) {
+			LOG_ERROR("read_memory: read at " TARGET_ADDR_FMT " with width=%u and count=%zu failed",
+				addr, width_bits, chunk_len);
+			Jim_SetResultString(interp, "read_memory: failed to read memory", -1);
+			e = JIM_ERR;
+			break;
+		}
+
+		for (size_t i = 0; i < chunk_len ; i++) {
+			uint64_t v = 0;
+
+			switch (width) {
+			case 8:
+				v = target_buffer_get_u64(target, &buffer[i * width]);
+				break;
+			case 4:
+				v = target_buffer_get_u32(target, &buffer[i * width]);
+				break;
+			case 2:
+				v = target_buffer_get_u16(target, &buffer[i * width]);
+				break;
+			case 1:
+				v = buffer[i];
+				break;
+			}
+
+			char value_buf[11];
+			snprintf(value_buf, sizeof(value_buf), "0x%" PRIx64, v);
+
+			Jim_ListAppendElement(interp, result_list,
+				Jim_NewStringObj(interp, value_buf, -1));
+		}
+
+		count -= chunk_len;
+		addr += chunk_len * width;
+	}
+
+	free(buffer);
+
+	if (e != JIM_OK) {
+		Jim_DecrRefCount(interp, result_list);
+		return e;
+	}
+
+	Jim_SetResult(interp, result_list);
+	Jim_DecrRefCount(interp, result_list);
+
+	return JIM_OK;
+}
+
 static int get_u64_array_element(Jim_Interp *interp, const char *varname, size_t idx, uint64_t *val)
 {
 	char *namebuf = alloc_printf("%s(%zu)", varname, idx);
@@ -4616,28 +4769,13 @@ static int get_u64_array_element(Jim_Interp *interp, const char *varname, size_t
 	return result;
 }
 
-static int jim_array2mem(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
-{
-	struct command_context *context;
-	struct target *target;
-
-	context = current_command_context(interp);
-	assert(context);
-
-	target = get_current_target(context);
-	if (!target) {
-		LOG_ERROR("array2mem: no current target");
-		return JIM_ERR;
-	}
-
-	return target_array2mem(interp, target, argc-1, argv + 1);
-}
-
 static int target_array2mem(Jim_Interp *interp, struct target *target,
 		int argc, Jim_Obj *const *argv)
 {
 	int e;
 
+	LOG_WARNING("DEPRECATED! use 'write_memory' not 'array2mem'");
+
 	/* argv[0] = name of array from which to read the data
 	 * argv[1] = desired element width in bits
 	 * argv[2] = memory address
@@ -4801,6 +4939,144 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 	return e;
 }
 
+static int target_jim_write_memory(Jim_Interp *interp, int argc,
+		Jim_Obj * const *argv)
+{
+	/*
+	 * argv[1] = memory address
+	 * argv[2] = desired element width in bits
+	 * argv[3] = list of data to write
+	 * argv[4] = optional "phys"
+	 */
+
+	if (argc < 4 || argc > 5) {
+		Jim_WrongNumArgs(interp, 1, argv, "address width data ['phys']");
+		return JIM_ERR;
+	}
+
+	/* Arg 1: Memory address. */
+	int e;
+	jim_wide wide_addr;
+	e = Jim_GetWide(interp, argv[1], &wide_addr);
+
+	if (e != JIM_OK)
+		return e;
+
+	target_addr_t addr = (target_addr_t)wide_addr;
+
+	/* Arg 2: Bit width of one element. */
+	long l;
+	e = Jim_GetLong(interp, argv[2], &l);
+
+	if (e != JIM_OK)
+		return e;
+
+	const unsigned int width_bits = l;
+	size_t count = Jim_ListLength(interp, argv[3]);
+
+	/* Arg 4: Optional 'phys'. */
+	bool is_phys = false;
+
+	if (argc > 4) {
+		const char *phys = Jim_GetString(argv[4], NULL);
+
+		if (strcmp(phys, "phys")) {
+			Jim_SetResultFormatted(interp, "invalid argument '%s', must be 'phys'", phys);
+			return JIM_ERR;
+		}
+
+		is_phys = true;
+	}
+
+	switch (width_bits) {
+	case 8:
+	case 16:
+	case 32:
+	case 64:
+		break;
+	default:
+		Jim_SetResultString(interp, "invalid width, must be 8, 16, 32 or 64", -1);
+		return JIM_ERR;
+	}
+
+	const unsigned int width = width_bits / 8;
+
+	if ((addr + (count * width)) < addr) {
+		Jim_SetResultString(interp, "write_memory: addr + len wraps to zero", -1);
+		return JIM_ERR;
+	}
+
+	if (count > 65536) {
+		Jim_SetResultString(interp, "write_memory: too large memory write request, exceeds 64K elements", -1);
+		return JIM_ERR;
+	}
+
+	struct command_context *cmd_ctx = current_command_context(interp);
+	assert(cmd_ctx != NULL);
+	struct target *target = get_current_target(cmd_ctx);
+
+	const size_t buffersize = 4096;
+	uint8_t *buffer = malloc(buffersize);
+
+	if (!buffer) {
+		LOG_ERROR("Failed to allocate memory");
+		return JIM_ERR;
+	}
+
+	size_t j = 0;
+
+	while (count > 0) {
+		const unsigned int max_chunk_len = buffersize / width;
+		const size_t chunk_len = MIN(count, max_chunk_len);
+
+		for (size_t i = 0; i < chunk_len; i++, j++) {
+			Jim_Obj *tmp = Jim_ListGetIndex(interp, argv[3], j);
+			jim_wide element_wide;
+			Jim_GetWide(interp, tmp, &element_wide);
+
+			const uint64_t v = element_wide;
+
+			switch (width) {
+			case 8:
+				target_buffer_set_u64(target, &buffer[i * width], v);
+				break;
+			case 4:
+				target_buffer_set_u32(target, &buffer[i * width], v);
+				break;
+			case 2:
+				target_buffer_set_u16(target, &buffer[i * width], v);
+				break;
+			case 1:
+				buffer[i] = v & 0x0ff;
+				break;
+			}
+		}
+
+		count -= chunk_len;
+
+		int retval;
+
+		if (is_phys)
+			retval = target_write_phys_memory(target, addr, width, chunk_len, buffer);
+		else
+			retval = target_write_memory(target, addr, width, chunk_len, buffer);
+
+		if (retval != ERROR_OK) {
+			LOG_ERROR("write_memory: write at " TARGET_ADDR_FMT " with width=%u and count=%zu failed",
+				addr,  width_bits, chunk_len);
+			Jim_SetResultString(interp, "write_memory: failed to write memory", -1);
+			e = JIM_ERR;
+			break;
+		}
+
+		addr += chunk_len * width;
+	}
+
+	free(buffer);
+
+	return e;
+}
+
 /* FIX? should we propagate errors here rather than printing them
  * and continuing?
  */
@@ -4816,7 +5092,7 @@ void target_handle_event(struct target *target, enum target_event e)
 					   target_name(target),
 					   target_type_name(target),
 					   e,
-					   jim_nvp_value2name_simple(nvp_target_event, e)->name,
+					   target_event_name(e),
 					   Jim_GetString(teap->body, NULL));
 
 			/* Override current target by the target an event
@@ -4840,7 +5116,7 @@ void target_handle_event(struct target *target, enum target_event e)
 			if (retval != JIM_OK) {
 				Jim_MakeErrorMessage(teap->interp);
 				LOG_USER("Error executing event %s on target %s:\n%s",
-						  jim_nvp_value2name_simple(nvp_target_event, e)->name,
+						  target_event_name(e),
 						  target_name(target),
 						  Jim_GetString(Jim_GetResult(teap->interp), NULL));
 				/* clean both error code and stacktrace before return */
@@ -4850,6 +5126,152 @@ void target_handle_event(struct target *target, enum target_event e)
 	}
 }
 
+static int target_jim_get_reg(Jim_Interp *interp, int argc,
+		Jim_Obj * const *argv)
+{
+	bool force = false;
+
+	if (argc == 3) {
+		const char *option = Jim_GetString(argv[1], NULL);
+
+		if (!strcmp(option, "-force")) {
+			argc--;
+			argv++;
+			force = true;
+		} else {
+			Jim_SetResultFormatted(interp, "invalid option '%s'", option);
+			return JIM_ERR;
+		}
+	}
+
+	if (argc != 2) {
+		Jim_WrongNumArgs(interp, 1, argv, "[-force] list");
+		return JIM_ERR;
+	}
+
+	const int length = Jim_ListLength(interp, argv[1]);
+
+	Jim_Obj *result_dict = Jim_NewDictObj(interp, NULL, 0);
+
+	if (!result_dict)
+		return JIM_ERR;
+
+	struct command_context *cmd_ctx = current_command_context(interp);
+	assert(cmd_ctx != NULL);
+	const struct target *target = get_current_target(cmd_ctx);
+
+	for (int i = 0; i < length; i++) {
+		Jim_Obj *elem = Jim_ListGetIndex(interp, argv[1], i);
+
+		if (!elem)
+			return JIM_ERR;
+
+		const char *reg_name = Jim_String(elem);
+
+		struct reg *reg = register_get_by_name(target->reg_cache, reg_name,
+			false);
+
+		if (!reg || !reg->exist) {
+			Jim_SetResultFormatted(interp, "unknown register '%s'", reg_name);
+			return JIM_ERR;
+		}
+
+		if (force) {
+			int retval = reg->type->get(reg);
+
+			if (retval != ERROR_OK) {
+				Jim_SetResultFormatted(interp, "failed to read register '%s'",
+					reg_name);
+				return JIM_ERR;
+			}
+		}
+
+		char *reg_value = buf_to_hex_str(reg->value, reg->size);
+
+		if (!reg_value) {
+			LOG_ERROR("Failed to allocate memory");
+			return JIM_ERR;
+		}
+
+		char *tmp = alloc_printf("0x%s", reg_value);
+
+		free(reg_value);
+
+		if (!tmp) {
+			LOG_ERROR("Failed to allocate memory");
+			return JIM_ERR;
+		}
+
+		Jim_DictAddElement(interp, result_dict, elem,
+			Jim_NewStringObj(interp, tmp, -1));
+
+		free(tmp);
+	}
+
+	Jim_SetResult(interp, result_dict);
+
+	return JIM_OK;
+}
+
+static int target_jim_set_reg(Jim_Interp *interp, int argc,
+		Jim_Obj * const *argv)
+{
+	if (argc != 2) {
+		Jim_WrongNumArgs(interp, 1, argv, "dict");
+		return JIM_ERR;
+	}
+
+	int tmp;
+#if JIM_VERSION >= 80
+	Jim_Obj **dict = Jim_DictPairs(interp, argv[1], &tmp);
+
+	if (!dict)
+		return JIM_ERR;
+#else
+	Jim_Obj **dict;
+	int ret = Jim_DictPairs(interp, argv[1], &dict, &tmp);
+
+	if (ret != JIM_OK)
+		return ret;
+#endif
+
+	const unsigned int length = tmp;
+	struct command_context *cmd_ctx = current_command_context(interp);
+	assert(cmd_ctx);
+	const struct target *target = get_current_target(cmd_ctx);
+
+	for (unsigned int i = 0; i < length; i += 2) {
+		const char *reg_name = Jim_String(dict[i]);
+		const char *reg_value = Jim_String(dict[i + 1]);
+		struct reg *reg = register_get_by_name(target->reg_cache, reg_name,
+			false);
+
+		if (!reg || !reg->exist) {
+			Jim_SetResultFormatted(interp, "unknown register '%s'", reg_name);
+			return JIM_ERR;
+		}
+
+		uint8_t *buf = malloc(DIV_ROUND_UP(reg->size, 8));
+
+		if (!buf) {
+			LOG_ERROR("Failed to allocate memory");
+			return JIM_ERR;
+		}
+
+		str_to_buf(reg_value, strlen(reg_value), buf, reg->size, 0);
+		int retval = reg->type->set(reg, buf);
+		free(buf);
+
+		if (retval != ERROR_OK) {
+			Jim_SetResultFormatted(interp, "failed to set '%s' to register '%s'",
+				reg_value, reg_name);
+			return JIM_ERR;
+		}
+	}
+
+	return JIM_OK;
+}
+
 /**
  * Returns true only if the target has a handler for the specified event.
  */
@@ -5503,9 +5925,9 @@ COMMAND_HANDLER(handle_target_event_list)
 	command_print(CMD, "------------------------- | "
 			"----------------------------------------");
 	while (teap) {
-		struct jim_nvp *opt = jim_nvp_value2name_simple(nvp_target_event, teap->event);
 		command_print(CMD, "%-25s | %s",
-				opt->name, Jim_GetString(teap->body, NULL));
+				target_event_name(teap->event),
+				Jim_GetString(teap->body, NULL));
 		teap = teap->next;
 	}
 	command_print(CMD, "***END***");
@@ -5632,6 +6054,34 @@ static const struct command_registration target_instance_command_handlers[] = {
 			"from target memory",
 		.usage = "arrayname bitwidth address count",
 	},
+	{
+		.name = "get_reg",
+		.mode = COMMAND_EXEC,
+		.jim_handler = target_jim_get_reg,
+		.help = "Get register values from the target",
+		.usage = "list",
+	},
+	{
+		.name = "set_reg",
+		.mode = COMMAND_EXEC,
+		.jim_handler = target_jim_set_reg,
+		.help = "Set target register values",
+		.usage = "dict",
+	},
+	{
+		.name = "read_memory",
+		.mode = COMMAND_EXEC,
+		.jim_handler = target_jim_read_memory,
+		.help = "Read Tcl list of 8/16/32/64 bit numbers from target memory",
+		.usage = "address width count ['phys']",
+	},
+	{
+		.name = "write_memory",
+		.mode = COMMAND_EXEC,
+		.jim_handler = target_jim_write_memory,
+		.help = "Write Tcl list of 8/16/32/64 bit numbers to target memory",
+		.usage = "address width data ['phys']",
+	},
 	{
 		.name = "eventlist",
 		.handler = handle_target_event_list,
@@ -5777,6 +6227,9 @@ static int target_create(struct jim_getopt_info *goi)
 		return JIM_ERR;
 	}
 
+	/* set empty smp cluster */
+	target->smp_targets = &empty_smp_targets;
+
 	/* set target number */
 	target->target_number = new_target_number();
 
@@ -5989,9 +6442,7 @@ static int jim_target_smp(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	const char *targetname;
 	int retval, len;
 	struct target *target = NULL;
-	struct target_list *head, *curr, *new;
-	curr = NULL;
-	head = NULL;
+	struct target_list *head, *new;
 
 	retval = 0;
 	LOG_DEBUG("%d", argc);
@@ -6000,6 +6451,13 @@ static int jim_target_smp(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	 * argv[3] ...
 	 */
 
+	struct list_head *lh = malloc(sizeof(*lh));
+	if (!lh) {
+		LOG_ERROR("Out of memory");
+		return JIM_ERR;
+	}
+	INIT_LIST_HEAD(lh);
+
 	for (i = 1; i < argc; i++) {
 
 		targetname = Jim_GetString(argv[i], &len);
@@ -6008,24 +6466,14 @@ static int jim_target_smp(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 		if (target) {
 			new = malloc(sizeof(struct target_list));
 			new->target = target;
-			new->next = NULL;
-			if (!head) {
-				head = new;
-				curr = head;
-			} else {
-				curr->next = new;
-				curr = new;
-			}
+			list_add_tail(&new->lh, lh);
 		}
 	}
 	/*  now parse the list of cpu and put the target in smp mode*/
-	curr = head;
-
-	while (curr) {
-		target = curr->target;
+	foreach_smp_target(head, lh) {
+		target = head->target;
 		target->smp = 1;
-		target->head = head;
-		curr = curr->next;
+		target->smp_targets = lh;
 	}
 
 	if (target && target->rtos)
@@ -6701,20 +7149,32 @@ static const struct command_registration target_exec_command_handlers[] = {
 		.usage = "filename [offset [type]]",
 	},
 	{
-		.name = "mem2array",
+		.name = "get_reg",
 		.mode = COMMAND_EXEC,
-		.jim_handler = jim_mem2array,
-		.help = "read 8/16/32 bit memory and return as a TCL array "
-			"for script processing",
-		.usage = "arrayname bitwidth address count",
+		.jim_handler = target_jim_get_reg,
+		.help = "Get register values from the target",
+		.usage = "list",
 	},
 	{
-		.name = "array2mem",
+		.name = "set_reg",
 		.mode = COMMAND_EXEC,
-		.jim_handler = jim_array2mem,
-		.help = "convert a TCL array to memory locations "
-			"and write the 8/16/32 bit values",
-		.usage = "arrayname bitwidth address count",
+		.jim_handler = target_jim_set_reg,
+		.help = "Set target register values",
+		.usage = "dict",
+	},
+	{
+		.name = "read_memory",
+		.mode = COMMAND_EXEC,
+		.jim_handler = target_jim_read_memory,
+		.help = "Read Tcl list of 8/16/32/64 bit numbers from target memory",
+		.usage = "address width count ['phys']",
+	},
+	{
+		.name = "write_memory",
+		.mode = COMMAND_EXEC,
+		.jim_handler = target_jim_write_memory,
+		.help = "Write Tcl list of 8/16/32/64 bit numbers to target memory",
+		.usage = "address width data ['phys']",
 	},
 	{
 		.name = "reset_nag",
diff --git a/src/target/target.h b/src/target/target.h
index 6ef8f10e0..1f1a35420 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -201,7 +201,9 @@ struct target {
 										 * and must be detected when symbols are offered */
 	struct backoff_timer backoff;
 	int smp;							/* add some target attributes for smp support */
-	struct target_list *head;
+	struct list_head *smp_targets;		/* list all targets in this smp group/cluster
+										 * The head of the list is shared between the
+										 * cluster, thus here there is a pointer */
 	/* the gdb service is there in case of smp, we have only one gdb server
 	 * for all smp target
 	 * the target attached to the gdb is changing dynamically by changing
@@ -220,8 +222,8 @@ struct target {
 };
 
 struct target_list {
+	struct list_head lh;
 	struct target *target;
-	struct target_list *next;
 };
 
 struct gdb_fileio_info {
@@ -294,6 +296,15 @@ enum target_event {
 	TARGET_EVENT_GDB_FLASH_WRITE_END,
 
 	TARGET_EVENT_TRACE_CONFIG,
+
+	TARGET_EVENT_SEMIHOSTING_USER_CMD_0x100 = 0x100, /* semihosting allows user cmds from 0x100 to 0x1ff */
+	TARGET_EVENT_SEMIHOSTING_USER_CMD_0x101 = 0x101,
+	TARGET_EVENT_SEMIHOSTING_USER_CMD_0x102 = 0x102,
+	TARGET_EVENT_SEMIHOSTING_USER_CMD_0x103 = 0x103,
+	TARGET_EVENT_SEMIHOSTING_USER_CMD_0x104 = 0x104,
+	TARGET_EVENT_SEMIHOSTING_USER_CMD_0x105 = 0x105,
+	TARGET_EVENT_SEMIHOSTING_USER_CMD_0x106 = 0x106,
+	TARGET_EVENT_SEMIHOSTING_USER_CMD_0x107 = 0x107,
 };
 
 struct target_event_action {
diff --git a/src/target/target_type.h b/src/target/target_type.h
index d6b6086b3..a26c2e7d8 100644
--- a/src/target/target_type.h
+++ b/src/target/target_type.h
@@ -242,6 +242,17 @@ struct target_type {
 	/**
 	 * Free all the resources allocated by the target.
 	 *
+	 * WARNING: deinit_target is called unconditionally regardless the target has
+	 * ever been examined/initialised or not.
+	 * If a problem has prevented establishing JTAG/SWD/... communication
+	 *  or
+	 * if the target was created with -defer-examine flag and has never been
+	 *  examined
+	 * then it is not possible to communicate with the target.
+	 *
+	 * If you need to talk to the target during deinit, first check if
+	 * target_was_examined()!
+	 *
 	 * @param target The target to deinit
 	 */
 	void (*deinit_target)(struct target *target);
diff --git a/src/target/x86_32_common.c b/src/target/x86_32_common.c
index a009bfe92..d119be148 100644
--- a/src/target/x86_32_common.c
+++ b/src/target/x86_32_common.c
@@ -862,7 +862,7 @@ int x86_32_common_remove_watchpoint(struct target *t, struct watchpoint *wp)
 {
 	if (check_not_halted(t))
 		return ERROR_TARGET_NOT_HALTED;
-	if (wp->set)
+	if (wp->is_set)
 		unset_watchpoint(t, wp);
 	return ERROR_OK;
 }
@@ -883,7 +883,7 @@ int x86_32_common_remove_breakpoint(struct target *t, struct breakpoint *bp)
 	LOG_DEBUG("type=%d, addr=" TARGET_ADDR_FMT, bp->type, bp->address);
 	if (check_not_halted(t))
 		return ERROR_TARGET_NOT_HALTED;
-	if (bp->set)
+	if (bp->is_set)
 		unset_breakpoint(t, bp);
 
 	return ERROR_OK;
@@ -995,7 +995,7 @@ static int set_hwbp(struct target *t, struct breakpoint *bp)
 	}
 	if (set_debug_regs(t, bp->address, hwbp_num, DR7_BP_EXECUTE, 1) != ERROR_OK)
 		return ERROR_FAIL;
-	bp->set = hwbp_num + 1;
+	breakpoint_hw_set(bp, hwbp_num);
 	debug_reg_list[hwbp_num].used = 1;
 	debug_reg_list[hwbp_num].bp_value = bp->address;
 	LOG_USER("%s hardware breakpoint %" PRIu32 " set at 0x%08" PRIx32 " (hwreg=%" PRIu8 ")", __func__,
@@ -1007,9 +1007,9 @@ static int unset_hwbp(struct target *t, struct breakpoint *bp)
 {
 	struct x86_32_common *x86_32 = target_to_x86_32(t);
 	struct x86_32_dbg_reg *debug_reg_list = x86_32->hw_break_list;
-	int hwbp_num = bp->set - 1;
+	int hwbp_num = bp->number;
 
-	if ((hwbp_num < 0) || (hwbp_num >= x86_32->num_hw_bpoints)) {
+	if (hwbp_num >= x86_32->num_hw_bpoints) {
 		LOG_ERROR("%s invalid breakpoint number=%d, bpid=%" PRIu32,
 				__func__, hwbp_num, bp->unique_id);
 		return ERROR_OK;
@@ -1055,7 +1055,7 @@ static int set_swbp(struct target *t, struct breakpoint *bp)
 				__func__, readback, *bp->orig_instr);
 		return ERROR_FAIL;
 	}
-	bp->set = SW_BP_OPCODE; /* just non 0 */
+	bp->is_set = true;
 
 	/* add the memory patch */
 	struct swbp_mem_patch *new_patch = malloc(sizeof(struct swbp_mem_patch));
@@ -1134,7 +1134,7 @@ static int set_breakpoint(struct target *t, struct breakpoint *bp)
 	int error = ERROR_OK;
 	struct x86_32_common *x86_32 = target_to_x86_32(t);
 	LOG_DEBUG("type=%d, addr=" TARGET_ADDR_FMT, bp->type, bp->address);
-	if (bp->set) {
+	if (bp->is_set) {
 		LOG_ERROR("breakpoint already set");
 		return error;
 	}
@@ -1164,7 +1164,7 @@ static int set_breakpoint(struct target *t, struct breakpoint *bp)
 static int unset_breakpoint(struct target *t, struct breakpoint *bp)
 {
 	LOG_DEBUG("type=%d, addr=" TARGET_ADDR_FMT, bp->type, bp->address);
-	if (!bp->set) {
+	if (!bp->is_set) {
 		LOG_WARNING("breakpoint not set");
 		return ERROR_OK;
 	}
@@ -1182,7 +1182,7 @@ static int unset_breakpoint(struct target *t, struct breakpoint *bp)
 			return ERROR_FAIL;
 		}
 	}
-	bp->set = 0;
+	bp->is_set = false;
 	return ERROR_OK;
 }
 
@@ -1193,7 +1193,7 @@ static int set_watchpoint(struct target *t, struct watchpoint *wp)
 	int wp_num = 0;
 	LOG_DEBUG("type=%d, addr=" TARGET_ADDR_FMT, wp->rw, wp->address);
 
-	if (wp->set) {
+	if (wp->is_set) {
 		LOG_ERROR("%s watchpoint already set", __func__);
 		return ERROR_OK;
 	}
@@ -1233,7 +1233,7 @@ static int set_watchpoint(struct target *t, struct watchpoint *wp)
 			LOG_ERROR("%s only 'access' or 'write' watchpoints are supported", __func__);
 			break;
 	}
-	wp->set = wp_num + 1;
+	watchpoint_set(wp, wp_num);
 	debug_reg_list[wp_num].used = 1;
 	debug_reg_list[wp_num].bp_value = wp->address;
 	LOG_USER("'%s' watchpoint %d set at " TARGET_ADDR_FMT " with length %" PRIu32 " (hwreg=%d)",
@@ -1248,13 +1248,13 @@ static int unset_watchpoint(struct target *t, struct watchpoint *wp)
 	struct x86_32_common *x86_32 = target_to_x86_32(t);
 	struct x86_32_dbg_reg *debug_reg_list = x86_32->hw_break_list;
 	LOG_DEBUG("type=%d, addr=" TARGET_ADDR_FMT, wp->rw, wp->address);
-	if (!wp->set) {
+	if (!wp->is_set) {
 		LOG_WARNING("watchpoint not set");
 		return ERROR_OK;
 	}
 
-	int wp_num = wp->set - 1;
-	if ((wp_num < 0) || (wp_num >= x86_32->num_hw_bpoints)) {
+	int wp_num = wp->number;
+	if (wp_num >= x86_32->num_hw_bpoints) {
 		LOG_DEBUG("Invalid FP Comparator number in watchpoint");
 		return ERROR_OK;
 	}
@@ -1263,7 +1263,7 @@ static int unset_watchpoint(struct target *t, struct watchpoint *wp)
 
 	debug_reg_list[wp_num].used = 0;
 	debug_reg_list[wp_num].bp_value = 0;
-	wp->set = 0;
+	wp->is_set = false;
 
 	LOG_USER("'%s' watchpoint %d removed from " TARGET_ADDR_FMT " with length %" PRIu32 " (hwreg=%d)",
 			wp->rw == WPT_READ ? "read" : wp->rw == WPT_WRITE ?
diff --git a/src/target/xscale.c b/src/target/xscale.c
index dd383b6e4..78bd09922 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -1087,7 +1087,7 @@ static void xscale_enable_watchpoints(struct target *target)
 	struct watchpoint *watchpoint = target->watchpoints;
 
 	while (watchpoint) {
-		if (watchpoint->set == 0)
+		if (!watchpoint->is_set)
 			xscale_set_watchpoint(target, watchpoint);
 		watchpoint = watchpoint->next;
 	}
@@ -1099,7 +1099,7 @@ static void xscale_enable_breakpoints(struct target *target)
 
 	/* set any pending breakpoints */
 	while (breakpoint) {
-		if (breakpoint->set == 0)
+		if (!breakpoint->is_set)
 			xscale_set_breakpoint(target, breakpoint);
 		breakpoint = breakpoint->next;
 	}
@@ -1506,7 +1506,7 @@ static int xscale_deassert_reset(struct target *target)
 	/* mark all hardware breakpoints as unset */
 	while (breakpoint) {
 		if (breakpoint->type == BKPT_HARD)
-			breakpoint->set = 0;
+			breakpoint->is_set = false;
 		breakpoint = breakpoint->next;
 	}
 
@@ -2088,7 +2088,7 @@ static int xscale_set_breakpoint(struct target *target,
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if (breakpoint->set) {
+	if (breakpoint->is_set) {
 		LOG_WARNING("breakpoint already set");
 		return ERROR_OK;
 	}
@@ -2098,11 +2098,13 @@ static int xscale_set_breakpoint(struct target *target,
 		if (!xscale->ibcr0_used) {
 			xscale_set_reg_u32(&xscale->reg_cache->reg_list[XSCALE_IBCR0], value);
 			xscale->ibcr0_used = 1;
-			breakpoint->set = 1;	/* breakpoint set on first breakpoint register */
+			/* breakpoint set on first breakpoint register */
+			breakpoint_hw_set(breakpoint, 0);
 		} else if (!xscale->ibcr1_used) {
 			xscale_set_reg_u32(&xscale->reg_cache->reg_list[XSCALE_IBCR1], value);
 			xscale->ibcr1_used = 1;
-			breakpoint->set = 2;	/* breakpoint set on second breakpoint register */
+			/* breakpoint set on second breakpoint register */
+			breakpoint_hw_set(breakpoint, 1);
 		} else {/* bug: availability previously verified in xscale_add_breakpoint() */
 			LOG_ERROR("BUG: no hardware comparator available");
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
@@ -2133,7 +2135,7 @@ static int xscale_set_breakpoint(struct target *target,
 			if (retval != ERROR_OK)
 				return retval;
 		}
-		breakpoint->set = 1;
+		breakpoint->is_set = true;
 
 		xscale_send_u32(target, 0x50);	/* clean dcache */
 		xscale_send_u32(target, xscale->cache_clean_address);
@@ -2176,20 +2178,20 @@ static int xscale_unset_breakpoint(struct target *target,
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if (!breakpoint->set) {
+	if (!breakpoint->is_set) {
 		LOG_WARNING("breakpoint not set");
 		return ERROR_OK;
 	}
 
 	if (breakpoint->type == BKPT_HARD) {
-		if (breakpoint->set == 1) {
+		if (breakpoint->number == 0) {
 			xscale_set_reg_u32(&xscale->reg_cache->reg_list[XSCALE_IBCR0], 0x0);
 			xscale->ibcr0_used = 0;
-		} else if (breakpoint->set == 2) {
+		} else if (breakpoint->number == 1) {
 			xscale_set_reg_u32(&xscale->reg_cache->reg_list[XSCALE_IBCR1], 0x0);
 			xscale->ibcr1_used = 0;
 		}
-		breakpoint->set = 0;
+		breakpoint->is_set = false;
 	} else {
 		/* restore original instruction (kept in target endianness) */
 		if (breakpoint->length == 4) {
@@ -2203,7 +2205,7 @@ static int xscale_unset_breakpoint(struct target *target,
 			if (retval != ERROR_OK)
 				return retval;
 		}
-		breakpoint->set = 0;
+		breakpoint->is_set = false;
 
 		xscale_send_u32(target, 0x50);	/* clean dcache */
 		xscale_send_u32(target, xscale->cache_clean_address);
@@ -2223,7 +2225,7 @@ static int xscale_remove_breakpoint(struct target *target, struct breakpoint *br
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if (breakpoint->set)
+	if (breakpoint->is_set)
 		xscale_unset_breakpoint(target, breakpoint);
 
 	if (breakpoint->type == BKPT_HARD)
@@ -2279,13 +2281,13 @@ static int xscale_set_watchpoint(struct target *target,
 		xscale_set_reg_u32(&xscale->reg_cache->reg_list[XSCALE_DBR0], watchpoint->address);
 		dbcon_value |= enable;
 		xscale_set_reg_u32(dbcon, dbcon_value);
-		watchpoint->set = 1;
+		watchpoint_set(watchpoint, 0);
 		xscale->dbr0_used = 1;
 	} else if (!xscale->dbr1_used) {
 		xscale_set_reg_u32(&xscale->reg_cache->reg_list[XSCALE_DBR1], watchpoint->address);
 		dbcon_value |= enable << 2;
 		xscale_set_reg_u32(dbcon, dbcon_value);
-		watchpoint->set = 2;
+		watchpoint_set(watchpoint, 1);
 		xscale->dbr1_used = 1;
 	} else {
 		LOG_ERROR("BUG: no hardware comparator available");
@@ -2349,12 +2351,12 @@ static int xscale_unset_watchpoint(struct target *target,
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if (!watchpoint->set) {
+	if (!watchpoint->is_set) {
 		LOG_WARNING("breakpoint not set");
 		return ERROR_OK;
 	}
 
-	if (watchpoint->set == 1) {
+	if (watchpoint->number == 0) {
 		if (watchpoint->length > 4) {
 			dbcon_value &= ~0x103;	/* clear DBCON[M] as well */
 			xscale->dbr1_used = 0;	/* DBR1 was used for mask */
@@ -2363,12 +2365,12 @@ static int xscale_unset_watchpoint(struct target *target,
 
 		xscale_set_reg_u32(dbcon, dbcon_value);
 		xscale->dbr0_used = 0;
-	} else if (watchpoint->set == 2) {
+	} else if (watchpoint->number == 1) {
 		dbcon_value &= ~0xc;
 		xscale_set_reg_u32(dbcon, dbcon_value);
 		xscale->dbr1_used = 0;
 	}
-	watchpoint->set = 0;
+	watchpoint->is_set = false;
 
 	return ERROR_OK;
 }
@@ -2382,7 +2384,7 @@ static int xscale_remove_watchpoint(struct target *target, struct watchpoint *wa
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if (watchpoint->set)
+	if (watchpoint->is_set)
 		xscale_unset_watchpoint(target, watchpoint);
 
 	if (watchpoint->length > 4)
diff --git a/tcl/board/at91cap7a-stk-sdram.cfg b/tcl/board/at91cap7a-stk-sdram.cfg
index 8a371e064..182a4067f 100644
--- a/tcl/board/at91cap7a-stk-sdram.cfg
+++ b/tcl/board/at91cap7a-stk-sdram.cfg
@@ -32,8 +32,7 @@ $_TARGETNAME configure -event reset-start {
 }
 
 proc peek32 {address} {
-	mem2array t 32 $address 1
-	return $t(0)
+	return [read_memory $address 32 1]
 }
 
 # Wait for an expression to be true with a timeout
diff --git a/tcl/board/at91sam9g20-ek.cfg b/tcl/board/at91sam9g20-ek.cfg
index e1cbb9120..04d9a197c 100644
--- a/tcl/board/at91sam9g20-ek.cfg
+++ b/tcl/board/at91sam9g20-ek.cfg
@@ -40,9 +40,7 @@ at91sam9 rdy_busy 0 0xfffff800 13
 at91sam9 ce 0 0xfffff800 14
 
 proc read_register {register} {
-        set result ""
-        mem2array result 32 $register 1
-        return $result(0)
+	return [read_memory $register 32 1]
 }
 
 proc at91sam9g20_reset_start { } {
diff --git a/tcl/board/embedded-artists_lpc2478-32.cfg b/tcl/board/embedded-artists_lpc2478-32.cfg
index 38f5e1b8e..a73d83263 100644
--- a/tcl/board/embedded-artists_lpc2478-32.cfg
+++ b/tcl/board/embedded-artists_lpc2478-32.cfg
@@ -8,9 +8,7 @@ source [find target/lpc2478.cfg]
 # Helper
 #
 proc read_register {register} {
-    set result ""
-    mem2array result 32 $register 1
-    return $result(0)
+    return [read_memory $register 32 1]
 }
 
 proc init_board {} {
diff --git a/tcl/board/evb-lan9255.cfg b/tcl/board/evb-lan9255.cfg
new file mode 100644
index 000000000..3fd6f603b
--- /dev/null
+++ b/tcl/board/evb-lan9255.cfg
@@ -0,0 +1,11 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# Microchip LAN9255 evaluation board
+# https://www.microchip.com/en-us/development-tool/EV25Y25A
+#
+
+set CHIPNAME same53
+
+source [find target/atsame5x.cfg]
+
+reset_config srst_only
diff --git a/tcl/board/hilscher_nxhx10.cfg b/tcl/board/hilscher_nxhx10.cfg
index 1875dacc0..6e2eba79e 100644
--- a/tcl/board/hilscher_nxhx10.cfg
+++ b/tcl/board/hilscher_nxhx10.cfg
@@ -26,9 +26,7 @@ proc flash_init { } {
 }
 
 proc mread32 {addr} {
-  set value(0) 0
-  mem2array value 32 $addr 1
-  return $value(0)
+  return [read_memory $addr 32 1]
 }
 
 proc init_clocks { } {
diff --git a/tcl/board/icnova_sam9g45_sodimm.cfg b/tcl/board/icnova_sam9g45_sodimm.cfg
index 8a0736b1f..91e0107c2 100644
--- a/tcl/board/icnova_sam9g45_sodimm.cfg
+++ b/tcl/board/icnova_sam9g45_sodimm.cfg
@@ -43,9 +43,7 @@ flash bank $_FLASHNAME cfi 0x10000000 0x00800000 2 2 $_TARGETNAME
 
 
 proc read_register {register} {
-        set result ""
-        mem2array result 32 $register 1
-        return $result(0)
+	return [read_memory $register 32 1]
 }
 
 proc at91sam9g45_start { } {
diff --git a/tcl/board/lemaker_hikey.cfg b/tcl/board/lemaker_hikey.cfg
index ee677c34b..325b6fdda 100644
--- a/tcl/board/lemaker_hikey.cfg
+++ b/tcl/board/lemaker_hikey.cfg
@@ -17,7 +17,7 @@ proc core_up { args } {
 	global _TARGETNAME
 
 	# examine remaining cores
-	foreach _core [set args] {
+	foreach _core $args {
 		${_TARGETNAME}$_core arp_examine
 	}
 }
diff --git a/tcl/board/nxp_frdm-k64f.cfg b/tcl/board/nxp_frdm-k64f.cfg
new file mode 100644
index 000000000..1581c9594
--- /dev/null
+++ b/tcl/board/nxp_frdm-k64f.cfg
@@ -0,0 +1,15 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+# This is an NXP Freedom eval board with a single MK64FN1M0VLL12 chip.
+# https://www.nxp.com/design/development-boards/freedom-development-boards/mcu-boards/freedom-development-platform-for-kinetis-k64-k63-and-k24-mcus:FRDM-K64F
+#
+
+source [find interface/cmsis-dap.cfg]
+
+# Set working area to 16 KiB
+set WORKAREASIZE 0x4000
+
+set CHIPNAME k64f
+reset_config srst_only
+
+source [find target/kx.cfg]
diff --git a/tcl/board/nxp_rdb-ls1046a.cfg b/tcl/board/nxp_rdb-ls1046a.cfg
new file mode 100644
index 000000000..fde1829fb
--- /dev/null
+++ b/tcl/board/nxp_rdb-ls1046a.cfg
@@ -0,0 +1,17 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# NXP LS1046ARDB (Reference Design Board)
+# This is for the "console" USB port on the front panel
+# You must ensure that SW4-7 is in the "off" position
+
+# NXP K20
+# The firmware implements the old CMSIS-DAP v1 USB HID interface
+# You must pass --enable-cmsis-dap to ./configure to enable it
+source [find interface/cmsis-dap.cfg]
+
+transport select jtag
+reset_config srst_only
+
+source [find target/ls1046a.cfg]
+
+# The adapter can't handle 10MHz
+adapter speed 5000
diff --git a/tcl/board/nxp_rdb-ls1088a.cfg b/tcl/board/nxp_rdb-ls1088a.cfg
new file mode 100644
index 000000000..40483f2d6
--- /dev/null
+++ b/tcl/board/nxp_rdb-ls1088a.cfg
@@ -0,0 +1,14 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# NXP LS1088ARDB (Reference Design Board)
+# This is for the "main" JTAG connector J55
+
+transport select jtag
+reset_config srst_only
+
+# To access the CPLD, populate J48 and add `-c 'set CWTAP 1'` to your command
+# line. At the time of this writing, programming is unsupported.
+if { [info exists CWTAP] } {
+	source [find cpld/altera-epm240.cfg]
+} else {
+	source [find target/ls1088a.cfg]
+}
diff --git a/tcl/board/steval-idb012v1.cfg b/tcl/board/steval-idb012v1.cfg
new file mode 100644
index 000000000..25efc581f
--- /dev/null
+++ b/tcl/board/steval-idb012v1.cfg
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0-or-later.
+# This is an evaluation board with a single BlueNRG-LPS chip.
+set CHIPNAME bluenrg-lps
+source [find interface/cmsis-dap.cfg]
+source [find target/bluenrg-x.cfg]
\ No newline at end of file
diff --git a/tcl/board/stm32mp25x_dk.cfg b/tcl/board/stm32mp25x_dk.cfg
new file mode 100644
index 000000000..5cd7f4134
--- /dev/null
+++ b/tcl/board/stm32mp25x_dk.cfg
@@ -0,0 +1,23 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+# Script for stm32mp25x DISCO board
+
+source [find interface/stlink-dap.cfg]
+
+transport select dapdirect_swd
+
+# For CubeIDE to select the core, use:
+# set AP_NUM : 0=>A35, 2=>M0P, 8=>M33
+#
+# if AP_NUM is set to 0, you can select which A35 instance by:
+# set CORE_ID : 0=>A35_0, 1=>A35_1
+#
+# by default AP_NUM=0, CORE_ID=0
+
+if { [info exists AP_NUM] } {
+	source [find target/stm32mp25x_cubeide.cfg]
+} else {
+	source [find target/stm32mp25x_oe.cfg]
+}
+
+reset_config srst_only
diff --git a/tcl/board/stm32mp25x_fpga_stlink_jtag.cfg b/tcl/board/stm32mp25x_fpga_stlink_jtag.cfg
new file mode 100644
index 000000000..ed6b90166
--- /dev/null
+++ b/tcl/board/stm32mp25x_fpga_stlink_jtag.cfg
@@ -0,0 +1,31 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+# internal script for stm32mp25x running on FPGA
+
+echo "          *******************************************************"
+echo "          *                    ATTENTION !!!                    *"
+echo "          *                                                     *"
+echo "          *   the file 'board/stm32mp25x_fpga_stlink_jtag.cfg'  *"
+echo "          *   will be dropped soon and only the file            *"
+echo "          *   'board/stm32mp25x_dk.cfg' will remain available.  *"
+echo "          *******************************************************"
+
+source [find interface/stlink-dap.cfg]
+
+transport select dapdirect_jtag
+
+# For CubeIDE to select the core, use:
+# set AP_NUM : 0=>A35, 2=>M0P, 8=>M33
+#
+# if AP_NUM is set to 0, you can select which A35 instance by:
+# set CORE_ID : 0=>A35_0, 1=>A35_1
+#
+# by default AP_NUM=0, CORE_ID=0
+
+if { [info exists AP_NUM] } {
+	source [find target/stm32mp25x_cubeide.cfg]
+} else {
+	source [find target/stm32mp25x_oe.cfg]
+}
+
+reset_config srst_only
diff --git a/tcl/board/stm32mp25x_fpga_stlink_swd.cfg b/tcl/board/stm32mp25x_fpga_stlink_swd.cfg
new file mode 100644
index 000000000..6281286f3
--- /dev/null
+++ b/tcl/board/stm32mp25x_fpga_stlink_swd.cfg
@@ -0,0 +1,13 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+# internal script for stm32mp25x running on FPGA
+
+echo "          *******************************************************"
+echo "          *                    ATTENTION !!!                    *"
+echo "          *                                                     *"
+echo "          *   the file 'board/stm32mp25x_fpga_stlink_swd.cfg'   *"
+echo "          *   will be dropped soon and only the file            *"
+echo "          *   'board/stm32mp25x_dk.cfg' will remain available.  *"
+echo "          *******************************************************"
+
+source [find board/stm32mp25x_dk.cfg]
diff --git a/tcl/board/stm32mp25x_fpga_ulink_jtag.cfg b/tcl/board/stm32mp25x_fpga_ulink_jtag.cfg
new file mode 100644
index 000000000..36909957c
--- /dev/null
+++ b/tcl/board/stm32mp25x_fpga_ulink_jtag.cfg
@@ -0,0 +1,31 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+# internal script for stm32mp25x running on FPGA
+
+echo "          *******************************************************"
+echo "          *                    ATTENTION !!!                    *"
+echo "          *                                                     *"
+echo "          *   the file 'board/stm32mp25x_fpga_ulink_jtag.cfg'   *"
+echo "          *   will be dropped soon and only the file            *"
+echo "          *   'board/stm32mp25x_dk.cfg' will remain available.  *"
+echo "          *******************************************************"
+
+source [find interface/cmsis-dap.cfg]
+
+transport select jtag
+
+# For CubeIDE to select the core, use:
+# set AP_NUM : 0=>A35, 2=>M0P, 8=>M33
+#
+# if AP_NUM is set to 0, you can select which A35 instance by:
+# set CORE_ID : 0=>A35_0, 1=>A35_1
+#
+# by default AP_NUM=0, CORE_ID=0
+
+if { [info exists AP_NUM] } {
+	source [find target/stm32mp25x_cubeide.cfg]
+} else {
+	source [find target/stm32mp25x_oe.cfg]
+}
+
+reset_config srst_only
diff --git a/tcl/board/stm32mp25x_fpga_ulink_swd.cfg b/tcl/board/stm32mp25x_fpga_ulink_swd.cfg
new file mode 100644
index 000000000..0aafff06d
--- /dev/null
+++ b/tcl/board/stm32mp25x_fpga_ulink_swd.cfg
@@ -0,0 +1,31 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+# internal script for stm32mp25x running on FPGA
+
+echo "          *******************************************************"
+echo "          *                    ATTENTION !!!                    *"
+echo "          *                                                     *"
+echo "          *   the file 'board/stm32mp25x_fpga_ulink_swd.cfg'    *"
+echo "          *   will be dropped soon and only the file            *"
+echo "          *   'board/stm32mp25x_dk.cfg' will remain available.  *"
+echo "          *******************************************************"
+
+source [find interface/cmsis-dap.cfg]
+
+transport select swd
+
+# For CubeIDE to select the core, use:
+# set AP_NUM : 0=>A35, 2=>M0P, 8=>M33
+#
+# if AP_NUM is set to 0, you can select which A35 instance by:
+# set CORE_ID : 0=>A35_0, 1=>A35_1
+#
+# by default AP_NUM=0, CORE_ID=0
+
+if { [info exists AP_NUM] } {
+	source [find target/stm32mp25x_cubeide.cfg]
+} else {
+	source [find target/stm32mp25x_oe.cfg]
+}
+
+reset_config srst_only
diff --git a/tcl/board/ti_am625evm.cfg b/tcl/board/ti_am625evm.cfg
new file mode 100644
index 000000000..4906fd096
--- /dev/null
+++ b/tcl/board/ti_am625evm.cfg
@@ -0,0 +1,25 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (C) 2021-2022 Texas Instruments Incorporated - http://www.ti.com/
+#
+# Texas Instruments am625 EVM/SK
+# Link: https://www.ti.com/lit/zip/sprr448
+#
+
+# AM625 EVM has an xds110 onboard.
+source [find interface/xds110.cfg]
+
+transport select jtag
+
+# default JTAG configuration has only SRST and no TRST
+reset_config srst_only srst_push_pull
+
+# delay after SRST goes inactive
+adapter srst delay 20
+
+if { ![info exists SOC] } {
+	set SOC am625
+}
+
+source [find target/ti_k3.cfg]
+
+adapter speed 2500
diff --git a/tcl/board/ti_j721s2evm.cfg b/tcl/board/ti_j721s2evm.cfg
new file mode 100644
index 000000000..72418b57b
--- /dev/null
+++ b/tcl/board/ti_j721s2evm.cfg
@@ -0,0 +1,25 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Copyright (C) 2021 Texas Instruments Incorporated - http://www.ti.com/
+#
+# Texas Instruments J721s2 EVM
+# Link(SoM): https://www.ti.com/lit/zip/sprr439
+#
+
+# J721s2 EVM has an xds110 onboard.
+source [find interface/xds110.cfg]
+
+transport select jtag
+
+# default JTAG configuration has only SRST and no TRST
+reset_config srst_only srst_push_pull
+
+# delay after SRST goes inactive
+adapter srst delay 20
+
+if { ![info exists SOC] } {
+	set SOC j721s2
+}
+
+source [find target/ti_k3.cfg]
+
+adapter speed 2500
diff --git a/tcl/board/tocoding_poplar.cfg b/tcl/board/tocoding_poplar.cfg
index 6d2e6354e..36d5aec47 100644
--- a/tcl/board/tocoding_poplar.cfg
+++ b/tcl/board/tocoding_poplar.cfg
@@ -19,7 +19,7 @@ proc core_up { args } {
 	global _TARGETNAME
 
 	# examine remaining cores
-	foreach _core [set args] {
+	foreach _core $args {
 		${_TARGETNAME}$_core arp_examine
 	}
 }
diff --git a/tcl/board/vd_a53x2_jtag.cfg b/tcl/board/vd_a53x2_jtag.cfg
new file mode 100644
index 000000000..869bc4db0
--- /dev/null
+++ b/tcl/board/vd_a53x2_jtag.cfg
@@ -0,0 +1,31 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Cadence virtual debug interface
+# Arm Cortex A53x2 through JTAG
+
+source [find interface/vdebug.cfg]
+
+set _CORES 2
+set _CHIPNAME a53
+set _MEMSTART 0x00000000
+set _MEMSIZE 0x1000000
+set _CPUTAPID 0x5ba00477
+
+# vdebug select transport
+#transport select jtag
+
+# JTAG reset config, frequency and reset delay
+reset_config trst_and_srst
+adapter speed 50000
+adapter srst delay 5
+
+# BFM hierarchical path and input clk period
+vdebug bfm_path tbench.u_vd_jtag_bfm 10ns
+
+# DMA Memories to access backdoor (up to 4)
+vdebug mem_path tbench.u_memory.mem_array $_MEMSTART $_MEMSIZE
+
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+jtag arp_init-reset
+
+source [find target/vd_aarch64.cfg]
diff --git a/tcl/board/vd_m4_jtag.cfg b/tcl/board/vd_m4_jtag.cfg
new file mode 100644
index 000000000..ca21476d2
--- /dev/null
+++ b/tcl/board/vd_m4_jtag.cfg
@@ -0,0 +1,30 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Cadence virtual debug interface
+# Arm Cortex m4 through JTAG
+
+source [find interface/vdebug.cfg]
+
+set _CHIPNAME m4
+set _MEMSTART 0x00000000
+set _MEMSIZE 0x10000
+set _CPUTAPID 0x4ba00477
+
+# vdebug select transport
+#transport select jtag
+
+# JTAG reset config, frequency and reset delay
+reset_config trst_and_srst
+adapter speed 25000
+adapter srst delay 5
+
+# BFM hierarchical path and input clk period
+vdebug bfm_path tbench.u_vd_jtag_bfm 20ns
+
+# DMA Memories to access backdoor (up to 4)
+vdebug mem_path tbench.u_mcu.u_sys.u_rom.rom $_MEMSTART $_MEMSIZE
+
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+jtag arp_init-reset
+
+source [find target/vd_cortex_m.cfg]
diff --git a/tcl/board/vd_pulpissimo_jtag.cfg b/tcl/board/vd_pulpissimo_jtag.cfg
new file mode 100644
index 000000000..69dd9e6db
--- /dev/null
+++ b/tcl/board/vd_pulpissimo_jtag.cfg
@@ -0,0 +1,32 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Cadence virtual debug interface
+# RISCV Ibex core with Pulpissimo through JTAG
+
+source [find interface/vdebug.cfg]
+
+set _CHIPNAME ibex
+set _HARTID 0x20
+set _CPUTAPID 0x249511c3
+
+# vdebug select transport
+#transport select jtag
+
+# JTAG reset config, frequency and reset delay
+reset_config trst_and_srst
+adapter speed 12500
+adapter srst delay 10
+
+# BFM hierarchical path and input clk period
+vdebug bfm_path tbench.u_vd_jtag_bfm 40ns
+
+# DMA Memories to access backdoor (up to 4)
+vdebug mem_path tbench.soc_domain_i.pulp_soc_i.gen_mem_l2_pri\[0\].sram_i.mem_array 0x1c000000 0x8000
+vdebug mem_path tbench.soc_domain_i.pulp_soc_i.gen_mem_l2_pri\[1\].sram_i.mem_array 0x1c008000 0x8000
+vdebug mem_path tbench.soc_domain_i.pulp_soc_i.gen_mem_l2\[0\].sram_i.mem_array 0x1c010000 0x80000
+
+# need to explicitly define riscv tap, autoprobing does not work for icapture != 0x01
+jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x05 -irmask 0x1f -expected-id $_CPUTAPID
+
+jtag arp_init-reset
+
+source [find target/vd_riscv.cfg]
diff --git a/tcl/board/vd_swerv_jtag.cfg b/tcl/board/vd_swerv_jtag.cfg
new file mode 100644
index 000000000..ff6c6835f
--- /dev/null
+++ b/tcl/board/vd_swerv_jtag.cfg
@@ -0,0 +1,32 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Cadence virtual debug interface
+# RISCV swerv core with Swerv through JTAG
+
+source [find interface/vdebug.cfg]
+
+set _CHIPNAME rv32
+set _HARTID 0x00
+set _CPUTAPID 0x1000008b
+set _MEMSTART 0x00000000
+set _MEMSIZE 0x10000
+
+# vdebug select transport
+#transport select jtag
+
+# JTAG reset config, frequency and reset delay
+reset_config trst_and_srst
+adapter speed 50000
+adapter srst delay 5
+
+# BFM hierarchical path and input clk period
+vdebug bfm_path tbench.u_vd_jtag_bfm 10ns
+
+# DMA Memories to access backdoor (up to 4)
+vdebug mem_path tbench.i_ahb_ic.mem $_MEMSTART $_MEMSIZE
+
+# need to explicitly define riscv tap, autoprobing does not work for icapture != 0x01
+jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x01 -irmask 0x1f -expected-id $_CPUTAPID
+
+jtag arp_init-reset
+
+source [find target/vd_riscv.cfg]
diff --git a/tcl/chip/atmel/at91/aic.tcl b/tcl/chip/atmel/at91/aic.tcl
index b0b100270..8b8a48f3b 100644
--- a/tcl/chip/atmel/at91/aic.tcl
+++ b/tcl/chip/atmel/at91/aic.tcl
@@ -54,36 +54,36 @@ proc show_AIC_IMR_helper { NAME ADDR VAL } {
 
 proc show_AIC { } {
     global AIC_SMR
-    if [catch { mem2array aaa 32 $AIC_SMR [expr {32 * 4}] } msg ] {
+    if [catch { set aaa [read_memory $AIC_SMR 32 [expr {32 * 4}]] } msg ] {
 	error [format "%s (%s)" $msg AIC_SMR]
     }
     echo "AIC_SMR: Mode & Type"
     global AT91C_ID
     for { set x 0 } { $x < 32 } {  } {
 	echo -n "   "
-	echo -n [format "%2d: %5s 0x%08x | " $x $AT91C_ID($x) $aaa($x)]
+	echo -n [format "%2d: %5s 0x%08x | " $x $AT91C_ID($x) [lindex $aaa $x]]
 	incr x
-	echo -n [format "%2d: %5s 0x%08x | " $x $AT91C_ID($x) $aaa($x)]
+	echo -n [format "%2d: %5s 0x%08x | " $x $AT91C_ID($x) [lindex $aaa $x]]
 	incr x
-	echo -n [format "%2d: %5s 0x%08x | " $x $AT91C_ID($x) $aaa($x)]
+	echo -n [format "%2d: %5s 0x%08x | " $x $AT91C_ID($x) [lindex $aaa $x]]
 	incr x
-	echo  [format "%2d: %5s 0x%08x"  $x $AT91C_ID($x) $aaa($x)]
+	echo  [format "%2d: %5s 0x%08x"  $x $AT91C_ID($x) [lindex $aaa $x]]
 	incr x
     }
     global AIC_SVR
-    if [catch { mem2array aaa 32 $AIC_SVR [expr {32 * 4}] } msg ] {
+    if [catch { set aaa [read_memory $AIC_SVR 32 [expr {32 * 4}]] } msg ] {
 	error [format "%s (%s)" $msg AIC_SVR]
     }
     echo "AIC_SVR: Vectors"
     for { set x 0 } { $x < 32 } {  } {
 	echo -n "   "
-	echo -n [format "%2d: %5s 0x%08x | " $x $AT91C_ID($x) $aaa($x)]
+	echo -n [format "%2d: %5s 0x%08x | " $x $AT91C_ID($x) [lindex $aaa $x]]
 	incr x
-	echo -n [format "%2d: %5s 0x%08x | " $x $AT91C_ID($x) $aaa($x)]
+	echo -n [format "%2d: %5s 0x%08x | " $x $AT91C_ID($x) [lindex $aaa $x]]
 	incr x
-	echo -n [format "%2d: %5s 0x%08x | " $x $AT91C_ID($x) $aaa($x)]
+	echo -n [format "%2d: %5s 0x%08x | " $x $AT91C_ID($x) [lindex $aaa $x]]
 	incr x
-	echo [format "%2d: %5s 0x%08x" $x $AT91C_ID($x) $aaa($x)]
+	echo [format "%2d: %5s 0x%08x" $x $AT91C_ID($x) [lindex $aaa $x]]
 	incr x
     }
 
diff --git a/tcl/cpld/altera-epm240.cfg b/tcl/cpld/altera-epm240.cfg
index 62f2b73b7..ece02bbef 100644
--- a/tcl/cpld/altera-epm240.cfg
+++ b/tcl/cpld/altera-epm240.cfg
@@ -1,6 +1,23 @@
 # Altera MAXII EPM240T100C CPLD
+
+if { [info exists CHIPNAME] } {
+	set _CHIPNAME $CHIPNAME
+} else {
+	set _CHIPNAME epm240
+}
+
 # see MAX II Device Handbook
 # Table 3-3: 32-Bit MAX II Device IDCODE
 # Version     Part Number             Manuf. ID        LSB
 # 0000        0010 0000 1010 0001     000 0110 1110    1
-jtag newtap epm240 tap -expected-id 0x020a10dd -irlen 10
+jtag newtap $_CHIPNAME tap -irlen 10 \
+	-expected-id 0x020a10dd \
+	-expected-id 0x020a20dd \
+	-expected-id 0x020a30dd \
+	-expected-id 0x020a40dd \
+	-expected-id 0x020a50dd \
+	-expected-id 0x020a60dd
+
+# 200ns seems like a good speed
+# c.f. Table 5-34: MAX II JTAG Timing Parameters
+adapter speed 5000
diff --git a/tcl/cpu/arc/common.tcl b/tcl/cpu/arc/common.tcl
index e9a915717..b31e31a34 100644
--- a/tcl/cpu/arc/common.tcl
+++ b/tcl/cpu/arc/common.tcl
@@ -29,9 +29,8 @@ proc arc_common_reset { {target ""} } {
         # vector located at the interrupt vector base address, which is the first
         # entry (offset 0x00) in the vector table.
         set int_vector_base [arc jtag get-aux-reg 0x25]
-        set start_pc ""
-        mem2array start_pc 32 $int_vector_base 1
-        arc jtag set-aux-reg 0x6 $start_pc(0)
+        set start_pc [read_memory $int_vector_base 32 1]
+        arc jtag set-aux-reg 0x6 $start_pc
 
         # It is OK to do uncached writes - register cache will be invalidated by
         # the reset_assert() function.
diff --git a/tcl/interface/vdebug.cfg b/tcl/interface/vdebug.cfg
new file mode 100644
index 000000000..9cca6aaab
--- /dev/null
+++ b/tcl/interface/vdebug.cfg
@@ -0,0 +1,33 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Cadence virtual debug interface
+
+if { [info exists VDEBUGHOST] } {
+	set _VDEBUGHOST $VDEBUGHOST
+} else {
+	set _VDEBUGHOST localhost
+}
+if { [info exists VDEBUGPORT] } {
+	set _VDEBUGPORT $VDEBUGPORT
+} else {
+	set _VDEBUGPORT 8192
+}
+
+adapter driver vdebug
+# vdebug server:port
+vdebug server $_VDEBUGHOST:$_VDEBUGPORT
+
+# example config debug level and log
+#debug_level 3
+#log_output vd_ocd.log
+
+# example config listen on all interfaces, disable tcl/telnet server
+bindto 0.0.0.0
+#gdb_port 3333
+#telnet_port disabled
+tcl_port disabled
+
+# transaction batching: 0 - no batching, 1 - (default) wr, 2 - rw
+vdebug batching 1
+
+# Polling values
+vdebug polling 100 1000
\ No newline at end of file
diff --git a/tcl/mem_helper.tcl b/tcl/mem_helper.tcl
index 9ea285a22..1c860119a 100644
--- a/tcl/mem_helper.tcl
+++ b/tcl/mem_helper.tcl
@@ -2,9 +2,7 @@
 
 # mrw: "memory read word", returns value of $reg
 proc mrw {reg} {
-	set value ""
-	mem2array value 32 $reg 1
-	return $value(0)
+	return [read_memory $reg 32 1]
 }
 
 add_usage_text mrw "address"
@@ -12,9 +10,7 @@ add_help_text mrw "Returns value of word in memory."
 
 # mrh: "memory read halfword", returns value of $reg
 proc mrh {reg} {
-	set value ""
-	mem2array value 16 $reg 1
-	return $value(0)
+	return [read_memory $reg 16 1]
 }
 
 add_usage_text mrh "address"
@@ -22,9 +18,7 @@ add_help_text mrh "Returns value of halfword in memory."
 
 # mrb: "memory read byte", returns value of $reg
 proc mrb {reg} {
-	set value ""
-	mem2array value 8 $reg 1
-	return $value(0)
+	return [read_memory $reg 8 1]
 }
 
 add_usage_text mrb "address"
diff --git a/tcl/memory.tcl b/tcl/memory.tcl
index 8d50ba853..ac273451d 100644
--- a/tcl/memory.tcl
+++ b/tcl/memory.tcl
@@ -79,108 +79,96 @@ proc address_info { ADDRESS } {
 }
 
 proc memread32 {ADDR} {
-    set foo(0) 0
-    if ![ catch { mem2array foo 32 $ADDR 1  } msg ] {
-	return $foo(0)
+    if ![ catch { set foo [read_memory $ADDR 32 1] } msg ] {
+	return $foo
     } else {
 	error "memread32: $msg"
     }
 }
 
 proc memread16 {ADDR} {
-    set foo(0) 0
-    if ![ catch { mem2array foo 16 $ADDR 1  } msg ] {
-	return $foo(0)
+    if ![ catch { set foo [read_memory $ADDR 16 1] } msg ] {
+	return $foo
     } else {
 	error "memread16: $msg"
     }
 }
 
 proc memread8 {ADDR} {
-    set foo(0) 0
-    if ![ catch { mem2array foo 8 $ADDR 1  } msg ] {
-	return $foo(0)
+    if ![ catch { set foo [read_memory $ADDR 8 1] } msg ] {
+	return $foo
     } else {
 	error "memread8: $msg"
     }
 }
 
 proc memwrite32 {ADDR DATA} {
-    set foo(0) $DATA
-    if ![ catch { array2mem foo 32 $ADDR 1  } msg ] {
-	return $foo(0)
+    if ![ catch { write_memory $ADDR 32 $DATA } msg ] {
+	return $DATA
     } else {
 	error "memwrite32: $msg"
     }
 }
 
 proc memwrite16 {ADDR DATA} {
-    set foo(0) $DATA
-    if ![ catch { array2mem foo 16 $ADDR 1  } msg ] {
-	return $foo(0)
+    if ![ catch { write_memory $ADDR 16 $DATA } msg ] {
+	return $DATA
     } else {
 	error "memwrite16: $msg"
     }
 }
 
 proc memwrite8 {ADDR DATA} {
-    set foo(0) $DATA
-    if ![ catch { array2mem foo 8 $ADDR 1  } msg ] {
-	return $foo(0)
+    if ![ catch { write_memory $ADDR 8 $DATA } msg ] {
+	return $DATA
     } else {
 	error "memwrite8: $msg"
     }
 }
 
 proc memread32_phys {ADDR} {
-    set foo(0) 0
-    if ![ catch { mem2array foo 32 $ADDR 1 phys } msg ] {
-	return $foo(0)
+    if ![ catch { set foo [read_memory $ADDR 32 1 phys] } msg ] {
+	return $foo
     } else {
 	error "memread32: $msg"
     }
 }
 
 proc memread16_phys {ADDR} {
-    set foo(0) 0
-    if ![ catch { mem2array foo 16 $ADDR 1 phys } msg ] {
-	return $foo(0)
+    if ![ catch { set foo [read_memory $ADDR 16 1 phys] } msg ] {
+	return $foo
     } else {
 	error "memread16: $msg"
     }
 }
 
 proc memread8_phys {ADDR} {
-    set foo(0) 0
-    if ![ catch { mem2array foo 8 $ADDR 1 phys } msg ] {
-	return $foo(0)
+    if ![ catch { set foo [read_memory $ADDR 8 1 phys] } msg ] {
+	return $foo
     } else {
 	error "memread8: $msg"
     }
 }
 
 proc memwrite32_phys {ADDR DATA} {
-    set foo(0) $DATA
-    if ![ catch { array2mem foo 32 $ADDR 1 phys } msg ] {
-	return $foo(0)
+    if ![ catch { write_memory $ADDR 32 $DATA phys } msg ] {
+	return $DATA
     } else {
 	error "memwrite32: $msg"
     }
 }
 
 proc memwrite16_phys {ADDR DATA} {
-    set foo(0) $DATA
-    if ![ catch { array2mem foo 16 $ADDR 1 phys } msg ] {
-	return $foo(0)
+    if ![ catch { write_memory $ADDR 16 $DATA phys } msg ] {
+	return $DATA
     } else {
 	error "memwrite16: $msg"
     }
 }
 
 proc memwrite8_phys {ADDR DATA} {
-    set foo(0) $DATA
-    if ![ catch { array2mem foo 8 $ADDR 1 phys } msg ] {
-	return $foo(0)
+    if ![ catch { write_memory $ADDR 8 $DATA phys } msg ] {
+	return $DATA
     } else {
 	error "memwrite8: $msg"
     }
diff --git a/tcl/target/bluefield.cfg b/tcl/target/bluefield.cfg
index 62b1e3165..dcebb2fb1 100644
--- a/tcl/target/bluefield.cfg
+++ b/tcl/target/bluefield.cfg
@@ -72,7 +72,7 @@ proc core_up { args } {
 	global _TARGETNAME
 
 	# Examine remaining cores
-	foreach _core [set args] {
+	foreach _core $args {
 		${_TARGETNAME}$_core arp_examine
 	}
 }
diff --git a/tcl/target/bluenrg-x.cfg b/tcl/target/bluenrg-x.cfg
index ea94be962..1eba37616 100644
--- a/tcl/target/bluenrg-x.cfg
+++ b/tcl/target/bluenrg-x.cfg
@@ -47,11 +47,14 @@ if {![using_hla]} {
    cortex_m reset_config sysresetreq
 }
 
+set JTAG_IDCODE_B2 0x0200A041
+set JTAG_IDCODE_B1 0x0
+
 $_TARGETNAME configure -event halted {
     global WDOG_VALUE
     global WDOG_VALUE_SET
     set _JTAG_IDCODE [mrw 0x40000004]
-    if {$_JTAG_IDCODE != 0x0201E041} {
+    if {$_JTAG_IDCODE == $JTAG_IDCODE_B2 || $_JTAG_IDCODE == $JTAG_IDCODE_B1} {
         # Stop watchdog during halt, if enabled. Only Bluenrg-1/2
         set WDOG_VALUE [mrw 0x40700008]
         if [expr {$WDOG_VALUE & (1 << 1)}] {
@@ -64,7 +67,7 @@ $_TARGETNAME configure -event resumed {
     global WDOG_VALUE
     global WDOG_VALUE_SET
     set _JTAG_IDCODE [mrw 0x40000004]
-    if {$_JTAG_IDCODE != 0x0201E041} {
+    if {$_JTAG_IDCODE == $JTAG_IDCODE_B2 || $_JTAG_IDCODE == $JTAG_IDCODE_B1} {
         if {$WDOG_VALUE_SET} {
             # Restore watchdog enable value after resume. Only Bluenrg-1/2
             mww 0x40700008 $WDOG_VALUE
diff --git a/tcl/target/c100helper.tcl b/tcl/target/c100helper.tcl
index bdcfd8cf5..ecd7edf11 100644
--- a/tcl/target/c100helper.tcl
+++ b/tcl/target/c100helper.tcl
@@ -29,9 +29,7 @@ source [find mem_helper.tcl]
 
 # read a 64-bit register (memory mapped)
 proc mr64bit {reg} {
-    set value ""
-    mem2array value 32 $reg 2
-    return $value
+    return [read_memory $reg 32 2]
 }
 
 
@@ -117,19 +115,19 @@ proc showAmbaClk {} {
     set PLL_CLK_BYPASS	             [regs PLL_CLK_BYPASS]
 
     echo [format "CLKCORE_AHB_CLK_CNTRL       (0x%x): 0x%x" $CLKCORE_AHB_CLK_CNTRL [mrw $CLKCORE_AHB_CLK_CNTRL]]
-    mem2array value 32 $CLKCORE_AHB_CLK_CNTRL 1
+    set value [read_memory $CLKCORE_AHB_CLK_CNTRL 32 1]
     # see if the PLL is in bypass mode
-    set bypass [expr {($value(0) & $PLL_CLK_BYPASS) >> 24}]
+    set bypass [expr {($value & $PLL_CLK_BYPASS) >> 24}]
     echo [format "PLL bypass bit: %d" $bypass]
     if {$bypass == 1} {
 	echo [format "Amba Clk is set to REFCLK: %d (MHz)" [expr {$CFG_REFCLKFREQ/1000000}]]
     } else {
 	# nope, extract x,y,w and compute the PLL output freq.
-	set x [expr {($value(0) & 0x0001F0000) >> 16}]
+	set x [expr {($value & 0x0001F0000) >> 16}]
 	echo [format "x: %d" $x]
-	set y [expr {($value(0) & 0x00000007F)}]
+	set y [expr {($value & 0x00000007F)}]
 	echo [format "y: %d" $y]
-	set w [expr {($value(0) & 0x000000300) >> 8}]
+	set w [expr {($value & 0x000000300) >> 8}]
 	echo [format "w: %d" $w]
 	echo [format "Amba PLL Clk: %d (MHz)" [expr {($CFG_REFCLKFREQ * $y / (($w + 1) * ($x + 1) * 2))/1000000}]]
     }
@@ -192,19 +190,19 @@ proc showArmClk {} {
     set PLL_CLK_BYPASS	        [regs PLL_CLK_BYPASS]
 
     echo [format "CLKCORE_ARM_CLK_CNTRL       (0x%x): 0x%x" $CLKCORE_ARM_CLK_CNTRL [mrw $CLKCORE_ARM_CLK_CNTRL]]
-    mem2array value 32 $CLKCORE_ARM_CLK_CNTRL 1
+    set value [read_memory $CLKCORE_ARM_CLK_CNTRL 32 1]
     # see if the PLL is in bypass mode
-    set bypass [expr {($value(0) & $PLL_CLK_BYPASS) >> 24}]
+    set bypass [expr {($value & $PLL_CLK_BYPASS) >> 24}]
     echo [format "PLL bypass bit: %d" $bypass]
     if {$bypass == 1} {
 	echo [format "Amba Clk is set to REFCLK: %d (MHz)" [expr {$CFG_REFCLKFREQ/1000000}]]
     } else {
 	# nope, extract x,y,w and compute the PLL output freq.
-	set x [expr {($value(0) & 0x0001F0000) >> 16}]
+	set x [expr {($value & 0x0001F0000) >> 16}]
 	echo [format "x: %d" $x]
-	set y [expr {($value(0) & 0x00000007F)}]
+	set y [expr {($value & 0x00000007F)}]
 	echo [format "y: %d" $y]
-	set w [expr {($value(0) & 0x000000300) >> 8}]
+	set w [expr {($value & 0x000000300) >> 8}]
 	echo [format "w: %d" $w]
 	echo [format "Arm PLL Clk: %d (MHz)" [expr {($CFG_REFCLKFREQ * $y / (($w + 1) * ($x + 1) * 2))/1000000}]]
     }
diff --git a/tcl/target/efm32.cfg b/tcl/target/efm32.cfg
index c789efc72..d2e4eb329 100644
--- a/tcl/target/efm32.cfg
+++ b/tcl/target/efm32.cfg
@@ -43,6 +43,8 @@ $_TARGETNAME configure -work-area-phys 0x10000000 -work-area-size $_WORKAREASIZE
 
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME efm32 0 0 0 0 $_TARGETNAME
+flash bank userdata.flash efm32 0x0FE00000 0 0 0 $_TARGETNAME
+flash bank lockbits.flash efm32 0x0FE04000 0 0 0 $_TARGETNAME
 
 if {![using_hla]} {
    # if srst is not fitted use SYSRESETREQ to
diff --git a/tcl/target/gd32vf103.cfg b/tcl/target/gd32vf103.cfg
index 0f4dcf375..cfc64783f 100644
--- a/tcl/target/gd32vf103.cfg
+++ b/tcl/target/gd32vf103.cfg
@@ -4,6 +4,8 @@
 # https://www.gigadevice.com/products/microcontrollers/gd32/risc-v/
 #
 
+source [find mem_helper.tcl]
+
 transport select jtag
 
 if { [info exists CHIPNAME] } {
@@ -12,10 +14,11 @@ if { [info exists CHIPNAME] } {
    set _CHIPNAME gd32vf103
 }
 
+# The smallest RAM size 6kB (GD32VF103C4/T4/R4)
 if { [info exists WORKAREASIZE] } {
    set _WORKAREASIZE $WORKAREASIZE
 } else {
-   set _WORKAREASIZE 0x800
+   set _WORKAREASIZE 0x1800
 }
 
 jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id 0x1000563d
@@ -24,3 +27,14 @@ set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME riscv -chain-position $_TARGETNAME
 
 $_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0
+
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME stm32f1x 0x08000000 0 0 0 $_TARGETNAME
+
+# DBGMCU_CR register cannot be set in examine-end event as the running RISC-V CPU
+# does not allow the debugger to access memory.
+# Stop watchdogs at least before flash programming.
+$_TARGETNAME configure -event reset-init {
+	# DBGMCU_CR |= DBG_WWDG_STOP | DBG_IWDG_STOP
+	mmw 0xE0042004 0x00000300 0
+}
diff --git a/tcl/target/hilscher_netx500.cfg b/tcl/target/hilscher_netx500.cfg
index 6d919f9dd..131bef221 100644
--- a/tcl/target/hilscher_netx500.cfg
+++ b/tcl/target/hilscher_netx500.cfg
@@ -26,9 +26,7 @@ set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME
 
 proc mread32 {addr} {
-  set value(0) 0
-  mem2array value 32 $addr 1
-  return $value(0)
+  return [read_memory $addr 32 1]
 }
 
 # This function must be called on netX100/500 right after halt
diff --git a/tcl/target/ls1046a.cfg b/tcl/target/ls1046a.cfg
new file mode 100644
index 000000000..3d96a994e
--- /dev/null
+++ b/tcl/target/ls1046a.cfg
@@ -0,0 +1,56 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# NXP LS1046A
+
+if { [info exists CHIPNAME] } {
+	set _CHIPNAME $CHIPNAME
+} else {
+	set _CHIPNAME ls1046a
+}
+
+if { [info exists DAP_TAPID] } {
+	set _DAP_TAPID $DAP_TAPID
+} else {
+	set _DAP_TAPID 0x5ba00477
+}
+
+if { [info exists SAP_TAPID] } {
+	set _SAP_TAPID $SAP_TAPID
+} else {
+	set _SAP_TAPID 0x06b3001d
+}
+
+jtag newtap $_CHIPNAME dap -irlen 4 -expected-id $_DAP_TAPID
+dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.dap
+
+target create $_CHIPNAME.axi mem_ap -dap $_CHIPNAME.dap -ap-num 0
+
+set _CPU_BASE 0x80400000
+set _CPU_STRIDE 0x100000
+set _CPU_DBGOFF 0x10000
+set _CPU_CTIOFF 0x20000
+
+set _TARGETS {}
+for {set i 0} {$i < 4} {incr i} {
+	set _BASE [expr {$_CPU_BASE + $_CPU_STRIDE * $i}]
+	cti create $_CHIPNAME.cti$i -dap $_CHIPNAME.dap -ap-num 1 \
+		-baseaddr [expr {$_BASE + $_CPU_CTIOFF}]
+	target create $_CHIPNAME.cpu$i aarch64 -dap $_CHIPNAME.dap \
+		-cti $_CHIPNAME.cti$i -dbgbase [expr {$_BASE + $_CPU_DBGOFF}] \
+		-coreid $i {*}[expr {$i ? {-defer-examine} : {-rtos hwthread} }]
+	lappend _TARGETS $_CHIPNAME.cpu$i
+}
+
+target smp {*}$_TARGETS
+
+jtag newtap $_CHIPNAME sap -irlen 8 -expected-id $_SAP_TAPID
+target create $_CHIPNAME.sap ls1_sap -chain-position $_CHIPNAME.sap -endian big
+
+proc core_up { args } {
+    foreach core $args {
+        $::_CHIPNAME.cpu$core arp_examine
+    }
+}
+
+targets $_CHIPNAME.cpu0
+
+adapter speed 10000
diff --git a/tcl/target/ls1088a.cfg b/tcl/target/ls1088a.cfg
new file mode 100644
index 000000000..f9ae9a134
--- /dev/null
+++ b/tcl/target/ls1088a.cfg
@@ -0,0 +1,74 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# NXP LS1088A
+
+if { [info exists CHIPNAME] } {
+	set _CHIPNAME $CHIPNAME
+} else {
+	set _CHIPNAME ls1088a
+}
+
+if { [info exists DAP_TAPID] } {
+	set _DAP_TAPID $DAP_TAPID
+} else {
+	set _DAP_TAPID 0x5ba00477
+}
+
+jtag newtap $_CHIPNAME dap -irlen 4 -expected-id $_DAP_TAPID
+dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.dap
+
+target create $_CHIPNAME.axi mem_ap -dap $_CHIPNAME.dap -ap-num 1
+
+set _CPU_BASE 0x81000000
+set _CPU_STRIDE 0x100000
+set _CPU_DBGOFF 0x10000
+set _CPU_CTIOFF 0x20000
+
+set _TARGETS {}
+for {set i 0} {$i < 8} {incr i} {
+	set _BASE [expr {$_CPU_BASE + $_CPU_STRIDE * $i}]
+	cti create $_CHIPNAME.cti$i -dap $_CHIPNAME.dap -ap-num 0 \
+		-baseaddr [expr {$_BASE + $_CPU_CTIOFF}]
+	target create $_CHIPNAME.cpu$i aarch64 -dap $_CHIPNAME.dap \
+		-cti $_CHIPNAME.cti$i -dbgbase [expr {$_BASE + $_CPU_DBGOFF}] \
+		{*}[expr {$i ? "-coreid $i" : "-rtos hwthread" }]
+	lappend _TARGETS $_CHIPNAME.cpu$i
+}
+
+target smp {*}$_TARGETS
+
+# Service processor
+target create $_CHIPNAME.sp cortex_a -dap $_CHIPNAME.dap -ap-num 0 -dbgbase 0x80138000
+
+# Normally you will not need to call this, but if you are using the hard-coded
+# Reset Configuration Word (RCW) you will need to call this manually. The CPU's
+# reset vector is 0, and the boot ROM at that location contains ARMv7-A 32-bit
+# instructions. This will cause the CPU to almost immediately execute an
+# illegal instruction.
+#
+# This code is idempotent; releasing a released CPU has no effect, although it
+# will halt/resume the service processor.
+add_help_text release_cpu "Release a cpu which is held off"
+proc release_cpu {cpu} {
+	set RST_BRRL 0x1e60060
+
+	set old [target current]
+	targets $::_CHIPNAME.sp
+	set not_halted [string compare halted [$::_CHIPNAME.sp curstate]]
+	if {$not_halted} {
+		halt
+	}
+
+	# Release the cpu; it will start executing something bogus
+	mem2array regs 32 $RST_BRRL 1
+	mww $RST_BRRL [expr {$regs(0) | 1 << $cpu}]
+
+	if {$not_halted} {
+		resume
+	}
+	targets $old
+}
+
+targets $_CHIPNAME.cpu0
+
+# Seems to work OK in testing
+adapter speed 10000
diff --git a/tcl/target/psoc4.cfg b/tcl/target/psoc4.cfg
index cffcbc753..40f2fcab3 100644
--- a/tcl/target/psoc4.cfg
+++ b/tcl/target/psoc4.cfg
@@ -74,22 +74,22 @@ if {![using_hla]} {
 }
 
 proc psoc4_get_family_id {} {
-	set err [catch "mem2array romtable_pid 32 0xF0000FE0 3"]
+	set err [catch {set romtable_pid [read_memory 0xF0000FE0 32 3]}]
 	if { $err } {
 		return 0
 	}
-	if { [expr {$romtable_pid(0) & 0xffffff00 }]
-	  || [expr {$romtable_pid(1) & 0xffffff00 }]
-	  || [expr {$romtable_pid(2) & 0xffffff00 }] } {
+	if { [expr {[lindex $romtable_pid 0] & 0xffffff00 }]
+	  || [expr {[lindex $romtable_pid 1] & 0xffffff00 }]
+	  || [expr {[lindex $romtable_pid 2] & 0xffffff00 }] } {
 		echo "Unexpected data in ROMTABLE"
 		return 0
 	}
-	set designer_id [expr {(( $romtable_pid(1) & 0xf0 ) >> 4) | (( $romtable_pid(2) & 0xf ) << 4 ) }]
+	set designer_id [expr {(( [lindex $romtable_pid 1] & 0xf0 ) >> 4) | (( [lindex $romtable_pid 2] & 0xf ) << 4 ) }]
 	if { $designer_id != 0xb4 } {
 		echo [format "ROMTABLE Designer ID 0x%02x is not Cypress" $designer_id]
 		return 0
 	}
-	set family_id [expr {( $romtable_pid(0) & 0xff ) | (( $romtable_pid(1) & 0xf ) << 8 ) }]
+	set family_id [expr {( [lindex $romtable_pid 0] & 0xff ) | (( [lindex $romtable_pid 1] & 0xf ) << 8 ) }]
 	return $family_id
 }
 
@@ -193,9 +193,9 @@ proc ocd_process_reset_inner { MODE } {
 		}
 
 		# Set registers to reset vector values
-		mem2array value 32 0 2
-		reg pc [expr {$value(1) & 0xfffffffe} ]
-		reg msp $value(0)
+		set value [read_memory 0x0 32 2]
+		reg pc [expr {[lindex $value 1] & 0xfffffffe}]
+		reg msp [lindex $value 0]
 
 		if { $PSOC4_TEST_MODE_WORKAROUND } {
 			catch { mww $TEST_MODE 0 }
diff --git a/tcl/target/stm32f4x.cfg b/tcl/target/stm32f4x.cfg
index 2228de72f..aa2816e76 100644
--- a/tcl/target/stm32f4x.cfg
+++ b/tcl/target/stm32f4x.cfg
@@ -1,7 +1,7 @@
 # script for stm32f4x family
 
 #
-# stm32 devices support both JTAG and SWD transports.
+# stm32f4 devices support both JTAG and SWD transports.
 #
 source [find target/swj-dp.tcl]
 source [find mem_helper.tcl]
diff --git a/tcl/target/stm32h7x.cfg b/tcl/target/stm32h7x.cfg
index f2a5c42c6..ca685c2f2 100644
--- a/tcl/target/stm32h7x.cfg
+++ b/tcl/target/stm32h7x.cfg
@@ -232,9 +232,7 @@ if {[set $_CHIPNAME.DUAL_CORE]} {
 
 # like mrw, but with target selection
 proc stm32h7x_mrw {used_target reg} {
-	set value ""
-	$used_target mem2array value 32 $reg 1
-	return $value(0)
+	return [$used_target read_memory $reg 32 1]
 }
 
 # like mmw, but with target selection
diff --git a/tcl/target/stm32l4x.cfg b/tcl/target/stm32l4x.cfg
index 589979193..9bd7e37ba 100644
--- a/tcl/target/stm32l4x.cfg
+++ b/tcl/target/stm32l4x.cfg
@@ -15,11 +15,11 @@ if { [info exists CHIPNAME] } {
 set _ENDIAN little
 
 # Work-area is a space in RAM used for flash programming
-# Smallest current target has 64kB ram, use 32kB by default to avoid surprises
+# By default use 40kB (Available RAM in smallest device STM32L412)
 if { [info exists WORKAREASIZE] } {
    set _WORKAREASIZE $WORKAREASIZE
 } else {
-   set _WORKAREASIZE 0x8000
+   set _WORKAREASIZE 0xa000
 }
 
 #jtag scan chain
@@ -38,6 +38,8 @@ if { [info exists CPUTAPID] } {
 swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
 
+tpiu create $_CHIPNAME.tpiu -dap $_CHIPNAME.dap -ap-num 0 -baseaddr 0xE0040000
+
 if {[using_jtag]} {
    jtag newtap $_CHIPNAME bs -irlen 5
 }
@@ -47,8 +49,9 @@ target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap
 
 $_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0
 
-flash bank $_CHIPNAME.flash stm32l4x 0x08000000 0 0 0 $_TARGETNAME
-flash bank $_CHIPNAME.otp   stm32l4x 0x1fff7000 0 0 0 $_TARGETNAME
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME stm32l4x 0x08000000 0 0 0 $_TARGETNAME
+flash bank $_CHIPNAME.otp stm32l4x 0x1fff7000 0 0 0 $_TARGETNAME
 
 if { [info exists QUADSPI] && $QUADSPI } {
    set a [llength [flash list]]
@@ -88,12 +91,54 @@ if {![using_hla]} {
    cortex_m reset_config sysresetreq
 }
 
+$_TARGETNAME configure -event examine-end {
+	# Enable debug during low power modes (uses more power)
+	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP
+	mmw 0xE0042004 0x00000007 0
+
+	# Stop watchdog counters during halt
+	# DBGMCU_APB1_FZ |= DBG_IWDG_STOP | DBG_WWDG_STOP
+	mmw 0xE0042008 0x00001800 0
+}
+
+proc proc_post_enable {_chipname} {
+	targets $_chipname.cpu
+
+	if { [$_chipname.tpiu cget -protocol] eq "sync" } {
+		switch [$_chipname.tpiu cget -port-width] {
+			1 {
+				mmw 0xE0042004 0x00000060 0x000000c0
+				mmw 0x48001020 0x00000000 0x0000ff00
+				mmw 0x48001000 0x000000a0 0x000000f0
+				mmw 0x48001008 0x000000f0 0x00000000
+			  }
+			2 {
+				mmw 0xE0042004 0x000000a0 0x000000c0
+				mmw 0x48001020 0x00000000 0x000fff00
+				mmw 0x48001000 0x000002a0 0x000003f0
+				mmw 0x48001008 0x000003f0 0x00000000
+			  }
+			4 {
+				mmw 0xE0042004 0x000000e0 0x000000c0
+				mmw 0x48001020 0x00000000 0x0fffff00
+				mmw 0x48001000 0x00002aa0 0x00003ff0
+				mmw 0x48001008 0x00003ff0 0x00000000
+			  }
+		}
+	} else {
+		mmw 0xE0042004 0x00000020 0x000000c0
+	}
+}
+
+$_CHIPNAME.tpiu configure -event post-enable "proc_post_enable $_CHIPNAME"
+
 $_TARGETNAME configure -event reset-init {
 	# CPU comes out of reset with MSI_ON | MSI_RDY | MSI Range 6 (4 MHz).
 	# Use MSI 24 MHz clock, compliant even with VOS == 2.
 	# 3 WS compliant with VOS == 2 and 24 MHz.
 	mww 0x40022000 0x00000103   ;# FLASH_ACR = PRFTBE | 3(Latency)
 	mww 0x40021000 0x00000099   ;# RCC_CR = MSI_ON | MSIRGSEL | MSI Range 9
+
 	# Boost JTAG frequency
 	adapter speed 4000
 }
@@ -102,19 +147,3 @@ $_TARGETNAME configure -event reset-start {
 	# Reset clock is MSI (4 MHz)
 	adapter speed 500
 }
-
-$_TARGETNAME configure -event examine-end {
-	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP
-	mmw 0xE0042004 0x00000007 0
-
-	# Stop watchdog counters during halt
-	# DBGMCU_APB1_FZ |= DBG_IWDG_STOP | DBG_WWDG_STOP
-	mmw 0xE0042008 0x00001800 0
-}
-
-$_TARGETNAME configure -event trace-config {
-	# Set TRACE_IOEN; TRACE_MODE is set to async; when using sync
-	# change this value accordingly to configure trace pins
-	# assignment
-	mmw 0xE0042004 0x00000020 0
-}
diff --git a/tcl/target/stm32l5x.cfg b/tcl/target/stm32l5x.cfg
index 0616df1cb..c43b699d2 100644
--- a/tcl/target/stm32l5x.cfg
+++ b/tcl/target/stm32l5x.cfg
@@ -1,10 +1,8 @@
 # SPDX-License-Identifier: GPL-2.0-or-later
 
 # script for stm32l5x family
+# stm32l5x devices support both JTAG and SWD transports.
 
-#
-# stm32l5 devices support both JTAG and SWD transports.
-#
 source [find target/swj-dp.tcl]
 source [find mem_helper.tcl]
 
@@ -14,78 +12,10 @@ if { [info exists CHIPNAME] } {
 	set _CHIPNAME stm32l5x
 }
 
-set _ENDIAN little
+source [find target/stm32x5x_common.cfg]
 
-# Work-area is a space in RAM used for flash programming
-# By default use 64kB
-if { [info exists WORKAREASIZE] } {
-	set _WORKAREASIZE $WORKAREASIZE
-} else {
-	set _WORKAREASIZE 0x10000
-}
-
-#jtag scan chain
-if { [info exists CPUTAPID] } {
-	set _CPUTAPID $CPUTAPID
-} else {
-	if { [using_jtag] } {
-		# See STM Document RM0438
-		# RM0438 Rev5, Section 52.2.8 JTAG debug port - Table 425. JTAG-DP data registers
-		# Corresponds to Cortex®-M33 JTAG debug port ID code
-		set _CPUTAPID 0x0ba04477
-	} {
-		# SWD IDCODE (single drop, arm)
-		set _CPUTAPID 0x0be12477
-	}
-}
-
-swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
-
-if {[using_jtag]} {
-	jtag newtap $_CHIPNAME bs -irlen 5
-}
-
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap
-
-# use non-secure RAM by default
-$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0
-
-# create sec/ns flash and otp memories (sizes will be probed)
-flash bank $_CHIPNAME.flash_ns      stm32l4x 0x08000000 0 0 0 $_TARGETNAME
-flash bank $_CHIPNAME.flash_alias_s stm32l4x 0x0C000000 0 0 0 $_TARGETNAME
-flash bank $_CHIPNAME.otp           stm32l4x 0x0BFA0000 0 0 0 $_TARGETNAME
-
-# Common knowledges tells JTAG speed should be <= F_CPU/6.
-# F_CPU after reset is MSI 4MHz, so use F_JTAG = 500 kHz to stay on
-# the safe side.
-#
-# Note that there is a pretty wide band where things are
-# more or less stable, see http://openocd.zylin.com/#/c/3366/
-adapter speed 500
-
-adapter srst delay 100
-if {[using_jtag]} {
-	jtag_ntrst_delay 100
-}
-
-reset_config srst_nogate
-
-if {![using_hla]} {
-	# if srst is not fitted use SYSRESETREQ to
-	# perform a soft reset
-	cortex_m reset_config sysresetreq
-}
-
-proc is_secure {} {
-	# read Debug Security Control and Status Regsiter (DSCSR) and check CDS (bit 16)
-	set DSCSR [mrw 0xE000EE08]
-	return [expr {($DSCSR & (1 << 16)) != 0}]
-}
-
-proc clock_config_110_mhz {} {
-	set offset [expr {[is_secure] ? 0x10000000 : 0}]
+proc stm32l5x_clock_config {} {
+	set offset [expr {[stm32x5x_is_secure] ? 0x10000000 : 0}]
 	# MCU clock is MSI (4MHz) after reset, set MCU freq at 110 MHz with PLL
 	# RCC_APB1ENR1 = PWREN
 	mww [expr {0x40021058 + $offset}] 0x10000000
@@ -111,90 +41,8 @@ proc clock_config_110_mhz {} {
 	while {([mrw [expr {0x40021008 + $offset}]] & 0x0C) != 0x0C} {}
 }
 
-proc ahb_ap_non_secure_access {} {
-	# SPROT=1=Non Secure access, Priv=1
-	[[target current] cget -dap] apcsw 0x4B000000 0x4F000000
-}
-
-proc ahb_ap_secure_access {} {
-	# SPROT=0=Secure access, Priv=1
-	[[target current] cget -dap] apcsw 0x0B000000 0x4F000000
-}
-
 $_TARGETNAME configure -event reset-init {
-	clock_config_110_mhz
+	stm32l5x_clock_config
 	# Boost JTAG frequency
 	adapter speed 4000
 }
-
-$_TARGETNAME configure -event reset-start {
-	# Reset clock is MSI (4 MHz)
-	adapter speed 480
-}
-
-$_TARGETNAME configure -event examine-end {
-	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP
-	mmw 0xE0044004 0x00000006 0
-
-	# Stop watchdog counters during halt
-	# DBGMCU_APB1_FZ |= DBG_IWDG_STOP | DBG_WWDG_STOP
-	mmw 0xE0044008 0x00001800 0
-}
-
-$_TARGETNAME configure -event halted {
-	set secure [is_secure]
-
-	if {$secure} {
-		set secure_str "Secure"
-		ahb_ap_secure_access
-	} else {
-		set secure_str "Non-Secure"
-		ahb_ap_non_secure_access
-	}
-
-	# print the secure state only when it changes
-	set _TARGETNAME [target current]
-	global $_TARGETNAME.secure
-
-	if {![info exists $_TARGETNAME.secure] || $secure != [set $_TARGETNAME.secure]} {
-		echo "CPU in $secure_str state"
-		# update saved security state
-		set $_TARGETNAME.secure $secure
-	}
-}
-
-$_TARGETNAME configure -event gdb-flash-erase-start {
-	set use_secure_workarea 0
-	# check if FLASH_OPTR.TZEN is enabled
-	set FLASH_OPTR [mrw 0x40022040]
-	if {[expr {$FLASH_OPTR & 0x80000000}] == 0} {
-		echo "TZEN option bit disabled"
-		ahb_ap_non_secure_access
-	} {
-		ahb_ap_secure_access
-		echo "TZEN option bit enabled"
-
-		# check if FLASH_OPTR.RDP is not Level 0.5
-		if {[expr {$FLASH_OPTR & 0xFF}] != 0x55} {
-			set use_secure_workarea 1
-		}
-	}
-
-	set workarea_addr [$_TARGETNAME cget -work-area-phys]
-	echo "workarea_addr $workarea_addr"
-
-	if {$use_secure_workarea} {
-		set workarea_addr [expr {$workarea_addr | 0x10000000}]
-	} {
-		set workarea_addr [expr {$workarea_addr & ~0x10000000}]
-	}
-
-	$_TARGETNAME configure -work-area-phys $workarea_addr
-}
-
-$_TARGETNAME configure -event trace-config {
-	# Set TRACE_IOEN; TRACE_MODE is set to async; when using sync
-	# change this value accordingly to configure trace pins
-	# assignment
-	mmw 0xE0044004 0x00000020 0
-}
diff --git a/tcl/target/stm32mp13x.cfg b/tcl/target/stm32mp13x.cfg
index 0c464b411..d57116c37 100644
--- a/tcl/target/stm32mp13x.cfg
+++ b/tcl/target/stm32mp13x.cfg
@@ -83,9 +83,18 @@ proc dbgmcu_enable_debug {} {
 }
 
 proc toggle_cpu_dbg_claim0 {} {
+	# set few bits in CPU0 DBG_CLAIM to verify write permission
+	# FSBL wrapper will clear CPU0 DBG_CLAIM[0]
 	# toggle CPU0 DBG_CLAIM[0]
-	$::_CHIPNAME.ap1 mww 0xe00d0fa0 1
-	$::_CHIPNAME.ap1 mww 0xe00d0fa4 1
+	$::_CHIPNAME.ap1 mww 0xe00d0fa0 0x0b
+	set claim [$::_CHIPNAME.ap1 read_memory 0xe00d0fa4 32 1]
+	if {[expr {$claim & 0xfe}] != 0x0a} {
+		error "ERROR: cannot write in DBG_CLAIM. Missing FSBL wrapper?"
+	}
+	if {[expr {$claim & 1}]} {
+		echo "WARNING: FSBL wrapper not detected. Board in dev boot mode?"
+	}
+	$::_CHIPNAME.ap1 mww 0xe00d0fa4 0x0b
 }
 
 # FIXME: most of handlers below will be removed once reset framework get merged
diff --git a/tcl/target/stm32mp15x.cfg b/tcl/target/stm32mp15x.cfg
index 639fbabe0..40abed963 100644
--- a/tcl/target/stm32mp15x.cfg
+++ b/tcl/target/stm32mp15x.cfg
@@ -103,14 +103,23 @@ proc dbgmcu_enable_debug {} {
 }
 
 proc toggle_cpu0_dbg_claim0 {} {
+	# set few bits in CPU0 DBG_CLAIM to verify write permission
+	# FSBL wrapper will clear CPU0 DBG_CLAIM[0]
 	# toggle CPU0 DBG_CLAIM[0]
-	$::_CHIPNAME.ap1 mww 0xe00d0fa0 1
-	$::_CHIPNAME.ap1 mww 0xe00d0fa4 1
+	$::_CHIPNAME.ap1 mww 0xe00d0fa0 0x0b
+	set claim [$::_CHIPNAME.ap1 read_memory 0xe00d0fa4 32 1]
+	if {[expr {$claim & 0xfe}] != 0x0a} {
+		error "ERROR: cannot write in DBG_CLAIM. Missing FSBL wrapper?"
+	}
+	if {[expr {$claim & 1}]} {
+		echo "WARNING: FSBL wrapper not detected. Board in dev boot mode?"
+	}
+	$::_CHIPNAME.ap1 mww 0xe00d0fa4 0x0b
 }
 
 proc detect_cpu1 {} {
-	$::_CHIPNAME.ap1 mem2array cpu1_prsr 32 0xE00D2314 1
-	set dual_core [expr {$cpu1_prsr(0) & 1}]
+	set cpu1_prsr [$::_CHIPNAME.ap1 read_memory 0xE00D2314 32 1]
+	set dual_core [expr {$cpu1_prsr & 1}]
 	if {! $dual_core} {$::_CHIPNAME.cpu1 configure -defer-examine}
 }
 
diff --git a/tcl/target/stm32mp25x_cubeide.cfg b/tcl/target/stm32mp25x_cubeide.cfg
new file mode 100644
index 000000000..46e017871
--- /dev/null
+++ b/tcl/target/stm32mp25x_cubeide.cfg
@@ -0,0 +1,283 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+# STMicroelectronics STM32MP25x
+# STM32MP25x devices support both JTAG and SWD transports.
+
+# HLA does not support multi-cores nor custom CSW nor AP other than 0
+if { [using_hla] } {
+	echo "ERROR: HLA transport cannot work with this target."
+	shutdown
+}
+
+source [find target/swj-dp.tcl]
+source [find mem_helper.tcl]
+
+if { [info exists CHIPNAME] } {
+	set _CHIPNAME $CHIPNAME
+} else {
+	set _CHIPNAME stm32mp25x
+}
+
+set _ENDIAN little
+
+# jtag scan chain
+if { [info exists CPUTAPID] } {
+	set _CPUTAPID $CPUTAPID
+} else {
+	if { [using_jtag] } {
+		set _CPUTAPID 0x6ba00477
+	} {
+		set _CPUTAPID 0x6ba02477
+	}
+}
+
+# Chip Level TAP Controller, only in jtag mode
+if { [info exists CLCTAPID] } {
+	set _CLCTAPID $CLCTAPID
+} else {
+	set _CLCTAPID 0x16505041
+}
+
+# For CubeIDE, in one debug sessio only one core is debugged
+set _AP_NUM_A35 0
+set _AP_NUM_M33 8
+set _AP_NUM_M0P 2
+if { [info exists AP_NUM] } {
+    set _AP_NUM $AP_NUM
+} else {
+    set _AP_NUM $_AP_NUM_A35
+}
+
+# set GDB_PORT
+if { [info exists GDB_PORT] } {
+    set _GDB_PORT $GDB_PORT
+} else {
+    set _GDB_PORT 3333
+}
+
+# MP2 device have 2 Cortex-A35 on AP 0, by default debug the A35_0
+# TODO validate _CORE_ID
+if { [info exists CORE_ID] } {
+    set _CORE_ID $CORE_ID
+} else {
+    set _CORE_ID 0
+}
+
+# Swicth mode from Aarch64/ARM64, Aarch32/ARM32 to Aarch64/Thumb
+if { [info exists A35_MODE_SWITCH ] } {
+    set _A35_MODE_SWITCH $A35_MODE_SWITCH
+} else {
+    set _A35_MODE_SWITCH yes
+}
+
+# A35 Secure mode
+if { [info exists A35_SECURE] } {
+    set _A35_SECURE $A35_SECURE
+} else {
+    set _A35_SECURE yes
+}
+
+# Manage RIF Memory Configuration
+if { [info exists INIT_MEMCONFIG_OPENOCD] } {
+    set _INIT_MEMCONFIG_OPENOCD $INIT_MEMCONFIG_OPENOCD
+} else {
+    set _INIT_MEMCONFIG_OPENOCD yes
+}
+
+# M33 TD-CID flag
+if { [info exists M33_TDCID_FLAG] } {
+    set _M33_TDCID_FLAG $M33_TDCID_FLAG
+} else {
+    set _M33_TDCID_FLAG [expr { $_AP_NUM == $_AP_NUM_M33 }]
+}
+
+# M33 secure
+if { [info exists M33_SECURE] } {
+    set _M33_SECURE $M33_SECURE
+} else {
+    set _M33_SECURE no
+}
+
+# HSI Frequency (used to patch EL3_Launcher to allow it to set STGEN to correct frequency)
+if { [info exists HSI_FREQ] } {
+    set _HSI_FREQ $HSI_FREQ
+} else {
+    # Default is 32MHz (for FPGA) # FIXME
+    set _HSI_FREQ 32000000
+}
+
+# A35_0 secure
+if { [info exists A35_0_SECURE] } {
+    set _A35_0_SECURE $A35_0_SECURE
+} else {
+    set _A35_0_SECURE yes
+}
+
+# A35_1 secure
+if { [info exists A35_1_SECURE] } {
+    set _A35_1_SECURE $A35_1_SECURE
+} else {
+    set _A35_1_SECURE yes
+}
+
+# TODO manage these flags
+# set _M33_SECURE yes/no/na
+# _A35_0_SECURE yes/no
+# Needed for EL3 Launcher {start/end addresses of memory for A35 0 code}
+#    single A35: [0x20006000:0x2003FFFF]
+#    dual A35 : A35_0 [0x20006000:0x20025FFF] , A35_1 [0x20026000:0x2003FFFF]
+# _HSI_FREQ [32000000] (used to patch EL3_Launcher to allow it to set STGEN to correct frequency)
+
+source [find target/stm32mp25x_misc.cfg]
+
+swj_newdap $_CHIPNAME tap -expected-id $_CPUTAPID -irlen 4 -ircapture 0x01 -irmask 0x0f
+if { [using_jtag] } {
+    jtag newtap $_CHIPNAME.clc tap -expected-id $_CLCTAPID -irlen 5
+}
+
+dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.tap
+
+# define AXI & APB Memory Access Ports
+target create $_CHIPNAME.apb mem_ap -dap $_CHIPNAME.dap -ap-num 0
+target create $_CHIPNAME.axi mem_ap -dap $_CHIPNAME.dap -ap-num 4
+
+# I prefer to have this removed
+set _REG_ACCESS_TARGET $_CHIPNAME.axi
+
+# FIXME
+# P.Chelius: I don't know why ...
+#   First target to be created is the one with which the reset is done
+#   Then M0+ and M33 must not be the last ones if A35 is to be debugged
+#   Otherwise M33 or M0PLUS may fail
+# => for CubeIDE, we are currently creating only the debugged core, so maybe we don't care
+# => @Antonio ?
+
+# define the first Cortex-A35 #####################################################################
+# TODO these 2 flags could be merged (for CubeIDE context)
+set _A35_0_CORE_USED no
+set _A35_0_CORE_START no
+set _A35_0_MEM_START 0x20006000
+set _A35_0_MEM_END 0x20025FFF
+if { ($_AP_NUM == $_AP_NUM_A35) && ($_CORE_ID == 0) } {
+    set _A35_0_CORE_USED yes
+    set _A35_0_CORE_START yes
+    cti create $_CHIPNAME.cti0 -dap $_CHIPNAME.dap -ap-num 0 -baseaddr 0x80220000
+    target create $_CHIPNAME.a35_0 aarch64 -dap $_CHIPNAME.dap -ap-num $_AP_NUM_A35 \
+        -dbgbase 0x80210000 -cti $_CHIPNAME.cti0 \
+        -gdb-port $_GDB_PORT
+    $_CHIPNAME.a35_0 configure -event examine-end { $::_CHIPNAME.a35_0 arp_poll     }
+    $_CHIPNAME.a35_0 configure -event halted      { ca35_halted_handler       A35_0 }
+    $_CHIPNAME.a35_0 configure -event reset-start { reset_start_handler       A35_0 }
+    $_CHIPNAME.a35_0 configure -event reset-end   { reset_end_handler         A35_0 }
+    $_CHIPNAME.a35_0 configure -event gdb-attach  { $::_CHIPNAME.a35_0 arp_examine; halt 1000 }
+}
+
+# define the second Cortex-A35 ####################################################################
+# TODO these 2 flags could be merged (for CubeIDE context)
+set _A35_1_CORE_USED no
+set _A35_1_CORE_START no
+set _A35_1_MEM_START 0x20026000
+set _A35_1_MEM_END 0x2003FFFF
+if { ($_AP_NUM == $_AP_NUM_A35) && ($_CORE_ID == 1) } {
+    set _A35_1_CORE_USED yes
+    set _A35_1_CORE_START yes
+    cti create $_CHIPNAME.cti1 -dap $_CHIPNAME.dap -ap-num 0 -baseaddr 0x80320000
+    target create $_CHIPNAME.a35_1 aarch64 -dap $_CHIPNAME.dap -ap-num  $_AP_NUM_A35 \
+        -dbgbase 0x80310000 -cti $_CHIPNAME.cti1 \
+        -gdb-port $_GDB_PORT
+    $_CHIPNAME.a35_1 configure -event examine-end { $::_CHIPNAME.a35_1 arp_poll     }
+    $_CHIPNAME.a35_1 configure -event halted      { ca35_halted_handler       A35_1 }
+    $_CHIPNAME.a35_1 configure -event reset-start { reset_start_handler       A35_1 }
+    $_CHIPNAME.a35_1 configure -event reset-end   { reset_end_handler         A35_1 }
+    $_CHIPNAME.a35_1 configure -event gdb-attach  { $::_CHIPNAME.a35_1 arp_examine; halt 1000 }
+}
+
+# define the Cortex-M33 ###########################################################################
+# TODO these 2 flags could be merged (for CubeIDE context)
+set _M33_CORE_USED no
+set _M33_CORE_START no
+if { $_AP_NUM == $_AP_NUM_M33 } {
+    set _M33_CORE_USED yes
+    set _M33_CORE_START yes
+    target create $_CHIPNAME.m33 cortex_m -dap $_CHIPNAME.dap -ap-num $_AP_NUM_M33 \
+        -gdb-port $_GDB_PORT -gdb-max-connections 2
+    $_CHIPNAME.m33 configure -event reset-start   { reset_start_handler       M33 }
+    $_CHIPNAME.m33 configure -event reset-end     { reset_end_handler         M33 }
+    $_CHIPNAME.m33 configure -event examine-end   { clear_icsr_m33                }
+}
+
+# define the Cortex-M0+ ###########################################################################
+# TODO these 2 flags could be merged (for CubeIDE context)
+set _M0PLUS_CORE_USED no
+set _M0PLUS_CORE_START no
+if { $_AP_NUM == $_AP_NUM_M0P } {
+    set _M0PLUS_CORE_USED yes
+    set _M0PLUS_CORE_START yes
+    target create $_CHIPNAME.m0p cortex_m -dap $_CHIPNAME.dap -ap-num $_AP_NUM_M0P \
+        -gdb-port $_GDB_PORT -gdb-max-connections 2
+    $_CHIPNAME.m0p configure -event reset-start   { reset_start_handler       M0PLUS }
+    $_CHIPNAME.m0p configure -event reset-end     { reset_end_handler         M0PLUS }
+    $_CHIPNAME.m0p configure -event examine-start { start_m0plus                     }
+    $_CHIPNAME.m0p configure -event examine-end   { clear_icsr_m0plus                }
+}
+
+# define event handlers ###########################################################################
+proc ca35_halted_handler {core_name} {
+   global _A35_MODE_SWITCH
+   if { $_A35_MODE_SWITCH } { switch_ca35_to_aarch32_thumb $core_name }
+}
+
+set _EL3_LAUNCHER_LOADED no
+proc reset_start_handler {core_name} {
+   global _EL3_LAUNCHER_LOADED
+   set _EL3_LAUNCHER_LOADED no
+}
+
+proc reset_end_handler {core_name} {
+   global _CHIPNAME
+   global _M33_TDCID_FLAG
+
+   if { $_M33_TDCID_FLAG } {
+      echo "....................................................................."
+      echo "...        M33 TDCID DEV BOOT SoC minimal configuration          ...."
+      echo "... Load Secure FW in RETRAM and nonsecure FW in SRAM and LPSRAM ...."
+      echo "......................................................................"
+
+      echo "... Configuring DAP in TZ mode (secure access with \"NS\"=0) ..."
+      $_CHIPNAME.dap apsel 4
+      $_CHIPNAME.dap apcsw 0x10006000
+
+      echo "... Setting TD-CID to M33-CID ..."
+      WriteReg 0x42080c00 0x00008720
+
+      echo "!!! TMP PATCH BOOTROM ISSUE in DEV BOOT (120635) -  RISAB5(RETRAM) set all 8 blocks of Page 1 to Secure access instead 3 blocks only !!!"
+      WriteReg 0x42130100  0xFF
+
+      echo "!!! RISAB4/5(SRAM1/2) in secure access to allow GDB (via M33 in secure state) to write FW in SYSRAM !!!"
+      # NOTE ! This is needed for Examples which runs on M33 SE Non-Secure in MCUSRAM which M33 SE Secure code runs from RETRAM
+      #   M33 SE Secure code for Examples is in Projects/STM32MP257F-VALID3/Applications/SPE_NSCubeProjects/STM32CubeIDE/CM33/Secure project
+      #   M33 SE Non-Secure applications and examples are in various projects in Projects/STM32MP257F-VALID3
+      #echo "... Switching ON MCUSRAM1 ..."
+      WriteReg 0x442004F8 0x6
+      #echo "... Switching ON MCUSRAM2 ..."
+      WriteReg 0x442004FC 0x6
+      set_access_to_memory SRAM1 secure_access none none
+      set_access_to_memory SRAM2 secure_access none none
+   }
+}
+
+# end of event handlers ###########################################################################
+
+
+# TODO verify what's best
+# reset_config srst_only connect_assert_srst (reduced scripts)
+reset_config srst_gates_jtag srst_pulls_trst
+
+adapter speed 20000
+adapter srst pulse_width 200
+# wait 2 seconds for bootrom
+adapter srst delay 1000
+
+# set CSW for AXI
+$_CHIPNAME.dap apsel 4
+$_CHIPNAME.dap apcsw 0x12800000
diff --git a/tcl/target/stm32mp25x_misc.cfg b/tcl/target/stm32mp25x_misc.cfg
new file mode 100644
index 000000000..abce36225
--- /dev/null
+++ b/tcl/target/stm32mp25x_misc.cfg
@@ -0,0 +1,3431 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+# STMicroelectronics STM32MP25x
+# STM32MP25x devices support both JTAG and SWD transports.
+
+# TODO review SetBit, ClearBit, WriteReg, ModifyReg, ReadBit, ReadReg
+## CMSIS Macro
+# #define SET_BIT(REG, BIT)     ((REG) |= (BIT))
+##
+proc SetBit {address bitmask} {
+   global _REG_ACCESS_TARGET
+
+   set data [$_REG_ACCESS_TARGET read_memory $address 32 1]
+   set data [expr {$data | $bitmask}]
+   $_REG_ACCESS_TARGET mww $address $data
+}
+
+## CMSIS Macro
+# #define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
+##
+proc ClearBit {address bitmask} {
+   global _REG_ACCESS_TARGET
+
+   set data [$_REG_ACCESS_TARGET read_memory $address 32 1]
+   set data [expr {$data & ~($bitmask)}]
+   $_REG_ACCESS_TARGET mww $address $data
+}
+
+## CMSIS Macro
+# #define CLEAR_REG(REG)        ((REG) = (0x0))
+##
+proc ClearReg {address} {
+   global _REG_ACCESS_TARGET
+
+   $_REG_ACCESS_TARGET mww $address 0x00
+}
+
+## CMSIS Macro
+# #define WRITE_REG(REG, VAL)   ((REG) = (VAL))
+##
+proc WriteReg {address value} {
+   global _REG_ACCESS_TARGET
+
+   $_REG_ACCESS_TARGET mww $address $value
+}
+
+## CMSIS Macro
+# #define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
+##
+proc ModifyReg {address clearmask setmask} {
+   global _REG_ACCESS_TARGET
+
+   set data [$_REG_ACCESS_TARGET read_memory $address 32 1]
+   set data [expr {(($data & ~$clearmask) | $setmask)}]
+   $_REG_ACCESS_TARGET mww $address $data
+}
+
+## CMSIS Macro
+# #define READ_BIT(REG, BIT)    ((REG) & (BIT))
+##
+proc ReadBit {address bitmask} {
+   global _REG_ACCESS_TARGET
+
+   set data [$_REG_ACCESS_TARGET read_memory $address 32 1]
+
+   return [expr {$data & $bitmask}]
+}
+
+## CMSIS Macro
+# #define READ_REG(REG)         ((REG))
+##
+proc ReadReg {address} {
+   global _REG_ACCESS_TARGET
+
+   set data [$_REG_ACCESS_TARGET read_memory $address 32 1]
+
+   return $data
+}
+
+# TODO review this, write_no_incr ?
+proc set_successive_registers {reg_base_addr number_of_reg reg_value} {
+   global _REG_ACCESS_TARGET
+
+   set reg_addr $reg_base_addr
+
+   for {set i 0} {$i < $number_of_reg} {incr i 1} {
+      WriteReg $reg_addr $reg_value
+      incr reg_addr 0x4
+   }
+}
+
+proc switch_ca35_to_aarch32_thumb {core_name} {
+   # get PC register value to check if core is currently in bootrom or not
+   # If it is not halted in bootrom then it's likely beeing executing some user code
+   # And we may be connecting to a running application
+   # So don't change processor state
+
+   # "reg 92"  (32 bits PC) command output is in the form "pc (/32): 0x00004fc4\n"
+   # So extract hex value before testing for STATE bit
+   set pc_value [string range [reg 92] 10 end-1]
+#   echo [format "<D> switch_ca35_to_aarch32_thumb : pc_value   = 0x%08x" $pc_value]
+   if { ($pc_value >= 0x00000000) &&
+        ($pc_value <  0x00020000) } {
+      # get CPSR register value to check for Aarch64/Aarch32-ARM/Aarch32-Thumb state of Core
+      # "reg cpsr" command output is in the form "cpsr (/32): 0x60000133\n"
+      # So extract hex value before testing for STATE bit
+      set cpsr_value [string range [reg cpsr] 12 end-1]
+#      echo [format "<D> switch_ca35_to_aarch32_thumb : cpsr_value = 0x%08x" $cpsr_value]
+#      echo [format "<D> switch_ca35_to_aarch32_thumb : Aarch32    = 0x%08x" [expr {$cpsr_value & (0x1 << 4)}]]
+#      echo [format "<D> switch_ca35_to_aarch32_thumb : Thumb      = 0x%08x" [expr {$cpsr_value & (0x1 << 5)}]]
+
+      # If bit 4 (M[4]) = 0 then A35 is in Aarch64 state. Run EL3_Launcher to switch to Aarch32/Thunb
+      # If bit 5 (T) = 1 then A35 is in Aarch32, Thumb state. So do nothing
+      # Else (bit 4 is 1 and bit 5 is 0) then CA35 is in Aarch32/ARM state. So switch to Aarch32/Thumb
+      if { [expr {$cpsr_value & (0x1 << 4)}] == 0 } {
+         echo "... $core_name is in Aarch64 state. Running EL3_Launcher to switch to Aarch32 EL1 Thumb mode ..."
+         Run_EL3_Launcher $core_name
+      } elseif { [expr {$cpsr_value & (0x1 << 5)}] == 0 } {
+         set cpsr_value [expr {$cpsr_value | (0x1 << 5)}]
+         echo "... $core_name is in ARM state. Writing [format "0x%08x" $cpsr_value] to CPSR to switch in Thumb state ..."
+         reg cpsr $cpsr_value
+      }
+   }
+}
+
+proc clear_icsr_m33 {} {
+   global _CHIPNAME
+
+   # Trace and clear SCB_ICSR if different from 0x0 [ROOT CAUSE TO BE CLARIFIED]
+   #
+   set SCB_ICSR_addr  0xE000ED04
+   set SCB_AIRCR_addr 0xE000ED0C
+   #
+   set data [$_CHIPNAME.m33 read_memory $SCB_ICSR_addr 32 1]
+   if {$data != 0} {
+      set scb_icsr_val [format %08X $data]
+      echo "WARNING ! m33 SCB_ICSR IS DIFFERENT FROM 0x0 (Root cause to be clarified)"
+      $_CHIPNAME.m33 mdw $SCB_ICSR_addr
+      echo "... Clearing it by setting m33 SCB_AIRCR bit 1 \"VECTCLRACTIVE\" ..."
+      $_CHIPNAME.m33 mww $SCB_AIRCR_addr 0x05FA0002
+      $_CHIPNAME.m33 mdw $SCB_ICSR_addr
+   }
+}
+
+proc start_m0plus {} {
+   global _CHIPNAME
+
+   echo "*** Starting M0PLUS ***"
+
+   echo "... Configuring DAP in TZ mode (secure access with \"NS\"=0) ..."
+   $_CHIPNAME.dap apsel 4
+   $_CHIPNAME.dap apcsw 0x10006000
+
+   echo "... Enabling DAP-AHB access to M0+ (access port #2) by configuring DBGMCU through DAP APB-AP ..."
+   $_CHIPNAME.apb mww 0x80010004 0x10
+
+   set RCC_C3CFGR_addr 0x44200490
+
+   if { [ReadBit $RCC_C3CFGR_addr 0x02] != 0x02 } {
+      # Authorize access to D3 domain for using LPSRAMx
+      echo "... Authorizing access to D3 domain ..."
+      WriteReg 0x44210038 0x1
+
+      echo "... Switching ON LPSRAM1 ..."
+      WriteReg 0x44200508 0x6
+      echo "... Switching ON LPSRAM2 ..."
+      WriteReg 0x4420050C 0x6
+      echo "... Switching ON LPSRAM3 ..."
+      WriteReg 0x44200510 0x6
+
+      # ALLOW NON-SECURE M0+ & M33 TO ACCESS APPLICATION CODE/DATA IN NON-SECURE LPSRAM1/LPSRAM2/LPSRAM3
+      set_access_to_memory LPSRAM1 non_secure_access M0PLUS M33
+      set_access_to_memory LPSRAM2 non_secure_access M0PLUS M33
+      set_access_to_memory LPSRAM3 non_secure_access M0PLUS M33
+
+      # NEED to define a default ("while(1)") application to be run
+      # between release of M0+ reset and M0+ transition in debug mode
+      echo "... Patching data (fake application for M0+) at beginning of LPSRAM1 ..."
+      $_CHIPNAME.dap apcsw 0x30006000
+      WriteReg 0x200C0000 0x200C2000
+      WriteReg 0x200C0004 0x200C0465
+      WriteReg 0x200C0464 0xBF00E7FE
+      $_CHIPNAME.dap apcsw 0x10006000
+
+      echo "... Resetting M0+ (aka \"CPU3\") via DAP-AXI ..."
+      # Release M0+ core from reset by enable its peripheral clock (RCC_C3CFGR bit 1 "C3EN")
+      WriteReg $RCC_C3CFGR_addr 0x6
+
+      echo "*** Started M0PLUS ***"
+   } else {
+      echo "*** M0PLUS Already Started ***"
+   }
+}
+
+proc clear_icsr_m0plus {} {
+   global _CHIPNAME
+
+   # Trace and clear SCB_ICSR if different from 0x0 [ROOT CAUSE TO BE CLARIFIED]
+   #
+   set SCB_ICSR_addr  0xE000ED04
+   set SCB_AIRCR_addr 0xE000ED0C
+   #
+   set data [$_CHIPNAME.m0p read_memory $SCB_ICSR_addr 32 1]
+   if {$data != 0} {
+      set scb_icsr_val [format %08X $data]
+      echo "WARNING ! m0plus SCB_ICSR IS DIFFERENT FROM 0x0 (Root cause to be clarified)"
+      echo "... Clearing it by setting m0plus SCB_AIRCR bit 1 \"VECTCLRACTIVE\" ..."
+      $_CHIPNAME.m0p mww $SCB_AIRCR_addr 0x05FA0002
+   }
+}
+
+# switch A35 Cores from Aarch64 mode to Aarch32/Thumb mode
+proc Run_EL3_Launcher {core_name} {
+   global _CHIPNAME
+   global _REG_ACCESS_TARGET
+   global _HSI_FREQ
+   global _A35_0_CORE_START
+   global _A35_0_SECURE
+   global _A35_0_MEM_START
+   global _A35_0_MEM_END
+   global _A35_1_CORE_START
+   global _A35_1_SECURE
+   global _A35_1_MEM_START
+   global _A35_1_MEM_END
+   global _EL3_LAUNCHER_LOADED
+
+   # EL3/EL1 Interface fields offsets
+   set EL1_TESTAPP_ENTRYPOINT_ADDR_OFS      0x00
+   set EL1_VECTOR_TABLE_BASE_ADDR_OFS       0x04
+   set INTERFACE_ASCII_ID_OFS               0x08
+   set EL1_TESTAPP_SECURITY_STATE_OFS       0x0C
+   set EL1_TESTAPP_MEM_START_ADDR_OFS       0x10
+   set EL1_TESTAPP_MEM_END_ADDR_OFS         0x14
+   set EL1_A35_1_INTERFACE_ADDR_OFS         0x18
+   set DUMMY_OFS                            0x1C
+
+   # Security states
+   set SECURE_EL3_AA64_TESTAPP         0xAA645EC3
+   set SECURE_EL1_AA64_TESTAPP         0xAA645EC1
+   set NON_SECURE_EL1_AA64_TESTAPP     0xAA6405E1
+   set SECURE_EL1_AA32_TESTAPP         0xAA325EC1
+   set NON_SECURE_EL1_AA32_TESTAPP     0xAA3205E1
+
+   # EL3-EL1 interface identification
+   set EL3_EL1_INTERFACE_ID1_SWITCHER  0x454C3353
+
+   set el3_launcher_bin {
+         0	0x0e003000
+         1	0x0e002800
+         2	0x76312e30
+         3	0x454c334c
+         4	0xd503201f
+         5	0xd65f03c0
+         6	0x00000000
+         7	0x00000000
+         8	0x00000000
+         9	0x00000000
+        10	0x00000000
+        11	0x00000000
+        12	0x00000000
+        13	0x00000000
+        14	0x00000000
+        15	0x00000000
+        16	0x00000000
+        17	0x00000000
+        18	0x00000000
+        19	0x00000000
+        20	0x00000000
+        21	0x00000000
+        22	0x00000000
+        23	0x00000000
+        24	0x00000000
+        25	0x00000000
+        26	0x00000000
+        27	0x00000000
+        28	0x00000000
+        29	0x00000000
+        30	0x00000000
+        31	0x00000000
+        32	0x00000000
+        33	0x00000000
+        34	0x00000000
+        35	0x00000000
+        36	0x00000000
+        37	0x00000000
+        38	0x00000000
+        39	0x00000000
+        40	0x00000000
+        41	0x00000000
+        42	0x00000000
+        43	0x00000000
+        44	0x00000000
+        45	0x00000000
+        46	0x00000000
+        47	0x00000000
+        48	0x00000000
+        49	0x00000000
+        50	0x00000000
+        51	0x00000000
+        52	0x00000000
+        53	0x00000000
+        54	0x00000000
+        55	0x00000000
+        56	0x00000000
+        57	0x00000000
+        58	0x00000000
+        59	0x00000000
+        60	0x00000000
+        61	0x00000000
+        62	0x00000000
+        63	0x00000000
+        64	0x00000000
+        65	0x00000000
+        66	0x00000000
+        67	0x00000000
+        68	0x00000000
+        69	0x00000000
+        70	0x00000000
+        71	0x00000000
+        72	0x00000000
+        73	0x00000000
+        74	0x00000000
+        75	0x00000000
+        76	0x00000000
+        77	0x00000000
+        78	0x00000000
+        79	0x00000000
+        80	0x00000000
+        81	0x00000000
+        82	0x00000000
+        83	0x00000000
+        84	0x00000000
+        85	0x00000000
+        86	0x00000000
+        87	0x00000000
+        88	0x00000000
+        89	0x00000000
+        90	0x00000000
+        91	0x00000000
+        92	0x00000000
+        93	0x00000000
+        94	0x00000000
+        95	0x00000000
+        96	0x00000000
+        97	0x00000000
+        98	0x00000000
+        99	0x00000000
+       100	0x00000000
+       101	0x00000000
+       102	0x00000000
+       103	0x00000000
+       104	0x00000000
+       105	0x00000000
+       106	0x00000000
+       107	0x00000000
+       108	0x00000000
+       109	0x00000000
+       110	0x00000000
+       111	0x00000000
+       112	0x00000000
+       113	0x00000000
+       114	0x00000000
+       115	0x00000000
+       116	0x00000000
+       117	0x00000000
+       118	0x00000000
+       119	0x00000000
+       120	0x00000000
+       121	0x00000000
+       122	0x00000000
+       123	0x00000000
+       124	0x00000000
+       125	0x00000000
+       126	0x00000000
+       127	0x00000000
+       128	0xd503201f
+       129	0x17ffffff
+       130	0xd503201f
+       131	0xd503201f
+       132	0xd503201f
+       133	0xd503201f
+       134	0xd503201f
+       135	0xd503201f
+       136	0xd503201f
+       137	0xd503201f
+       138	0xd503201f
+       139	0xd503201f
+       140	0xd503201f
+       141	0xd503201f
+       142	0xd503201f
+       143	0xd503201f
+       144	0xd503201f
+       145	0xd503201f
+       146	0xd503201f
+       147	0xd503201f
+       148	0xd503201f
+       149	0xd503201f
+       150	0xd503201f
+       151	0xd503201f
+       152	0xd503201f
+       153	0xd503201f
+       154	0xd503201f
+       155	0xd503201f
+       156	0xd503201f
+       157	0xd503201f
+       158	0xd503201f
+       159	0xd503201f
+       160	0xd503201f
+       161	0x17ffffff
+       162	0xd503201f
+       163	0xd503201f
+       164	0xd503201f
+       165	0xd503201f
+       166	0xd503201f
+       167	0xd503201f
+       168	0xd503201f
+       169	0xd503201f
+       170	0xd503201f
+       171	0xd503201f
+       172	0xd503201f
+       173	0xd503201f
+       174	0xd503201f
+       175	0xd503201f
+       176	0xd503201f
+       177	0xd503201f
+       178	0xd503201f
+       179	0xd503201f
+       180	0xd503201f
+       181	0xd503201f
+       182	0xd503201f
+       183	0xd503201f
+       184	0xd503201f
+       185	0xd503201f
+       186	0xd503201f
+       187	0xd503201f
+       188	0xd503201f
+       189	0xd503201f
+       190	0xd503201f
+       191	0xd503201f
+       192	0xd503201f
+       193	0x17ffffff
+       194	0xd503201f
+       195	0xd503201f
+       196	0xd503201f
+       197	0xd503201f
+       198	0xd503201f
+       199	0xd503201f
+       200	0xd503201f
+       201	0xd503201f
+       202	0xd503201f
+       203	0xd503201f
+       204	0xd503201f
+       205	0xd503201f
+       206	0xd503201f
+       207	0xd503201f
+       208	0xd503201f
+       209	0xd503201f
+       210	0xd503201f
+       211	0xd503201f
+       212	0xd503201f
+       213	0xd503201f
+       214	0xd503201f
+       215	0xd503201f
+       216	0xd503201f
+       217	0xd503201f
+       218	0xd503201f
+       219	0xd503201f
+       220	0xd503201f
+       221	0xd503201f
+       222	0xd503201f
+       223	0xd503201f
+       224	0xd503201f
+       225	0x17ffffff
+       226	0xd503201f
+       227	0xd503201f
+       228	0xd503201f
+       229	0xd503201f
+       230	0xd503201f
+       231	0xd503201f
+       232	0xd503201f
+       233	0xd503201f
+       234	0xd503201f
+       235	0xd503201f
+       236	0xd503201f
+       237	0xd503201f
+       238	0xd503201f
+       239	0xd503201f
+       240	0xd503201f
+       241	0xd503201f
+       242	0xd503201f
+       243	0xd503201f
+       244	0xd503201f
+       245	0xd503201f
+       246	0xd503201f
+       247	0xd503201f
+       248	0xd503201f
+       249	0xd503201f
+       250	0xd503201f
+       251	0xd503201f
+       252	0xd503201f
+       253	0xd503201f
+       254	0xd503201f
+       255	0xd503201f
+       256	0xa9bf07e0
+       257	0xa9bf0fe2
+       258	0xa9bf17e4
+       259	0xa9bf1fe6
+       260	0xa9bf27e8
+       261	0xa9bf2fea
+       262	0xa9bf37ec
+       263	0xa9bf3fee
+       264	0xa9bf7bfd
+       265	0xd503201f
+       266	0xa8c17bfd
+       267	0xa8c13fee
+       268	0xa8c137ec
+       269	0xa8c12fea
+       270	0xa8c127e8
+       271	0xa8c11fe6
+       272	0xa8c117e4
+       273	0xa8c10fe2
+       274	0xa8c107e0
+       275	0xd69f03e0
+       276	0xd503201f
+       277	0xd503201f
+       278	0xd503201f
+       279	0xd503201f
+       280	0xd503201f
+       281	0xd503201f
+       282	0xd503201f
+       283	0xd503201f
+       284	0xd503201f
+       285	0xd503201f
+       286	0xd503201f
+       287	0xd503201f
+       288	0xa9bf07e0
+       289	0xa9bf0fe2
+       290	0xa9bf17e4
+       291	0xa9bf1fe6
+       292	0xa9bf27e8
+       293	0xa9bf2fea
+       294	0xa9bf37ec
+       295	0xa9bf3fee
+       296	0xa9bf7bfd
+       297	0xd503201f
+       298	0xa8c17bfd
+       299	0xa8c13fee
+       300	0xa8c137ec
+       301	0xa8c12fea
+       302	0xa8c127e8
+       303	0xa8c11fe6
+       304	0xa8c117e4
+       305	0xa8c10fe2
+       306	0xa8c107e0
+       307	0xd69f03e0
+       308	0xd503201f
+       309	0xd503201f
+       310	0xd503201f
+       311	0xd503201f
+       312	0xd503201f
+       313	0xd503201f
+       314	0xd503201f
+       315	0xd503201f
+       316	0xd503201f
+       317	0xd503201f
+       318	0xd503201f
+       319	0xd503201f
+       320	0xa9bf07e0
+       321	0xa9bf0fe2
+       322	0xa9bf17e4
+       323	0xa9bf1fe6
+       324	0xa9bf27e8
+       325	0xa9bf2fea
+       326	0xa9bf37ec
+       327	0xa9bf3fee
+       328	0xa9bf7bfd
+       329	0xd503201f
+       330	0xa8c17bfd
+       331	0xa8c13fee
+       332	0xa8c137ec
+       333	0xa8c12fea
+       334	0xa8c127e8
+       335	0xa8c11fe6
+       336	0xa8c117e4
+       337	0xa8c10fe2
+       338	0xa8c107e0
+       339	0xd69f03e0
+       340	0xd503201f
+       341	0xd503201f
+       342	0xd503201f
+       343	0xd503201f
+       344	0xd503201f
+       345	0xd503201f
+       346	0xd503201f
+       347	0xd503201f
+       348	0xd503201f
+       349	0xd503201f
+       350	0xd503201f
+       351	0xd503201f
+       352	0xa9bf07e0
+       353	0xa9bf0fe2
+       354	0xa9bf17e4
+       355	0xa9bf1fe6
+       356	0xa9bf27e8
+       357	0xa9bf2fea
+       358	0xa9bf37ec
+       359	0xa9bf3fee
+       360	0xa9bf7bfd
+       361	0xd503201f
+       362	0xa8c17bfd
+       363	0xa8c13fee
+       364	0xa8c137ec
+       365	0xa8c12fea
+       366	0xa8c127e8
+       367	0xa8c11fe6
+       368	0xa8c117e4
+       369	0xa8c10fe2
+       370	0xa8c107e0
+       371	0xd69f03e0
+       372	0xd503201f
+       373	0xd503201f
+       374	0xd503201f
+       375	0xd503201f
+       376	0xd503201f
+       377	0xd503201f
+       378	0xd503201f
+       379	0xd503201f
+       380	0xd503201f
+       381	0xd503201f
+       382	0xd503201f
+       383	0xd503201f
+       384	0x1400072f
+       385	0x17ffffff
+       386	0xd503201f
+       387	0xd503201f
+       388	0xd503201f
+       389	0xd503201f
+       390	0xd503201f
+       391	0xd503201f
+       392	0xd503201f
+       393	0xd503201f
+       394	0xd503201f
+       395	0xd503201f
+       396	0xd503201f
+       397	0xd503201f
+       398	0xd503201f
+       399	0xd503201f
+       400	0xd503201f
+       401	0xd503201f
+       402	0xd503201f
+       403	0xd503201f
+       404	0xd503201f
+       405	0xd503201f
+       406	0xd503201f
+       407	0xd503201f
+       408	0xd503201f
+       409	0xd503201f
+       410	0xd503201f
+       411	0xd503201f
+       412	0xd503201f
+       413	0xd503201f
+       414	0xd503201f
+       415	0xd503201f
+       416	0xd503201f
+       417	0x17ffffff
+       418	0xd503201f
+       419	0xd503201f
+       420	0xd503201f
+       421	0xd503201f
+       422	0xd503201f
+       423	0xd503201f
+       424	0xd503201f
+       425	0xd503201f
+       426	0xd503201f
+       427	0xd503201f
+       428	0xd503201f
+       429	0xd503201f
+       430	0xd503201f
+       431	0xd503201f
+       432	0xd503201f
+       433	0xd503201f
+       434	0xd503201f
+       435	0xd503201f
+       436	0xd503201f
+       437	0xd503201f
+       438	0xd503201f
+       439	0xd503201f
+       440	0xd503201f
+       441	0xd503201f
+       442	0xd503201f
+       443	0xd503201f
+       444	0xd503201f
+       445	0xd503201f
+       446	0xd503201f
+       447	0xd503201f
+       448	0xd503201f
+       449	0x17ffffff
+       450	0xd503201f
+       451	0xd503201f
+       452	0xd503201f
+       453	0xd503201f
+       454	0xd503201f
+       455	0xd503201f
+       456	0xd503201f
+       457	0xd503201f
+       458	0xd503201f
+       459	0xd503201f
+       460	0xd503201f
+       461	0xd503201f
+       462	0xd503201f
+       463	0xd503201f
+       464	0xd503201f
+       465	0xd503201f
+       466	0xd503201f
+       467	0xd503201f
+       468	0xd503201f
+       469	0xd503201f
+       470	0xd503201f
+       471	0xd503201f
+       472	0xd503201f
+       473	0xd503201f
+       474	0xd503201f
+       475	0xd503201f
+       476	0xd503201f
+       477	0xd503201f
+       478	0xd503201f
+       479	0xd503201f
+       480	0xd503201f
+       481	0x17ffffff
+       482	0xd503201f
+       483	0xd503201f
+       484	0xd503201f
+       485	0xd503201f
+       486	0xd503201f
+       487	0xd503201f
+       488	0xd503201f
+       489	0xd503201f
+       490	0xd503201f
+       491	0xd503201f
+       492	0xd503201f
+       493	0xd503201f
+       494	0xd503201f
+       495	0xd503201f
+       496	0xd503201f
+       497	0xd503201f
+       498	0xd503201f
+       499	0xd503201f
+       500	0xd503201f
+       501	0xd503201f
+       502	0xd503201f
+       503	0xd503201f
+       504	0xd503201f
+       505	0xd503201f
+       506	0xd503201f
+       507	0xd503201f
+       508	0xd503201f
+       509	0xd503201f
+       510	0xd503201f
+       511	0xd503201f
+       512	0x140006b2
+       513	0x17ffffff
+       514	0xd503201f
+       515	0xd503201f
+       516	0xd503201f
+       517	0xd503201f
+       518	0xd503201f
+       519	0xd503201f
+       520	0xd503201f
+       521	0xd503201f
+       522	0xd503201f
+       523	0xd503201f
+       524	0xd503201f
+       525	0xd503201f
+       526	0xd503201f
+       527	0xd503201f
+       528	0xd503201f
+       529	0xd503201f
+       530	0xd503201f
+       531	0xd503201f
+       532	0xd503201f
+       533	0xd503201f
+       534	0xd503201f
+       535	0xd503201f
+       536	0xd503201f
+       537	0xd503201f
+       538	0xd503201f
+       539	0xd503201f
+       540	0xd503201f
+       541	0xd503201f
+       542	0xd503201f
+       543	0xd503201f
+       544	0xd503201f
+       545	0x17ffffff
+       546	0xd503201f
+       547	0xd503201f
+       548	0xd503201f
+       549	0xd503201f
+       550	0xd503201f
+       551	0xd503201f
+       552	0xd503201f
+       553	0xd503201f
+       554	0xd503201f
+       555	0xd503201f
+       556	0xd503201f
+       557	0xd503201f
+       558	0xd503201f
+       559	0xd503201f
+       560	0xd503201f
+       561	0xd503201f
+       562	0xd503201f
+       563	0xd503201f
+       564	0xd503201f
+       565	0xd503201f
+       566	0xd503201f
+       567	0xd503201f
+       568	0xd503201f
+       569	0xd503201f
+       570	0xd503201f
+       571	0xd503201f
+       572	0xd503201f
+       573	0xd503201f
+       574	0xd503201f
+       575	0xd503201f
+       576	0xd503201f
+       577	0x17ffffff
+       578	0xd503201f
+       579	0xd503201f
+       580	0xd503201f
+       581	0xd503201f
+       582	0xd503201f
+       583	0xd503201f
+       584	0xd503201f
+       585	0xd503201f
+       586	0xd503201f
+       587	0xd503201f
+       588	0xd503201f
+       589	0xd503201f
+       590	0xd503201f
+       591	0xd503201f
+       592	0xd503201f
+       593	0xd503201f
+       594	0xd503201f
+       595	0xd503201f
+       596	0xd503201f
+       597	0xd503201f
+       598	0xd503201f
+       599	0xd503201f
+       600	0xd503201f
+       601	0xd503201f
+       602	0xd503201f
+       603	0xd503201f
+       604	0xd503201f
+       605	0xd503201f
+       606	0xd503201f
+       607	0xd503201f
+       608	0xd503201f
+       609	0x17ffffff
+       610	0xd503201f
+       611	0xd503201f
+       612	0xd503201f
+       613	0xd503201f
+       614	0xd503201f
+       615	0xd503201f
+       616	0xd503201f
+       617	0xd503201f
+       618	0xd503201f
+       619	0xd503201f
+       620	0xd503201f
+       621	0xd503201f
+       622	0xd503201f
+       623	0xd503201f
+       624	0xd503201f
+       625	0xd503201f
+       626	0xd503201f
+       627	0xd503201f
+       628	0xd503201f
+       629	0xd503201f
+       630	0xd503201f
+       631	0xd503201f
+       632	0xd503201f
+       633	0xd503201f
+       634	0xd503201f
+       635	0xd503201f
+       636	0xd503201f
+       637	0xd503201f
+       638	0xd503201f
+       639	0xd503201f
+       640	0xaa1f03e0
+       641	0xaa1f03e1
+       642	0xaa1f03e2
+       643	0xaa1f03e3
+       644	0xaa1f03e4
+       645	0xaa1f03e5
+       646	0xaa1f03e6
+       647	0xaa1f03e7
+       648	0xaa1f03e8
+       649	0xaa1f03e9
+       650	0xaa1f03ea
+       651	0xaa1f03eb
+       652	0xaa1f03ec
+       653	0xaa1f03ed
+       654	0xaa1f03ee
+       655	0xaa1f03ef
+       656	0xaa1f03f0
+       657	0xaa1f03f1
+       658	0xaa1f03f2
+       659	0xaa1f03f3
+       660	0xaa1f03f4
+       661	0xaa1f03f5
+       662	0xaa1f03f6
+       663	0xaa1f03f7
+       664	0xaa1f03f8
+       665	0xaa1f03f9
+       666	0xaa1f03fa
+       667	0xaa1f03fb
+       668	0xaa1f03fc
+       669	0xaa1f03fd
+       670	0xaa1f03fe
+       671	0x9100001f
+       672	0xd5184100
+       673	0xd51c4100
+       674	0xd51e4100
+       675	0xd5184020
+       676	0xd51c4020
+       677	0xd51e4020
+       678	0xd5184000
+       679	0xd51c4000
+       680	0xd51e4000
+       681	0xd53e4020
+       682	0xd53e1000
+       683	0x927ff800
+       684	0xd51e1000
+       685	0x58001aa1
+       686	0xd51ec001
+       687	0x940000bf
+       688	0x940000bb
+       689	0xf100001f
+       690	0x54000021
+       691	0xd5380400
+       692	0xd3504c00
+       693	0xb5000480
+       694	0xd2a00601
+       695	0xd5181041
+       696	0xd5033fdf
+       697	0x9e6703e0
+       698	0x9e6703e1
+       699	0x9e6703e2
+       700	0x9e6703e3
+       701	0x9e6703e4
+       702	0x9e6703e5
+       703	0x9e6703e6
+       704	0x9e6703e7
+       705	0x9e6703e8
+       706	0x9e6703e9
+       707	0x9e6703ea
+       708	0x9e6703eb
+       709	0x9e6703ec
+       710	0x9e6703ed
+       711	0x9e6703ee
+       712	0x9e6703ef
+       713	0x9e6703f0
+       714	0x9e6703f1
+       715	0x9e6703f2
+       716	0x9e6703f3
+       717	0x9e6703f4
+       718	0x9e6703f5
+       719	0x9e6703f6
+       720	0x9e6703f7
+       721	0x9e6703f8
+       722	0x9e6703f9
+       723	0x9e6703fa
+       724	0x9e6703fb
+       725	0x9e6703fc
+       726	0x9e6703fd
+       727	0x9e6703fe
+       728	0x9e6703ff
+       729	0x180014e1
+       730	0xd51e2041
+       731	0x58001361
+       732	0xd51ea201
+       733	0x10001360
+       734	0xd51e2000
+       735	0xd539f220
+       736	0x9279f800
+       737	0xd519f220
+       738	0xd5033fdf
+       739	0x94000088
+       740	0xf100041f
+       741	0x54000e20
+       742	0xd53e1000
+       743	0x927cf800
+       744	0xb2400000
+       745	0xd51e1000
+       746	0x94000070
+       747	0x58001328
+       748	0xf9400108
+       749	0xd2800000
+       750	0x910003e1
+       751	0xf81f8c20
+       752	0x38401503
+       753	0x34000243
+       754	0x7100807f
+       755	0x54ffffa0
+       756	0x52800404
+       757	0x71008869
+       758	0xd1000508
+       759	0x7a451924
+       760	0x1a840064
+       761	0x9a881508
+       762	0xf81f8c28
+       763	0x91000400
+       764	0x38401503
+       765	0x340000c3
+       766	0x6b03009f
+       767	0x54ffffa1
+       768	0x52800004
+       769	0x381ff104
+       770	0x17ffffee
+       771	0x91000023
+       772	0x8b204c24
+       773	0xeb03009f
+       774	0x540000e3
+       775	0xf85f8085
+       776	0xf9400066
+       777	0xf81f8c86
+       778	0xf8008465
+       779	0xeb03009f
+       780	0x54ffff68
+       781	0x927cec24
+       782	0x9100009f
+       783	0x94000104
+       784	0x140005ac
+       785	0x0e00324c
+       786	0x00000000
+       787	0x00000000
+       788	0x00000000
+       789	0x00000000
+       790	0x00000000
+       791	0x00000000
+       792	0x00000000
+       793	0x00000000
+       794	0x00000000
+       795	0x00000000
+       796	0x00000000
+       797	0x00000000
+       798	0x00000000
+       799	0x00000000
+       800	0x00000000
+       801	0x00000000
+       802	0x00000000
+       803	0x00000000
+       804	0x00000000
+       805	0x00000000
+       806	0x00000000
+       807	0x00000000
+       808	0x00000000
+       809	0x00000000
+       810	0x00000000
+       811	0x00000000
+       812	0x00000000
+       813	0x00000000
+       814	0x00000000
+       815	0x00000000
+       816	0x00000000
+       817	0x00000000
+       818	0x00000000
+       819	0x00000000
+       820	0x00000000
+       821	0x00000000
+       822	0x00000000
+       823	0x00000000
+       824	0x00000000
+       825	0x00000000
+       826	0x00000000
+       827	0x00000000
+       828	0x00000000
+       829	0x00000000
+       830	0x00000000
+       831	0x00000000
+       832	0x00000000
+       833	0x00000000
+       834	0x00000000
+       835	0x00000000
+       836	0x00000000
+       837	0x00000000
+       838	0x00000000
+       839	0x00000000
+       840	0x00000000
+       841	0x00000000
+       842	0x00000000
+       843	0x00000000
+       844	0x00000000
+       845	0x00000000
+       846	0x00000000
+       847	0x00000000
+       848	0x00000000
+       849	0x00000000
+       850	0x00000000
+       851	0xd503205f
+       852	0xd5033fdf
+       853	0x17fffffe
+       854	0x14000227
+       855	0xd503205f
+       856	0xd5033fdf
+       857	0x17fffffe
+       858	0xa9bf7bf3
+       859	0x9400000b
+       860	0x58000540
+       861	0x58000561
+       862	0xcb000022
+       863	0xd2800001
+       864	0x94000030
+       865	0x58000520
+       866	0x94000554
+       867	0x94000579
+       868	0xa8c17bf3
+       869	0xd65f03c0
+       870	0xd53e1000
+       871	0xb27e0000
+       872	0xb2740000
+       873	0xd51e1000
+       874	0xd65f03c0
+       875	0xd53800a0
+       876	0x92401c00
+       877	0xd65f03c0
+       878	0xd53800a0
+       879	0x92401c00
+       880	0xd376d400
+       881	0x58000361
+       882	0xcb000020
+       883	0x9100001f
+       884	0xd5033fdf
+       885	0xd65f03c0
+       886	0x44ff0400
+       887	0x00000000
+       888	0x0000064d
+       889	0x00000000
+       890	0x40000641
+       891	0x00000000
+       892	0x8000064d
+       893	0x00000000
+       894	0xc0000749
+       895	0x00000000
+       896	0x80803520
+       897	0x00000000
+       898	0x0e002800
+       899	0x00000000
+       900	0x0e003244
+       901	0x00000000
+       902	0x0e005360
+       903	0x00000000
+       904	0x0e005390
+       905	0x00000000
+       906	0x0e004928
+       907	0x00000000
+       908	0x0e006000
+       909	0x00000000
+       910	0x00000000
+       911	0x00000000
+       912	0x4e010c20
+       913	0x8b020004
+       914	0xf101805f
+       915	0x540003c8
+       916	0xf100405f
+       917	0x54000202
+       918	0x4e083c01
+       919	0x361800a2
+       920	0xf9000001
+       921	0xf81f8081
+       922	0xd65f03c0
+       923	0xd503201f
+       924	0x36100082
+       925	0xb9000001
+       926	0xb81fc081
+       927	0xd65f03c0
+       928	0xb4000082
+       929	0x39000001
+       930	0x36080042
+       931	0x781fe081
+       932	0xd65f03c0
+       933	0x3d800000
+       934	0x373000c2
+       935	0x3c9f0080
+       936	0x36280062
+       937	0x3d800400
+       938	0x3c9e0080
+       939	0xd65f03c0
+       940	0x3d800400
+       941	0xad010000
+       942	0xad3f0080
+       943	0xd65f03c0
+       944	0xd503201f
+       945	0x12001c21
+       946	0x927cec03
+       947	0x3d800000
+       948	0xf104005f
+       949	0x7a402820
+       950	0x54000180
+       951	0xcb030082
+       952	0xd1004063
+       953	0xd1014042
+       954	0xad010060
+       955	0xad820060
+       956	0xf1010042
+       957	0x54ffffa8
+       958	0xad3e0080
+       959	0xad3f0080
+       960	0xd65f03c0
+       961	0xd503201f
+       962	0xd53b00e5
+       963	0x3727fe85
+       964	0x12000ca5
+       965	0x710010bf
+       966	0x54000281
+       967	0x3d800460
+       968	0xad010060
+       969	0x927ae463
+       970	0xad020060
+       971	0xad030060
+       972	0xcb030082
+       973	0xd1040042
+       974	0x91020063
+       975	0xd503201f
+       976	0xd50b7423
+       977	0x91010063
+       978	0xf1010042
+       979	0x54ffffa8
+       980	0xad000060
+       981	0xad010060
+       982	0xad3e0080
+       983	0xad3f0080
+       984	0xd65f03c0
+       985	0xd503201f
+       986	0x710014bf
+       987	0x54000241
+       988	0x3d800460
+       989	0xad010060
+       990	0xad020060
+       991	0xad030060
+       992	0x9279e063
+       993	0xcb030082
+       994	0xd1040042
+       995	0x91020063
+       996	0xd50b7423
+       997	0x91020063
+       998	0xf1020042
+       999	0x54ffffa8
+      1000	0xad3c0080
+      1001	0xad3d0080
+      1002	0xad3e0080
+      1003	0xad3f0080
+      1004	0xd65f03c0
+      1005	0x52800086
+      1006	0x1ac520c7
+      1007	0x910100e5
+      1008	0xeb05005f
+      1009	0x54fff8c3
+      1010	0xd10004e6
+      1011	0x8b070065
+      1012	0x91004063
+      1013	0xeb0300a2
+      1014	0x8a2600a5
+      1015	0x540000a0
+      1016	0xac820060
+      1017	0xad3f0060
+      1018	0xf1010042
+      1019	0x54ffffa8
+      1020	0xaa0503e3
+      1021	0xcb050082
+      1022	0xeb070042
+      1023	0x540000a3
+      1024	0xd50b7423
+      1025	0x8b070063
+      1026	0xeb070042
+      1027	0x54ffffa2
+      1028	0x8b070042
+      1029	0xd1008063
+      1030	0x17ffffb6
+      1031	0xa9bf7bfd
+      1032	0xa9bf73fb
+      1033	0xa9bf6bf9
+      1034	0xa9bf63f7
+      1035	0xa9bf5bf5
+      1036	0xa9bf53f3
+      1037	0xa9bf7bfd
+      1038	0xa9bf73fb
+      1039	0xa9bf6bf9
+      1040	0xa9bf63f7
+      1041	0xa9bf5bf5
+      1042	0xa9bf53f3
+      1043	0xa9bc7bfd
+      1044	0x910003fd
+      1045	0xb9003fff
+      1046	0xf90017ff
+      1047	0xf0000000
+      1048	0x91000000
+      1049	0xb9400800
+      1050	0x52866981
+      1051	0x72a8a981
+      1052	0x6b01001f
+      1053	0x540000c0
+      1054	0x52866a61
+      1055	0x72a8a981
+      1056	0x6b01001f
+      1057	0x540000a0
+      1058	0x14000006
+      1059	0x52800020
+      1060	0xb90033e0
+      1061	0x14000006
+      1062	0xb90033ff
+      1063	0x14000004
+      1064	0x12800000
+      1065	0xb90033e0
+      1066	0xd503201f
+      1067	0xb94033e0
+      1068	0x3100041f
+      1069	0x54000f00
+      1070	0xf0000000
+      1071	0x91000000
+      1072	0xb9400401
+      1073	0xd0000000
+      1074	0x910d6000
+      1075	0xb9000001
+      1076	0xf0000000
+      1077	0x91000000
+      1078	0xb9400000
+      1079	0x2a0003e1
+      1080	0xd0000000
+      1081	0x910d8000
+      1082	0xf9000001
+      1083	0xf0000000
+      1084	0x91000000
+      1085	0xb9400c01
+      1086	0xb0000000
+      1087	0x912fe000
+      1088	0xb9000001
+      1089	0xf0000000
+      1090	0x91000000
+      1091	0xb9401001
+      1092	0xd0000000
+      1093	0x910dc000
+      1094	0xb9000001
+      1095	0xf0000000
+      1096	0x91000000
+      1097	0xb9401401
+      1098	0xd0000000
+      1099	0x910de000
+      1100	0xb9000001
+      1101	0xf0000000
+      1102	0x91000000
+      1103	0xb9401800
+      1104	0x7100001f
+      1105	0x54000461
+      1106	0xf0000000
+      1107	0x91000000
+      1108	0xb9400401
+      1109	0xd0000000
+      1110	0x910d6000
+      1111	0xb9000401
+      1112	0xf0000000
+      1113	0x91000000
+      1114	0xb9400000
+      1115	0x2a0003e1
+      1116	0xd0000000
+      1117	0x910d8000
+      1118	0xf9000401
+      1119	0xf0000000
+      1120	0x91000000
+      1121	0xb9400c01
+      1122	0xb0000000
+      1123	0x912fe000
+      1124	0xb9000401
+      1125	0xf0000000
+      1126	0x91000000
+      1127	0xb9401001
+      1128	0xd0000000
+      1129	0x910dc000
+      1130	0xb9000401
+      1131	0xf0000000
+      1132	0x91000000
+      1133	0xb9401401
+      1134	0xd0000000
+      1135	0x910de000
+      1136	0xb9000401
+      1137	0x52800020
+      1138	0xb90037e0
+      1139	0x14000021
+      1140	0xf0000000
+      1141	0x91000000
+      1142	0xb9401800
+      1143	0x2a0003e0
+      1144	0xf90017e0
+      1145	0xf94017e0
+      1146	0xb9400401
+      1147	0xd0000000
+      1148	0x910d6000
+      1149	0xb9000401
+      1150	0xf94017e0
+      1151	0xb9400000
+      1152	0x2a0003e1
+      1153	0xd0000000
+      1154	0x910d8000
+      1155	0xf9000401
+      1156	0xf94017e0
+      1157	0xb9400c01
+      1158	0xb0000000
+      1159	0x912fe000
+      1160	0xb9000401
+      1161	0xf94017e0
+      1162	0xb9401001
+      1163	0xd0000000
+      1164	0x910dc000
+      1165	0xb9000401
+      1166	0xf94017e0
+      1167	0xb9401401
+      1168	0xd0000000
+      1169	0x910de000
+      1170	0xb9000401
+      1171	0xb90037ff
+      1172	0xb94033e0
+      1173	0x7100001f
+      1174	0x54000801
+      1175	0xb9003bff
+      1176	0x14000009
+      1177	0xd0000000
+      1178	0x910e0000
+      1179	0xb9403be1
+      1180	0x52800022
+      1181	0xb8217802
+      1182	0xb9403be0
+      1183	0x11000400
+      1184	0xb9003be0
+      1185	0xb9403be0
+      1186	0x7100041f
+      1187	0x54fffec9
+      1188	0x14000032
+      1189	0xb9003bff
+      1190	0x1400002b
+      1191	0xd0000000
+      1192	0x910d6000
+      1193	0xb9403be1
+      1194	0x528c0002
+      1195	0x72a40002
+      1196	0xb8217802
+      1197	0xb9403be0
+      1198	0xd37df001
+      1199	0xb0000000
+      1200	0x91300000
+      1201	0x8b000020
+      1202	0xb2400002
+      1203	0xd0000000
+      1204	0x910d8000
+      1205	0xb9403be1
+      1206	0xf8217802
+      1207	0xb0000000
+      1208	0x912fe000
+      1209	0xb9403be1
+      1210	0x528bd822
+      1211	0x72b54642
+      1212	0xb8217802
+      1213	0xf0000000
+      1214	0x91000000
+      1215	0x2a0003e2
+      1216	0xd0000000
+      1217	0x910dc000
+      1218	0xb9403be1
+      1219	0xb8217802
+      1220	0xd0000000
+      1221	0x910de000
+      1222	0xb9403be1
+      1223	0x12bbff82
+      1224	0xb8217802
+      1225	0xd0000000
+      1226	0x910e0000
+      1227	0xb9403be1
+      1228	0x52800022
+      1229	0xb8217802
+      1230	0xb9403be0
+      1231	0x11000400
+      1232	0xb9003be0
+      1233	0xb9403be0
+      1234	0x7100041f
+      1235	0x54fffa89
+      1236	0x52800020
+      1237	0xb90037e0
+      1238	0xb9003bff
+      1239	0x1400002f
+      1240	0xd0000000
+      1241	0x910e0000
+      1242	0xb9403be1
+      1243	0xb8617800
+      1244	0x7100041f
+      1245	0x540004c1
+      1246	0xd0000000
+      1247	0x910d8000
+      1248	0xb9403be1
+      1249	0xf8617800
+      1250	0x927ff800
+      1251	0xf90013e0
+      1252	0xb0000000
+      1253	0x912fe000
+      1254	0xb9403be1
+      1255	0xb8617800
+      1256	0x2a0003e1
+      1257	0x129ffe00
+      1258	0x8a000021
+      1259	0xd2800020
+      1260	0xf2b54c80
+      1261	0xeb00003f
+      1262	0x540000a1
+      1263	0xf94013e0
+      1264	0x52a28001
+      1265	0xb9000001
+      1266	0x14000011
+      1267	0xd0000000
+      1268	0x910d8000
+      1269	0xb9403be1
+      1270	0xf8617800
+      1271	0x92400000
+      1272	0xf100041f
+      1273	0x540000c1
+      1274	0xf94013e0
+      1275	0x529cffc1
+      1276	0x72b7e001
+      1277	0xb9000001
+      1278	0x14000005
+      1279	0xf94013e0
+      1280	0x529fffc1
+      1281	0x72bd5fe1
+      1282	0xb9000001
+      1283	0xb9403be0
+      1284	0x11000400
+      1285	0xb9003be0
+      1286	0xb9403be0
+      1287	0x7100041f
+      1288	0x54fffa09
+      1289	0x940001ca
+      1290	0xd0000000
+      1291	0x910d8000
+      1292	0xf9400000
+      1293	0x12000000
+      1294	0xb9001fe0
+      1295	0x940000a2
+      1296	0xd0000000
+      1297	0x910dc000
+      1298	0xb9400000
+      1299	0x7100001f
+      1300	0x540000cb
+      1301	0xd0000000
+      1302	0x910dc000
+      1303	0xb9400400
+      1304	0x7100001f
+      1305	0x5400004a
+      1306	0x940002c3
+      1307	0xd539f220
+      1308	0xb9001be0
+      1309	0xb9401be0
+      1310	0x53067c00
+      1311	0x12000000
+      1312	0xb90017e0
+      1313	0xb94017e1
+      1314	0xb94037e0
+      1315	0x6b00003f
+      1316	0x540000c0
+      1317	0xd0000000
+      1318	0x910e2000
+      1319	0x5286a1a1
+      1320	0x72b75b41
+      1321	0xb9000001
+      1322	0xb9003bff
+      1323	0x1400001a
+      1324	0xb0000000
+      1325	0x912fe000
+      1326	0xb9403be1
+      1327	0xb8617800
+      1328	0x2a0003e0
+      1329	0x92403c00
+      1330	0xf117841f
+      1331	0x540001e1
+      1332	0x52800020
+      1333	0xb9003fe0
+      1334	0xd0000000
+      1335	0x910dc000
+      1336	0xb9403be1
+      1337	0xb8617803
+      1338	0xd0000000
+      1339	0x910de000
+      1340	0xb9403be1
+      1341	0xb8617800
+      1342	0xb9403be2
+      1343	0x2a0003e1
+      1344	0x2a0303e0
+      1345	0x94000223
+      1346	0xb9403be0
+      1347	0x11000400
+      1348	0xb9003be0
+      1349	0xb9403be0
+      1350	0x7100041f
+      1351	0x54fffca9
+      1352	0xb9403fe0
+      1353	0x7100041f
+      1354	0x54000041
+      1355	0x940001a9
+      1356	0xb0000000
+      1357	0x912fb000
+      1358	0xb900001f
+      1359	0xd2800480
+      1360	0xf2a88000
+      1361	0xb9400000
+      1362	0x12000000
+      1363	0x7100041f
+      1364	0x54000080
+      1365	0xb94033e0
+      1366	0x7100001f
+      1367	0x54000081
+      1368	0xb0000000
+      1369	0x912fc000
+      1370	0xb900001f
+      1371	0xd503201f
+      1372	0xb0000000
+      1373	0x912fc000
+      1374	0xb9400000
+      1375	0x7100041f
+      1376	0x54ffff80
+      1377	0xb0000000
+      1378	0x912fe000
+      1379	0xb9400000
+      1380	0x2a0003e1
+      1381	0x129ffe00
+      1382	0x8a000021
+      1383	0xd2800020
+      1384	0xf2b54640
+      1385	0xeb00003f
+      1386	0x54000081
+      1387	0xb9401fe0
+      1388	0x940000a6
+      1389	0x1400000c
+      1390	0xb0000000
+      1391	0x912fe000
+      1392	0xb9400000
+      1393	0x2a0003e1
+      1394	0x129ffe00
+      1395	0x8a000021
+      1396	0xd2800020
+      1397	0xf2b54c80
+      1398	0xeb00003f
+      1399	0x54000041
+      1400	0x94000102
+      1401	0x94000037
+      1402	0x52800000
+      1403	0xa8c47bfd
+      1404	0xd65f03c0
+      1405	0xa9be7bfd
+      1406	0x910003fd
+      1407	0xd503201f
+      1408	0xb0000000
+      1409	0x912fb000
+      1410	0xb9400000
+      1411	0x7100041f
+      1412	0x54ffff80
+      1413	0xd2800400
+      1414	0xf2a90100
+      1415	0xb9400000
+      1416	0xb9001fe0
+      1417	0xd51be000
+      1418	0xb9001fe0
+      1419	0xd0000000
+      1420	0x910d8000
+      1421	0xf9400400
+      1422	0x12000000
+      1423	0xb9001be0
+      1424	0xb0000000
+      1425	0x912fe000
+      1426	0xb9400400
+      1427	0x2a0003e1
+      1428	0x129ffe00
+      1429	0x8a000021
+      1430	0xd2800020
+      1431	0xf2b54640
+      1432	0xeb00003f
+      1433	0x54000081
+      1434	0xb9401be0
+      1435	0x94000077
+      1436	0x14000010
+      1437	0xb0000000
+      1438	0x912fe000
+      1439	0xb9400400
+      1440	0x2a0003e1
+      1441	0x129ffe00
+      1442	0x8a000021
+      1443	0xd2800020
+      1444	0xf2b54c80
+      1445	0xeb00003f
+      1446	0x54000061
+      1447	0x940000d3
+      1448	0x14000004
+      1449	0xb0000000
+      1450	0x912fc000
+      1451	0xb900001f
+      1452	0x94000004
+      1453	0xd503201f
+      1454	0xa8c27bfd
+      1455	0xd65f03c0
+      1456	0x14000000
+      1457	0xd280b080
+      1458	0xf2a88400
+      1459	0xb9400000
+      1460	0x2a0003e0
+      1461	0x927f0000
+      1462	0xf100081f
+      1463	0x54000101
+      1464	0xd281c400
+      1465	0xf2a88000
+      1466	0xb9400001
+      1467	0x5281ffe0
+      1468	0x72bbd6c0
+      1469	0x6b00003f
+      1470	0x54000360
+      1471	0xd280b080
+      1472	0xf2a88400
+      1473	0xb9400000
+      1474	0x2a0003e0
+      1475	0x927f0000
+      1476	0xf100081f
+      1477	0x54000100
+      1478	0xd280b080
+      1479	0xf2a88400
+      1480	0xb9400001
+      1481	0xd280b080
+      1482	0xf2a88400
+      1483	0x321f0021
+      1484	0xb9000001
+      1485	0xd281c400
+      1486	0xf2a88000
+      1487	0xb9400001
+      1488	0x5281ffe0
+      1489	0x72bbd6c0
+      1490	0x6b00003f
+      1491	0x540000c0
+      1492	0xd281c400
+      1493	0xf2a88000
+      1494	0x5281ffe1
+      1495	0x72bbd6c1
+      1496	0xb9000001
+      1497	0xd280a400
+      1498	0xf2a88400
+      1499	0xb9400001
+      1500	0xd280a400
+      1501	0xf2a88400
+      1502	0x32180021
+      1503	0xb9000001
+      1504	0xd2800700
+      1505	0xf2a88420
+      1506	0xb9400000
+      1507	0x2a0003e0
+      1508	0x92400000
+      1509	0xf100041f
+      1510	0x540000a0
+      1511	0xd2800700
+      1512	0xf2a88420
+      1513	0x52800021
+      1514	0xb9000001
+      1515	0xd2807f00
+      1516	0xf2a8c020
+      1517	0xb9400001
+      1518	0x52820660
+      1519	0x72a00240
+      1520	0x6b00003f
+      1521	0x540003e0
+      1522	0xd280af00
+      1523	0xf2a88400
+      1524	0xb9400001
+      1525	0xd280af00
+      1526	0xf2a88400
+      1527	0x321f0021
+      1528	0xb9000001
+      1529	0xd280af00
+      1530	0xf2a88400
+      1531	0xb9400001
+      1532	0xd280af00
+      1533	0xf2a88400
+      1534	0x121e7821
+      1535	0xb9000001
+      1536	0xd280af00
+      1537	0xf2a88400
+      1538	0xb9400001
+      1539	0xd280af00
+      1540	0xf2a88400
+      1541	0x321f0021
+      1542	0xb9000001
+      1543	0xd503201f
+      1544	0xd2807f00
+      1545	0xf2a8c020
+      1546	0xb9400001
+      1547	0x52820660
+      1548	0x72a00240
+      1549	0x6b00003f
+      1550	0x54ffff41
+      1551	0xd503201f
+      1552	0xd503201f
+      1553	0xd65f03c0
+      1554	0xd100c3ff
+      1555	0xb9000fe0
+      1556	0xd53800a0
+      1557	0xb9002fe0
+      1558	0xb9402fe0
+      1559	0x12000c00
+      1560	0xb9002fe0
+      1561	0xb9402fe0
+      1562	0x7100041f
+      1563	0x54000081
+      1564	0xb0000000
+      1565	0x912fc000
+      1566	0xb900001f
+      1567	0xd53e1100
+      1568	0xb9001fe0
+      1569	0xb9401fe0
+      1570	0x121d7400
+      1571	0xb9001fe0
+      1572	0xd51e1100
+      1573	0xb9001fe0
+      1574	0xd53e1100
+      1575	0xb9001fe0
+      1576	0xb0000000
+      1577	0x912fe000
+      1578	0xb9402fe1
+      1579	0xb8617801
+      1580	0x528bd820
+      1581	0x72b54640
+      1582	0x6b00003f
+      1583	0x540000a1
+      1584	0xb9401fe0
+      1585	0x121f7800
+      1586	0xb9001fe0
+      1587	0x14000004
+      1588	0xb9401fe0
+      1589	0x32000000
+      1590	0xb9001fe0
+      1591	0xb9401fe0
+      1592	0x12187800
+      1593	0xb9001fe0
+      1594	0xb9401fe0
+      1595	0x12157800
+      1596	0xb9001fe0
+      1597	0xb9401fe0
+      1598	0x32150000
+      1599	0xb9001fe0
+      1600	0xd51e1100
+      1601	0xb9001fe0
+      1602	0xd5033fdf
+      1603	0xd53c1100
+      1604	0xf90013e0
+      1605	0xf94013e0
+      1606	0x9260f800
+      1607	0xf90013e0
+      1608	0xd51c1100
+      1609	0xf90013e0
+      1610	0xd5033fdf
+      1611	0x52800260
+      1612	0xb9001fe0
+      1613	0xd51c4000
+      1614	0xb9001fe0
+      1615	0xd5033fdf
+      1616	0xd0000000
+      1617	0x910d6000
+      1618	0xb9402fe1
+      1619	0xb8617800
+      1620	0x2a0003e0
+      1621	0x927f7800
+      1622	0xf90013e0
+      1623	0xd518c000
+      1624	0xf90013e0
+      1625	0xd5033fdf
+      1626	0xd53e4000
+      1627	0xb9001fe0
+      1628	0xb9400fe0
+      1629	0x7100041f
+      1630	0x540000c1
+      1631	0xb9401fe1
+      1632	0x52800660
+      1633	0x2a000020
+      1634	0xb9001fe0
+      1635	0x14000005
+      1636	0xb9401fe1
+      1637	0x52800260
+      1638	0x2a000020
+      1639	0xb9001fe0
+      1640	0xb9401fe0
+      1641	0x121c7400
+      1642	0xb9001fe0
+      1643	0xd51e4000
+      1644	0xb9001fe0
+      1645	0xd5033fdf
+      1646	0xd0000000
+      1647	0x910d8000
+      1648	0xb9402fe1
+      1649	0xf8617800
+      1650	0xf90013e0
+      1651	0xd51e4020
+      1652	0xf90013e0
+      1653	0xd5033fdf
+      1654	0xd69f03e0
+      1655	0xd503201f
+      1656	0x9100c3ff
+      1657	0xd65f03c0
+      1658	0xd10083ff
+      1659	0xd53800a0
+      1660	0xb9001fe0
+      1661	0xb9401fe0
+      1662	0x12000c00
+      1663	0xb9001fe0
+      1664	0xb9401fe0
+      1665	0x7100041f
+      1666	0x54000081
+      1667	0x90000000
+      1668	0x912fc000
+      1669	0xb900001f
+      1670	0xd51c101f
+      1671	0xd51c111f
+      1672	0xd53e1100
+      1673	0xb9000fe0
+      1674	0xb9400fe0
+      1675	0x121d7400
+      1676	0xb9000fe0
+      1677	0xd51e1100
+      1678	0xb9000fe0
+      1679	0xd53e1100
+      1680	0xb9000fe0
+      1681	0x90000000
+      1682	0x912fe000
+      1683	0xb9401fe1
+      1684	0xb8617801
+      1685	0x528bd820
+      1686	0x72b54c80
+      1687	0x6b00003f
+      1688	0x540000a1
+      1689	0xb9400fe0
+      1690	0x121f7800
+      1691	0xb9000fe0
+      1692	0x14000004
+      1693	0xb9400fe0
+      1694	0x32000000
+      1695	0xb9000fe0
+      1696	0xb9400fe0
+      1697	0x12187800
+      1698	0xb9000fe0
+      1699	0xb9400fe0
+      1700	0x32160400
+      1701	0xb9000fe0
+      1702	0xd51e1100
+      1703	0xb9000fe0
+      1704	0xd5033fdf
+      1705	0xd53c1100
+      1706	0xf9000be0
+      1707	0xf9400be0
+      1708	0xb2610000
+      1709	0xf9000be0
+      1710	0xd51c1100
+      1711	0xf9000be0
+      1712	0xd5033fdf
+      1713	0xd53e4000
+      1714	0xb9000fe0
+      1715	0xb9400fe1
+      1716	0x528000a0
+      1717	0x2a000020
+      1718	0xb9000fe0
+      1719	0xb9400fe1
+      1720	0x12800340
+      1721	0x0a000020
+      1722	0xb9000fe0
+      1723	0xd51e4000
+      1724	0xb9000fe0
+      1725	0xd5033fdf
+      1726	0xb0000000
+      1727	0x910d6000
+      1728	0xb9401fe1
+      1729	0xb8617800
+      1730	0x2a0003e0
+      1731	0xf9000be0
+      1732	0xd518c000
+      1733	0xf9000be0
+      1734	0xd5033fdf
+      1735	0xb0000000
+      1736	0x910d8000
+      1737	0xb9401fe1
+      1738	0xf8617800
+      1739	0xf9000be0
+      1740	0xd51e4020
+      1741	0xf9000be0
+      1742	0xd5033fdf
+      1743	0xd69f03e0
+      1744	0xd503201f
+      1745	0x910083ff
+      1746	0xd65f03c0
+      1747	0xd10043ff
+      1748	0xd2810480
+      1749	0xf2a88400
+      1750	0xb9400001
+      1751	0xd2810480
+      1752	0xf2a88400
+      1753	0x321f0021
+      1754	0xb9000001
+      1755	0xd2800400
+      1756	0xf2a90100
+      1757	0x90000001
+      1758	0x912fa021
+      1759	0xb9400021
+      1760	0xb9000001
+      1761	0xd2800100
+      1762	0xf2a94020
+      1763	0xb9400001
+      1764	0xd2800100
+      1765	0xf2a94020
+      1766	0x321f0021
+      1767	0xb9000001
+      1768	0xd2a90100
+      1769	0x52800061
+      1770	0xb9000001
+      1771	0xd2800400
+      1772	0xf2a90100
+      1773	0xb9400000
+      1774	0xb9000fe0
+      1775	0xd51be000
+      1776	0xb9000fe0
+      1777	0xd503201f
+      1778	0x910043ff
+      1779	0xd65f03c0
+      1780	0xd280a580
+      1781	0xf2a88400
+      1782	0xb9400001
+      1783	0xd280a580
+      1784	0xf2a88400
+      1785	0x321f0021
+      1786	0xb9000001
+      1787	0xd280a600
+      1788	0xf2a88400
+      1789	0xb9400001
+      1790	0xd280a600
+      1791	0xf2a88400
+      1792	0x321f0021
+      1793	0xb9000001
+      1794	0xd280a680
+      1795	0xf2a88400
+      1796	0xb9400001
+      1797	0xd280a680
+      1798	0xf2a88400
+      1799	0x321f0021
+      1800	0xb9000001
+      1801	0xd280a700
+      1802	0xf2a88400
+      1803	0xb9400001
+      1804	0xd280a700
+      1805	0xf2a88400
+      1806	0x321f0021
+      1807	0xb9000001
+      1808	0xd280a780
+      1809	0xf2a88400
+      1810	0xb9400001
+      1811	0xd280a780
+      1812	0xf2a88400
+      1813	0x321f0021
+      1814	0xb9000001
+      1815	0xd280a800
+      1816	0xf2a88400
+      1817	0xb9400001
+      1818	0xd280a800
+      1819	0xf2a88400
+      1820	0x321f0021
+      1821	0xb9000001
+      1822	0xd280a880
+      1823	0xf2a88400
+      1824	0xb9400001
+      1825	0xd280a880
+      1826	0xf2a88400
+      1827	0x321f0021
+      1828	0xb9000001
+      1829	0xd280a900
+      1830	0xf2a88400
+      1831	0xb9400001
+      1832	0xd280a900
+      1833	0xf2a88400
+      1834	0x321f0021
+      1835	0xb9000001
+      1836	0xd280a980
+      1837	0xf2a88400
+      1838	0xb9400001
+      1839	0xd280a980
+      1840	0xf2a88400
+      1841	0x321f0021
+      1842	0xb9000001
+      1843	0xd280aa00
+      1844	0xf2a88400
+      1845	0xb9400001
+      1846	0xd280aa00
+      1847	0xf2a88400
+      1848	0x321f0021
+      1849	0xb9000001
+      1850	0xd280aa80
+      1851	0xf2a88400
+      1852	0xb9400001
+      1853	0xd280aa80
+      1854	0xf2a88400
+      1855	0x321f0021
+      1856	0xb9000001
+      1857	0xd2800600
+      1858	0xf2a88480
+      1859	0xb900001f
+      1860	0xd2800600
+      1861	0xf2a884a0
+      1862	0xb900001f
+      1863	0xd2800600
+      1864	0xf2a884c0
+      1865	0xb900001f
+      1866	0xd2800600
+      1867	0xf2a884e0
+      1868	0xb900001f
+      1869	0xd2800600
+      1870	0xf2a88500
+      1871	0xb900001f
+      1872	0xd2800600
+      1873	0xf2a88520
+      1874	0xb900001f
+      1875	0xd2800600
+      1876	0xf2a88540
+      1877	0xb900001f
+      1878	0xd2800600
+      1879	0xf2a88560
+      1880	0xb900001f
+      1881	0xd2800600
+      1882	0xf2a88580
+      1883	0xb900001f
+      1884	0xd2800600
+      1885	0xf2a885a0
+      1886	0xb900001f
+      1887	0xd2800600
+      1888	0xf2a885c0
+      1889	0xb900001f
+      1890	0xd503201f
+      1891	0xd65f03c0
+      1892	0xd10103ff
+      1893	0xb9000fe0
+      1894	0xb9000be1
+      1895	0xb90007e2
+      1896	0xb9400fe0
+      1897	0x92610001
+      1898	0xb2407be0
+      1899	0xeb00003f
+      1900	0x540003c9
+      1901	0xb94007e0
+      1902	0x7100001f
+      1903	0x540001c1
+      1904	0xd2801080
+      1905	0xf2a841a0
+      1906	0xb9400fe1
+      1907	0xb9000001
+      1908	0xd2801100
+      1909	0xf2a841a0
+      1910	0xb9400be1
+      1911	0xb9000001
+      1912	0xd2801000
+      1913	0xf2a841a0
+      1914	0x52800021
+      1915	0xb9000001
+      1916	0x1400005e
+      1917	0xd2801880
+      1918	0xf2a841a0
+      1919	0xb9400fe1
+      1920	0xb9000001
+      1921	0xd2801900
+      1922	0xf2a841a0
+      1923	0xb9400be1
+      1924	0xb9000001
+      1925	0xd2801800
+      1926	0xf2a841a0
+      1927	0x52800021
+      1928	0xb9000001
+      1929	0x14000051
+      1930	0xb9400fe0
+      1931	0x12004c00
+      1932	0xb90023e0
+      1933	0xb9400be0
+      1934	0x12004c00
+      1935	0xb9001fe0
+      1936	0xb90027ff
+      1937	0xd2802000
+      1938	0xf2a841e0
+      1939	0xf90017e0
+      1940	0xb9003fff
+      1941	0x1400003b
+      1942	0xf94017e0
+      1943	0xb9400000
+      1944	0xb90037e0
+      1945	0xb9003bff
+      1946	0x1400001c
+      1947	0xb9403fe0
+      1948	0x531d7001
+      1949	0xb9403be0
+      1950	0x0b000020
+      1951	0x53175800
+      1952	0xb9001be0
+      1953	0xb94023e1
+      1954	0xb9401be0
+      1955	0x6b00003f
+      1956	0x540001e8
+      1957	0xb9401fe1
+      1958	0xb9401be0
+      1959	0x9107fc00
+      1960	0xeb00003f
+      1961	0x54000143
+      1962	0xb9403be0
+      1963	0xd2800021
+      1964	0x9ac02020
+      1965	0x2a2003e0
+      1966	0xb94037e1
+      1967	0x0a000020
+      1968	0xb90037e0
+      1969	0x52800020
+      1970	0xb90027e0
+      1971	0xb9403be0
+      1972	0x11000400
+      1973	0xb9003be0
+      1974	0xb9403be0
+      1975	0x71001c1f
+      1976	0x54fffc69
+      1977	0xf94017e0
+      1978	0xb94037e1
+      1979	0xb9000001
+      1980	0xb9403fe0
+      1981	0x71007c1f
+      1982	0x54000181
+      1983	0xb94027e0
+      1984	0x7100001f
+      1985	0x54000080
+      1986	0xd2a841e0
+      1987	0x52b00001
+      1988	0xb9000001
+      1989	0xb90027ff
+      1990	0xd2802000
+      1991	0xf2a84200
+      1992	0xf90017e0
+      1993	0x14000004
+      1994	0xf94017e0
+      1995	0x91001000
+      1996	0xf90017e0
+      1997	0xb9403fe0
+      1998	0x11000400
+      1999	0xb9003fe0
+      2000	0xb9403fe0
+      2001	0x7100fc1f
+      2002	0x54fff889
+      2003	0xb94027e0
+      2004	0x7100001f
+      2005	0x540000a0
+      2006	0xd2a84200
+      2007	0x52b00001
+      2008	0xb9000001
+      2009	0xd503201f
+      2010	0xd503201f
+      2011	0x910103ff
+      2012	0xd65f03c0
+      2013	0xd2800800
+      2014	0xf2a841a0
+      2015	0xb900001f
+      2016	0xd5033f9f
+      2017	0xd2800880
+      2018	0xf2a841a0
+      2019	0x52b00001
+      2020	0xb9000001
+      2021	0xd2800900
+      2022	0xf2a841a0
+      2023	0x528bffe1
+      2024	0x72b00001
+      2025	0xb9000001
+      2026	0xd2800980
+      2027	0xf2a841a0
+      2028	0x320f83e1
+      2029	0xb9000001
+      2030	0xd2800800
+      2031	0xf2a841a0
+      2032	0x52802021
+      2033	0xb9000001
+      2034	0xd2801000
+      2035	0xf2a841a0
+      2036	0xb900001f
+      2037	0xd5033f9f
+      2038	0xd2801080
+      2039	0xf2a841a0
+      2040	0x528c0001
+      2041	0x72b00001
+      2042	0xb9000001
+      2043	0xd2801100
+      2044	0xf2a841a0
+      2045	0x12ac0001
+      2046	0xb9000001
+      2047	0xd2801180
+      2048	0xf2a841a0
+      2049	0x320f83e1
+      2050	0xb9000001
+      2051	0xd2801000
+      2052	0xf2a841a0
+      2053	0x52802021
+      2054	0xb9000001
+      2055	0xd2801800
+      2056	0xf2a841a0
+      2057	0xb900001f
+      2058	0xd5033f9f
+      2059	0xd2801880
+      2060	0xf2a841a0
+      2061	0x52b40001
+      2062	0xb9000001
+      2063	0xd2801900
+      2064	0xf2a841a0
+      2065	0x12a80001
+      2066	0xb9000001
+      2067	0xd2801980
+      2068	0xf2a841a0
+      2069	0x320f83e1
+      2070	0xb9000001
+      2071	0xd2801800
+      2072	0xf2a841a0
+      2073	0x52802021
+      2074	0xb9000001
+      2075	0xd503201f
+      2076	0xd65f03c0
+      2077	0xd100c3ff
+      2078	0xb9001fe0
+      2079	0xf9000be1
+      2080	0xf90007e2
+      2081	0xb9002fff
+      2082	0xb9401fe1
+      2083	0x528220a0
+      2084	0x72ac3940
+      2085	0x6b00003f
+      2086	0x54000420
+      2087	0xb9401fe1
+      2088	0x528220a0
+      2089	0x72ac3940
+      2090	0x6b00003f
+      2091	0x54000188
+      2092	0xb9401fe1
+      2093	0x529e01a0
+      2094	0x72aaa220
+      2095	0x6b00003f
+      2096	0x54000560
+      2097	0xb9401fe1
+      2098	0x529b4f40
+      2099	0x72ab6a80
+      2100	0x6b00003f
+      2101	0x54000a40
+      2102	0x1400005f
+      2103	0xb9401fe1
+      2104	0x529e01a0
+      2105	0x72bb4f40
+      2106	0x6b00003f
+      2107	0x540005a0
+      2108	0xb9401fe1
+      2109	0x529b4f40
+      2110	0x72bfdda0
+      2111	0x6b00003f
+      2112	0x540005c0
+      2113	0xb9401fe1
+      2114	0x529b4f40
+      2115	0x72b96a80
+      2116	0x6b00003f
+      2117	0x54000660
+      2118	0x1400004f
+      2119	0xd2801000
+      2120	0xf2a95820
+      2121	0xf90013e0
+      2122	0xb9002bff
+      2123	0x1400000a
+      2124	0xf94013e0
+      2125	0x12800001
+      2126	0xb9000001
+      2127	0xf94013e0
+      2128	0x91001000
+      2129	0xf90013e0
+      2130	0xb9402be0
+      2131	0x11000400
+      2132	0xb9002be0
+      2133	0xb9402be0
+      2134	0x7100301f
+      2135	0x54fffea9
+      2136	0x52800020
+      2137	0xb9002fe0
+      2138	0x1400003b
+      2139	0xf9400be0
+      2140	0xb9400001
+      2141	0x52818220
+      2142	0x72a62c40
+      2143	0x6b00003f
+      2144	0x54000081
+      2145	0xd53e1100
+      2146	0xb9002fe0
+      2147	0x14000032
+      2148	0x5297dde0
+      2149	0x72bbd5a0
+      2150	0xb9002fe0
+      2151	0x1400002e
+      2152	0xf9400be0
+      2153	0xb9400000
+      2154	0x2a0003e0
+      2155	0xb9400000
+      2156	0xb9002fe0
+      2157	0x14000028
+      2158	0xf9400be0
+      2159	0xb9400000
+      2160	0x2a0003e0
+      2161	0xaa0003e1
+      2162	0xf94007e0
+      2163	0xb9400000
+      2164	0xb9000020
+      2165	0x52800020
+      2166	0xb9002fe0
+      2167	0x1400001e
+      2168	0xf9400be0
+      2169	0xb9400000
+      2170	0x2a0003e0
+      2171	0xb9400001
+      2172	0xf94007e0
+      2173	0xb9400000
+      2174	0x2a2003e0
+      2175	0xf9400be2
+      2176	0xb9400042
+      2177	0x2a0203e2
+      2178	0x0a000020
+      2179	0xb9000040
+      2180	0x52800020
+      2181	0xb9002fe0
+      2182	0x1400000f
+      2183	0xf9400be0
+      2184	0xb9400000
+      2185	0x2a0003e0
+      2186	0xb9400001
+      2187	0xf94007e0
+      2188	0xb9400000
+      2189	0xf9400be2
+      2190	0xb9400042
+      2191	0x2a0203e2
+      2192	0x2a000020
+      2193	0xb9000040
+      2194	0x52800020
+      2195	0xb9002fe0
+      2196	0xd503201f
+      2197	0xb9402fe0
+      2198	0x9100c3ff
+      2199	0xd65f03c0
+      2200	0xa9be7bfd
+      2201	0x910003fd
+      2202	0xaa0003e0
+      2203	0xb9001fe0
+      2204	0xaa0103e0
+      2205	0xb90017e0
+      2206	0xaa0203e0
+      2207	0xb90013e0
+      2208	0x910043e1
+      2209	0x910053e0
+      2210	0xaa0103e2
+      2211	0xaa0003e1
+      2212	0xb9401fe0
+      2213	0x97ffff78
+      2214	0xb9001be0
+      2215	0xb9401be0
+      2216	0xaa0003e0
+      2217	0xd5033f9f
+      2218	0xd5033fdf
+      2219	0xd69f03e0
+      2220	0xd503201f
+      2221	0xa8c27bfd
+      2222	0xd65f03c0
+      2223	0x17ffffe9
+      2224	0xd503201f
+      2225	0xd65f03c0
+      2226	0x17ffffe6
+      2227	0xd503201f
+      2228	0xd65f03c0
+      2229	0x00000000
+      2230	0xaa0003e1
+      2231	0xd2800003
+      2232	0xd2800002
+      2233	0x52800000
+      2234	0x14000046
+      2235	0x00000000
+      2236	0xa9be7bfd
+      2237	0xd2800001
+      2238	0x910003fd
+      2239	0xf9000bf3
+      2240	0x2a0003f3
+      2241	0x94000067
+      2242	0x90000000
+      2243	0xf945e000
+      2244	0xf9402c01
+      2245	0xb4000041
+      2246	0xd63f0020
+      2247	0x2a1303e0
+      2248	0x940000a2
+      2249	0x00000000
+      2250	0xa9be7bfd
+      2251	0x90000001
+      2252	0x90000000
+      2253	0x910003fd
+      2254	0xa90153f3
+      2255	0xf945d833
+      2256	0xf945dc14
+      2257	0xcb140273
+      2258	0x9343fe73
+      2259	0xb40000b3
+      2260	0xd1000673
+      2261	0xf8737a80
+      2262	0xd63f0000
+      2263	0xb5ffffb3
+      2264	0xa94153f3
+      2265	0xa8c27bfd
+      2266	0x17fffb33
+      2267	0x00000000
+      2268	0xa9bd7bfd
+      2269	0x90000001
+      2270	0x90000000
+      2271	0x910003fd
+      2272	0xa90153f3
+      2273	0xf945e434
+      2274	0xf90013f5
+      2275	0xf945e815
+      2276	0xcb150294
+      2277	0x9343fe94
+      2278	0xb40000f4
+      2279	0xd2800013
+      2280	0xf8737aa0
+      2281	0x91000673
+      2282	0xd63f0000
+      2283	0xeb13029f
+      2284	0x54ffff81
+      2285	0x97fffb1a
+      2286	0x90000001
+      2287	0x90000000
+      2288	0xf945ec34
+      2289	0xf945f015
+      2290	0xcb150294
+      2291	0x9343fe94
+      2292	0xb40000f4
+      2293	0xd2800013
+      2294	0xf8737aa0
+      2295	0x91000673
+      2296	0xd63f0000
+      2297	0xeb13029f
+      2298	0x54ffff81
+      2299	0xa94153f3
+      2300	0xf94013f5
+      2301	0xa8c37bfd
+      2302	0xd65f03c0
+      2303	0x00000000
+      2304	0x90000004
+      2305	0xf945e085
+      2306	0xf940fca4
+      2307	0xb40002c4
+      2308	0xb9400885
+      2309	0x71007cbf
+      2310	0x540003ec
+      2311	0x93407ca6
+      2312	0x34000160
+      2313	0x8b060c89
+      2314	0x52800027
+      2315	0x7100081f
+      2316	0x1ac520e0
+      2317	0xf9008922
+      2318	0xb9431082
+      2319	0x2a000042
+      2320	0xb9031082
+      2321	0xf9010923
+      2322	0x54000140
+      2323	0x910008c6
+      2324	0x110004a5
+      2325	0xb9000885
+      2326	0x52800000
+      2327	0xf8267881
+      2328	0xd65f03c0
+      2329	0x910800a4
+      2330	0xf900fca4
+      2331	0x17ffffe9
+      2332	0xb9431482
+      2333	0x910008c6
+      2334	0x110004a5
+      2335	0xb9000885
+      2336	0x2a000040
+      2337	0xb9031480
+      2338	0x52800000
+      2339	0xf8267881
+      2340	0x17fffff4
+      2341	0x12800000
+      2342	0xd65f03c0
+      2343	0x00000000
+      2344	0xa9bb7bfd
+      2345	0x90000002
+      2346	0x910003fd
+      2347	0xa9046bf9
+      2348	0x2a0003fa
+      2349	0xf945e059
+      2350	0xa9025bf5
+      2351	0xaa0103f6
+      2352	0xa90153f3
+      2353	0xa90363f7
+      2354	0x52800037
+      2355	0xf940ff35
+      2356	0xb40001d5
+      2357	0xb9400ab3
+      2358	0x71000674
+      2359	0x54000164
+      2360	0x8b33ceb3
+      2361	0x91002273
+      2362	0xb40001d6
+      2363	0xf9410260
+      2364	0xeb16001f
+      2365	0x54000160
+      2366	0x51000694
+      2367	0xd1002273
+      2368	0x3100069f
+      2369	0x54ffff21
+      2370	0xa94153f3
+      2371	0xa9425bf5
+      2372	0xa94363f7
+      2373	0xa9446bf9
+      2374	0xa8c57bfd
+      2375	0xd65f03c0
+      2376	0xb9400aa0
+      2377	0xf9400262
+      2378	0x51000400
+      2379	0x6b14001f
+      2380	0x54000320
+      2381	0xf900027f
+      2382	0xb4fffe02
+      2383	0x910442a0
+      2384	0xb9420001
+      2385	0x1ad422e3
+      2386	0xb9400ab8
+      2387	0x6a01007f
+      2388	0x54000121
+      2389	0xd63f0040
+      2390	0xb9400aa0
+      2391	0x6b18001f
+      2392	0x54fffb61
+      2393	0xf940ff20
+      2394	0xeb15001f
+      2395	0x54fffc60
+      2396	0x17ffffd7
+      2397	0xb9420401
+      2398	0xf9408260
+      2399	0x6a01007f
+      2400	0x540000e1
+      2401	0xaa0003e1
+      2402	0x2a1a03e0
+      2403	0xd63f0040
+      2404	0x17fffff2
+      2405	0xb9000ab4
+      2406	0x17ffffe8
+      2407	0xd63f0040
+      2408	0x17ffffee
+      2409	0x00000000
+      2410	0x14000000
+      2411	0x00000000
+      2412	0x00000000
+      2413	0x00000000
+      2414	0x00000000
+      2415	0x00000000
+      2416	0x0e004c10
+      2417	0x00000000
+      2418	0x00000000
+      2419	0x00000000
+      2420	0x00000000
+      2421	0x00000000
+      2422	0x00000000
+      2423	0x00000000
+      2424	0x00000000
+      2425	0x00000000
+      2426	0x01e84800
+      2427	0x00000001
+      2428	0x00000001
+      2429	0x00000000
+      2430	0xaa645ec3
+      2431	0xaa645ec3
+      2432	0x0badf00d
+      2433	0x0badf00d
+      2434	0x1badf00d
+      2435	0x1badf00d
+      2436	0x00000000
+      2437	0x00000000
+      2438	0x0e005148
+      2439	0x00000000
+      2440	0x0e0051f8
+      2441	0x00000000
+      2442	0x0e0052a8
+      2443	0x00000000
+      2444	0x00000000
+      2445	0x00000000
+      2446	0x00000000
+      2447	0x00000000
+      2448	0x00000000
+      2449	0x00000000
+      2450	0x00000000
+      2451	0x00000000
+      2452	0x00000000
+      2453	0x00000000
+      2454	0x00000000
+      2455	0x00000000
+      2456	0x00000000
+      2457	0x00000000
+      2458	0x00000000
+      2459	0x00000000
+      2460	0x00000000
+      2461	0x00000000
+      2462	0x00000000
+      2463	0x00000000
+      2464	0x00000000
+      2465	0x00000000
+      2466	0x00000000
+      2467	0x00000000
+      2468	0x00000000
+      2469	0x00000000
+      2470	0x00000000
+      2471	0x00000000
+      2472	0x00000000
+      2473	0x00000000
+      2474	0x00000000
+      2475	0x00000000
+      2476	0x00000000
+      2477	0x00000000
+      2478	0x00000000
+      2479	0x00000000
+      2480	0x00000000
+      2481	0x00000000
+      2482	0x00000000
+      2483	0x00000000
+      2484	0x00000000
+      2485	0x00000000
+      2486	0x00000000
+      2487	0x00000000
+      2488	0x00000000
+      2489	0x00000000
+      2490	0x00000000
+      2491	0x00000000
+      2492	0x00000000
+      2493	0x00000000
+      2494	0x00000001
+      2495	0x00000000
+      2496	0xabcd330e
+      2497	0xe66d1234
+      2498	0x0005deec
+      2499	0x0000000b
+      2500	0x00000000
+      2501	0x00000000
+      2502	0x00000000
+      2503	0x00000000
+      2504	0x00000000
+      2505	0x00000000
+      2506	0x00000000
+      2507	0x00000000
+      2508	0x00000000
+      2509	0x00000000
+      2510	0x00000000
+      2511	0x00000000
+      2512	0x00000000
+      2513	0x00000000
+      2514	0x00000000
+      2515	0x00000000
+      2516	0x00000000
+      2517	0x00000000
+      2518	0x00000000
+      2519	0x00000000
+      2520	0x00000000
+      2521	0x00000000
+      2522	0x00000000
+      2523	0x00000000
+      2524	0x00000000
+      2525	0x00000000
+      2526	0x00000000
+      2527	0x00000000
+      2528	0x00000000
+      2529	0x00000000
+      2530	0x00000000
+      2531	0x00000000
+      2532	0x00000000
+      2533	0x00000000
+      2534	0x00000000
+      2535	0x00000000
+      2536	0x00000000
+      2537	0x00000000
+      2538	0x00000000
+      2539	0x00000000
+      2540	0x00000000
+      2541	0x00000000
+      2542	0x00000000
+      2543	0x00000000
+      2544	0x00000000
+      2545	0x00000000
+      2546	0x00000000
+      2547	0x00000000
+      2548	0x00000000
+      2549	0x00000000
+      2550	0x00000000
+      2551	0x00000000
+      2552	0x00000000
+      2553	0x00000000
+      2554	0x00000000
+      2555	0x00000000
+      2556	0x00000000
+      2557	0x00000000
+      2558	0x00000000
+      2559	0x00000000
+      2560	0x00000000
+      2561	0x00000000
+      2562	0x00000000
+      2563	0x00000000
+      2564	0x00000000
+      2565	0x00000000
+      2566	0x00000000
+      2567	0x00000000
+      2568	0x00000000
+      2569	0x00000000
+      2570	0x00000000
+      2571	0x00000000
+      2572	0x00000000
+      2573	0x00000000
+      2574	0x00000000
+      2575	0x00000000
+      2576	0x00000000
+      2577	0x00000000
+      2578	0x00000000
+      2579	0x00000000
+      2580	0x00000000
+      2581	0x00000000
+      2582	0x00000000
+      2583	0x00000000
+      2584	0x00000000
+      2585	0x00000000
+      2586	0x00000000
+      2587	0x00000000
+      2588	0x00000000
+      2589	0x00000000
+      2590	0x00000000
+      2591	0x00000000
+      2592	0x00000000
+      2593	0x00000000
+      2594	0x00000000
+      2595	0x00000000
+      2596	0x00000000
+      2597	0x00000000
+      2598	0x00000000
+      2599	0x00000000
+      2600	0x00000000
+      2601	0x00000000
+      2602	0x00000000
+      2603	0x00000000
+      2604	0x00000000
+      2605	0x00000000
+      2606	0x00000000
+      2607	0x00000000
+      2608	0x00000000
+      2609	0x00000000
+      2610	0x00000000
+      2611	0x00000000
+      2612	0x00000000
+      2613	0x00000000
+      2614	0x00000000
+      2615	0x00000000
+      2616	0x00000000
+      2617	0x00000000
+      2618	0x00000000
+      2619	0x00000000
+      2620	0x00000000
+      2621	0x00000000
+      2622	0x00000000
+      2623	0x00000000
+      2624	0x00000000
+      2625	0x00000000
+      2626	0x00000000
+      2627	0x00000000
+      2628	0x00000000
+      2629	0x00000000
+      2630	0x00000000
+      2631	0x00000000
+      2632	0x00000000
+      2633	0x00000000
+      2634	0x00000000
+      2635	0x00000000
+      2636	0x00000000
+      2637	0x00000000
+      2638	0x00000000
+      2639	0x00000000
+      2640	0x00000000
+      2641	0x00000000
+      2642	0x00000000
+      2643	0x00000000
+      2644	0x00000000
+      2645	0x00000000
+      2646	0x00000000
+      2647	0x00000000
+      2648	0x00000000
+      2649	0x00000000
+      2650	0x00000000
+      2651	0x00000000
+      2652	0x00000000
+      2653	0x00000000
+      2654	0x00000000
+      2655	0x00000000
+      2656	0x00000000
+      2657	0x00000000
+      2658	0x00000000
+      2659	0x00000000
+      2660	0x00000000
+      2661	0x00000000
+      2662	0x00000000
+      2663	0x00000000
+      2664	0x00000000
+      2665	0x00000000
+      2666	0x00000000
+      2667	0x00000000
+      2668	0x00000000
+      2669	0x00000000
+      2670	0x00000000
+      2671	0x00000000
+      2672	0x00000000
+      2673	0x00000000
+      2674	0x00000000
+      2675	0x00000000
+      2676	0x00000000
+      2677	0x00000000
+      2678	0x00000000
+      2679	0x00000000
+      2680	0x00000000
+      2681	0x00000000
+      2682	0x00000000
+      2683	0x00000000
+      2684	0x00000000
+      2685	0x00000000
+      2686	0x00000000
+      2687	0x00000000
+      2688	0x00000000
+      2689	0x00000000
+      2690	0x00000000
+      2691	0x00000000
+      2692	0x00000000
+      2693	0x00000000
+      2694	0x00000000
+      2695	0x00000000
+      2696	0x00000000
+      2697	0x00000000
+      2698	0x00000000
+      2699	0x00000000
+      2700	0x00000000
+      2701	0x00000000
+      2702	0x00000000
+      2703	0x00000000
+      2704	0x00000000
+      2705	0x00000000
+      2706	0x00000000
+      2707	0x00000000
+      2708	0x00000000
+      2709	0x00000000
+      2710	0x00000000
+      2711	0x00000000
+      2712	0x00000000
+      2713	0x00000000
+      2714	0x00000000
+      2715	0x00000000
+      2716	0x00000000
+      2717	0x00000000
+      2718	0x00000000
+      2719	0x00000000
+      2720	0x00000000
+      2721	0x00000000
+      2722	0x00000000
+      2723	0x00000000
+      2724	0x00000000
+      2725	0x00000000
+      2726	0x00000000
+      2727	0x00000000
+      2728	0x00000000
+      2729	0x00000000
+      2730	0x00000000
+      2731	0x00000000
+      2732	0x00000000
+      2733	0x00000000
+      2734	0x00000000
+      2735	0x00000000
+      2736	0x00000000
+      2737	0x00000000
+      2738	0x00000000
+      2739	0x00000000
+      2740	0x00000000
+      2741	0x00000000
+      2742	0x00000000
+      2743	0x00000000
+      2744	0x00000000
+      2745	0x00000000
+      2746	0x00000000
+      2747	0x00000000
+      2748	0x00000000
+      2749	0x00000000
+      2750	0x00000000
+      2751	0x00000000
+      2752	0x00000000
+      2753	0x00000000
+      2754	0x00000000
+      2755	0x00000000
+      2756	0x00000000
+      2757	0x00000000
+      2758	0x00000000
+      2759	0x00000000
+      2760	0x00000000
+      2761	0x00000000
+      2762	0x00000000
+      2763	0x00000000
+      2764	0x00000000
+      2765	0x00000000
+      2766	0x00000000
+      2767	0x00000000
+      2768	0x00000000
+      2769	0x00000000
+      2770	0x00000000
+      2771	0x00000000
+      2772	0x00000000
+      2773	0x00000000
+      2774	0x00000000
+      2775	0x00000000
+      2776	0x00000000
+      2777	0x00000000
+      2778	0x00000000
+      2779	0x00000000
+      2780	0x00000000
+      2781	0x00000000
+      2782	0x00000000
+      2783	0x00000000
+      2784	0x00000000
+      2785	0x00000000
+      2786	0x00000000
+      2787	0x00000000
+      2788	0x00000000
+      2789	0x00000000
+      2790	0x00000000
+      2791	0x00000000
+      2792	0x00000000
+      2793	0x00000000
+      2794	0x00000000
+      2795	0x00000000
+      2796	0x00000000
+      2797	0x00000000
+      2798	0x00000000
+      2799	0x00000000
+      2800	0x00000000
+      2801	0x00000000
+      2802	0x00000000
+      2803	0x00000000
+      2804	0x00000000
+      2805	0x00000000
+      2806	0x00000000
+      2807	0x00000000
+      2808	0x00000000
+      2809	0x00000000
+      2810	0x00000000
+      2811	0x00000000
+      2812	0x00000000
+      2813	0x00000000
+      2814	0x00000000
+      2815	0x00000000
+      2816	0x00000000
+      2817	0x00000000
+      2818	0x00000000
+      2819	0x00000000
+      2820	0x00000000
+      2821	0x00000000
+      2822	0x00000000
+      2823	0x00000000
+      2824	0x00000000
+      2825	0x00000000
+      2826	0x00000000
+      2827	0x00000000
+      2828	0x00000000
+      2829	0x00000000
+      2830	0x00000000
+      2831	0x00000000
+      2832	0x00000000
+      2833	0x00000000
+      2834	0x00000000
+      2835	0x00000000
+      2836	0x00000000
+      2837	0x00000000
+      2838	0x00000000
+      2839	0x00000000
+      2840	0x00000000
+      2841	0x00000000
+      2842	0x00000000
+      2843	0x00000000
+      2844	0x00000000
+      2845	0x00000000
+      2846	0x00000000
+      2847	0x00000000
+      2848	0x00000000
+      2849	0x00000000
+      2850	0x00000000
+      2851	0x00000000
+      2852	0x00000000
+      2853	0x00000000
+      2854	0x00000000
+      2855	0x00000000
+      2856	0x00000000
+      2857	0x00000000
+      2858	0x00000000
+      2859	0x00000000
+      2860	0x00000000
+      2861	0x00000000
+      2862	0x00000000
+      2863	0x00000000
+      2864	0x00000000
+      2865	0x00000000
+      2866	0x00000000
+      2867	0x00000000
+      2868	0x00000000
+      2869	0x00000000
+      2870	0x00000000
+      2871	0x00000000
+      2872	0x00000000
+      2873	0x00000000
+      2874	0x00000000
+      2875	0x00000000
+      2876	0x00000000
+      2877	0x00000000
+      2878	0x00000000
+      2879	0x00000000
+      2880	0x00000000
+      2881	0x00000000
+      2882	0x00000000
+      2883	0x00000000
+      2884	0x00000000
+      2885	0x00000000
+      2886	0x00000000
+      2887	0x00000000
+      2888	0x00000000
+      2889	0x00000000
+      2890	0x00000000
+      2891	0x00000000
+      2892	0x00000000
+      2893	0x00000000
+      2894	0x00000000
+      2895	0x00000000
+      2896	0x00000000
+      2897	0x00000000
+      2898	0x00000000
+      2899	0x00000000
+      2900	0x00000000
+      2901	0x00000000
+   }
+
+   set EL3_load_addr 0x000000000e002600
+   set EL3_entry_point 0xe003000
+   set EL3_STGENFreqHz_addr 0x000000000e004be8
+   set EL3_STACK_BASE_addr 0x000000000e006000
+
+   if { $_EL3_LAUNCHER_LOADED == "no" } {
+      set nb_words [array size el3_launcher_bin]
+      if { $core_name == "A35_0" } {
+         # Use A35_0 port to access SYSRAM
+         set _REG_ACCESS_TARGET_SAVED $_REG_ACCESS_TARGET
+         set _REG_ACCESS_TARGET $_CHIPNAME.a35_0
+         echo "... Loading EL3_Launcher at $EL3_load_addr ($nb_words Words, [expr {$nb_words*4}] Bytes) ..."
+         $_CHIPNAME.a35_0 array2mem el3_launcher_bin 32 $EL3_load_addr $nb_words
+         # Patch HSI value to the one specified in option
+         echo "... Patching HSI_FREQ for STGEN to ${_HSI_FREQ} Hz ..."
+         WriteReg $EL3_STGENFreqHz_addr ${_HSI_FREQ}
+         echo [format "... Filling EL3/EL1 Interface for A35_0 at 0x%08x ..." $EL3_STACK_BASE_addr]
+         # Fill a35_0 EL3_EL1_Interface to configure EL3_Launcher
+         #   - EL1 entry-point (Reset_Handler) address
+         #     uint32_t el1_testapp_entrypoint_addr;
+         #       Set entry-point to (start of core 0 mem | 1) to run Aarch32 EL1 stub in Thumb because application is not loaded yet
+         WriteReg [expr {$EL3_STACK_BASE_addr+$EL1_TESTAPP_ENTRYPOINT_ADDR_OFS}]  [expr {${_A35_0_MEM_START} | 0x1}]
+         #   - EL1 Vector table address
+         #     uint32_t el1_vector_table_base_addr;
+         #       Set vector table base address to start of core 0 because application is not loaded yet
+         WriteReg [expr {$EL3_STACK_BASE_addr+$EL1_VECTOR_TABLE_BASE_ADDR_OFS}] ${_A35_0_MEM_START}
+         #   - data "EL3S" in ASCII format
+         #     uint32_t interface_ascii_id1;
+         #       Indicate this EL3_EL1 interface is valid
+         #         But ... it is "don't care" for a35_1
+         WriteReg [expr {$EL3_STACK_BASE_addr+$INTERFACE_ASCII_ID_OFS}] ${EL3_EL1_INTERFACE_ID1_SWITCHER}
+         #   - EL1 A35_0 (AMP) / A35_* (SMP) security state
+         #     uint32_t el1_testapp_security_state;
+         #       Set a35_0 security state to "Secure"
+         if { $_A35_0_SECURE == "no" } {
+            WriteReg [expr {$EL3_STACK_BASE_addr+$EL1_TESTAPP_SECURITY_STATE_OFS}] ${NON_SECURE_EL1_AA32_TESTAPP}
+         } else {
+            WriteReg [expr {$EL3_STACK_BASE_addr+$EL1_TESTAPP_SECURITY_STATE_OFS}] ${SECURE_EL1_AA32_TESTAPP}
+         }
+         #   - EL1 application memory start
+         #     uint32_t el1_testapp_mem_start_addr;
+         WriteReg [expr {$EL3_STACK_BASE_addr+$EL1_TESTAPP_MEM_START_ADDR_OFS}] ${_A35_0_MEM_START}
+         #   - EL1 application memory end
+         #     uint32_t el1_testapp_mem_end_addr;
+         WriteReg [expr {$EL3_STACK_BASE_addr+$EL1_TESTAPP_MEM_END_ADDR_OFS}] ${_A35_0_MEM_END}
+         #   - EL1 A35_1 interface address
+         #     uint32_t el1_a35_1_interface_addr;
+         if { $_A35_1_CORE_START == "no" } {
+            # Set a35 1 interface address to 0 because we are not going to switch A35_1
+            echo "... Setting EL3/EL1 Interface pointer for A35_1 to 0"
+            set EL3_IF_CA35_1_addr 0x00000000
+            WriteReg [expr {$EL3_STACK_BASE_addr+$EL1_A35_1_INTERFACE_ADDR_OFS}] 0x00000000
+         } else {
+            # Set a35 1 I/F address to memory after a35_0 I/F to be able to specify different configurations for a35_0 and a35_1
+            set EL3_IF_CA35_1_addr ${_A35_1_MEM_START}
+            echo [format "... Filling EL3/EL1 Interface for A35_1 at 0x%08x ..." $EL3_IF_CA35_1_addr]
+            WriteReg [expr {$EL3_STACK_BASE_addr+$EL1_A35_1_INTERFACE_ADDR_OFS}] $EL3_IF_CA35_1_addr
+            # Fill a35_1 EL3_EL1_Interface to configure EL3_Launcher
+            #   - EL1 entry-point (Reset_Handler) address
+            #     uint32_t el1_testapp_entrypoint_addr;
+            #       Set entry-point to (start of core 1 mem | 1) to run Aarch32 EL1 stub in Thumb because application is not loaded yet
+            WriteReg [expr {$EL3_IF_CA35_1_addr+$EL1_TESTAPP_ENTRYPOINT_ADDR_OFS}] [expr {${_A35_1_MEM_START} | 0x1}]
+            #   - EL1 Vector table address
+            #     uint32_t el1_vector_table_base_addr;
+            #       Set vector table base address to start of core 1 because application is not loaded yet
+            WriteReg [expr {$EL3_IF_CA35_1_addr+$EL1_VECTOR_TABLE_BASE_ADDR_OFS}] ${_A35_1_MEM_START}
+            #   - data "EL3S" in ASCII format
+            #     uint32_t interface_ascii_id1;
+            #       Indicate this EL3_EL1 interface is valid
+            #         But ... it is "don't care" for a35_1
+            WriteReg [expr {$EL3_IF_CA35_1_addr+$INTERFACE_ASCII_ID_OFS}] ${EL3_EL1_INTERFACE_ID1_SWITCHER}
+            #   - EL1 A35_0 (AMP) / A35_* (SMP) security state
+            #     uint32_t el1_testapp_security_state;
+            #       Set a35_0 security state to "Secure"
+            if { $_A35_1_SECURE == "no" } {
+               WriteReg [expr {$EL3_IF_CA35_1_addr+$EL1_TESTAPP_SECURITY_STATE_OFS}] ${NON_SECURE_EL1_AA32_TESTAPP}
+            } else {
+               WriteReg [expr {$EL3_IF_CA35_1_addr+$EL1_TESTAPP_SECURITY_STATE_OFS}] ${SECURE_EL1_AA32_TESTAPP}
+            }
+            #   - EL1 application memory start
+            #     uint32_t el1_testapp_mem_start_addr;
+            WriteReg [expr {$EL3_IF_CA35_1_addr+$EL1_TESTAPP_MEM_START_ADDR_OFS}] ${_A35_1_MEM_START}
+            #   - EL1 application memory end
+            #     uint32_t el1_testapp_mem_end_addr;
+            WriteReg [expr {$EL3_IF_CA35_1_addr+$EL1_TESTAPP_MEM_END_ADDR_OFS}] ${_A35_1_MEM_END}
+            #   - EL1 A35_1 interface address
+            #     uint32_t el1_a35_1_interface_addr;
+            #         "don't care" for a35_1
+            WriteReg [expr {$EL3_IF_CA35_1_addr+$EL1_A35_1_INTERFACE_ADDR_OFS}] 0x00000000
+            #   - Reserved to align structure
+            #     uint32_t dummy;
+            #       Just fill it with 0 for cleanness ...
+            WriteReg [expr {$EL3_IF_CA35_1_addr+$DUMMY_OFS}] 0x00000000
+         }
+         #   - Reserved to align structure
+         #     uint32_t dummy;
+         #       Just fill it with 0 for cleanness ...
+         WriteReg [expr {$EL3_STACK_BASE_addr+$DUMMY_OFS}] 0x00000000
+         set _EL3_LAUNCHER_LOADED yes
+         echo [format "<D> A35_0 el1_testapp_entrypoint_addr       0x%08x=0x%08x" [expr {$EL3_STACK_BASE_addr+$EL1_TESTAPP_ENTRYPOINT_ADDR_OFS}] [ReadReg [expr {$EL3_STACK_BASE_addr+$EL1_TESTAPP_ENTRYPOINT_ADDR_OFS}]]]
+         echo [format "<D> A35_0 el1_vector_table_base_addr        0x%08x=0x%08x" [expr {$EL3_STACK_BASE_addr+$EL1_VECTOR_TABLE_BASE_ADDR_OFS}]  [ReadReg [expr {$EL3_STACK_BASE_addr+$EL1_VECTOR_TABLE_BASE_ADDR_OFS}]]]
+         echo [format "<D> A35_0 interface_ascii_id1               0x%08x=0x%08x" [expr {$EL3_STACK_BASE_addr+$INTERFACE_ASCII_ID_OFS}]          [ReadReg [expr {$EL3_STACK_BASE_addr+$INTERFACE_ASCII_ID_OFS}]]]
+         echo [format "<D> A35_0 el1_testapp_security_state        0x%08x=0x%08x" [expr {$EL3_STACK_BASE_addr+$EL1_TESTAPP_SECURITY_STATE_OFS}]  [ReadReg [expr {$EL3_STACK_BASE_addr+$EL1_TESTAPP_SECURITY_STATE_OFS}]]]
+         echo [format "<D> A35_0 el1_testapp_mem_start_addr        0x%08x=0x%08x" [expr {$EL3_STACK_BASE_addr+$EL1_TESTAPP_MEM_START_ADDR_OFS}]  [ReadReg [expr {$EL3_STACK_BASE_addr+$EL1_TESTAPP_MEM_START_ADDR_OFS}]]]
+         echo [format "<D> A35_0 el1_testapp_mem_end_addr          0x%08x=0x%08x" [expr {$EL3_STACK_BASE_addr+$EL1_TESTAPP_MEM_END_ADDR_OFS}]    [ReadReg [expr {$EL3_STACK_BASE_addr+$EL1_TESTAPP_MEM_END_ADDR_OFS}]]]
+         echo [format "<D> A35_0 el1_a35_1_interface_addr          0x%08x=0x%08x" [expr {$EL3_STACK_BASE_addr+$EL1_A35_1_INTERFACE_ADDR_OFS}]    [ReadReg [expr {$EL3_STACK_BASE_addr+$EL1_A35_1_INTERFACE_ADDR_OFS}]]]
+         echo [format "<D> A35_0 dummy                             0x%08x=0x%08x" [expr {$EL3_STACK_BASE_addr+$DUMMY_OFS}]                       [ReadReg [expr {$EL3_STACK_BASE_addr+$DUMMY_OFS}]]]
+         if { $EL3_IF_CA35_1_addr != 0 } {
+            echo [format "<D> A35_1 el1_testapp_entrypoint_addr       0x%08x=0x%08x" [expr {$EL3_IF_CA35_1_addr+$EL1_TESTAPP_ENTRYPOINT_ADDR_OFS}] [ReadReg [expr {$EL3_IF_CA35_1_addr+$EL1_TESTAPP_ENTRYPOINT_ADDR_OFS}]]]
+            echo [format "<D> A35_1 el1_vector_table_base_addr        0x%08x=0x%08x" [expr {$EL3_IF_CA35_1_addr+$EL1_VECTOR_TABLE_BASE_ADDR_OFS}]  [ReadReg [expr {$EL3_IF_CA35_1_addr+$EL1_VECTOR_TABLE_BASE_ADDR_OFS}]]]
+            echo [format "<D> A35_1 interface_ascii_id1               0x%08x=0x%08x" [expr {$EL3_IF_CA35_1_addr+$INTERFACE_ASCII_ID_OFS}]          [ReadReg [expr {$EL3_IF_CA35_1_addr+$INTERFACE_ASCII_ID_OFS}]]]
+            echo [format "<D> A35_1 el1_testapp_security_state        0x%08x=0x%08x" [expr {$EL3_IF_CA35_1_addr+$EL1_TESTAPP_SECURITY_STATE_OFS}]  [ReadReg [expr {$EL3_IF_CA35_1_addr+$EL1_TESTAPP_SECURITY_STATE_OFS}]]]
+            echo [format "<D> A35_1 el1_testapp_mem_start_addr        0x%08x=0x%08x" [expr {$EL3_IF_CA35_1_addr+$EL1_TESTAPP_MEM_START_ADDR_OFS}]  [ReadReg [expr {$EL3_IF_CA35_1_addr+$EL1_TESTAPP_MEM_START_ADDR_OFS}]]]
+            echo [format "<D> A35_1 el1_testapp_mem_end_addr          0x%08x=0x%08x" [expr {$EL3_IF_CA35_1_addr+$EL1_TESTAPP_MEM_END_ADDR_OFS}]    [ReadReg [expr {$EL3_IF_CA35_1_addr+$EL1_TESTAPP_MEM_END_ADDR_OFS}]]]
+            echo [format "<D> A35_1 el1_a35_1_interface_addr          0x%08x=0x%08x" [expr {$EL3_IF_CA35_1_addr+$EL1_A35_1_INTERFACE_ADDR_OFS}]    [ReadReg [expr {$EL3_IF_CA35_1_addr+$EL1_A35_1_INTERFACE_ADDR_OFS}]]]
+            echo [format "<D> A35_1 dummy                             0x%08x=0x%08x" [expr {$EL3_IF_CA35_1_addr+$DUMMY_OFS}]                       [ReadReg [expr {$EL3_IF_CA35_1_addr+$DUMMY_OFS}]]]
+         }
+         # Restore default port for memory and registers accesses
+         set _REG_ACCESS_TARGET $_REG_ACCESS_TARGET_SAVED
+      } elseif  { $core_name == "A35_1" } {
+         # If EL3_Launcher has not yet been loaded and executed on A35_0
+         # we have to do it because EL3_Launcher has to be run on A35_0 to unlock execution on A35_1
+         # Save current target to restore it later
+         echo "... Running EL3_Launcher on A35_0 ..."
+         set TARGET_CURRENT [target current]
+         # Change current target to A35_0 to be able to execute "resume" command on it
+         targets $_CHIPNAME.a35_0
+         if { [$_CHIPNAME.a35_0 was_examined] != 1 } {
+            # If A35_0 has not been examimed yet, we have to do it and halt it
+            #   to run commands on it
+            $_CHIPNAME.a35_0 arp_examine
+         }
+         # Halt A35_0
+         # This triggers A35_0 halted event which recursively runs this procedure and
+         # load and run EL3_Launcher on A35_0
+         halt 1000
+         # Resume A35_0 in order to leave it in a correct state for GDB to attach to it
+         resume
+         # Restore current target
+         targets $TARGET_CURRENT
+      }
+   }
+   echo "... Resuming $core_name at $EL3_entry_point ..."
+   resume $EL3_entry_point
+   sleep 1000
+#   echo "<D> Halting"
+   halt 1000
+}
+
+# configure RIF in the most "open configuration" (no CID filtering, no "privileged only", ...)
+proc set_access_to_memory {memory_name secure_mode core_name core_name2} {
+   global _CHIPNAME
+   global _INIT_MEMCONFIG_OPENOCD
+
+   if ($_INIT_MEMCONFIG_OPENOCD!="yes") {
+       echo ">> Init to be done by test FW..."
+       return
+   }
+
+   set rif_name UNKNOWN
+
+   switch $memory_name {
+      "SRAM1" {
+          set rif_name RISAB3
+      }
+      "SRAM2" {
+          set rif_name RISAB4
+      }
+      "LPSRAM1" {
+          set rif_name RISAL1
+      }
+      "LPSRAM2" {
+          set rif_name RISAL2
+      }
+      "LPSRAM3" {
+          set rif_name RISAL3
+      }
+   }
+
+   if {($core_name2!="") && ($core_name2!=$core_name)} {
+      echo "... Programming $rif_name for $core_name & $core_name2 access to $memory_name in $secure_mode mode ..."
+   } else {
+      echo "... Programming $rif_name for $core_name access to $memory_name in $secure_mode mode ..."
+   }
+
+   set risab_seccfgr_offset  0x100
+   set risab_privcfgr_offset 0x200
+   set risab_reg_nb          32
+   set risal_region3_subregiona_addr_value 0x08000000
+   set risal_region3_subregionb_addr_value 0x08000000
+   set risab_privcfgr_value  0x00000000
+
+   if {$secure_mode=="secure_access"} {
+      set risab_seccfgr_value   0x000000FF
+      if {$core_name=="A35"} {
+         set risal_region_subregiona_cfgr_value 0x00000111
+         set risal_region_subregionb_cfgr_value 0x00000111
+      }
+      if {$core_name=="M33"} {
+         set risal_region_subregiona_cfgr_value 0x00000121
+         set risal_region_subregionb_cfgr_value 0x00000121
+      }
+      set risaf_cfgr_value 0x00000101
+   } else {
+      set risab_seccfgr_value   0x00000000
+      if {$core_name=="A35"} {
+         set risal_region_subregiona_cfgr_value 0x00000011
+         set risal_region_subregionb_cfgr_value 0x00000011
+      }
+      if {$core_name=="M33"} {
+         set risal_region_subregiona_cfgr_value 0x00000021
+         set risal_region_subregionb_cfgr_value 0x00000021
+      }
+      if {$core_name=="M0PLUS"} {
+         set risal_region_subregiona_cfgr_value 0x00000031
+         set risal_region_subregionb_cfgr_value 0x00000031
+      }
+   }
+   if {$secure_mode=="secure_access"} {
+      if {$core_name2=="A35"} {
+         set risal_region_subregionb_cfgr_value 0x00000111
+      }
+      if {$core_name2=="M33"} {
+         set risal_region_subregionb_cfgr_value 0x00000121
+      }
+   } else {
+      if {$core_name2=="A35"} {
+         set risal_region_subregionb_cfgr_value 0x00000011
+      }
+      if {$core_name2=="M33"} {
+         set risal_region_subregionb_cfgr_value 0x00000021
+      }
+      if {$core_name2=="M0PLUS"} {
+         set risal_region_subregionb_cfgr_value 0x00000031
+      }
+   }
+
+   switch $memory_name {
+      "SRAM1" { # when memory is SRAM1, set RISAB3
+         set risab_base_addr 0x42110000
+         # set all RISAB_SECCFGRx registers
+         set risab_reg_addr [expr {$risab_base_addr+$risab_seccfgr_offset}]
+         set_successive_registers $risab_reg_addr $risab_reg_nb $risab_seccfgr_value
+         # set all RISAB_PRIVCFGRx registers
+         set risab_reg_addr [expr {$risab_base_addr+$risab_privcfgr_offset}]
+         set_successive_registers $risab_reg_addr $risab_reg_nb $risab_privcfgr_value
+      }
+      "SRAM2" { # when memory is SRAM2, set RISAB4
+         set risab_base_addr 0x42120000
+         # set all RISAB_SECCFGRx registers
+         set risab_reg_addr [expr {$risab_base_addr+$risab_seccfgr_offset}]
+         set_successive_registers $risab_reg_addr $risab_reg_nb $risab_seccfgr_value
+         # set all RISAB_PRIVCFGRx registers
+         set risab_reg_addr [expr {$risab_base_addr+$risab_privcfgr_offset}]
+         set_successive_registers $risab_reg_addr $risab_reg_nb $risab_privcfgr_value
+      }
+      "LPSRAM1" { # when memory is LPSRAM1, set RIFSC/RISAL1
+         # set RISC_REG1_ACFGR register
+         WriteReg 0x42080900 $risal_region_subregiona_cfgr_value
+         # set RISC_REG1_BCFGR register
+         WriteReg 0x42080908 $risal_region_subregionb_cfgr_value
+      }
+      "LPSRAM2" { # when memory is LPSRAM2, set RIFSC/RISAL2
+         # set RISC_REG2_ACFGR register
+         WriteReg 0x42080910 $risal_region_subregiona_cfgr_value
+         # set RISC_REG2_BCFGR register
+         WriteReg 0x42080918 $risal_region_subregionb_cfgr_value
+      }
+      "LPSRAM3" { # when memory is LPSRAM3, set RIFSC/RISAL3
+         # set RISC_REG3_ACFGR register
+         WriteReg 0x42080920 $risal_region_subregiona_cfgr_value
+         # set RISC_REG3_AADDR register
+         WriteReg 0x42080924 $risal_region3_subregiona_addr_value
+         # set RISC_REG3_BCFGR register
+         WriteReg 0x42080928 $risal_region_subregionb_cfgr_value
+         # set RISC_REG3_BADDR register
+         WriteReg 0x4208092C $risal_region3_subregionb_addr_value
+      }
+   }
+}
diff --git a/tcl/target/stm32mp25x_oe.cfg b/tcl/target/stm32mp25x_oe.cfg
new file mode 100644
index 000000000..9ffde1694
--- /dev/null
+++ b/tcl/target/stm32mp25x_oe.cfg
@@ -0,0 +1,143 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+# STMicroelectronics STM32MP25x
+# STM32MP25x devices support both JTAG and SWD transports.
+
+# HLA does not support multi-cores nor custom CSW nor AP other than 0
+if { [using_hla] } {
+	echo "ERROR: HLA transport cannot work with this target."
+	shutdown
+}
+
+source [find target/swj-dp.tcl]
+source [find mem_helper.tcl]
+
+if { [info exists CHIPNAME] } {
+	set _CHIPNAME $CHIPNAME
+} else {
+	set _CHIPNAME stm32mp25x
+}
+
+set _ENDIAN little
+
+# jtag scan chain
+if { [info exists CPUTAPID] } {
+	set _CPUTAPID $CPUTAPID
+} else {
+	if { [using_jtag] } {
+		set _CPUTAPID 0x6ba00477
+	} {
+		set _CPUTAPID 0x6ba02477
+	}
+}
+
+# Chip Level TAP Controller, only in jtag mode
+if { [info exists CLCTAPID] } {
+	set _CLCTAPID $CLCTAPID
+} else {
+	set _CLCTAPID 0x16505041
+}
+
+swj_newdap $_CHIPNAME tap -expected-id $_CPUTAPID -irlen 4 -ircapture 0x01 -irmask 0x0f
+if { [using_jtag] } {
+	swj_newdap $_CHIPNAME.clc tap -expected-id $_CLCTAPID -irlen 5
+}
+
+dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.tap
+
+# define AXI & APB Memory Access Ports
+# NOTE: do not change the order of target create
+target create $_CHIPNAME.ap0 mem_ap -dap $_CHIPNAME.dap -ap-num 0
+target create $_CHIPNAME.axi mem_ap -dap $_CHIPNAME.dap -ap-num 4
+target create $_CHIPNAME.ap2 mem_ap -dap $_CHIPNAME.dap -ap-num 2
+target create $_CHIPNAME.ap8 mem_ap -dap $_CHIPNAME.dap -ap-num 8
+
+# define the first Cortex-A35
+cti create $_CHIPNAME.cti.a35_0 -dap $_CHIPNAME.dap -ap-num 0 -baseaddr 0x80220000
+target create $_CHIPNAME.a35_0 aarch64 -dap $_CHIPNAME.dap -dbgbase 0x80210000 -ap-num 0 -cti $_CHIPNAME.cti.a35_0
+
+# define the second Cortex-A35
+cti create $_CHIPNAME.cti.a35_1 -dap $_CHIPNAME.dap -ap-num 0 -baseaddr 0x80320000
+target create $_CHIPNAME.a35_1 aarch64 -dap $_CHIPNAME.dap -dbgbase 0x80310000 -ap-num 0 -cti $_CHIPNAME.cti.a35_1
+
+# define the Cortex-M33
+target create $_CHIPNAME.m33 cortex_m -dap $_CHIPNAME.dap -ap-num 8 -defer-examine
+cti create $_CHIPNAME.cti.m33 -dap $_CHIPNAME.dap -ap-num 8 -baseaddr 0xe0042000
+
+# define the Cortex-M0+
+target create $_CHIPNAME.m0p cortex_m -dap $_CHIPNAME.dap -ap-num 2 -defer-examine
+cti create $_CHIPNAME.cti.m0p -dap $_CHIPNAME.dap -ap-num 2 -baseaddr 0xf0000000
+
+# define the system CTIs
+cti create $_CHIPNAME.cti.sys0 -dap $_CHIPNAME.dap -ap-num 0 -baseaddr 0x80090000
+cti create $_CHIPNAME.cti.sys1 -dap $_CHIPNAME.dap -ap-num 0 -baseaddr 0x800a0000
+
+targets $_CHIPNAME.a35_0
+
+target smp $_CHIPNAME.a35_0 $_CHIPNAME.a35_1
+
+reset_config srst_gates_jtag srst_pulls_trst
+
+adapter speed 5000
+adapter srst pulse_width 200
+# wait 1 seconds for bootrom
+adapter srst delay 1000
+
+# set CSW for AXI
+$_CHIPNAME.dap apsel 4
+$_CHIPNAME.dap apcsw 0x12800000
+
+# mmw with target selection
+proc target_mmw {target reg setbits clearbits} {
+	set val [eval $target read_memory $reg 32 1]
+	set val [expr {($val & ~$clearbits) | $setbits}]
+	eval $target mww $reg $val
+}
+
+proc dbgmcu_enable_debug {} {
+	# set debug enable bits in DBGMCU_CR to get ap2/cm0+ and ap8/cm33 visible
+	# set DBG_SWD_SEL_N bit in DBGMCU_CR to get ap2/cm0+ on main debug interface
+	$::_CHIPNAME.ap0 mww 0x80010004 0x17
+}
+
+proc dbgmcu_freeze_watchdogs {} {
+	# Freeze watchdogs on CPU halt
+	$::_CHIPNAME.axi mww 0x4a010008 0x00000001
+	$::_CHIPNAME.axi mww 0x4a01003c 0x00000026
+	$::_CHIPNAME.axi mww 0x4a010040 0x00000038
+	$::_CHIPNAME.axi mww 0x4a010044 0x00000400
+	$::_CHIPNAME.axi mww 0x4a010048 0x00000400
+	$::_CHIPNAME.axi mww 0x4a01004c 0x00000600
+}
+
+proc enable_ap2_debug {} {
+	# set bits C3LPEN and C3EN in RCC_C3CFGR to enable AP2 and CM0+ clock
+	target_mmw $::_CHIPNAME.axi 0x54200490 6 0
+}
+
+proc toggle_a35_0_dbg_claim0 {} {
+	# set few bits in CPU0 DBG_CLAIM to verify write permission
+	# FSBL wrapper will clear CPU0 DBG_CLAIM[0]
+	# toggle CPU0 DBG_CLAIM[0]
+	$::_CHIPNAME.ap0 mww 0x80210fa0 0x0b
+	set claim [$::_CHIPNAME.ap0 read_memory 0x80210fa4 32 1]
+	if {[expr {$claim & 0xfe}] != 0x0a} {
+		error "ERROR: cannot write in DBG_CLAIM. Missing FSBL wrapper?"
+	}
+	if {[expr {$claim & 1}]} {
+		echo "WARNING: FSBL wrapper not detected. Board in dev boot mode?"
+	}
+	$::_CHIPNAME.ap0 mww 0x80210fa4 0x0b
+}
+
+$_CHIPNAME.m33   configure -event reset-assert        { }
+$_CHIPNAME.ap0   configure -event reset-deassert-pre  {adapter deassert srst deassert trst;catch {dap init};catch {$::_CHIPNAME.dap apid 0}}
+$_CHIPNAME.ap2   configure -event reset-deassert-pre  {dbgmcu_enable_debug;dbgmcu_freeze_watchdogs;enable_ap2_debug}
+$_CHIPNAME.a35_0 configure -event reset-deassert-pre  {$::_CHIPNAME.a35_0 arp_examine}
+$_CHIPNAME.a35_1 configure -event reset-deassert-pre  {$::_CHIPNAME.a35_1 arp_examine}
+$_CHIPNAME.a35_0 configure -event reset-deassert-post {toggle_a35_0_dbg_claim0;if {$halt} {$::_CHIPNAME.a35_0 arp_halt}}
+$_CHIPNAME.m33   configure -event reset-deassert-post {$::_CHIPNAME.m33 arp_examine;$::_CHIPNAME.m33 arp_poll;$::_CHIPNAME.m33 arp_poll;if {$halt} {catch {$::_CHIPNAME.m33 arp_halt}}}
+$_CHIPNAME.m0p   configure -event reset-deassert-post {$::_CHIPNAME.m0p arp_examine}
+$_CHIPNAME.ap0   configure -event examine-start       {dap init}
+$_CHIPNAME.ap2   configure -event examine-start       {dbgmcu_freeze_watchdogs;enable_ap2_debug;$::_CHIPNAME.m0p arp_examine}
+$_CHIPNAME.ap0   configure -event examine-end         {dbgmcu_enable_debug;$::_CHIPNAME.m33 arp_examine}
diff --git a/tcl/target/stm32u5x.cfg b/tcl/target/stm32u5x.cfg
index 2c2c0e037..44b51e2b6 100644
--- a/tcl/target/stm32u5x.cfg
+++ b/tcl/target/stm32u5x.cfg
@@ -1,10 +1,8 @@
 # SPDX-License-Identifier: GPL-2.0-or-later
 
 # script for stm32u5x family
+# stm32u5x devices support both JTAG and SWD transports.
 
-#
-# stm32u5 devices support both JTAG and SWD transports.
-#
 source [find target/swj-dp.tcl]
 source [find mem_helper.tcl]
 
@@ -14,99 +12,34 @@ if { [info exists CHIPNAME] } {
 	set _CHIPNAME stm32u5x
 }
 
-set _ENDIAN little
+source [find target/stm32x5x_common.cfg]
 
-# Work-area is a space in RAM used for flash programming
-# By default use 64kB
-if { [info exists WORKAREASIZE] } {
-	set _WORKAREASIZE $WORKAREASIZE
-} else {
-	set _WORKAREASIZE 0x10000
-}
-
-#jtag scan chain
-if { [info exists CPUTAPID] } {
-	set _CPUTAPID $CPUTAPID
-} else {
-	if { [using_jtag] } {
-		# See STM Document RM0438
-		# RM0456 Rev1, Section 65.2.8 JTAG debug port - Table 661. JTAG-DP data registers
-		# Corresponds to Cortex®-M33 JTAG debug port ID code
-		set _CPUTAPID 0x0ba04477
-	} {
-		# SWD IDCODE (single drop, arm)
-		set _CPUTAPID 0x0be12477
-	}
-}
-
-swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
-
-if {[using_jtag]} {
-	jtag newtap $_CHIPNAME bs -irlen 5
-}
-
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap
-
-# use non-secure RAM by default
-$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0
-
-# create sec/ns flash and otp memories (sizes will be probed)
-flash bank $_CHIPNAME.flash_ns      stm32l4x 0x08000000 0 0 0 $_TARGETNAME
-flash bank $_CHIPNAME.flash_alias_s stm32l4x 0x0C000000 0 0 0 $_TARGETNAME
-flash bank $_CHIPNAME.otp           stm32l4x 0x0BFA0000 0 0 0 $_TARGETNAME
-
-# Common knowledges tells JTAG speed should be <= F_CPU/6.
-# F_CPU after reset is MSI 4MHz, so use F_JTAG = 500 kHz to stay on
-# the safe side.
-#
-# Note that there is a pretty wide band where things are
-# more or less stable, see http://openocd.zylin.com/#/c/3366/
-adapter speed 500
-
-adapter srst delay 100
-if {[using_jtag]} {
-	jtag_ntrst_delay 100
-}
-
-reset_config srst_nogate
-
-if {![using_hla]} {
-	# if srst is not fitted use SYSRESETREQ to
-	# perform a soft reset
-	cortex_m reset_config sysresetreq
-}
-
-proc is_secure {} {
-	# read Debug Security Control and Status Regsiter (DSCSR) and check CDS (bit 16)
-	set DSCSR [mrw 0xE000EE08]
-	return [expr {($DSCSR & (1 << 16)) != 0}]
-}
-
-proc clock_config_160_mhz {} {
-	set offset [expr {[is_secure] ? 0x10000000 : 0}]
+proc stm32u5x_clock_config {} {
+	set offset [expr {[stm32x5x_is_secure] ? 0x10000000 : 0}]
 	# MCU clock is at MSI 4MHz after reset, set MCU freq at 160 MHz with PLL
 
 	# Enable voltage range 1 for frequency above 100 Mhz
 	# RCC_AHB3ENR = PWREN
 	mww [expr {0x46020C94 + $offset}] 0x00000004
 	# delay for register clock enable (read back reg)
-	mrw [expr {0x56020C94 + $offset}]
+	mrw [expr {0x46020C94 + $offset}]
 	# PWR_VOSR : VOS Range 1
-	mww [expr {0x4602080C + $offset}] 0x00030000
-	# delay for register write (read back reg)
-	mrw [expr {0x4602080C + $offset}]
+	mmw [expr {0x4602080C + $offset}] 0x00030000 0
+	# while !(PWR_VOSR & VOSRDY)
+	while {!([mrw [expr {0x4602080C + $offset}]] & 0x00008000)} {}
 	# FLASH_ACR : 4 WS for 160 MHz HCLK
 	mww [expr {0x40022000 + $offset}] 0x00000004
-	# RCC_PLL1CFGR => PLL1M=0000=/1, PLL1SRC=MSI 4MHz
-	mww [expr {0x46020C28 + $offset}] 0x00000001
+	# RCC_PLL1CFGR => PLL1MBOOST=0, PLL1M=0=/1, PLL1FRACEN=0, PLL1SRC=MSI 4MHz
+	#                 PLL1REN=1, PLL1RGE => VCOInputRange=PLLInputRange_4_8
+	mww [expr {0x46020C28 + $offset}] 0x00040009
+	# Enable EPOD Booster
+	mmw [expr {0x4602080C + $offset}] 0x00040000 0
+	# while !(PWR_VOSR & BOOSTRDY)
+	while {!([mrw [expr {0x4602080C + $offset}]] & 0x00004000)} {}
 	# RCC_PLL1DIVR => PLL1P=PLL1Q=PLL1R=000001=/2, PLL1N=0x4F=80
 	# fVCO = 4 x 80 /1 = 320
 	# SYSCLOCK = fVCO/PLL1R = 320/2 = 160 MHz
-	mmw [expr {0x46020C34 + $offset}] 0x0000004F 0
-	# RCC_PLL1CFGR => PLL1REN=1
-	mmw [expr {0x46020C28 + $offset}] 0x00040000 0
+	mww [expr {0x46020C34 + $offset}] 0x0101024F
 	# RCC_CR |= PLL1ON
 	mmw [expr {0x46020C00 + $offset}] 0x01000000 0
 	# while !(RCC_CR & PLL1RDY)
@@ -117,91 +50,8 @@ proc clock_config_160_mhz {} {
 	while {([mrw [expr {0x46020C1C + $offset}]] & 0x0C) != 0x0C} {}
 }
 
-proc ahb_ap_non_secure_access {} {
-	# SPROT=1=Non Secure access, Priv=1
-	[[target current] cget -dap] apcsw 0x4B000000 0x4F000000
-}
-
-proc ahb_ap_secure_access {} {
-	# SPROT=0=Secure access, Priv=1
-	[[target current] cget -dap] apcsw 0x0B000000 0x4F000000
-}
-
 $_TARGETNAME configure -event reset-init {
-	clock_config_160_mhz
+	stm32u5x_clock_config
 	# Boost JTAG frequency
 	adapter speed 4000
 }
-
-$_TARGETNAME configure -event reset-start {
-	# Reset clock is MSI (4 MHz)
-	adapter speed 480
-}
-
-$_TARGETNAME configure -event examine-end {
-	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP
-	mmw 0xE0044004 0x00000006 0
-
-	# Stop watchdog counters during halt
-	# DBGMCU_APB1_FZ |= DBG_IWDG_STOP | DBG_WWDG_STOP
-	mmw 0xE0044008 0x00001800 0
-}
-
-$_TARGETNAME configure -event halted {
-	set secure [is_secure]
-
-	if {$secure} {
-		set secure_str "Secure"
-		ahb_ap_secure_access
-	} else {
-		set secure_str "Non-Secure"
-		ahb_ap_non_secure_access
-	}
-
-	# print the secure state only when it changes
-	set _TARGETNAME [target current]
-	global $_TARGETNAME.secure
-
-	if {![info exists $_TARGETNAME.secure] || $secure != [set $_TARGETNAME.secure]} {
-		echo "CPU in $secure_str state"
-		# update saved security state
-		set $_TARGETNAME.secure $secure
-	}
-}
-
-$_TARGETNAME configure -event gdb-flash-erase-start {
-	set use_secure_workarea 0
-	# check if FLASH_OPTR.TZEN is enabled
-	set FLASH_OPTR [mrw 0x40022040]
-	if {[expr {$FLASH_OPTR & 0x80000000}] == 0} {
-		echo "TZEN option bit disabled"
-		ahb_ap_non_secure_access
-	} else {
-		ahb_ap_secure_access
-		echo "TZEN option bit enabled"
-
-		# check if FLASH_OPTR.RDP is not Level 0.5
-		if {[expr {$FLASH_OPTR & 0xFF}] != 0x55} {
-			set use_secure_workarea 1
-		}
-	}
-
-	set _TARGETNAME [target current]
-	set workarea_addr [$_TARGETNAME cget -work-area-phys]
-	echo "workarea_addr $workarea_addr"
-
-	if {$use_secure_workarea} {
-		set workarea_addr [expr {$workarea_addr | 0x10000000}]
-	} else {
-		set workarea_addr [expr {$workarea_addr & ~0x10000000}]
-	}
-
-	$_TARGETNAME configure -work-area-phys $workarea_addr
-}
-
-$_TARGETNAME configure -event trace-config {
-	# Set TRACE_IOEN; TRACE_MODE is set to async; when using sync
-	# change this value accordingly to configure trace pins
-	# assignment
-	mmw 0xE0044004 0x00000020 0
-}
diff --git a/tcl/target/stm32wlx.cfg b/tcl/target/stm32wlx.cfg
index fafe9bcba..75f6f0288 100644
--- a/tcl/target/stm32wlx.cfg
+++ b/tcl/target/stm32wlx.cfg
@@ -156,9 +156,7 @@ proc stm32wlx_get_chipname {} {
 
 # like mrw, but with target selection
 proc stm32wlx_mrw {used_target reg} {
-	set value ""
-	$used_target mem2array value 32 $reg 1
-	return $value(0)
+	return [$used_target read_memory $reg 32 1]
 }
 
 # like mmw, but with target selection
diff --git a/tcl/target/stm32x5x_common.cfg b/tcl/target/stm32x5x_common.cfg
new file mode 100644
index 000000000..276d0cca0
--- /dev/null
+++ b/tcl/target/stm32x5x_common.cfg
@@ -0,0 +1,154 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+# common script for stm32l5x and stm32u5x families
+
+# Work-area is a space in RAM used for flash programming
+# By default use 64kB
+if { [info exists WORKAREASIZE] } {
+	set _WORKAREASIZE $WORKAREASIZE
+} else {
+	set _WORKAREASIZE 0x10000
+}
+
+#jtag scan chain
+if { [info exists CPUTAPID] } {
+	set _CPUTAPID $CPUTAPID
+} else {
+	if { [using_jtag] } {
+		# STM32L5x: RM0438 Rev5, Section 52.2.8 JTAG debug port - Table 425. JTAG-DP data registers
+		# STM32U5x: RM0456 Rev1, Section 65.2.8 JTAG debug port - Table 661. JTAG-DP data registers
+		# Corresponds to Cortex®-M33 JTAG debug port ID code
+		set _CPUTAPID 0x0ba04477
+	} {
+		# SWD IDCODE (single drop, arm)
+		set _CPUTAPID 0x0be12477
+	}
+}
+
+swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
+
+if {[using_jtag]} {
+	jtag newtap $_CHIPNAME bs -irlen 5
+}
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME cortex_m -endian little -dap $_CHIPNAME.dap
+
+# use non-secure RAM by default
+$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0
+
+# create sec/ns flash and otp memories (sizes will be probed)
+flash bank $_CHIPNAME.flash_ns      stm32l4x 0x08000000 0 0 0 $_TARGETNAME
+flash bank $_CHIPNAME.flash_alias_s stm32l4x 0x0C000000 0 0 0 $_TARGETNAME
+flash bank $_CHIPNAME.otp           stm32l4x 0x0BFA0000 0 0 0 $_TARGETNAME
+
+# Common knowledge tells JTAG speed should be <= F_CPU/6.
+# F_CPU after reset is MSI 4MHz, so use F_JTAG = 500 kHz to stay on
+# the safe side.
+#
+# Note that there is a pretty wide band where things are
+# more or less stable, see http://review.openocd.org/3366
+adapter speed 500
+
+adapter srst delay 100
+if {[using_jtag]} {
+	jtag_ntrst_delay 100
+}
+
+reset_config srst_nogate
+
+if {![using_hla]} {
+	# if srst is not fitted use SYSRESETREQ to
+	# perform a soft reset
+	cortex_m reset_config sysresetreq
+}
+
+proc stm32x5x_is_secure {} {
+	# read Debug Security Control and Status Register (DSCSR) and check CDS (bit 16)
+	set DSCSR [mrw 0xE000EE08]
+	return [expr {($DSCSR & (1 << 16)) != 0}]
+}
+
+proc stm32x5x_ahb_ap_non_secure_access {} {
+	# SPROT=1=Non Secure access, Priv=1
+	[[target current] cget -dap] apcsw 0x4B000000 0x4F000000
+}
+
+proc stm32x5x_ahb_ap_secure_access {} {
+	# SPROT=0=Secure access, Priv=1
+	[[target current] cget -dap] apcsw 0x0B000000 0x4F000000
+}
+
+$_TARGETNAME configure -event reset-start {
+	# Reset clock is MSI (4 MHz)
+	adapter speed 480
+}
+
+$_TARGETNAME configure -event examine-end {
+	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP
+	mmw 0xE0044004 0x00000006 0
+
+	# Stop watchdog counters during halt
+	# DBGMCU_APB1_FZ |= DBG_IWDG_STOP | DBG_WWDG_STOP
+	mmw 0xE0044008 0x00001800 0
+}
+
+$_TARGETNAME configure -event halted {
+	set secure [stm32x5x_is_secure]
+
+	if {$secure} {
+		set secure_str "Secure"
+		stm32x5x_ahb_ap_secure_access
+	} else {
+		set secure_str "Non-Secure"
+		stm32x5x_ahb_ap_non_secure_access
+	}
+
+	# print the secure state only when it changes
+	set _TARGETNAME [target current]
+	global $_TARGETNAME.secure
+
+	if {![info exists $_TARGETNAME.secure] || $secure != [set $_TARGETNAME.secure]} {
+		echo "CPU in $secure_str state"
+		# update saved security state
+		set $_TARGETNAME.secure $secure
+	}
+}
+
+$_TARGETNAME configure -event gdb-flash-erase-start {
+	set use_secure_workarea 0
+	# check if FLASH_OPTR.TZEN is enabled
+	set FLASH_OPTR [mrw 0x40022040]
+	if {[expr {$FLASH_OPTR & 0x80000000}] == 0} {
+		echo "TZEN option bit disabled"
+		stm32x5x_ahb_ap_non_secure_access
+	} else {
+		stm32x5x_ahb_ap_secure_access
+		echo "TZEN option bit enabled"
+
+		# check if FLASH_OPTR.RDP is not Level 0.5
+		if {[expr {$FLASH_OPTR & 0xFF}] != 0x55} {
+			set use_secure_workarea 1
+		}
+	}
+
+	set _TARGETNAME [target current]
+	set workarea_addr [$_TARGETNAME cget -work-area-phys]
+	echo "workarea_addr $workarea_addr"
+
+	if {$use_secure_workarea} {
+		set workarea_addr [expr {$workarea_addr | 0x10000000}]
+	} else {
+		set workarea_addr [expr {$workarea_addr & ~0x10000000}]
+	}
+
+	$_TARGETNAME configure -work-area-phys $workarea_addr
+}
+
+$_TARGETNAME configure -event trace-config {
+	# Set TRACE_IOEN; TRACE_MODE is set to async; when using sync
+	# change this value accordingly to configure trace pins
+	# assignment
+	mmw 0xE0044004 0x00000020 0
+}
diff --git a/tcl/target/ti_cc3220sf.cfg b/tcl/target/ti_cc3220sf.cfg
index 74269aa66..c0a7b568d 100644
--- a/tcl/target/ti_cc3220sf.cfg
+++ b/tcl/target/ti_cc3220sf.cfg
@@ -26,11 +26,11 @@ proc ocd_process_reset_inner { MODE } {
 	soft_reset_halt
 
 	# Initialize MSP, PSP, and PC from vector table at flash 0x01000800
-	mem2array boot 32 0x01000800 2
+	set boot [read_memory 0x01000800 32 2]
 
-	reg msp $boot(0)
-	reg psp $boot(0)
-	reg pc $boot(1)
+	reg msp [lindex $boot 0]
+	reg psp [lindex $boot 0]
+	reg pc [lindex $boot 1]
 
 	if { 0 == [string compare $MODE run ] } {
 		resume
diff --git a/tcl/target/ti_k3.cfg b/tcl/target/ti_k3.cfg
index d2aa53160..254bb6971 100644
--- a/tcl/target/ti_k3.cfg
+++ b/tcl/target/ti_k3.cfg
@@ -27,11 +27,11 @@ if { [info exists V8_SMP_DEBUG] } {
 
 # Common Definitions
 
-# CM3 the very first processor - all current SoCs have it.
+# System Controller is the very first processor - all current SoCs have it.
 set CM3_CTIBASE		{0x3C016000}
 
-# M3 power-ap unlock offsets
-set _m3_ap_unlock_offsets {0xf0 0x44}
+# sysctrl power-ap unlock offsets
+set _sysctrl_ap_unlock_offsets {0xf0 0x44}
 
 # All the ARMV8s are the next processors.
 #		   CL0,CORE0  CL0,CORE1  CL1,CORE0  CL1,CORE1
@@ -42,14 +42,15 @@ set ARMV8_CTIBASE {0x90420000 0x90520000 0x90820000 0x90920000}
 #		(0)MCU 0   (1)MCU 1   (2)MAIN_0_0 (3)MAIN_0_1 (4)MAIN_1_0 (5)MAIN_1_1
 set R5_DBGBASE {0x9d010000 0x9d012000 0x9d410000 0x9d412000 0x9d510000 0x9d512000}
 set R5_CTIBASE {0x9d018000 0x9d019000 0x9d418000 0x9d419000 0x9d518000 0x9d519000}
+set R5_NAMES {mcu_r5.0 mcu_r5.1 main0_r5.0 main0_r5.1 main1_r5.0 main1_r5.1}
 
-# Finally an M4F
+# Finally an General Purpose(GP) MCU
 set CM4_CTIBASE		{0x20001000}
 
-# M4 may be present on some very few SoCs
-set _mcu_m4_cores 0
-# M4 power-ap unlock offsets
-set _m4_ap_unlock_offsets {0xf0 0x60}
+# General Purpose MCU (M4) may be present on some very few SoCs
+set _gp_mcu_cores 0
+# General Purpose MCU power-ap unlock offsets
+set _gp_mcu_ap_unlock_offsets {0xf0 0x60}
 
 # Set configuration overrides for each SOC
 switch $_soc {
@@ -63,15 +64,10 @@ switch $_soc {
 
 		# AM654 has 1 cluster of 2 R5s cores.
 		set _r5_cores 2
-		set _mcu_r5_cores 2
-		set _mcu_base_core_id 0
-		set _main0_r5_cores 0
-		set _main0_base_core_id 0
-		set _main1_r5_cores 0
-		set _main1_base_core_id 0
-
-		# M3 power-ap unlock offsets
-		set _m3_ap_unlock_offsets {0xf0 0x50}
+		set R5_NAMES {mcu_r5.0 mcu_r5.1}
+
+		# Sysctrl power-ap unlock offsets
+		set _sysctrl_ap_unlock_offsets {0xf0 0x50}
 	}
 	am642 {
 		set _CHIPNAME am642
@@ -85,17 +81,37 @@ switch $_soc {
 
 		# AM642 has 2 cluster of 2 R5s cores.
 		set _r5_cores 4
-		set _mcu_r5_cores 0
-		set _mcu_base_core_id 0
-		set _main0_r5_cores 2
-		set _main0_base_core_id 0
-		set _main1_r5_cores 2
-		set _main1_base_core_id 2
+		set R5_NAMES {main0_r5.0 main0_r5.1 main1_r5.0 main1_r5.1}
 		set R5_DBGBASE {0x9d410000 0x9d412000 0x9d510000 0x9d512000}
 		set R5_CTIBASE {0x9d418000 0x9d419000 0x9d518000 0x9d519000}
 
 		# M4 processor
-		set _mcu_m4_cores 1
+		set _gp_mcu_cores 1
+	}
+	am625 {
+		set _CHIPNAME am625
+		set _K3_DAP_TAPID 0x0bb7e02f
+
+		# AM625 has 1 clusters of 4 A53 cores.
+		set _armv8_cpu_name a53
+		set _armv8_cores 4
+		set ARMV8_DBGBASE {0x90010000 0x90110000 0x90210000 0x90310000}
+		set ARMV8_CTIBASE {0x90020000 0x90120000 0x90220000 0x90320000}
+
+		# AM625 has 1 cluster of 1 R5s core.
+		set _r5_cores 1
+		set R5_NAMES {main0_r5.0}
+		set R5_DBGBASE {0x9d410000}
+		set R5_CTIBASE {0x9d418000}
+
+		# sysctrl CTI base
+		set CM3_CTIBASE {0x20001000}
+		# Sysctrl power-ap unlock offsets
+		set _sysctrl_ap_unlock_offsets {0xf0 0x78}
+
+		# M4 processor
+		set _gp_mcu_cores 1
+		set _gp_mcu_ap_unlock_offsets {0xf0 0x7c}
 	}
 	j721e {
 		set _CHIPNAME j721e
@@ -106,12 +122,6 @@ switch $_soc {
 
 		# J721E has 3 clusters of 2 R5 cores each.
 		set _r5_cores 6
-		set _mcu_r5_cores 2
-		set _mcu_base_core_id 0
-		set _main0_r5_cores 2
-		set _main0_base_core_id 2
-		set _main1_r5_cores 2
-		set _main1_base_core_id 4
 	}
 	j7200 {
 		set _CHIPNAME j7200
@@ -123,18 +133,32 @@ switch $_soc {
 
 		# J7200 has 2 clusters of 2 R5 cores each.
 		set _r5_cores 4
-		set _mcu_r5_cores 2
-		set _mcu_base_core_id 0
-		set _main0_r5_cores 2
-		set _main0_base_core_id 2
-		set _main1_r5_cores 0
-		set _main1_base_core_id 0
 		set R5_DBGBASE {0x9d010000 0x9d012000 0x9d110000 0x9d112000}
 		set R5_CTIBASE {0x9d018000 0x9d019000 0x9d118000 0x9d119000}
 
 		# M3 CTI base
 		set CM3_CTIBASE {0x20001000}
 	}
+	j721s2 {
+		set _CHIPNAME j721s2
+		set _K3_DAP_TAPID 0x0bb7502f
+
+		# J721s2 has 1 cluster of 2 A72 cores.
+		set _armv8_cpu_name a72
+		set _armv8_cores 2
+
+		# J721s2 has 3 clusters of 2 R5 cores each.
+		set _r5_cores 6
+
+		# sysctrl CTI base
+		set CM3_CTIBASE {0x20001000}
+		# Sysctrl power-ap unlock offsets
+		set _sysctrl_ap_unlock_offsets {0xf0 0x78}
+
+		# M4 processor
+		set _gp_mcu_cores 1
+		set _gp_mcu_ap_unlock_offsets {0xf0 0x7c}
+	}
 	default {
 		echo "'$_soc' is invalid!"
 	}
@@ -147,18 +171,42 @@ set _TARGETNAME $_CHIPNAME.cpu
 
 set _CTINAME $_CHIPNAME.cti
 
-# M3 is always present
-cti create $_CTINAME.m3 -dap $_CHIPNAME.dap -ap-num 7 -baseaddr [lindex $CM3_CTIBASE 0]
-target create $_TARGETNAME.m3 cortex_m -dap $_CHIPNAME.dap -ap-num 7 -defer-examine
-$_TARGETNAME.m3 configure -event reset-assert { }
+# sysctrl is always present
+cti create $_CTINAME.sysctrl -dap $_CHIPNAME.dap -ap-num 7 -baseaddr [lindex $CM3_CTIBASE 0]
+target create $_TARGETNAME.sysctrl cortex_m -dap $_CHIPNAME.dap -ap-num 7 -defer-examine
+$_TARGETNAME.sysctrl configure -event reset-assert { }
 
-proc m3_up { args } {
-	# To access M3, we need to enable the JTAG access for the same.
+proc sysctrl_up {} {
+	# To access sysctrl, we need to enable the JTAG access for the same.
 	# Ensure Power-AP unlocked
-	$::_CHIPNAME.dap apreg 3 [lindex $::_m3_ap_unlock_offsets 0] 0x00190000
-	$::_CHIPNAME.dap apreg 3 [lindex $::_m3_ap_unlock_offsets 1] 0x00102098
+	$::_CHIPNAME.dap apreg 3 [lindex $::_sysctrl_ap_unlock_offsets 0] 0x00190000
+	$::_CHIPNAME.dap apreg 3 [lindex $::_sysctrl_ap_unlock_offsets 1] 0x00102098
+
+	$::_TARGETNAME.sysctrl arp_examine
+}
 
-	$::_TARGETNAME.m3 arp_examine
+$_TARGETNAME.sysctrl configure -event gdb-attach {
+	sysctrl_up
+	# gdb-attach default rule
+	halt 1000
+}
+
+proc _cpu_no_smp_up {} {
+	set _current_target [target current]
+	set _current_type [$_current_target cget -type]
+
+	$_current_target arp_examine
+	$_current_target $_current_type dbginit
+}
+
+proc _armv8_smp_up {} {
+	for { set _core 0 } { $_core < $::_armv8_cores } { incr _core } {
+		$::_TARGETNAME.$::_armv8_cpu_name.$_core arp_examine
+		$::_TARGETNAME.$::_armv8_cpu_name.$_core aarch64 dbginit
+		$::_TARGETNAME.$::_armv8_cpu_name.$_core aarch64 smp on
+	}
+	# Set Default target as core 0
+	targets $::_TARGETNAME.$::_armv8_cpu_name.0
 }
 
 set _v8_smp_targets ""
@@ -172,6 +220,20 @@ for { set _core 0 } { $_core < $_armv8_cores } { incr _core } {
 		-dbgbase [lindex $ARMV8_DBGBASE $_core] -cti $_CTINAME.$_armv8_cpu_name.$_core -defer-examine
 
 	set _v8_smp_targets "$_v8_smp_targets $_TARGETNAME.$_armv8_cpu_name.$_core"
+
+	if { $_v8_smp_debug == 0 } {
+		$_TARGETNAME.$_armv8_cpu_name.$_core configure -event gdb-attach {
+			_cpu_no_smp_up
+			# gdb-attach default rule
+			halt 1000
+		}
+	} else {
+		$_TARGETNAME.$_armv8_cpu_name.$_core configure -event gdb-attach {
+			_armv8_smp_up
+			# gdb-attach default rule
+			halt 1000
+		}
+	}
 }
 
 # Setup ARMV8 proc commands based on CPU to prevent people confusing SoCs
@@ -181,76 +243,59 @@ set _armv8_smp_cmd "$_armv8_cpu_name"_smp
 
 if { $_v8_smp_debug == 0 } {
 	proc $_armv8_up_cmd { args } {
-		foreach { _core } [set args] {
-			$::_TARGETNAME.$::_armv8_cpu_name.$_core arp_examine
-			$::_TARGETNAME.$::_armv8_cpu_name.$_core aarch64 dbginit
+		foreach _core $args {
+			targets $_core
+			_cpu_no_smp_up
 		}
 	}
 } else {
 	proc $_armv8_smp_cmd { args } {
-		for { set _core 0 } { $_core < $::_armv8_cores } { incr _core } {
-			$::_TARGETNAME.$::_armv8_cpu_name.$_core arp_examine
-			$::_TARGETNAME.$::_armv8_cpu_name.$_core aarch64 dbginit
-			$::_TARGETNAME.$::_armv8_cpu_name.$_core aarch64 smp on
-		}
-		# Set Default target are core 0
-		targets $::_TARGETNAME.$::_armv8_cpu_name.0
+		_armv8_smp_up
 	}
-
 	# Declare SMP
 	target smp $:::_v8_smp_targets
 }
 
 for { set _core 0 } { $_core < $_r5_cores } { incr _core } {
-	cti create $_CTINAME.r5.$_core -dap $_CHIPNAME.dap -ap-num 1 \
+	set _r5_name [lindex $R5_NAMES $_core]
+	cti create $_CTINAME.$_r5_name -dap $_CHIPNAME.dap -ap-num 1 \
 		-baseaddr [lindex $R5_CTIBASE $_core]
 
 	# inactive core examination will fail - wait till startup of additional core
-	target create $_TARGETNAME.r5.$_core cortex_r4 -dap $_CHIPNAME.dap \
+	target create $_TARGETNAME.$_r5_name cortex_r4 -dap $_CHIPNAME.dap \
 		-dbgbase [lindex $R5_DBGBASE $_core] -ap-num 1 -defer-examine
-}
-
-if { $_mcu_r5_cores != 0 } {
-	proc mcu_r5_up { args } {
-		foreach { _core } [set args] {
-			set _core [expr {$_core + $::_mcu_base_core_id}]
-			$::_TARGETNAME.r5.$_core arp_examine
-			$::_TARGETNAME.r5.$_core cortex_r4 dbginit
-		}
-	}
-}
 
-if { $_main0_r5_cores != 0 } {
-	proc main0_r5_up { args } {
-		foreach { _core } [set args] {
-			set _core [expr {$_core + $::_main0_base_core_id}]
-			$::_TARGETNAME.r5.$_core arp_examine
-			$::_TARGETNAME.r5.$_core cortex_r4 dbginit
-		}
+	$_TARGETNAME.$_r5_name configure -event gdb-attach {
+		_cpu_no_smp_up
+		# gdb-attach default rule
+		halt 1000
 	}
 }
 
-if { $_main1_r5_cores != 0 } {
-	proc main1_r5_up { args } {
-		foreach { _core } [set args] {
-			set _core [expr {$_core + $::_main1_base_core_id}]
-			$::_TARGETNAME.r5.$_core arp_examine
-			$::_TARGETNAME.r5.$_core cortex_r4 dbginit
-		}
+proc r5_up { args } {
+	foreach  _core $args {
+		targets $_core
+		_cpu_no_smp_up
 	}
 }
 
-if { $_mcu_m4_cores != 0 } {
-	cti create $_CTINAME.m4 -dap $_CHIPNAME.dap -ap-num 8 -baseaddr [lindex $CM4_CTIBASE 0]
-	target create $_TARGETNAME.m4 cortex_m -dap $_CHIPNAME.dap -ap-num 8 -defer-examine
-	$_TARGETNAME.m4 configure -event reset-assert { }
+if { $_gp_mcu_cores != 0 } {
+	cti create $_CTINAME.gp_mcu -dap $_CHIPNAME.dap -ap-num 8 -baseaddr [lindex $CM4_CTIBASE 0]
+	target create $_TARGETNAME.gp_mcu cortex_m -dap $_CHIPNAME.dap -ap-num 8 -defer-examine
+	$_TARGETNAME.gp_mcu configure -event reset-assert { }
 
-	proc m4_up { args } {
-		# To access M4, we need to enable the JTAG access for the same.
+	proc gp_mcu_up {} {
+		# To access GP MCU, we need to enable the JTAG access for the same.
 		# Ensure Power-AP unlocked
-		$::_CHIPNAME.dap apreg 3 [lindex $::_m4_ap_unlock_offsets 0] 0x00190000
-		$::_CHIPNAME.dap apreg 3 [lindex $::_m4_ap_unlock_offsets 1] 0x00102098
+		$::_CHIPNAME.dap apreg 3 [lindex $::_gp_mcu_ap_unlock_offsets 0] 0x00190000
+		$::_CHIPNAME.dap apreg 3 [lindex $::_gp_mcu_ap_unlock_offsets 1] 0x00102098
+
+		$::_TARGETNAME.gp_mcu arp_examine
+	}
 
-		$::_TARGETNAME.m4 arp_examine
+	$_TARGETNAME.gp_mcu configure -event gdb-attach {
+		gp_mcu_up
+		# gdb-attach default rule
+		halt 1000
 	}
 }
diff --git a/tcl/target/vd_aarch64.cfg b/tcl/target/vd_aarch64.cfg
new file mode 100644
index 000000000..619134aa6
--- /dev/null
+++ b/tcl/target/vd_aarch64.cfg
@@ -0,0 +1,37 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Cadence virtual debug interface
+# Arm v8 64b Cortex A
+
+if {![info exists _CORES]} {
+	set _CORES 1
+}
+if {![info exists _CHIPNAME]} {
+	set _CHIPNAME aarch64
+}
+set _TARGETNAME $_CHIPNAME.cpu
+set _CTINAME $_CHIPNAME.cti
+
+set DBGBASE {0x80810000 0x80910000}
+set CTIBASE {0x80820000 0x80920000}
+
+dap create $_CHIPNAME.dap -chain-position $_TARGETNAME
+$_CHIPNAME.dap apsel 1
+
+for { set _core 0 } { $_core < $_CORES } { incr _core } \
+{
+	cti create $_CTINAME.$_core -dap $_CHIPNAME.dap -ap-num 1 -baseaddr [lindex $CTIBASE $_core]
+	set _command "target create $_TARGETNAME.$_core aarch64 -dap $_CHIPNAME.dap \
+	-dbgbase [lindex $DBGBASE $_core] -cti $_CTINAME.$_core -coreid $_core"
+	if { $_core != 0 } {
+		# non-boot core examination may fail
+		set _command "$_command -defer-examine"
+		set _smp_command "$_smp_command $_TARGETNAME.$_core"
+	} else {
+		set _smp_command "target smp $_TARGETNAME.$_core"
+	}
+	eval $_command
+}
+eval $_smp_command
+
+# default target is core 0
+targets $_TARGETNAME.0
diff --git a/tcl/target/vd_cortex_m.cfg b/tcl/target/vd_cortex_m.cfg
new file mode 100644
index 000000000..4d7b0df26
--- /dev/null
+++ b/tcl/target/vd_cortex_m.cfg
@@ -0,0 +1,12 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Cadence virtual debug interface
+# ARM Cortex M
+
+if {![info exists _CHIPNAME]} {
+	set _CHIPNAME cortex_m
+}
+set _TARGETNAME $_CHIPNAME.cpu
+
+dap create $_CHIPNAME.dap -chain-position $_TARGETNAME
+
+target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap
diff --git a/tcl/target/vd_riscv.cfg b/tcl/target/vd_riscv.cfg
new file mode 100644
index 000000000..b42b25a3a
--- /dev/null
+++ b/tcl/target/vd_riscv.cfg
@@ -0,0 +1,18 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Cadence virtual debug interface
+# RISCV core
+
+if {![info exists _HARTID]} {
+	set _HARTID 0x00
+}
+if {![info exists _CHIPNAME]} {
+	set _CHIPNAME riscv
+}
+set _TARGETNAME $_CHIPNAME.cpu
+
+target create $_TARGETNAME riscv -chain-position $_TARGETNAME -coreid $_HARTID
+
+riscv set_reset_timeout_sec 120
+riscv set_command_timeout_sec 120
+# prefer to use sba for system bus access
+riscv set_prefer_sba on
diff --git a/tcl/target/xilinx_zynqmp.cfg b/tcl/target/xilinx_zynqmp.cfg
index e66289a70..2df7a4ff9 100644
--- a/tcl/target/xilinx_zynqmp.cfg
+++ b/tcl/target/xilinx_zynqmp.cfg
@@ -99,7 +99,7 @@ targets $_TARGETNAME.0
 
 proc core_up { args } {
     global _TARGETNAME
-    foreach { core } [set args] {
+    foreach core $args {
         $_TARGETNAME.$core arp_examine
     }
 }
diff --git a/tcl/tools/test_cpu_speed.tcl b/tcl/tools/test_cpu_speed.tcl
new file mode 100644
index 000000000..cef2bbbd7
--- /dev/null
+++ b/tcl/tools/test_cpu_speed.tcl
@@ -0,0 +1,50 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+# Description:
+#  Measure the CPU clock frequency of an ARM Cortex-M based device.
+#
+# Return:
+#  The CPU clock frequency in Hz. A negative value indicates that the loop
+#  counter was saturated.
+#
+# Note:
+#  You may need to adapt the number of cycles for your device.
+#
+add_help_text cortex_m_test_cpu_speed "Measure the CPU clock frequency of an ARM Cortex-M based device"
+add_usage_text cortex_m_test_cpu_speed {address [timeout [cycles_per_loop]]}
+proc cortex_m_test_cpu_speed { address { timeout 200 } { cycles_per_loop 4 } } {
+	set loop_counter_start 0xffffffff
+
+	halt
+
+	# Backup registers and memory.
+	set backup_regs [get_reg -force {pc r0 xPSR}]
+	set backup_mem [read_memory $address 16 3]
+
+	# We place the following code at the given address to measure the
+	# CPU clock frequency:
+	#
+	# 3801: subs r0, #1
+	# d1fd: bne #-2
+	# e7fe: b #-4
+	write_memory $address 16 {0x3801 0xd1fd 0xe7fe}
+
+	set_reg "pc $address r0 $loop_counter_start"
+	resume
+	sleep $timeout
+	halt
+
+	# Get the loop counter value from register r0.
+	set loop_counter_end [dict values [get_reg r0]]
+	set loop_counter_diff [expr {$loop_counter_start - $loop_counter_end}]
+
+	# Restore registers and memory.
+	set_reg $backup_regs
+	write_memory $address 16 $backup_mem
+
+	if { [expr {$loop_counter_end == 0}] } {
+		return -1
+	}
+
+	return [expr {double($loop_counter_diff) * $cycles_per_loop / $timeout * 1000}]
+}
diff --git a/testing/examples/cortex/cm3-ftest.cfg b/testing/examples/cortex/cm3-ftest.cfg
index 6f3fa5c81..02c8da11a 100644
--- a/testing/examples/cortex/cm3-ftest.cfg
+++ b/testing/examples/cortex/cm3-ftest.cfg
@@ -50,7 +50,7 @@ proc load_and_run { name halfwords n_instr } {
 	echo "# code to trigger $name vector"
 	set addr 0x20000000
 
-	# array2mem should be faster, though we'd need to
+	# write_memory should be faster, though we'd need to
 	# compute the resulting $addr ourselves
 	foreach opcode $halfwords {
 		mwh $addr $opcode
-- 
2.34.1

