From 7ced883785da1d212cd5b5cd9b57299c6afd1392 Mon Sep 17 00:00:00 2001
From: Christophe Priouzeau <christophe.priouzeau@foss.st.com>
Date: Wed, 2 Nov 2022 09:59:36 +0100
Subject: [PATCH] v2.6-stm32mp25-alpha-r1

Signed-off-by: Christophe Priouzeau <christophe.priouzeau@foss.st.com>
---
 .commitlintrc.js                              |    2 +-
 CONTRIBUTING.md                               |   30 +
 Makefile                                      |   19 +-
 SECURITY.md                                   |    8 +
 bl1/aarch32/bl1_entrypoint.S                  |    9 +
 bl2/aarch32/bl2_el3_exceptions.S              |    9 +
 bl2/aarch32/bl2_entrypoint.S                  |    9 +
 bl2/bl2_main.c                                |    6 +-
 bl2u/aarch32/bl2u_entrypoint.S                |    9 +
 bl32/sp_min/aarch32/entrypoint.S              |    9 +
 common/aarch32/debug.S                        |   52 +-
 common/bl_common.c                            |   10 +-
 docs/devicetree/bindings/arm/secure.txt       |   53 +
 .../bindings/clock/st,stm32mp1-rcc.txt        |  496 ++
 .../bindings/clock/st,stm32mp13-rcc.txt       |  640 ++
 docs/devicetree/bindings/i2c/i2c-stm32.txt    |   54 +
 .../memory-controllers/st,stm32mp1-ddr.txt    |  289 +
 docs/devicetree/bindings/mmc/mmci.txt         |   72 +
 .../bindings/mmc/st,stm32-sdmmc2.txt          |   22 +
 .../bindings/power/st,stm32mp1-pwr.txt        |   43 +
 docs/devicetree/bindings/power/st,stpmic1.txt |   94 +
 .../bindings/reset/st,stm32mp1-rcc.txt        |    6 +
 docs/devicetree/bindings/rng/st,stm32-rng.txt |   23 +
 .../bindings/serial/st,stm32-usart.txt        |   88 +
 .../bindings/soc/st,stm32-etzpc.txt           |   54 +
 .../bindings/soc/st,stm32-romem.txt           |   52 +
 .../bindings/soc/st,stm32-stgen.txt           |   18 +
 .../devicetree/bindings/soc/st,stm32-tamp.txt |   20 +
 .../bindings/watchdog/st,stm32-iwdg.txt       |   27 +
 docs/getting_started/porting-guide.rst        |   60 +-
 docs/plat/stm32mp1.rst                        |  146 +-
 drivers/auth/auth_mod.c                       |   14 +
 drivers/auth/mbedtls/mbedtls_common.mk        |    2 +-
 drivers/auth/mbedtls/mbedtls_x509_parser.c    |    4 +-
 drivers/clk/clk.c                             |   65 +
 drivers/fwu/fwu.c                             |   17 +-
 drivers/mmc/mmc.c                             |   67 +-
 drivers/mtd/nand/core.c                       |   21 +-
 drivers/mtd/nand/raw_nand.c                   |   45 +-
 drivers/mtd/nand/spi_nand.c                   |    5 +-
 drivers/mtd/nor/spi_nor.c                     |   11 +-
 drivers/mtd/spi-mem/spi_mem.c                 |   75 +-
 drivers/partition/gpt.c                       |    6 +-
 drivers/partition/partition.c                 |   29 +-
 drivers/regulator/regulator_core.c            | 1139 +++
 drivers/scmi-msg/base.c                       |    4 +-
 drivers/scmi-msg/clock.c                      |   76 +
 drivers/scmi-msg/clock.h                      |   12 +
 drivers/st/bsec/bsec.c                        |  891 ---
 drivers/st/bsec/bsec2.c                       |  934 +++
 drivers/st/bsec/bsec3.c                       |  597 ++
 drivers/st/clk/clk-stm32-core.c               | 1105 +++
 drivers/st/clk/clk-stm32-core.h               |  393 +
 drivers/st/clk/clk-stm32mp13.c                | 2378 ++++++
 drivers/st/clk/stm32mp1_calib.c               |  536 ++
 drivers/st/clk/stm32mp1_clk.c                 | 1761 ++++-
 drivers/st/clk/stm32mp2_clk.c                 | 2246 ++++++
 drivers/st/clk/stm32mp_clkfunc.c              |  226 +-
 drivers/st/crypto/stm32_hash.c                |   55 +-
 drivers/st/crypto/stm32_pka.c                 |  704 ++
 drivers/st/crypto/stm32_saes.c                | 1074 +++
 .../firmware/include/mnpmusrammsgblock_ddr3.h |  999 +++
 .../firmware/include/mnpmusrammsgblock_ddr4.h | 2274 ++++++
 .../include/mnpmusrammsgblock_lpddr4.h        |  967 +++
 .../phyinit/include/ddrphy_csr_all_cdefines.h | 6947 +++++++++++++++++
 .../ddr/phy/phyinit/include/ddrphy_phyinit.h  |   34 +
 .../phyinit/include/ddrphy_phyinit_struct.h   | 1083 +++
 .../include/ddrphy_phyinit_usercustom.h       |  184 +
 .../ddr/phy/phyinit/include/ddrphy_wrapper.h  |   20 +
 .../src/ddrphy_phyinit_c_initphyconfig.c      | 1331 ++++
 .../phy/phyinit/src/ddrphy_phyinit_calcmb.c   |  218 +
 .../phyinit/src/ddrphy_phyinit_d_loadimem.c   |   49 +
 .../phyinit/src/ddrphy_phyinit_f_loaddmem.c   |   74 +
 .../phy/phyinit/src/ddrphy_phyinit_g_execfw.c |   70 +
 .../phy/phyinit/src/ddrphy_phyinit_globals.c  |   31 +
 .../src/ddrphy_phyinit_h_readmsgblock.c       |   49 +
 .../src/ddrphy_phyinit_i_loadpieimage.c       |  429 +
 .../phyinit/src/ddrphy_phyinit_initstruct.c   |  454 ++
 .../src/ddrphy_phyinit_isdbytedisabled.c      |   87 +
 .../phyinit/src/ddrphy_phyinit_load_sr_fw.c   |   39 +
 .../src/ddrphy_phyinit_loadpieprodcode.c      |  185 +
 .../ddr/phy/phyinit/src/ddrphy_phyinit_main.c |  227 +
 .../phyinit/src/ddrphy_phyinit_mapdrvstren.c  |  292 +
 .../src/ddrphy_phyinit_progcsrskiptrain.c     | 1016 +++
 .../phyinit/src/ddrphy_phyinit_reginterface.c |  167 +
 .../src/ddrphy_phyinit_restore_sequence.c     |  102 +
 .../phy/phyinit/src/ddrphy_phyinit_sequence.c |  137 +
 .../phyinit/src/ddrphy_phyinit_softsetmb.c    |  108 +
 .../src/ddrphy_phyinit_sr_complete_function.c |   72 +
 .../src/ddrphy_phyinit_sr_start_function.c    |   71 +
 .../src/ddrphy_phyinit_storeincvfile.c        |   72 +
 .../phyinit/src/ddrphy_phyinit_storemsgblk.c  |   29 +
 .../phyinit/src/ddrphy_phyinit_writeoutmem.c  |   77 +
 ...ddrphy_phyinit_usercustom_a_bringuppower.c |   37 +
 ..._phyinit_usercustom_b_startclockresetphy.c |   46 +
 ...drphy_phyinit_usercustom_customposttrain.c |   46 +
 ...ddrphy_phyinit_usercustom_custompretrain.c |   93 +
 .../ddrphy_phyinit_usercustom_e_setdficlk.c   |   42 +
 .../ddrphy_phyinit_usercustom_g_waitfwdone.c  |  185 +
 ...ddrphy_phyinit_usercustom_h_readmsgblock.c |   42 +
 ...hy_phyinit_usercustom_j_entermissionmode.c |   41 +
 .../ddrphy_phyinit_usercustom_saveretregs.c   |  414 +
 .../ddrphy_phyinit_usercustom_sr_wait.c       |   40 +
 drivers/st/ddr/stm32mp1_ddr.c                 |  489 +-
 drivers/st/ddr/stm32mp1_ddr_helpers.c         |  546 +-
 drivers/st/ddr/stm32mp1_ram.c                 |  265 +-
 drivers/st/ddr/stm32mp2_ddr.c                 |  411 +
 drivers/st/ddr/stm32mp2_ddr_helpers.c         |  265 +
 drivers/st/ddr/stm32mp2_ram.c                 |  215 +
 drivers/st/ddr/stm32mp_ddr.c                  |  297 +
 drivers/st/ddr/stm32mp_ddr_test.c             |  148 +
 drivers/st/ddr/stm32mp_ram.c                  |   59 +
 drivers/st/etzpc/etzpc.c                      |   72 +-
 drivers/st/fmc/stm32_fmc2_nand.c              |  145 +-
 drivers/st/gpio/stm32_gpio.c                  |  181 +-
 drivers/st/i2c/stm32_i2c.c                    |  459 +-
 drivers/st/io/io_stm32image.c                 |  379 -
 drivers/st/iwdg/stm32_iwdg.c                  |  151 +-
 drivers/st/mce/stm32_mce.c                    |  425 +
 drivers/st/mmc/stm32_sdmmc2.c                 |   99 +-
 drivers/st/pmic/stm32mp_pmic.c                |  566 +-
 drivers/st/pmic/stpmic1.c                     |  217 +-
 drivers/st/regulator/regulator_fixed.c        |   91 +
 drivers/st/regulator/regulator_gpio.c         |  166 +
 drivers/st/reset/stm32mp1_reset.c             |   33 +-
 drivers/st/reset/stm32mp2_reset.c             |   76 +
 drivers/st/rif/stm32mp2_risaf.c               |  624 ++
 drivers/st/rng/stm32_rng.c                    |  246 +
 drivers/st/rtc/stm32_rtc.c                    |  480 ++
 drivers/st/spi/stm32_ospi.c                   |  595 ++
 drivers/st/spi/stm32_qspi.c                   |   18 +-
 drivers/st/tamper/stm32_tamp.c                |  681 ++
 drivers/st/timer/stm32_timer.c                |  322 +
 drivers/st/uart/aarch32/stm32_console.S       |   48 +-
 drivers/st/uart/aarch64/stm32_console.S       |  254 +
 drivers/st/uart/stm32_uart.c                  |  440 ++
 drivers/st/usb_dwc3/usb_dwc3.c                | 2357 ++++++
 drivers/st/usb_dwc3/usb_dwc3_regs.h           | 1225 +++
 drivers/usb/usb_device.c                      |   21 +-
 fdts/stm32mp1-cot-descriptors.dtsi            |  158 +
 fdts/stm32mp13-bl2.dtsi                       |   87 +
 fdts/stm32mp13-ddr.dtsi                       |  184 +
 fdts/stm32mp13-ddr3-1x4Gb-1066-binF.dtsi      |  100 +
 fdts/stm32mp13-fw-config-mem-encrypt.dtsi     |   11 +
 fdts/stm32mp13-fw-config.dtsi                 |   56 +
 fdts/stm32mp13-pinctrl.dtsi                   |  103 +
 fdts/stm32mp13-ssp-bl2.dtsi                   |   52 +
 fdts/stm32mp131.dtsi                          |  579 ++
 fdts/stm32mp133.dtsi                          |    7 +
 fdts/stm32mp135.dtsi                          |    7 +
 fdts/stm32mp135f-dk-fw-config.dts             |    8 +
 fdts/stm32mp135f-dk.dts                       |  329 +
 fdts/stm32mp13xa.dtsi                         |    5 +
 fdts/stm32mp13xc.dtsi                         |   27 +
 fdts/stm32mp13xd.dtsi                         |    5 +
 fdts/stm32mp13xf.dtsi                         |   26 +
 fdts/stm32mp15-bl2.dtsi                       |   33 +-
 fdts/stm32mp15-bl32.dtsi                      |    3 +-
 fdts/stm32mp15-ddr.dtsi                       |   15 -
 fdts/stm32mp15-ddr3-1x4Gb-1066-binG.dtsi      |   12 -
 fdts/stm32mp15-ddr3-2x4Gb-1066-binG.dtsi      |   12 -
 fdts/stm32mp15-fw-config.dtsi                 |   20 +-
 fdts/stm32mp15-ssp-bl2.dtsi                   |   98 +
 fdts/stm32mp151.dtsi                          |   65 +-
 fdts/stm32mp153.dtsi                          |    1 +
 fdts/stm32mp157a-avenger96.dts                |   25 +-
 fdts/stm32mp157a-dk1.dts                      |   18 +
 fdts/stm32mp157a-ed1.dts                      |   38 +
 fdts/stm32mp157a-ev1.dts                      |   24 +
 fdts/stm32mp157c-dk2.dts                      |   18 +
 fdts/stm32mp157c-ed1.dts                      |  331 +-
 fdts/stm32mp157c-ev1.dts                      |   44 +-
 fdts/stm32mp157c-odyssey-som.dtsi             |    6 +-
 fdts/stm32mp157d-dk1.dts                      |   45 +
 fdts/stm32mp157d-ed1.dts                      |   39 +
 fdts/stm32mp157d-ev1.dts                      |   23 +
 fdts/stm32mp157f-dk2.dts                      |   51 +
 fdts/stm32mp157f-ed1.dts                      |   43 +
 fdts/stm32mp157f-ev1.dts                      |   23 +
 fdts/stm32mp15xa.dtsi                         |   13 +
 fdts/stm32mp15xc.dtsi                         |    2 +
 fdts/stm32mp15xd.dtsi                         |   19 +
 fdts/stm32mp15xf.dtsi                         |   20 +
 fdts/stm32mp15xx-dkx.dtsi                     |  158 +-
 fdts/stm32mp15xx-edx.dtsi                     |  491 ++
 fdts/stm32mp15xx-evx.dtsi                     |   73 +
 fdts/stm32mp15xx-osd32.dtsi                   |    6 +-
 fdts/stm32mp15xxaa-pinctrl.dtsi               |    2 +-
 fdts/stm32mp15xxac-pinctrl.dtsi               |    2 +-
 fdts/stm32mp25-bl2.dtsi                       |   54 +
 fdts/stm32mp25-ddr.dtsi                       |  249 +
 ...32mp25-ddr4-2x8Gbits-2x16bits-1200MHz.dtsi |  246 +
 ...m32mp25-ddr4-2x8Gbits-2x16bits-800MHz.dtsi |  246 +
 fdts/stm32mp25-fw-config.dtsi                 |   49 +
 ...p25-lpddr4-1x16Gbits-1x32bits-1200MHz.dtsi |  247 +
 ...mp25-lpddr4-1x16Gbits-1x32bits-800MHz.dtsi |  247 +
 fdts/stm32mp25-pinctrl-test.dtsi              |   74 +
 fdts/stm32mp25-pinctrl.dtsi                   |    7 +
 fdts/stm32mp251.dtsi                          |  568 ++
 fdts/stm32mp253.dtsi                          |    6 +
 fdts/stm32mp255.dtsi                          |    9 +
 fdts/stm32mp257.dtsi                          |    9 +
 fdts/stm32mp257f-dk-fw-config.dts             |    7 +
 fdts/stm32mp257f-dk.dts                       |   36 +
 fdts/stm32mp257f-ev-fw-config.dts             |    7 +
 fdts/stm32mp257f-ev.dts                       |   36 +
 fdts/stm32mp257f-valid3-ca35tdcid-rcc.dtsi    |   94 +
 .../stm32mp257f-valid3-daughter-fw-config.dts |    7 +
 fdts/stm32mp257f-valid3-daughter.dts          |  172 +
 fdts/stm32mp257f-valid3-fw-config.dts         |    7 +
 fdts/stm32mp257f-valid3.dts                   |   14 +
 fdts/stm32mp25xc.dtsi                         |    8 +
 fdts/stm32mp25xf.dtsi                         |    8 +
 fdts/stm32mp25xxai-pinctrl.dtsi               |   81 +
 fdts/stm32mp25xxak-pinctrl.dtsi               |   69 +
 fdts/stm32mp25xxal-pinctrl.dtsi               |   69 +
 include/arch/aarch32/arch.h                   |   18 +-
 include/arch/aarch32/arch_helpers.h           |    4 +
 include/arch/aarch64/arch.h                   |    6 +-
 include/common/tbbr/cot_def.h                 |    2 +-
 include/drivers/clk.h                         |   28 +
 include/drivers/fwu/fwu.h                     |    1 +
 include/drivers/io/io_storage.h               |    3 +-
 include/drivers/mmc.h                         |   25 +
 include/drivers/nand.h                        |    2 +
 include/drivers/partition/efi.h               |   37 +
 include/drivers/partition/gpt.h               |    9 +-
 include/drivers/partition/partition.h         |   10 +-
 include/drivers/regulator.h                   |  155 +
 include/drivers/spi_mem.h                     |   12 +
 include/drivers/spi_nand.h                    |    4 +
 include/drivers/spi_nor.h                     |    6 +
 include/drivers/st/bsec.h                     |  204 +-
 include/drivers/st/bsec2_reg.h                |  102 +
 include/drivers/st/bsec3_reg.h                |  103 +
 include/drivers/st/io_stm32image.h            |   32 -
 include/drivers/st/regulator_fixed.h          |   12 +
 include/drivers/st/regulator_gpio.h           |   12 +
 include/drivers/st/stm32_gpio.h               |   24 +-
 include/drivers/st/stm32_hash.h               |    8 +-
 include/drivers/st/stm32_i2c.h                |   38 +-
 include/drivers/st/stm32_iwdg.h               |    1 +
 include/drivers/st/stm32_mce.h                |   46 +
 include/drivers/st/stm32_ospi.h               |   12 +
 include/drivers/st/stm32_pka.h                |   46 +
 include/drivers/st/stm32_rng.h                |   13 +
 include/drivers/st/stm32_rtc.h                |   78 +
 include/drivers/st/stm32_saes.h               |   66 +
 include/drivers/st/stm32_sdmmc2.h             |    2 +
 include/drivers/st/stm32_tamp.h               |  252 +
 include/drivers/st/stm32_timer.h              |   21 +
 include/drivers/st/stm32_uart.h               |  159 +
 include/drivers/st/stm32mp13_rcc.h            | 1878 +++++
 include/drivers/st/stm32mp15_rcc.h            | 2328 ++++++
 include/drivers/st/stm32mp1_calib.h           |   20 +
 include/drivers/st/stm32mp1_clk.h             |   50 +-
 include/drivers/st/stm32mp1_ddr.h             |   65 +-
 include/drivers/st/stm32mp1_ddr_helpers.h     |   18 +-
 include/drivers/st/stm32mp1_ddr_regs.h        |  235 +-
 include/drivers/st/stm32mp1_pwr.h             |   24 +-
 include/drivers/st/stm32mp1_ram.h             |    3 +-
 include/drivers/st/stm32mp1_rcc.h             | 2328 +-----
 include/drivers/st/stm32mp2_clk.h             |   43 +
 include/drivers/st/stm32mp2_ddr.h             |  137 +
 include/drivers/st/stm32mp2_ddr_helpers.h     |   28 +
 include/drivers/st/stm32mp2_ddr_regs.h        |   29 +
 include/drivers/st/stm32mp2_pwr.h             |  478 ++
 include/drivers/st/stm32mp2_ram.h             |   13 +
 include/drivers/st/stm32mp2_rcc.h             | 4986 ++++++++++++
 include/drivers/st/stm32mp2_risaf.h           |   15 +
 include/drivers/st/stm32mp_clkfunc.h          |   19 +-
 include/drivers/st/stm32mp_ddr.h              |   82 +
 include/drivers/st/stm32mp_ddr_test.h         |   15 +
 include/drivers/st/stm32mp_ddrctrl_regs.h     |  273 +
 include/drivers/st/stm32mp_pmic.h             |   32 +-
 include/drivers/st/stm32mp_ram.h              |   33 +
 include/drivers/st/stm32mp_reset.h            |   14 +-
 include/drivers/st/stm32mp_rifsc_regs.h       |   35 +
 include/drivers/st/stm32mp_risab_regs.h       |  271 +
 include/drivers/st/stpmic1.h                  |   35 +-
 include/drivers/st/usb_dwc3.h                 |  244 +
 include/drivers/usb_device.h                  |   11 +
 include/dt-bindings/clock/stm32mp1-clks.h     |  278 +-
 include/dt-bindings/clock/stm32mp1-clksrc.h   |  284 +-
 include/dt-bindings/clock/stm32mp13-clks.h    |  230 +
 include/dt-bindings/clock/stm32mp13-clksrc.h  |  394 +
 include/dt-bindings/clock/stm32mp15-clks.h    |  278 +
 include/dt-bindings/clock/stm32mp15-clksrc.h  |  282 +
 include/dt-bindings/clock/stm32mp2-clks.h     |  462 ++
 include/dt-bindings/clock/stm32mp2-clksrc.h   |  226 +
 include/dt-bindings/gpio/stm32-gpio.h         |   41 +
 include/dt-bindings/power/stm32mp1-power.h    |   20 +
 include/dt-bindings/reset/stm32mp1-resets.h   |  126 +-
 include/dt-bindings/reset/stm32mp13-resets.h  |   96 +
 include/dt-bindings/reset/stm32mp15-resets.h  |  123 +
 include/dt-bindings/reset/stm32mp2-resets.h   |  165 +
 include/dt-bindings/soc/rif.h                 |   95 +
 include/dt-bindings/soc/st,stm32-etzpc.h      |   86 +
 include/dt-bindings/soc/stm32mp13-mce.h       |   12 +
 include/dt-bindings/soc/stm32mp13-tzc400.h    |   34 +
 include/dt-bindings/soc/stm32mp25-rif.h       |  132 +
 include/lib/fconf/fconf_dyn_cfg_getter.h      |    5 +-
 include/lib/psci/psci.h                       |    1 +
 include/lib/utils_def.h                       |   10 +
 include/plat/common/common_def.h              |   37 +-
 include/plat/common/platform.h                |   14 +-
 lib/aarch32/misc_helpers.S                    |    4 +-
 lib/aarch64/misc_helpers.S                    |    8 +-
 lib/fconf/fconf_dyn_cfg_getter.c              |   19 +-
 lib/optee/optee_utils.c                       |   21 +-
 lib/psci/psci_private.h                       |    1 -
 make_helpers/build_macros.mk                  |    9 +-
 make_helpers/defaults.mk                      |   10 +-
 plat/arm/common/arm_io_storage.c              |    9 +-
 plat/common/aarch32/platform_helpers.S        |   34 +
 plat/common/plat_bl_common.c                  |    8 +-
 plat/st/common/bl2_io_storage.c               |  422 +-
 plat/st/common/bl2_stm32_io_storage.c         |  665 --
 plat/st/common/common.mk                      |  215 +
 plat/st/common/common_rules.mk                |   79 +
 plat/st/common/include/stm32cubeprogrammer.h  |   18 +
 plat/st/common/include/stm32mp_auth.h         |   19 -
 plat/st/common/include/stm32mp_common.h       |   80 +-
 plat/st/common/include/stm32mp_dt.h           |   11 +
 plat/st/common/include/stm32mp_efi.h          |   15 +
 plat/st/common/include/stm32mp_fconf_getter.h |    2 +
 plat/st/common/include/stm32mp_io_storage.h   |    4 +
 .../st/common/include/stm32mp_shres_helpers.h |   65 +-
 plat/st/common/include/stm32mp_svc_setup.h    |   35 +
 plat/st/common/stm32cubeprogrammer_uart.c     |  662 ++
 plat/st/common/stm32cubeprogrammer_usb.c      |  103 +-
 plat/st/common/stm32mp_auth.c                 |   90 -
 plat/st/common/stm32mp_common.c               |  330 +-
 plat/st/common/stm32mp_crypto_lib.c           |  658 ++
 plat/st/common/stm32mp_dt.c                   |  338 +-
 plat/st/common/stm32mp_fconf_fuse.c           |  103 +
 plat/st/common/stm32mp_fconf_io.c             |  102 +-
 plat/st/common/stm32mp_gic.c                  |  219 +
 plat/st/common/stm32mp_shres_helpers.c        |   63 +
 plat/st/common/stm32mp_svc_setup.c            |   81 +
 plat/st/common/stm32mp_trusted_boot.c         |  206 +
 plat/st/stm32mp1/bl2_plat_setup.c             |  403 +-
 plat/st/stm32mp1/cert_create_tbbr.mk          |   19 +
 plat/st/stm32mp1/default_metadata.json        |   37 +
 plat/st/stm32mp1/include/boot_api.h           |  720 +-
 plat/st/stm32mp1/include/plat_def_fip_uuid.h  |   14 +
 plat/st/stm32mp1/include/plat_tbbr_img_def.h  |   40 +
 plat/st/stm32mp1/include/platform_def.h       |   43 +-
 .../include/stm32mp15_mbedtls_config.h        |  119 +
 plat/st/stm32mp1/include/stm32mp1_context.h   |   33 +-
 .../stm32mp1/include/stm32mp1_critic_power.h  |   22 +
 plat/st/stm32mp1/include/stm32mp1_dbgmcu.h    |    9 +-
 plat/st/stm32mp1/include/stm32mp1_low_power.h |   23 +
 .../stm32mp1/include/stm32mp1_power_config.h  |   29 +
 plat/st/stm32mp1/include/stm32mp1_private.h   |   40 +-
 .../include/stm32mp1_shared_resources.h       |   17 +
 plat/st/stm32mp1/include/stm32mp1_smc.h       |   80 +-
 .../stm32mp1/include/tbbr/stm32mp1_tbb_cert.h |   19 +
 plat/st/stm32mp1/plat_bl2_mem_params_desc.c   |    8 +-
 plat/st/stm32mp1/plat_def_uuid_config.c       |   18 +
 plat/st/stm32mp1/plat_fiptool.mk              |   25 +
 plat/st/stm32mp1/plat_image_load.c            |   11 +-
 plat/st/stm32mp1/platform.mk                  |  412 +-
 plat/st/stm32mp1/services/bsec_svc.c          |  229 +-
 plat/st/stm32mp1/services/bsec_svc.h          |    4 -
 plat/st/stm32mp1/services/low_power_svc.c     |   23 +
 plat/st/stm32mp1/services/low_power_svc.h     |   14 +
 plat/st/stm32mp1/services/pwr_svc.c           |  103 +
 plat/st/stm32mp1/services/pwr_svc.h           |   12 +
 plat/st/stm32mp1/services/rcc_svc.c           |  141 +
 plat/st/stm32mp1/services/rcc_svc.h           |   13 +
 .../st/stm32mp1/services/stm32mp1_svc_setup.c |   89 +-
 plat/st/stm32mp1/sp_min/sp_min-stm32mp1.mk    |   27 +-
 plat/st/stm32mp1/sp_min/sp_min_setup.c        |  437 +-
 plat/st/stm32mp1/stm32mp1.S                   |    9 +-
 plat/st/stm32mp1/stm32mp1.ld.S                |   24 +-
 plat/st/stm32mp1/stm32mp1_boot_device.c       |   52 +-
 plat/st/stm32mp1/stm32mp1_context.c           |  629 +-
 plat/st/stm32mp1/stm32mp1_critic_power.c      |  167 +
 .../stm32mp1/stm32mp1_critic_power_wrapper.S  |  134 +
 plat/st/stm32mp1/stm32mp1_dbgmcu.c            |   65 +-
 plat/st/stm32mp1/stm32mp1_def.h               |  451 +-
 plat/st/stm32mp1/stm32mp1_fconf_firewall.c    |   24 +-
 plat/st/stm32mp1/stm32mp1_fip_def.h           |  121 +-
 plat/st/stm32mp1/stm32mp1_gic.c               |   92 -
 plat/st/stm32mp1/stm32mp1_helper.S            |  133 +
 plat/st/stm32mp1/stm32mp1_low_power.c         |  441 ++
 plat/st/stm32mp1/stm32mp1_pm.c                |  112 +-
 plat/st/stm32mp1/stm32mp1_power_config.c      |  229 +
 plat/st/stm32mp1/stm32mp1_private.c           |  662 +-
 plat/st/stm32mp1/stm32mp1_scmi.c              |  131 +-
 plat/st/stm32mp1/stm32mp1_security.c          |  135 -
 plat/st/stm32mp1/stm32mp1_shared_resources.c  |  207 +-
 plat/st/stm32mp1/stm32mp1_ssp.c               | 1050 +++
 plat/st/stm32mp1/stm32mp1_ssp.mk              |  104 +
 plat/st/stm32mp1/stm32mp1_stm32image_def.h    |   73 -
 plat/st/stm32mp1/stm32mp1_syscfg.c            |  330 +-
 plat/st/stm32mp1/stm32mp1_tbb_cert.c          |   36 +
 plat/st/stm32mp1/stm32mp1_usb_dfu.c           |   72 +-
 plat/st/stm32mp2/.gitignore                   |    1 +
 plat/st/stm32mp2/aarch64/stm32mp2.S           |   11 +
 plat/st/stm32mp2/aarch64/stm32mp2.ld.S        |   71 +
 plat/st/stm32mp2/aarch64/stm32mp2_helper.S    |  228 +
 plat/st/stm32mp2/bl2_plat_setup.c             |  435 ++
 plat/st/stm32mp2/bl31_plat_setup.c            |  107 +
 plat/st/stm32mp2/include/boot_api.h           |  391 +
 plat/st/stm32mp2/include/plat_def_fip_uuid.h  |   15 +
 plat/st/stm32mp2/include/plat_macros.S        |   13 +
 plat/st/stm32mp2/include/plat_tbbr_img_def.h  |   22 +
 plat/st/stm32mp2/include/platform_def.h       |  191 +
 plat/st/stm32mp2/include/stm32mp2_private.h   |   59 +
 plat/st/stm32mp2/include/stm32mp2_smc.h       |   22 +
 .../plat_bl2_mem_params_desc.c}               |   91 +-
 plat/st/stm32mp2/plat_image_load.c            |   38 +
 plat/st/stm32mp2/platform.mk                  |  288 +
 plat/st/stm32mp2/services/stgen_svc.c         |   40 +
 plat/st/stm32mp2/services/stgen_svc.h         |   12 +
 .../st/stm32mp2/services/stm32mp2_svc_setup.c |   46 +
 plat/st/stm32mp2/stm32mp2_boot_device.c       |  173 +
 plat/st/stm32mp2/stm32mp2_def.h               |  545 ++
 plat/st/stm32mp2/stm32mp2_fconf_firewall.c    |   26 +
 plat/st/stm32mp2/stm32mp2_pm.c                |  241 +
 plat/st/stm32mp2/stm32mp2_private.c           |  482 ++
 plat/st/stm32mp2/stm32mp2_pwr.c               |  188 +
 plat/st/stm32mp2/stm32mp2_syscfg.c            |  166 +
 plat/st/stm32mp2/stm32mp2_topology.c          |   57 +
 plat/st/stm32mp2/stm32mp2_usb_dfu.c           |  375 +
 tools/cert_create/Makefile                    |    4 +-
 tools/cert_create/include/key.h               |    6 +-
 tools/cert_create/src/key.c                   |   20 +-
 tools/cert_create/src/main.c                  |    3 +-
 tools/encrypt_fw/Makefile                     |    6 +-
 tools/fiptool/Makefile                        |    6 +-
 tools/fwu_gen_metadata/README.md              |   87 +
 tools/fwu_gen_metadata/fwumd_tool.py          |  181 +
 tools/fwu_gen_metadata/src/metadata.py        |  102 +
 tools/fwu_gen_metadata/src/structs.py         |  262 +
 tools/fwu_gen_metadata/src/utils.py           |   69 +
 tools/fwu_gen_metadata/src/uuid_t.py          |   79 +
 tools/fwu_gen_metadata/tests/testall.sh       |   21 +
 .../fwu_gen_metadata/tests/validate_stable.sh |    8 +
 tools/st/plat_fiptool/plat_def_uuid_config.c  |   20 +
 tools/st/plat_fiptool/plat_fiptool.mk         |   25 +
 tools/stm32image/stm32image.c                 |  188 +-
 444 files changed, 83733 insertions(+), 8848 deletions(-)
 create mode 100644 CONTRIBUTING.md
 create mode 100644 SECURITY.md
 create mode 100644 docs/devicetree/bindings/arm/secure.txt
 create mode 100644 docs/devicetree/bindings/clock/st,stm32mp1-rcc.txt
 create mode 100644 docs/devicetree/bindings/clock/st,stm32mp13-rcc.txt
 create mode 100644 docs/devicetree/bindings/i2c/i2c-stm32.txt
 create mode 100644 docs/devicetree/bindings/memory-controllers/st,stm32mp1-ddr.txt
 create mode 100644 docs/devicetree/bindings/mmc/mmci.txt
 create mode 100644 docs/devicetree/bindings/mmc/st,stm32-sdmmc2.txt
 create mode 100644 docs/devicetree/bindings/power/st,stm32mp1-pwr.txt
 create mode 100644 docs/devicetree/bindings/power/st,stpmic1.txt
 create mode 100644 docs/devicetree/bindings/reset/st,stm32mp1-rcc.txt
 create mode 100644 docs/devicetree/bindings/rng/st,stm32-rng.txt
 create mode 100644 docs/devicetree/bindings/serial/st,stm32-usart.txt
 create mode 100644 docs/devicetree/bindings/soc/st,stm32-etzpc.txt
 create mode 100644 docs/devicetree/bindings/soc/st,stm32-romem.txt
 create mode 100644 docs/devicetree/bindings/soc/st,stm32-stgen.txt
 create mode 100644 docs/devicetree/bindings/soc/st,stm32-tamp.txt
 create mode 100644 docs/devicetree/bindings/watchdog/st,stm32-iwdg.txt
 create mode 100644 drivers/clk/clk.c
 create mode 100644 drivers/regulator/regulator_core.c
 delete mode 100644 drivers/st/bsec/bsec.c
 create mode 100644 drivers/st/bsec/bsec2.c
 create mode 100644 drivers/st/bsec/bsec3.c
 create mode 100644 drivers/st/clk/clk-stm32-core.c
 create mode 100644 drivers/st/clk/clk-stm32-core.h
 create mode 100644 drivers/st/clk/clk-stm32mp13.c
 create mode 100644 drivers/st/clk/stm32mp1_calib.c
 create mode 100644 drivers/st/clk/stm32mp2_clk.c
 create mode 100644 drivers/st/crypto/stm32_pka.c
 create mode 100644 drivers/st/crypto/stm32_saes.c
 create mode 100644 drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_ddr3.h
 create mode 100644 drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_ddr4.h
 create mode 100644 drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_lpddr4.h
 create mode 100644 drivers/st/ddr/phy/phyinit/include/ddrphy_csr_all_cdefines.h
 create mode 100644 drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit.h
 create mode 100644 drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit_struct.h
 create mode 100644 drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit_usercustom.h
 create mode 100644 drivers/st/ddr/phy/phyinit/include/ddrphy_wrapper.h
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_c_initphyconfig.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_calcmb.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_d_loadimem.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_f_loaddmem.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_g_execfw.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_globals.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_h_readmsgblock.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_i_loadpieimage.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_initstruct.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_isdbytedisabled.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_load_sr_fw.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_loadpieprodcode.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_main.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_mapdrvstren.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_progcsrskiptrain.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_reginterface.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_restore_sequence.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_sequence.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_softsetmb.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_sr_complete_function.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_sr_start_function.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_storeincvfile.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_storemsgblk.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_writeoutmem.c
 create mode 100644 drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_a_bringuppower.c
 create mode 100644 drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_b_startclockresetphy.c
 create mode 100644 drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_customposttrain.c
 create mode 100644 drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_custompretrain.c
 create mode 100644 drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_e_setdficlk.c
 create mode 100644 drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_g_waitfwdone.c
 create mode 100644 drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_h_readmsgblock.c
 create mode 100644 drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_j_entermissionmode.c
 create mode 100644 drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_saveretregs.c
 create mode 100644 drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_sr_wait.c
 create mode 100644 drivers/st/ddr/stm32mp2_ddr.c
 create mode 100644 drivers/st/ddr/stm32mp2_ddr_helpers.c
 create mode 100644 drivers/st/ddr/stm32mp2_ram.c
 create mode 100644 drivers/st/ddr/stm32mp_ddr.c
 create mode 100644 drivers/st/ddr/stm32mp_ddr_test.c
 create mode 100644 drivers/st/ddr/stm32mp_ram.c
 delete mode 100644 drivers/st/io/io_stm32image.c
 create mode 100644 drivers/st/mce/stm32_mce.c
 create mode 100644 drivers/st/regulator/regulator_fixed.c
 create mode 100644 drivers/st/regulator/regulator_gpio.c
 create mode 100644 drivers/st/reset/stm32mp2_reset.c
 create mode 100644 drivers/st/rif/stm32mp2_risaf.c
 create mode 100644 drivers/st/rng/stm32_rng.c
 create mode 100644 drivers/st/rtc/stm32_rtc.c
 create mode 100644 drivers/st/spi/stm32_ospi.c
 create mode 100644 drivers/st/tamper/stm32_tamp.c
 create mode 100644 drivers/st/timer/stm32_timer.c
 create mode 100644 drivers/st/uart/aarch64/stm32_console.S
 create mode 100644 drivers/st/uart/stm32_uart.c
 create mode 100644 drivers/st/usb_dwc3/usb_dwc3.c
 create mode 100644 drivers/st/usb_dwc3/usb_dwc3_regs.h
 create mode 100644 fdts/stm32mp1-cot-descriptors.dtsi
 create mode 100644 fdts/stm32mp13-bl2.dtsi
 create mode 100644 fdts/stm32mp13-ddr.dtsi
 create mode 100644 fdts/stm32mp13-ddr3-1x4Gb-1066-binF.dtsi
 create mode 100644 fdts/stm32mp13-fw-config-mem-encrypt.dtsi
 create mode 100644 fdts/stm32mp13-fw-config.dtsi
 create mode 100644 fdts/stm32mp13-pinctrl.dtsi
 create mode 100644 fdts/stm32mp13-ssp-bl2.dtsi
 create mode 100644 fdts/stm32mp131.dtsi
 create mode 100644 fdts/stm32mp133.dtsi
 create mode 100644 fdts/stm32mp135.dtsi
 create mode 100644 fdts/stm32mp135f-dk-fw-config.dts
 create mode 100644 fdts/stm32mp135f-dk.dts
 create mode 100644 fdts/stm32mp13xa.dtsi
 create mode 100644 fdts/stm32mp13xc.dtsi
 create mode 100644 fdts/stm32mp13xd.dtsi
 create mode 100644 fdts/stm32mp13xf.dtsi
 create mode 100644 fdts/stm32mp15-ssp-bl2.dtsi
 create mode 100644 fdts/stm32mp157a-ed1.dts
 create mode 100644 fdts/stm32mp157a-ev1.dts
 create mode 100644 fdts/stm32mp157d-dk1.dts
 create mode 100644 fdts/stm32mp157d-ed1.dts
 create mode 100644 fdts/stm32mp157d-ev1.dts
 create mode 100644 fdts/stm32mp157f-dk2.dts
 create mode 100644 fdts/stm32mp157f-ed1.dts
 create mode 100644 fdts/stm32mp157f-ev1.dts
 create mode 100644 fdts/stm32mp15xa.dtsi
 create mode 100644 fdts/stm32mp15xd.dtsi
 create mode 100644 fdts/stm32mp15xf.dtsi
 create mode 100644 fdts/stm32mp15xx-edx.dtsi
 create mode 100644 fdts/stm32mp15xx-evx.dtsi
 create mode 100644 fdts/stm32mp25-bl2.dtsi
 create mode 100644 fdts/stm32mp25-ddr.dtsi
 create mode 100644 fdts/stm32mp25-ddr4-2x8Gbits-2x16bits-1200MHz.dtsi
 create mode 100644 fdts/stm32mp25-ddr4-2x8Gbits-2x16bits-800MHz.dtsi
 create mode 100644 fdts/stm32mp25-fw-config.dtsi
 create mode 100644 fdts/stm32mp25-lpddr4-1x16Gbits-1x32bits-1200MHz.dtsi
 create mode 100644 fdts/stm32mp25-lpddr4-1x16Gbits-1x32bits-800MHz.dtsi
 create mode 100644 fdts/stm32mp25-pinctrl-test.dtsi
 create mode 100644 fdts/stm32mp25-pinctrl.dtsi
 create mode 100644 fdts/stm32mp251.dtsi
 create mode 100644 fdts/stm32mp253.dtsi
 create mode 100644 fdts/stm32mp255.dtsi
 create mode 100644 fdts/stm32mp257.dtsi
 create mode 100644 fdts/stm32mp257f-dk-fw-config.dts
 create mode 100644 fdts/stm32mp257f-dk.dts
 create mode 100644 fdts/stm32mp257f-ev-fw-config.dts
 create mode 100644 fdts/stm32mp257f-ev.dts
 create mode 100644 fdts/stm32mp257f-valid3-ca35tdcid-rcc.dtsi
 create mode 100644 fdts/stm32mp257f-valid3-daughter-fw-config.dts
 create mode 100644 fdts/stm32mp257f-valid3-daughter.dts
 create mode 100644 fdts/stm32mp257f-valid3-fw-config.dts
 create mode 100644 fdts/stm32mp257f-valid3.dts
 create mode 100644 fdts/stm32mp25xc.dtsi
 create mode 100644 fdts/stm32mp25xf.dtsi
 create mode 100644 fdts/stm32mp25xxai-pinctrl.dtsi
 create mode 100644 fdts/stm32mp25xxak-pinctrl.dtsi
 create mode 100644 fdts/stm32mp25xxal-pinctrl.dtsi
 create mode 100644 include/drivers/clk.h
 create mode 100644 include/drivers/partition/efi.h
 create mode 100644 include/drivers/regulator.h
 create mode 100644 include/drivers/st/bsec2_reg.h
 create mode 100644 include/drivers/st/bsec3_reg.h
 delete mode 100644 include/drivers/st/io_stm32image.h
 create mode 100644 include/drivers/st/regulator_fixed.h
 create mode 100644 include/drivers/st/regulator_gpio.h
 create mode 100644 include/drivers/st/stm32_mce.h
 create mode 100644 include/drivers/st/stm32_ospi.h
 create mode 100644 include/drivers/st/stm32_pka.h
 create mode 100644 include/drivers/st/stm32_rng.h
 create mode 100644 include/drivers/st/stm32_rtc.h
 create mode 100644 include/drivers/st/stm32_saes.h
 create mode 100644 include/drivers/st/stm32_tamp.h
 create mode 100644 include/drivers/st/stm32_timer.h
 create mode 100644 include/drivers/st/stm32_uart.h
 create mode 100644 include/drivers/st/stm32mp13_rcc.h
 create mode 100644 include/drivers/st/stm32mp15_rcc.h
 create mode 100644 include/drivers/st/stm32mp1_calib.h
 create mode 100644 include/drivers/st/stm32mp2_clk.h
 create mode 100644 include/drivers/st/stm32mp2_ddr.h
 create mode 100644 include/drivers/st/stm32mp2_ddr_helpers.h
 create mode 100644 include/drivers/st/stm32mp2_ddr_regs.h
 create mode 100644 include/drivers/st/stm32mp2_pwr.h
 create mode 100644 include/drivers/st/stm32mp2_ram.h
 create mode 100644 include/drivers/st/stm32mp2_rcc.h
 create mode 100644 include/drivers/st/stm32mp2_risaf.h
 create mode 100644 include/drivers/st/stm32mp_ddr.h
 create mode 100644 include/drivers/st/stm32mp_ddr_test.h
 create mode 100644 include/drivers/st/stm32mp_ddrctrl_regs.h
 create mode 100644 include/drivers/st/stm32mp_ram.h
 create mode 100644 include/drivers/st/stm32mp_rifsc_regs.h
 create mode 100644 include/drivers/st/stm32mp_risab_regs.h
 create mode 100644 include/drivers/st/usb_dwc3.h
 create mode 100644 include/dt-bindings/clock/stm32mp13-clks.h
 create mode 100644 include/dt-bindings/clock/stm32mp13-clksrc.h
 create mode 100644 include/dt-bindings/clock/stm32mp15-clks.h
 create mode 100644 include/dt-bindings/clock/stm32mp15-clksrc.h
 create mode 100644 include/dt-bindings/clock/stm32mp2-clks.h
 create mode 100644 include/dt-bindings/clock/stm32mp2-clksrc.h
 create mode 100644 include/dt-bindings/gpio/stm32-gpio.h
 create mode 100644 include/dt-bindings/power/stm32mp1-power.h
 create mode 100644 include/dt-bindings/reset/stm32mp13-resets.h
 create mode 100644 include/dt-bindings/reset/stm32mp15-resets.h
 create mode 100644 include/dt-bindings/reset/stm32mp2-resets.h
 create mode 100644 include/dt-bindings/soc/rif.h
 create mode 100644 include/dt-bindings/soc/stm32mp13-mce.h
 create mode 100644 include/dt-bindings/soc/stm32mp13-tzc400.h
 create mode 100644 include/dt-bindings/soc/stm32mp25-rif.h
 delete mode 100644 plat/st/common/bl2_stm32_io_storage.c
 create mode 100644 plat/st/common/common.mk
 create mode 100644 plat/st/common/common_rules.mk
 delete mode 100644 plat/st/common/include/stm32mp_auth.h
 create mode 100644 plat/st/common/include/stm32mp_efi.h
 create mode 100644 plat/st/common/include/stm32mp_svc_setup.h
 create mode 100644 plat/st/common/stm32cubeprogrammer_uart.c
 delete mode 100644 plat/st/common/stm32mp_auth.c
 create mode 100644 plat/st/common/stm32mp_crypto_lib.c
 create mode 100644 plat/st/common/stm32mp_fconf_fuse.c
 create mode 100644 plat/st/common/stm32mp_gic.c
 create mode 100644 plat/st/common/stm32mp_shres_helpers.c
 create mode 100644 plat/st/common/stm32mp_svc_setup.c
 create mode 100644 plat/st/common/stm32mp_trusted_boot.c
 create mode 100644 plat/st/stm32mp1/cert_create_tbbr.mk
 create mode 100644 plat/st/stm32mp1/default_metadata.json
 create mode 100644 plat/st/stm32mp1/include/plat_def_fip_uuid.h
 create mode 100644 plat/st/stm32mp1/include/plat_tbbr_img_def.h
 create mode 100644 plat/st/stm32mp1/include/stm32mp15_mbedtls_config.h
 create mode 100644 plat/st/stm32mp1/include/stm32mp1_critic_power.h
 create mode 100644 plat/st/stm32mp1/include/stm32mp1_low_power.h
 create mode 100644 plat/st/stm32mp1/include/stm32mp1_power_config.h
 create mode 100644 plat/st/stm32mp1/include/tbbr/stm32mp1_tbb_cert.h
 create mode 100644 plat/st/stm32mp1/plat_def_uuid_config.c
 create mode 100644 plat/st/stm32mp1/plat_fiptool.mk
 create mode 100644 plat/st/stm32mp1/services/low_power_svc.c
 create mode 100644 plat/st/stm32mp1/services/low_power_svc.h
 create mode 100644 plat/st/stm32mp1/services/pwr_svc.c
 create mode 100644 plat/st/stm32mp1/services/pwr_svc.h
 create mode 100644 plat/st/stm32mp1/services/rcc_svc.c
 create mode 100644 plat/st/stm32mp1/services/rcc_svc.h
 create mode 100644 plat/st/stm32mp1/stm32mp1_critic_power.c
 create mode 100644 plat/st/stm32mp1/stm32mp1_critic_power_wrapper.S
 delete mode 100644 plat/st/stm32mp1/stm32mp1_gic.c
 create mode 100644 plat/st/stm32mp1/stm32mp1_low_power.c
 create mode 100644 plat/st/stm32mp1/stm32mp1_power_config.c
 delete mode 100644 plat/st/stm32mp1/stm32mp1_security.c
 create mode 100644 plat/st/stm32mp1/stm32mp1_ssp.c
 create mode 100644 plat/st/stm32mp1/stm32mp1_ssp.mk
 delete mode 100644 plat/st/stm32mp1/stm32mp1_stm32image_def.h
 create mode 100644 plat/st/stm32mp1/stm32mp1_tbb_cert.c
 create mode 100644 plat/st/stm32mp2/.gitignore
 create mode 100644 plat/st/stm32mp2/aarch64/stm32mp2.S
 create mode 100644 plat/st/stm32mp2/aarch64/stm32mp2.ld.S
 create mode 100644 plat/st/stm32mp2/aarch64/stm32mp2_helper.S
 create mode 100644 plat/st/stm32mp2/bl2_plat_setup.c
 create mode 100644 plat/st/stm32mp2/bl31_plat_setup.c
 create mode 100644 plat/st/stm32mp2/include/boot_api.h
 create mode 100644 plat/st/stm32mp2/include/plat_def_fip_uuid.h
 create mode 100644 plat/st/stm32mp2/include/plat_macros.S
 create mode 100644 plat/st/stm32mp2/include/plat_tbbr_img_def.h
 create mode 100644 plat/st/stm32mp2/include/platform_def.h
 create mode 100644 plat/st/stm32mp2/include/stm32mp2_private.h
 create mode 100644 plat/st/stm32mp2/include/stm32mp2_smc.h
 rename plat/st/{stm32mp1/plat_bl2_stm32_mem_params_desc.c => stm32mp2/plat_bl2_mem_params_desc.c} (55%)
 create mode 100644 plat/st/stm32mp2/plat_image_load.c
 create mode 100644 plat/st/stm32mp2/platform.mk
 create mode 100644 plat/st/stm32mp2/services/stgen_svc.c
 create mode 100644 plat/st/stm32mp2/services/stgen_svc.h
 create mode 100644 plat/st/stm32mp2/services/stm32mp2_svc_setup.c
 create mode 100644 plat/st/stm32mp2/stm32mp2_boot_device.c
 create mode 100644 plat/st/stm32mp2/stm32mp2_def.h
 create mode 100644 plat/st/stm32mp2/stm32mp2_fconf_firewall.c
 create mode 100644 plat/st/stm32mp2/stm32mp2_pm.c
 create mode 100644 plat/st/stm32mp2/stm32mp2_private.c
 create mode 100644 plat/st/stm32mp2/stm32mp2_pwr.c
 create mode 100644 plat/st/stm32mp2/stm32mp2_syscfg.c
 create mode 100644 plat/st/stm32mp2/stm32mp2_topology.c
 create mode 100644 plat/st/stm32mp2/stm32mp2_usb_dfu.c
 create mode 100644 tools/fwu_gen_metadata/README.md
 create mode 100755 tools/fwu_gen_metadata/fwumd_tool.py
 create mode 100644 tools/fwu_gen_metadata/src/metadata.py
 create mode 100644 tools/fwu_gen_metadata/src/structs.py
 create mode 100644 tools/fwu_gen_metadata/src/utils.py
 create mode 100644 tools/fwu_gen_metadata/src/uuid_t.py
 create mode 100755 tools/fwu_gen_metadata/tests/testall.sh
 create mode 100755 tools/fwu_gen_metadata/tests/validate_stable.sh
 create mode 100644 tools/st/plat_fiptool/plat_def_uuid_config.c
 create mode 100644 tools/st/plat_fiptool/plat_fiptool.mk

diff --git a/.commitlintrc.js b/.commitlintrc.js
index 3bd68bb6c..f97048188 100644
--- a/.commitlintrc.js
+++ b/.commitlintrc.js
@@ -46,7 +46,7 @@ module.exports = {
         "change-id-exists": [1, "always", "Change-Id:"], /* Warning */
         "signed-off-by-exists": [1, "always", "Signed-off-by:"], /* Warning */
 
-        "scope-case": [2, "always", "kebab-case"], /* Error */
+        "scope-case": [2, "always", "lower-case"], /* Error */
         "scope-enum": [1, "always", scopes] /* Warning */
     },
 };
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 000000000..3d1bacd78
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,30 @@
+﻿# Contributing guide
+
+This document serves as a checklist before contributing to this repository. It includes links to read up on if topics are unclear to you.
+
+This guide mainly focuses on the proper use of Git.
+
+## 1. Issues
+
+STM32MPU projects do not activate "Github issues" feature for the time being. If you need to report an issue or question about this project deliverables, you can report them using [ ST Support Center ](https://my.st.com/ols#/ols/newrequest)  or  [ ST Community MPU Forum ](https://community.st.com/s/topic/0TO0X0000003u2AWAQ/stm32-mpus).
+
+## 2. Pull Requests
+
+STMicrolectronics is happy to receive contributions from the community, based on an initial Contributor License Agreement (CLA) procedure.
+
+* If you are an individual writing original source code and you are sure **you own the intellectual property**, then you need to sign an Individual CLA (https://cla.st.com).
+* If you work for a company that wants also to allow you to contribute with your work, your company needs to provide a Corporate CLA (https://cla.st.com) mentioning your GitHub account name.
+* If you are not sure that a CLA (Individual or Corporate) has been signed for your GitHub account you can check here (https://cla.st.com).
+
+Please note that:
+* The Corporate CLA will always take precedence over the Individual CLA.
+* One CLA submission is sufficient, for any project proposed by STMicroelectronics.
+
+__How to proceed__
+
+* We recommend to fork the project in your GitHub account to further develop your contribution. Please use the latest commit version.
+* Please, submit one Pull Request for one new feature or proposal. This will ease the analysis and final merge if accepted.
+
+__Note__
+
+Merge will not be done directly in GitHub but it will need first to follow internal integration process before public deliver in a standard release. The Pull request will stay open until it is merged and delivered.
diff --git a/Makefile b/Makefile
index 73007b413..77b9dd76c 100644
--- a/Makefile
+++ b/Makefile
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2013-2021, Arm Limited and Contributors. All rights reserved.
+# Copyright (c) 2013-2022, Arm Limited and Contributors. All rights reserved.
 #
 # SPDX-License-Identifier: BSD-3-Clause
 #
@@ -170,6 +170,11 @@ FIP_DEPS += enctool
 FWU_FIP_DEPS += enctool
 endif
 
+ifeq (${PSA_FWU_SUPPORT},1)
+FWUMD_ARGS += --nb-fw-imgs ${NR_OF_FW_BANKS}
+FWUMD_ARGS += --nb-banks ${NR_OF_IMAGES_IN_FW_BANK}
+endif
+
 ################################################################################
 # Toolchain
 ################################################################################
@@ -918,6 +923,10 @@ ENCTOOL			?=	${ENCTOOLPATH}/encrypt_fw${BIN_EXT}
 FIPTOOLPATH		?=	tools/fiptool
 FIPTOOL			?=	${FIPTOOLPATH}/fiptool${BIN_EXT}
 
+# Variables for use with Firmware Update Metadata
+FWUMDTOOLPATH		?=	tools/fwu_gen_metadata/
+FWUMDTOOL		?=	${FWUMDTOOLPATH}/fwumd_tool.py
+
 # Variables for use with sptool
 SPTOOLPATH		?=	tools/sptool
 SPTOOL			?=	${SPTOOLPATH}/sptool${BIN_EXT}
@@ -1041,6 +1050,7 @@ $(eval $(call assert_booleans,\
         ENABLE_FEAT_HCX \
         ENABLE_MPMM \
         ENABLE_MPMM_FCONF \
+        AARCH32_EXCEPTION_DEBUG \
 )))
 
 $(eval $(call assert_numerics,\
@@ -1153,6 +1163,7 @@ $(eval $(call add_defines,\
         ENABLE_FEAT_HCX \
         ENABLE_MPMM \
         ENABLE_MPMM_FCONF \
+        AARCH32_EXCEPTION_DEBUG \
 )))
 
 ifeq (${SANITIZE_UB},trap)
@@ -1382,7 +1393,7 @@ checkpatch:		locate-checkpatch
 certtool: ${CRTTOOL}
 
 ${CRTTOOL}: FORCE
-	${Q}${MAKE} PLAT=${PLAT} USE_TBBR_DEFS=${USE_TBBR_DEFS} COT=${COT} OPENSSL_DIR=${OPENSSL_DIR} CRTTOOL=${CRTTOOL} --no-print-directory -C ${CRTTOOLPATH}
+	${Q}${MAKE} PLAT=${PLAT} USE_TBBR_DEFS=${USE_TBBR_DEFS} COT=${COT} CRTTOOL=${CRTTOOL} --no-print-directory -C ${CRTTOOLPATH} all
 	@${ECHO_BLANK_LINE}
 	@echo "Built $@ successfully"
 	@${ECHO_BLANK_LINE}
@@ -1427,7 +1438,7 @@ fwu_fip: ${BUILD_PLAT}/${FWU_FIP_NAME}
 
 ${FIPTOOL}: FORCE
 ifdef UNIX_MK
-	${Q}${MAKE} CPPFLAGS="-DVERSION='\"${VERSION_STRING}\"'" FIPTOOL=${FIPTOOL} --no-print-directory -C ${FIPTOOLPATH}
+	${Q}${MAKE} CPPFLAGS="-DVERSION='\"${VERSION_STRING}\"'" FIPTOOL=${FIPTOOL} --no-print-directory -C ${FIPTOOLPATH} all
 else
 # Clear the MAKEFLAGS as we do not want
 # to pass the gnumake flags to nmake.
@@ -1452,7 +1463,7 @@ doc:
 enctool: ${ENCTOOL}
 
 ${ENCTOOL}: FORCE
-	${Q}${MAKE} PLAT=${PLAT} BUILD_INFO=0 OPENSSL_DIR=${OPENSSL_DIR} ENCTOOL=${ENCTOOL} --no-print-directory -C ${ENCTOOLPATH}
+	${Q}${MAKE} PLAT=${PLAT} BUILD_INFO=0 ENCTOOL=${ENCTOOL} --no-print-directory -C ${ENCTOOLPATH}
 	@${ECHO_BLANK_LINE}
 	@echo "Built $@ successfully"
 	@${ECHO_BLANK_LINE}
diff --git a/SECURITY.md b/SECURITY.md
new file mode 100644
index 000000000..4b3e4e6ba
--- /dev/null
+++ b/SECURITY.md
@@ -0,0 +1,8 @@
+# Report potential product security vulnerabilities
+ST places a high priority on security, and our Product Security Incident Response Team (PSIRT) is committed to rapidly addressing potential security vulnerabilities affecting our products. PSIRT's long history and vast experience in security allows ST to perform clear analyses and provide appropriate guidance on mitigations  and solutions when applicable.
+If you wish to report potential security vulnerabilities regarding our products, **please do not report them through public GitHub issues.** Instead, we encourage you to report them to our ST PSIRT following the process described at: **https://www.st.com/content/st_com/en/security/report-vulnerabilities.html**
+
+### IMPORTANT - READ CAREFULLY:
+STMicroelectronics International N.V., on behalf of itself, its affiliates and  subsidiaries, (collectively “ST”) takes all potential security vulnerability reports or other related communications (“Report(s)”)  seriously. In order to review Your Report (the terms “You” and “Yours”  include your employer, and all affiliates, subsidiaries and related  persons or entities) and take actions as deemed appropriate, ST requires that we have the rights and Your permission to do so.
+As such, by submitting Your Report to ST, You agree that You have the right to do so, and You grant to ST the rights to use the Report for purposes related to security vulnerability analysis, testing, correction, patching, reporting and any other related purpose or function.
+By submitting Your Report, You agree that ST’s [Privacy Policy](https://www.st.com/content/st_com/en/common/privacy-portal.html) applies to all related communications.
diff --git a/bl1/aarch32/bl1_entrypoint.S b/bl1/aarch32/bl1_entrypoint.S
index 94dfd3738..f6abfb166 100644
--- a/bl1/aarch32/bl1_entrypoint.S
+++ b/bl1/aarch32/bl1_entrypoint.S
@@ -21,10 +21,19 @@
 	 */
 vector_base bl1_vector_table
 	b	bl1_entrypoint
+#if AARCH32_EXCEPTION_DEBUG
+	b	report_undef_inst	/* Undef */
+#else
 	b	report_exception	/* Undef */
+#endif
 	b	bl1_aarch32_smc_handler	/* SMC call */
+#if AARCH32_EXCEPTION_DEBUG
+	b	report_prefetch_abort	/* Prefetch abort */
+	b	report_data_abort	/* Data abort */
+#else
 	b	report_exception	/* Prefetch abort */
 	b	report_exception	/* Data abort */
+#endif
 	b	report_exception	/* Reserved */
 	b	report_exception	/* IRQ */
 	b	report_exception	/* FIQ */
diff --git a/bl2/aarch32/bl2_el3_exceptions.S b/bl2/aarch32/bl2_el3_exceptions.S
index 087b6656d..dff4e36a4 100644
--- a/bl2/aarch32/bl2_el3_exceptions.S
+++ b/bl2/aarch32/bl2_el3_exceptions.S
@@ -12,10 +12,19 @@
 
 vector_base bl2_vector_table
 	b	bl2_entrypoint
+#if AARCH32_EXCEPTION_DEBUG
+	b	report_undef_inst	/* Undef */
+#else
 	b	report_exception	/* Undef */
+#endif
 	b	report_exception	/* SVC call */
+#if AARCH32_EXCEPTION_DEBUG
+	b	report_prefetch_abort	/* Prefetch abort */
+	b	report_data_abort	/* Data abort */
+#else
 	b	report_exception	/* Prefetch abort */
 	b	report_exception	/* Data abort */
+#endif
 	b	report_exception	/* Reserved */
 	b	report_exception	/* IRQ */
 	b	report_exception	/* FIQ */
diff --git a/bl2/aarch32/bl2_entrypoint.S b/bl2/aarch32/bl2_entrypoint.S
index 6e8e2c1e1..dfcec18ee 100644
--- a/bl2/aarch32/bl2_entrypoint.S
+++ b/bl2/aarch32/bl2_entrypoint.S
@@ -14,10 +14,19 @@
 
 vector_base bl2_vector_table
 	b	bl2_entrypoint
+#if AARCH32_EXCEPTION_DEBUG
+	b	report_undef_inst	/* Undef */
+#else
 	b	report_exception	/* Undef */
+#endif
 	b	report_exception	/* SVC call */
+#if AARCH32_EXCEPTION_DEBUG
+	b	report_prefetch_abort	/* Prefetch abort */
+	b	report_data_abort	/* Data abort */
+#else
 	b	report_exception	/* Prefetch abort */
 	b	report_exception	/* Data abort */
+#endif
 	b	report_exception	/* Reserved */
 	b	report_exception	/* IRQ */
 	b	report_exception	/* FIQ */
diff --git a/bl2/bl2_main.c b/bl2/bl2_main.c
index 90fe39bc2..072b5647b 100644
--- a/bl2/bl2_main.c
+++ b/bl2/bl2_main.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013-2021, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2013-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -86,7 +86,9 @@ void bl2_main(void)
 	bl2_arch_setup();
 
 #if PSA_FWU_SUPPORT
-	fwu_init();
+	if (plat_fwu_is_enabled()) {
+		fwu_init();
+	}
 #endif /* PSA_FWU_SUPPORT */
 
 #if TRUSTED_BOARD_BOOT
diff --git a/bl2u/aarch32/bl2u_entrypoint.S b/bl2u/aarch32/bl2u_entrypoint.S
index e4dd03dec..f48bc8249 100644
--- a/bl2u/aarch32/bl2u_entrypoint.S
+++ b/bl2u/aarch32/bl2u_entrypoint.S
@@ -14,10 +14,19 @@
 
 vector_base bl2u_vector_table
 	b	bl2u_entrypoint
+#if AARCH32_EXCEPTION_DEBUG
+	b	report_undef_inst	/* Undef */
+#else
 	b	report_exception	/* Undef */
+#endif
 	b	report_exception	/* SVC call */
+#if AARCH32_EXCEPTION_DEBUG
+	b	report_prefetch_abort	/* Prefetch abort */
+	b	report_data_abort	/* Data abort */
+#else
 	b	report_exception	/* Prefetch abort */
 	b	report_exception	/* Data abort */
+#endif
 	b	report_exception	/* Reserved */
 	b	report_exception	/* IRQ */
 	b	report_exception	/* FIQ */
diff --git a/bl32/sp_min/aarch32/entrypoint.S b/bl32/sp_min/aarch32/entrypoint.S
index 39f1065f0..8508d443d 100644
--- a/bl32/sp_min/aarch32/entrypoint.S
+++ b/bl32/sp_min/aarch32/entrypoint.S
@@ -49,10 +49,19 @@
 
 vector_base sp_min_vector_table
 	b	sp_min_entrypoint
+#if AARCH32_EXCEPTION_DEBUG
+	b	report_undef_inst	/* Undef */
+#else
 	b	plat_panic_handler	/* Undef */
+#endif
 	b	sp_min_handle_smc	/* Syscall */
+#if AARCH32_EXCEPTION_DEBUG
+	b	report_prefetch_abort	/* Prefetch abort */
+	b	report_data_abort	/* Data abort */
+#else
 	b	plat_panic_handler	/* Prefetch abort */
 	b	plat_panic_handler	/* Data abort */
+#endif
 	b	plat_panic_handler	/* Reserved */
 	b	plat_panic_handler	/* IRQ */
 	b	sp_min_handle_fiq	/* FIQ */
diff --git a/common/aarch32/debug.S b/common/aarch32/debug.S
index 9d410df07..69b1ed4ed 100644
--- a/common/aarch32/debug.S
+++ b/common/aarch32/debug.S
@@ -14,6 +14,11 @@
 	.globl	asm_assert
 	.globl	do_panic
 	.globl	report_exception
+#if AARCH32_EXCEPTION_DEBUG
+	.globl	report_undef_inst
+	.globl	report_prefetch_abort
+	.globl	report_data_abort
+#endif
 
 /* Since the max decimal input number is 65536 */
 #define MAX_DEC_DIVISOR		10000
@@ -113,10 +118,10 @@ endfunc asm_assert
 
 /*
  * This function prints a string from address in r4
- * Clobber: lr, r0 - r4
+ * Clobber: lr, r0 - r4, r7
  */
 func asm_print_str
-	mov	r3, lr
+	mov	r7, lr
 1:
 	ldrb	r0, [r4], #0x1
 	cmp	r0, #0
@@ -124,20 +129,20 @@ func asm_print_str
 	bl	plat_crash_console_putc
 	b	1b
 2:
-	bx	r3
+	bx	r7
 endfunc asm_print_str
 
 /*
  * This function prints a hexadecimal number in r4.
  * In: r4 = the hexadecimal to print.
- * Clobber: lr, r0 - r3, r5
+ * Clobber: lr, r0 - r3, r5, r7
  */
 func asm_print_hex
 	mov	r5, #32  /* No of bits to convert to ascii */
 
 	/* Convert to ascii number of bits in r5 */
 asm_print_hex_bits:
-	mov	r3, lr
+	mov	r7, lr
 1:
 	sub	r5, r5, #4
 	lsr	r0, r4, r5
@@ -153,7 +158,7 @@ asm_print_hex_bits:
 	bl	plat_crash_console_putc
 	cmp	r5, #0
 	bne	1b
-	bx	r3
+	bx	r7
 endfunc asm_print_hex
 
 	/***********************************************************
@@ -205,3 +210,38 @@ func report_exception
 	bl	plat_report_exception
 	no_ret	plat_panic_handler
 endfunc report_exception
+
+#if AARCH32_EXCEPTION_DEBUG
+	/***********************************************************
+	 * This function is called from the vector table for
+	 * undefined instruction. The lr_und is given as an
+	 * argument to platform handler.
+	 ***********************************************************/
+func report_undef_inst
+	mrs	r0, lr_und
+	bl	plat_report_undef_inst
+	no_ret	plat_panic_handler
+endfunc report_undef_inst
+
+	/***********************************************************
+	 * This function is called from the vector table for
+	 * unhandled exceptions. The lr_abt is given as an
+	 * argument to platform handler.
+	 ***********************************************************/
+func report_prefetch_abort
+	mrs	r0, lr_abt
+	bl	plat_report_prefetch_abort
+	no_ret	plat_panic_handler
+endfunc report_prefetch_abort
+
+	/***********************************************************
+	 * This function is called from the vector table for
+	 * unhandled exceptions. The lr_abt is given as an
+	 * argument to platform handler.
+	 ***********************************************************/
+func report_data_abort
+	mrs	r0, lr_abt
+	bl	plat_report_data_abort
+	no_ret	plat_panic_handler
+endfunc report_data_abort
+#endif
diff --git a/common/bl_common.c b/common/bl_common.c
index eb2352a77..ae7bca2c7 100644
--- a/common/bl_common.c
+++ b/common/bl_common.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013-2021, Arm Limited and Contributors. All rights reserved.
+ * Copyright (c) 2013-2022, Arm Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -259,11 +259,15 @@ int load_auth_image(unsigned int image_id, image_info_t *image_data)
  * when PSA FWU is enabled.
  */
 #if PSA_FWU_SUPPORT
-	err = load_auth_image_internal(image_id, image_data);
+	do {
+		err = load_auth_image_internal(image_id, image_data);
+	} while ((err != 0) && (plat_try_backup_partitions(image_id) != 0));
 #else
 	do {
 		err = load_auth_image_internal(image_id, image_data);
-	} while ((err != 0) && (plat_try_next_boot_source() != 0));
+	} while (((err != 0) && ((plat_try_next_boot_source() != 0) ||
+				 (plat_try_backup_partitions(image_id) != 0))));
+
 #endif /* PSA_FWU_SUPPORT */
 
 	return err;
diff --git a/docs/devicetree/bindings/arm/secure.txt b/docs/devicetree/bindings/arm/secure.txt
new file mode 100644
index 000000000..e31303fb2
--- /dev/null
+++ b/docs/devicetree/bindings/arm/secure.txt
@@ -0,0 +1,53 @@
+* ARM Secure world bindings
+
+ARM CPUs with TrustZone support have two distinct address spaces,
+"Normal" and "Secure". Most devicetree consumers (including the Linux
+kernel) are not TrustZone aware and run entirely in either the Normal
+world or the Secure world. However some devicetree consumers are
+TrustZone aware and need to be able to determine whether devices are
+visible only in the Secure address space, only in the Normal address
+space, or visible in both. (One example of that situation would be a
+virtual machine which boots Secure firmware and wants to tell the
+firmware about the layout of the machine via devicetree.)
+
+The general principle of the naming scheme for Secure world bindings
+is that any property that needs a different value in the Secure world
+can be supported by prefixing the property name with "secure-". So for
+instance "secure-foo" would override "foo". For property names with
+a vendor prefix, the Secure variant of "vendor,foo" would be
+"vendor,secure-foo". If there is no "secure-" property then the Secure
+world value is the same as specified for the Normal world by the
+non-prefixed property. However, only the properties listed below may
+validly have "secure-" versions; this list will be enlarged on a
+case-by-case basis.
+
+Defining the bindings in this way means that a device tree which has
+been annotated to indicate the presence of Secure-only devices can
+still be processed unmodified by existing Non-secure software (and in
+particular by the kernel).
+
+Note that it is still valid for bindings intended for purely Secure
+world consumers (like kernels that run entirely in Secure) to simply
+describe the view of Secure world using the standard bindings. These
+secure- bindings only need to be used where both the Secure and Normal
+world views need to be described in a single device tree.
+
+Valid Secure world properties:
+
+- secure-status : specifies whether the device is present and usable
+  in the secure world. The combination of this with "status" allows
+  the various possible combinations of device visibility to be
+  specified. If "secure-status" is not specified it defaults to the
+  same value as "status"; if "status" is not specified either then
+  both default to "okay". This means the following combinations are
+  possible:
+
+   /* Neither specified: default to visible in both S and NS */
+   secure-status = "okay";                          /* visible in both */
+   status = "okay";                                 /* visible in both */
+   status = "okay"; secure-status = "okay";         /* visible in both */
+   secure-status = "disabled";                      /* NS-only */
+   status = "okay"; secure-status = "disabled";     /* NS-only */
+   status = "disabled"; secure-status = "okay";     /* S-only */
+   status = "disabled";                             /* disabled in both */
+   status = "disabled"; secure-status = "disabled"; /* disabled in both */
diff --git a/docs/devicetree/bindings/clock/st,stm32mp1-rcc.txt b/docs/devicetree/bindings/clock/st,stm32mp1-rcc.txt
new file mode 100644
index 000000000..f227b8c55
--- /dev/null
+++ b/docs/devicetree/bindings/clock/st,stm32mp1-rcc.txt
@@ -0,0 +1,496 @@
+STMicroelectronics STM32 Peripheral Reset Clock Controller
+==========================================================
+
+The RCC IP is both a reset and a clock controller.
+
+RCC makes also power management (resume/supend and wakeup interrupt).
+
+Please also refer to reset.txt for common reset controller binding usage.
+
+Please also refer to clock-bindings.txt for common clock controller
+binding usage.
+
+
+Required properties:
+- compatible: "st,stm32mp1-rcc-secure", "st,stm32mp1-rcc", "syscon"
+  Adding "st,stm32mp1-rcc-secure" in the compatible list restricts
+  RCC access through RCC TZ_ENABLE bit.
+- reg: should be register base and length as documented in the datasheet
+- #clock-cells: 1, device nodes should specify the clock in their
+  "clocks" property, containing a phandle to the clock device node,
+  an index specifying the clock to use.
+- #reset-cells: Shall be 1
+- interrupts: Should contain a general interrupt line.
+- secure-interrupts: Should contain a interrupt line to the wake-up of
+                     processor (CSTOP).
+
+Example:
+	rcc: rcc@50000000 {
+		compatible = "st,stm32mp1-rcc", "syscon";
+		reg = <0x50000000 0x1000>;
+		#clock-cells = <1>;
+		#reset-cells = <1>;
+		interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>;
+		secure-interrupts = <GIC_SPI 145 IRQ_TYPE_LEVEL_HIGH>;
+	};
+
+Specifying clocks
+=================
+
+All available clocks are defined as preprocessor macros in
+dt-bindings/clock/stm32mp1-clks.h header and can be used in device
+tree sources.
+
+Specifying softreset control of devices
+=======================================
+
+Device nodes should specify the reset channel required in their "resets"
+property, containing a phandle to the reset device node and an index specifying
+which channel to use.
+The index is the bit number within the RCC registers bank, starting from RCC
+base address.
+It is calculated as: index = register_offset / 4 * 32 + bit_offset.
+Where bit_offset is the bit offset within the register.
+
+For example on STM32MP1, for LTDC reset:
+ ltdc = APB4_RSTSETR_offset / 4 * 32 + LTDC_bit_offset
+      = 0x180 / 4 * 32 + 0 = 3072
+
+The list of valid indices for STM32MP1 is available in:
+include/dt-bindings/reset-controller/stm32mp1-resets.h
+
+This file implements defines like:
+#define LTDC_R	3072
+
+
+Defining clock source distribution with property st,clksrc
+==========================================================
+
+- st,clksrc : The clock sources configuration array in a platform specific
+              order.
+
+  Property can be used to configure the clock distribution tree.
+  When used, it shall describe the whole distribution tree.
+
+  For the STM32MP15x family there are 9 clock sources selector which are
+  configured in the following order:
+	MPU AXI MCU PLL12 PLL3 PLL4 RTC MCO1 MCO2
+
+  Clock source configuration values are defined by macros CLK_<NAME>_<SOURCE>
+  from dt-bindings/clock/stm32mp1-clksrc.h.
+
+  Example:
+	st,clksrc = <
+		CLK_MPU_PLL1P
+		CLK_AXI_PLL2P
+		CLK_MCU_PLL3P
+		CLK_PLL12_HSE
+		CLK_PLL3_HSE
+		CLK_PLL4_HSE
+		CLK_RTC_LSE
+		CLK_MCO1_DISABLED
+		CLK_MCO2_DISABLED
+	>;
+
+Defining clock dividers with property st,clkdiv
+===============================================
+
+- st,clkdiv : The clock main dividers value specified in an array
+              in a platform specific order.
+
+  When used, it shall describe the whole clock dividers tree.
+
+  Property can be used to configure the clock main dividers value.
+  When used, it shall describe the whole clock dividers tree.
+
+  For the STM32MP15x family there are 11 dividers values expected.
+  They shall be configured in the following order:
+		MPU AXI MCU APB1 APB2 APB3 APB4 APB5 RTC MCO1 MCO2
+
+  The each divider value uses the DIV coding defined in RCC associated
+  register RCC_xxxDIVR. In most cases, it is:
+		0x0: not divided
+		0x1: division by 2
+		0x2: division by 4
+		0x3: division by 8
+		...
+
+  Note that for RTC MCO1 MCO2, the coding is different:
+		0x0: not divided
+		0x1: division by 2
+		0x2: division by 3
+		0x3: division by 4
+		...
+
+  Example:
+	st,clkdiv = <
+		1 /*MPU*/
+		0 /*AXI*/
+		0 /*MCU*/
+		1 /*APB1*/
+		1 /*APB2*/
+		1 /*APB3*/
+		1 /*APB4*/
+		2 /*APB5*/
+		23 /*RTC*/
+		0 /*MCO1*/
+		0 /*MCO2*/
+	>;
+
+Optional Properties:
+Defining peripherals kernel clock tree distribution with property st,pkcs
+=========================================================================
+
+- st,pkcs : used to configure the peripherals kernel clock selection.
+
+  The property is a list of peripheral kernel clock source identifiers defined
+  by macros CLK_<KERNEL-CLOCK>_<PARENT-CLOCK> as defined by header file
+  dt-bindings/clock/stm32mp1-clksrc.h.
+
+  st,pkcs may not list all the kernel clocks and has no ordering requirements.
+
+  Example:
+	st,pkcs = <
+		CLK_STGEN_HSE
+		CLK_CKPER_HSI
+		CLK_USBPHY_PLL2P
+		CLK_DSI_PLL2Q
+		CLK_I2C46_HSI
+		CLK_UART1_HSI
+		CLK_UART24_HSI
+	>;
+
+Defining peripheral PLL frequencies
+========================================================
+
+- children for a PLL static configuration with "st,stm32mp1-pll" compatible
+
+  Each PLL children nodes for PLL1 to PLL4 (see ref manual for details)
+  are listed with associated reg 0 to 3.
+
+  PLL2, PLL3 or PLL4 are off when their associated nodes are absent or
+  deactivated.
+
+  The configuration of PLL1, the source clock of Cortex-A7 core, with st,pll@0
+  node, is optional as TF-A automatically selects the most suitable operating
+  point for the platform.
+  The node st,pll@0 node should be absent; it is only used if you want to
+  override the PLL1 properties computed by TF-A (clock spreading for example).
+
+  Here are the available properties for each PLL node:
+    - compatible: should be "st,stm32mp1-pll"
+
+    - reg: index of the pll instance
+
+    - cfg: The parameters for PLL configuration in the following order:
+           DIVM DIVN DIVP DIVQ DIVR Output.
+
+	DIVx values are defined as in RCC spec:
+		0x0: bypass (division by 1)
+		0x1: division by 2
+		0x2: division by 3
+		0x3: division by 4
+		...
+
+	Output contains a bitfield for each output value (1:ON/0:OFF)
+		BIT(0) => output P : DIVPEN
+		BIT(1) => output Q : DIVQEN
+		BIT(2) => output R : DIVREN
+	  NB: macro PQR(p,q,r) can be used to build this value
+	      with p,q,r = 0 or 1.
+
+    - frac: Fractional part of the multiplication factor
+            (optional, PLL is in integer mode when absent).
+
+    - csg: Clock Spreading Generator (optional) with parameters in the
+	   following order: MOD_PER INC_STEP SSCG_MODE.
+
+	MOD_PER: Modulation Period Adjustment
+	INC_STEP: Modulation Depth Adjustment
+	SSCG_MODE: Spread spectrum clock generator mode, with associated
+		   defined from stm32mp1-clksrc.h:
+			- SSCG_MODE_CENTER_SPREAD = 0
+			- SSCG_MODE_DOWN_SPREAD = 1
+
+    Example:
+	st,pll@0 {
+		compatible = "st,stm32mp1-pll";
+		reg = <0>;
+		cfg = <1 53 0 0 0 1>;
+		frac = <0x810>;
+	};
+	st,pll@1 {
+		compatible = "st,stm32mp1-pll";
+		reg = <1>;
+		cfg = <1 43 1 0 0 PQR(0,1,1)>;
+		csg = <10 20 1>;
+	};
+	st,pll@2 {
+		compatible = "st,stm32mp1-pll";
+		reg = <2>;
+		cfg = <2 85 3 13 3 0>;
+		csg = <10 20 SSCG_MODE_CENTER_SPREAD>;
+	};
+	st,pll@3 {
+		compatible = "st,stm32mp1-pll";
+		reg = <3>;
+		cfg = <2 78 4 7 9 3>;
+	};
+
+Fixed clocks description
+========================
+
+The clock tree is also based on 5 fixed-clock in clocks node
+used to define the state of associated ST32MP1 oscillators:
+  - clk-lsi
+  - clk-lse
+  - clk-hsi
+  - clk-hse
+  - clk-csi
+
+At boot the clock tree initialization will
+  - enable oscillators present in device tree and not disabled
+    (node with status="disabled"),
+  - disable HSI oscillator if the node is absent (always activated by bootrom)
+    and not disabled (node with status="disabled").
+
+Optional properties :
+
+a) for external oscillator: "clk-lse", "clk-hse"
+
+  4 optional fields are managed
+  - "st,bypass" configures the oscillator bypass mode (HSEBYP, LSEBYP)
+  - "st,digbypass" configures the bypass mode as full-swing digital
+    signal (DIGBYP)
+  - "st,css" activates the clock security system (HSECSSON, LSECSSON)
+  - "st,drive" (only for LSE) contains the value of the drive for the
+     oscillator (see LSEDRV_ defined in the file
+     dt-bindings/clock/stm32mp1-clksrc.h)
+
+  Example board file:
+	/ {
+		clocks {
+			clk_hse: clk-hse {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <64000000>;
+				st,bypass;
+			};
+
+			clk_lse: clk-lse {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <32768>;
+				st,css;
+				st,drive = <LSEDRV_LOWEST>;
+			};
+	};
+
+b) for internal oscillator: "clk-hsi"
+
+  Internally HSI clock is fixed to 64MHz for STM32MP157 SoC.
+  In device tree, clk-hsi is the clock after HSIDIV (clk_hsi in RCC
+  doc). So this clock frequency is used to compute the expected HSI_DIV
+  for the clock tree initialization.
+
+  Example with HSIDIV = /1:
+	/ {
+		clocks {
+			clk_hsi: clk-hsi {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <64000000>;
+			};
+	};
+
+  Example with HSIDIV = /2
+	/ {
+		clocks {
+			clk_hsi: clk-hsi {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <32000000>;
+			};
+	};
+
+HSI & CSI calibration
+========================
+
+Calibration is an optional feature that may be enabled from device tree. It
+allows to request calibration of the HSI or the CSI clocks from several means:
+	- SiP SMC service
+	- Periodic calibration every X seconds
+	- Interrupt raised by the MCU
+
+This feature requires that a HW timer is assigned to the calibration sequence.
+
+Dedicated secure interrupt must be defined using "mcu_sev" name to start a
+calibration on detection of an interrupt raised by MCU.
+
+- st,hsi-cal: used to enable HSI clock calibration feature.
+
+- st,csi-cal; used to enable CSI clock calibration feature.
+
+- st,cal-sec: used to enable periodic calibration every specified seconds from
+  secure monitor. Time must be given in seconds. If not specified, calibration
+  is processed for each incoming request.
+
+Example:
+	&rcc {
+		st,hsi-cal;
+		st,csi-cal;
+		st,cal-sec = <15>;
+		secure-interrupts = <GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 145 IRQ_TYPE_LEVEL_HIGH>;
+		secure-interrupt-names = "mcu_sev", "wakeup";
+	};
+
+
+Example of clock tree initialization
+====================================
+
+/ {
+	clocks {
+		clk_hse: clk-hse {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+			st,digbypass;
+		};
+
+		clk_hsi: clk-hsi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <64000000>;
+		};
+
+		clk_lse: clk-lse {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <32768>;
+		};
+
+		clk_lsi: clk-lsi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <32000>;
+		};
+
+		clk_csi: clk-csi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <4000000>;
+		};
+	};
+
+	soc {
+
+		rcc: rcc@50000000 {
+			compatible = "st,stm32mp1-rcc", "syscon";
+			reg = <0x50000000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>;
+			secure-interrupts = <GIC_SPI 145 IRQ_TYPE_LEVEL_HIGH>;
+			secure-interrupt-names = "wakeup";
+
+			st,clksrc = <
+				CLK_MPU_PLL1P
+				CLK_AXI_PLL2P
+				CLK_MCU_PLL3P
+				CLK_PLL12_HSE
+				CLK_PLL3_HSE
+				CLK_PLL4_HSE
+				CLK_RTC_LSE
+				CLK_MCO1_DISABLED
+				CLK_MCO2_DISABLED
+			>;
+
+			st,clkdiv = <
+				1 /*MPU*/
+				0 /*AXI*/
+				0 /*MCU*/
+				1 /*APB1*/
+				1 /*APB2*/
+				1 /*APB3*/
+				1 /*APB4*/
+				2 /*APB5*/
+				23 /*RTC*/
+				0 /*MCO1*/
+				0 /*MCO2*/
+			>;
+
+			st,pkcs = <
+				CLK_CKPER_HSE
+				CLK_FMC_ACLK
+				CLK_QSPI_ACLK
+				CLK_ETH_DISABLED
+				CLK_SDMMC12_PLL4P
+				CLK_DSI_DSIPLL
+				CLK_STGEN_HSE
+				CLK_USBPHY_HSE
+				CLK_SPI2S1_PLL3Q
+				CLK_SPI2S23_PLL3Q
+				CLK_SPI45_HSI
+				CLK_SPI6_HSI
+				CLK_I2C46_HSI
+				CLK_SDMMC3_PLL4P
+				CLK_USBO_USBPHY
+				CLK_ADC_CKPER
+				CLK_CEC_LSE
+				CLK_I2C12_HSI
+				CLK_I2C35_HSI
+				CLK_UART1_HSI
+				CLK_UART24_HSI
+				CLK_UART35_HSI
+				CLK_UART6_HSI
+				CLK_UART78_HSI
+				CLK_SPDIF_PLL4P
+				CLK_FDCAN_PLL4Q
+				CLK_SAI1_PLL3Q
+				CLK_SAI2_PLL3Q
+				CLK_SAI3_PLL3Q
+				CLK_SAI4_PLL3Q
+				CLK_RNG1_LSI
+				CLK_RNG2_LSI
+				CLK_LPTIM1_PCLK1
+				CLK_LPTIM23_PCLK3
+				CLK_LPTIM45_LSE
+			>;
+
+			/* VCO = 1300.0 MHz => P = 650 (CPU) */
+			pll1: st,pll@0 {
+				compatible = "st,stm32mp1-pll";
+				reg = <0>;
+				cfg = <2 80 0 0 0 PQR(1,0,0)>;
+				frac = <0x800>;
+			};
+
+			/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU),
+			                       R = 533 (DDR) */
+			pll2: st,pll@1 {
+				compatible = "st,stm32mp1-pll";
+				reg = <1>;
+				cfg = <2 65 1 0 0 PQR(1,1,1)>;
+				frac = <0x1400>;
+			};
+
+			/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
+			pll3: st,pll@2 {
+				compatible = "st,stm32mp1-pll";
+				reg = <2>;
+				cfg = <1 33 1 16 36 PQR(1,1,1)>;
+				frac = <0x1a04>;
+			};
+
+			/* VCO = 594.0 MHz => P = 99, Q = 74, R = 74 */
+			pll4: st,pll@3 {
+				compatible = "st,stm32mp1-pll";
+				reg = <3>;
+				cfg = <3 98 5 7 7 PQR(1,1,1)>;
+			};
+		};
+	};
+};
diff --git a/docs/devicetree/bindings/clock/st,stm32mp13-rcc.txt b/docs/devicetree/bindings/clock/st,stm32mp13-rcc.txt
new file mode 100644
index 000000000..eb23449c2
--- /dev/null
+++ b/docs/devicetree/bindings/clock/st,stm32mp13-rcc.txt
@@ -0,0 +1,640 @@
+STMicroelectronics STM32 Peripheral Reset Clock Controller
+==========================================================
+
+The RCC IP is both a reset and a clock controller.
+
+RCC makes also power management (resume/supend and wakeup interrupt).
+
+Please also refer to reset.txt for common reset controller binding usage.
+
+Please also refer to clock-bindings.txt for common clock controller
+binding usage.
+
+
+Required properties:
+- compatible: "st,stm32mp13-rcc", "syscon"
+- reg: should be register base and length as documented in the datasheet
+- #clock-cells: 1, device nodes should specify the clock in their
+  "clocks" property, containing a phandle to the clock device node,
+  an index specifying the clock to use.
+- #reset-cells: Shall be 1
+- interrupts: Should contain a general interrupt line.
+- secure-interrupts: Should contain an interrupt line to the wake-up of
+                     processor (CSTOP).
+
+Example:
+	rcc: rcc@50000000 {
+		compatible = "st,stm32mp13-rcc", "syscon";
+		reg = <0x50000000 0x1000>;
+		#clock-cells = <1>;
+		#reset-cells = <1>;
+		interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>;
+		secure-interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+	};
+
+Specifying clocks
+=================
+
+All available clocks are defined as preprocessor macros in
+dt-bindings/clock/stm32mp13-clks.h header and can be used in device
+tree sources.
+
+Specifying softreset control of devices
+=======================================
+
+Device nodes should specify the reset channel required in their "resets"
+property, containing a phandle to the reset device node and an index specifying
+which channel to use.
+The index is the bit number within the RCC registers bank, starting from RCC
+base address.
+It is calculated as: index = register_offset / 4 * 32 + bit_offset.
+Where bit_offset is the bit offset within the register.
+
+For example on STM32MP13, for I2C2 reset:
+ i2c2 = APB1_RSTSETR_offset / 4 * 32 + I2C2_bit_offset
+      = 0x6A0 / 4 * 32 + 22 = 13590
+
+The list of valid indices for STM32MP13 is available in:
+include/dt-bindings/reset/stm32mp13-resets.h
+
+This file implements defines like:
+#define I2C2_R	13590
+
+
+Defining clock source distribution with property st,clksrc
+==========================================================
+
+- st,clksrc : used to configure the peripherals kernel clock selection.
+
+  The property is a list of peripheral kernel clock source identifiers defined
+  by macros CLK_<KERNEL-CLOCK>_<PARENT-CLOCK> as defined by header file
+  dt-bindings/clock/stm32mp13-clksrc.h.
+
+  st,clksrc may not list all the kernel clocks and has no ordering requirements.
+
+  Property can be used to configure the clock distribution tree.
+
+  Example:
+	st,clksrc = <
+		CLK_MPU_PLL1P
+		CLK_AXI_PLL2P
+		CLK_MLAHBS_PLL3
+		CLK_RTC_LSE
+		CLK_MCO1_DISABLED
+		CLK_MCO2_DISABLED
+		CLK_ETH1_PLL4P
+		CLK_ETH2_PLL4P
+		CLK_SDMMC1_PLL4P
+		CLK_SDMMC2_PLL4P
+		CLK_STGEN_HSE
+		CLK_USBPHY_HSE
+		CLK_I2C4_HSI
+	>;
+
+Defining clock dividers with property st,clkdiv
+===============================================
+
+- st,clkdiv : The property is a list of dividers defined
+              by macros DIV(DIV_<DIV-CLOCK>, value) as defined by header file
+	      dt-bindings/clock/stm32mp13-clksrc.h.
+
+  Property can be used to configure the clock main dividers value.
+
+  For the STM32MP13 family there are 12 dividers values expected.
+		MPU AXI MLAHB APB1 APB2 APB3 APB4 APB5 APB6 RTC MCO1 MCO2
+
+  Each divider value uses the DIV coding defined in RCC associated
+  register RCC_xxxDIVR. In most cases, it is:
+		0x0: not divided
+		0x1: division by 2
+		0x2: division by 4
+		0x3: division by 8
+		...
+
+  Note that the coding is different for:
+
+  RTC MCO1 MCO2
+		0x0: not divided
+		0x1: division by 2
+		0x2: division by 3
+		0x3: division by 4
+		...
+
+  DIV_MPU
+		0x0: no clock generated
+		0x1: division by 2
+		0x2: division by 3
+		0x3: division by 4
+		...
+		0xf: division by 16
+
+  Example:
+	st,clkdiv = <
+		DIV(DIV_MPU, 1)
+		DIV(DIV_AXI, 0)
+		DIV(DIV_MLAHB, 0)
+		DIV(DIV_APB1, 1)
+		DIV(DIV_APB2, 1)
+		DIV(DIV_APB3, 1)
+		DIV(DIV_APB4, 1)
+		DIV(DIV_APB5, 2)
+		DIV(DIV_APB6, 1)
+		DIV(DIV_RTC, 23)
+		DIV(DIV_MCO1, 0)
+		DIV(DIV_MCO2, 0)
+	>;
+
+Defining peripheral PLL frequencies
+========================================================
+
+- children for a PLL static configuration with "st,stm32mp1-pll" compatible
+
+  Each PLL children node for PLL1 to PLL4 (see ref manual for details)
+  are listed with associated reg 0 to 3.
+
+  PLL2, PLL3 or PLL4 are off when their associated nodes are absent or
+  deactivated.
+
+  The configuration of PLL1, the source clock of Cortex-A7 core, is mandatory
+  for TF-A.
+
+      Here are the available properties for each PLL node:
+    - compatible: should be "st,stm32mp1-pll"
+
+    - reg: index of the pll instance
+
+    - st,pll: Phandle of the default pll configuration.
+              A pll could have several configuration (5 max) and shoud be described in a subnode
+              just below.
+
+    - pllx_cfgx node: The PLL configuration node is composed of 2 mandatory parameters:
+        - st,pll_vco: Phandle of pll vco configuration.
+	              See description of 'st,pll_vco' node.
+
+        - st,pll_div_pqr: The parameters for PLL configuration in the following order:
+                          DIVP DIVQ DIVR Output.
+
+			  DIVx values are defined as in RCC spec:
+			  0x0: bypass (division by 1)
+			  0x1: division by 2
+			  0x2: division by 3
+			  0x3: division by 4
+			  ...
+  Note that in the next stage (e.g. OPTEE) the phandle of the default pll configuration
+  ('st,pll') could be optional (the configuration of TF-A will be kept).
+  The DVFS could apllied configuration at run-time from pllx_cfgx node.
+
+- st,pll_vco node: This node will contain all vco configuration of all PLLs in subnodes.
+                   We will found theses parameters in each subnodes.
+
+	   -src: Clock source configuration values are defined by macros CLK_<NAME>_<SOURCE>
+                 from dt-bindings/clock/stm32mp13-clksrc.h.
+
+	   -divmn: The parameters for PLL divider (DIVM) and multiplication factor (DIVN)
+	           configuration.
+
+	   - frac: Fractional part of the multiplication factor
+                   (optional, PLL is in integer mode when absent).
+
+	   - csg: Clock Spreading Generator (optional) with parameters in the
+	          following order: MOD_PER INC_STEP SSCG_MODE.
+
+	          MOD_PER: Modulation Period Adjustment
+		  INC_STEP: Modulation Depth Adjustment
+		  SSCG_MODE: Spread spectrum clock generator mode, with associated
+			     defined from stm32mp13-clksrc.h:
+		               - SSCG_MODE_CENTER_SPREAD = 0
+			       - SSCG_MODE_DOWN_SPREAD = 1
+
+    Example:
+	st,pll_vco {
+		pll1_vco_1300Mhz: pll1-vco-1300Mhz {
+			src = < CLK_PLL12_HSE >;
+			divmn = < 2 80 >;
+			frac = < 0x800 >;
+		};
+		...
+		pll2_vco_1066Mhz: pll2-vco-1066Mhz {
+			src = < CLK_PLL12_HSE >;
+			divmn = < 2 65 >;
+			frac = < 0x1400 >;
+			csg = <10 20 1>;
+		};
+		...
+	};
+
+	pll1:st,pll@0 {
+		compatible = "st,stm32mp1-pll";
+		reg = <0>;
+
+		st,pll = < &pll1_cfg1 >;
+
+		pll1_cfg1: pll1_cfg1 {
+			st,pll_vco = < &pll1_vco_1300Mhz >;
+			st,pll_div_pqr = < 0 1 1 >;
+		};
+	};
+
+	st,pll@1 {
+		compatible = "st,stm32mp1-pll";
+		reg = <1>;
+
+		st,pll = < &pll2_cfg1 >;
+
+		pll2_cfg1: pll2_cfg1 {
+			st,pll_vco = < &pll2_vco_1066Mhz >;
+			st,pll_div_pqr = < 1 0 1 >;
+		};
+	};
+
+  Note: pll1 and pll2 have same source clock, if source clock is different
+  between pll1 and pll2 a panic will be generated.
+
+Fixed clocks description
+========================
+
+The clock tree is also based on 5 fixed-clock in clocks node
+used to define the state of associated ST32MP1 oscillators:
+  - clk-lsi
+  - clk-lse
+  - clk-hsi
+  - clk-hse
+  - clk-csi
+
+At boot the clock tree initialization will
+  - enable oscillators present in device tree and not disabled
+    (node with status="disabled"),
+  - disable HSI oscillator if the node is absent (always activated by bootrom)
+    or disabled (node with status="disabled").
+
+Optional properties :
+
+a) for external oscillator: "clk-lse", "clk-hse"
+
+  4 optional fields are managed
+  - "st,bypass" configures the oscillator bypass mode (HSEBYP, LSEBYP)
+  - "st,digbypass" configures the bypass mode as full-swing digital
+    signal (DIGBYP)
+  - "st,css" activates the clock security system (HSECSSON, LSECSSON)
+  - "st,drive" (only for LSE) contains the value of the drive for the
+     oscillator (see LSEDRV_ defined in the file
+     dt-bindings/clock/stm32mp13-clksrc.h)
+
+  Example board file:
+	/ {
+		clocks {
+			clk_hse: clk-hse {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <24000000>;
+				st,bypass;
+			};
+
+			clk_lse: clk-lse {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <32768>;
+				st,css;
+				st,drive = <LSEDRV_LOWEST>;
+			};
+	};
+
+b) for internal oscillator: "clk-hsi"
+
+  Internally HSI clock is fixed to 64MHz for STM32MP13 SoC.
+  In device tree, clk-hsi is the clock after HSIDIV (clk_hsi in RCC
+  doc). So this clock frequency is used to compute the expected HSI_DIV
+  for the clock tree initialization.
+
+  Example with HSIDIV = /1:
+	/ {
+		clocks {
+			clk_hsi: clk-hsi {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <64000000>;
+			};
+	};
+
+  Example with HSIDIV = /2
+	/ {
+		clocks {
+			clk_hsi: clk-hsi {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <32000000>;
+			};
+	};
+
+HSI & CSI calibration
+========================
+
+Calibration is an optional feature that may be enabled from device tree. It
+allows to request calibration of the HSI or the CSI clocks from several means:
+	- SiP SMC service
+	- Periodic calibration every X seconds
+
+This feature requires that a HW timer is assigned to the calibration sequence.
+
+- st,hsi-cal: used to enable HSI clock calibration feature.
+
+- st,csi-cal: used to enable CSI clock calibration feature.
+
+- st,cal-sec: used to enable periodic calibration every specified seconds from
+  secure monitor. Time must be given in seconds. If not specified, calibration
+  is processed for each incoming request.
+
+Example:
+	&rcc {
+		st,hsi-cal;
+		st,csi-cal;
+		st,cal-sec = <15>;
+		secure-interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+		secure-interrupt-names = "wakeup";
+	};
+
+
+Clocks and Operating Performance Points
+=======================================
+
+- st,clk_opp node: This node will contain all operating point configurations.
+		   We can have 3 operating points:
+		     - st,ck_mpu
+		     - st,ck_axi
+		     - ck_mlahbs
+		   These nodes are not mandatory, but we have to respect the naming.
+
+                   Each node will contain a list of operating point configurations (cfg_1, cfg_2...)
+
+                   These configuration subnodes contain these properties:
+
+		   mandatory parameters:
+		     -hz: Operating point frequency in hertz
+
+		     -st,clksrc: The clock source (same syntax of 'st,clksrc' property below)
+
+		   optional parameters:
+		     -st,clkdiv: The clock divider value (same syntax of 'st,clkdiv' property below)
+
+                     -st,pll: Phandle of the pll configuration (See description of 'pllx_cfgx' node)
+
+  Note that this OPP configuration will be apllied at the run-time and will override the clock tree
+  configuration.
+
+  Example:
+			st,clk_opp {
+				st,ck_mpu {
+					cfg_1 {
+						hz = < 900000000 >;
+						st,clksrc = < CLK_MPU_PLL1P >;
+						st,pll = < &pll1_cfg1 >;
+					};
+
+					cfg_2 {
+						hz = < 650000000 >;
+						st,clksrc = < CLK_MPU_PLL1P >;
+						st,pll = < &pll1_cfg2 >;
+					}
+
+
+Example of clock tree initialization and Operating Points Performance
+=====================================================================
+
+/ {
+	clocks {
+		clk_hse: clk-hse {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+			st,digbypass;
+		};
+
+		clk_hsi: clk-hsi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <64000000>;
+		};
+
+		clk_lse: clk-lse {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <32768>;
+		};
+
+		clk_lsi: clk-lsi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <32000>;
+		};
+
+		clk_csi: clk-csi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <4000000>;
+		};
+	};
+
+	soc {
+
+		rcc: rcc@50000000 {
+			compatible = "st,stm32mp13-rcc", "syscon";
+			reg = <0x50000000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>;
+			secure-interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+			secure-interrupt-names = "wakeup";
+
+			st,clksrc = <
+				CLK_MPU_PLL1P
+				CLK_AXI_PLL2P
+				CLK_MLAHBS_PLL3
+				CLK_RTC_LSE
+				CLK_MCO1_DISABLED
+				CLK_MCO2_DISABLED
+				CLK_CKPER_HSE
+				CLK_ETH1_PLL4P
+				CLK_ETH2_PLL4P
+				CLK_SDMMC1_PLL4P
+				CLK_SDMMC2_PLL4P
+				CLK_STGEN_HSE
+				CLK_USBPHY_HSE
+				CLK_I2C4_HSI
+				CLK_USBO_USBPHY
+				CLK_ADC2_CKPER
+				CLK_I2C12_HSI
+				CLK_UART2_HSI
+				CLK_UART4_HSI
+				CLK_SAES_AXI
+				CLK_DCMIPP_PLL2Q
+				CLK_LPTIM3_PCLK3
+			>;
+
+			st,clkdiv = <
+				DIV(DIV_MPU, 1)
+				DIV(DIV_AXI, 0)
+				DIV(DIV_MLAHB, 0)
+				DIV(DIV_APB1, 1)
+				DIV(DIV_APB2, 1)
+				DIV(DIV_APB3, 1)
+				DIV(DIV_APB4, 1)
+				DIV(DIV_APB5, 2)
+				DIV(DIV_APB6, 1)
+				DIV(DIV_RTC, 0)
+				DIV(DIV_MCO1, 0)
+				DIV(DIV_MCO2, 0)
+			>;
+
+			st,pll_vco {
+				pll1_vco_1800Mhz: pll1-vco-1800Mhz {
+					src = < CLK_PLL12_HSE >;
+					divmn = < 1 74 >;
+				};
+
+				pll1_vco_1300Mhz: pll1-vco-1300Mhz {
+					src = < CLK_PLL12_HSE >;
+					divmn = < 2 80 >;
+					frac = < 0x800 >;
+				};
+
+				pll2_vco_1066Mhz: pll2-vco-1066Mhz {
+					src = < CLK_PLL12_HSE >;
+					divmn = < 2 65 >;
+					frac = < 0x1400 >;
+				};
+
+				pll3_vco_417_8Mhz: pll3-vco-417_8Mhz {
+					src = < CLK_PLL3_HSE >;
+					divmn = < 1 33 >;
+					frac = < 0x1a04 >;
+				};
+
+				pll4_vco_600Mhz: pll4-vco-600Mhz {
+					src = < CLK_PLL4_HSE >;
+					divmn = < 1 49 >;
+				};
+			};
+
+			/* VCO = 1300.0 MHz => P = 650 (CPU) */
+			pll1:st,pll@0 {
+				compatible = "st,stm32mp1-pll";
+				reg = <0>;
+
+				st,pll = < &pll1_cfg1 >;
+
+				pll1_cfg1: pll1_cfg1 {
+					st,pll_vco = < &pll1_vco_1300Mhz >;
+					st,pll_div_pqr = < 0 1 1 >;
+				};
+
+				pll1_cfg2: pll2_cfg1 {
+					st,pll_vco = < &pll1_vco_1800Mhz >;
+					st,pll_div_pqr = < 0 1 1 >;
+				};
+			};
+
+			/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 266, R = 533 (DDR) */
+			pll2:st,pll@1 {
+				compatible = "st,stm32mp1-pll";
+				reg = <1>;
+
+				st,pll = < &pll2_cfg1 >;
+
+				pll2_cfg1: pll2_cfg1 {
+					st,pll_vco = < &pll2_vco_1066Mhz >;
+					st,pll_div_pqr = < 1 0 1 >;
+				};
+			};
+
+			/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
+			pll3:st,pll@2 {
+				compatible = "st,stm32mp1-pll";
+				reg = <2>;
+
+				st,pll = < &pll3_cfg1 >;
+
+				pll3_cfg1: pll3_cfg1 {
+					st,pll_vco = < &pll3_vco_417_8Mhz >;
+					st,pll_div_pqr = < 1 16 1 >;
+				};
+			};
+
+			/* VCO = 600.0 MHz => P = 50, Q = 10, R = 100 */
+			pll4:st,pll@3 {
+				compatible = "st,stm32mp1-pll";
+				reg = <3>;
+				st,pll = < &pll4_cfg1 >;
+
+				pll4_cfg1: pll4_cfg1 {
+					st,pll_vco = < &pll4_vco_600Mhz >;
+					st,pll_div_pqr = < 11 59 5 >;
+				};
+			};
+
+			st,clk_opp {
+				st,ck_mpu {
+					cfg_1 {
+						hz = < 900000000 >;
+						st,clksrc = < CLK_MPU_PLL1P >;
+						st,pll = < &pll1_cfg1 >;
+					};
+
+					cfg_2 {
+						hz = < 650000000 >;
+						st,clksrc = < CLK_MPU_PLL1P >;
+						st,pll = < &pll1_cfg2 >;
+					};
+
+					cfg_3 {
+						hz = < 450000000 >;
+						st,clksrc = < CLK_MPU_PLL1P_DIV >;
+						st,clkdiv = < DIV(DIV_MPU, 1) >;
+						st,pll = < &pll1_cfg1 >;
+					};
+
+					cfg_4 {
+						hz = <64000000>;
+						st,clksrc = < CLK_MPU_HSI >;
+					};
+
+					cfg_5 {
+						hz = <24000000>;
+						st,clksrc = < CLK_MPU_HSE >;
+					};
+				};
+
+				st,ck_axi {
+					cfg_1 {
+						hz = <266500000>;
+						st,clksrc  = < CLK_AXI_PLL2P >;
+						st,clkdiv = < DIV(DIV_AXI, 0) >;
+						st,pll = < &pll2_cfg1 >;
+					};
+
+					cfg_2 {
+						hz = <64000000>;
+						st,clksrc  = < CLK_AXI_HSI>;
+						st,clkdiv = < DIV(DIV_AXI, 0) >;
+					};
+				};
+
+				st,ck_mlahbs {
+					cfg_1 {
+						hz = <208877930>;
+						st,clksrc  = < CLK_MLAHBS_PLL3 >;
+						st,clkdiv = < DIV(DIV_MLAHB, 0) >;
+						st,pll = < &pll3_cfg1 >;
+					};
+
+					cfg_2 {
+						hz = <12000000>;
+						st,clksrc  = < CLK_MLAHBS_HSE>;
+						st,clkdiv = < DIV(DIV_MLAHB, 1) >;
+					};
+				};
+			};
+		};
+	};
+};
diff --git a/docs/devicetree/bindings/i2c/i2c-stm32.txt b/docs/devicetree/bindings/i2c/i2c-stm32.txt
new file mode 100644
index 000000000..68aefa6dc
--- /dev/null
+++ b/docs/devicetree/bindings/i2c/i2c-stm32.txt
@@ -0,0 +1,54 @@
+* I2C controller embedded in STMicroelectronics STM32 I2C platform
+
+Required properties :
+- compatible : Must be one of the following
+  - "st,stm32f7-i2c"
+- reg : Offset and length of the register set for the device
+- resets: Must contain the phandle to the reset controller.
+- clocks: Must contain the input clock of the I2C instance.
+- A pinctrl state named "default" must be defined to set pins in mode of
+  operation for I2C transfer. An optional pinctrl state named "sleep" has to
+  be defined as well as to put I2C in low power mode in suspend mode.
+- #address-cells = <1>;
+- #size-cells = <0>;
+
+Optional properties :
+- clock-frequency : Desired I2C bus clock frequency in Hz. If not specified,
+  the default 100 kHz frequency will be used.
+- i2c-scl-rising-time-ns : Only for STM32F7, I2C SCL Rising time for the board
+  (default: 25)
+- i2c-scl-falling-time-ns : Only for STM32F7, I2C SCL Falling time for the board
+  (default: 10)
+  I2C Timings are derived from these 2 values
+- st,syscfg-fmp:  Only for STM32F7, use to set Fast Mode Plus bit within SYSCFG
+  whether Fast Mode Plus speed is selected by slave.
+	1st cell : phandle to syscfg
+	2nd cell : register offset within SYSCFG
+	3rd cell : register bitmask for FMP bit
+
+Example :
+
+	i2c@40005400 {
+		compatible = "st,stm32f4-i2c";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x40005400 0x400>;
+		resets = <&rcc 277>;
+		clocks = <&rcc 0 149>;
+		pinctrl-0 = <&i2c1_sda_pin>, <&i2c1_scl_pin>;
+		pinctrl-names = "default";
+	};
+
+	i2c@40005400 {
+		compatible = "st,stm32f7-i2c";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x40005400 0x400>;
+		resets = <&rcc STM32F7_APB1_RESET(I2C1)>;
+		clocks = <&rcc 1 CLK_I2C1>;
+		pinctrl-0 = <&i2c1_sda_pin>, <&i2c1_scl_pin>;
+		pinctrl-1 =  <&i2c1_sda_pin_sleep>, <&i2c1_scl_pin_sleep>;
+		pinctrl-names = "default", "sleep";
+		st,syscfg-fmp = <&syscfg 0x4 0x1>;
+	};
+
diff --git a/docs/devicetree/bindings/memory-controllers/st,stm32mp1-ddr.txt b/docs/devicetree/bindings/memory-controllers/st,stm32mp1-ddr.txt
new file mode 100644
index 000000000..ec610925b
--- /dev/null
+++ b/docs/devicetree/bindings/memory-controllers/st,stm32mp1-ddr.txt
@@ -0,0 +1,289 @@
+ST,stm32mp1 DDR3/LPDDR2/LPDDR3 Controller (DDRCTRL and DDRPHYC)
+
+--------------------
+Required properties:
+--------------------
+- compatible	: Should be "st,stm32mp1-ddr" for STM32MP15x
+		  Should be "st,stm32mp13-ddr" for STM32MP13x
+- reg		: controleur (DDRCTRL) and phy (DDRPHYC) base address
+- clocks	: controller clocks handle
+- clock-names	: associated controller clock names
+		  the "ddrphyc" clock is used to check the DDR frequency
+		  at phy level according the expected value in "mem-speed" field
+
+the next attributes are DDR parameters, they are generated by DDR tools
+included in STM32 Cube tool
+
+info attributes:
+----------------
+- st,mem-name	: name for DDR configuration, simple string for information
+- st,mem-speed	: DDR expected speed for the setting in kHz
+- st,mem-size	: DDR mem size in byte
+
+
+controlleur attributes:
+-----------------------
+- st,ctl-reg	: controleur values depending of the DDR type
+		  (DDR3/LPDDR2/LPDDR3)
+	for STM32MP13x and STM32MP15x: 25 values are requested in this order
+		MSTR
+		MRCTRL0
+		MRCTRL1
+		DERATEEN
+		DERATEINT
+		PWRCTL
+		PWRTMG
+		HWLPCTL
+		RFSHCTL0
+		RFSHCTL3
+		CRCPARCTL0
+		ZQCTL0
+		DFITMG0
+		DFITMG1
+		DFILPCFG0
+		DFIUPD0
+		DFIUPD1
+		DFIUPD2
+		DFIPHYMSTR
+		ODTMAP
+		DBG0
+		DBG1
+		DBGCMD
+		POISONCFG
+		PCCFG
+
+- st,ctl-timing	: controleur values depending of frequency and timing parameter
+		  of DDR
+	for STM32MP13x and STM32MP15x: 12 values are requested in this order
+		RFSHTMG
+		DRAMTMG0
+		DRAMTMG1
+		DRAMTMG2
+		DRAMTMG3
+		DRAMTMG4
+		DRAMTMG5
+		DRAMTMG6
+		DRAMTMG7
+		DRAMTMG8
+		DRAMTMG14
+		ODTCFG
+
+- st,ctl-map	: controleur values depending of address mapping
+	for STM32MP13x and STM32MP15x: 9 values are requested in this order
+		ADDRMAP1
+		ADDRMAP2
+		ADDRMAP3
+		ADDRMAP4
+		ADDRMAP5
+		ADDRMAP6
+		ADDRMAP9
+		ADDRMAP10
+		ADDRMAP11
+
+- st,ctl-perf	: controleur values depending of performance and scheduling
+	for STM32MP13x: 11 values are requested in this order
+		SCHED
+		SCHED1
+		PERFHPR1
+		PERFLPR1
+		PERFWR1
+		PCFGR_0
+		PCFGW_0
+		PCFGQOS0_0
+		PCFGQOS1_0
+		PCFGWQOS0_0
+		PCFGWQOS1_0
+
+	for STM32MP15x: 17 values are requested in this order
+		SCHED
+		SCHED1
+		PERFHPR1
+		PERFLPR1
+		PERFWR1
+		PCFGR_0
+		PCFGW_0
+		PCFGQOS0_0
+		PCFGQOS1_0
+		PCFGWQOS0_0
+		PCFGWQOS1_0
+		PCFGR_1
+		PCFGW_1
+		PCFGQOS0_1
+		PCFGQOS1_1
+		PCFGWQOS0_1
+		PCFGWQOS1_1
+
+phyc attributes:
+----------------
+- st,phy-reg	: phy values depending of the DDR type (DDR3/LPDDR2/LPDDR3)
+	for STM32MP13x: 9 values are requested in this order
+		PGCR
+		ACIOCR
+		DXCCR
+		DSGCR
+		DCR
+		ODTCR
+		ZQ0CR1
+		DX0GCR
+		DX1GCR
+
+	for STM32MP15x: 11 values are requested in this order
+		PGCR
+		ACIOCR
+		DXCCR
+		DSGCR
+		DCR
+		ODTCR
+		ZQ0CR1
+		DX0GCR
+		DX1GCR
+		DX2GCR
+		DX3GCR
+
+- st,phy-timing	: phy values depending of frequency and timing parameter of DDR
+	for STM32MP13x and STM32MP15x: 10 values are requested in this order
+		PTR0
+		PTR1
+		PTR2
+		DTPR0
+		DTPR1
+		DTPR2
+		MR0
+		MR1
+		MR2
+		MR3
+
+Example:
+
+/ {
+	soc {
+		ddr: ddr@0x5A003000{
+			compatible = "st,stm32mp1-ddr";
+
+			reg = <0x5A003000 0x550
+			       0x5A004000 0x234>;
+
+			clocks = <&rcc_clk AXIDCG>,
+				 <&rcc_clk DDRC1>,
+				 <&rcc_clk DDRC2>,
+				 <&rcc_clk DDRPHYC>,
+				 <&rcc_clk DDRCAPB>,
+				 <&rcc_clk DDRPHYCAPB>;
+
+			clock-names = "axidcg",
+				      "ddrc1",
+				      "ddrc2",
+				      "ddrphyc",
+				      "ddrcapb",
+				      "ddrphycapb";
+
+			st,mem-name = "DDR3 2x4Gb 533MHz";
+			st,mem-speed = <533000>;
+			st,mem-size = <0x40000000>;
+
+			st,ctl-reg = <
+				0x00040401 /*MSTR*/
+				0x00000010 /*MRCTRL0*/
+				0x00000000 /*MRCTRL1*/
+				0x00000000 /*DERATEEN*/
+				0x00800000 /*DERATEINT*/
+				0x00000000 /*PWRCTL*/
+				0x00400010 /*PWRTMG*/
+				0x00000000 /*HWLPCTL*/
+				0x00210000 /*RFSHCTL0*/
+				0x00000000 /*RFSHCTL3*/
+				0x00000000 /*CRCPARCTL0*/
+				0xC2000040 /*ZQCTL0*/
+				0x02050105 /*DFITMG0*/
+				0x00000202 /*DFITMG1*/
+				0x07000000 /*DFILPCFG0*/
+				0xC0400003 /*DFIUPD0*/
+				0x00000000 /*DFIUPD1*/
+				0x00000000 /*DFIUPD2*/
+				0x00000000 /*DFIPHYMSTR*/
+				0x00000001 /*ODTMAP*/
+				0x00000000 /*DBG0*/
+				0x00000000 /*DBG1*/
+				0x00000000 /*DBGCMD*/
+				0x00000000 /*POISONCFG*/
+				0x00000010 /*PCCFG*/
+			>;
+
+			st,ctl-timing = <
+				0x0080008A /*RFSHTMG*/
+				0x121B2414 /*DRAMTMG0*/
+				0x000D041B /*DRAMTMG1*/
+				0x0607080E /*DRAMTMG2*/
+				0x0050400C /*DRAMTMG3*/
+				0x07040407 /*DRAMTMG4*/
+				0x06060303 /*DRAMTMG5*/
+				0x02020002 /*DRAMTMG6*/
+				0x00000202 /*DRAMTMG7*/
+				0x00001005 /*DRAMTMG8*/
+				0x000D041B /*DRAMTMG1*/4
+				0x06000600 /*ODTCFG*/
+			>;
+
+			st,ctl-map = <
+				0x00080808 /*ADDRMAP1*/
+				0x00000000 /*ADDRMAP2*/
+				0x00000000 /*ADDRMAP3*/
+				0x00001F1F /*ADDRMAP4*/
+				0x07070707 /*ADDRMAP5*/
+				0x0F070707 /*ADDRMAP6*/
+				0x00000000 /*ADDRMAP9*/
+				0x00000000 /*ADDRMAP10*/
+				0x00000000 /*ADDRMAP11*/
+			>;
+
+			st,ctl-perf = <
+				0x00001201 /*SCHED*/
+				0x00001201 /*SCHED*/1
+				0x01000001 /*PERFHPR1*/
+				0x08000200 /*PERFLPR1*/
+				0x08000400 /*PERFWR1*/
+				0x00010000 /*PCFGR_0*/
+				0x00000000 /*PCFGW_0*/
+				0x02100B03 /*PCFGQOS0_0*/
+				0x00800100 /*PCFGQOS1_0*/
+				0x01100B03 /*PCFGWQOS0_0*/
+				0x01000200 /*PCFGWQOS1_0*/
+				0x00010000 /*PCFGR_1*/
+				0x00000000 /*PCFGW_1*/
+				0x02100B03 /*PCFGQOS0_1*/
+				0x00800000 /*PCFGQOS1_1*/
+				0x01100B03 /*PCFGWQOS0_1*/
+				0x01000200 /*PCFGWQOS1_1*/
+			>;
+
+			st,phy-reg = <
+				0x01442E02 /*PGCR*/
+				0x10400812 /*ACIOCR*/
+				0x00000C40 /*DXCCR*/
+				0xF200001F /*DSGCR*/
+				0x0000000B /*DCR*/
+				0x00010000 /*ODTCR*/
+				0x0000007B /*ZQ0CR1*/
+				0x0000CE81 /*DX0GCR*/
+				0x0000CE81 /*DX1GCR*/
+				0x0000CE81 /*DX2GCR*/
+				0x0000CE81 /*DX3GCR*/
+			>;
+
+			st,phy-timing = <
+				0x0022A41B /*PTR0*/
+				0x047C0740 /*PTR1*/
+				0x042D9C80 /*PTR2*/
+				0x369477D0 /*DTPR0*/
+				0x098A00D8 /*DTPR1*/
+				0x10023600 /*DTPR2*/
+				0x00000830 /*MR0*/
+				0x00000000 /*MR1*/
+				0x00000208 /*MR2*/
+				0x00000000 /*MR3*/
+			>;
+
+			status = "okay";
+		};
+	};
+};
diff --git a/docs/devicetree/bindings/mmc/mmci.txt b/docs/devicetree/bindings/mmc/mmci.txt
new file mode 100644
index 000000000..6d3c626e0
--- /dev/null
+++ b/docs/devicetree/bindings/mmc/mmci.txt
@@ -0,0 +1,72 @@
+* ARM PrimeCell MultiMedia Card Interface (MMCI) PL180/1
+
+The ARM PrimeCell MMCI PL180 and PL181 provides an interface for
+reading and writing to MultiMedia and SD cards alike.
+
+This file documents differences between the core properties described
+by mmc.txt and the properties used by the mmci driver. Using "st" as
+the prefix for a property, indicates support by the ST Micro variant.
+
+Required properties:
+- compatible             : contains "arm,pl18x", "arm,primecell".
+- vmmc-supply            : phandle to the regulator device tree node, mentioned
+                           as the VCC/VDD supply in the eMMC/SD specs.
+
+Optional properties:
+- arm,primecell-periphid : contains the PrimeCell Peripheral ID, it overrides
+                           the ID provided by the HW
+- resets                 : phandle to internal reset line.
+			   Should be defined for sdmmc variant.
+- vqmmc-supply           : phandle to the regulator device tree node, mentioned
+                           as the VCCQ/VDD_IO supply in the eMMC/SD specs.
+specific for ux500 variant:
+- st,sig-dir-dat0        : bus signal direction pin used for DAT[0].
+- st,sig-dir-dat2        : bus signal direction pin used for DAT[2].
+- st,sig-dir-dat31       : bus signal direction pin used for DAT[3] and DAT[1].
+- st,sig-dir-dat74       : bus signal direction pin used for DAT[4] to DAT[7].
+- st,sig-dir-cmd         : cmd signal direction pin used for CMD.
+- st,sig-pin-fbclk       : feedback clock signal pin used.
+
+specific for sdmmc variant:
+- st,sig-dir             : signal direction polarity used for cmd, dat0 dat123.
+- st,neg-edge            : data & command phase relation, generated on
+                           sd clock falling edge.
+- st,use-ckin            : use ckin pin from an external driver to sample
+                           the receive data (example: with voltage
+			   switch transceiver).
+
+Deprecated properties:
+- mmc-cap-mmc-highspeed  : indicates whether MMC is high speed capable.
+- mmc-cap-sd-highspeed   : indicates whether SD is high speed capable.
+
+Example:
+
+sdi0_per1@80126000 {
+	compatible = "arm,pl18x", "arm,primecell";
+	reg = <0x80126000 0x1000>;
+	interrupts = <0 60 IRQ_TYPE_LEVEL_HIGH>;
+
+	dmas = <&dma 29 0 0x2>, /* Logical - DevToMem */
+	       <&dma 29 0 0x0>; /* Logical - MemToDev */
+	dma-names = "rx", "tx";
+
+	clocks = <&prcc_kclk 1 5>, <&prcc_pclk 1 5>;
+	clock-names = "sdi", "apb_pclk";
+
+	max-frequency = <100000000>;
+	bus-width = <4>;
+	cap-sd-highspeed;
+	cap-mmc-highspeed;
+	cd-gpios  = <&gpio2 31 0x4>; // 95
+	st,sig-dir-dat0;
+	st,sig-dir-dat2;
+	st,sig-dir-cmd;
+	st,sig-pin-fbclk;
+
+	vmmc-supply = <&ab8500_ldo_aux3_reg>;
+	vqmmc-supply = <&vmmci>;
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdi0_default_mode>;
+	pinctrl-1 = <&sdi0_sleep_mode>;
+};
diff --git a/docs/devicetree/bindings/mmc/st,stm32-sdmmc2.txt b/docs/devicetree/bindings/mmc/st,stm32-sdmmc2.txt
new file mode 100644
index 000000000..51576a384
--- /dev/null
+++ b/docs/devicetree/bindings/mmc/st,stm32-sdmmc2.txt
@@ -0,0 +1,22 @@
+* STMicroelectronics STM32 SDMMC2 controller
+
+The highspeed MMC host controller on STM32 soc family
+provides an interface for MMC, SD and SDIO types of memory cards.
+
+This file documents differences between the core properties described
+by mmci.txt and the properties used by the sdmmc2 driver.
+
+Required properties:
+ - compatible: should be one of:
+   "st,stm32-sdmmc2"
+
+Example:
+	sdmmc1: sdmmc@0x58005000 {
+		compatible = "st,stm32-sdmmc2";
+		reg = <0x58005000 0x1000>;
+		clocks = <&rcc SDMMC1_K>;
+		resets = <&rcc SDMMC1_R>;
+		cap-sd-highspeed;
+		cap-mmc-highspeed;
+		status = "disabled";
+	};
diff --git a/docs/devicetree/bindings/power/st,stm32mp1-pwr.txt b/docs/devicetree/bindings/power/st,stm32mp1-pwr.txt
new file mode 100644
index 000000000..22779b05a
--- /dev/null
+++ b/docs/devicetree/bindings/power/st,stm32mp1-pwr.txt
@@ -0,0 +1,43 @@
+STMicroelectronics STM32MP1 Power Management Controller
+=======================================================
+
+The PWR IP is responsible for handling the power related resources such as
+clocks, power supplies and resets. It provides 6 wake-up pins that are handled
+by an interrupt-controller. Wake-up pin can be used to wake-up from STANDBY SoC
+state.
+
+Required properties:
+- compatible should be: "st,stm32mp1-pwr", "st,stm32-pwr"
+- reg: should be register base and length as documented in the
+  datasheet
+
+Optional Properties:
+- Nodes corresponding to PSCI commands issued by kernel:
+  - system_suspend_supported_soc_modes: list of supported SoC modes in suspend
+  - system_off_soc_mode: SoC mode for shutdown
+  - st,retram-enabled-in-standby-ddr-sr: enable retram during standby-ddr-sr
+
+The list of SoC modes is in include/dt-bindings/power/stm32mp1-power.h:
+  - modes for system_suspend
+	1 -> STM32_PM_CSTOP_ALLOW_STOP
+	2 -> STM32_PM_CSTOP_ALLOW_LP_STOP
+	3 -> STM32_PM_CSTOP_ALLOW_LPLV_STOP
+	4 -> STM32_PM_CSTOP_ALLOW_STANDBY_DDR_SR
+  - modes for system_off
+	6 -> STM32_PM_CSTOP_ALLOW_STANDBY_DDR_OFF
+	7 -> STM32_PM_SHUTDOWN
+
+Example:
+
+pwr: pwr@50001000 {
+	compatible = "st,stm32mp1-pwr", "st,stm32-pwr", "syscon", "simple-mfd";
+	reg = <0x50001000 0x400>;
+
+	system_suspend_supported_soc_modes = <
+		STM32_PM_CSLEEP_RUN
+		STM32_PM_CSTOP_ALLOW_LP_STOP
+		STM32_PM_CSTOP_ALLOW_STANDBY_DDR_SR
+	>;
+
+	system_off_soc_mode = <STM32_PM_CSTOP_ALLOW_STANDBY_DDR_OFF>;
+};
diff --git a/docs/devicetree/bindings/power/st,stpmic1.txt b/docs/devicetree/bindings/power/st,stpmic1.txt
new file mode 100644
index 000000000..83307d23b
--- /dev/null
+++ b/docs/devicetree/bindings/power/st,stpmic1.txt
@@ -0,0 +1,94 @@
+* STMicroelectronics STPMIC1 Power Management IC
+
+Required parent device properties:
+- compatible:			"st,stpmic1"
+- reg:				The I2C slave address for the STPMIC1 chip.
+- interrupts:			The interrupt lines the device is connected to.
+				The second interrupt is used for wake-up.
+- #interrupt-cells:		Should be 2.
+- interrupt-controller: 	Describes the STPMIC1 as an interrupt
+  controller (has its own domain). Interrupt number are the following:
+	/* Interrupt Register 1 (0x50 for latch) */
+	IT_SWOUT_R=0
+	IT_SWOUT_F=1
+	IT_VBUS_OTG_R=2
+	IT_VBUS_OTG_F=3
+	IT_WAKEUP_R=4
+	IT_WAKEUP_F=5
+	IT_PONKEY_R=6
+	IT_PONKEY_F=7
+	/* Interrupt Register 2 (0x51 for latch) */
+	IT_OVP_BOOST=8
+	IT_OCP_BOOST=9
+	IT_OCP_SWOUT=10
+	IT_OCP_OTG=11
+	IT_CURLIM_BUCK4=12
+	IT_CURLIM_BUCK3=13
+	IT_CURLIM_BUCK2=14
+	IT_CURLIM_BUCK1=15
+	/* Interrupt Register 3 (0x52 for latch) */
+	IT_SHORT_SWOUT=16
+	IT_SHORT_SWOTG=17
+	IT_CURLIM_LDO6=18
+	IT_CURLIM_LDO5=19
+	IT_CURLIM_LDO4=20
+	IT_CURLIM_LDO3=21
+	IT_CURLIM_LDO2=22
+	IT_CURLIM_LDO1=23
+	/* Interrupt Register 3 (0x52 for latch) */
+	IT_SWIN_R=24
+	IT_SWIN_F=25
+	IT_RESERVED_1=26
+	IT_RESERVED_2=27
+	IT_VINLOW_R=28
+	IT_VINLOW_F=29
+	IT_TWARN_R=30
+	IT_TWARN_F=31
+
+STPMIC1 consists in a varied group of sub-devices.
+Each sub-device binding is be described in own documentation file.
+
+Device			 Description
+------			------------
+st,stpmic1-onkey	: Power on key, see ../input/st,stpmic1-onkey.txt
+st,stpmic1-regulators	: Regulators, see ../regulator/st,stpmic1-regulator.txt
+st,stpmic1-wdt		: Watchdog, see ../watchdog/st,stpmic1-wdt.txt
+
+Example:
+
+pmic: pmic@33 {
+	compatible = "st,stpmic1";
+	reg = <0x33>;
+	interrupt-parent = <&gpioa>;
+	interrupts = <0 2>;
+	interrupt-controller;
+	#interrupt-cells = <2>;
+
+	onkey {
+		compatible = "st,stpmic1-onkey";
+		interrupts = <IT_PONKEY_F 0>,<IT_PONKEY_R 1>;
+		interrupt-names = "onkey-falling", "onkey-rising";
+		power-off-time-sec = <10>;
+	};
+
+	watchdog {
+		compatible = "st,stpmic1-wdt";
+	};
+
+	regulators {
+		compatible = "st,stpmic1-regulators";
+
+		vdd_core: buck1 {
+			regulator-name = "vdd_core";
+			regulator-boot-on;
+			regulator-min-microvolt = <700000>;
+			regulator-max-microvolt = <1200000>;
+		};
+		vdd: buck3 {
+			regulator-name = "vdd";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-boot-on;
+			regulator-pull-down;
+		};
+	};
diff --git a/docs/devicetree/bindings/reset/st,stm32mp1-rcc.txt b/docs/devicetree/bindings/reset/st,stm32mp1-rcc.txt
new file mode 100644
index 000000000..b4edaf7c7
--- /dev/null
+++ b/docs/devicetree/bindings/reset/st,stm32mp1-rcc.txt
@@ -0,0 +1,6 @@
+STMicroelectronics STM32MP1 Peripheral Reset Controller
+=======================================================
+
+The RCC IP is both a reset and a clock controller.
+
+Please see Documentation/devicetree/bindings/clock/st,stm32mp1-rcc.txt
diff --git a/docs/devicetree/bindings/rng/st,stm32-rng.txt b/docs/devicetree/bindings/rng/st,stm32-rng.txt
new file mode 100644
index 000000000..3c613d791
--- /dev/null
+++ b/docs/devicetree/bindings/rng/st,stm32-rng.txt
@@ -0,0 +1,23 @@
+STMicroelectronics STM32 HW RNG
+===============================
+
+The STM32 hardware random number generator is a simple fixed purpose IP and
+is fully separated from other crypto functions.
+
+Required properties:
+
+- compatible : Should be "st,stm32-rng"
+- reg : Should be register base and length as documented in the datasheet
+- clocks : The clock needed to enable the RNG
+
+Optional properties:
+- resets : The reset to properly start RNG
+- clock-error-detect : Enable the clock detection management
+
+Example:
+
+	rng: rng@50060800 {
+		compatible = "st,stm32-rng";
+		reg = <0x50060800 0x400>;
+		clocks = <&rcc 0 38>;
+	};
diff --git a/docs/devicetree/bindings/serial/st,stm32-usart.txt b/docs/devicetree/bindings/serial/st,stm32-usart.txt
new file mode 100644
index 000000000..08b499045
--- /dev/null
+++ b/docs/devicetree/bindings/serial/st,stm32-usart.txt
@@ -0,0 +1,88 @@
+* STMicroelectronics STM32 USART
+
+Required properties:
+- compatible: can be either:
+  - "st,stm32-uart",
+  - "st,stm32f7-uart",
+  - "st,stm32h7-uart".
+  depending is compatible with stm32(f4), stm32f7 or stm32h7.
+- reg: The address and length of the peripheral registers space
+- interrupts:
+  - The interrupt line for the USART instance,
+  - An optional wake-up interrupt.
+- interrupt-names: Contains "event" for the USART interrupt line.
+- clocks: The input clock of the USART instance
+
+Optional properties:
+- resets: Must contain the phandle to the reset controller.
+- pinctrl-names: Set to "default". An additional "sleep" state can be defined
+  to set pins in sleep state when in low power. In case the device is used as
+  a wakeup source, "idle" state is defined in order to keep RX pin active.
+  For a console device, an optional state "no_console_suspend" can be defined
+  to enable console messages during suspend. Typically, "no_console_suspend" and
+  "default" states can refer to the same pin configuration.
+- pinctrl-n: Phandle(s) pointing to pin configuration nodes.
+  For Pinctrl properties see ../pinctrl/pinctrl-bindings.txt
+- st,hw-flow-ctrl: bool flag to enable hardware flow control.
+- rs485-rts-delay, rs485-rx-during-tx, rs485-rts-active-low,
+  linux,rs485-enabled-at-boot-time: see rs485.txt.
+- dmas: phandle(s) to DMA controller node(s). Refer to stm32-dma.txt
+- dma-names: "rx" and/or "tx"
+- wakeup-source: bool flag to indicate this device has wakeup capabilities
+- interrupt-names : Should contain "wakeup" if optional wake-up interrupt is
+  used.
+
+Note for dma using:
+- "tx" dma can be used without any constraint since it uses single
+dma transfers.
+- "rx" dma using requires some attention:
+   1) if you cannot anticipate the length of your received packets
+   and if your usart device embeds an internal fifo, then DON'T use
+   dma mode.
+   2) if you enable dma mode WITHOUT mdma intermediate copy (cf.
+   stm32-dma.txt), then the availability of the received data will
+   depend on the dma driver policy and it may be delayed until dma
+   internal fifo is full. The usart driver will see this checking
+   the dma residue when rx interrupt (RXNE or RTO) occurs.
+   3) if you enable dma mode WITH mdma intermediate copy (cf.
+   stm32-dma.txt) then the usart driver will never see the dma
+   residue becoming smaller than RX_BUF_P but it will get its
+   rx dma complete callback called when the cyclic transfer period
+   (RX_BUF_P) is reached.
+The three possibilities above are ordered from the most cpu time
+consuming one to the least one. The counterpart of this optimisation
+is the reception granularity achievable by the usart driver, from
+one byte up to RX_BUF_P.
+
+Examples:
+usart4: serial@40004c00 {
+	compatible = "st,stm32-uart";
+	reg = <0x40004c00 0x400>;
+	interrupts = <52>;
+	clocks = <&clk_pclk1>;
+	pinctrl-names = "default", "sleep", "idle", "no_console_suspend";
+	pinctrl-0 = <&pinctrl_usart4>;
+	pinctrl-1 = <&pinctrl_usart4_sleep>;
+	pinctrl-2 = <&pinctrl_usart4_idle>;
+	pinctrl-3 = <&pinctrl_usart4>;
+};
+
+usart2: serial@40004400 {
+	compatible = "st,stm32-uart";
+	reg = <0x40004400 0x400>;
+	interrupts = <38>;
+	clocks = <&clk_pclk1>;
+	st,hw-flow-ctrl;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usart2 &pinctrl_usart2_rtscts>;
+};
+
+usart1: serial@40011000 {
+	compatible = "st,stm32-uart";
+	reg = <0x40011000 0x400>;
+	interrupts = <37>;
+	clocks = <&rcc 0 164>;
+	dmas = <&dma2 2 4 0x414 0x0>,
+	       <&dma2 7 4 0x414 0x0>;
+	dma-names = "rx", "tx";
+};
diff --git a/docs/devicetree/bindings/soc/st,stm32-etzpc.txt b/docs/devicetree/bindings/soc/st,stm32-etzpc.txt
new file mode 100644
index 000000000..ec58557ad
--- /dev/null
+++ b/docs/devicetree/bindings/soc/st,stm32-etzpc.txt
@@ -0,0 +1,54 @@
+STM32 ETZPC
+---------------------------------
+
+Required properties:
+- compatible: should be "st,stm32-etzpc"
+- reg: physical base address and length of the registers set for the device
+- clocks: reference to the clock entry
+
+Optional property:
+- st,decprot: Configure option to properly set firewall for IPs.
+
+Examples:
+etzpc: etzpc@5C007000 {
+			compatible = "st,stm32-etzpc";
+			reg = <0x5C007000 0x400>;
+			clocks = <&rcc TZPC>;
+		};
+
+Firewall specifications
+=======================
+
+DECPROT macro must be used to properly configure IP firewalling. It must
+specify ID, domain and locking register status.
+
+The macro is defined in the binding header file [1].
+
+Example:
+	... {
+	st,decprot = <
+	DECPROT(STM32MP1_ETZPC_I2C4_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+	DECPROT(STM32MP1_ETZPC_RNG1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+	DECPROT(STM32MP1_ETZPC_HASH1_ID, DECPROT_NS_RW,	DECPROT_UNLOCK)
+	DECPROT(STM32MP1_ETZPC_CRYP1_ID, DECPROT_NS_RW,	DECPROT_UNLOCK)
+	DECPROT(STM32MP1_ETZPC_GPIOZ_ID, DECPROT_NS_RW,	DECPROT_UNLOCK)>;
+	};
+
+Specify Peripheral IDs
+=======================
+
+Each peripheral is identified with a specific ID. Each platform defines the
+identifiers relevant to that platform. Peripheral IDs are defined in [1].
+
+Specify domain
+==============
+Firewall controls peripherals in specific domains:
+
+DECPROT_S_RW		0x0  -> Read/write Secure
+DECPROT_NS_R_S_W	0x1  -> Non secure read / Read/write Secure
+DECPROT_MCU_ISOLATION	0x2  -> MCU access only
+DECPROT_NS_RW		0x3  -> Non secure read/write
+
+
+[1] include/dt-bindings/soc/st,stm32-etzpc.h
+
diff --git a/docs/devicetree/bindings/soc/st,stm32-romem.txt b/docs/devicetree/bindings/soc/st,stm32-romem.txt
new file mode 100644
index 000000000..424e18a5c
--- /dev/null
+++ b/docs/devicetree/bindings/soc/st,stm32-romem.txt
@@ -0,0 +1,52 @@
+STMicroelectronics STM32 Factory-programmed data device tree bindings
+
+This represents STM32 Factory-programmed read only non-volatile area: locked
+flash, OTP, read-only HW regs... This contains various information such as:
+analog calibration data for temperature sensor (e.g. TS_CAL1, TS_CAL2),
+internal vref (VREFIN_CAL), unique device ID...
+
+Required properties:
+- compatible:		Should be one of:
+			"st,stm32f4-otp"
+			"st,stm32mp13-bsec"
+			"st,stm32mp15-bsec"
+- reg:			Offset and length of factory-programmed area.
+- #address-cells:	Should be '<1>'.
+- #size-cells:		Should be '<1>'.
+
+Optional Data cells:
+- Must be child nodes as described in nvmem.txt.
+
+Optional-properties:
+- "st,non-secure-otp" specifies that the OTP can be accessed by non-secure
+  world through secure world services. Only useful for upper OTPs. This
+  property mandates 32-bit granularity of the related nvmem area, that is
+  offset and length are both multiple of 4.
+
+Example on stm32f4:
+	romem: efuse@1fff7800 {
+		compatible = "st,stm32f4-otp";
+		reg = <0x1fff7800 0x400>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		/* Data cells: ts_cal1 at 0x1fff7a2c */
+		ts_cal1: calib@22c {
+			reg = <0x22c 0x2>;
+		};
+		...
+	};
+
+Example on stm32mp15:
+	bsec: efuse@5c005000 {
+		compatible = "st,stm32mp15-bsec";
+		reg = <0x5c005000 0x400>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		mac_addr: mac_addr@e4 {
+			reg = <0xe4 0x8>;
+			st,non-secure-otp;
+		};
+		...
+	};
diff --git a/docs/devicetree/bindings/soc/st,stm32-stgen.txt b/docs/devicetree/bindings/soc/st,stm32-stgen.txt
new file mode 100644
index 000000000..dbd962ebc
--- /dev/null
+++ b/docs/devicetree/bindings/soc/st,stm32-stgen.txt
@@ -0,0 +1,18 @@
+STMicroelectronics STM32 STGEN
+===============================
+
+The STM32 System Generic Counter generate a time count value. This
+is a 64 bits wide counter.
+
+Required properties:
+
+- compatible : Should be "st,stm32-stgen"
+- reg : Should be register base and length as documented in the datasheet
+
+Example:
+
+	stgen: stgen@5C008000 {
+		compatible = "st,stm32-stgen";
+		reg = <0x5C008000 0x1000>;
+		status = "okay";
+	};
diff --git a/docs/devicetree/bindings/soc/st,stm32-tamp.txt b/docs/devicetree/bindings/soc/st,stm32-tamp.txt
new file mode 100644
index 000000000..e903b466a
--- /dev/null
+++ b/docs/devicetree/bindings/soc/st,stm32-tamp.txt
@@ -0,0 +1,20 @@
+STM32 TAMPER
+---------------------------------
+
+Required properties:
+- compatible: should be "st,stm32-tamp"
+- reg: physical base address and length of the registers set for the device
+- clocks: reference to the clock entry
+
+Optional property:
+- st,out3-pc13: Configure option register to map OUT3 on PC13
+- wakeup-source : Configure tamp as wakeup-src
+
+Examples:
+tamp: tamp@5C00A000 {
+	compatible = "st,stm32-tamp";
+	reg = <0x5C00A000 0x100>;
+	clocks = <&rcc_clk RTCAPB>;
+	st,out3-pc13;
+	wakeup-source;
+};
diff --git a/docs/devicetree/bindings/watchdog/st,stm32-iwdg.txt b/docs/devicetree/bindings/watchdog/st,stm32-iwdg.txt
new file mode 100644
index 000000000..2d35e978d
--- /dev/null
+++ b/docs/devicetree/bindings/watchdog/st,stm32-iwdg.txt
@@ -0,0 +1,27 @@
+STM32 Independent WatchDoG (IWDG)
+---------------------------------
+
+Required properties:
+- compatible: should be "st,stm32mp1-iwdg".
+- reg: physical base address and length of the registers set for the device.
+- clocks: reference to the clock entry lsi. Additional pclk clock entry.
+  is required only for st,stm32mp1-iwdg.
+- clock-names: name of the clocks used.
+  "pclk", "lsi" for st,stm32mp1-iwdg.
+
+Optional properties:
+- timeout-sec: Watchdog timeout value in seconds.
+- secure-timeout-sec: Watchdog early timeout management in seconds.
+- stm32,enable-on-stop: Keep watchdog enable during stop.
+- stm32,enable-on-standby: Keep watchdog enable durung standby.
+
+Examples:
+
+iwdg2: iwdg@5a002000 {
+	compatible = "st,stm32mp1-iwdg";
+	reg = <0x5a002000 0x400>;
+	clocks = <&rcc IWDG2>, <&clk_lsi>;
+	clock-names = "pclk", "lsi";
+	instance = <2>;
+	timeout-sec = <30>;
+};
diff --git a/docs/getting_started/porting-guide.rst b/docs/getting_started/porting-guide.rst
index 92ff39fdd..775b8cd0e 100644
--- a/docs/getting_started/porting-guide.rst
+++ b/docs/getting_started/porting-guide.rst
@@ -787,6 +787,31 @@ The function returns 0 on success. Any other value means the counter value
 either could not be updated or the authentication image descriptor indicates
 that it is not allowed to be updated.
 
+Function: plat_get_hashed_pk()
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+::
+
+    Argument : void *, unsigned int, void **, unsigned int *
+    Return   : int
+
+This function is optional when Trusted Board Boot is enabled, and only
+used if the platform saves a hash of the ROTPK.
+First argument is the BER ROTPK.
+Second argument is its size.
+Third argument is used to return a pointer to a buffer, which hash should
+be the one saved in OTP
+Fourth argument is a pointer to return its size
+
+Most platforms save the hash of the BER ROTPK, but some may save the hash of
+a non encapsulated public key or a platform specific encapsulated ROT public
+key. Defining this function allows to transform the BER ROTPK used to verify
+the signature to the buffer (a platform specific encapsulated public key) which
+hash is saved in OTP.
+
+The function returns 0 on success. Any other value means the expected
+public key buffer cannot be extracted from the BER public key.
+
 Common mandatory function modifications
 ---------------------------------------
 
@@ -889,7 +914,7 @@ Function : plat_fwu_set_images_source() [when PSA_FWU_SUPPORT == 1]
 
 ::
 
-    Argument : struct fwu_metadata *metadata
+    Argument : const struct fwu_metadata *metadata
     Return   : void
 
 This function is mandatory when PSA_FWU_SUPPORT is enabled.
@@ -932,6 +957,37 @@ It returns '0' on success, otherwise a negative error value on error.
 Alongside, returns device handle and image specification from the I/O policy
 of the requested FWU metadata image.
 
+Function : plat_fwu_get_boot_idx() [when PSA_FWU_SUPPORT == 1]
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+::
+
+    Argument : void
+    Return   : uint32_t
+
+This function is mandatory when PSA_FWU_SUPPORT is enabled. It provides the
+means to retrieve the boot index value from the platform. The boot index is the
+bank from which the platform has booted the firmware images.
+
+By default, the platform will read the metadata structure and try to boot from
+the active bank. If the platform fails to boot from the active bank due to
+reasons like an Authentication failure, or on crossing a set number of watchdog
+resets while booting from the active bank, the platform can then switch to boot
+from a different bank. This function then returns the bank that the platform
+should boot its images from.
+
+Function : plat_fwu_is_enabled() [when PSA_FWU_SUPPORT == 1]
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+::
+
+    Argument : void
+    Return   : bool
+
+This function is mandatory when PSA_FWU_SUPPORT is enabled. It checks at
+platform level that all conditions are met to initialize FWU process.
+
+
 Common optional modifications
 -----------------------------
 
@@ -3117,7 +3173,7 @@ amount of open resources per driver.
 
 --------------
 
-*Copyright (c) 2013-2021, Arm Limited and Contributors. All rights reserved.*
+*Copyright (c) 2013-2022, Arm Limited and Contributors. All rights reserved.*
 
 .. _PSCI: http://infocenter.arm.com/help/topic/com.arm.doc.den0022c/DEN0022C_Power_State_Coordination_Interface.pdf
 .. _Arm Generic Interrupt Controller version 2.0 (GICv2): http://infocenter.arm.com/help/topic/com.arm.doc.ihi0048b/index.html
diff --git a/docs/plat/stm32mp1.rst b/docs/plat/stm32mp1.rst
index af302c628..3575b1547 100644
--- a/docs/plat/stm32mp1.rst
+++ b/docs/plat/stm32mp1.rst
@@ -2,15 +2,34 @@ STMicroelectronics STM32MP1
 ===========================
 
 STM32MP1 is a microprocessor designed by STMicroelectronics
-based on a dual Arm Cortex-A7.
+based on Arm Cortex-A7.
 It is an Armv7-A platform, using dedicated code from TF-A.
-The STM32MP1 chip also embeds a Cortex-M4.
 More information can be found on `STM32MP1 Series`_ page.
 
 
 STM32MP1 Versions
 -----------------
-The STM32MP1 series is available in 3 different lines which are pin-to-pin compatible:
+
+There are 2 variants for STM32MP1: STM32MP13 and STM32MP15
+
+STM32MP13 Versions
+~~~~~~~~~~~~~~~~~~
+The STM32MP13 series is available in 3 different lines which are pin-to-pin compatible:
+
+- STM32MP131: Single Cortex-A7 core
+- STM32MP133: STM32MP131 + 2*CAN, ETH2(GMAC), ADC1
+- STM32MP135: STM32MP133 + DCMIPP, LTDC
+
+Each line comes with a security option (cryptography & secure boot) and a Cortex-A frequency option:
+
+- A      Cortex-A7 @ 650 MHz
+- C      Secure Boot + HW Crypto + Cortex-A7 @ 650 MHz
+- D      Cortex-A7 @ 900 MHz
+- F      Secure Boot + HW Crypto + Cortex-A7 @ 900 MHz
+
+STM32MP15 Versions
+~~~~~~~~~~~~~~~~~~
+The STM32MP15 series is available in 3 different lines which are pin-to-pin compatible:
 
 - STM32MP157: Dual Cortex-A7 cores, Cortex-M4 core @ 209 MHz, 3D GPU, DSI display interface and CAN FD
 - STM32MP153: Dual Cortex-A7 cores, Cortex-M4 core @ 209 MHz and CAN FD
@@ -44,15 +63,6 @@ Only BL2 (with STM32 header) is loaded by ROM code. The other binaries are
 inside the FIP binary: BL32 (SP_min or OP-TEE), U-Boot and their respective
 device tree blobs.
 
-STM32IMAGE bootchain
-~~~~~~~~~~~~~~~~~~~~
-Although still supported, this way of booting is not recommended.
-Pease use FIP instead.
-At compilation step, BL2, BL32 and DTB file are linked together in a single
-binary. The stm32image tool is also generated and the header is added to TF-A
-binary. This binary file with header is named tf-a-stm32mp157c-ev1.stm32.
-It can then be copied in the first partition of the boot device.
-
 
 Memory mapping
 ~~~~~~~~~~~~~~
@@ -115,6 +125,32 @@ Available storage medias are:
 - ``STM32MP_SPI_NAND``
 - ``STM32MP_SPI_NOR``
 
+Serial boot devices:
+
+- ``STM32MP_UART_PROGRAMMER``
+- ``STM32MP_USB_PROGRAMMER``
+
+
+Other configuration flags:
+
+- | ``DTB_FILE_NAME``: to precise board device-tree blob to be used.
+  | Default: stm32mp157c-ev1.dtb
+- | ``STM32MP_EARLY_CONSOLE``: to enable early traces before clock driver is setup.
+  | Default: 0 (disabled)
+- | ``STM32MP_RECONFIGURE_CONSOLE``: to re-configure crash console (especially after BL2).
+  | Default: 0 (disabled)
+- | ``STM32MP_UART_BAUDRATE``: to select UART baud rate.
+  | Default: 115200
+- | ``STM32_TF_VERSION``: to manage BL2 monotonic counter.
+  | Default: 0
+- | ``DWL_BUFFER_BASE``: the 'serial boot' load address of FIP,
+  | default location (end of the first 128MB) is used when absent
+- | ``STM32MP13``: to select STM32MP13 variant configuration.
+  | Default: 0
+- | ``STM32MP15``: to select STM32MP15 variant configuration.
+  | Default: 1
+
+
 Boot with FIP
 ~~~~~~~~~~~~~
 You need to build BL2, BL32 (SP_min or OP-TEE) and BL33 (U-Boot) before building FIP binary.
@@ -190,44 +226,42 @@ With OP-TEE:
         BL32_EXTRA2=<optee_directory>/tee-pageable_v2.bin
         fip
 
+Trusted Boot Board
+__________________
 
-STM32IMAGE bootchain
-~~~~~~~~~~~~~~~~~~~~
-You need to add the following flag to the make command:
-``STM32MP_USE_STM32IMAGE=1``
-
-To build with SP_min and support for SD-card boot:
-
-.. code:: bash
-
-    make CROSS_COMPILE=arm-linux-gnueabihf- PLAT=stm32mp1 ARCH=aarch32 ARM_ARCH_MAJOR=7 \
-        AARCH32_SP=sp_min STM32MP_SDMMC=1 DTB_FILE_NAME=stm32mp157c-ev1.dtb \
-        STM32MP_USE_STM32IMAGE=1
-
-    cd <u-boot_directory>
-    make stm32mp15_trusted_defconfig
-    make DEVICE_TREE=stm32mp157c-ev1 all
-
-To build TF-A with OP-TEE support for SD-card boot:
-
-.. code:: bash
-
-    make CROSS_COMPILE=arm-linux-gnueabihf- PLAT=stm32mp1 ARCH=aarch32 ARM_ARCH_MAJOR=7 \
-        AARCH32_SP=optee STM32MP_SDMMC=1 DTB_FILE_NAME=stm32mp157c-ev1.dtb \
-        STM32MP_USE_STM32IMAGE=1
-
-    cd <optee_directory>
-    make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm PLATFORM=stm32mp1 \
-        CFG_EMBED_DTB_SOURCE_FILE=stm32mp157c-ev1.dts
-
-    cd <u-boot_directory>
-    make stm32mp15_trusted_defconfig
-    make DEVICE_TREE=stm32mp157c-ev1 all
-
-
-The following build options are supported:
+.. code:: shell
+
+    tools/cert_create/cert_create -n --rot-key "build/stm32mp1/debug/rot_key.pem" \
+        --tfw-nvctr 0 \
+        --ntfw-nvctr 0 \
+        --key-alg ecdsa --hash-alg sha256 \
+        --trusted-key-cert build/stm32mp1/cert_images/trusted-key-cert.key-crt \
+        --tb-fw=build/stm32mp1/debug/bl2.bin \
+        --tb-fw-cert build/stm32mp1/cert_images/trusted-boot-fw.key-crt\
+        --tos-fw <optee_directory>/tee-header_v2.bin \
+        --tos-fw-cert build/stm32mp1/cert_images/tee-header_v2.bin.crt \
+        --tos-fw-key-cert build/stm32mp1/cert_images/tee-header_v2.bin.key-crt \
+        --tos-fw-extra1 <optee_directory>/tee-pager_v2.bin \
+        --tos-fw-extra2 <optee_directory>/tee-pageable_v2.bin \
+        --nt-fw <u-boot_directory>/u-boot-nodtb.bin \
+        --nt-fw-cert build/stm32mp1/cert_images/u-boot.bin.crt \
+        --nt-fw-key-cert build/stm32mp1/cert_images/u-boot.bin.key-crt \
+        --hw-config <u-boot_directory>/u-boot.dtb \
+        --fw-config build/stm32mp1/debug/fdts/fw-config.dtb \
+        --stm32mp-cfg-cert build/stm32mp1/cert_images/stm32mp_cfg_cert.crt
+
+    tools/fiptool/fiptool create --tos-fw <optee_directory>/tee-header_v2.bin \
+        --tos-fw-extra1 <optee_directory>/tee-pager_v2.bin \
+        --tos-fw-extra2 <optee_directory>/tee-pageable_v2.bin \
+        --nt-fw <u-boot_directory>/u-boot-nodtb.bin \
+        --hw-config <u-boot_directory>/u-boot.dtb \
+        --fw-config build/stm32mp1/debug/fdts/fw-config.dtb \
+        --tos-fw-cert build/stm32mp1/cert_images/tee-header_v2.bin.crt \
+        --tos-fw-key-cert build/stm32mp1/cert_images/tee-header_v2.bin.key-crt \
+        --nt-fw-cert build/stm32mp1/cert_images/u-boot.bin.crt \
+        --nt-fw-key-cert build/stm32mp1/cert_images/u-boot.bin.key-crt \
+        --stm32mp-cfg-cert build/stm32mp1/stm32mp_cfg_cert.crt stm32mp1.fip
 
-- ``ENABLE_STACK_PROTECTOR``: To enable the stack protection.
 
 
 Populate SD-card
@@ -243,22 +277,6 @@ It should contain at least those partitions:
 
 Usually, two copies of fsbl are used (fsbl1 and fsbl2) instead of one partition fsbl.
 
-STM32IMAGE bootchain
-~~~~~~~~~~~~~~~~~~~~
-The SD-card has to be formatted with GPT.
-It should contain at least those partitions:
-
-- fsbl: to copy the tf-a-stm32mp157c-ev1.stm32 binary
-- ssbl: to copy the u-boot.stm32 binary
-
-Usually, two copies of fsbl are used (fsbl1 and fsbl2) instead of one partition fsbl.
-
-OP-TEE artifacts go into separate partitions as follows:
-
-- teeh: tee-header_v2.stm32
-- teed: tee-pageable_v2.stm32
-- teex: tee-pager_v2.stm32
-
 
 .. _STM32MP1 Series: https://www.st.com/en/microcontrollers-microprocessors/stm32mp1-series.html
 .. _STM32MP1 part number codification: https://wiki.st.com/stm32mpu/wiki/STM32MP15_microprocessor#Part_number_codification
diff --git a/drivers/auth/auth_mod.c b/drivers/auth/auth_mod.c
index 917ee4a28..b4f3949f3 100644
--- a/drivers/auth/auth_mod.c
+++ b/drivers/auth/auth_mod.c
@@ -31,6 +31,7 @@
 	} while (0)
 
 #pragma weak plat_set_nv_ctr2
+#pragma weak plat_get_hashed_pk
 
 
 static int cmp_auth_param_type_desc(const auth_param_type_desc_t *a,
@@ -202,6 +203,10 @@ static int auth_signature(const auth_method_param_sig_t *param,
 			NOTICE("ROTPK is not deployed on platform. "
 				"Skipping ROTPK verification.\n");
 		} else {
+			/* platform may store the hash of a prefixed, suffixed or modified pk */
+			rc = plat_get_hashed_pk(pk_ptr, pk_len, &pk_ptr, &pk_len);
+			return_if_error(rc);
+
 			/* Ask the crypto-module to verify the key hash */
 			rc = crypto_mod_verify_hash(pk_ptr, pk_len,
 				    pk_hash_ptr, pk_hash_len);
@@ -301,6 +306,15 @@ int plat_set_nv_ctr2(void *cookie, const auth_img_desc_t *img_desc __unused,
 	return plat_set_nv_ctr(cookie, nv_ctr);
 }
 
+int plat_get_hashed_pk(void *full_pk_ptr, unsigned int full_pk_len,
+		       void **hashed_pk_ptr, unsigned int *hashed_pk_len)
+{
+	*hashed_pk_ptr = full_pk_ptr;
+	*hashed_pk_len = full_pk_len;
+
+	return 0;
+}
+
 /*
  * Return the parent id in the output parameter '*parent_id'
  *
diff --git a/drivers/auth/mbedtls/mbedtls_common.mk b/drivers/auth/mbedtls/mbedtls_common.mk
index 53ebe30b6..ace4312cf 100644
--- a/drivers/auth/mbedtls/mbedtls_common.mk
+++ b/drivers/auth/mbedtls/mbedtls_common.mk
@@ -16,7 +16,7 @@ endif
 MBEDTLS_INC		=	-I${MBEDTLS_DIR}/include
 
 # Specify mbed TLS configuration file
-MBEDTLS_CONFIG_FILE	:=	"<drivers/auth/mbedtls/mbedtls_config.h>"
+MBEDTLS_CONFIG_FILE	?=	"<drivers/auth/mbedtls/mbedtls_config.h>"
 $(eval $(call add_define,MBEDTLS_CONFIG_FILE))
 
 MBEDTLS_SOURCES	+=		drivers/auth/mbedtls/mbedtls_common.c
diff --git a/drivers/auth/mbedtls/mbedtls_x509_parser.c b/drivers/auth/mbedtls/mbedtls_x509_parser.c
index 129566bd6..7b3ecd1a3 100644
--- a/drivers/auth/mbedtls/mbedtls_x509_parser.c
+++ b/drivers/auth/mbedtls/mbedtls_x509_parser.c
@@ -114,10 +114,10 @@ static int get_ext(const char *oid, void **ext, unsigned int *ext_len)
 		oid_len = mbedtls_oid_get_numeric_string(oid_str,
 							 MAX_OID_STR_LEN,
 							 &extn_oid);
-		if (oid_len == MBEDTLS_ERR_OID_BUF_TOO_SMALL) {
+		if ((oid_len == MBEDTLS_ERR_OID_BUF_TOO_SMALL) || (oid_len < 0)) {
 			return IMG_PARSER_ERR;
 		}
-		if ((oid_len == strlen(oid_str)) && !strcmp(oid, oid_str)) {
+		if (((size_t)oid_len == strlen(oid_str)) && !strcmp(oid, oid_str)) {
 			*ext = (void *)p;
 			*ext_len = (unsigned int)len;
 			return IMG_PARSER_OK;
diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
new file mode 100644
index 000000000..b3000ff76
--- /dev/null
+++ b/drivers/clk/clk.c
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2020-2021, STMicroelectronics - All Rights Reserved
+ * Author(s): Ludovic Barre, <ludovic.barre@st.com> for STMicroelectronics.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <stdbool.h>
+
+#include <drivers/clk.h>
+
+static const struct clk_ops *ops;
+
+int clk_enable(unsigned long id)
+{
+	assert((ops != NULL) && (ops->enable != NULL));
+
+	return ops->enable(id);
+}
+
+void clk_disable(unsigned long id)
+{
+	assert((ops != NULL) && (ops->disable != NULL));
+
+	ops->disable(id);
+}
+
+unsigned long clk_get_rate(unsigned long id)
+{
+	assert((ops != NULL) && (ops->get_rate != NULL));
+
+	return ops->get_rate(id);
+}
+
+int clk_get_parent(unsigned long id)
+{
+	assert((ops != NULL) && (ops->get_parent != NULL));
+
+	return ops->get_parent(id);
+}
+
+bool clk_is_enabled(unsigned long id)
+{
+	assert((ops != NULL) && (ops->is_enabled != NULL));
+
+	return ops->is_enabled(id);
+}
+
+/*
+ * Initialize the clk. The fields in the provided clk
+ * ops pointer must be valid.
+ */
+void clk_register(const struct clk_ops *ops_ptr)
+{
+	assert((ops_ptr != NULL) &&
+	       (ops_ptr->enable != NULL) &&
+	       (ops_ptr->disable != NULL) &&
+	       (ops_ptr->get_rate != NULL) &&
+	       (ops_ptr->get_parent != NULL) &&
+	       (ops_ptr->is_enabled != NULL));
+
+	ops = ops_ptr;
+}
diff --git a/drivers/fwu/fwu.c b/drivers/fwu/fwu.c
index 7cb4c2982..55da110a9 100644
--- a/drivers/fwu/fwu.c
+++ b/drivers/fwu/fwu.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2021-2022, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -25,7 +25,7 @@ CASSERT((offsetof(struct fwu_metadata, crc_32) == 0),
 	crc_32_must_be_first_member_of_structure);
 
 static struct fwu_metadata metadata;
-static bool is_fwu_initialized;
+static bool is_metadata_initialized;
 
 /*******************************************************************************
  * Compute CRC32 of the FWU metadata, and check it against the CRC32 value
@@ -142,7 +142,7 @@ bool fwu_is_trial_run_state(void)
 {
 	bool trial_run = false;
 
-	assert(is_fwu_initialized == true);
+	assert(is_metadata_initialized);
 
 	for (unsigned int i = 0U; i < NR_OF_IMAGES_IN_FW_BANK; i++) {
 		struct fwu_image_entry *entry = &metadata.img_entry[i];
@@ -157,6 +157,13 @@ bool fwu_is_trial_run_state(void)
 	return trial_run;
 }
 
+const struct fwu_metadata *fwu_get_metadata(void)
+{
+	assert(is_metadata_initialized);
+
+	return &metadata;
+}
+
 /*******************************************************************************
  * Load verified copy of FWU metadata image kept in the platform NV storage
  * into local FWU metadata structure.
@@ -181,7 +188,7 @@ void fwu_init(void)
 		}
 	}
 
-	plat_fwu_set_images_source(&metadata);
+	is_metadata_initialized = true;
 
-	is_fwu_initialized = true;
+	plat_fwu_set_images_source(&metadata);
 }
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index c327e71d2..2671bf4ee 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -25,6 +25,7 @@
 static const struct mmc_ops *ops;
 static unsigned int mmc_ocr_value;
 static struct mmc_csd_emmc mmc_csd;
+static struct sd_switch_status sd_switch_func_status;
 static unsigned char mmc_ext_csd[512] __aligned(16);
 static unsigned int mmc_flags;
 static struct mmc_device_info *mmc_dev_info;
@@ -44,6 +45,11 @@ static bool is_cmd23_enabled(void)
 	return ((mmc_flags & MMC_FLAG_CMD23) != 0U);
 }
 
+static bool is_sd_cmd6_enabled(void)
+{
+	return ((mmc_flags & MMC_FLAG_SD_CMD6) != 0U);
+}
+
 static int mmc_send_cmd(unsigned int idx, unsigned int arg,
 			unsigned int r_type, unsigned int *r_data)
 {
@@ -357,6 +363,33 @@ static int mmc_fill_device_info(void)
 	return 0;
 }
 
+static int sd_switch(unsigned char mode, unsigned char group,
+		     unsigned char func)
+{
+	unsigned int group_shift = (group - 1U) * 4U;
+	unsigned int group_mask = GENMASK(group_shift + 3U,  group_shift);
+	unsigned int arg;
+	int ret = 0;
+
+	ret = ops->prepare(0, (uintptr_t)&sd_switch_func_status,
+			   sizeof(sd_switch_func_status));
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* MMC CMD6: SWITCH_FUNC */
+	arg = (mode << 31) | GENMASK(23, 0);
+	arg &= ~group_mask;
+	arg |= func << group_shift;
+	ret = mmc_send_cmd(MMC_CMD(6), arg, MMC_RESPONSE_R1, NULL);
+	if (ret != 0) {
+		return ret;
+	}
+
+	return ops->read(0, (uintptr_t)&sd_switch_func_status,
+			 sizeof(sd_switch_func_status));
+}
+
 static int sd_send_op_cond(void)
 {
 	int n;
@@ -524,7 +557,39 @@ static int mmc_enumerate(unsigned int clk, unsigned int bus_width)
 		return ret;
 	}
 
-	return mmc_fill_device_info();
+	ret = mmc_fill_device_info();
+	if (ret != 0) {
+		return ret;
+	}
+
+	if (is_sd_cmd6_enabled() &&
+	    (mmc_dev_info->mmc_dev_type == MMC_IS_SD_HC)) {
+		/* Try to switch to High Speed Mode */
+		ret = sd_switch(SD_SWITCH_FUNC_CHECK, 1U, 1U);
+		if (ret != 0) {
+			return ret;
+		}
+
+		if ((sd_switch_func_status.support_g1 & BIT(9)) == 0U) {
+			/* High speed not supported, keep default speed */
+			return 0;
+		}
+
+		ret = sd_switch(SD_SWITCH_FUNC_SWITCH, 1U, 1U);
+		if (ret != 0) {
+			return ret;
+		}
+
+		if ((sd_switch_func_status.sel_g2_g1 & 0x1U) == 0U) {
+			/* Cannot switch to high speed, keep default speed */
+			return 0;
+		}
+
+		mmc_dev_info->max_bus_freq = 50000000U;
+		ret = ops->set_ios(clk, bus_width);
+	}
+
+	return ret;
 }
 
 size_t mmc_read_blocks(int lba, uintptr_t buf, size_t size)
diff --git a/drivers/mtd/nand/core.c b/drivers/mtd/nand/core.c
index 9f0331ad7..ce697b238 100644
--- a/drivers/mtd/nand/core.c
+++ b/drivers/mtd/nand/core.c
@@ -19,7 +19,18 @@
  * Define a single nand_device used by specific NAND frameworks.
  */
 static struct nand_device nand_dev;
-static uint8_t scratch_buff[PLATFORM_MTD_MAX_PAGE_SIZE];
+
+#pragma weak plat_get_scratch_buffer
+void plat_get_scratch_buffer(void **buffer_addr, size_t *buf_size)
+{
+	static uint8_t scratch_buff[PLATFORM_MTD_MAX_PAGE_SIZE];
+
+	assert(buffer_addr != NULL);
+	assert(buf_size != NULL);
+
+	*buffer_addr = (void *)scratch_buff;
+	*buf_size = sizeof(scratch_buff);
+}
 
 int nand_read(unsigned int offset, uintptr_t buffer, size_t length,
 	      size_t *length_read)
@@ -34,6 +45,12 @@ int nand_read(unsigned int offset, uintptr_t buffer, size_t length,
 	unsigned int bytes_read;
 	int is_bad;
 	int ret;
+	uint8_t *scratch_buff;
+	size_t scratch_buff_size;
+
+	plat_get_scratch_buffer((void **)&scratch_buff, &scratch_buff_size);
+
+	assert(scratch_buff != NULL);
 
 	VERBOSE("Block %u - %u, page_start %u, nb %u, length %zu, offset %u\n",
 		block, end_block, page_start, nb_pages, length, offset);
@@ -41,7 +58,7 @@ int nand_read(unsigned int offset, uintptr_t buffer, size_t length,
 	*length_read = 0UL;
 
 	if (((start_offset != 0U) || (length % nand_dev.page_size) != 0U) &&
-	    (sizeof(scratch_buff) < nand_dev.page_size)) {
+	    (scratch_buff_size < nand_dev.page_size)) {
 		return -EINVAL;
 	}
 
diff --git a/drivers/mtd/nand/raw_nand.c b/drivers/mtd/nand/raw_nand.c
index 1fb5facaf..3595c2142 100644
--- a/drivers/mtd/nand/raw_nand.c
+++ b/drivers/mtd/nand/raw_nand.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2020, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2019-2022, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -8,13 +8,13 @@
 #include <errno.h>
 #include <stddef.h>
 
-#include <platform_def.h>
-
 #include <common/debug.h>
 #include <drivers/delay_timer.h>
 #include <drivers/raw_nand.h>
 #include <lib/utils.h>
 
+#include <platform_def.h>
+
 #define ONFI_SIGNATURE_ADDR	0x20U
 
 /* CRC calculation */
@@ -24,9 +24,6 @@
 /* Status register */
 #define NAND_STATUS_READY	BIT(6)
 
-#define SZ_128M			0x08000000U
-#define SZ_512			0x200U
-
 static struct rawnand_device rawnand_dev;
 
 #pragma weak plat_get_raw_nand_data
@@ -221,6 +218,18 @@ int nand_wait_ready(unsigned int delay_ms)
 	return -ETIMEDOUT;
 }
 
+static int nand_reset(void)
+{
+	int ret;
+
+	ret = nand_send_cmd(NAND_CMD_RESET, NAND_TWB_MAX);
+	if (ret != 0) {
+		return ret;
+	}
+
+	return nand_send_wait(PSEC_TO_MSEC(NAND_TRST_MAX), 0U);
+}
+
 #if NAND_ONFI_DETECT
 static uint16_t nand_check_crc(uint16_t crc, uint8_t *data_in,
 			       unsigned int data_len)
@@ -268,18 +277,6 @@ static int nand_read_id(uint8_t addr, uint8_t *id, unsigned int size)
 	return nand_read_data(id, size, true);
 }
 
-static int nand_reset(void)
-{
-	int ret;
-
-	ret = nand_send_cmd(NAND_CMD_RESET, NAND_TWB_MAX);
-	if (ret != 0) {
-		return ret;
-	}
-
-	return nand_send_wait(PSEC_TO_MSEC(NAND_TRST_MAX), 0U);
-}
-
 static int nand_read_param_page(void)
 {
 	struct nand_param_page page;
@@ -349,11 +346,6 @@ static int detect_onfi(void)
 	int ret;
 	char id[4];
 
-	ret = nand_reset();
-	if (ret != 0) {
-		return ret;
-	}
-
 	ret = nand_read_id(ONFI_SIGNATURE_ADDR, (uint8_t *)id, sizeof(id));
 	if (ret != 0) {
 		return ret;
@@ -409,6 +401,8 @@ void nand_raw_ctrl_init(const struct nand_ctrl_ops *ops)
 
 int nand_raw_init(unsigned long long *size, unsigned int *erase_size)
 {
+	int ret;
+
 	rawnand_dev.nand_dev = get_nand_device();
 	if (rawnand_dev.nand_dev == NULL) {
 		return -EINVAL;
@@ -423,6 +417,11 @@ int nand_raw_init(unsigned long long *size, unsigned int *erase_size)
 		return -ENODEV;
 	}
 
+	ret = nand_reset();
+	if (ret != 0) {
+		return ret;
+	}
+
 #if NAND_ONFI_DETECT
 	if (detect_onfi() != 0) {
 		WARN("Detect ONFI failed\n");
diff --git a/drivers/mtd/nand/spi_nand.c b/drivers/mtd/nand/spi_nand.c
index abb524d7f..2049d7ba1 100644
--- a/drivers/mtd/nand/spi_nand.c
+++ b/drivers/mtd/nand/spi_nand.c
@@ -17,7 +17,6 @@
 
 #define SPI_NAND_MAX_ID_LEN		4U
 #define DELAY_US_400MS			400000U
-#define MACRONIX_ID			0xC2U
 
 static struct spinand_device spinand_dev;
 
@@ -91,7 +90,7 @@ static int spi_nand_quad_enable(uint8_t manufacturer_id)
 {
 	bool enable = false;
 
-	if (manufacturer_id != MACRONIX_ID) {
+	if ((spinand_dev.flags & SPI_NAND_HAS_QE_BIT) == 0U) {
 		return 0;
 	}
 
@@ -193,7 +192,7 @@ static int spi_nand_read_from_cache(unsigned int page, unsigned int offset,
 	spinand_dev.spi_read_cache_op.data.buf = buffer;
 	spinand_dev.spi_read_cache_op.data.nbytes = len;
 
-	return spi_mem_exec_op(&spinand_dev.spi_read_cache_op);
+	return spi_mem_dirmap_read(&spinand_dev.spi_read_cache_op);
 }
 
 static int spi_nand_read_page(unsigned int page, unsigned int offset,
diff --git a/drivers/mtd/nor/spi_nor.c b/drivers/mtd/nor/spi_nor.c
index 6b4643e89..d4498402f 100644
--- a/drivers/mtd/nor/spi_nor.c
+++ b/drivers/mtd/nor/spi_nor.c
@@ -300,7 +300,7 @@ int spi_nor_read(unsigned int offset, uintptr_t buffer, size_t length,
 			nor_dev.read_op.data.nbytes = length;
 		}
 
-		ret = spi_mem_exec_op(&nor_dev.read_op);
+		ret = spi_mem_dirmap_read(&nor_dev.read_op);
 		if (ret != 0) {
 			spi_nor_clean_bar();
 			return ret;
@@ -341,8 +341,13 @@ int spi_nor_init(unsigned long long *size, unsigned int *erase_size)
 
 	assert(nor_dev.size != 0U);
 
-	if (nor_dev.size > BANK_SIZE) {
-		nor_dev.flags |= SPI_NOR_USE_BANK;
+	if ((nor_dev.size > BANK_SIZE) &&
+	    (nor_dev.read_op.addr.nbytes == 3U) &&
+	    ((nor_dev.flags & SPI_NOR_USE_BANK) == 0U)) {
+		WARN("%s: Only the first 16 MB of the memory are available. Please,\n", __func__);
+		WARN("%s: enable SPI_NOR_USE_BANK flag in plat_get_nor_data function\n", __func__);
+		WARN("%s: if the memory supports bank selection or use 4-bytes\n", __func__);
+		WARN("%s: address commands if the memory supports these commands.\n", __func__);
 	}
 
 	*size = nor_dev.size;
diff --git a/drivers/mtd/spi-mem/spi_mem.c b/drivers/mtd/spi-mem/spi_mem.c
index 010e8b62a..2ebf357b6 100644
--- a/drivers/mtd/spi-mem/spi_mem.c
+++ b/drivers/mtd/spi-mem/spi_mem.c
@@ -34,22 +34,31 @@ static struct spi_slave spi_slave;
 
 static bool spi_mem_check_buswidth_req(uint8_t buswidth, bool tx)
 {
+	unsigned int mode = spi_slave.mode;
+
 	switch (buswidth) {
 	case 1U:
 		return true;
 
 	case 2U:
-		if ((tx && (spi_slave.mode & (SPI_TX_DUAL | SPI_TX_QUAD)) !=
-		     0U) ||
-		    (!tx && (spi_slave.mode & (SPI_RX_DUAL | SPI_RX_QUAD)) !=
-		     0U)) {
+		if ((tx &&
+		     (mode & (SPI_TX_DUAL | SPI_TX_QUAD | SPI_TX_OCTAL)) != 0U) ||
+		    (!tx &&
+		     (mode & (SPI_RX_DUAL | SPI_RX_QUAD | SPI_RX_OCTAL)) != 0U)) {
 			return true;
 		}
 		break;
 
 	case 4U:
-		if ((tx && (spi_slave.mode & SPI_TX_QUAD) != 0U) ||
-		    (!tx && (spi_slave.mode & SPI_RX_QUAD) != 0U)) {
+		if ((tx && (mode & (SPI_TX_QUAD | SPI_TX_OCTAL)) != 0U) ||
+		    (!tx && (mode & (SPI_RX_QUAD | SPI_RX_OCTAL)) != 0U)) {
+			return true;
+		}
+		break;
+
+	case 8U:
+		if ((tx && (mode & SPI_TX_OCTAL) != 0U) ||
+		    (!tx && (mode & SPI_RX_OCTAL) != 0U)) {
 			return true;
 		}
 		break;
@@ -175,6 +184,54 @@ int spi_mem_exec_op(const struct spi_mem_op *op)
 	return ret;
 }
 
+/*
+ * spi_mem_dirmap_read() - Read data through a direct mapping
+ * @op: The memory operation to execute.
+ *
+ * This function reads data from a memory device using a direct mapping.
+ *
+ * Return: 0 in case of success, a negative error code otherwise.
+ */
+int spi_mem_dirmap_read(const struct spi_mem_op *op)
+{
+	const struct spi_bus_ops *ops = spi_slave.ops;
+	int ret;
+
+	VERBOSE("%s: cmd:%x mode:%d.%d.%d.%d addr:%" PRIx64 " len:%x\n",
+		__func__, op->cmd.opcode, op->cmd.buswidth, op->addr.buswidth,
+		op->dummy.buswidth, op->data.buswidth,
+		op->addr.val, op->data.nbytes);
+
+	if (op->data.dir != SPI_MEM_DATA_IN) {
+		return -EINVAL;
+	}
+
+	if (op->data.nbytes == 0U) {
+		return 0;
+	}
+
+	if (ops->dirmap_read == NULL) {
+		return spi_mem_exec_op(op);
+	}
+
+	if (!spi_mem_supports_op(op)) {
+		WARN("Error in spi_mem_support\n");
+		return -ENOTSUP;
+	}
+
+	ret = ops->claim_bus(spi_slave.cs);
+	if (ret != 0) {
+		WARN("Error claim_bus\n");
+		return ret;
+	}
+
+	ret = ops->dirmap_read(op);
+
+	ops->release_bus();
+
+	return ret;
+}
+
 /*
  * spi_mem_init_slave() - SPI slave device initialization.
  * @fdt: Pointer to the device tree blob.
@@ -257,6 +314,9 @@ int spi_mem_init_slave(void *fdt, int bus_node, const struct spi_bus_ops *ops)
 			case 4U:
 				mode |= SPI_TX_QUAD;
 				break;
+			case 8U:
+				mode |= SPI_TX_OCTAL;
+				break;
 			default:
 				WARN("spi-tx-bus-width %d not supported\n",
 				     fdt32_to_cpu(*cuint));
@@ -275,6 +335,9 @@ int spi_mem_init_slave(void *fdt, int bus_node, const struct spi_bus_ops *ops)
 			case 4U:
 				mode |= SPI_RX_QUAD;
 				break;
+			case 8U:
+				mode |= SPI_RX_OCTAL;
+				break;
 			default:
 				WARN("spi-rx-bus-width %d not supported\n",
 				     fdt32_to_cpu(*cuint));
diff --git a/drivers/partition/gpt.c b/drivers/partition/gpt.c
index 1b804deef..4fe832244 100644
--- a/drivers/partition/gpt.c
+++ b/drivers/partition/gpt.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2017, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2016-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -9,6 +9,7 @@
 #include <string.h>
 
 #include <common/debug.h>
+#include <drivers/partition/efi.h>
 #include <drivers/partition/gpt.h>
 #include <lib/utils.h>
 
@@ -57,5 +58,8 @@ int parse_gpt_entry(gpt_entry_t *gpt_entry, partition_entry_t *entry)
 	entry->length = (uint64_t)(gpt_entry->last_lba -
 				   gpt_entry->first_lba + 1) *
 			PLAT_PARTITION_BLOCK_SIZE;
+	guidcpy(&entry->part_guid, &gpt_entry->unique_uuid);
+	guidcpy(&entry->type_guid, &gpt_entry->type_uuid);
+
 	return 0;
 }
diff --git a/drivers/partition/partition.c b/drivers/partition/partition.c
index fdea10dbd..a8fdf6566 100644
--- a/drivers/partition/partition.c
+++ b/drivers/partition/partition.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2019, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2016-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -11,6 +11,7 @@
 
 #include <common/debug.h>
 #include <drivers/io/io_storage.h>
+#include <drivers/partition/efi.h>
 #include <drivers/partition/partition.h>
 #include <drivers/partition/gpt.h>
 #include <drivers/partition/mbr.h>
@@ -246,6 +247,32 @@ const partition_entry_t *get_partition_entry(const char *name)
 	return NULL;
 }
 
+const partition_entry_t *get_partition_entry_by_type(const uuid_t *type_uuid)
+{
+	int i;
+
+	for (i = 0; i < list.entry_count; i++) {
+		if (guidcmp(type_uuid, &list.list[i].type_guid) == 0) {
+			return &list.list[i];
+		}
+	}
+
+	return NULL;
+}
+
+const partition_entry_t *get_partition_entry_by_uuid(const uuid_t *part_uuid)
+{
+	int i;
+
+	for (i = 0; i < list.entry_count; i++) {
+		if (guidcmp(part_uuid, &list.list[i].part_guid) == 0) {
+			return &list.list[i];
+		}
+	}
+
+	return NULL;
+}
+
 const partition_entry_list_t *get_partition_entry_list(void)
 {
 	return &list;
diff --git a/drivers/regulator/regulator_core.c b/drivers/regulator/regulator_core.c
new file mode 100644
index 000000000..de915a4a6
--- /dev/null
+++ b/drivers/regulator/regulator_core.c
@@ -0,0 +1,1139 @@
+/*
+ * Copyright (c) 2020-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdint.h>
+#include <string.h>
+
+#include <libfdt.h>
+
+#include <common/debug.h>
+#include <drivers/delay_timer.h>
+#include <drivers/regulator.h>
+
+#define MAX_PROPERTY_LEN 64
+
+static struct rdev rdev_array[PLAT_NB_RDEVS];
+
+#pragma weak plat_get_lp_mode_name
+const char *plat_get_lp_mode_name(int mode)
+{
+	return NULL;
+}
+
+#define for_each_rdev(rdev) \
+	for (rdev = rdev_array; rdev < (rdev_array + PLAT_NB_RDEVS); rdev++)
+
+#define for_each_registered_rdev(rdev) \
+	for (rdev = rdev_array; \
+	     (rdev < (rdev_array + PLAT_NB_RDEVS)) && (rdev->desc != NULL); rdev++)
+
+static void lock_driver(const struct rdev *rdev)
+{
+	if (rdev->desc->ops->lock != NULL) {
+		rdev->desc->ops->lock(rdev->desc);
+	}
+}
+
+static void unlock_driver(const struct rdev *rdev)
+{
+	if (rdev->desc->ops->unlock != NULL) {
+		rdev->desc->ops->unlock(rdev->desc);
+	}
+}
+
+static struct rdev *regulator_get_by_phandle(int32_t phandle)
+{
+	struct rdev *rdev;
+
+	for_each_registered_rdev(rdev) {
+		if (rdev->phandle == phandle) {
+			return rdev;
+		}
+	}
+
+	WARN("%s: phandle %d not found\n", __func__, phandle);
+	return NULL;
+}
+
+/*
+ * Get a regulator from its node name
+ *
+ * @fdt - pointer to device tree memory
+ * @node_name - name of the node "ldo1"
+ * Return pointer to rdev if succeed, NULL else.
+ */
+struct rdev *regulator_get_by_name(const char *node_name)
+{
+	struct rdev *rdev;
+
+	assert(node_name != NULL);
+	VERBOSE("get %s\n", node_name);
+
+	for_each_registered_rdev(rdev) {
+		if (strcmp(rdev->desc->node_name, node_name) == 0) {
+			return rdev;
+		}
+	}
+
+	WARN("%s: %s not found\n", __func__, node_name);
+	return NULL;
+}
+
+static int32_t get_supply_phandle(const void *fdt, int node, const char *name)
+{
+	const fdt32_t *cuint;
+	int len __unused;
+	int supply_phandle = -FDT_ERR_NOTFOUND;
+	char prop_name[MAX_PROPERTY_LEN];
+
+	len = snprintf(prop_name, MAX_PROPERTY_LEN - 1, "%s-supply", name);
+	assert((len >= 0) && (len < MAX_PROPERTY_LEN - 1));
+
+	cuint = fdt_getprop(fdt, node, prop_name, NULL);
+	if (cuint != NULL) {
+		supply_phandle = fdt32_to_cpu(*cuint);
+		VERBOSE("%s: supplied by %d\n", name, supply_phandle);
+	}
+
+	return supply_phandle;
+}
+
+/*
+ * Get a regulator from a supply name
+ *
+ * @fdt - pointer to device tree memory
+ * @node - offset of the node that contains the supply description
+ * @name - name of the supply "vdd" for "vdd-supply'
+ * Return pointer to rdev if succeed, NULL else.
+ */
+struct rdev *regulator_get_by_supply_name(const void *fdt, int node, const char *name)
+{
+	const int p = get_supply_phandle(fdt, node, name);
+
+	if (p < 0) {
+		return NULL;
+	}
+
+	return regulator_get_by_phandle(p);
+}
+
+static int __regulator_set_state(struct rdev *rdev, bool state)
+{
+	if (rdev->desc->ops->set_state == NULL) {
+		return -ENODEV;
+	}
+
+	return rdev->desc->ops->set_state(rdev->desc, state);
+}
+
+#if defined(IMAGE_BL32)
+/*
+ * Enable regulator supply
+ * Enable regulator if use_count == 0
+ * Apply ramp delay
+ *
+ * @rdev - pointer to rdev struct
+ * Return 0 if succeed, non 0 else.
+ */
+static int __regulator_enable(struct rdev *rdev)
+{
+	VERBOSE("%s: en\n", rdev->desc->node_name);
+
+	if (rdev->desc->ops->set_state == NULL) {
+		return -ENODEV;
+	}
+
+	if (rdev->supply_dev != NULL)
+		regulator_enable(rdev->supply_dev);
+
+	lock_driver(rdev);
+
+	if (rdev->use_count == 0) {
+		int ret;
+
+		ret = __regulator_set_state(rdev, STATE_ENABLE);
+		if (ret != 0) {
+			ERROR("regul %s set state failed: err:%d\n",
+			      rdev->desc->node_name, ret);
+			unlock_driver(rdev);
+			return ret;
+		}
+
+		udelay(rdev->enable_ramp_delay);
+	}
+
+	rdev->use_count++;
+
+	assert(rdev->use_count != UINT8_MAX);
+
+	VERBOSE("%s: en count:%u\n", rdev->desc->node_name, rdev->use_count);
+
+	unlock_driver(rdev);
+
+	return 0;
+}
+
+/*
+ * Enable regulator
+ *
+ * @rdev - pointer to rdev struct
+ * Return 0 if succeed, non 0 else.
+ */
+int regulator_enable(struct rdev *rdev)
+{
+	assert(rdev != NULL);
+
+	if (rdev->flags & REGUL_ALWAYS_ON) {
+		return 0;
+	}
+
+	return __regulator_enable(rdev);
+}
+
+/*
+ * Disable regulator if use_count fall to zero
+ * Warn if count is < 0 because too many disable were requested
+ * Disable regulator supply
+ *
+ * @rdev - pointer to rdev struct
+ * Return 0 if succeed, non 0 else.
+ */
+static int __regulator_disable(struct rdev *rdev)
+{
+	VERBOSE("%s: dis\n", rdev->desc->node_name);
+
+	if (rdev->desc->ops->set_state == NULL) {
+		return -ENODEV;
+	}
+
+	lock_driver(rdev);
+
+	if (rdev->use_count == 1) {
+		int ret;
+
+		ret = __regulator_set_state(rdev, STATE_DISABLE);
+		if (ret != 0) {
+			ERROR("regul %s set state failed: err:%d\n",
+			      rdev->desc->node_name, ret);
+			unlock_driver(rdev);
+			return ret;
+		}
+	}
+
+	if (rdev->use_count == 0) {
+		WARN("regulator %s unbalanced disable\n", rdev->desc->node_name);
+	} else {
+		rdev->use_count--;
+	}
+
+	VERBOSE("%s: dis count:%u\n", rdev->desc->node_name, rdev->use_count);
+
+	unlock_driver(rdev);
+
+	if (rdev->supply_dev != NULL) {
+		regulator_disable(rdev->supply_dev);
+	}
+
+	return 0;
+}
+
+/*
+ * Disable regulator
+ *
+ * @rdev - pointer to rdev struct
+ * Return 0 if succeed, non 0 else.
+ */
+int regulator_disable(struct rdev *rdev)
+{
+	assert(rdev != NULL);
+
+	if (rdev->flags & REGUL_ALWAYS_ON) {
+		return 0;
+	}
+
+	return __regulator_disable(rdev);
+}
+#else
+/*
+ * Enable regulator
+ *
+ * @rdev - pointer to rdev struct
+ * Return 0 if succeed, non 0 else.
+ */
+int regulator_enable(struct rdev *rdev)
+{
+	int ret;
+
+	assert(rdev != NULL);
+
+	ret = __regulator_set_state(rdev, STATE_ENABLE);
+
+	udelay(rdev->enable_ramp_delay);
+
+	return ret;
+}
+
+/*
+ * Disable regulator
+ *
+ * @rdev - pointer to rdev struct
+ * Return 0 if succeed, non 0 else.
+ */
+int regulator_disable(struct rdev *rdev)
+{
+	int ret;
+
+	assert(rdev != NULL);
+
+	if (rdev->flags & REGUL_ALWAYS_ON) {
+		return 0;
+	}
+
+	ret = __regulator_set_state(rdev, STATE_DISABLE);
+
+	udelay(rdev->enable_ramp_delay);
+
+	return ret;
+}
+#endif
+
+/*
+ * Regulator enabled query
+ *
+ * @rdev - pointer to rdev struct
+ * Return 0 if disabled, 1 if enabled, <0 else.
+ */
+int regulator_is_enabled(const struct rdev *rdev)
+{
+	int ret = 0;
+
+	assert(rdev != NULL);
+
+	VERBOSE("%s: is en\n", rdev->desc->node_name);
+
+	if (rdev->desc->ops->get_state == NULL) {
+		return -ENODEV;
+	}
+
+	lock_driver(rdev);
+
+	ret = rdev->desc->ops->get_state(rdev->desc);
+	if (ret < 0) {
+		ERROR("regul %s get state failed: err:%d\n",
+		      rdev->desc->node_name, ret);
+	}
+
+	unlock_driver(rdev);
+
+	return ret;
+}
+
+/*
+ * Set regulator voltage
+ *
+ * @rdev - pointer to rdev struct
+ * @mvolt - Target voltage level in millivolt
+ * Return 0 if succeed, non 0 else.
+ */
+int regulator_set_voltage(struct rdev *rdev, uint16_t mvolt)
+{
+	int ret = 0;
+
+	assert(rdev != NULL);
+
+	VERBOSE("%s: set mvolt\n", rdev->desc->node_name);
+
+	if (rdev->desc->ops->set_voltage == NULL) {
+		return -ENODEV;
+	}
+
+	if ((mvolt < rdev->min_mv) || (mvolt > rdev->max_mv)) {
+		return -EPERM;
+	}
+
+	lock_driver(rdev);
+
+	ret = rdev->desc->ops->set_voltage(rdev->desc, mvolt);
+	if (ret < 0) {
+		ERROR("regul %s set volt failed: err:%d\n",
+		      rdev->desc->node_name, ret);
+	}
+
+	unlock_driver(rdev);
+
+	return ret;
+}
+
+/*
+ * Set regulator min voltage
+ *
+ * @rdev - pointer to rdev struct
+ * Return 0 if succeed, non 0 else.
+ */
+int regulator_set_min_voltage(struct rdev *rdev)
+{
+	return regulator_set_voltage(rdev, rdev->min_mv);
+}
+
+/*
+ * Get regulator voltage
+ *
+ * @rdev - pointer to rdev struct
+ * Return milli volts if succeed, <0 else.
+ */
+int regulator_get_voltage(const struct rdev *rdev)
+{
+	int ret = 0;
+
+	assert(rdev != NULL);
+
+	VERBOSE("%s: get volt\n", rdev->desc->node_name);
+
+	if (rdev->desc->ops->get_voltage == NULL) {
+		return rdev->min_mv;
+	}
+
+	lock_driver(rdev);
+
+	ret = rdev->desc->ops->get_voltage(rdev->desc);
+	if (ret < 0) {
+		ERROR("regul %s get voltage failed: err:%d\n",
+		      rdev->desc->node_name, ret);
+	}
+
+	unlock_driver(rdev);
+
+	return ret;
+}
+
+/*
+ * List regulator voltages
+ *
+ * @rdev - pointer to rdev struct
+ * @levels - out: array of supported millitvolt levels from min to max value
+ * @count - out: number of possible millivolt values
+ * Return 0 if succeed, non 0 else.
+ */
+int regulator_list_voltages(const struct rdev *rdev, const uint16_t **levels, size_t *count)
+{
+	int ret;
+	size_t n;
+
+	assert(rdev != NULL);
+	assert(levels != NULL);
+	assert(count != NULL);
+
+	VERBOSE("%s: list volt\n", rdev->desc->node_name);
+
+	if (rdev->desc->ops->list_voltages == NULL) {
+		return -ENODEV;
+	}
+
+	lock_driver(rdev);
+
+	ret = rdev->desc->ops->list_voltages(rdev->desc, levels, count);
+
+	unlock_driver(rdev);
+
+	if (ret < 0) {
+		ERROR("regul %s list_voltages failed: err: %d\n",
+		      rdev->desc->node_name, ret);
+		return ret;
+	}
+
+	/*
+	 * Reduce the possible values depending on min and max from device-tree
+	 */
+	n = *count;
+	while (((*levels)[n - 1U] > rdev->max_mv) && (n > 1U)) {
+		n--;
+	}
+
+	/* Verify that max val is a valid value */
+	if (rdev->max_mv != (*levels)[n - 1]) {
+		ERROR("regul %s: max value %u is invalid\n",
+		      rdev->desc->node_name, rdev->max_mv);
+		return -EINVAL;
+	}
+
+	while (((*levels[0U]) < rdev->min_mv) && (n > 1U)) {
+		(*levels)++;
+		n--;
+	}
+
+	/* Verify that min is not too high */
+	if (n == 0U) {
+		ERROR("regul %s set min voltage is too high\n",
+		      rdev->desc->node_name);
+		return -EINVAL;
+	}
+
+	/* Verify that min val is a valid vlue */
+	if (rdev->min_mv != (*levels)[0U]) {
+		ERROR("regul %s: min value %u is invalid\n",
+		      rdev->desc->node_name, rdev->min_mv);
+		return -EINVAL;
+	}
+
+	*count = n;
+
+	VERBOSE("rdev->min_mv=%u rdev->max_mv=%u\n", rdev->min_mv, rdev->max_mv);
+
+	return 0;
+}
+
+/*
+ * Get regulator voltages range
+ *
+ * @rdev - pointer to rdev struct
+ * @min_mv - out: min possible millivolt value
+ * @max_mv - out: max possible millivolt value
+ * Return 0 if succeed, non 0 else.
+ */
+void regulator_get_range(const struct rdev *rdev, uint16_t *min_mv, uint16_t *max_mv)
+{
+	assert(rdev != NULL);
+
+	if (min_mv != NULL) {
+		*min_mv = rdev->min_mv;
+	}
+	if (max_mv != NULL) {
+		*max_mv = rdev->max_mv;
+	}
+}
+
+/*
+ * Set regulator flag
+ *
+ * @rdev - pointer to rdev struct
+ * @flag - flag value to set (eg: REGUL_OCP)
+ * Return 0 if succeed, non 0 else.
+ */
+int regulator_set_flag(struct rdev *rdev, uint16_t flag)
+{
+	int ret;
+
+	/* check that only one bit is set on flag */
+	if (__builtin_popcount(flag) != 1) {
+		return -EINVAL;
+	}
+
+	/* REGUL_ALWAYS_ON and REGUL_BOOT_ON are internal properties of the core */
+	if ((flag == REGUL_ALWAYS_ON) || (flag == REGUL_BOOT_ON)) {
+		rdev->flags |= flag;
+		return 0;
+	}
+
+	if (rdev->desc->ops->set_flag == NULL) {
+		ERROR("%s can not set any flag\n", rdev->desc->node_name);
+		return -ENODEV;
+	}
+
+	lock_driver(rdev);
+
+	ret = rdev->desc->ops->set_flag(rdev->desc, flag);
+
+	unlock_driver(rdev);
+
+	if (ret != 0) {
+		ERROR("%s: could not set flag %d ret=%d\n",
+		      rdev->desc->node_name, flag, ret);
+		return ret;
+	}
+
+	rdev->flags |= flag;
+
+	return 0;
+}
+
+#if defined(IMAGE_BL32)
+
+struct regul_property {
+	char *name;
+	uint16_t flag;
+};
+
+static struct regul_property flag_prop[] = {
+	{
+		.name = "regulator-always-on",
+		.flag = REGUL_ALWAYS_ON,
+	},
+	{
+		.name = "regulator-boot-on",
+		.flag = REGUL_BOOT_ON,
+	},
+	{
+		.name = "regulator-active-discharge",
+		.flag = REGUL_ACTIVE_DISCHARGE,
+	},
+	{
+		.name = "regulator-over-current-protection",
+		.flag = REGUL_OCP,
+	},
+	{
+		.name = "regulator-pull-down",
+		.flag = REGUL_PULL_DOWN,
+	},
+	{
+		.name = "st,mask-reset",
+		.flag = REGUL_MASK_RESET,
+	},
+	{
+		.name = "st,regulator-sink-source",
+		.flag = REGUL_SINK_SOURCE,
+	},
+	{
+		.name = "st,regulator-bypass",
+		.flag = REGUL_ENABLE_BYPASS,
+	},
+};
+
+static int parse_properties(const void *fdt, struct rdev *rdev, int node)
+{
+	const fdt32_t *cuint;
+	int ret = 0;
+	struct regul_property *prop;
+
+	for (prop = flag_prop; prop < (flag_prop + ARRAY_SIZE(flag_prop)); prop++) {
+		if (fdt_getprop(fdt, node, prop->name, NULL) != NULL) {
+			VERBOSE("%s: prop 0x%x\n", rdev->desc->node_name, prop->flag);
+			ret = regulator_set_flag(rdev, prop->flag);
+			if (ret != 0) {
+				return ret;
+			}
+		}
+	}
+
+	cuint = fdt_getprop(fdt, node, "regulator-enable-ramp-delay", NULL);
+	if (cuint != NULL) {
+		rdev->enable_ramp_delay = (uint32_t)(fdt32_to_cpu(*cuint));
+		VERBOSE("%s: enable_ramp_delay=%u\n", rdev->desc->node_name,
+			rdev->enable_ramp_delay);
+	}
+
+	rdev->reg_name = fdt_getprop(fdt, node, "regulator-name", NULL);
+
+	return 0;
+}
+
+static void parse_supply(const void *fdt, struct rdev *rdev, int node)
+{
+	const char *name = rdev->desc->supply_name;
+
+	if (name == NULL) {
+		name = rdev->desc->node_name;
+	}
+
+	rdev->supply_phandle = get_supply_phandle(fdt, node, name);
+	if (rdev->supply_phandle < 0) {
+		node = fdt_parent_offset(fdt, node);
+		rdev->supply_phandle = get_supply_phandle(fdt, node, name);
+	}
+}
+
+static void parse_low_power_mode(const void *fdt, struct rdev *rdev, int node, int mode)
+{
+	const fdt32_t *cuint;
+
+	rdev->lp_state[mode] = 0;
+
+	if (fdt_getprop(fdt, node, "regulator-off-in-suspend", NULL) != NULL) {
+		VERBOSE("%s: mode:%d OFF\n", rdev->desc->node_name, mode);
+		rdev->lp_state[mode] |= LP_STATE_OFF;
+	} else if (fdt_getprop(fdt, node, "regulator-on-in-suspend", NULL) != NULL) {
+		VERBOSE("%s: mode:%d ON\n", rdev->desc->node_name, mode);
+		rdev->lp_state[mode] |= LP_STATE_ON;
+	} else {
+		rdev->lp_state[mode] |= LP_STATE_UNCHANGED;
+	}
+
+	cuint = fdt_getprop(fdt, node, "regulator-suspend-microvolt", NULL);
+	if (cuint != NULL) {
+		uint16_t mv;
+
+		mv = (uint16_t)(fdt32_to_cpu(*cuint) / 1000U);
+		VERBOSE("%s: mode:%d suspend mv=%u\n", rdev->desc->node_name,
+			mode, mv);
+
+		rdev->lp_state[mode] |= LP_STATE_SET_VOLT;
+		rdev->lp_mv[mode] = mv;
+	}
+}
+
+static void parse_low_power_modes(const void *fdt, struct rdev *rdev, int node)
+{
+	int i;
+
+	for (i = 0; i < PLAT_NB_SUSPEND_MODES; i++) {
+		const char *lp_mode_name = plat_get_lp_mode_name(i);
+		int n;
+
+		if (lp_mode_name == NULL) {
+			continue;
+		}
+
+		/* Get the configs from regulator_state_node subnode */
+		n = fdt_subnode_offset(fdt, node, lp_mode_name);
+		if (n >= 0) {
+			parse_low_power_mode(fdt, rdev, n, i);
+		}
+	}
+}
+#else
+static int parse_properties(const void *fdt, struct rdev *rdev, int node)
+{
+	const fdt32_t *cuint;
+	int ret;
+
+	if (fdt_getprop(fdt, node, "regulator-always-on", NULL) != NULL) {
+		VERBOSE("%s: set regulator-always-on\n", rdev->desc->node_name);
+		ret = regulator_set_flag(rdev, REGUL_ALWAYS_ON);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	cuint = fdt_getprop(fdt, node, "regulator-enable-ramp-delay", NULL);
+	if (cuint != NULL) {
+		rdev->enable_ramp_delay = fdt32_to_cpu(*cuint);
+		VERBOSE("%s: enable_ramp_delay=%u\n", rdev->desc->node_name,
+			rdev->enable_ramp_delay);
+	}
+
+	return 0;
+}
+#endif
+
+/*
+ * Parse the device-tree for a regulator
+ *
+ * Read min/max voltage from dt and check its validity
+ * Read the properties, and call the driver to set flags
+ * Read power supply phandle
+ * Read and store low power mode states
+ *
+ * @rdev - pointer to rdev struct
+ * @node - device-tree node offset of the regulator
+ * Return 0 if disabled, 1 if enabled, <0 else.
+ */
+static int parse_dt(struct rdev *rdev, int node)
+{
+	void *fdt;
+	const fdt32_t *cuint;
+	const uint16_t *levels;
+	size_t size;
+	int ret = 0;
+
+	VERBOSE("%s: parse dt\n", rdev->desc->node_name);
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -ENOENT;
+	}
+
+	rdev->phandle = fdt_get_phandle(fdt, node);
+
+	cuint = fdt_getprop(fdt, node, "regulator-min-microvolt", NULL);
+	if (cuint != NULL) {
+		uint16_t min_mv;
+
+		min_mv = (uint16_t)(fdt32_to_cpu(*cuint) / 1000U);
+		VERBOSE("%s: min_mv=%d\n", rdev->desc->node_name, (int)min_mv);
+		if (min_mv <= rdev->max_mv) {
+			rdev->min_mv = min_mv;
+		} else {
+			ERROR("%s: min_mv=%d is too high\n",
+			      rdev->desc->node_name, (int)min_mv);
+			return -EINVAL;
+		}
+	}
+
+	cuint = fdt_getprop(fdt, node, "regulator-max-microvolt", NULL);
+	if (cuint != NULL) {
+		uint16_t max_mv;
+
+		max_mv = (uint16_t)(fdt32_to_cpu(*cuint) / 1000U);
+		VERBOSE("%s: max_mv=%d\n", rdev->desc->node_name, (int)max_mv);
+		if (max_mv >= rdev->min_mv) {
+			rdev->max_mv = max_mv;
+		} else {
+			ERROR("%s: max_mv=%d is too low\n",
+			      rdev->desc->node_name, (int)max_mv);
+			return -EINVAL;
+		}
+	}
+
+	/* validate that min and max values can be used */
+	ret = regulator_list_voltages(rdev, &levels, &size);
+	if ((ret != 0) && (ret != -ENODEV)) {
+		return ret;
+	}
+
+	ret = parse_properties(fdt, rdev, node);
+	if (ret != 0) {
+		return ret;
+	}
+
+#if defined(IMAGE_BL32)
+	parse_supply(fdt, rdev, node);
+
+	parse_low_power_modes(fdt, rdev, node);
+#endif
+
+	return 0;
+}
+
+/*
+ * Register a regulator driver in regulator framework.
+ * Initialize voltage range from driver description
+ *
+ * @desc - pointer to the regulator description
+ * @node - device-tree node offset of the regulator
+ * Return 0 if succeed, non 0 else.
+ */
+int regulator_register(const struct regul_description *desc, int node)
+{
+	struct rdev *rdev;
+
+	assert(desc != NULL);
+
+	VERBOSE("register %s\n", desc->node_name);
+
+	for_each_rdev(rdev) {
+		if (rdev->desc == NULL) {
+			break;
+		}
+	}
+
+	if (rdev == rdev_array + PLAT_NB_RDEVS) {
+		WARN("Not enough place for regulators, PLAT_NB_RDEVS should be increased.\n");
+		return -ENOMEM;
+	}
+
+	rdev->desc = desc;
+	rdev->enable_ramp_delay = rdev->desc->enable_ramp_delay;
+
+	if (rdev->desc->ops->list_voltages != NULL) {
+		int ret = 0;
+		const uint16_t *levels;
+		size_t count;
+
+		lock_driver(rdev);
+
+		ret = rdev->desc->ops->list_voltages(rdev->desc, &levels, &count);
+
+		unlock_driver(rdev);
+
+		if (ret < 0) {
+			ERROR("regul %s set state failed: err:%d\n",
+			      rdev->desc->node_name, ret);
+			return ret;
+		}
+
+		rdev->min_mv = levels[0];
+		rdev->max_mv = levels[count - 1U];
+	} else {
+		rdev->max_mv = UINT16_MAX;
+	}
+
+	return parse_dt(rdev, node);
+}
+
+#if defined(IMAGE_BL32)
+/*
+ * Suspend a single regulator before low power entry
+ * Call regulator suspend call back,
+ * Enable the regulator if boot_on flag is set as regulator is needed during
+ * boot/resume from suspend sequences.
+ *
+ * @rdev - pointer to rdev struct
+ * @mode - low power mode index
+ * Return 0 if succeed, non 0 else.
+ */
+static int suspend_regulator(struct rdev *rdev, int mode)
+{
+	int ret = 0;
+
+	if (rdev->desc->ops->suspend != NULL) {
+		lock_driver(rdev);
+		ret = rdev->desc->ops->suspend(rdev->desc,
+					       rdev->lp_state[mode],
+					       rdev->lp_mv[mode]);
+		unlock_driver(rdev);
+		if (ret != 0) {
+			ERROR("%s failed to suspend: %d\n", rdev->desc->node_name, ret);
+			return ret;
+		}
+	}
+
+	if (rdev->flags & REGUL_BOOT_ON) {
+		ret = regulator_enable(rdev);
+	}
+
+	return ret;
+}
+
+/*
+ * Resume a single regulator after low power
+ *
+ * @rdev - pointer to rdev struct
+ * Return 0 if succeed, non 0 else.
+ */
+static int resume_regulator(struct rdev *rdev)
+{
+	int ret = 0;
+
+	if (rdev->flags & REGUL_BOOT_ON) {
+		/* Revert to the state it was before suspend */
+		ret = regulator_disable(rdev);
+		if (ret != 0) {
+			ERROR("%s failed to resume: %d\n", rdev->desc->node_name, ret);
+		}
+	}
+
+	return ret;
+}
+
+/*
+ * Suspend regulators before entering low power
+ *
+ * Return 0 if succeed, non 0 else.
+ */
+int regulator_core_suspend(int mode)
+{
+	struct rdev *rdev;
+
+	VERBOSE("Regulator core suspend\n");
+
+	if (mode >= PLAT_NB_SUSPEND_MODES) {
+		return -EINVAL;
+	}
+
+	/* Suspend each regulator */
+	for_each_registered_rdev(rdev) {
+		if (suspend_regulator(rdev, mode) != 0) {
+			panic();
+		}
+	}
+
+#if LOG_LEVEL >= LOG_LEVEL_VERBOSE
+	regulator_core_dump();
+#endif
+
+	return 0;
+}
+
+/*
+ * Resume regulators from low power
+ *
+ * Return 0 if succeed, non 0 else.
+ */
+int regulator_core_resume(void)
+{
+	struct rdev *rdev;
+
+	VERBOSE("Regulator core resume\n");
+
+	/* Resume each regulator */
+	for_each_registered_rdev(rdev) {
+		if (resume_regulator(rdev) != 0) {
+			panic();
+		}
+	}
+
+#if LOG_LEVEL >= LOG_LEVEL_VERBOSE
+	regulator_core_dump();
+#endif
+
+	return 0;
+}
+
+/*
+ * save regulators data
+ *
+ * @backup_area - pointer to save data
+ * @backup_size - size of the backup area
+ */
+void regulator_core_backup_context(void *backup_area, size_t backup_size)
+{
+	int8_t *data = (int8_t *)backup_area;
+	struct rdev *rdev;
+
+	assert(data != NULL);
+	assert(backup_size == PLAT_BACKUP_REGULATOR_SIZE);
+
+	for_each_rdev(rdev) {
+		*data = rdev->use_count;
+		data++;
+	}
+}
+
+/*
+ * restore regulators data
+ *
+ * @backup_area - pointer to retrieve saved data
+ * @backup_size - size of the backup area
+ */
+void regulator_core_restore_context(void *backup_area, size_t backup_size)
+{
+	int8_t *data = (int8_t *)backup_area;
+	struct rdev *rdev;
+
+	assert(data != NULL);
+	assert(backup_size == PLAT_BACKUP_REGULATOR_SIZE);
+
+	for_each_rdev(rdev) {
+		rdev->use_count = *data;
+		data++;
+	}
+}
+
+#if LOG_LEVEL >= LOG_LEVEL_VERBOSE
+static void sprint_name(char *dest, const char *src, int len)
+{
+	int l;
+
+	if (src == NULL) {
+		src = "";
+	}
+
+	l = strlen(src);
+	if (l > len) {
+		l = len;
+	}
+
+	memset(dest, ' ', len);
+	memcpy(dest, src, l);
+	dest[len] = 0;
+}
+
+/*
+ * Log regulators state
+ */
+void regulator_core_dump(void)
+{
+	struct rdev *rdev;
+
+	VERBOSE("Dump Regulators\n");
+
+	INFO("reg      name     use\ten\tmV\tmin\tmax\tflags\tsupply\n");
+
+	for_each_registered_rdev(rdev) {
+		uint16_t min_mv, max_mv;
+		char reg[9] = "";
+		char name[9];
+		const char *supply = "";
+
+		sprint_name(name, rdev->desc->node_name, 8);
+		sprint_name(reg, rdev->reg_name, 8);
+
+		regulator_get_range(rdev, &min_mv, &max_mv);
+		if (rdev->supply_dev != NULL)
+			supply = rdev->supply_dev->desc->node_name;
+
+		INFO("%s %s %d\t%d\t%d\t%d\t%d\t0x%x\t%s\n",
+		     reg, name,
+		     rdev->use_count,
+		     regulator_is_enabled(rdev),
+		     regulator_get_voltage(rdev),  min_mv, max_mv,
+		     rdev->flags, supply);
+	}
+}
+#endif
+
+/*
+ * Connect each regulator to its supply
+ * Apply min voltage if the voltage is outside the authorized range
+ * Enable always-on regulators
+ *
+ * Return 0 if succeed, non 0 else.
+ */
+int regulator_core_config(void)
+{
+	int ret;
+	struct rdev *rdev;
+
+	VERBOSE("Regul Core config\n");
+
+	for_each_registered_rdev(rdev) {
+		if (rdev->supply_phandle >= 0) {
+			struct rdev *s;
+
+			VERBOSE("%s: connect supply\n", rdev->desc->node_name);
+
+			s = regulator_get_by_phandle(rdev->supply_phandle);
+			if (s == NULL) {
+				return -EINVAL;
+			}
+
+			rdev->supply_dev = s;
+		}
+	}
+
+	for_each_registered_rdev(rdev) {
+		uint16_t mv, min_mv, max_mv;
+
+		regulator_get_range(rdev, &min_mv, &max_mv);
+
+		ret = regulator_get_voltage(rdev);
+		if (ret >= 0) {
+			mv = ret;
+			if ((mv < min_mv) || (mv > max_mv)) {
+				ret = regulator_set_voltage(rdev, min_mv);
+				if (ret != 0) {
+					return ret;
+				}
+			}
+		} else {
+			return ret;
+		}
+
+		/*
+		 * Enable always-on regulator and increment its use_count so that
+		 * the regulator is not being disabled during clean-up sequence.
+		 */
+		if (rdev->flags & REGUL_ALWAYS_ON) {
+			ret = __regulator_enable(rdev);
+			if (ret != 0) {
+				return ret;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Sync hardware regulator state with use refcount
+ *
+ * Return 0 if succeed, non 0 else.
+ */
+int regulator_core_cleanup(void)
+{
+	struct rdev *rdev;
+
+	VERBOSE("Regul Core cleanup\n");
+
+	for_each_registered_rdev(rdev) {
+		if (!(rdev->flags & REGUL_BOOT_ON)) {
+			if ((rdev->use_count == 0) && (regulator_is_enabled(rdev) == 1)) {
+				VERBOSE("disable %s during cleanup\n", rdev->desc->node_name);
+				/* force disable to synchronize the framework */
+				__regulator_set_state(rdev, STATE_DISABLE);
+			}
+		}
+	}
+
+#if LOG_LEVEL >= LOG_LEVEL_VERBOSE
+	regulator_core_dump();
+#endif
+
+	return 0;
+}
+
+#endif
diff --git a/drivers/scmi-msg/base.c b/drivers/scmi-msg/base.c
index 2d7203451..522819c09 100644
--- a/drivers/scmi-msg/base.c
+++ b/drivers/scmi-msg/base.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: BSD-3-Clause
 /*
  * Copyright (c) 2015-2019, Arm Limited and Contributors. All rights reserved.
- * Copyright (c) 2019-2020, Linaro Limited
+ * Copyright (c) 2019-2022, Linaro Limited
  */
 #include <assert.h>
 #include <string.h>
@@ -165,7 +165,7 @@ static void discover_list_protocols(struct scmi_msg *msg)
 	memcpy(outargs, &p2a, sizeof(p2a));
 	memcpy(outargs + sizeof(p2a), list + a2p->skip, count);
 
-	scmi_write_response(msg, outargs, sizeof(outargs));
+	scmi_write_response(msg, outargs, sizeof(p2a) + round_up(count, sizeof(uint32_t)));
 }
 
 static const scmi_msg_handler_t scmi_base_handler_table[] = {
diff --git a/drivers/scmi-msg/clock.c b/drivers/scmi-msg/clock.c
index e96cede6e..c169b8e69 100644
--- a/drivers/scmi-msg/clock.c
+++ b/drivers/scmi-msg/clock.c
@@ -20,6 +20,8 @@
 #pragma weak plat_scmi_clock_set_rate
 #pragma weak plat_scmi_clock_get_state
 #pragma weak plat_scmi_clock_set_state
+#pragma weak plat_scmi_clock_get_duty_cycle
+#pragma weak plat_scmi_clock_get_round_rate
 
 static bool message_id_is_supported(unsigned int message_id);
 
@@ -75,6 +77,21 @@ int32_t plat_scmi_clock_set_state(unsigned int agent_id __unused,
 	return SCMI_NOT_SUPPORTED;
 }
 
+int32_t plat_scmi_clock_get_duty_cycle(unsigned int agent_id __unused,
+				       unsigned int scmi_id __unused,
+				       unsigned int *num __unused,
+				       unsigned int *den __unused)
+{
+	return SCMI_NOT_SUPPORTED;
+}
+
+int32_t plat_scmi_clock_get_round_rate(unsigned int agent_id __unused,
+				       unsigned int scmi_id __unused)
+{
+	/* Return the clock rate */
+	return plat_scmi_clock_get_rate(agent_id, scmi_id);
+}
+
 static void report_version(struct scmi_msg *msg)
 {
 	struct scmi_protocol_version_p2a return_values = {
@@ -193,6 +210,35 @@ static void scmi_clock_rate_get(struct scmi_msg *msg)
 	scmi_write_response(msg, &return_values, sizeof(return_values));
 }
 
+static void scmi_clock_round_rate_get(struct scmi_msg *msg)
+{
+	const struct scmi_clock_rate_get_a2p *in_args = (void *)msg->in;
+	unsigned long rate = 0U;
+	struct scmi_clock_rate_get_p2a return_values = {
+		.status = SCMI_SUCCESS,
+	};
+	unsigned int clock_id = 0U;
+
+	if (msg->in_size != sizeof(*in_args)) {
+		scmi_status_response(msg, SCMI_PROTOCOL_ERROR);
+		return;
+	}
+
+	clock_id = SPECULATION_SAFE_VALUE(in_args->clock_id);
+
+	if (clock_id >= plat_scmi_clock_count(msg->agent_id)) {
+		scmi_status_response(msg, SCMI_INVALID_PARAMETERS);
+		return;
+	}
+
+	rate = plat_scmi_clock_get_round_rate(msg->agent_id, clock_id);
+
+	return_values.rate[0] = (uint32_t)rate;
+	return_values.rate[1] = (uint32_t)((uint64_t)rate >> 32);
+
+	scmi_write_response(msg, &return_values, sizeof(return_values));
+}
+
 static void scmi_clock_rate_set(struct scmi_msg *msg)
 {
 	const struct scmi_clock_rate_set_a2p *in_args = (void *)msg->in;
@@ -220,6 +266,34 @@ static void scmi_clock_rate_set(struct scmi_msg *msg)
 	scmi_status_response(msg, status);
 }
 
+static void scmi_clock_duty_cycle_get(struct scmi_msg *msg)
+{
+	const struct scmi_clock_duty_cycle_get_a2p *in_args = (void *)msg->in;
+	struct scmi_clock_duty_cycle_get_p2a return_values = { };
+	unsigned int clock_id = 0U;
+	unsigned int numerator = 1U;
+	unsigned int denominator = 2U;
+
+	if (msg->in_size != sizeof(*in_args)) {
+		scmi_status_response(msg, SCMI_PROTOCOL_ERROR);
+		return;
+	}
+
+	clock_id = SPECULATION_SAFE_VALUE(in_args->clock_id);
+
+	if (clock_id >= plat_scmi_clock_count(msg->agent_id)) {
+		scmi_status_response(msg, SCMI_INVALID_PARAMETERS);
+		return;
+	}
+
+	plat_scmi_clock_get_duty_cycle(msg->agent_id, clock_id,
+				       &numerator, &denominator);
+	return_values.num = numerator;
+	return_values.den = denominator;
+
+	scmi_write_response(msg, &return_values, sizeof(return_values));
+}
+
 static void scmi_clock_config_set(struct scmi_msg *msg)
 {
 	const struct scmi_clock_config_set_a2p *in_args = (void *)msg->in;
@@ -359,6 +433,8 @@ static const scmi_msg_handler_t scmi_clock_handler_table[] = {
 	[SCMI_CLOCK_RATE_SET] = scmi_clock_rate_set,
 	[SCMI_CLOCK_RATE_GET] = scmi_clock_rate_get,
 	[SCMI_CLOCK_CONFIG_SET] = scmi_clock_config_set,
+	[SCMI_CLOCK_DUTY_CYCLE_GET] = scmi_clock_duty_cycle_get,
+	[SCMI_CLOCK_ROUND_RATE_GET] = scmi_clock_round_rate_get,
 };
 
 static bool message_id_is_supported(size_t message_id)
diff --git a/drivers/scmi-msg/clock.h b/drivers/scmi-msg/clock.h
index a637934ee..eacbf0d27 100644
--- a/drivers/scmi-msg/clock.h
+++ b/drivers/scmi-msg/clock.h
@@ -22,6 +22,8 @@ enum scmi_clock_command_id {
 	SCMI_CLOCK_RATE_SET = 0x005,
 	SCMI_CLOCK_RATE_GET = 0x006,
 	SCMI_CLOCK_CONFIG_SET = 0x007,
+	SCMI_CLOCK_DUTY_CYCLE_GET = 0x008,
+	SCMI_CLOCK_ROUND_RATE_GET = 0x009,
 };
 
 /* Protocol attributes */
@@ -57,6 +59,16 @@ struct scmi_clock_rate_get_p2a {
 	uint32_t rate[2];
 };
 
+struct scmi_clock_duty_cycle_get_a2p {
+	uint32_t clock_id;
+};
+
+struct scmi_clock_duty_cycle_get_p2a {
+	int32_t status;
+	uint32_t num;
+	uint32_t den;
+};
+
 /*
  * Clock Rate Set
  */
diff --git a/drivers/st/bsec/bsec.c b/drivers/st/bsec/bsec.c
deleted file mode 100644
index 01c369edc..000000000
--- a/drivers/st/bsec/bsec.c
+++ /dev/null
@@ -1,891 +0,0 @@
-/*
- * Copyright (c) 2017-2019, STMicroelectronics - All Rights Reserved
- *
- * SPDX-License-Identifier: BSD-3-Clause
- */
-
-#include <assert.h>
-#include <limits.h>
-
-#include <libfdt.h>
-
-#include <platform_def.h>
-
-#include <arch_helpers.h>
-#include <common/debug.h>
-#include <drivers/st/bsec.h>
-#include <lib/mmio.h>
-#include <lib/spinlock.h>
-
-#define BSEC_IP_VERSION_1_0	0x10
-#define BSEC_COMPAT		"st,stm32mp15-bsec"
-
-#define OTP_ACCESS_SIZE (round_up(OTP_MAX_SIZE, __WORD_BIT) / __WORD_BIT)
-
-static uint32_t otp_nsec_access[OTP_ACCESS_SIZE] __unused;
-
-static uint32_t bsec_power_safmem(bool power);
-
-/* BSEC access protection */
-static spinlock_t bsec_spinlock;
-static uintptr_t bsec_base;
-
-static void bsec_lock(void)
-{
-	if (stm32mp_lock_available()) {
-		spin_lock(&bsec_spinlock);
-	}
-}
-
-static void bsec_unlock(void)
-{
-	if (stm32mp_lock_available()) {
-		spin_unlock(&bsec_spinlock);
-	}
-}
-
-static int bsec_get_dt_node(struct dt_node_info *info)
-{
-	int node;
-
-	node = dt_get_node(info, -1, BSEC_COMPAT);
-	if (node < 0) {
-		return -FDT_ERR_NOTFOUND;
-	}
-
-	return node;
-}
-
-#if defined(IMAGE_BL32)
-static void enable_non_secure_access(uint32_t otp)
-{
-	otp_nsec_access[otp / __WORD_BIT] |= BIT(otp % __WORD_BIT);
-
-	if (bsec_shadow_register(otp) != BSEC_OK) {
-		panic();
-	}
-}
-
-static bool non_secure_can_access(uint32_t otp)
-{
-	return (otp_nsec_access[otp / __WORD_BIT] &
-		BIT(otp % __WORD_BIT)) != 0;
-}
-
-static int bsec_dt_otp_nsec_access(void *fdt, int bsec_node)
-{
-	int bsec_subnode;
-
-	fdt_for_each_subnode(bsec_subnode, fdt, bsec_node) {
-		const fdt32_t *cuint;
-		uint32_t reg;
-		uint32_t i;
-		uint32_t size;
-		uint8_t status;
-
-		cuint = fdt_getprop(fdt, bsec_subnode, "reg", NULL);
-		if (cuint == NULL) {
-			panic();
-		}
-
-		reg = fdt32_to_cpu(*cuint) / sizeof(uint32_t);
-		if (reg < STM32MP1_UPPER_OTP_START) {
-			continue;
-		}
-
-		status = fdt_get_status(bsec_subnode);
-		if ((status & DT_NON_SECURE) == 0U)  {
-			continue;
-		}
-
-		size = fdt32_to_cpu(*(cuint + 1)) / sizeof(uint32_t);
-
-		if ((fdt32_to_cpu(*(cuint + 1)) % sizeof(uint32_t)) != 0) {
-			size++;
-		}
-
-		for (i = reg; i < (reg + size); i++) {
-			enable_non_secure_access(i);
-		}
-	}
-
-	return 0;
-}
-#endif
-
-static uint32_t otp_bank_offset(uint32_t otp)
-{
-	assert(otp <= STM32MP1_OTP_MAX_ID);
-
-	return ((otp & ~BSEC_OTP_MASK) >> BSEC_OTP_BANK_SHIFT) *
-	       sizeof(uint32_t);
-}
-
-static uint32_t bsec_check_error(uint32_t otp)
-{
-	uint32_t bit = BIT(otp & BSEC_OTP_MASK);
-	uint32_t bank = otp_bank_offset(otp);
-
-	if ((mmio_read_32(bsec_base + BSEC_DISTURBED_OFF + bank) & bit) != 0U) {
-		return BSEC_DISTURBED;
-	}
-
-	if ((mmio_read_32(bsec_base + BSEC_ERROR_OFF + bank) & bit) != 0U) {
-		return BSEC_ERROR;
-	}
-
-	return BSEC_OK;
-}
-
-/*
- * bsec_probe: initialize BSEC driver.
- * return value: BSEC_OK if no error.
- */
-uint32_t bsec_probe(void)
-{
-	void *fdt;
-	int node;
-	struct dt_node_info bsec_info;
-
-	if (fdt_get_address(&fdt) == 0) {
-		panic();
-	}
-
-	node = bsec_get_dt_node(&bsec_info);
-	if (node < 0) {
-		panic();
-	}
-
-	bsec_base = bsec_info.base;
-
-#if defined(IMAGE_BL32)
-	bsec_dt_otp_nsec_access(fdt, node);
-#endif
-	return BSEC_OK;
-}
-
-/*
- * bsec_get_base: return BSEC base address.
- */
-uint32_t bsec_get_base(void)
-{
-	return bsec_base;
-}
-
-/*
- * bsec_set_config: enable and configure BSEC.
- * cfg: pointer to param structure used to set register.
- * return value: BSEC_OK if no error.
- */
-uint32_t bsec_set_config(struct bsec_config *cfg)
-{
-	uint32_t value;
-	int32_t result;
-
-	value = ((((uint32_t)cfg->freq << BSEC_CONF_FRQ_SHIFT) &
-						BSEC_CONF_FRQ_MASK) |
-		 (((uint32_t)cfg->pulse_width << BSEC_CONF_PRG_WIDTH_SHIFT) &
-						BSEC_CONF_PRG_WIDTH_MASK) |
-		 (((uint32_t)cfg->tread << BSEC_CONF_TREAD_SHIFT) &
-						BSEC_CONF_TREAD_MASK));
-
-	bsec_lock();
-
-	mmio_write_32(bsec_base + BSEC_OTP_CONF_OFF, value);
-
-	bsec_unlock();
-
-	result = bsec_power_safmem((bool)cfg->power &
-				   BSEC_CONF_POWER_UP_MASK);
-	if (result != BSEC_OK) {
-		return result;
-	}
-
-	value = ((((uint32_t)cfg->upper_otp_lock << UPPER_OTP_LOCK_SHIFT) &
-						UPPER_OTP_LOCK_MASK) |
-		 (((uint32_t)cfg->den_lock << DENREG_LOCK_SHIFT) &
-						DENREG_LOCK_MASK) |
-		 (((uint32_t)cfg->prog_lock << GPLOCK_LOCK_SHIFT) &
-						GPLOCK_LOCK_MASK));
-
-	bsec_lock();
-
-	mmio_write_32(bsec_base + BSEC_OTP_LOCK_OFF, value);
-
-	bsec_unlock();
-
-	return BSEC_OK;
-}
-
-/*
- * bsec_get_config: return config parameters set in BSEC registers.
- * cfg: config param return.
- * return value: BSEC_OK if no error.
- */
-uint32_t bsec_get_config(struct bsec_config *cfg)
-{
-	uint32_t value;
-
-	if (cfg == NULL) {
-		return BSEC_INVALID_PARAM;
-	}
-
-	value = mmio_read_32(bsec_base + BSEC_OTP_CONF_OFF);
-	cfg->power = (uint8_t)((value & BSEC_CONF_POWER_UP_MASK) >>
-						BSEC_CONF_POWER_UP_SHIFT);
-	cfg->freq = (uint8_t)((value & BSEC_CONF_FRQ_MASK) >>
-						BSEC_CONF_FRQ_SHIFT);
-	cfg->pulse_width = (uint8_t)((value & BSEC_CONF_PRG_WIDTH_MASK) >>
-						BSEC_CONF_PRG_WIDTH_SHIFT);
-	cfg->tread = (uint8_t)((value & BSEC_CONF_TREAD_MASK) >>
-						BSEC_CONF_TREAD_SHIFT);
-
-	value = mmio_read_32(bsec_base + BSEC_OTP_LOCK_OFF);
-	cfg->upper_otp_lock = (uint8_t)((value & UPPER_OTP_LOCK_MASK) >>
-						UPPER_OTP_LOCK_SHIFT);
-	cfg->den_lock = (uint8_t)((value & DENREG_LOCK_MASK) >>
-						DENREG_LOCK_SHIFT);
-	cfg->prog_lock = (uint8_t)((value & GPLOCK_LOCK_MASK) >>
-						GPLOCK_LOCK_SHIFT);
-
-	return BSEC_OK;
-}
-
-/*
- * bsec_shadow_register: copy SAFMEM OTP to BSEC data.
- * otp: OTP number.
- * return value: BSEC_OK if no error.
- */
-uint32_t bsec_shadow_register(uint32_t otp)
-{
-	uint32_t result;
-	bool power_up = false;
-
-	if (otp > STM32MP1_OTP_MAX_ID) {
-		return BSEC_INVALID_PARAM;
-	}
-
-	/* Check if shadowing of OTP is locked */
-	if (bsec_read_sr_lock(otp)) {
-		VERBOSE("BSEC: OTP %i is locked and will not be refreshed\n",
-			otp);
-	}
-
-	if ((bsec_get_status() & BSEC_MODE_PWR_MASK) == 0U) {
-		result = bsec_power_safmem(true);
-
-		if (result != BSEC_OK) {
-			return result;
-		}
-
-		power_up = true;
-	}
-
-	bsec_lock();
-
-	/* Set BSEC_OTP_CTRL_OFF and set ADDR with the OTP value */
-	mmio_write_32(bsec_base + BSEC_OTP_CTRL_OFF, otp | BSEC_READ);
-
-	while ((bsec_get_status() & BSEC_MODE_BUSY_MASK) != 0U) {
-		;
-	}
-
-	result = bsec_check_error(otp);
-
-	bsec_unlock();
-
-	if (power_up) {
-		if (bsec_power_safmem(false) != BSEC_OK) {
-			panic();
-		}
-	}
-
-	return result;
-}
-
-/*
- * bsec_read_otp: read an OTP data value.
- * val: read value.
- * otp: OTP number.
- * return value: BSEC_OK if no error.
- */
-uint32_t bsec_read_otp(uint32_t *val, uint32_t otp)
-{
-	uint32_t result;
-
-	if (otp > STM32MP1_OTP_MAX_ID) {
-		return BSEC_INVALID_PARAM;
-	}
-
-	bsec_lock();
-
-	*val = mmio_read_32(bsec_base + BSEC_OTP_DATA_OFF +
-			    (otp * sizeof(uint32_t)));
-
-	result = bsec_check_error(otp);
-
-	bsec_unlock();
-
-	return result;
-}
-
-/*
- * bsec_write_otp: write value in BSEC data register.
- * val: value to write.
- * otp: OTP number.
- * return value: BSEC_OK if no error.
- */
-uint32_t bsec_write_otp(uint32_t val, uint32_t otp)
-{
-	uint32_t result;
-
-	if (otp > STM32MP1_OTP_MAX_ID) {
-		return BSEC_INVALID_PARAM;
-	}
-
-	/* Check if programming of OTP is locked */
-	if (bsec_read_sw_lock(otp)) {
-		VERBOSE("BSEC: OTP %i is locked and write will be ignored\n",
-			otp);
-	}
-
-	bsec_lock();
-
-	mmio_write_32(bsec_base + BSEC_OTP_DATA_OFF +
-		      (otp * sizeof(uint32_t)), val);
-
-	result = bsec_check_error(otp);
-
-	bsec_unlock();
-
-	return result;
-}
-
-/*
- * bsec_program_otp: program a bit in SAFMEM after the prog.
- *	The OTP data is not refreshed.
- * val: value to program.
- * otp: OTP number.
- * return value: BSEC_OK if no error.
- */
-uint32_t bsec_program_otp(uint32_t val, uint32_t otp)
-{
-	uint32_t result;
-	bool power_up = false;
-
-	if (otp > STM32MP1_OTP_MAX_ID) {
-		return BSEC_INVALID_PARAM;
-	}
-
-	/* Check if programming of OTP is locked */
-	if (bsec_read_sp_lock(otp)) {
-		WARN("BSEC: OTP locked, prog will be ignored\n");
-	}
-
-	if ((mmio_read_32(bsec_base + BSEC_OTP_LOCK_OFF) &
-	     BIT(BSEC_LOCK_PROGRAM)) != 0U) {
-		WARN("BSEC: GPLOCK activated, prog will be ignored\n");
-	}
-
-	if ((bsec_get_status() & BSEC_MODE_PWR_MASK) == 0U) {
-		result = bsec_power_safmem(true);
-
-		if (result != BSEC_OK) {
-			return result;
-		}
-
-		power_up = true;
-	}
-
-	bsec_lock();
-
-	/* Set value in write register */
-	mmio_write_32(bsec_base + BSEC_OTP_WRDATA_OFF, val);
-
-	/* Set BSEC_OTP_CTRL_OFF and set ADDR with the OTP value */
-	mmio_write_32(bsec_base + BSEC_OTP_CTRL_OFF, otp | BSEC_WRITE);
-
-	while ((bsec_get_status() & BSEC_MODE_BUSY_MASK) != 0U) {
-		;
-	}
-
-	if ((bsec_get_status() & BSEC_MODE_PROGFAIL_MASK) != 0U) {
-		result = BSEC_PROG_FAIL;
-	} else {
-		result = bsec_check_error(otp);
-	}
-
-	bsec_unlock();
-
-	if (power_up) {
-		if (bsec_power_safmem(false) != BSEC_OK) {
-			panic();
-		}
-	}
-
-	return result;
-}
-
-/*
- * bsec_permanent_lock_otp: permanent lock of OTP in SAFMEM.
- * otp: OTP number.
- * return value: BSEC_OK if no error.
- */
-uint32_t bsec_permanent_lock_otp(uint32_t otp)
-{
-	uint32_t result;
-	bool power_up = false;
-	uint32_t data;
-	uint32_t addr;
-
-	if (otp > STM32MP1_OTP_MAX_ID) {
-		return BSEC_INVALID_PARAM;
-	}
-
-	if ((bsec_get_status() & BSEC_MODE_PWR_MASK) == 0U) {
-		result = bsec_power_safmem(true);
-
-		if (result != BSEC_OK) {
-			return result;
-		}
-
-		power_up = true;
-	}
-
-	if (otp < STM32MP1_UPPER_OTP_START) {
-		addr = otp >> ADDR_LOWER_OTP_PERLOCK_SHIFT;
-		data = DATA_LOWER_OTP_PERLOCK_BIT <<
-		       ((otp & DATA_LOWER_OTP_PERLOCK_MASK) << 1U);
-	} else {
-		addr = (otp >> ADDR_UPPER_OTP_PERLOCK_SHIFT) + 2U;
-		data = DATA_UPPER_OTP_PERLOCK_BIT <<
-		       (otp & DATA_UPPER_OTP_PERLOCK_MASK);
-	}
-
-	bsec_lock();
-
-	/* Set value in write register */
-	mmio_write_32(bsec_base + BSEC_OTP_WRDATA_OFF, data);
-
-	/* Set BSEC_OTP_CTRL_OFF and set ADDR with the OTP value */
-	mmio_write_32(bsec_base + BSEC_OTP_CTRL_OFF,
-		      addr | BSEC_WRITE | BSEC_LOCK);
-
-	while ((bsec_get_status() & BSEC_MODE_BUSY_MASK) != 0U) {
-		;
-	}
-
-	if ((bsec_get_status() & BSEC_MODE_PROGFAIL_MASK) != 0U) {
-		result = BSEC_PROG_FAIL;
-	} else {
-		result = bsec_check_error(otp);
-	}
-
-	bsec_unlock();
-
-	if (power_up) {
-		if (bsec_power_safmem(false) != BSEC_OK) {
-			panic();
-		}
-	}
-
-	return result;
-}
-
-/*
- * bsec_write_debug_conf: write value in debug feature
- *	to enable/disable debug service.
- * val: value to write.
- * return value: BSEC_OK if no error.
- */
-uint32_t bsec_write_debug_conf(uint32_t val)
-{
-	uint32_t result = BSEC_ERROR;
-	uint32_t masked_val = val & BSEC_DEN_ALL_MSK;
-
-	bsec_lock();
-
-	mmio_write_32(bsec_base + BSEC_DEN_OFF, masked_val);
-
-	if ((mmio_read_32(bsec_base + BSEC_DEN_OFF) ^ masked_val) == 0U) {
-		result = BSEC_OK;
-	}
-
-	bsec_unlock();
-
-	return result;
-}
-
-/*
- * bsec_read_debug_conf: read debug configuration.
- */
-uint32_t bsec_read_debug_conf(void)
-{
-	return mmio_read_32(bsec_base + BSEC_DEN_OFF);
-}
-
-/*
- * bsec_get_status: return status register value.
- */
-uint32_t bsec_get_status(void)
-{
-	return mmio_read_32(bsec_base + BSEC_OTP_STATUS_OFF);
-}
-
-/*
- * bsec_get_hw_conf: return hardware configuration.
- */
-uint32_t bsec_get_hw_conf(void)
-{
-	return mmio_read_32(bsec_base + BSEC_IPHW_CFG_OFF);
-}
-
-/*
- * bsec_get_version: return BSEC version.
- */
-uint32_t bsec_get_version(void)
-{
-	return mmio_read_32(bsec_base + BSEC_IPVR_OFF);
-}
-
-/*
- * bsec_get_id: return BSEC ID.
- */
-uint32_t bsec_get_id(void)
-{
-	return mmio_read_32(bsec_base + BSEC_IP_ID_OFF);
-}
-
-/*
- * bsec_get_magic_id: return BSEC magic number.
- */
-uint32_t bsec_get_magic_id(void)
-{
-	return mmio_read_32(bsec_base + BSEC_IP_MAGIC_ID_OFF);
-}
-
-/*
- * bsec_write_sr_lock: write shadow-read lock.
- * otp: OTP number.
- * value: value to write in the register.
- *	Must be always 1.
- * return: true if OTP is locked, else false.
- */
-bool bsec_write_sr_lock(uint32_t otp, uint32_t value)
-{
-	bool result = false;
-	uint32_t bank = otp_bank_offset(otp);
-	uint32_t bank_value;
-	uint32_t otp_mask = BIT(otp & BSEC_OTP_MASK);
-
-	bsec_lock();
-
-	bank_value = mmio_read_32(bsec_base + BSEC_SRLOCK_OFF + bank);
-
-	if ((bank_value & otp_mask) == value) {
-		/*
-		 * In case of write don't need to write,
-		 * the lock is already set.
-		 */
-		if (value != 0U) {
-			result = true;
-		}
-	} else {
-		if (value != 0U) {
-			bank_value = bank_value | otp_mask;
-		} else {
-			bank_value = bank_value & ~otp_mask;
-		}
-
-		/*
-		 * We can write 0 in all other OTP
-		 * if the lock is activated in one of other OTP.
-		 * Write 0 has no effect.
-		 */
-		mmio_write_32(bsec_base + BSEC_SRLOCK_OFF + bank, bank_value);
-		result = true;
-	}
-
-	bsec_unlock();
-
-	return result;
-}
-
-/*
- * bsec_read_sr_lock: read shadow-read lock.
- * otp: OTP number.
- * return: true if otp is locked, else false.
- */
-bool bsec_read_sr_lock(uint32_t otp)
-{
-	uint32_t bank = otp_bank_offset(otp);
-	uint32_t otp_mask = BIT(otp & BSEC_OTP_MASK);
-	uint32_t bank_value = mmio_read_32(bsec_base + BSEC_SRLOCK_OFF + bank);
-
-	return (bank_value & otp_mask) != 0U;
-}
-
-/*
- * bsec_write_sw_lock: write shadow-write lock.
- * otp: OTP number.
- * value: Value to write in the register.
- *	Must be always 1.
- * return: true if OTP is locked, else false.
- */
-bool bsec_write_sw_lock(uint32_t otp, uint32_t value)
-{
-	bool result = false;
-	uint32_t bank = otp_bank_offset(otp);
-	uint32_t otp_mask = BIT(otp & BSEC_OTP_MASK);
-	uint32_t bank_value;
-
-	bsec_lock();
-
-	bank_value = mmio_read_32(bsec_base + BSEC_SWLOCK_OFF + bank);
-
-	if ((bank_value & otp_mask) == value) {
-		/*
-		 * In case of write don't need to write,
-		 * the lock is already set.
-		 */
-		if (value != 0U) {
-			result = true;
-		}
-	} else {
-		if (value != 0U) {
-			bank_value = bank_value | otp_mask;
-		} else {
-			bank_value = bank_value & ~otp_mask;
-		}
-
-		/*
-		 * We can write 0 in all other OTP
-		 * if the lock is activated in one of other OTP.
-		 * Write 0 has no effect.
-		 */
-		mmio_write_32(bsec_base + BSEC_SWLOCK_OFF + bank, bank_value);
-		result = true;
-	}
-
-	bsec_unlock();
-
-	return result;
-}
-
-/*
- * bsec_read_sw_lock: read shadow-write lock.
- * otp: OTP number.
- * return: true if OTP is locked, else false.
- */
-bool bsec_read_sw_lock(uint32_t otp)
-{
-	uint32_t bank = otp_bank_offset(otp);
-	uint32_t otp_mask = BIT(otp & BSEC_OTP_MASK);
-	uint32_t bank_value = mmio_read_32(bsec_base + BSEC_SWLOCK_OFF + bank);
-
-	return (bank_value & otp_mask) != 0U;
-}
-
-/*
- * bsec_write_sp_lock: write shadow-program lock.
- * otp: OTP number.
- * value: Value to write in the register.
- *	Must be always 1.
- * return: true if OTP is locked, else false.
- */
-bool bsec_write_sp_lock(uint32_t otp, uint32_t value)
-{
-	bool result = false;
-	uint32_t bank = otp_bank_offset(otp);
-	uint32_t bank_value;
-	uint32_t otp_mask = BIT(otp & BSEC_OTP_MASK);
-
-	bsec_lock();
-
-	bank_value = mmio_read_32(bsec_base + BSEC_SPLOCK_OFF + bank);
-
-	if ((bank_value & otp_mask) == value) {
-		/*
-		 * In case of write don't need to write,
-		 * the lock is already set.
-		 */
-		if (value != 0U) {
-			result = true;
-		}
-	} else {
-		if (value != 0U) {
-			bank_value = bank_value | otp_mask;
-		} else {
-			bank_value = bank_value & ~otp_mask;
-		}
-
-		/*
-		 * We can write 0 in all other OTP
-		 * if the lock is activated in one of other OTP.
-		 * Write 0 has no effect.
-		 */
-		mmio_write_32(bsec_base + BSEC_SPLOCK_OFF + bank, bank_value);
-		result = true;
-	}
-
-	bsec_unlock();
-
-	return result;
-}
-
-/*
- * bsec_read_sp_lock: read shadow-program lock.
- * otp: OTP number.
- * return: true if OTP is locked, else false.
- */
-bool bsec_read_sp_lock(uint32_t otp)
-{
-	uint32_t bank = otp_bank_offset(otp);
-	uint32_t otp_mask = BIT(otp & BSEC_OTP_MASK);
-	uint32_t bank_value = mmio_read_32(bsec_base + BSEC_SPLOCK_OFF + bank);
-
-	return (bank_value & otp_mask) != 0U;
-}
-
-/*
- * bsec_wr_lock: Read permanent lock status.
- * otp: OTP number.
- * return: true if OTP is locked, else false.
- */
-bool bsec_wr_lock(uint32_t otp)
-{
-	uint32_t bank = otp_bank_offset(otp);
-	uint32_t lock_bit = BIT(otp & BSEC_OTP_MASK);
-
-	if ((mmio_read_32(bsec_base + BSEC_WRLOCK_OFF + bank) &
-	     lock_bit) != 0U) {
-		/*
-		 * In case of write don't need to write,
-		 * the lock is already set.
-		 */
-		return true;
-	}
-
-	return false;
-}
-
-/*
- * bsec_otp_lock: Lock Upper OTP or Global programming or debug enable
- * service: Service to lock see header file.
- * value: Value to write must always set to 1 (only use for debug purpose).
- * return: BSEC_OK if succeed.
- */
-uint32_t bsec_otp_lock(uint32_t service, uint32_t value)
-{
-	uintptr_t reg = bsec_base + BSEC_OTP_LOCK_OFF;
-
-	switch (service) {
-	case BSEC_LOCK_UPPER_OTP:
-		mmio_write_32(reg, value << BSEC_LOCK_UPPER_OTP);
-		break;
-	case BSEC_LOCK_DEBUG:
-		mmio_write_32(reg, value << BSEC_LOCK_DEBUG);
-		break;
-	case BSEC_LOCK_PROGRAM:
-		mmio_write_32(reg, value << BSEC_LOCK_PROGRAM);
-		break;
-	default:
-		return BSEC_INVALID_PARAM;
-	}
-
-	return BSEC_OK;
-}
-
-/*
- * bsec_power_safmem: Activate or deactivate SAFMEM power.
- * power: true to power up, false to power down.
- * return: BSEC_OK if succeed.
- */
-static uint32_t bsec_power_safmem(bool power)
-{
-	uint32_t register_val;
-	uint32_t timeout = BSEC_TIMEOUT_VALUE;
-
-	bsec_lock();
-
-	register_val = mmio_read_32(bsec_base + BSEC_OTP_CONF_OFF);
-
-	if (power) {
-		register_val |= BSEC_CONF_POWER_UP_MASK;
-	} else {
-		register_val &= ~BSEC_CONF_POWER_UP_MASK;
-	}
-
-	mmio_write_32(bsec_base + BSEC_OTP_CONF_OFF, register_val);
-
-	/* Waiting loop */
-	if (power) {
-		while (((bsec_get_status() & BSEC_MODE_PWR_MASK) == 0U) &&
-		       (timeout != 0U)) {
-			timeout--;
-		}
-	} else {
-		while (((bsec_get_status() & BSEC_MODE_PWR_MASK) != 0U) &&
-		       (timeout != 0U)) {
-			timeout--;
-		}
-	}
-
-	bsec_unlock();
-
-	if (timeout == 0U) {
-		return BSEC_TIMEOUT;
-	}
-
-	return BSEC_OK;
-}
-
-/*
- * bsec_shadow_read_otp: Load OTP from SAFMEM and provide its value
- * otp_value: read value.
- * word: OTP number.
- * return value: BSEC_OK if no error.
- */
-uint32_t bsec_shadow_read_otp(uint32_t *otp_value, uint32_t word)
-{
-	uint32_t result;
-
-	result = bsec_shadow_register(word);
-	if (result != BSEC_OK) {
-		ERROR("BSEC: %u Shadowing Error %i\n", word, result);
-		return result;
-	}
-
-	result = bsec_read_otp(otp_value, word);
-	if (result != BSEC_OK) {
-		ERROR("BSEC: %u Read Error %i\n", word, result);
-	}
-
-	return result;
-}
-
-/*
- * bsec_check_nsec_access_rights: check non-secure access rights to target OTP.
- * otp: OTP number.
- * return: BSEC_OK if authorized access.
- */
-uint32_t bsec_check_nsec_access_rights(uint32_t otp)
-{
-#if defined(IMAGE_BL32)
-	if (otp > STM32MP1_OTP_MAX_ID) {
-		return BSEC_INVALID_PARAM;
-	}
-
-	if (otp >= STM32MP1_UPPER_OTP_START) {
-		/* Check if BSEC is in OTP-SECURED closed_device state. */
-		if (stm32mp_is_closed_device()) {
-			if (!non_secure_can_access(otp)) {
-				return BSEC_ERROR;
-			}
-		}
-	}
-#endif
-
-	return BSEC_OK;
-}
-
diff --git a/drivers/st/bsec/bsec2.c b/drivers/st/bsec/bsec2.c
new file mode 100644
index 000000000..097cdfe11
--- /dev/null
+++ b/drivers/st/bsec/bsec2.c
@@ -0,0 +1,934 @@
+/*
+ * Copyright (c) 2017-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <limits.h>
+
+#include <libfdt.h>
+
+#include <platform_def.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/st/bsec.h>
+#include <drivers/st/bsec2_reg.h>
+#include <lib/mmio.h>
+#include <lib/spinlock.h>
+
+#define BSEC_IP_VERSION_1_1	U(0x11)
+#define BSEC_IP_VERSION_2_0	U(0x20)
+#define BSEC_IP_ID_2		U(0x100032)
+
+/*
+ * IP configuration
+ */
+#define BSEC_OTP_MASK			GENMASK(4, 0)
+#define BSEC_OTP_BANK_SHIFT		5
+#define BSEC_TIMEOUT_VALUE		U(0xFFFF)
+
+#define OTP_ACCESS_SIZE (round_up(OTP_MAX_SIZE, __WORD_BIT) / __WORD_BIT)
+
+static uint32_t otp_nsec_access[OTP_ACCESS_SIZE] __unused;
+
+static uint32_t bsec_shadow_register(uint32_t otp);
+static uint32_t bsec_power_safmem(bool power);
+static uint32_t bsec_get_version(void);
+static uint32_t bsec_get_id(void);
+static uint32_t bsec_get_status(void);
+static uint32_t bsec_read_permanent_lock(uint32_t otp, bool *value);
+
+/* BSEC access protection */
+static spinlock_t bsec_spinlock;
+
+static void bsec_lock(void)
+{
+	if (stm32mp_lock_available()) {
+		spin_lock(&bsec_spinlock);
+	}
+}
+
+static void bsec_unlock(void)
+{
+	if (stm32mp_lock_available()) {
+		spin_unlock(&bsec_spinlock);
+	}
+}
+
+static bool is_otp_invalid_mode(void)
+{
+	bool ret = ((bsec_get_status() & BSEC_OTP_STATUS_INVALID) == BSEC_OTP_STATUS_INVALID);
+
+	if (ret) {
+		ERROR("OTP mode is OTP-INVALID\n");
+	}
+
+	return ret;
+}
+
+#if defined(IMAGE_BL32)
+static int bsec_get_dt_node(struct dt_node_info *info)
+{
+	int node;
+
+	node = dt_get_node(info, -1, DT_BSEC_COMPAT);
+	if (node < 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	return node;
+}
+
+static void enable_non_secure_access(uint32_t otp)
+{
+	otp_nsec_access[otp / __WORD_BIT] |= BIT(otp % __WORD_BIT);
+
+	if (bsec_shadow_register(otp) != BSEC_OK) {
+		panic();
+	}
+}
+
+static bool non_secure_can_access(uint32_t otp)
+{
+	return (otp_nsec_access[otp / __WORD_BIT] &
+		BIT(otp % __WORD_BIT)) != 0;
+}
+
+static int bsec_dt_otp_nsec_access(void *fdt, int bsec_node)
+{
+	int bsec_subnode;
+
+	fdt_for_each_subnode(bsec_subnode, fdt, bsec_node) {
+		const fdt32_t *cuint;
+		uint32_t otp;
+		uint32_t i;
+		uint32_t size;
+		uint32_t offset;
+		uint32_t length;
+
+		cuint = fdt_getprop(fdt, bsec_subnode, "reg", NULL);
+		if (cuint == NULL) {
+			panic();
+		}
+
+		offset = fdt32_to_cpu(*cuint);
+		cuint++;
+		length = fdt32_to_cpu(*cuint);
+
+		otp = offset / sizeof(uint32_t);
+
+		if (otp < STM32MP1_UPPER_OTP_START) {
+			unsigned int otp_end = round_up(offset + length,
+						       sizeof(uint32_t)) /
+					       sizeof(uint32_t);
+
+			if (otp_end > STM32MP1_UPPER_OTP_START) {
+				/*
+				 * OTP crosses Lower/Upper boundary, consider
+				 * only the upper part.
+				 */
+				otp = STM32MP1_UPPER_OTP_START;
+				length -= (STM32MP1_UPPER_OTP_START *
+					   sizeof(uint32_t)) - offset;
+				offset = STM32MP1_UPPER_OTP_START *
+					 sizeof(uint32_t);
+
+				WARN("OTP crosses Lower/Upper boundary\n");
+			} else {
+				continue;
+			}
+		}
+
+		if ((fdt_getprop(fdt, bsec_subnode,
+				 "st,non-secure-otp", NULL)) == NULL) {
+			continue;
+		}
+
+		if (((offset % sizeof(uint32_t)) != 0) ||
+		    ((length % sizeof(uint32_t)) != 0)) {
+			ERROR("Unaligned non-secure OTP\n");
+			panic();
+		}
+
+		size = length / sizeof(uint32_t);
+
+		for (i = otp; i < (otp + size); i++) {
+			enable_non_secure_access(i);
+		}
+	}
+
+	return 0;
+}
+
+static void bsec_late_init(void)
+{
+	void *fdt;
+	int node;
+	struct dt_node_info bsec_info;
+
+	if (fdt_get_address(&fdt) == 0) {
+		panic();
+	}
+
+	node = bsec_get_dt_node(&bsec_info);
+	if (node < 0) {
+		panic();
+	}
+
+	assert(bsec_info.base == BSEC_BASE);
+
+	bsec_dt_otp_nsec_access(fdt, node);
+}
+#endif
+
+static uint32_t otp_bank_offset(uint32_t otp)
+{
+	assert(otp <= STM32MP1_OTP_MAX_ID);
+
+	return ((otp & ~BSEC_OTP_MASK) >> BSEC_OTP_BANK_SHIFT) *
+	       sizeof(uint32_t);
+}
+
+static uint32_t otp_bit_mask(uint32_t otp)
+{
+	return BIT(otp & BSEC_OTP_MASK);
+}
+
+/*
+ * bsec_check_error: check BSEC error status.
+ * otp: OTP number.
+ * check_disturbed: check only error (false),
+ *	or error and disturbed status (true).
+ * return value: BSEC_OK if no error.
+ */
+static uint32_t bsec_check_error(uint32_t otp, bool check_disturbed)
+{
+	uint32_t bit = otp_bit_mask(otp);
+	uint32_t bank = otp_bank_offset(otp);
+
+	if ((mmio_read_32(BSEC_BASE + BSEC_ERROR_OFF + bank) & bit) != 0U) {
+		return BSEC_ERROR;
+	}
+
+	if (!check_disturbed) {
+		return BSEC_OK;
+	}
+
+	if ((mmio_read_32(BSEC_BASE + BSEC_DISTURBED_OFF + bank) & bit) != 0U) {
+		return BSEC_DISTURBED;
+	}
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_get_otp_by_phandle: return OTP id and OTP size for a given phandle
+ * fdt: device tree
+ * phandle: phandle to be found
+ * otp_id: return value for the OTP id found
+ * otp_len: return value for the OTP len
+ * return: BSEC_OK if OTP found, < 0 otherwise
+ */
+int bsec_get_otp_by_phandle(const void *fdt, const uint32_t phandle,
+			    uint32_t *otp_id, uint32_t *otp_len)
+{
+	int node;
+	int child;
+	const int *cuint;
+	uint32_t offset;
+	bool otp_found = false;
+
+	if (fdt == NULL) {
+		panic();
+	}
+
+	node = fdt_node_offset_by_compatible(fdt, -1, DT_BSEC_COMPAT);
+	if (node < 0) {
+		return BSEC_ERROR;
+	}
+
+	fdt_for_each_subnode(child, fdt, node) {
+		uint32_t ph = fdt_get_phandle(fdt, child);
+
+		if (ph == phandle) {
+			otp_found = true;
+			break;
+		}
+	}
+
+	if (!otp_found) {
+		return BSEC_ERROR;
+	}
+
+	cuint = fdt_getprop(fdt, child, "reg", NULL);
+	if (cuint == NULL) {
+		panic();
+	}
+
+	offset = fdt32_to_cpu(*cuint);
+	cuint++;
+	*otp_len = fdt32_to_cpu(*cuint);
+
+	*otp_id = offset / sizeof(uint32_t);
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_probe: initialize BSEC driver.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_probe(void)
+{
+	if (is_otp_invalid_mode()) {
+		return BSEC_ERROR;
+	}
+
+	if (((bsec_get_version() != BSEC_IP_VERSION_1_1) &&
+	     (bsec_get_version() != BSEC_IP_VERSION_2_0)) ||
+	    (bsec_get_id() != BSEC_IP_ID_2)) {
+		panic();
+	}
+
+#if defined(IMAGE_BL32)
+	bsec_late_init();
+#endif
+	return BSEC_OK;
+}
+
+/*
+ * bsec_shadow_register: copy SAFMEM OTP to BSEC data.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+static uint32_t bsec_shadow_register(uint32_t otp)
+{
+	uint32_t result;
+	bool value;
+	bool power_up = false;
+
+	if (is_otp_invalid_mode()) {
+		return BSEC_ERROR;
+	}
+
+	result = bsec_read_sr_lock(otp, &value);
+	if (result != BSEC_OK) {
+		ERROR("BSEC: %u Sticky-read bit read Error %i\n", otp, result);
+		return result;
+	}
+
+	if (value) {
+		VERBOSE("BSEC: OTP %u is locked and will not be refreshed\n",
+			otp);
+	}
+
+	if ((bsec_get_status() & BSEC_OTP_STATUS_PWRON) == 0U) {
+		result = bsec_power_safmem(true);
+
+		if (result != BSEC_OK) {
+			return result;
+		}
+
+		power_up = true;
+	}
+
+	bsec_lock();
+
+	mmio_write_32(BSEC_BASE + BSEC_OTP_CTRL_OFF, otp | BSEC_READ);
+
+	while ((bsec_get_status() & BSEC_OTP_STATUS_BUSY) != 0U) {
+		;
+	}
+
+	result = bsec_check_error(otp, true);
+
+	bsec_unlock();
+
+	if (power_up) {
+		if (bsec_power_safmem(false) != BSEC_OK) {
+			panic();
+		}
+	}
+
+	return result;
+}
+
+/*
+ * bsec_read_otp: read an OTP data value.
+ * val: read value.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_read_otp(uint32_t *val, uint32_t otp)
+{
+	if (is_otp_invalid_mode()) {
+		return BSEC_ERROR;
+	}
+
+	if (otp > STM32MP1_OTP_MAX_ID) {
+		return BSEC_INVALID_PARAM;
+	}
+
+	*val = mmio_read_32(BSEC_BASE + BSEC_OTP_DATA_OFF +
+			    (otp * sizeof(uint32_t)));
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_write_otp: write value in BSEC data register.
+ * val: value to write.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_write_otp(uint32_t val, uint32_t otp)
+{
+	uint32_t result;
+	bool value;
+
+	if (is_otp_invalid_mode()) {
+		return BSEC_ERROR;
+	}
+
+	result = bsec_read_sw_lock(otp, &value);
+	if (result != BSEC_OK) {
+		ERROR("BSEC: %u Sticky-write bit read Error %i\n", otp, result);
+		return result;
+	}
+
+	if (value) {
+		VERBOSE("BSEC: OTP %u is locked and write will be ignored\n",
+			otp);
+	}
+
+	/* Ensure integrity of each register access sequence */
+	bsec_lock();
+
+	mmio_write_32(BSEC_BASE + BSEC_OTP_DATA_OFF +
+		      (otp * sizeof(uint32_t)), val);
+
+	bsec_unlock();
+
+	return result;
+}
+
+/*
+ * bsec_program_otp: program a bit in SAFMEM after the prog.
+ *	The OTP data is not refreshed.
+ * val: value to program.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_program_otp(uint32_t val, uint32_t otp)
+{
+	uint32_t result;
+	bool power_up = false;
+	bool sp_lock, perm_lock;
+
+	if (is_otp_invalid_mode()) {
+		return BSEC_ERROR;
+	}
+
+	result = bsec_read_sp_lock(otp, &sp_lock);
+	if (result != BSEC_OK) {
+		ERROR("BSEC: %u Sticky-prog bit read Error %i\n", otp, result);
+		return result;
+	}
+
+	result = bsec_read_permanent_lock(otp, &perm_lock);
+	if (result != BSEC_OK) {
+		ERROR("BSEC: %u permanent bit read Error %i\n", otp, result);
+		return result;
+	}
+
+	if (sp_lock || perm_lock) {
+		WARN("BSEC: OTP locked, prog will be ignored\n");
+		return BSEC_PROG_FAIL;
+	}
+
+	if ((mmio_read_32(BSEC_BASE + BSEC_OTP_LOCK_OFF) & GPLOCK_LOCK_MASK) != 0U) {
+		WARN("BSEC: GPLOCK activated, prog will be ignored\n");
+	}
+
+	if ((bsec_get_status() & BSEC_OTP_STATUS_PWRON) == 0U) {
+		result = bsec_power_safmem(true);
+
+		if (result != BSEC_OK) {
+			return result;
+		}
+
+		power_up = true;
+	}
+
+	bsec_lock();
+
+	mmio_write_32(BSEC_BASE + BSEC_OTP_WRDATA_OFF, val);
+
+	mmio_write_32(BSEC_BASE + BSEC_OTP_CTRL_OFF, otp | BSEC_WRITE);
+
+	while ((bsec_get_status() & BSEC_OTP_STATUS_BUSY) != 0U) {
+		;
+	}
+
+	if ((bsec_get_status() & BSEC_OTP_STATUS_PROGFAIL) != 0U) {
+		result = BSEC_PROG_FAIL;
+	} else {
+		result = bsec_check_error(otp, true);
+	}
+
+	bsec_unlock();
+
+	if (power_up) {
+		if (bsec_power_safmem(false) != BSEC_OK) {
+			panic();
+		}
+	}
+
+	return result;
+}
+
+/*
+ * bsec_permanent_lock_otp: permanent lock of OTP in SAFMEM.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+#if defined(IMAGE_BL32) || defined(STM32MP_SSP)
+uint32_t bsec_permanent_lock_otp(uint32_t otp)
+{
+	uint32_t result;
+	bool power_up = false;
+	uint32_t data;
+	uint32_t addr;
+
+	if (is_otp_invalid_mode()) {
+		return BSEC_ERROR;
+	}
+
+	if (otp > STM32MP1_OTP_MAX_ID) {
+		return BSEC_INVALID_PARAM;
+	}
+
+	if ((bsec_get_status() & BSEC_OTP_STATUS_PWRON) == 0U) {
+		result = bsec_power_safmem(true);
+
+		if (result != BSEC_OK) {
+			return result;
+		}
+
+		power_up = true;
+	}
+
+	if (otp < STM32MP1_UPPER_OTP_START) {
+		addr = otp >> ADDR_LOWER_OTP_PERLOCK_SHIFT;
+		data = DATA_LOWER_OTP_PERLOCK_BIT <<
+		       ((otp & DATA_LOWER_OTP_PERLOCK_MASK) << 1U);
+	} else {
+		addr = (otp >> ADDR_UPPER_OTP_PERLOCK_SHIFT) + 2U;
+		data = DATA_UPPER_OTP_PERLOCK_BIT <<
+		       (otp & DATA_UPPER_OTP_PERLOCK_MASK);
+	}
+
+	bsec_lock();
+
+	mmio_write_32(BSEC_BASE + BSEC_OTP_WRDATA_OFF, data);
+
+	mmio_write_32(BSEC_BASE + BSEC_OTP_CTRL_OFF,
+		      addr | BSEC_WRITE | BSEC_LOCK);
+
+	while ((bsec_get_status() & BSEC_OTP_STATUS_BUSY) != 0U) {
+		;
+	}
+
+	if ((bsec_get_status() & BSEC_OTP_STATUS_PROGFAIL) != 0U) {
+		result = BSEC_PROG_FAIL;
+	} else {
+		result = bsec_check_error(otp, false);
+	}
+
+	bsec_unlock();
+
+	if (power_up) {
+		if (bsec_power_safmem(false) != BSEC_OK) {
+			panic();
+		}
+	}
+
+	return result;
+}
+#endif
+
+/*
+ * bsec_read_debug_conf: return debug configuration register value.
+ */
+uint32_t bsec_read_debug_conf(void)
+{
+	return mmio_read_32(BSEC_BASE + BSEC_DEN_OFF);
+}
+
+/*
+ * bsec_write_scratch: write value in scratch register.
+ * val: value to write.
+ * return value: none.
+ */
+void bsec_write_scratch(uint32_t val)
+{
+#if defined(IMAGE_BL32)
+	if (is_otp_invalid_mode()) {
+		return;
+	}
+
+	bsec_lock();
+	mmio_write_32(BSEC_BASE + BSEC_SCRATCH_OFF, val);
+	bsec_unlock();
+#else
+	mmio_write_32(BSEC_BASE + BSEC_SCRATCH_OFF, val);
+#endif
+}
+
+/*
+ * bsec_get_status: return status register value.
+ */
+static uint32_t bsec_get_status(void)
+{
+	return mmio_read_32(BSEC_BASE + BSEC_OTP_STATUS_OFF);
+}
+
+/*
+ * bsec_get_hw_conf: return hardware configuration register value.
+ */
+uint32_t bsec_get_hw_conf(void)
+{
+	return mmio_read_32(BSEC_BASE + BSEC_IPHW_CFG_OFF);
+}
+
+/*
+ * bsec_get_version: return BSEC version register value.
+ */
+static uint32_t bsec_get_version(void)
+{
+	return mmio_read_32(BSEC_BASE + BSEC_IPVR_OFF) & BSEC_IPVR_MSK;
+}
+
+/*
+ * bsec_get_id: return BSEC ID register value.
+ */
+static uint32_t bsec_get_id(void)
+{
+	return mmio_read_32(BSEC_BASE + BSEC_IP_ID_OFF);
+}
+
+/*
+ * bsec_get_magic_id: return BSEC magic number register value.
+ */
+uint32_t bsec_get_magic_id(void)
+{
+	return mmio_read_32(BSEC_BASE + BSEC_IP_MAGIC_ID_OFF);
+}
+
+/*
+ * bsec_set_sr_lock: set shadow-read lock.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_set_sr_lock(uint32_t otp)
+{
+	uint32_t bank = otp_bank_offset(otp);
+	uint32_t otp_mask = otp_bit_mask(otp);
+
+	if (is_otp_invalid_mode()) {
+		return BSEC_ERROR;
+	}
+
+	if (otp > STM32MP1_OTP_MAX_ID) {
+		return BSEC_INVALID_PARAM;
+	}
+
+	bsec_lock();
+	mmio_write_32(BSEC_BASE + BSEC_SRLOCK_OFF + bank, otp_mask);
+	bsec_unlock();
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_read_sr_lock: read shadow-read lock.
+ * otp: OTP number.
+ * value: read value (true or false).
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_read_sr_lock(uint32_t otp, bool *value)
+{
+	uint32_t bank = otp_bank_offset(otp);
+	uint32_t otp_mask = otp_bit_mask(otp);
+	uint32_t bank_value;
+
+	if (otp > STM32MP1_OTP_MAX_ID) {
+		return BSEC_INVALID_PARAM;
+	}
+
+	bank_value = mmio_read_32(BSEC_BASE + BSEC_SRLOCK_OFF + bank);
+
+	*value = ((bank_value & otp_mask) != 0U);
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_set_sw_lock: set shadow-write lock.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_set_sw_lock(uint32_t otp)
+{
+	uint32_t bank = otp_bank_offset(otp);
+	uint32_t otp_mask = otp_bit_mask(otp);
+
+	if (is_otp_invalid_mode()) {
+		return BSEC_ERROR;
+	}
+
+	if (otp > STM32MP1_OTP_MAX_ID) {
+		return BSEC_INVALID_PARAM;
+	}
+
+	bsec_lock();
+	mmio_write_32(BSEC_BASE + BSEC_SWLOCK_OFF + bank, otp_mask);
+	bsec_unlock();
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_read_sw_lock: read shadow-write lock.
+ * otp: OTP number.
+ * value: read value (true or false).
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_read_sw_lock(uint32_t otp, bool *value)
+{
+	uint32_t bank = otp_bank_offset(otp);
+	uint32_t otp_mask = BIT(otp & BSEC_OTP_MASK);
+	uint32_t bank_value;
+
+	if (otp > STM32MP1_OTP_MAX_ID) {
+		return BSEC_INVALID_PARAM;
+	}
+
+	bank_value = mmio_read_32(BSEC_BASE + BSEC_SWLOCK_OFF + bank);
+
+	*value = ((bank_value & otp_mask) != 0U);
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_set_sp_lock: set shadow-program lock.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_set_sp_lock(uint32_t otp)
+{
+	uint32_t bank = otp_bank_offset(otp);
+	uint32_t otp_mask = otp_bit_mask(otp);
+
+	if (is_otp_invalid_mode()) {
+		return BSEC_ERROR;
+	}
+
+	if (otp > STM32MP1_OTP_MAX_ID) {
+		return BSEC_INVALID_PARAM;
+	}
+
+	bsec_lock();
+	mmio_write_32(BSEC_BASE + BSEC_SPLOCK_OFF + bank, otp_mask);
+	bsec_unlock();
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_read_sp_lock: read shadow-program lock.
+ * otp: OTP number.
+ * value: read value (true or false).
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_read_sp_lock(uint32_t otp, bool *value)
+{
+	uint32_t bank = otp_bank_offset(otp);
+	uint32_t otp_mask = BIT(otp & BSEC_OTP_MASK);
+	uint32_t bank_value;
+
+	if (otp > STM32MP1_OTP_MAX_ID) {
+		return BSEC_INVALID_PARAM;
+	}
+
+	bank_value = mmio_read_32(BSEC_BASE + BSEC_SPLOCK_OFF + bank);
+
+	*value = ((bank_value & otp_mask) != 0U);
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_read_permanent_lock: Read permanent lock status.
+ * otp: OTP number.
+ * value: read value (true or false).
+ * return value: BSEC_OK if no error.
+ */
+static uint32_t bsec_read_permanent_lock(uint32_t otp, bool *value)
+{
+	uint32_t bank = otp_bank_offset(otp);
+	uint32_t otp_mask = otp_bit_mask(otp);
+	uint32_t bank_value;
+
+	if (otp > STM32MP1_OTP_MAX_ID) {
+		return BSEC_INVALID_PARAM;
+	}
+
+	bank_value = mmio_read_32(BSEC_BASE + BSEC_WRLOCK_OFF + bank);
+
+	*value = ((bank_value & otp_mask) != 0U);
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_power_safmem: Activate or deactivate SAFMEM power.
+ * power: true to power up, false to power down.
+ * return value: BSEC_OK if no error.
+ */
+static uint32_t bsec_power_safmem(bool power)
+{
+	uint32_t register_val;
+	uint32_t timeout = BSEC_TIMEOUT_VALUE;
+
+	bsec_lock();
+
+	register_val = mmio_read_32(BSEC_BASE + BSEC_OTP_CONF_OFF);
+
+	if (power) {
+		register_val |= BSEC_CONF_POWER_UP_MASK;
+	} else {
+		register_val &= ~BSEC_CONF_POWER_UP_MASK;
+	}
+
+	mmio_write_32(BSEC_BASE + BSEC_OTP_CONF_OFF, register_val);
+
+	if (power) {
+		while (((bsec_get_status() & BSEC_OTP_STATUS_PWRON) == 0U) &&
+		       (timeout != 0U)) {
+			timeout--;
+		}
+	} else {
+		while (((bsec_get_status() & BSEC_OTP_STATUS_PWRON) != 0U) &&
+		       (timeout != 0U)) {
+			timeout--;
+		}
+	}
+
+	bsec_unlock();
+
+	if (timeout == 0U) {
+		return BSEC_TIMEOUT;
+	}
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_shadow_read_otp: Load OTP from SAFMEM and provide its value.
+ * otp_value: read value.
+ * word: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_shadow_read_otp(uint32_t *otp_value, uint32_t word)
+{
+	uint32_t result;
+
+	result = bsec_shadow_register(word);
+	if (result != BSEC_OK) {
+		ERROR("BSEC: %u Shadowing Error %u\n", word, result);
+		return result;
+	}
+
+	result = bsec_read_otp(otp_value, word);
+	if (result != BSEC_OK) {
+		ERROR("BSEC: %u Read Error %u\n", word, result);
+	}
+
+	return result;
+}
+
+#if defined(IMAGE_BL32)
+/*
+ * bsec_check_nsec_access_rights: check non-secure access rights to target OTP.
+ * otp: OTP number.
+ * return value: BSEC_OK if authorized access.
+ */
+uint32_t bsec_check_nsec_access_rights(uint32_t otp)
+{
+	if (otp > STM32MP1_OTP_MAX_ID) {
+		return BSEC_INVALID_PARAM;
+	}
+
+	if (otp >= STM32MP1_UPPER_OTP_START) {
+		if (!non_secure_can_access(otp)) {
+			return BSEC_ERROR;
+		}
+	}
+
+	return BSEC_OK;
+}
+#endif
+
+uint32_t bsec_get_secure_state(void)
+{
+	uint32_t status = bsec_get_status();
+	uint32_t result = BSEC_STATE_INVALID;
+	uint32_t otp_enc_id __unused;
+	uint32_t otp_bit_len __unused;
+	int res __unused;
+
+	if ((status & BSEC_OTP_STATUS_INVALID) != 0U) {
+		result = BSEC_STATE_INVALID;
+	} else {
+		if ((status & BSEC_OTP_STATUS_SECURE) != 0U) {
+			if (stm32mp_is_closed_device()) {
+				result = BSEC_STATE_SEC_CLOSED;
+			} else {
+				result = BSEC_STATE_SEC_OPEN;
+			}
+		} else {
+			/* OTP modes OPEN1 and OPEN2 are not supported */
+			result = BSEC_STATE_INVALID;
+		}
+	}
+
+#if STM32MP13
+	res = stm32_get_otp_index("oem_enc_key", &otp_enc_id, &otp_bit_len);
+	if ((res == 0) && (otp_bit_len > 0)) {
+		uint32_t start = otp_enc_id / sizeof(uint32_t);
+		size_t otp_nb = round_up(otp_bit_len, sizeof(uint32_t)) /
+				sizeof(uint32_t);
+		size_t otp_locked_nb = 0U;
+		uint32_t idx;
+
+		for (idx = start; idx < start + otp_nb; idx++) {
+			bool locked = false;
+
+			res = bsec_read_sp_lock(idx, &locked);
+			if ((res != 0U) || (locked == 0U)) {
+				break;
+			}
+			otp_locked_nb++;
+		}
+		if (otp_locked_nb == otp_nb) {
+			result |= BSEC_HARDWARE_KEY;
+		}
+	}
+#endif
+
+	return result;
+}
diff --git a/drivers/st/bsec/bsec3.c b/drivers/st/bsec/bsec3.c
new file mode 100644
index 000000000..b2250b8e5
--- /dev/null
+++ b/drivers/st/bsec/bsec3.c
@@ -0,0 +1,597 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <limits.h>
+
+#include <libfdt.h>
+
+#include <platform_def.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/st/bsec.h>
+#include <drivers/st/bsec3_reg.h>
+#include <drivers/st/stm32mp_reset.h>
+#include <lib/mmio.h>
+#include <lib/spinlock.h>
+
+#define BSEC_IP_VERSION_1_0	U(0x10)
+#define BSEC_IP_ID_3		U(0x100033)
+
+#define MAX_NB_TRIES		3U
+
+#define BSEC_DENR_KEY		0xDEB60000
+
+/*
+ * IP configuration
+ */
+#define BSEC_OTP_MASK			GENMASK(4, 0)
+#define BSEC_OTP_BANK_SHIFT		5
+#define BSEC_TIMEOUT_VALUE		0xFFFFFFFFU
+
+/* Magic use to indicated valid SHADOW = 'B' 'S' 'E' 'C' */
+#define BSEC_MAGIC			0x42534543U
+
+#define OTP_MAX_SIZE			(STM32MP2_OTP_MAX_ID + 1U)
+
+struct bsec_shadow {
+	uint32_t magic;
+	uint32_t state;
+	uint32_t value[OTP_MAX_SIZE];
+	uint32_t status[OTP_MAX_SIZE];
+};
+
+static uint32_t otp_bank(uint32_t otp)
+{
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	return (otp & ~BSEC_OTP_MASK) >> BSEC_OTP_BANK_SHIFT;
+}
+
+static uint32_t otp_bit_mask(uint32_t otp)
+{
+	return BIT(otp & BSEC_OTP_MASK);
+}
+
+/*
+ * bsec_get_status: return status register value.
+ */
+static uint32_t bsec_get_status(void)
+{
+	return mmio_read_32(BSEC_BASE + BSEC_OTPSR);
+}
+
+/*
+ * bsec_get_version: return BSEC version.
+ */
+static uint32_t bsec_get_version(void)
+{
+	return mmio_read_32(BSEC_BASE + BSEC_VERR) & BSEC_VERR_MASK;
+}
+
+/*
+ * bsec_get_id: return BSEC ID.
+ */
+static uint32_t bsec_get_id(void)
+{
+	return mmio_read_32(BSEC_BASE + BSEC_IPIDR);
+}
+
+static bool is_fuse_shadowed(uint32_t otp)
+{
+	uint32_t bank = otp_bank(otp);
+	uint32_t otp_mask = otp_bit_mask(otp);
+	uint32_t bank_value;
+
+	bank_value = mmio_read_32(BSEC_BASE + BSEC_SFSR(bank));
+
+	if ((bank_value & otp_mask) != 0U) {
+		return true;
+	}
+
+	return false;
+}
+
+static void poll_otp_status_busy(void)
+{
+	int32_t timeout = BSEC_TIMEOUT_VALUE;
+
+	while (((bsec_get_status() & BSEC_OTPSR_BUSY) != 0U) && (timeout != 0U)) {
+		timeout--;
+	}
+
+	if ((bsec_get_status() & BSEC_OTPSR_BUSY) != 0U) {
+		ERROR("BSEC timeout\n");
+		panic();
+	}
+}
+
+static uint32_t check_read_error(uint32_t otp)
+{
+	uint32_t status = bsec_get_status();
+
+	if ((status & BSEC_OTPSR_SECF) != 0U) {
+		VERBOSE("BSEC read %u single error correction detected\n", otp);
+	}
+
+	if ((status & BSEC_OTPSR_PPLF) != 0U) {
+		VERBOSE("BSEC read %u permanent programming lock detected.\n", otp);
+	}
+
+	if ((status & BSEC_OTPSR_PPLMF) != 0U) {
+		ERROR("BSEC read %u error 0x%x\n", otp, status);
+		return BSEC_ERROR;
+	}
+
+	if ((status & (BSEC_OTPSR_DISTURBF | BSEC_OTPSR_DEDF | BSEC_OTPSR_AMEF)) != 0U) {
+		ERROR("BSEC read %u error 0x%x with invalid FVR\n", otp, status);
+		return BSEC_RETRY;
+	}
+
+	return BSEC_OK;
+}
+
+static uint32_t check_program_error(uint32_t otp)
+{
+	uint32_t status = bsec_get_status();
+
+	if ((status & BSEC_OTPSR_PROGFAIL) != 0U) {
+		ERROR("BSEC program %u error 0x%x\n", otp, status);
+		return BSEC_RETRY;
+	}
+
+	return BSEC_OK;
+}
+
+static void check_reset_error(void)
+{
+	uint32_t status = bsec_get_status();
+
+	/* check initial status reporting */
+	if ((status & BSEC_OTPSR_BUSY) != 0U) {
+		VERBOSE("BSEC reset and busy when OTPSR read\n");
+	}
+	if ((status & BSEC_OTPSR_HIDEUP) != 0U) {
+		VERBOSE("BSEC upper fuse are not accessible (HIDEUP)\n");
+	}
+	if ((status & BSEC_OTPSR_OTPSEC) != 0U) {
+		VERBOSE("BSEC reset single error correction detected\n");
+	}
+	if ((status & BSEC_OTPSR_OTPNVIR) == 0U) {
+		VERBOSE("BSEC reset first fuse word 0 is detected zero\n");
+	}
+	if ((status & BSEC_OTPSR_OTPERR) != 0U) {
+		ERROR("BSEC reset critical error 0x%x\n", status);
+		panic();
+	}
+	if ((status & BSEC_OTPSR_FUSEOK) != BSEC_OTPSR_FUSEOK) {
+		ERROR("BSEC reset critical error 0x%x\n", status);
+		panic();
+	}
+}
+
+static bool is_bsec_write_locked(void)
+{
+	return (mmio_read_32(BSEC_BASE + BSEC_LOCKR) & BSEC_LOCKR_GWLOCK_MASK) != 0U;
+}
+
+/*
+ * bsec_get_otp_by_phandle: return OTP id and OTP size for a given phandle
+ * fdt: device tree
+ * phandle: phandle to be found
+ * otp_id: return value for the OTP id found
+ * otp_len: return value for the OTP len
+ * return: BSEC_OK if OTP found, < 0 otherwise
+ */
+int bsec_get_otp_by_phandle(const void *fdt, const uint32_t phandle,
+			    uint32_t *otp_id, uint32_t *otp_len)
+{
+	int node;
+	int child;
+	const int *cuint;
+	uint32_t offset;
+	bool otp_found = false;
+
+	if (fdt == NULL) {
+		panic();
+	}
+
+	node = fdt_node_offset_by_compatible(fdt, -1, DT_BSEC_COMPAT);
+	if (node < 0) {
+		return BSEC_ERROR;
+	}
+
+	fdt_for_each_subnode(child, fdt, node) {
+		uint32_t ph = fdt_get_phandle(fdt, child);
+
+		if (ph == phandle) {
+			otp_found = true;
+			break;
+		}
+	}
+
+	if (!otp_found) {
+		return BSEC_ERROR;
+	}
+
+	cuint = fdt_getprop(fdt, child, "reg", NULL);
+	if (cuint == NULL) {
+		panic();
+	}
+
+	offset = fdt32_to_cpu(*cuint);
+	cuint++;
+	*otp_len = fdt32_to_cpu(*cuint);
+
+	*otp_id = offset / sizeof(uint32_t);
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_probe: initialize BSEC driver.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_probe(void)
+{
+	if ((bsec_get_version() != BSEC_IP_VERSION_1_0) ||
+	    (bsec_get_id() != BSEC_IP_ID_3)) {
+		ERROR("BSEC probe wrong IP version/ID\n");
+		panic();
+	}
+
+	check_reset_error();
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_shadow_register: copy SAFMEM OTP to BSEC data.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+static uint32_t bsec_shadow_register(uint32_t otp)
+{
+	uint32_t result;
+	uint32_t i;
+	bool value;
+
+	result = bsec_read_sr_lock(otp, &value);
+	if (result != BSEC_OK) {
+		WARN("BSEC: %u Sticky-read bit read Error %u\n", otp, result);
+	} else if (value) {
+		VERBOSE("BSEC: OTP %u is locked and will not be refreshed\n", otp);
+	}
+
+	for (i = 0U; i < MAX_NB_TRIES; i++) {
+		mmio_write_32(BSEC_BASE + BSEC_OTPCR, otp);
+
+		poll_otp_status_busy();
+
+		result = check_read_error(otp);
+		if (result != BSEC_RETRY) {
+			break;
+		}
+	}
+
+	return result;
+}
+
+/*
+ * bsec_write_otp: write a value in shadow OTP.
+ * val: value to program.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_write_otp(uint32_t val, uint32_t otp)
+{
+	bool state;
+	uint32_t result;
+
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	if (!is_fuse_shadowed(otp)) {
+		return BSEC_ERROR;
+	}
+
+	if (is_bsec_write_locked()) {
+		return BSEC_WRITE_LOCKED;
+	}
+
+	result = bsec_read_sw_lock(otp, &state);
+	if (result != BSEC_OK) {
+		WARN("Shadow register is SW locked\n");
+		return result;
+	}
+
+	mmio_write_32(BSEC_BASE + BSEC_FVR(otp), val);
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_program_otp: program a bit in SAFMEM after the prog.
+ *	The OTP data is not refreshed.
+ * val: value to program.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_program_otp(uint32_t val, uint32_t otp)
+{
+	uint32_t result;
+	uint32_t i;
+	bool value;
+
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	if (is_bsec_write_locked() == true) {
+		return BSEC_WRITE_LOCKED;
+	}
+
+	result = bsec_read_sp_lock(otp, &value);
+	if (result != BSEC_OK) {
+		WARN("BSEC: %u Sticky-prog bit read Error %u\n", otp, result);
+	} else if (value) {
+		WARN("BSEC: OTP locked, prog will be ignored\n");
+		return BSEC_WRITE_LOCKED;
+	}
+
+	mmio_write_32(BSEC_BASE + BSEC_WDR, val);
+
+	for (i = 0U; i < MAX_NB_TRIES; i++) {
+		mmio_write_32(BSEC_BASE + BSEC_OTPCR, otp | BSEC_OTPCR_PROG);
+
+		poll_otp_status_busy();
+
+		result = check_program_error(otp);
+		if (result != BSEC_RETRY) {
+			break;
+		}
+	}
+
+	return result;
+}
+
+/*
+ * bsec_read_debug_conf: read debug configuration.
+ */
+uint32_t bsec_read_debug_conf(void)
+{
+	return mmio_read_32(BSEC_BASE + BSEC_DENR);
+}
+
+static uint32_t bsec_lock_register_set(uint32_t offset, uint32_t mask)
+{
+	uint32_t value = mmio_read_32(BSEC_BASE + offset);
+
+	/* The lock is already set */
+	if ((value & mask) != 0U) {
+		return BSEC_OK;
+	}
+
+	if (is_bsec_write_locked()) {
+		return BSEC_WRITE_LOCKED;
+	}
+
+	value |= mask;
+
+	mmio_write_32(BSEC_BASE + offset, value);
+
+	return BSEC_OK;
+}
+
+static bool bsec_lock_register_get(uint32_t offset, uint32_t mask)
+{
+	uint32_t value = mmio_read_32(BSEC_BASE + offset);
+
+	return (value & mask) != 0U;
+}
+
+/*
+ * bsec_set_sr_lock: set shadow-read lock.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_set_sr_lock(uint32_t otp)
+{
+	uint32_t bank = otp_bank(otp);
+	uint32_t otp_mask = otp_bit_mask(otp);
+
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	return bsec_lock_register_set(BSEC_SRLOCK(bank), otp_mask);
+}
+
+/*
+ * bsec_read_sr_lock: read shadow-read lock.
+ * otp: OTP number.
+ * value: read value (true or false).
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_read_sr_lock(uint32_t otp, bool *value)
+{
+	uint32_t bank = otp_bank(otp);
+	uint32_t otp_mask = otp_bit_mask(otp);
+
+	assert(value != NULL);
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	*value = bsec_lock_register_get(BSEC_SRLOCK(bank), otp_mask);
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_set_sw_lock: set shadow-write lock.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_set_sw_lock(uint32_t otp)
+{
+	uint32_t bank = otp_bank(otp);
+	uint32_t otp_mask = otp_bit_mask(otp);
+
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	return bsec_lock_register_set(BSEC_SWLOCK(bank), otp_mask);
+}
+
+/*
+ * bsec_read_sw_lock: read shadow-write lock.
+ * otp: OTP number.
+ * value: read value (true or false).
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_read_sw_lock(uint32_t otp, bool *value)
+{
+	uint32_t bank = otp_bank(otp);
+	uint32_t otp_mask = otp_bit_mask(otp);
+
+	assert(value != NULL);
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	*value = bsec_lock_register_get(BSEC_SWLOCK(bank), otp_mask);
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_set_sp_lock: set shadow-program lock.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_set_sp_lock(uint32_t otp)
+{
+	uint32_t bank = otp_bank(otp);
+	uint32_t otp_mask = otp_bit_mask(otp);
+
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	return bsec_lock_register_set(BSEC_SPLOCK(bank), otp_mask);
+}
+
+/*
+ * bsec_read_sp_lock: read shadow-program lock.
+ * otp: OTP number.
+ * value: read value (true or false).
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_read_sp_lock(uint32_t otp, bool *value)
+{
+	uint32_t bank = otp_bank(otp);
+	uint32_t otp_mask = otp_bit_mask(otp);
+
+	assert(value != NULL);
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	*value = bsec_lock_register_get(BSEC_SPLOCK(bank), otp_mask);
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_get_secure_state: read state in BSEC status register.
+ * return: secure state
+ */
+uint32_t bsec_get_secure_state(void)
+{
+	uint32_t state = BSEC_STATE_INVALID;
+	uint32_t status = bsec_get_status();
+	uint32_t bsec_sr = mmio_read_32(BSEC_BASE + BSEC_SR);
+
+	if ((status & BSEC_OTPSR_FUSEOK) == BSEC_OTPSR_FUSEOK) {
+		/* NVSTATE is only valid if FUSEOK */
+		uint32_t nvstates = (bsec_sr & BSEC_SR_NVSTATE_MASK) >> BSEC_SR_NVSTATE_SHIFT;
+
+		if (nvstates == BSEC_SR_NVSTATE_OPEN)
+			state = BSEC_STATE_SEC_OPEN;
+		else if (nvstates == BSEC_SR_NVSTATE_CLOSED)
+			state = BSEC_STATE_SEC_CLOSED;
+	}
+
+	if ((bsec_sr & BSEC_SR_HVALID) != 0U) {
+		state |= BSEC_HARDWARE_KEY;
+	}
+
+	return state;
+}
+
+/*
+ * bsec_shadow_read_otp: Load OTP from SAFMEM and provide its value
+ * value: read value.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_shadow_read_otp(uint32_t *value, uint32_t otp)
+{
+	assert(value != NULL);
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	*value = 0U;
+
+	if (is_bsec_write_locked()) {
+		return BSEC_WRITE_LOCKED;
+	}
+
+	if (!is_fuse_shadowed(otp)) {
+		uint32_t result = bsec_shadow_register(otp);
+
+		if (result != BSEC_OK) {
+			ERROR("BSEC: %u Shadowing Error %u\n", otp, result);
+			return result;
+		}
+	}
+
+	*value = mmio_read_32(BSEC_BASE + BSEC_FVR(otp));
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_read_otp: read an OTP data value.
+ * val: read value.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_read_otp(uint32_t *val, uint32_t otp)
+{
+	struct bsec_shadow *shadow = (struct bsec_shadow *)SRAM1_BASE;
+
+	assert(val != NULL);
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	/* OTP already shadowed */
+	if ((shadow->magic == BSEC_MAGIC) && (shadow->state != BSEC_STATE_INVALID)) {
+		*val = shadow->value[otp];
+
+		return BSEC_OK;
+	}
+
+	return bsec_shadow_read_otp(val, otp);
+}
diff --git a/drivers/st/clk/clk-stm32-core.c b/drivers/st/clk/clk-stm32-core.c
new file mode 100644
index 000000000..ff90e8af9
--- /dev/null
+++ b/drivers/st/clk/clk-stm32-core.c
@@ -0,0 +1,1105 @@
+/*
+ * Copyright (C) 2018-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+
+#include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32mp_clkfunc.h>
+#include <lib/mmio.h>
+#include <lib/spinlock.h>
+
+#include "clk-stm32-core.h"
+
+static struct spinlock reg_lock;
+static struct spinlock refcount_lock;
+
+static struct stm32_clk_priv *stm32_clock_data;
+
+const struct stm32_clk_ops clk_mux_ops;
+
+struct stm32_clk_priv *clk_stm32_get_priv(void)
+{
+	return stm32_clock_data;
+}
+
+static void stm32mp1_clk_lock(struct spinlock *lock)
+{
+	if (stm32mp_lock_available()) {
+		/* Assume interrupts are masked */
+		spin_lock(lock);
+	}
+}
+
+static void stm32mp1_clk_unlock(struct spinlock *lock)
+{
+	if (stm32mp_lock_available()) {
+		spin_unlock(lock);
+	}
+}
+
+void stm32mp1_clk_rcc_regs_lock(void)
+{
+	stm32mp1_clk_lock(&reg_lock);
+}
+
+void stm32mp1_clk_rcc_regs_unlock(void)
+{
+	stm32mp1_clk_unlock(&reg_lock);
+}
+
+#define TIMEOUT_US_1S	U(1000000)
+#define OSCRDY_TIMEOUT	TIMEOUT_US_1S
+
+struct clk_oscillator_data *clk_oscillator_get_data(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct stm32_osc_cfg *osc_cfg = clk->clock_cfg;
+	int osc_id = osc_cfg->osc_id;
+
+	return &priv->osci_data[osc_id];
+}
+
+void clk_oscillator_set_bypass(struct stm32_clk_priv *priv, int id, bool digbyp, bool bypass)
+{
+	struct clk_oscillator_data *osc_data = clk_oscillator_get_data(priv, id);
+
+	struct stm32_clk_bypass *bypass_data = osc_data->bypass;
+	uintptr_t address;
+
+	if (bypass_data == NULL) {
+		return;
+	}
+
+	address = priv->base + bypass_data->offset;
+
+	if (digbyp) {
+		mmio_setbits_32(address, BIT(bypass_data->bit_digbyp));
+	}
+
+	if (bypass || digbyp) {
+		mmio_setbits_32(address, BIT(bypass_data->bit_byp));
+	}
+}
+
+void clk_oscillator_set_css(struct stm32_clk_priv *priv, int id, bool css)
+{
+	struct clk_oscillator_data *osc_data = clk_oscillator_get_data(priv, id);
+
+	struct stm32_clk_css *css_data = osc_data->css;
+	uintptr_t address;
+
+	if (css_data == NULL) {
+		return;
+	}
+
+	address = priv->base + css_data->offset;
+
+	if (css) {
+		mmio_setbits_32(address, BIT(css_data->bit_css));
+	}
+}
+
+void clk_oscillator_set_drive(struct stm32_clk_priv *priv, int id, uint8_t lsedrv)
+{
+	struct clk_oscillator_data *osc_data = clk_oscillator_get_data(priv, id);
+
+	struct stm32_clk_drive *drive_data = osc_data->drive;
+	uintptr_t address;
+	uint32_t mask;
+	uint32_t value;
+
+	if (drive_data == NULL) {
+		return;
+	}
+
+	address = priv->base + drive_data->offset;
+
+	mask = (BIT(drive_data->drv_width) - 1U) <<  drive_data->drv_shift;
+
+	/*
+	 * Warning: not recommended to switch directly from "high drive"
+	 * to "medium low drive", and vice-versa.
+	 */
+	value = (mmio_read_32(address) & mask) >> drive_data->drv_shift;
+
+	while (value != lsedrv) {
+		if (value > lsedrv) {
+			value--;
+		} else {
+			value++;
+		}
+
+		mmio_clrsetbits_32(address, mask, value << drive_data->drv_shift);
+	}
+}
+
+int clk_oscillator_wait_ready(struct stm32_clk_priv *priv, int id, bool ready_on)
+{
+	struct clk_oscillator_data *osc_data = clk_oscillator_get_data(priv, id);
+
+	return _clk_stm32_gate_wait_ready(priv, osc_data->gate_rdy_id, ready_on);
+}
+
+int clk_oscillator_wait_ready_on(struct stm32_clk_priv *priv, int id)
+{
+	return clk_oscillator_wait_ready(priv, id, true);
+}
+
+int clk_oscillator_wait_ready_off(struct stm32_clk_priv *priv, int id)
+{
+	return clk_oscillator_wait_ready(priv, id, false);
+}
+
+static int clk_gate_enable(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct clk_gate_cfg *cfg = clk->clock_cfg;
+
+	stm32mp_mmio_setbits_32_shregs(priv->base + cfg->offset, BIT(cfg->bit_idx));
+
+	return 0;
+}
+
+static void clk_gate_disable(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct clk_gate_cfg *cfg = clk->clock_cfg;
+
+	stm32mp_mmio_clrbits_32_shregs(priv->base + cfg->offset, BIT(cfg->bit_idx));
+}
+
+static bool clk_gate_is_enabled(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct clk_gate_cfg *cfg = clk->clock_cfg;
+
+	return ((mmio_read_32(priv->base + cfg->offset) & BIT(cfg->bit_idx)) != 0U);
+}
+
+const struct stm32_clk_ops clk_gate_ops = {
+	.enable		= clk_gate_enable,
+	.disable	= clk_gate_disable,
+	.is_enabled	= clk_gate_is_enabled,
+};
+
+void _clk_stm32_gate_disable(struct stm32_clk_priv *priv, uint16_t gate_id)
+{
+	const struct gate_cfg *gate = &priv->gates[gate_id];
+	uintptr_t addr = priv->base + gate->offset;
+
+	if (gate->set_clr != 0U) {
+		mmio_write_32(addr + RCC_MP_ENCLRR_OFFSET, BIT(gate->bit_idx));
+	} else {
+		stm32mp_mmio_clrbits_32_shregs(addr, BIT(gate->bit_idx));
+	}
+}
+
+int _clk_stm32_gate_enable(struct stm32_clk_priv *priv, uint16_t gate_id)
+{
+	const struct gate_cfg *gate = &priv->gates[gate_id];
+	uintptr_t addr = priv->base + gate->offset;
+
+	if (gate->set_clr != 0U) {
+		mmio_write_32(addr, BIT(gate->bit_idx));
+
+	} else {
+		stm32mp_mmio_setbits_32_shregs(addr, BIT(gate->bit_idx));
+	}
+
+	return 0;
+}
+
+const struct clk_stm32 *_clk_get(struct stm32_clk_priv *priv, int id)
+{
+	if ((unsigned int)id < priv->num) {
+		return &priv->clks[id];
+	}
+
+	return NULL;
+}
+
+#define clk_div_mask(_width) GENMASK(((_width) - 1U), 0U)
+
+static unsigned int _get_table_div(const struct clk_div_table *table,
+				   unsigned int val)
+{
+	const struct clk_div_table *clkt;
+
+	for (clkt = table; clkt->div; clkt++) {
+		if (clkt->val == val) {
+			return clkt->div;
+		}
+	}
+
+	return 0;
+}
+
+static unsigned int _get_div(const struct clk_div_table *table,
+			     unsigned int val, unsigned long flags,
+			     uint8_t width)
+{
+	if ((flags & CLK_DIVIDER_ONE_BASED) != 0UL) {
+		return val;
+	}
+
+	if ((flags & CLK_DIVIDER_POWER_OF_TWO) != 0UL) {
+		return BIT(val);
+	}
+
+	if ((flags & CLK_DIVIDER_MAX_AT_ZERO) != 0UL) {
+		return (val != 0U) ? val : BIT(width);
+	}
+
+	if (table != NULL) {
+		return _get_table_div(table, val);
+	}
+
+	return val + 1U;
+}
+
+#define TIMEOUT_US_200MS	U(200000)
+#define CLKSRC_TIMEOUT		TIMEOUT_US_200MS
+
+int clk_mux_set_parent(struct stm32_clk_priv *priv, uint16_t pid, uint8_t sel)
+{
+	const struct parent_cfg *parents = &priv->parents[pid & MUX_PARENT_MASK];
+	const struct mux_cfg *mux = parents->mux;
+	uintptr_t address = priv->base + mux->offset;
+	uint32_t mask;
+	uint64_t timeout;
+
+	mask = MASK_WIDTH_SHIFT(mux->width, mux->shift);
+
+	mmio_clrsetbits_32(address, mask, (sel << mux->shift) & mask);
+
+	if (mux->bitrdy == MUX_NO_BIT_RDY) {
+		return 0;
+	}
+
+	timeout = timeout_init_us(CLKSRC_TIMEOUT);
+
+	mask = BIT(mux->bitrdy);
+
+	while ((mmio_read_32(address) & mask) == 0U) {
+		if (timeout_elapsed(timeout)) {
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+int _clk_stm32_set_parent(struct stm32_clk_priv *priv, int clk, int clkp)
+{
+	const struct parent_cfg *parents;
+	uint16_t pid;
+	uint8_t sel;
+	int old_parent;
+
+	pid = priv->clks[clk].parent;
+
+	if ((pid == CLK_IS_ROOT) || (pid < MUX_MAX_PARENTS)) {
+		return -EINVAL;
+	}
+
+	old_parent = _clk_stm32_get_parent(priv, clk);
+	if (old_parent < 0) {
+		return old_parent;
+	}
+	if (old_parent == clkp) {
+		return 0;
+	}
+
+	parents = &priv->parents[pid & MUX_PARENT_MASK];
+
+	for (sel = 0; sel <  parents->num_parents; sel++) {
+		if (parents->id_parents[sel] == (uint16_t)clkp) {
+			bool clk_was_enabled = _clk_stm32_is_enabled(priv, clk);
+			int err = 0;
+
+			/* Enable the parents (for glitch free mux) */
+			_clk_stm32_enable(priv, clkp);
+			_clk_stm32_enable(priv, old_parent);
+
+			err = clk_mux_set_parent(priv, pid, sel);
+
+			_clk_stm32_disable(priv, old_parent);
+
+			if (clk_was_enabled) {
+				_clk_stm32_disable(priv, old_parent);
+			}
+			else {
+				_clk_stm32_disable(priv, clkp);
+			}
+
+			return err;
+		}
+	}
+
+	return -EINVAL;
+}
+
+int clk_mux_get_parent(struct stm32_clk_priv *priv, uint32_t mux_id)
+{
+	const struct parent_cfg *parent;
+	const struct mux_cfg *mux;
+	uint32_t mask;
+
+	if (mux_id >= priv->nb_parents) {
+		panic();
+	}
+
+	parent = &priv->parents[mux_id];
+	mux = parent->mux;
+
+	mask = MASK_WIDTH_SHIFT(mux->width, mux->shift);
+
+	return (mmio_read_32(priv->base + mux->offset) & mask) >> mux->shift;
+}
+
+int _clk_stm32_set_parent_by_index(struct stm32_clk_priv *priv, int clk, int sel)
+{
+	uint16_t pid;
+
+	pid = priv->clks[clk].parent;
+
+	if ((pid == CLK_IS_ROOT) || (pid < MUX_MAX_PARENTS)) {
+		return -EINVAL;
+	}
+
+	return clk_mux_set_parent(priv, pid, sel);
+}
+
+int _clk_stm32_get_parent(struct stm32_clk_priv *priv, int clk_id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, clk_id);
+	const struct parent_cfg *parent;
+	uint16_t mux_id;
+	int sel;
+
+	mux_id = priv->clks[clk_id].parent;
+	if (mux_id == CLK_IS_ROOT) {
+		return CLK_IS_ROOT;
+	}
+
+	if (mux_id < MUX_MAX_PARENTS) {
+		return mux_id & MUX_PARENT_MASK;
+	}
+
+	mux_id &= MUX_PARENT_MASK;
+	parent = &priv->parents[mux_id];
+
+	if (clk->ops->get_parent != NULL) {
+		sel = clk->ops->get_parent(priv, clk_id);
+	} else {
+		sel = clk_mux_get_parent(priv, mux_id);
+	}
+
+	if ((sel >= 0) && (sel < parent->num_parents)) {
+		return parent->id_parents[sel];
+	}
+
+	return -EINVAL;
+}
+
+int _clk_stm32_get_parent_index(struct stm32_clk_priv *priv, int clk_id)
+{
+	uint16_t mux_id;
+
+	mux_id = priv->clks[clk_id].parent;
+	if (mux_id == CLK_IS_ROOT) {
+		return CLK_IS_ROOT;
+	}
+
+	if (mux_id < MUX_MAX_PARENTS) {
+		return mux_id & MUX_PARENT_MASK;
+	}
+
+	mux_id &= MUX_PARENT_MASK;
+
+	return clk_mux_get_parent(priv, mux_id);
+}
+
+int _clk_stm32_get_parent_by_index(struct stm32_clk_priv *priv, int clk_id, int idx)
+{
+	const struct parent_cfg *parent;
+	uint16_t mux_id;
+
+	mux_id = priv->clks[clk_id].parent;
+	if (mux_id == CLK_IS_ROOT) {
+		return CLK_IS_ROOT;
+	}
+
+	if (mux_id < MUX_MAX_PARENTS) {
+		return mux_id & MUX_PARENT_MASK;
+	}
+
+	mux_id &= MUX_PARENT_MASK;
+	parent = &priv->parents[mux_id];
+
+	if (idx < parent->num_parents) {
+		return parent->id_parents[idx];
+	}
+
+	return -EINVAL;
+}
+
+int clk_get_index(struct stm32_clk_priv *priv, unsigned long binding_id)
+{
+	unsigned int i;
+
+	for (i = 0U; i < priv->num; i++) {
+		if (binding_id == priv->clks[i].binding) {
+			return (int)i;
+		}
+	}
+
+	return -EINVAL;
+}
+
+unsigned long _clk_stm32_get_rate(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	int parent;
+	unsigned long rate = 0UL;
+
+	if ((unsigned int)id >= priv->num) {
+		return rate;
+	}
+
+	parent = _clk_stm32_get_parent(priv, id);
+	if (parent < 0) {
+		return 0UL;
+	}
+
+	if (clk->ops->recalc_rate != NULL) {
+		unsigned long prate = 0UL;
+
+		if (parent != CLK_IS_ROOT) {
+			prate = _clk_stm32_get_rate(priv, parent);
+		}
+
+		rate = clk->ops->recalc_rate(priv, id, prate);
+
+		return rate;
+	}
+
+	switch (parent) {
+	case CLK_IS_ROOT:
+		panic();
+
+	default:
+		rate = _clk_stm32_get_rate(priv, parent);
+		break;
+	}
+	return rate;
+
+}
+
+unsigned long _clk_stm32_get_parent_rate(struct stm32_clk_priv *priv, int id)
+{
+	int parent_id = _clk_stm32_get_parent(priv, id);
+
+	if (parent_id < 0) {
+		return 0UL;
+	}
+
+	return _clk_stm32_get_rate(priv, parent_id);
+}
+
+static uint8_t _stm32_clk_get_flags(struct stm32_clk_priv *priv, int id)
+{
+	return priv->clks[id].flags;
+}
+
+bool _stm32_clk_is_flags(struct stm32_clk_priv *priv, int id, uint8_t flag)
+{
+	if (_stm32_clk_get_flags(priv, id) & flag) {
+		return true;
+	}
+
+	return false;
+}
+
+int clk_stm32_enable_call_ops(struct stm32_clk_priv *priv, uint16_t id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+
+	if (clk->ops->enable != NULL) {
+		clk->ops->enable(priv, id);
+	}
+
+	return 0;
+}
+
+static int _clk_stm32_enable_core(struct stm32_clk_priv *priv, int id)
+{
+	int parent;
+	int ret = 0;
+
+	if (priv->gate_refcounts[id] == 0U) {
+		parent = _clk_stm32_get_parent(priv, id);
+		if (parent < 0) {
+			return parent;
+		}
+		if (parent != CLK_IS_ROOT) {
+			ret = _clk_stm32_enable_core(priv, parent);
+			if (ret) {
+				return ret;
+			}
+		}
+		clk_stm32_enable_call_ops(priv, id);
+	}
+
+	priv->gate_refcounts[id]++;
+
+	if (priv->gate_refcounts[id] == UINT_MAX) {
+		ERROR("%s: %d max enable count !", __func__, id);
+		panic();
+	}
+
+	return 0;
+}
+
+int _clk_stm32_enable(struct stm32_clk_priv *priv, int id)
+{
+	int ret;
+
+	stm32mp1_clk_lock(&refcount_lock);
+	ret = _clk_stm32_enable_core(priv, id);
+	stm32mp1_clk_unlock(&refcount_lock);
+
+	return ret;
+}
+
+void clk_stm32_disable_call_ops(struct stm32_clk_priv *priv, uint16_t id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+
+	if (clk->ops->disable != NULL) {
+		clk->ops->disable(priv, id);
+	}
+}
+
+static void _clk_stm32_disable_core(struct stm32_clk_priv *priv, int id)
+{
+	int parent;
+
+	if ((priv->gate_refcounts[id] == 1U) && _stm32_clk_is_flags(priv, id, CLK_IS_CRITICAL)) {
+		return;
+	}
+
+	if (priv->gate_refcounts[id] == 0U) {
+		/* case of clock ignore unused */
+		if (_clk_stm32_is_enabled(priv, id)) {
+			clk_stm32_disable_call_ops(priv, id);
+			return;
+		}
+		VERBOSE("%s: %d already disabled !\n\n", __func__, id);
+		return;
+	}
+
+	if (--priv->gate_refcounts[id] > 0U) {
+		return;
+	}
+
+	clk_stm32_disable_call_ops(priv, id);
+
+	parent = _clk_stm32_get_parent(priv, id);
+	if ((parent >= 0) && (parent != CLK_IS_ROOT)) {
+		_clk_stm32_disable_core(priv, parent);
+	}
+}
+
+void _clk_stm32_disable(struct stm32_clk_priv *priv, int id)
+{
+	stm32mp1_clk_lock(&refcount_lock);
+
+	_clk_stm32_disable_core(priv, id);
+
+	stm32mp1_clk_unlock(&refcount_lock);
+}
+
+bool _clk_stm32_is_enabled(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+
+	if (clk->ops->is_enabled != NULL) {
+		return clk->ops->is_enabled(priv, id);
+	}
+
+	return priv->gate_refcounts[id];
+}
+
+static int clk_stm32_enable(unsigned long binding_id)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	int id;
+
+	id = clk_get_index(priv, binding_id);
+	if (id == -EINVAL) {
+		return id;
+	}
+
+	return _clk_stm32_enable(priv, id);
+}
+
+static void clk_stm32_disable(unsigned long binding_id)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	int id;
+
+	id = clk_get_index(priv, binding_id);
+	if (id != -EINVAL) {
+		_clk_stm32_disable(priv, id);
+	}
+}
+
+static bool clk_stm32_is_enabled(unsigned long binding_id)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	int id;
+
+	id = clk_get_index(priv, binding_id);
+	if (id == -EINVAL) {
+		return false;
+	}
+
+	return _clk_stm32_is_enabled(priv, id);
+}
+
+static unsigned long clk_stm32_get_rate(unsigned long binding_id)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	int id;
+
+	id = clk_get_index(priv, binding_id);
+	if (id == -EINVAL) {
+		return 0UL;
+	}
+
+	return _clk_stm32_get_rate(priv, id);
+}
+
+static int clk_stm32_get_parent(unsigned long binding_id)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	int id;
+
+	id = clk_get_index(priv, binding_id);
+	if (id == -EINVAL) {
+		return id;
+	}
+
+	return _clk_stm32_get_parent(priv, id);
+}
+
+static const struct clk_ops stm32mp_clk_ops = {
+	.enable		= clk_stm32_enable,
+	.disable	= clk_stm32_disable,
+	.is_enabled	= clk_stm32_is_enabled,
+	.get_rate	= clk_stm32_get_rate,
+	.get_parent	= clk_stm32_get_parent,
+};
+
+void clk_stm32_enable_critical_clocks(void)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	unsigned int i;
+
+	for (i = 0U; i < priv->num; i++) {
+		if (_stm32_clk_is_flags(priv, i, CLK_IS_CRITICAL)) {
+			_clk_stm32_enable(priv, i);
+		}
+	}
+}
+
+static void stm32_clk_register(void)
+{
+	clk_register(&stm32mp_clk_ops);
+}
+
+uint32_t clk_stm32_div_get_value(struct stm32_clk_priv *priv, int div_id)
+{
+	const struct div_cfg *divider = &priv->div[div_id];
+	uint32_t val = 0;
+
+	val = mmio_read_32(priv->base + divider->offset) >> divider->shift;
+	val &= clk_div_mask(divider->width);
+
+	return val;
+}
+
+unsigned long _clk_stm32_divider_recalc(struct stm32_clk_priv *priv,
+					int div_id,
+					unsigned long prate)
+{
+	const struct div_cfg *divider = &priv->div[div_id];
+	uint32_t val = clk_stm32_div_get_value(priv, div_id);
+	unsigned int div = 0U;
+
+	div = _get_div(divider->table, val, divider->flags, divider->width);
+	if (div == 0U) {
+		return prate;
+	}
+
+	return div_round_up((uint64_t)prate, div);
+}
+
+unsigned long clk_stm32_divider_recalc(struct stm32_clk_priv *priv, int id,
+				       unsigned long prate)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct clk_stm32_div_cfg *div_cfg = clk->clock_cfg;
+
+	return _clk_stm32_divider_recalc(priv, div_cfg->id, prate);
+}
+
+const struct stm32_clk_ops clk_stm32_divider_ops = {
+	.recalc_rate	= clk_stm32_divider_recalc,
+};
+
+int clk_stm32_set_div(struct stm32_clk_priv *priv, uint32_t div_id, uint32_t value)
+{
+	const struct div_cfg *divider;
+	uintptr_t address;
+	uint64_t timeout;
+	uint32_t mask;
+
+	if (div_id >= priv->nb_div) {
+		panic();
+	}
+
+	divider = &priv->div[div_id];
+	address = priv->base + divider->offset;
+
+	mask = MASK_WIDTH_SHIFT(divider->width, divider->shift);
+	mmio_clrsetbits_32(address, mask, (value << divider->shift) & mask);
+
+	if (divider->bitrdy == DIV_NO_BIT_RDY) {
+		return 0;
+	}
+
+	timeout = timeout_init_us(CLKSRC_TIMEOUT);
+	mask = BIT(divider->bitrdy);
+
+	while ((mmio_read_32(address) & mask) == 0U) {
+		if (timeout_elapsed(timeout)) {
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+int _clk_stm32_gate_wait_ready(struct stm32_clk_priv *priv, uint16_t gate_id,
+			       bool ready_on)
+{
+	const struct gate_cfg *gate = &priv->gates[gate_id];
+	uintptr_t address = priv->base + gate->offset;
+	uint32_t mask_rdy = BIT(gate->bit_idx);
+	uint64_t timeout;
+	uint32_t mask_test;
+
+	if (ready_on) {
+		mask_test = BIT(gate->bit_idx);
+	} else {
+		mask_test = 0U;
+	}
+
+	timeout = timeout_init_us(OSCRDY_TIMEOUT);
+
+	while ((mmio_read_32(address) & mask_rdy) != mask_test) {
+		if (timeout_elapsed(timeout)) {
+			break;
+		}
+	}
+
+	if ((mmio_read_32(address) & mask_rdy) != mask_test)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+int clk_stm32_gate_enable(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct clk_stm32_gate_cfg *cfg = clk->clock_cfg;
+	const struct gate_cfg *gate = &priv->gates[cfg->id];
+	uintptr_t addr = priv->base + gate->offset;
+
+	if (gate->set_clr != 0U) {
+		mmio_write_32(addr, BIT(gate->bit_idx));
+
+	} else {
+		stm32mp_mmio_setbits_32_shregs(addr, BIT(gate->bit_idx));
+	}
+
+	return 0;
+}
+
+void clk_stm32_gate_disable(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct clk_stm32_gate_cfg *cfg = clk->clock_cfg;
+	const struct gate_cfg *gate = &priv->gates[cfg->id];
+	uintptr_t addr = priv->base + gate->offset;
+
+	if (gate->set_clr != 0U) {
+		mmio_write_32(addr + RCC_MP_ENCLRR_OFFSET, BIT(gate->bit_idx));
+	} else {
+		stm32mp_mmio_clrbits_32_shregs(addr, BIT(gate->bit_idx));
+	}
+}
+
+bool _clk_stm32_gate_is_enabled(struct stm32_clk_priv *priv, int gate_id)
+{
+	const struct gate_cfg *gate;
+	uint32_t addr;
+
+	gate = &priv->gates[gate_id];
+	addr = priv->base + gate->offset;
+
+	return ((mmio_read_32(addr) & BIT(gate->bit_idx)) != 0U);
+}
+
+bool clk_stm32_gate_is_enabled(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct clk_stm32_gate_cfg *cfg = clk->clock_cfg;
+
+	return _clk_stm32_gate_is_enabled(priv, cfg->id);
+}
+
+const struct stm32_clk_ops clk_stm32_gate_ops = {
+	.enable		= clk_stm32_gate_enable,
+	.disable	= clk_stm32_gate_disable,
+	.is_enabled	= clk_stm32_gate_is_enabled,
+};
+
+const struct stm32_clk_ops clk_fixed_factor_ops = {
+	.recalc_rate	= fixed_factor_recalc_rate,
+};
+
+unsigned long fixed_factor_recalc_rate(struct stm32_clk_priv *priv,
+				       int id, unsigned long prate)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	const struct fixed_factor_cfg *cfg = clk->clock_cfg;
+	unsigned long long rate;
+
+	rate = (unsigned long long)prate * cfg->mult;
+
+	if (cfg->div == 0U) {
+		ERROR("division by zero\n");
+		panic();
+	}
+
+	return (unsigned long)(rate / cfg->div);
+};
+
+#define APB_DIV_MASK	GENMASK(2, 0)
+#define TIM_PRE_MASK	BIT(0)
+
+static unsigned long timer_recalc_rate(struct stm32_clk_priv *priv,
+				       int id, unsigned long prate)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	const struct clk_timer_cfg *cfg = clk->clock_cfg;
+	uint32_t prescaler, timpre;
+	uintptr_t rcc_base = priv->base;
+
+	prescaler = mmio_read_32(rcc_base + cfg->apbdiv) &
+		APB_DIV_MASK;
+
+	timpre = mmio_read_32(rcc_base + cfg->timpre) &
+		TIM_PRE_MASK;
+
+	if (prescaler == 0U) {
+		return prate;
+	}
+
+	return prate * (timpre + 1U) * 2U;
+};
+
+const struct stm32_clk_ops clk_timer_ops = {
+	.recalc_rate	= timer_recalc_rate,
+};
+
+static unsigned long clk_fixed_rate_recalc(struct stm32_clk_priv *priv, int id,
+					   unsigned long prate)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct clk_stm32_fixed_rate_cfg *cfg = clk->clock_cfg;
+
+	return cfg->rate;
+}
+
+const struct stm32_clk_ops clk_stm32_fixed_rate_ops = {
+	.recalc_rate	= clk_fixed_rate_recalc,
+};
+
+static unsigned long clk_stm32_osc_recalc_rate(struct stm32_clk_priv *priv,
+					       int id, unsigned long prate)
+{
+	struct clk_oscillator_data *osc_data = clk_oscillator_get_data(priv, id);
+
+	return osc_data->frequency;
+};
+
+bool clk_stm32_osc_gate_is_enabled(struct stm32_clk_priv *priv, int id)
+{
+	struct clk_oscillator_data *osc_data = clk_oscillator_get_data(priv, id);
+
+	return _clk_stm32_gate_is_enabled(priv, osc_data->gate_id);
+
+}
+
+int clk_stm32_osc_gate_enable(struct stm32_clk_priv *priv, int id)
+{
+	struct clk_oscillator_data *osc_data = clk_oscillator_get_data(priv, id);
+
+	if (osc_data->frequency == 0UL) {
+		return 0;
+	}
+
+	_clk_stm32_gate_enable(priv, osc_data->gate_id);
+
+	if (_clk_stm32_gate_wait_ready(priv, osc_data->gate_rdy_id, true) != 0U) {
+		ERROR("%s: %s (%d)\n", __func__, osc_data->name, __LINE__);
+		panic();
+	}
+
+	return 0;
+}
+
+void clk_stm32_osc_gate_disable(struct stm32_clk_priv *priv, int id)
+{
+	struct clk_oscillator_data *osc_data = clk_oscillator_get_data(priv, id);
+
+	if (osc_data->frequency == 0UL) {
+		return;
+	}
+
+	_clk_stm32_gate_disable(priv, osc_data->gate_id);
+
+	if (_clk_stm32_gate_wait_ready(priv, osc_data->gate_rdy_id, false) != 0U) {
+		ERROR("%s: %s (%d)\n", __func__, osc_data->name, __LINE__);
+		panic();
+	}
+}
+
+static unsigned long clk_stm32_get_dt_oscillator_frequency(const char *name)
+{
+	void *fdt = NULL;
+	int node = 0;
+	int subnode = 0;
+
+	if (fdt_get_address(&fdt) == 0) {
+		panic();
+	}
+
+	node = fdt_path_offset(fdt, "/clocks");
+	if (node < 0) {
+		return 0UL;
+	}
+
+	fdt_for_each_subnode(subnode, fdt, node) {
+		const char *cchar = NULL;
+		const fdt32_t *cuint = 0;
+		int ret = 0;
+
+		cchar = fdt_get_name(fdt, subnode, &ret);
+		if (cchar == NULL) {
+			continue;
+		}
+
+		if (strncmp(cchar, name, (size_t)ret) ||
+		    fdt_get_status(subnode) == DT_DISABLED) {
+			continue;
+		}
+
+		cuint = fdt_getprop(fdt, subnode, "clock-frequency", &ret);
+		if (cuint == NULL) {
+			return 0UL;
+		}
+
+		return fdt32_to_cpu(*cuint);
+	}
+
+	return 0UL;
+}
+
+void clk_stm32_osc_init(struct stm32_clk_priv *priv, int id)
+{
+	struct clk_oscillator_data *osc_data = clk_oscillator_get_data(priv, id);
+	const char *name = osc_data->name;
+
+	osc_data->frequency = clk_stm32_get_dt_oscillator_frequency(name);
+}
+
+const struct stm32_clk_ops clk_stm32_osc_ops = {
+	.recalc_rate	= clk_stm32_osc_recalc_rate,
+	.is_enabled	= clk_stm32_osc_gate_is_enabled,
+	.enable		= clk_stm32_osc_gate_enable,
+	.disable	= clk_stm32_osc_gate_disable,
+	.init		= clk_stm32_osc_init,
+};
+
+const struct stm32_clk_ops clk_stm32_osc_nogate_ops = {
+	.recalc_rate 	= clk_stm32_osc_recalc_rate,
+	.init		= clk_stm32_osc_init,
+};
+
+int stm32_clk_parse_fdt_by_name(void *fdt, int node, const char *name, uint32_t *tab, uint32_t *nb)
+{
+	const fdt32_t *cell;
+	int len = 0;
+	uint32_t i;
+
+	cell = fdt_getprop(fdt, node, name, &len);
+	if (cell == NULL) {
+		*nb = 0U;
+		return 0;
+	}
+
+	for (i = 0; i < ((uint32_t)len / sizeof(uint32_t)); i++) {
+		uint32_t val = fdt32_to_cpu(cell[i]);
+
+		tab[i] = val;
+	}
+
+	*nb = (uint32_t)len / sizeof(uint32_t);
+
+	return 0;
+}
+
+int clk_stm32_init(struct stm32_clk_priv *priv, uintptr_t base)
+{
+	unsigned int i;
+
+	stm32_clock_data = priv;
+
+	priv->base = base;
+
+	for (i = 0U; i < priv->num; i++) {
+		const struct clk_stm32 *clk = _clk_get(priv, i);
+
+		assert(clk->ops != NULL);
+
+		if (clk->ops->init != NULL) {
+			clk->ops->init(priv, i);
+		}
+	}
+
+	stm32_clk_register();
+
+	return 0;
+}
diff --git a/drivers/st/clk/clk-stm32-core.h b/drivers/st/clk/clk-stm32-core.h
new file mode 100644
index 000000000..280141bad
--- /dev/null
+++ b/drivers/st/clk/clk-stm32-core.h
@@ -0,0 +1,393 @@
+/*
+ * Copyright (C) 2018-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ */
+
+#ifndef CLK_STM32_CORE_H
+#define CLK_STM32_CORE_H
+
+struct mux_cfg {
+	uint16_t offset;
+	uint8_t shift;
+	uint8_t width;
+	uint8_t bitrdy;
+};
+
+struct gate_cfg {
+	uint16_t offset;
+	uint8_t bit_idx;
+	uint8_t set_clr;
+};
+
+struct clk_div_table {
+	unsigned int val;
+	unsigned int div;
+};
+
+struct div_cfg {
+	uint16_t offset;
+	uint8_t shift;
+	uint8_t width;
+	uint8_t flags;
+	uint8_t bitrdy;
+	const struct clk_div_table *table;
+};
+
+struct parent_cfg {
+	uint8_t num_parents;
+	const uint16_t *id_parents;
+	struct mux_cfg *mux;
+};
+
+struct stm32_clk_priv;
+
+struct stm32_clk_ops {
+	unsigned long (*recalc_rate)(struct stm32_clk_priv *priv, int id, unsigned long rate);
+	int (*get_parent)(struct stm32_clk_priv *priv, int id);
+	int (*set_rate)(struct stm32_clk_priv *priv, int id, unsigned long rate,
+			unsigned long prate);
+	int (*enable)(struct stm32_clk_priv *priv, int id);
+	void (*disable)(struct stm32_clk_priv *priv, int id);
+	bool (*is_enabled)(struct stm32_clk_priv *priv, int id);
+	void (*init)(struct stm32_clk_priv *priv, int id);
+};
+
+struct clk_stm32 {
+	uint16_t binding;
+	uint16_t parent;
+	uint8_t flags;
+	void *clock_cfg;
+	const struct stm32_clk_ops *ops;
+};
+
+struct stm32_clk_priv {
+	uintptr_t base;
+	const uint32_t num;
+	const struct clk_stm32 *clks;
+	const struct parent_cfg *parents;
+	const uint32_t nb_parents;
+	const struct gate_cfg *gates;
+	const uint32_t nb_gates;
+	const struct div_cfg *div;
+	const uint32_t nb_div;
+	struct clk_oscillator_data *osci_data;
+	const uint32_t nb_osci_data;
+	uint32_t *gate_refcounts;
+	void *pdata;
+};
+
+struct stm32_clk_bypass {
+	uint16_t offset;
+	uint8_t bit_byp;
+	uint8_t bit_digbyp;
+};
+
+struct stm32_clk_css {
+	uint16_t offset;
+	uint8_t bit_css;
+};
+
+struct stm32_clk_drive {
+	uint16_t offset;
+	uint8_t drv_shift;
+	uint8_t drv_width;
+	uint8_t drv_default;
+};
+
+struct clk_oscillator_data {
+	const char *name;
+	uint16_t id_clk;
+	unsigned long frequency;
+	uint16_t gate_id;
+	uint16_t gate_rdy_id;
+	struct stm32_clk_bypass *bypass;
+	struct stm32_clk_css *css;
+	struct stm32_clk_drive *drive;
+};
+
+struct clk_fixed_rate {
+	const char *name;
+	unsigned long fixed_rate;
+};
+
+struct clk_gate_cfg {
+	uint32_t offset;
+	uint8_t bit_idx;
+};
+
+/* CLOCK FLAGS */
+#define CLK_IS_CRITICAL			BIT(0)
+#define CLK_IGNORE_UNUSED		BIT(1)
+#define CLK_SET_RATE_PARENT		BIT(2)
+
+#define CLK_DIVIDER_ONE_BASED		BIT(0)
+#define CLK_DIVIDER_POWER_OF_TWO	BIT(1)
+#define CLK_DIVIDER_ALLOW_ZERO		BIT(2)
+#define CLK_DIVIDER_HIWORD_MASK		BIT(3)
+#define CLK_DIVIDER_ROUND_CLOSEST	BIT(4)
+#define CLK_DIVIDER_READ_ONLY		BIT(5)
+#define CLK_DIVIDER_MAX_AT_ZERO		BIT(6)
+#define CLK_DIVIDER_BIG_ENDIAN		BIT(7)
+
+#define MUX_MAX_PARENTS			U(0x8000)
+#define MUX_PARENT_MASK			GENMASK(14, 0)
+#define MUX_FLAG			U(0x8000)
+#define MUX(mux)			((mux) | MUX_FLAG)
+
+#define NO_GATE				0
+#define _NO_ID				UINT16_MAX
+#define CLK_IS_ROOT			UINT16_MAX
+#define MUX_NO_BIT_RDY			UINT8_MAX
+#define DIV_NO_BIT_RDY			UINT8_MAX
+
+#define MASK_WIDTH_SHIFT(_width, _shift) \
+	GENMASK(((_width) + (_shift) - 1U), _shift)
+
+int clk_stm32_init(struct stm32_clk_priv *priv, uintptr_t base);
+void clk_stm32_enable_critical_clocks(void);
+
+struct stm32_clk_priv *clk_stm32_get_priv(void);
+
+int clk_get_index(struct stm32_clk_priv *priv, unsigned long binding_id);
+const struct clk_stm32 *_clk_get(struct stm32_clk_priv *priv, int id);
+
+void clk_oscillator_set_bypass(struct stm32_clk_priv *priv, int id, bool digbyp, bool bypass);
+void clk_oscillator_set_drive(struct stm32_clk_priv *priv, int id, uint8_t lsedrv);
+void clk_oscillator_set_css(struct stm32_clk_priv *priv, int id, bool css);
+
+int _clk_stm32_gate_wait_ready(struct stm32_clk_priv *priv, uint16_t gate_id, bool ready_on);
+
+int clk_oscillator_wait_ready(struct stm32_clk_priv *priv, int id, bool ready_on);
+int clk_oscillator_wait_ready_on(struct stm32_clk_priv *priv, int id);
+int clk_oscillator_wait_ready_off(struct stm32_clk_priv *priv, int id);
+
+int clk_stm32_get_counter(unsigned long binding_id);
+
+void _clk_stm32_gate_disable(struct stm32_clk_priv *priv, uint16_t gate_id);
+int _clk_stm32_gate_enable(struct stm32_clk_priv *priv, uint16_t gate_id);
+
+int _clk_stm32_set_parent(struct stm32_clk_priv *priv, int id, int src_id);
+int _clk_stm32_set_parent_by_index(struct stm32_clk_priv *priv, int clk, int sel);
+
+int _clk_stm32_get_parent(struct stm32_clk_priv *priv, int id);
+int _clk_stm32_get_parent_by_index(struct stm32_clk_priv *priv, int clk_id, int idx);
+int _clk_stm32_get_parent_index(struct stm32_clk_priv *priv, int clk_id);
+
+unsigned long _clk_stm32_get_rate(struct stm32_clk_priv *priv, int id);
+unsigned long _clk_stm32_get_parent_rate(struct stm32_clk_priv *priv, int id);
+
+bool _stm32_clk_is_flags(struct stm32_clk_priv *priv, int id, uint8_t flag);
+
+int _clk_stm32_enable(struct stm32_clk_priv *priv, int id);
+void _clk_stm32_disable(struct stm32_clk_priv *priv, int id);
+
+int clk_stm32_enable_call_ops(struct stm32_clk_priv *priv, uint16_t id);
+void clk_stm32_disable_call_ops(struct stm32_clk_priv *priv, uint16_t id);
+
+bool _clk_stm32_is_enabled(struct stm32_clk_priv *priv, int id);
+
+int _clk_stm32_divider_set_rate(struct stm32_clk_priv *priv, int div_id,
+				unsigned long rate, unsigned long parent_rate);
+
+ int clk_stm32_divider_set_rate(struct stm32_clk_priv *priv, int id, unsigned long rate,
+				unsigned long prate);
+
+unsigned long _clk_stm32_divider_recalc(struct stm32_clk_priv *priv,
+					int div_id,
+					unsigned long prate);
+
+unsigned long clk_stm32_divider_recalc(struct stm32_clk_priv *priv, int idx,
+				       unsigned long prate);
+
+int clk_stm32_gate_enable(struct stm32_clk_priv *priv, int idx);
+void clk_stm32_gate_disable(struct stm32_clk_priv *priv, int idx);
+
+bool _clk_stm32_gate_is_enabled(struct stm32_clk_priv *priv, int gate_id);
+bool clk_stm32_gate_is_enabled(struct stm32_clk_priv *priv, int idx);
+
+uint32_t clk_stm32_div_get_value(struct stm32_clk_priv *priv, int div_id);
+int clk_stm32_set_div(struct stm32_clk_priv *priv, uint32_t div_id, uint32_t value);
+int clk_mux_set_parent(struct stm32_clk_priv *priv, uint16_t pid, uint8_t sel);
+int clk_mux_get_parent(struct stm32_clk_priv *priv, uint32_t mux_id);
+
+int stm32_clk_parse_fdt_by_name(void *fdt, int node, const char *name, uint32_t *tab, uint32_t *nb);
+
+#ifdef CFG_STM32_CLK_DEBUG
+void clk_stm32_display_clock_info(void);
+#endif
+
+struct clk_stm32_div_cfg {
+	int id;
+};
+
+#define STM32_DIV(idx, _binding, _parent, _flags, _div_id) \
+	[(idx)] = (struct clk_stm32){ \
+		.binding	= (_binding),\
+		.parent		=  (_parent),\
+		.flags		= (_flags),\
+		.clock_cfg	= &(struct clk_stm32_div_cfg){\
+			.id	= (_div_id),\
+		},\
+		.ops 		= &clk_stm32_divider_ops,\
+	}
+
+struct clk_stm32_gate_cfg {
+	int id;
+};
+
+#define STM32_GATE(idx, _binding, _parent, _flags, _gate_id) \
+	[(idx)] = (struct clk_stm32){ \
+		.binding	= (_binding),\
+		.parent		=  (_parent),\
+		.flags		= (_flags),\
+		.clock_cfg	= &(struct clk_stm32_gate_cfg){\
+			.id	= (_gate_id),\
+		},\
+		.ops		= &clk_stm32_gate_ops,\
+	}
+
+struct fixed_factor_cfg {
+	unsigned int mult;
+	unsigned int div;
+};
+
+unsigned long fixed_factor_recalc_rate(struct stm32_clk_priv *priv,
+				       int _idx, unsigned long prate);
+
+#define FIXED_FACTOR(idx, _idx, _parent, _mult, _div) \
+	[(idx)] = (struct clk_stm32){ \
+		.binding	= (_idx),\
+		.parent		= (_parent),\
+		.clock_cfg	= &(struct fixed_factor_cfg){\
+			.mult	= (_mult),\
+			.div	= (_div),\
+		},\
+		.ops		= &clk_fixed_factor_ops,\
+	}
+
+#define GATE(idx, _binding, _parent, _flags, _offset, _bit_idx) \
+	[(idx)] = (struct clk_stm32){ \
+		.binding	= (_binding),\
+		.parent		=  (_parent),\
+		.flags		= (_flags),\
+		.clock_cfg	= &(struct clk_gate_cfg){\
+			.offset		= (_offset),\
+			.bit_idx	= (_bit_idx),\
+		},\
+		.ops		= &clk_gate_ops,\
+	}
+
+#define STM32_MUX(idx, _binding, _mux_id, _flags) \
+	[(idx)] = (struct clk_stm32){ \
+		.binding	= (_binding),\
+		.parent		= (MUX(_mux_id)),\
+		.flags		= (_flags),\
+		.clock_cfg	= NULL,\
+		.ops		= (&clk_mux_ops),\
+	}
+
+struct clk_timer_cfg {
+	uint32_t apbdiv;
+	uint32_t timpre;
+};
+
+#define CK_TIMER(idx, _idx, _parent, _flags, _apbdiv, _timpre) \
+	[(idx)] = (struct clk_stm32){ \
+		.binding	= (_idx),\
+		.parent		= (_parent),\
+		.flags		= (CLK_SET_RATE_PARENT | (_flags)),\
+		.clock_cfg	= &(struct clk_timer_cfg){\
+			.apbdiv = (_apbdiv),\
+			.timpre = (_timpre),\
+		},\
+		.ops		= &clk_timer_ops,\
+	}
+
+struct clk_stm32_fixed_rate_cfg {
+	unsigned long rate;
+};
+
+#define CLK_FIXED_RATE(idx, _binding, _rate) \
+	[(idx)] = (struct clk_stm32){ \
+		.binding	= (_binding),\
+		.parent		= (CLK_IS_ROOT),\
+		.clock_cfg	= &(struct clk_stm32_fixed_rate_cfg){\
+			.rate	= (_rate),\
+		},\
+		.ops		= &clk_stm32_fixed_rate_ops,\
+	}
+
+#define BYPASS(_offset, _bit_byp, _bit_digbyp) &(struct stm32_clk_bypass){\
+	.offset		= (_offset),\
+	.bit_byp	= (_bit_byp),\
+	.bit_digbyp	= (_bit_digbyp),\
+}
+
+#define CSS(_offset, _bit_css)	&(struct stm32_clk_css){\
+	.offset		= (_offset),\
+	.bit_css	= (_bit_css),\
+}
+
+#define DRIVE(_offset, _shift, _width, _default) &(struct stm32_clk_drive){\
+	.offset		= (_offset),\
+	.drv_shift	= (_shift),\
+	.drv_width	= (_width),\
+	.drv_default	= (_default),\
+}
+
+#define OSCILLATOR(idx_osc, _id, _name, _gate_id, _gate_rdy_id, _bypass, _css, _drive) \
+	[(idx_osc)] = (struct clk_oscillator_data){\
+		.name		= (_name),\
+		.id_clk		= (_id),\
+		.gate_id	= (_gate_id),\
+		.gate_rdy_id	= (_gate_rdy_id),\
+		.bypass		= (_bypass),\
+		.css		= (_css),\
+		.drive		= (_drive),\
+	}
+
+struct clk_oscillator_data *clk_oscillator_get_data(struct stm32_clk_priv *priv, int id);
+
+void clk_stm32_osc_init(struct stm32_clk_priv *priv, int id);
+bool clk_stm32_osc_gate_is_enabled(struct stm32_clk_priv *priv, int id);
+int clk_stm32_osc_gate_enable(struct stm32_clk_priv *priv, int id);
+void clk_stm32_osc_gate_disable(struct stm32_clk_priv *priv, int id);
+
+struct stm32_osc_cfg {
+	int osc_id;
+};
+
+#define CLK_OSC(idx, _idx, _parent, _osc_id) \
+	[(idx)] = (struct clk_stm32){ \
+		.binding	= (_idx),\
+		.parent		= (_parent),\
+		.flags		= CLK_IS_CRITICAL,\
+		.clock_cfg	= &(struct stm32_osc_cfg){\
+			.osc_id = (_osc_id),\
+		},\
+		.ops		= &clk_stm32_osc_ops,\
+	}
+
+#define CLK_OSC_FIXED(idx, _idx, _parent, _osc_id) \
+	[(idx)] = (struct clk_stm32){ \
+		.binding	= (_idx),\
+		.parent		= (_parent),\
+		.flags		= CLK_IS_CRITICAL,\
+		.clock_cfg	= &(struct stm32_osc_cfg){\
+			.osc_id	= (_osc_id),\
+		},\
+		.ops		= &clk_stm32_osc_nogate_ops,\
+	}
+
+extern const struct stm32_clk_ops clk_mux_ops;
+extern const struct stm32_clk_ops clk_stm32_divider_ops;
+extern const struct stm32_clk_ops clk_stm32_gate_ops;
+extern const struct stm32_clk_ops clk_fixed_factor_ops;
+extern const struct stm32_clk_ops clk_gate_ops;
+extern const struct stm32_clk_ops clk_timer_ops;
+extern const struct stm32_clk_ops clk_stm32_fixed_rate_ops;
+extern const struct stm32_clk_ops clk_stm32_osc_ops;
+extern const struct stm32_clk_ops clk_stm32_osc_nogate_ops;
+
+#endif /* CLK_STM32_CORE_H */
diff --git a/drivers/st/clk/clk-stm32mp13.c b/drivers/st/clk/clk-stm32mp13.c
new file mode 100644
index 000000000..321b1fdc9
--- /dev/null
+++ b/drivers/st/clk/clk-stm32mp13.c
@@ -0,0 +1,2378 @@
+/*
+ * Copyright (C) 2018-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdint.h>
+#include <stdio.h>
+
+#include <libfdt.h>
+
+#include <platform_def.h>
+
+#include <arch.h>
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32mp_clkfunc.h>
+#include <drivers/st/stm32mp1_clk.h>
+#include <drivers/st/stm32mp13_rcc.h>
+#include <dt-bindings/clock/stm32mp13-clksrc.h>
+#include <lib/mmio.h>
+#include <lib/spinlock.h>
+#include <lib/utils_def.h>
+#include <plat/common/platform.h>
+
+#include "clk-stm32-core.h"
+
+struct stm32_osci_dt_cfg {
+	unsigned long freq;
+	bool bypass;
+	bool digbyp;
+	bool css;
+	uint32_t drive;
+};
+
+enum pll_mn {
+	PLL_CFG_M,
+	PLL_CFG_N,
+	PLL_DIV_MN_NB
+};
+
+enum pll_pqr {
+	PLL_CFG_P,
+	PLL_CFG_Q,
+	PLL_CFG_R,
+	PLL_DIV_PQR_NB
+};
+
+enum pll_csg {
+	PLL_CSG_MOD_PER,
+	PLL_CSG_INC_STEP,
+	PLL_CSG_SSCG_MODE,
+	PLL_CSG_NB
+};
+
+struct stm32_pll_vco {
+	uint32_t status;
+	uint32_t src;
+	uint32_t div_mn[PLL_DIV_MN_NB];
+	uint32_t frac;
+	bool csg_enabled;
+	uint32_t csg[PLL_CSG_NB];
+};
+
+struct stm32_pll_output {
+	uint32_t output[PLL_DIV_PQR_NB];
+};
+
+struct stm32_pll_dt_cfg {
+	struct stm32_pll_vco vco;
+	struct stm32_pll_output output;
+};
+
+struct stm32_clk_platdata {
+	uint32_t nosci;
+	struct stm32_osci_dt_cfg *osci;
+	uint32_t npll;
+	struct stm32_pll_dt_cfg *pll;
+	uint32_t nclksrc;
+	uint32_t *clksrc;
+	uint32_t nclkdiv;
+	uint32_t *clkdiv;
+};
+
+enum stm32_clock {
+	/* ROOT CLOCKS */
+	_CK_OFF,
+	_CK_HSI,
+	_CK_HSE,
+	_CK_CSI,
+	_CK_LSI,
+	_CK_LSE,
+	_I2SCKIN,
+	_CSI_DIV122,
+	_HSE_DIV,
+	_HSE_DIV2,
+	_CK_PLL1,
+	_CK_PLL2,
+	_CK_PLL3,
+	_CK_PLL4,
+	_PLL1P,
+	_PLL1P_DIV,
+	_PLL2P,
+	_PLL2Q,
+	_PLL2R,
+	_PLL3P,
+	_PLL3Q,
+	_PLL3R,
+	_PLL4P,
+	_PLL4Q,
+	_PLL4R,
+	_PCLK1,
+	_PCLK2,
+	_PCLK3,
+	_PCLK4,
+	_PCLK5,
+	_PCLK6,
+	_CKMPU,
+	_CKAXI,
+	_CKMLAHB,
+	_CKPER,
+	_CKTIMG1,
+	_CKTIMG2,
+	_CKTIMG3,
+	_USB_PHY_48,
+	_MCO1_K,
+	_MCO2_K,
+	_TRACECK,
+	/* BUS and KERNEL CLOCKS */
+	_DDRC1,
+	_DDRC1LP,
+	_DDRPHYC,
+	_DDRPHYCLP,
+	_DDRCAPB,
+	_DDRCAPBLP,
+	_AXIDCG,
+	_DDRPHYCAPB,
+	_DDRPHYCAPBLP,
+	_SYSCFG,
+	_DDRPERFM,
+	_IWDG2APB,
+	_USBPHY_K,
+	_USBO_K,
+	_RTCAPB,
+	_TZC,
+	_ETZPC,
+	_IWDG1APB,
+	_BSEC,
+	_STGENC,
+	_USART1_K,
+	_USART2_K,
+	_I2C3_K,
+	_I2C4_K,
+	_I2C5_K,
+	_TIM12,
+	_TIM15,
+	_RTCCK,
+	_GPIOA,
+	_GPIOB,
+	_GPIOC,
+	_GPIOD,
+	_GPIOE,
+	_GPIOF,
+	_GPIOG,
+	_GPIOH,
+	_GPIOI,
+	_PKA,
+	_SAES_K,
+	_CRYP1,
+	_HASH1,
+	_RNG1_K,
+	_BKPSRAM,
+	_SDMMC1_K,
+	_SDMMC2_K,
+	_DBGCK,
+	_USART3_K,
+	_UART4_K,
+	_UART5_K,
+	_UART7_K,
+	_UART8_K,
+	_USART6_K,
+	_MCE,
+	_FMC_K,
+	_QSPI_K,
+#if defined(IMAGE_BL32)
+	_LTDC,
+	_DMA1,
+	_DMA2,
+	_MDMA,
+	_ETH1MAC,
+	_USBH,
+	_TIM2,
+	_TIM3,
+	_TIM4,
+	_TIM5,
+	_TIM6,
+	_TIM7,
+	_LPTIM1_K,
+	_SPI2_K,
+	_SPI3_K,
+	_SPDIF_K,
+	_TIM1,
+	_TIM8,
+	_SPI1_K,
+	_SAI1_K,
+	_SAI2_K,
+	_DFSDM,
+	_FDCAN_K,
+	_TIM13,
+	_TIM14,
+	_TIM16,
+	_TIM17,
+	_SPI4_K,
+	_SPI5_K,
+	_I2C1_K,
+	_I2C2_K,
+	_ADFSDM,
+	_LPTIM2_K,
+	_LPTIM3_K,
+	_LPTIM4_K,
+	_LPTIM5_K,
+	_VREF,
+	_DTS,
+	_PMBCTRL,
+	_HDP,
+	_STGENRO,
+	_DCMIPP_K,
+	_DMAMUX1,
+	_DMAMUX2,
+	_DMA3,
+	_ADC1_K,
+	_ADC2_K,
+	_TSC,
+	_AXIMC,
+	_ETH1CK,
+	_ETH1TX,
+	_ETH1RX,
+	_CRC1,
+	_ETH2CK,
+	_ETH2TX,
+	_ETH2RX,
+	_ETH2MAC,
+#endif
+	CK_LAST
+};
+
+/* PARENT CONFIG */
+static const uint16_t RTC_src[] = {
+	 _CK_OFF, _CK_LSE, _CK_LSI, _CK_HSE
+};
+
+static const uint16_t MCO1_src[] = {
+	 _CK_HSI, _CK_HSE, _CK_CSI, _CK_LSI, _CK_LSE
+};
+
+static const uint16_t MCO2_src[] = {
+	 _CKMPU, _CKAXI, _CKMLAHB, _PLL4P, _CK_HSE, _CK_HSI
+};
+
+static const uint16_t PLL12_src[] = {
+	 _CK_HSI, _CK_HSE
+};
+
+static const uint16_t PLL3_src[] = {
+	 _CK_HSI, _CK_HSE, _CK_CSI
+};
+
+static const uint16_t PLL4_src[] = {
+	 _CK_HSI, _CK_HSE, _CK_CSI, _I2SCKIN
+};
+
+static const uint16_t MPU_src[] = {
+	 _CK_HSI, _CK_HSE, _PLL1P, _PLL1P_DIV
+};
+
+static const uint16_t AXI_src[] = {
+	 _CK_HSI, _CK_HSE, _PLL2P
+};
+
+static const uint16_t MLAHBS_src[] = {
+	 _CK_HSI, _CK_HSE, _CK_CSI, _PLL3P
+};
+
+static const uint16_t CKPER_src[] = {
+	 _CK_HSI, _CK_CSI, _CK_HSE, _CK_OFF
+};
+
+static const uint16_t I2C12_src[] = {
+	 _PCLK1, _PLL4R, _CK_HSI, _CK_CSI
+};
+
+static const uint16_t I2C3_src[] = {
+	 _PCLK6, _PLL4R, _CK_HSI, _CK_CSI
+};
+
+static const uint16_t I2C4_src[] = {
+	 _PCLK6, _PLL4R, _CK_HSI, _CK_CSI
+};
+
+static const uint16_t I2C5_src[] = {
+	 _PCLK6, _PLL4R, _CK_HSI, _CK_CSI
+};
+
+static const uint16_t SPI1_src[] = {
+	 _PLL4P, _PLL3Q, _I2SCKIN, _CKPER, _PLL3R
+};
+
+static const uint16_t SPI23_src[] = {
+	 _PLL4P, _PLL3Q, _I2SCKIN, _CKPER, _PLL3R
+};
+
+static const uint16_t SPI4_src[] = {
+	 _PCLK6, _PLL4Q, _CK_HSI, _CK_CSI, _CK_HSE, _I2SCKIN
+};
+
+static const uint16_t SPI5_src[] = {
+	 _PCLK6, _PLL4Q, _CK_HSI, _CK_CSI, _CK_HSE
+};
+
+static const uint16_t UART1_src[] = {
+	 _PCLK6, _PLL3Q, _CK_HSI, _CK_CSI, _PLL4Q, _CK_HSE
+};
+
+static const uint16_t UART2_src[] = {
+	 _PCLK6, _PLL3Q, _CK_HSI, _CK_CSI, _PLL4Q, _CK_HSE
+};
+
+static const uint16_t UART35_src[] = {
+	 _PCLK1, _PLL4Q, _CK_HSI, _CK_CSI, _CK_HSE
+};
+
+static const uint16_t UART4_src[] = {
+	 _PCLK1, _PLL4Q, _CK_HSI, _CK_CSI, _CK_HSE
+};
+
+static const uint16_t UART6_src[] = {
+	 _PCLK2, _PLL4Q, _CK_HSI, _CK_CSI, _CK_HSE
+};
+
+static const uint16_t UART78_src[] = {
+	 _PCLK1, _PLL4Q, _CK_HSI, _CK_CSI, _CK_HSE
+};
+
+static const uint16_t LPTIM1_src[] = {
+	 _PCLK1, _PLL4P, _PLL3Q, _CK_LSE, _CK_LSI, _CKPER
+};
+
+static const uint16_t LPTIM2_src[] = {
+	 _PCLK3, _PLL4Q, _CKPER, _CK_LSE, _CK_LSI
+};
+
+static const uint16_t LPTIM3_src[] = {
+	 _PCLK3, _PLL4Q, _CKPER, _CK_LSE, _CK_LSI
+};
+
+static const uint16_t LPTIM45_src[] = {
+	 _PCLK3, _PLL4P, _PLL3Q, _CK_LSE, _CK_LSI, _CKPER
+};
+
+static const uint16_t SAI1_src[] = {
+	 _PLL4Q, _PLL3Q, _I2SCKIN, _CKPER, _PLL3R
+};
+
+static const uint16_t SAI2_src[] = {
+	 _PLL4Q, _PLL3Q, _I2SCKIN, _CKPER, _NO_ID, _PLL3R
+};
+
+static const uint16_t FDCAN_src[] = {
+	 _CK_HSE, _PLL3Q, _PLL4Q, _PLL4R
+};
+
+static const uint16_t SPDIF_src[] = {
+	 _PLL4P, _PLL3Q, _CK_HSI
+};
+
+static const uint16_t ADC1_src[] = {
+	 _PLL4R, _CKPER, _PLL3Q
+};
+
+static const uint16_t ADC2_src[] = {
+	 _PLL4R, _CKPER, _PLL3Q
+};
+
+static const uint16_t SDMMC1_src[] = {
+	 _CKAXI, _PLL3R, _PLL4P, _CK_HSI
+};
+
+static const uint16_t SDMMC2_src[] = {
+	 _CKAXI, _PLL3R, _PLL4P, _CK_HSI
+};
+
+static const uint16_t ETH1_src[] = {
+	 _PLL4P, _PLL3Q
+};
+
+static const uint16_t ETH2_src[] = {
+	 _PLL4P, _PLL3Q
+};
+
+static const uint16_t USBPHY_src[] = {
+	 _CK_HSE, _PLL4R, _HSE_DIV2
+};
+
+static const uint16_t USBO_src[] = {
+	 _PLL4R, _USB_PHY_48
+};
+
+static const uint16_t QSPI_src[] = {
+	 _CKAXI, _PLL3R, _PLL4P, _CKPER
+};
+
+static const uint16_t FMC_src[] = {
+	 _CKAXI, _PLL3R, _PLL4P, _CKPER
+};
+
+/* Position 2 of RNG1 mux is reserved */
+static const uint16_t RNG1_src[] = {
+	 _CK_CSI, _PLL4R, _CK_OFF, _CK_LSI
+};
+
+static const uint16_t STGEN_src[] = {
+	 _CK_HSI, _CK_HSE
+};
+
+static const uint16_t DCMIPP_src[] = {
+	 _CKAXI, _PLL2Q, _PLL4P, _CKPER
+};
+
+static const uint16_t SAES_src[] = {
+	 _CKAXI, _CKPER, _PLL4R, _CK_LSI
+};
+
+#define MUX_CFG(id, src, _offset, _shift, _witdh)[id] = {\
+	.id_parents	= src,\
+	.num_parents	= ARRAY_SIZE(src),\
+	.mux		= &(struct mux_cfg) {\
+		.offset	= (_offset),\
+		.shift	= (_shift),\
+		.width	= (_witdh),\
+		.bitrdy = MUX_NO_BIT_RDY,\
+	},\
+}
+
+#define MUX_RDY_CFG(id, src, _offset, _shift, _witdh)[id] = {\
+	.id_parents	= src,\
+	.num_parents	= ARRAY_SIZE(src),\
+	.mux		= &(struct mux_cfg) {\
+		.offset	= (_offset),\
+		.shift	= (_shift),\
+		.width	= (_witdh),\
+		.bitrdy = 31,\
+	},\
+}
+
+static const struct parent_cfg parent_mp13[] = {
+	MUX_CFG(MUX_ADC1,	ADC1_src,	RCC_ADC12CKSELR, 0, 2),
+	MUX_CFG(MUX_ADC2,	ADC2_src,	RCC_ADC12CKSELR, 2, 2),
+	MUX_RDY_CFG(MUX_AXI,	AXI_src,	RCC_ASSCKSELR, 0, 3),
+	MUX_CFG(MUX_CKPER,	CKPER_src,	RCC_CPERCKSELR, 0, 2),
+	MUX_CFG(MUX_DCMIPP,	DCMIPP_src,	RCC_DCMIPPCKSELR, 0, 2),
+	MUX_CFG(MUX_ETH1,	ETH1_src,	RCC_ETH12CKSELR, 0, 2),
+	MUX_CFG(MUX_ETH2,	ETH2_src,	RCC_ETH12CKSELR, 8, 2),
+	MUX_CFG(MUX_FDCAN,	FDCAN_src,	RCC_FDCANCKSELR, 0, 2),
+	MUX_CFG(MUX_FMC,	FMC_src,	RCC_FMCCKSELR, 0, 2),
+	MUX_CFG(MUX_I2C12,	I2C12_src,	RCC_I2C12CKSELR, 0, 3),
+	MUX_CFG(MUX_I2C3,	I2C3_src,	RCC_I2C345CKSELR, 0, 3),
+	MUX_CFG(MUX_I2C4,	I2C4_src,	RCC_I2C345CKSELR, 3, 3),
+	MUX_CFG(MUX_I2C5,	I2C5_src,	RCC_I2C345CKSELR, 6, 3),
+	MUX_CFG(MUX_LPTIM1,	LPTIM1_src,	RCC_LPTIM1CKSELR, 0, 3),
+	MUX_CFG(MUX_LPTIM2,	LPTIM2_src,	RCC_LPTIM23CKSELR, 0, 3),
+	MUX_CFG(MUX_LPTIM3,	LPTIM3_src,	RCC_LPTIM23CKSELR, 3, 3),
+	MUX_CFG(MUX_LPTIM45,	LPTIM45_src,	RCC_LPTIM45CKSELR, 0, 3),
+	MUX_CFG(MUX_MCO1,	MCO1_src,	RCC_MCO1CFGR, 0, 3),
+	MUX_CFG(MUX_MCO2,	MCO2_src,	RCC_MCO2CFGR, 0, 3),
+	MUX_RDY_CFG(MUX_MLAHB,	MLAHBS_src,	RCC_MSSCKSELR, 0, 2),
+	MUX_RDY_CFG(MUX_MPU,	MPU_src,	RCC_MPCKSELR, 0, 2),
+	MUX_RDY_CFG(MUX_PLL12,	PLL12_src,	RCC_RCK12SELR, 0, 2),
+	MUX_RDY_CFG(MUX_PLL3,	PLL3_src,	RCC_RCK3SELR, 0, 2),
+	MUX_RDY_CFG(MUX_PLL4,	PLL4_src,	RCC_RCK4SELR, 0, 2),
+	MUX_CFG(MUX_QSPI,	QSPI_src,	RCC_QSPICKSELR, 0, 2),
+	MUX_CFG(MUX_RNG1,	RNG1_src,	RCC_RNG1CKSELR, 0, 2),
+	MUX_CFG(MUX_RTC,	RTC_src,	RCC_BDCR, 16, 2),
+	MUX_CFG(MUX_SAES,	SAES_src,	RCC_SAESCKSELR, 0, 2),
+	MUX_CFG(MUX_SAI1,	SAI1_src,	RCC_SAI1CKSELR, 0, 3),
+	MUX_CFG(MUX_SAI2,	SAI2_src,	RCC_SAI2CKSELR, 0, 3),
+	MUX_CFG(MUX_SDMMC1,	SDMMC1_src,	RCC_SDMMC12CKSELR, 0, 3),
+	MUX_CFG(MUX_SDMMC2,	SDMMC2_src,	RCC_SDMMC12CKSELR, 3, 3),
+	MUX_CFG(MUX_SPDIF,	SPDIF_src,	RCC_SPDIFCKSELR, 0, 2),
+	MUX_CFG(MUX_SPI1,	SPI1_src,	RCC_SPI2S1CKSELR, 0, 3),
+	MUX_CFG(MUX_SPI23,	SPI23_src,	RCC_SPI2S23CKSELR, 0, 3),
+	MUX_CFG(MUX_SPI4,	SPI4_src,	RCC_SPI45CKSELR, 0, 3),
+	MUX_CFG(MUX_SPI5,	SPI5_src,	RCC_SPI45CKSELR, 3, 3),
+	MUX_CFG(MUX_STGEN,	STGEN_src,	RCC_STGENCKSELR, 0, 2),
+	MUX_CFG(MUX_UART1,	UART1_src,	RCC_UART12CKSELR, 0, 3),
+	MUX_CFG(MUX_UART2,	UART2_src,	RCC_UART12CKSELR, 3, 3),
+	MUX_CFG(MUX_UART35,	UART35_src,	RCC_UART35CKSELR, 0, 3),
+	MUX_CFG(MUX_UART4,	UART4_src,	RCC_UART4CKSELR, 0, 3),
+	MUX_CFG(MUX_UART6,	UART6_src,	RCC_UART6CKSELR, 0, 3),
+	MUX_CFG(MUX_UART78,	UART78_src,	RCC_UART78CKSELR, 0, 3),
+	MUX_CFG(MUX_USBO,	USBO_src,	RCC_USBCKSELR, 4, 1),
+	MUX_CFG(MUX_USBPHY,	USBPHY_src,	RCC_USBCKSELR, 0, 2),
+};
+
+/*
+ * GATE CONFIG
+ */
+
+enum enum_gate_cfg {
+	GATE_ZERO, /* reserved for no gate */
+	GATE_LSE,
+	GATE_RTCCK,
+	GATE_LSI,
+	GATE_HSI,
+	GATE_CSI,
+	GATE_HSE,
+	GATE_LSI_RDY,
+	GATE_CSI_RDY,
+	GATE_LSE_RDY,
+	GATE_HSE_RDY,
+	GATE_HSI_RDY,
+	GATE_MCO1,
+	GATE_MCO2,
+	GATE_DBGCK,
+	GATE_TRACECK,
+	GATE_PLL1,
+	GATE_PLL1_DIVP,
+	GATE_PLL1_DIVQ,
+	GATE_PLL1_DIVR,
+	GATE_PLL2,
+	GATE_PLL2_DIVP,
+	GATE_PLL2_DIVQ,
+	GATE_PLL2_DIVR,
+	GATE_PLL3,
+	GATE_PLL3_DIVP,
+	GATE_PLL3_DIVQ,
+	GATE_PLL3_DIVR,
+	GATE_PLL4,
+	GATE_PLL4_DIVP,
+	GATE_PLL4_DIVQ,
+	GATE_PLL4_DIVR,
+	GATE_DDRC1,
+	GATE_DDRC1LP,
+	GATE_DDRPHYC,
+	GATE_DDRPHYCLP,
+	GATE_DDRCAPB,
+	GATE_DDRCAPBLP,
+	GATE_AXIDCG,
+	GATE_DDRPHYCAPB,
+	GATE_DDRPHYCAPBLP,
+	GATE_TIM2,
+	GATE_TIM3,
+	GATE_TIM4,
+	GATE_TIM5,
+	GATE_TIM6,
+	GATE_TIM7,
+	GATE_LPTIM1,
+	GATE_SPI2,
+	GATE_SPI3,
+	GATE_USART3,
+	GATE_UART4,
+	GATE_UART5,
+	GATE_UART7,
+	GATE_UART8,
+	GATE_I2C1,
+	GATE_I2C2,
+	GATE_SPDIF,
+	GATE_TIM1,
+	GATE_TIM8,
+	GATE_SPI1,
+	GATE_USART6,
+	GATE_SAI1,
+	GATE_SAI2,
+	GATE_DFSDM,
+	GATE_ADFSDM,
+	GATE_FDCAN,
+	GATE_LPTIM2,
+	GATE_LPTIM3,
+	GATE_LPTIM4,
+	GATE_LPTIM5,
+	GATE_VREF,
+	GATE_DTS,
+	GATE_PMBCTRL,
+	GATE_HDP,
+	GATE_SYSCFG,
+	GATE_DCMIPP,
+	GATE_DDRPERFM,
+	GATE_IWDG2APB,
+	GATE_USBPHY,
+	GATE_STGENRO,
+	GATE_LTDC,
+	GATE_RTCAPB,
+	GATE_TZC,
+	GATE_ETZPC,
+	GATE_IWDG1APB,
+	GATE_BSEC,
+	GATE_STGENC,
+	GATE_USART1,
+	GATE_USART2,
+	GATE_SPI4,
+	GATE_SPI5,
+	GATE_I2C3,
+	GATE_I2C4,
+	GATE_I2C5,
+	GATE_TIM12,
+	GATE_TIM13,
+	GATE_TIM14,
+	GATE_TIM15,
+	GATE_TIM16,
+	GATE_TIM17,
+	GATE_DMA1,
+	GATE_DMA2,
+	GATE_DMAMUX1,
+	GATE_DMA3,
+	GATE_DMAMUX2,
+	GATE_ADC1,
+	GATE_ADC2,
+	GATE_USBO,
+	GATE_TSC,
+	GATE_GPIOA,
+	GATE_GPIOB,
+	GATE_GPIOC,
+	GATE_GPIOD,
+	GATE_GPIOE,
+	GATE_GPIOF,
+	GATE_GPIOG,
+	GATE_GPIOH,
+	GATE_GPIOI,
+	GATE_PKA,
+	GATE_SAES,
+	GATE_CRYP1,
+	GATE_HASH1,
+	GATE_RNG1,
+	GATE_BKPSRAM,
+	GATE_AXIMC,
+	GATE_MCE,
+	GATE_ETH1CK,
+	GATE_ETH1TX,
+	GATE_ETH1RX,
+	GATE_ETH1MAC,
+	GATE_FMC,
+	GATE_QSPI,
+	GATE_SDMMC1,
+	GATE_SDMMC2,
+	GATE_CRC1,
+	GATE_USBH,
+	GATE_ETH2CK,
+	GATE_ETH2TX,
+	GATE_ETH2RX,
+	GATE_ETH2MAC,
+	GATE_MDMA,
+
+	LAST_GATE
+};
+
+#define GATE_CFG(id, _offset, _bit_idx, _offset_clr)[id] = {\
+	.offset		= (_offset),\
+	.bit_idx	= (_bit_idx),\
+	.set_clr	= (_offset_clr),\
+}
+
+static const struct gate_cfg gates_mp13[LAST_GATE] = {
+	GATE_CFG(GATE_LSE,		RCC_BDCR,	0,	0),
+	GATE_CFG(GATE_RTCCK,		RCC_BDCR,	20,	0),
+	GATE_CFG(GATE_LSI,		RCC_RDLSICR,	0,	0),
+	GATE_CFG(GATE_HSI,		RCC_OCENSETR,	0,	1),
+	GATE_CFG(GATE_CSI,		RCC_OCENSETR,	4,	1),
+	GATE_CFG(GATE_HSE,		RCC_OCENSETR,	8,	1),
+	GATE_CFG(GATE_LSI_RDY,		RCC_RDLSICR,	1,	0),
+	GATE_CFG(GATE_CSI_RDY,		RCC_OCRDYR,	4,	0),
+	GATE_CFG(GATE_LSE_RDY,		RCC_BDCR,	2,	0),
+	GATE_CFG(GATE_HSE_RDY,		RCC_OCRDYR,	8,	0),
+	GATE_CFG(GATE_HSI_RDY,		RCC_OCRDYR,	0,	0),
+	GATE_CFG(GATE_MCO1,		RCC_MCO1CFGR,	12,	0),
+	GATE_CFG(GATE_MCO2,		RCC_MCO2CFGR,	12,	0),
+	GATE_CFG(GATE_DBGCK,		RCC_DBGCFGR,	8,	0),
+	GATE_CFG(GATE_TRACECK,		RCC_DBGCFGR,	9,	0),
+	GATE_CFG(GATE_PLL1,		RCC_PLL1CR,	0,	0),
+	GATE_CFG(GATE_PLL1_DIVP,	RCC_PLL1CR,	4,	0),
+	GATE_CFG(GATE_PLL1_DIVQ,	RCC_PLL1CR,	5,	0),
+	GATE_CFG(GATE_PLL1_DIVR,	RCC_PLL1CR,	6,	0),
+	GATE_CFG(GATE_PLL2,		RCC_PLL2CR,	0,	0),
+	GATE_CFG(GATE_PLL2_DIVP,	RCC_PLL2CR,	4,	0),
+	GATE_CFG(GATE_PLL2_DIVQ,	RCC_PLL2CR,	5,	0),
+	GATE_CFG(GATE_PLL2_DIVR,	RCC_PLL2CR,	6,	0),
+	GATE_CFG(GATE_PLL3,		RCC_PLL3CR,	0,	0),
+	GATE_CFG(GATE_PLL3_DIVP,	RCC_PLL3CR,	4,	0),
+	GATE_CFG(GATE_PLL3_DIVQ,	RCC_PLL3CR,	5,	0),
+	GATE_CFG(GATE_PLL3_DIVR,	RCC_PLL3CR,	6,	0),
+	GATE_CFG(GATE_PLL4,		RCC_PLL4CR,	0,	0),
+	GATE_CFG(GATE_PLL4_DIVP,	RCC_PLL4CR,	4,	0),
+	GATE_CFG(GATE_PLL4_DIVQ,	RCC_PLL4CR,	5,	0),
+	GATE_CFG(GATE_PLL4_DIVR,	RCC_PLL4CR,	6,	0),
+	GATE_CFG(GATE_DDRC1,		RCC_DDRITFCR,	0,	0),
+	GATE_CFG(GATE_DDRC1LP,		RCC_DDRITFCR,	1,	0),
+	GATE_CFG(GATE_DDRPHYC,		RCC_DDRITFCR,	4,	0),
+	GATE_CFG(GATE_DDRPHYCLP,	RCC_DDRITFCR,	5,	0),
+	GATE_CFG(GATE_DDRCAPB,		RCC_DDRITFCR,	6,	0),
+	GATE_CFG(GATE_DDRCAPBLP,	RCC_DDRITFCR,	7,	0),
+	GATE_CFG(GATE_AXIDCG,		RCC_DDRITFCR,	8,	0),
+	GATE_CFG(GATE_DDRPHYCAPB,	RCC_DDRITFCR,	9,	0),
+	GATE_CFG(GATE_DDRPHYCAPBLP,	RCC_DDRITFCR,	10,	0),
+	GATE_CFG(GATE_TIM2,		RCC_MP_APB1ENSETR,	0,	1),
+	GATE_CFG(GATE_TIM3,		RCC_MP_APB1ENSETR,	1,	1),
+	GATE_CFG(GATE_TIM4,		RCC_MP_APB1ENSETR,	2,	1),
+	GATE_CFG(GATE_TIM5,		RCC_MP_APB1ENSETR,	3,	1),
+	GATE_CFG(GATE_TIM6,		RCC_MP_APB1ENSETR,	4,	1),
+	GATE_CFG(GATE_TIM7,		RCC_MP_APB1ENSETR,	5,	1),
+	GATE_CFG(GATE_LPTIM1,		RCC_MP_APB1ENSETR,	9,	1),
+	GATE_CFG(GATE_SPI2,		RCC_MP_APB1ENSETR,	11,	1),
+	GATE_CFG(GATE_SPI3,		RCC_MP_APB1ENSETR,	12,	1),
+	GATE_CFG(GATE_USART3,		RCC_MP_APB1ENSETR,	15,	1),
+	GATE_CFG(GATE_UART4,		RCC_MP_APB1ENSETR,	16,	1),
+	GATE_CFG(GATE_UART5,		RCC_MP_APB1ENSETR,	17,	1),
+	GATE_CFG(GATE_UART7,		RCC_MP_APB1ENSETR,	18,	1),
+	GATE_CFG(GATE_UART8,		RCC_MP_APB1ENSETR,	19,	1),
+	GATE_CFG(GATE_I2C1,		RCC_MP_APB1ENSETR,	21,	1),
+	GATE_CFG(GATE_I2C2,		RCC_MP_APB1ENSETR,	22,	1),
+	GATE_CFG(GATE_SPDIF,		RCC_MP_APB1ENSETR,	26,	1),
+	GATE_CFG(GATE_TIM1,		RCC_MP_APB2ENSETR,	0,	1),
+	GATE_CFG(GATE_TIM8,		RCC_MP_APB2ENSETR,	1,	1),
+	GATE_CFG(GATE_SPI1,		RCC_MP_APB2ENSETR,	8,	1),
+	GATE_CFG(GATE_USART6,		RCC_MP_APB2ENSETR,	13,	1),
+	GATE_CFG(GATE_SAI1,		RCC_MP_APB2ENSETR,	16,	1),
+	GATE_CFG(GATE_SAI2,		RCC_MP_APB2ENSETR,	17,	1),
+	GATE_CFG(GATE_DFSDM,		RCC_MP_APB2ENSETR,	20,	1),
+	GATE_CFG(GATE_ADFSDM,		RCC_MP_APB2ENSETR,	21,	1),
+	GATE_CFG(GATE_FDCAN,		RCC_MP_APB2ENSETR,	24,	1),
+	GATE_CFG(GATE_LPTIM2,		RCC_MP_APB3ENSETR,	0,	1),
+	GATE_CFG(GATE_LPTIM3,		RCC_MP_APB3ENSETR,	1,	1),
+	GATE_CFG(GATE_LPTIM4,		RCC_MP_APB3ENSETR,	2,	1),
+	GATE_CFG(GATE_LPTIM5,		RCC_MP_APB3ENSETR,	3,	1),
+	GATE_CFG(GATE_VREF,		RCC_MP_APB3ENSETR,	13,	1),
+	GATE_CFG(GATE_DTS,		RCC_MP_APB3ENSETR,	16,	1),
+	GATE_CFG(GATE_PMBCTRL,		RCC_MP_APB3ENSETR,	17,	1),
+	GATE_CFG(GATE_HDP,		RCC_MP_APB3ENSETR,	20,	1),
+	GATE_CFG(GATE_SYSCFG,		RCC_MP_S_APB3ENSETR,	0,	1),
+	GATE_CFG(GATE_DCMIPP,		RCC_MP_APB4ENSETR,	1,	1),
+	GATE_CFG(GATE_DDRPERFM,		RCC_MP_APB4ENSETR,	8,	1),
+	GATE_CFG(GATE_IWDG2APB,		RCC_MP_APB4ENSETR,	15,	1),
+	GATE_CFG(GATE_USBPHY,		RCC_MP_APB4ENSETR,	16,	1),
+	GATE_CFG(GATE_STGENRO,		RCC_MP_APB4ENSETR,	20,	1),
+	GATE_CFG(GATE_LTDC,		RCC_MP_S_APB4ENSETR,	0,	1),
+	GATE_CFG(GATE_RTCAPB,		RCC_MP_APB5ENSETR,	8,	1),
+	GATE_CFG(GATE_TZC,		RCC_MP_APB5ENSETR,	11,	1),
+	GATE_CFG(GATE_ETZPC,		RCC_MP_APB5ENSETR,	13,	1),
+	GATE_CFG(GATE_IWDG1APB,		RCC_MP_APB5ENSETR,	15,	1),
+	GATE_CFG(GATE_BSEC,		RCC_MP_APB5ENSETR,	16,	1),
+	GATE_CFG(GATE_STGENC,		RCC_MP_APB5ENSETR,	20,	1),
+	GATE_CFG(GATE_USART1,		RCC_MP_APB6ENSETR,	0,	1),
+	GATE_CFG(GATE_USART2,		RCC_MP_APB6ENSETR,	1,	1),
+	GATE_CFG(GATE_SPI4,		RCC_MP_APB6ENSETR,	2,	1),
+	GATE_CFG(GATE_SPI5,		RCC_MP_APB6ENSETR,	3,	1),
+	GATE_CFG(GATE_I2C3,		RCC_MP_APB6ENSETR,	4,	1),
+	GATE_CFG(GATE_I2C4,		RCC_MP_APB6ENSETR,	5,	1),
+	GATE_CFG(GATE_I2C5,		RCC_MP_APB6ENSETR,	6,	1),
+	GATE_CFG(GATE_TIM12,		RCC_MP_APB6ENSETR,	7,	1),
+	GATE_CFG(GATE_TIM13,		RCC_MP_APB6ENSETR,	8,	1),
+	GATE_CFG(GATE_TIM14,		RCC_MP_APB6ENSETR,	9,	1),
+	GATE_CFG(GATE_TIM15,		RCC_MP_APB6ENSETR,	10,	1),
+	GATE_CFG(GATE_TIM16,		RCC_MP_APB6ENSETR,	11,	1),
+	GATE_CFG(GATE_TIM17,		RCC_MP_APB6ENSETR,	12,	1),
+	GATE_CFG(GATE_DMA1,		RCC_MP_AHB2ENSETR,	0,	1),
+	GATE_CFG(GATE_DMA2,		RCC_MP_AHB2ENSETR,	1,	1),
+	GATE_CFG(GATE_DMAMUX1,		RCC_MP_AHB2ENSETR,	2,	1),
+	GATE_CFG(GATE_DMA3,		RCC_MP_AHB2ENSETR,	3,	1),
+	GATE_CFG(GATE_DMAMUX2,		RCC_MP_AHB2ENSETR,	4,	1),
+	GATE_CFG(GATE_ADC1,		RCC_MP_AHB2ENSETR,	5,	1),
+	GATE_CFG(GATE_ADC2,		RCC_MP_AHB2ENSETR,	6,	1),
+	GATE_CFG(GATE_USBO,		RCC_MP_AHB2ENSETR,	8,	1),
+	GATE_CFG(GATE_TSC,		RCC_MP_AHB4ENSETR,	15,	1),
+
+	GATE_CFG(GATE_GPIOA,		RCC_MP_S_AHB4ENSETR,	0,	1),
+	GATE_CFG(GATE_GPIOB,		RCC_MP_S_AHB4ENSETR,	1,	1),
+	GATE_CFG(GATE_GPIOC,		RCC_MP_S_AHB4ENSETR,	2,	1),
+	GATE_CFG(GATE_GPIOD,		RCC_MP_S_AHB4ENSETR,	3,	1),
+	GATE_CFG(GATE_GPIOE,		RCC_MP_S_AHB4ENSETR,	4,	1),
+	GATE_CFG(GATE_GPIOF,		RCC_MP_S_AHB4ENSETR,	5,	1),
+	GATE_CFG(GATE_GPIOG,		RCC_MP_S_AHB4ENSETR,	6,	1),
+	GATE_CFG(GATE_GPIOH,		RCC_MP_S_AHB4ENSETR,	7,	1),
+	GATE_CFG(GATE_GPIOI,		RCC_MP_S_AHB4ENSETR,	8,	1),
+
+	GATE_CFG(GATE_PKA,		RCC_MP_AHB5ENSETR,	2,	1),
+	GATE_CFG(GATE_SAES,		RCC_MP_AHB5ENSETR,	3,	1),
+	GATE_CFG(GATE_CRYP1,		RCC_MP_AHB5ENSETR,	4,	1),
+	GATE_CFG(GATE_HASH1,		RCC_MP_AHB5ENSETR,	5,	1),
+	GATE_CFG(GATE_RNG1,		RCC_MP_AHB5ENSETR,	6,	1),
+	GATE_CFG(GATE_BKPSRAM,		RCC_MP_AHB5ENSETR,	8,	1),
+	GATE_CFG(GATE_AXIMC,		RCC_MP_AHB5ENSETR,	16,	1),
+	GATE_CFG(GATE_MCE,		RCC_MP_AHB6ENSETR,	1,	1),
+	GATE_CFG(GATE_ETH1CK,		RCC_MP_AHB6ENSETR,	7,	1),
+	GATE_CFG(GATE_ETH1TX,		RCC_MP_AHB6ENSETR,	8,	1),
+	GATE_CFG(GATE_ETH1RX,		RCC_MP_AHB6ENSETR,	9,	1),
+	GATE_CFG(GATE_ETH1MAC,		RCC_MP_AHB6ENSETR,	10,	1),
+	GATE_CFG(GATE_FMC,		RCC_MP_AHB6ENSETR,	12,	1),
+	GATE_CFG(GATE_QSPI,		RCC_MP_AHB6ENSETR,	14,	1),
+	GATE_CFG(GATE_SDMMC1,		RCC_MP_AHB6ENSETR,	16,	1),
+	GATE_CFG(GATE_SDMMC2,		RCC_MP_AHB6ENSETR,	17,	1),
+	GATE_CFG(GATE_CRC1,		RCC_MP_AHB6ENSETR,	20,	1),
+	GATE_CFG(GATE_USBH,		RCC_MP_AHB6ENSETR,	24,	1),
+	GATE_CFG(GATE_ETH2CK,		RCC_MP_AHB6ENSETR,	27,	1),
+	GATE_CFG(GATE_ETH2TX,		RCC_MP_AHB6ENSETR,	28,	1),
+	GATE_CFG(GATE_ETH2RX,		RCC_MP_AHB6ENSETR,	29,	1),
+	GATE_CFG(GATE_ETH2MAC,		RCC_MP_AHB6ENSETR,	30,	1),
+	GATE_CFG(GATE_MDMA,		RCC_MP_S_AHB6ENSETR,	0,	1),
+};
+
+/*
+ * DIV CONFIG
+ */
+
+static const struct clk_div_table axi_div_table[] = {
+	{ 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 4 },
+	{ 4, 4 }, { 5, 4 }, { 6, 4 }, { 7, 4 },
+	{ 0 },
+};
+
+static const struct clk_div_table mlahb_div_table[] = {
+	{ 0, 1 }, { 1, 2 }, { 2, 4 }, { 3, 8 },
+	{ 4, 16 }, { 5, 32 }, { 6, 64 }, { 7, 128 },
+	{ 8, 256 }, { 9, 512 }, { 10, 512}, { 11, 512 },
+	{ 12, 512 }, { 13, 512 }, { 14, 512}, { 15, 512 },
+	{ 0 },
+};
+
+static const struct clk_div_table apb_div_table[] = {
+	{ 0, 1 }, { 1, 2 }, { 2, 4 }, { 3, 8 },
+	{ 4, 16 }, { 5, 16 }, { 6, 16 }, { 7, 16 },
+	{ 0 },
+};
+
+#define DIV_CFG(id, _offset, _shift, _width, _flags, _table, _bitrdy)[id] = {\
+		.offset	= _offset,\
+		.shift	= _shift,\
+		.width	= _width,\
+		.flags	= _flags,\
+		.table	= _table,\
+		.bitrdy	= _bitrdy,\
+}
+
+static const struct div_cfg dividers_mp13[] = {
+	DIV_CFG(DIV_PLL1DIVP, RCC_PLL1CFGR2, 0, 7, 0, NULL, DIV_NO_BIT_RDY),
+	DIV_CFG(DIV_PLL2DIVP, RCC_PLL2CFGR2, 0, 7, 0, NULL, DIV_NO_BIT_RDY),
+	DIV_CFG(DIV_PLL2DIVQ, RCC_PLL2CFGR2, 8, 7, 0, NULL, DIV_NO_BIT_RDY),
+	DIV_CFG(DIV_PLL2DIVR, RCC_PLL2CFGR2, 16, 7, 0, NULL, DIV_NO_BIT_RDY),
+	DIV_CFG(DIV_PLL3DIVP, RCC_PLL3CFGR2, 0, 7, 0, NULL, DIV_NO_BIT_RDY),
+	DIV_CFG(DIV_PLL3DIVQ, RCC_PLL3CFGR2, 8, 7, 0, NULL, DIV_NO_BIT_RDY),
+	DIV_CFG(DIV_PLL3DIVR, RCC_PLL3CFGR2, 16, 7, 0, NULL, DIV_NO_BIT_RDY),
+	DIV_CFG(DIV_PLL4DIVP, RCC_PLL4CFGR2, 0, 7, 0, NULL, DIV_NO_BIT_RDY),
+	DIV_CFG(DIV_PLL4DIVQ, RCC_PLL4CFGR2, 8, 7, 0, NULL, DIV_NO_BIT_RDY),
+	DIV_CFG(DIV_PLL4DIVR, RCC_PLL4CFGR2, 16, 7, 0, NULL, DIV_NO_BIT_RDY),
+	DIV_CFG(DIV_MPU, RCC_MPCKDIVR, 0, 4, 0, NULL, DIV_NO_BIT_RDY),
+	DIV_CFG(DIV_AXI, RCC_AXIDIVR, 0, 3, 0, axi_div_table, 31),
+	DIV_CFG(DIV_MLAHB, RCC_MLAHBDIVR, 0, 4, 0, mlahb_div_table, 31),
+	DIV_CFG(DIV_APB1, RCC_APB1DIVR, 0, 3, 0, apb_div_table, 31),
+	DIV_CFG(DIV_APB2, RCC_APB2DIVR, 0, 3, 0, apb_div_table, 31),
+	DIV_CFG(DIV_APB3, RCC_APB3DIVR, 0, 3, 0, apb_div_table, 31),
+	DIV_CFG(DIV_APB4, RCC_APB4DIVR, 0, 3, 0, apb_div_table, 31),
+	DIV_CFG(DIV_APB5, RCC_APB5DIVR, 0, 3, 0, apb_div_table, 31),
+	DIV_CFG(DIV_APB6, RCC_APB6DIVR, 0, 3, 0, apb_div_table, 31),
+	DIV_CFG(DIV_RTC, RCC_RTCDIVR, 0, 6, 0, NULL, DIV_NO_BIT_RDY),
+	DIV_CFG(DIV_MCO1, RCC_MCO1CFGR, 4, 4, 0, NULL, DIV_NO_BIT_RDY),
+	DIV_CFG(DIV_MCO2, RCC_MCO2CFGR, 4, 4, 0, NULL, DIV_NO_BIT_RDY),
+
+	DIV_CFG(DIV_HSI, RCC_HSICFGR, 0, 2, CLK_DIVIDER_POWER_OF_TWO, NULL, DIV_NO_BIT_RDY),
+	DIV_CFG(DIV_TRACE, RCC_DBGCFGR, 0, 3, CLK_DIVIDER_POWER_OF_TWO, NULL, DIV_NO_BIT_RDY),
+
+	DIV_CFG(DIV_ETH1PTP, RCC_ETH12CKSELR, 4, 4, 0, NULL, DIV_NO_BIT_RDY),
+	DIV_CFG(DIV_ETH2PTP, RCC_ETH12CKSELR, 12, 4, 0, NULL, DIV_NO_BIT_RDY),
+};
+
+#define MAX_HSI_HZ		64000000
+#define USB_PHY_48_MHZ		48000000
+
+#define TIMEOUT_US_200MS	U(200000)
+#define TIMEOUT_US_1S		U(1000000)
+
+#define PLLRDY_TIMEOUT		TIMEOUT_US_200MS
+#define CLKSRC_TIMEOUT		TIMEOUT_US_200MS
+#define CLKDIV_TIMEOUT		TIMEOUT_US_200MS
+#define HSIDIV_TIMEOUT		TIMEOUT_US_200MS
+#define OSCRDY_TIMEOUT		TIMEOUT_US_1S
+
+enum stm32_osc {
+	OSC_HSI,
+	OSC_HSE,
+	OSC_CSI,
+	OSC_LSI,
+	OSC_LSE,
+	OSC_I2SCKIN,
+	NB_OSCILLATOR
+};
+
+enum stm32mp1_pll_id {
+	_PLL1,
+	_PLL2,
+	_PLL3,
+	_PLL4,
+	_PLL_NB
+};
+
+enum stm32mp1_plltype {
+	PLL_800,
+	PLL_1600,
+	PLL_2000,
+	PLL_TYPE_NB
+};
+
+#define RCC_OFFSET_PLLXCR		0
+#define RCC_OFFSET_PLLXCFGR1		4
+#define RCC_OFFSET_PLLXCFGR2		8
+#define RCC_OFFSET_PLLXFRACR		12
+#define RCC_OFFSET_PLLXCSGR		16
+
+struct stm32_clk_pll {
+	enum stm32mp1_plltype plltype;
+	uint16_t clk_id;
+	uint16_t reg_pllxcr;
+};
+
+struct stm32mp1_pll {
+	uint8_t refclk_min;
+	uint8_t refclk_max;
+};
+
+/* Define characteristic of PLL according type */
+static const struct stm32mp1_pll stm32mp1_pll[PLL_TYPE_NB] = {
+	[PLL_800] = {
+		.refclk_min = 4,
+		.refclk_max = 16,
+	},
+	[PLL_1600] = {
+		.refclk_min = 8,
+		.refclk_max = 16,
+	},
+	[PLL_2000] = {
+		.refclk_min = 8,
+		.refclk_max = 16,
+	},
+};
+
+#if STM32MP_USB_PROGRAMMER
+static bool pll4_bootrom;
+#endif
+
+/* RCC clock device driver private */
+static unsigned int refcounts_mp13[CK_LAST];
+
+static const struct stm32_clk_pll *clk_st32_pll_data(unsigned int idx);
+
+void stm32mp1_clk_force_enable(unsigned long id)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	int idx = clk_get_index(priv, id);
+
+	if (!_stm32_clk_is_flags(priv, idx, CLK_IS_CRITICAL)) {
+		_clk_stm32_enable(priv, idx);
+	}
+}
+
+void stm32mp1_clk_force_disable(unsigned long id)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	int idx = clk_get_index(priv, id);
+
+	if (!_stm32_clk_is_flags(priv, idx, CLK_IS_CRITICAL)) {
+		_clk_stm32_disable(priv, idx);
+	}
+}
+
+#if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
+static void clk_oscillator_check_bypass(struct stm32_clk_priv *priv, int idx,
+					bool digbyp, bool bypass)
+{
+	struct clk_oscillator_data *osc_data = clk_oscillator_get_data(priv, idx);
+	struct stm32_clk_bypass *bypass_data = osc_data->bypass;
+	uintptr_t address;
+
+	if (bypass_data == NULL) {
+		return;
+	}
+
+	address = priv->base + bypass_data->offset;
+	if ((mmio_read_32(address) & RCC_OCENR_HSEBYP) &&
+	    (!(digbyp || bypass))) {
+		panic();
+	}
+}
+#endif
+
+static void stm32_enable_oscillator_hse(struct stm32_clk_priv *priv)
+{
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	struct stm32_osci_dt_cfg *osci = &pdata->osci[OSC_HSE];
+	bool digbyp =  osci->digbyp;
+	bool bypass = osci->bypass;
+	bool css = osci->css;
+
+	if (_clk_stm32_get_rate(priv, _CK_HSE) == 0U) {
+		return;
+	}
+
+	clk_oscillator_set_bypass(priv, _CK_HSE, digbyp, bypass);
+
+	_clk_stm32_enable(priv, _CK_HSE);
+
+#if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
+	clk_oscillator_check_bypass(priv, _CK_HSE, digbyp, bypass);
+#endif
+
+	clk_oscillator_set_css(priv, _CK_HSE, css);
+}
+
+static void stm32_enable_oscillator_lse(struct stm32_clk_priv *priv)
+{
+	struct clk_oscillator_data *osc_data = clk_oscillator_get_data(priv, _CK_LSE);
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	struct stm32_osci_dt_cfg *osci = &pdata->osci[OSC_LSE];
+	bool digbyp =  osci->digbyp;
+	bool bypass = osci->bypass;
+	uint8_t drive = osci->drive;
+
+	if (_clk_stm32_get_rate(priv, _CK_LSE) == 0U) {
+		return;
+	}
+
+	/* Do not reconfigure LSE if already enabled */
+	if (_clk_stm32_gate_is_enabled(priv, osc_data->gate_id)) {
+		return;
+	}
+
+	clk_oscillator_set_bypass(priv, _CK_LSE, digbyp, bypass);
+
+	clk_oscillator_set_drive(priv, _CK_LSE, drive);
+
+	_clk_stm32_gate_enable(priv, osc_data->gate_id);
+}
+
+static int stm32mp1_set_hsidiv(uint8_t hsidiv)
+{
+	uint64_t timeout;
+	uintptr_t rcc_base = stm32mp_rcc_base();
+	uintptr_t address = rcc_base + RCC_OCRDYR;
+
+	mmio_clrsetbits_32(rcc_base + RCC_HSICFGR,
+			   RCC_HSICFGR_HSIDIV_MASK,
+			   RCC_HSICFGR_HSIDIV_MASK & (uint32_t)hsidiv);
+
+	timeout = timeout_init_us(HSIDIV_TIMEOUT);
+	while ((mmio_read_32(address) & RCC_OCRDYR_HSIDIVRDY) == 0U) {
+		if (timeout_elapsed(timeout)) {
+			ERROR("HSIDIV failed @ 0x%lx: 0x%x\n",
+			      address, mmio_read_32(address));
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32mp1_hsidiv(unsigned long hsifreq)
+{
+	uint8_t hsidiv;
+	uint32_t hsidivfreq = MAX_HSI_HZ;
+
+	for (hsidiv = 0; hsidiv < 4U; hsidiv++) {
+		if (hsidivfreq == hsifreq) {
+			break;
+		}
+
+		hsidivfreq /= 2U;
+	}
+
+	if (hsidiv == 4U) {
+		ERROR("Invalid clk-hsi frequency\n");
+		return -1;
+	}
+
+	if (hsidiv != 0U) {
+		return stm32mp1_set_hsidiv(hsidiv);
+	}
+
+	return 0;
+}
+
+static int stm32_clk_oscillators_lse_set_css(struct stm32_clk_priv *priv)
+{
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	struct stm32_osci_dt_cfg *osci = &pdata->osci[OSC_LSE];
+
+	clk_oscillator_set_css(priv, _CK_LSE, osci->css);
+
+	return 0;
+}
+
+/*******************************************************************************
+ * This function determines the number of needed RTC calendar read operations
+ * to get consistent values (1 or 2 depending on clock frequencies).
+ * If APB1 frequency is lower than 7 times the RTC one, the software has to
+ * read the calendar time and date registers twice.
+ * Returns true if read twice is needed, false else.
+ ******************************************************************************/
+bool stm32mp1_rtc_get_read_twice(void)
+{
+	unsigned long apb1_freq;
+	unsigned long rtc_freq;
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+
+	rtc_freq = _clk_stm32_get_rate(priv, _RTCCK);
+	apb1_freq = _clk_stm32_get_rate(priv, _PCLK1);
+
+	return apb1_freq < (rtc_freq * 7U);
+}
+
+static int stm32mp1_come_back_to_hsi(void)
+{
+	int ret;
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+
+	/* Come back to HSI */
+	ret = _clk_stm32_set_parent(priv, _CKMPU, _CK_HSI);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = _clk_stm32_set_parent(priv, _CKAXI, _CK_HSI);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = _clk_stm32_set_parent(priv, _CKMLAHB, _CK_HSI);
+	if (ret != 0) {
+		return ret;
+	}
+
+	return 0;
+}
+
+int stm32_clk_configure_clk_get_binding_id(struct stm32_clk_priv *priv, uint32_t data)
+{
+	unsigned long binding_id = ((unsigned long)data & CLK_ID_MASK) >> CLK_ID_SHIFT;
+
+	return clk_get_index(priv, binding_id);
+}
+
+static int stm32_clk_configure_clk(struct stm32_clk_priv *priv, uint32_t data)
+{
+	int sel = (data & CLK_SEL_MASK) >> CLK_SEL_SHIFT;
+	int enable = (data & CLK_ON_MASK) >> CLK_ON_SHIFT;
+	int clk_id;
+	int ret;
+
+	clk_id = stm32_clk_configure_clk_get_binding_id(priv, data);
+	if (clk_id < 0) {
+		return clk_id;
+	}
+
+	ret = _clk_stm32_set_parent_by_index(priv, clk_id, sel);
+	if (ret != 0) {
+		return ret;
+	}
+
+	if (enable) {
+		clk_stm32_enable_call_ops(priv, clk_id);
+	} else {
+		clk_stm32_disable_call_ops(priv, clk_id);
+	}
+
+	return 0;
+}
+
+int stm32_clk_configure_mux(struct stm32_clk_priv *priv, uint32_t data)
+{
+	int mux = (data & MUX_ID_MASK) >> MUX_ID_SHIFT;
+	int sel = (data & MUX_SEL_MASK) >> MUX_SEL_SHIFT;
+
+	return clk_mux_set_parent(priv, mux, sel);
+}
+
+static int stm32_clk_dividers_configure(struct stm32_clk_priv *priv)
+{
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	uint32_t i;
+
+	for (i = 0; i < pdata->nclkdiv; i++) {
+		int div_id, div_n;
+		int val;
+		int ret;
+
+		val = pdata->clkdiv[i] & CMD_DATA_MASK;
+		div_id = (val & DIV_ID_MASK) >> DIV_ID_SHIFT;
+		div_n = (val & DIV_DIVN_MASK) >> DIV_DIVN_SHIFT;
+
+		ret = clk_stm32_set_div(priv, div_id, div_n);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_clk_source_configure(struct stm32_clk_priv *priv)
+{
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	bool ckper_disabled = false;
+	int clk_id;
+	int ret;
+	uint32_t i;
+
+	for (i = 0; i < pdata->nclksrc; i++) {
+		uint32_t val = pdata->clksrc[i];
+		uint32_t cmd, cmd_data;
+
+		if (val == (uint32_t)CLK_CKPER_DISABLED) {
+			ckper_disabled = true;
+			continue;
+		}
+
+		if (val == (uint32_t)CLK_RTC_DISABLED) {
+			continue;
+		}
+
+		cmd = (val & CMD_MASK) >> CMD_SHIFT;
+		cmd_data = val & ~CMD_MASK;
+
+		switch (cmd) {
+		case CMD_MUX:
+			ret = stm32_clk_configure_mux(priv, cmd_data);
+			break;
+
+		case CMD_CLK:
+			clk_id = stm32_clk_configure_clk_get_binding_id(priv, cmd_data);
+
+			if (clk_id == _RTCCK) {
+				if ((_clk_stm32_is_enabled(priv, _RTCCK) == true)) {
+					continue;
+				}
+			}
+
+			ret = stm32_clk_configure_clk(priv, cmd_data);
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	/*
+	 * CKPER is source for some peripheral clocks
+	 * (FMC-NAND / QPSI-NOR) and switching source is allowed
+	 * only if previous clock is still ON
+	 * => deactivate CKPER only after switching clock
+	 */
+	if (ckper_disabled) {
+		ret = stm32_clk_configure_mux(priv, CLK_CKPER_DISABLED & CMD_MASK);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_clk_stgen_configure(struct stm32_clk_priv *priv, int id)
+{
+	unsigned long stgen_freq;
+
+	stgen_freq = _clk_stm32_get_rate(priv, id);
+
+	stm32mp_stgen_config(stgen_freq);
+
+	return 0;
+}
+
+#define CLK_PLL_CFG(_idx, _clk_id, _type, _reg)\
+	[(_idx)] = {\
+		.clk_id = (_clk_id),\
+		.plltype = (_type),\
+		.reg_pllxcr = (_reg),\
+	}
+
+static int clk_stm32_pll_compute_cfgr1(struct stm32_clk_priv *priv,
+				       const struct stm32_clk_pll *pll,
+				       struct stm32_pll_vco *vco,
+				       uint32_t *value)
+{
+	uint32_t divm = vco->div_mn[PLL_CFG_M];
+	uint32_t divn = vco->div_mn[PLL_CFG_N];
+	unsigned long prate = 0UL;
+	unsigned long refclk = 0UL;
+
+	prate = _clk_stm32_get_parent_rate(priv, pll->clk_id);
+	refclk = prate / (divm + 1U);
+
+	if ((refclk < (stm32mp1_pll[pll->plltype].refclk_min * 1000000U)) ||
+	    (refclk > (stm32mp1_pll[pll->plltype].refclk_max * 1000000U))) {
+		return -1;
+	}
+
+	*value = 0;
+
+	if ((pll->plltype == PLL_800) && (refclk >= 8000000U)) {
+		*value = 1U << RCC_PLLNCFGR1_IFRGE_SHIFT;
+	}
+
+	*value |= (divn << RCC_PLLNCFGR1_DIVN_SHIFT) & RCC_PLLNCFGR1_DIVN_MASK;
+	*value |= (divm << RCC_PLLNCFGR1_DIVM_SHIFT) & RCC_PLLNCFGR1_DIVM_MASK;
+
+	return 0;
+}
+
+static uint32_t  clk_stm32_pll_compute_cfgr2(struct stm32_pll_output *out)
+{
+	uint32_t value = 0;
+
+	value |= (out->output[PLL_CFG_P] << RCC_PLLNCFGR2_DIVP_SHIFT) & RCC_PLLNCFGR2_DIVP_MASK;
+	value |= (out->output[PLL_CFG_Q] << RCC_PLLNCFGR2_DIVQ_SHIFT) & RCC_PLLNCFGR2_DIVQ_MASK;
+	value |= (out->output[PLL_CFG_R] << RCC_PLLNCFGR2_DIVR_SHIFT) & RCC_PLLNCFGR2_DIVR_MASK;
+
+	return value;
+}
+
+static void clk_stm32_pll_config_vco(struct stm32_clk_priv *priv,
+				     const struct stm32_clk_pll *pll,
+				     struct stm32_pll_vco *vco)
+{
+	uintptr_t pll_base = priv->base + pll->reg_pllxcr;
+	uint32_t value = 0;
+
+	if (clk_stm32_pll_compute_cfgr1(priv, pll, vco, &value) != 0) {
+		ERROR("Invalid Vref clock !\n");
+		panic();
+	}
+
+	/* Write N / M / IFREGE fields */
+	mmio_write_32(pll_base + RCC_OFFSET_PLLXCFGR1, value);
+
+	/* Fractional configuration */
+	mmio_write_32(pll_base + RCC_OFFSET_PLLXFRACR, 0);
+
+	/* Frac must be enabled only once its configuration is loaded */
+	mmio_write_32(pll_base + RCC_OFFSET_PLLXFRACR, vco->frac << RCC_PLLNFRACR_FRACV_SHIFT);
+	mmio_setbits_32(pll_base + RCC_OFFSET_PLLXFRACR, RCC_PLLNFRACR_FRACLE);
+}
+
+static void clk_stm32_pll_config_csg(struct stm32_clk_priv *priv,
+				     const struct stm32_clk_pll *pll,
+				     struct stm32_pll_vco *vco)
+{
+	uintptr_t pll_base = priv->base + pll->reg_pllxcr;
+	uint32_t mod_per = 0;
+	uint32_t inc_step = 0;
+	uint32_t sscg_mode = 0;
+	uint32_t value = 0;
+
+	if (!vco->csg_enabled) {
+		return;
+	}
+
+	mod_per = vco->csg[PLL_CSG_MOD_PER];
+	inc_step = vco->csg[PLL_CSG_INC_STEP];
+	sscg_mode = vco->csg[PLL_CSG_SSCG_MODE];
+
+	value |= (mod_per << RCC_PLLNCSGR_MOD_PER_SHIFT) & RCC_PLLNCSGR_MOD_PER_MASK;
+	value |= (inc_step << RCC_PLLNCSGR_INC_STEP_SHIFT) & RCC_PLLNCSGR_INC_STEP_MASK;
+	value |= (sscg_mode << RCC_PLLNCSGR_SSCG_MODE_SHIFT) & RCC_PLLNCSGR_SSCG_MODE_MASK;
+
+	mmio_write_32(pll_base + RCC_OFFSET_PLLXCSGR, value);
+	mmio_setbits_32(pll_base+ RCC_OFFSET_PLLXCR, RCC_PLLNCR_SSCG_CTRL);
+}
+
+static void clk_stm32_pll_config_out(struct stm32_clk_priv *priv, const struct stm32_clk_pll *pll,
+				     struct stm32_pll_output *out)
+{
+	uintptr_t pll_base = priv->base + pll->reg_pllxcr;
+	uint32_t value = 0;
+
+	value = clk_stm32_pll_compute_cfgr2(out);
+
+	mmio_write_32(pll_base + RCC_OFFSET_PLLXCFGR2, value);
+}
+
+static inline struct stm32_pll_dt_cfg *clk_stm32_pll_get_pdata(int pll_idx)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	struct stm32_clk_platdata *pdata = priv->pdata;
+
+	return &pdata->pll[pll_idx];
+}
+
+static bool _clk_stm32_pll_is_enabled(struct stm32_clk_priv *priv, const struct stm32_clk_pll *pll)
+{
+	uintptr_t pll_base = priv->base + pll->reg_pllxcr;
+
+	return ((mmio_read_32(pll_base) & RCC_PLLNCR_PLLON) != 0U);
+}
+
+static void _clk_stm32_pll_set_on(struct stm32_clk_priv *priv, const struct stm32_clk_pll *pll)
+{
+	uintptr_t pll_base = priv->base + pll->reg_pllxcr;
+
+	/* Preserve RCC_PLLNCR_SSCG_CTRL value */
+	mmio_clrsetbits_32(pll_base, RCC_PLLNCR_DIVPEN | RCC_PLLNCR_DIVQEN | RCC_PLLNCR_DIVREN,
+			RCC_PLLNCR_PLLON);
+}
+
+static void _clk_stm32_pll_set_off(struct stm32_clk_priv *priv, const struct stm32_clk_pll *pll)
+{
+	uintptr_t pll_base = priv->base + pll->reg_pllxcr;
+
+	/* Stop all output */
+	mmio_clrbits_32(pll_base, RCC_PLLNCR_DIVPEN | RCC_PLLNCR_DIVQEN | RCC_PLLNCR_DIVREN);
+
+	/* Stop PLL */
+	mmio_clrbits_32(pll_base, RCC_PLLNCR_PLLON);
+}
+
+static int _clk_stm32_pll_wait_ready_on(struct stm32_clk_priv *priv,
+					const struct stm32_clk_pll *pll)
+{
+	uintptr_t pll_base = priv->base + pll->reg_pllxcr;
+	uint64_t timeout = timeout_init_us(PLLRDY_TIMEOUT);
+
+	/* Wait PLL lock */
+	while ((mmio_read_32(pll_base) & RCC_PLLNCR_PLLRDY) == 0U) {
+		if (timeout_elapsed(timeout)) {
+			ERROR("%d clock start failed @ 0x%x: 0x%x\n",
+			       pll->clk_id, pll->reg_pllxcr, mmio_read_32(pll_base));
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int _clk_stm32_pll_wait_ready_off(struct stm32_clk_priv *priv,
+					 const struct stm32_clk_pll *pll)
+{
+	uintptr_t pll_base = priv->base + pll->reg_pllxcr;
+	uint64_t timeout = timeout_init_us(PLLRDY_TIMEOUT);
+
+	/* Wait PLL lock */
+	while ((mmio_read_32(pll_base) & RCC_PLLNCR_PLLRDY) != 0U) {
+		if (timeout_elapsed(timeout)) {
+			ERROR("%d clock stop failed @ 0x%x: 0x%x\n",
+			       pll->clk_id, pll->reg_pllxcr, mmio_read_32(pll_base));
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int _clk_stm32_pll_enable(struct stm32_clk_priv *priv, const struct stm32_clk_pll *pll)
+{
+	if (_clk_stm32_pll_is_enabled(priv, pll)) {
+		return 0;
+	}
+
+	/* Preserve RCC_PLLNCR_SSCG_CTRL value */
+	_clk_stm32_pll_set_on(priv, pll);
+
+	/* Wait PLL lock */
+	return _clk_stm32_pll_wait_ready_on(priv, pll);
+}
+
+static void _clk_stm32_pll_disable(struct stm32_clk_priv *priv, const struct stm32_clk_pll *pll)
+{
+	if (!_clk_stm32_pll_is_enabled(priv, pll)) {
+		return;
+	}
+
+	/* Stop all ouput and the PLL */
+	_clk_stm32_pll_set_off(priv, pll);
+
+	/* Wait PLL stopped */
+	_clk_stm32_pll_wait_ready_off(priv, pll);
+}
+
+static int _clk_stm32_pll_init(struct stm32_clk_priv *priv, int pll_idx,
+			       struct stm32_pll_dt_cfg *pll_conf)
+{
+	const struct stm32_clk_pll *pll = clk_st32_pll_data(pll_idx);
+	uintptr_t pll_base = priv->base + pll->reg_pllxcr;
+	int ret = 0;
+
+	/* Configure PLLs source */
+	ret = stm32_clk_configure_mux(priv, pll_conf->vco.src);
+	if (ret) {
+		return ret;
+	}
+
+#if STM32MP_USB_PROGRAMMER
+	if ((pll_idx == _PLL4) && pll4_bootrom) {
+		clk_stm32_pll_config_out(priv, pll, &pll_conf->output);
+
+		mmio_setbits_32(pll_base, RCC_PLLNCR_DIVPEN | RCC_PLLNCR_DIVQEN|
+				RCC_PLLNCR_DIVREN);
+
+		return 0;
+	}
+#endif
+	/* Stop the PLL before */
+	_clk_stm32_pll_disable(priv, pll);
+
+	clk_stm32_pll_config_vco(priv, pll, &pll_conf->vco);
+	clk_stm32_pll_config_out(priv, pll, &pll_conf->output);
+	clk_stm32_pll_config_csg(priv, pll, &pll_conf->vco);
+
+	ret = _clk_stm32_pll_enable(priv, pll);
+	if (ret != 0) {
+		return ret;
+	}
+
+	mmio_setbits_32(pll_base, RCC_PLLNCR_DIVPEN | RCC_PLLNCR_DIVQEN | RCC_PLLNCR_DIVREN);
+
+	return 0;
+}
+
+static int clk_stm32_pll_init(struct stm32_clk_priv *priv, int pll_idx)
+{
+	struct stm32_pll_dt_cfg *pll_conf = clk_stm32_pll_get_pdata(pll_idx);
+
+	if (pll_conf->vco.status) {
+		return _clk_stm32_pll_init(priv, pll_idx, pll_conf);
+	}
+
+	return 0;
+}
+
+static int stm32_clk_pll_configure(struct stm32_clk_priv *priv)
+{
+	int err = 0;
+
+	err = clk_stm32_pll_init(priv, _PLL1);
+	if (err) {
+		return err;
+	}
+
+	err = clk_stm32_pll_init(priv, _PLL2);
+	if (err) {
+		return err;
+	}
+
+	err = clk_stm32_pll_init(priv, _PLL3);
+	if (err) {
+		return err;
+	}
+
+	err = clk_stm32_pll_init(priv, _PLL4);
+	if (err) {
+		return err;
+	}
+
+	return 0;
+}
+
+static int stm32_clk_oscillators_wait_lse_ready(struct stm32_clk_priv *priv)
+{
+	int ret = 0;
+
+	if (_clk_stm32_get_rate(priv, _CK_LSE) != 0U) {
+		ret = clk_oscillator_wait_ready_on(priv, _CK_LSE);
+	}
+
+	return ret;
+}
+
+static void stm32_clk_oscillators_enable(struct stm32_clk_priv *priv)
+{
+	stm32_enable_oscillator_hse(priv);
+	stm32_enable_oscillator_lse(priv);
+	_clk_stm32_enable(priv, _CK_LSI);
+	_clk_stm32_enable(priv, _CK_CSI);
+}
+
+static int stm32_clk_hsidiv_configure(struct stm32_clk_priv *priv)
+{
+	return stm32mp1_hsidiv(_clk_stm32_get_rate(priv, _CK_HSI));
+}
+
+#if STM32MP_USB_PROGRAMMER
+static bool stm32mp1_clk_is_pll4_used_by_bootrom(struct stm32_clk_priv *priv, int usbphy_p)
+{
+	/* Don't initialize PLL4, when used by BOOTROM */
+	if ((stm32mp_get_boot_itf_selected() ==
+	     BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB) &&
+	    (usbphy_p == _PLL4R)) {
+		return true;
+	}
+
+	return false;
+}
+
+static int stm32mp1_clk_check_usb_conflict(struct stm32_clk_priv *priv, int usbphy_p, int usbo_p)
+{
+	int _usbo_p;
+	int _usbphy_p;
+
+	if (!pll4_bootrom) {
+		return 0;
+	}
+
+	_usbo_p = _clk_stm32_get_parent(priv, _USBO_K);
+	_usbphy_p = _clk_stm32_get_parent(priv, _USBPHY_K);
+
+	if ((_usbo_p != usbo_p) || (_usbphy_p != usbphy_p)) {
+		return -FDT_ERR_BADVALUE;
+	}
+
+	return 0;
+}
+#endif
+
+static struct clk_oscillator_data stm32mp13_osc_data[NB_OSCILLATOR] = {
+	OSCILLATOR(OSC_HSI, _CK_HSI, "clk-hsi", GATE_HSI, GATE_HSI_RDY,
+		   NULL, NULL, NULL),
+
+	OSCILLATOR(OSC_LSI, _CK_LSI, "clk-lsi", GATE_LSI, GATE_LSI_RDY,
+		   NULL, NULL, NULL),
+
+	OSCILLATOR(OSC_CSI, _CK_CSI, "clk-csi", GATE_CSI, GATE_CSI_RDY,
+		   NULL, NULL, NULL),
+
+	OSCILLATOR(OSC_LSE, _CK_LSE, "clk-lse", GATE_LSE, GATE_LSE_RDY,
+		   BYPASS(RCC_BDCR, 1, 3),
+		   CSS(RCC_BDCR, 8),
+		   DRIVE(RCC_BDCR, 4, 2, 2)),
+
+	OSCILLATOR(OSC_HSE, _CK_HSE, "clk-hse", GATE_HSE, GATE_HSE_RDY,
+		   BYPASS(RCC_OCENSETR, 10, 7),
+		   CSS(RCC_OCENSETR, 11),
+		   NULL),
+
+	OSCILLATOR(OSC_I2SCKIN, _I2SCKIN, "i2s_ckin", NO_GATE, NO_GATE,
+		   NULL, NULL, NULL),
+};
+
+const char *clk_stm32_get_oscillator_name(enum stm32_osc id)
+{
+	if (id < NB_OSCILLATOR) {
+		return stm32mp13_osc_data[id].name;
+	}
+
+	return NULL;
+}
+
+#define CLK_PLL_CFG(_idx, _clk_id, _type, _reg)\
+	[(_idx)] = {\
+		.clk_id = (_clk_id),\
+		.plltype = (_type),\
+		.reg_pllxcr = (_reg),\
+	}
+
+static const struct stm32_clk_pll stm32_mp13_clk_pll[_PLL_NB] = {
+	CLK_PLL_CFG(_PLL1, _CK_PLL1, PLL_2000, RCC_PLL1CR),
+	CLK_PLL_CFG(_PLL2, _CK_PLL2, PLL_1600, RCC_PLL2CR),
+	CLK_PLL_CFG(_PLL3, _CK_PLL3, PLL_800, RCC_PLL3CR),
+	CLK_PLL_CFG(_PLL4, _CK_PLL4, PLL_800, RCC_PLL4CR),
+};
+
+static const struct stm32_clk_pll *clk_st32_pll_data(unsigned int idx)
+{
+	return &stm32_mp13_clk_pll[idx];
+}
+
+struct stm32_pll_cfg {
+	int pll_id;
+};
+
+static unsigned long clk_stm32_pll_recalc_rate(struct stm32_clk_priv *priv,  int id,
+					       unsigned long prate)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct stm32_pll_cfg *pll_cfg = clk->clock_cfg;
+	const struct stm32_clk_pll *pll = clk_st32_pll_data(pll_cfg->pll_id);
+	uintptr_t pll_base = priv->base + pll->reg_pllxcr;
+	uint32_t cfgr1, fracr, divm, divn;
+	unsigned long fvco;
+
+	cfgr1 = mmio_read_32(pll_base + RCC_OFFSET_PLLXCFGR1);
+	fracr = mmio_read_32(pll_base + RCC_OFFSET_PLLXFRACR);
+
+	divm = (cfgr1 & (RCC_PLLNCFGR1_DIVM_MASK)) >> RCC_PLLNCFGR1_DIVM_SHIFT;
+	divn = cfgr1 & RCC_PLLNCFGR1_DIVN_MASK;
+
+	/*
+	 * With FRACV :
+	 *   Fvco = Fck_ref * ((DIVN + 1) + FRACV / 2^13) / (DIVM + 1)
+	 * Without FRACV
+	 *   Fvco = Fck_ref * ((DIVN + 1) / (DIVM + 1)
+	 */
+	if ((fracr & RCC_PLLNFRACR_FRACLE) != 0U) {
+		uint32_t fracv = (fracr & RCC_PLLNFRACR_FRACV_MASK) >>
+				 RCC_PLLNFRACR_FRACV_SHIFT;
+		unsigned long long numerator, denominator;
+
+		numerator = (((unsigned long long)divn + 1U) << 13) + fracv;
+		numerator = prate * numerator;
+		denominator = ((unsigned long long)divm + 1U) << 13;
+		fvco = (unsigned long)(numerator / denominator);
+	} else {
+		fvco = (unsigned long)(prate * (divn + 1U) / (divm + 1U));
+	}
+
+	return fvco;
+};
+
+static bool clk_stm32_pll_is_enabled(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct stm32_pll_cfg *pll_cfg = clk->clock_cfg;
+	const struct stm32_clk_pll *pll = clk_st32_pll_data(pll_cfg->pll_id);
+
+	return _clk_stm32_pll_is_enabled(priv, pll);
+}
+
+static int clk_stm32_pll_enable(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct stm32_pll_cfg *pll_cfg = clk->clock_cfg;
+	const struct stm32_clk_pll *pll = clk_st32_pll_data(pll_cfg->pll_id);
+
+	return _clk_stm32_pll_enable(priv, pll);
+}
+
+static void clk_stm32_pll_disable(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct stm32_pll_cfg *pll_cfg = clk->clock_cfg;
+	const struct stm32_clk_pll *pll = clk_st32_pll_data(pll_cfg->pll_id);
+
+	_clk_stm32_pll_disable(priv, pll);
+}
+
+const struct stm32_clk_ops clk_stm32_pll_ops = {
+	.recalc_rate	= clk_stm32_pll_recalc_rate,
+	.enable		= clk_stm32_pll_enable,
+	.disable	= clk_stm32_pll_disable,
+	.is_enabled	= clk_stm32_pll_is_enabled,
+};
+
+#define CLK_PLL(idx, _idx, _parent, _gate, _pll_id, _flags)[idx] = {\
+	.binding = _idx,\
+	.parent = _parent,\
+	.flags = (_flags),\
+	.clock_cfg	= &(struct stm32_pll_cfg) {\
+		.pll_id = _pll_id,\
+	},\
+	.ops = &clk_stm32_pll_ops,\
+}
+
+struct clk_stm32_composite_cfg {
+	int gate_id;
+	int div_id;
+};
+
+static unsigned long clk_stm32_composite_recalc_rate(struct stm32_clk_priv *priv,
+						     int idx, unsigned long prate)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, idx);
+	struct clk_stm32_composite_cfg *composite_cfg = clk->clock_cfg;
+
+	return _clk_stm32_divider_recalc(priv, composite_cfg->div_id, prate);
+};
+
+bool clk_stm32_composite_gate_is_enabled(struct stm32_clk_priv *priv, int idx)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, idx);
+	struct clk_stm32_composite_cfg *composite_cfg = clk->clock_cfg;
+
+	return _clk_stm32_gate_is_enabled(priv, composite_cfg->gate_id);
+}
+
+int clk_stm32_composite_gate_enable(struct stm32_clk_priv *priv, int idx)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, idx);
+	struct clk_stm32_composite_cfg *composite_cfg = clk->clock_cfg;
+
+	return _clk_stm32_gate_enable(priv, composite_cfg->gate_id);
+}
+
+void clk_stm32_composite_gate_disable(struct stm32_clk_priv *priv, int idx)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, idx);
+	struct clk_stm32_composite_cfg *composite_cfg = clk->clock_cfg;
+
+	_clk_stm32_gate_disable(priv, composite_cfg->gate_id);
+}
+
+const struct stm32_clk_ops clk_stm32_composite_ops = {
+	.recalc_rate = clk_stm32_composite_recalc_rate,
+	.is_enabled = clk_stm32_composite_gate_is_enabled,
+	.enable = clk_stm32_composite_gate_enable,
+	.disable = clk_stm32_composite_gate_disable,
+};
+
+#define STM32_COMPOSITE(idx, _binding, _parent, _flags, _gate_id,\
+			_div_id)[idx] = {\
+	.binding = (_binding),\
+	.parent =  (_parent),\
+	.flags = (_flags),\
+	.clock_cfg	= &(struct clk_stm32_composite_cfg) {\
+		.gate_id	= (_gate_id),\
+		.div_id	= (_div_id),\
+	},\
+	.ops = &clk_stm32_composite_ops,\
+}
+
+static const struct clk_stm32 stm32mp13_clk[CK_LAST] = {
+	/* ROOT CLOCKS */
+	CLK_FIXED_RATE(_CK_OFF, _NO_ID, 0),
+	CLK_OSC(_CK_HSE, CK_HSE, CLK_IS_ROOT, OSC_HSE),
+	CLK_OSC(_CK_HSI, CK_HSI, CLK_IS_ROOT, OSC_HSI),
+	CLK_OSC(_CK_CSI, CK_CSI, CLK_IS_ROOT, OSC_CSI),
+	CLK_OSC(_CK_LSI, CK_LSI, CLK_IS_ROOT, OSC_LSI),
+	CLK_OSC(_CK_LSE, CK_LSE, CLK_IS_ROOT, OSC_LSE),
+
+	CLK_OSC_FIXED(_I2SCKIN, _NO_ID, CLK_IS_ROOT, OSC_I2SCKIN),
+
+	CLK_FIXED_RATE(_USB_PHY_48, _NO_ID, USB_PHY_48_MHZ),
+
+	STM32_DIV(_HSE_DIV, _NO_ID, _CK_HSE, 0, DIV_RTC),
+
+	FIXED_FACTOR(_HSE_DIV2, CK_HSE_DIV2, _CK_HSE, 1, 2),
+	FIXED_FACTOR(_CSI_DIV122, _NO_ID, _CK_CSI, 1, 122),
+
+	CLK_PLL(_CK_PLL1, PLL1, MUX(MUX_PLL12), GATE_PLL1, _PLL1, 0),
+	CLK_PLL(_CK_PLL2, PLL2, MUX(MUX_PLL12), GATE_PLL2, _PLL2, 0),
+	CLK_PLL(_CK_PLL3, PLL3, MUX(MUX_PLL3), GATE_PLL3, _PLL3, 0),
+	CLK_PLL(_CK_PLL4, PLL4, MUX(MUX_PLL4), GATE_PLL4, _PLL4, 0),
+
+	STM32_COMPOSITE(_PLL1P, PLL1_P, _CK_PLL1, CLK_IS_CRITICAL, GATE_PLL1_DIVP, DIV_PLL1DIVP),
+	STM32_DIV(_PLL1P_DIV, _NO_ID, _CK_PLL1, 0, DIV_MPU),
+
+	STM32_COMPOSITE(_PLL2P, PLL2_P, _CK_PLL2, CLK_IS_CRITICAL, GATE_PLL2_DIVP, DIV_PLL2DIVP),
+	STM32_COMPOSITE(_PLL2Q, PLL2_Q, _CK_PLL2, 0, GATE_PLL2_DIVQ, DIV_PLL2DIVQ),
+	STM32_COMPOSITE(_PLL2R, PLL2_R, _CK_PLL2, CLK_IS_CRITICAL, GATE_PLL2_DIVR, DIV_PLL2DIVR),
+
+	STM32_COMPOSITE(_PLL3P, PLL3_P, _CK_PLL3, 0, GATE_PLL3_DIVP, DIV_PLL3DIVP),
+	STM32_COMPOSITE(_PLL3Q, PLL3_Q, _CK_PLL3, 0, GATE_PLL3_DIVQ, DIV_PLL3DIVQ),
+	STM32_COMPOSITE(_PLL3R, PLL3_R, _CK_PLL3, 0, GATE_PLL3_DIVR, DIV_PLL3DIVR),
+
+	STM32_COMPOSITE(_PLL4P, PLL4_P, _CK_PLL4, 0, GATE_PLL4_DIVP, DIV_PLL4DIVP),
+	STM32_COMPOSITE(_PLL4Q, PLL4_Q, _CK_PLL4, 0, GATE_PLL4_DIVQ, DIV_PLL4DIVQ),
+	STM32_COMPOSITE(_PLL4R, PLL4_R, _CK_PLL4, 0, GATE_PLL4_DIVR, DIV_PLL4DIVR),
+
+	STM32_MUX(_CKMPU, CK_MPU, MUX_MPU, 0),
+	STM32_DIV(_CKAXI, CK_AXI, MUX(MUX_AXI), 0, DIV_AXI),
+	STM32_DIV(_CKMLAHB, CK_MLAHB, MUX(MUX_MLAHB), CLK_IS_CRITICAL, DIV_MLAHB),
+	STM32_MUX(_CKPER, CK_PER, MUX(MUX_CKPER), 0),
+
+	STM32_DIV(_PCLK1, PCLK1, _CKMLAHB, 0, DIV_APB1),
+	STM32_DIV(_PCLK2, PCLK2, _CKMLAHB, 0, DIV_APB2),
+	STM32_DIV(_PCLK3, PCLK3, _CKMLAHB, 0, DIV_APB3),
+	STM32_DIV(_PCLK4, PCLK4, _CKAXI, 0, DIV_APB4),
+	STM32_DIV(_PCLK5, PCLK5, _CKAXI, 0, DIV_APB5),
+	STM32_DIV(_PCLK6, PCLK6, _CKMLAHB, 0, DIV_APB6),
+
+	CK_TIMER(_CKTIMG1, CK_TIMG1, _PCLK1, 0, RCC_APB1DIVR, RCC_TIMG1PRER),
+	CK_TIMER(_CKTIMG2, CK_TIMG2, _PCLK2, 0, RCC_APB2DIVR, RCC_TIMG2PRER),
+	CK_TIMER(_CKTIMG3, CK_TIMG3, _PCLK6, 0, RCC_APB6DIVR, RCC_TIMG3PRER),
+
+	/* END ROOT CLOCKS */
+
+	STM32_GATE(_DDRC1, DDRC1, _CKAXI, CLK_IS_CRITICAL, GATE_DDRC1),
+	STM32_GATE(_DDRC1LP, DDRC1LP, _CKAXI, CLK_IS_CRITICAL, GATE_DDRC1LP),
+	STM32_GATE(_DDRPHYC, DDRPHYC, _PLL2R, CLK_IS_CRITICAL, GATE_DDRPHYC),
+	STM32_GATE(_DDRPHYCLP, DDRPHYCLP, _PLL2R, CLK_IS_CRITICAL, GATE_DDRPHYCLP),
+	STM32_GATE(_DDRCAPB, DDRCAPB, _PCLK4, CLK_IS_CRITICAL, GATE_DDRCAPB),
+	STM32_GATE(_DDRCAPBLP, DDRCAPBLP, _PCLK4, CLK_IS_CRITICAL, GATE_DDRCAPBLP),
+	STM32_GATE(_AXIDCG, AXIDCG, _CKAXI, CLK_IS_CRITICAL, GATE_AXIDCG),
+	STM32_GATE(_DDRPHYCAPB, DDRPHYCAPB, _PCLK4, CLK_IS_CRITICAL, GATE_DDRPHYCAPB),
+	STM32_GATE(_DDRPHYCAPBLP, DDRPHYCAPBLP, _PCLK4, CLK_IS_CRITICAL,  GATE_DDRPHYCAPBLP),
+
+	STM32_GATE(_SYSCFG, SYSCFG, _PCLK3, 0, GATE_SYSCFG),
+	STM32_GATE(_DDRPERFM, DDRPERFM, _PCLK4, 0, GATE_DDRPERFM),
+	STM32_GATE(_IWDG2APB, IWDG2, _PCLK4, 0, GATE_IWDG2APB),
+	STM32_GATE(_USBPHY_K, USBPHY_K, MUX(MUX_USBPHY), 0, GATE_USBPHY),
+	STM32_GATE(_USBO_K, USBO_K, MUX(MUX_USBO), 0, GATE_USBO),
+
+	STM32_GATE(_RTCAPB, RTCAPB, _PCLK5, CLK_IS_CRITICAL, GATE_RTCAPB),
+	STM32_GATE(_TZC, TZC, _PCLK5, CLK_IS_CRITICAL, GATE_TZC),
+	STM32_GATE(_ETZPC, TZPC, _PCLK5, CLK_IS_CRITICAL, GATE_ETZPC),
+	STM32_GATE(_IWDG1APB, IWDG1, _PCLK5, 0, GATE_IWDG1APB),
+	STM32_GATE(_BSEC, BSEC, _PCLK5, CLK_IS_CRITICAL, GATE_BSEC),
+	STM32_GATE(_STGENC, STGEN_K, MUX(MUX_STGEN), CLK_IS_CRITICAL, GATE_STGENC),
+
+	STM32_GATE(_USART1_K, USART1_K, MUX(MUX_UART1), 0, GATE_USART1),
+	STM32_GATE(_USART2_K, USART2_K, MUX(MUX_UART2), 0, GATE_USART2),
+	STM32_GATE(_I2C3_K, I2C3_K, MUX(MUX_I2C3), 0, GATE_I2C3),
+	STM32_GATE(_I2C4_K, I2C4_K, MUX(MUX_I2C4), 0, GATE_I2C4),
+	STM32_GATE(_I2C5_K, I2C5_K, MUX(MUX_I2C5), 0, GATE_I2C5),
+	STM32_GATE(_TIM12, TIM12_K, _CKTIMG3, 0, GATE_TIM12),
+	STM32_GATE(_TIM15, TIM15_K, _CKTIMG3, 0, GATE_TIM15),
+
+	STM32_GATE(_RTCCK, RTC, MUX(MUX_RTC), 0, GATE_RTCCK),
+
+	STM32_GATE(_GPIOA, GPIOA, _CKMLAHB, 0, GATE_GPIOA),
+	STM32_GATE(_GPIOB, GPIOB, _CKMLAHB, 0, GATE_GPIOB),
+	STM32_GATE(_GPIOC, GPIOC, _CKMLAHB, 0, GATE_GPIOC),
+	STM32_GATE(_GPIOD, GPIOD, _CKMLAHB, 0, GATE_GPIOD),
+	STM32_GATE(_GPIOE, GPIOE, _CKMLAHB, 0, GATE_GPIOE),
+	STM32_GATE(_GPIOF, GPIOF, _CKMLAHB, 0, GATE_GPIOF),
+	STM32_GATE(_GPIOG, GPIOG, _CKMLAHB, 0, GATE_GPIOG),
+	STM32_GATE(_GPIOH, GPIOH, _CKMLAHB, 0, GATE_GPIOH),
+	STM32_GATE(_GPIOI, GPIOI, _CKMLAHB, 0, GATE_GPIOI),
+
+	STM32_GATE(_PKA, PKA, _CKAXI, 0, GATE_PKA),
+	STM32_GATE(_SAES_K, SAES_K, MUX(MUX_SAES), 0, GATE_SAES),
+	STM32_GATE(_CRYP1, CRYP1, _PCLK5, 0, GATE_CRYP1),
+	STM32_GATE(_HASH1, HASH1, _PCLK5, 0, GATE_HASH1),
+
+	STM32_GATE(_RNG1_K, RNG1_K, MUX(MUX_RNG1), 0, GATE_RNG1),
+	STM32_GATE(_BKPSRAM, BKPSRAM, _PCLK5, CLK_IS_CRITICAL, GATE_BKPSRAM),
+
+	STM32_GATE(_SDMMC1_K, SDMMC1_K, MUX(MUX_SDMMC1), 0, GATE_SDMMC1),
+	STM32_GATE(_SDMMC2_K, SDMMC2_K, MUX(MUX_SDMMC2), 0, GATE_SDMMC2),
+	STM32_GATE(_DBGCK, CK_DBG, _CKAXI, 0, GATE_DBGCK),
+
+/* TODO: CHECK CLOCK FOR BL2/BL32 AND IF ONLY FOR TEST OR NOT */
+	STM32_GATE(_USART3_K, USART3_K, MUX(MUX_UART35), 0, GATE_USART3),
+	STM32_GATE(_UART4_K, UART4_K, MUX(MUX_UART4), 0, GATE_UART4),
+	STM32_GATE(_UART5_K, UART5_K, MUX(MUX_UART35), 0, GATE_UART5),
+	STM32_GATE(_UART7_K, UART7_K, MUX(MUX_UART78), 0, GATE_UART7),
+	STM32_GATE(_UART8_K, UART8_K, MUX(MUX_UART78), 0, GATE_UART8),
+	STM32_GATE(_USART6_K, USART6_K, MUX(MUX_UART6), 0, GATE_USART6),
+	STM32_GATE(_MCE, MCE, _CKAXI, CLK_IS_CRITICAL, GATE_MCE),
+	STM32_GATE(_FMC_K, FMC_K, MUX(MUX_FMC), 0, GATE_FMC),
+	STM32_GATE(_QSPI_K, QSPI_K, MUX(MUX_QSPI), 0, GATE_QSPI),
+
+	STM32_COMPOSITE(_MCO1_K, CK_MCO1, MUX(MUX_MCO1), 0, GATE_MCO1, DIV_MCO1),
+	STM32_COMPOSITE(_MCO2_K, CK_MCO2, MUX(MUX_MCO2), 0, GATE_MCO2, DIV_MCO2),
+	STM32_COMPOSITE(_TRACECK, CK_TRACE, _CKAXI, 0, GATE_TRACECK, DIV_TRACE),
+
+#if defined(IMAGE_BL32)
+	STM32_GATE(_TIM2, TIM2_K, _CKTIMG1, 0, GATE_TIM2),
+	STM32_GATE(_TIM3, TIM3_K, _CKTIMG1, 0, GATE_TIM3),
+	STM32_GATE(_TIM4, TIM4_K, _CKTIMG1, 0, GATE_TIM4),
+	STM32_GATE(_TIM5, TIM5_K, _CKTIMG1, 0, GATE_TIM5),
+	STM32_GATE(_TIM6, TIM6_K, _CKTIMG1, 0, GATE_TIM6),
+	STM32_GATE(_TIM7, TIM7_K, _CKTIMG1, 0, GATE_TIM7),
+	STM32_GATE(_TIM13, TIM13_K, _CKTIMG3, 0, GATE_TIM13),
+	STM32_GATE(_TIM14, TIM14_K, _CKTIMG3, 0, GATE_TIM14),
+	STM32_GATE(_LPTIM1_K, LPTIM1_K, MUX(MUX_LPTIM1), 0, GATE_LPTIM1),
+	STM32_GATE(_SPI2_K, SPI2_K, MUX(MUX_SPI23), 0, GATE_SPI2),
+	STM32_GATE(_SPI3_K, SPI3_K, MUX(MUX_SPI23), 0, GATE_SPI3),
+	STM32_GATE(_SPDIF_K, SPDIF_K, MUX(MUX_SPDIF), 0, GATE_SPDIF),
+	STM32_GATE(_TIM1, TIM1_K, _CKTIMG2, 0, GATE_TIM1),
+	STM32_GATE(_TIM8, TIM8_K, _CKTIMG2, 0, GATE_TIM8),
+	STM32_GATE(_TIM16, TIM16_K, _CKTIMG3, 0, GATE_TIM16),
+	STM32_GATE(_TIM17, TIM17_K, _CKTIMG3, 0, GATE_TIM17),
+	STM32_GATE(_SPI1_K, SPI1_K, MUX(MUX_SPI1), 0, GATE_SPI1),
+	STM32_GATE(_SPI4_K, SPI4_K, MUX(MUX_SPI4), 0, GATE_SPI4),
+	STM32_GATE(_SPI5_K, SPI5_K, MUX(MUX_SPI5), 0, GATE_SPI5),
+	STM32_GATE(_SAI1_K, SAI1_K, MUX(MUX_SAI1), 0, GATE_SAI1),
+	STM32_GATE(_SAI2_K, SAI2_K, MUX(MUX_SAI2), 0, GATE_SAI2),
+	STM32_GATE(_DFSDM, DFSDM_K, MUX(MUX_SAI1), 0, GATE_DFSDM),
+	STM32_GATE(_FDCAN_K, FDCAN_K, MUX(MUX_FDCAN), 0, GATE_FDCAN),
+	STM32_GATE(_USBH, USBH, _CKAXI, 0, GATE_USBH),
+	STM32_GATE(_I2C1_K, I2C1_K, MUX(MUX_I2C12), 0, GATE_I2C1),
+	STM32_GATE(_I2C2_K, I2C2_K, MUX(MUX_I2C12), 0, GATE_I2C2),
+	STM32_GATE(_ADFSDM, ADFSDM_K, MUX(MUX_SAI1), 0, GATE_ADFSDM),
+	STM32_GATE(_LPTIM2_K, LPTIM2_K, MUX(MUX_LPTIM2), 0, GATE_LPTIM2),
+	STM32_GATE(_LPTIM3_K, LPTIM3_K, MUX(MUX_LPTIM3), 0, GATE_LPTIM3),
+	STM32_GATE(_LPTIM4_K, LPTIM4_K, MUX(MUX_LPTIM45), 0, GATE_LPTIM4),
+	STM32_GATE(_LPTIM5_K, LPTIM5_K, MUX(MUX_LPTIM45), 0, GATE_LPTIM5),
+	STM32_GATE(_VREF, VREF, _PCLK3, 0, GATE_VREF),
+	STM32_GATE(_DTS, TMPSENS, _PCLK3, 0, GATE_DTS),
+	STM32_GATE(_PMBCTRL, PMBCTRL, _PCLK3, 0, GATE_HDP),
+	STM32_GATE(_HDP, HDP, _PCLK3, 0, GATE_PMBCTRL),
+	STM32_GATE(_STGENRO, STGENRO, _PCLK4, 0, GATE_DCMIPP),
+	STM32_GATE(_DCMIPP_K, DCMIPP_K, MUX(MUX_DCMIPP), 0, GATE_DCMIPP),
+	STM32_GATE(_DMAMUX1, DMAMUX1, _CKAXI, 0, GATE_DMAMUX1),
+	STM32_GATE(_DMAMUX2, DMAMUX2, _CKAXI, 0, GATE_DMAMUX2),
+	STM32_GATE(_DMA3, DMA3, _CKAXI, 0, GATE_DMAMUX2),
+	STM32_GATE(_ADC1_K, ADC1_K, MUX(MUX_ADC1), 0, GATE_ADC1),
+	STM32_GATE(_ADC2_K, ADC2_K, MUX(MUX_ADC2), 0, GATE_ADC2),
+	STM32_GATE(_TSC, TSC, _CKAXI, 0, GATE_TSC),
+	STM32_GATE(_AXIMC, AXIMC, _CKAXI, 0, GATE_AXIMC),
+	STM32_GATE(_CRC1, CRC1, _CKAXI, 0, GATE_ETH1TX),
+	STM32_GATE(_ETH1CK, ETH1CK_K, MUX(MUX_ETH1), 0, GATE_ETH1CK),
+	STM32_GATE(_ETH1TX, ETH1TX, _CKAXI, 0, GATE_ETH1TX),
+	STM32_GATE(_ETH1RX, ETH1RX, _CKAXI, 0, GATE_ETH1RX),
+	STM32_GATE(_ETH2CK, ETH2CK_K, MUX(MUX_ETH2), 0, GATE_ETH2CK),
+	STM32_GATE(_ETH2TX, ETH2TX, _CKAXI, 0, GATE_ETH2TX),
+	STM32_GATE(_ETH2RX, ETH2RX, _CKAXI, 0, GATE_ETH2RX),
+	STM32_GATE(_ETH2MAC, ETH2MAC, _CKAXI, 0, GATE_ETH2MAC),
+#endif
+};
+
+struct stm32_pll_dt_cfg mp13_pll[_PLL_NB];
+
+struct stm32_osci_dt_cfg mp13_osci[NB_OSCILLATOR];
+
+uint32_t mp13_clksrc[MUX_MAX];
+
+uint32_t mp13_clkdiv[DIV_MAX];
+
+struct stm32_clk_platdata stm32mp13_clock_pdata = {
+	.osci		= mp13_osci,
+	.nosci		= NB_OSCILLATOR,
+	.pll		= mp13_pll,
+	.npll		= _PLL_NB,
+	.clksrc		= mp13_clksrc,
+	.nclksrc	= MUX_MAX,
+	.clkdiv		= mp13_clkdiv,
+	.nclkdiv	= DIV_MAX,
+};
+
+static struct stm32_clk_priv stm32mp13_clock_data = {
+	.base		= RCC_BASE,
+	.num		= ARRAY_SIZE(stm32mp13_clk),
+	.clks		= stm32mp13_clk,
+	.parents	= parent_mp13,
+	.nb_parents	= ARRAY_SIZE(parent_mp13),
+	.gates		= gates_mp13,
+	.nb_gates	= ARRAY_SIZE(gates_mp13),
+	.div		= dividers_mp13,
+	.nb_div		= ARRAY_SIZE(dividers_mp13),
+	.osci_data	= stm32mp13_osc_data,
+	.nb_osci_data	= ARRAY_SIZE(stm32mp13_osc_data),
+	.gate_refcounts	= refcounts_mp13,
+	.pdata		= &stm32mp13_clock_pdata,
+};
+
+static int stm32mp1_init_clock_tree(void)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	int ret;
+
+#if STM32MP_USB_PROGRAMMER
+	int usbphy_p = _clk_stm32_get_parent(priv, _USBPHY_K);
+	int usbo_p = _clk_stm32_get_parent(priv, _USBO_K);
+
+	/* Don't initialize PLL4, when used by BOOTROM */
+	pll4_bootrom = stm32mp1_clk_is_pll4_used_by_bootrom(priv, usbphy_p);
+#endif
+
+	/*
+	 * Switch ON oscillators found in device-tree.
+	 * Note: HSI already ON after BootROM stage.
+	 */
+	stm32_clk_oscillators_enable(priv);
+
+	/* Come back to HSI */
+	ret = stm32mp1_come_back_to_hsi();
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = stm32_clk_hsidiv_configure(priv);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = stm32_clk_stgen_configure(priv, _STGENC);
+	if (ret != 0) {
+		panic();
+	}
+
+	ret = stm32_clk_dividers_configure(priv);
+	if (ret != 0) {
+		panic();
+	}
+
+	ret = stm32_clk_pll_configure(priv);
+	if (ret != 0) {
+		panic();
+	}
+
+	/* Wait LSE ready before to use it */
+	ret = stm32_clk_oscillators_wait_lse_ready(priv);
+	if (ret != 0) {
+		panic();
+	}
+
+	/* Configure with expected clock source */
+	ret = stm32_clk_source_configure(priv);
+	if (ret != 0) {
+		panic();
+	}
+
+	/* Configure LSE css after RTC source configuration */
+	ret = stm32_clk_oscillators_lse_set_css(priv);
+	if (ret != 0) {
+		panic();
+	}
+
+#if STM32MP_USB_PROGRAMMER
+	ret = stm32mp1_clk_check_usb_conflict(priv, usbphy_p, usbo_p);
+	if (ret != 0) {
+		return ret;
+	}
+#endif
+	/* reconfigure STGEN with DT config */
+	ret = stm32_clk_stgen_configure(priv, _STGENC);
+	if (ret != 0) {
+		panic();
+	}
+
+	/* Software Self-Refresh mode (SSR) during DDR initilialization */
+	mmio_clrsetbits_32(priv->base + RCC_DDRITFCR,
+			   RCC_DDRITFCR_DDRCKMOD_MASK,
+			   RCC_DDRITFCR_DDRCKMOD_SSR <<
+			   RCC_DDRITFCR_DDRCKMOD_SHIFT);
+
+	return 0;
+}
+
+#define LSEDRV_MEDIUM_HIGH 2
+
+int clk_stm32_parse_oscillator_fdt(void *fdt, int node, const char *name,
+					  struct stm32_osci_dt_cfg *osci)
+{
+	int subnode = 0;
+
+	/* default value oscillator not found, freq=0 */
+	osci->freq = 0;
+
+	fdt_for_each_subnode(subnode, fdt, node) {
+		const char *cchar = NULL;
+		const fdt32_t *cuint = NULL;
+		int ret = 0;
+
+		cchar = fdt_get_name(fdt, subnode, &ret);
+		if (cchar == NULL) {
+			return ret;
+		}
+
+		if (strncmp(cchar, name, (size_t)ret) ||
+		    fdt_get_status(subnode) == DT_DISABLED) {
+			continue;
+		}
+
+		cuint = fdt_getprop(fdt, subnode, "clock-frequency", &ret);
+		if (cuint == NULL) {
+			return ret;
+		}
+
+		osci->freq = fdt32_to_cpu(*cuint);
+
+		if (fdt_getprop(fdt, subnode, "st,bypass", NULL) != NULL) {
+			osci->bypass = true;
+		}
+
+		if (fdt_getprop(fdt, subnode, "st,digbypass", NULL) != NULL) {
+			osci->digbyp = true;
+		}
+
+		if (fdt_getprop(fdt, subnode, "st,css", NULL) != NULL) {
+			osci->css = true;
+		}
+
+		osci->drive = fdt_read_uint32_default(fdt, subnode, "st,drive", LSEDRV_MEDIUM_HIGH);
+
+		return 0;
+	}
+
+	return 0;
+}
+
+static int stm32_clk_parse_fdt_all_oscillator(void *fdt, struct stm32_clk_platdata *pdata)
+{
+	int fdt_err = 0;
+	uint32_t i = 0;
+	int node = 0;
+
+	node = fdt_path_offset(fdt, "/clocks");
+	if (node < 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	for (i = 0; i < pdata->nosci; i++) {
+		const char *name = NULL;
+
+		name = clk_stm32_get_oscillator_name((enum stm32_osc) i);
+		if (name == NULL) {
+			continue;
+		}
+
+		fdt_err = clk_stm32_parse_oscillator_fdt(fdt, node, name, &pdata->osci[i]);
+		if (fdt_err < 0) {
+			panic();
+		}
+	}
+
+	return 0;
+}
+
+#define RCC_PLL_NAME_SIZE 12
+
+static int clk_stm32_load_vco_config(void * fdt, int subnode, struct stm32_pll_vco *vco)
+{
+	int err = 0;
+
+	err = fdt_read_uint32_array(fdt, subnode, "divmn", (int)PLL_DIV_MN_NB, vco->div_mn);
+	if (err != 0) {
+		return err;
+	}
+
+	err = fdt_read_uint32_array(fdt, subnode, "csg", (int)PLL_CSG_NB, vco->csg);
+
+	vco->csg_enabled = (err == 0);
+
+	if (err == -FDT_ERR_NOTFOUND) {
+		err = 0;
+	}
+
+	if (err != 0) {
+		return err;
+	}
+
+	vco->status = RCC_PLLNCR_DIVPEN | RCC_PLLNCR_DIVQEN | RCC_PLLNCR_DIVREN | RCC_PLLNCR_PLLON;
+
+	vco->frac = fdt_read_uint32_default(fdt, subnode, "frac", 0);
+
+	vco->src = fdt_read_uint32_default(fdt, subnode, "src", UINT32_MAX);
+
+	return 0;
+}
+
+static int clk_stm32_load_output_config(void * fdt, int subnode, struct stm32_pll_output *output)
+{
+	int err = 0;
+
+	err = fdt_read_uint32_array(fdt, subnode, "st,pll_div_pqr", (int)PLL_DIV_PQR_NB,
+				    output->output);
+	if (err != 0) {
+		return err;
+	}
+
+	return 0;
+}
+
+static int clk_stm32_parse_pll_fdt(void *fdt, int subnode, struct stm32_pll_dt_cfg *pll)
+{
+	const fdt32_t *cuint = NULL;
+	int subnode_pll = 0;
+	int subnode_vco = 0;
+	int err = 0;
+
+	cuint = fdt_getprop(fdt, subnode, "st,pll", NULL);
+	if (!cuint) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	subnode_pll = fdt_node_offset_by_phandle(fdt, fdt32_to_cpu(*cuint));
+	if (subnode_pll < 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	cuint = fdt_getprop(fdt, subnode_pll, "st,pll_vco", NULL);
+	if (!cuint) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	subnode_vco = fdt_node_offset_by_phandle(fdt, fdt32_to_cpu(*cuint));
+	if (subnode_vco < 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	err = clk_stm32_load_vco_config(fdt, subnode_vco, &pll->vco);
+	if (err != 0) {
+		return err;
+	}
+
+	err = clk_stm32_load_output_config(fdt, subnode_pll, &pll->output);
+	if (err != 0) {
+		return err;
+	}
+
+	return 0;
+}
+
+static int stm32_clk_parse_fdt_all_pll(void *fdt, int node, struct stm32_clk_platdata *pdata)
+{
+	size_t i = 0;
+
+	for (i = _PLL1; i < pdata->npll; i++) {
+		struct stm32_pll_dt_cfg *pll = pdata->pll + i;
+		char name[RCC_PLL_NAME_SIZE];
+		int subnode = 0;
+		int err = 0;
+
+		snprintf(name, sizeof(name), "st,pll@%d", i);
+
+		subnode = fdt_subnode_offset(fdt, node, name);
+		if (!fdt_check_node(subnode)) {
+			continue;
+		}
+
+		err = clk_stm32_parse_pll_fdt(fdt, subnode, pll);
+		if (err != 0) {
+			panic();
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_clk_parse_fdt(struct stm32_clk_platdata *pdata)
+{
+	void *fdt = NULL;
+	int node;
+	uint32_t err;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -ENOENT;
+	}
+
+	node = fdt_node_offset_by_compatible(fdt, -1, DT_RCC_CLK_COMPAT);
+	if (node < 0) {
+		panic();
+	}
+
+	err = stm32_clk_parse_fdt_all_oscillator(fdt, pdata);
+	if (err != 0) {
+		return err;
+	}
+
+	err = stm32_clk_parse_fdt_all_pll(fdt, node, pdata);
+	if (err != 0) {
+		return err;
+	}
+
+	err = stm32_clk_parse_fdt_by_name(fdt, node, "st,clkdiv", pdata->clkdiv, &pdata->nclkdiv);
+	if (err != 0) {
+		return err;
+	}
+
+	err = stm32_clk_parse_fdt_by_name(fdt, node, "st,clksrc", pdata->clksrc, &pdata->nclksrc);
+	if (err != 0) {
+		return err;
+	}
+
+	return 0;
+}
+
+int stm32mp1_clk_init(uint32_t pll1_freq_khz)
+{
+	return 0;
+}
+
+int stm32mp1_clk_probe(void)
+{
+	uintptr_t base = RCC_BASE;
+	int ret;
+
+	ret = stm32_clk_parse_fdt(&stm32mp13_clock_pdata);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = clk_stm32_init(&stm32mp13_clock_data, base);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = stm32mp1_init_clock_tree();
+	if (ret != 0) {
+		return ret;
+	}
+
+	clk_stm32_enable_critical_clocks();
+
+	return 0;
+}
diff --git a/drivers/st/clk/stm32mp1_calib.c b/drivers/st/clk/stm32mp1_calib.c
new file mode 100644
index 000000000..11a334303
--- /dev/null
+++ b/drivers/st/clk/stm32mp1_calib.c
@@ -0,0 +1,536 @@
+/*
+ * Copyright (C) 2019-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdint.h>
+#include <stdio.h>
+
+#include <libfdt.h>
+
+#include <platform_def.h>
+
+#include <arch.h>
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/generic_delay_timer.h>
+#include <drivers/st/stm32_timer.h>
+#include <drivers/st/stm32mp_clkfunc.h>
+#include <lib/mmio.h>
+#include <lib/spinlock.h>
+#include <lib/utils_def.h>
+#include <plat/common/platform.h>
+
+#define TIMEOUT_10MS	10000
+#define CALIB_TIMEOUT	TIMEOUT_10MS
+
+struct stm32mp1_trim_boundary_t {
+	/* Max boundary trim value around forbidden value */
+	unsigned int x1;
+	/* Min boundary trim value around forbidden value */
+	unsigned int x2;
+};
+
+struct stm32mp1_clk_cal {
+	uint16_t *fbv;
+	unsigned int cal_ref;
+	int trim_max;
+	int trim_min;
+	unsigned int boundary_max;
+	unsigned long ref_freq;
+	unsigned int freq_margin;
+	unsigned long (*get_freq)(void);
+	void (*set_trim)(unsigned int cal);
+	unsigned int (*get_trim)(void);
+	struct stm32mp1_trim_boundary_t boundary[16];
+};
+
+/* RCC Wakeup status */
+static bool rcc_wakeup;
+
+/* List of forbiden values for HSI */
+static uint16_t fbv_hsi[] = {
+	512,
+	480,
+	448,
+	416,
+	384,
+	352,
+	320,
+	288,
+	256,
+	224,
+	192,
+	160,
+	128,
+	96,
+	64,
+	32,
+	0
+};
+
+/* List of forbiden values for CSI */
+static uint16_t fbv_csi[] = {
+	256,
+	240,
+	224,
+	208,
+	192,
+	176,
+	160,
+	144,
+	128,
+	112,
+	96,
+	80,
+	64,
+	48,
+	32,
+	16,
+	0
+};
+
+static void hsi_set_trim(unsigned int cal);
+static unsigned int hsi_get_trimed_cal(void);
+static void csi_set_trim(unsigned int cal);
+static unsigned int csi_get_trimed_cal(void);
+
+static struct stm32mp1_clk_cal stm32mp1_clk_cal_hsi = {
+	.fbv = fbv_hsi,
+	.trim_max = 63,
+	.trim_min = -64,
+	.ref_freq = 0,
+	.freq_margin = 5,
+	.set_trim = hsi_set_trim,
+	.get_trim = hsi_get_trimed_cal,
+};
+
+static struct stm32mp1_clk_cal stm32mp1_clk_cal_csi = {
+	.fbv = fbv_csi,
+	.trim_max = 15,
+	.trim_min = -16,
+	.ref_freq = 0,
+	.freq_margin = 8,
+	.set_trim = csi_set_trim,
+	.get_trim = csi_get_trimed_cal,
+};
+
+static uint32_t timer_val;
+
+/*
+ * HSI Calibration part
+ */
+static int get_signed_value(uint8_t val)
+{
+	return ((int8_t)(val << 1)) >> 1;
+}
+
+static void hsi_set_trim(unsigned int cal)
+{
+	int clk_trim = (int)cal - (int)stm32mp1_clk_cal_hsi.cal_ref;
+	uint32_t trim = ((uint32_t)clk_trim << RCC_HSICFGR_HSITRIM_SHIFT) &
+			RCC_HSICFGR_HSITRIM_MASK;
+
+	mmio_clrsetbits_32(stm32mp_rcc_base() + RCC_HSICFGR,
+			   RCC_HSICFGR_HSITRIM_MASK, trim);
+}
+
+static unsigned int hsi_get_trimed_cal(void)
+{
+	uint32_t utrim = (mmio_read_32(stm32mp_rcc_base() + RCC_HSICFGR) &
+			  RCC_HSICFGR_HSITRIM_MASK) >>
+			 RCC_HSICFGR_HSITRIM_SHIFT;
+
+	int trim = get_signed_value((uint8_t)utrim);
+
+	if (trim + (int)stm32mp1_clk_cal_hsi.cal_ref < 0) {
+		return 0;
+	}
+
+	return stm32mp1_clk_cal_hsi.cal_ref + trim;
+}
+
+static void csi_set_trim(unsigned int cal)
+{
+	int clk_trim = (int)cal - (int)stm32mp1_clk_cal_csi.cal_ref +
+		       stm32mp1_clk_cal_csi.trim_max + 1;
+	uint32_t trim = ((uint32_t)clk_trim << RCC_CSICFGR_CSITRIM_SHIFT) &
+			RCC_CSICFGR_CSITRIM_MASK;
+
+	mmio_clrsetbits_32(stm32mp_rcc_base() + RCC_CSICFGR,
+			   RCC_CSICFGR_CSITRIM_MASK, trim);
+}
+
+static unsigned int csi_get_trimed_cal(void)
+{
+	uint32_t trim = (mmio_read_32(stm32mp_rcc_base() + RCC_CSICFGR) &
+			 RCC_CSICFGR_CSITRIM_MASK) >>
+			RCC_CSICFGR_CSITRIM_SHIFT;
+
+	return (int)trim - stm32mp1_clk_cal_csi.trim_max +
+		(int)stm32mp1_clk_cal_csi.cal_ref - 1;
+}
+
+static unsigned int trim_increase(struct stm32mp1_clk_cal *clk_cal,
+				  unsigned int cal)
+{
+	struct stm32mp1_trim_boundary_t *boundary;
+	unsigned int new_cal;
+	int i;
+
+	/* By default: last calibration value */
+	new_cal = cal;
+
+	/* Start from Lowest cal value */
+	for (i = (int)clk_cal->boundary_max - 1; i >= 0; i--) {
+		boundary = &clk_cal->boundary[i];
+
+		if (cal < boundary->x2) {
+			new_cal = boundary->x2;
+			break;
+		}
+
+		if ((cal >= boundary->x2) && (cal < boundary->x1)) {
+			new_cal = cal + 1;
+			break;
+		}
+	}
+
+	return new_cal;
+}
+
+static unsigned int trim_decrease(struct stm32mp1_clk_cal *clk_cal,
+				  unsigned int cal)
+{
+	struct stm32mp1_trim_boundary_t *boundary;
+	unsigned int new_cal;
+	unsigned int i;
+
+	/* By default: last calibration value */
+	new_cal = cal;
+
+	/* Start from Highest cal value */
+	for (i = 0; i < clk_cal->boundary_max; i++) {
+		boundary = &clk_cal->boundary[i];
+
+		if (cal > boundary->x1) {
+			new_cal = boundary->x1;
+			break;
+		}
+
+		if ((cal > boundary->x2) && (cal <= boundary->x1)) {
+			new_cal = cal - 1;
+			break;
+		}
+	}
+
+	return new_cal;
+}
+
+static void rcc_calibration(struct stm32mp1_clk_cal *clk_cal)
+{
+	unsigned long freq = clk_cal->get_freq();
+	unsigned long min = clk_cal->ref_freq -
+		((clk_cal->ref_freq * clk_cal->freq_margin) / 1000);
+	unsigned long max = clk_cal->ref_freq +
+		((clk_cal->ref_freq * clk_cal->freq_margin) / 1000);
+	int trim, new_trim;
+	unsigned long conv;
+	unsigned long min_conv = ULONG_MAX;
+	uint64_t start;
+
+	if ((freq >= min) && (freq <= max)) {
+		return;
+	}
+
+	trim = clk_cal->get_trim();
+	start = timeout_init_us(CALIB_TIMEOUT);
+	do {
+		if (freq < clk_cal->ref_freq) {
+			new_trim = trim_increase(clk_cal, trim);
+		} else {
+			new_trim = trim_decrease(clk_cal, trim);
+		}
+
+		clk_cal->set_trim(new_trim);
+		freq = clk_cal->get_freq();
+		if (freq == 0U) {
+			/* Calibration will be stopped */
+			clk_cal->ref_freq = 0U;
+			return;
+		}
+		conv = (clk_cal->ref_freq < freq) ?
+			freq - clk_cal->ref_freq : clk_cal->ref_freq - freq;
+		if (conv < min_conv) {
+			min_conv = conv;
+			trim = new_trim;
+		}
+
+		if (timeout_elapsed(start)) {
+			break;
+		}
+
+	} while (conv == min_conv);
+
+	clk_cal->set_trim(trim);
+	freq = clk_cal->get_freq();
+
+	if ((freq < min) || (freq > max)) {
+		ERROR("%s Calibration : Freq %lu, trim %i\n",
+		      (clk_cal->set_trim == hsi_set_trim) ? "HSI" : "CSI",
+		      freq, trim);
+#if DEBUG
+		/*
+		 * Show the steps around the selected trim value
+		 * to correct the margin if needed
+		 */
+		new_trim = trim_decrease(clk_cal, trim);
+		clk_cal->set_trim(new_trim);
+		ERROR("%s Calibration : Freq %lu, trim %i\n",
+		      (clk_cal->set_trim == hsi_set_trim) ?
+		      "HSI" : "CSI", clk_cal->get_freq(), new_trim);
+
+		new_trim = trim_increase(clk_cal, trim);
+		clk_cal->set_trim(new_trim);
+		ERROR("%s Calibration : Freq %lu, trim %i\n",
+		      (clk_cal->set_trim == hsi_set_trim) ?
+		      "HSI" : "CSI", clk_cal->get_freq(), new_trim);
+#endif
+	}
+}
+
+static void save_trim(struct stm32mp1_clk_cal *clk_cal,
+		      unsigned int i, unsigned int x1, unsigned int x2)
+{
+	clk_cal->boundary[i].x1 = x1;
+	clk_cal->boundary[i].x2 = x2;
+}
+
+static int trim_find_prev_boundary(struct stm32mp1_clk_cal *clk_cal,
+				   unsigned int x1)
+{
+	unsigned int x = x1;
+	unsigned long freq;
+
+	clk_cal->set_trim(x1 + 1);
+	freq = clk_cal->get_freq();
+
+	while (x >= (clk_cal->cal_ref + clk_cal->trim_min)) {
+		x--;
+		clk_cal->set_trim(x);
+
+		if (clk_cal->get_freq() <= freq) {
+			break;
+		}
+	};
+
+	return x;
+}
+
+static void trim_table_init(struct stm32mp1_clk_cal *clk_cal)
+{
+	uint16_t *trim_fbv = clk_cal->fbv;
+	unsigned int min;
+	unsigned int max;
+	int boundary = 0;
+	int i = 0;
+
+	max = clk_cal->cal_ref + clk_cal->trim_max;
+	min = clk_cal->cal_ref + clk_cal->trim_min;
+
+	while (trim_fbv[i]) {
+		unsigned int x;
+		unsigned int x1 = trim_fbv[i];
+		unsigned int x2 = trim_fbv[i + 1];
+
+		if ((max <= x2) || (min >= x1)) {
+			i++;
+			if (boundary != 0) {
+				goto out;
+			}
+			continue;
+		}
+
+		/* Take forbiden value + 1 */
+		x2 = x2 + 1;
+		if (x2 < min) {
+			x2 = min;
+		}
+
+		if (boundary == 0) {
+			/* Save first boundary */
+			save_trim(clk_cal, boundary, max, x2);
+			boundary++;
+			i++;
+			continue;
+		}
+
+		x = trim_find_prev_boundary(clk_cal, x1);
+		/* Save boundary values */
+		save_trim(clk_cal, boundary, x - 1, x2);
+		boundary++;
+		i++;
+	};
+out:
+	clk_cal->boundary_max = boundary;
+}
+
+bool stm32mp1_calib_get_wakeup(void)
+{
+	return rcc_wakeup;
+}
+
+void stm32mp1_calib_set_wakeup(bool state)
+{
+	rcc_wakeup = state;
+}
+
+void stm32mp1_calib_it_handler(uint32_t id)
+{
+	uintptr_t rcc_base = stm32mp_rcc_base();
+
+	switch (id) {
+	case STM32MP1_IRQ_RCC_WAKEUP:
+		plat_ic_set_priority_mask(GIC_HIGHEST_NS_PRIORITY);
+		mmio_setbits_32(rcc_base + RCC_MP_CIFR, RCC_MP_CIFR_WKUPF);
+		stm32mp1_calib_set_wakeup(true);
+		return;
+
+	case STM32MP1_IRQ_MCU_SEV:
+		stm32mp1_calib_set_wakeup(false);
+		if ((mmio_read_32(EXTI_BASE + EXTI_RPR3) &
+		     EXTI_RPR3_RPIF65) != 0U) {
+			mmio_setbits_32(EXTI_BASE + EXTI_RPR3,
+					EXTI_RPR3_RPIF65);
+		}
+
+		if ((mmio_read_32(EXTI_BASE + EXTI_FPR3) &
+		     EXTI_FPR3_FPIF65) != 0U) {
+			mmio_setbits_32(EXTI_BASE + EXTI_FPR3,
+					EXTI_FPR3_FPIF65);
+		}
+
+		break;
+
+	case ARM_IRQ_SEC_PHY_TIMER:
+	default:
+		break;
+	}
+
+	if (stm32mp1_clk_cal_hsi.ref_freq != 0U) {
+		rcc_calibration(&stm32mp1_clk_cal_hsi);
+	}
+
+	if (stm32mp1_clk_cal_csi.ref_freq != 0U) {
+		rcc_calibration(&stm32mp1_clk_cal_csi);
+	}
+
+	if (timer_val != 0U) {
+		write_cntp_tval(timer_val);
+	}
+}
+
+int stm32mp1_calib_start_hsi_cal(void)
+{
+	if (stm32mp1_clk_cal_hsi.ref_freq == 0U) {
+		return -ENOENT;
+	}
+
+	rcc_calibration(&stm32mp1_clk_cal_hsi);
+	return 0;
+}
+
+int stm32mp1_calib_start_csi_cal(void)
+{
+	if (stm32mp1_clk_cal_csi.ref_freq == 0U) {
+		return -ENOENT;
+	}
+
+	rcc_calibration(&stm32mp1_clk_cal_csi);
+	return 0;
+}
+
+static void init_hsi_cal(void)
+{
+	int len;
+
+	if (fdt_rcc_read_prop("st,hsi-cal", &len) == NULL) {
+		return;
+	}
+
+	stm32_timer_freq_func(&stm32mp1_clk_cal_hsi.get_freq, HSI_CAL);
+	if (stm32mp1_clk_cal_hsi.get_freq == NULL) {
+		return;
+	}
+
+	stm32mp1_clk_cal_hsi.ref_freq = clk_get_rate(CK_HSI);
+
+	/* Read initial value */
+	stm32mp1_clk_cal_hsi.cal_ref =
+		((mmio_read_32(stm32mp_rcc_base() + RCC_HSICFGR)
+		  & RCC_HSICFGR_HSICAL_MASK) >> RCC_HSICFGR_HSICAL_SHIFT);
+
+	trim_table_init(&stm32mp1_clk_cal_hsi);
+
+	stm32mp1_clk_cal_hsi.set_trim(stm32mp1_clk_cal_hsi.cal_ref);
+
+	rcc_calibration(&stm32mp1_clk_cal_hsi);
+}
+
+static void init_csi_cal(void)
+{
+	int len;
+
+	if (fdt_rcc_read_prop("st,csi-cal", &len) == NULL) {
+		return;
+	}
+
+	stm32_timer_freq_func(&stm32mp1_clk_cal_csi.get_freq, CSI_CAL);
+	if (stm32mp1_clk_cal_csi.get_freq == NULL) {
+		return;
+	}
+
+	stm32mp1_clk_cal_csi.ref_freq = clk_get_rate(CK_CSI);
+
+	/* Read initial value */
+	stm32mp1_clk_cal_csi.cal_ref =
+		((mmio_read_32(stm32mp_rcc_base() + RCC_CSICFGR) &
+		  RCC_CSICFGR_CSICAL_MASK) >> RCC_CSICFGR_CSICAL_SHIFT);
+
+	trim_table_init(&stm32mp1_clk_cal_csi);
+
+	stm32mp1_clk_cal_csi.set_trim(stm32mp1_clk_cal_csi.cal_ref);
+
+	rcc_calibration(&stm32mp1_clk_cal_csi);
+}
+
+void stm32mp1_calib_init(void)
+{
+	init_hsi_cal();
+	init_csi_cal();
+
+	timer_val = fdt_rcc_read_uint32_default("st,cal-sec", 0) *
+		plat_get_syscnt_freq2();
+
+	if (timer_val > INT32_MAX) {
+		timer_val = INT32_MAX;
+	}
+
+	if (timer_val != 0U) {
+		/* Load & enable timer */
+		INFO("Set calibration timer to %u sec\n",
+		     timer_val / plat_get_syscnt_freq2());
+		write_cntp_tval(timer_val);
+		write_cntp_ctl(BIT(0));
+	};
+
+	if (fdt_rcc_enable_it("mcu_sev") < 0) {
+		VERBOSE("No MCU calibration\n");
+	}
+}
diff --git a/drivers/st/clk/stm32mp1_clk.c b/drivers/st/clk/stm32mp1_clk.c
index 3ebc376cd..3e11438ad 100644
--- a/drivers/st/clk/stm32mp1_clk.c
+++ b/drivers/st/clk/stm32mp1_clk.c
@@ -1,11 +1,12 @@
 /*
- * Copyright (C) 2018-2021, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2018-2022, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
  */
 
 #include <assert.h>
 #include <errno.h>
+#include <limits.h>
 #include <stdint.h>
 #include <stdio.h>
 
@@ -17,8 +18,8 @@
 #include <arch_helpers.h>
 #include <common/debug.h>
 #include <common/fdt_wrappers.h>
+#include <drivers/clk.h>
 #include <drivers/delay_timer.h>
-#include <drivers/generic_delay_timer.h>
 #include <drivers/st/stm32mp_clkfunc.h>
 #include <drivers/st/stm32mp1_clk.h>
 #include <drivers/st/stm32mp1_rcc.h>
@@ -49,6 +50,19 @@ const char *stm32mp_osc_node_label[NB_OSC] = {
 	[_I2S_CKIN] = "i2s_ckin",
 };
 
+/* PLL settings computation related definitions */
+#define POST_DIVM_MIN	8000000
+#define POST_DIVM_MAX	16000000
+#define DIVM_MIN	0
+#define DIVM_MAX	63
+#define DIVN_MIN	24
+#define DIVN_MAX	99
+#define DIVP_MIN	0
+#define DIVP_MAX	127
+#define FRAC_MAX	8192
+#define VCO_MIN		800000000
+#define VCO_MAX		1600000000
+
 enum stm32mp1_parent_id {
 /* Oscillators are defined in enum stm32mp_osc_id */
 
@@ -233,7 +247,6 @@ enum stm32mp1_plltype {
 struct stm32mp1_pll {
 	uint8_t refclk_min;
 	uint8_t refclk_max;
-	uint8_t divn_max;
 };
 
 struct stm32mp1_clk_gate {
@@ -241,6 +254,7 @@ struct stm32mp1_clk_gate {
 	uint8_t bit;
 	uint8_t index;
 	uint8_t set_clr;
+	uint8_t secure;
 	uint8_t sel; /* Relates to enum stm32mp1_parent_sel */
 	uint8_t fixed; /* Relates to enum stm32mp1_parent_id */
 };
@@ -265,46 +279,59 @@ struct stm32mp1_clk_pll {
 	enum stm32mp_osc_id refclk[REFCLK_SIZE];
 };
 
+/* Compact structure of 32bit cells, copied raw when suspending */
+struct stm32mp1_pll_settings {
+	uint32_t valid_id;
+	uint32_t freq[PLAT_MAX_OPP_NB];
+	uint32_t volt[PLAT_MAX_OPP_NB];
+	uint32_t cfg[PLAT_MAX_OPP_NB][PLAT_MAX_PLLCFG_NB];
+	uint32_t frac[PLAT_MAX_OPP_NB];
+};
+
 /* Clocks with selectable source and non set/clr register access */
-#define _CLK_SELEC(off, b, idx, s)			\
+#define _CLK_SELEC(sec, off, b, idx, s)			\
 	{						\
 		.offset = (off),			\
 		.bit = (b),				\
 		.index = (idx),				\
 		.set_clr = 0,				\
+		.secure = (sec),			\
 		.sel = (s),				\
 		.fixed = _UNKNOWN_ID,			\
 	}
 
 /* Clocks with fixed source and non set/clr register access */
-#define _CLK_FIXED(off, b, idx, f)			\
+#define _CLK_FIXED(sec, off, b, idx, f)			\
 	{						\
 		.offset = (off),			\
 		.bit = (b),				\
 		.index = (idx),				\
 		.set_clr = 0,				\
+		.secure = (sec),			\
 		.sel = _UNKNOWN_SEL,			\
 		.fixed = (f),				\
 	}
 
 /* Clocks with selectable source and set/clr register access */
-#define _CLK_SC_SELEC(off, b, idx, s)			\
+#define _CLK_SC_SELEC(sec, off, b, idx, s)			\
 	{						\
 		.offset = (off),			\
 		.bit = (b),				\
 		.index = (idx),				\
 		.set_clr = 1,				\
+		.secure = (sec),			\
 		.sel = (s),				\
 		.fixed = _UNKNOWN_ID,			\
 	}
 
 /* Clocks with fixed source and set/clr register access */
-#define _CLK_SC_FIXED(off, b, idx, f)			\
+#define _CLK_SC_FIXED(sec, off, b, idx, f)			\
 	{						\
 		.offset = (off),			\
 		.bit = (b),				\
 		.index = (idx),				\
 		.set_clr = 1,				\
+		.secure = (sec),			\
 		.sel = _UNKNOWN_SEL,			\
 		.fixed = (f),				\
 	}
@@ -338,81 +365,90 @@ struct stm32mp1_clk_pll {
 
 #define NB_GATES	ARRAY_SIZE(stm32mp1_clk_gate)
 
+#define SEC		1
+#define N_S		0
+
 static const struct stm32mp1_clk_gate stm32mp1_clk_gate[] = {
-	_CLK_FIXED(RCC_DDRITFCR, 0, DDRC1, _ACLK),
-	_CLK_FIXED(RCC_DDRITFCR, 1, DDRC1LP, _ACLK),
-	_CLK_FIXED(RCC_DDRITFCR, 2, DDRC2, _ACLK),
-	_CLK_FIXED(RCC_DDRITFCR, 3, DDRC2LP, _ACLK),
-	_CLK_FIXED(RCC_DDRITFCR, 4, DDRPHYC, _PLL2_R),
-	_CLK_FIXED(RCC_DDRITFCR, 5, DDRPHYCLP, _PLL2_R),
-	_CLK_FIXED(RCC_DDRITFCR, 6, DDRCAPB, _PCLK4),
-	_CLK_FIXED(RCC_DDRITFCR, 7, DDRCAPBLP, _PCLK4),
-	_CLK_FIXED(RCC_DDRITFCR, 8, AXIDCG, _ACLK),
-	_CLK_FIXED(RCC_DDRITFCR, 9, DDRPHYCAPB, _PCLK4),
-	_CLK_FIXED(RCC_DDRITFCR, 10, DDRPHYCAPBLP, _PCLK4),
-
-	_CLK_SC_FIXED(RCC_MP_APB1ENSETR, 6, TIM12_K, _PCLK1),
-	_CLK_SC_SELEC(RCC_MP_APB1ENSETR, 14, USART2_K, _UART24_SEL),
-	_CLK_SC_SELEC(RCC_MP_APB1ENSETR, 15, USART3_K, _UART35_SEL),
-	_CLK_SC_SELEC(RCC_MP_APB1ENSETR, 16, UART4_K, _UART24_SEL),
-	_CLK_SC_SELEC(RCC_MP_APB1ENSETR, 17, UART5_K, _UART35_SEL),
-	_CLK_SC_SELEC(RCC_MP_APB1ENSETR, 18, UART7_K, _UART78_SEL),
-	_CLK_SC_SELEC(RCC_MP_APB1ENSETR, 19, UART8_K, _UART78_SEL),
-	_CLK_SC_SELEC(RCC_MP_APB1ENSETR, 21, I2C1_K, _I2C12_SEL),
-	_CLK_SC_SELEC(RCC_MP_APB1ENSETR, 22, I2C2_K, _I2C12_SEL),
-	_CLK_SC_SELEC(RCC_MP_APB1ENSETR, 23, I2C3_K, _I2C35_SEL),
-	_CLK_SC_SELEC(RCC_MP_APB1ENSETR, 24, I2C5_K, _I2C35_SEL),
-
-	_CLK_SC_FIXED(RCC_MP_APB2ENSETR, 2, TIM15_K, _PCLK2),
-	_CLK_SC_SELEC(RCC_MP_APB2ENSETR, 13, USART6_K, _UART6_SEL),
-
-	_CLK_SC_FIXED(RCC_MP_APB3ENSETR, 11, SYSCFG, _UNKNOWN_ID),
-
-	_CLK_SC_SELEC(RCC_MP_APB4ENSETR, 8, DDRPERFM, _UNKNOWN_SEL),
-	_CLK_SC_SELEC(RCC_MP_APB4ENSETR, 15, IWDG2, _UNKNOWN_SEL),
-	_CLK_SC_SELEC(RCC_MP_APB4ENSETR, 16, USBPHY_K, _USBPHY_SEL),
-
-	_CLK_SC_SELEC(RCC_MP_APB5ENSETR, 0, SPI6_K, _SPI6_SEL),
-	_CLK_SC_SELEC(RCC_MP_APB5ENSETR, 2, I2C4_K, _I2C46_SEL),
-	_CLK_SC_SELEC(RCC_MP_APB5ENSETR, 3, I2C6_K, _I2C46_SEL),
-	_CLK_SC_SELEC(RCC_MP_APB5ENSETR, 4, USART1_K, _UART1_SEL),
-	_CLK_SC_FIXED(RCC_MP_APB5ENSETR, 8, RTCAPB, _PCLK5),
-	_CLK_SC_FIXED(RCC_MP_APB5ENSETR, 11, TZC1, _PCLK5),
-	_CLK_SC_FIXED(RCC_MP_APB5ENSETR, 12, TZC2, _PCLK5),
-	_CLK_SC_FIXED(RCC_MP_APB5ENSETR, 13, TZPC, _PCLK5),
-	_CLK_SC_FIXED(RCC_MP_APB5ENSETR, 15, IWDG1, _PCLK5),
-	_CLK_SC_FIXED(RCC_MP_APB5ENSETR, 16, BSEC, _PCLK5),
-	_CLK_SC_SELEC(RCC_MP_APB5ENSETR, 20, STGEN_K, _STGEN_SEL),
-
-	_CLK_SC_SELEC(RCC_MP_AHB2ENSETR, 8, USBO_K, _USBO_SEL),
-	_CLK_SC_SELEC(RCC_MP_AHB2ENSETR, 16, SDMMC3_K, _SDMMC3_SEL),
-
-	_CLK_SC_SELEC(RCC_MP_AHB4ENSETR, 0, GPIOA, _UNKNOWN_SEL),
-	_CLK_SC_SELEC(RCC_MP_AHB4ENSETR, 1, GPIOB, _UNKNOWN_SEL),
-	_CLK_SC_SELEC(RCC_MP_AHB4ENSETR, 2, GPIOC, _UNKNOWN_SEL),
-	_CLK_SC_SELEC(RCC_MP_AHB4ENSETR, 3, GPIOD, _UNKNOWN_SEL),
-	_CLK_SC_SELEC(RCC_MP_AHB4ENSETR, 4, GPIOE, _UNKNOWN_SEL),
-	_CLK_SC_SELEC(RCC_MP_AHB4ENSETR, 5, GPIOF, _UNKNOWN_SEL),
-	_CLK_SC_SELEC(RCC_MP_AHB4ENSETR, 6, GPIOG, _UNKNOWN_SEL),
-	_CLK_SC_SELEC(RCC_MP_AHB4ENSETR, 7, GPIOH, _UNKNOWN_SEL),
-	_CLK_SC_SELEC(RCC_MP_AHB4ENSETR, 8, GPIOI, _UNKNOWN_SEL),
-	_CLK_SC_SELEC(RCC_MP_AHB4ENSETR, 9, GPIOJ, _UNKNOWN_SEL),
-	_CLK_SC_SELEC(RCC_MP_AHB4ENSETR, 10, GPIOK, _UNKNOWN_SEL),
-
-	_CLK_SC_FIXED(RCC_MP_AHB5ENSETR, 0, GPIOZ, _PCLK5),
-	_CLK_SC_FIXED(RCC_MP_AHB5ENSETR, 4, CRYP1, _PCLK5),
-	_CLK_SC_FIXED(RCC_MP_AHB5ENSETR, 5, HASH1, _PCLK5),
-	_CLK_SC_SELEC(RCC_MP_AHB5ENSETR, 6, RNG1_K, _RNG1_SEL),
-	_CLK_SC_FIXED(RCC_MP_AHB5ENSETR, 8, BKPSRAM, _PCLK5),
-
-	_CLK_SC_SELEC(RCC_MP_AHB6ENSETR, 12, FMC_K, _FMC_SEL),
-	_CLK_SC_SELEC(RCC_MP_AHB6ENSETR, 14, QSPI_K, _QSPI_SEL),
-	_CLK_SC_SELEC(RCC_MP_AHB6ENSETR, 16, SDMMC1_K, _SDMMC12_SEL),
-	_CLK_SC_SELEC(RCC_MP_AHB6ENSETR, 17, SDMMC2_K, _SDMMC12_SEL),
-	_CLK_SC_SELEC(RCC_MP_AHB6ENSETR, 24, USBH, _UNKNOWN_SEL),
-
-	_CLK_SELEC(RCC_BDCR, 20, RTC, _RTC_SEL),
-	_CLK_SELEC(RCC_DBGCFGR, 8, CK_DBG, _UNKNOWN_SEL),
+	_CLK_FIXED(SEC, RCC_DDRITFCR, 0, DDRC1, _ACLK),
+	_CLK_FIXED(SEC, RCC_DDRITFCR, 1, DDRC1LP, _ACLK),
+	_CLK_FIXED(SEC, RCC_DDRITFCR, 2, DDRC2, _ACLK),
+	_CLK_FIXED(SEC, RCC_DDRITFCR, 3, DDRC2LP, _ACLK),
+	_CLK_FIXED(SEC, RCC_DDRITFCR, 4, DDRPHYC, _PLL2_R),
+	_CLK_FIXED(SEC, RCC_DDRITFCR, 5, DDRPHYCLP, _PLL2_R),
+	_CLK_FIXED(SEC, RCC_DDRITFCR, 6, DDRCAPB, _PCLK4),
+	_CLK_FIXED(SEC, RCC_DDRITFCR, 7, DDRCAPBLP, _PCLK4),
+	_CLK_FIXED(SEC, RCC_DDRITFCR, 8, AXIDCG, _ACLK),
+	_CLK_FIXED(SEC, RCC_DDRITFCR, 9, DDRPHYCAPB, _PCLK4),
+	_CLK_FIXED(SEC, RCC_DDRITFCR, 10, DDRPHYCAPBLP, _PCLK4),
+
+#if defined(IMAGE_BL32)
+	_CLK_SC_FIXED(N_S, RCC_MP_APB1ENSETR, 6, TIM12_K, _PCLK1),
+#endif
+	_CLK_SC_SELEC(N_S, RCC_MP_APB1ENSETR, 14, USART2_K, _UART24_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_APB1ENSETR, 15, USART3_K, _UART35_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_APB1ENSETR, 16, UART4_K, _UART24_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_APB1ENSETR, 17, UART5_K, _UART35_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_APB1ENSETR, 18, UART7_K, _UART78_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_APB1ENSETR, 19, UART8_K, _UART78_SEL),
+
+#if defined(IMAGE_BL32)
+	_CLK_SC_FIXED(N_S, RCC_MP_APB2ENSETR, 2, TIM15_K, _PCLK2),
+#endif
+	_CLK_SC_SELEC(N_S, RCC_MP_APB2ENSETR, 13, USART6_K, _UART6_SEL),
+
+	_CLK_SC_FIXED(N_S, RCC_MP_APB3ENSETR, 11, SYSCFG, _UNKNOWN_ID),
+
+	_CLK_SC_SELEC(N_S, RCC_MP_APB4ENSETR, 8, DDRPERFM, _UNKNOWN_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_APB4ENSETR, 15, IWDG2, _UNKNOWN_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_APB4ENSETR, 16, USBPHY_K, _USBPHY_SEL),
+
+	_CLK_SC_SELEC(SEC, RCC_MP_APB5ENSETR, 0, SPI6_K, _SPI6_SEL),
+	_CLK_SC_SELEC(SEC, RCC_MP_APB5ENSETR, 2, I2C4_K, _I2C46_SEL),
+	_CLK_SC_SELEC(SEC, RCC_MP_APB5ENSETR, 3, I2C6_K, _I2C46_SEL),
+	_CLK_SC_SELEC(SEC, RCC_MP_APB5ENSETR, 4, USART1_K, _UART1_SEL),
+	_CLK_SC_FIXED(SEC, RCC_MP_APB5ENSETR, 8, RTCAPB, _PCLK5),
+	_CLK_SC_FIXED(SEC, RCC_MP_APB5ENSETR, 11, TZC1, _PCLK5),
+	_CLK_SC_FIXED(SEC, RCC_MP_APB5ENSETR, 12, TZC2, _PCLK5),
+	_CLK_SC_FIXED(SEC, RCC_MP_APB5ENSETR, 13, TZPC, _PCLK5),
+	_CLK_SC_FIXED(SEC, RCC_MP_APB5ENSETR, 15, IWDG1, _PCLK5),
+	_CLK_SC_FIXED(SEC, RCC_MP_APB5ENSETR, 16, BSEC, _PCLK5),
+	_CLK_SC_SELEC(SEC, RCC_MP_APB5ENSETR, 20, STGEN_K, _STGEN_SEL),
+
+#if defined(IMAGE_BL32)
+	_CLK_SC_SELEC(N_S, RCC_MP_AHB2ENSETR, 8, USBO_K, _USBO_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_AHB2ENSETR, 16, SDMMC3_K, _SDMMC3_SEL),
+#endif
+
+	_CLK_SC_SELEC(N_S, RCC_MP_AHB4ENSETR, 0, GPIOA, _UNKNOWN_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_AHB4ENSETR, 1, GPIOB, _UNKNOWN_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_AHB4ENSETR, 2, GPIOC, _UNKNOWN_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_AHB4ENSETR, 3, GPIOD, _UNKNOWN_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_AHB4ENSETR, 4, GPIOE, _UNKNOWN_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_AHB4ENSETR, 5, GPIOF, _UNKNOWN_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_AHB4ENSETR, 6, GPIOG, _UNKNOWN_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_AHB4ENSETR, 7, GPIOH, _UNKNOWN_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_AHB4ENSETR, 8, GPIOI, _UNKNOWN_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_AHB4ENSETR, 9, GPIOJ, _UNKNOWN_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_AHB4ENSETR, 10, GPIOK, _UNKNOWN_SEL),
+
+	_CLK_SC_FIXED(SEC, RCC_MP_AHB5ENSETR, 0, GPIOZ, _PCLK5),
+	_CLK_SC_FIXED(SEC, RCC_MP_AHB5ENSETR, 4, CRYP1, _PCLK5),
+	_CLK_SC_FIXED(SEC, RCC_MP_AHB5ENSETR, 5, HASH1, _PCLK5),
+	_CLK_SC_SELEC(SEC, RCC_MP_AHB5ENSETR, 6, RNG1_K, _RNG1_SEL),
+	_CLK_SC_FIXED(SEC, RCC_MP_AHB5ENSETR, 8, BKPSRAM, _PCLK5),
+
+#if defined(IMAGE_BL2)
+	_CLK_SC_SELEC(N_S, RCC_MP_AHB6ENSETR, 12, FMC_K, _FMC_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_AHB6ENSETR, 14, QSPI_K, _QSPI_SEL),
+#endif
+	_CLK_SC_SELEC(N_S, RCC_MP_AHB6ENSETR, 16, SDMMC1_K, _SDMMC12_SEL),
+	_CLK_SC_SELEC(N_S, RCC_MP_AHB6ENSETR, 17, SDMMC2_K, _SDMMC12_SEL),
+#if defined(IMAGE_BL32)
+	_CLK_SC_SELEC(N_S, RCC_MP_AHB6ENSETR, 24, USBH, _UNKNOWN_SEL),
+#endif
+
+	_CLK_SELEC(SEC, RCC_BDCR, 20, RTC, _RTC_SEL),
+	_CLK_SELEC(N_S, RCC_DBGCFGR, 8, CK_DBG, _UNKNOWN_SEL),
 };
 
 static const uint8_t i2c12_parents[] = {
@@ -521,17 +557,14 @@ static const struct stm32mp1_clk_sel stm32mp1_clk_sel[_PARENT_SEL_NB] = {
 };
 
 /* Define characteristic of PLL according type */
-#define DIVN_MIN	24
 static const struct stm32mp1_pll stm32mp1_pll[PLL_TYPE_NB] = {
 	[PLL_800] = {
 		.refclk_min = 4,
 		.refclk_max = 16,
-		.divn_max = 99,
 	},
 	[PLL_1600] = {
 		.refclk_min = 8,
 		.refclk_max = 16,
-		.divn_max = 199,
 	},
 };
 
@@ -622,12 +655,28 @@ static unsigned long stm32mp1_osc[NB_OSC];
 static struct spinlock reg_lock;
 static unsigned int gate_refcounts[NB_GATES];
 static struct spinlock refcount_lock;
+static struct stm32mp1_pll_settings pll1_settings;
+static uint32_t current_opp_khz;
+#if defined(IMAGE_BL32)
+static uint32_t save_current_opp_khz;
+static uint32_t pll3cr;
+static uint32_t pll4cr;
+static uint32_t mssckselr;
+static uint32_t mcudivr;
+#endif
 
 static const struct stm32mp1_clk_gate *gate_ref(unsigned int idx)
 {
 	return &stm32mp1_clk_gate[idx];
 }
 
+#if defined(IMAGE_BL32)
+static bool gate_is_non_secure(const struct stm32mp1_clk_gate *gate)
+{
+	return gate->secure == N_S;
+}
+#endif
+
 static const struct stm32mp1_clk_sel *clk_sel_ref(unsigned int idx)
 {
 	return &stm32mp1_clk_sel[idx];
@@ -1037,7 +1086,8 @@ static void __clk_enable(struct stm32mp1_clk_gate const *gate)
 	if (gate->set_clr != 0U) {
 		mmio_write_32(rcc_base + gate->offset, BIT(gate->bit));
 	} else {
-		mmio_setbits_32(rcc_base + gate->offset, BIT(gate->bit));
+		stm32mp_mmio_setbits_32_shregs(rcc_base + gate->offset,
+					       BIT(gate->bit));
 	}
 }
 
@@ -1051,7 +1101,8 @@ static void __clk_disable(struct stm32mp1_clk_gate const *gate)
 		mmio_write_32(rcc_base + gate->offset + RCC_MP_ENCLRR_OFFSET,
 			      BIT(gate->bit));
 	} else {
-		mmio_clrbits_32(rcc_base + gate->offset, BIT(gate->bit));
+		stm32mp_mmio_clrbits_32_shregs(rcc_base + gate->offset,
+					       BIT(gate->bit));
 	}
 }
 
@@ -1062,17 +1113,6 @@ static bool __clk_is_enabled(struct stm32mp1_clk_gate const *gate)
 	return mmio_read_32(rcc_base + gate->offset) & BIT(gate->bit);
 }
 
-unsigned int stm32mp1_clk_get_refcount(unsigned long id)
-{
-	int i = stm32mp1_clk_get_gated_id(id);
-
-	if (i < 0) {
-		panic();
-	}
-
-	return gate_refcounts[i];
-}
-
 /* Oscillators and PLLs are not gated at runtime */
 static bool clock_is_always_on(unsigned long id)
 {
@@ -1101,11 +1141,10 @@ static bool clock_is_always_on(unsigned long id)
 	}
 }
 
-void __stm32mp1_clk_enable(unsigned long id, bool secure)
+static void __stm32mp1_clk_enable(unsigned long id, bool with_refcnt)
 {
 	const struct stm32mp1_clk_gate *gate;
 	int i;
-	unsigned int *refcnt;
 
 	if (clock_is_always_on(id)) {
 		return;
@@ -1118,22 +1157,38 @@ void __stm32mp1_clk_enable(unsigned long id, bool secure)
 	}
 
 	gate = gate_ref(i);
-	refcnt = &gate_refcounts[i];
+
+	if (!with_refcnt) {
+		__clk_enable(gate);
+		return;
+	}
+
+#if defined(IMAGE_BL32)
+	if (gate_is_non_secure(gate)) {
+		/* Enable non-secure clock w/o any refcounting */
+		__clk_enable(gate);
+		return;
+	}
+#endif
 
 	stm32mp1_clk_lock(&refcount_lock);
 
-	if (stm32mp_incr_shrefcnt(refcnt, secure) != 0) {
+	if (gate_refcounts[i] == 0) {
 		__clk_enable(gate);
 	}
 
+	gate_refcounts[i]++;
+	if (gate_refcounts[i] == UINT_MAX) {
+		panic();
+	}
+
 	stm32mp1_clk_unlock(&refcount_lock);
 }
 
-void __stm32mp1_clk_disable(unsigned long id, bool secure)
+static void __stm32mp1_clk_disable(unsigned long id, bool with_refcnt)
 {
 	const struct stm32mp1_clk_gate *gate;
 	int i;
-	unsigned int *refcnt;
 
 	if (clock_is_always_on(id)) {
 		return;
@@ -1146,28 +1201,56 @@ void __stm32mp1_clk_disable(unsigned long id, bool secure)
 	}
 
 	gate = gate_ref(i);
-	refcnt = &gate_refcounts[i];
+
+	if (!with_refcnt) {
+		__clk_disable(gate);
+		return;
+	}
+
+#if defined(IMAGE_BL32)
+	if (gate_is_non_secure(gate)) {
+		/* Don't disable non-secure clocks */
+		return;
+	}
+#endif
 
 	stm32mp1_clk_lock(&refcount_lock);
 
-	if (stm32mp_decr_shrefcnt(refcnt, secure) != 0) {
+	if (gate_refcounts[i] == 0) {
+		panic();
+	}
+	gate_refcounts[i]--;
+
+	if (gate_refcounts[i] == 0) {
 		__clk_disable(gate);
 	}
 
 	stm32mp1_clk_unlock(&refcount_lock);
 }
 
-void stm32mp_clk_enable(unsigned long id)
+static int stm32mp_clk_enable(unsigned long id)
 {
 	__stm32mp1_clk_enable(id, true);
+
+	return 0;
 }
 
-void stm32mp_clk_disable(unsigned long id)
+static void stm32mp_clk_disable(unsigned long id)
 {
 	__stm32mp1_clk_disable(id, true);
 }
 
-bool stm32mp_clk_is_enabled(unsigned long id)
+void stm32mp1_clk_force_enable(unsigned long id)
+{
+	__stm32mp1_clk_enable(id, false);
+}
+
+void stm32mp1_clk_force_disable(unsigned long id)
+{
+	__stm32mp1_clk_disable(id, false);
+}
+
+static bool stm32mp_clk_is_enabled(unsigned long id)
 {
 	int i;
 
@@ -1183,15 +1266,55 @@ bool stm32mp_clk_is_enabled(unsigned long id)
 	return __clk_is_enabled(gate_ref(i));
 }
 
-unsigned long stm32mp_clk_get_rate(unsigned long id)
+static unsigned long stm32mp_clk_get_rate(unsigned long id)
 {
+	uintptr_t rcc_base = stm32mp_rcc_base();
 	int p = stm32mp1_clk_get_parent(id);
+	uint32_t prescaler, timpre;
+	unsigned long parent_rate;
 
 	if (p < 0) {
 		return 0;
 	}
 
-	return get_clock_rate(p);
+	parent_rate = get_clock_rate(p);
+
+	switch (id) {
+	case TIM2_K:
+	case TIM3_K:
+	case TIM4_K:
+	case TIM5_K:
+	case TIM6_K:
+	case TIM7_K:
+	case TIM12_K:
+	case TIM13_K:
+	case TIM14_K:
+		prescaler = mmio_read_32(rcc_base + RCC_APB1DIVR) &
+			    RCC_APBXDIV_MASK;
+		timpre = mmio_read_32(rcc_base + RCC_TIMG1PRER) &
+			 RCC_TIMGXPRER_TIMGXPRE;
+		break;
+
+	case TIM1_K:
+	case TIM8_K:
+	case TIM15_K:
+	case TIM16_K:
+	case TIM17_K:
+		prescaler = mmio_read_32(rcc_base + RCC_APB2DIVR) &
+			    RCC_APBXDIV_MASK;
+		timpre = mmio_read_32(rcc_base + RCC_TIMG2PRER) &
+			 RCC_TIMGXPRER_TIMGXPRE;
+		break;
+
+	default:
+		return parent_rate;
+	}
+
+	if (prescaler == 0U) {
+		return parent_rate;
+	}
+
+	return parent_rate * (timpre + 1U) * 2U;
 }
 
 static void stm32mp1_ls_osc_set(bool enable, uint32_t offset, uint32_t mask_on)
@@ -1242,6 +1365,11 @@ static void stm32mp1_lse_enable(bool bypass, bool digbyp, uint32_t lsedrv)
 	uint32_t value;
 	uintptr_t rcc_base = stm32mp_rcc_base();
 
+	/* Do not reconfigure LSE if it is already ON */
+	if ((mmio_read_32(rcc_base + RCC_BDCR) & RCC_BDCR_LSEON) == RCC_BDCR_LSEON) {
+		return;
+	}
+
 	if (digbyp) {
 		mmio_setbits_32(rcc_base + RCC_BDCR, RCC_BDCR_DIGBYP);
 	}
@@ -1308,6 +1436,13 @@ static void stm32mp1_hse_enable(bool bypass, bool digbyp, bool css)
 	if (css) {
 		mmio_write_32(rcc_base + RCC_OCENSETR, RCC_OCENR_HSECSSON);
 	}
+
+#if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
+	if ((mmio_read_32(rcc_base + RCC_OCENSETR) & RCC_OCENR_HSEBYP) &&
+	    (!(digbyp || bypass))) {
+		panic();
+	}
+#endif
 }
 
 static void stm32mp1_csi_set(bool enable)
@@ -1507,11 +1642,8 @@ static int stm32mp1_pll_stop(enum stm32mp1_pll_id pll_id)
 	return 0;
 }
 
-static void stm32mp1_pll_config_output(enum stm32mp1_pll_id pll_id,
-				       uint32_t *pllcfg)
+static uint32_t stm32mp1_pll_compute_pllxcfgr2(uint32_t *pllcfg)
 {
-	const struct stm32mp1_clk_pll *pll = pll_ref(pll_id);
-	uintptr_t rcc_base = stm32mp_rcc_base();
 	uint32_t value;
 
 	value = (pllcfg[PLLCFG_P] << RCC_PLLNCFGR2_DIVP_SHIFT) &
@@ -1520,21 +1652,33 @@ static void stm32mp1_pll_config_output(enum stm32mp1_pll_id pll_id,
 		 RCC_PLLNCFGR2_DIVQ_MASK;
 	value |= (pllcfg[PLLCFG_R] << RCC_PLLNCFGR2_DIVR_SHIFT) &
 		 RCC_PLLNCFGR2_DIVR_MASK;
-	mmio_write_32(rcc_base + pll->pllxcfgr2, value);
+
+	return value;
 }
 
-static int stm32mp1_pll_config(enum stm32mp1_pll_id pll_id,
-			       uint32_t *pllcfg, uint32_t fracv)
+static void stm32mp1_pll_config_output(enum stm32mp1_pll_id pll_id,
+				       uint32_t *pllcfg)
 {
 	const struct stm32mp1_clk_pll *pll = pll_ref(pll_id);
+	uintptr_t rcc_base = stm32mp_rcc_base();
+	uint32_t value;
+
+	value = stm32mp1_pll_compute_pllxcfgr2(pllcfg);
+
+	mmio_write_32(rcc_base + pll->pllxcfgr2, value);
+}
+
+static int stm32mp1_pll_compute_pllxcfgr1(const struct stm32mp1_clk_pll *pll,
+					  uint32_t *pllcfg, uint32_t *cfgr1)
+{
 	uintptr_t rcc_base = stm32mp_rcc_base();
 	enum stm32mp1_plltype type = pll->plltype;
 	unsigned long refclk;
 	uint32_t ifrge = 0;
-	uint32_t src, value;
+	uint32_t src;
 
 	src = mmio_read_32(rcc_base + pll->rckxselr) &
-		RCC_SELR_REFCLK_SRC_MASK;
+	      RCC_SELR_REFCLK_SRC_MASK;
 
 	refclk = stm32mp1_clk_get_fixed(pll->refclk[src]) /
 		 (pllcfg[PLLCFG_M] + 1U);
@@ -1548,23 +1692,39 @@ static int stm32mp1_pll_config(enum stm32mp1_pll_id pll_id,
 		ifrge = 1U;
 	}
 
-	value = (pllcfg[PLLCFG_N] << RCC_PLLNCFGR1_DIVN_SHIFT) &
-		RCC_PLLNCFGR1_DIVN_MASK;
-	value |= (pllcfg[PLLCFG_M] << RCC_PLLNCFGR1_DIVM_SHIFT) &
-		 RCC_PLLNCFGR1_DIVM_MASK;
-	value |= (ifrge << RCC_PLLNCFGR1_IFRGE_SHIFT) &
-		 RCC_PLLNCFGR1_IFRGE_MASK;
+	*cfgr1 = (pllcfg[PLLCFG_N] << RCC_PLLNCFGR1_DIVN_SHIFT) &
+		 RCC_PLLNCFGR1_DIVN_MASK;
+	*cfgr1 |= (pllcfg[PLLCFG_M] << RCC_PLLNCFGR1_DIVM_SHIFT) &
+		  RCC_PLLNCFGR1_DIVM_MASK;
+	*cfgr1 |= (ifrge << RCC_PLLNCFGR1_IFRGE_SHIFT) &
+		  RCC_PLLNCFGR1_IFRGE_MASK;
+
+	return 0;
+}
+
+static int stm32mp1_pll_config(enum stm32mp1_pll_id pll_id,
+			       uint32_t *pllcfg, uint32_t fracv)
+{
+	const struct stm32mp1_clk_pll *pll = pll_ref(pll_id);
+	uintptr_t rcc_base = stm32mp_rcc_base();
+	uint32_t value;
+	int ret;
+
+	ret = stm32mp1_pll_compute_pllxcfgr1(pll, pllcfg, &value);
+	if (ret != 0) {
+		return ret;
+	}
+
 	mmio_write_32(rcc_base + pll->pllxcfgr1, value);
 
 	/* Fractional configuration */
 	value = 0;
 	mmio_write_32(rcc_base + pll->pllxfracr, value);
 
+	/*  Frac must be enabled only once its configuration is loaded */
 	value = fracv << RCC_PLLNFRACR_FRACV_SHIFT;
 	mmio_write_32(rcc_base + pll->pllxfracr, value);
-
-	value |= RCC_PLLNFRACR_FRACLE;
-	mmio_write_32(rcc_base + pll->pllxfracr, value);
+	mmio_setbits_32(rcc_base + pll->pllxfracr, RCC_PLLNFRACR_FRACLE);
 
 	stm32mp1_pll_config_output(pll_id, pllcfg);
 
@@ -1671,48 +1831,41 @@ static void stm32mp1_set_rtcsrc(unsigned int clksrc, bool lse_css)
 	}
 }
 
-static void stm32mp1_stgen_config(void)
+/*******************************************************************************
+ * This function determines the number of needed RTC calendar read operations
+ * to get consistent values (1 or 2 depending on clock frequencies).
+ * If APB1 frequency is lower than 7 times the RTC one, the software has to
+ * read the calendar time and date registers twice.
+ * Returns true if read twice is needed, false else.
+ ******************************************************************************/
+bool stm32mp1_rtc_get_read_twice(void)
 {
-	uint32_t cntfid0;
-	unsigned long rate;
-	unsigned long long counter;
-
-	cntfid0 = mmio_read_32(STGEN_BASE + CNTFID_OFF);
-	rate = get_clock_rate(stm32mp1_clk_get_parent(STGEN_K));
+	unsigned long apb1_freq;
+	uint32_t rtc_freq;
+	uint32_t apb1_div;
+	uintptr_t rcc_base = stm32mp_rcc_base();
 
-	if (cntfid0 == rate) {
-		return;
+	switch ((mmio_read_32(rcc_base + RCC_BDCR) &
+		 RCC_BDCR_RTCSRC_MASK) >> RCC_BDCR_RTCSRC_SHIFT) {
+	case 1:
+		rtc_freq = stm32mp_clk_get_rate(CK_LSE);
+		break;
+	case 2:
+		rtc_freq = stm32mp_clk_get_rate(CK_LSI);
+		break;
+	case 3:
+		rtc_freq = stm32mp_clk_get_rate(CK_HSE);
+		rtc_freq /= (mmio_read_32(rcc_base + RCC_RTCDIVR) &
+			     RCC_DIVR_DIV_MASK) + 1U;
+		break;
+	default:
+		panic();
 	}
 
-	mmio_clrbits_32(STGEN_BASE + CNTCR_OFF, CNTCR_EN);
-	counter = (unsigned long long)mmio_read_32(STGEN_BASE + CNTCVL_OFF);
-	counter |= ((unsigned long long)mmio_read_32(STGEN_BASE + CNTCVU_OFF)) << 32;
-	counter = (counter * rate / cntfid0);
-
-	mmio_write_32(STGEN_BASE + CNTCVL_OFF, (uint32_t)counter);
-	mmio_write_32(STGEN_BASE + CNTCVU_OFF, (uint32_t)(counter >> 32));
-	mmio_write_32(STGEN_BASE + CNTFID_OFF, rate);
-	mmio_setbits_32(STGEN_BASE + CNTCR_OFF, CNTCR_EN);
-
-	write_cntfrq((u_register_t)rate);
-
-	/* Need to update timer with new frequency */
-	generic_delay_timer_init();
-}
-
-void stm32mp1_stgen_increment(unsigned long long offset_in_ms)
-{
-	unsigned long long cnt;
-
-	cnt = ((unsigned long long)mmio_read_32(STGEN_BASE + CNTCVU_OFF) << 32) |
-		mmio_read_32(STGEN_BASE + CNTCVL_OFF);
-
-	cnt += (offset_in_ms * mmio_read_32(STGEN_BASE + CNTFID_OFF)) / 1000U;
+	apb1_div = mmio_read_32(rcc_base + RCC_APB1DIVR) & RCC_APBXDIV_MASK;
+	apb1_freq = stm32mp_clk_get_rate(CK_MCU) >> apb1_div;
 
-	mmio_clrbits_32(STGEN_BASE + CNTCR_OFF, CNTCR_EN);
-	mmio_write_32(STGEN_BASE + CNTCVL_OFF, (uint32_t)cnt);
-	mmio_write_32(STGEN_BASE + CNTCVU_OFF, (uint32_t)(cnt >> 32));
-	mmio_setbits_32(STGEN_BASE + CNTCR_OFF, CNTCR_EN);
+	return apb1_freq < (rtc_freq * 7U);
 }
 
 static void stm32mp1_pkcs_config(uint32_t pkcs)
@@ -1729,152 +1882,743 @@ static void stm32mp1_pkcs_config(uint32_t pkcs)
 	mmio_clrsetbits_32(address, mask, value);
 }
 
-int stm32mp1_clk_init(void)
+static bool clk_pll1_settings_are_valid(void)
 {
-	uintptr_t rcc_base = stm32mp_rcc_base();
-	unsigned int clksrc[CLKSRC_NB];
-	unsigned int clkdiv[CLKDIV_NB];
-	unsigned int pllcfg[_PLL_NB][PLLCFG_NB];
-	int plloff[_PLL_NB];
-	int ret, len;
-	enum stm32mp1_pll_id i;
-	bool lse_css = false;
-	bool pll3_preserve = false;
-	bool pll4_preserve = false;
-	bool pll4_bootrom = false;
-	const fdt32_t *pkcs_cell;
-	void *fdt;
+	return pll1_settings.valid_id == PLL1_SETTINGS_VALID_ID;
+}
 
-	if (fdt_get_address(&fdt) == 0) {
-		return -FDT_ERR_NOTFOUND;
-	}
+#if defined(IMAGE_BL32)
+int stm32mp1_round_opp_khz(uint32_t *freq_khz)
+{
+	unsigned int i;
+	uint32_t round_opp = 0U;
+
+	if (!clk_pll1_settings_are_valid()) {
+		/*
+		 * No OPP table in DT, or an error occurred during PLL1
+		 * settings computation, system can only work on current
+		 * operating point, so return current CPU frequency.
+		 */
+		*freq_khz = current_opp_khz;
 
-	/* Check status field to disable security */
-	if (!fdt_get_rcc_secure_status()) {
-		mmio_write_32(rcc_base + RCC_TZCR, 0);
+		return 0;
 	}
 
-	ret = fdt_rcc_read_uint32_array("st,clksrc", (uint32_t)CLKSRC_NB,
-					clksrc);
-	if (ret < 0) {
-		return -FDT_ERR_NOTFOUND;
+	for (i = 0; i < PLAT_MAX_OPP_NB; i++) {
+		if ((pll1_settings.freq[i] <= *freq_khz) &&
+		    (pll1_settings.freq[i] > round_opp)) {
+			round_opp = pll1_settings.freq[i];
+		}
 	}
 
-	ret = fdt_rcc_read_uint32_array("st,clkdiv", (uint32_t)CLKDIV_NB,
-					clkdiv);
-	if (ret < 0) {
-		return -FDT_ERR_NOTFOUND;
+	*freq_khz = round_opp;
+
+	return 0;
+}
+
+/*
+ * Check if PLL1 can be configured on the fly.
+ * @result (-1) => config on the fly is not possible.
+ *         (0)  => config on the fly is possible.
+ *         (+1) => same parameters, no need to reconfigure.
+ * Return value is 0 if no error.
+ */
+static int stm32mp1_is_pll_config_on_the_fly(enum stm32mp1_pll_id pll_id,
+					     uint32_t *pllcfg, uint32_t fracv,
+					     int *result)
+{
+	const struct stm32mp1_clk_pll *pll = pll_ref(pll_id);
+	uintptr_t rcc_base = stm32mp_rcc_base();
+	uint32_t fracr;
+	uint32_t value;
+	int ret;
+
+	ret = stm32mp1_pll_compute_pllxcfgr1(pll, pllcfg, &value);
+	if (ret != 0) {
+		return ret;
 	}
 
-	for (i = (enum stm32mp1_pll_id)0; i < _PLL_NB; i++) {
-		char name[12];
+	if (mmio_read_32(rcc_base + pll->pllxcfgr1) != value) {
+		/* Different DIVN/DIVM, can't config on the fly */
+		*result = -1;
+		return 0;
+	}
 
-		snprintf(name, sizeof(name), "st,pll@%d", i);
-		plloff[i] = fdt_rcc_subnode_offset(name);
+	*result = true;
 
-		if (!fdt_check_node(plloff[i])) {
-			continue;
-		}
+	fracr = fracv << RCC_PLLNFRACR_FRACV_SHIFT;
+	fracr |= RCC_PLLNFRACR_FRACLE;
+	value = stm32mp1_pll_compute_pllxcfgr2(pllcfg);
 
-		ret = fdt_read_uint32_array(fdt, plloff[i], "cfg",
-					    (int)PLLCFG_NB, pllcfg[i]);
-		if (ret < 0) {
-			return -FDT_ERR_NOTFOUND;
-		}
+	if ((mmio_read_32(rcc_base + pll->pllxfracr) == fracr) &&
+	    (mmio_read_32(rcc_base + pll->pllxcfgr2) == value)) {
+		/* Same parameters, no need to config */
+		*result = 1;
+	} else {
+		*result = 0;
 	}
 
-	stm32mp1_mco_csg(clksrc[CLKSRC_MCO1], clkdiv[CLKDIV_MCO1]);
-	stm32mp1_mco_csg(clksrc[CLKSRC_MCO2], clkdiv[CLKDIV_MCO2]);
+	return 0;
+}
 
-	/*
-	 * Switch ON oscillator found in device-tree.
-	 * Note: HSI already ON after BootROM stage.
-	 */
-	if (stm32mp1_osc[_LSI] != 0U) {
-		stm32mp1_lsi_set(true);
+static int stm32mp1_get_mpu_div(uint32_t freq_khz)
+{
+	unsigned long freq_pll1_p;
+	unsigned long div;
+
+	freq_pll1_p = get_clock_rate(_PLL1_P) / 1000UL;
+	if ((freq_pll1_p % freq_khz) != 0U) {
+		return -1;
 	}
-	if (stm32mp1_osc[_LSE] != 0U) {
-		bool bypass, digbyp;
-		uint32_t lsedrv;
 
-		bypass = fdt_osc_read_bool(_LSE, "st,bypass");
-		digbyp = fdt_osc_read_bool(_LSE, "st,digbypass");
-		lse_css = fdt_osc_read_bool(_LSE, "st,css");
-		lsedrv = fdt_osc_read_uint32_default(_LSE, "st,drive",
-						     LSEDRV_MEDIUM_HIGH);
-		stm32mp1_lse_enable(bypass, digbyp, lsedrv);
+	div = freq_pll1_p / freq_khz;
+
+	switch (div) {
+	case 1UL:
+	case 2UL:
+	case 4UL:
+	case 8UL:
+	case 16UL:
+		return __builtin_ffs(div) - 1;
+	default:
+		return -1;
 	}
-	if (stm32mp1_osc[_HSE] != 0U) {
-		bool bypass, digbyp, css;
+}
 
-		bypass = fdt_osc_read_bool(_HSE, "st,bypass");
-		digbyp = fdt_osc_read_bool(_HSE, "st,digbypass");
-		css = fdt_osc_read_bool(_HSE, "st,css");
-		stm32mp1_hse_enable(bypass, digbyp, css);
+static int stm32mp1_pll1_config_from_opp_khz(uint32_t freq_khz)
+{
+	unsigned int i;
+	int ret;
+	int div;
+	int config_on_the_fly = -1;
+
+	for (i = 0; i < PLAT_MAX_OPP_NB; i++) {
+		if (pll1_settings.freq[i] == freq_khz) {
+			break;
+		}
 	}
-	/*
-	 * CSI is mandatory for automatic I/O compensation (SYSCFG_CMPCR)
-	 * => switch on CSI even if node is not present in device tree
-	 */
-	stm32mp1_csi_set(true);
 
-	/* Come back to HSI */
-	ret = stm32mp1_set_clksrc(CLK_MPU_HSI);
-	if (ret != 0) {
-		return ret;
+	if (i == PLAT_MAX_OPP_NB) {
+		return -ENXIO;
 	}
-	ret = stm32mp1_set_clksrc(CLK_AXI_HSI);
-	if (ret != 0) {
+
+	div = stm32mp1_get_mpu_div(freq_khz);
+
+	switch (div) {
+	case -1:
+		break;
+	case 0:
+		return stm32mp1_set_clksrc(CLK_MPU_PLL1P);
+	default:
+		ret = stm32mp1_set_clkdiv(div, stm32mp_rcc_base() +
+					  RCC_MPCKDIVR);
+		if (ret == 0) {
+			ret = stm32mp1_set_clksrc(CLK_MPU_PLL1P_DIV);
+		}
 		return ret;
 	}
-	ret = stm32mp1_set_clksrc(CLK_MCU_HSI);
+
+	ret = stm32mp1_is_pll_config_on_the_fly(_PLL1, &pll1_settings.cfg[i][0],
+						pll1_settings.frac[i],
+						&config_on_the_fly);
 	if (ret != 0) {
 		return ret;
 	}
 
-	if ((mmio_read_32(rcc_base + RCC_MP_RSTSCLRR) &
-	     RCC_MP_RSTSCLRR_MPUP0RSTF) != 0) {
-		pll3_preserve = stm32mp1_check_pll_conf(_PLL3,
-							clksrc[CLKSRC_PLL3],
-							pllcfg[_PLL3],
-							plloff[_PLL3]);
-		pll4_preserve = stm32mp1_check_pll_conf(_PLL4,
-							clksrc[CLKSRC_PLL4],
-							pllcfg[_PLL4],
-							plloff[_PLL4]);
+	if (config_on_the_fly == 1) {
+		/*  No need to reconfigure, setup already OK */
+		return 0;
 	}
 
-	for (i = (enum stm32mp1_pll_id)0; i < _PLL_NB; i++) {
-		if (((i == _PLL3) && pll3_preserve) ||
-		    ((i == _PLL4) && pll4_preserve)) {
-			continue;
-		}
-
-		ret = stm32mp1_pll_stop(i);
+	if (config_on_the_fly == -1) {
+		/* Switch to HSI and stop PLL1 before reconfiguration */
+		ret = stm32mp1_set_clksrc(CLK_MPU_HSI);
 		if (ret != 0) {
 			return ret;
 		}
-	}
 
-	/* Configure HSIDIV */
-	if (stm32mp1_osc[_HSI] != 0U) {
-		ret = stm32mp1_hsidiv(stm32mp1_osc[_HSI]);
+		ret = stm32mp1_pll_stop(_PLL1);
 		if (ret != 0) {
 			return ret;
 		}
-		stm32mp1_stgen_config();
 	}
 
-	/* Select DIV */
-	/* No ready bit when MPUSRC != CLK_MPU_PLL1P_DIV, MPUDIV is disabled */
-	mmio_write_32(rcc_base + RCC_MPCKDIVR,
-		      clkdiv[CLKDIV_MPU] & RCC_DIVR_DIV_MASK);
-	ret = stm32mp1_set_clkdiv(clkdiv[CLKDIV_AXI], rcc_base + RCC_AXIDIVR);
+	ret = stm32mp1_pll_config(_PLL1, &pll1_settings.cfg[i][0],
+				  pll1_settings.frac[i]);
 	if (ret != 0) {
 		return ret;
 	}
-	ret = stm32mp1_set_clkdiv(clkdiv[CLKDIV_APB4], rcc_base + RCC_APB4DIVR);
-	if (ret != 0) {
+
+	if (config_on_the_fly == -1) {
+		/* Start PLL1 and switch back to after reconfiguration */
+		stm32mp1_pll_start(_PLL1);
+
+		ret = stm32mp1_pll_output(_PLL1,
+					  pll1_settings.cfg[i][PLLCFG_O]);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = stm32mp1_set_clksrc(CLK_MPU_PLL1P);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+int stm32mp1_set_opp_khz(uint32_t freq_khz)
+{
+	uintptr_t rcc_base = stm32mp_rcc_base();
+	uint32_t mpu_src;
+
+	if (freq_khz == current_opp_khz) {
+		/* OPP already set, nothing to do */
+		return 0;
+	}
+
+	if (!clk_pll1_settings_are_valid()) {
+		/*
+		 * No OPP table in DT or an error occurred during PLL1
+		 * settings computation, system can only work on current
+		 * operating point so return error.
+		 */
+		return -EACCES;
+	}
+
+	/* Check that PLL1 is MPU clock source */
+	mpu_src = mmio_read_32(rcc_base + RCC_MPCKSELR) & RCC_SELR_SRC_MASK;
+	if ((mpu_src != RCC_MPCKSELR_PLL) &&
+	    (mpu_src != RCC_MPCKSELR_PLL_MPUDIV)) {
+		return -EPERM;
+	}
+
+	if (stm32mp1_pll1_config_from_opp_khz(freq_khz) != 0) {
+		/* Restore original value */
+		if (stm32mp1_pll1_config_from_opp_khz(current_opp_khz) != 0) {
+			ERROR("No CPU operating point can be set\n");
+			panic();
+		}
+
+		return -EIO;
+	}
+
+	current_opp_khz = freq_khz;
+
+	return 0;
+}
+#endif /* IMAGE_BL32 */
+
+static int clk_get_pll_settings_from_dt(int plloff, unsigned int *pllcfg,
+					uint32_t *fracv, uint32_t *csg,
+					bool *csg_set)
+{
+	void *fdt;
+	int ret;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	ret = fdt_read_uint32_array(fdt, plloff, "cfg", (uint32_t)PLLCFG_NB,
+				    pllcfg);
+	if (ret < 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	*fracv = fdt_read_uint32_default(fdt, plloff, "frac", 0);
+
+	ret = fdt_read_uint32_array(fdt, plloff, "csg", (uint32_t)PLLCSG_NB,
+				    csg);
+
+	*csg_set = (ret == 0);
+
+	if (ret == -FDT_ERR_NOTFOUND) {
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static int clk_compute_pll1_settings(unsigned long input_freq,
+				     uint32_t freq_khz,
+				     uint32_t *pllcfg, uint32_t *fracv)
+{
+	unsigned long long output_freq = freq_khz * 1000U;
+	unsigned long long freq;
+	unsigned long long vco;
+	int divm;
+	int divn;
+	int divp;
+	int frac;
+	int i;
+	unsigned int diff;
+	unsigned int best_diff = UINT_MAX;
+
+	/* Following parameters have always the same value */
+	pllcfg[PLLCFG_Q] = 0;
+	pllcfg[PLLCFG_R] = 0;
+	pllcfg[PLLCFG_O] = PQR(1, 0, 0);
+
+	for (divm = DIVM_MAX; divm >= DIVM_MIN; divm--)	{
+		unsigned long post_divm = input_freq /
+					  (unsigned long)(divm + 1);
+
+		if ((post_divm < POST_DIVM_MIN) ||
+		    (post_divm > POST_DIVM_MAX)) {
+			continue;
+		}
+
+		for (divp = DIVP_MIN; divp <= DIVP_MAX; divp++) {
+
+			freq = output_freq * (divm + 1) * (divp + 1);
+
+			divn = (int)((freq / input_freq) - 1);
+			if ((divn < DIVN_MIN) || (divn > DIVN_MAX)) {
+				continue;
+			}
+
+			frac = (int)(((freq * FRAC_MAX) / input_freq) -
+				     ((divn + 1) * FRAC_MAX));
+
+			/* 2 loops to refine the fractional part */
+			for (i = 2; i != 0; i--) {
+				if (frac > FRAC_MAX) {
+					break;
+				}
+
+				vco = (post_divm * (divn + 1)) +
+				      ((post_divm * (unsigned long long)frac) /
+				       FRAC_MAX);
+
+				if ((vco < (VCO_MIN / 2)) ||
+				    (vco > (VCO_MAX / 2))) {
+					frac++;
+					continue;
+				}
+
+				freq = vco / (divp + 1);
+				if (output_freq < freq) {
+					diff = (unsigned int)(freq -
+							      output_freq);
+				} else {
+					diff = (unsigned int)(output_freq -
+							      freq);
+				}
+
+				if (diff < best_diff)  {
+					pllcfg[PLLCFG_M] = divm;
+					pllcfg[PLLCFG_N] = divn;
+					pllcfg[PLLCFG_P] = divp;
+					*fracv = frac;
+
+					if (diff == 0) {
+						return 0;
+					}
+
+					best_diff = diff;
+				}
+
+				frac++;
+			}
+		}
+	}
+
+	if (best_diff == UINT_MAX) {
+		return -1;
+	}
+
+	return 0;
+}
+
+static int clk_get_pll1_settings(uint32_t clksrc, uint32_t freq_khz,
+				 uint32_t *pllcfg, uint32_t *fracv)
+{
+	unsigned int i;
+
+	assert(pllcfg != NULL);
+	assert(fracv != NULL);
+
+	for (i = 0; i < PLAT_MAX_OPP_NB; i++) {
+		if (pll1_settings.freq[i] == freq_khz) {
+			break;
+		}
+	}
+
+	if (((i == PLAT_MAX_OPP_NB) && (pll1_settings.valid_id == 0U)) ||
+	    ((i < PLAT_MAX_OPP_NB) &&
+	     (pll1_settings.cfg[i][PLLCFG_O] == 0U))) {
+		unsigned long input_freq;
+
+		/*
+		 * Either PLL1 settings structure is completely empty,
+		 * or these settings are not yet computed: do it.
+		 */
+		switch (clksrc) {
+		case CLK_PLL12_HSI:
+			input_freq = stm32mp_clk_get_rate(CK_HSI);
+			break;
+		case CLK_PLL12_HSE:
+			input_freq = stm32mp_clk_get_rate(CK_HSE);
+			break;
+		default:
+			panic();
+		}
+
+		return clk_compute_pll1_settings(input_freq, freq_khz, pllcfg,
+						 fracv);
+	}
+
+	if ((i < PLAT_MAX_OPP_NB) &&
+	    (pll1_settings.cfg[i][PLLCFG_O] != 0U)) {
+		/*
+		 * Index is in range and PLL1 settings are computed:
+		 * use content to answer to the request.
+		 */
+		memcpy(pllcfg, &pll1_settings.cfg[i][0],
+		       sizeof(uint32_t) * PLAT_MAX_PLLCFG_NB);
+		*fracv = pll1_settings.frac[i];
+
+		return 0;
+	}
+
+	return -1;
+}
+
+int stm32mp1_clk_get_maxfreq_opp(uint32_t *freq_khz,
+				 uint32_t *voltage_mv)
+{
+	unsigned int i;
+	uint32_t freq = 0U;
+	uint32_t voltage = 0U;
+
+	assert(freq_khz != NULL);
+	assert(voltage_mv != NULL);
+
+	if (!clk_pll1_settings_are_valid()) {
+		return -1;
+	}
+
+	for (i = 0; i < PLAT_MAX_OPP_NB; i++) {
+		if (pll1_settings.freq[i] > freq) {
+			freq = pll1_settings.freq[i];
+			voltage = pll1_settings.volt[i];
+		}
+	}
+
+	if ((freq == 0U) || (voltage == 0U)) {
+		return -1;
+	}
+
+	*freq_khz = freq;
+	*voltage_mv = voltage;
+
+	return 0;
+}
+
+static int clk_save_current_pll1_settings(uint32_t buck1_voltage)
+{
+	const struct stm32mp1_clk_pll *pll = pll_ref(_PLL1);
+	uint32_t rcc_base = stm32mp_rcc_base();
+	uint32_t freq;
+	unsigned int i;
+
+	freq = udiv_round_nearest(stm32mp_clk_get_rate(CK_MPU), 1000L);
+
+	for (i = 0; i < PLAT_MAX_OPP_NB; i++) {
+		if (pll1_settings.freq[i] == freq) {
+			break;
+		}
+	}
+
+	if ((i == PLAT_MAX_OPP_NB) ||
+	    ((pll1_settings.volt[i] != buck1_voltage) &&
+	     (buck1_voltage != 0U))) {
+		return -1;
+	}
+
+	pll1_settings.cfg[i][PLLCFG_M] =
+		(mmio_read_32(rcc_base + pll->pllxcfgr1) &
+		 RCC_PLLNCFGR1_DIVM_MASK) >> RCC_PLLNCFGR1_DIVM_SHIFT;
+
+	pll1_settings.cfg[i][PLLCFG_N] =
+		(mmio_read_32(rcc_base + pll->pllxcfgr1) &
+		 RCC_PLLNCFGR1_DIVN_MASK) >> RCC_PLLNCFGR1_DIVN_SHIFT;
+
+	pll1_settings.cfg[i][PLLCFG_P] =
+		(mmio_read_32(rcc_base + pll->pllxcfgr2) &
+		 RCC_PLLNCFGR2_DIVP_MASK) >> RCC_PLLNCFGR2_DIVP_SHIFT;
+
+	pll1_settings.cfg[i][PLLCFG_Q] =
+		(mmio_read_32(rcc_base + pll->pllxcfgr2) &
+		 RCC_PLLNCFGR2_DIVQ_MASK) >> RCC_PLLNCFGR2_DIVQ_SHIFT;
+
+	pll1_settings.cfg[i][PLLCFG_R] =
+		(mmio_read_32(rcc_base + pll->pllxcfgr2) &
+		 RCC_PLLNCFGR2_DIVR_MASK) >> RCC_PLLNCFGR2_DIVR_SHIFT;
+
+	pll1_settings.cfg[i][PLLCFG_O] =
+		mmio_read_32(rcc_base + pll->pllxcr) >>
+		RCC_PLLNCR_DIVEN_SHIFT;
+
+	pll1_settings.frac[i] =
+		(mmio_read_32(rcc_base + pll->pllxfracr) &
+		 RCC_PLLNFRACR_FRACV_MASK) >> RCC_PLLNFRACR_FRACV_SHIFT;
+
+	return i;
+}
+
+static uint32_t stm32mp1_clk_get_pll1_current_clksrc(void)
+{
+	uint32_t value;
+	const struct stm32mp1_clk_pll *pll = pll_ref(_PLL1);
+	uint32_t rcc_base = stm32mp_rcc_base();
+
+	value = mmio_read_32(rcc_base + pll->rckxselr);
+
+	switch (value & RCC_SELR_REFCLK_SRC_MASK) {
+	case 0:
+		return CLK_PLL12_HSI;
+	case 1:
+		return CLK_PLL12_HSE;
+	default:
+		panic();
+	}
+}
+
+int stm32mp1_clk_compute_all_pll1_settings(uint32_t buck1_voltage)
+{
+	int i;
+	int ret;
+	int index;
+	uint32_t count = PLAT_MAX_OPP_NB;
+	uint32_t clksrc;
+
+	ret = dt_get_all_opp_freqvolt(&count, pll1_settings.freq,
+				      pll1_settings.volt);
+	switch (ret) {
+	case 0:
+		break;
+	case -FDT_ERR_NOTFOUND:
+		VERBOSE("Cannot find OPP table in DT, use default settings.\n");
+		return 0;
+	default:
+		ERROR("Inconsistent OPP settings found in DT, ignored.\n");
+		return 0;
+	}
+
+	index = clk_save_current_pll1_settings(buck1_voltage);
+
+	clksrc = stm32mp1_clk_get_pll1_current_clksrc();
+
+	for (i = 0; i < (int)count; i++) {
+		if (i == index) {
+			continue;
+		}
+
+		ret = clk_get_pll1_settings(clksrc, pll1_settings.freq[i],
+					    &pll1_settings.cfg[i][0],
+					    &pll1_settings.frac[i]);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	pll1_settings.valid_id = PLL1_SETTINGS_VALID_ID;
+
+	return 0;
+}
+
+void stm32mp1_clk_lp_save_opp_pll1_settings(uint8_t *data, size_t size)
+{
+	if (size != sizeof(pll1_settings) || !clk_pll1_settings_are_valid()) {
+		panic();
+	}
+
+	memcpy(data, &pll1_settings, size);
+}
+
+void stm32mp1_clk_lp_load_opp_pll1_settings(uint8_t *data, size_t size)
+{
+	if (size != sizeof(pll1_settings)) {
+		panic();
+	}
+
+	memcpy(&pll1_settings, data, size);
+}
+
+int stm32mp1_clk_init(uint32_t pll1_freq_khz)
+{
+	uintptr_t rcc_base = stm32mp_rcc_base();
+	uint32_t pllfracv[_PLL_NB];
+	uint32_t pllcsg[_PLL_NB][PLLCSG_NB];
+	unsigned int clksrc[CLKSRC_NB];
+	unsigned int clkdiv[CLKDIV_NB];
+	unsigned int pllcfg[_PLL_NB][PLLCFG_NB];
+	int plloff[_PLL_NB];
+	int ret, len;
+	enum stm32mp1_pll_id i;
+	bool pllcsg_set[_PLL_NB];
+	bool pllcfg_valid[_PLL_NB];
+	bool lse_css = false;
+	bool pll3_preserve = false;
+	bool pll4_preserve = false;
+	bool pll4_bootrom = false;
+	const fdt32_t *pkcs_cell;
+	void *fdt;
+	int stgen_p = stm32mp1_clk_get_parent(STGEN_K);
+	int usbphy_p = stm32mp1_clk_get_parent(USBPHY_K);
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	ret = fdt_rcc_read_uint32_array("st,clksrc", (uint32_t)CLKSRC_NB,
+					clksrc);
+	if (ret < 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	ret = fdt_rcc_read_uint32_array("st,clkdiv", (uint32_t)CLKDIV_NB,
+					clkdiv);
+	if (ret < 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	for (i = (enum stm32mp1_pll_id)0; i < _PLL_NB; i++) {
+		char name[12];
+
+		snprintf(name, sizeof(name), "st,pll@%d", i);
+		plloff[i] = fdt_rcc_subnode_offset(name);
+
+		pllcfg_valid[i] = fdt_check_node(plloff[i]);
+		if (pllcfg_valid[i]) {
+			ret = clk_get_pll_settings_from_dt(plloff[i], pllcfg[i],
+							   &pllfracv[i],
+							   pllcsg[i],
+							   &pllcsg_set[i]);
+			if (ret != 0) {
+				return ret;
+			}
+
+			continue;
+		}
+
+		if ((i == _PLL1) && (pll1_freq_khz != 0U)) {
+			ret = clk_get_pll1_settings(clksrc[CLKSRC_PLL12],
+						    pll1_freq_khz,
+						    pllcfg[i], &pllfracv[i]);
+			if (ret != 0) {
+				return ret;
+			}
+
+			pllcfg_valid[i] = true;
+		}
+	}
+
+	stm32mp1_mco_csg(clksrc[CLKSRC_MCO1], clkdiv[CLKDIV_MCO1]);
+	stm32mp1_mco_csg(clksrc[CLKSRC_MCO2], clkdiv[CLKDIV_MCO2]);
+
+	/*
+	 * Switch ON oscillator found in device-tree.
+	 * Note: HSI already ON after BootROM stage.
+	 */
+	if (stm32mp1_osc[_LSI] != 0U) {
+		stm32mp1_lsi_set(true);
+	}
+	if (stm32mp1_osc[_LSE] != 0U) {
+		const char *name = stm32mp_osc_node_label[_LSE];
+		bool bypass, digbyp;
+		uint32_t lsedrv;
+
+		bypass = fdt_clk_read_bool(name, "st,bypass");
+		digbyp = fdt_clk_read_bool(name, "st,digbypass");
+		lse_css = fdt_clk_read_bool(name, "st,css");
+		lsedrv = fdt_clk_read_uint32_default(name, "st,drive",
+						     LSEDRV_MEDIUM_HIGH);
+		stm32mp1_lse_enable(bypass, digbyp, lsedrv);
+	}
+	if (stm32mp1_osc[_HSE] != 0U) {
+		const char *name = stm32mp_osc_node_label[_HSE];
+		bool bypass, digbyp, css;
+
+		bypass = fdt_clk_read_bool(name, "st,bypass");
+		digbyp = fdt_clk_read_bool(name, "st,digbypass");
+		css = fdt_clk_read_bool(name, "st,css");
+		stm32mp1_hse_enable(bypass, digbyp, css);
+	}
+	/*
+	 * CSI is mandatory for automatic I/O compensation (SYSCFG_CMPCR)
+	 * => switch on CSI even if node is not present in device tree
+	 */
+	stm32mp1_csi_set(true);
+
+	/* Come back to HSI */
+	ret = stm32mp1_set_clksrc(CLK_MPU_HSI);
+	if (ret != 0) {
+		return ret;
+	}
+	ret = stm32mp1_set_clksrc(CLK_AXI_HSI);
+	if (ret != 0) {
+		return ret;
+	}
+	ret = stm32mp1_set_clksrc(CLK_MCU_HSI);
+	if (ret != 0) {
+		return ret;
+	}
+
+	if ((mmio_read_32(rcc_base + RCC_MP_RSTSCLRR) &
+	     RCC_MP_RSTSCLRR_MPUP0RSTF) != 0) {
+		pll3_preserve = stm32mp1_check_pll_conf(_PLL3,
+							clksrc[CLKSRC_PLL3],
+							pllcfg[_PLL3],
+							plloff[_PLL3]);
+		pll4_preserve = stm32mp1_check_pll_conf(_PLL4,
+							clksrc[CLKSRC_PLL4],
+							pllcfg[_PLL4],
+							plloff[_PLL4]);
+	}
+	/* Don't initialize PLL4, when used by BOOTROM */
+	if ((stm32mp_get_boot_itf_selected() ==
+	     BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB) &&
+	    ((stgen_p == (int)_PLL4_R) || (usbphy_p == (int)_PLL4_R))) {
+		pll4_bootrom = true;
+		pll4_preserve = true;
+	}
+
+	for (i = (enum stm32mp1_pll_id)0; i < _PLL_NB; i++) {
+		if (((i == _PLL3) && pll3_preserve) ||
+		    ((i == _PLL4) && pll4_preserve)) {
+			continue;
+		}
+
+		ret = stm32mp1_pll_stop(i);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	/* Configure HSIDIV */
+	if (stm32mp1_osc[_HSI] != 0U) {
+		ret = stm32mp1_hsidiv(stm32mp1_osc[_HSI]);
+		if (ret != 0) {
+			return ret;
+		}
+
+		stm32mp_stgen_config(stm32mp_clk_get_rate(STGEN_K));
+	}
+
+	/* Select DIV */
+	/* No ready bit when MPUSRC != CLK_MPU_PLL1P_DIV, MPUDIV is disabled */
+	mmio_write_32(rcc_base + RCC_MPCKDIVR,
+		      clkdiv[CLKDIV_MPU] & RCC_DIVR_DIV_MASK);
+	ret = stm32mp1_set_clkdiv(clkdiv[CLKDIV_AXI], rcc_base + RCC_AXIDIVR);
+	if (ret != 0) {
+		return ret;
+	}
+	ret = stm32mp1_set_clkdiv(clkdiv[CLKDIV_APB4], rcc_base + RCC_APB4DIVR);
+	if (ret != 0) {
 		return ret;
 	}
 	ret = stm32mp1_set_clkdiv(clkdiv[CLKDIV_APB5], rcc_base + RCC_APB5DIVR);
@@ -1924,15 +2668,12 @@ int stm32mp1_clk_init(void)
 
 	/* Configure and start PLLs */
 	for (i = (enum stm32mp1_pll_id)0; i < _PLL_NB; i++) {
-		uint32_t fracv;
-		uint32_t csg[PLLCSG_NB];
-
 		if (((i == _PLL3) && pll3_preserve) ||
 		    ((i == _PLL4) && pll4_preserve && !pll4_bootrom)) {
 			continue;
 		}
 
-		if (!fdt_check_node(plloff[i])) {
+		if (!pllcfg_valid[i]) {
 			continue;
 		}
 
@@ -1942,25 +2683,20 @@ int stm32mp1_clk_init(void)
 			continue;
 		}
 
-		fracv = fdt_read_uint32_default(fdt, plloff[i], "frac", 0);
-
-		ret = stm32mp1_pll_config(i, pllcfg[i], fracv);
+		ret = stm32mp1_pll_config(i, pllcfg[i], pllfracv[i]);
 		if (ret != 0) {
 			return ret;
 		}
-		ret = fdt_read_uint32_array(fdt, plloff[i], "csg",
-					    (uint32_t)PLLCSG_NB, csg);
-		if (ret == 0) {
-			stm32mp1_pll_csg(i, csg);
-		} else if (ret != -FDT_ERR_NOTFOUND) {
-			return ret;
+
+		if (pllcsg_set[i]) {
+			stm32mp1_pll_csg(i, pllcsg[i]);
 		}
 
 		stm32mp1_pll_start(i);
 	}
 	/* Wait and start PLLs ouptut when ready */
 	for (i = (enum stm32mp1_pll_id)0; i < _PLL_NB; i++) {
-		if (!fdt_check_node(plloff[i])) {
+		if (!pllcfg_valid[i]) {
 			continue;
 		}
 
@@ -1994,6 +2730,11 @@ int stm32mp1_clk_init(void)
 	if (pkcs_cell != NULL) {
 		bool ckper_disabled = false;
 		uint32_t j;
+		uint32_t usbreg_bootrom = 0U;
+
+		if (pll4_bootrom) {
+			usbreg_bootrom = mmio_read_32(rcc_base + RCC_USBCKSELR);
+		}
 
 		for (j = 0; j < ((uint32_t)len / sizeof(uint32_t)); j++) {
 			uint32_t pkcs = fdt32_to_cpu(pkcs_cell[j]);
@@ -2014,13 +2755,33 @@ int stm32mp1_clk_init(void)
 		if (ckper_disabled) {
 			stm32mp1_pkcs_config(CLK_CKPER_DISABLED);
 		}
+
+		if (pll4_bootrom) {
+			uint32_t usbreg_value, usbreg_mask;
+			const struct stm32mp1_clk_sel *sel;
+
+			sel = clk_sel_ref(_USBPHY_SEL);
+			usbreg_mask = (uint32_t)sel->msk << sel->src;
+			sel = clk_sel_ref(_USBO_SEL);
+			usbreg_mask |= (uint32_t)sel->msk << sel->src;
+
+			usbreg_value = mmio_read_32(rcc_base + RCC_USBCKSELR) &
+				       usbreg_mask;
+			usbreg_bootrom &= usbreg_mask;
+			if (usbreg_bootrom != usbreg_value) {
+				VERBOSE("forbidden new USB clk path\n");
+				VERBOSE("vs bootrom on USB boot\n");
+				return -FDT_ERR_BADVALUE;
+			}
+		}
 	}
 
 	/* Switch OFF HSI if not found in device-tree */
 	if (stm32mp1_osc[_HSI] == 0U) {
 		stm32mp1_hsi_set(false);
 	}
-	stm32mp1_stgen_config();
+
+	stm32mp_stgen_config(stm32mp_clk_get_rate(STGEN_K));
 
 	/* Software Self-Refresh mode (SSR) during DDR initilialization */
 	mmio_clrsetbits_32(rcc_base + RCC_DDRITFCR,
@@ -2210,6 +2971,410 @@ void stm32mp1_register_clock_parents_secure(unsigned long clock_id)
 }
 #endif /* STM32MP_SHARED_RESOURCES */
 
+#if defined(IMAGE_BL32)
+/*
+ * Sequence to save/restore the non-secure configuration.
+ * Restoring clocks and muxes need IPs to run on kernel clock
+ * hence on configuration is restored at resume, kernel clock
+ * should be disable: this mandates secure access.
+ *
+ * backup_mux*_cfg for the clock muxes.
+ * backup_clock_sc_cfg for the set/clear clock gating registers
+ * backup_clock_cfg for the regular full write registers
+ */
+
+struct backup_mux_cfg {
+	uint16_t offset;
+	uint8_t value;
+	uint8_t bit_len;
+};
+
+#define MUXCFG(_offset, _bit_len) \
+	{ .offset = (_offset), .bit_len = (_bit_len) }
+
+static struct backup_mux_cfg backup_mux0_cfg[] = {
+	MUXCFG(RCC_SDMMC12CKSELR, 3),
+	MUXCFG(RCC_SPI2S23CKSELR, 3),
+	MUXCFG(RCC_SPI45CKSELR, 3),
+	MUXCFG(RCC_I2C12CKSELR, 3),
+	MUXCFG(RCC_I2C35CKSELR, 3),
+	MUXCFG(RCC_LPTIM23CKSELR, 3),
+	MUXCFG(RCC_LPTIM45CKSELR, 3),
+	MUXCFG(RCC_UART24CKSELR, 3),
+	MUXCFG(RCC_UART35CKSELR, 3),
+	MUXCFG(RCC_UART78CKSELR, 3),
+	MUXCFG(RCC_SAI1CKSELR, 3),
+	MUXCFG(RCC_ETHCKSELR, 2),
+	MUXCFG(RCC_I2C46CKSELR, 3),
+	MUXCFG(RCC_RNG2CKSELR, 2),
+	MUXCFG(RCC_SDMMC3CKSELR, 3),
+	MUXCFG(RCC_FMCCKSELR, 2),
+	MUXCFG(RCC_QSPICKSELR, 2),
+	MUXCFG(RCC_USBCKSELR, 2),
+	MUXCFG(RCC_SPDIFCKSELR, 2),
+	MUXCFG(RCC_SPI2S1CKSELR, 3),
+	MUXCFG(RCC_CECCKSELR, 2),
+	MUXCFG(RCC_LPTIM1CKSELR, 3),
+	MUXCFG(RCC_UART6CKSELR, 3),
+	MUXCFG(RCC_FDCANCKSELR, 2),
+	MUXCFG(RCC_SAI2CKSELR, 3),
+	MUXCFG(RCC_SAI3CKSELR,  3),
+	MUXCFG(RCC_SAI4CKSELR, 3),
+	MUXCFG(RCC_ADCCKSELR, 2),
+	MUXCFG(RCC_DSICKSELR, 1),
+	MUXCFG(RCC_CPERCKSELR, 2),
+	MUXCFG(RCC_RNG1CKSELR, 2),
+	MUXCFG(RCC_STGENCKSELR, 2),
+	MUXCFG(RCC_UART1CKSELR, 3),
+	MUXCFG(RCC_SPI6CKSELR, 3),
+};
+
+static struct backup_mux_cfg backup_mux4_cfg[] = {
+	MUXCFG(RCC_USBCKSELR, 1),
+};
+
+static void backup_mux_cfg(void)
+{
+	uintptr_t base = stm32mp_rcc_base();
+	struct backup_mux_cfg *cfg;
+	size_t i;
+
+	cfg = backup_mux0_cfg;
+	for (i = 0U; i < ARRAY_SIZE(backup_mux0_cfg); i++) {
+		cfg[i].value = mmio_read_32(base + cfg[i].offset) &
+			       GENMASK_32(cfg[i].bit_len - 1U, 0U);
+	}
+
+	cfg = backup_mux4_cfg;
+	for (i = 0U; i < ARRAY_SIZE(backup_mux4_cfg); i++) {
+		cfg[i].value = mmio_read_32(base + cfg[i].offset) &
+			       GENMASK_32(4U + cfg[i].bit_len - 1U, 4U);
+	}
+}
+
+static void restore_mux_cfg(void)
+{
+	uintptr_t base = stm32mp_rcc_base();
+	struct backup_mux_cfg *cfg;
+	size_t i;
+
+	cfg = backup_mux0_cfg;
+	for (i = 0U; i < ARRAY_SIZE(backup_mux0_cfg); i++) {
+		uint32_t mask = GENMASK_32(cfg[i].bit_len - 1U, 0U);
+		uint32_t value = cfg[i].value & mask;
+
+		mmio_clrsetbits_32(base + cfg[i].offset, mask, value);
+	}
+
+	cfg = backup_mux4_cfg;
+	for (i = 0U; i < ARRAY_SIZE(backup_mux4_cfg); i++) {
+		uint32_t mask = GENMASK_32(4U + cfg[i].bit_len - 1U, 4U);
+		uint32_t value = cfg[i].value & mask;
+
+		mmio_clrsetbits_32(base + cfg[i].offset, mask, value);
+	}
+}
+
+/* Structure is used for set/clear registers and for regular registers */
+struct backup_clock_cfg {
+	uint32_t offset;
+	uint32_t value;
+};
+
+static struct backup_clock_cfg backup_clock_sc_cfg[] = {
+	{ .offset = RCC_MP_APB1ENSETR },
+	{ .offset = RCC_MP_APB2ENSETR },
+	{ .offset = RCC_MP_APB3ENSETR },
+	{ .offset = RCC_MP_APB4ENSETR },
+	{ .offset = RCC_MP_APB5ENSETR },
+	{ .offset = RCC_MP_AHB2ENSETR },
+	{ .offset = RCC_MP_AHB3ENSETR },
+	{ .offset = RCC_MP_AHB4ENSETR },
+	{ .offset = RCC_MP_AHB5ENSETR },
+	{ .offset = RCC_MP_AHB6ENSETR },
+	{ .offset = RCC_MP_MLAHBENSETR },
+};
+
+static struct backup_clock_cfg backup_clock_cfg[] = {
+	{ .offset = RCC_MCO1CFGR },
+	{ .offset = RCC_MCO2CFGR },
+	{ .offset = RCC_PLL3CR },
+	{ .offset = RCC_PLL4CR },
+	{ .offset = RCC_PLL4CFGR2 },
+	{ .offset = RCC_MCUDIVR },
+	{ .offset = RCC_MSSCKSELR },
+};
+
+static void backup_sc_cfg(void)
+{
+	struct backup_clock_cfg *cfg = backup_clock_sc_cfg;
+	size_t count = ARRAY_SIZE(backup_clock_sc_cfg);
+	uintptr_t base = stm32mp_rcc_base();
+	size_t i;
+
+	for (i = 0U; i < count; i++) {
+		cfg[i].value = mmio_read_32(base + cfg[i].offset);
+	}
+}
+
+static void restore_sc_cfg(void)
+{
+	struct backup_clock_cfg *cfg = backup_clock_sc_cfg;
+	size_t count = ARRAY_SIZE(backup_clock_sc_cfg);
+	uintptr_t base = stm32mp_rcc_base();
+	size_t i;
+
+	for (i = 0U; i < count; i++) {
+		mmio_write_32(base + cfg[i].offset, cfg[i].value);
+		mmio_write_32(base + cfg[i].offset + RCC_MP_ENCLRR_OFFSET,
+			      ~cfg[i].value);
+	}
+}
+
+static void backup_regular_cfg(void)
+{
+	struct backup_clock_cfg *cfg = backup_clock_cfg;
+	size_t count = ARRAY_SIZE(backup_clock_cfg);
+	uintptr_t base = stm32mp_rcc_base();
+	size_t i;
+
+	for (i = 0U; i < count; i++) {
+		cfg[i].value = mmio_read_32(base + cfg[i].offset);
+	}
+}
+
+static void restore_regular_cfg(void)
+{
+	struct backup_clock_cfg *cfg = backup_clock_cfg;
+	size_t count = ARRAY_SIZE(backup_clock_cfg);
+	uintptr_t base = stm32mp_rcc_base();
+	size_t i;
+
+	for (i = 0U; i < count; i++) {
+		mmio_write_32(base + cfg[i].offset, cfg[i].value);
+	}
+}
+
+static void disable_kernel_clocks(void)
+{
+	const uint32_t ker_mask = RCC_OCENR_HSIKERON |
+				  RCC_OCENR_CSIKERON |
+				  RCC_OCENR_HSEKERON;
+
+	/* Disable all ck_xxx_ker clocks */
+	mmio_write_32(stm32mp_rcc_base() + RCC_OCENCLRR, ker_mask);
+}
+
+static void enable_kernel_clocks(void)
+{
+	uintptr_t rcc_base = stm32mp_rcc_base();
+	uint32_t reg;
+	const uint32_t ker_mask = RCC_OCENR_HSIKERON |
+				  RCC_OCENR_CSIKERON |
+				  RCC_OCENR_HSEKERON;
+
+	/* Enable ck_xxx_ker clocks if ck_xxx was on */
+	reg = mmio_read_32(rcc_base + RCC_OCENSETR) << 1U;
+	mmio_write_32(rcc_base + RCC_OCENSETR, reg & ker_mask);
+}
+
+static void clear_rcc_reset_status(void)
+{
+	/* Clear reset status fields */
+	mmio_write_32(stm32mp_rcc_base() + RCC_MP_RSTSCLRR, 0U);
+}
+
+void save_clock_pm_context(void)
+{
+	size_t offset = 0U;
+
+	stm32mp1_pm_save_clock_cfg(offset,
+				   (uint8_t *)backup_mux0_cfg,
+				   sizeof(backup_mux0_cfg));
+	offset += sizeof(backup_mux0_cfg);
+
+	stm32mp1_pm_save_clock_cfg(offset,
+				   (uint8_t *)backup_mux4_cfg,
+				   sizeof(backup_mux4_cfg));
+	offset += sizeof(backup_mux4_cfg);
+
+	stm32mp1_pm_save_clock_cfg(offset,
+				   (uint8_t *)backup_clock_sc_cfg,
+				   sizeof(backup_clock_sc_cfg));
+	offset += sizeof(backup_clock_sc_cfg);
+
+	stm32mp1_pm_save_clock_cfg(offset,
+				   (uint8_t *)backup_clock_cfg,
+				   sizeof(backup_clock_cfg));
+	offset += sizeof(backup_clock_cfg);
+
+	stm32mp1_pm_save_clock_cfg(offset,
+				   (uint8_t *)gate_refcounts,
+				   sizeof(gate_refcounts));
+	offset += sizeof(gate_refcounts);
+
+	save_current_opp_khz = current_opp_khz;
+
+	stm32mp1_pm_save_clock_cfg(offset,
+				   (uint8_t *)&save_current_opp_khz,
+				   sizeof(save_current_opp_khz));
+}
+
+void restore_clock_pm_context(void)
+{
+	size_t offset = 0U;
+
+	stm32mp1_pm_restore_clock_cfg(offset,
+				      (uint8_t *)backup_mux0_cfg,
+				      sizeof(backup_mux0_cfg));
+	offset += sizeof(backup_mux0_cfg);
+
+	stm32mp1_pm_restore_clock_cfg(offset,
+				      (uint8_t *)backup_mux4_cfg,
+				      sizeof(backup_mux4_cfg));
+	offset += sizeof(backup_mux4_cfg);
+
+	stm32mp1_pm_restore_clock_cfg(offset,
+				      (uint8_t *)backup_clock_sc_cfg,
+				      sizeof(backup_clock_sc_cfg));
+	offset += sizeof(backup_clock_sc_cfg);
+
+	stm32mp1_pm_restore_clock_cfg(offset,
+				      (uint8_t *)backup_clock_cfg,
+				      sizeof(backup_clock_cfg));
+	offset += sizeof(backup_clock_cfg);
+
+	stm32mp1_pm_restore_clock_cfg(offset,
+				      (uint8_t *)gate_refcounts,
+				      sizeof(gate_refcounts));
+	offset += sizeof(gate_refcounts);
+
+	stm32mp1_pm_restore_clock_cfg(offset,
+				      (uint8_t *)&save_current_opp_khz,
+				      sizeof(save_current_opp_khz));
+
+	stm32mp1_set_opp_khz(save_current_opp_khz);
+}
+
+void stm32mp1_clock_suspend(void)
+{
+	backup_regular_cfg();
+	backup_sc_cfg();
+	backup_mux_cfg();
+	clear_rcc_reset_status();
+}
+
+void stm32mp1_clock_resume(void)
+{
+	unsigned int idx;
+
+	restore_mux_cfg();
+	restore_sc_cfg();
+	restore_regular_cfg();
+
+	/* Sync secure and shared clocks physical state on functional state */
+	for (idx = 0U; idx < NB_GATES; idx++) {
+		struct stm32mp1_clk_gate const *gate = gate_ref(idx);
+
+		if (clock_is_always_on(gate->index)) {
+			continue;
+		}
+
+		if (gate_is_non_secure(gate)) {
+			continue;
+		}
+
+		if (gate_refcounts[idx] != 0U) {
+			VERBOSE("Resume clock %d enable\n", gate->index);
+			__clk_enable(gate);
+		} else {
+			VERBOSE("Resume clock %d disable\n", gate->index);
+			__clk_disable(gate);
+		}
+	}
+
+	disable_kernel_clocks();
+}
+
+void stm32mp1_clock_stopmode_save(void)
+{
+	uintptr_t rcc_base = stm32mp_rcc_base();
+
+	/* Save registers not restored after STOP mode */
+	pll3cr = mmio_read_32(rcc_base + RCC_PLL3CR);
+	pll4cr = mmio_read_32(rcc_base + RCC_PLL4CR);
+	mssckselr = mmio_read_32(rcc_base + RCC_MSSCKSELR);
+	mcudivr = mmio_read_32(rcc_base + RCC_MCUDIVR) & RCC_MCUDIV_MASK;
+	enable_kernel_clocks();
+}
+
+static bool pll_is_running(uint32_t pll_offset)
+{
+	uintptr_t pll_cr = stm32mp_rcc_base() + pll_offset;
+
+	return (mmio_read_32(pll_cr) & RCC_PLLNCR_PLLON) != 0U;
+}
+
+static bool pll_was_running(uint32_t saved_value)
+{
+	return (saved_value & RCC_PLLNCR_PLLON) != 0U;
+}
+
+int stm32mp1_clock_stopmode_resume(void)
+{
+	int res;
+	uintptr_t rcc_base = stm32mp_rcc_base();
+
+	if (pll_was_running(pll4cr) && !pll_is_running(RCC_PLL4CR)) {
+		stm32mp1_pll_start(_PLL4);
+	}
+
+	if (pll_was_running(pll3cr)) {
+		if (!pll_is_running(RCC_PLL3CR)) {
+			stm32mp1_pll_start(_PLL3);
+		}
+
+		res = stm32mp1_pll_output(_PLL3,
+					  pll3cr >> RCC_PLLNCR_DIVEN_SHIFT);
+		if (res != 0) {
+			return res;
+		}
+	}
+
+	if (pll_was_running(pll4cr)) {
+		res = stm32mp1_pll_output(_PLL4,
+					  pll4cr >> RCC_PLLNCR_DIVEN_SHIFT);
+		if (res != 0) {
+			return res;
+		}
+	}
+
+	/* Restore MCU clock src after PLL3 RDY */
+	mmio_write_32(rcc_base + RCC_MSSCKSELR, mssckselr);
+
+	/* Restore MCUDIV */
+	res = stm32mp1_set_clkdiv(mcudivr, rcc_base + RCC_MCUDIVR);
+	if (res != 0) {
+		return res;
+	}
+
+	disable_kernel_clocks();
+
+	return 0;
+}
+#endif /* IMAGE_BL32 */
+
+void stm32mp1_clk_mcuss_protect(bool enable)
+{
+	uintptr_t rcc_base = stm32mp_rcc_base();
+
+	if (enable) {
+		mmio_setbits_32(rcc_base + RCC_TZCR, RCC_TZCR_MCKPROT);
+	} else {
+		mmio_clrbits_32(rcc_base + RCC_TZCR, RCC_TZCR_MCKPROT);
+	}
+}
+
 static void sync_earlyboot_clocks_state(void)
 {
 	unsigned int idx;
@@ -2231,11 +3396,39 @@ static void sync_earlyboot_clocks_state(void)
 	}
 }
 
+static const struct clk_ops stm32mp_clk_ops = {
+	.enable		= stm32mp_clk_enable,
+	.disable	= stm32mp_clk_disable,
+	.is_enabled	= stm32mp_clk_is_enabled,
+	.get_rate	= stm32mp_clk_get_rate,
+	.get_parent	= stm32mp1_clk_get_parent,
+};
+
 int stm32mp1_clk_probe(void)
 {
+	unsigned long freq_khz;
+
+	assert(PLLCFG_NB == PLAT_MAX_PLLCFG_NB);
+
+#if defined(IMAGE_BL32)
+	if (!fdt_get_rcc_secure_state()) {
+		mmio_write_32(stm32mp_rcc_base() + RCC_TZCR, 0U);
+	}
+#endif
+
 	stm32mp1_osc_init();
 
 	sync_earlyboot_clocks_state();
 
+	/* Save current CPU operating point value */
+	freq_khz = udiv_round_nearest(stm32mp_clk_get_rate(CK_MPU), 1000UL);
+	if (freq_khz > (unsigned long)UINT32_MAX) {
+		panic();
+	}
+
+	current_opp_khz = (uint32_t)freq_khz;
+
+	clk_register(&stm32mp_clk_ops);
+
 	return 0;
 }
diff --git a/drivers/st/clk/stm32mp2_clk.c b/drivers/st/clk/stm32mp2_clk.c
new file mode 100644
index 000000000..50a226d79
--- /dev/null
+++ b/drivers/st/clk/stm32mp2_clk.c
@@ -0,0 +1,2246 @@
+/*
+ * Copyright (C) 2018-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include <platform_def.h>
+#include <common/fdt_wrappers.h>
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/generic_delay_timer.h>
+#include <drivers/st/stm32mp_clkfunc.h>
+#include <drivers/st/stm32mp2_clk.h>
+#include <dt-bindings/clock/stm32mp2-clksrc.h>
+#include <lib/mmio.h>
+#include <lib/spinlock.h>
+#include <lib/utils_def.h>
+
+#include "clk-stm32-core.h"
+
+struct stm32_osci_dt_cfg {
+	unsigned long freq;
+	bool bypass;
+	bool digbyp;
+	bool css;
+	uint32_t drive;
+};
+
+struct stm32_pll_dt_cfg {
+	bool enabled;
+	uint32_t cfg[PLLCFG_NB];
+	uint32_t csg[PLLCSG_NB];
+	uint32_t frac;
+	bool csg_enabled;
+	uint32_t src;
+};
+
+struct stm32_clk_platdata {
+	uintptr_t rcc_base;
+	uint32_t nosci;
+	struct stm32_osci_dt_cfg *osci;
+	uint32_t npll;
+	struct stm32_pll_dt_cfg *pll;
+	uint32_t nflexgen;
+	uint32_t *flexgen;
+	uint32_t nbusclk;
+	uint32_t *busclk;
+	uint32_t nkernelclk;
+	uint32_t *kernelclk;
+};
+
+/* A35 Sub-System which manages its own PLL (PLL1) */
+#define A35_SS_CHGCLKREQ	0x0000
+#define A35_SS_PLL_FREQ1	0x0080
+#define A35_SS_PLL_FREQ2	0x0090
+#define A35_SS_PLL_ENABLE	0x00a0
+
+#define A35_SS_CHGCLKREQ_ARM_CHGCLKREQ		BIT(0)
+#define A35_SS_CHGCLKREQ_ARM_CHGCLKACK		BIT(1)
+
+#define A35_SS_PLL_FREQ1_FBDIV_MASK		GENMASK(11, 0)
+#define A35_SS_PLL_FREQ1_FBDIV_SHIFT		0
+#define A35_SS_PLL_FREQ1_REFDIV_MASK		GENMASK(21, 16)
+#define A35_SS_PLL_FREQ1_REFDIV_SHIFT		16
+
+#define A35_SS_PLL_FREQ2_POSTDIV1_MASK		GENMASK(2, 0)
+#define A35_SS_PLL_FREQ2_POSTDIV1_SHIFT		0
+#define A35_SS_PLL_FREQ2_POSTDIV2_MASK		GENMASK(5, 3)
+#define A35_SS_PLL_FREQ2_POSTDIV2_SHIFT		3
+
+#define A35_SS_PLL_ENABLE_PD			BIT(0)
+#define A35_SS_PLL_ENABLE_LOCKP			BIT(1)
+#define A35_SS_PLL_ENABLE_NRESET_SWPLL_FF	BIT(2)
+
+#define TIMEOUT_US_200MS	U(200000)
+#define TIMEOUT_US_1S		U(1000000)
+
+#define PLLRDY_TIMEOUT		TIMEOUT_US_200MS
+#define CLKSRC_TIMEOUT		TIMEOUT_US_200MS
+#define CLKDIV_TIMEOUT		TIMEOUT_US_200MS
+#define OSCRDY_TIMEOUT		TIMEOUT_US_1S
+
+/* PLL minimal frequencies for clock sources */
+#define PLL_REFCLK_MIN			UL(5000000)
+#define PLL_FRAC_REFCLK_MIN		UL(10000000)
+
+#define XBAR_CHANNEL_NB			64
+
+/* Warning, should be start to 1 */
+enum clock {
+	_CK_0_MHZ,
+
+	/* ROOT CLOCKS */
+	_CK_HSI,
+	_CK_HSE,
+	_CK_MSI,
+	_CK_LSI,
+	_CK_LSE,
+	_I2SCKIN,
+	_SPDIFSYMB,
+	_CK_PLL1,
+	_CK_PLL2,
+	_CK_PLL3,
+	_CK_PLL4,
+	_CK_PLL5,
+	_CK_PLL6,
+	_CK_PLL7,
+	_CK_PLL8,
+	_CK_HSE_RTC,
+	_CK_RTCCK,
+	_CK_ICN_HS_MCU,
+	_CK_ICN_SDMMC,
+	_CK_ICN_DDR,
+	_CK_ICN_HSL,
+	_CK_ICN_NIC,
+	_CK_ICN_LS_MCU,
+	_CK_FLEXGEN_07,
+	_CK_FLEXGEN_08,
+	_CK_FLEXGEN_09,
+	_CK_FLEXGEN_10,
+	_CK_FLEXGEN_11,
+	_CK_FLEXGEN_12,
+	_CK_FLEXGEN_13,
+	_CK_FLEXGEN_14,
+	_CK_FLEXGEN_15,
+	_CK_FLEXGEN_16,
+	_CK_FLEXGEN_17,
+	_CK_FLEXGEN_18,
+	_CK_FLEXGEN_19,
+	_CK_FLEXGEN_20,
+	_CK_FLEXGEN_21,
+	_CK_FLEXGEN_22,
+	_CK_FLEXGEN_23,
+	_CK_FLEXGEN_24,
+	_CK_FLEXGEN_25,
+	_CK_FLEXGEN_26,
+	_CK_FLEXGEN_27,
+	_CK_FLEXGEN_28,
+	_CK_FLEXGEN_29,
+	_CK_FLEXGEN_30,
+	_CK_FLEXGEN_31,
+	_CK_FLEXGEN_32,
+	_CK_FLEXGEN_33,
+	_CK_FLEXGEN_34,
+	_CK_FLEXGEN_35,
+	_CK_FLEXGEN_36,
+	_CK_FLEXGEN_37,
+	_CK_FLEXGEN_38,
+	_CK_FLEXGEN_39,
+	_CK_FLEXGEN_40,
+	_CK_FLEXGEN_41,
+	_CK_FLEXGEN_42,
+	_CK_FLEXGEN_43,
+	_CK_FLEXGEN_44,
+	_CK_FLEXGEN_45,
+	_CK_FLEXGEN_46,
+	_CK_FLEXGEN_47,
+	_CK_FLEXGEN_48,
+	_CK_FLEXGEN_49,
+	_CK_FLEXGEN_50,
+	_CK_FLEXGEN_51,
+	_CK_FLEXGEN_52,
+	_CK_FLEXGEN_53,
+	_CK_FLEXGEN_54,
+	_CK_FLEXGEN_55,
+	_CK_FLEXGEN_56,
+	_CK_FLEXGEN_57,
+	_CK_FLEXGEN_58,
+	_CK_FLEXGEN_59,
+	_CK_FLEXGEN_60,
+	_CK_FLEXGEN_61,
+	_CK_FLEXGEN_62,
+	_CK_FLEXGEN_63,
+	_CK_ICN_APB1,
+	_CK_ICN_APB2,
+	_CK_ICN_APB3,
+	_CK_ICN_APB4,
+	_CK_ICN_APBDBG,
+	_CK_BKPSRAM,
+	_CK_BSEC,
+	_CK_CRC,
+	_CK_CRYP1,
+	_CK_CRYP2,
+	_CK_DDR,
+	_CK_DDRCAPB,
+	_CK_DDRCP,
+	_CK_DDRPHYC,
+	_CK_FMC,
+	_CK_GPIOA,
+	_CK_GPIOB,
+	_CK_GPIOC,
+	_CK_GPIOD,
+	_CK_GPIOE,
+	_CK_GPIOF,
+	_CK_GPIOG,
+	_CK_GPIOH,
+	_CK_GPIOI,
+	_CK_GPIOJ,
+	_CK_GPIOK,
+	_CK_GPIOZ,
+	_CK_HASH,
+	_CK_I2C1,
+	_CK_I2C2,
+	_CK_I2C3,
+	_CK_I2C4,
+	_CK_I2C5,
+	_CK_I2C6,
+	_CK_I2C7,
+	_CK_I2C8,
+	_CK_IWDG1,
+	_CK_IWDG2,
+	_CK_OSPI1,
+	_CK_OSPI2,
+	_CK_OSPIIOM,
+	_CK_PKA,
+	_CK_RETRAM,
+	_CK_RNG,
+	_CK_RTC,
+	_CK_SAES,
+	_CK_SDMMC1,
+	_CK_SDMMC2,
+	_CK_SRAM1,
+	_CK_SRAM2,
+	_CK_STGEN,
+	_CK_SYSCPU1,
+	_CK_SYSRAM,
+	_CK_UART4,
+	_CK_UART5,
+	_CK_UART7,
+	_CK_UART8,
+	_CK_UART9,
+	_CK_USART1,
+	_CK_USART2,
+	_CK_USART3,
+	_CK_USART6,
+	_CK_USB2EHCI,
+	_CK_USB2OHCI,
+	_CK_USB2PHY1,
+	_CK_USB2PHY2,
+	_CK_USB3DRD,
+	_CK_USB3PCIEPHY,
+	_CK_USBTC,
+
+	CK_LAST
+};
+
+static const uint16_t muxsel_src[] = {
+	_CK_HSI, _CK_HSE, _CK_MSI, _CK_0_MHZ
+};
+
+static const uint16_t xbarsel_src[] = {
+	_CK_PLL4, _CK_PLL5, _CK_PLL6, _CK_PLL7, _CK_PLL8,
+	_CK_HSI, _CK_HSE, _CK_MSI, _CK_HSI, _CK_HSE, _CK_MSI,
+	_SPDIFSYMB, _I2SCKIN, _CK_LSI, _CK_LSE
+};
+
+static const uint16_t rtc_src[] = {
+	_CK_0_MHZ, _CK_LSE, _CK_LSI, _CK_HSE_RTC
+};
+
+static const uint16_t usb2phy1_src[] = {
+	_CK_FLEXGEN_57, _CK_HSE
+};
+
+static const uint16_t usb2phy2_src[] = {
+	_CK_FLEXGEN_58, _CK_HSE
+};
+
+static const uint16_t usb3pciphy_src[] = {
+	_CK_FLEXGEN_34, _CK_HSE
+};
+
+static const uint16_t d3per_src[] = {
+	_CK_MSI, _CK_LSI, _CK_LSE
+};
+
+#undef MUX_CFG
+#define MUX_CFG(id, src, _offset, _shift, _witdh)[id] = {\
+	.id_parents	= src,\
+	.num_parents	= ARRAY_SIZE(src),\
+	.mux		= &(struct mux_cfg) {\
+		.offset	= (_offset),\
+		.shift	= (_shift),\
+		.width	= (_witdh),\
+		.bitrdy = UINT8_MAX,\
+	},\
+}
+
+static const struct parent_cfg parent_mp25[] = {
+	MUX_CFG(MUX_MUXSEL0, muxsel_src, RCC_MUXSELCFGR, 0, 2),
+	MUX_CFG(MUX_MUXSEL1, muxsel_src, RCC_MUXSELCFGR, 4, 2),
+	MUX_CFG(MUX_MUXSEL2, muxsel_src, RCC_MUXSELCFGR, 8, 2),
+	MUX_CFG(MUX_MUXSEL3, muxsel_src, RCC_MUXSELCFGR, 12, 2),
+	MUX_CFG(MUX_MUXSEL4, muxsel_src, RCC_MUXSELCFGR, 16, 2),
+	MUX_CFG(MUX_MUXSEL5, muxsel_src, RCC_MUXSELCFGR, 20, 2),
+	MUX_CFG(MUX_MUXSEL6, muxsel_src, RCC_MUXSELCFGR, 24, 2),
+	MUX_CFG(MUX_MUXSEL7, muxsel_src, RCC_MUXSELCFGR, 28, 2),
+	MUX_CFG(MUX_XBARSEL, xbarsel_src, RCC_XBAR0CFGR, 0, 4),
+	MUX_CFG(MUX_RTC, rtc_src, RCC_BDCR, 16, 2),
+	MUX_CFG(MUX_USB2PHY1, usb2phy1_src, RCC_USB2PHY1CFGR, 15, 1),
+	MUX_CFG(MUX_USB2PHY2, usb2phy2_src, RCC_USB2PHY2CFGR, 15, 1),
+	MUX_CFG(MUX_USB3PCIEPHY, usb3pciphy_src, RCC_USB3PCIEPHYCFGR, 15, 1),
+	MUX_CFG(MUX_D3PER, d3per_src, RCC_D3DCR, 16, 2),
+};
+
+/* GATES */
+enum enum_gate_cfg {
+	GATE_ZERO, /* reserved for no gate */
+	GATE_LSE,
+	GATE_RTCCK,
+	GATE_LSI,
+	GATE_HSI,
+	GATE_MSI,
+	GATE_HSE,
+	GATE_LSI_RDY,
+	GATE_MSI_RDY,
+	GATE_LSE_RDY,
+	GATE_HSE_RDY,
+	GATE_HSI_RDY,
+	LAST_GATE
+};
+
+#define GATE_CFG(id, _offset, _bit_idx, _offset_clr)[id] = {\
+	.offset		= (_offset),\
+	.bit_idx	= (_bit_idx),\
+	.set_clr	= (_offset_clr),\
+}
+
+/* TODO : ADD MCO... ETH */
+static const struct gate_cfg gates_mp25[LAST_GATE] = {
+	GATE_CFG(GATE_LSE,		RCC_BDCR,	0,	0),
+	GATE_CFG(GATE_LSI,		RCC_BDCR,	9,	0),
+	GATE_CFG(GATE_RTCCK,		RCC_BDCR,	20,	0),
+	GATE_CFG(GATE_HSI,		RCC_OCENSETR,	0,	1),
+	GATE_CFG(GATE_HSE,		RCC_OCENSETR,	8,	1),
+	GATE_CFG(GATE_MSI,		RCC_D3DCR,	0,	0),
+
+	GATE_CFG(GATE_LSI_RDY,		RCC_BDCR,	10,	0),
+	GATE_CFG(GATE_LSE_RDY,		RCC_BDCR,	2,	0),
+	GATE_CFG(GATE_MSI_RDY,		RCC_D3DCR,	2,	0),
+	GATE_CFG(GATE_HSE_RDY,		RCC_OCRDYR,	8,	0),
+	GATE_CFG(GATE_HSI_RDY,		RCC_OCRDYR,	0,	0),
+
+};
+
+static const struct clk_div_table apb_div_table[] = {
+	{ 0, 1 },  { 1, 2 },  { 2, 4 },  { 3, 8 }, { 4, 16 },
+	{ 5, 16 }, { 6, 16 }, { 7, 16 }, { 0 },
+};
+
+#undef DIV_CFG
+#define DIV_CFG(id, _offset, _shift, _width, _flags, _table, _bitrdy)[id] = {\
+		.offset	= _offset,\
+		.shift	= _shift,\
+		.width	= _width,\
+		.flags	= _flags,\
+		.table	= _table,\
+		.bitrdy	= _bitrdy,\
+}
+
+static const struct div_cfg dividers_mp25[] = {
+	DIV_CFG(DIV_APB1, RCC_APB1DIVR, 0, 3, 0, apb_div_table, 31),
+	DIV_CFG(DIV_APB2, RCC_APB2DIVR, 0, 3, 0, apb_div_table, 31),
+	DIV_CFG(DIV_APB3, RCC_APB3DIVR, 0, 3, 0, apb_div_table, 31),
+	DIV_CFG(DIV_APB4, RCC_APB4DIVR, 0, 3, 0, apb_div_table, 31),
+	DIV_CFG(DIV_APBDBG, RCC_APBDBGDIVR, 0, 3, 0, apb_div_table, 31),
+	DIV_CFG(DIV_LSMCU, RCC_LSMCUDIVR, 0, 1, 0, NULL, 31),
+	DIV_CFG(DIV_RTC, RCC_RTCDIVR, 0, 6, 0, NULL, 0),
+};
+
+enum stm32_osc {
+	OSC_HSI,
+	OSC_HSE,
+	OSC_MSI,
+	OSC_LSI,
+	OSC_LSE,
+	OSC_I2SCKIN,
+	OSC_SPDIFSYMB,
+	NB_OSCILLATOR
+};
+
+static struct clk_oscillator_data stm32mp25_osc_data[] = {
+	OSCILLATOR(OSC_HSI, _CK_HSI, "clk-hsi", GATE_HSI, GATE_HSI_RDY,
+		   NULL, NULL, NULL),
+
+	OSCILLATOR(OSC_LSI, _CK_LSI, "clk-lsi", GATE_LSI, GATE_LSI_RDY,
+		   NULL, NULL, NULL),
+
+	OSCILLATOR(OSC_MSI, _CK_MSI, "clk-msi", GATE_MSI, GATE_MSI_RDY,
+		   NULL, NULL, NULL),
+
+	OSCILLATOR(OSC_HSE, _CK_HSE, "clk-hse", GATE_HSE, GATE_HSE_RDY,
+		   BYPASS(RCC_OCENSETR, 10, 7),
+		   CSS(RCC_OCENSETR, 11),
+		   NULL),
+
+	OSCILLATOR(OSC_LSE, _CK_LSE, "clk-lse", GATE_LSE, GATE_LSE_RDY,
+		   BYPASS(RCC_BDCR, 1, 3),
+		   CSS(RCC_BDCR, 8),
+		   DRIVE(RCC_BDCR, 4, 2, 2)),
+
+	OSCILLATOR(OSC_I2SCKIN, _I2SCKIN, "i2s_ckin", NO_GATE, NO_GATE,
+		   NULL, NULL, NULL),
+
+	OSCILLATOR(OSC_SPDIFSYMB, _SPDIFSYMB, "spdif_symb", NO_GATE, NO_GATE,
+		   NULL, NULL, NULL),
+};
+
+const char *clk_stm32_get_oscillator_name(enum stm32_osc id)
+{
+	if (id < NB_OSCILLATOR) {
+		return stm32mp25_osc_data[id].name;
+	}
+
+	return NULL;
+}
+
+enum pll_id {
+	_PLL1,
+	_PLL2,
+	_PLL3,
+	_PLL4,
+	_PLL5,
+	_PLL6,
+	_PLL7,
+	_PLL8,
+	_PLL_NB
+};
+
+/* PLL configuration registers offsets from RCC_PLLxCFGR1 */
+#define RCC_OFFSET_PLLXCFGR1		0x00
+#define RCC_OFFSET_PLLXCFGR2		0x04
+#define RCC_OFFSET_PLLXCFGR3		0x08
+#define RCC_OFFSET_PLLXCFGR4		0x0C
+#define RCC_OFFSET_PLLXCFGR5		0x10
+#define RCC_OFFSET_PLLXCFGR6		0x18
+#define RCC_OFFSET_PLLXCFGR7		0x1C
+
+struct stm32_clk_pll {
+	uint16_t clk_id;
+	uint16_t reg_pllxcfgr1;
+};
+
+#define CLK_PLL_CFG(_idx, _clk_id, _reg)\
+	[(_idx)] = {\
+		.clk_id = (_clk_id),\
+		.reg_pllxcfgr1 = (_reg),\
+	}
+
+static const struct stm32_clk_pll stm32mp25_clk_pll[_PLL_NB] = {
+	CLK_PLL_CFG(_PLL1, _CK_PLL1, A35_SS_CHGCLKREQ),
+	CLK_PLL_CFG(_PLL2, _CK_PLL2, RCC_PLL2CFGR1),
+	CLK_PLL_CFG(_PLL3, _CK_PLL3, RCC_PLL3CFGR1),
+	CLK_PLL_CFG(_PLL4, _CK_PLL4, RCC_PLL4CFGR1),
+	CLK_PLL_CFG(_PLL5, _CK_PLL5, RCC_PLL5CFGR1),
+	CLK_PLL_CFG(_PLL6, _CK_PLL6, RCC_PLL6CFGR1),
+	CLK_PLL_CFG(_PLL7, _CK_PLL7, RCC_PLL7CFGR1),
+	CLK_PLL_CFG(_PLL8, _CK_PLL8, RCC_PLL8CFGR1),
+};
+
+static const struct stm32_clk_pll *clk_stm32_pll_data(unsigned int idx)
+{
+	return &stm32mp25_clk_pll[idx];
+}
+
+static unsigned long clk_get_pll_fvco(struct stm32_clk_priv *priv,
+				      const struct stm32_clk_pll *pll,
+				      unsigned long prate)
+{
+	unsigned long refclk, fvco;
+	uint32_t fracin, fbdiv, refdiv;
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+	uintptr_t pllxcfgr2 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR2;
+	uintptr_t pllxcfgr3 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR3;
+
+	refclk = prate;
+
+	fracin = mmio_read_32(pllxcfgr3) & RCC_PLLxCFGR3_FRACIN_MASK;
+	fbdiv = (mmio_read_32(pllxcfgr2) & RCC_PLLxCFGR2_FBDIV_MASK) >>
+		RCC_PLLxCFGR2_FBDIV_SHIFT;
+	refdiv = mmio_read_32(pllxcfgr2) & RCC_PLLxCFGR2_FREFDIV_MASK;
+
+	if (fracin != 0U) {
+		unsigned long long numerator, denominator;
+
+		numerator = ((unsigned long long)fbdiv << 24) + fracin;
+		numerator = refclk * numerator;
+		denominator = (unsigned long long)refdiv << 24;
+		fvco = (unsigned long)(numerator / denominator);
+	} else {
+		fvco = (unsigned long)(refclk * fbdiv / refdiv);
+	}
+
+	return fvco;
+}
+
+struct stm32_pll_cfg {
+	int pll_id;
+};
+
+static bool _clk_stm32_pll_is_enabled(struct stm32_clk_priv *priv, const struct stm32_clk_pll *pll)
+{
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+
+	return ((mmio_read_32(pllxcfgr1) & RCC_PLLxCFGR1_PLLEN) != 0U);
+}
+
+static void _clk_stm32_pll_set_on(struct stm32_clk_priv *priv, const struct stm32_clk_pll *pll)
+{
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+
+	mmio_setbits_32(pllxcfgr1, RCC_PLLxCFGR1_PLLEN);
+}
+
+static void _clk_stm32_pll_set_off(struct stm32_clk_priv *priv, const struct stm32_clk_pll *pll)
+{
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+
+	/* Stop PLL */
+	mmio_clrbits_32(pllxcfgr1, RCC_PLLxCFGR1_PLLEN);
+}
+
+static int _clk_stm32_pll_wait_ready_on(struct stm32_clk_priv *priv,
+					const struct stm32_clk_pll *pll)
+{
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+	uint64_t timeout = timeout_init_us(PLLRDY_TIMEOUT);
+
+	/* Wait PLL lock */
+	while ((mmio_read_32(pllxcfgr1) & RCC_PLLxCFGR1_PLLRDY) == 0U) {
+		if (timeout_elapsed(timeout)) {
+			ERROR("CLK %d : PLL start failed @ 0x%x: 0x%x\n",
+			      pll->clk_id, pll->reg_pllxcfgr1, mmio_read_32(pllxcfgr1));
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static int _clk_stm32_pll_wait_ready_off(struct stm32_clk_priv *priv,
+					 const struct stm32_clk_pll *pll)
+{
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+	uint64_t timeout = timeout_init_us(PLLRDY_TIMEOUT);
+
+	/* Wait PLL stopped */
+	while ((mmio_read_32(pllxcfgr1) & RCC_PLLxCFGR1_PLLRDY) != 0U) {
+		if (timeout_elapsed(timeout)) {
+			ERROR("PLL%d stop failed @ 0x%lx: 0x%x\n",
+			      pll->clk_id, pllxcfgr1, mmio_read_32(pllxcfgr1));
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static int _clk_stm32_pll_enable(struct stm32_clk_priv *priv, const struct stm32_clk_pll *pll)
+{
+	if (_clk_stm32_pll_is_enabled(priv, pll)) {
+		return 0;
+	}
+
+	_clk_stm32_pll_set_on(priv, pll);
+
+	return _clk_stm32_pll_wait_ready_on(priv, pll);
+}
+
+static void _clk_stm32_pll_disable(struct stm32_clk_priv *priv, const struct stm32_clk_pll *pll)
+{
+	if (!_clk_stm32_pll_is_enabled(priv, pll)) {
+		return;
+	}
+
+	_clk_stm32_pll_set_off(priv, pll);
+
+	_clk_stm32_pll_wait_ready_off(priv, pll);
+}
+
+static bool clk_stm32_pll_is_enabled(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct stm32_pll_cfg *pll_cfg = clk->clock_cfg;
+	const struct stm32_clk_pll *pll = clk_stm32_pll_data(pll_cfg->pll_id);
+
+	return _clk_stm32_pll_is_enabled(priv, pll);
+}
+
+static int clk_stm32_pll_enable(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct stm32_pll_cfg *pll_cfg = clk->clock_cfg;
+	const struct stm32_clk_pll *pll = clk_stm32_pll_data(pll_cfg->pll_id);
+
+	return _clk_stm32_pll_enable(priv, pll);
+}
+
+static void clk_stm32_pll_disable(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct stm32_pll_cfg *pll_cfg = clk->clock_cfg;
+	const struct stm32_clk_pll *pll = clk_stm32_pll_data(pll_cfg->pll_id);
+
+	_clk_stm32_pll_disable(priv, pll);
+}
+
+static unsigned long clk_stm32_pll_recalc_rate(struct stm32_clk_priv *priv, int id,
+					       unsigned long prate)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct stm32_pll_cfg *pll_cfg = clk->clock_cfg;
+	const struct stm32_clk_pll *pll = clk_stm32_pll_data(pll_cfg->pll_id);
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+	uintptr_t pllxcfgr4 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR4;
+	uintptr_t pllxcfgr6 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR6;
+	uintptr_t pllxcfgr7 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR7;
+	unsigned long dfout;
+	uint32_t postdiv1, postdiv2;
+
+	postdiv1 = mmio_read_32(pllxcfgr6) & RCC_PLLxCFGR6_POSTDIV1_MASK;
+	postdiv2 = mmio_read_32(pllxcfgr7) & RCC_PLLxCFGR7_POSTDIV2_MASK;
+
+	if ((mmio_read_32(pllxcfgr4) & RCC_PLLxCFGR4_BYPASS) != 0U) {
+		dfout = prate;
+	} else {
+		if ((postdiv1 == 0U) || (postdiv2 == 0U)) {
+			dfout = prate;
+		} else {
+			dfout = clk_get_pll_fvco(priv, pll, prate) / (postdiv1 * postdiv2);
+		}
+	}
+
+	return dfout;
+}
+
+const struct stm32_clk_ops clk_stm32_pll_ops = {
+	.recalc_rate	= clk_stm32_pll_recalc_rate,
+	.enable		= clk_stm32_pll_enable,
+	.disable	= clk_stm32_pll_disable,
+	.is_enabled	= clk_stm32_pll_is_enabled,
+};
+
+#define CLK_PLL(idx, _idx, _parent, _pll_id, _flags)[idx] = {\
+	.binding	= _idx,\
+	.parent		= _parent,\
+	.flags		= (_flags),\
+	.clock_cfg	= &(struct stm32_pll_cfg) {\
+		.pll_id	= _pll_id,\
+	},\
+	.ops		= &clk_stm32_pll_ops,\
+}
+
+static unsigned long clk_get_pll1_fvco(unsigned long refclk)
+{
+	uintptr_t pll_freq1_reg = A35SSC_BASE + A35_SS_PLL_FREQ1;
+	uint32_t reg, fbdiv, refdiv;
+
+	reg = mmio_read_32(pll_freq1_reg);
+
+	fbdiv = (reg & A35_SS_PLL_FREQ1_FBDIV_MASK) >> A35_SS_PLL_FREQ1_FBDIV_SHIFT;
+	refdiv = (reg & A35_SS_PLL_FREQ1_REFDIV_MASK) >> A35_SS_PLL_FREQ1_REFDIV_SHIFT;
+
+	return (unsigned long)(refclk * fbdiv / refdiv);
+}
+
+static unsigned long clk_stm32_pll1_recalc_rate(struct stm32_clk_priv *priv,
+						int id, unsigned long prate)
+{
+	uintptr_t pll_freq2_reg = A35SSC_BASE + A35_SS_PLL_FREQ2;
+	uint32_t postdiv1, postdiv2;
+	unsigned long dfout;
+
+	postdiv1 = (mmio_read_32(pll_freq2_reg) & A35_SS_PLL_FREQ2_POSTDIV1_MASK) >>
+		   A35_SS_PLL_FREQ2_POSTDIV1_SHIFT;
+	postdiv2 = (mmio_read_32(pll_freq2_reg) & A35_SS_PLL_FREQ2_POSTDIV2_MASK) >>
+		   A35_SS_PLL_FREQ2_POSTDIV2_SHIFT;
+
+	if ((postdiv1 == 0U) || (postdiv2 == 0U)) {
+		dfout = prate;
+	} else {
+		dfout = clk_get_pll1_fvco(prate) / (postdiv1 * postdiv2);
+	}
+
+	return dfout;
+}
+
+const struct stm32_clk_ops clk_stm32_pll1_ops = {
+	.recalc_rate = clk_stm32_pll1_recalc_rate,
+};
+
+#define CLK_PLL1(idx, _idx, _parent, _pll_id, _flags)[idx] = {\
+	.binding	= _idx,\
+	.parent		= _parent,\
+	.flags		= (_flags),\
+	.clock_cfg	= &(struct stm32_pll_cfg) {\
+		.pll_id	= _pll_id,\
+	},\
+	.ops		= &clk_stm32_pll1_ops,\
+}
+
+struct stm32_clk_flexgen_cfg {
+	int id;
+};
+
+static unsigned long clk_flexgen_recalc(struct stm32_clk_priv *priv, int idx,
+					unsigned long prate)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, idx);
+	struct stm32_clk_flexgen_cfg *cfg = clk->clock_cfg;
+	uintptr_t rcc_base = priv->base;
+	uint32_t prediv, findiv;
+	uint8_t channel = cfg->id;
+	unsigned long freq = prate;
+
+	prediv = mmio_read_32(rcc_base + RCC_PREDIV0CFGR + (0x4U * channel)) &
+		RCC_PREDIVxCFGR_PREDIVx_MASK;
+	findiv = mmio_read_32(rcc_base + RCC_FINDIV0CFGR + (0x4U * channel)) &
+		RCC_FINDIVxCFGR_FINDIVx_MASK;
+
+	if (freq == 0UL) {
+		return 0U;
+	}
+
+	switch (prediv) {
+	case 0x0:
+	case 0x1:
+	case 0x3:
+	case 0x3FF:
+		break;
+
+	default:
+		ERROR("Unsupported PREDIV value (%x)\n", prediv);
+		panic();
+		break;
+	}
+
+	freq /= (prediv + 1U);
+	freq /= (findiv + 1U);
+
+	return freq;
+}
+
+static int clk_flexgen_get_parent(struct stm32_clk_priv *priv, int idx)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, idx);
+	struct stm32_clk_flexgen_cfg *cfg = clk->clock_cfg;
+	uint32_t sel;
+	uint32_t address;
+	uintptr_t rcc_base = priv->base;
+
+	address = RCC_XBAR0CFGR + (cfg->id * 4);
+
+	sel = mmio_read_32(rcc_base + address) & RCC_XBARxCFGR_XBARxSEL_MASK;
+
+	return sel;
+}
+
+static int clk_flexgen_gate_enable(struct stm32_clk_priv *priv, int idx)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, idx);
+	struct stm32_clk_flexgen_cfg *cfg = clk->clock_cfg;
+	uintptr_t rcc_base = priv->base;
+	uint8_t channel = cfg->id;
+
+	mmio_setbits_32(rcc_base + RCC_FINDIV0CFGR + (0x4U * channel),
+			RCC_FINDIVxCFGR_FINDIVxEN);
+
+	return 0;
+}
+
+static void clk_flexgen_gate_disable(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct stm32_clk_flexgen_cfg *cfg = clk->clock_cfg;
+	uintptr_t rcc_base = priv->base;
+	uint8_t channel = cfg->id;
+
+	mmio_clrbits_32(rcc_base + RCC_FINDIV0CFGR + (0x4U * channel),
+			RCC_FINDIVxCFGR_FINDIVxEN);
+}
+
+static bool clk_flexgen_gate_is_enabled(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct stm32_clk_flexgen_cfg *cfg = clk->clock_cfg;
+	uintptr_t rcc_base = priv->base;
+	uint8_t channel = cfg->id;
+
+	return !!(mmio_read_32(rcc_base + RCC_FINDIV0CFGR + (0x4U * channel)) &
+		RCC_FINDIVxCFGR_FINDIVxEN);
+}
+
+const struct stm32_clk_ops clk_stm32_flexgen_ops = {
+	.recalc_rate = clk_flexgen_recalc,
+	.get_parent = clk_flexgen_get_parent,
+	.enable = clk_flexgen_gate_enable,
+	.disable = clk_flexgen_gate_disable,
+	.is_enabled = clk_flexgen_gate_is_enabled,
+};
+
+#define FLEXGEN(idx, _idx, _flags, _id)[idx] = {\
+	.binding = _idx,\
+	.parent =  MUX(MUX_XBARSEL),\
+	.flags = (_flags),\
+	.clock_cfg	= &(struct stm32_clk_flexgen_cfg) {\
+		.id	= _id,\
+	},\
+	.ops = &clk_stm32_flexgen_ops,\
+}
+
+#define RCC_0_MHZ	UL(0)
+#define RCC_4_MHZ	UL(4000000)
+#define RCC_16_MHZ	UL(16000000)
+
+#ifdef IMAGE_BL2
+static int clk_stm32_osc_msi_set_rate(struct stm32_clk_priv *priv, int id, unsigned long rate,
+				      unsigned long prate)
+{
+	uintptr_t address = priv->base + RCC_BDCR;
+	uint32_t mask = RCC_BDCR_MSIFREQSEL;
+	int ret = -1;
+
+	switch (rate) {
+	case RCC_4_MHZ:
+		mmio_clrbits_32(address, mask);
+		ret = 0;
+		break;
+
+	case RCC_16_MHZ:
+		mmio_setbits_32(address, mask);
+		ret = 0;
+		break;
+
+	default:
+		break;
+	}
+
+	return ret;
+}
+#endif /* IMAGE_BL2 */
+
+static unsigned long clk_stm32_osc_msi_recalc_rate(struct stm32_clk_priv *priv,
+						   int id __unused,
+						   unsigned long prate __unused)
+{
+	uintptr_t address = priv->base + RCC_BDCR;
+
+	if ((mmio_read_32(address) & RCC_BDCR_MSIFREQSEL) == 0U) {
+		return RCC_4_MHZ;
+	} else {
+		return RCC_16_MHZ;
+	}
+}
+
+const struct stm32_clk_ops clk_stm32_osc_msi_ops = {
+	.recalc_rate	= clk_stm32_osc_msi_recalc_rate,
+	.is_enabled	= clk_stm32_osc_gate_is_enabled,
+	.enable		= clk_stm32_osc_gate_enable,
+	.disable	= clk_stm32_osc_gate_disable,
+	.init		= clk_stm32_osc_init,
+};
+
+#define CLK_OSC_MSI(idx, _idx, _parent, _osc_id) \
+	[(idx)] = (struct clk_stm32){ \
+		.binding	= (_idx),\
+		.parent		= (_parent),\
+		.flags		= CLK_IS_CRITICAL,\
+		.clock_cfg	= &(struct stm32_osc_cfg){\
+			.osc_id = (_osc_id),\
+		},\
+		.ops		= &clk_stm32_osc_msi_ops,\
+	}
+
+const struct stm32_clk_ops clk_stm32_rtc_ops = {
+	.enable = clk_stm32_gate_enable,
+	.disable = clk_stm32_gate_disable,
+	.is_enabled = clk_stm32_gate_is_enabled,
+};
+
+#define CLK_RTC(idx, _binding, _parent, _flags, _gate_id)[idx] = {\
+	.binding = (_binding),\
+	.parent =  (_parent),\
+	.flags = (_flags),\
+	.clock_cfg	= &(struct clk_stm32_gate_cfg) {\
+		.id	= (_gate_id),\
+	},\
+	.ops = &clk_stm32_rtc_ops,\
+}
+
+#ifdef CFG_WORKAROUND_VSW0V8
+static unsigned long clk_stm32_osc_recalc_rd_only(struct stm32_clk_priv *priv,
+						  int id,
+						  unsigned long prate)
+{
+	struct clk_oscillator_data *data = clk_oscillator_get_data(priv, id);
+
+	return data->frequency;
+};
+
+const struct stm32_clk_ops clk_stm32_osc_rd_only_ops = {
+	.recalc_rate	= clk_stm32_osc_recalc_rd_only,
+	.is_enabled	= clk_stm32_osc_gate_is_enabled,
+	.init		= clk_stm32_osc_init,
+};
+
+#define CLK_OSC_RD_ONLY(idx, _idx, _parent, _osc_id) \
+	[(idx)] = (struct clk_stm32){ \
+		.binding	= (_idx),\
+		.parent		= (_parent),\
+		.flags		= 0,\
+		.clock_cfg	= &(struct stm32_osc_cfg){\
+			.osc_id = (_osc_id),\
+		},\
+		.ops		= &clk_stm32_osc_rd_only_ops,\
+	}
+#endif
+
+static const struct clk_stm32 stm32mp25_clk[CK_LAST] = {
+	CLK_FIXED_RATE(_CK_0_MHZ, _NO_ID, RCC_0_MHZ),
+
+	/* ROOT CLOCKS */
+	CLK_OSC(_CK_HSE, HSE_CK, CLK_IS_ROOT, OSC_HSE),
+
+#ifndef CFG_WORKAROUND_VSW0V8
+	CLK_OSC(_CK_LSE, LSE_CK, CLK_IS_ROOT, OSC_LSE),
+#else
+	CLK_OSC_RD_ONLY(_CK_LSE, LSE_CK, CLK_IS_ROOT, OSC_LSE),
+#endif
+
+	CLK_OSC(_CK_HSI, HSI_CK, CLK_IS_ROOT, OSC_HSI),
+
+#ifndef CFG_WORKAROUND_VSW0V8
+	CLK_OSC(_CK_LSI, LSI_CK, CLK_IS_ROOT, OSC_LSI),
+#else
+	CLK_OSC_RD_ONLY(_CK_LSI, LSI_CK, CLK_IS_ROOT, OSC_LSI),
+#endif
+
+	CLK_OSC_MSI(_CK_MSI, MSI_CK, CLK_IS_ROOT, OSC_MSI),
+
+	CLK_OSC_FIXED(_I2SCKIN, _NO_ID, CLK_IS_ROOT, OSC_I2SCKIN),
+	CLK_OSC_FIXED(_SPDIFSYMB, _NO_ID, CLK_IS_ROOT, OSC_SPDIFSYMB),
+
+	STM32_DIV(_CK_HSE_RTC, _NO_ID, _CK_HSE, 0, DIV_RTC),
+
+	CLK_RTC(_CK_RTCCK, RTC_CK, MUX(MUX_RTC), 0, GATE_RTCCK),
+
+	CLK_PLL1(_CK_PLL1, PLL1_CK, MUX(MUX_MUXSEL5), _PLL1, 0),
+
+	CLK_PLL(_CK_PLL2, PLL2_CK, MUX(MUX_MUXSEL6), _PLL2, 0),
+	CLK_PLL(_CK_PLL3, PLL3_CK, MUX(MUX_MUXSEL7), _PLL3, 0),
+	CLK_PLL(_CK_PLL4, PLL4_CK, MUX(MUX_MUXSEL0), _PLL4, 0),
+	CLK_PLL(_CK_PLL5, PLL5_CK, MUX(MUX_MUXSEL1), _PLL5, 0),
+	CLK_PLL(_CK_PLL6, PLL6_CK, MUX(MUX_MUXSEL2), _PLL6, 0),
+	CLK_PLL(_CK_PLL7, PLL7_CK, MUX(MUX_MUXSEL3), _PLL7, 0),
+	CLK_PLL(_CK_PLL8, PLL8_CK, MUX(MUX_MUXSEL4), _PLL8, 0),
+
+	FLEXGEN(_CK_ICN_HS_MCU,	CK_ICN_HS_MCU, CLK_IS_CRITICAL, 0),
+	FLEXGEN(_CK_ICN_SDMMC, CK_ICN_SDMMC, CLK_IS_CRITICAL, 1),
+	FLEXGEN(_CK_ICN_DDR, CK_ICN_DDR, CLK_IS_CRITICAL, 2),
+	FLEXGEN(_CK_ICN_HSL, CK_ICN_HSL, CLK_IS_CRITICAL, 4),
+	FLEXGEN(_CK_ICN_NIC, CK_ICN_NIC, CLK_IS_CRITICAL, 5),
+
+	STM32_DIV(_CK_ICN_LS_MCU, CK_ICN_LS_MCU, _CK_ICN_HS_MCU, 0, DIV_LSMCU),
+
+	FLEXGEN(_CK_FLEXGEN_07, CK_FLEXGEN_07, 0, 7),
+	FLEXGEN(_CK_FLEXGEN_08, CK_FLEXGEN_08, 0, 8),
+	FLEXGEN(_CK_FLEXGEN_09, CK_FLEXGEN_09, 0, 9),
+	FLEXGEN(_CK_FLEXGEN_10, CK_FLEXGEN_10, 0, 10),
+	FLEXGEN(_CK_FLEXGEN_11, CK_FLEXGEN_11, 0, 11),
+	FLEXGEN(_CK_FLEXGEN_12, CK_FLEXGEN_12, 0, 12),
+	FLEXGEN(_CK_FLEXGEN_13, CK_FLEXGEN_13, 0, 13),
+	FLEXGEN(_CK_FLEXGEN_14, CK_FLEXGEN_14, 0, 14),
+	FLEXGEN(_CK_FLEXGEN_15, CK_FLEXGEN_15, 0, 15),
+	FLEXGEN(_CK_FLEXGEN_16, CK_FLEXGEN_16, 0, 16),
+	FLEXGEN(_CK_FLEXGEN_17, CK_FLEXGEN_17, 0, 17),
+	FLEXGEN(_CK_FLEXGEN_18, CK_FLEXGEN_18, 0, 18),
+	FLEXGEN(_CK_FLEXGEN_19, CK_FLEXGEN_19, 0, 19),
+	FLEXGEN(_CK_FLEXGEN_20, CK_FLEXGEN_20, 0, 20),
+	FLEXGEN(_CK_FLEXGEN_21, CK_FLEXGEN_21, 0, 21),
+	FLEXGEN(_CK_FLEXGEN_22, CK_FLEXGEN_22, 0, 22),
+	FLEXGEN(_CK_FLEXGEN_23, CK_FLEXGEN_23, 0, 23),
+	FLEXGEN(_CK_FLEXGEN_24, CK_FLEXGEN_24, 0, 24),
+	FLEXGEN(_CK_FLEXGEN_25, CK_FLEXGEN_25, 0, 25),
+	FLEXGEN(_CK_FLEXGEN_26, CK_FLEXGEN_26, 0, 26),
+	FLEXGEN(_CK_FLEXGEN_27, CK_FLEXGEN_27, 0, 27),
+	FLEXGEN(_CK_FLEXGEN_28, CK_FLEXGEN_28, 0, 28),
+	FLEXGEN(_CK_FLEXGEN_29, CK_FLEXGEN_29, 0, 29),
+	FLEXGEN(_CK_FLEXGEN_30, CK_FLEXGEN_30, 0, 30),
+	FLEXGEN(_CK_FLEXGEN_31, CK_FLEXGEN_31, 0, 31),
+	FLEXGEN(_CK_FLEXGEN_32, CK_FLEXGEN_32, 0, 32),
+	FLEXGEN(_CK_FLEXGEN_33, CK_FLEXGEN_33, 0, 33),
+	FLEXGEN(_CK_FLEXGEN_34, CK_FLEXGEN_34, 0, 34),
+	FLEXGEN(_CK_FLEXGEN_35, CK_FLEXGEN_35, 0, 35),
+	FLEXGEN(_CK_FLEXGEN_36, CK_FLEXGEN_36, 0, 36),
+	FLEXGEN(_CK_FLEXGEN_37, CK_FLEXGEN_37, 0, 37),
+	FLEXGEN(_CK_FLEXGEN_38, CK_FLEXGEN_38, 0, 38),
+	FLEXGEN(_CK_FLEXGEN_39, CK_FLEXGEN_39, 0, 39),
+	FLEXGEN(_CK_FLEXGEN_40, CK_FLEXGEN_40, 0, 40),
+	FLEXGEN(_CK_FLEXGEN_41, CK_FLEXGEN_41, 0, 41),
+	FLEXGEN(_CK_FLEXGEN_42, CK_FLEXGEN_42, 0, 42),
+	FLEXGEN(_CK_FLEXGEN_43, CK_FLEXGEN_43, 0, 43),
+	FLEXGEN(_CK_FLEXGEN_44, CK_FLEXGEN_44, 0, 44),
+	FLEXGEN(_CK_FLEXGEN_45, CK_FLEXGEN_45, 0, 45),
+	FLEXGEN(_CK_FLEXGEN_46, CK_FLEXGEN_46, 0, 46),
+	FLEXGEN(_CK_FLEXGEN_47, CK_FLEXGEN_47, 0, 47),
+	FLEXGEN(_CK_FLEXGEN_48, CK_FLEXGEN_48, 0, 48),
+	FLEXGEN(_CK_FLEXGEN_49, CK_FLEXGEN_49, 0, 49),
+	FLEXGEN(_CK_FLEXGEN_50, CK_FLEXGEN_50, 0, 50),
+	FLEXGEN(_CK_FLEXGEN_51, CK_FLEXGEN_51, 0, 51),
+	FLEXGEN(_CK_FLEXGEN_52, CK_FLEXGEN_52, 0, 52),
+	FLEXGEN(_CK_FLEXGEN_53, CK_FLEXGEN_53, 0, 53),
+	FLEXGEN(_CK_FLEXGEN_54, CK_FLEXGEN_54, 0, 54),
+	FLEXGEN(_CK_FLEXGEN_55, CK_FLEXGEN_55, 0, 55),
+	FLEXGEN(_CK_FLEXGEN_56, CK_FLEXGEN_56, 0, 56),
+	FLEXGEN(_CK_FLEXGEN_57, CK_FLEXGEN_57, 0, 57),
+	FLEXGEN(_CK_FLEXGEN_58, CK_FLEXGEN_58, 0, 58),
+	FLEXGEN(_CK_FLEXGEN_59, CK_FLEXGEN_59, 0, 59),
+	FLEXGEN(_CK_FLEXGEN_60, CK_FLEXGEN_60, 0, 60),
+	FLEXGEN(_CK_FLEXGEN_61, CK_FLEXGEN_61, 0, 61),
+	FLEXGEN(_CK_FLEXGEN_62, CK_FLEXGEN_62, 0, 62),
+	FLEXGEN(_CK_FLEXGEN_63, CK_FLEXGEN_63, 0, 63),
+
+	STM32_DIV(_CK_ICN_APB1, CK_ICN_APB1, _CK_ICN_LS_MCU, 0, DIV_APB1),
+	STM32_DIV(_CK_ICN_APB2, CK_ICN_APB2, _CK_ICN_LS_MCU, 0, DIV_APB2),
+	STM32_DIV(_CK_ICN_APB3, CK_ICN_APB3, _CK_ICN_LS_MCU, 0, DIV_APB3),
+	STM32_DIV(_CK_ICN_APB4, CK_ICN_APB4, _CK_ICN_LS_MCU, 0, DIV_APB4),
+	STM32_DIV(_CK_ICN_APBDBG, CK_ICN_APBDBG, _CK_ICN_LS_MCU, 0, DIV_APBDBG),
+
+	/* KERNEL CLOCK */
+	GATE(_CK_SYSRAM, CK_BUS_SYSRAM, _CK_ICN_HS_MCU, 0, RCC_SYSRAMCFGR, 1),
+	GATE(_CK_RETRAM, CK_BUS_RETRAM, _CK_ICN_HS_MCU, 0, RCC_RETRAMCFGR, 1),
+	GATE(_CK_SRAM1, CK_BUS_SRAM1, _CK_ICN_HS_MCU, CLK_IS_CRITICAL, RCC_SRAM1CFGR, 1),
+	GATE(_CK_SRAM2, CK_BUS_SRAM2, _CK_ICN_HS_MCU, CLK_IS_CRITICAL, RCC_SRAM2CFGR, 1),
+
+	GATE(_CK_DDRPHYC, CK_BUS_DDRPHYC, _CK_ICN_LS_MCU, 0, RCC_DDRPHYCAPBCFGR, 1),
+	GATE(_CK_SYSCPU1, CK_BUS_SYSCPU1, _CK_ICN_LS_MCU, 0, RCC_SYSCPU1CFGR, 1),
+	GATE(_CK_CRC, CK_BUS_CRC, _CK_ICN_LS_MCU, 0, RCC_CRCCFGR, 1),
+	GATE(_CK_OSPIIOM, CK_BUS_OSPIIOM, _CK_ICN_LS_MCU, 0, RCC_OSPIIOMCFGR, 1),
+	GATE(_CK_BKPSRAM, CK_BUS_BKPSRAM, _CK_ICN_LS_MCU, 0, RCC_BKPSRAMCFGR, 1),
+	GATE(_CK_HASH, CK_BUS_HASH, _CK_ICN_LS_MCU, 0, RCC_HASHCFGR, 1),
+	GATE(_CK_RNG, CK_BUS_RNG, _CK_ICN_LS_MCU, 0, RCC_RNGCFGR, 1),
+	GATE(_CK_CRYP1, CK_BUS_CRYP1, _CK_ICN_LS_MCU, 0, RCC_CRYP1CFGR, 1),
+	GATE(_CK_CRYP2, CK_BUS_CRYP2, _CK_ICN_LS_MCU, 0, RCC_CRYP2CFGR, 1),
+	GATE(_CK_SAES, CK_BUS_SAES, _CK_ICN_LS_MCU, 0, RCC_SAESCFGR, 1),
+	GATE(_CK_PKA, CK_BUS_PKA, _CK_ICN_LS_MCU, 0, RCC_PKACFGR, 1),
+
+	GATE(_CK_GPIOA, CK_BUS_GPIOA, _CK_ICN_LS_MCU, 0, RCC_GPIOACFGR, 1),
+	GATE(_CK_GPIOB, CK_BUS_GPIOB, _CK_ICN_LS_MCU, 0, RCC_GPIOBCFGR, 1),
+	GATE(_CK_GPIOC, CK_BUS_GPIOC, _CK_ICN_LS_MCU, 0, RCC_GPIOCCFGR, 1),
+	GATE(_CK_GPIOD, CK_BUS_GPIOD, _CK_ICN_LS_MCU, 0, RCC_GPIODCFGR, 1),
+	GATE(_CK_GPIOE, CK_BUS_GPIOE, _CK_ICN_LS_MCU, 0, RCC_GPIOECFGR, 1),
+	GATE(_CK_GPIOF, CK_BUS_GPIOF, _CK_ICN_LS_MCU, 0, RCC_GPIOFCFGR, 1),
+	GATE(_CK_GPIOG, CK_BUS_GPIOG, _CK_ICN_LS_MCU, 0, RCC_GPIOGCFGR, 1),
+	GATE(_CK_GPIOH, CK_BUS_GPIOH, _CK_ICN_LS_MCU, 0, RCC_GPIOHCFGR, 1),
+	GATE(_CK_GPIOI, CK_BUS_GPIOI, _CK_ICN_LS_MCU, 0, RCC_GPIOICFGR, 1),
+	GATE(_CK_GPIOJ, CK_BUS_GPIOJ, _CK_ICN_LS_MCU, 0, RCC_GPIOJCFGR, 1),
+	GATE(_CK_GPIOK, CK_BUS_GPIOK, _CK_ICN_LS_MCU, 0, RCC_GPIOKCFGR, 1),
+	GATE(_CK_GPIOZ, CK_BUS_GPIOZ, _CK_ICN_LS_MCU, 0, RCC_GPIOZCFGR, 1),
+	GATE(_CK_RTC, CK_BUS_RTC, _CK_ICN_LS_MCU, 0, RCC_RTCCFGR, 1),
+
+	GATE(_CK_DDRCP, CK_BUS_DDR, _CK_ICN_DDR, 0, RCC_DDRCPCFGR, 1),
+
+	/* WARNING 2 CLOCKS FOR ONE GATE */
+	GATE(_CK_USB2OHCI, CK_BUS_USB2OHCI, _CK_ICN_HSL, 0, RCC_USB2CFGR, 1),
+	GATE(_CK_USB2EHCI, CK_BUS_USB2EHCI, _CK_ICN_HSL, 0, RCC_USB2CFGR, 1),
+
+	GATE(_CK_USB3DRD, CK_BUS_USB3DRD, _CK_ICN_HSL, 0, RCC_USB3DRDCFGR, 1),
+
+	GATE(_CK_BSEC, CK_BUS_BSEC, _CK_ICN_APB3, 0, RCC_BSECCFGR, 1),
+	GATE(_CK_IWDG1, CK_BUS_IWDG1, _CK_ICN_APB3, 0, RCC_IWDG1CFGR, 1),
+	GATE(_CK_IWDG2, CK_BUS_IWDG2, _CK_ICN_APB3, 0, RCC_IWDG2CFGR, 1),
+
+	GATE(_CK_DDRCAPB, CK_BUS_DDRC, _CK_ICN_APB4, 0, RCC_DDRCAPBCFGR, 1),
+	GATE(_CK_DDR, CK_BUS_DDRCFG, _CK_ICN_APB4, 0, RCC_DDRCFGR, 1),
+
+	GATE(_CK_USART2, CK_KER_USART2, _CK_FLEXGEN_08, 0, RCC_USART2CFGR, 1),
+	GATE(_CK_UART4, CK_KER_UART4, _CK_FLEXGEN_08, 0, RCC_UART4CFGR, 1),
+	GATE(_CK_USART3, CK_KER_USART3, _CK_FLEXGEN_09, 0, RCC_USART3CFGR, 1),
+	GATE(_CK_UART5, CK_KER_UART5, _CK_FLEXGEN_09, 0, RCC_UART5CFGR, 1),
+	GATE(_CK_I2C1, CK_KER_I2C1, _CK_FLEXGEN_12, 0, RCC_I2C1CFGR, 1),
+	GATE(_CK_I2C2, CK_KER_I2C2, _CK_FLEXGEN_12, 0, RCC_I2C2CFGR, 1),
+	GATE(_CK_I2C3, CK_KER_I2C3, _CK_FLEXGEN_13, 0, RCC_I2C3CFGR, 1),
+	GATE(_CK_I2C5, CK_KER_I2C5, _CK_FLEXGEN_13, 0, RCC_I2C5CFGR, 1),
+	GATE(_CK_I2C4, CK_KER_I2C4, _CK_FLEXGEN_14, 0, RCC_I2C4CFGR, 1),
+	GATE(_CK_I2C6, CK_KER_I2C6, _CK_FLEXGEN_14, 0, RCC_I2C6CFGR, 1),
+	GATE(_CK_I2C7, CK_KER_I2C7, _CK_FLEXGEN_15, 0, RCC_I2C7CFGR, 1),
+	GATE(_CK_USART1, CK_KER_USART1, _CK_FLEXGEN_19, 0, RCC_USART1CFGR, 1),
+	GATE(_CK_USART6, CK_KER_USART6, _CK_FLEXGEN_20, 0, RCC_USART6CFGR, 1),
+	GATE(_CK_UART7, CK_KER_UART7, _CK_FLEXGEN_21, 0, RCC_UART7CFGR, 1),
+	GATE(_CK_UART8, CK_KER_UART8, _CK_FLEXGEN_21, 0, RCC_UART8CFGR, 1),
+	GATE(_CK_UART9, CK_KER_UART9, _CK_FLEXGEN_22, 0, RCC_UART9CFGR, 1),
+	GATE(_CK_STGEN, CK_KER_STGEN, _CK_FLEXGEN_33, 0, RCC_STGENCFGR, 1),
+	GATE(_CK_USB3PCIEPHY, CK_KER_USB3PCIEPHY, _CK_FLEXGEN_34, 0, RCC_USB3PCIEPHYCFGR, 1),
+	GATE(_CK_USBTC, CK_KER_USB3TC, _CK_FLEXGEN_35, 0, RCC_USBTCCFGR, 1),
+	GATE(_CK_I2C8, CK_KER_I2C8, _CK_FLEXGEN_38, 0, RCC_I2C8CFGR, 1),
+	GATE(_CK_OSPI1, CK_KER_OSPI1, _CK_FLEXGEN_48, 0, RCC_OSPI1CFGR, 1),
+	GATE(_CK_OSPI2, CK_KER_OSPI2, _CK_FLEXGEN_49, 0, RCC_OSPI2CFGR, 1),
+	GATE(_CK_FMC, CK_KER_FMC, _CK_FLEXGEN_50, 0, RCC_FMCCFGR, 1),
+	GATE(_CK_SDMMC1, CK_KER_SDMMC1, _CK_FLEXGEN_51, 0, RCC_SDMMC1CFGR, 1),
+	GATE(_CK_SDMMC2, CK_KER_SDMMC2, _CK_FLEXGEN_52, 0, RCC_SDMMC2CFGR, 1),
+	GATE(_CK_USB2PHY1, CK_KER_USB2PHY1, _CK_FLEXGEN_57, 0, RCC_USB2PHY1CFGR, 1),
+	GATE(_CK_USB2PHY2, CK_KER_USB2PHY2, _CK_FLEXGEN_58, 0, RCC_USB2PHY2CFGR, 1),
+};
+
+enum clksrc_id {
+	CLKSRC_CA35SS,
+	CLKSRC_PLL1,
+	CLKSRC_PLL2,
+	CLKSRC_PLL3,
+	CLKSRC_PLL4,
+	CLKSRC_PLL5,
+	CLKSRC_PLL6,
+	CLKSRC_PLL7,
+	CLKSRC_PLL8,
+	CLKSRC_XBAR_CHANNEL0,
+	CLKSRC_XBAR_CHANNEL1,
+	CLKSRC_XBAR_CHANNEL2,
+	CLKSRC_XBAR_CHANNEL3,
+	CLKSRC_XBAR_CHANNEL4,
+	CLKSRC_XBAR_CHANNEL5,
+	CLKSRC_XBAR_CHANNEL6,
+	CLKSRC_XBAR_CHANNEL7,
+	CLKSRC_XBAR_CHANNEL8,
+	CLKSRC_XBAR_CHANNEL9,
+	CLKSRC_XBAR_CHANNEL10,
+	CLKSRC_XBAR_CHANNEL11,
+	CLKSRC_XBAR_CHANNEL12,
+	CLKSRC_XBAR_CHANNEL13,
+	CLKSRC_XBAR_CHANNEL14,
+	CLKSRC_XBAR_CHANNEL15,
+	CLKSRC_XBAR_CHANNEL16,
+	CLKSRC_XBAR_CHANNEL17,
+	CLKSRC_XBAR_CHANNEL18,
+	CLKSRC_XBAR_CHANNEL19,
+	CLKSRC_XBAR_CHANNEL20,
+	CLKSRC_XBAR_CHANNEL21,
+	CLKSRC_XBAR_CHANNEL22,
+	CLKSRC_XBAR_CHANNEL23,
+	CLKSRC_XBAR_CHANNEL24,
+	CLKSRC_XBAR_CHANNEL25,
+	CLKSRC_XBAR_CHANNEL26,
+	CLKSRC_XBAR_CHANNEL27,
+	CLKSRC_XBAR_CHANNEL28,
+	CLKSRC_XBAR_CHANNEL29,
+	CLKSRC_XBAR_CHANNEL30,
+	CLKSRC_XBAR_CHANNEL31,
+	CLKSRC_XBAR_CHANNEL32,
+	CLKSRC_XBAR_CHANNEL33,
+	CLKSRC_XBAR_CHANNEL34,
+	CLKSRC_XBAR_CHANNEL35,
+	CLKSRC_XBAR_CHANNEL36,
+	CLKSRC_XBAR_CHANNEL37,
+	CLKSRC_XBAR_CHANNEL38,
+	CLKSRC_XBAR_CHANNEL39,
+	CLKSRC_XBAR_CHANNEL40,
+	CLKSRC_XBAR_CHANNEL41,
+	CLKSRC_XBAR_CHANNEL42,
+	CLKSRC_XBAR_CHANNEL43,
+	CLKSRC_XBAR_CHANNEL44,
+	CLKSRC_XBAR_CHANNEL45,
+	CLKSRC_XBAR_CHANNEL46,
+	CLKSRC_XBAR_CHANNEL47,
+	CLKSRC_XBAR_CHANNEL48,
+	CLKSRC_XBAR_CHANNEL49,
+	CLKSRC_XBAR_CHANNEL50,
+	CLKSRC_XBAR_CHANNEL51,
+	CLKSRC_XBAR_CHANNEL52,
+	CLKSRC_XBAR_CHANNEL53,
+	CLKSRC_XBAR_CHANNEL54,
+	CLKSRC_XBAR_CHANNEL55,
+	CLKSRC_XBAR_CHANNEL56,
+	CLKSRC_XBAR_CHANNEL57,
+	CLKSRC_XBAR_CHANNEL58,
+	CLKSRC_XBAR_CHANNEL59,
+	CLKSRC_XBAR_CHANNEL60,
+	CLKSRC_XBAR_CHANNEL61,
+	CLKSRC_XBAR_CHANNEL62,
+	CLKSRC_XBAR_CHANNEL63,
+	CLKSRC_RTC,
+	CLKSRC_MCO1,
+	CLKSRC_MCO2,
+	CLKSRC_NB
+};
+
+#ifdef IMAGE_BL2
+static void stm32mp2_clk_muxsel_on_hsi(struct stm32_clk_priv *priv)
+{
+
+	mmio_clrbits_32(priv->base + RCC_MUXSELCFGR,
+			RCC_MUXSELCFGR_MUXSEL0_MASK |
+			RCC_MUXSELCFGR_MUXSEL1_MASK |
+			RCC_MUXSELCFGR_MUXSEL2_MASK |
+			RCC_MUXSELCFGR_MUXSEL3_MASK |
+			RCC_MUXSELCFGR_MUXSEL4_MASK |
+			RCC_MUXSELCFGR_MUXSEL5_MASK |
+			RCC_MUXSELCFGR_MUXSEL6_MASK |
+			RCC_MUXSELCFGR_MUXSEL7_MASK);
+}
+
+static void stm32mp2_a35_ss_on_hsi(void)
+{
+	uintptr_t a35_ss_address = A35SSC_BASE;
+	uintptr_t chgclkreq_reg = a35_ss_address + A35_SS_CHGCLKREQ;
+	uintptr_t pll_enable_reg = a35_ss_address + A35_SS_PLL_ENABLE;
+	uint64_t timeout;
+
+	if ((mmio_read_32(chgclkreq_reg) & A35_SS_CHGCLKREQ_ARM_CHGCLKACK) ==
+	    A35_SS_CHGCLKREQ_ARM_CHGCLKACK) {
+		/* Nothing to do, clock source is already set on bypass clock */
+		return;
+	}
+
+	mmio_setbits_32(chgclkreq_reg, A35_SS_CHGCLKREQ_ARM_CHGCLKREQ);
+
+	timeout = timeout_init_us(CLKSRC_TIMEOUT);
+	while ((mmio_read_32(chgclkreq_reg) & A35_SS_CHGCLKREQ_ARM_CHGCLKACK) !=
+	       A35_SS_CHGCLKREQ_ARM_CHGCLKACK) {
+		if (timeout_elapsed(timeout)) {
+			ERROR("Cannot switch A35 to bypass clock\n");
+			panic();
+		}
+	}
+
+	mmio_clrbits_32(pll_enable_reg, A35_SS_PLL_ENABLE_NRESET_SWPLL_FF);
+}
+
+static void stm32mp2_clk_xbar_on_hsi(struct stm32_clk_priv *priv)
+{
+	uintptr_t xbar0cfgr = priv->base + RCC_XBAR0CFGR;
+	uint32_t i;
+
+	for (i = 0; i < XBAR_CHANNEL_NB; i++) {
+		mmio_clrsetbits_32(xbar0cfgr + (0x4 * i),
+				   RCC_XBAR0CFGR_XBAR0SEL_MASK,
+				   XBAR_SRC_HSI);
+	}
+}
+
+/* TODO: MOVE THIS FUNCTION A35 ONLY */
+static int stm32mp2_a35_pll1_start(void)
+{
+	uintptr_t a35_ss_address = A35SSC_BASE;
+	uintptr_t pll_enable_reg = a35_ss_address + A35_SS_PLL_ENABLE;
+	uintptr_t chgclkreq_reg = a35_ss_address + A35_SS_CHGCLKREQ;
+	uint64_t timeout = timeout_init_us(PLLRDY_TIMEOUT);
+
+	mmio_setbits_32(pll_enable_reg, A35_SS_PLL_ENABLE_PD);
+
+	/* Wait PLL lock */
+	while ((mmio_read_32(pll_enable_reg) & A35_SS_PLL_ENABLE_LOCKP) == 0U) {
+		if (timeout_elapsed(timeout)) {
+			ERROR("PLL1 start failed @ 0x%lx: 0x%x\n",
+			      pll_enable_reg, mmio_read_32(pll_enable_reg));
+			return -ETIMEDOUT;
+		}
+	}
+
+	/* De-assert reset on PLL output clock path */
+	mmio_setbits_32(pll_enable_reg, A35_SS_PLL_ENABLE_NRESET_SWPLL_FF);
+
+	/* Switch CPU clock to PLL clock */
+	mmio_clrbits_32(chgclkreq_reg, A35_SS_CHGCLKREQ_ARM_CHGCLKREQ);
+
+	/* Wait for clock change acknowledge */
+	timeout = timeout_init_us(CLKSRC_TIMEOUT);
+	while ((mmio_read_32(chgclkreq_reg) & A35_SS_CHGCLKREQ_ARM_CHGCLKACK) != 0U) {
+		if (timeout_elapsed(timeout)) {
+			ERROR("CA35SS switch to PLL1 failed @ 0x%lx: 0x%x\n",
+			      chgclkreq_reg, mmio_read_32(chgclkreq_reg));
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static void stm32mp2_a35_pll1_config(uint32_t fbdiv, uint32_t refdiv, uint32_t postdiv1,
+				     uint32_t postdiv2)
+{
+	uintptr_t a35_ss_address = A35SSC_BASE;
+	uintptr_t pll_freq1_reg = a35_ss_address + A35_SS_PLL_FREQ1;
+	uintptr_t pll_freq2_reg = a35_ss_address + A35_SS_PLL_FREQ2;
+
+	mmio_clrsetbits_32(pll_freq1_reg, A35_SS_PLL_FREQ1_REFDIV_MASK,
+			   (refdiv << A35_SS_PLL_FREQ1_REFDIV_SHIFT) &
+			   A35_SS_PLL_FREQ1_REFDIV_MASK);
+
+	mmio_clrsetbits_32(pll_freq1_reg, A35_SS_PLL_FREQ1_FBDIV_MASK,
+			   (fbdiv << A35_SS_PLL_FREQ1_FBDIV_SHIFT) &
+			   A35_SS_PLL_FREQ1_FBDIV_MASK);
+
+	mmio_clrsetbits_32(pll_freq2_reg, A35_SS_PLL_FREQ2_POSTDIV1_MASK,
+			   (postdiv1 << A35_SS_PLL_FREQ2_POSTDIV1_SHIFT) &
+			   A35_SS_PLL_FREQ2_POSTDIV1_MASK);
+
+	mmio_clrsetbits_32(pll_freq2_reg, A35_SS_PLL_FREQ2_POSTDIV2_MASK,
+			   (postdiv2 << A35_SS_PLL_FREQ2_POSTDIV2_SHIFT) &
+			   A35_SS_PLL_FREQ2_POSTDIV2_MASK);
+}
+
+static int clk_stm32_pll_config_output(struct stm32_clk_priv *priv,
+				       const struct stm32_clk_pll *pll,
+				       uint32_t *pllcfg,
+				       uint32_t fracv)
+{
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+	uintptr_t pllxcfgr2 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR2;
+	uintptr_t pllxcfgr3 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR3;
+	uintptr_t pllxcfgr4 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR4;
+	uintptr_t pllxcfgr6 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR6;
+	uintptr_t pllxcfgr7 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR7;
+	unsigned long refclk;
+
+	refclk = _clk_stm32_get_parent_rate(priv, pll->clk_id);
+
+	if (fracv == 0U) {
+		/* PLL in integer mode */
+
+		/*
+		 * No need to check max clock, as oscillator reference clocks
+		 * will always be less than 1.2GHz
+		 */
+		if (refclk < PLL_REFCLK_MIN) {
+			panic();
+		}
+
+		mmio_clrbits_32(pllxcfgr3, RCC_PLLxCFGR3_FRACIN_MASK);
+		mmio_clrbits_32(pllxcfgr4, RCC_PLLxCFGR4_DSMEN);
+		mmio_clrbits_32(pllxcfgr3, RCC_PLLxCFGR3_DACEN);
+		mmio_setbits_32(pllxcfgr3, RCC_PLLxCFGR3_SSCGDIS);
+		mmio_setbits_32(pllxcfgr1, RCC_PLLxCFGR1_SSMODRST);
+	} else {
+		/* PLL in frac mode */
+
+		/*
+		 * No need to check max clock, as oscillator reference clocks
+		 * will always be less than 1.2GHz
+		 */
+		if (refclk < PLL_FRAC_REFCLK_MIN) {
+			panic();
+		}
+
+		mmio_clrsetbits_32(pllxcfgr3, RCC_PLLxCFGR3_FRACIN_MASK,
+				   fracv & RCC_PLLxCFGR3_FRACIN_MASK);
+		mmio_setbits_32(pllxcfgr3, RCC_PLLxCFGR3_SSCGDIS);
+		mmio_setbits_32(pllxcfgr4, RCC_PLLxCFGR4_DSMEN);
+	}
+
+	assert(pllcfg[REFDIV] != 0U);
+
+	mmio_clrsetbits_32(pllxcfgr2, RCC_PLLxCFGR2_FBDIV_MASK,
+			   (pllcfg[FBDIV] << RCC_PLLxCFGR2_FBDIV_SHIFT) &
+			   RCC_PLLxCFGR2_FBDIV_MASK);
+	mmio_clrsetbits_32(pllxcfgr2, RCC_PLLxCFGR2_FREFDIV_MASK,
+			   pllcfg[REFDIV] & RCC_PLLxCFGR2_FREFDIV_MASK);
+	mmio_clrsetbits_32(pllxcfgr6, RCC_PLLxCFGR6_POSTDIV1_MASK,
+			   pllcfg[POSTDIV1] & RCC_PLLxCFGR6_POSTDIV1_MASK);
+	mmio_clrsetbits_32(pllxcfgr7, RCC_PLLxCFGR7_POSTDIV2_MASK,
+			   pllcfg[POSTDIV2] & RCC_PLLxCFGR7_POSTDIV2_MASK);
+
+	if ((pllcfg[POSTDIV1] == 0U) || (pllcfg[POSTDIV2] == 0U)) {
+		/* Bypass mode */
+		mmio_setbits_32(pllxcfgr4, RCC_PLLxCFGR4_BYPASS);
+		mmio_clrbits_32(pllxcfgr4, RCC_PLLxCFGR4_FOUTPOSTDIVEN);
+	} else {
+		mmio_clrbits_32(pllxcfgr4, RCC_PLLxCFGR4_BYPASS);
+		mmio_setbits_32(pllxcfgr4, RCC_PLLxCFGR4_FOUTPOSTDIVEN);
+	}
+
+	return 0;
+}
+
+static void clk_stm32_pll_config_csg(struct stm32_clk_priv *priv,
+				     const struct stm32_clk_pll *pll,
+				     uint32_t *csg)
+{
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+	uintptr_t pllxcfgr3 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR3;
+	uintptr_t pllxcfgr4 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR4;
+	uintptr_t pllxcfgr5 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR5;
+
+
+	mmio_clrsetbits_32(pllxcfgr5, RCC_PLLxCFGR5_DIVVAL_MASK,
+			   csg[DIVVAL] & RCC_PLLxCFGR5_DIVVAL_MASK);
+	mmio_clrsetbits_32(pllxcfgr5, RCC_PLLxCFGR5_SPREAD_MASK,
+			   (csg[SPREAD] << RCC_PLLxCFGR5_SPREAD_SHIFT) &
+			   RCC_PLLxCFGR5_SPREAD_MASK);
+
+	if (csg[DOWNSPREAD] != 0) {
+		mmio_setbits_32(pllxcfgr3, RCC_PLLxCFGR3_DOWNSPREAD);
+	} else {
+		mmio_clrbits_32(pllxcfgr3, RCC_PLLxCFGR3_DOWNSPREAD);
+	}
+
+	mmio_clrbits_32(pllxcfgr3, RCC_PLLxCFGR3_SSCGDIS);
+
+	mmio_clrbits_32(pllxcfgr1, RCC_PLLxCFGR1_PLLEN);
+	udelay(1);
+
+	mmio_setbits_32(pllxcfgr4, RCC_PLLxCFGR4_DSMEN);
+	mmio_setbits_32(pllxcfgr3, RCC_PLLxCFGR3_DACEN);
+}
+
+static int stm32_clk_configure_mux(struct stm32_clk_priv *priv, uint32_t data);
+
+static inline struct stm32_pll_dt_cfg *clk_stm32_pll_get_pdata(int pll_idx)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	struct stm32_clk_platdata *pdata = priv->pdata;
+
+	return  &pdata->pll[pll_idx];
+}
+
+static int _clk_stm32_pll1_init(struct stm32_clk_priv *priv, int pll_idx,
+				struct stm32_pll_dt_cfg *pll_conf)
+{
+	const struct stm32_clk_pll *pll = clk_stm32_pll_data(pll_idx);
+	unsigned long refclk;
+	int ret = 0;
+
+	/*
+	 * TODO: check if pll has already good parameters or if we could make
+	    a configuration on the fly.
+	 */
+
+	stm32mp2_a35_ss_on_hsi();
+
+	ret = stm32_clk_configure_mux(priv, pll_conf->src);
+	if (ret != 0) {
+		panic();
+	}
+
+	refclk = _clk_stm32_get_parent_rate(priv, pll->clk_id);
+
+	/*
+	 * No need to check max clock, as oscillator reference clocks will
+	 * always be less than 1.2 GHz
+	 */
+	if (refclk < PLL_REFCLK_MIN) {
+		ERROR("%s: %d\n", __func__, __LINE__);
+		panic();
+	}
+
+	stm32mp2_a35_pll1_config(pll_conf->cfg[FBDIV], pll_conf->cfg[REFDIV],
+				 pll_conf->cfg[POSTDIV1], pll_conf->cfg[POSTDIV2]);
+
+	ret = stm32mp2_a35_pll1_start();
+	if (ret != 0) {
+		panic();
+	}
+
+	return 0;
+}
+
+static int clk_stm32_pll_wait_mux_ready(struct stm32_clk_priv *priv,
+					const struct stm32_clk_pll *pll)
+{
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+	uint64_t timeout = timeout_init_us(CLKSRC_TIMEOUT);
+
+	while ((mmio_read_32(pllxcfgr1) & RCC_PLLxCFGR1_CKREFST) !=
+	       RCC_PLLxCFGR1_CKREFST) {
+		if (timeout_elapsed(timeout)) {
+			ERROR("PLL%d ref clock not started\n", pll->clk_id);
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static int _clk_stm32_pll_init(struct stm32_clk_priv *priv, int pll_idx,
+			       struct stm32_pll_dt_cfg *pll_conf)
+{
+	const struct stm32_clk_pll *pll = clk_stm32_pll_data(pll_idx);
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+	bool spread_spectrum = false;
+	int ret = 0;
+
+	/*
+	 * TODO: check if pll has already good parameters or if we could make
+	    a configuration on the fly.
+	 */
+
+	_clk_stm32_pll_disable(priv, pll);
+
+	ret = stm32_clk_configure_mux(priv, pll_conf->src);
+	if (ret != 0) {
+		panic();
+	}
+
+	ret = clk_stm32_pll_wait_mux_ready(priv, pll);
+	if (ret != 0) {
+		panic();
+	}
+
+	ret = clk_stm32_pll_config_output(priv, pll, pll_conf->cfg, pll_conf->frac);
+	if (ret != 0) {
+		panic();
+	}
+
+	if (pll_conf->csg_enabled) {
+		clk_stm32_pll_config_csg(priv, pll, pll_conf->csg);
+		spread_spectrum = true;
+	}
+
+	_clk_stm32_pll_enable(priv, pll);
+
+	if (spread_spectrum) {
+		mmio_clrbits_32(pllxcfgr1, RCC_PLLxCFGR1_SSMODRST);
+	}
+
+	return 0;
+}
+
+static int clk_stm32_pll_init(struct stm32_clk_priv *priv, int pll_idx)
+{
+	struct stm32_pll_dt_cfg *pll_conf = clk_stm32_pll_get_pdata(pll_idx);
+
+	if (pll_conf->enabled) {
+		if (pll_idx == _PLL1) {
+			return _clk_stm32_pll1_init(priv, pll_idx, pll_conf);
+		} else  {
+			return _clk_stm32_pll_init(priv, pll_idx, pll_conf);
+		}
+	}
+
+	return 0;
+}
+
+static int stm32mp2_clk_pll_configure(struct stm32_clk_priv *priv)
+{
+	enum pll_id i;
+	int err;
+
+	for (i = _PLL1; i < _PLL_NB; i++) {
+		err = clk_stm32_pll_init(priv, i);
+		if (err) {
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int wait_predivsr(uint16_t channel)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	uintptr_t rcc_base = priv->base;
+	uintptr_t previvsr;
+	uint32_t channel_bit;
+	uint64_t timeout;
+
+	if (channel < __WORD_BIT) {
+		previvsr = rcc_base + RCC_PREDIVSR1;
+		channel_bit = BIT(channel);
+	} else {
+		previvsr = rcc_base + RCC_PREDIVSR2;
+		channel_bit = BIT(channel - __WORD_BIT);
+	}
+
+	timeout = timeout_init_us(CLKDIV_TIMEOUT);
+	while ((mmio_read_32(previvsr) & channel_bit) != 0U) {
+		if (timeout_elapsed(timeout)) {
+			ERROR("Pre divider status: %x\n",
+			      mmio_read_32(previvsr));
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static int wait_findivsr(uint16_t channel)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	uintptr_t rcc_base = priv->base;
+	uintptr_t finvivsr;
+	uint32_t channel_bit;
+	uint64_t timeout;
+
+	if (channel < __WORD_BIT) {
+		finvivsr = rcc_base + RCC_FINDIVSR1;
+		channel_bit = BIT(channel);
+	} else {
+		finvivsr = rcc_base + RCC_FINDIVSR2;
+		channel_bit = BIT(channel - __WORD_BIT);
+	}
+
+	timeout = timeout_init_us(CLKDIV_TIMEOUT);
+	while ((mmio_read_32(finvivsr) & channel_bit) != 0U) {
+		if (timeout_elapsed(timeout)) {
+			ERROR("Final divider status: %x\n",
+			      mmio_read_32(finvivsr));
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static int wait_xbar_sts(uint16_t channel)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	uintptr_t rcc_base = priv->base;
+	uintptr_t xbar_cfgr = rcc_base + RCC_XBAR0CFGR + (0x4U * channel);
+	uint64_t timeout;
+
+	timeout = timeout_init_us(CLKDIV_TIMEOUT);
+	while ((mmio_read_32(xbar_cfgr) & RCC_XBAR0CFGR_XBAR0STS) != 0U) {
+		if (timeout_elapsed(timeout)) {
+			ERROR("XBAR%uCFGR: %x\n", channel,
+			      mmio_read_32(xbar_cfgr));
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static void flexclkgen_config_channel(uint16_t channel, unsigned int clk_src,
+				      unsigned int prediv, unsigned int findiv)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	uintptr_t rcc_base = priv->base;
+
+	if (wait_predivsr(channel) != 0) {
+		panic();
+	}
+
+	mmio_clrsetbits_32(rcc_base + RCC_PREDIV0CFGR + (0x4U * channel),
+			   RCC_PREDIV0CFGR_PREDIV0_MASK,
+			   prediv);
+
+	if (wait_predivsr(channel) != 0) {
+		panic();
+	}
+
+	if (wait_findivsr(channel) != 0) {
+		panic();
+	}
+
+	mmio_clrsetbits_32(rcc_base + RCC_FINDIV0CFGR + (0x4U * channel),
+			   RCC_FINDIV0CFGR_FINDIV0_MASK,
+			   findiv);
+
+	if (wait_findivsr(channel) != 0) {
+		panic();
+	}
+
+	if (wait_xbar_sts(channel) != 0) {
+		panic();
+	}
+
+	mmio_clrsetbits_32(rcc_base + RCC_XBAR0CFGR + (0x4U * channel),
+			   RCC_XBARxCFGR_XBARxSEL_MASK,
+			   clk_src);
+	mmio_setbits_32(rcc_base + RCC_XBAR0CFGR + (0x4U * channel),
+			RCC_XBARxCFGR_XBARxEN);
+
+	if (wait_xbar_sts(channel) != 0) {
+		panic();
+	}
+}
+
+static int stm32mp2_clk_flexgen_configure(struct stm32_clk_priv *priv)
+{
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	uint32_t i;
+
+	for (i = 0U; i < pdata->nflexgen; i++) {
+		uint32_t val = pdata->flexgen[i];
+		uint32_t cmd, cmd_data;
+		unsigned int channel, clk_src, pdiv, fdiv;
+
+		cmd = (val & CMD_MASK) >> CMD_SHIFT;
+		cmd_data = val & ~CMD_MASK;
+
+		if (cmd != CMD_FLEXGEN) {
+			continue;
+		}
+
+		channel = (cmd_data & FLEX_ID_MASK) >> FLEX_ID_SHIFT;
+		clk_src = (cmd_data & FLEX_SEL_MASK) >> FLEX_SEL_SHIFT;
+		pdiv = (cmd_data & FLEX_PDIV_MASK) >> FLEX_PDIV_SHIFT;
+		fdiv = (cmd_data & FLEX_FDIV_MASK) >> FLEX_FDIV_SHIFT;
+
+		/* TODO: check if channel can be reconfigured */
+		switch (channel) {
+		case 33U: /* STGEN */
+			break;
+
+		default:
+			flexclkgen_config_channel(channel, clk_src, pdiv, fdiv);
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static void stm32_enable_oscillator_hse(struct stm32_clk_priv *priv)
+{
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	struct stm32_osci_dt_cfg *osci = &pdata->osci[OSC_HSE];
+	bool digbyp =  osci->digbyp;
+	bool bypass = osci->bypass;
+	bool css = osci->css;
+
+	if (_clk_stm32_get_rate(priv, _CK_HSE) == 0U) {
+		return;
+	}
+
+	clk_oscillator_set_bypass(priv, _CK_HSE, digbyp, bypass);
+
+	_clk_stm32_enable(priv, _CK_HSE);
+
+	clk_oscillator_set_css(priv, _CK_HSE, css);
+}
+
+#ifndef CFG_WORKAROUND_VSW0V8
+static void stm32_enable_oscillator_lse(struct stm32_clk_priv *priv)
+{
+	struct clk_oscillator_data *osc_data = clk_oscillator_get_data(priv, _CK_LSE);
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	struct stm32_osci_dt_cfg *osci = &pdata->osci[OSC_LSE];
+	bool digbyp =  osci->digbyp;
+	bool bypass = osci->bypass;
+	uint8_t drive = osci->drive;
+
+	if (_clk_stm32_get_rate(priv, _CK_LSE) == 0U) {
+		return;
+	}
+
+	/* Do not reconfigure LSE if already enabled */
+	if (_clk_stm32_gate_is_enabled(priv, osc_data->gate_id)) {
+		return;
+	}
+
+	clk_oscillator_set_bypass(priv, _CK_LSE, digbyp, bypass);
+
+	clk_oscillator_set_drive(priv, _CK_LSE, drive);
+
+	_clk_stm32_gate_enable(priv, osc_data->gate_id);
+}
+#else
+static void stm32_enable_oscillator_lse(struct stm32_clk_priv *priv __unused)
+{
+}
+#endif
+
+static int stm32mp2_clk_switch_to_hsi(struct stm32_clk_priv *priv)
+{
+	stm32mp2_a35_ss_on_hsi();
+	stm32mp2_clk_muxsel_on_hsi(priv);
+	stm32mp2_clk_xbar_on_hsi(priv);
+
+	return 0;
+}
+
+static int stm32_clk_oscillators_wait_lse_ready(struct stm32_clk_priv *priv)
+{
+	int ret = 0;
+
+	if (_clk_stm32_get_rate(priv, _CK_LSE) != 0U) {
+#ifndef CFG_WORKAROUND_VSW0V8
+		ret = clk_oscillator_wait_ready_on(priv, _CK_LSE);
+#endif
+	}
+
+	return ret;
+}
+
+static void stm32_enable_oscillator_msi(struct stm32_clk_priv *priv)
+{
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	struct stm32_osci_dt_cfg *osci = &pdata->osci[OSC_MSI];
+	int err;
+
+	err = clk_stm32_osc_msi_set_rate(priv, _CK_MSI, osci->freq, 0);
+	if (err != 0) {
+		ERROR("Invalid rate %lu MHz for MSI ! (4 or 16 only)\n", osci->freq / 1000000U);
+		panic();
+	}
+
+	_clk_stm32_enable(priv, _CK_MSI);
+}
+
+static void stm32_clk_oscillators_enable(struct stm32_clk_priv *priv)
+{
+	stm32_enable_oscillator_hse(priv);
+	stm32_enable_oscillator_lse(priv);
+	stm32_enable_oscillator_msi(priv);
+#ifndef CFG_WORKAROUND_VSW0V8
+	_clk_stm32_enable(priv, _CK_LSI);
+#endif
+}
+
+static int stm32_clk_configure_div(struct stm32_clk_priv *priv, uint32_t data)
+{
+	int div_id = (data & DIV_ID_MASK) >> DIV_ID_SHIFT;
+	int div_n = (data & DIV_DIVN_MASK) >> DIV_DIVN_SHIFT;
+
+	return clk_stm32_set_div(priv, div_id, div_n);
+}
+
+static int stm32_clk_configure_mux(struct stm32_clk_priv *priv, uint32_t data)
+{
+	int mux_id = (data & MUX_ID_MASK) >> MUX_ID_SHIFT;
+	int sel = (data & MUX_SEL_MASK) >> MUX_SEL_SHIFT;
+
+	return clk_mux_set_parent(priv, mux_id, sel);
+}
+
+static int stm32_clk_configure_clk_get_binding_id(struct stm32_clk_priv *priv, uint32_t data)
+{
+	unsigned long binding_id = ((unsigned long)data & CLK_ID_MASK) >> CLK_ID_SHIFT;
+
+	return clk_get_index(priv, binding_id);
+}
+
+static int stm32_clk_configure_clk(struct stm32_clk_priv *priv, uint32_t data)
+{
+	int sel = (data & CLK_SEL_MASK) >> CLK_SEL_SHIFT;
+	int enable = (data & CLK_ON_MASK) >> CLK_ON_SHIFT;
+	int clk_id = 0;
+	int ret = 0;
+
+	clk_id = stm32_clk_configure_clk_get_binding_id(priv, data);
+	if (clk_id < 0) {
+		return clk_id;
+	}
+
+	if (sel != CLK_NOMUX) {
+		ret = _clk_stm32_set_parent_by_index(priv, clk_id, sel);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	if (enable) {
+		clk_stm32_enable_call_ops(priv, clk_id);
+	} else {
+		clk_stm32_disable_call_ops(priv, clk_id);
+	}
+
+	return 0;
+}
+
+static int stm32_clk_configure(struct stm32_clk_priv *priv, uint32_t val)
+{
+	uint32_t cmd = (val & CMD_MASK) >> CMD_SHIFT;
+	uint32_t cmd_data = val & ~CMD_MASK;
+	int ret = -1;
+
+	switch (cmd) {
+	case CMD_DIV:
+		ret = stm32_clk_configure_div(priv, cmd_data);
+		break;
+
+	case CMD_MUX:
+		ret = stm32_clk_configure_mux(priv, cmd_data);
+		break;
+
+	case CMD_CLK:
+		ret = stm32_clk_configure_clk(priv, cmd_data);
+		break;
+
+	default:
+		ERROR("%s: cmd unknown ! : 0x%x\n", __func__, val);
+		break;
+	}
+
+	return ret;
+}
+
+static int stm32_clk_bus_configure(struct stm32_clk_priv *priv)
+{
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	uint32_t i;
+
+	for (i = 0; i < pdata->nbusclk; i++) {
+		int ret;
+
+		ret = stm32_clk_configure(priv, pdata->busclk[i]);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_clk_kernel_configure(struct stm32_clk_priv *priv)
+{
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	uint32_t i;
+
+	for (i = 0U; i < pdata->nkernelclk; i++) {
+		int ret;
+
+		ret = stm32_clk_configure(priv, pdata->kernelclk[i]);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32mp2_init_clock_tree(void)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	int ret;
+
+	/* Set timer with STGEN without changing its clock source */
+	stm32mp_stgen_restore_rate();
+	generic_delay_timer_init();
+
+	stm32_clk_oscillators_enable(priv);
+
+	/* Come back to HSI */
+	ret = stm32mp2_clk_switch_to_hsi(priv);
+	if (ret != 0) {
+		panic();
+	}
+
+	ret = stm32mp2_clk_pll_configure(priv);
+	if (ret != 0) {
+		panic();
+	}
+
+	/* Wait LSE ready before to use it */
+	ret = stm32_clk_oscillators_wait_lse_ready(priv);
+	if (ret != 0) {
+		panic();
+	}
+
+	ret = stm32mp2_clk_flexgen_configure(priv);
+	if (ret != 0) {
+		panic();
+	}
+
+	ret = stm32_clk_bus_configure(priv);
+	if (ret != 0) {
+		panic();
+	}
+
+	ret = stm32_clk_kernel_configure(priv);
+	if (ret != 0) {
+		panic();
+	}
+
+	return 0;
+}
+
+#define LSEDRV_MEDIUM_HIGH 2
+
+int clk_stm32_parse_oscillator_fdt(void *fdt, int node, const char *name,
+				   struct stm32_osci_dt_cfg *osci)
+{
+	int subnode = 0;
+
+	/* Default value oscillator not found, freq=0 */
+	osci->freq = 0;
+
+	fdt_for_each_subnode(subnode, fdt, node) {
+		const char *cchar = NULL;
+		const fdt32_t *cuint = NULL;
+		int ret = 0;
+
+		cchar = fdt_get_name(fdt, subnode, &ret);
+		if (cchar == NULL) {
+			return ret;
+		}
+
+		if (strncmp(cchar, name, (size_t)ret) ||
+		    fdt_get_status(subnode) == DT_DISABLED) {
+			continue;
+		}
+
+		cuint = fdt_getprop(fdt, subnode, "clock-frequency", &ret);
+		if (cuint == NULL) {
+			return ret;
+		}
+
+		osci->freq = fdt32_to_cpu(*cuint);
+
+		if (fdt_getprop(fdt, subnode, "st,bypass", NULL) != NULL) {
+			osci->bypass = true;
+		}
+
+		if (fdt_getprop(fdt, subnode, "st,digbypass", NULL) != NULL) {
+			osci->digbyp = true;
+		}
+
+		if (fdt_getprop(fdt, subnode, "st,css", NULL) != NULL) {
+			osci->css = true;
+		}
+
+		osci->drive = fdt_read_uint32_default(fdt, subnode, "st,drive", LSEDRV_MEDIUM_HIGH);
+
+		return 0;
+	}
+
+	return 0;
+}
+
+static int stm32_clk_parse_fdt_all_oscillator(void *fdt, struct stm32_clk_platdata *pdata)
+{
+	int fdt_err = 0;
+	uint32_t i = 0;
+	int node = 0;
+
+	node = fdt_path_offset(fdt, "/clocks");
+	if (node < 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	for (i = 0; i < pdata->nosci; i++) {
+		const char *name = NULL;
+
+		name = clk_stm32_get_oscillator_name((enum stm32_osc)i);
+		if (name == NULL) {
+			continue;
+		}
+
+		fdt_err = clk_stm32_parse_oscillator_fdt(fdt, node, name, &pdata->osci[i]);
+		if (fdt_err < 0) {
+			panic();
+		}
+	}
+
+	return 0;
+}
+
+static int clk_stm32_parse_pll_fdt(void *fdt, int subnode, struct stm32_pll_dt_cfg *pll)
+{
+	const fdt32_t *cuint = NULL;
+	int subnode_pll = 0;
+	uint32_t val = 0;
+	int err = 0;
+
+	cuint = fdt_getprop(fdt, subnode, "st,pll", NULL);
+	if (!cuint) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	subnode_pll = fdt_node_offset_by_phandle(fdt, fdt32_to_cpu(*cuint));
+	if (subnode_pll < 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	err = fdt_read_uint32_array(fdt, subnode_pll, "cfg", (int)PLLCFG_NB, pll->cfg);
+	if (err != 0) {
+		return err;
+	}
+
+	err = fdt_read_uint32_array(fdt, subnode_pll, "csg", (int)PLLCSG_NB, pll->csg);
+
+	pll->csg_enabled = (err == 0);
+
+	if (err == -FDT_ERR_NOTFOUND) {
+		err = 0;
+	}
+
+	if (err != 0) {
+		return err;
+	}
+
+	pll->enabled = true;
+
+	pll->frac = fdt_read_uint32_default(fdt, subnode_pll, "frac", 0);
+
+	pll->src = UINT32_MAX;
+
+	err = fdt_read_uint32(fdt, subnode_pll, "src", &val);
+	if  (err == 0) {
+		pll->src = val;
+	}
+
+	return 0;
+}
+
+#define RCC_PLL_NAME_SIZE 12
+
+static int stm32_clk_parse_fdt_all_pll(void *fdt, int node, struct stm32_clk_platdata *pdata)
+{
+	unsigned int i = 0;
+
+	for (i = _PLL1; i < pdata->npll; i++) {
+		struct stm32_pll_dt_cfg *pll = pdata->pll + i;
+		char name[RCC_PLL_NAME_SIZE];
+		int subnode = 0;
+		int err = 0;
+
+		snprintf(name, sizeof(name), "st,pll@%u", i);
+
+		subnode = fdt_subnode_offset(fdt, node, name);
+		if (!fdt_check_node(subnode)) {
+			continue;
+		}
+
+		err = clk_stm32_parse_pll_fdt(fdt, subnode, pll);
+		if (err != 0) {
+			panic();
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_clk_parse_fdt(struct stm32_clk_platdata *pdata)
+{
+	void *fdt = NULL;
+	int node;
+	int err;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -ENOENT;
+	}
+
+	node = fdt_node_offset_by_compatible(fdt, -1, DT_RCC_CLK_COMPAT);
+	if (node < 0) {
+		panic();
+	}
+
+	err = stm32_clk_parse_fdt_all_oscillator(fdt, pdata);
+	if (err != 0) {
+		return err;
+	}
+
+	err = stm32_clk_parse_fdt_all_pll(fdt, node, pdata);
+	if (err != 0) {
+		return err;
+	}
+
+	err = stm32_clk_parse_fdt_by_name(fdt, node, "st,busclk", pdata->busclk, &pdata->nbusclk);
+	if (err != 0) {
+		return err;
+	}
+
+	err = stm32_clk_parse_fdt_by_name(fdt, node, "st,flexgen", pdata->flexgen,
+					  &pdata->nflexgen);
+	if (err != 0) {
+		return err;
+	}
+
+	err = stm32_clk_parse_fdt_by_name(fdt, node, "st,kerclk", pdata->kernelclk,
+					  &pdata->nkernelclk);
+	if (err != 0) {
+		return err;
+	}
+
+	return 0;
+}
+#endif /* IMAGE_BL2 */
+
+static void stmp32mp2_clk_init_ddr_sub_system(uintptr_t base)
+{
+	mmio_write_32(base + RCC_DDRCPCFGR,
+		      RCC_DDRCPCFGR_DDRCPEN | RCC_DDRCPCFGR_DDRCPLPEN);
+}
+
+struct stm32_osci_dt_cfg mp25_osci[NB_OSCILLATOR];
+
+struct stm32_pll_dt_cfg mp25_pll[_PLL_NB];
+
+#define DT_FLEXGEN_CLK_MAX	64
+uint32_t mp25_flexgen[DT_FLEXGEN_CLK_MAX];
+
+#define DT_BUS_CLK_MAX		6
+uint32_t mp25_busclk[DT_BUS_CLK_MAX];
+
+#define DT_KERNEL_CLK_MAX	20
+uint32_t mp25_kernelclk[DT_KERNEL_CLK_MAX];
+
+struct stm32_clk_platdata stm32mp25_pdata = {
+	.osci = mp25_osci,
+	.nosci = NB_OSCILLATOR,
+	.pll = mp25_pll,
+	.npll = _PLL_NB,
+	.flexgen = mp25_flexgen,
+	.nflexgen = DT_FLEXGEN_CLK_MAX,
+	.busclk	= mp25_busclk,
+	.nbusclk = DT_BUS_CLK_MAX,
+	.kernelclk = mp25_kernelclk,
+	.nkernelclk = DT_KERNEL_CLK_MAX,
+};
+
+static unsigned int refcounts_mp25[CK_LAST];
+
+static struct stm32_clk_priv stm32mp25_clock_data = {
+	.base		= RCC_BASE,
+	.num		= ARRAY_SIZE(stm32mp25_clk),
+	.clks		= stm32mp25_clk,
+	.parents	= parent_mp25,
+	.nb_parents	= ARRAY_SIZE(parent_mp25),
+	.gates		= gates_mp25,
+	.nb_gates	= ARRAY_SIZE(gates_mp25),
+	.div		= dividers_mp25,
+	.nb_div		= ARRAY_SIZE(dividers_mp25),
+	.osci_data	= stm32mp25_osc_data,
+	.nb_osci_data	= ARRAY_SIZE(stm32mp25_osc_data),
+	.gate_refcounts	= refcounts_mp25,
+	.pdata		= &stm32mp25_pdata
+};
+
+int stm32mp2_clk_init(void)
+{
+	uintptr_t base = RCC_BASE;
+	int ret;
+
+#ifdef IMAGE_BL2
+	ret = stm32_clk_parse_fdt(&stm32mp25_pdata);
+	if (ret != 0) {
+		return ret;
+	}
+#endif
+
+	ret = clk_stm32_init(&stm32mp25_clock_data, base);
+	if (ret != 0) {
+		return ret;
+	}
+
+	stmp32mp2_clk_init_ddr_sub_system(base);
+
+#ifdef IMAGE_BL2
+	ret = stm32mp2_init_clock_tree();
+	if (ret != 0) {
+		return ret;
+	}
+
+	clk_stm32_enable_critical_clocks();
+#endif
+
+	return 0;
+}
diff --git a/drivers/st/clk/stm32mp_clkfunc.c b/drivers/st/clk/stm32mp_clkfunc.c
index d57f120b9..fb683a803 100644
--- a/drivers/st/clk/stm32mp_clkfunc.c
+++ b/drivers/st/clk/stm32mp_clkfunc.c
@@ -10,9 +10,13 @@
 
 #include <platform_def.h>
 
+#include <arch_helpers.h>
 #include <common/fdt_wrappers.h>
+#include <drivers/clk.h>
+#include <drivers/generic_delay_timer.h>
 #include <drivers/st/stm32_gpio.h>
 #include <drivers/st/stm32mp_clkfunc.h>
+#include <lib/mmio.h>
 
 /*
  * Get the frequency of an oscillator from its name in device tree.
@@ -43,7 +47,8 @@ int fdt_osc_read_freq(const char *name, uint32_t *freq)
 			return ret;
 		}
 
-		if (strncmp(cchar, name, (size_t)ret) == 0) {
+		if ((strncmp(cchar, name, (size_t)ret) == 0) &&
+		    (fdt_get_status(subnode) != DT_DISABLED)) {
 			const fdt32_t *cuint;
 
 			cuint = fdt_getprop(fdt, subnode, "clock-frequency",
@@ -69,7 +74,7 @@ int fdt_osc_read_freq(const char *name, uint32_t *freq)
  * @param prop_name: property name
  * @return: true/false regarding search result.
  */
-bool fdt_osc_read_bool(enum stm32mp_osc_id osc_id, const char *prop_name)
+bool fdt_clk_read_bool(const char *node_label, const char *prop_name)
 {
 	int node, subnode;
 	void *fdt;
@@ -78,10 +83,6 @@ bool fdt_osc_read_bool(enum stm32mp_osc_id osc_id, const char *prop_name)
 		return false;
 	}
 
-	if (osc_id >= NB_OSC) {
-		return false;
-	}
-
 	node = fdt_path_offset(fdt, "/clocks");
 	if (node < 0) {
 		return false;
@@ -96,8 +97,7 @@ bool fdt_osc_read_bool(enum stm32mp_osc_id osc_id, const char *prop_name)
 			return false;
 		}
 
-		if (strncmp(cchar, stm32mp_osc_node_label[osc_id],
-			    (size_t)ret) != 0) {
+		if (strncmp(cchar, node_label, (size_t)ret) != 0) {
 			continue;
 		}
 
@@ -110,13 +110,13 @@ bool fdt_osc_read_bool(enum stm32mp_osc_id osc_id, const char *prop_name)
 }
 
 /*
- * Get the value of a oscillator property from its ID.
- * @param osc_id: oscillator ID
+ * Get the value of a oscillator property from its name.
+ * @param node_label: oscillator name
  * @param prop_name: property name
  * @param dflt_value: default value
  * @return oscillator value on success, default value if property not found.
  */
-uint32_t fdt_osc_read_uint32_default(enum stm32mp_osc_id osc_id,
+uint32_t fdt_clk_read_uint32_default(const char *node_label,
 				     const char *prop_name, uint32_t dflt_value)
 {
 	int node, subnode;
@@ -126,10 +126,6 @@ uint32_t fdt_osc_read_uint32_default(enum stm32mp_osc_id osc_id,
 		return dflt_value;
 	}
 
-	if (osc_id >= NB_OSC) {
-		return dflt_value;
-	}
-
 	node = fdt_path_offset(fdt, "/clocks");
 	if (node < 0) {
 		return dflt_value;
@@ -144,8 +140,7 @@ uint32_t fdt_osc_read_uint32_default(enum stm32mp_osc_id osc_id,
 			return dflt_value;
 		}
 
-		if (strncmp(cchar, stm32mp_osc_node_label[osc_id],
-			    (size_t)ret) != 0) {
+		if (strncmp(cchar, node_label, (size_t)ret) != 0) {
 			continue;
 		}
 
@@ -197,6 +192,29 @@ int fdt_rcc_read_uint32_array(const char *prop_name, uint32_t count,
 	return fdt_read_uint32_array(fdt, node, prop_name, count, array);
 }
 
+/*******************************************************************************
+ * This function reads a property rcc-clk section.
+ * It reads the values indicated inside the device tree, from property name.
+ * Returns dflt_value if property is not found, and a property value on
+ * success.
+ ******************************************************************************/
+uint32_t fdt_rcc_read_uint32_default(const char *prop_name, uint32_t dflt_value)
+{
+	int node;
+	void *fdt;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return dflt_value;
+	}
+
+	node = fdt_get_rcc_node(fdt);
+	if (node < 0) {
+		return dflt_value;
+	}
+
+	return fdt_read_uint32_default(fdt, node, prop_name, dflt_value);
+}
+
 /*
  * Get the subnode offset in rcc-clk section from its name in device tree
  * @param name: name of the RCC property
@@ -255,24 +273,38 @@ const fdt32_t *fdt_rcc_read_prop(const char *prop_name, int *lenp)
 }
 
 /*
- * Get the secure status for rcc node in device tree.
- * @return: true if rcc is available from secure world, false if not.
+ * Get the secure state for rcc node in device tree.
+ * @return: true if rcc is configured for secure world access, false if not.
  */
-bool fdt_get_rcc_secure_status(void)
+bool fdt_get_rcc_secure_state(void)
 {
-	int node;
 	void *fdt;
 
 	if (fdt_get_address(&fdt) == 0) {
 		return false;
 	}
 
-	node = fdt_get_rcc_node(fdt);
-	if (node < 0) {
+	if (fdt_node_offset_by_compatible(fdt, -1, DT_RCC_SEC_CLK_COMPAT) < 0) {
 		return false;
 	}
 
-	return !!(fdt_get_status(node) & DT_SECURE);
+	return true;
+}
+
+/*
+ * This function gets interrupt name.
+ * It reads the values indicated the enabling status.
+ * Returns 0 if success, and a negative value else.
+ */
+int fdt_rcc_enable_it(const char *name)
+{
+	void *fdt;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -ENOENT;
+	}
+
+	return stm32mp_gic_enable_spi(fdt_get_rcc_node(fdt), name);
 }
 
 /*
@@ -297,3 +329,149 @@ int fdt_get_clock_id(int node)
 	cuint++;
 	return (int)fdt32_to_cpu(*cuint);
 }
+
+/*******************************************************************************
+ * This function gets the clock ID of the given node using clock-names.
+ * It reads the value indicated inside the device tree.
+ * Returns ID on success, and a negative FDT/ERRNO error code on failure.
+ ******************************************************************************/
+int fdt_get_clock_id_by_name(int node, const char *name)
+{
+	const fdt32_t *cuint;
+	void *fdt;
+	int index, len;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -ENOENT;
+	}
+
+	index = fdt_stringlist_search(fdt, node, "clock-names", name);
+	if (index < 0) {
+		return index;
+	}
+
+	cuint = fdt_getprop(fdt, node, "clocks", &len);
+	if (cuint == NULL) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	if ((index * (int)sizeof(uint32_t)) > len) {
+		return -FDT_ERR_BADVALUE;
+	}
+
+	cuint += (index << 1) + 1;
+	return (int)fdt32_to_cpu(*cuint);
+}
+
+/*
+ * Get the frequency of the specified UART instance.
+ * @param instance: UART interface registers base address.
+ * @return: clock frequency on success, 0 value on failure.
+ */
+unsigned long fdt_get_uart_clock_freq(uintptr_t instance)
+{
+	void *fdt;
+	int node;
+	int clk_id;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return 0UL;
+	}
+
+	/* Check for UART nodes */
+	node = dt_match_instance_by_compatible(DT_UART_COMPAT, instance);
+	if (node < 0) {
+		return 0UL;
+	}
+
+	clk_id = fdt_get_clock_id(node);
+	if (clk_id < 0) {
+		return 0UL;
+	}
+
+	return clk_get_rate((unsigned long)clk_id);
+}
+
+/*******************************************************************************
+ * This function sets the STGEN counter value.
+ ******************************************************************************/
+static void stgen_set_counter(unsigned long long counter)
+{
+#ifdef __aarch64__
+	mmio_write_64(STGEN_BASE + CNTCV_OFF, counter);
+#else
+	mmio_write_32(STGEN_BASE + CNTCVL_OFF, (uint32_t)counter);
+	mmio_write_32(STGEN_BASE + CNTCVU_OFF, (uint32_t)(counter >> 32));
+#endif
+}
+
+/*******************************************************************************
+ * This function configures and restores the STGEN counter depending on the
+ * connected clock.
+ ******************************************************************************/
+void stm32mp_stgen_config(unsigned long rate)
+{
+	uint32_t cntfid0;
+	unsigned long long counter;
+
+	cntfid0 = mmio_read_32(STGEN_BASE + CNTFID_OFF);
+
+	if (cntfid0 == rate) {
+		return;
+	}
+
+	mmio_clrbits_32(STGEN_BASE + CNTCR_OFF, CNTCR_EN);
+	counter = stm32mp_stgen_get_counter() * rate / cntfid0;
+
+	stgen_set_counter(counter);
+	mmio_write_32(STGEN_BASE + CNTFID_OFF, rate);
+	mmio_setbits_32(STGEN_BASE + CNTCR_OFF, CNTCR_EN);
+
+	write_cntfrq_el0((u_register_t)rate);
+
+	/* Need to update timer with new frequency */
+	generic_delay_timer_init();
+}
+
+/*******************************************************************************
+ * This function restores CPU generic timer rate from the STGEN clock rate.
+ ******************************************************************************/
+void stm32mp_stgen_restore_rate(void)
+{
+	unsigned long rate;
+
+	rate = mmio_read_32(STGEN_BASE + CNTFID_OFF);
+
+	write_cntfrq_el0((u_register_t)rate);
+}
+
+/*******************************************************************************
+ * This function returns the STGEN counter value.
+ ******************************************************************************/
+unsigned long long stm32mp_stgen_get_counter(void)
+{
+#ifdef __aarch64__
+	return mmio_read_64(STGEN_BASE + CNTCV_OFF);
+#else
+	return (((unsigned long long)mmio_read_32(STGEN_BASE + CNTCVU_OFF) << 32) |
+		mmio_read_32(STGEN_BASE + CNTCVL_OFF));
+#endif
+}
+
+/*******************************************************************************
+ * This function restores the STGEN counter value.
+ * It takes a first input value as a counter backup value to be restored and a
+ * offset in ms to be added.
+ ******************************************************************************/
+void stm32mp_stgen_restore_counter(unsigned long long value,
+				   unsigned long long offset_in_ms)
+{
+	unsigned long long cnt;
+
+	cnt = value + ((offset_in_ms *
+			mmio_read_32(STGEN_BASE + CNTFID_OFF)) / 1000U);
+
+	mmio_clrbits_32(STGEN_BASE + CNTCR_OFF, CNTCR_EN);
+	stgen_set_counter(cnt);
+	mmio_setbits_32(STGEN_BASE + CNTCR_OFF, CNTCR_EN);
+}
diff --git a/drivers/st/crypto/stm32_hash.c b/drivers/st/crypto/stm32_hash.c
index 317fd9eb8..af7fd954f 100644
--- a/drivers/st/crypto/stm32_hash.c
+++ b/drivers/st/crypto/stm32_hash.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2020, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2019-2021, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -14,6 +14,7 @@
 
 #include <arch_helpers.h>
 #include <common/debug.h>
+#include <drivers/clk.h>
 #include <drivers/delay_timer.h>
 #include <drivers/st/stm32_hash.h>
 #include <drivers/st/stm32mp_reset.h>
@@ -21,7 +22,12 @@
 #include <lib/utils.h>
 #include <plat/common/platform.h>
 
+#if STM32MP13 || STM32MP25
+#define DT_HASH_COMPAT			"st,stm32mp13-hash"
+#endif
+#if STM32MP15
 #define DT_HASH_COMPAT			"st,stm32f756-hash"
+#endif
 
 #define HASH_CR				0x00U
 #define HASH_DIN			0x04U
@@ -32,11 +38,22 @@
 /* Control Register */
 #define HASH_CR_INIT			BIT(2)
 #define HASH_CR_DATATYPE_SHIFT		U(4)
-
+#if STM32MP13 || STM32MP25
+#define HASH_CR_ALGO_SHIFT		U(17)
+#define HASH_CR_ALGO_SHA1		(0x0U << HASH_CR_ALGO_SHIFT)
+#define HASH_CR_ALGO_SHA224		(0x2U << HASH_CR_ALGO_SHIFT)
+#define HASH_CR_ALGO_SHA256		(0x3U << HASH_CR_ALGO_SHIFT)
+#define HASH_CR_ALGO_SHA384		(0xCU << HASH_CR_ALGO_SHIFT)
+#define HASH_CR_ALGO_SHA512_224		(0xDU << HASH_CR_ALGO_SHIFT)
+#define HASH_CR_ALGO_SHA512_256		(0xEU << HASH_CR_ALGO_SHIFT)
+#define HASH_CR_ALGO_SHA512		(0xFU << HASH_CR_ALGO_SHIFT)
+#endif
+#if STM32MP15
 #define HASH_CR_ALGO_SHA1		0x0U
 #define HASH_CR_ALGO_MD5		BIT(7)
 #define HASH_CR_ALGO_SHA224		BIT(18)
 #define HASH_CR_ALGO_SHA256		(BIT(18) | BIT(7))
+#endif
 
 /* Status Flags */
 #define HASH_SR_DCIS			BIT(1)
@@ -50,6 +67,10 @@
 #define SHA1_DIGEST_SIZE		20U
 #define SHA224_DIGEST_SIZE		28U
 #define SHA256_DIGEST_SIZE		32U
+#define SHA384_DIGEST_SIZE		48U
+#define SHA512_224_DIGEST_SIZE		28U
+#define SHA512_256_DIGEST_SIZE		32U
+#define SHA512_DIGEST_SIZE		64U
 
 #define RESET_TIMEOUT_US_1MS		1000U
 #define HASH_TIMEOUT_US			10000U
@@ -130,10 +151,12 @@ static void hash_hw_init(enum stm32_hash_algo_mode mode)
 	reg = HASH_CR_INIT | (HASH_DATA_8_BITS << HASH_CR_DATATYPE_SHIFT);
 
 	switch (mode) {
+#if STM32MP15
 	case HASH_MD5SUM:
 		reg |= HASH_CR_ALGO_MD5;
 		stm32_hash.digest_size = MD5_DIGEST_SIZE;
 		break;
+#endif
 	case HASH_SHA1:
 		reg |= HASH_CR_ALGO_SHA1;
 		stm32_hash.digest_size = SHA1_DIGEST_SIZE;
@@ -142,6 +165,16 @@ static void hash_hw_init(enum stm32_hash_algo_mode mode)
 		reg |= HASH_CR_ALGO_SHA224;
 		stm32_hash.digest_size = SHA224_DIGEST_SIZE;
 		break;
+#if STM32MP13
+	case HASH_SHA384:
+		reg |= HASH_CR_ALGO_SHA384;
+		stm32_hash.digest_size = SHA384_DIGEST_SIZE;
+		break;
+	case HASH_SHA512:
+		reg |= HASH_CR_ALGO_SHA512;
+		stm32_hash.digest_size = SHA512_DIGEST_SIZE;
+		break;
+#endif
 	/* Default selected algo is SHA256 */
 	case HASH_SHA256:
 	default:
@@ -189,7 +222,7 @@ int stm32_hash_update(const uint8_t *buffer, size_t length)
 		return 0;
 	}
 
-	stm32mp_clk_enable(stm32_hash.clock);
+	clk_enable(stm32_hash.clock);
 
 	if (stm32_remain.length != 0U) {
 		uint32_t copysize;
@@ -231,7 +264,7 @@ int stm32_hash_update(const uint8_t *buffer, size_t length)
 	}
 
 exit:
-	stm32mp_clk_disable(stm32_hash.clock);
+	clk_disable(stm32_hash.clock);
 
 	return ret;
 }
@@ -240,12 +273,12 @@ int stm32_hash_final(uint8_t *digest)
 {
 	int ret;
 
-	stm32mp_clk_enable(stm32_hash.clock);
+	clk_enable(stm32_hash.clock);
 
 	if (stm32_remain.length != 0U) {
 		ret = hash_write_data(stm32_remain.buffer);
 		if (ret != 0) {
-			stm32mp_clk_disable(stm32_hash.clock);
+			clk_disable(stm32_hash.clock);
 			return ret;
 		}
 
@@ -260,7 +293,7 @@ int stm32_hash_final(uint8_t *digest)
 
 	ret = hash_get_digest(digest);
 
-	stm32mp_clk_disable(stm32_hash.clock);
+	clk_disable(stm32_hash.clock);
 
 	return ret;
 }
@@ -280,11 +313,11 @@ int stm32_hash_final_update(const uint8_t *buffer, uint32_t length,
 
 void stm32_hash_init(enum stm32_hash_algo_mode mode)
 {
-	stm32mp_clk_enable(stm32_hash.clock);
+	clk_enable(stm32_hash.clock);
 
 	hash_hw_init(mode);
 
-	stm32mp_clk_disable(stm32_hash.clock);
+	clk_disable(stm32_hash.clock);
 
 	zeromem(&stm32_remain, sizeof(stm32_remain));
 }
@@ -321,7 +354,7 @@ int stm32_hash_register(void)
 	stm32_hash.base = hash_info.base;
 	stm32_hash.clock = hash_info.clock;
 
-	stm32mp_clk_enable(stm32_hash.clock);
+	clk_enable(stm32_hash.clock);
 
 	if (hash_info.reset >= 0) {
 		uint32_t id = (uint32_t)hash_info.reset;
@@ -335,7 +368,7 @@ int stm32_hash_register(void)
 		}
 	}
 
-	stm32mp_clk_disable(stm32_hash.clock);
+	clk_disable(stm32_hash.clock);
 
 	return 0;
 }
diff --git a/drivers/st/crypto/stm32_pka.c b/drivers/st/crypto/stm32_pka.c
new file mode 100644
index 000000000..e60ca3d12
--- /dev/null
+++ b/drivers/st/crypto/stm32_pka.c
@@ -0,0 +1,704 @@
+/*
+ * Copyright (c) 2020-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <stdint.h>
+
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32_pka.h>
+#include <drivers/st/stm32mp_reset.h>
+#include <lib/mmio.h>
+#include <lib/utils.h>
+#include <libfdt.h>
+
+#include <plat/common/platform.h>
+#include <platform_def.h>
+
+/*
+ * For our comprehension in this file
+ *  _len are in BITs
+ *  _size are in BYTEs
+ *  _nbw are in number of PKA_word (PKA_word = u64)
+ */
+
+#define INT8_LEN			U(8)
+#define INT64_LEN			(INT8_LEN * sizeof(uint64_t))
+#define WORD_SIZE			(sizeof(uint64_t))
+#define OP_NBW_FROM_LEN(len)		(DIV_ROUND_UP_2EVAL(len, INT64_LEN) + 1)
+#define OP_NBW_FROM_SIZE(s)		OP_NBW_FROM_LEN((s) * INT8_LEN)
+#define OP_SIZE_FROM_SIZE(s)		(OP_NBW_FROM_SIZE(s) * WORD_SIZE)
+
+#define DT_PKA_COMPAT			"st,stm32-pka64"
+
+#define MAX_ECC_SIZE_LEN		640
+#define MAX_EO_NBW			OP_NBW_FROM_LEN(MAX_ECC_SIZE_LEN)
+
+/* PKA registers */
+/* PKA control register */
+#define _PKA_CR				U(0x0)
+/* PKA status register */
+#define _PKA_SR				U(0x4)
+/* PKA clear flag register */
+#define _PKA_CLRFR			U(0x8)
+/* PKA version register */
+#define _PKA_VERR			U(0x1FF4)
+/* PKA identification register */
+#define _PKA_IPIDR			U(0x1FF8)
+
+/* PKA control register fields */
+#define _PKA_CR_MODE_MASK		GENMASK(13, 8)
+#define _PKA_CR_MODE_SHIFT		U(8)
+#define _PKA_CR_MODE_ADD		U(0x9)
+#define _PKA_CR_MODE_ECDSA_VERIF	U(0x26)
+#define _PKA_CR_START			BIT(1)
+#define _PKA_CR_EN			BIT(0)
+
+/* PKA status register fields */
+#define _PKA_SR_BUSY			BIT(16)
+#define _PKA_SR_LMF			BIT(1)
+#define _PKA_SR_INITOK			BIT(0)
+
+/* PKA it flag fields (used in CR, SR and CLRFR) */
+#define _PKA_IT_MASK			(GENMASK(21, 19) | BIT(17))
+#define _PKA_IT_SHIFT			U(17)
+#define _PKA_IT_OPERR			BIT(21)
+#define _PKA_IT_ADDRERR			BIT(20)
+#define _PKA_IT_RAMERR			BIT(19)
+#define _PKA_IT_PROCEND			BIT(17)
+
+/* PKA version register fields */
+#define _PKA_VERR_MAJREV_MASK		GENMASK(7, 4)
+#define _PKA_VERR_MAJREV_SHIFT		U(4)
+#define _PKA_VERR_MINREV_MASK		GENMASK(3, 0)
+#define _PKA_VERR_MINREV_SHIFT		U(0)
+
+/* PKA identification register value */
+#define _PKA_IDID			U(0x00170072)
+
+/* RAM magic offset */
+#define _PKA_RAM_START			U(0x400)
+#define _PKA_RAM_SIZE			U(5336)
+
+/* ECDSA verification */
+#define _PKA_RAM_N_LEN			U(0x408) /* 64 */
+#define _PKA_RAM_P_LEN			U(0x4C8) /* 64 */
+#define _PKA_RAM_A_SIGN			U(0x468) /* 64 */
+#define _PKA_RAM_A			U(0x470) /* EOS */
+#define _PKA_RAM_P			U(0x4D0) /* EOS */
+#define _PKA_RAM_XG			U(0x678) /* EOS */
+#define _PKA_RAM_YG			U(0x6D0) /* EOS */
+#define _PKA_RAM_XQ			U(0x12F8) /* EOS */
+#define _PKA_RAM_YQ			U(0x1350) /* EOS */
+#define _PKA_RAM_SIGN_R			U(0x10E0) /* EOS */
+#define _PKA_RAM_SIGN_S			U(0xC68) /* EOS */
+#define _PKA_RAM_HASH_Z			U(0x13A8) /* EOS */
+#define _PKA_RAM_PRIME_N		U(0x1088) /* EOS */
+#define _PKA_RAM_ECDSA_VERIFY		U(0x5D0) /* 64 */
+#define _PKA_RAM_ECDSA_VERIFY_VALID	ULL(0xD60D)
+#define _PKA_RAM_ECDSA_VERIFY_INVALID	ULL(0xA3B7)
+
+#define PKA_TIMEOUT_US			U(1000000)
+#define TIMEOUT_US_1MS			U(1000)
+#define PKA_RESET_DELAY			U(20)
+
+struct curve_parameters {
+	uint32_t a_sign;  /* 0 positive, 1 negative */
+	uint8_t *a;    /* Curve coefficient |a| */
+	size_t a_size;
+	uint8_t *p;    /* Curve modulus value */
+	uint32_t p_len;
+	uint8_t *xg;   /* Curve base point G coordinate x */
+	size_t xg_size;
+	uint8_t *yg;   /* Curve base point G coordinate y */
+	size_t yg_size;
+	uint8_t *n;    /* Curve prime order n */
+	uint32_t n_len;
+};
+
+static struct curve_parameters curve_def[] = {
+#if PKA_USE_NIST_P256
+	[PKA_NIST_P256] = {
+		.p_len = 256U,
+		.n_len = 256U,
+		.p  = (uint8_t[]){0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
+				  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
+				  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
+		.n  = (uint8_t[]){0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+				  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+				  0xBC, 0xE6, 0xFA, 0xAD, 0xA7, 0x17, 0x9E, 0x84,
+				  0xF3, 0xB9, 0xCA, 0xC2, 0xFC, 0x63, 0x25, 0x51},
+		.a_sign = 1U,
+		.a = (uint8_t[]){0x03},
+		.a_size = 1U,
+		.xg = (uint8_t[]){0x6B, 0x17, 0xD1, 0xF2, 0xE1, 0x2C, 0x42, 0x47,
+				  0xF8, 0xBC, 0xE6, 0xE5, 0x63, 0xA4, 0x40, 0xF2,
+				  0x77, 0x03, 0x7D, 0x81, 0x2D, 0xEB, 0x33, 0xA0,
+				  0xF4, 0xA1, 0x39, 0x45, 0xD8, 0x98, 0xC2, 0x96},
+		.xg_size = 32U,
+		.yg = (uint8_t[]){0x4F, 0xE3, 0x42, 0xE2, 0xFE, 0x1A, 0x7F, 0x9B,
+				  0x8E, 0xE7, 0xEB, 0x4A, 0x7C, 0x0F, 0x9E, 0x16,
+				  0x2B, 0xCE, 0x33, 0x57, 0x6B, 0x31, 0x5E, 0xCE,
+				  0xCB, 0xB6, 0x40, 0x68, 0x37, 0xBF, 0x51, 0xF5},
+		.yg_size = 32U,
+	},
+#endif
+#if PKA_USE_BRAINPOOL_P256R1
+	[PKA_BRAINPOOL_P256R1] = {
+		.p_len = 256,
+		.n_len = 256,
+		.p  = (uint8_t[]){0xA9, 0xFB, 0x57, 0xDB, 0xA1, 0xEE, 0xA9, 0xBC,
+				  0x3E, 0x66, 0x0A, 0x90, 0x9D, 0x83, 0x8D, 0x72,
+				  0x6E, 0x3B, 0xF6, 0x23, 0xD5, 0x26, 0x20, 0x28,
+				  0x20, 0x13, 0x48, 0x1D, 0x1F, 0x6E, 0x53, 0x77},
+		.n  = (uint8_t[]){0xA9, 0xFB, 0x57, 0xDB, 0xA1, 0xEE, 0xA9, 0xBC,
+				  0x3E, 0x66, 0x0A, 0x90, 0x9D, 0x83, 0x8D, 0x71,
+				  0x8C, 0x39, 0x7A, 0xA3, 0xB5, 0x61, 0xA6, 0xF7,
+				  0x90, 0x1E, 0x0E, 0x82, 0x97, 0x48, 0x56, 0xA7},
+		.a  = (uint8_t[]){0x7D, 0x5A, 0x09, 0x75, 0xFC, 0x2C, 0x30, 0x57,
+				  0xEE, 0xF6, 0x75, 0x30, 0x41, 0x7A, 0xFF, 0xE7,
+				  0xFB, 0x80, 0x55, 0xC1, 0x26, 0xDC, 0x5C, 0x6C,
+				  0xE9, 0x4A, 0x4B, 0x44, 0xF3, 0x30, 0xB5, 0xD9},
+		.a_size = 32U,
+		.xg = (uint8_t[]){0x8B, 0xD2, 0xAE, 0xB9, 0xCB, 0x7E, 0x57, 0xCB,
+				  0x2C, 0x4B, 0x48, 0x2F, 0xFC, 0x81, 0xB7, 0xAF,
+				  0xB9, 0xDE, 0x27, 0xE1, 0xE3, 0xBD, 0x23, 0xC2,
+				  0x3A, 0x44, 0x53, 0xBD, 0x9A, 0xCE, 0x32, 0x62},
+		.xg_size = 32U,
+		.yg = (uint8_t[]){0x54, 0x7E, 0xF8, 0x35, 0xC3, 0xDA, 0xC4, 0xFD,
+				  0x97, 0xF8, 0x46, 0x1A, 0x14, 0x61, 0x1D, 0xC9,
+				  0xC2, 0x77, 0x45, 0x13, 0x2D, 0xED, 0x8E, 0x54,
+				  0x5C, 0x1D, 0x54, 0xC7, 0x2F, 0x04, 0x69, 0x97},
+		.yg_size = 32U,
+	},
+#endif
+#if PKA_USE_BRAINPOOL_P256T1
+	[PKA_BRAINPOOL_P256T1] = {
+		.p_len = 256,
+		.n_len = 256,
+		.p  = (uint8_t[]){0xA9, 0xFB, 0x57, 0xDB, 0xA1, 0xEE, 0xA9, 0xBC,
+				  0x3E, 0x66, 0x0A, 0x90, 0x9D, 0x83, 0x8D, 0x72,
+				  0x6E, 0x3B, 0xF6, 0x23, 0xD5, 0x26, 0x20, 0x28,
+				  0x20, 0x13, 0x48, 0x1D, 0x1F, 0x6E, 0x53, 0x77},
+		.n  = (uint8_t[]){0xA9, 0xFB, 0x57, 0xDB, 0xA1, 0xEE, 0xA9, 0xBC,
+				  0x3E, 0x66, 0x0A, 0x90, 0x9D, 0x83, 0x8D, 0x71,
+				  0x8C, 0x39, 0x7A, 0xA3, 0xB5, 0x61, 0xA6, 0xF7,
+				  0x90, 0x1E, 0x0E, 0x82, 0x97, 0x48, 0x56, 0xA7},
+		.a  = (uint8_t[]){0xA9, 0xFB, 0x57, 0xDB, 0xA1, 0xEE, 0xA9, 0xBC,
+				  0x3E, 0x66, 0x0A, 0x90, 0x9D, 0x83, 0x8D, 0x72,
+				  0x6E, 0x3B, 0xF6, 0x23, 0xD5, 0x26, 0x20, 0x28,
+				  0x20, 0x13, 0x48, 0x1D, 0x1F, 0x6E, 0x53, 0x74},
+		.a_size = 32U,
+		.xg = (uint8_t[]){0xA3, 0xE8, 0xEB, 0x3C, 0xC1, 0xCF, 0xE7, 0xB7,
+				  0x73, 0x22, 0x13, 0xB2, 0x3A, 0x65, 0x61, 0x49,
+				  0xAF, 0xA1, 0x42, 0xC4, 0x7A, 0xAF, 0xBC, 0x2B,
+				  0x79, 0xA1, 0x91, 0x56, 0x2E, 0x13, 0x05, 0xF4},
+		.xg_size = 32U,
+		.yg = (uint8_t[]){0x2D, 0x99, 0x6C, 0x82, 0x34, 0x39, 0xC5, 0x6D,
+				  0x7F, 0x7B, 0x22, 0xE1, 0x46, 0x44, 0x41, 0x7E,
+				  0x69, 0xBC, 0xB6, 0xDE, 0x39, 0xD0, 0x27, 0x00,
+				  0x1D, 0xAB, 0xE8, 0xF3, 0x5B, 0x25, 0xC9, 0xBE},
+		.yg_size = 32U,
+	},
+#endif
+#if PKA_USE_NIST_P521
+	[PKA_NIST_P521] = {
+		.p_len = 521,
+		.n_len = 521,
+		.p  = (uint8_t[]){                                    0x01, 0xff,
+				  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+				  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+				  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+				  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+				  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+				  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+				  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+				  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
+		.n  = (uint8_t[]){                                    0x01, 0xff,
+				  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+				  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+				  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+				  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa,
+				  0x51, 0x86, 0x87, 0x83, 0xbf, 0x2f, 0x96, 0x6b,
+				  0x7f, 0xcc, 0x01, 0x48, 0xf7, 0x09, 0xa5, 0xd0,
+				  0x3b, 0xb5, 0xc9, 0xb8, 0x89, 0x9c, 0x47, 0xae,
+				  0xbb, 0x6f, 0xb7, 0x1e, 0x91, 0x38, 0x64, 0x09},
+		.a_sign = 1,
+		.a  = (uint8_t[]){0x03},
+		.a_size = 1U,
+		.xg = (uint8_t[]){                                          0xc6,
+				  0x85, 0x8e, 0x06, 0xb7, 0x04, 0x04, 0xe9, 0xcd,
+				  0x9e, 0x3e, 0xcb, 0x66, 0x23, 0x95, 0xb4, 0x42,
+				  0x9c, 0x64, 0x81, 0x39, 0x05, 0x3f, 0xb5, 0x21,
+				  0xf8, 0x28, 0xaf, 0x60, 0x6b, 0x4d, 0x3d, 0xba,
+				  0xa1, 0x4b, 0x5e, 0x77, 0xef, 0xe7, 0x59, 0x28,
+				  0xfe, 0x1d, 0xc1, 0x27, 0xa2, 0xff, 0xa8, 0xde,
+				  0x33, 0x48, 0xb3, 0xc1, 0x85, 0x6a, 0x42, 0x9b,
+				  0xf9, 0x7e, 0x7e, 0x31, 0xc2, 0xe5, 0xbd, 0x66},
+		.xg_size = 65U,
+		.yg = (uint8_t[]){                                    0x01, 0x18,
+				  0x39, 0x29, 0x6a, 0x78, 0x9a, 0x3b, 0xc0, 0x04,
+				  0x5c, 0x8a, 0x5f, 0xb4, 0x2c, 0x7d, 0x1b, 0xd9,
+				  0x98, 0xf5, 0x44, 0x49, 0x57, 0x9b, 0x44, 0x68,
+				  0x17, 0xaf, 0xbd, 0x17, 0x27, 0x3e, 0x66, 0x2c,
+				  0x97, 0xee, 0x72, 0x99, 0x5e, 0xf4, 0x26, 0x40,
+				  0xc5, 0x50, 0xb9, 0x01, 0x3f, 0xad, 0x07, 0x61,
+				  0x35, 0x3c, 0x70, 0x86, 0xa2, 0x72, 0xc2, 0x40,
+				  0x88, 0xbe, 0x94, 0x76, 0x9f, 0xd1, 0x66, 0x50},
+		.yg_size = 66U,
+	},
+#endif
+};
+
+static struct stm32_pka_platdata pka_pdata;
+
+__attribute__((weak))
+int stm32_pka_get_platdata(struct stm32_pka_platdata *pdata)
+{
+	return -ENODEV;
+}
+
+static int stm32_pka_parse_fdt(void)
+{
+	int node;
+	struct dt_node_info info;
+	void *fdt;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	node = dt_get_node(&info, -1, DT_PKA_COMPAT);
+	if (node < 0) {
+		ERROR("No PKA entry in DT\n");
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	if (info.status == DT_DISABLED) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	if ((info.base == 0) || (info.clock < 0) || (info.reset < 0)) {
+		return -FDT_ERR_BADVALUE;
+	}
+
+	pka_pdata.base = (uintptr_t)info.base;
+	pka_pdata.clock_id = (unsigned long)info.clock;
+	pka_pdata.reset_id = (unsigned int)info.reset;
+
+	return 0;
+}
+
+static int pka_wait_bit(uintptr_t base, uint32_t bit)
+{
+	uint64_t timeout = timeout_init_us(PKA_TIMEOUT_US);
+
+	while ((mmio_read_32(base + _PKA_SR) & bit) != bit) {
+		if (timeout_elapsed(timeout)) {
+			WARN("timeout waiting %x\n", bit);
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+
+}
+
+static void pka_disable(uintptr_t base)
+{
+	mmio_clrbits_32(base + _PKA_CR, _PKA_CR_EN);
+}
+
+static int pka_enable(uintptr_t base, uint32_t mode)
+{
+	/* set mode and disable interrupts */
+	mmio_clrsetbits_32(base + _PKA_CR, _PKA_IT_MASK | _PKA_CR_MODE_MASK,
+			   _PKA_CR_MODE_MASK & (mode << _PKA_CR_MODE_SHIFT));
+
+	mmio_setbits_32(base + _PKA_CR, _PKA_CR_EN);
+
+	return pka_wait_bit(base, _PKA_SR_INITOK);
+}
+
+/*
+ * Data are already loaded in PKA internal RAM
+ * MODE is set
+ * we start process, and wait for its end.
+ */
+static int stm32_pka_process(uintptr_t base)
+{
+	mmio_setbits_32(base + _PKA_CR, _PKA_CR_START);
+
+	return pka_wait_bit(base, _PKA_IT_PROCEND);
+}
+
+/**
+ * @brief  Write ECC operand to PKA RAM.
+ * @note  PKA expect to write u64 word, each u64 are: the least significant bit is
+ *        bit 0; the most significant bit is bit 63.
+ *        We write eo_nbw (ECC operand Size) u64, value that depends of the chosen
+ *        prime modulus length in bits.
+ *        First less signicant u64 is written to low address
+ *        Most significant u64 to higher address.
+ *        And at last address we write a u64(0x0)
+ * @note This function doesn't only manage endianness (as bswap64 do), but also
+ *       complete most significant incomplete u64 with 0 (if data is not a u64
+ *       multiple), and fill u64 last address with 0.
+ * @param addr: PKA_RAM address to write the buffer 'data'
+ * @param data: is a BYTE list with most significant bytes first
+ * @param data_size: nb of byte in data
+ * @param eo_nbw: is ECC Operand size in 64bits word (including the extra 0)
+ *                (note it depends of the prime modulus length, not the data size)
+ * @retval 0 if OK.
+ *         -EINVAL if data_size and eo_nbw are inconsistent, ie data doesn't
+ *         fit in defined eo_nbw, or eo_nbw bigger than hardware limit.
+ */
+static int write_eo_data(uintptr_t addr, uint8_t *data, unsigned int data_size,
+			 unsigned int eo_nbw)
+{
+	uint32_t word_index;
+	int data_index;
+
+	if ((eo_nbw < OP_NBW_FROM_SIZE(data_size)) || (eo_nbw > MAX_EO_NBW)) {
+		return -EINVAL;
+	}
+
+	/* fill value */
+	data_index = (int)data_size - 1;
+	for (word_index = 0U; word_index < eo_nbw; word_index++) {
+		uint64_t tmp = 0ULL;
+		unsigned int i = 0U;  /* index in the tmp U64 word */
+
+		/* Stop if end of tmp or end of data */
+		while ((i < sizeof(tmp)) && (data_index >= 0)) {
+			tmp |= (uint64_t)(data[data_index]) << (INT8_LEN * i);
+			i++; /* Move byte index in current (u64)tmp */
+			data_index--; /* Move to just next most significat byte */
+		}
+
+		mmio_write_64(addr + word_index * sizeof(tmp), tmp);
+	}
+
+	return 0;
+}
+
+static unsigned int get_ecc_op_nbword(enum stm32_pka_ecdsa_curve_id cid)
+{
+	return OP_NBW_FROM_LEN(curve_def[cid].n_len);
+}
+
+static int stm32_pka_ecdsa_verif_configure_curve(uintptr_t base, enum stm32_pka_ecdsa_curve_id cid)
+{
+	int ret;
+	unsigned int eo_nbw = get_ecc_op_nbword(cid);
+
+	mmio_write_64(base + _PKA_RAM_N_LEN, curve_def[cid].n_len);
+	mmio_write_64(base + _PKA_RAM_P_LEN, curve_def[cid].p_len);
+	mmio_write_64(base + _PKA_RAM_A_SIGN, curve_def[cid].a_sign);
+
+	ret = write_eo_data(base + _PKA_RAM_A, curve_def[cid].a, curve_def[cid].a_size, eo_nbw);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = write_eo_data(base + _PKA_RAM_PRIME_N,
+			    curve_def[cid].n, div_round_up(curve_def[cid].n_len, INT8_LEN),
+			    eo_nbw);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = write_eo_data(base + _PKA_RAM_P, curve_def[cid].p,
+			    div_round_up(curve_def[cid].p_len, INT8_LEN), eo_nbw);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = write_eo_data(base + _PKA_RAM_XG, curve_def[cid].xg, curve_def[cid].xg_size, eo_nbw);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = write_eo_data(base + _PKA_RAM_YG, curve_def[cid].yg, curve_def[cid].yg_size, eo_nbw);
+	if (ret < 0) {
+		return ret;
+	}
+
+	return 0;
+}
+
+static int stm32_pka_ecdsa_verif_check_return(uintptr_t base)
+{
+	uint64_t value;
+	uint32_t sr;
+
+	sr = mmio_read_32(base + _PKA_SR);
+	if ((sr & (_PKA_IT_OPERR | _PKA_IT_ADDRERR | _PKA_IT_RAMERR)) != 0) {
+		WARN("Detected error(s): %s%s%s\n",
+		     (sr & _PKA_IT_OPERR) ? "Operation " : "",
+		     (sr & _PKA_IT_ADDRERR) ? "Address " : "",
+		     (sr & _PKA_IT_RAMERR) ? "RAM" : "");
+		return -EINVAL;
+	}
+
+	value = mmio_read_64(base + _PKA_RAM_ECDSA_VERIFY);
+	if (value == _PKA_RAM_ECDSA_VERIFY_VALID) {
+		return 0;
+	}
+
+	if (value == _PKA_RAM_ECDSA_VERIFY_INVALID) {
+		return -EAUTH;
+	}
+
+	return -EINVAL;
+}
+
+/**
+ * @brief Check if BigInt stored in data is 0
+ *
+ * @param data: a BYTE array with most significant bytes first
+ * @param size: data size
+ *
+ * @retval: true: if data represents a 0 value (ie all bytes == 0)
+ *          false: if data represents a non-zero value.
+ */
+static bool is_zero(uint8_t *data, unsigned int size)
+{
+	unsigned int i;
+
+	for (i = 0U; i < size; i++) {
+		if (data[i] != 0U) {
+			return false;
+		}
+	}
+
+	return true;
+}
+
+/**
+ * @brief Compare two BigInt:
+ * @param xdata_a: a BYTE array with most significant bytes first
+ * @param size_a: nb of Byte of 'a'
+ * @param data_b: a BYTE array with most significant bytes first
+ * @param size_b: nb of Byte of 'b'
+ *
+ * @retval: true if data_a < data_b
+ *          false if data_a >= data_b
+ */
+static bool is_smaller(uint8_t *data_a, unsigned int size_a,
+		       uint8_t *data_b, unsigned int size_b)
+{
+	unsigned int i;
+
+	i = MAX(size_a, size_b) + 1;
+	do {
+		uint8_t a, b;
+
+		i--;
+		if (size_a < i) {
+			a = 0U;
+		} else {
+			a = data_a[size_a - i];
+		}
+
+		if (size_b < i) {
+			b = 0U;
+		} else {
+			b = data_b[size_b - i];
+		}
+
+		if (a < b) {
+			return true;
+		}
+
+		if (a > b) {
+			return false;
+		}
+	} while (i != 0U);
+
+	return false;
+}
+
+static int stm32_pka_ecdsa_check_param(void *sig_r_ptr, unsigned int sig_r_size,
+				       void *sig_s_ptr, unsigned int sig_s_size,
+				       void *pk_x_ptr, unsigned int pk_x_size,
+				       void *pk_y_ptr, unsigned int pk_y_size,
+				       enum stm32_pka_ecdsa_curve_id cid)
+{
+	/* Public Key check */
+	/* Check Xq < p */
+	if (!is_smaller(pk_x_ptr, pk_x_size,
+			curve_def[cid].p, div_round_up(curve_def[cid].p_len, INT8_LEN))) {
+		WARN("%s Xq < p inval\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Check Yq < p */
+	if (!is_smaller(pk_y_ptr, pk_y_size,
+			curve_def[cid].p, div_round_up(curve_def[cid].p_len, INT8_LEN))) {
+		WARN("%s Yq < p inval\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Signature check */
+	/* Check 0 < r < n */
+	if (!is_smaller(sig_r_ptr, sig_r_size,
+			curve_def[cid].n, div_round_up(curve_def[cid].n_len, INT8_LEN)) &&
+	    !is_zero(sig_r_ptr, sig_r_size)) {
+		WARN("%s 0< r < n inval\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Check 0 < s < n */
+	if (!is_smaller(sig_s_ptr, sig_s_size,
+			curve_def[cid].n, div_round_up(curve_def[cid].n_len, INT8_LEN)) &&
+	    !is_zero(sig_s_ptr, sig_s_size)) {
+		WARN("%s 0< s < n inval\n", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * @brief  Initialize the PKA driver.
+ * @param  None.
+ * @retval 0 if OK, negative value else.
+ */
+int stm32_pka_init(void)
+{
+	int err;
+#if LOG_LEVEL >= LOG_LEVEL_VERBOSE
+	uint32_t ver;
+	uint32_t id;
+#endif
+
+	err = stm32_pka_parse_fdt();
+	if (err != 0) {
+		err = stm32_pka_get_platdata(&pka_pdata);
+		if (err != 0) {
+			return err;
+		}
+	}
+
+	clk_enable(pka_pdata.clock_id);
+
+	if (stm32mp_reset_assert((unsigned long)pka_pdata.reset_id, TIMEOUT_US_1MS) != 0) {
+		panic();
+	}
+
+	udelay(PKA_RESET_DELAY);
+	if (stm32mp_reset_deassert((unsigned long)pka_pdata.reset_id, TIMEOUT_US_1MS) != 0) {
+		panic();
+	}
+
+#if LOG_LEVEL >= LOG_LEVEL_VERBOSE
+	id = mmio_read_32(pka_pdata.base + _PKA_IPIDR);
+	ver = mmio_read_32(pka_pdata.base + _PKA_VERR);
+
+	VERBOSE("STM32 PKA[%x] V%u.%u\n", id,
+		(ver & _PKA_VERR_MAJREV_MASK) >> _PKA_VERR_MAJREV_SHIFT,
+		(ver & _PKA_VERR_MINREV_MASK) >> _PKA_VERR_MINREV_SHIFT);
+#endif
+	return 0;
+}
+
+int stm32_pka_ecdsa_verif(void *hash, unsigned int hash_size,
+			  void *sig_r_ptr, unsigned int sig_r_size,
+			  void *sig_s_ptr, unsigned int sig_s_size,
+			  void *pk_x_ptr, unsigned int pk_x_size,
+			  void *pk_y_ptr, unsigned int pk_y_size,
+			  enum stm32_pka_ecdsa_curve_id cid)
+{
+	int ret;
+	uintptr_t base = pka_pdata.base;
+	unsigned int eo_nbw = get_ecc_op_nbword(cid);
+
+	if ((hash == NULL) || (sig_r_ptr == NULL) || (sig_s_ptr == NULL) ||
+	    (pk_x_ptr == NULL) || (pk_y_ptr == NULL)) {
+		INFO("%s invalid input param\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = stm32_pka_ecdsa_check_param(sig_r_ptr, sig_r_size,
+					  sig_s_ptr, sig_s_size,
+					  pk_x_ptr, pk_x_size,
+					  pk_y_ptr, pk_y_size,
+					  cid);
+	if (ret < 0) {
+		INFO("%s check param error %d\n", __func__, ret);
+		goto out;
+	}
+
+	if ((mmio_read_32(base + _PKA_SR) & _PKA_SR_BUSY) == _PKA_SR_BUSY) {
+		INFO("%s busy\n", __func__);
+		ret = -EBUSY;
+		goto out;
+	}
+
+	/* Fill PKA RAM */
+	/*    With curve id values */
+	ret = stm32_pka_ecdsa_verif_configure_curve(base, cid);
+	if (ret < 0) {
+		goto out;
+	}
+
+	/*    With pubkey */
+	ret = write_eo_data(base + _PKA_RAM_XQ, pk_x_ptr, pk_x_size, eo_nbw);
+	if (ret < 0) {
+		goto out;
+	}
+
+	ret = write_eo_data(base + _PKA_RAM_YQ, pk_y_ptr, pk_y_size, eo_nbw);
+	if (ret < 0) {
+		goto out;
+	}
+
+	/*    With hash */
+	ret = write_eo_data(base + _PKA_RAM_HASH_Z, hash, hash_size, eo_nbw);
+	if (ret < 0) {
+		goto out;
+	}
+
+	/*    With signature */
+	ret = write_eo_data(base + _PKA_RAM_SIGN_R, sig_r_ptr, sig_r_size, eo_nbw);
+	if (ret < 0) {
+		goto out;
+	}
+
+	ret = write_eo_data(base + _PKA_RAM_SIGN_S, sig_s_ptr, sig_s_size, eo_nbw);
+	if (ret < 0) {
+		goto out;
+	}
+
+	/* Set mode to ecdsa signature verification */
+	ret = pka_enable(base, _PKA_CR_MODE_ECDSA_VERIF);
+	if (ret < 0) {
+		WARN("%s set mode pka error %d\n", __func__, ret);
+		goto out;
+	}
+
+	/* Start processing and wait end */
+	ret = stm32_pka_process(base);
+	if (ret < 0) {
+		WARN("%s process error %d\n", __func__, ret);
+		goto out;
+	}
+
+	/* Check return status */
+	ret = stm32_pka_ecdsa_verif_check_return(base);
+
+	/* Unset end proc */
+	mmio_setbits_32(base + _PKA_CLRFR, _PKA_IT_PROCEND);
+
+out:
+	/* Disable PKA (will stop all pending proccess and reset RAM) */
+	pka_disable(base);
+
+	return ret;
+}
diff --git a/drivers/st/crypto/stm32_saes.c b/drivers/st/crypto/stm32_saes.c
new file mode 100644
index 000000000..13358eeda
--- /dev/null
+++ b/drivers/st/crypto/stm32_saes.c
@@ -0,0 +1,1074 @@
+/*
+ * Copyright (c) 2020-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#include <assert.h>
+#include <endian.h>
+#include <errno.h>
+#include <stdint.h>
+
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32_saes.h>
+#include <drivers/st/stm32mp_reset.h>
+#include <libfdt.h>
+#include <lib/mmio.h>
+#include <lib/utils_def.h>
+
+#include <platform_def.h>
+
+#define INT8_BIT			U(8)
+#define AES_BLOCK_SIZE_BIT		128U
+#define AES_BLOCK_SIZE			(AES_BLOCK_SIZE_BIT / INT8_BIT)
+
+#define AES_KEYSIZE_128			16U
+#define AES_KEYSIZE_256			32U
+#define AES_IVSIZE			16U
+
+/* SAES control register */
+#define _SAES_CR			0x0U
+/* SAES status register */
+#define _SAES_SR			0x04U
+/* SAES data input register */
+#define _SAES_DINR			0x08U
+/* SAES data output register */
+#define _SAES_DOUTR			0x0CU
+/* SAES key registers [0-3] */
+#define _SAES_KEYR0			0x10U
+#define _SAES_KEYR1			0x14U
+#define _SAES_KEYR2			0x18U
+#define _SAES_KEYR3			0x1CU
+/* SAES initialization vector registers [0-3] */
+#define _SAES_IVR0			0x20U
+#define _SAES_IVR1			0x24U
+#define _SAES_IVR2			0x28U
+#define _SAES_IVR3			0x2CU
+/* SAES key registers [4-7] */
+#define _SAES_KEYR4			0x30U
+#define _SAES_KEYR5			0x34U
+#define _SAES_KEYR6			0x38U
+#define _SAES_KEYR7			0x3CU
+/* SAES suspend registers [0-7] */
+#define _SAES_SUSPR0			0x40U
+#define _SAES_SUSPR1			0x44U
+#define _SAES_SUSPR2			0x48U
+#define _SAES_SUSPR3			0x4CU
+#define _SAES_SUSPR4			0x50U
+#define _SAES_SUSPR5			0x54U
+#define _SAES_SUSPR6			0x58U
+#define _SAES_SUSPR7			0x5CU
+/* SAES Interrupt Enable Register */
+#define _SAES_IER			0x300U
+/* SAES Interrupt Status Register */
+#define _SAES_ISR			0x304U
+/* SAES Interrupt Clear Register */
+#define _SAES_ICR			0x308U
+
+/* SAES control register fields */
+#define _SAES_CR_RESET_VALUE		0x0U
+#define _SAES_CR_IPRST			BIT(31)
+#define _SAES_CR_KEYSEL_MASK		GENMASK(30, 28)
+#define _SAES_CR_KEYSEL_SHIFT		28U
+#define _SAES_CR_KEYSEL_SOFT		0x0U
+#define _SAES_CR_KEYSEL_DHUK		0x1U
+#define _SAES_CR_KEYSEL_BHK		0x2U
+#define _SAES_CR_KEYSEL_BHU_XOR_BH_K	0x4U
+#define _SAES_CR_KEYSEL_TEST		0x7U
+#define _SAES_CR_KSHAREID_MASK		GENMASK(27, 26)
+#define _SAES_CR_KSHAREID_SHIFT		26U
+#define _SAES_CR_KSHAREID_CRYP		0x0U
+#define _SAES_CR_KEYMOD_MASK		GENMASK(25, 24)
+#define _SAES_CR_KEYMOD_SHIFT		24U
+#define _SAES_CR_KEYMOD_NORMAL		0x0U
+#define _SAES_CR_KEYMOD_WRAPPED		0x1U
+#define _SAES_CR_KEYMOD_SHARED		0x2U
+#define _SAES_CR_NPBLB_MASK		GENMASK(23, 20)
+#define _SAES_CR_NPBLB_SHIFT		20U
+#define _SAES_CR_KEYPROT		BIT(19)
+#define _SAES_CR_KEYSIZE		BIT(18)
+#define _SAES_CR_GCMPH_MASK		GENMASK(14, 13)
+#define _SAES_CR_GCMPH_SHIFT		13U
+#define _SAES_CR_GCMPH_INIT		0U
+#define _SAES_CR_GCMPH_HEADER		1U
+#define _SAES_CR_GCMPH_PAYLOAD		2U
+#define _SAES_CR_GCMPH_FINAL		3U
+#define _SAES_CR_DMAOUTEN		BIT(12)
+#define _SAES_CR_DMAINEN		BIT(11)
+#define _SAES_CR_CHMOD_MASK		(BIT(16) | GENMASK(6, 5))
+#define _SAES_CR_CHMOD_SHIFT		5U
+#define _SAES_CR_CHMOD_ECB		0x0U
+#define _SAES_CR_CHMOD_CBC		0x1U
+#define _SAES_CR_CHMOD_CTR		0x2U
+#define _SAES_CR_CHMOD_GCM		0x3U
+#define _SAES_CR_CHMOD_GMAC		0x3U
+#define _SAES_CR_CHMOD_CCM		0x800U
+#define _SAES_CR_MODE_MASK		GENMASK(4, 3)
+#define _SAES_CR_MODE_SHIFT		3U
+#define _SAES_CR_MODE_ENC		0U
+#define _SAES_CR_MODE_KEYPREP		1U
+#define _SAES_CR_MODE_DEC		2U
+#define _SAES_CR_DATATYPE_MASK		GENMASK(2, 1)
+#define _SAES_CR_DATATYPE_SHIFT		1U
+#define _SAES_CR_DATATYPE_NONE		0U
+#define _SAES_CR_DATATYPE_HALF_WORD	1U
+#define _SAES_CR_DATATYPE_BYTE		2U
+#define _SAES_CR_DATATYPE_BIT		3U
+#define _SAES_CR_EN			BIT(0)
+
+/* SAES status register fields */
+#define _SAES_SR_KEYVALID		BIT(7)
+#define _SAES_SR_BUSY			BIT(3)
+#define _SAES_SR_WRERR			BIT(2)
+#define _SAES_SR_RDERR			BIT(1)
+#define _SAES_SR_CCF			BIT(0)
+
+/* SAES interrupt registers fields */
+#define _SAES_I_RNG_ERR			BIT(3)
+#define _SAES_I_KEY_ERR			BIT(2)
+#define _SAES_I_RW_ERR			BIT(1)
+#define _SAES_I_CC			BIT(0)
+
+#define SAES_TIMEOUT_US			100000U
+#define TIMEOUT_US_1MS			1000U
+#define SAES_RESET_DELAY		U(20)
+
+#define IS_CHAINING_MODE(mod, cr) \
+	(((cr) & _SAES_CR_CHMOD_MASK) == (_SAES_CR_CHMOD_##mod << _SAES_CR_CHMOD_SHIFT))
+
+#define SET_CHAINING_MODE(mod, cr) \
+	mmio_clrsetbits_32((cr), _SAES_CR_CHMOD_MASK, _SAES_CR_CHMOD_##mod << _SAES_CR_CHMOD_SHIFT)
+
+static struct stm32_saes_platdata saes_pdata;
+
+__attribute__((weak))
+int stm32_saes_get_platdata(struct stm32_saes_platdata *pdata)
+{
+	return -ENODEV;
+}
+
+static int stm32_saes_parse_fdt(struct stm32_saes_platdata *pdata)
+{
+	int node;
+	struct dt_node_info info;
+	void *fdt;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	node = dt_get_node(&info, -1, DT_SAES_COMPAT);
+	if (node < 0) {
+		ERROR("No SAES entry in DT\n");
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	if (info.status == DT_DISABLED) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	if ((info.base == 0U) || (info.clock < 0) || (info.reset < 0)) {
+		return -FDT_ERR_BADVALUE;
+	}
+
+	pdata->base = (uintptr_t)info.base;
+	pdata->clock_id = (unsigned long)info.clock;
+	pdata->reset_id = (unsigned int)info.reset;
+
+	return 0;
+}
+
+static bool does_chaining_mode_need_iv(uint32_t cr)
+{
+	return !(IS_CHAINING_MODE(ECB, cr));
+}
+
+static bool is_encrypt(uint32_t cr)
+{
+	return (cr & _SAES_CR_MODE_MASK) == (_SAES_CR_MODE_ENC << _SAES_CR_MODE_SHIFT);
+}
+
+static bool is_decrypt(uint32_t cr)
+{
+	return (cr & _SAES_CR_MODE_MASK) == (_SAES_CR_MODE_DEC << _SAES_CR_MODE_SHIFT);
+}
+
+static int wait_computation_completed(uintptr_t base)
+{
+	uint64_t timeout = timeout_init_us(SAES_TIMEOUT_US);
+
+	while ((mmio_read_32(base + _SAES_SR) & _SAES_SR_CCF) != _SAES_SR_CCF) {
+		if (timeout_elapsed(timeout)) {
+			WARN("%s: timeout\n", __func__);
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static void clear_computation_completed(uintptr_t base)
+{
+	mmio_setbits_32(base + _SAES_ICR, _SAES_I_CC);
+}
+
+static int saes_start(struct stm32_saes_context *ctx)
+{
+	uint64_t timeout;
+
+	/* Reset IP */
+	mmio_setbits_32(ctx->base + _SAES_CR, _SAES_CR_IPRST);
+	udelay(SAES_RESET_DELAY);
+	mmio_clrbits_32(ctx->base + _SAES_CR, _SAES_CR_IPRST);
+
+	timeout = timeout_init_us(SAES_TIMEOUT_US);
+	while ((mmio_read_32(ctx->base + _SAES_SR) & _SAES_SR_BUSY) == _SAES_SR_BUSY) {
+		if (timeout_elapsed(timeout)) {
+			WARN("%s: timeout\n", __func__);
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static void saes_end(struct stm32_saes_context *ctx, int prev_error)
+{
+	if (prev_error != 0) {
+		/* Reset IP */
+		mmio_setbits_32(ctx->base + _SAES_CR, _SAES_CR_IPRST);
+		udelay(SAES_RESET_DELAY);
+		mmio_clrbits_32(ctx->base + _SAES_CR, _SAES_CR_IPRST);
+	}
+
+	/* Disable the SAES peripheral */
+	mmio_clrbits_32(ctx->base + _SAES_CR, _SAES_CR_EN);
+}
+
+static void saes_write_iv(struct stm32_saes_context *ctx)
+{
+	/* If chaining mode need to restore IV */
+	if (does_chaining_mode_need_iv(ctx->cr)) {
+		uint8_t i;
+
+		/* Restore the _SAES_IVRx */
+		for (i = 0U; i < AES_IVSIZE / sizeof(uint32_t); i++) {
+			mmio_write_32(ctx->base + _SAES_IVR0 + i * sizeof(uint32_t), ctx->iv[i]);
+		}
+	}
+
+}
+
+static void saes_write_key(struct stm32_saes_context *ctx)
+{
+	/* Restore the _SAES_KEYRx if SOFTWARE key */
+	if ((ctx->cr & _SAES_CR_KEYSEL_MASK) == (_SAES_CR_KEYSEL_SOFT << _SAES_CR_KEYSEL_SHIFT)) {
+		uint8_t i;
+
+		for (i = 0U; i < AES_KEYSIZE_128 / sizeof(uint32_t); i++) {
+			mmio_write_32(ctx->base + _SAES_KEYR0 + i * sizeof(uint32_t), ctx->key[i]);
+		}
+
+		if ((ctx->cr & _SAES_CR_KEYSIZE) == _SAES_CR_KEYSIZE) {
+			for (i = 0U; i < (AES_KEYSIZE_256 / 2U) / sizeof(uint32_t); i++) {
+				mmio_write_32(ctx->base + _SAES_KEYR4 + i * sizeof(uint32_t),
+					      ctx->key[i + 4U]);
+			}
+		}
+	}
+}
+
+static int saes_prepare_key(struct stm32_saes_context *ctx)
+{
+	/* Disable the SAES peripheral */
+	mmio_clrbits_32(ctx->base + _SAES_CR, _SAES_CR_EN);
+
+	/* Set key size */
+	if ((ctx->cr & _SAES_CR_KEYSIZE) != 0U) {
+		mmio_setbits_32(ctx->base + _SAES_CR, _SAES_CR_KEYSIZE);
+	} else {
+		mmio_clrbits_32(ctx->base + _SAES_CR, _SAES_CR_KEYSIZE);
+	}
+
+	saes_write_key(ctx);
+
+	/* For ECB/CBC decryption, key preparation mode must be selected to populate the key */
+	if ((IS_CHAINING_MODE(ECB, ctx->cr) || IS_CHAINING_MODE(CBC, ctx->cr)) &&
+	    is_decrypt(ctx->cr)) {
+		int ret;
+
+		/* Select Mode 2 */
+		mmio_clrsetbits_32(ctx->base + _SAES_CR, _SAES_CR_MODE_MASK,
+				   _SAES_CR_MODE_KEYPREP << _SAES_CR_MODE_SHIFT);
+
+		/* Enable SAES */
+		mmio_setbits_32(ctx->base + _SAES_CR, _SAES_CR_EN);
+
+		/* Wait Computation completed */
+		ret = wait_computation_completed(ctx->base);
+		if (ret != 0) {
+			return ret;
+		}
+
+		clear_computation_completed(ctx->base);
+
+		/* Set Mode 3 */
+		mmio_clrsetbits_32(ctx->base + _SAES_CR, _SAES_CR_MODE_MASK,
+				   _SAES_CR_MODE_DEC << _SAES_CR_MODE_SHIFT);
+	}
+
+	return 0;
+}
+
+static int save_context(struct stm32_saes_context *ctx)
+{
+	if ((mmio_read_32(ctx->base + _SAES_SR) & _SAES_SR_CCF) != 0U) {
+		/* Device should not be in a processing phase */
+		return -EINVAL;
+	}
+
+	/* Save CR */
+	ctx->cr = mmio_read_32(ctx->base + _SAES_CR);
+
+	/* If chaining mode need to save current IV */
+	if (does_chaining_mode_need_iv(ctx->cr)) {
+		uint8_t i;
+
+		/* Save IV */
+		for (i = 0U; i < AES_IVSIZE / sizeof(uint32_t); i++) {
+			ctx->iv[i] = mmio_read_32(ctx->base + _SAES_IVR0 + i * sizeof(uint32_t));
+		}
+	}
+
+	/* Disable the SAES peripheral */
+	mmio_clrbits_32(ctx->base + _SAES_CR, _SAES_CR_EN);
+
+	return 0;
+}
+
+/* To resume the processing of a message */
+static int restore_context(struct stm32_saes_context *ctx)
+{
+	int ret;
+
+	/* IP should be disabled */
+	if ((mmio_read_32(ctx->base + _SAES_CR) & _SAES_CR_EN) != 0U) {
+		VERBOSE("%s: Device is still enabled\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Reset internal state */
+	mmio_setbits_32(ctx->base + _SAES_CR, _SAES_CR_IPRST);
+
+	/* Restore the _SAES_CR */
+	mmio_write_32(ctx->base + _SAES_CR, ctx->cr);
+
+	/* Preparation decrypt key */
+	ret = saes_prepare_key(ctx);
+	if (ret != 0) {
+		return ret;
+	}
+
+	saes_write_iv(ctx);
+
+	/* Enable the SAES peripheral */
+	mmio_setbits_32(ctx->base + _SAES_CR, _SAES_CR_EN);
+
+	return 0;
+}
+
+/**
+ * @brief Initialize SAES driver.
+ * @param None.
+ * @retval 0 if OK; negative value else.
+ */
+int stm32_saes_driver_init(void)
+{
+	int err;
+
+	err = stm32_saes_parse_fdt(&saes_pdata);
+	if (err != 0) {
+		err = stm32_saes_get_platdata(&saes_pdata);
+		if (err != 0) {
+			return err;
+		}
+	}
+
+	clk_enable(saes_pdata.clock_id);
+	if (stm32mp_reset_assert(saes_pdata.reset_id, TIMEOUT_US_1MS) != 0) {
+		panic();
+	}
+
+	udelay(SAES_RESET_DELAY);
+	if (stm32mp_reset_deassert(saes_pdata.reset_id, TIMEOUT_US_1MS) != 0) {
+		panic();
+	}
+
+	return 0;
+}
+
+/**
+ * @brief Start a AES computation.
+ * @param ctx: SAES process context
+ * @param is_dec: true if decryption, false if encryption
+ * @param ch_mode: define the chaining mode
+ * @param key_select: define where the key comes from.
+ * @param key: pointer to key (if key_select is KEY_SOFT, else unused)
+ * @param key_size: key size
+ * @param iv: pointer to initialization vectore (unsed if ch_mode is ECB)
+ * @param iv_size: iv size
+ * @note this function doesn't access to hardware but store in ctx the values
+ *
+ * @retval 0 if OK; negative value else.
+ */
+int stm32_saes_init(struct stm32_saes_context *ctx, bool is_dec,
+		    enum stm32_saes_chaining_mode ch_mode, enum stm32_saes_key_selection key_select,
+		    const void *key, size_t key_size, const void *iv, size_t iv_size)
+{
+	unsigned int i;
+	const uint32_t *iv_u32;
+	const uint32_t *key_u32;
+
+	ctx->assoc_len = 0U;
+	ctx->load_len = 0U;
+
+	ctx->base = saes_pdata.base;
+	ctx->cr = _SAES_CR_RESET_VALUE;
+
+	/* We want buffer to be u32 aligned */
+	assert((uintptr_t)key % __alignof__(uint32_t) == 0);
+	assert((uintptr_t)iv % __alignof__(uint32_t) == 0);
+
+	iv_u32 = iv;
+	key_u32 = key;
+
+	if (is_dec) {
+		/* Save Mode 3 = decrypt */
+		mmio_clrsetbits_32((uintptr_t)&(ctx->cr), _SAES_CR_MODE_MASK,
+				   _SAES_CR_MODE_DEC << _SAES_CR_MODE_SHIFT);
+	} else {
+		/* Save Mode 1 = crypt */
+		mmio_clrsetbits_32((uintptr_t)&(ctx->cr), _SAES_CR_MODE_MASK,
+				   _SAES_CR_MODE_ENC << _SAES_CR_MODE_SHIFT);
+	}
+
+	/* Save chaining mode */
+	switch (ch_mode) {
+	case STM32_SAES_MODE_ECB:
+		SET_CHAINING_MODE(ECB, (uintptr_t)&(ctx->cr));
+		break;
+	case STM32_SAES_MODE_CBC:
+		SET_CHAINING_MODE(CBC, (uintptr_t)&(ctx->cr));
+		break;
+	case STM32_SAES_MODE_CTR:
+		SET_CHAINING_MODE(CTR, (uintptr_t)&(ctx->cr));
+		break;
+	case STM32_SAES_MODE_GCM:
+		SET_CHAINING_MODE(GCM, (uintptr_t)&(ctx->cr));
+		break;
+	case STM32_SAES_MODE_CCM:
+		SET_CHAINING_MODE(CCM, (uintptr_t)&(ctx->cr));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* We will use HW Byte swap (_SAES_CR_DATATYPE_BYTE) for data.
+	 * so we won't need to
+	 * htobe32(data) before write to DINR
+	 * nor
+	 * be32toh after reading from DOUTR
+	 *
+	 * But note that wrap key only accept _SAES_CR_DATATYPE_NONE
+	 */
+	mmio_clrsetbits_32((uintptr_t)&(ctx->cr), _SAES_CR_DATATYPE_MASK,
+			   _SAES_CR_DATATYPE_BYTE << _SAES_CR_DATATYPE_SHIFT);
+
+	/* Configure keysize */
+	switch (key_size) {
+	case AES_KEYSIZE_128:
+		mmio_clrbits_32((uintptr_t)&(ctx->cr), _SAES_CR_KEYSIZE);
+		break;
+	case AES_KEYSIZE_256:
+		mmio_setbits_32((uintptr_t)&(ctx->cr), _SAES_CR_KEYSIZE);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Configure key */
+	switch (key_select) {
+	case STM32_SAES_KEY_SOFT:
+		mmio_clrsetbits_32((uintptr_t)&(ctx->cr), _SAES_CR_KEYSEL_MASK,
+				   _SAES_CR_KEYSEL_SOFT << _SAES_CR_KEYSEL_SHIFT);
+		/* Save key */
+		switch (key_size) {
+		case AES_KEYSIZE_128:
+			/* First 16 bytes == 4 u32 */
+			for (i = 0U; i < AES_KEYSIZE_128 / sizeof(uint32_t); i++) {
+				mmio_write_32((uintptr_t)(ctx->key + i), htobe32(key_u32[3 - i]));
+				/* /!\ we save the key in HW byte order
+				 * and word order : key[i] is for _SAES_KEYRi
+				 */
+			}
+			break;
+		case AES_KEYSIZE_256:
+			for (i = 0U; i < AES_KEYSIZE_256 / sizeof(uint32_t); i++) {
+				mmio_write_32((uintptr_t)(ctx->key + i), htobe32(key_u32[7 - i]));
+				/* /!\ we save the key in HW byte order
+				 * and word order : key[i] is for _SAES_KEYRi
+				 */
+			}
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	case STM32_SAES_KEY_DHU:
+		mmio_clrsetbits_32((uintptr_t)&(ctx->cr), _SAES_CR_KEYSEL_MASK,
+				   _SAES_CR_KEYSEL_DHUK << _SAES_CR_KEYSEL_SHIFT);
+		break;
+	case STM32_SAES_KEY_BH:
+		mmio_clrsetbits_32((uintptr_t)&(ctx->cr), _SAES_CR_KEYSEL_MASK,
+				   _SAES_CR_KEYSEL_BHK << _SAES_CR_KEYSEL_SHIFT);
+		break;
+	case STM32_SAES_KEY_BHU_XOR_BH:
+		mmio_clrsetbits_32((uintptr_t)&(ctx->cr), _SAES_CR_KEYSEL_MASK,
+				   _SAES_CR_KEYSEL_BHU_XOR_BH_K << _SAES_CR_KEYSEL_SHIFT);
+		break;
+	case STM32_SAES_KEY_WRAPPED:
+		mmio_clrsetbits_32((uintptr_t)&(ctx->cr), _SAES_CR_KEYSEL_MASK,
+				   _SAES_CR_KEYSEL_SOFT << _SAES_CR_KEYSEL_SHIFT);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	/* Save IV */
+	if (ch_mode != STM32_SAES_MODE_ECB) {
+		if ((iv == NULL) || (iv_size != AES_IVSIZE)) {
+			return -EINVAL;
+		}
+		for (i = 0U; i < AES_IVSIZE / sizeof(uint32_t); i++) {
+			mmio_write_32((uintptr_t)(ctx->iv + i), htobe32(iv_u32[3 - i]));
+			/* /!\ We save the iv in HW byte order */
+		}
+	}
+	return saes_start(ctx);
+}
+
+/**
+ * @brief Update (or start) a AES authentificate process of associated data (CCM or GCM).
+ * @param ctx: SAES process context
+ * @param last_block: true if last assoc data block
+ * @param data: pointer to associated data
+ * @param data_size: data size
+ *
+ * @retval 0 if OK; negative value else.
+ */
+int stm32_saes_update_assodata(struct stm32_saes_context *ctx, bool last_block,
+			       uint8_t *data, size_t data_size)
+{
+	int ret;
+	uint32_t *data_u32;
+	unsigned int i = 0U;
+
+	/* We want buffers to be u32 aligned */
+	assert((uintptr_t)data % __alignof__(uint32_t) == 0);
+	data_u32 = (uint32_t *)data;
+
+	/* Init phase */
+	ret = restore_context(ctx);
+	if (ret != 0) {
+		goto out;
+	}
+
+	ret = wait_computation_completed(ctx->base);
+	if (ret != 0) {
+		return ret;
+	}
+
+	clear_computation_completed(ctx->base);
+
+	if ((data == NULL) || (data_size == 0U)) {
+		/* No associated data */
+		/* ret already = 0 */
+		goto out;
+	}
+
+	/* There is an header/associated data phase */
+	mmio_clrsetbits_32(ctx->base + _SAES_CR, _SAES_CR_GCMPH_MASK,
+			   _SAES_CR_GCMPH_HEADER << _SAES_CR_GCMPH_SHIFT);
+
+	/* Enable the SAES peripheral */
+	mmio_setbits_32(ctx->base + _SAES_CR, _SAES_CR_EN);
+
+	while (i < round_down(data_size, AES_BLOCK_SIZE)) {
+		unsigned int w; /* Word index */
+
+		w = i / sizeof(uint32_t);
+		/* No need to htobe() as we configure the HW to swap bytes */
+		mmio_write_32(ctx->base + _SAES_DINR, data_u32[w + 0U]);
+		mmio_write_32(ctx->base + _SAES_DINR, data_u32[w + 1U]);
+		mmio_write_32(ctx->base + _SAES_DINR, data_u32[w + 2U]);
+		mmio_write_32(ctx->base + _SAES_DINR, data_u32[w + 3U]);
+
+		ret = wait_computation_completed(ctx->base);
+		if (ret != 0) {
+			goto out;
+		}
+
+		clear_computation_completed(ctx->base);
+
+		/* Process next block */
+		i += AES_BLOCK_SIZE;
+		ctx->assoc_len += AES_BLOCK_SIZE_BIT;
+	}
+
+	/* Manage last block if not a block size multiple */
+	if ((last_block) && (i < data_size)) {
+		/* We don't manage unaligned last block yet */
+		ret = -ENODEV;
+		goto out;
+	}
+
+out:
+	if (ret != 0) {
+		saes_end(ctx, ret);
+	}
+
+	return ret;
+}
+
+/**
+ * @brief Update (or start) a AES authenticate and de/encrypt with payload data (CCM or GCM).
+ * @param ctx: SAES process context
+ * @param last_block: true if last payload data block
+ * @param data_in: pointer to payload
+ * @param data_out: pointer where to save de/encrypted payload
+ * @param data_size: payload size
+ *
+ * @retval 0 if OK; negative value else.
+ */
+int stm32_saes_update_load(struct stm32_saes_context *ctx, bool last_block,
+			   uint8_t *data_in, uint8_t *data_out, size_t data_size)
+{
+	int ret = 0;
+	uint32_t *data_in_u32;
+	uint32_t *data_out_u32;
+	unsigned int i = 0U;
+	uint32_t prev_cr;
+
+	/* We want buffers to be u32 aligned */
+	assert((uintptr_t)data_in % __alignof__(uint32_t) == 0);
+	assert((uintptr_t)data_out % __alignof__(uint32_t) == 0);
+	data_in_u32 = (uint32_t *)data_in;
+	data_out_u32 = (uint32_t *)data_out;
+
+	prev_cr = mmio_read_32(ctx->base + _SAES_CR);
+
+	if ((data_in == NULL) || (data_size == 0U)) {
+		/* there is no data */
+		goto out;
+	}
+
+	/* There is a load phase */
+	mmio_clrsetbits_32(ctx->base + _SAES_CR, _SAES_CR_GCMPH_MASK,
+			   _SAES_CR_GCMPH_PAYLOAD << _SAES_CR_GCMPH_SHIFT);
+
+	if ((prev_cr & _SAES_CR_GCMPH_MASK) ==
+	    (_SAES_CR_GCMPH_INIT << _SAES_CR_GCMPH_SHIFT)) {
+		/* Still in initialization phase, no header
+		 * We need to enable the SAES peripheral
+		 */
+		mmio_setbits_32(ctx->base + _SAES_CR, _SAES_CR_EN);
+	}
+
+	while (i < round_down(data_size, AES_BLOCK_SIZE)) {
+		unsigned int w; /* Word index */
+
+		w = i / sizeof(uint32_t);
+		/* No need to htobe() as we configure the HW to swap bytes */
+		mmio_write_32(ctx->base + _SAES_DINR, data_in_u32[w + 0U]);
+		mmio_write_32(ctx->base + _SAES_DINR, data_in_u32[w + 1U]);
+		mmio_write_32(ctx->base + _SAES_DINR, data_in_u32[w + 2U]);
+		mmio_write_32(ctx->base + _SAES_DINR, data_in_u32[w + 3U]);
+
+		ret = wait_computation_completed(ctx->base);
+		if (ret != 0) {
+			goto out;
+		}
+
+		/* No need to htobe() as we configure the HW to swap bytes */
+		data_out_u32[w + 0U] = mmio_read_32(ctx->base + _SAES_DOUTR);
+		data_out_u32[w + 1U] = mmio_read_32(ctx->base + _SAES_DOUTR);
+		data_out_u32[w + 2U] = mmio_read_32(ctx->base + _SAES_DOUTR);
+		data_out_u32[w + 3U] = mmio_read_32(ctx->base + _SAES_DOUTR);
+
+		clear_computation_completed(ctx->base);
+
+		/* Process next block */
+		i += AES_BLOCK_SIZE;
+		ctx->load_len += AES_BLOCK_SIZE_BIT;
+	}
+	/* Manage last block if not a block size multiple */
+	if ((last_block) && (i < data_size)) {
+		uint32_t block_in[AES_BLOCK_SIZE / sizeof(uint32_t)] = {0};
+		uint32_t block_out[AES_BLOCK_SIZE / sizeof(uint32_t)] = {0};
+
+		memcpy(block_in, data_in + i, data_size - i);
+
+		/* No need to htobe() as we configure the HW to swap bytes */
+		mmio_write_32(ctx->base + _SAES_DINR, block_in[0U]);
+		mmio_write_32(ctx->base + _SAES_DINR, block_in[1U]);
+		mmio_write_32(ctx->base + _SAES_DINR, block_in[2U]);
+		mmio_write_32(ctx->base + _SAES_DINR, block_in[3U]);
+
+		ret = wait_computation_completed(ctx->base);
+		if (ret != 0) {
+			VERBOSE("%s %d\n", __func__, __LINE__);
+			goto out;
+		}
+
+		/* No need to htobe() as we configure the HW to swap bytes */
+		block_out[0U] = mmio_read_32(ctx->base + _SAES_DOUTR);
+		block_out[1U] = mmio_read_32(ctx->base + _SAES_DOUTR);
+		block_out[2U] = mmio_read_32(ctx->base + _SAES_DOUTR);
+		block_out[3U] = mmio_read_32(ctx->base + _SAES_DOUTR);
+
+		clear_computation_completed(ctx->base);
+
+		memcpy(data_out + i, block_out, data_size - i);
+
+		ctx->load_len += (data_size - i) * INT8_BIT;
+	}
+
+out:
+	if (ret != 0) {
+		saes_end(ctx, ret);
+	}
+
+	return ret;
+}
+
+/**
+ * @brief Get authentication tag for AES authenticated algorithms (CCM or GCM).
+ * @param ctx: SAES process context
+ * @param tag: pointer where to save the tag
+ * @param data_size: tag size
+ *
+ * @retval 0 if OK; negative value else.
+ */
+int stm32_saes_final(struct stm32_saes_context *ctx, uint8_t *tag,
+		     size_t tag_size)
+{
+	int ret;
+	uint32_t tag_u32[4];
+	uint32_t prev_cr;
+
+	prev_cr = mmio_read_32(ctx->base + _SAES_CR);
+
+	mmio_clrsetbits_32(ctx->base + _SAES_CR, _SAES_CR_GCMPH_MASK,
+			   _SAES_CR_GCMPH_FINAL << _SAES_CR_GCMPH_SHIFT);
+
+	if ((prev_cr & _SAES_CR_GCMPH_MASK) == (_SAES_CR_GCMPH_INIT << _SAES_CR_GCMPH_SHIFT)) {
+		/* Still in initialization phase, no header
+		 * We need to enable the SAES peripheral
+		 */
+		mmio_setbits_32(ctx->base + _SAES_CR, _SAES_CR_EN);
+	}
+
+	/* No need to htobe() as we configure the HW to swap bytes */
+	mmio_write_32(ctx->base + _SAES_DINR, 0);
+	mmio_write_32(ctx->base + _SAES_DINR, ctx->assoc_len);
+	mmio_write_32(ctx->base + _SAES_DINR, 0);
+	mmio_write_32(ctx->base + _SAES_DINR, ctx->load_len);
+
+	ret = wait_computation_completed(ctx->base);
+	if (ret != 0) {
+		goto out;
+	}
+
+	/* No need to htobe() as we configure the HW to swap bytes */
+	tag_u32[0] = mmio_read_32(ctx->base + _SAES_DOUTR);
+	tag_u32[1] = mmio_read_32(ctx->base + _SAES_DOUTR);
+	tag_u32[2] = mmio_read_32(ctx->base + _SAES_DOUTR);
+	tag_u32[3] = mmio_read_32(ctx->base + _SAES_DOUTR);
+
+	clear_computation_completed(ctx->base);
+
+	memcpy(tag, tag_u32, MIN(sizeof(tag_u32), tag_size));
+
+out:
+	saes_end(ctx, ret);
+
+	return ret;
+}
+
+/**
+ * @brief Update (or start) a AES de/encrypt process (ECB, CBC or CTR).
+ * @param ctx: SAES process context
+ * @param last_block: true if last payload data block
+ * @param data_in: pointer to payload
+ * @param data_out: pointer where to save de/encrypted payload
+ * @param data_size: payload size
+ *
+ * @retval 0 if OK; negative value else.
+ */
+int stm32_saes_update(struct stm32_saes_context *ctx, bool last_block,
+		      uint8_t *data_in, uint8_t *data_out, size_t data_size)
+{
+	int ret;
+	uint32_t *data_in_u32;
+	uint32_t *data_out_u32;
+	unsigned int i = 0U;
+
+	/* We want buffers to be u32 aligned */
+	assert((uintptr_t)data_in % __alignof__(uint32_t) == 0);
+	assert((uintptr_t)data_out % __alignof__(uint32_t) == 0);
+	data_in_u32 = (uint32_t *)data_in;
+	data_out_u32 = (uint32_t *)data_out;
+
+	if ((!last_block) &&
+	    (round_down(data_size, AES_BLOCK_SIZE) != data_size)) {
+		ERROR("%s: non last block must be multiple of 128 bits\n",
+		      __func__);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* In CBC encryption we need to manage specifically last 2 128bits
+	 * blocks if total size in not a block size aligned
+	 * work TODO. Currently return ENODEV.
+	 * Morevoer as we need to know last 2 block, if unaligned and
+	 * call with less than two block, return -EINVAL.
+	 */
+	if (last_block && IS_CHAINING_MODE(CBC, ctx->cr) && is_encrypt(ctx->cr) &&
+	    (round_down(data_size, AES_BLOCK_SIZE) != data_size)) {
+		if (data_size < AES_BLOCK_SIZE * 2) {
+			ERROR("if CBC, size of the last part should be at least 2*AES_BLOCK_SIZE\n");
+			ret = -EINVAL;
+			goto out;
+		}
+		/* Moreover the CBC specific padding for encrypt is not yet implemented */
+		ret = -ENODEV;
+		goto out;
+	}
+
+	ret = restore_context(ctx);
+	if (ret != 0) {
+		goto out;
+	}
+
+	while (i < round_down(data_size, AES_BLOCK_SIZE)) {
+		unsigned int w; /* Word index */
+
+		w = i / sizeof(uint32_t);
+		/* No need to htobe() as we configure the HW to swap bytes */
+		mmio_write_32(ctx->base + _SAES_DINR, data_in_u32[w + 0U]);
+		mmio_write_32(ctx->base + _SAES_DINR, data_in_u32[w + 1U]);
+		mmio_write_32(ctx->base + _SAES_DINR, data_in_u32[w + 2U]);
+		mmio_write_32(ctx->base + _SAES_DINR, data_in_u32[w + 3U]);
+
+		ret = wait_computation_completed(ctx->base);
+		if (ret != 0) {
+			goto out;
+		}
+
+		/* No need to htobe() as we configure the HW to swap bytes */
+		data_out_u32[w + 0U] = mmio_read_32(ctx->base + _SAES_DOUTR);
+		data_out_u32[w + 1U] = mmio_read_32(ctx->base + _SAES_DOUTR);
+		data_out_u32[w + 2U] = mmio_read_32(ctx->base + _SAES_DOUTR);
+		data_out_u32[w + 3U] = mmio_read_32(ctx->base + _SAES_DOUTR);
+
+		clear_computation_completed(ctx->base);
+
+		/* Process next block */
+		i += AES_BLOCK_SIZE;
+	}
+	/* Manage last block if not a block size multiple */
+
+	if ((last_block) && (i < data_size)) {
+		/* In and out buffer have same size so should be AES_BLOCK_SIZE multiple */
+		ret = -ENODEV;
+		goto out;
+	}
+
+	if (!last_block) {
+		ret = save_context(ctx);
+	}
+
+out:
+	/* If last block or error, end of SAES process */
+	if (last_block || (ret != 0)) {
+		saes_end(ctx, ret);
+	}
+
+	return ret;
+}
+
+static int stm32_saes_derived_key(struct stm32_saes_context *ctx, bool is_dec,
+				  bool protect_key, bool shared_key,
+				  enum stm32_saes_chaining_mode ch_mode,
+				  enum stm32_saes_key_selection key_select,
+				  const void *key, size_t key_size, const void *iv, size_t iv_size,
+				  const void *in_data, const void *out_data)
+{
+	int ret = 0;
+	uint32_t *out_data_u32;
+	uint32_t *in_data_u32;
+	size_t i, j;
+
+	switch (key_size) {
+	case AES_KEYSIZE_128:
+	case AES_KEYSIZE_256:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (ch_mode) {
+	case STM32_SAES_MODE_GCM:
+		/* GCM is not a supported algo for derived key */
+		return -EINVAL;
+	case STM32_SAES_MODE_CCM:
+	case STM32_SAES_MODE_CTR:
+		/* not yet tested */
+		return -EINVAL;
+	default:
+		break;
+	}
+
+	/* We want buffers to be u32 aligned */
+	assert((uintptr_t)in_data % __alignof__(uint32_t) == 0);
+	assert((uintptr_t)out_data % __alignof__(uint32_t) == 0);
+	in_data_u32 = (uint32_t *)in_data;
+	out_data_u32 = (uint32_t *)out_data;
+
+	ret = stm32_saes_init(ctx, is_dec, ch_mode, key_select, key, key_size,
+			      iv, iv_size);
+	if (ret != 0) {
+		goto out;
+	}
+
+	/* IP should be disabled */
+	if ((mmio_read_32(ctx->base + _SAES_CR) & _SAES_CR_EN) != 0U) {
+		VERBOSE("%s: Device is still enabled\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Unwrap and wrap key expec DATATYPE=NONE */
+	mmio_clrsetbits_32((uintptr_t)&(ctx->cr), _SAES_CR_DATATYPE_MASK,
+			   _SAES_CR_DATATYPE_NONE << _SAES_CR_DATATYPE_SHIFT);
+
+	/* Select KEYMOD wrap key/shared key */
+	if (shared_key) {
+		mmio_clrsetbits_32(ctx->base + _SAES_CR, _SAES_CR_KEYMOD_MASK,
+				   _SAES_CR_KEYMOD_SHARED << _SAES_CR_KEYMOD_SHIFT);
+	} else {
+		mmio_clrsetbits_32(ctx->base + _SAES_CR, _SAES_CR_KEYMOD_MASK,
+				   _SAES_CR_KEYMOD_WRAPPED << _SAES_CR_KEYMOD_SHIFT);
+	}
+
+	if (protect_key) {
+		mmio_setbits_32(ctx->base + _SAES_CR, _SAES_CR_KEYPROT);
+	} else {
+		mmio_clrbits_32(ctx->base + _SAES_CR, _SAES_CR_KEYPROT);
+	}
+
+	/* Write CR defined by init */
+	mmio_write_32(ctx->base + _SAES_CR, ctx->cr);
+
+	/* Preparation decrypt key */
+	ret = saes_prepare_key(ctx);
+	if (ret != 0) {
+		goto out;
+	}
+
+	saes_write_iv(ctx);
+
+	/* Enable the SAES peripheral */
+	mmio_setbits_32(ctx->base + _SAES_CR, _SAES_CR_EN);
+
+	for (i = 0; i < key_size / sizeof(uint32_t); i += (AES_BLOCK_SIZE / sizeof(uint32_t))) {
+		for (j = 0; j < AES_BLOCK_SIZE / sizeof(uint32_t); j++) {
+			/* Need to htobe() as keyshared need the HW in NO swap mode */
+			mmio_write_32(ctx->base + _SAES_DINR, htobe32(in_data_u32[i + j]));
+		}
+
+		ret = wait_computation_completed(ctx->base);
+		if (ret != 0) {
+			goto out;
+		}
+
+		if ((IS_CHAINING_MODE(ECB, ctx->cr) || IS_CHAINING_MODE(CBC, ctx->cr)) &&
+		    (!is_dec)) {
+			for (j = 0; j < AES_BLOCK_SIZE / sizeof(uint32_t); j++) {
+				out_data_u32[i + j] = be32toh(mmio_read_32(ctx->base +
+									   _SAES_DOUTR));
+			}
+		}
+
+		clear_computation_completed(ctx->base);
+	}
+
+out:
+	/* Disable the SAES peripheral and reset SAES in case of error */
+	saes_end(ctx, ret);
+
+	return ret;
+}
+
+/**
+ * @brief  Wrap (encrypt) application keys (not appplicable for CTR chaining
+ *         mode algorithm)
+ * @param  ch_mod: select chaining mode algorithm
+ * @param  key_select: select key origin
+ * @param  key: pointer to key use to encrypt (if key_select == SOFT)
+ * else not used.
+ * @param  key_size: len of the encrypt key, key to encrypt and encrypted key.
+ * (16 or 32)
+ * @param  iv: pointer to IV used to encrypt (not use for ECB)
+ * @param  iv_size: iv size should be 16 (not use for ECB)
+ * @param  in_key: key to encrypt (same size as 'key'), not used for CCM
+ * @param  out_data: encrypted key (ECM, CBC) (same size as 'key'),
+ *                   or authentication tag for CCM (size = 16)
+ * @retval HAL status
+ */
+int stm32_saes_wrap_key(enum stm32_saes_chaining_mode ch_mode,
+			enum stm32_saes_key_selection key_select, const void *key, size_t key_size,
+			const void *iv, size_t iv_size, const void *in_key, const void *out_data)
+{
+	struct stm32_saes_context ctx;
+
+	return stm32_saes_derived_key(&ctx, false,
+			  true, false, ch_mode, key_select,
+			  key, key_size, iv, iv_size, in_key, out_data);
+}
+
+/**
+ * @brief  Unwrap (decrypt) application keys
+ * @param  ch_mod: select chaining mode algorithm
+ * @param  key_select: select key origin
+ * @param  key: pointer to key used to decrypt (if key_select == SOFT)
+ *              for other key_select, not used.
+ * @param  key_size: len of the decrypt key, key to decrypt and decrypted key.
+ *                   (16 or 32)
+ * @param  iv: pointer to IV used to encrypt (not use for ECB)
+ * @param  iv_size: iv size should be 16 (not use for ECB)
+ * @param  in_data: key to decrypt (same size as 'key') for ECB and CBC,
+ *                  authentication tag for CCM (size = 16)
+ *                  not used for CTR.
+ * @retval HAL status
+ */
+int stm32_saes_unwrap_key(enum stm32_saes_chaining_mode ch_mode,
+			  enum stm32_saes_key_selection key_select, const void *key,
+			  size_t key_size, const void *iv, size_t iv_size, const void *in_data)
+{
+	struct stm32_saes_context ctx;
+
+	return stm32_saes_derived_key(&ctx, true,
+			  true, false, ch_mode, key_select,
+			  key, key_size, iv, iv_size, in_data, NULL);
+}
diff --git a/drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_ddr3.h b/drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_ddr3.h
new file mode 100644
index 000000000..cfcac3626
--- /dev/null
+++ b/drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_ddr3.h
@@ -0,0 +1,999 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef MNPMUSRAMMSGBLOCK_DDR3_H
+#define MNPMUSRAMMSGBLOCK_DDR3_H
+
+/*
+ * DDR3U_1D training firmware message block structure
+ *
+ * Please refer to the Training Firmware App Note for futher information about
+ * the usage for Message Block.
+ */
+typedef struct _pmu_smb_ddr_1d_t {
+	uint8_t reserved00;		/*
+					 * Byte offset 0x00, CSR Addr 0x54000, Direction=In
+					 * reserved00[0:4] RFU, must be zero
+					 *
+					 * reserved00[5] = Train vrefDAC0 During Read Deskew
+					 *   0x1 = Read Deskew will begin by enabling and roughly
+					 *   training the phy's per-lane reference voltages.
+					 *   Training the vrefDACs CSRs will increase the maximum 1D
+					 *   training time by around half a millisecond, but will
+					 *   improve 1D training accuracy on systems with
+					 *   significant voltage-offsets between lane read eyes.
+					 *   0x0 = Read Deskew will assume the messageblock's
+					 *   phyVref setting will work for all lanes.
+					 *
+					 * reserved00[6] = Enable High Effort WrDQ1D
+					 *   0x1 = WrDQ1D will conditionally retry training at
+					 *   several extra RxClkDly Timings. This will increase the
+					 *   maximum 1D training time by up to 4 extra iterations of
+					 *   WrDQ1D. This is only required in systems that suffer
+					 *   from very large, asymmetric eye-collapse when receiving
+					 *   PRBS patterns.
+					 *   0x0 = WrDQ1D assume rxClkDly values found by SI
+					 *   Friendly RdDqs1D will work for receiving PRBS patterns
+					 *
+					 * reserved00[7] = Optimize for the special hard macros in
+					 * TSMC28.
+					 *   0x1 = set if the phy being trained was manufactured in
+					 *   any TSMC28 process node.
+					 *   0x0 = otherwise, when not training a TSMC28 phy, leave
+					 *   this field as 0.
+					 */
+	uint8_t msgmisc;		/*
+					 * Byte offset 0x01, CSR Addr 0x54000, Direction=In
+					 * Contains various global options for training.
+					 *
+					 * Bit fields:
+					 *
+					 * msgmisc[0] = MTESTEnable
+					 *   0x1 = Pulse primary digital test output bump at the end
+					 *   of each major training stage. This enables observation
+					 *   of training stage completion by observing the digital
+					 *   test output.
+					 *   0x0 = Do not pulse primary digital test output bump
+					 *
+					 * msgmisc[1] = SimulationOnlyReset
+					 *   0x1 = Verilog only simulation option to shorten
+					 *   duration of DRAM reset pulse length to 1ns.
+					 *   Must never be set to 1 in silicon.
+					 *   0x0 = Use reset pulse length specifed by JEDEC standard
+					 *
+					 * msgmisc[2] = SimulationOnlyTraining
+					 *   0x1 = Verilog only simulation option to shorten the
+					 *   duration of the training steps by performing fewer
+					 *   iterations.
+					 *   Must never be set to 1 in silicon.
+					 *   0x0 = Use standard training duration.
+					 *
+					 * msgmisc[3] = RFU, must be zero
+					 *
+					 * msgmisc[4] = Suppress streaming messages, including
+					 * assertions, regardless of hdtctrl setting.
+					 * Stage Completion messages, as well as training completion
+					 * and error messages are still sent depending on hdtctrl
+					 * setting.
+					 *
+					 * msgmisc[5] = PerByteMaxRdLat
+					 *   0x1 = Each DBYTE will return dfi_rddata_valid at the
+					 *   lowest possible latency. This may result in unaligned
+					 *   data between bytes to be returned to the DFI.
+					 *   0x0 = Every DBYTE will return dfi_rddata_valid
+					 *   simultaneously. This will ensure that data bytes will
+					 *   return aligned accesses to the DFI.
+					 *
+					 * msgmisc[6] = PartialRank (DDR3 UDIMM and DDR4 UDIMM only,
+					 * otherwise RFU, must be zero)
+					 *   0x1 = Support rank populated with a subset of byte, but
+					 *   where even-odd pair of rank support all the byte
+					 *   0x0 = All rank populated with all the byte (tyical
+					 *   configuration)
+					 *
+					 * msgmisc[7] RFU, must be zero
+					 *
+					 * Notes:
+					 *
+					 * - SimulationOnlyReset and SimulationOnlyTraining can be
+					 *   used to speed up simulation run times, and must never
+					 *   be used in real silicon. Some VIPs may have checks on
+					 *   DRAM reset parameters that may need to be disabled when
+					 *   using SimulationOnlyReset.
+					 */
+	uint16_t pmurevision;		/*
+					 * Byte offset 0x02, CSR Addr 0x54001, Direction=Out
+					 * PMU firmware revision ID
+					 * After training is run, this address will contain the
+					 * revision ID of the firmware.
+					 * Please reference this revision ID when filing support
+					 * cases.
+					 */
+	uint8_t pstate;			/*
+					 * Byte offset 0x04, CSR Addr 0x54002, Direction=In
+					 * Must be set to the target pstate to be trained
+					 *   0x0 = pstate 0
+					 *   0x1 = pstate 1
+					 *   0x2 = pstate 2
+					 *   0x3 = pstate 3
+					 *   All other encodings are reserved
+					 */
+	uint8_t pllbypassen;		/*
+					 * Byte offset 0x05, CSR Addr 0x54002, Direction=In
+					 * Set according to whether target pstate uses PHY PLL
+					 * bypass
+					 *   0x0 = PHY PLL is enabled for target pstate
+					 *   0x1 = PHY PLL is bypassed for target pstate
+					 */
+	uint16_t dramfreq;		/*
+					 * Byte offset 0x06, CSR Addr 0x54003, Direction=In
+					 * DDR data rate for the target pstate in units of MT/s.
+					 * For example enter 0x0640 for DDR1600.
+					 */
+	uint8_t dfifreqratio;		/*
+					 * Byte offset 0x08, CSR Addr 0x54004, Direction=In
+					 * Frequency ratio betwen DfiCtlClk and SDRAM memclk.
+					 *   0x1 = 1:1
+					 *   0x2 = 1:2
+					 *   0x4 = 1:4
+					 */
+	uint8_t bpznresval;		/*
+					 * Byte offset 0x09, CSR Addr 0x54004, Direction=In
+					 * Must be programmed to match the precision resistor
+					 * connected to Phy BP_ZN
+					 *   0x00 = Do not program. Use current CSR value.
+					 *   0xf0 = 240 Ohm (recommended value)
+					 *   0x78 = 120 Ohm
+					 *   0x28 = 40 Ohm
+					 *   All other values are reserved.
+					 */
+	uint8_t phyodtimpedance;	/*
+					 * Byte offset 0x0a, CSR Addr 0x54005, Direction=In
+					 * Must be programmed to the termination impedance in ohms
+					 * used by PHY during reads.
+					 *
+					 *   0x0 = Firmware skips programming (must be manually
+					 *   programmed by user prior to training start)
+					 *
+					 * See PHY databook for legal termination impedance values.
+					 *
+					 * For digital simulation, any legal value can be used. For
+					 * silicon, the users must determine the correct value
+					 * through SI simulation or other methods.
+					 */
+	uint8_t phydrvimpedance;	/*
+					 * Byte offset 0x0b, CSR Addr 0x54005, Direction=In
+					 * Must be programmed to the driver impedance in ohms used
+					 * by PHY during writes for all DBYTE drivers
+					 * (DQ/DM/DBI/DQS).
+					 *
+					 *   0x0 = Firmware skips programming (must be manually
+					 *   programmed by user prior to training start)
+					 *
+					 * See PHY databook for legal R_on driver impedance values.
+					 *
+					 * For digital simulation, any value can be used that is not
+					 * Hi-Z. For silicon, the users must determine the correct
+					 * value through SI simulation or other methods.
+					 */
+	uint8_t phyvref;		/*
+					 * Byte offset 0x0c, CSR Addr 0x54006, Direction=In
+					 * Must be programmed with the Vref level to be used by the
+					 * PHY during reads
+					 *
+					 * The units of this field are a percentage of VDDQ
+					 * according to the following equation:
+					 *
+					 * Receiver Vref = VDDQ*phyvref[6:0]/128
+					 *
+					 * For example to set Vref at 0.75*VDDQ, set this field to
+					 * 0x60.
+					 *
+					 * For digital simulation, any legal value can be used. For
+					 * silicon, the users must calculate the analytical Vref by
+					 * using the impedances, terminations, and series resistance
+					 * present in the system.
+					 */
+	uint8_t dramtype;		/*
+					 * Byte offset 0x0d, CSR Addr 0x54006, Direction=In
+					 * Module Type:
+					 *   0x01 = DDR3 unbuffered
+					 *   0x02 = Reserved
+					 *   0x03 = Reserved
+					 *   0x04 = Reserved
+					 *   0x05 = Reserved
+					 */
+	uint8_t disableddbyte;		/*
+					 * Byte offset 0x0e, CSR Addr 0x54007, Direction=In
+					 * Bitmap to indicate which Dbyte are not connected (for
+					 * DByte 0 to 7):
+					 * Set disableddbyte[i] to 1 only to specify that DByte is
+					 * not need to be trained (DByte 8 can be disabled via
+					 * enableddqs setting)
+					 */
+	uint8_t enableddqs;		/*
+					 * Byte offset 0x0f, CSR Addr 0x54007, Direction=In
+					 * Total number of DQ bits enabled in PHY
+					 */
+	uint8_t cspresent;		/*
+					 * Byte offset 0x10, CSR Addr 0x54008, Direction=In
+					 * Indicates presence of DRAM at each chip select for PHY.
+					 * Each bit corresponds to a logical CS.
+					 *
+					 * If the bit is set to 1, the CS is connected to DRAM.
+					 * If the bit is set to 0, the CS is not connected to DRAM.
+					 *
+					 * cspresent[0] = CS0 is populated with DRAM
+					 * cspresent[1] = CS1 is populated with DRAM
+					 * cspresent[2] = CS2 is populated with DRAM
+					 * cspresent[3] = CS3 is populated with DRAM
+					 * cspresent[7:4] = Reserved (must be programmed to 0)
+					 */
+	uint8_t cspresentd0;		/*
+					 * Byte offset 0x11, CSR Addr 0x54008, Direction=In
+					 * The CS signals from field cspresent that are routed to
+					 * DIMM connector 0
+					 */
+	uint8_t cspresentd1;		/*
+					 * Byte offset 0x12, CSR Addr 0x54009, Direction=In
+					 * The CS signals from field cspresent that are routed to
+					 * DIMM connector 1
+					 */
+	uint8_t addrmirror;		/*
+					 * Byte offset 0x13, CSR Addr 0x54009, Direction=In
+					 * Corresponds to CS[3:0]
+					 *   1 = Address Mirror.
+					 *   0 = No Address Mirror.
+					 */
+	uint8_t cstestfail;		/*
+					 * Byte offset 0x14, CSR Addr 0x5400a, Direction=Out
+					 * This field will be set if training fails on any rank.
+					 *   0x0 = No failures
+					 *   non-zero = one or more ranks failed training
+					 */
+	uint8_t phycfg;			/*
+					 * Byte offset 0x15, CSR Addr 0x5400a, Direction=In
+					 * Additional mode bits.
+					 *
+					 * Bit fields:
+					 * [0] SlowAccessMode:
+					 *   1 = 2T Address Timing.
+					 *   0 = 1T Address Timing.
+					 * [7-1] RFU, must be zero
+					 *
+					 * WARNING: In case of DDR4 Geardown Mode (mr3[A3] == 1),
+					 * phycfg[0] must be 0.
+					 */
+	uint16_t sequencectrl;		/*
+					 * Byte offset 0x16, CSR Addr 0x5400b, Direction=In
+					 * Controls the training steps to be run. Each bit
+					 * corresponds to a training step.
+					 *
+					 * If the bit is set to 1, the training step will run.
+					 * If the bit is set to 0, the training step will be
+					 * skipped.
+					 *
+					 * Training step to bit mapping:
+					 * sequencectrl[0] = Run DevInit - Device/phy
+					 *		     initialization. Should always be set.
+					 * sequencectrl[1] = Run WrLvl - Write leveling
+					 * sequencectrl[2] = Run RxEn - Read gate training
+					 * sequencectrl[3] = Run RdDQS1D - 1d read dqs training
+					 * sequencectrl[4] = Run WrDQ1D - 1d write dq training
+					 * sequencectrl[5] = RFU, must be zero
+					 * sequencectrl[6] = RFU, must be zero
+					 * sequencectrl[7] = RFU, must be zero
+					 * sequencectrl[8] = Run RdDeskew - Per lane read dq deskew
+					 *		     training
+					 * sequencectrl[9] = Run MxRdLat - Max read latency training
+					 * sequencectrl[10] = RFU, must be zero
+					 * sequencectrl[11] = RFU, must be zero
+					 * sequencectrl[12] = RFU, must be zero
+					 * sequencectrl[13] = RFU, must be zero
+					 * sequencectrl[15-14] = RFU, must be zero
+					 */
+	uint8_t hdtctrl;		/*
+					 * Byte offset 0x18, CSR Addr 0x5400c, Direction=In
+					 * To control the total number of debug messages, a
+					 * verbosity subfield (hdtctrl, Hardware Debug Trace
+					 * Control) exists in the message block. Every message has a
+					 * verbosity level associated with it, and as the hdtctrl
+					 * value is increased, less important s messages stop being
+					 * sent through the mailboxes. The meanings of several major
+					 * hdtctrl thresholds are explained below:
+					 *
+					 *   0x04 = Maximal debug messages (e.g., Eye contours)
+					 *   0x05 = Detailed debug messages (e.g. Eye delays)
+					 *   0x0A = Coarse debug messages (e.g. rank information)
+					 *   0xC8 = Stage completion
+					 *   0xC9 = Assertion messages
+					 *   0xFF = Firmware completion messages only
+					 *
+					 * See Training App Note for more detailed information on
+					 * what messages are included for each threshold.
+					 */
+	uint8_t reserved19;		/* Byte offset 0x19, CSR Addr 0x5400c, Direction=N/A */
+	uint8_t reserved1a;		/* Byte offset 0x1a, CSR Addr 0x5400d, Direction=N/A */
+	uint8_t share2dvrefresult;	/*
+					 * Byte offset 0x1b, CSR Addr 0x5400d, Direction=In
+					 * Bitmap that designates the phy's vref source for every
+					 * pstate
+					 * If share2dvrefresult[x] = 0, then after 2D training,
+					 * pstate x will continue using the phyVref provided in
+					 * pstate x's 1D messageblock.
+					 * If share2dvrefresult[x] = 1, then after 2D training,
+					 * pstate x will use the per-lane VrefDAC0/1 CSRs trained by
+					 * 2d training.
+					 */
+	uint8_t reserved1c;		/* Byte offset 0x1c, CSR Addr 0x5400e, Direction=N/A */
+	uint8_t reserved1d;		/* Byte offset 0x1d, CSR Addr 0x5400e, Direction=N/A */
+	uint8_t reserved1e;		/*
+					 * Byte offset 0x1e, CSR Addr 0x5400f, Direction=In
+					 * Input for constraining the range of vref(DQ) values
+					 * training will collect data for, usually reducing training
+					 * time. However, too large of a voltage range may cause
+					 * longer 2D training times while too small of a voltage
+					 * range may truncate passing regions. When in doubt, leave
+					 * this field set to 0.
+					 * Used by 2D training in: Rd2D, Wr2D
+					 *
+					 * reserved1E[0-3]: Rd2D Voltage Range
+					 *   0 = Training will search all phy vref(DQ) settings
+					 *   1 = limit to +/-2 %VDDQ from phyVref
+					 *   2 = limit to +/-4 %VDDQ from phyVref
+					 *     . . .
+					 *   15 = limit to +/-30% VDDQ from phyVref
+					 *
+					 * reserved1E[4-7]: Wr2D Voltage Range
+					 *   0 = Training will search all dram vref(DQ) settings
+					 *   1 = limit to +/-2 %VDDQ from mr6
+					 *   2 = limit to +/-4 %VDDQ from mr6
+					 *     . . .
+					 *   15 = limit to +/-30% VDDQ from mr6
+					 */
+	uint8_t reserved1f;		/*
+					 * Byte offset 0x1f, CSR Addr 0x5400f, Direction=In
+					 * Extended training option:
+					 *
+					 * reserved1F[1:0]: Configured RxClkDly offset try during
+					 * WrDq1D high-effort (i.e., when reserved00[6] is set)
+					 *   0: -8, +8, -16, +16
+					 *   1: -4, +4, -8, +8, -12, +12, -16, +16
+					 *   2: -2, +2, -4, +4, -6, +6, -8, +8
+					 *   3: -2, +2, -4, +4, -6, +6, -8, +8, -10, +10, -12, +12,
+					 *      -14, +14, -16, +16
+					 *
+					 * reserved1F[2]: When set, execute again WrDq1D after
+					 * RdDqs1D PRBS
+					 *
+					 * reserved1F[3]: When set redo RdDeskew with PRBS after
+					 * (first) WrDqs1D
+					 *
+					 * reserved1F[7:4]: This field is reserved and must be
+					 * programmed to 0x00.
+					 */
+	uint8_t reserved20;		/*
+					 * Byte offset 0x20, CSR Addr 0x54010, Direction=In
+					 * This field is reserved and must be programmed to 0x00,
+					 * excepted for Reserved:
+					 * Reserved MREP assume raising edge is found when
+					 * reserved20[3:0]+3 consecutive 1 are received during MREP
+					 * fine delay swept; reserved20[6:0] thus permits to
+					 * increase tolerance for noisy system. And if reserved20[7]
+					 * is set, MREP training is failing if no raising edge is
+					 * found (otherwise the raising edge is assume close to
+					 * delay 0).
+					 */
+	uint8_t reserved21;		/*
+					 * Byte offset 0x21, CSR Addr 0x54010, Direction=In
+					 * This field is reserved and must be programmed to 0x00,
+					 * excepted for Reserved:
+					 * Reserved DWL assume raising edge is found when
+					 * reserved21[3:0]+3 consecutive 1 are received during DWL
+					 * fine delay swept; reserved21[6:0] thus permits to
+					 * increase tolerance for noisy system. And if reserved21[7]
+					 * is set, DWL training is failing if no raising edge is
+					 * found (otherwise the raising edge is assume close to
+					 * delay 0).
+					 */
+	uint16_t phyconfigoverride;	/*
+					 * Byte offset 0x22, CSR Addr 0x54011, Direction=In
+					 * Override PhyConfig csr.
+					 *   0x0: Use hardware csr value for PhyConfing
+					 *   (recommended)
+					 *   Other values: Use value for PhyConfig instead of
+					 *   Hardware value.
+					 */
+	uint8_t dfimrlmargin;		/*
+					 * Byte offset 0x24, CSR Addr 0x54012, Direction=In
+					 * Margin added to smallest passing trained DFI Max Read
+					 * Latency value, in units of DFI clocks. Recommended to be
+					 * >= 1. See the Training App Note for more details on the
+					 * training process and the use of this value.
+					 */
+	int8_t cdd_rr_3_2;		/*
+					 * Byte offset 0x25, CSR Addr 0x54012, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 3 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_3_1;		/*
+					 * Byte offset 0x26, CSR Addr 0x54013, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 3 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_3_0;		/*
+					 * Byte offset 0x27, CSR Addr 0x54013, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 3 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_2_3;		/*
+					 * Byte offset 0x28, CSR Addr 0x54014, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 2 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_2_1;		/*
+					 * Byte offset 0x29, CSR Addr 0x54014, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 2 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_2_0;		/*
+					 * Byte offset 0x2a, CSR Addr 0x54015, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 2 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_1_3;		/*
+					 * Byte offset 0x2b, CSR Addr 0x54015, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 1 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_1_2;		/*
+					 * Byte offset 0x2c, CSR Addr 0x54016, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 1 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_1_0;		/*
+					 * Byte offset 0x2d, CSR Addr 0x54016, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 1 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_0_3;		/*
+					 * Byte offset 0x2e, CSR Addr 0x54017, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 0 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_0_2;		/*
+					 * Byte offset 0x2f, CSR Addr 0x54017, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 0 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_0_1;		/*
+					 * Byte offset 0x30, CSR Addr 0x54018, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 0 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_3_2;		/*
+					 * Byte offset 0x31, CSR Addr 0x54018, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 3 to cs
+					 * 2. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_3_1;		/*
+					 * Byte offset 0x32, CSR Addr 0x54019, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 3 to cs
+					 * 1. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_3_0;		/*
+					 * Byte offset 0x33, CSR Addr 0x54019, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 3 to cs
+					 * 0. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_2_3;		/*
+					 * Byte offset 0x34, CSR Addr 0x5401a, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 2 to cs
+					 * 3. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_2_1;		/*
+					 * Byte offset 0x35, CSR Addr 0x5401a, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 2 to cs
+					 * 1. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_2_0;		/*
+					 * Byte offset 0x36, CSR Addr 0x5401b, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 2 to cs
+					 * 0. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_1_3;		/*
+					 * Byte offset 0x37, CSR Addr 0x5401b, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 1 to cs
+					 * 3. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_1_2;		/*
+					 * Byte offset 0x38, CSR Addr 0x5401c, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 1 to cs
+					 * 2. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_1_0;		/*
+					 * Byte offset 0x39, CSR Addr 0x5401c, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 1 to cs
+					 * 0. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_0_3;		/*
+					 * Byte offset 0x3a, CSR Addr 0x5401d, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 0 to cs
+					 * 3. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_0_2;		/*
+					 * Byte offset 0x3b, CSR Addr 0x5401d, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 0 to cs
+					 * 2. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_0_1;		/*
+					 * Byte offset 0x3c, CSR Addr 0x5401e, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 0 to cs
+					 * 1. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_3_3;		/*
+					 * Byte offset 0x3d, CSR Addr 0x5401e, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 3 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_3_2;		/*
+					 * Byte offset 0x3e, CSR Addr 0x5401f, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 3 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_3_1;		/*
+					 * Byte offset 0x3f, CSR Addr 0x5401f, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 3 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_3_0;		/*
+					 * Byte offset 0x40, CSR Addr 0x54020, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 3 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_2_3;		/*
+					 * Byte offset 0x41, CSR Addr 0x54020, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 2 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_2_2;		/*
+					 * Byte offset 0x42, CSR Addr 0x54021, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 2 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_2_1;		/*
+					 * Byte offset 0x43, CSR Addr 0x54021, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 2 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_2_0;		/*
+					 * Byte offset 0x44, CSR Addr 0x54022, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 2 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_1_3;		/*
+					 * Byte offset 0x45, CSR Addr 0x54022, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_1_2;		/*
+					 * Byte offset 0x46, CSR Addr 0x54023, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_1_1;		/*
+					 * Byte offset 0x47, CSR Addr 0x54023, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_1_0;		/*
+					 * Byte offset 0x48, CSR Addr 0x54024, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_0_3;		/*
+					 * Byte offset 0x49, CSR Addr 0x54024, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_0_2;		/*
+					 * Byte offset 0x4a, CSR Addr 0x54025, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_0_1;		/*
+					 * Byte offset 0x4b, CSR Addr 0x54025, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_0_0;		/*
+					 * Byte offset 0x4c, CSR Addr 0x54026, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_3_3;		/*
+					 * Byte offset 0x4d, CSR Addr 0x54026, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 3 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_3_2;		/*
+					 * Byte offset 0x4e, CSR Addr 0x54027, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 3 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_3_1;		/*
+					 * Byte offset 0x4f, CSR Addr 0x54027, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 3 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_3_0;		/*
+					 * Byte offset 0x50, CSR Addr 0x54028, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 3 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_2_3;		/*
+					 * Byte offset 0x51, CSR Addr 0x54028, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 2 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_2_2;		/*
+					 * Byte offset 0x52, CSR Addr 0x54029, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 2 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_2_1;		/*
+					 * Byte offset 0x53, CSR Addr 0x54029, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 2 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_2_0;		/*
+					 * Byte offset 0x54, CSR Addr 0x5402a, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 2 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_1_3;		/*
+					 * Byte offset 0x55, CSR Addr 0x5402a, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_1_2;		/*
+					 * Byte offset 0x56, CSR Addr 0x5402b, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_1_1;		/*
+					 * Byte offset 0x57, CSR Addr 0x5402b, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_1_0;		/*
+					 * Byte offset 0x58, CSR Addr 0x5402c, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_0_3;		/*
+					 * Byte offset 0x59, CSR Addr 0x5402c, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_0_2;		/*
+					 * Byte offset 0x5a, CSR Addr 0x5402d, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_0_1;		/*
+					 * Byte offset 0x5b, CSR Addr 0x5402d, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_0_0;		/*
+					 * Byte offset 0x5c, CSR Addr 0x5402e, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	uint8_t reserved5d;		/*
+					 * Byte offset 0x5d, CSR Addr 0x5402e, Direction=In
+					 * This field is reserved and must be programmed to 0x00,
+					 * excepted for DDR4:
+					 * By default, if this parameter is 0, the offset applied at
+					 * the end of DDR4 RxEn training resulting in the trained
+					 * RxEnDly is 3/8 of the RX preamble width; if reserved5D is
+					 * non zero, this offset is used instead (in fine step).
+					 */
+	uint16_t mr0;			/*
+					 * Byte offset 0x5e, CSR Addr 0x5402f, Direction=In
+					 * Value of DDR mode register mr0 for all ranks for current
+					 * pstate
+					 */
+	uint16_t mr1;			/*
+					 * Byte offset 0x60, CSR Addr 0x54030, Direction=In
+					 * Value of DDR mode register mr1 for all ranks for current
+					 * pstate
+					 */
+	uint16_t mr2;			/*
+					 * Byte offset 0x62, CSR Addr 0x54031, Direction=In
+					 * Value of DDR mode register mr2 for all ranks for current
+					 * pstate
+					 */
+	uint8_t reserved64;		/*
+					 * Byte offset 0x64, CSR Addr 0x54032, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved65;		/*
+					 * Byte offset 0x65, CSR Addr 0x54032, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved66;		/*
+					 * Byte offset 0x66, CSR Addr 0x54033, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved67;		/*
+					 * Byte offset 0x67, CSR Addr 0x54033, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved68;		/*
+					 * Byte offset 0x68, CSR Addr 0x54034, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved69;		/*
+					 * Byte offset 0x69, CSR Addr 0x54034, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved6a;		/*
+					 * Byte offset 0x6a, CSR Addr 0x54035, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved6b;		/*
+					 * Byte offset 0x6b, CSR Addr 0x54035, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved6c;		/*
+					 * Byte offset 0x6c, CSR Addr 0x54036, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved6d;		/*
+					 * Byte offset 0x6d, CSR Addr 0x54036, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved6e;		/*
+					 * Byte offset 0x6e, CSR Addr 0x54037, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved6f;		/*
+					 * Byte offset 0x6f, CSR Addr 0x54037, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved70;		/*
+					 * Byte offset 0x70, CSR Addr 0x54038, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved71;		/*
+					 * Byte offset 0x71, CSR Addr 0x54038, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved72;		/*
+					 * Byte offset 0x72, CSR Addr 0x54039, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved73;		/*
+					 * Byte offset 0x73, CSR Addr 0x54039, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t acsmodtctrl0;		/*
+					 * Byte offset 0x74, CSR Addr 0x5403a, Direction=In
+					 * Odt pattern for accesses targeting rank 0. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl1;		/*
+					 * Byte offset 0x75, CSR Addr 0x5403a, Direction=In
+					 * Odt pattern for accesses targeting rank 1. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl2;		/*
+					 * Byte offset 0x76, CSR Addr 0x5403b, Direction=In
+					 * Odt pattern for accesses targeting rank 2. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl3;		/*
+					 * Byte offset 0x77, CSR Addr 0x5403b, Direction=In
+					 * Odt pattern for accesses targeting rank 3. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl4;		/*
+					 * Byte offset 0x78, CSR Addr 0x5403c, Direction=In
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t acsmodtctrl5;		/*
+					 * Byte offset 0x79, CSR Addr 0x5403c, Direction=In
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t acsmodtctrl6;		/*
+					 * Byte offset 0x7a, CSR Addr 0x5403d, Direction=In
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t acsmodtctrl7;		/*
+					 * Byte offset 0x7b, CSR Addr 0x5403d, Direction=In
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved7c;		/*
+					 * Byte offset 0x7c, CSR Addr 0x5403e, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved7d;		/*
+					 * Byte offset 0x7d, CSR Addr 0x5403e, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved7e;		/*
+					 * Byte offset 0x7e, CSR Addr 0x5403f, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved7f;		/*
+					 * Byte offset 0x7f, CSR Addr 0x5403f, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved80;		/*
+					 * Byte offset 0x80, CSR Addr 0x54040, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved81;		/*
+					 * Byte offset 0x81, CSR Addr 0x54040, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved82;		/*
+					 * Byte offset 0x82, CSR Addr 0x54041, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved83;		/*
+					 * Byte offset 0x83, CSR Addr 0x54041, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved84;		/* Byte offset 0x84, CSR Addr 0x54042, Direction=N/A */
+	uint8_t reserved85;		/* Byte offset 0x85, CSR Addr 0x54042, Direction=N/A */
+	uint8_t reserved86;		/* Byte offset 0x86, CSR Addr 0x54043, Direction=N/A */
+	uint8_t reserved87;		/* Byte offset 0x87, CSR Addr 0x54043, Direction=N/A */
+	uint8_t reserved88;		/* Byte offset 0x88, CSR Addr 0x54044, Direction=N/A */
+	uint8_t reserved89;		/* Byte offset 0x89, CSR Addr 0x54044, Direction=N/A */
+	uint8_t reserved8a;		/* Byte offset 0x8a, CSR Addr 0x54045, Direction=N/A */
+	uint8_t reserved8b;		/* Byte offset 0x8b, CSR Addr 0x54045, Direction=N/A */
+	uint8_t reserved8c;		/* Byte offset 0x8c, CSR Addr 0x54046, Direction=N/A */
+	uint8_t reserved8d;		/* Byte offset 0x8d, CSR Addr 0x54046, Direction=N/A */
+	uint8_t reserved8e;		/* Byte offset 0x8e, CSR Addr 0x54047, Direction=N/A */
+	uint8_t reserved8f;		/* Byte offset 0x8f, CSR Addr 0x54047, Direction=N/A */
+	uint8_t reserved90;		/* Byte offset 0x90, CSR Addr 0x54048, Direction=N/A */
+	uint8_t reserved91;		/* Byte offset 0x91, CSR Addr 0x54048, Direction=N/A */
+	uint8_t reserved92;		/* Byte offset 0x92, CSR Addr 0x54049, Direction=N/A */
+	uint8_t reserved93;		/* Byte offset 0x93, CSR Addr 0x54049, Direction=N/A */
+	uint8_t reserved94;		/* Byte offset 0x94, CSR Addr 0x5404a, Direction=N/A */
+	uint8_t reserved95;		/* Byte offset 0x95, CSR Addr 0x5404a, Direction=N/A */
+	uint8_t reserved96;		/* Byte offset 0x96, CSR Addr 0x5404b, Direction=N/A */
+	uint8_t reserved97;		/* Byte offset 0x97, CSR Addr 0x5404b, Direction=N/A */
+	uint8_t reserved98;		/* Byte offset 0x98, CSR Addr 0x5404c, Direction=N/A */
+	uint8_t reserved99;		/* Byte offset 0x99, CSR Addr 0x5404c, Direction=N/A */
+	uint8_t reserved9a;		/* Byte offset 0x9a, CSR Addr 0x5404d, Direction=N/A */
+	uint8_t reserved9b;		/* Byte offset 0x9b, CSR Addr 0x5404d, Direction=N/A */
+	uint8_t reserved9c;		/* Byte offset 0x9c, CSR Addr 0x5404e, Direction=N/A */
+	uint8_t reserved9d;		/* Byte offset 0x9d, CSR Addr 0x5404e, Direction=N/A */
+	uint8_t reserved9e;		/* Byte offset 0x9e, CSR Addr 0x5404f, Direction=N/A */
+	uint8_t reserved9f;		/* Byte offset 0x9f, CSR Addr 0x5404f, Direction=N/A */
+	uint8_t reserveda0;		/* Byte offset 0xa0, CSR Addr 0x54050, Direction=N/A */
+	uint8_t reserveda1;		/* Byte offset 0xa1, CSR Addr 0x54050, Direction=N/A */
+	uint8_t reserveda2;		/* Byte offset 0xa2, CSR Addr 0x54051, Direction=N/A */
+	uint8_t reserveda3;		/* Byte offset 0xa3, CSR Addr 0x54051, Direction=N/A */
+} __attribute__ ((packed)) __attribute__ ((aligned(2))) pmu_smb_ddr_1d_t;
+
+#endif /* MNPMUSRAMMSGBLOCK_DDR3_H */
diff --git a/drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_ddr4.h b/drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_ddr4.h
new file mode 100644
index 000000000..4a6391b56
--- /dev/null
+++ b/drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_ddr4.h
@@ -0,0 +1,2274 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef MNPMUSRAMMSGBLOCK_DDR4_H
+#define MNPMUSRAMMSGBLOCK_DDR4_H
+
+/* DDR4U_1D training firmware message block structure
+ *
+ * Please refer to the Training Firmware App Note for futher information about
+ * the usage for Message Block.
+ */
+typedef struct _pmu_smb_ddr_1d_t {
+	uint8_t reserved00;		/*
+					 * Byte offset 0x00, CSR Addr 0x54000, Direction=In
+					 * reserved00[0:4] RFU, must be zero
+					 *
+					 * reserved00[5] = Train vrefDAC0 During Read Deskew
+					 *   0x1 = Read Deskew will begin by enabling and roughly
+					 *   training the phy's per-lane reference voltages.
+					 *   Training the vrefDACs CSRs will increase the maximum 1D
+					 *   training time by around half a millisecond, but will
+					 *   improve 1D training accuracy on systems with
+					 *   significant voltage-offsets between lane read eyes.
+					 *   0x0 = Read Deskew will assume the messageblock's
+					 *   phyVref setting will work for all lanes.
+					 *
+					 * reserved00[6] = Enable High Effort WrDQ1D
+					 *   0x1 = WrDQ1D will conditionally retry training at
+					 *   several extra RxClkDly Timings. This will increase the
+					 *   maximum 1D training time by up to 4 extra iterations of
+					 *   WrDQ1D. This is only required in systems that suffer
+					 *   from very large, asymmetric eye-collapse when receiving
+					 *   PRBS patterns.
+					 *   0x0 = WrDQ1D assume rxClkDly values found by SI
+					 *   Friendly RdDqs1D will work for receiving PRBS patterns
+					 *
+					 * reserved00[7] = Optimize for the special hard macros in
+					 * TSMC28.
+					 *   0x1 = set if the phy being trained was manufactured in
+					 *   any TSMC28 process node.
+					 *   0x0 = otherwise, when not training a TSMC28 phy, leave
+					 *   this field as 0.
+					 */
+	uint8_t msgmisc;		/*
+					 * Byte offset 0x01, CSR Addr 0x54000, Direction=In
+					 * Contains various global options for training.
+					 *
+					 * Bit fields:
+					 *
+					 * msgmisc[0] = MTESTEnable
+					 *   0x1 = Pulse primary digital test output bump at the end
+					 *   of each major training stage. This enables observation
+					 *   of training stage completion by observing the digital
+					 *   test output.
+					 *   0x0 = Do not pulse primary digital test output bump
+					 *
+					 * msgmisc[1] = SimulationOnlyReset
+					 *   0x1 = Verilog only simulation option to shorten
+					 *   duration of DRAM reset pulse length to 1ns.
+					 *   Must never be set to 1 in silicon.
+					 *   0x0 = Use reset pulse length specifed by JEDEC standard
+					 *
+					 * msgmisc[2] = SimulationOnlyTraining
+					 *   0x1 = Verilog only simulation option to shorten the
+					 *   duration of the training steps by performing fewer
+					 *   iterations.
+					 *   Must never be set to 1 in silicon.
+					 *   0x0 = Use standard training duration.
+					 *
+					 * msgmisc[3] = RFU, must be zero
+					 *   0x1 = Program user characterized Vref DQ values per
+					 *   DDR4 DRAM device. The message block vrefdqr*nib* fields
+					 *   must be populated with the desired per device Vref DQs
+					 *   when using this option. Note: this option is not
+					 *   applicable in 2D training because these values are
+					 *   explicitly trained in 2D.
+					 *   0x0 = Program Vref DQ for all DDR4 devices with the
+					 *   single value provided in mr6 message block field
+					 *
+					 * msgmisc[4] = Suppress streaming messages, including
+					 * assertions, regardless of hdtctrl setting.
+					 * Stage Completion messages, as well as training completion
+					 * and error messages are still sent depending on hdtctrl
+					 * setting.
+					 *
+					 * msgmisc[5] = PerByteMaxRdLat
+					 *   0x1 = Each DBYTE will return dfi_rddata_valid at the
+					 *   lowest possible latency. This may result in unaligned
+					 *   data between bytes to be returned to the DFI.
+					 *   0x0 = Every DBYTE will return dfi_rddata_valid
+					 *   simultaneously. This will ensure that data bytes will
+					 *   return aligned accesses to the DFI.
+					 *
+					 * msgmisc[6] = PartialRank (DDR3 UDIMM and DDR4 UDIMM only,
+					 * otherwise RFU, must be zero)
+					 *   0x1 = Support rank populated with a subset of byte, but
+					 *   where even-odd pair of rank support all the byte
+					 *   0x0 = All rank populated with all the byte (tyical
+					 *   configuration)
+					 *
+					 * msgmisc[7] RFU, must be zero
+					 *
+					 * Notes:
+					 *
+					 * - SimulationOnlyReset and SimulationOnlyTraining can be
+					 *   used to speed up simulation run times, and must never
+					 *   be used in real silicon. Some VIPs may have checks on
+					 *   DRAM reset parameters that may need to be disabled when
+					 *   using SimulationOnlyReset.
+					 */
+	uint16_t pmurevision;		/*
+					 * Byte offset 0x02, CSR Addr 0x54001, Direction=Out
+					 * PMU firmware revision ID
+					 * After training is run, this address will contain the
+					 * revision ID of the firmware.
+					 * Please reference this revision ID when filing support
+					 * cases.
+					 */
+	uint8_t pstate;			/*
+					 * Byte offset 0x04, CSR Addr 0x54002, Direction=In
+					 * Must be set to the target pstate to be trained
+					 *   0x0 = pstate 0
+					 *   0x1 = pstate 1
+					 *   0x2 = pstate 2
+					 *   0x3 = pstate 3
+					 *   All other encodings are reserved
+					 */
+	uint8_t pllbypassen;		/*
+					 * Byte offset 0x05, CSR Addr 0x54002, Direction=In
+					 * Set according to whether target pstate uses PHY PLL
+					 * bypass
+					 *   0x0 = PHY PLL is enabled for target pstate
+					 *   0x1 = PHY PLL is bypassed for target pstate
+					 */
+	uint16_t dramfreq;		/*
+					 * Byte offset 0x06, CSR Addr 0x54003, Direction=In
+					 * DDR data rate for the target pstate in units of MT/s.
+					 * For example enter 0x0640 for DDR1600.
+					 */
+	uint8_t dfifreqratio;		/*
+					 * Byte offset 0x08, CSR Addr 0x54004, Direction=In
+					 * Frequency ratio betwen DfiCtlClk and SDRAM memclk.
+					 *   0x1 = 1:1
+					 *   0x2 = 1:2
+					 *   0x4 = 1:4
+					 */
+	uint8_t bpznresval;		/*
+					 * Byte offset 0x09, CSR Addr 0x54004, Direction=In
+					 * Must be programmed to match the precision resistor
+					 * connected to Phy BP_ZN
+					 *   0x00 = Do not program. Use current CSR value.
+					 *   0xf0 = 240 Ohm (recommended value)
+					 *   0x78 = 120 Ohm
+					 *   0x28 = 40 Ohm
+					 *   All other values are reserved.
+					 *
+					 */
+	uint8_t phyodtimpedance;	/*
+					 * Byte offset 0x0a, CSR Addr 0x54005, Direction=In
+					 * Must be programmed to the termination impedance in ohms
+					 * used by PHY during reads.
+					 *
+					 * 0x0 = Firmware skips programming (must be manually
+					 * programmed by user prior to training start)
+					 *
+					 * See PHY databook for legal termination impedance values.
+					 *
+					 * For digital simulation, any legal value can be used. For
+					 * silicon, the users must determine the correct value
+					 * through SI simulation or other methods.
+					 */
+	uint8_t phydrvimpedance;	/*
+					 * Byte offset 0x0b, CSR Addr 0x54005, Direction=In
+					 * Must be programmed to the driver impedance in ohms used
+					 * by PHY during writes for all DBYTE drivers
+					 * (DQ/DM/DBI/DQS).
+					 *
+					 *   0x0 = Firmware skips programming (must be manually
+					 *   programmed by user prior to training start)
+					 *
+					 * See PHY databook for legal R_on driver impedance values.
+					 *
+					 * For digital simulation, any value can be used that is not
+					 * Hi-Z. For silicon, the users must determine the correct
+					 * value through SI simulation or other methods.
+					 */
+	uint8_t phyvref;		/*
+					 * Byte offset 0x0c, CSR Addr 0x54006, Direction=In
+					 * Must be programmed with the Vref level to be used by the
+					 * PHY during reads
+					 *
+					 * The units of this field are a percentage of VDDQ
+					 * according to the following equation:
+					 *
+					 * Receiver Vref = VDDQ*phyvref[6:0]/128
+					 *
+					 * For example to set Vref at 0.75*VDDQ, set this field to
+					 * 0x60.
+					 *
+					 * For digital simulation, any legal value can be used. For
+					 * silicon, the users must calculate the analytical Vref by
+					 * using the impedances, terminations, and series resistance
+					 * present in the system.
+					 */
+	uint8_t dramtype;		/*
+					 * Byte offset 0x0d, CSR Addr 0x54006, Direction=In
+					 * Module Type:
+					 *   0x01 = Reserved
+					 *   0x02 = DDR4 unbuffered
+					 *   0x03 = Reserved
+					 *   0x04 = Reserved
+					 *   0x05 = Reserved
+					 */
+	uint8_t disableddbyte;		/*
+					 * Byte offset 0x0e, CSR Addr 0x54007, Direction=In
+					 * Bitmap to indicate which Dbyte are not connected (for
+					 * DByte 0 to 7):
+					 * Set disableddbyte[i] to 1 only to specify that DByte is
+					 * not need to be trained (DByte 8 can be disabled via
+					 * enableddqs setting)
+					 */
+	uint8_t enableddqs;		/*
+					 * Byte offset 0x0f, CSR Addr 0x54007, Direction=In
+					 * Total number of DQ bits enabled in PHY
+					 */
+	uint8_t cspresent;		/*
+					 * Byte offset 0x10, CSR Addr 0x54008, Direction=In
+					 * Indicates presence of DRAM at each chip select for PHY.
+					 * Each bit corresponds to a logical CS.
+					 *
+					 * If the bit is set to 1, the CS is connected to DRAM.
+					 * If the bit is set to 0, the CS is not connected to DRAM.
+					 *
+					 * cspresent[0] = CS0 is populated with DRAM
+					 * cspresent[1] = CS1 is populated with DRAM
+					 * cspresent[2] = CS2 is populated with DRAM
+					 * cspresent[3] = CS3 is populated with DRAM
+					 * cspresent[7:4] = Reserved (must be programmed to 0)
+					 */
+	uint8_t cspresentd0;		/*
+					 * Byte offset 0x11, CSR Addr 0x54008, Direction=In
+					 * The CS signals from field cspresent that are routed to
+					 * DIMM connector 0
+					 */
+	uint8_t cspresentd1;		/*
+					 * Byte offset 0x12, CSR Addr 0x54009, Direction=In
+					 * The CS signals from field cspresent that are routed to
+					 * DIMM connector 1
+					 */
+	uint8_t addrmirror;		/*
+					 * Byte offset 0x13, CSR Addr 0x54009, Direction=In
+					 * Corresponds to CS[3:0]
+					 *   1 = Address Mirror.
+					 *   0 = No Address Mirror.
+					 */
+	uint8_t cstestfail;		/*
+					 * Byte offset 0x14, CSR Addr 0x5400a, Direction=Out
+					 * This field will be set if training fails on any rank.
+					 *   0x0 = No failures
+					 *   non-zero = one or more ranks failed training
+					 */
+	uint8_t phycfg;			/*
+					 * Byte offset 0x15, CSR Addr 0x5400a, Direction=In
+					 * Additional mode bits.
+					 *
+					 * Bit fields:
+					 * [0] SlowAccessMode:
+					 *   1 = 2T Address Timing.
+					 *   0 = 1T Address Timing.
+					 * [7-1] RFU, must be zero
+					 *
+					 * WARNING: In case of DDR4 Geardown Mode (mr3[A3] == 1),
+					 * phycfg[0] must be 0.
+					 */
+	uint16_t sequencectrl;		/*
+					 * Byte offset 0x16, CSR Addr 0x5400b, Direction=In
+					 * Controls the training steps to be run. Each bit
+					 * corresponds to a training step.
+					 *
+					 * If the bit is set to 1, the training step will run.
+					 * If the bit is set to 0, the training step will be
+					 * skipped.
+					 *
+					 * Training step to bit mapping:
+					 * sequencectrl[0] = Run DevInit - Device/phy
+					 *		     initialization. Should always be set.
+					 * sequencectrl[1] = Run WrLvl - Write leveling
+					 * sequencectrl[2] = Run RxEn - Read gate training
+					 * sequencectrl[3] = Run RdDQS1D - 1d read dqs training
+					 * sequencectrl[4] = Run WrDQ1D - 1d write dq training
+					 * sequencectrl[5] = RFU, must be zero
+					 * sequencectrl[6] = RFU, must be zero
+					 * sequencectrl[7] = RFU, must be zero
+					 * sequencectrl[8] = Run RdDeskew - Per lane read dq deskew
+					 *		     training
+					 * sequencectrl[9] = Run MxRdLat - Max read latency training
+					 * sequencectrl[10] = Run Reserved
+					 * sequencectrl[11] = Run Reserved
+					 * sequencectrl[12] = Run Reserved
+					 * sequencectrl[13] = Run Reserved
+					 * sequencectrl[15-14] = RFU, must be zero
+					 */
+	uint8_t hdtctrl;		/*
+					 * Byte offset 0x18, CSR Addr 0x5400c, Direction=In
+					 * To control the total number of debug messages, a
+					 * verbosity subfield (hdtctrl, Hardware Debug Trace
+					 * Control) exists in the message block. Every message has a
+					 * verbosity level associated with it, and as the hdtctrl
+					 * value is increased, less important s messages stop being
+					 * sent through the mailboxes. The meanings of several major
+					 * hdtctrl thresholds are explained below:
+					 *
+					 *   0x04 = Maximal debug messages (e.g., Eye contours)
+					 *   0x05 = Detailed debug messages (e.g. Eye delays)
+					 *   0x0A = Coarse debug messages (e.g. rank information)
+					 *   0xC8 = Stage completion
+					 *   0xC9 = Assertion messages
+					 *   0xFF = Firmware completion messages only
+					 *
+					 * See Training App Note for more detailed information on
+					 * what messages are included for each threshold.
+					 */
+	uint8_t reserved19;		/* Byte offset 0x19, CSR Addr 0x5400c, Direction=N/A */
+	uint8_t reserved1a;		/* Byte offset 0x1a, CSR Addr 0x5400d, Direction=N/A */
+	uint8_t share2dvrefresult;	/*
+					 * Byte offset 0x1b, CSR Addr 0x5400d, Direction=In
+					 * Bitmap that designates the phy's vref source for every
+					 * pstate
+					 * If share2dvrefresult[x] = 0, then after 2D training,
+					 * pstate x will continue using the phyVref provided in
+					 * pstate x's 1D messageblock.
+					 * If share2dvrefresult[x] = 1, then after 2D training,
+					 * pstate x will use the per-lane VrefDAC0/1 CSRs trained by
+					 * 2d training.
+					 */
+	uint8_t reserved1c;		/* Byte offset 0x1c, CSR Addr 0x5400e, Direction=N/A */
+	uint8_t reserved1d;		/* Byte offset 0x1d, CSR Addr 0x5400e, Direction=N/A */
+	uint8_t reserved1e;		/*
+					 * Byte offset 0x1e, CSR Addr 0x5400f, Direction=In
+					 * Input for constraining the range of vref(DQ) values
+					 * training will collect data for, usually reducing training
+					 * time. However, too large of a voltage range may cause
+					 * longer 2D training times while too small of a voltage
+					 * range may truncate passing regions. When in doubt, leave
+					 * this field set to 0.
+					 * Used by 2D training in: Rd2D, Wr2D
+					 *
+					 * reserved1E[0-3]: Rd2D Voltage Range
+					 *   0 = Training will search all phy vref(DQ) settings
+					 *   1 = limit to +/-2 %VDDQ from phyVref
+					 *   2 = limit to +/-4 %VDDQ from phyVref
+					 *     . . .
+					 *   15 = limit to +/-30% VDDQ from phyVref
+					 *
+					 * reserved1E[4-7]: Wr2D Voltage Range
+					 *   0 = Training will search all dram vref(DQ) settings
+					 *   1 = limit to +/-2 %VDDQ from mr6
+					 *   2 = limit to +/-4 %VDDQ from mr6
+					 *     . . .
+					 *   15 = limit to +/-30% VDDQ from mr6
+					 */
+	uint8_t reserved1f;		/*
+					 * Byte offset 0x1f, CSR Addr 0x5400f, Direction=In
+					 * Extended training option:
+					 *
+					 * reserved1F[1:0]: Configured RxClkDly offset try during
+					 * WrDq1D high-effort (i.e., when reserved00[6] is set)
+					 *   0: -8, +8, -16, +16
+					 *   1: -4, +4, -8, +8, -12, +12, -16, +16
+					 *   2: -2, +2, -4, +4, -6, +6, -8, +8
+					 *   3: -2, +2, -4, +4, -6, +6, -8, +8, -10, +10, -12, +12,
+					 *      -14, +14, -16, +16
+					 *
+					 * reserved1F[2]: When set, execute again WrDq1D after
+					 * RdDqs1D PRBS
+					 * reserved1F[3]: When set redo RdDeskew with PRBS after
+					 * (first) WrDqs1D
+					 * reserved1F[7:4]: This field is reserved and must be
+					 * programmed to 0x00.
+					 */
+	uint8_t reserved20;		/*
+					 * Byte offset 0x20, CSR Addr 0x54010, Direction=In
+					 * This field is reserved and must be programmed to 0x00,
+					 * excepted for Reserved:
+					 * Reserved MREP assume raising edge is found when
+					 * reserved20[3:0]+3 consecutive 1 are received during MREP
+					 * fine delay swept; reserved20[6:0] thus permits to
+					 * increase tolerance for noisy system. And if reserved20[7]
+					 * is set, MREP training is failing if no raising edge is
+					 * found (otherwise the raising edge is assume close to
+					 * delay 0).
+					 */
+	uint8_t reserved21;		/*
+					 * Byte offset 0x21, CSR Addr 0x54010, Direction=In
+					 * This field is reserved and must be programmed to 0x00,
+					 * excepted for Reserved:
+					 * Reserved DWL assume raising edge is found when
+					 * reserved21[3:0]+3 consecutive 1 are received during DWL
+					 * fine delay swept; reserved21[6:0] thus permits to
+					 * increase tolerance for noisy system. And if reserved21[7]
+					 * is set, DWL training is failing if no raising edge is
+					 * found (otherwise the raising edge is assume close to
+					 * delay 0).
+					 */
+	uint16_t phyconfigoverride;	/*
+					 * Byte offset 0x22, CSR Addr 0x54011, Direction=In
+					 * Override PhyConfig csr.
+					 *   0x0: Use hardware csr value for PhyConfing
+					 *   (recommended)
+					 *   Other values: Use value for PhyConfig instead of
+					 *   Hardware value.
+					 */
+	uint8_t dfimrlmargin;		/*
+					 * Byte offset 0x24, CSR Addr 0x54012, Direction=In
+					 * Margin added to smallest passing trained DFI Max Read
+					 * Latency value, in units of DFI clocks. Recommended to be
+					 * >= 1. See the Training App Note for more details on the
+					 * training process and the use of this value.
+					 */
+	int8_t cdd_rr_3_2;		/*
+					 * Byte offset 0x25, CSR Addr 0x54012, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 3 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_3_1;		/*
+					 * Byte offset 0x26, CSR Addr 0x54013, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 3 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_3_0;		/*
+					 * Byte offset 0x27, CSR Addr 0x54013, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 3 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_2_3;		/*
+					 * Byte offset 0x28, CSR Addr 0x54014, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 2 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_2_1;		/*
+					 * Byte offset 0x29, CSR Addr 0x54014, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 2 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_2_0;		/*
+					 * Byte offset 0x2a, CSR Addr 0x54015, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 2 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_1_3;		/*
+					 * Byte offset 0x2b, CSR Addr 0x54015, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 1 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_1_2;		/*
+					 * Byte offset 0x2c, CSR Addr 0x54016, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 1 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_1_0;		/*
+					 * Byte offset 0x2d, CSR Addr 0x54016, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 1 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_0_3;		/*
+					 * Byte offset 0x2e, CSR Addr 0x54017, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 0 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_0_2;		/*
+					 * Byte offset 0x2f, CSR Addr 0x54017, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 0 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rr_0_1;		/*
+					 * Byte offset 0x30, CSR Addr 0x54018, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 0 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_3_2;		/*
+					 * Byte offset 0x31, CSR Addr 0x54018, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 3 to cs
+					 * 2. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_3_1;		/*
+					 * Byte offset 0x32, CSR Addr 0x54019, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 3 to cs
+					 * 1. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_3_0;		/*
+					 * Byte offset 0x33, CSR Addr 0x54019, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 3 to cs
+					 * 0. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_2_3;		/*
+					 * Byte offset 0x34, CSR Addr 0x5401a, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 2 to cs
+					 * 3. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_2_1;		/*
+					 * Byte offset 0x35, CSR Addr 0x5401a, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 2 to cs
+					 * 1. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_2_0;		/*
+					 * Byte offset 0x36, CSR Addr 0x5401b, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 2 to cs
+					 * 0. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_1_3;		/*
+					 * Byte offset 0x37, CSR Addr 0x5401b, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 1 to cs
+					 * 3. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_1_2;		/*
+					 * Byte offset 0x38, CSR Addr 0x5401c, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 1 to cs
+					 * 2. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_1_0;		/*
+					 * Byte offset 0x39, CSR Addr 0x5401c, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 1 to cs
+					 * 0. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_0_3;		/*
+					 * Byte offset 0x3a, CSR Addr 0x5401d, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 0 to cs
+					 * 3. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_0_2;		/*
+					 * Byte offset 0x3b, CSR Addr 0x5401d, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 0 to cs
+					 * 2. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_ww_0_1;		/*
+					 * Byte offset 0x3c, CSR Addr 0x5401e, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 0 to cs
+					 * 1. See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_3_3;		/*
+					 * Byte offset 0x3d, CSR Addr 0x5401e, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 3 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_3_2;		/*
+					 * Byte offset 0x3e, CSR Addr 0x5401f, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 3 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_3_1;		/*
+					 * Byte offset 0x3f, CSR Addr 0x5401f, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 3 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_3_0;		/*
+					 * Byte offset 0x40, CSR Addr 0x54020, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 3 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_2_3;		/*
+					 * Byte offset 0x41, CSR Addr 0x54020, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 2 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_2_2;		/*
+					 * Byte offset 0x42, CSR Addr 0x54021, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 2 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_2_1;		/*
+					 * Byte offset 0x43, CSR Addr 0x54021, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 2 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_2_0;		/*
+					 * Byte offset 0x44, CSR Addr 0x54022, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 2 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_1_3;		/*
+					 * Byte offset 0x45, CSR Addr 0x54022, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_1_2;		/*
+					 * Byte offset 0x46, CSR Addr 0x54023, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_1_1;		/*
+					 * Byte offset 0x47, CSR Addr 0x54023, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_1_0;		/*
+					 * Byte offset 0x48, CSR Addr 0x54024, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_0_3;		/*
+					 * Byte offset 0x49, CSR Addr 0x54024, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_0_2;		/*
+					 * Byte offset 0x4a, CSR Addr 0x54025, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_0_1;		/*
+					 * Byte offset 0x4b, CSR Addr 0x54025, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_rw_0_0;		/*
+					 * Byte offset 0x4c, CSR Addr 0x54026, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_3_3;		/*
+					 * Byte offset 0x4d, CSR Addr 0x54026, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 3 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_3_2;		/*
+					 * Byte offset 0x4e, CSR Addr 0x54027, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 3 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_3_1;		/*
+					 * Byte offset 0x4f, CSR Addr 0x54027, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 3 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_3_0;		/*
+					 * Byte offset 0x50, CSR Addr 0x54028, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 3 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_2_3;		/*
+					 * Byte offset 0x51, CSR Addr 0x54028, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 2 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_2_2;		/*
+					 * Byte offset 0x52, CSR Addr 0x54029, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 2 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_2_1;		/*
+					 * Byte offset 0x53, CSR Addr 0x54029, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 2 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_2_0;		/*
+					 * Byte offset 0x54, CSR Addr 0x5402a, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 2 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_1_3;		/*
+					 * Byte offset 0x55, CSR Addr 0x5402a, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_1_2;		/*
+					 * Byte offset 0x56, CSR Addr 0x5402b, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_1_1;		/*
+					 * Byte offset 0x57, CSR Addr 0x5402b, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_1_0;		/*
+					 * Byte offset 0x58, CSR Addr 0x5402c, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_0_3;		/*
+					 * Byte offset 0x59, CSR Addr 0x5402c, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to cs 3
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_0_2;		/*
+					 * Byte offset 0x5a, CSR Addr 0x5402d, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to cs 2
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_0_1;		/*
+					 * Byte offset 0x5b, CSR Addr 0x5402d, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to cs 1
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_wr_0_0;		/*
+					 * Byte offset 0x5c, CSR Addr 0x5402e, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to cs 0
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	uint8_t reserved5d;		/*
+					 * Byte offset 0x5d, CSR Addr 0x5402e, Direction=In
+					 * This field is reserved and must be programmed to 0x00,
+					 * excepted for DDR4:
+					 * By default, if this parameter is 0, the offset applied at
+					 * the end of DDR4 RxEn training resulting in the trained
+					 * RxEnDly is 3/8 of the RX preamble width; if reserved5D is
+					 * non zero, this offset is used instead (in fine step).
+					 */
+	uint16_t mr0;			/*
+					 * Byte offset 0x5e, CSR Addr 0x5402f, Direction=In
+					 * Value of DDR mode register mr0 for all ranks for current
+					 * pstate
+					 */
+	uint16_t mr1;			/*
+					 * Byte offset 0x60, CSR Addr 0x54030, Direction=In
+					 * Value of DDR mode register mr1 for all ranks for current
+					 * pstate
+					 */
+	uint16_t mr2;			/*
+					 * Byte offset 0x62, CSR Addr 0x54031, Direction=In
+					 * Value of DDR mode register mr2 for all ranks for current
+					 * pstate
+					 */
+	uint16_t mr3;			/*
+					 * Byte offset 0x64, CSR Addr 0x54032, Direction=In
+					 * Value of DDR mode register mr3 for all ranks for current
+					 * pstate
+					 */
+	uint16_t mr4;			/*
+					 * Byte offset 0x66, CSR Addr 0x54033, Direction=In
+					 * Value of DDR mode register mr4 for all ranks for current
+					 * pstate
+					 */
+	uint16_t mr5;			/*
+					 * Byte offset 0x68, CSR Addr 0x54034, Direction=In
+					 * Value of DDR mode register mr5 for all ranks for current
+					 * pstate
+					 */
+	uint16_t mr6;			/*
+					 * Byte offset 0x6a, CSR Addr 0x54035, Direction=In
+					 * Value of DDR mode register mr6 for all ranks for current
+					 * pstate. Note: The initial VrefDq value and range must be
+					 * set in A6:A0.
+					 */
+	uint8_t x16present;		/*
+					 * Byte offset 0x6c, CSR Addr 0x54036, Direction=In
+					 * X16 device map. Corresponds to CS[3:0].
+					 * x16present[0] = CS0 is populated with X16 devices
+					 * x16present[1] = CS1 is populated with X16 devices
+					 * x16present[2] = CS2 is populated with X16 devices
+					 * x16present[3] = CS3 is populated with X16 devices
+					 * x16present[7:4] = Reserved (must be programmed to 0)
+					 *
+					 * Ranks may not contain mixed device types.
+					 */
+	uint8_t cssetupgddec;		/*
+					 * Byte offset 0x6d, CSR Addr 0x54036, Direction=In
+					 * controls timing of chip select signals when DDR4
+					 * gear-down mode is active
+					 *   0 - Leave delay of chip select timing group signal
+					 *   the same both before and after gear-down sync occurs
+					 *   1 - Add 1UI of delay to chip select timing group
+					 *   signals when geardown-mode is active. This allows CS
+					 *   signals to have equal setup and hold time in gear-down
+					 *   mode
+					 */
+	uint16_t rtt_nom_wr_park0;	/*
+					 * Byte offset 0x6e, CSR Addr 0x54037, Direction=In
+					 * Optional RTT_NOM, RTT_WR and RTT_PARK values for rank 0
+					 * DRAM:
+					 * rtt_nom_wr_park0[0] = 1: Option is enable (otherwise,
+					 * remaining bit fields are don't care)
+					 * rtt_nom_wr_park0[5:3]: Optional RTT_NOM value to be used
+					 * in mr1[10:8] for rank 0
+					 * rtt_nom_wr_park0[11:9]: Optional RTT_WR value to be used
+					 * in mr2[11:9] for rank 0
+					 * rtt_nom_wr_park0[8:6]: Optional RTT_PARK value to be used
+					 * in mr5[8:6] for rank 0
+					 */
+	uint16_t rtt_nom_wr_park1;	/*
+					 * Byte offset 0x70, CSR Addr 0x54038, Direction=In
+					 * Optional RTT_NOM, RTT_WR and RTT_PARK values for rank 1
+					 * DRAM:
+					 * rtt_nom_wr_park1[0] = 1: Option is enable (otherwise,
+					 * remaining bit fields are don't care)
+					 * rtt_nom_wr_park1[5:3]: Optional RTT_NOM value to be used
+					 * in mr1[10:8] for rank 1
+					 * rtt_nom_wr_park1[11:9]: Optional RTT_WR value to be used
+					 * in mr2[11:9] for rank 1
+					 * rtt_nom_wr_park1[8:6]: Optional RTT_PARK value to be used
+					 * in mr5[8:6] for rank 1
+					 */
+	uint16_t rtt_nom_wr_park2;	/*
+					 * Byte offset 0x72, CSR Addr 0x54039, Direction=In
+					 * Optional RTT_NOM, RTT_WR and RTT_PARK values for rank 2
+					 * DRAM:
+					 * rtt_nom_wr_park2[0] = 1: Option is enable (otherwise,
+					 * remaining bit fields are don't care)
+					 * rtt_nom_wr_park2[5:3]: Optional RTT_NOM value to be used
+					 * in mr1[10:8] for rank 2
+					 * rtt_nom_wr_park2[11:9]: Optional RTT_WR value to be used
+					 * in mr2[11:9] for rank 2
+					 * rtt_nom_wr_park2[8:6]: Optional RTT_PARK value to be used
+					 * in mr5[8:6] for rank 2
+					 */
+	uint16_t rtt_nom_wr_park3;	/*
+					 * Byte offset 0x74, CSR Addr 0x5403a, Direction=In
+					 * Optional RTT_NOM, RTT_WR and RTT_PARK values for rank 3
+					 * DRAM:
+					 * rtt_nom_wr_park3[0] = 1: Option is enable (otherwise,
+					 * remaining bit fields are don't care)
+					 * rtt_nom_wr_park3[5:3]: Optional RTT_NOM value to be used
+					 * in mr1[10:8] for rank 3
+					 * rtt_nom_wr_park3[11:9]: Optional RTT_WR value to be used
+					 * in mr2[11:9] for rank 3
+					 * rtt_nom_wr_park3[8:6]: Optional RTT_PARK value to be used
+					 * in mr5[8:6] for rank 3
+					 */
+	uint16_t rtt_nom_wr_park4;	/*
+					 * Byte offset 0x76, CSR Addr 0x5403b, Direction=In
+					 * Optional RTT_NOM, RTT_WR and RTT_PARK values for rank 4
+					 * DRAM:
+					 * rtt_nom_wr_park4[0] = 1: Option is enable (otherwise,
+					 * remaining bit fields are don't care)
+					 * rtt_nom_wr_park4[5:3]: Optional RTT_NOM value to be used
+					 * in mr1[10:8] for rank 4
+					 * rtt_nom_wr_park4[11:9]: Optional RTT_WR value to be used
+					 * in mr2[11:9] for rank 4
+					 * rtt_nom_wr_park4[8:6]: Optional RTT_PARK value to be used
+					 * in mr5[8:6] for rank 4
+					 */
+	uint16_t rtt_nom_wr_park5;	/*
+					 * Byte offset 0x78, CSR Addr 0x5403c, Direction=In
+					 * Optional RTT_NOM, RTT_WR and RTT_PARK values for rank 5
+					 * DRAM:
+					 * rtt_nom_wr_park5[0] = 1: Option is enable (otherwise,
+					 * remaining bit fields are don't care)
+					 * rtt_nom_wr_park5[5:3]: Optional RTT_NOM value to be used
+					 * in mr1[10:8] for rank 5
+					 * rtt_nom_wr_park5[11:9]: Optional RTT_WR value to be used
+					 * in mr2[11:9] for rank 5
+					 * rtt_nom_wr_park5[8:6]: Optional RTT_PARK value to be used
+					 * in mr5[8:6] for rank 5
+					 */
+	uint16_t rtt_nom_wr_park6;	/*
+					 * Byte offset 0x7a, CSR Addr 0x5403d, Direction=In
+					 * Optional RTT_NOM, RTT_WR and RTT_PARK values for rank 6
+					 * DRAM:
+					 * rtt_nom_wr_park6[0] = 1: Option is enable (otherwise,
+					 * remaining bit fields are don't care)
+					 * rtt_nom_wr_park6[5:3]: Optional RTT_NOM value to be used
+					 * in mr1[10:8] for rank 6
+					 * rtt_nom_wr_park6[11:9]: Optional RTT_WR value to be used
+					 * in mr2[11:9] for rank 6
+					 * rtt_nom_wr_park6[8:6]: Optional RTT_PARK value to be used
+					 * in mr5[8:6] for rank 6
+					 */
+	uint16_t rtt_nom_wr_park7;	/*
+					 * Byte offset 0x7c, CSR Addr 0x5403e, Direction=In
+					 * Optional RTT_NOM, RTT_WR and RTT_PARK values for rank 7
+					 * DRAM:
+					 * rtt_nom_wr_park7[0] = 1: Option is enable (otherwise,
+					 * remaining bit fields are don't care)
+					 * rtt_nom_wr_park7[5:3]: Optional RTT_NOM value to be used
+					 * in mr1[10:8] for rank 7
+					 * rtt_nom_wr_park7[11:9]: Optional RTT_WR value to be used
+					 * in mr2[11:9] for rank 7
+					 * rtt_nom_wr_park7[8:6]: Optional RTT_PARK value to be used
+					 * in mr5[8:6] for rank 7
+					 */
+	uint8_t acsmodtctrl0;		/*
+					 * Byte offset 0x7e, CSR Addr 0x5403f, Direction=In
+					 * Odt pattern for accesses targeting rank 0. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl1;		/*
+					 * Byte offset 0x7f, CSR Addr 0x5403f, Direction=In
+					 * Odt pattern for accesses targeting rank 1. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl2;		/*
+					 * Byte offset 0x80, CSR Addr 0x54040, Direction=In
+					 * Odt pattern for accesses targeting rank 2. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl3;		/*
+					 * Byte offset 0x81, CSR Addr 0x54040, Direction=In
+					 * Odt pattern for accesses targeting rank 3. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl4;		/*
+					 * Byte offset 0x82, CSR Addr 0x54041, Direction=In
+					 * Odt pattern for accesses targeting rank 4. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl5;		/*
+					 * Byte offset 0x83, CSR Addr 0x54041, Direction=In
+					 * Odt pattern for accesses targeting rank 5. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl6;		/*
+					 * Byte offset 0x84, CSR Addr 0x54042, Direction=In
+					 * Odt pattern for accesses targeting rank 6. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl7;		/*
+					 * Byte offset 0x85, CSR Addr 0x54042, Direction=In
+					 * Odt pattern for accesses targeting rank 7. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t vrefdqr0nib0;		/*
+					 * Byte offset 0x86, CSR Addr 0x54043, Direction=InOut
+					 * VrefDq for rank 0 nibble 0. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr0nib1;		/*
+					 * Byte offset 0x87, CSR Addr 0x54043, Direction=InOut
+					 * VrefDq for rank 0 nibble 1. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib0 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr0nib2;		/*
+					 * Byte offset 0x88, CSR Addr 0x54044, Direction=InOut
+					 * VrefDq for rank 0 nibble 2. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib0 for x16 devices.
+					 */
+	uint8_t vrefdqr0nib3;		/*
+					 * Byte offset 0x89, CSR Addr 0x54044, Direction=InOut
+					 * VrefDq for rank 0 nibble 3. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib0 for x16 devices, or
+					 * vrefdqr0nib2 for x8 devices.
+					 */
+	uint8_t vrefdqr0nib4;		/*
+					 * Byte offset 0x8a, CSR Addr 0x54045, Direction=InOut
+					 * VrefDq for rank 0 nibble 4. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr0nib5;		/*
+					 * Byte offset 0x8b, CSR Addr 0x54045, Direction=InOut
+					 * VrefDq for rank 0 nibble 5. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib4 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr0nib6;		/*
+					 * Byte offset 0x8c, CSR Addr 0x54046, Direction=InOut
+					 * VrefDq for rank 0 nibble 6. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib4 for x16 devices.
+					 */
+	uint8_t vrefdqr0nib7;		/*
+					 * Byte offset 0x8d, CSR Addr 0x54046, Direction=InOut
+					 * VrefDq for rank 0 nibble 7. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib4 for x16 devices,
+					 * or vrefdqr0nib6 for x8 devices.
+					 */
+	uint8_t vrefdqr0nib8;		/*
+					 * Byte offset 0x8e, CSR Addr 0x54047, Direction=InOut
+					 * VrefDq for rank 0 nibble 8. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr0nib9;		/*
+					 * Byte offset 0x8f, CSR Addr 0x54047, Direction=InOut
+					 * VrefDq for rank 0 nibble 9. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib8 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr0nib10;		/*
+					 * Byte offset 0x90, CSR Addr 0x54048, Direction=InOut
+					 * VrefDq for rank 0 nibble 10. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib8 for x16 devices.
+					 */
+	uint8_t vrefdqr0nib11;		/*
+					 * Byte offset 0x91, CSR Addr 0x54048, Direction=InOut
+					 * VrefDq for rank 0 nibble 11. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib8 for x16 devices,
+					 * or vrefdqr0nib10 for x8 devices.
+					 */
+	uint8_t vrefdqr0nib12;		/*
+					 * Byte offset 0x92, CSR Addr 0x54049, Direction=InOut
+					 * VrefDq for rank 0 nibble 12. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr0nib13;		/*
+					 * Byte offset 0x93, CSR Addr 0x54049, Direction=InOut
+					 * VrefDq for rank 0 nibble 13. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib12 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr0nib14;		/*
+					 * Byte offset 0x94, CSR Addr 0x5404a, Direction=InOut
+					 * VrefDq for rank 0 nibble 14. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib12 for x16 devices.
+					 */
+	uint8_t vrefdqr0nib15;		/*
+					 * Byte offset 0x95, CSR Addr 0x5404a, Direction=InOut
+					 * VrefDq for rank 0 nibble 15. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib12 for x16 devices,
+					 * or vrefdqr0nib14 for x8 devices.
+					 */
+	uint8_t vrefdqr0nib16;		/*
+					 * Byte offset 0x96, CSR Addr 0x5404b, Direction=InOut
+					 * VrefDq for rank 0 nibble 16. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr0nib17;		/*
+					 * Byte offset 0x97, CSR Addr 0x5404b, Direction=InOut
+					 * VrefDq for rank 0 nibble 17. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib16 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr0nib18;		/*
+					 * Byte offset 0x98, CSR Addr 0x5404c, Direction=InOut
+					 * VrefDq for rank 0 nibble 18. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib16 for x16 devices.
+					 */
+	uint8_t vrefdqr0nib19;		/*
+					 * Byte offset 0x99, CSR Addr 0x5404c, Direction=InOut
+					 * VrefDq for rank 0 nibble 19. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib16 for x16 devices,
+					 * or vrefdqr0nib18 for x8 devices.
+					 */
+	uint8_t vrefdqr1nib0;		/*
+					 * Byte offset 0x9a, CSR Addr 0x5404d, Direction=InOut
+					 * VrefDq for rank 1 nibble 0. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr1nib1;		/*
+					 * Byte offset 0x9b, CSR Addr 0x5404d, Direction=InOut
+					 * VrefDq for rank 1 nibble 1. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib0 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr1nib2;		/*
+					 * Byte offset 0x9c, CSR Addr 0x5404e, Direction=InOut
+					 * VrefDq for rank 1 nibble 2. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib0 for x16 devices.
+					 */
+	uint8_t vrefdqr1nib3;		/*
+					 * Byte offset 0x9d, CSR Addr 0x5404e, Direction=InOut
+					 * VrefDq for rank 1 nibble 3. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib0 for x16 devices,
+					 * or vrefdqr1nib2 for x8 devices.
+					 */
+	uint8_t vrefdqr1nib4;		/*
+					 * Byte offset 0x9e, CSR Addr 0x5404f, Direction=InOut
+					 * VrefDq for rank 1 nibble 4. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr1nib5;		/*
+					 * Byte offset 0x9f, CSR Addr 0x5404f, Direction=InOut
+					 * VrefDq for rank 1 nibble 5. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib4 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr1nib6;		/*
+					 * Byte offset 0xa0, CSR Addr 0x54050, Direction=InOut
+					 * VrefDq for rank 1 nibble 6. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib4 for x16 devices.
+					 */
+	uint8_t vrefdqr1nib7;		/*
+					 * Byte offset 0xa1, CSR Addr 0x54050, Direction=InOut
+					 * VrefDq for rank 1 nibble 7. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib4 for x16 devices,
+					 * or vrefdqr1nib6 for x8 devices.
+					 */
+	uint8_t vrefdqr1nib8;		/*
+					 * Byte offset 0xa2, CSR Addr 0x54051, Direction=InOut
+					 * VrefDq for rank 1 nibble 8. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr1nib9;		/*
+					 * Byte offset 0xa3, CSR Addr 0x54051, Direction=InOut
+					 * VrefDq for rank 1 nibble 9. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib8 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr1nib10;		/*
+					 * Byte offset 0xa4, CSR Addr 0x54052, Direction=InOut
+					 * VrefDq for rank 1 nibble 10. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib8 for x16 devices.
+					 */
+	uint8_t vrefdqr1nib11;		/*
+					 * Byte offset 0xa5, CSR Addr 0x54052, Direction=InOut
+					 * VrefDq for rank 1 nibble 11. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib8 for x16 devices,
+					 * or vrefdqr1nib10 for x8 devices.
+					 */
+	uint8_t vrefdqr1nib12;		/*
+					 * Byte offset 0xa6, CSR Addr 0x54053, Direction=InOut
+					 * VrefDq for rank 1 nibble 12. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr1nib13;		/*
+					 * Byte offset 0xa7, CSR Addr 0x54053, Direction=InOut
+					 * VrefDq for rank 1 nibble 13. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib12 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr1nib14;		/*
+					 * Byte offset 0xa8, CSR Addr 0x54054, Direction=InOut
+					 * VrefDq for rank 1 nibble 14. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib12 for x16 devices.
+					 */
+	uint8_t vrefdqr1nib15;		/*
+					 * Byte offset 0xa9, CSR Addr 0x54054, Direction=InOut
+					 * VrefDq for rank 1 nibble 15. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib12 for x16 devices,
+					 * or vrefdqr1nib14 for x8 devices.
+					 */
+	uint8_t vrefdqr1nib16;		/*
+					 * Byte offset 0xaa, CSR Addr 0x54055, Direction=InOut
+					 * VrefDq for rank 1 nibble 16. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr1nib17;		/*
+					 * Byte offset 0xab, CSR Addr 0x54055, Direction=InOut
+					 * VrefDq for rank 1 nibble 17. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib16 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr1nib18;		/*
+					 * Byte offset 0xac, CSR Addr 0x54056, Direction=InOut
+					 * VrefDq for rank 1 nibble 18. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib16 for x16 devices.
+					 */
+	uint8_t vrefdqr1nib19;		/*
+					 * Byte offset 0xad, CSR Addr 0x54056, Direction=InOut
+					 * VrefDq for rank 1 nibble 19. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib16 for x16 devices,
+					 * or vrefdqr1nib18 for x8 devices.
+					 */
+	uint8_t vrefdqr2nib0;		/*
+					 * Byte offset 0xae, CSR Addr 0x54057, Direction=InOut
+					 * VrefDq for rank 2 nibble 0. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr2nib1;		/*
+					 * Byte offset 0xaf, CSR Addr 0x54057, Direction=InOut
+					 * VrefDq for rank 2 nibble 1. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib0 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr2nib2;		/*
+					 * Byte offset 0xb0, CSR Addr 0x54058, Direction=InOut
+					 * VrefDq for rank 2 nibble 2. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib0 for x16 devices.
+					 */
+	uint8_t vrefdqr2nib3;		/*
+					 * Byte offset 0xb1, CSR Addr 0x54058, Direction=InOut
+					 * VrefDq for rank 2 nibble 3. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib0 for x16 devices,
+					 * or vrefdqr2nib2 for x8 devices.
+					 */
+	uint8_t vrefdqr2nib4;		/*
+					 * Byte offset 0xb2, CSR Addr 0x54059, Direction=InOut
+					 * VrefDq for rank 2 nibble 4. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr2nib5;		/*
+					 * Byte offset 0xb3, CSR Addr 0x54059, Direction=InOut
+					 * VrefDq for rank 2 nibble 5. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib4 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr2nib6;		/*
+					 * Byte offset 0xb4, CSR Addr 0x5405a, Direction=InOut
+					 * VrefDq for rank 2 nibble 6. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib4 for x16 devices.
+					 */
+	uint8_t vrefdqr2nib7;		/*
+					 * Byte offset 0xb5, CSR Addr 0x5405a, Direction=InOut
+					 * VrefDq for rank 2 nibble 7. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib4 for x16 devices,
+					 * or vrefdqr2nib6 for x8 devices.
+					 */
+	uint8_t vrefdqr2nib8;		/*
+					 * Byte offset 0xb6, CSR Addr 0x5405b, Direction=InOut
+					 * VrefDq for rank 2 nibble 8. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr2nib9;		/*
+					 * Byte offset 0xb7, CSR Addr 0x5405b, Direction=InOut
+					 * VrefDq for rank 2 nibble 9. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib8 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr2nib10;		/*
+					 * Byte offset 0xb8, CSR Addr 0x5405c, Direction=InOut
+					 * VrefDq for rank 2 nibble 10. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib8 for x16 devices.
+					 */
+	uint8_t vrefdqr2nib11;		/*
+					 * Byte offset 0xb9, CSR Addr 0x5405c, Direction=InOut
+					 * VrefDq for rank 2 nibble 11. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib8 for x16 devices,
+					 * or vrefdqr2nib10 for x8 devices.
+					 */
+	uint8_t vrefdqr2nib12;		/*
+					 * Byte offset 0xba, CSR Addr 0x5405d, Direction=InOut
+					 * VrefDq for rank 2 nibble 12. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr2nib13;		/*
+					 * Byte offset 0xbb, CSR Addr 0x5405d, Direction=InOut
+					 * VrefDq for rank 2 nibble 13. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib12 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr2nib14;		/*
+					 * Byte offset 0xbc, CSR Addr 0x5405e, Direction=InOut
+					 * VrefDq for rank 2 nibble 14. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib12 for x16 devices.
+					 */
+	uint8_t vrefdqr2nib15;		/*
+					 * Byte offset 0xbd, CSR Addr 0x5405e, Direction=InOut
+					 * VrefDq for rank 2 nibble 15. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib12 for x16 devices,
+					 * or vrefdqr2nib14 for x8 devices.
+					 */
+	uint8_t vrefdqr2nib16;		/*
+					 * Byte offset 0xbe, CSR Addr 0x5405f, Direction=InOut
+					 * VrefDq for rank 2 nibble 16. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr2nib17;		/*
+					 * Byte offset 0xbf, CSR Addr 0x5405f, Direction=InOut
+					 * VrefDq for rank 2 nibble 17. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib16 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr2nib18;		/*
+					 * Byte offset 0xc0, CSR Addr 0x54060, Direction=InOut
+					 * VrefDq for rank 2 nibble 18. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib16 for x16 devices.
+					 */
+	uint8_t vrefdqr2nib19;		/*
+					 * Byte offset 0xc1, CSR Addr 0x54060, Direction=InOut
+					 * VrefDq for rank 2 nibble 19. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib16 for x16 devices,
+					 * or vrefdqr2nib18 for x8 devices.
+					 */
+	uint8_t vrefdqr3nib0;		/*
+					 * Byte offset 0xc2, CSR Addr 0x54061, Direction=InOut
+					 * VrefDq for rank 3 nibble 0. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr3nib1;		/*
+					 * Byte offset 0xc3, CSR Addr 0x54061, Direction=InOut
+					 * VrefDq for rank 3 nibble 1. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib0 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr3nib2;		/*
+					 * Byte offset 0xc4, CSR Addr 0x54062, Direction=InOut
+					 * VrefDq for rank 3 nibble 2. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib0 for x16 devices.
+					 */
+	uint8_t vrefdqr3nib3;		/*
+					 * Byte offset 0xc5, CSR Addr 0x54062, Direction=InOut
+					 * VrefDq for rank 3 nibble 3. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib0 for x16 devices,
+					 * or vrefdqr3nib2 for x8 devices.
+					 */
+	uint8_t vrefdqr3nib4;		/*
+					 * Byte offset 0xc6, CSR Addr 0x54063, Direction=InOut
+					 * VrefDq for rank 3 nibble 4. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr3nib5;		/*
+					 * Byte offset 0xc7, CSR Addr 0x54063, Direction=InOut
+					 * VrefDq for rank 3 nibble 5. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib4 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr3nib6;		/*
+					 * Byte offset 0xc8, CSR Addr 0x54064, Direction=InOut
+					 * VrefDq for rank 3 nibble 6. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib4 for x16 devices.
+					 */
+	uint8_t vrefdqr3nib7;		/*
+					 * Byte offset 0xc9, CSR Addr 0x54064, Direction=InOut
+					 * VrefDq for rank 3 nibble 7. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib4 for x16 devices,
+					 * or vrefdqr3nib6 for x8 devices.
+					 */
+	uint8_t vrefdqr3nib8;		/*
+					 * Byte offset 0xca, CSR Addr 0x54065, Direction=InOut
+					 * VrefDq for rank 3 nibble 8. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr3nib9;		/*
+					 * Byte offset 0xcb, CSR Addr 0x54065, Direction=InOut
+					 * VrefDq for rank 3 nibble 9. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib8 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr3nib10;		/*
+					 * Byte offset 0xcc, CSR Addr 0x54066, Direction=InOut
+					 * VrefDq for rank 3 nibble 10. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib8 for x16 devices.
+					 */
+	uint8_t vrefdqr3nib11;		/*
+					 * Byte offset 0xcd, CSR Addr 0x54066, Direction=InOut
+					 * VrefDq for rank 3 nibble 11. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib8 for x16 devices,
+					 * or vrefdqr3nib10 for x8 devices.
+					 */
+	uint8_t vrefdqr3nib12;		/*
+					 * Byte offset 0xce, CSR Addr 0x54067, Direction=InOut
+					 * VrefDq for rank 3 nibble 12. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr3nib13;		/*
+					 * Byte offset 0xcf, CSR Addr 0x54067, Direction=InOut
+					 * VrefDq for rank 3 nibble 13. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib12 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr3nib14;		/*
+					 * Byte offset 0xd0, CSR Addr 0x54068, Direction=InOut
+					 * VrefDq for rank 3 nibble 14. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib12 for x16 devices.
+					 */
+	uint8_t vrefdqr3nib15;		/*
+					 * Byte offset 0xd1, CSR Addr 0x54068, Direction=InOut
+					 * VrefDq for rank 3 nibble 15. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib12 for x16 devices,
+					 * or vrefdqr3nib14 for x8 devices.
+					 */
+	uint8_t vrefdqr3nib16;		/*
+					 * Byte offset 0xd2, CSR Addr 0x54069, Direction=InOut
+					 * VrefDq for rank 3 nibble 16. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr3nib17;		/*
+					 * Byte offset 0xd3, CSR Addr 0x54069, Direction=InOut
+					 * VrefDq for rank 3 nibble 17. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib16 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr3nib18;		/*
+					 * Byte offset 0xd4, CSR Addr 0x5406a, Direction=InOut
+					 * VrefDq for rank 3 nibble 18. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib16 for x16 devices.
+					 */
+	uint8_t vrefdqr3nib19;		/*
+					 * Byte offset 0xd5, CSR Addr 0x5406a, Direction=InOut
+					 * VrefDq for rank 3 nibble 19. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib16 for x16 devices,
+					 * or vrefdqr3nib18 for x8 devices.
+					 */
+	uint8_t reservedd6;		/* Byte offset 0xd6, CSR Addr 0x5406b, Direction=N/A */
+	uint8_t reservedd7;		/* Byte offset 0xd7, CSR Addr 0x5406b, Direction=N/A */
+	uint8_t reservedd8;		/* Byte offset 0xd8, CSR Addr 0x5406c, Direction=N/A */
+	uint8_t reservedd9;		/* Byte offset 0xd9, CSR Addr 0x5406c, Direction=N/A */
+	uint8_t reservedda;		/* Byte offset 0xda, CSR Addr 0x5406d, Direction=N/A */
+	uint8_t reserveddb;		/* Byte offset 0xdb, CSR Addr 0x5406d, Direction=N/A */
+	uint8_t reserveddc;		/* Byte offset 0xdc, CSR Addr 0x5406e, Direction=N/A */
+	uint8_t reserveddd;		/* Byte offset 0xdd, CSR Addr 0x5406e, Direction=N/A */
+	uint8_t reservedde;		/* Byte offset 0xde, CSR Addr 0x5406f, Direction=N/A */
+	uint8_t reserveddf;		/* Byte offset 0xdf, CSR Addr 0x5406f, Direction=N/A */
+	uint8_t reservede0;		/* Byte offset 0xe0, CSR Addr 0x54070, Direction=N/A */
+	uint8_t reservede1;		/* Byte offset 0xe1, CSR Addr 0x54070, Direction=N/A */
+	uint8_t reservede2;		/* Byte offset 0xe2, CSR Addr 0x54071, Direction=N/A */
+	uint8_t reservede3;		/* Byte offset 0xe3, CSR Addr 0x54071, Direction=N/A */
+	uint8_t reservede4;		/* Byte offset 0xe4, CSR Addr 0x54072, Direction=N/A */
+	uint8_t reservede5;		/* Byte offset 0xe5, CSR Addr 0x54072, Direction=N/A */
+	uint8_t reservede6;		/* Byte offset 0xe6, CSR Addr 0x54073, Direction=N/A */
+	uint8_t reservede7;		/* Byte offset 0xe7, CSR Addr 0x54073, Direction=N/A */
+	uint8_t reservede8;		/* Byte offset 0xe8, CSR Addr 0x54074, Direction=N/A */
+	uint8_t reservede9;		/* Byte offset 0xe9, CSR Addr 0x54074, Direction=N/A */
+	uint8_t reservedea;		/* Byte offset 0xea, CSR Addr 0x54075, Direction=N/A */
+	uint8_t reservedeb;		/* Byte offset 0xeb, CSR Addr 0x54075, Direction=N/A */
+	uint8_t reservedec;		/* Byte offset 0xec, CSR Addr 0x54076, Direction=N/A */
+	uint8_t reserveded;		/* Byte offset 0xed, CSR Addr 0x54076, Direction=N/A */
+	uint8_t reservedee;		/* Byte offset 0xee, CSR Addr 0x54077, Direction=N/A */
+	uint8_t reservedef;		/* Byte offset 0xef, CSR Addr 0x54077, Direction=N/A */
+	uint8_t reservedf0;		/* Byte offset 0xf0, CSR Addr 0x54078, Direction=N/A */
+	uint8_t reservedf1;		/* Byte offset 0xf1, CSR Addr 0x54078, Direction=N/A */
+	uint8_t reservedf2;		/* Byte offset 0xf2, CSR Addr 0x54079, Direction=N/A */
+	uint8_t reservedf3;		/* Byte offset 0xf3, CSR Addr 0x54079, Direction=N/A */
+	uint8_t reservedf4;		/* Byte offset 0xf4, CSR Addr 0x5407a, Direction=N/A */
+	uint8_t reservedf5;		/* Byte offset 0xf5, CSR Addr 0x5407a, Direction=N/A */
+	uint8_t reservedf6;		/* Byte offset 0xf6, CSR Addr 0x5407b, Direction=N/A */
+	uint8_t reservedf7;		/* Byte offset 0xf7, CSR Addr 0x5407b, Direction=N/A */
+	uint8_t reservedf8;		/* Byte offset 0xf8, CSR Addr 0x5407c, Direction=N/A */
+	uint8_t reservedf9;		/* Byte offset 0xf9, CSR Addr 0x5407c, Direction=N/A */
+	uint8_t reservedfa;		/* Byte offset 0xfa, CSR Addr 0x5407d, Direction=N/A */
+	uint8_t reservedfb;		/* Byte offset 0xfb, CSR Addr 0x5407d, Direction=N/A */
+	uint8_t reservedfc;		/* Byte offset 0xfc, CSR Addr 0x5407e, Direction=N/A */
+	uint8_t reservedfd;		/* Byte offset 0xfd, CSR Addr 0x5407e, Direction=N/A */
+	uint8_t reservedfe;		/* Byte offset 0xfe, CSR Addr 0x5407f, Direction=N/A */
+	uint8_t reservedff;		/* Byte offset 0xff, CSR Addr 0x5407f, Direction=N/A */
+	uint8_t reserved100;		/* Byte offset 0x100, CSR Addr 0x54080, Direction=N/A */
+	uint8_t reserved101;		/* Byte offset 0x101, CSR Addr 0x54080, Direction=N/A */
+	uint8_t reserved102;		/* Byte offset 0x102, CSR Addr 0x54081, Direction=N/A */
+	uint8_t reserved103;		/* Byte offset 0x103, CSR Addr 0x54081, Direction=N/A */
+	uint8_t reserved104;		/* Byte offset 0x104, CSR Addr 0x54082, Direction=N/A */
+	uint8_t reserved105;		/* Byte offset 0x105, CSR Addr 0x54082, Direction=N/A */
+	uint8_t reserved106;		/* Byte offset 0x106, CSR Addr 0x54083, Direction=N/A */
+	uint8_t reserved107;		/* Byte offset 0x107, CSR Addr 0x54083, Direction=N/A */
+	uint8_t reserved108;		/* Byte offset 0x108, CSR Addr 0x54084, Direction=N/A */
+	uint8_t reserved109;		/* Byte offset 0x109, CSR Addr 0x54084, Direction=N/A */
+	uint8_t reserved10a;		/* Byte offset 0x10a, CSR Addr 0x54085, Direction=N/A */
+	uint8_t reserved10b;		/* Byte offset 0x10b, CSR Addr 0x54085, Direction=N/A */
+	uint8_t reserved10c;		/* Byte offset 0x10c, CSR Addr 0x54086, Direction=N/A */
+	uint8_t reserved10d;		/* Byte offset 0x10d, CSR Addr 0x54086, Direction=N/A */
+	uint8_t reserved10e;		/* Byte offset 0x10e, CSR Addr 0x54087, Direction=N/A */
+	uint8_t reserved10f;		/* Byte offset 0x10f, CSR Addr 0x54087, Direction=N/A */
+	uint8_t reserved110;		/* Byte offset 0x110, CSR Addr 0x54088, Direction=N/A */
+	uint8_t reserved111;		/* Byte offset 0x111, CSR Addr 0x54088, Direction=N/A */
+	uint8_t reserved112;		/* Byte offset 0x112, CSR Addr 0x54089, Direction=N/A */
+	uint8_t reserved113;		/* Byte offset 0x113, CSR Addr 0x54089, Direction=N/A */
+	uint8_t reserved114;		/* Byte offset 0x114, CSR Addr 0x5408a, Direction=N/A */
+	uint8_t reserved115;		/* Byte offset 0x115, CSR Addr 0x5408a, Direction=N/A */
+	uint8_t reserved116;		/* Byte offset 0x116, CSR Addr 0x5408b, Direction=N/A */
+	uint8_t reserved117;		/* Byte offset 0x117, CSR Addr 0x5408b, Direction=N/A */
+	uint8_t reserved118;		/* Byte offset 0x118, CSR Addr 0x5408c, Direction=N/A */
+	uint8_t reserved119;		/* Byte offset 0x119, CSR Addr 0x5408c, Direction=N/A */
+	uint8_t reserved11a;		/* Byte offset 0x11a, CSR Addr 0x5408d, Direction=N/A */
+	uint8_t reserved11b;		/* Byte offset 0x11b, CSR Addr 0x5408d, Direction=N/A */
+	uint8_t reserved11c;		/* Byte offset 0x11c, CSR Addr 0x5408e, Direction=N/A */
+	uint8_t reserved11d;		/* Byte offset 0x11d, CSR Addr 0x5408e, Direction=N/A */
+	uint8_t reserved11e;		/* Byte offset 0x11e, CSR Addr 0x5408f, Direction=N/A */
+	uint8_t reserved11f;		/* Byte offset 0x11f, CSR Addr 0x5408f, Direction=N/A */
+	uint8_t reserved120;		/* Byte offset 0x120, CSR Addr 0x54090, Direction=N/A */
+	uint8_t reserved121;		/* Byte offset 0x121, CSR Addr 0x54090, Direction=N/A */
+	uint8_t reserved122;		/* Byte offset 0x122, CSR Addr 0x54091, Direction=N/A */
+	uint8_t reserved123;		/* Byte offset 0x123, CSR Addr 0x54091, Direction=N/A */
+	uint8_t reserved124;		/* Byte offset 0x124, CSR Addr 0x54092, Direction=N/A */
+	uint8_t reserved125;		/* Byte offset 0x125, CSR Addr 0x54092, Direction=N/A */
+	uint8_t reserved126;		/* Byte offset 0x126, CSR Addr 0x54093, Direction=N/A */
+	uint8_t reserved127;		/* Byte offset 0x127, CSR Addr 0x54093, Direction=N/A */
+	uint8_t reserved128;		/* Byte offset 0x128, CSR Addr 0x54094, Direction=N/A */
+	uint8_t reserved129;		/* Byte offset 0x129, CSR Addr 0x54094, Direction=N/A */
+	uint8_t reserved12a;		/* Byte offset 0x12a, CSR Addr 0x54095, Direction=N/A */
+	uint8_t reserved12b;		/* Byte offset 0x12b, CSR Addr 0x54095, Direction=N/A */
+	uint8_t reserved12c;		/* Byte offset 0x12c, CSR Addr 0x54096, Direction=N/A */
+	uint8_t reserved12d;		/* Byte offset 0x12d, CSR Addr 0x54096, Direction=N/A */
+	uint8_t reserved12e;		/* Byte offset 0x12e, CSR Addr 0x54097, Direction=N/A */
+	uint8_t reserved12f;		/* Byte offset 0x12f, CSR Addr 0x54097, Direction=N/A */
+	uint8_t reserved130;		/* Byte offset 0x130, CSR Addr 0x54098, Direction=N/A */
+	uint8_t reserved131;		/* Byte offset 0x131, CSR Addr 0x54098, Direction=N/A */
+	uint8_t reserved132;		/* Byte offset 0x132, CSR Addr 0x54099, Direction=N/A */
+	uint8_t reserved133;		/* Byte offset 0x133, CSR Addr 0x54099, Direction=N/A */
+	uint8_t reserved134;		/* Byte offset 0x134, CSR Addr 0x5409a, Direction=N/A */
+	uint8_t reserved135;		/* Byte offset 0x135, CSR Addr 0x5409a, Direction=N/A */
+	uint8_t reserved136;		/* Byte offset 0x136, CSR Addr 0x5409b, Direction=N/A */
+	uint8_t reserved137;		/* Byte offset 0x137, CSR Addr 0x5409b, Direction=N/A */
+	uint8_t reserved138;		/* Byte offset 0x138, CSR Addr 0x5409c, Direction=N/A */
+	uint8_t reserved139;		/* Byte offset 0x139, CSR Addr 0x5409c, Direction=N/A */
+	uint8_t reserved13a;		/* Byte offset 0x13a, CSR Addr 0x5409d, Direction=N/A */
+	uint8_t reserved13b;		/* Byte offset 0x13b, CSR Addr 0x5409d, Direction=N/A */
+	uint8_t reserved13c;		/* Byte offset 0x13c, CSR Addr 0x5409e, Direction=N/A */
+	uint8_t reserved13d;		/* Byte offset 0x13d, CSR Addr 0x5409e, Direction=N/A */
+	uint8_t reserved13e;		/* Byte offset 0x13e, CSR Addr 0x5409f, Direction=N/A */
+	uint8_t reserved13f;		/* Byte offset 0x13f, CSR Addr 0x5409f, Direction=N/A */
+	uint8_t reserved140;		/* Byte offset 0x140, CSR Addr 0x540a0, Direction=N/A */
+	uint8_t reserved141;		/* Byte offset 0x141, CSR Addr 0x540a0, Direction=N/A */
+	uint8_t reserved142;		/* Byte offset 0x142, CSR Addr 0x540a1, Direction=N/A */
+	uint8_t reserved143;		/* Byte offset 0x143, CSR Addr 0x540a1, Direction=N/A */
+	uint8_t reserved144;		/* Byte offset 0x144, CSR Addr 0x540a2, Direction=N/A */
+	uint8_t reserved145;		/* Byte offset 0x145, CSR Addr 0x540a2, Direction=N/A */
+	uint8_t reserved146;		/* Byte offset 0x146, CSR Addr 0x540a3, Direction=N/A */
+	uint8_t reserved147;		/* Byte offset 0x147, CSR Addr 0x540a3, Direction=N/A */
+	uint8_t reserved148;		/* Byte offset 0x148, CSR Addr 0x540a4, Direction=N/A */
+	uint8_t reserved149;		/* Byte offset 0x149, CSR Addr 0x540a4, Direction=N/A */
+	uint8_t reserved14a;		/* Byte offset 0x14a, CSR Addr 0x540a5, Direction=N/A */
+	uint8_t reserved14b;		/* Byte offset 0x14b, CSR Addr 0x540a5, Direction=N/A */
+	uint8_t reserved14c;		/* Byte offset 0x14c, CSR Addr 0x540a6, Direction=N/A */
+	uint8_t reserved14d;		/* Byte offset 0x14d, CSR Addr 0x540a6, Direction=N/A */
+	uint8_t reserved14e;		/* Byte offset 0x14e, CSR Addr 0x540a7, Direction=N/A */
+	uint8_t reserved14f;		/* Byte offset 0x14f, CSR Addr 0x540a7, Direction=N/A */
+	uint8_t reserved150;		/* Byte offset 0x150, CSR Addr 0x540a8, Direction=N/A */
+	uint8_t reserved151;		/* Byte offset 0x151, CSR Addr 0x540a8, Direction=N/A */
+	uint8_t reserved152;		/* Byte offset 0x152, CSR Addr 0x540a9, Direction=N/A */
+	uint8_t reserved153;		/* Byte offset 0x153, CSR Addr 0x540a9, Direction=N/A */
+	uint8_t reserved154;		/* Byte offset 0x154, CSR Addr 0x540aa, Direction=N/A */
+	uint8_t reserved155;		/* Byte offset 0x155, CSR Addr 0x540aa, Direction=N/A */
+	uint8_t reserved156;		/* Byte offset 0x156, CSR Addr 0x540ab, Direction=N/A */
+	uint8_t reserved157;		/* Byte offset 0x157, CSR Addr 0x540ab, Direction=N/A */
+	uint8_t reserved158;		/* Byte offset 0x158, CSR Addr 0x540ac, Direction=N/A */
+	uint8_t reserved159;		/* Byte offset 0x159, CSR Addr 0x540ac, Direction=N/A */
+	uint8_t reserved15a;		/* Byte offset 0x15a, CSR Addr 0x540ad, Direction=N/A */
+	uint8_t reserved15b;		/* Byte offset 0x15b, CSR Addr 0x540ad, Direction=N/A */
+	uint8_t reserved15c;		/* Byte offset 0x15c, CSR Addr 0x540ae, Direction=N/A */
+	uint8_t reserved15d;		/* Byte offset 0x15d, CSR Addr 0x540ae, Direction=N/A */
+	uint8_t reserved15e;		/* Byte offset 0x15e, CSR Addr 0x540af, Direction=N/A */
+	uint8_t reserved15f;		/* Byte offset 0x15f, CSR Addr 0x540af, Direction=N/A */
+	uint8_t reserved160;		/* Byte offset 0x160, CSR Addr 0x540b0, Direction=N/A */
+	uint8_t reserved161;		/* Byte offset 0x161, CSR Addr 0x540b0, Direction=N/A */
+	uint8_t reserved162;		/* Byte offset 0x162, CSR Addr 0x540b1, Direction=N/A */
+	uint8_t reserved163;		/* Byte offset 0x163, CSR Addr 0x540b1, Direction=N/A */
+	uint8_t reserved164;		/* Byte offset 0x164, CSR Addr 0x540b2, Direction=N/A */
+	uint8_t reserved165;		/* Byte offset 0x165, CSR Addr 0x540b2, Direction=N/A */
+	uint8_t reserved166;		/* Byte offset 0x166, CSR Addr 0x540b3, Direction=N/A */
+	uint8_t reserved167;		/* Byte offset 0x167, CSR Addr 0x540b3, Direction=N/A */
+	uint8_t reserved168;		/* Byte offset 0x168, CSR Addr 0x540b4, Direction=N/A */
+	uint8_t reserved169;		/* Byte offset 0x169, CSR Addr 0x540b4, Direction=N/A */
+	uint8_t reserved16a;		/* Byte offset 0x16a, CSR Addr 0x540b5, Direction=N/A */
+	uint8_t reserved16b;		/* Byte offset 0x16b, CSR Addr 0x540b5, Direction=N/A */
+	uint8_t reserved16c;		/* Byte offset 0x16c, CSR Addr 0x540b6, Direction=N/A */
+	uint8_t reserved16d;		/* Byte offset 0x16d, CSR Addr 0x540b6, Direction=N/A */
+	uint8_t reserved16e;		/* Byte offset 0x16e, CSR Addr 0x540b7, Direction=N/A */
+	uint8_t reserved16f;		/* Byte offset 0x16f, CSR Addr 0x540b7, Direction=N/A */
+	uint8_t reserved170;		/* Byte offset 0x170, CSR Addr 0x540b8, Direction=N/A */
+	uint8_t reserved171;		/* Byte offset 0x171, CSR Addr 0x540b8, Direction=N/A */
+	uint8_t reserved172;		/* Byte offset 0x172, CSR Addr 0x540b9, Direction=N/A */
+	uint8_t reserved173;		/* Byte offset 0x173, CSR Addr 0x540b9, Direction=N/A */
+	uint8_t reserved174;		/* Byte offset 0x174, CSR Addr 0x540ba, Direction=N/A */
+	uint8_t reserved175;		/* Byte offset 0x175, CSR Addr 0x540ba, Direction=N/A */
+	uint8_t reserved176;		/* Byte offset 0x176, CSR Addr 0x540bb, Direction=N/A */
+	uint8_t reserved177;		/* Byte offset 0x177, CSR Addr 0x540bb, Direction=N/A */
+	uint8_t reserved178;		/* Byte offset 0x178, CSR Addr 0x540bc, Direction=N/A */
+	uint8_t reserved179;		/* Byte offset 0x179, CSR Addr 0x540bc, Direction=N/A */
+	uint8_t reserved17a;		/* Byte offset 0x17a, CSR Addr 0x540bd, Direction=N/A */
+	uint8_t reserved17b;		/* Byte offset 0x17b, CSR Addr 0x540bd, Direction=N/A */
+	uint8_t reserved17c;		/* Byte offset 0x17c, CSR Addr 0x540be, Direction=N/A */
+	uint8_t reserved17d;		/* Byte offset 0x17d, CSR Addr 0x540be, Direction=N/A */
+	uint8_t reserved17e;		/* Byte offset 0x17e, CSR Addr 0x540bf, Direction=N/A */
+	uint8_t reserved17f;		/* Byte offset 0x17f, CSR Addr 0x540bf, Direction=N/A */
+	uint8_t reserved180;		/* Byte offset 0x180, CSR Addr 0x540c0, Direction=N/A */
+	uint8_t reserved181;		/* Byte offset 0x181, CSR Addr 0x540c0, Direction=N/A */
+	uint8_t reserved182;		/* Byte offset 0x182, CSR Addr 0x540c1, Direction=N/A */
+	uint8_t reserved183;		/* Byte offset 0x183, CSR Addr 0x540c1, Direction=N/A */
+	uint8_t reserved184;		/* Byte offset 0x184, CSR Addr 0x540c2, Direction=N/A */
+	uint8_t reserved185;		/* Byte offset 0x185, CSR Addr 0x540c2, Direction=N/A */
+	uint8_t reserved186;		/* Byte offset 0x186, CSR Addr 0x540c3, Direction=N/A */
+	uint8_t reserved187;		/* Byte offset 0x187, CSR Addr 0x540c3, Direction=N/A */
+	uint8_t reserved188;		/* Byte offset 0x188, CSR Addr 0x540c4, Direction=N/A */
+	uint8_t reserved189;		/* Byte offset 0x189, CSR Addr 0x540c4, Direction=N/A */
+	uint8_t reserved18a;		/* Byte offset 0x18a, CSR Addr 0x540c5, Direction=N/A */
+	uint8_t reserved18b;		/* Byte offset 0x18b, CSR Addr 0x540c5, Direction=N/A */
+	uint8_t reserved18c;		/* Byte offset 0x18c, CSR Addr 0x540c6, Direction=N/A */
+	uint8_t reserved18d;		/* Byte offset 0x18d, CSR Addr 0x540c6, Direction=N/A */
+	uint8_t reserved18e;		/* Byte offset 0x18e, CSR Addr 0x540c7, Direction=N/A */
+	uint8_t reserved18f;		/* Byte offset 0x18f, CSR Addr 0x540c7, Direction=N/A */
+	uint8_t reserved190;		/* Byte offset 0x190, CSR Addr 0x540c8, Direction=N/A */
+	uint8_t reserved191;		/* Byte offset 0x191, CSR Addr 0x540c8, Direction=N/A */
+	uint8_t reserved192;		/* Byte offset 0x192, CSR Addr 0x540c9, Direction=N/A */
+	uint8_t reserved193;		/* Byte offset 0x193, CSR Addr 0x540c9, Direction=N/A */
+	uint8_t reserved194;		/* Byte offset 0x194, CSR Addr 0x540ca, Direction=N/A */
+	uint8_t reserved195;		/* Byte offset 0x195, CSR Addr 0x540ca, Direction=N/A */
+	uint8_t reserved196;		/* Byte offset 0x196, CSR Addr 0x540cb, Direction=N/A */
+	uint8_t reserved197;		/* Byte offset 0x197, CSR Addr 0x540cb, Direction=N/A */
+	uint8_t reserved198;		/* Byte offset 0x198, CSR Addr 0x540cc, Direction=N/A */
+	uint8_t reserved199;		/* Byte offset 0x199, CSR Addr 0x540cc, Direction=N/A */
+	uint8_t reserved19a;		/* Byte offset 0x19a, CSR Addr 0x540cd, Direction=N/A */
+	uint8_t reserved19b;		/* Byte offset 0x19b, CSR Addr 0x540cd, Direction=N/A */
+	uint8_t reserved19c;		/* Byte offset 0x19c, CSR Addr 0x540ce, Direction=N/A */
+	uint8_t reserved19d;		/* Byte offset 0x19d, CSR Addr 0x540ce, Direction=N/A */
+	uint8_t reserved19e;		/* Byte offset 0x19e, CSR Addr 0x540cf, Direction=N/A */
+	uint8_t reserved19f;		/* Byte offset 0x19f, CSR Addr 0x540cf, Direction=N/A */
+	uint8_t reserved1a0;		/* Byte offset 0x1a0, CSR Addr 0x540d0, Direction=N/A */
+	uint8_t reserved1a1;		/* Byte offset 0x1a1, CSR Addr 0x540d0, Direction=N/A */
+	uint8_t reserved1a2;		/* Byte offset 0x1a2, CSR Addr 0x540d1, Direction=N/A */
+	uint8_t reserved1a3;		/* Byte offset 0x1a3, CSR Addr 0x540d1, Direction=N/A */
+	uint8_t reserved1a4;		/* Byte offset 0x1a4, CSR Addr 0x540d2, Direction=N/A */
+	uint8_t reserved1a5;		/* Byte offset 0x1a5, CSR Addr 0x540d2, Direction=N/A */
+	uint8_t reserved1a6;		/* Byte offset 0x1a6, CSR Addr 0x540d3, Direction=N/A */
+	uint8_t reserved1a7;		/* Byte offset 0x1a7, CSR Addr 0x540d3, Direction=N/A */
+	uint8_t reserved1a8;		/* Byte offset 0x1a8, CSR Addr 0x540d4, Direction=N/A */
+	uint8_t reserved1a9;		/* Byte offset 0x1a9, CSR Addr 0x540d4, Direction=N/A */
+	uint8_t reserved1aa;		/* Byte offset 0x1aa, CSR Addr 0x540d5, Direction=N/A */
+	uint8_t reserved1ab;		/* Byte offset 0x1ab, CSR Addr 0x540d5, Direction=N/A */
+	uint8_t reserved1ac;		/* Byte offset 0x1ac, CSR Addr 0x540d6, Direction=N/A */
+	uint8_t reserved1ad;		/* Byte offset 0x1ad, CSR Addr 0x540d6, Direction=N/A */
+	uint8_t reserved1ae;		/* Byte offset 0x1ae, CSR Addr 0x540d7, Direction=N/A */
+	uint8_t reserved1af;		/* Byte offset 0x1af, CSR Addr 0x540d7, Direction=N/A */
+	uint8_t reserved1b0;		/* Byte offset 0x1b0, CSR Addr 0x540d8, Direction=N/A */
+	uint8_t reserved1b1;		/* Byte offset 0x1b1, CSR Addr 0x540d8, Direction=N/A */
+	uint8_t reserved1b2;		/* Byte offset 0x1b2, CSR Addr 0x540d9, Direction=N/A */
+	uint8_t reserved1b3;		/* Byte offset 0x1b3, CSR Addr 0x540d9, Direction=N/A */
+	uint8_t reserved1b4;		/* Byte offset 0x1b4, CSR Addr 0x540da, Direction=N/A */
+	uint8_t reserved1b5;		/* Byte offset 0x1b5, CSR Addr 0x540da, Direction=N/A */
+	uint8_t reserved1b6;		/* Byte offset 0x1b6, CSR Addr 0x540db, Direction=N/A */
+	uint8_t reserved1b7;		/* Byte offset 0x1b7, CSR Addr 0x540db, Direction=N/A */
+	uint8_t reserved1b8;		/* Byte offset 0x1b8, CSR Addr 0x540dc, Direction=N/A */
+	uint8_t reserved1b9;		/* Byte offset 0x1b9, CSR Addr 0x540dc, Direction=N/A */
+	uint8_t reserved1ba;		/* Byte offset 0x1ba, CSR Addr 0x540dd, Direction=N/A */
+	uint8_t reserved1bb;		/* Byte offset 0x1bb, CSR Addr 0x540dd, Direction=N/A */
+	uint8_t reserved1bc;		/* Byte offset 0x1bc, CSR Addr 0x540de, Direction=N/A */
+	uint8_t reserved1bd;		/* Byte offset 0x1bd, CSR Addr 0x540de, Direction=N/A */
+	uint8_t reserved1be;		/* Byte offset 0x1be, CSR Addr 0x540df, Direction=N/A */
+	uint8_t reserved1bf;		/* Byte offset 0x1bf, CSR Addr 0x540df, Direction=N/A */
+	uint8_t reserved1c0;		/* Byte offset 0x1c0, CSR Addr 0x540e0, Direction=N/A */
+	uint8_t reserved1c1;		/* Byte offset 0x1c1, CSR Addr 0x540e0, Direction=N/A */
+	uint8_t reserved1c2;		/* Byte offset 0x1c2, CSR Addr 0x540e1, Direction=N/A */
+	uint8_t reserved1c3;		/* Byte offset 0x1c3, CSR Addr 0x540e1, Direction=N/A */
+	uint8_t reserved1c4;		/* Byte offset 0x1c4, CSR Addr 0x540e2, Direction=N/A */
+	uint8_t reserved1c5;		/* Byte offset 0x1c5, CSR Addr 0x540e2, Direction=N/A */
+	uint8_t reserved1c6;		/* Byte offset 0x1c6, CSR Addr 0x540e3, Direction=N/A */
+	uint8_t reserved1c7;		/* Byte offset 0x1c7, CSR Addr 0x540e3, Direction=N/A */
+	uint8_t reserved1c8;		/* Byte offset 0x1c8, CSR Addr 0x540e4, Direction=N/A */
+	uint8_t reserved1c9;		/* Byte offset 0x1c9, CSR Addr 0x540e4, Direction=N/A */
+	uint8_t reserved1ca;		/* Byte offset 0x1ca, CSR Addr 0x540e5, Direction=N/A */
+	uint8_t reserved1cb;		/* Byte offset 0x1cb, CSR Addr 0x540e5, Direction=N/A */
+	uint8_t reserved1cc;		/* Byte offset 0x1cc, CSR Addr 0x540e6, Direction=N/A */
+	uint8_t reserved1cd;		/* Byte offset 0x1cd, CSR Addr 0x540e6, Direction=N/A */
+	uint8_t reserved1ce;		/* Byte offset 0x1ce, CSR Addr 0x540e7, Direction=N/A */
+	uint8_t reserved1cf;		/* Byte offset 0x1cf, CSR Addr 0x540e7, Direction=N/A */
+	uint8_t reserved1d0;		/* Byte offset 0x1d0, CSR Addr 0x540e8, Direction=N/A */
+	uint8_t reserved1d1;		/* Byte offset 0x1d1, CSR Addr 0x540e8, Direction=N/A */
+	uint8_t reserved1d2;		/* Byte offset 0x1d2, CSR Addr 0x540e9, Direction=N/A */
+	uint8_t reserved1d3;		/* Byte offset 0x1d3, CSR Addr 0x540e9, Direction=N/A */
+	uint8_t reserved1d4;		/* Byte offset 0x1d4, CSR Addr 0x540ea, Direction=N/A */
+	uint8_t reserved1d5;		/* Byte offset 0x1d5, CSR Addr 0x540ea, Direction=N/A */
+	uint8_t reserved1d6;		/* Byte offset 0x1d6, CSR Addr 0x540eb, Direction=N/A */
+	uint8_t reserved1d7;		/* Byte offset 0x1d7, CSR Addr 0x540eb, Direction=N/A */
+	uint8_t reserved1d8;		/* Byte offset 0x1d8, CSR Addr 0x540ec, Direction=N/A */
+	uint8_t reserved1d9;		/* Byte offset 0x1d9, CSR Addr 0x540ec, Direction=N/A */
+	uint8_t reserved1da;		/* Byte offset 0x1da, CSR Addr 0x540ed, Direction=N/A */
+	uint8_t reserved1db;		/* Byte offset 0x1db, CSR Addr 0x540ed, Direction=N/A */
+	uint8_t reserved1dc;		/* Byte offset 0x1dc, CSR Addr 0x540ee, Direction=N/A */
+	uint8_t reserved1dd;		/* Byte offset 0x1dd, CSR Addr 0x540ee, Direction=N/A */
+	uint8_t reserved1de;		/* Byte offset 0x1de, CSR Addr 0x540ef, Direction=N/A */
+	uint8_t reserved1df;		/* Byte offset 0x1df, CSR Addr 0x540ef, Direction=N/A */
+	uint8_t reserved1e0;		/* Byte offset 0x1e0, CSR Addr 0x540f0, Direction=N/A */
+	uint8_t reserved1e1;		/* Byte offset 0x1e1, CSR Addr 0x540f0, Direction=N/A */
+	uint8_t reserved1e2;		/* Byte offset 0x1e2, CSR Addr 0x540f1, Direction=N/A */
+	uint8_t reserved1e3;		/* Byte offset 0x1e3, CSR Addr 0x540f1, Direction=N/A */
+	uint8_t reserved1e4;		/* Byte offset 0x1e4, CSR Addr 0x540f2, Direction=N/A */
+	uint8_t reserved1e5;		/* Byte offset 0x1e5, CSR Addr 0x540f2, Direction=N/A */
+	uint8_t reserved1e6;		/* Byte offset 0x1e6, CSR Addr 0x540f3, Direction=N/A */
+	uint8_t reserved1e7;		/* Byte offset 0x1e7, CSR Addr 0x540f3, Direction=N/A */
+	uint8_t reserved1e8;		/* Byte offset 0x1e8, CSR Addr 0x540f4, Direction=N/A */
+	uint8_t reserved1e9;		/* Byte offset 0x1e9, CSR Addr 0x540f4, Direction=N/A */
+	uint8_t reserved1ea;		/* Byte offset 0x1ea, CSR Addr 0x540f5, Direction=N/A */
+	uint8_t reserved1eb;		/* Byte offset 0x1eb, CSR Addr 0x540f5, Direction=N/A */
+	uint8_t reserved1ec;		/* Byte offset 0x1ec, CSR Addr 0x540f6, Direction=N/A */
+	uint8_t reserved1ed;		/* Byte offset 0x1ed, CSR Addr 0x540f6, Direction=N/A */
+	uint8_t reserved1ee;		/* Byte offset 0x1ee, CSR Addr 0x540f7, Direction=N/A */
+	uint8_t reserved1ef;		/* Byte offset 0x1ef, CSR Addr 0x540f7, Direction=N/A */
+	uint8_t reserved1f0;		/* Byte offset 0x1f0, CSR Addr 0x540f8, Direction=N/A */
+	uint8_t reserved1f1;		/* Byte offset 0x1f1, CSR Addr 0x540f8, Direction=N/A */
+	uint8_t reserved1f2;		/* Byte offset 0x1f2, CSR Addr 0x540f9, Direction=N/A */
+	uint8_t reserved1f3;		/* Byte offset 0x1f3, CSR Addr 0x540f9, Direction=N/A */
+	uint8_t reserved1f4;		/* Byte offset 0x1f4, CSR Addr 0x540fa, Direction=N/A */
+	uint8_t reserved1f5;		/* Byte offset 0x1f5, CSR Addr 0x540fa, Direction=N/A */
+	uint8_t reserved1f6;		/* Byte offset 0x1f6, CSR Addr 0x540fb, Direction=N/A */
+	uint8_t reserved1f7;		/* Byte offset 0x1f7, CSR Addr 0x540fb, Direction=N/A */
+	uint8_t reserved1f8;		/* Byte offset 0x1f8, CSR Addr 0x540fc, Direction=N/A */
+	uint8_t reserved1f9;		/* Byte offset 0x1f9, CSR Addr 0x540fc, Direction=N/A */
+	uint8_t reserved1fa;		/* Byte offset 0x1fa, CSR Addr 0x540fd, Direction=N/A */
+	uint8_t reserved1fb;		/* Byte offset 0x1fb, CSR Addr 0x540fd, Direction=N/A */
+	uint8_t reserved1fc;		/* Byte offset 0x1fc, CSR Addr 0x540fe, Direction=N/A */
+	uint8_t reserved1fd;		/* Byte offset 0x1fd, CSR Addr 0x540fe, Direction=N/A */
+	uint8_t reserved1fe;		/* Byte offset 0x1fe, CSR Addr 0x540ff, Direction=N/A */
+	uint8_t reserved1ff;		/* Byte offset 0x1ff, CSR Addr 0x540ff, Direction=N/A */
+	uint8_t reserved200;		/* Byte offset 0x200, CSR Addr 0x54100, Direction=N/A */
+	uint8_t reserved201;		/* Byte offset 0x201, CSR Addr 0x54100, Direction=N/A */
+	uint8_t reserved202;		/* Byte offset 0x202, CSR Addr 0x54101, Direction=N/A */
+	uint8_t reserved203;		/* Byte offset 0x203, CSR Addr 0x54101, Direction=N/A */
+	uint8_t reserved204;		/* Byte offset 0x204, CSR Addr 0x54102, Direction=N/A */
+	uint8_t reserved205;		/* Byte offset 0x205, CSR Addr 0x54102, Direction=N/A */
+	uint8_t reserved206;		/* Byte offset 0x206, CSR Addr 0x54103, Direction=N/A */
+	uint8_t reserved207;		/* Byte offset 0x207, CSR Addr 0x54103, Direction=N/A */
+	uint8_t reserved208;		/* Byte offset 0x208, CSR Addr 0x54104, Direction=N/A */
+	uint8_t reserved209;		/* Byte offset 0x209, CSR Addr 0x54104, Direction=N/A */
+	uint8_t reserved20a;		/* Byte offset 0x20a, CSR Addr 0x54105, Direction=N/A */
+	uint8_t reserved20b;		/* Byte offset 0x20b, CSR Addr 0x54105, Direction=N/A */
+	uint8_t reserved20c;		/* Byte offset 0x20c, CSR Addr 0x54106, Direction=N/A */
+	uint8_t reserved20d;		/* Byte offset 0x20d, CSR Addr 0x54106, Direction=N/A */
+	uint8_t reserved20e;		/* Byte offset 0x20e, CSR Addr 0x54107, Direction=N/A */
+	uint8_t reserved20f;		/* Byte offset 0x20f, CSR Addr 0x54107, Direction=N/A */
+	uint8_t reserved210;		/* Byte offset 0x210, CSR Addr 0x54108, Direction=N/A */
+	uint8_t reserved211;		/* Byte offset 0x211, CSR Addr 0x54108, Direction=N/A */
+	uint8_t reserved212;		/* Byte offset 0x212, CSR Addr 0x54109, Direction=N/A */
+	uint8_t reserved213;		/* Byte offset 0x213, CSR Addr 0x54109, Direction=N/A */
+	uint8_t reserved214;		/* Byte offset 0x214, CSR Addr 0x5410a, Direction=N/A */
+	uint8_t reserved215;		/* Byte offset 0x215, CSR Addr 0x5410a, Direction=N/A */
+	uint8_t reserved216;		/* Byte offset 0x216, CSR Addr 0x5410b, Direction=N/A */
+	uint8_t reserved217;		/* Byte offset 0x217, CSR Addr 0x5410b, Direction=N/A */
+	uint8_t reserved218;		/* Byte offset 0x218, CSR Addr 0x5410c, Direction=N/A */
+	uint8_t reserved219;		/* Byte offset 0x219, CSR Addr 0x5410c, Direction=N/A */
+	uint8_t reserved21a;		/* Byte offset 0x21a, CSR Addr 0x5410d, Direction=N/A */
+	uint8_t reserved21b;		/* Byte offset 0x21b, CSR Addr 0x5410d, Direction=N/A */
+	uint8_t reserved21c;		/* Byte offset 0x21c, CSR Addr 0x5410e, Direction=N/A */
+	uint8_t reserved21d;		/* Byte offset 0x21d, CSR Addr 0x5410e, Direction=N/A */
+	uint8_t reserved21e;		/* Byte offset 0x21e, CSR Addr 0x5410f, Direction=N/A */
+	uint8_t reserved21f;		/* Byte offset 0x21f, CSR Addr 0x5410f, Direction=N/A */
+	uint8_t reserved220;		/* Byte offset 0x220, CSR Addr 0x54110, Direction=N/A */
+	uint8_t reserved221;		/* Byte offset 0x221, CSR Addr 0x54110, Direction=N/A */
+	uint8_t reserved222;		/* Byte offset 0x222, CSR Addr 0x54111, Direction=N/A */
+	uint8_t reserved223;		/* Byte offset 0x223, CSR Addr 0x54111, Direction=N/A */
+	uint8_t reserved224;		/* Byte offset 0x224, CSR Addr 0x54112, Direction=N/A */
+	uint8_t reserved225;		/* Byte offset 0x225, CSR Addr 0x54112, Direction=N/A */
+	uint8_t reserved226;		/* Byte offset 0x226, CSR Addr 0x54113, Direction=N/A */
+	uint8_t reserved227;		/* Byte offset 0x227, CSR Addr 0x54113, Direction=N/A */
+	uint8_t reserved228;		/* Byte offset 0x228, CSR Addr 0x54114, Direction=N/A */
+	uint8_t reserved229;		/* Byte offset 0x229, CSR Addr 0x54114, Direction=N/A */
+	uint8_t reserved22a;		/* Byte offset 0x22a, CSR Addr 0x54115, Direction=N/A */
+	uint8_t reserved22b;		/* Byte offset 0x22b, CSR Addr 0x54115, Direction=N/A */
+	uint8_t reserved22c;		/* Byte offset 0x22c, CSR Addr 0x54116, Direction=N/A */
+	uint8_t reserved22d;		/* Byte offset 0x22d, CSR Addr 0x54116, Direction=N/A */
+	uint8_t reserved22e;		/* Byte offset 0x22e, CSR Addr 0x54117, Direction=N/A */
+	uint8_t reserved22f;		/* Byte offset 0x22f, CSR Addr 0x54117, Direction=N/A */
+	uint8_t reserved230;		/* Byte offset 0x230, CSR Addr 0x54118, Direction=N/A */
+	uint8_t reserved231;		/* Byte offset 0x231, CSR Addr 0x54118, Direction=N/A */
+	uint8_t reserved232;		/* Byte offset 0x232, CSR Addr 0x54119, Direction=N/A */
+	uint8_t reserved233;		/* Byte offset 0x233, CSR Addr 0x54119, Direction=N/A */
+	uint8_t reserved234;		/* Byte offset 0x234, CSR Addr 0x5411a, Direction=N/A */
+	uint8_t reserved235;		/* Byte offset 0x235, CSR Addr 0x5411a, Direction=N/A */
+	uint8_t reserved236;		/* Byte offset 0x236, CSR Addr 0x5411b, Direction=N/A */
+	uint8_t reserved237;		/* Byte offset 0x237, CSR Addr 0x5411b, Direction=N/A */
+	uint8_t reserved238;		/* Byte offset 0x238, CSR Addr 0x5411c, Direction=N/A */
+	uint8_t reserved239;		/* Byte offset 0x239, CSR Addr 0x5411c, Direction=N/A */
+	uint8_t reserved23a;		/* Byte offset 0x23a, CSR Addr 0x5411d, Direction=N/A */
+	uint8_t reserved23b;		/* Byte offset 0x23b, CSR Addr 0x5411d, Direction=N/A */
+	uint8_t reserved23c;		/* Byte offset 0x23c, CSR Addr 0x5411e, Direction=N/A */
+	uint8_t reserved23d;		/* Byte offset 0x23d, CSR Addr 0x5411e, Direction=N/A */
+	uint8_t reserved23e;		/* Byte offset 0x23e, CSR Addr 0x5411f, Direction=N/A */
+	uint8_t reserved23f;		/* Byte offset 0x23f, CSR Addr 0x5411f, Direction=N/A */
+	uint8_t reserved240;		/* Byte offset 0x240, CSR Addr 0x54120, Direction=N/A */
+	uint8_t reserved241;		/* Byte offset 0x241, CSR Addr 0x54120, Direction=N/A */
+	uint8_t reserved242;		/* Byte offset 0x242, CSR Addr 0x54121, Direction=N/A */
+	uint8_t reserved243;		/* Byte offset 0x243, CSR Addr 0x54121, Direction=N/A */
+	uint8_t reserved244;		/* Byte offset 0x244, CSR Addr 0x54122, Direction=N/A */
+	uint8_t reserved245;		/* Byte offset 0x245, CSR Addr 0x54122, Direction=N/A */
+	uint8_t reserved246;		/* Byte offset 0x246, CSR Addr 0x54123, Direction=N/A */
+	uint8_t reserved247;		/* Byte offset 0x247, CSR Addr 0x54123, Direction=N/A */
+	uint8_t reserved248;		/* Byte offset 0x248, CSR Addr 0x54124, Direction=N/A */
+	uint8_t reserved249;		/* Byte offset 0x249, CSR Addr 0x54124, Direction=N/A */
+	uint8_t reserved24a;		/* Byte offset 0x24a, CSR Addr 0x54125, Direction=N/A */
+	uint8_t reserved24b;		/* Byte offset 0x24b, CSR Addr 0x54125, Direction=N/A */
+	uint8_t reserved24c;		/* Byte offset 0x24c, CSR Addr 0x54126, Direction=N/A */
+	uint8_t reserved24d;		/* Byte offset 0x24d, CSR Addr 0x54126, Direction=N/A */
+	uint8_t reserved24e;		/* Byte offset 0x24e, CSR Addr 0x54127, Direction=N/A */
+	uint8_t reserved24f;		/* Byte offset 0x24f, CSR Addr 0x54127, Direction=N/A */
+	uint8_t reserved250;		/* Byte offset 0x250, CSR Addr 0x54128, Direction=N/A */
+	uint8_t reserved251;		/* Byte offset 0x251, CSR Addr 0x54128, Direction=N/A */
+	uint8_t reserved252;		/* Byte offset 0x252, CSR Addr 0x54129, Direction=N/A */
+	uint8_t reserved253;		/* Byte offset 0x253, CSR Addr 0x54129, Direction=N/A */
+	uint8_t reserved254;		/* Byte offset 0x254, CSR Addr 0x5412a, Direction=N/A */
+	uint8_t reserved255;		/* Byte offset 0x255, CSR Addr 0x5412a, Direction=N/A */
+	uint8_t reserved256;		/* Byte offset 0x256, CSR Addr 0x5412b, Direction=N/A */
+	uint8_t reserved257;		/* Byte offset 0x257, CSR Addr 0x5412b, Direction=N/A */
+	uint8_t reserved258;		/* Byte offset 0x258, CSR Addr 0x5412c, Direction=N/A */
+	uint8_t reserved259;		/* Byte offset 0x259, CSR Addr 0x5412c, Direction=N/A */
+	uint8_t reserved25a;		/* Byte offset 0x25a, CSR Addr 0x5412d, Direction=N/A */
+	uint8_t reserved25b;		/* Byte offset 0x25b, CSR Addr 0x5412d, Direction=N/A */
+	uint8_t reserved25c;		/* Byte offset 0x25c, CSR Addr 0x5412e, Direction=N/A */
+	uint8_t reserved25d;		/* Byte offset 0x25d, CSR Addr 0x5412e, Direction=N/A */
+	uint8_t reserved25e;		/* Byte offset 0x25e, CSR Addr 0x5412f, Direction=N/A */
+	uint8_t reserved25f;		/* Byte offset 0x25f, CSR Addr 0x5412f, Direction=N/A */
+	uint8_t reserved260;		/* Byte offset 0x260, CSR Addr 0x54130, Direction=N/A */
+	uint8_t reserved261;		/* Byte offset 0x261, CSR Addr 0x54130, Direction=N/A */
+	uint8_t reserved262;		/* Byte offset 0x262, CSR Addr 0x54131, Direction=N/A */
+	uint8_t reserved263;		/* Byte offset 0x263, CSR Addr 0x54131, Direction=N/A */
+	uint8_t reserved264;		/* Byte offset 0x264, CSR Addr 0x54132, Direction=N/A */
+	uint8_t reserved265;		/* Byte offset 0x265, CSR Addr 0x54132, Direction=N/A */
+	uint8_t reserved266;		/* Byte offset 0x266, CSR Addr 0x54133, Direction=N/A */
+	uint8_t reserved267;		/* Byte offset 0x267, CSR Addr 0x54133, Direction=N/A */
+	uint8_t reserved268;		/* Byte offset 0x268, CSR Addr 0x54134, Direction=N/A */
+	uint8_t reserved269;		/* Byte offset 0x269, CSR Addr 0x54134, Direction=N/A */
+	uint8_t reserved26a;		/* Byte offset 0x26a, CSR Addr 0x54135, Direction=N/A */
+	uint8_t reserved26b;		/* Byte offset 0x26b, CSR Addr 0x54135, Direction=N/A */
+	uint8_t reserved26c;		/* Byte offset 0x26c, CSR Addr 0x54136, Direction=N/A */
+	uint8_t reserved26d;		/* Byte offset 0x26d, CSR Addr 0x54136, Direction=N/A */
+	uint8_t reserved26e;		/* Byte offset 0x26e, CSR Addr 0x54137, Direction=N/A */
+	uint8_t reserved26f;		/* Byte offset 0x26f, CSR Addr 0x54137, Direction=N/A */
+	uint8_t reserved270;		/* Byte offset 0x270, CSR Addr 0x54138, Direction=N/A */
+	uint8_t reserved271;		/* Byte offset 0x271, CSR Addr 0x54138, Direction=N/A */
+	uint8_t reserved272;		/* Byte offset 0x272, CSR Addr 0x54139, Direction=N/A */
+	uint8_t reserved273;		/* Byte offset 0x273, CSR Addr 0x54139, Direction=N/A */
+	uint8_t reserved274;		/* Byte offset 0x274, CSR Addr 0x5413a, Direction=N/A */
+	uint8_t reserved275;		/* Byte offset 0x275, CSR Addr 0x5413a, Direction=N/A */
+	uint8_t reserved276;		/* Byte offset 0x276, CSR Addr 0x5413b, Direction=N/A */
+	uint8_t reserved277;		/* Byte offset 0x277, CSR Addr 0x5413b, Direction=N/A */
+	uint8_t reserved278;		/* Byte offset 0x278, CSR Addr 0x5413c, Direction=N/A */
+	uint8_t reserved279;		/* Byte offset 0x279, CSR Addr 0x5413c, Direction=N/A */
+	uint8_t reserved27a;		/* Byte offset 0x27a, CSR Addr 0x5413d, Direction=N/A */
+	uint8_t reserved27b;		/* Byte offset 0x27b, CSR Addr 0x5413d, Direction=N/A */
+	uint8_t reserved27c;		/* Byte offset 0x27c, CSR Addr 0x5413e, Direction=N/A */
+	uint8_t reserved27d;		/* Byte offset 0x27d, CSR Addr 0x5413e, Direction=N/A */
+	uint8_t reserved27e;		/* Byte offset 0x27e, CSR Addr 0x5413f, Direction=N/A */
+	uint8_t reserved27f;		/* Byte offset 0x27f, CSR Addr 0x5413f, Direction=N/A */
+	uint8_t reserved280;		/* Byte offset 0x280, CSR Addr 0x54140, Direction=N/A */
+	uint8_t reserved281;		/* Byte offset 0x281, CSR Addr 0x54140, Direction=N/A */
+	uint8_t reserved282;		/* Byte offset 0x282, CSR Addr 0x54141, Direction=N/A */
+	uint8_t reserved283;		/* Byte offset 0x283, CSR Addr 0x54141, Direction=N/A */
+	uint8_t reserved284;		/* Byte offset 0x284, CSR Addr 0x54142, Direction=N/A */
+	uint8_t reserved285;		/* Byte offset 0x285, CSR Addr 0x54142, Direction=N/A */
+	uint8_t reserved286;		/* Byte offset 0x286, CSR Addr 0x54143, Direction=N/A */
+	uint8_t reserved287;		/* Byte offset 0x287, CSR Addr 0x54143, Direction=N/A */
+	uint8_t reserved288;		/* Byte offset 0x288, CSR Addr 0x54144, Direction=N/A */
+	uint8_t reserved289;		/* Byte offset 0x289, CSR Addr 0x54144, Direction=N/A */
+	uint8_t reserved28a;		/* Byte offset 0x28a, CSR Addr 0x54145, Direction=N/A */
+	uint8_t reserved28b;		/* Byte offset 0x28b, CSR Addr 0x54145, Direction=N/A */
+	uint8_t reserved28c;		/* Byte offset 0x28c, CSR Addr 0x54146, Direction=N/A */
+	uint8_t reserved28d;		/* Byte offset 0x28d, CSR Addr 0x54146, Direction=N/A */
+	uint8_t reserved28e;		/* Byte offset 0x28e, CSR Addr 0x54147, Direction=N/A */
+	uint8_t reserved28f;		/* Byte offset 0x28f, CSR Addr 0x54147, Direction=N/A */
+	uint8_t reserved290;		/* Byte offset 0x290, CSR Addr 0x54148, Direction=N/A */
+	uint8_t reserved291;		/* Byte offset 0x291, CSR Addr 0x54148, Direction=N/A */
+	uint8_t reserved292;		/* Byte offset 0x292, CSR Addr 0x54149, Direction=N/A */
+	uint8_t reserved293;		/* Byte offset 0x293, CSR Addr 0x54149, Direction=N/A */
+	uint8_t reserved294;		/* Byte offset 0x294, CSR Addr 0x5414a, Direction=N/A */
+	uint8_t reserved295;		/* Byte offset 0x295, CSR Addr 0x5414a, Direction=N/A */
+	uint8_t reserved296;		/* Byte offset 0x296, CSR Addr 0x5414b, Direction=N/A */
+	uint8_t reserved297;		/* Byte offset 0x297, CSR Addr 0x5414b, Direction=N/A */
+	uint8_t reserved298;		/* Byte offset 0x298, CSR Addr 0x5414c, Direction=N/A */
+	uint8_t reserved299;		/* Byte offset 0x299, CSR Addr 0x5414c, Direction=N/A */
+	uint8_t reserved29a;		/* Byte offset 0x29a, CSR Addr 0x5414d, Direction=N/A */
+	uint8_t reserved29b;		/* Byte offset 0x29b, CSR Addr 0x5414d, Direction=N/A */
+	uint8_t reserved29c;		/* Byte offset 0x29c, CSR Addr 0x5414e, Direction=N/A */
+	uint8_t reserved29d;		/* Byte offset 0x29d, CSR Addr 0x5414e, Direction=N/A */
+	uint8_t reserved29e;		/* Byte offset 0x29e, CSR Addr 0x5414f, Direction=N/A */
+	uint8_t reserved29f;		/* Byte offset 0x29f, CSR Addr 0x5414f, Direction=N/A */
+	uint8_t reserved2a0;		/* Byte offset 0x2a0, CSR Addr 0x54150, Direction=N/A */
+	uint8_t reserved2a1;		/* Byte offset 0x2a1, CSR Addr 0x54150, Direction=N/A */
+	uint8_t reserved2a2;		/* Byte offset 0x2a2, CSR Addr 0x54151, Direction=N/A */
+	uint8_t reserved2a3;		/* Byte offset 0x2a3, CSR Addr 0x54151, Direction=N/A */
+	uint8_t reserved2a4;		/* Byte offset 0x2a4, CSR Addr 0x54152, Direction=N/A */
+	uint8_t reserved2a5;		/* Byte offset 0x2a5, CSR Addr 0x54152, Direction=N/A */
+	uint8_t reserved2a6;		/* Byte offset 0x2a6, CSR Addr 0x54153, Direction=N/A */
+	uint8_t reserved2a7;		/* Byte offset 0x2a7, CSR Addr 0x54153, Direction=N/A */
+	uint8_t reserved2a8;		/* Byte offset 0x2a8, CSR Addr 0x54154, Direction=N/A */
+	uint8_t reserved2a9;		/* Byte offset 0x2a9, CSR Addr 0x54154, Direction=N/A */
+	uint8_t reserved2aa;		/* Byte offset 0x2aa, CSR Addr 0x54155, Direction=N/A */
+	uint8_t reserved2ab;		/* Byte offset 0x2ab, CSR Addr 0x54155, Direction=N/A */
+	uint8_t reserved2ac;		/* Byte offset 0x2ac, CSR Addr 0x54156, Direction=N/A */
+	uint8_t reserved2ad;		/* Byte offset 0x2ad, CSR Addr 0x54156, Direction=N/A */
+	uint8_t reserved2ae;		/* Byte offset 0x2ae, CSR Addr 0x54157, Direction=N/A */
+	uint8_t reserved2af;		/* Byte offset 0x2af, CSR Addr 0x54157, Direction=N/A */
+	uint8_t reserved2b0;		/* Byte offset 0x2b0, CSR Addr 0x54158, Direction=N/A */
+	uint8_t reserved2b1;		/* Byte offset 0x2b1, CSR Addr 0x54158, Direction=N/A */
+	uint8_t reserved2b2;		/* Byte offset 0x2b2, CSR Addr 0x54159, Direction=N/A */
+	uint8_t reserved2b3;		/* Byte offset 0x2b3, CSR Addr 0x54159, Direction=N/A */
+	uint8_t reserved2b4;		/* Byte offset 0x2b4, CSR Addr 0x5415a, Direction=N/A */
+	uint8_t reserved2b5;		/* Byte offset 0x2b5, CSR Addr 0x5415a, Direction=N/A */
+	uint8_t reserved2b6;		/* Byte offset 0x2b6, CSR Addr 0x5415b, Direction=N/A */
+	uint8_t reserved2b7;		/* Byte offset 0x2b7, CSR Addr 0x5415b, Direction=N/A */
+	uint8_t reserved2b8;		/* Byte offset 0x2b8, CSR Addr 0x5415c, Direction=N/A */
+	uint8_t reserved2b9;		/* Byte offset 0x2b9, CSR Addr 0x5415c, Direction=N/A */
+	uint8_t reserved2ba;		/* Byte offset 0x2ba, CSR Addr 0x5415d, Direction=N/A */
+	uint8_t reserved2bb;		/* Byte offset 0x2bb, CSR Addr 0x5415d, Direction=N/A */
+	uint8_t reserved2bc;		/* Byte offset 0x2bc, CSR Addr 0x5415e, Direction=N/A */
+	uint8_t reserved2bd;		/* Byte offset 0x2bd, CSR Addr 0x5415e, Direction=N/A */
+	uint8_t reserved2be;		/* Byte offset 0x2be, CSR Addr 0x5415f, Direction=N/A */
+	uint8_t reserved2bf;		/* Byte offset 0x2bf, CSR Addr 0x5415f, Direction=N/A */
+	uint8_t reserved2c0;		/* Byte offset 0x2c0, CSR Addr 0x54160, Direction=N/A */
+	uint8_t reserved2c1;		/* Byte offset 0x2c1, CSR Addr 0x54160, Direction=N/A */
+	uint8_t reserved2c2;		/* Byte offset 0x2c2, CSR Addr 0x54161, Direction=N/A */
+	uint8_t reserved2c3;		/* Byte offset 0x2c3, CSR Addr 0x54161, Direction=N/A */
+	uint8_t reserved2c4;		/* Byte offset 0x2c4, CSR Addr 0x54162, Direction=N/A */
+	uint8_t reserved2c5;		/* Byte offset 0x2c5, CSR Addr 0x54162, Direction=N/A */
+	uint8_t reserved2c6;		/* Byte offset 0x2c6, CSR Addr 0x54163, Direction=N/A */
+	uint8_t reserved2c7;		/* Byte offset 0x2c7, CSR Addr 0x54163, Direction=N/A */
+	uint8_t reserved2c8;		/* Byte offset 0x2c8, CSR Addr 0x54164, Direction=N/A */
+	uint8_t reserved2c9;		/* Byte offset 0x2c9, CSR Addr 0x54164, Direction=N/A */
+	uint8_t reserved2ca;		/* Byte offset 0x2ca, CSR Addr 0x54165, Direction=N/A */
+	uint8_t reserved2cb;		/* Byte offset 0x2cb, CSR Addr 0x54165, Direction=N/A */
+	uint8_t reserved2cc;		/* Byte offset 0x2cc, CSR Addr 0x54166, Direction=N/A */
+	uint8_t reserved2cd;		/* Byte offset 0x2cd, CSR Addr 0x54166, Direction=N/A */
+	uint8_t reserved2ce;		/* Byte offset 0x2ce, CSR Addr 0x54167, Direction=N/A */
+	uint8_t reserved2cf;		/* Byte offset 0x2cf, CSR Addr 0x54167, Direction=N/A */
+	uint8_t reserved2d0;		/* Byte offset 0x2d0, CSR Addr 0x54168, Direction=N/A */
+	uint8_t reserved2d1;		/* Byte offset 0x2d1, CSR Addr 0x54168, Direction=N/A */
+	uint8_t reserved2d2;		/* Byte offset 0x2d2, CSR Addr 0x54169, Direction=N/A */
+	uint8_t reserved2d3;		/* Byte offset 0x2d3, CSR Addr 0x54169, Direction=N/A */
+	uint8_t reserved2d4;		/* Byte offset 0x2d4, CSR Addr 0x5416a, Direction=N/A */
+	uint8_t reserved2d5;		/* Byte offset 0x2d5, CSR Addr 0x5416a, Direction=N/A */
+	uint8_t reserved2d6;		/* Byte offset 0x2d6, CSR Addr 0x5416b, Direction=N/A */
+	uint8_t reserved2d7;		/* Byte offset 0x2d7, CSR Addr 0x5416b, Direction=N/A */
+	uint8_t reserved2d8;		/* Byte offset 0x2d8, CSR Addr 0x5416c, Direction=N/A */
+	uint8_t reserved2d9;		/* Byte offset 0x2d9, CSR Addr 0x5416c, Direction=N/A */
+	uint8_t reserved2da;		/* Byte offset 0x2da, CSR Addr 0x5416d, Direction=N/A */
+	uint8_t reserved2db;		/* Byte offset 0x2db, CSR Addr 0x5416d, Direction=N/A */
+	uint8_t reserved2dc;		/* Byte offset 0x2dc, CSR Addr 0x5416e, Direction=N/A */
+	uint8_t reserved2dd;		/* Byte offset 0x2dd, CSR Addr 0x5416e, Direction=N/A */
+	uint8_t reserved2de;		/* Byte offset 0x2de, CSR Addr 0x5416f, Direction=N/A */
+	uint8_t reserved2df;		/* Byte offset 0x2df, CSR Addr 0x5416f, Direction=N/A */
+	uint8_t reserved2e0;		/* Byte offset 0x2e0, CSR Addr 0x54170, Direction=N/A */
+	uint8_t reserved2e1;		/* Byte offset 0x2e1, CSR Addr 0x54170, Direction=N/A */
+	uint8_t reserved2e2;		/* Byte offset 0x2e2, CSR Addr 0x54171, Direction=N/A */
+	uint8_t reserved2e3;		/* Byte offset 0x2e3, CSR Addr 0x54171, Direction=N/A */
+	uint8_t reserved2e4;		/* Byte offset 0x2e4, CSR Addr 0x54172, Direction=N/A */
+	uint8_t reserved2e5;		/* Byte offset 0x2e5, CSR Addr 0x54172, Direction=N/A */
+	uint8_t reserved2e6;		/* Byte offset 0x2e6, CSR Addr 0x54173, Direction=N/A */
+	uint8_t reserved2e7;		/* Byte offset 0x2e7, CSR Addr 0x54173, Direction=N/A */
+	uint8_t reserved2e8;		/* Byte offset 0x2e8, CSR Addr 0x54174, Direction=N/A */
+	uint8_t reserved2e9;		/* Byte offset 0x2e9, CSR Addr 0x54174, Direction=N/A */
+	uint8_t reserved2ea;		/* Byte offset 0x2ea, CSR Addr 0x54175, Direction=N/A */
+	uint8_t reserved2eb;		/* Byte offset 0x2eb, CSR Addr 0x54175, Direction=N/A */
+	uint8_t reserved2ec;		/* Byte offset 0x2ec, CSR Addr 0x54176, Direction=N/A */
+	uint8_t reserved2ed;		/* Byte offset 0x2ed, CSR Addr 0x54176, Direction=N/A */
+	uint8_t reserved2ee;		/* Byte offset 0x2ee, CSR Addr 0x54177, Direction=N/A */
+	uint8_t reserved2ef;		/* Byte offset 0x2ef, CSR Addr 0x54177, Direction=N/A */
+	uint8_t reserved2f0;		/* Byte offset 0x2f0, CSR Addr 0x54178, Direction=N/A */
+	uint8_t reserved2f1;		/* Byte offset 0x2f1, CSR Addr 0x54178, Direction=N/A */
+	uint8_t reserved2f2;		/* Byte offset 0x2f2, CSR Addr 0x54179, Direction=N/A */
+	uint8_t reserved2f3;		/* Byte offset 0x2f3, CSR Addr 0x54179, Direction=N/A */
+	uint8_t reserved2f4;		/* Byte offset 0x2f4, CSR Addr 0x5417a, Direction=N/A */
+	uint8_t reserved2f5;		/* Byte offset 0x2f5, CSR Addr 0x5417a, Direction=N/A */
+	uint8_t reserved2f6;		/* Byte offset 0x2f6, CSR Addr 0x5417b, Direction=N/A */
+	uint8_t reserved2f7;		/* Byte offset 0x2f7, CSR Addr 0x5417b, Direction=N/A */
+	uint8_t reserved2f8;		/* Byte offset 0x2f8, CSR Addr 0x5417c, Direction=N/A */
+	uint8_t reserved2f9;		/* Byte offset 0x2f9, CSR Addr 0x5417c, Direction=N/A */
+	uint8_t reserved2fa;		/* Byte offset 0x2fa, CSR Addr 0x5417d, Direction=N/A */
+	uint8_t reserved2fb;		/* Byte offset 0x2fb, CSR Addr 0x5417d, Direction=N/A */
+	uint8_t reserved2fc;		/* Byte offset 0x2fc, CSR Addr 0x5417e, Direction=N/A */
+	uint8_t reserved2fd;		/* Byte offset 0x2fd, CSR Addr 0x5417e, Direction=N/A */
+	uint8_t reserved2fe;		/* Byte offset 0x2fe, CSR Addr 0x5417f, Direction=N/A */
+	uint8_t reserved2ff;		/* Byte offset 0x2ff, CSR Addr 0x5417f, Direction=N/A */
+	uint8_t reserved300;		/* Byte offset 0x300, CSR Addr 0x54180, Direction=N/A */
+	uint8_t reserved301;		/* Byte offset 0x301, CSR Addr 0x54180, Direction=N/A */
+	uint8_t reserved302;		/* Byte offset 0x302, CSR Addr 0x54181, Direction=N/A */
+	uint8_t reserved303;		/* Byte offset 0x303, CSR Addr 0x54181, Direction=N/A */
+	uint8_t reserved304;		/* Byte offset 0x304, CSR Addr 0x54182, Direction=N/A */
+	uint8_t reserved305;		/* Byte offset 0x305, CSR Addr 0x54182, Direction=N/A */
+	uint8_t reserved306;		/* Byte offset 0x306, CSR Addr 0x54183, Direction=N/A */
+	uint8_t reserved307;		/* Byte offset 0x307, CSR Addr 0x54183, Direction=N/A */
+	uint8_t reserved308;		/* Byte offset 0x308, CSR Addr 0x54184, Direction=N/A */
+	uint8_t reserved309;		/* Byte offset 0x309, CSR Addr 0x54184, Direction=N/A */
+	uint8_t reserved30a;		/* Byte offset 0x30a, CSR Addr 0x54185, Direction=N/A */
+	uint8_t reserved30b;		/* Byte offset 0x30b, CSR Addr 0x54185, Direction=N/A */
+	uint8_t reserved30c;		/* Byte offset 0x30c, CSR Addr 0x54186, Direction=N/A */
+	uint8_t reserved30d;		/* Byte offset 0x30d, CSR Addr 0x54186, Direction=N/A */
+	uint8_t reserved30e;		/* Byte offset 0x30e, CSR Addr 0x54187, Direction=N/A */
+	uint8_t reserved30f;		/* Byte offset 0x30f, CSR Addr 0x54187, Direction=N/A */
+	uint8_t reserved310;		/* Byte offset 0x310, CSR Addr 0x54188, Direction=N/A */
+	uint8_t reserved311;		/* Byte offset 0x311, CSR Addr 0x54188, Direction=N/A */
+	uint8_t reserved312;		/* Byte offset 0x312, CSR Addr 0x54189, Direction=N/A */
+	uint8_t reserved313;		/* Byte offset 0x313, CSR Addr 0x54189, Direction=N/A */
+	uint8_t reserved314;		/* Byte offset 0x314, CSR Addr 0x5418a, Direction=N/A */
+	uint8_t reserved315;		/* Byte offset 0x315, CSR Addr 0x5418a, Direction=N/A */
+	uint8_t reserved316;		/* Byte offset 0x316, CSR Addr 0x5418b, Direction=N/A */
+	uint8_t reserved317;		/* Byte offset 0x317, CSR Addr 0x5418b, Direction=N/A */
+	uint8_t reserved318;		/* Byte offset 0x318, CSR Addr 0x5418c, Direction=N/A */
+	uint8_t reserved319;		/* Byte offset 0x319, CSR Addr 0x5418c, Direction=N/A */
+	uint8_t reserved31a;		/* Byte offset 0x31a, CSR Addr 0x5418d, Direction=N/A */
+	uint8_t reserved31b;		/* Byte offset 0x31b, CSR Addr 0x5418d, Direction=N/A */
+	uint8_t reserved31c;		/* Byte offset 0x31c, CSR Addr 0x5418e, Direction=N/A */
+	uint8_t reserved31d;		/* Byte offset 0x31d, CSR Addr 0x5418e, Direction=N/A */
+	uint8_t reserved31e;		/* Byte offset 0x31e, CSR Addr 0x5418f, Direction=N/A */
+	uint8_t reserved31f;		/* Byte offset 0x31f, CSR Addr 0x5418f, Direction=N/A */
+	uint8_t reserved320;		/* Byte offset 0x320, CSR Addr 0x54190, Direction=N/A */
+	uint8_t reserved321;		/* Byte offset 0x321, CSR Addr 0x54190, Direction=N/A */
+	uint8_t reserved322;		/* Byte offset 0x322, CSR Addr 0x54191, Direction=N/A */
+	uint8_t reserved323;		/* Byte offset 0x323, CSR Addr 0x54191, Direction=N/A */
+	uint8_t reserved324;		/* Byte offset 0x324, CSR Addr 0x54192, Direction=N/A */
+	uint8_t reserved325;		/* Byte offset 0x325, CSR Addr 0x54192, Direction=N/A */
+	uint8_t reserved326;		/* Byte offset 0x326, CSR Addr 0x54193, Direction=N/A */
+	uint8_t reserved327;		/* Byte offset 0x327, CSR Addr 0x54193, Direction=N/A */
+	uint8_t reserved328;		/* Byte offset 0x328, CSR Addr 0x54194, Direction=N/A */
+	uint8_t reserved329;		/* Byte offset 0x329, CSR Addr 0x54194, Direction=N/A */
+	uint8_t reserved32a;		/* Byte offset 0x32a, CSR Addr 0x54195, Direction=N/A */
+	uint8_t reserved32b;		/* Byte offset 0x32b, CSR Addr 0x54195, Direction=N/A */
+	uint8_t reserved32c;		/* Byte offset 0x32c, CSR Addr 0x54196, Direction=N/A */
+	uint8_t reserved32d;		/* Byte offset 0x32d, CSR Addr 0x54196, Direction=N/A */
+	uint8_t reserved32e;		/* Byte offset 0x32e, CSR Addr 0x54197, Direction=N/A */
+	uint8_t reserved32f;		/* Byte offset 0x32f, CSR Addr 0x54197, Direction=N/A */
+	uint8_t reserved330;		/* Byte offset 0x330, CSR Addr 0x54198, Direction=N/A */
+	uint8_t reserved331;		/* Byte offset 0x331, CSR Addr 0x54198, Direction=N/A */
+	uint8_t reserved332;		/* Byte offset 0x332, CSR Addr 0x54199, Direction=N/A */
+	uint8_t reserved333;		/* Byte offset 0x333, CSR Addr 0x54199, Direction=N/A */
+	uint8_t reserved334;		/* Byte offset 0x334, CSR Addr 0x5419a, Direction=N/A */
+	uint8_t reserved335;		/* Byte offset 0x335, CSR Addr 0x5419a, Direction=N/A */
+	uint8_t reserved336;		/* Byte offset 0x336, CSR Addr 0x5419b, Direction=N/A */
+	uint8_t reserved337;		/* Byte offset 0x337, CSR Addr 0x5419b, Direction=N/A */
+	uint8_t reserved338;		/* Byte offset 0x338, CSR Addr 0x5419c, Direction=N/A */
+	uint8_t reserved339;		/* Byte offset 0x339, CSR Addr 0x5419c, Direction=N/A */
+	uint8_t reserved33a;		/* Byte offset 0x33a, CSR Addr 0x5419d, Direction=N/A */
+	uint8_t reserved33b;		/* Byte offset 0x33b, CSR Addr 0x5419d, Direction=N/A */
+	uint8_t reserved33c;		/* Byte offset 0x33c, CSR Addr 0x5419e, Direction=N/A */
+	uint8_t reserved33d;		/* Byte offset 0x33d, CSR Addr 0x5419e, Direction=N/A */
+	uint8_t reserved33e;		/* Byte offset 0x33e, CSR Addr 0x5419f, Direction=N/A */
+	uint8_t reserved33f;		/* Byte offset 0x33f, CSR Addr 0x5419f, Direction=N/A */
+	uint8_t reserved340;		/* Byte offset 0x340, CSR Addr 0x541a0, Direction=N/A */
+	uint8_t reserved341;		/* Byte offset 0x341, CSR Addr 0x541a0, Direction=N/A */
+	uint8_t reserved342;		/* Byte offset 0x342, CSR Addr 0x541a1, Direction=N/A */
+	uint8_t reserved343;		/* Byte offset 0x343, CSR Addr 0x541a1, Direction=N/A */
+	uint8_t reserved344;		/* Byte offset 0x344, CSR Addr 0x541a2, Direction=N/A */
+	uint8_t reserved345;		/* Byte offset 0x345, CSR Addr 0x541a2, Direction=N/A */
+	uint8_t reserved346;		/* Byte offset 0x346, CSR Addr 0x541a3, Direction=N/A */
+	uint8_t reserved347;		/* Byte offset 0x347, CSR Addr 0x541a3, Direction=N/A */
+	uint8_t reserved348;		/* Byte offset 0x348, CSR Addr 0x541a4, Direction=N/A */
+	uint8_t reserved349;		/* Byte offset 0x349, CSR Addr 0x541a4, Direction=N/A */
+	uint8_t reserved34a;		/* Byte offset 0x34a, CSR Addr 0x541a5, Direction=N/A */
+	uint8_t reserved34b;		/* Byte offset 0x34b, CSR Addr 0x541a5, Direction=N/A */
+	uint8_t reserved34c;		/* Byte offset 0x34c, CSR Addr 0x541a6, Direction=N/A */
+	uint8_t reserved34d;		/* Byte offset 0x34d, CSR Addr 0x541a6, Direction=N/A */
+	uint8_t reserved34e;		/* Byte offset 0x34e, CSR Addr 0x541a7, Direction=N/A */
+	uint8_t reserved34f;		/* Byte offset 0x34f, CSR Addr 0x541a7, Direction=N/A */
+	uint8_t reserved350;		/* Byte offset 0x350, CSR Addr 0x541a8, Direction=N/A */
+	uint8_t reserved351;		/* Byte offset 0x351, CSR Addr 0x541a8, Direction=N/A */
+	uint8_t reserved352;		/* Byte offset 0x352, CSR Addr 0x541a9, Direction=N/A */
+	uint8_t reserved353;		/* Byte offset 0x353, CSR Addr 0x541a9, Direction=N/A */
+	uint8_t reserved354;		/* Byte offset 0x354, CSR Addr 0x541aa, Direction=N/A */
+	uint8_t reserved355;		/* Byte offset 0x355, CSR Addr 0x541aa, Direction=N/A */
+	uint8_t reserved356;		/* Byte offset 0x356, CSR Addr 0x541ab, Direction=N/A */
+	uint8_t reserved357;		/* Byte offset 0x357, CSR Addr 0x541ab, Direction=N/A */
+	uint8_t reserved358;		/* Byte offset 0x358, CSR Addr 0x541ac, Direction=N/A */
+	uint8_t reserved359;		/* Byte offset 0x359, CSR Addr 0x541ac, Direction=N/A */
+	uint8_t reserved35a;		/* Byte offset 0x35a, CSR Addr 0x541ad, Direction=N/A */
+	uint8_t reserved35b;		/* Byte offset 0x35b, CSR Addr 0x541ad, Direction=N/A */
+	uint8_t reserved35c;		/* Byte offset 0x35c, CSR Addr 0x541ae, Direction=N/A */
+	uint8_t reserved35d;		/* Byte offset 0x35d, CSR Addr 0x541ae, Direction=N/A */
+	uint8_t reserved35e;		/* Byte offset 0x35e, CSR Addr 0x541af, Direction=N/A */
+	uint8_t reserved35f;		/* Byte offset 0x35f, CSR Addr 0x541af, Direction=N/A */
+	uint8_t reserved360;		/* Byte offset 0x360, CSR Addr 0x541b0, Direction=N/A */
+	uint8_t reserved361;		/* Byte offset 0x361, CSR Addr 0x541b0, Direction=N/A */
+	uint8_t reserved362;		/* Byte offset 0x362, CSR Addr 0x541b1, Direction=N/A */
+	uint8_t reserved363;		/* Byte offset 0x363, CSR Addr 0x541b1, Direction=N/A */
+	uint8_t reserved364;		/* Byte offset 0x364, CSR Addr 0x541b2, Direction=N/A */
+	uint8_t reserved365;		/* Byte offset 0x365, CSR Addr 0x541b2, Direction=N/A */
+	uint8_t reserved366;		/* Byte offset 0x366, CSR Addr 0x541b3, Direction=N/A */
+	uint8_t reserved367;		/* Byte offset 0x367, CSR Addr 0x541b3, Direction=N/A */
+	uint8_t reserved368;		/* Byte offset 0x368, CSR Addr 0x541b4, Direction=N/A */
+	uint8_t reserved369;		/* Byte offset 0x369, CSR Addr 0x541b4, Direction=N/A */
+	uint8_t reserved36a;		/* Byte offset 0x36a, CSR Addr 0x541b5, Direction=N/A */
+	uint8_t reserved36b;		/* Byte offset 0x36b, CSR Addr 0x541b5, Direction=N/A */
+	uint8_t reserved36c;		/* Byte offset 0x36c, CSR Addr 0x541b6, Direction=N/A */
+	uint8_t reserved36d;		/* Byte offset 0x36d, CSR Addr 0x541b6, Direction=N/A */
+	uint8_t reserved36e;		/* Byte offset 0x36e, CSR Addr 0x541b7, Direction=N/A */
+	uint8_t reserved36f;		/* Byte offset 0x36f, CSR Addr 0x541b7, Direction=N/A */
+	uint8_t reserved370;		/* Byte offset 0x370, CSR Addr 0x541b8, Direction=N/A */
+	uint8_t reserved371;		/* Byte offset 0x371, CSR Addr 0x541b8, Direction=N/A */
+	uint8_t reserved372;		/* Byte offset 0x372, CSR Addr 0x541b9, Direction=N/A */
+	uint8_t reserved373;		/* Byte offset 0x373, CSR Addr 0x541b9, Direction=N/A */
+	uint8_t reserved374;		/* Byte offset 0x374, CSR Addr 0x541ba, Direction=N/A */
+	uint8_t reserved375;		/* Byte offset 0x375, CSR Addr 0x541ba, Direction=N/A */
+	uint8_t reserved376;		/* Byte offset 0x376, CSR Addr 0x541bb, Direction=N/A */
+	uint8_t reserved377;		/* Byte offset 0x377, CSR Addr 0x541bb, Direction=N/A */
+	uint8_t reserved378;		/* Byte offset 0x378, CSR Addr 0x541bc, Direction=N/A */
+	uint8_t reserved379;		/* Byte offset 0x379, CSR Addr 0x541bc, Direction=N/A */
+	uint8_t reserved37a;		/* Byte offset 0x37a, CSR Addr 0x541bd, Direction=N/A */
+	uint8_t reserved37b;		/* Byte offset 0x37b, CSR Addr 0x541bd, Direction=N/A */
+	uint8_t reserved37c;		/* Byte offset 0x37c, CSR Addr 0x541be, Direction=N/A */
+	uint8_t reserved37d;		/* Byte offset 0x37d, CSR Addr 0x541be, Direction=N/A */
+	uint8_t reserved37e;		/* Byte offset 0x37e, CSR Addr 0x541bf, Direction=N/A */
+	uint8_t reserved37f;		/* Byte offset 0x37f, CSR Addr 0x541bf, Direction=N/A */
+	uint8_t reserved380;		/* Byte offset 0x380, CSR Addr 0x541c0, Direction=N/A */
+	uint8_t reserved381;		/* Byte offset 0x381, CSR Addr 0x541c0, Direction=N/A */
+	uint8_t reserved382;		/* Byte offset 0x382, CSR Addr 0x541c1, Direction=N/A */
+	uint8_t reserved383;		/* Byte offset 0x383, CSR Addr 0x541c1, Direction=N/A */
+	uint8_t reserved384;		/* Byte offset 0x384, CSR Addr 0x541c2, Direction=N/A */
+	uint8_t reserved385;		/* Byte offset 0x385, CSR Addr 0x541c2, Direction=N/A */
+	uint8_t reserved386;		/* Byte offset 0x386, CSR Addr 0x541c3, Direction=N/A */
+	uint8_t reserved387;		/* Byte offset 0x387, CSR Addr 0x541c3, Direction=N/A */
+	uint8_t reserved388;		/* Byte offset 0x388, CSR Addr 0x541c4, Direction=N/A */
+	uint8_t reserved389;		/* Byte offset 0x389, CSR Addr 0x541c4, Direction=N/A */
+	uint8_t reserved38a;		/* Byte offset 0x38a, CSR Addr 0x541c5, Direction=N/A */
+	uint8_t reserved38b;		/* Byte offset 0x38b, CSR Addr 0x541c5, Direction=N/A */
+	uint8_t reserved38c;		/* Byte offset 0x38c, CSR Addr 0x541c6, Direction=N/A */
+	uint8_t reserved38d;		/* Byte offset 0x38d, CSR Addr 0x541c6, Direction=N/A */
+	uint8_t reserved38e;		/* Byte offset 0x38e, CSR Addr 0x541c7, Direction=N/A */
+	uint8_t reserved38f;		/* Byte offset 0x38f, CSR Addr 0x541c7, Direction=N/A */
+	uint8_t reserved390;		/* Byte offset 0x390, CSR Addr 0x541c8, Direction=N/A */
+	uint8_t reserved391;		/* Byte offset 0x391, CSR Addr 0x541c8, Direction=N/A */
+	uint8_t reserved392;		/* Byte offset 0x392, CSR Addr 0x541c9, Direction=N/A */
+	uint8_t reserved393;		/* Byte offset 0x393, CSR Addr 0x541c9, Direction=N/A */
+	uint8_t reserved394;		/* Byte offset 0x394, CSR Addr 0x541ca, Direction=N/A */
+	uint8_t reserved395;		/* Byte offset 0x395, CSR Addr 0x541ca, Direction=N/A */
+	uint8_t reserved396;		/* Byte offset 0x396, CSR Addr 0x541cb, Direction=N/A */
+	uint8_t reserved397;		/* Byte offset 0x397, CSR Addr 0x541cb, Direction=N/A */
+	uint8_t reserved398;		/* Byte offset 0x398, CSR Addr 0x541cc, Direction=N/A */
+	uint8_t reserved399;		/* Byte offset 0x399, CSR Addr 0x541cc, Direction=N/A */
+	uint8_t reserved39a;		/* Byte offset 0x39a, CSR Addr 0x541cd, Direction=N/A */
+	uint8_t reserved39b;		/* Byte offset 0x39b, CSR Addr 0x541cd, Direction=N/A */
+	uint8_t reserved39c;		/* Byte offset 0x39c, CSR Addr 0x541ce, Direction=N/A */
+	uint8_t reserved39d;		/* Byte offset 0x39d, CSR Addr 0x541ce, Direction=N/A */
+	uint8_t reserved39e;		/* Byte offset 0x39e, CSR Addr 0x541cf, Direction=N/A */
+	uint8_t reserved39f;		/* Byte offset 0x39f, CSR Addr 0x541cf, Direction=N/A */
+	uint8_t reserved3a0;		/* Byte offset 0x3a0, CSR Addr 0x541d0, Direction=N/A */
+	uint8_t reserved3a1;		/* Byte offset 0x3a1, CSR Addr 0x541d0, Direction=N/A */
+	uint8_t reserved3a2;		/* Byte offset 0x3a2, CSR Addr 0x541d1, Direction=N/A */
+	uint8_t reserved3a3;		/* Byte offset 0x3a3, CSR Addr 0x541d1, Direction=N/A */
+	uint8_t reserved3a4;		/* Byte offset 0x3a4, CSR Addr 0x541d2, Direction=N/A */
+	uint8_t reserved3a5;		/* Byte offset 0x3a5, CSR Addr 0x541d2, Direction=N/A */
+	uint8_t reserved3a6;		/* Byte offset 0x3a6, CSR Addr 0x541d3, Direction=N/A */
+	uint8_t reserved3a7;		/* Byte offset 0x3a7, CSR Addr 0x541d3, Direction=N/A */
+	uint8_t reserved3a8;		/* Byte offset 0x3a8, CSR Addr 0x541d4, Direction=N/A */
+	uint8_t reserved3a9;		/* Byte offset 0x3a9, CSR Addr 0x541d4, Direction=N/A */
+	uint8_t reserved3aa;		/* Byte offset 0x3aa, CSR Addr 0x541d5, Direction=N/A */
+	uint8_t reserved3ab;		/* Byte offset 0x3ab, CSR Addr 0x541d5, Direction=N/A */
+	uint8_t reserved3ac;		/* Byte offset 0x3ac, CSR Addr 0x541d6, Direction=N/A */
+	uint8_t reserved3ad;		/* Byte offset 0x3ad, CSR Addr 0x541d6, Direction=N/A */
+	uint8_t reserved3ae;		/* Byte offset 0x3ae, CSR Addr 0x541d7, Direction=N/A */
+	uint8_t reserved3af;		/* Byte offset 0x3af, CSR Addr 0x541d7, Direction=N/A */
+	uint8_t reserved3b0;		/* Byte offset 0x3b0, CSR Addr 0x541d8, Direction=N/A */
+	uint8_t reserved3b1;		/* Byte offset 0x3b1, CSR Addr 0x541d8, Direction=N/A */
+	uint8_t reserved3b2;		/* Byte offset 0x3b2, CSR Addr 0x541d9, Direction=N/A */
+	uint8_t reserved3b3;		/* Byte offset 0x3b3, CSR Addr 0x541d9, Direction=N/A */
+	uint8_t reserved3b4;		/* Byte offset 0x3b4, CSR Addr 0x541da, Direction=N/A */
+	uint8_t reserved3b5;		/* Byte offset 0x3b5, CSR Addr 0x541da, Direction=N/A */
+	uint8_t reserved3b6;		/* Byte offset 0x3b6, CSR Addr 0x541db, Direction=N/A */
+	uint8_t reserved3b7;		/* Byte offset 0x3b7, CSR Addr 0x541db, Direction=N/A */
+	uint8_t reserved3b8;		/* Byte offset 0x3b8, CSR Addr 0x541dc, Direction=N/A */
+	uint8_t reserved3b9;		/* Byte offset 0x3b9, CSR Addr 0x541dc, Direction=N/A */
+	uint8_t reserved3ba;		/* Byte offset 0x3ba, CSR Addr 0x541dd, Direction=N/A */
+	uint8_t reserved3bb;		/* Byte offset 0x3bb, CSR Addr 0x541dd, Direction=N/A */
+	uint8_t reserved3bc;		/* Byte offset 0x3bc, CSR Addr 0x541de, Direction=N/A */
+	uint8_t reserved3bd;		/* Byte offset 0x3bd, CSR Addr 0x541de, Direction=N/A */
+	uint8_t reserved3be;		/* Byte offset 0x3be, CSR Addr 0x541df, Direction=N/A */
+	uint8_t reserved3bf;		/* Byte offset 0x3bf, CSR Addr 0x541df, Direction=N/A */
+	uint8_t reserved3c0;		/* Byte offset 0x3c0, CSR Addr 0x541e0, Direction=N/A */
+	uint8_t reserved3c1;		/* Byte offset 0x3c1, CSR Addr 0x541e0, Direction=N/A */
+	uint8_t reserved3c2;		/* Byte offset 0x3c2, CSR Addr 0x541e1, Direction=N/A */
+	uint8_t reserved3c3;		/* Byte offset 0x3c3, CSR Addr 0x541e1, Direction=N/A */
+	uint8_t reserved3c4;		/* Byte offset 0x3c4, CSR Addr 0x541e2, Direction=N/A */
+	uint8_t reserved3c5;		/* Byte offset 0x3c5, CSR Addr 0x541e2, Direction=N/A */
+	uint8_t reserved3c6;		/* Byte offset 0x3c6, CSR Addr 0x541e3, Direction=N/A */
+	uint8_t reserved3c7;		/* Byte offset 0x3c7, CSR Addr 0x541e3, Direction=N/A */
+	uint8_t reserved3c8;		/* Byte offset 0x3c8, CSR Addr 0x541e4, Direction=N/A */
+	uint8_t reserved3c9;		/* Byte offset 0x3c9, CSR Addr 0x541e4, Direction=N/A */
+	uint8_t reserved3ca;		/* Byte offset 0x3ca, CSR Addr 0x541e5, Direction=N/A */
+	uint8_t reserved3cb;		/* Byte offset 0x3cb, CSR Addr 0x541e5, Direction=N/A */
+	uint8_t reserved3cc;		/* Byte offset 0x3cc, CSR Addr 0x541e6, Direction=N/A */
+	uint8_t reserved3cd;		/* Byte offset 0x3cd, CSR Addr 0x541e6, Direction=N/A */
+	uint8_t reserved3ce;		/* Byte offset 0x3ce, CSR Addr 0x541e7, Direction=N/A */
+	uint8_t reserved3cf;		/* Byte offset 0x3cf, CSR Addr 0x541e7, Direction=N/A */
+	uint8_t reserved3d0;		/* Byte offset 0x3d0, CSR Addr 0x541e8, Direction=N/A */
+	uint8_t reserved3d1;		/* Byte offset 0x3d1, CSR Addr 0x541e8, Direction=N/A */
+	uint8_t reserved3d2;		/* Byte offset 0x3d2, CSR Addr 0x541e9, Direction=N/A */
+	uint8_t reserved3d3;		/* Byte offset 0x3d3, CSR Addr 0x541e9, Direction=N/A */
+	uint8_t reserved3d4;		/* Byte offset 0x3d4, CSR Addr 0x541ea, Direction=N/A */
+	uint8_t reserved3d5;		/* Byte offset 0x3d5, CSR Addr 0x541ea, Direction=N/A */
+	uint8_t reserved3d6;		/* Byte offset 0x3d6, CSR Addr 0x541eb, Direction=N/A */
+	uint8_t reserved3d7;		/* Byte offset 0x3d7, CSR Addr 0x541eb, Direction=N/A */
+	uint8_t reserved3d8;		/* Byte offset 0x3d8, CSR Addr 0x541ec, Direction=N/A */
+	uint8_t reserved3d9;		/* Byte offset 0x3d9, CSR Addr 0x541ec, Direction=N/A */
+	uint8_t reserved3da;		/* Byte offset 0x3da, CSR Addr 0x541ed, Direction=N/A */
+	uint8_t reserved3db;		/* Byte offset 0x3db, CSR Addr 0x541ed, Direction=N/A */
+	uint8_t reserved3dc;		/* Byte offset 0x3dc, CSR Addr 0x541ee, Direction=N/A */
+	uint8_t reserved3dd;		/* Byte offset 0x3dd, CSR Addr 0x541ee, Direction=N/A */
+	uint8_t reserved3de;		/* Byte offset 0x3de, CSR Addr 0x541ef, Direction=N/A */
+	uint8_t reserved3df;		/* Byte offset 0x3df, CSR Addr 0x541ef, Direction=N/A */
+	uint8_t reserved3e0;		/* Byte offset 0x3e0, CSR Addr 0x541f0, Direction=N/A */
+	uint8_t reserved3e1;		/* Byte offset 0x3e1, CSR Addr 0x541f0, Direction=N/A */
+	uint8_t reserved3e2;		/* Byte offset 0x3e2, CSR Addr 0x541f1, Direction=N/A */
+	uint8_t reserved3e3;		/* Byte offset 0x3e3, CSR Addr 0x541f1, Direction=N/A */
+	uint8_t reserved3e4;		/* Byte offset 0x3e4, CSR Addr 0x541f2, Direction=N/A */
+	uint8_t reserved3e5;		/* Byte offset 0x3e5, CSR Addr 0x541f2, Direction=N/A */
+	uint8_t reserved3e6;		/* Byte offset 0x3e6, CSR Addr 0x541f3, Direction=N/A */
+	uint8_t reserved3e7;		/* Byte offset 0x3e7, CSR Addr 0x541f3, Direction=N/A */
+	uint8_t reserved3e8;		/* Byte offset 0x3e8, CSR Addr 0x541f4, Direction=N/A */
+	uint8_t reserved3e9;		/* Byte offset 0x3e9, CSR Addr 0x541f4, Direction=N/A */
+	uint8_t reserved3ea;		/* Byte offset 0x3ea, CSR Addr 0x541f5, Direction=N/A */
+	uint8_t reserved3eb;		/* Byte offset 0x3eb, CSR Addr 0x541f5, Direction=N/A */
+	uint8_t reserved3ec;		/* Byte offset 0x3ec, CSR Addr 0x541f6, Direction=N/A */
+	uint8_t reserved3ed;		/* Byte offset 0x3ed, CSR Addr 0x541f6, Direction=N/A */
+	uint8_t reserved3ee;		/* Byte offset 0x3ee, CSR Addr 0x541f7, Direction=N/A */
+	uint8_t reserved3ef;		/* Byte offset 0x3ef, CSR Addr 0x541f7, Direction=N/A */
+	uint8_t reserved3f0;		/* Byte offset 0x3f0, CSR Addr 0x541f8, Direction=N/A */
+	uint8_t reserved3f1;		/* Byte offset 0x3f1, CSR Addr 0x541f8, Direction=N/A */
+	uint8_t reserved3f2;		/* Byte offset 0x3f2, CSR Addr 0x541f9, Direction=N/A */
+	uint8_t reserved3f3;		/* Byte offset 0x3f3, CSR Addr 0x541f9, Direction=N/A */
+	uint8_t reserved3f4;		/* Byte offset 0x3f4, CSR Addr 0x541fa, Direction=N/A */
+	uint8_t reserved3f5;		/* Byte offset 0x3f5, CSR Addr 0x541fa, Direction=N/A */
+	uint16_t alt_cas_l;		/*
+					 * Byte offset 0x3f6, CSR Addr 0x541fb, Direction=in
+					 * This field must be populated if RdDBI is enabled
+					 * (applicable when mr5[A12] == 1).
+					 * RdDBI is dynamically disabled in certain training steps,
+					 * and so the [RdDBI disabled] CAS Latency must be provided
+					 * in this field.
+					 * The required encoding is as follows:
+					 * alt_cas_l[0] == 0: use value in mr0
+					 * alt_cas_l[0] == 1: use value in alt_cas_l, i.e.,
+					 *   mr0{A[12],A[6],A[5],A[4],A[2]} = alt_cas_l[12,6,5,4,2]
+					 * Other bits are ignored
+					 */
+	uint8_t alt_wcas_l;		/*
+					 * Byte offset 0x3f8, CSR Addr 0x541fc, Direction=In
+					 * This field must be populated if 2tCK write preambles are
+					 * enabled (applicable when mr4[A12] == 1).
+					 * 2tCK write prambles are dynamically disabled in certain
+					 * training steps, and so the [1tCK write preamble] WCAS
+					 * Latency must be provided in this field.
+					 * The required encoding is as follows:
+					 * alt_wcas_l[0] == 0: use value in mr2
+					 * alt_wcas_l[0] == 1: use value in alt_wcas_l, i.e.,
+					 *   mr2{A[5],A[4],A[3]} = alt_wcas_l[5,4,3]
+					 * Other bits are ignored
+					 */
+	uint8_t d4misc;			/*
+					 * Byte offset 0x3f9, CSR Addr 0x541fc, Direction=In
+					 * Contains various options for training DDR4 Devices.
+					 *
+					 * Bit fields:
+					 *
+					 * d4misc[7:5,2,1] RFU, must be zero
+					 *
+					 * d4misc[0] = protect memory reset
+					 *   0x1 = dfi_reset_n cannot control BP_MEMRESERT_L to
+					 *         devices after training.
+					 *   0x0 = dfi_resert_n can control BP_MEMRESERT_L to
+					 *         devices after training
+					 *
+					 * d4misc[3]: reserved
+					 *
+					 * d4misc[4]: DRAM reset mode
+					 *   0x1 = Do not reset DRAM during devinit
+					 *   0x0 = Reset DRAM during devinit
+					 */
+} __attribute__ ((packed)) __attribute__ ((aligned(2))) pmu_smb_ddr_1d_t;
+
+#endif /* MNPMUSRAMMSGBLOCK_DDR4_H */
diff --git a/drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_lpddr4.h b/drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_lpddr4.h
new file mode 100644
index 000000000..1d46a0439
--- /dev/null
+++ b/drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_lpddr4.h
@@ -0,0 +1,967 @@
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef MNPMUSRAMMSGBLOCK_LPDDR4_H
+#define MNPMUSRAMMSGBLOCK_LPDDR4_H
+
+/* LPDDR4_1D training firmware message block structure
+ *
+ * Please refer to the Training Firmware App Note for futher information about
+ * the usage for Message Block.
+ */
+typedef struct _pmu_smb_ddr_1d_t {
+	uint8_t reserved00;		/*
+					 * Byte offset 0x00, CSR Addr 0x54000, Direction=In
+					 * reserved00[0:4] RFU, must be zero
+					 *
+					 * reserved00[5] = Quick Rd2D during 1D Training
+					 *   0x1 = Read Deskew will begin by enabling and quickly
+					 *   training the phy's per-lane reference voltages.
+					 *   Training the vrefDACs CSRs will increase the maximum 1D
+					 *   training time by around half a millisecond, but will
+					 *   improve 1D training accuracy on systems with
+					 *   significant voltage-offsets between lane read eyes.
+					 *   0x0 = Read Deskew will assume the messageblock's
+					 *   phyVref setting is optimal for all lanes.
+					 *
+					 * reserved00[6] = Enable High Effort WrDQ1D
+					 *   0x1 = WrDQ1D will conditionally retry training at
+					 *   several extra RxClkDly Timings. This will increase the
+					 *   maximum 1D training time by up to 4 extra iterations of
+					 *   WrDQ1D. This is only required in systems that suffer
+					 *   from very large, asymmetric eye-collapse when receiving
+					 *   PRBS patterns.
+					 *   0x0 = WrDQ1D assume rxClkDly values found by SI
+					 *   Friendly RdDqs1D will work for receiving PRBS patterns
+					 *
+					 * reserved00[7] = Optimize for the special hard macros in
+					 * TSMC28.
+					 *   0x1 = set if the phy being trained was manufactured in
+					 *   any TSMC28 process node.
+					 *   0x0 = otherwise, when not training a TSMC28 phy, leave
+					 *   this field as 0.
+					 */
+	uint8_t msgmisc;		/*
+					 * Byte offset 0x01, CSR Addr 0x54000, Direction=In
+					 * Contains various global options for training.
+					 *
+					 * Bit fields:
+					 *
+					 * msgmisc[0] MTESTEnable
+					 *   0x1 = Pulse primary digital test output bump at the end
+					 *   of each major training stage. This enables observation
+					 *   of training stage completion by observing the digital
+					 *   test output.
+					 *   0x0 = Do not pulse primary digital test output bump
+					 *
+					 * msgmisc[1] SimulationOnlyReset
+					 *   0x1 = Verilog only simulation option to shorten
+					 *   duration of DRAM reset pulse length to 1ns.
+					 *   Must never be set to 1 in silicon.
+					 *   0x0 = Use reset pulse length specifed by JEDEC standard
+					 *
+					 * msgmisc[2] SimulationOnlyTraining
+					 *   0x1 = Verilog only simulation option to shorten the
+					 *   duration of the training steps by performing fewer
+					 *   iterations.
+					 *   Must never be set to 1 in silicon.
+					 *   0x0 = Use standard training duration.
+					 *
+					 * msgmisc[3] Disable Boot Clock
+					 *   0x1 = Disable boot frequency clock when initializing
+					 *   DRAM. (not recommended)
+					 *   0x0 = Use Boot Frequency Clock
+					 *
+					 * msgmisc[4] Suppress streaming messages, including
+					 * assertions, regardless of hdtctrl setting.
+					 * Stage Completion messages, as well as training completion
+					 * and error messages are still sent depending on hdtctrl
+					 * setting.
+					 *
+					 * msgmisc[5] PerByteMaxRdLat
+					 *   0x1 = Each DBYTE will return dfi_rddata_valid at the
+					 *   lowest possible latency. This may result in unaligned
+					 *   data between bytes to be returned to the DFI.
+					 *   0x0 = Every DBYTE will return dfi_rddata_valid
+					 *   simultaneously. This will ensure that data bytes will
+					 *   return aligned accesses to the DFI.
+					 *
+					 * msgmisc[7-6] RFU, must be zero
+					 *
+					 * Notes:
+					 *
+					 * - SimulationOnlyReset and SimulationOnlyTraining can be
+					 *   used to speed up simulation run times, and must never
+					 *   be used in real silicon. Some VIPs may have checks on
+					 *   DRAM reset parameters that may need to be disabled when
+					 *   using SimulationOnlyReset.
+					 */
+	uint16_t pmurevision;		/*
+					 * Byte offset 0x02, CSR Addr 0x54001, Direction=Out
+					 * PMU firmware revision ID
+					 * After training is run, this address will contain the
+					 * revision ID of the firmware
+					 */
+	uint8_t pstate;			/*
+					 * Byte offset 0x04, CSR Addr 0x54002, Direction=In
+					 * Must be set to the target pstate to be trained
+					 *   0x0 = pstate 0
+					 *   0x1 = pstate 1
+					 *   0x2 = pstate 2
+					 *   0x3 = pstate 3
+					 *   All other encodings are reserved
+					 */
+	uint8_t pllbypassen;		/*
+					 * Byte offset 0x05, CSR Addr 0x54002, Direction=In
+					 * Set according to whether target pstate uses PHY PLL
+					 * bypass
+					 *   0x0 = PHY PLL is enabled for target pstate
+					 *   0x1 = PHY PLL is bypassed for target pstate
+					 */
+	uint16_t dramfreq;		/*
+					 * Byte offset 0x06, CSR Addr 0x54003, Direction=In
+					 * DDR data rate for the target pstate in units of MT/s.
+					 * For example enter 0x0640 for DDR1600.
+					 */
+	uint8_t dfifreqratio;		/*
+					 * Byte offset 0x08, CSR Addr 0x54004, Direction=In
+					 * Frequency ratio betwen DfiCtlClk and SDRAM memclk.
+					 *   0x1 = 1:1
+					 *   0x2 = 1:2
+					 *   0x4 = 1:4
+					 */
+	uint8_t bpznresval;		/*
+					 * Byte offset 0x09, CSR Addr 0x54004, Direction=In
+					 * Must be programmed to match the precision resistor
+					 * connected to Phy BP_ZN
+					 *   0x00 = Do not program. Use current CSR value.
+					 *   0xf0 = 240 Ohm (recommended value)
+					 *   0x78 = 120 Ohm
+					 *   0x28 = 40 Ohm
+					 *   All other values are reserved.
+					 */
+	uint8_t phyodtimpedance;	/*
+					 * Byte offset 0x0a, CSR Addr 0x54005, Direction=In
+					 * Must be programmed to the termination impedance in ohms
+					 * used by PHY during reads.
+					 *
+					 * 0x0 = Firmware skips programming (must be manually
+					 * programmed by user prior to training start)
+					 *
+					 * See PHY databook for legal termination impedance values.
+					 *
+					 * For digital simulation, any legal value can be used. For
+					 * silicon, the users must determine the correct value
+					 * through SI simulation or other methods.
+					 */
+	uint8_t phydrvimpedance;	/*
+					 * Byte offset 0x0b, CSR Addr 0x54005, Direction=In
+					 * Must be programmed to the driver impedance in ohms used
+					 * by PHY during writes for all DBYTE drivers
+					 * (DQ/DM/DBI/DQS).
+					 *
+					 *   0x0 = Firmware skips programming (must be manually
+					 *   programmed by user prior to training start)
+					 *
+					 * See PHY databook for legal R_on driver impedance values.
+					 *
+					 * For digital simulation, any value can be used that is not
+					 * Hi-Z. For silicon, the users must determine the correct
+					 * value through SI simulation or other methods.
+					 */
+	uint8_t phyvref;		/*
+					 * Byte offset 0x0c, CSR Addr 0x54006, Direction=In
+					 * Must be programmed with the Vref level to be used by the
+					 * PHY during reads
+					 *
+					 * The units of this field are a percentage of VDDQ
+					 * according to the following equation:
+					 *
+					 * Receiver Vref = VDDQ*phyvref[6:0]/128
+					 *
+					 * For example to set Vref at 0.25*VDDQ, set this field to
+					 * 0x20.
+					 *
+					 * For digital simulation, any legal value can be used. For
+					 * silicon, the users must calculate the analytical Vref by
+					 * using the impedances, terminations, and series resistance
+					 * present in the system.
+					 */
+	uint8_t lp4misc;		/*
+					 * Byte offset 0x0d, CSR Addr 0x54006, Direction=In
+					 * Lp4 specific options for training.
+					 *
+					 * Bit fields:
+					 *
+					 * lp4misc[0] Enable dfi_reset_n
+					 *
+					 *   0x0 = (Recommended) PHY internal registers control
+					 *   memreset during training, and also after training.
+					 *   dfi_reset_n cannot control the PHY BP_MEMRESET_L pin.
+					 *
+					 *   0x1 = Enables dfi_reset_n to control memreset after
+					 *   training. PHY Internal registers control memreset
+					 *   during training only. To ensure that no glitches occur
+					 *   on BP_MEMRESET at the end of training, The MC must
+					 *   drive dfi_reset_n=1'b1 _prior to starting training_
+					 *
+					 * lp4misc[7-1] RFU, must be zero
+					 */
+	uint8_t reserved0e;		/*
+					 * Byte offset 0x0e, CSR Addr 0x54007, Direction=In
+					 * Bit Field for enabling optional 2D training features
+					 * that impact both Rx2D and Tx2D.
+					 *
+					 * reserved0E[0:3]: bitTimeControl
+					 * input for the amount of data bits 2D writes/reads per DQ
+					 * before deciding if any specific voltage and delay setting
+					 * passes or fails. Every time this input increases by 1,
+					 * the number of 2D data comparisons is doubled. The 2D run
+					 * time will increase proportionally to the number of bit
+					 * times requested per point.
+					 *   0 = 288 bits per point (legacy behavior)
+					 *   1 = 576 bits per point
+					 *   2 = 1.125 kilobits per point
+					 *     . . .
+					 *   15 = 9 megabits per point
+					 *
+					 * reserved0E[4]: Exhaustive2D
+					 *   0 = 2D optimization assumes the optimal trained point
+					 *   is near the 1D trained point (legacy behavior)
+					 *   1 = 2D optimization searches the entire passing region
+					 *   at the cost of run time. Recommended for optimal
+					 *   results any time the optimal trained point is expected
+					 *   to be near the edges of the eyes instead of near the 1D
+					 *   trained point.
+					 *
+					 * reserved0E[5]: Detect Vref Eye Truncation, ignored if
+					 * eyeWeight2DControl == 0.
+					 *   0 = 2D optimizes for the passing region it can measure.
+					 *   1 = For every eye, 2D checks If the legal voltage range
+					 *   truncated the eye. If the true voltage margin cannot be
+					 *   measured, 2D will optimize heavily for delay margin
+					 *   instead of using incomplete voltage margin data. Eyes
+					 *   that are not truncated will still be optimized using
+					 *   user programmed weights.
+					 *
+					 * reserved0E[6]: eyeWeight2DControl
+					 *   0 = Use 8 bit weights for Delay_Weight2D and
+					 *   Voltage_Weight2D and disable TrunkV behavior.
+					 *   1 = Use 4 bit weights for Delay_weight2D and
+					 *   Voltage_Weight2D and enable TrunkV behavior.
+					 *
+					 * reserved0E[7]: RFU, must be 0
+					 */
+	uint8_t cstestfail;		/*
+					 * Byte offset 0x0f, CSR Addr 0x54007, Direction=Out
+					 * This field will be set if training fails on any rank.
+					 *   0x0 = No failures
+					 *   non-zero = one or more ranks failed training
+					 */
+	uint16_t sequencectrl;		/*
+					 * Byte offset 0x10, CSR Addr 0x54008, Direction=In
+					 * Controls the training steps to be run. Each bit
+					 * corresponds to a training step.
+					 *
+					 * If the bit is set to 1, the training step will run.
+					 * If the bit is set to 0, the training step will be
+					 * skipped.
+					 *
+					 * Training step to bit mapping:
+					 * sequencectrl[0] = Run DevInit - Device/phy
+					 *                   initialization. Should always be set.
+					 * sequencectrl[1] = Run WrLvl - Write leveling
+					 * sequencectrl[2] = Run RxEn - Read gate training
+					 * sequencectrl[3] = Run RdDQS1D - 1d read dqs training
+					 * sequencectrl[4] = Run WrDQ1D - 1d write dq training
+					 * sequencectrl[5] = RFU, must be zero
+					 * sequencectrl[6] = RFU, must be zero
+					 * sequencectrl[7] = RFU, must be zero
+					 * sequencectrl[8] = Run RdDeskew - Per lane read dq deskew
+					 *                   training
+					 * sequencectrl[9] = Run MxRdLat - Max read latency training
+					 * sequencectrl[11-10] = RFU, must be zero
+					 * sequencectrl[12] = Run LPCA - CA Training
+					 * sequencectrl[15-13] = RFU, must be zero
+					 */
+	uint8_t hdtctrl;		/*
+					 * Byte offset 0x12, CSR Addr 0x54009, Direction=In
+					 * To control the total number of debug messages, a
+					 * verbosity subfield (hdtctrl, Hardware Debug Trace
+					 * Control) exists in the message block. Every message has a
+					 * verbosity level associated with it, and as the hdtctrl
+					 * value is increased, less important s messages stop being
+					 * sent through the mailboxes. The meanings of several major
+					 * hdtctrl thresholds are explained below:
+					 *
+					 *   0x04 = Maximal debug messages (e.g., Eye contours)
+					 *   0x05 = Detailed debug messages (e.g. Eye delays)
+					 *   0x0A = Coarse debug messages (e.g. rank information)
+					 *   0xC8 = Stage completion
+					 *   0xC9 = Assertion messages
+					 *   0xFF = Firmware completion messages only
+					 *
+					 * See Training App Note for more detailed information on
+					 * what messages are included for each threshold.
+					 */
+	uint8_t reserved13;		/*
+					 * Byte offset 0x13, CSR Addr 0x54009, Direction=In
+					 *
+					 *   0 = Default operation, unchanged.
+					 *   Others = RD DQ calibration Training steps are completed
+					 *   with user specified pattern.
+					 */
+	uint8_t reserved14;		/*
+					 * Byte offset 0x14, CSR Addr 0x5400a, Direction=In
+					 * Configure rd2D search iteration from a starting seed
+					 * point:
+					 *
+					 * reserved14[5:0]: If reserved14[6] is 0, Number of search
+					 * iterations (if 0, then default is 20); otherwise if this
+					 * value non zero, this value is used as a delta to filter
+					 * out points during the averaging: when averaging over a
+					 * dimension (delay or voltage), the points having a margin
+					 * smaller than the max of the eye in this dimension by at
+					 * least this delta value are filtered out.
+					 *
+					 * reserved14[6]: If set, instead of search, extract center
+					 * using an averaging function over the eye surface area,
+					 * where some points can be filtered out using
+					 * reserved14[5:0]
+					 *
+					 * reserved14[7]: if set, start search with large step size,
+					 * decreasing at each 4 iterations, down to 1 (do not care
+					 * if reserved14[6] is set)
+					 */
+	uint8_t reserved15;		/*
+					 * Byte offset 0x15, CSR Addr 0x5400a, Direction=In
+					 * Configure wr2D search iteration from a starting seed
+					 * point:
+					 *
+					 * reserved15[5:0]: If reserved15[6] is 0, Number of search
+					 * iterations (if 0, then default is 20); otherwise if this
+					 * value non zero, this value is used as a delta to filter
+					 * out points during the averaging: when averaging over a
+					 * dimension (delay or voltage), the points having a margin
+					 * smaller than the max of the eye in this dimension by at
+					 * least this delta value are filtered out.
+					 *
+					 * reserved15[6]: If set, instead of search, extract center
+					 * using an averaging function over the eye surface area,
+					 * where some points can be filtered out using
+					 * reserved15[5:0]
+					 *
+					 * reserved15[7]: if set, start search with large step size,
+					 * decreasing at each 4 iterations, down to 1 (do not care
+					 * if reserved15[6] is set)
+					 */
+	uint8_t dfimrlmargin;		/*
+					 * Byte offset 0x16, CSR Addr 0x5400b, Direction=In
+					 * Margin added to smallest passing trained DFI Max Read
+					 * Latency value, in units of DFI clocks. Recommended to be
+					 * >= 1. See the Training App Note for more details on the
+					 * training process and the use of this value.
+					 *
+					 * This margin must include the maximum positive drift
+					 * expected in tDQSCK over the target temperature and
+					 * voltage range of the users system.
+					 */
+	uint8_t reserved17;		/*
+					 * Byte offset 0x17, CSR Addr 0x5400b, Direction=In
+					 * Configure DB from which extra info is dump during 2D
+					 * training when maximal debug is set:
+					 *
+					 * reserved17[3:0]: first DB
+					 *
+					 * reserved17[7:4]: number of DB, including first DB (if 0,
+					 * no extra debug per DB is dump)
+					 */
+	uint8_t usebroadcastmr;		/*
+					 * Byte offset 0x18, CSR Addr 0x5400c, Direction=In
+					 * Training firmware can optionally set per rank mode
+					 * register values for DRAM partial array self-refresh
+					 * features if desired.
+					 *
+					 *   0x0 = Use mr<0:17>_a0 for rank 0 channel A
+					 *	   Use mr<0:17>_b0 for rank 0 channel B
+					 *	   Use mr<0:17>_a1 for rank 1 channel A
+					 *	   Use mr<0:17>_b1 for rank 1 channel B
+					 *
+					 *   0x1 = Use mr<0:17>_a0 setting for all channels/ranks
+					 *
+					 * It is recommended in most LPDDR4 system configurations
+					 * to set this to 1.
+					 *
+					 * Note: When set to 0, only mode registers associated with
+					 * Vref CA, Vref DQ, and DRAM partial array self-refresh may
+					 * differ between ranks and channels.
+					 */
+	uint8_t lp4quickboot;		/*
+					 * Byte offset 0x19, CSR Addr 0x5400c, Direction=In
+					 * Enable Quickboot.
+					 */
+	uint8_t reserved1a;		/*
+					 * Byte offset 0x1a, CSR Addr 0x5400d, Direction=In
+					 * Input for constraining the range of vref(DQ) values
+					 * training will collect data for, usually reducing training
+					 * time. However, too large of a voltage range may cause
+					 * longer 2D training times while too small of a voltage
+					 * range may truncate passing regions. When in doubt, leave
+					 * this field set to 0.
+					 * Used by 2D stages: Rd2D, Wr2D
+					 *
+					 * reserved1A[0-3]: Rd2D Voltage Range
+					 *   0 = Training will search all phy vref(DQ) settings
+					 *   1 = limit to +/-2 %VDDQ from phyVref
+					 *   2 = limit to +/-4 %VDDQ from phyVref
+					 *     . . .
+					 *   15 = limit to +/-30% VDDQ from phyVref
+					 *
+					 * reserved1A[4-7]: Wr2D Voltage Range
+					 *   0 = Training will search all dram vref(DQ) settings
+					 *   1 = limit to +/-2 %VDDQ from mr14
+					 *   2 = limit to +/-4 %VDDQ from mr14
+					 *     . . .
+					 *   15 = limit to +/-30% VDDQ from mr14
+					 */
+	uint8_t catrainopt;		/*
+					 * Byte offset 0x1b, CSR Addr 0x5400d, Direction=In
+					 * CA training option bit field
+					 * [0] CA VREF Training
+					 *   1 = Enable CA VREF Training
+					 *   0 = Disable CA VREF Training
+					 *  WARNING: catrainopt[0] must be set to the same value in
+					 *  1D and 2D training.
+					 *
+					 * [1-7] RFU must be zero
+					 */
+	uint8_t x8mode;			/*
+					 * Byte offset 0x1c, CSR Addr 0x5400e, Direction=In
+					 * X8 mode configuration:
+					 *   0x0 = x16 configuration for all devices
+					 *   0xF = x8 configuration for all devices
+					 * All other values are RFU
+					 */
+	uint8_t reserved1d;		/* Byte offset 0x1d, CSR Addr 0x5400e, Direction=N/A */
+	uint8_t reserved1e;		/* Byte offset 0x1e, CSR Addr 0x5400f, Direction=N/A */
+	uint8_t share2dvrefresult;	/*
+					 * Byte offset 0x1f, CSR Addr 0x5400f, Direction=In
+					 * Bitmap that designates the phy's vref source for every
+					 * pstate
+					 * If share2dvrefresult[x] = 0, then after 2D training,
+					 * pstate x will continue using the phyVref provided in
+					 * pstate x's 1D messageblock.
+					 * If share2dvrefresult[x] = 1, then after 2D training,
+					 * pstate x will use the per-lane VrefDAC0/1 CSRs trained by
+					 * 2d training.
+					 */
+	uint8_t reserved20;		/* Byte offset 0x20, CSR Addr 0x54010, Direction=N/A */
+	uint8_t reserved21;		/* Byte offset 0x21, CSR Addr 0x54010, Direction=N/A */
+	uint16_t phyconfigoverride;	/*
+					 * Byte offset 0x22, CSR Addr 0x54011, Direction=In
+					 * Override PhyConfig csr.
+					 *   0x0: Use hardware csr value for PhyConfing
+					 *   (recommended)
+					 *   Other values: Use value for PhyConfig instead of
+					 *   Hardware value.
+					 *
+					 */
+	uint8_t enableddqscha;		/*
+					 * Byte offset 0x24, CSR Addr 0x54012, Direction=In
+					 * Total number of DQ bits enabled in PHY Channel A
+					 */
+	uint8_t cspresentcha;		/*
+					 * Byte offset 0x25, CSR Addr 0x54012, Direction=In
+					 * Indicates presence of DRAM at each chip select for PHY
+					 * channel A.
+					 *   0x1 = CS0 is populated with DRAM
+					 *   0x3 = CS0 and CS1 are populated with DRAM
+					 *
+					 * All other encodings are illegal
+					 */
+	int8_t cdd_cha_rr_1_0;		/*
+					 * Byte offset 0x26, CSR Addr 0x54013, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 1 to cs 0
+					 * on Channel A
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_cha_rr_0_1;		/*
+					 * Byte offset 0x27, CSR Addr 0x54013, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 0 to cs 1
+					 * on Channel A
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_cha_rw_1_1;		/*
+					 * Byte offset 0x28, CSR Addr 0x54014, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to cs 1
+					 * on Channel A
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_cha_rw_1_0;		/*
+					 * Byte offset 0x29, CSR Addr 0x54014, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to cs 0
+					 * on Channel A
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_cha_rw_0_1;		/*
+					 * Byte offset 0x2a, CSR Addr 0x54015, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to cs 1
+					 * on Channel A
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_cha_rw_0_0;		/*
+					 * Byte offset 0x2b, CSR Addr 0x54015, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs0 to cs 0
+					 * on Channel A
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_cha_wr_1_1;		/*
+					 * Byte offset 0x2c, CSR Addr 0x54016, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to cs 1
+					 * on Channel A
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_cha_wr_1_0;		/*
+					 * Byte offset 0x2d, CSR Addr 0x54016, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to cs 0
+					 * on Channel A
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_cha_wr_0_1;		/*
+					 * Byte offset 0x2e, CSR Addr 0x54017, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to cs 1
+					 * on Channel A
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_cha_wr_0_0;		/*
+					 * Byte offset 0x2f, CSR Addr 0x54017, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to cs 0
+					 * on Channel A
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_cha_ww_1_0;		/*
+					 * Byte offset 0x30, CSR Addr 0x54018, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 1 to cs
+					 * 0 on Channel A
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_cha_ww_0_1;		/*
+					 * Byte offset 0x31, CSR Addr 0x54018, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 0 to cs
+					 * 1 on Channel A
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	uint8_t mr1_a0;			/*
+					 * Byte offset 0x32, CSR Addr 0x54019, Direction=In
+					 * Value to be programmed in DRAM Mode Register 1
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr2_a0;			/*
+					 * Byte offset 0x33, CSR Addr 0x54019, Direction=In
+					 * Value to be programmed in DRAM Mode Register 2
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr3_a0;			/*
+					 * Byte offset 0x34, CSR Addr 0x5401a, Direction=In
+					 * Value to be programmed in DRAM Mode Register 3
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr4_a0;			/*
+					 * Byte offset 0x35, CSR Addr 0x5401a, Direction=In
+					 * Value to be programmed in DRAM Mode Register 4
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr11_a0;		/*
+					 * Byte offset 0x36, CSR Addr 0x5401b, Direction=In
+					 * Value to be programmed in DRAM Mode Register 11
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr12_a0;		/*
+					 * Byte offset 0x37, CSR Addr 0x5401b, Direction=In
+					 * Value to be programmed in DRAM Mode Register 12
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr13_a0;		/*
+					 * Byte offset 0x38, CSR Addr 0x5401c, Direction=In
+					 * Value to be programmed in DRAM Mode Register 13
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr14_a0;		/*
+					 * Byte offset 0x39, CSR Addr 0x5401c, Direction=In
+					 * Value to be programmed in DRAM Mode Register 14
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr16_a0;		/*
+					 * Byte offset 0x3a, CSR Addr 0x5401d, Direction=In
+					 * Value to be programmed in DRAM Mode Register 16
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr17_a0;		/*
+					 * Byte offset 0x3b, CSR Addr 0x5401d, Direction=In
+					 * Value to be programmed in DRAM Mode Register 17
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr22_a0;		/*
+					 * Byte offset 0x3c, CSR Addr 0x5401e, Direction=In
+					 * Value to be programmed in DRAM Mode Register 22
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr24_a0;		/*
+					 * Byte offset 0x3d, CSR Addr 0x5401e, Direction=In
+					 * Value to be programmed in DRAM Mode Register 24
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr1_a1;			/*
+					 * Byte offset 0x3e, CSR Addr 0x5401f, Direction=In
+					 * Value to be programmed in DRAM Mode Register 1
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr2_a1;			/*
+					 * Byte offset 0x3f, CSR Addr 0x5401f, Direction=In
+					 * Value to be programmed in DRAM Mode Register 2
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr3_a1;			/*
+					 * Byte offset 0x40, CSR Addr 0x54020, Direction=In
+					 * Value to be programmed in DRAM Mode Register 3
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr4_a1;			/*
+					 * Byte offset 0x41, CSR Addr 0x54020, Direction=In
+					 * Value to be programmed in DRAM Mode Register 4
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr11_a1;		/*
+					 * Byte offset 0x42, CSR Addr 0x54021, Direction=In
+					 * Value to be programmed in DRAM Mode Register 11
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr12_a1;		/*
+					 * Byte offset 0x43, CSR Addr 0x54021, Direction=In
+					 * Value to be programmed in DRAM Mode Register 12
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr13_a1;		/*
+					 * Byte offset 0x44, CSR Addr 0x54022, Direction=In
+					 * Value to be programmed in DRAM Mode Register 13
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr14_a1;		/*
+					 * Byte offset 0x45, CSR Addr 0x54022, Direction=In
+					 * Value to be programmed in DRAM Mode Register 14
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr16_a1;		/*
+					 * Byte offset 0x46, CSR Addr 0x54023, Direction=In
+					 * Value to be programmed in DRAM Mode Register 16
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr17_a1;		/*
+					 * Byte offset 0x47, CSR Addr 0x54023, Direction=In
+					 * Value to be programmed in DRAM Mode Register 17
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr22_a1;		/*
+					 * Byte offset 0x48, CSR Addr 0x54024, Direction=In
+					 * Value to be programmed in DRAM Mode Register 22
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr24_a1;		/*
+					 * Byte offset 0x49, CSR Addr 0x54024, Direction=In
+					 * Value to be programmed in DRAM Mode Register 24
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t caterminatingrankcha;	/* Byte offset 0x4a, CSR Addr 0x54025, Direction=In
+					 * Terminating Rank for CA bus on Channel A
+					 *   0x0 = Rank 0 is terminating rank
+					 *   0x1 = Rank 1 is terminating rank
+					 */
+	uint8_t reserved4b;		/* Byte offset 0x4b, CSR Addr 0x54025, Direction=N/A */
+	uint8_t reserved4c;		/* Byte offset 0x4c, CSR Addr 0x54026, Direction=N/A */
+	uint8_t reserved4d;		/* Byte offset 0x4d, CSR Addr 0x54026, Direction=N/A */
+	uint8_t reserved4e;		/* Byte offset 0x4e, CSR Addr 0x54027, Direction=N/A */
+	uint8_t reserved4f;		/* Byte offset 0x4f, CSR Addr 0x54027, Direction=N/A */
+	uint8_t reserved50;		/* Byte offset 0x50, CSR Addr 0x54028, Direction=N/A */
+	uint8_t reserved51;		/* Byte offset 0x51, CSR Addr 0x54028, Direction=N/A */
+	uint8_t reserved52;		/* Byte offset 0x52, CSR Addr 0x54029, Direction=N/A */
+	uint8_t reserved53;		/* Byte offset 0x53, CSR Addr 0x54029, Direction=N/A */
+	uint8_t reserved54;		/* Byte offset 0x54, CSR Addr 0x5402a, Direction=N/A */
+	uint8_t reserved55;		/* Byte offset 0x55, CSR Addr 0x5402a, Direction=N/A */
+	uint8_t reserved56;		/* Byte offset 0x56, CSR Addr 0x5402b, Direction=N/A */
+	uint8_t enableddqschb;		/*
+					 * Byte offset 0x57, CSR Addr 0x5402b, Direction=In
+					 * Total number of DQ bits enabled in PHY Channel B
+					 */
+	uint8_t cspresentchb;		/*
+					 * Byte offset 0x58, CSR Addr 0x5402c, Direction=In
+					 * Indicates presence of DRAM at each chip select for PHY
+					 * channel B.
+					 *   0x0 = No chip selects are populated with DRAM
+					 *   0x1 = CS0 is populated with DRAM
+					 *   0x3 = CS0 and CS1 are populated with DRAM
+					 *
+					 * All other encodings are illegal
+					 */
+	int8_t cdd_chb_rr_1_0;		/*
+					 * Byte offset 0x59, CSR Addr 0x5402c, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 1 to cs 0
+					 * on Channel B
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_chb_rr_0_1;		/*
+					 * Byte offset 0x5a, CSR Addr 0x5402d, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 0 to cs 1
+					 * on Channel B
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_chb_rw_1_1;		/*
+					 * Byte offset 0x5b, CSR Addr 0x5402d, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to cs 1
+					 * on Channel B
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_chb_rw_1_0;		/*
+					 * Byte offset 0x5c, CSR Addr 0x5402e, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to cs 0
+					 * on Channel B
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_chb_rw_0_1;		/*
+					 * Byte offset 0x5d, CSR Addr 0x5402e, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to cs 1
+					 * on Channel B
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_chb_rw_0_0;		/*
+					 * Byte offset 0x5e, CSR Addr 0x5402f, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs01 to cs 0
+					 * on Channel B
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_chb_wr_1_1;		/*
+					 * Byte offset 0x5f, CSR Addr 0x5402f, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to cs 1
+					 * on Channel B
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_chb_wr_1_0;		/*
+					 * Byte offset 0x60, CSR Addr 0x54030, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to cs 0
+					 * on Channel B
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_chb_wr_0_1;		/*
+					 * Byte offset 0x61, CSR Addr 0x54030, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to cs 1
+					 * on Channel B
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_chb_wr_0_0;		/*
+					 * Byte offset 0x62, CSR Addr 0x54031, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to cs 0
+					 * on Channel B
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_chb_ww_1_0;		/*
+					 * Byte offset 0x63, CSR Addr 0x54031, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 1 to cs
+					 * 0 on Channel B
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	int8_t cdd_chb_ww_0_1;		/*
+					 * Byte offset 0x64, CSR Addr 0x54032, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 0 to cs
+					 * 1 on Channel B
+					 * See PUB Databook section 8.2 for details on use of CDD
+					 * values.
+					 */
+	uint8_t mr1_b0;			/*
+					 * Byte offset 0x65, CSR Addr 0x54032, Direction=In
+					 * Value to be programmed in DRAM Mode Register 1
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr2_b0;			/*
+					 * Byte offset 0x66, CSR Addr 0x54033, Direction=In
+					 * Value to be programmed in DRAM Mode Register 2
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr3_b0;			/*
+					 * Byte offset 0x67, CSR Addr 0x54033, Direction=In
+					 * Value to be programmed in DRAM Mode Register 3
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr4_b0;			/*
+					 * Byte offset 0x68, CSR Addr 0x54034, Direction=In
+					 * Value to be programmed in DRAM Mode Register 4
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr11_b0;		/*
+					 * Byte offset 0x69, CSR Addr 0x54034, Direction=In
+					 * Value to be programmed in DRAM Mode Register 11
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr12_b0;		/*
+					 * Byte offset 0x6a, CSR Addr 0x54035, Direction=In
+					 * Value to be programmed in DRAM Mode Register 12
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr13_b0;		/*
+					 * Byte offset 0x6b, CSR Addr 0x54035, Direction=In
+					 * Value to be programmed in DRAM Mode Register 13
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr14_b0;		/*
+					 * Byte offset 0x6c, CSR Addr 0x54036, Direction=In
+					 * Value to be programmed in DRAM Mode Register 14
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr16_b0;		/*
+					 * Byte offset 0x6d, CSR Addr 0x54036, Direction=In
+					 * Value to be programmed in DRAM Mode Register 16
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr17_b0;		/*
+					 * Byte offset 0x6e, CSR Addr 0x54037, Direction=In
+					 * Value to be programmed in DRAM Mode Register 17
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr22_b0;		/*
+					 * Byte offset 0x6f, CSR Addr 0x54037, Direction=In
+					 * Value to be programmed in DRAM Mode Register 22
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr24_b0;		/*
+					 * Byte offset 0x70, CSR Addr 0x54038, Direction=In
+					 * Value to be programmed in DRAM Mode Register 24
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr1_b1;			/*
+					 * Byte offset 0x71, CSR Addr 0x54038, Direction=In
+					 * Value to be programmed in DRAM Mode Register 1
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr2_b1;			/*
+					 * Byte offset 0x72, CSR Addr 0x54039, Direction=In
+					 * Value to be programmed in DRAM Mode Register 2
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr3_b1;			/*
+					 * Byte offset 0x73, CSR Addr 0x54039, Direction=In
+					 * Value to be programmed in DRAM Mode Register 3
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr4_b1;			/*
+					 * Byte offset 0x74, CSR Addr 0x5403a, Direction=In
+					 * Value to be programmed in DRAM Mode Register 4
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr11_b1;		/*
+					 * Byte offset 0x75, CSR Addr 0x5403a, Direction=In
+					 * Value to be programmed in DRAM Mode Register 11
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr12_b1;		/*
+					 * Byte offset 0x76, CSR Addr 0x5403b, Direction=In
+					 * Value to be programmed in DRAM Mode Register 12
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr13_b1;		/*
+					 * Byte offset 0x77, CSR Addr 0x5403b, Direction=In
+					 * Value to be programmed in DRAM Mode Register 13
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr14_b1;		/*
+					 * Byte offset 0x78, CSR Addr 0x5403c, Direction=In
+					 * Value to be programmed in DRAM Mode Register 14
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr16_b1;		/*
+					 * Byte offset 0x79, CSR Addr 0x5403c, Direction=In
+					 * Value to be programmed in DRAM Mode Register 16
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr17_b1;		/*
+					 * Byte offset 0x7a, CSR Addr 0x5403d, Direction=In
+					 * Value to be programmed in DRAM Mode Register 17
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr22_b1;		/*
+					 * Byte offset 0x7b, CSR Addr 0x5403d, Direction=In
+					 * Value to be programmed in DRAM Mode Register 22
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr24_b1;		/*
+					 * Byte offset 0x7c, CSR Addr 0x5403e, Direction=In
+					 * Value to be programmed in DRAM Mode Register 24
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t caterminatingrankchb;	/* Byte offset 0x7d, CSR Addr 0x5403e, Direction=In
+					 * Terminating Rank for CA bus on Channel B
+					 *   0x0 = Rank 0 is terminating rank
+					 *   0x1 = Rank 1 is terminating rank
+					 */
+	uint8_t reserved7e;		/* Byte offset 0x7e, CSR Addr 0x5403f, Direction=N/A */
+	uint8_t reserved7f;		/* Byte offset 0x7f, CSR Addr 0x5403f, Direction=N/A */
+	uint8_t reserved80;		/* Byte offset 0x80, CSR Addr 0x54040, Direction=N/A */
+	uint8_t reserved81;		/* Byte offset 0x81, CSR Addr 0x54040, Direction=N/A */
+	uint8_t reserved82;		/* Byte offset 0x82, CSR Addr 0x54041, Direction=N/A */
+	uint8_t reserved83;		/* Byte offset 0x83, CSR Addr 0x54041, Direction=N/A */
+	uint8_t reserved84;		/* Byte offset 0x84, CSR Addr 0x54042, Direction=N/A */
+	uint8_t reserved85;		/* Byte offset 0x85, CSR Addr 0x54042, Direction=N/A */
+	uint8_t reserved86;		/* Byte offset 0x86, CSR Addr 0x54043, Direction=N/A */
+	uint8_t reserved87;		/* Byte offset 0x87, CSR Addr 0x54043, Direction=N/A */
+	uint8_t reserved88;		/* Byte offset 0x88, CSR Addr 0x54044, Direction=N/A */
+	uint8_t reserved89;		/* Byte offset 0x89, CSR Addr 0x54044, Direction=N/A */
+} __attribute__ ((packed)) __attribute__ ((aligned(2))) pmu_smb_ddr_1d_t;
+
+#endif /* MNPMUSRAMMSGBLOCK_LPDDR4_H */
diff --git a/drivers/st/ddr/phy/phyinit/include/ddrphy_csr_all_cdefines.h b/drivers/st/ddr/phy/phyinit/include/ddrphy_csr_all_cdefines.h
new file mode 100644
index 000000000..ce2967114
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/include/ddrphy_csr_all_cdefines.h
@@ -0,0 +1,6947 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef DDRPHY_PHYINIT_CSR_ALL_DEFINES_H
+#define DDRPHY_PHYINIT_CSR_ALL_DEFINES_H
+
+/* ANIBx register offsets */
+#define CSR_MTESTMUXSEL_ADDR				0x1AU
+#define CSR_AFORCEDRVCONT_ADDR				0x27U
+#define CSR_AFORCETRICONT_ADDR				0x28U
+#define CSR_ATXIMPEDANCE_ADDR				0x43U
+#define CSR_ATESTPRBSERR_ADDR				0x53U
+#define CSR_ATXSLEWRATE_ADDR				0x55U
+#define CSR_ATESTPRBSERRCNT_ADDR			0x56U
+#define CSR_ATXDLY_ADDR					0x80U
+
+/* DBYTEx register offsets */
+#define CSR_DBYTEMISCMODE_ADDR				0x0U
+#define CSR_TSMBYTE0_ADDR				0x1U
+#define CSR_TRAININGPARAM_ADDR				0x2U
+#define CSR_USEDQSENREPLICA_ADDR			0x3U
+#define CSR_RXTRAINPATTERNENABLE_ADDR			0x10U
+#define CSR_TSMBYTE1_ADDR				0x11U
+#define CSR_TSMBYTE2_ADDR				0x12U
+#define CSR_TSMBYTE3_ADDR				0x13U
+#define CSR_TSMBYTE4_ADDR				0x14U
+#define CSR_TESTMODECONFIG_ADDR				0x17U
+#define CSR_TSMBYTE5_ADDR				0x18U
+/* MTESTMUXSEL already defined in ANIBx section */
+#define CSR_DTSMTRAINMODECTRL_ADDR			0x1FU
+#define CSR_DFIMRL_ADDR					0x20U
+#define CSR_ASYNCDBYTEMODE_ADDR				0x24U
+#define CSR_ASYNCDBYTETXEN_ADDR				0x26U
+#define CSR_ASYNCDBYTETXDATA_ADDR			0x28U
+#define CSR_ASYNCDBYTERXDATA_ADDR			0x2AU
+#define CSR_VREFDAC1_ADDR				0x30U
+#define CSR_TRAININGCNTR_ADDR				0x32U
+#define CSR_VREFDAC0_ADDR				0x40U
+#define CSR_TXIMPEDANCECTRL0_ADDR			0x41U
+#define CSR_DQDQSRCVCNTRL_ADDR				0x43U
+#define CSR_TXEQUALIZATIONMODE_ADDR			0x48U
+#define CSR_TXIMPEDANCECTRL1_ADDR			0x49U
+#define CSR_DQDQSRCVCNTRL1_ADDR				0x4AU
+#define CSR_TXIMPEDANCECTRL2_ADDR			0x4BU
+#define CSR_DQDQSRCVCNTRL2_ADDR				0x4CU
+#define CSR_TXODTDRVSTREN_ADDR				0x4DU
+#define CSR_RXFIFOCHECKSTATUS_ADDR			0x56U
+#define CSR_RXFIFOCHECKERRVALUES_ADDR			0x57U
+#define CSR_RXFIFOINFO_ADDR				0x58U
+#define CSR_RXFIFOVISIBILITY_ADDR			0x59U
+#define CSR_RXFIFOCONTENTSDQ3210_ADDR			0x5AU
+#define CSR_RXFIFOCONTENTSDQ7654_ADDR			0x5BU
+#define CSR_RXFIFOCONTENTSDBI_ADDR			0x5CU
+#define CSR_TXSLEWRATE_ADDR				0x5FU
+#define CSR_TRAININGINCDECDTSMEN_ADDR			0x62U
+#define CSR_RXPBDLYTG0_ADDR				0x68U
+#define CSR_RXPBDLYTG1_ADDR				0x69U
+#define CSR_RXPBDLYTG2_ADDR				0x6AU
+#define CSR_RXPBDLYTG3_ADDR				0x6BU
+#define CSR_RXENDLYTG0_ADDR				0x80U
+#define CSR_RXENDLYTG1_ADDR				0x81U
+#define CSR_RXENDLYTG2_ADDR				0x82U
+#define CSR_RXENDLYTG3_ADDR				0x83U
+#define CSR_RXCLKDLYTG0_ADDR				0x8CU
+#define CSR_RXCLKDLYTG1_ADDR				0x8DU
+#define CSR_RXCLKDLYTG2_ADDR				0x8EU
+#define CSR_RXCLKDLYTG3_ADDR				0x8FU
+#define CSR_RXCLKCDLYTG0_ADDR				0x90U
+#define CSR_RXCLKCDLYTG1_ADDR				0x91U
+#define CSR_RXCLKCDLYTG2_ADDR				0x92U
+#define CSR_RXCLKCDLYTG3_ADDR				0x93U
+#define CSR_DQ0LNSEL_ADDR				0xA0U
+#define CSR_DQ1LNSEL_ADDR				0xA1U
+#define CSR_DQ2LNSEL_ADDR				0xA2U
+#define CSR_DQ3LNSEL_ADDR				0xA3U
+#define CSR_DQ4LNSEL_ADDR				0xA4U
+#define CSR_DQ5LNSEL_ADDR				0xA5U
+#define CSR_DQ6LNSEL_ADDR				0xA6U
+#define CSR_DQ7LNSEL_ADDR				0xA7U
+#define CSR_PPTCTLSTATIC_ADDR				0xAAU
+#define CSR_PPTCTLDYN_ADDR				0xABU
+#define CSR_PPTINFO_ADDR				0xACU
+#define CSR_PPTRXENEVNT_ADDR				0xADU
+#define CSR_PPTDQSCNTINVTRNTG0_ADDR			0xAEU
+#define CSR_PPTDQSCNTINVTRNTG1_ADDR			0xAFU
+#define CSR_DTSMBLANKINGCTRL_ADDR			0xB1U
+#define CSR_TSM0_ADDR					0xB2U
+#define CSR_TSM1_ADDR					0xB3U
+#define CSR_TSM2_ADDR					0xB4U
+#define CSR_TSM3_ADDR					0xB5U
+#define CSR_TXCHKDATASELECTS_ADDR			0xB6U
+#define CSR_DTSMUPTHLDXINGIND_ADDR			0xB7U
+#define CSR_DTSMLOTHLDXINGIND_ADDR			0xB8U
+#define CSR_DBYTEALLDTSMCTRL0_ADDR			0xB9U
+#define CSR_DBYTEALLDTSMCTRL1_ADDR			0xBAU
+#define CSR_DBYTEALLDTSMCTRL2_ADDR			0xBBU
+#define CSR_TXDQDLYTG0_ADDR				0xC0U
+#define CSR_TXDQDLYTG1_ADDR				0xC1U
+#define CSR_TXDQDLYTG2_ADDR				0xC2U
+#define CSR_TXDQDLYTG3_ADDR				0xC3U
+#define CSR_TXDQSDLYTG0_ADDR				0xD0U
+#define CSR_TXDQSDLYTG1_ADDR				0xD1U
+#define CSR_TXDQSDLYTG2_ADDR				0xD2U
+#define CSR_TXDQSDLYTG3_ADDR				0xD3U
+#define CSR_DXLCDLSTATUS_ADDR				0xE4U
+
+/* MASTER0 register offsets */
+#define CSR_RXFIFOINIT_ADDR				0x0U
+#define CSR_FORCECLKDISABLE_ADDR			0x1U
+#define CSR_CLOCKINGCTRL_ADDR				0x2U
+#define CSR_FORCEINTERNALUPDATE_ADDR			0x3U
+#define CSR_PHYCONFIG_ADDR				0x4U
+#define CSR_PGCR_ADDR					0x5U
+#define CSR_TESTBUMPCNTRL1_ADDR				0x7U
+#define CSR_CALUCLKINFO_ADDR				0x8U
+#define CSR_TESTBUMPCNTRL_ADDR				0xAU
+#define CSR_SEQ0BDLY0_ADDR				0xBU
+#define CSR_SEQ0BDLY1_ADDR				0xCU
+#define CSR_SEQ0BDLY2_ADDR				0xDU
+#define CSR_SEQ0BDLY3_ADDR				0xEU
+#define CSR_PHYALERTSTATUS_ADDR				0xFU
+#define CSR_PPTTRAINSETUP_ADDR				0x10U
+#define CSR_PPTTRAINSETUP2_ADDR				0x11U
+#define CSR_ATESTMODE_ADDR				0x12U
+#define CSR_TXCALBINP_ADDR				0x14U
+#define CSR_TXCALBINN_ADDR				0x15U
+#define CSR_TXCALPOVR_ADDR				0x16U
+#define CSR_TXCALNOVR_ADDR				0x17U
+#define CSR_DFIMODE_ADDR				0x18U
+#define CSR_TRISTATEMODECA_ADDR				0x19U
+/* MTESTMUXSEL already defined in ANIBx section */
+#define CSR_MTESTPGMINFO_ADDR				0x1BU
+#define CSR_DYNPWRDNUP_ADDR				0x1CU
+#define CSR_PMIENABLE_ADDR				0x1DU
+#define CSR_PHYTID_ADDR					0x1EU
+#define CSR_HWTMRL_ADDR					0x20U
+#define CSR_DFIPHYUPD_ADDR				0x21U
+#define CSR_PDAMRSWRITEMODE_ADDR			0x22U
+#define CSR_DFIGEARDOWNCTL_ADDR				0x23U
+#define CSR_DQSPREAMBLECONTROL_ADDR			0x24U
+#define CSR_MASTERX4CONFIG_ADDR				0x25U
+#define CSR_WRLEVBITS_ADDR				0x26U
+#define CSR_ENABLECSMULTICAST_ADDR			0x27U
+#define CSR_HWTLPCSMULTICAST_ADDR			0x28U
+#define CSR_ACX4ANIBDIS_ADDR				0x2CU
+#define CSR_DMIPINPRESENT_ADDR				0x2DU
+#define CSR_ARDPTRINITVAL_ADDR				0x2EU
+#define CSR_DB0LCDLCALPHDETOUT_ADDR			0x30U
+#define CSR_DB1LCDLCALPHDETOUT_ADDR			0x31U
+#define CSR_DB2LCDLCALPHDETOUT_ADDR			0x32U
+#define CSR_DB3LCDLCALPHDETOUT_ADDR			0x33U
+#define CSR_DB4LCDLCALPHDETOUT_ADDR			0x34U
+#define CSR_DB5LCDLCALPHDETOUT_ADDR			0x35U
+#define CSR_DB6LCDLCALPHDETOUT_ADDR			0x36U
+#define CSR_DB7LCDLCALPHDETOUT_ADDR			0x37U
+#define CSR_DB8LCDLCALPHDETOUT_ADDR			0x38U
+#define CSR_DB9LCDLCALPHDETOUT_ADDR			0x39U
+#define CSR_DBYTEDLLMODECNTRL_ADDR			0x3AU
+#define CSR_DBYTERXENTRAIN_ADDR				0x3BU
+#define CSR_ANLCDLCALPHDETOUT_ADDR			0x3FU
+#define CSR_CALOFFSETS_ADDR				0x45U
+#define CSR_SARINITVALS_ADDR				0x47U
+#define CSR_CALPEXTOVR_ADDR				0x49U
+#define CSR_CALCMPR5OVR_ADDR				0x4AU
+#define CSR_CALNINTOVR_ADDR				0x4BU
+#define CSR_CALDRVSTR0_ADDR				0x50U
+#define CSR_PROCODTCTL_ADDR				0x55U
+#define CSR_PROCODTTIMECTL_ADDR				0x56U
+#define CSR_MEMALERTCONTROL_ADDR			0x5BU
+#define CSR_MEMALERTCONTROL2_ADDR			0x5CU
+#define CSR_MEMRESETL_ADDR				0x60U
+#define CSR_PUBMODE_ADDR				0x6EU
+#define CSR_MISCPHYSTATUS_ADDR				0x6FU
+#define CSR_CORELOOPBACKSEL_ADDR			0x70U
+#define CSR_DLLTRAINPARAM_ADDR				0x71U
+#define CSR_HWTLPCSENA_ADDR				0x72U
+#define CSR_HWTLPCSENB_ADDR				0x73U
+#define CSR_HWTLPCSENBYPASS_ADDR			0x74U
+#define CSR_DFICAMODE_ADDR				0x75U
+#define CSR_HWTCACTL_ADDR				0x76U
+#define CSR_HWTCAMODE_ADDR				0x77U
+#define CSR_DLLCONTROL_ADDR				0x78U
+#define CSR_PULSEDLLUPDATEPHASE_ADDR			0x79U
+#define CSR_HWTCONTROLOVR0_ADDR				0x7AU
+#define CSR_HWTCONTROLOVR1_ADDR				0x7BU
+#define CSR_DLLGAINCTL_ADDR				0x7CU
+#define CSR_DLLLOCKPARAM_ADDR				0x7DU
+#define CSR_HWTCONTROLVAL0_ADDR				0x7EU
+#define CSR_HWTCONTROLVAL1_ADDR				0x7FU
+#define CSR_ACSMGLBLSTART_ADDR				0x81U
+#define CSR_ACSMGLBLSGLSTPCTRL_ADDR			0x82U
+#define CSR_LCDLCALPHASE_ADDR				0x84U
+#define CSR_LCDLCALCTRL_ADDR				0x85U
+#define CSR_CALRATE_ADDR				0x88U
+#define CSR_CALZAP_ADDR					0x89U
+#define CSR_PSTATE_ADDR					0x8BU
+#define CSR_CALPREDRIVEROVERRIDE_ADDR			0x8CU
+#define CSR_PLLOUTGATECONTROL_ADDR			0x8DU
+#define CSR_UCMEMRESETCONTROL_ADDR			0x8FU
+#define CSR_PORCONTROL_ADDR				0x90U
+#define CSR_CALBUSY_ADDR				0x97U
+#define CSR_CALMISC2_ADDR				0x98U
+#define CSR_CALMISC_ADDR				0x9AU
+#define CSR_CALVREFS_ADDR				0x9BU
+#define CSR_CALCMPR5_ADDR				0x9CU
+#define CSR_CALNINT_ADDR				0x9DU
+#define CSR_CALPEXT_ADDR				0x9EU
+#define CSR_CALCMPINVERT_ADDR				0xA8U
+#define CSR_CALCMPANACNTRL_ADDR				0xAEU
+#define CSR_DFIRDDATACSDESTMAP_ADDR			0xB0U
+#define CSR_VREFINGLOBAL_ADDR				0xB2U
+#define CSR_DFIWRDATACSDESTMAP_ADDR			0xB4U
+#define CSR_MASUPDGOODCTR_ADDR				0xB5U
+#define CSR_PHYUPD0GOODCTR_ADDR				0xB6U
+#define CSR_PHYUPD1GOODCTR_ADDR				0xB7U
+#define CSR_CTLUPD0GOODCTR_ADDR				0xB8U
+#define CSR_CTLUPD1GOODCTR_ADDR				0xB9U
+#define CSR_MASUPDFAILCTR_ADDR				0xBAU
+#define CSR_PHYUPD0FAILCTR_ADDR				0xBBU
+#define CSR_PHYUPD1FAILCTR_ADDR				0xBCU
+#define CSR_PHYPERFCTRENABLE_ADDR			0xBDU
+#define CSR_DFIWRRDDATACSCONFIG_ADDR			0xBEU
+#define CSR_PLLPWRDN_ADDR				0xC3U
+#define CSR_PLLRESET_ADDR				0xC4U
+#define CSR_PLLCTRL2_ADDR				0xC5U
+#define CSR_PLLCTRL0_ADDR				0xC6U
+#define CSR_PLLCTRL1_ADDR				0xC7U
+#define CSR_PLLTST_ADDR					0xC8U
+#define CSR_PLLLOCKSTATUS_ADDR				0xC9U
+#define CSR_PLLTESTMODE_ADDR				0xCAU
+#define CSR_PLLCTRL3_ADDR				0xCBU
+#define CSR_PLLCTRL4_ADDR				0xCCU
+#define CSR_PLLENDOFCAL_ADDR				0xCDU
+#define CSR_PLLSTANDBYEFF_ADDR				0xCEU
+#define CSR_PLLDACVALOUT_ADDR				0xCFU
+#define CSR_DLYTESTSEQ_ADDR				0xD0U
+#define CSR_DLYTESTRINGSELDB_ADDR			0xD1U
+#define CSR_DLYTESTRINGSELAC_ADDR			0xD2U
+#define CSR_DLYTESTCNTDFICLKIV_ADDR			0xD3U
+#define CSR_DLYTESTCNTDFICLK_ADDR			0xD4U
+#define CSR_DLYTESTCNTRINGOSCDB0_ADDR			0xD5U
+#define CSR_DLYTESTCNTRINGOSCDB1_ADDR			0xD6U
+#define CSR_DLYTESTCNTRINGOSCDB2_ADDR			0xD7U
+#define CSR_DLYTESTCNTRINGOSCDB3_ADDR			0xD8U
+#define CSR_DLYTESTCNTRINGOSCDB4_ADDR			0xD9U
+#define CSR_DLYTESTCNTRINGOSCDB5_ADDR			0xDAU
+#define CSR_DLYTESTCNTRINGOSCDB6_ADDR			0xDBU
+#define CSR_DLYTESTCNTRINGOSCDB7_ADDR			0xDCU
+#define CSR_DLYTESTCNTRINGOSCDB8_ADDR			0xDDU
+#define CSR_DLYTESTCNTRINGOSCDB9_ADDR			0xDEU
+#define CSR_DLYTESTCNTRINGOSCAC_ADDR			0xDFU
+#define CSR_MSTLCDLDBGCNTL_ADDR				0xE0U
+#define CSR_MSTLCDL0DBGRES_ADDR				0xE1U
+#define CSR_MSTLCDL1DBGRES_ADDR				0xE2U
+#define CSR_LCDLDBGCNTL_ADDR				0xE3U
+#define CSR_ACLCDLSTATUS_ADDR				0xE4U
+#define CSR_CUSTPHYREV_ADDR				0xEDU
+#define CSR_PHYREV_ADDR					0xEEU
+#define CSR_LP3EXITSEQ0BSTARTVECTOR_ADDR		0xEFU
+#define CSR_DFIFREQXLAT0_ADDR				0xF0U
+#define CSR_DFIFREQXLAT1_ADDR				0xF1U
+#define CSR_DFIFREQXLAT2_ADDR				0xF2U
+#define CSR_DFIFREQXLAT3_ADDR				0xF3U
+#define CSR_DFIFREQXLAT4_ADDR				0xF4U
+#define CSR_DFIFREQXLAT5_ADDR				0xF5U
+#define CSR_DFIFREQXLAT6_ADDR				0xF6U
+#define CSR_DFIFREQXLAT7_ADDR				0xF7U
+#define CSR_TXRDPTRINIT_ADDR				0xF8U
+#define CSR_DFIINITCOMPLETE_ADDR			0xF9U
+#define CSR_DFIFREQRATIO_ADDR				0xFAU
+#define CSR_RXFIFOCHECKS_ADDR				0xFBU
+#define CSR_MTESTDTOCTRL_ADDR				0xFFU
+#define CSR_MAPCAA0TODFI_ADDR				0x100U
+#define CSR_MAPCAA1TODFI_ADDR				0x101U
+#define CSR_MAPCAA2TODFI_ADDR				0x102U
+#define CSR_MAPCAA3TODFI_ADDR				0x103U
+#define CSR_MAPCAA4TODFI_ADDR				0x104U
+#define CSR_MAPCAA5TODFI_ADDR				0x105U
+#define CSR_MAPCAA6TODFI_ADDR				0x106U
+#define CSR_MAPCAA7TODFI_ADDR				0x107U
+#define CSR_MAPCAA8TODFI_ADDR				0x108U
+#define CSR_MAPCAA9TODFI_ADDR				0x109U
+#define CSR_MAPCAB0TODFI_ADDR				0x110U
+#define CSR_MAPCAB1TODFI_ADDR				0x111U
+#define CSR_MAPCAB2TODFI_ADDR				0x112U
+#define CSR_MAPCAB3TODFI_ADDR				0x113U
+#define CSR_MAPCAB4TODFI_ADDR				0x114U
+#define CSR_MAPCAB5TODFI_ADDR				0x115U
+#define CSR_MAPCAB6TODFI_ADDR				0x116U
+#define CSR_MAPCAB7TODFI_ADDR				0x117U
+#define CSR_MAPCAB8TODFI_ADDR				0x118U
+#define CSR_MAPCAB9TODFI_ADDR				0x119U
+#define CSR_PHYINTERRUPTENABLE_ADDR			0x11BU
+#define CSR_PHYINTERRUPTFWCONTROL_ADDR			0x11CU
+#define CSR_PHYINTERRUPTMASK_ADDR			0x11DU
+#define CSR_PHYINTERRUPTCLEAR_ADDR			0x11EU
+#define CSR_PHYINTERRUPTSTATUS_ADDR			0x11FU
+#define CSR_HWTSWIZZLEHWTADDRESS0_ADDR			0x120U
+#define CSR_HWTSWIZZLEHWTADDRESS1_ADDR			0x121U
+#define CSR_HWTSWIZZLEHWTADDRESS2_ADDR			0x122U
+#define CSR_HWTSWIZZLEHWTADDRESS3_ADDR			0x123U
+#define CSR_HWTSWIZZLEHWTADDRESS4_ADDR			0x124U
+#define CSR_HWTSWIZZLEHWTADDRESS5_ADDR			0x125U
+#define CSR_HWTSWIZZLEHWTADDRESS6_ADDR			0x126U
+#define CSR_HWTSWIZZLEHWTADDRESS7_ADDR			0x127U
+#define CSR_HWTSWIZZLEHWTADDRESS8_ADDR			0x128U
+#define CSR_HWTSWIZZLEHWTADDRESS9_ADDR			0x129U
+#define CSR_HWTSWIZZLEHWTADDRESS10_ADDR			0x12AU
+#define CSR_HWTSWIZZLEHWTADDRESS11_ADDR			0x12BU
+#define CSR_HWTSWIZZLEHWTADDRESS12_ADDR			0x12CU
+#define CSR_HWTSWIZZLEHWTADDRESS13_ADDR			0x12DU
+#define CSR_HWTSWIZZLEHWTADDRESS14_ADDR			0x12EU
+#define CSR_HWTSWIZZLEHWTADDRESS15_ADDR			0x12FU
+#define CSR_HWTSWIZZLEHWTADDRESS17_ADDR			0x130U
+#define CSR_HWTSWIZZLEHWTACTN_ADDR			0x131U
+#define CSR_HWTSWIZZLEHWTBANK0_ADDR			0x132U
+#define CSR_HWTSWIZZLEHWTBANK1_ADDR			0x133U
+#define CSR_HWTSWIZZLEHWTBANK2_ADDR			0x134U
+#define CSR_HWTSWIZZLEHWTBG0_ADDR			0x135U
+#define CSR_HWTSWIZZLEHWTBG1_ADDR			0x136U
+#define CSR_HWTSWIZZLEHWTCASN_ADDR			0x137U
+#define CSR_HWTSWIZZLEHWTRASN_ADDR			0x138U
+#define CSR_HWTSWIZZLEHWTWEN_ADDR			0x139U
+#define CSR_HWTSWIZZLEHWTPARITYIN_ADDR			0x13AU
+#define CSR_DFIHANDSHAKEDELAYS0_ADDR			0x13CU
+#define CSR_DFIHANDSHAKEDELAYS1_ADDR			0x13DU
+#define CSR_REMOTEIMPCAL_ADDR				0x13EU
+#define CSR_ACLOOPBACKCTL_ADDR				0x13FU
+
+/* ACSM0 register offsets */
+#define CSR_ACSMSEQ0X0_ADDR				0x0U
+#define CSR_ACSMSEQ0X1_ADDR				0x1U
+#define CSR_ACSMSEQ0X2_ADDR				0x2U
+#define CSR_ACSMSEQ0X3_ADDR				0x3U
+#define CSR_ACSMSEQ0X4_ADDR				0x4U
+#define CSR_ACSMSEQ0X5_ADDR				0x5U
+#define CSR_ACSMSEQ0X6_ADDR				0x6U
+#define CSR_ACSMSEQ0X7_ADDR				0x7U
+#define CSR_ACSMSEQ0X8_ADDR				0x8U
+#define CSR_ACSMSEQ0X9_ADDR				0x9U
+#define CSR_ACSMSEQ0X10_ADDR				0xAU
+#define CSR_ACSMSEQ0X11_ADDR				0xBU
+#define CSR_ACSMSEQ0X12_ADDR				0xCU
+#define CSR_ACSMSEQ0X13_ADDR				0xDU
+#define CSR_ACSMSEQ0X14_ADDR				0xEU
+#define CSR_ACSMSEQ0X15_ADDR				0xFU
+#define CSR_ACSMSEQ0X16_ADDR				0x10U
+#define CSR_ACSMSEQ0X17_ADDR				0x11U
+#define CSR_ACSMSEQ0X18_ADDR				0x12U
+#define CSR_ACSMSEQ0X19_ADDR				0x13U
+#define CSR_ACSMSEQ0X20_ADDR				0x14U
+#define CSR_ACSMSEQ0X21_ADDR				0x15U
+#define CSR_ACSMSEQ0X22_ADDR				0x16U
+#define CSR_ACSMSEQ0X23_ADDR				0x17U
+#define CSR_ACSMSEQ0X24_ADDR				0x18U
+#define CSR_ACSMSEQ0X25_ADDR				0x19U
+#define CSR_ACSMSEQ0X26_ADDR				0x1AU
+#define CSR_ACSMSEQ0X27_ADDR				0x1BU
+#define CSR_ACSMSEQ0X28_ADDR				0x1CU
+#define CSR_ACSMSEQ0X29_ADDR				0x1DU
+#define CSR_ACSMSEQ0X30_ADDR				0x1EU
+#define CSR_ACSMSEQ0X31_ADDR				0x1FU
+#define CSR_ACSMSEQ1X0_ADDR				0x20U
+#define CSR_ACSMSEQ1X1_ADDR				0x21U
+#define CSR_ACSMSEQ1X2_ADDR				0x22U
+#define CSR_ACSMSEQ1X3_ADDR				0x23U
+#define CSR_ACSMSEQ1X4_ADDR				0x24U
+#define CSR_ACSMSEQ1X5_ADDR				0x25U
+#define CSR_ACSMSEQ1X6_ADDR				0x26U
+#define CSR_ACSMSEQ1X7_ADDR				0x27U
+#define CSR_ACSMSEQ1X8_ADDR				0x28U
+#define CSR_ACSMSEQ1X9_ADDR				0x29U
+#define CSR_ACSMSEQ1X10_ADDR				0x2AU
+#define CSR_ACSMSEQ1X11_ADDR				0x2BU
+#define CSR_ACSMSEQ1X12_ADDR				0x2CU
+#define CSR_ACSMSEQ1X13_ADDR				0x2DU
+#define CSR_ACSMSEQ1X14_ADDR				0x2EU
+#define CSR_ACSMSEQ1X15_ADDR				0x2FU
+#define CSR_ACSMSEQ1X16_ADDR				0x30U
+#define CSR_ACSMSEQ1X17_ADDR				0x31U
+#define CSR_ACSMSEQ1X18_ADDR				0x32U
+#define CSR_ACSMSEQ1X19_ADDR				0x33U
+#define CSR_ACSMSEQ1X20_ADDR				0x34U
+#define CSR_ACSMSEQ1X21_ADDR				0x35U
+#define CSR_ACSMSEQ1X22_ADDR				0x36U
+#define CSR_ACSMSEQ1X23_ADDR				0x37U
+#define CSR_ACSMSEQ1X24_ADDR				0x38U
+#define CSR_ACSMSEQ1X25_ADDR				0x39U
+#define CSR_ACSMSEQ1X26_ADDR				0x3AU
+#define CSR_ACSMSEQ1X27_ADDR				0x3BU
+#define CSR_ACSMSEQ1X28_ADDR				0x3CU
+#define CSR_ACSMSEQ1X29_ADDR				0x3DU
+#define CSR_ACSMSEQ1X30_ADDR				0x3EU
+#define CSR_ACSMSEQ1X31_ADDR				0x3FU
+#define CSR_ACSMSEQ2X0_ADDR				0x40U
+#define CSR_ACSMSEQ2X1_ADDR				0x41U
+#define CSR_ACSMSEQ2X2_ADDR				0x42U
+#define CSR_ACSMSEQ2X3_ADDR				0x43U
+#define CSR_ACSMSEQ2X4_ADDR				0x44U
+#define CSR_ACSMSEQ2X5_ADDR				0x45U
+#define CSR_ACSMSEQ2X6_ADDR				0x46U
+#define CSR_ACSMSEQ2X7_ADDR				0x47U
+#define CSR_ACSMSEQ2X8_ADDR				0x48U
+#define CSR_ACSMSEQ2X9_ADDR				0x49U
+#define CSR_ACSMSEQ2X10_ADDR				0x4AU
+#define CSR_ACSMSEQ2X11_ADDR				0x4BU
+#define CSR_ACSMSEQ2X12_ADDR				0x4CU
+#define CSR_ACSMSEQ2X13_ADDR				0x4DU
+#define CSR_ACSMSEQ2X14_ADDR				0x4EU
+#define CSR_ACSMSEQ2X15_ADDR				0x4FU
+#define CSR_ACSMSEQ2X16_ADDR				0x50U
+#define CSR_ACSMSEQ2X17_ADDR				0x51U
+#define CSR_ACSMSEQ2X18_ADDR				0x52U
+#define CSR_ACSMSEQ2X19_ADDR				0x53U
+#define CSR_ACSMSEQ2X20_ADDR				0x54U
+#define CSR_ACSMSEQ2X21_ADDR				0x55U
+#define CSR_ACSMSEQ2X22_ADDR				0x56U
+#define CSR_ACSMSEQ2X23_ADDR				0x57U
+#define CSR_ACSMSEQ2X24_ADDR				0x58U
+#define CSR_ACSMSEQ2X25_ADDR				0x59U
+#define CSR_ACSMSEQ2X26_ADDR				0x5AU
+#define CSR_ACSMSEQ2X27_ADDR				0x5BU
+#define CSR_ACSMSEQ2X28_ADDR				0x5CU
+#define CSR_ACSMSEQ2X29_ADDR				0x5DU
+#define CSR_ACSMSEQ2X30_ADDR				0x5EU
+#define CSR_ACSMSEQ2X31_ADDR				0x5FU
+#define CSR_ACSMSEQ3X0_ADDR				0x60U
+#define CSR_ACSMSEQ3X1_ADDR				0x61U
+#define CSR_ACSMSEQ3X2_ADDR				0x62U
+#define CSR_ACSMSEQ3X3_ADDR				0x63U
+#define CSR_ACSMSEQ3X4_ADDR				0x64U
+#define CSR_ACSMSEQ3X5_ADDR				0x65U
+#define CSR_ACSMSEQ3X6_ADDR				0x66U
+#define CSR_ACSMSEQ3X7_ADDR				0x67U
+#define CSR_ACSMSEQ3X8_ADDR				0x68U
+#define CSR_ACSMSEQ3X9_ADDR				0x69U
+#define CSR_ACSMSEQ3X10_ADDR				0x6AU
+#define CSR_ACSMSEQ3X11_ADDR				0x6BU
+#define CSR_ACSMSEQ3X12_ADDR				0x6CU
+#define CSR_ACSMSEQ3X13_ADDR				0x6DU
+#define CSR_ACSMSEQ3X14_ADDR				0x6EU
+#define CSR_ACSMSEQ3X15_ADDR				0x6FU
+#define CSR_ACSMSEQ3X16_ADDR				0x70U
+#define CSR_ACSMSEQ3X17_ADDR				0x71U
+#define CSR_ACSMSEQ3X18_ADDR				0x72U
+#define CSR_ACSMSEQ3X19_ADDR				0x73U
+#define CSR_ACSMSEQ3X20_ADDR				0x74U
+#define CSR_ACSMSEQ3X21_ADDR				0x75U
+#define CSR_ACSMSEQ3X22_ADDR				0x76U
+#define CSR_ACSMSEQ3X23_ADDR				0x77U
+#define CSR_ACSMSEQ3X24_ADDR				0x78U
+#define CSR_ACSMSEQ3X25_ADDR				0x79U
+#define CSR_ACSMSEQ3X26_ADDR				0x7AU
+#define CSR_ACSMSEQ3X27_ADDR				0x7BU
+#define CSR_ACSMSEQ3X28_ADDR				0x7CU
+#define CSR_ACSMSEQ3X29_ADDR				0x7DU
+#define CSR_ACSMSEQ3X30_ADDR				0x7EU
+#define CSR_ACSMSEQ3X31_ADDR				0x7FU
+#define CSR_ACSMPLAYBACK0X0_ADDR			0x80U
+#define CSR_ACSMPLAYBACK1X0_ADDR			0x81U
+#define CSR_ACSMPLAYBACK0X1_ADDR			0x82U
+#define CSR_ACSMPLAYBACK1X1_ADDR			0x83U
+#define CSR_ACSMPLAYBACK0X2_ADDR			0x84U
+#define CSR_ACSMPLAYBACK1X2_ADDR			0x85U
+#define CSR_ACSMPLAYBACK0X3_ADDR			0x86U
+#define CSR_ACSMPLAYBACK1X3_ADDR			0x87U
+#define CSR_ACSMPLAYBACK0X4_ADDR			0x88U
+#define CSR_ACSMPLAYBACK1X4_ADDR			0x89U
+#define CSR_ACSMPLAYBACK0X5_ADDR			0x8AU
+#define CSR_ACSMPLAYBACK1X5_ADDR			0x8BU
+#define CSR_ACSMPLAYBACK0X6_ADDR			0x8CU
+#define CSR_ACSMPLAYBACK1X6_ADDR			0x8DU
+#define CSR_ACSMPLAYBACK0X7_ADDR			0x8EU
+#define CSR_ACSMPLAYBACK1X7_ADDR			0x8FU
+#define CSR_ACSMPSTATEOVREN_ADDR			0x90U
+#define CSR_ACSMPSTATEOVRVAL_ADDR			0x91U
+#define CSR_ACSMCTRL23_ADDR				0xC0U
+#define CSR_ACSMCKEVAL_ADDR				0xC2U
+#define CSR_LOWSPEEDCLOCKDIVIDER_ADDR			0xC8U
+#define CSR_ACSMCSMAPCTRL0_ADDR				0xD0U
+#define CSR_ACSMCSMAPCTRL1_ADDR				0xD1U
+#define CSR_ACSMCSMAPCTRL2_ADDR				0xD2U
+#define CSR_ACSMCSMAPCTRL3_ADDR				0xD3U
+#define CSR_ACSMCSMAPCTRL4_ADDR				0xD4U
+#define CSR_ACSMCSMAPCTRL5_ADDR				0xD5U
+#define CSR_ACSMCSMAPCTRL6_ADDR				0xD6U
+#define CSR_ACSMCSMAPCTRL7_ADDR				0xD7U
+#define CSR_ACSMCSMAPCTRL8_ADDR				0xD8U
+#define CSR_ACSMCSMAPCTRL9_ADDR				0xD9U
+#define CSR_ACSMCSMAPCTRL10_ADDR			0xDAU
+#define CSR_ACSMCSMAPCTRL11_ADDR			0xDBU
+#define CSR_ACSMCSMAPCTRL12_ADDR			0xDCU
+#define CSR_ACSMCSMAPCTRL13_ADDR			0xDDU
+#define CSR_ACSMCSMAPCTRL14_ADDR			0xDEU
+#define CSR_ACSMCSMAPCTRL15_ADDR			0xDFU
+#define CSR_ACSMODTCTRL0_ADDR				0xE0U
+#define CSR_ACSMODTCTRL1_ADDR				0xE1U
+#define CSR_ACSMODTCTRL2_ADDR				0xE2U
+#define CSR_ACSMODTCTRL3_ADDR				0xE3U
+#define CSR_ACSMODTCTRL4_ADDR				0xE4U
+#define CSR_ACSMODTCTRL5_ADDR				0xE5U
+#define CSR_ACSMODTCTRL6_ADDR				0xE6U
+#define CSR_ACSMODTCTRL7_ADDR				0xE7U
+#define CSR_ACSMODTCTRL8_ADDR				0xE8U
+#define CSR_ACSMCTRL16_ADDR				0xE9U
+#define CSR_LOWSPEEDCLOCKSTOPVAL_ADDR			0xEAU
+#define CSR_ACSMCTRL18_ADDR				0xEBU
+#define CSR_ACSMCTRL19_ADDR				0xECU
+#define CSR_ACSMCTRL20_ADDR				0xEDU
+#define CSR_ACSMCTRL21_ADDR				0xEEU
+#define CSR_ACSMCTRL22_ADDR				0xEFU
+#define CSR_ACSMCTRL0_ADDR				0xF0U
+#define CSR_ACSMCTRL1_ADDR				0xF1U
+#define CSR_ACSMCTRL2_ADDR				0xF2U
+#define CSR_ACSMCTRL3_ADDR				0xF3U
+#define CSR_ACSMCTRL4_ADDR				0xF4U
+#define CSR_ACSMCTRL5_ADDR				0xF5U
+#define CSR_ACSMCTRL6_ADDR				0xF6U
+#define CSR_ACSMCTRL7_ADDR				0xF7U
+#define CSR_ACSMCTRL8_ADDR				0xF8U
+#define CSR_ACSMCTRL9_ADDR				0xF9U
+#define CSR_ACSMCTRL10_ADDR				0xFAU
+#define CSR_ACSMCTRL11_ADDR				0xFBU
+#define CSR_ACSMCTRL12_ADDR				0xFCU
+#define CSR_ACSMCTRL13_ADDR				0xFDU
+#define CSR_ACSMCTRL14_ADDR				0xFEU
+#define CSR_ACSMCTRL15_ADDR				0xFFU
+
+/* PPGC0 register offsets */
+#define CSR_PPGCCTRL1_ADDR				0x11U
+#define CSR_PPGCLANE2CRCINMAP0_ADDR			0x15U
+#define CSR_PPGCLANE2CRCINMAP1_ADDR			0x16U
+#define CSR_PRBSTAPDLY0_ADDR				0x24U
+#define CSR_PRBSTAPDLY1_ADDR				0x25U
+#define CSR_PRBSTAPDLY2_ADDR				0x26U
+#define CSR_PRBSTAPDLY3_ADDR				0x27U
+#define CSR_GENPRBSBYTE0_ADDR				0x30U
+#define CSR_GENPRBSBYTE1_ADDR				0x31U
+#define CSR_GENPRBSBYTE2_ADDR				0x32U
+#define CSR_GENPRBSBYTE3_ADDR				0x33U
+#define CSR_GENPRBSBYTE4_ADDR				0x34U
+#define CSR_GENPRBSBYTE5_ADDR				0x35U
+#define CSR_GENPRBSBYTE6_ADDR				0x36U
+#define CSR_GENPRBSBYTE7_ADDR				0x37U
+#define CSR_GENPRBSBYTE8_ADDR				0x38U
+#define CSR_GENPRBSBYTE9_ADDR				0x39U
+#define CSR_GENPRBSBYTE10_ADDR				0x3AU
+#define CSR_GENPRBSBYTE11_ADDR				0x3BU
+#define CSR_GENPRBSBYTE12_ADDR				0x3CU
+#define CSR_GENPRBSBYTE13_ADDR				0x3DU
+#define CSR_GENPRBSBYTE14_ADDR				0x3EU
+#define CSR_GENPRBSBYTE15_ADDR				0x3FU
+#define CSR_PRBSGENCTL_ADDR				0x60U
+#define CSR_PRBSGENSTATELO_ADDR				0x61U
+#define CSR_PRBSGENSTATEHI_ADDR				0x62U
+#define CSR_PRBSCHKSTATELO_ADDR				0x63U
+#define CSR_PRBSCHKSTATEHI_ADDR				0x64U
+#define CSR_PRBSGENCTL1_ADDR				0x65U
+#define CSR_PRBSGENCTL2_ADDR				0x66U
+
+/* INITENG0 register offsets */
+#define CSR_PRESEQUENCEREG0B0S0_ADDR			0x0U
+#define CSR_PRESEQUENCEREG0B0S1_ADDR			0x1U
+#define CSR_PRESEQUENCEREG0B0S2_ADDR			0x2U
+#define CSR_PRESEQUENCEREG0B1S0_ADDR			0x3U
+#define CSR_PRESEQUENCEREG0B1S1_ADDR			0x4U
+#define CSR_PRESEQUENCEREG0B1S2_ADDR			0x5U
+#define CSR_POSTSEQUENCEREG0B0S0_ADDR			0x6U
+#define CSR_POSTSEQUENCEREG0B0S1_ADDR			0x7U
+#define CSR_POSTSEQUENCEREG0B0S2_ADDR			0x8U
+#define CSR_POSTSEQUENCEREG0B1S0_ADDR			0x9U
+#define CSR_POSTSEQUENCEREG0B1S1_ADDR			0xAU
+#define CSR_POSTSEQUENCEREG0B1S2_ADDR			0xBU
+#define CSR_SEQ0BDISABLEFLAG0_ADDR			0xCU
+#define CSR_SEQ0BDISABLEFLAG1_ADDR			0xDU
+#define CSR_SEQ0BDISABLEFLAG2_ADDR			0xEU
+#define CSR_SEQ0BDISABLEFLAG3_ADDR			0xFU
+#define CSR_SEQ0BDISABLEFLAG4_ADDR			0x10U
+#define CSR_SEQ0BDISABLEFLAG5_ADDR			0x11U
+#define CSR_SEQ0BDISABLEFLAG6_ADDR			0x12U
+#define CSR_SEQ0BDISABLEFLAG7_ADDR			0x13U
+#define CSR_STARTVECTOR0B0_ADDR				0x17U
+#define CSR_STARTVECTOR0B1_ADDR				0x18U
+#define CSR_STARTVECTOR0B2_ADDR				0x19U
+#define CSR_STARTVECTOR0B3_ADDR				0x1AU
+#define CSR_STARTVECTOR0B4_ADDR				0x1BU
+#define CSR_STARTVECTOR0B5_ADDR				0x1CU
+#define CSR_STARTVECTOR0B6_ADDR				0x1DU
+#define CSR_STARTVECTOR0B7_ADDR				0x1EU
+#define CSR_STARTVECTOR0B8_ADDR				0x1FU
+#define CSR_STARTVECTOR0B9_ADDR				0x20U
+#define CSR_STARTVECTOR0B10_ADDR			0x21U
+#define CSR_STARTVECTOR0B11_ADDR			0x22U
+#define CSR_STARTVECTOR0B12_ADDR			0x23U
+#define CSR_STARTVECTOR0B13_ADDR			0x24U
+#define CSR_STARTVECTOR0B14_ADDR			0x25U
+#define CSR_STARTVECTOR0B15_ADDR			0x26U
+#define CSR_SEQ0BWAITCONDSEL_ADDR			0x27U
+#define CSR_PHYINLP3_ADDR				0x28U
+#define CSR_SEQUENCEREG0B0S0_ADDR			0x29U
+#define CSR_SEQUENCEREG0B0S1_ADDR			0x2AU
+#define CSR_SEQUENCEREG0B0S2_ADDR			0x2BU
+#define CSR_SEQUENCEREG0B1S0_ADDR			0x2CU
+#define CSR_SEQUENCEREG0B1S1_ADDR			0x2DU
+#define CSR_SEQUENCEREG0B1S2_ADDR			0x2EU
+#define CSR_SEQUENCEREG0B2S0_ADDR			0x2FU
+#define CSR_SEQUENCEREG0B2S1_ADDR			0x30U
+#define CSR_SEQUENCEREG0B2S2_ADDR			0x31U
+#define CSR_SEQUENCEREG0B3S0_ADDR			0x32U
+#define CSR_SEQUENCEREG0B3S1_ADDR			0x33U
+#define CSR_SEQUENCEREG0B3S2_ADDR			0x34U
+#define CSR_SEQUENCEREG0B4S0_ADDR			0x35U
+#define CSR_SEQUENCEREG0B4S1_ADDR			0x36U
+#define CSR_SEQUENCEREG0B4S2_ADDR			0x37U
+#define CSR_SEQUENCEREG0B5S0_ADDR			0x38U
+#define CSR_SEQUENCEREG0B5S1_ADDR			0x39U
+#define CSR_SEQUENCEREG0B5S2_ADDR			0x3AU
+#define CSR_SEQUENCEREG0B6S0_ADDR			0x3BU
+#define CSR_SEQUENCEREG0B6S1_ADDR			0x3CU
+#define CSR_SEQUENCEREG0B6S2_ADDR			0x3DU
+#define CSR_SEQUENCEREG0B7S0_ADDR			0x3EU
+#define CSR_SEQUENCEREG0B7S1_ADDR			0x3FU
+#define CSR_SEQUENCEREG0B7S2_ADDR			0x40U
+#define CSR_SEQUENCEREG0B8S0_ADDR			0x41U
+#define CSR_SEQUENCEREG0B8S1_ADDR			0x42U
+#define CSR_SEQUENCEREG0B8S2_ADDR			0x43U
+#define CSR_SEQUENCEREG0B9S0_ADDR			0x44U
+#define CSR_SEQUENCEREG0B9S1_ADDR			0x45U
+#define CSR_SEQUENCEREG0B9S2_ADDR			0x46U
+#define CSR_SEQUENCEREG0B10S0_ADDR			0x47U
+#define CSR_SEQUENCEREG0B10S1_ADDR			0x48U
+#define CSR_SEQUENCEREG0B10S2_ADDR			0x49U
+#define CSR_SEQUENCEREG0B11S0_ADDR			0x4AU
+#define CSR_SEQUENCEREG0B11S1_ADDR			0x4BU
+#define CSR_SEQUENCEREG0B11S2_ADDR			0x4CU
+#define CSR_SEQUENCEREG0B12S0_ADDR			0x4DU
+#define CSR_SEQUENCEREG0B12S1_ADDR			0x4EU
+#define CSR_SEQUENCEREG0B12S2_ADDR			0x4FU
+#define CSR_SEQUENCEREG0B13S0_ADDR			0x50U
+#define CSR_SEQUENCEREG0B13S1_ADDR			0x51U
+#define CSR_SEQUENCEREG0B13S2_ADDR			0x52U
+#define CSR_SEQUENCEREG0B14S0_ADDR			0x53U
+#define CSR_SEQUENCEREG0B14S1_ADDR			0x54U
+#define CSR_SEQUENCEREG0B14S2_ADDR			0x55U
+#define CSR_SEQUENCEREG0B15S0_ADDR			0x56U
+#define CSR_SEQUENCEREG0B15S1_ADDR			0x57U
+#define CSR_SEQUENCEREG0B15S2_ADDR			0x58U
+#define CSR_SEQUENCEREG0B16S0_ADDR			0x59U
+#define CSR_SEQUENCEREG0B16S1_ADDR			0x5AU
+#define CSR_SEQUENCEREG0B16S2_ADDR			0x5BU
+#define CSR_SEQUENCEREG0B17S0_ADDR			0x5CU
+#define CSR_SEQUENCEREG0B17S1_ADDR			0x5DU
+#define CSR_SEQUENCEREG0B17S2_ADDR			0x5EU
+#define CSR_SEQUENCEREG0B18S0_ADDR			0x5FU
+#define CSR_SEQUENCEREG0B18S1_ADDR			0x60U
+#define CSR_SEQUENCEREG0B18S2_ADDR			0x61U
+#define CSR_SEQUENCEREG0B19S0_ADDR			0x62U
+#define CSR_SEQUENCEREG0B19S1_ADDR			0x63U
+#define CSR_SEQUENCEREG0B19S2_ADDR			0x64U
+#define CSR_SEQUENCEREG0B20S0_ADDR			0x65U
+#define CSR_SEQUENCEREG0B20S1_ADDR			0x66U
+#define CSR_SEQUENCEREG0B20S2_ADDR			0x67U
+#define CSR_SEQUENCEREG0B21S0_ADDR			0x68U
+#define CSR_SEQUENCEREG0B21S1_ADDR			0x69U
+#define CSR_SEQUENCEREG0B21S2_ADDR			0x6AU
+#define CSR_SEQUENCEREG0B22S0_ADDR			0x6BU
+#define CSR_SEQUENCEREG0B22S1_ADDR			0x6CU
+#define CSR_SEQUENCEREG0B22S2_ADDR			0x6DU
+#define CSR_SEQUENCEREG0B23S0_ADDR			0x6EU
+#define CSR_SEQUENCEREG0B23S1_ADDR			0x6FU
+#define CSR_SEQUENCEREG0B23S2_ADDR			0x70U
+#define CSR_SEQUENCEREG0B24S0_ADDR			0x71U
+#define CSR_SEQUENCEREG0B24S1_ADDR			0x72U
+#define CSR_SEQUENCEREG0B24S2_ADDR			0x73U
+#define CSR_SEQUENCEREG0B25S0_ADDR			0x74U
+#define CSR_SEQUENCEREG0B25S1_ADDR			0x75U
+#define CSR_SEQUENCEREG0B25S2_ADDR			0x76U
+#define CSR_SEQUENCEREG0B26S0_ADDR			0x77U
+#define CSR_SEQUENCEREG0B26S1_ADDR			0x78U
+#define CSR_SEQUENCEREG0B26S2_ADDR			0x79U
+#define CSR_SEQUENCEREG0B27S0_ADDR			0x7AU
+#define CSR_SEQUENCEREG0B27S1_ADDR			0x7BU
+#define CSR_SEQUENCEREG0B27S2_ADDR			0x7CU
+#define CSR_SEQUENCEREG0B28S0_ADDR			0x7DU
+#define CSR_SEQUENCEREG0B28S1_ADDR			0x7EU
+#define CSR_SEQUENCEREG0B28S2_ADDR			0x7FU
+#define CSR_SEQUENCEREG0B29S0_ADDR			0x80U
+#define CSR_SEQUENCEREG0B29S1_ADDR			0x81U
+#define CSR_SEQUENCEREG0B29S2_ADDR			0x82U
+#define CSR_SEQUENCEREG0B30S0_ADDR			0x83U
+#define CSR_SEQUENCEREG0B30S1_ADDR			0x84U
+#define CSR_SEQUENCEREG0B30S2_ADDR			0x85U
+#define CSR_SEQUENCEREG0B31S0_ADDR			0x86U
+#define CSR_SEQUENCEREG0B31S1_ADDR			0x87U
+#define CSR_SEQUENCEREG0B31S2_ADDR			0x88U
+#define CSR_SEQUENCEREG0B32S0_ADDR			0x89U
+#define CSR_SEQUENCEREG0B32S1_ADDR			0x8AU
+#define CSR_SEQUENCEREG0B32S2_ADDR			0x8BU
+#define CSR_SEQUENCEREG0B33S0_ADDR			0x8CU
+#define CSR_SEQUENCEREG0B33S1_ADDR			0x8DU
+#define CSR_SEQUENCEREG0B33S2_ADDR			0x8EU
+#define CSR_SEQUENCEREG0B34S0_ADDR			0x8FU
+#define CSR_SEQUENCEREG0B34S1_ADDR			0x90U
+#define CSR_SEQUENCEREG0B34S2_ADDR			0x91U
+#define CSR_SEQUENCEREG0B35S0_ADDR			0x92U
+#define CSR_SEQUENCEREG0B35S1_ADDR			0x93U
+#define CSR_SEQUENCEREG0B35S2_ADDR			0x94U
+#define CSR_SEQUENCEREG0B36S0_ADDR			0x95U
+#define CSR_SEQUENCEREG0B36S1_ADDR			0x96U
+#define CSR_SEQUENCEREG0B36S2_ADDR			0x97U
+#define CSR_SEQUENCEREG0B37S0_ADDR			0x98U
+#define CSR_SEQUENCEREG0B37S1_ADDR			0x99U
+#define CSR_SEQUENCEREG0B37S2_ADDR			0x9AU
+#define CSR_SEQUENCEREG0B38S0_ADDR			0x9BU
+#define CSR_SEQUENCEREG0B38S1_ADDR			0x9CU
+#define CSR_SEQUENCEREG0B38S2_ADDR			0x9DU
+#define CSR_SEQUENCEREG0B39S0_ADDR			0x9EU
+#define CSR_SEQUENCEREG0B39S1_ADDR			0x9FU
+#define CSR_SEQUENCEREG0B39S2_ADDR			0xA0U
+#define CSR_SEQUENCEREG0B40S0_ADDR			0xA1U
+#define CSR_SEQUENCEREG0B40S1_ADDR			0xA2U
+#define CSR_SEQUENCEREG0B40S2_ADDR			0xA3U
+#define CSR_SEQUENCEREG0B41S0_ADDR			0xA4U
+#define CSR_SEQUENCEREG0B41S1_ADDR			0xA5U
+#define CSR_SEQUENCEREG0B41S2_ADDR			0xA6U
+#define CSR_SEQUENCEREG0B42S0_ADDR			0xA7U
+#define CSR_SEQUENCEREG0B42S1_ADDR			0xA8U
+#define CSR_SEQUENCEREG0B42S2_ADDR			0xA9U
+#define CSR_SEQUENCEREG0B43S0_ADDR			0xAAU
+#define CSR_SEQUENCEREG0B43S1_ADDR			0xABU
+#define CSR_SEQUENCEREG0B43S2_ADDR			0xACU
+#define CSR_SEQUENCEREG0B44S0_ADDR			0xADU
+#define CSR_SEQUENCEREG0B44S1_ADDR			0xAEU
+#define CSR_SEQUENCEREG0B44S2_ADDR			0xAFU
+#define CSR_SEQUENCEREG0B45S0_ADDR			0xB0U
+#define CSR_SEQUENCEREG0B45S1_ADDR			0xB1U
+#define CSR_SEQUENCEREG0B45S2_ADDR			0xB2U
+#define CSR_SEQUENCEREG0B46S0_ADDR			0xB3U
+#define CSR_SEQUENCEREG0B46S1_ADDR			0xB4U
+#define CSR_SEQUENCEREG0B46S2_ADDR			0xB5U
+#define CSR_SEQUENCEREG0B47S0_ADDR			0xB6U
+#define CSR_SEQUENCEREG0B47S1_ADDR			0xB7U
+#define CSR_SEQUENCEREG0B47S2_ADDR			0xB8U
+#define CSR_SEQUENCEREG0B48S0_ADDR			0xB9U
+#define CSR_SEQUENCEREG0B48S1_ADDR			0xBAU
+#define CSR_SEQUENCEREG0B48S2_ADDR			0xBBU
+#define CSR_SEQUENCEREG0B49S0_ADDR			0xBCU
+#define CSR_SEQUENCEREG0B49S1_ADDR			0xBDU
+#define CSR_SEQUENCEREG0B49S2_ADDR			0xBEU
+#define CSR_SEQUENCEREG0B50S0_ADDR			0xBFU
+#define CSR_SEQUENCEREG0B50S1_ADDR			0xC0U
+#define CSR_SEQUENCEREG0B50S2_ADDR			0xC1U
+#define CSR_SEQUENCEREG0B51S0_ADDR			0xC2U
+#define CSR_SEQUENCEREG0B51S1_ADDR			0xC3U
+#define CSR_SEQUENCEREG0B51S2_ADDR			0xC4U
+#define CSR_SEQUENCEREG0B52S0_ADDR			0xC5U
+#define CSR_SEQUENCEREG0B52S1_ADDR			0xC6U
+#define CSR_SEQUENCEREG0B52S2_ADDR			0xC7U
+#define CSR_SEQUENCEREG0B53S0_ADDR			0xC8U
+#define CSR_SEQUENCEREG0B53S1_ADDR			0xC9U
+#define CSR_SEQUENCEREG0B53S2_ADDR			0xCAU
+#define CSR_SEQUENCEREG0B54S0_ADDR			0xCBU
+#define CSR_SEQUENCEREG0B54S1_ADDR			0xCCU
+#define CSR_SEQUENCEREG0B54S2_ADDR			0xCDU
+#define CSR_SEQUENCEREG0B55S0_ADDR			0xCEU
+#define CSR_SEQUENCEREG0B55S1_ADDR			0xCFU
+#define CSR_SEQUENCEREG0B55S2_ADDR			0xD0U
+#define CSR_SEQUENCEREG0B56S0_ADDR			0xD1U
+#define CSR_SEQUENCEREG0B56S1_ADDR			0xD2U
+#define CSR_SEQUENCEREG0B56S2_ADDR			0xD3U
+#define CSR_SEQUENCEREG0B57S0_ADDR			0xD4U
+#define CSR_SEQUENCEREG0B57S1_ADDR			0xD5U
+#define CSR_SEQUENCEREG0B57S2_ADDR			0xD6U
+#define CSR_SEQUENCEREG0B58S0_ADDR			0xD7U
+#define CSR_SEQUENCEREG0B58S1_ADDR			0xD8U
+#define CSR_SEQUENCEREG0B58S2_ADDR			0xD9U
+#define CSR_SEQUENCEREG0B59S0_ADDR			0xDAU
+#define CSR_SEQUENCEREG0B59S1_ADDR			0xDBU
+#define CSR_SEQUENCEREG0B59S2_ADDR			0xDCU
+#define CSR_SEQUENCEREG0B60S0_ADDR			0xDDU
+#define CSR_SEQUENCEREG0B60S1_ADDR			0xDEU
+#define CSR_SEQUENCEREG0B60S2_ADDR			0xDFU
+#define CSR_SEQUENCEREG0B61S0_ADDR			0xE0U
+#define CSR_SEQUENCEREG0B61S1_ADDR			0xE1U
+#define CSR_SEQUENCEREG0B61S2_ADDR			0xE2U
+#define CSR_SEQUENCEREG0B62S0_ADDR			0xE3U
+#define CSR_SEQUENCEREG0B62S1_ADDR			0xE4U
+#define CSR_SEQUENCEREG0B62S2_ADDR			0xE5U
+#define CSR_SEQUENCEREG0B63S0_ADDR			0xE6U
+#define CSR_SEQUENCEREG0B63S1_ADDR			0xE7U
+#define CSR_SEQUENCEREG0B63S2_ADDR			0xE8U
+#define CSR_SEQUENCEREG0B64S0_ADDR			0xE9U
+#define CSR_SEQUENCEREG0B64S1_ADDR			0xEAU
+#define CSR_SEQUENCEREG0B64S2_ADDR			0xEBU
+#define CSR_SEQUENCEREG0B65S0_ADDR			0xECU
+#define CSR_SEQUENCEREG0B65S1_ADDR			0xEDU
+#define CSR_SEQUENCEREG0B65S2_ADDR			0xEEU
+#define CSR_SEQUENCEREG0B66S0_ADDR			0xEFU
+#define CSR_SEQUENCEREG0B66S1_ADDR			0xF0U
+#define CSR_SEQUENCEREG0B66S2_ADDR			0xF1U
+#define CSR_SEQUENCEREG0B67S0_ADDR			0xF2U
+#define CSR_SEQUENCEREG0B67S1_ADDR			0xF3U
+#define CSR_SEQUENCEREG0B67S2_ADDR			0xF4U
+#define CSR_SEQUENCEREG0B68S0_ADDR			0xF5U
+#define CSR_SEQUENCEREG0B68S1_ADDR			0xF6U
+#define CSR_SEQUENCEREG0B68S2_ADDR			0xF7U
+#define CSR_SEQUENCEREG0B69S0_ADDR			0xF8U
+#define CSR_SEQUENCEREG0B69S1_ADDR			0xF9U
+#define CSR_SEQUENCEREG0B69S2_ADDR			0xFAU
+#define CSR_SEQUENCEREG0B70S0_ADDR			0xFBU
+#define CSR_SEQUENCEREG0B70S1_ADDR			0xFCU
+#define CSR_SEQUENCEREG0B70S2_ADDR			0xFDU
+#define CSR_SEQUENCEREG0B71S0_ADDR			0xFEU
+#define CSR_SEQUENCEREG0B71S1_ADDR			0xFFU
+#define CSR_SEQUENCEREG0B71S2_ADDR			0x100U
+#define CSR_SEQUENCEREG0B72S0_ADDR			0x101U
+#define CSR_SEQUENCEREG0B72S1_ADDR			0x102U
+#define CSR_SEQUENCEREG0B72S2_ADDR			0x103U
+#define CSR_SEQUENCEREG0B73S0_ADDR			0x104U
+#define CSR_SEQUENCEREG0B73S1_ADDR			0x105U
+#define CSR_SEQUENCEREG0B73S2_ADDR			0x106U
+#define CSR_SEQUENCEREG0B74S0_ADDR			0x107U
+#define CSR_SEQUENCEREG0B74S1_ADDR			0x108U
+#define CSR_SEQUENCEREG0B74S2_ADDR			0x109U
+#define CSR_SEQUENCEREG0B75S0_ADDR			0x10AU
+#define CSR_SEQUENCEREG0B75S1_ADDR			0x10BU
+#define CSR_SEQUENCEREG0B75S2_ADDR			0x10CU
+#define CSR_SEQUENCEREG0B76S0_ADDR			0x10DU
+#define CSR_SEQUENCEREG0B76S1_ADDR			0x10EU
+#define CSR_SEQUENCEREG0B76S2_ADDR			0x10FU
+#define CSR_SEQUENCEREG0B77S0_ADDR			0x110U
+#define CSR_SEQUENCEREG0B77S1_ADDR			0x111U
+#define CSR_SEQUENCEREG0B77S2_ADDR			0x112U
+#define CSR_SEQUENCEREG0B78S0_ADDR			0x113U
+#define CSR_SEQUENCEREG0B78S1_ADDR			0x114U
+#define CSR_SEQUENCEREG0B78S2_ADDR			0x115U
+#define CSR_SEQUENCEREG0B79S0_ADDR			0x116U
+#define CSR_SEQUENCEREG0B79S1_ADDR			0x117U
+#define CSR_SEQUENCEREG0B79S2_ADDR			0x118U
+#define CSR_SEQUENCEREG0B80S0_ADDR			0x119U
+#define CSR_SEQUENCEREG0B80S1_ADDR			0x11AU
+#define CSR_SEQUENCEREG0B80S2_ADDR			0x11BU
+#define CSR_SEQUENCEREG0B81S0_ADDR			0x11CU
+#define CSR_SEQUENCEREG0B81S1_ADDR			0x11DU
+#define CSR_SEQUENCEREG0B81S2_ADDR			0x11EU
+#define CSR_SEQUENCEREG0B82S0_ADDR			0x11FU
+#define CSR_SEQUENCEREG0B82S1_ADDR			0x120U
+#define CSR_SEQUENCEREG0B82S2_ADDR			0x121U
+#define CSR_SEQUENCEREG0B83S0_ADDR			0x122U
+#define CSR_SEQUENCEREG0B83S1_ADDR			0x123U
+#define CSR_SEQUENCEREG0B83S2_ADDR			0x124U
+#define CSR_SEQUENCEREG0B84S0_ADDR			0x125U
+#define CSR_SEQUENCEREG0B84S1_ADDR			0x126U
+#define CSR_SEQUENCEREG0B84S2_ADDR			0x127U
+#define CSR_SEQUENCEREG0B85S0_ADDR			0x128U
+#define CSR_SEQUENCEREG0B85S1_ADDR			0x129U
+#define CSR_SEQUENCEREG0B85S2_ADDR			0x12AU
+#define CSR_SEQUENCEREG0B86S0_ADDR			0x12BU
+#define CSR_SEQUENCEREG0B86S1_ADDR			0x12CU
+#define CSR_SEQUENCEREG0B86S2_ADDR			0x12DU
+#define CSR_SEQUENCEREG0B87S0_ADDR			0x12EU
+#define CSR_SEQUENCEREG0B87S1_ADDR			0x12FU
+#define CSR_SEQUENCEREG0B87S2_ADDR			0x130U
+#define CSR_SEQUENCEREG0B88S0_ADDR			0x131U
+#define CSR_SEQUENCEREG0B88S1_ADDR			0x132U
+#define CSR_SEQUENCEREG0B88S2_ADDR			0x133U
+#define CSR_SEQUENCEREG0B89S0_ADDR			0x134U
+#define CSR_SEQUENCEREG0B89S1_ADDR			0x135U
+#define CSR_SEQUENCEREG0B89S2_ADDR			0x136U
+#define CSR_SEQUENCEREG0B90S0_ADDR			0x137U
+#define CSR_SEQUENCEREG0B90S1_ADDR			0x138U
+#define CSR_SEQUENCEREG0B90S2_ADDR			0x139U
+#define CSR_SEQUENCEREG0B91S0_ADDR			0x13AU
+#define CSR_SEQUENCEREG0B91S1_ADDR			0x13BU
+#define CSR_SEQUENCEREG0B91S2_ADDR			0x13CU
+#define CSR_SEQUENCEREG0B92S0_ADDR			0x13DU
+#define CSR_SEQUENCEREG0B92S1_ADDR			0x13EU
+#define CSR_SEQUENCEREG0B92S2_ADDR			0x13FU
+#define CSR_SEQUENCEREG0B93S0_ADDR			0x140U
+#define CSR_SEQUENCEREG0B93S1_ADDR			0x141U
+#define CSR_SEQUENCEREG0B93S2_ADDR			0x142U
+#define CSR_SEQUENCEREG0B94S0_ADDR			0x143U
+#define CSR_SEQUENCEREG0B94S1_ADDR			0x144U
+#define CSR_SEQUENCEREG0B94S2_ADDR			0x145U
+#define CSR_SEQUENCEREG0B95S0_ADDR			0x146U
+#define CSR_SEQUENCEREG0B95S1_ADDR			0x147U
+#define CSR_SEQUENCEREG0B95S2_ADDR			0x148U
+#define CSR_SEQUENCEREG0B96S0_ADDR			0x149U
+#define CSR_SEQUENCEREG0B96S1_ADDR			0x14AU
+#define CSR_SEQUENCEREG0B96S2_ADDR			0x14BU
+#define CSR_SEQUENCEREG0B97S0_ADDR			0x14CU
+#define CSR_SEQUENCEREG0B97S1_ADDR			0x14DU
+#define CSR_SEQUENCEREG0B97S2_ADDR			0x14EU
+#define CSR_SEQUENCEREG0B98S0_ADDR			0x14FU
+#define CSR_SEQUENCEREG0B98S1_ADDR			0x150U
+#define CSR_SEQUENCEREG0B98S2_ADDR			0x151U
+#define CSR_SEQUENCEREG0B99S0_ADDR			0x152U
+#define CSR_SEQUENCEREG0B99S1_ADDR			0x153U
+#define CSR_SEQUENCEREG0B99S2_ADDR			0x154U
+#define CSR_SEQUENCEREG0B100S0_ADDR			0x155U
+#define CSR_SEQUENCEREG0B100S1_ADDR			0x156U
+#define CSR_SEQUENCEREG0B100S2_ADDR			0x157U
+#define CSR_SEQUENCEREG0B101S0_ADDR			0x158U
+#define CSR_SEQUENCEREG0B101S1_ADDR			0x159U
+#define CSR_SEQUENCEREG0B101S2_ADDR			0x15AU
+#define CSR_SEQUENCEREG0B102S0_ADDR			0x15BU
+#define CSR_SEQUENCEREG0B102S1_ADDR			0x15CU
+#define CSR_SEQUENCEREG0B102S2_ADDR			0x15DU
+#define CSR_SEQUENCEREG0B103S0_ADDR			0x15EU
+#define CSR_SEQUENCEREG0B103S1_ADDR			0x15FU
+#define CSR_SEQUENCEREG0B103S2_ADDR			0x160U
+#define CSR_SEQUENCEREG0B104S0_ADDR			0x161U
+#define CSR_SEQUENCEREG0B104S1_ADDR			0x162U
+#define CSR_SEQUENCEREG0B104S2_ADDR			0x163U
+#define CSR_SEQUENCEREG0B105S0_ADDR			0x164U
+#define CSR_SEQUENCEREG0B105S1_ADDR			0x165U
+#define CSR_SEQUENCEREG0B105S2_ADDR			0x166U
+#define CSR_SEQUENCEREG0B106S0_ADDR			0x167U
+#define CSR_SEQUENCEREG0B106S1_ADDR			0x168U
+#define CSR_SEQUENCEREG0B106S2_ADDR			0x169U
+#define CSR_SEQUENCEREG0B107S0_ADDR			0x16AU
+#define CSR_SEQUENCEREG0B107S1_ADDR			0x16BU
+#define CSR_SEQUENCEREG0B107S2_ADDR			0x16CU
+#define CSR_SEQUENCEREG0B108S0_ADDR			0x16DU
+#define CSR_SEQUENCEREG0B108S1_ADDR			0x16EU
+#define CSR_SEQUENCEREG0B108S2_ADDR			0x16FU
+#define CSR_SEQUENCEREG0B109S0_ADDR			0x170U
+#define CSR_SEQUENCEREG0B109S1_ADDR			0x171U
+#define CSR_SEQUENCEREG0B109S2_ADDR			0x172U
+#define CSR_SEQUENCEREG0B110S0_ADDR			0x173U
+#define CSR_SEQUENCEREG0B110S1_ADDR			0x174U
+#define CSR_SEQUENCEREG0B110S2_ADDR			0x175U
+#define CSR_SEQUENCEREG0B111S0_ADDR			0x176U
+#define CSR_SEQUENCEREG0B111S1_ADDR			0x177U
+#define CSR_SEQUENCEREG0B111S2_ADDR			0x178U
+#define CSR_SEQUENCEREG0B112S0_ADDR			0x179U
+#define CSR_SEQUENCEREG0B112S1_ADDR			0x17AU
+#define CSR_SEQUENCEREG0B112S2_ADDR			0x17BU
+#define CSR_SEQUENCEREG0B113S0_ADDR			0x17CU
+#define CSR_SEQUENCEREG0B113S1_ADDR			0x17DU
+#define CSR_SEQUENCEREG0B113S2_ADDR			0x17EU
+#define CSR_SEQUENCEREG0B114S0_ADDR			0x17FU
+#define CSR_SEQUENCEREG0B114S1_ADDR			0x180U
+#define CSR_SEQUENCEREG0B114S2_ADDR			0x181U
+#define CSR_SEQUENCEREG0B115S0_ADDR			0x182U
+#define CSR_SEQUENCEREG0B115S1_ADDR			0x183U
+#define CSR_SEQUENCEREG0B115S2_ADDR			0x184U
+#define CSR_SEQUENCEREG0B116S0_ADDR			0x185U
+#define CSR_SEQUENCEREG0B116S1_ADDR			0x186U
+#define CSR_SEQUENCEREG0B116S2_ADDR			0x187U
+#define CSR_SEQUENCEREG0B117S0_ADDR			0x188U
+#define CSR_SEQUENCEREG0B117S1_ADDR			0x189U
+#define CSR_SEQUENCEREG0B117S2_ADDR			0x18AU
+#define CSR_SEQUENCEREG0B118S0_ADDR			0x18BU
+#define CSR_SEQUENCEREG0B118S1_ADDR			0x18CU
+#define CSR_SEQUENCEREG0B118S2_ADDR			0x18DU
+#define CSR_SEQUENCEREG0B119S0_ADDR			0x18EU
+#define CSR_SEQUENCEREG0B119S1_ADDR			0x18FU
+#define CSR_SEQUENCEREG0B119S2_ADDR			0x190U
+#define CSR_SEQUENCEREG0B120S0_ADDR			0x191U
+#define CSR_SEQUENCEREG0B120S1_ADDR			0x192U
+#define CSR_SEQUENCEREG0B120S2_ADDR			0x193U
+#define CSR_SEQUENCEREG0B121S0_ADDR			0x194U
+#define CSR_SEQUENCEREG0B121S1_ADDR			0x195U
+#define CSR_SEQUENCEREG0B121S2_ADDR			0x196U
+#define CSR_SEQ0BGPR1_ADDR				0x201U
+#define CSR_SEQ0BGPR2_ADDR				0x202U
+#define CSR_SEQ0BGPR3_ADDR				0x203U
+#define CSR_SEQ0BGPR4_ADDR				0x204U
+#define CSR_SEQ0BGPR5_ADDR				0x205U
+#define CSR_SEQ0BGPR6_ADDR				0x206U
+#define CSR_SEQ0BGPR7_ADDR				0x207U
+#define CSR_SEQ0BGPR8_ADDR				0x208U
+#define CSR_SEQ0BFIXEDADDRBITS_ADDR			0x2FFU
+
+/* DRTUB0 register offsets */
+#define CSR_DCTSHADOWREGS_ADDR				0x4U
+#define CSR_DCTWRITEONLYSHADOW_ADDR			0x30U
+#define CSR_UCTWRITEONLY_ADDR				0x32U
+#define CSR_UCTWRITEPROT_ADDR				0x33U
+#define CSR_UCTDATWRITEONLY_ADDR			0x34U
+#define CSR_UCTDATWRITEPROT_ADDR			0x35U
+#define CSR_UCTLERR_ADDR				0x36U
+#define CSR_UCCLKHCLKENABLES_ADDR			0x80U
+#define CSR_CURPSTATE0B_ADDR				0x81U
+#define CSR_CLRWAKEUPSTICKY_ADDR			0x95U
+#define CSR_WAKEUPMASK_ADDR				0x96U
+#define CSR_CUSTPUBREV_ADDR				0xEDU
+#define CSR_PUBREV_ADDR					0xEEU
+
+/* APBONLY0 register offsets */
+#define CSR_MICROCONTMUXSEL_ADDR			0x0U
+#define CSR_UCTSHADOWREGS_ADDR				0x4U
+#define CSR_DCTWRITEONLY_ADDR				0x30U
+#define CSR_DCTWRITEPROT_ADDR				0x31U
+#define CSR_UCTWRITEONLYSHADOW_ADDR			0x32U
+#define CSR_UCTDATWRITEONLYSHADOW_ADDR			0x34U
+#define CSR_NEVERGATECSRCLOCK_ADDR			0x35U
+#define CSR_DFICFGRDDATAVALIDTICKS_ADDR			0x37U
+#define CSR_MICRORESET_ADDR				0x99U
+#define CSR_SEQUENCEROVERRIDE_ADDR			0xE7U
+#define CSR_DFIINITCOMPLETESHADOW_ADDR			0xFAU
+
+/* ANIBx register bit fields */
+/* CSR_MTESTMUXSEL */
+#define CSR_MTESTMUXSEL_LSB				0
+#define CSR_MTESTMUXSEL_MASK				GENMASK_32(5, 0)
+/* CSR_AFORCEDRVCONT */
+#define CSR_AFORCEDRVCONT_LSB				0
+#define CSR_AFORCEDRVCONT_MASK				GENMASK_32(3, 0)
+/* CSR_AFORCETRICONT */
+#define CSR_AFORCETRICONT_LSB				0
+#define CSR_AFORCETRICONT_MASK				GENMASK_32(3, 0)
+/* CSR_ATXIMPEDANCE */
+#define CSR_ATXIMPEDANCE_LSB				0
+#define CSR_ATXIMPEDANCE_MASK				GENMASK_32(9, 0)
+#define CSR_ADRVSTRENP_LSB				0
+#define CSR_ADRVSTRENP_MASK				GENMASK_32(4, 0)
+#define CSR_ADRVSTRENN_LSB				5
+#define CSR_ADRVSTRENN_MASK				GENMASK_32(9, 5)
+/* CSR_ATESTPRBSERR */
+#define CSR_ATESTPRBSERR_LSB				0
+#define CSR_ATESTPRBSERR_MASK				GENMASK_32(3, 0)
+/* CSR_ATXSLEWRATE */
+#define CSR_ATXSLEWRATE_LSB				0
+#define CSR_ATXSLEWRATE_MASK				GENMASK_32(10, 0)
+#define CSR_ATXPREP_LSB					0
+#define CSR_ATXPREP_MASK				GENMASK_32(3, 0)
+#define CSR_ATXPREN_LSB					4
+#define CSR_ATXPREN_MASK				GENMASK_32(7, 4)
+#define CSR_ATXPREDRVMODE_LSB				8
+#define CSR_ATXPREDRVMODE_MASK				GENMASK_32(10, 8)
+/* CSR_ATESTPRBSERRCNT */
+#define CSR_ATESTPRBSERRCNT_LSB				0
+#define CSR_ATESTPRBSERRCNT_MASK			GENMASK_32(15, 0)
+/* CSR_ATXDLY */
+#define CSR_ATXDLY_LSB					0
+#define CSR_ATXDLY_MASK					GENMASK_32(6, 0)
+
+/* DBYTEx register bit fields */
+/* CSR_DBYTEMISCMODE */
+#define CSR_DBYTEMISCMODE_LSB				2
+#define CSR_DBYTEMISCMODE_MASK				BIT(2)
+#define CSR_DBYTEDISABLE_LSB				2
+#define CSR_DBYTEDISABLE_MASK				BIT(2)
+/* CSR_TSMBYTE0 */
+#define CSR_TSMBYTE0_LSB				0
+#define CSR_TSMBYTE0_MASK				GENMASK_32(15, 0)
+#define CSR_PERPHTRAINEN_LSB				0
+#define CSR_PERPHTRAINEN_MASK				BIT(0)
+#define CSR_EYEINC_LSB					1
+#define CSR_EYEINC_MASK					BIT(1)
+#define CSR_EDGEINC_LSB					2
+#define CSR_EDGEINC_MASK				BIT(2)
+#define CSR_EDGEEYEMXSEL_LSB				3
+#define CSR_EDGEEYEMXSEL_MASK				BIT(3)
+#define CSR_TSMBYTE0RSVD_LSB				4
+#define CSR_TSMBYTE0RSVD_MASK				GENMASK_32(5, 4)
+#define CSR_DIMMBROADINC_LSB				6
+#define CSR_DIMMBROADINC_MASK				BIT(6)
+#define CSR_DIMMINC_LSB					7
+#define CSR_DIMMINC_MASK				GENMASK_32(8, 7)
+#define CSR_COARSEINC_LSB				9
+#define CSR_COARSEINC_MASK				BIT(9)
+#define CSR_DELAYINC_LSB				10
+#define CSR_DELAYINC_MASK				BIT(10)
+#define CSR_RXINC_LSB					11
+#define CSR_RXINC_MASK					BIT(11)
+#define CSR_RXPERTRAIN_LSB				12
+#define CSR_RXPERTRAIN_MASK				BIT(12)
+#define CSR_TXPERTRAIN_LSB				13
+#define CSR_TXPERTRAIN_MASK				BIT(13)
+#define CSR_DMTRAIN_LSB					14
+#define CSR_DMTRAIN_MASK				BIT(14)
+#define CSR_WRLEVTRAIN_LSB				15
+#define CSR_WRLEVTRAIN_MASK				BIT(15)
+/* CSR_TRAININGPARAM */
+#define CSR_TRAININGPARAM_LSB				0
+#define CSR_TRAININGPARAM_MASK				GENMASK_32(15, 0)
+#define CSR_ENDYNRATEREDUCTION_LSB			0
+#define CSR_ENDYNRATEREDUCTION_MASK			BIT(0)
+#define CSR_TRAININGPARAM01RSVD_LSB			1
+#define CSR_TRAININGPARAM01RSVD_MASK			BIT(1)
+#define CSR_TRAINENRXCLK_LSB				2
+#define CSR_TRAINENRXCLK_MASK				BIT(2)
+#define CSR_TRAINENRXEN_LSB				3
+#define CSR_TRAINENRXEN_MASK				BIT(3)
+#define CSR_TRAINENTXDQS_LSB				4
+#define CSR_TRAINENTXDQS_MASK				BIT(4)
+#define CSR_TRAINENTXDQ_LSB				5
+#define CSR_TRAINENTXDQ_MASK				BIT(5)
+#define CSR_TRAINENVREFDAC1_LSB				6
+#define CSR_TRAINENVREFDAC1_MASK			BIT(6)
+#define CSR_TRAINENVREFDAC0_LSB				7
+#define CSR_TRAINENVREFDAC0_MASK			BIT(7)
+#define CSR_TRAINENRXPBD_LSB				8
+#define CSR_TRAINENRXPBD_MASK				BIT(8)
+#define CSR_ROLLINTOCOARSE_LSB				9
+#define CSR_ROLLINTOCOARSE_MASK				BIT(9)
+#define CSR_TRAINUSINGNATIVEDDLCNTL_LSB			10
+#define CSR_TRAINUSINGNATIVEDDLCNTL_MASK		BIT(10)
+#define CSR_TRAININGPARAM11RSVD_LSB			11
+#define CSR_TRAININGPARAM11RSVD_MASK			BIT(11)
+#define CSR_TRAININGPARAM12RSVD_LSB			12
+#define CSR_TRAININGPARAM12RSVD_MASK			BIT(12)
+#define CSR_INCDECRATE_LSB				13
+#define CSR_INCDECRATE_MASK				GENMASK_32(15, 13)
+/* CSR_USEDQSENREPLICA */
+#define CSR_USEDQSENREPLICA_LSB				0
+#define CSR_USEDQSENREPLICA_MASK			BIT(0)
+/* CSR_RXTRAINPATTERNENABLE */
+#define CSR_RXTRAINPATTERNENABLE_LSB			0
+#define CSR_RXTRAINPATTERNENABLE_MASK			BIT(0)
+/* CSR_TSMBYTE1 */
+#define CSR_TSMBYTE1_LSB				0
+#define CSR_TSMBYTE1_MASK				GENMASK_32(15, 0)
+#define CSR_DTSMBDSTP_LSB				0
+#define CSR_DTSMBDSTP_MASK				GENMASK_32(7, 0)
+#define CSR_DTSMGDSTP_LSB				8
+#define CSR_DTSMGDSTP_MASK				GENMASK_32(15, 8)
+/* CSR_TSMBYTE2 */
+#define CSR_TSMBYTE2_LSB				0
+#define CSR_TSMBYTE2_MASK				GENMASK_32(15, 0)
+#define CSR_DTSMGDBAR_LSB				0
+#define CSR_DTSMGDBAR_MASK				GENMASK_32(15, 0)
+/* CSR_TSMBYTE3 */
+#define CSR_TSMBYTE3_LSB				0
+#define CSR_TSMBYTE3_MASK				GENMASK_32(8, 0)
+#define CSR_DTSMINCDECMODE_LSB				0
+#define CSR_DTSMINCDECMODE_MASK				BIT(0)
+#define CSR_DTSMINCDECCTRL_LSB				1
+#define CSR_DTSMINCDECCTRL_MASK				BIT(1)
+#define CSR_ENBLRXSAMPFLOPS_LSB				2
+#define CSR_ENBLRXSAMPFLOPS_MASK			BIT(2)
+#define CSR_SELRXSAMPFLOPS_LSB				3
+#define CSR_SELRXSAMPFLOPS_MASK				BIT(3)
+#define CSR_SELRXBYBASS_LSB				4
+#define CSR_SELRXBYBASS_MASK				BIT(4)
+#define CSR_DTSMIGNUPDATEACK_LSB			5
+#define CSR_DTSMIGNUPDATEACK_MASK			BIT(5)
+#define CSR_ENABLERXDQASYNC_LSB				6
+#define CSR_ENABLERXDQASYNC_MASK			BIT(6)
+#define CSR_DTSMSTATICCMPR_LSB				7
+#define CSR_DTSMSTATICCMPR_MASK				BIT(7)
+#define CSR_DTSMSTATICCMPRVAL_LSB			8
+#define CSR_DTSMSTATICCMPRVAL_MASK			BIT(8)
+/* CSR_TSMBYTE4 */
+#define CSR_TSMBYTE4_LSB				0
+#define CSR_TSMBYTE4_MASK				GENMASK_32(3, 0)
+#define CSR_DTSMINCDECPW_LSB				0
+#define CSR_DTSMINCDECPW_MASK				GENMASK_32(3, 0)
+/* CSR_TESTMODECONFIG */
+#define CSR_TESTMODECONFIG_LSB				0
+#define CSR_TESTMODECONFIG_MASK				GENMASK_32(9, 0)
+#define CSR_LOOPBACKEN_LSB				0
+#define CSR_LOOPBACKEN_MASK				BIT(0)
+#define CSR_RSVDTESTDLLEN_LSB				1
+#define CSR_RSVDTESTDLLEN_MASK				BIT(1)
+#define CSR_RSVDTWOTCKTXDQSPRE_LSB			2
+#define CSR_RSVDTWOTCKTXDQSPRE_MASK			BIT(2)
+#define CSR_TESTMODERSVD_LSB				3
+#define CSR_TESTMODERSVD_MASK				GENMASK_32(7, 3)
+#define CSR_LOOPBACKDISDQSTRI_LSB			8
+#define CSR_LOOPBACKDISDQSTRI_MASK			BIT(8)
+#define CSR_RSVDDISTXDQEQPREAMBLE_LSB			9
+#define CSR_RSVDDISTXDQEQPREAMBLE_MASK			BIT(9)
+/* CSR_TSMBYTE5 */
+#define CSR_TSMBYTE5_LSB				0
+#define CSR_TSMBYTE5_MASK				GENMASK_32(15, 0)
+#define CSR_DTSMBDBAR_LSB				0
+#define CSR_DTSMBDBAR_MASK				GENMASK_32(15, 0)
+/* MTESTMUXSEL already defined in ANIBx section */
+/* CSR_DTSMTRAINMODECTRL */
+#define CSR_DTSMTRAINMODECTRL_LSB			0
+#define CSR_DTSMTRAINMODECTRL_MASK			GENMASK_32(3, 0)
+#define CSR_DTSMSOELANEMODE_LSB				0
+#define CSR_DTSMSOELANEMODE_MASK			GENMASK_32(1, 0)
+#define CSR_DTSMBYTEERRANDMODE_LSB			2
+#define CSR_DTSMBYTEERRANDMODE_MASK			BIT(2)
+#define CSR_DTSMNIBERRMODE_LSB				3
+#define CSR_DTSMNIBERRMODE_MASK				BIT(3)
+/* CSR_DFIMRL */
+#define CSR_DFIMRL_LSB					0
+#define CSR_DFIMRL_MASK					GENMASK_32(4, 0)
+/* CSR_ASYNCDBYTEMODE */
+#define CSR_ASYNCDBYTEMODE_LSB				0
+#define CSR_ASYNCDBYTEMODE_MASK				GENMASK_32(8, 0)
+/* CSR_ASYNCDBYTETXEN */
+#define CSR_ASYNCDBYTETXEN_LSB				0
+#define CSR_ASYNCDBYTETXEN_MASK				GENMASK_32(11, 0)
+/* CSR_ASYNCDBYTETXDATA */
+#define CSR_ASYNCDBYTETXDATA_LSB			0
+#define CSR_ASYNCDBYTETXDATA_MASK			GENMASK_32(11, 0)
+/* CSR_ASYNCDBYTERXDATA */
+#define CSR_ASYNCDBYTERXDATA_LSB			0
+#define CSR_ASYNCDBYTERXDATA_MASK			GENMASK_32(11, 0)
+/* CSR_VREFDAC1 */
+#define CSR_VREFDAC1_LSB				0
+#define CSR_VREFDAC1_MASK				GENMASK_32(6, 0)
+/* CSR_TRAININGCNTR */
+#define CSR_TRAININGCNTR_LSB				0
+#define CSR_TRAININGCNTR_MASK				GENMASK_32(15, 0)
+#define CSR_TRAININGCNTRFINE_LSB			0
+#define CSR_TRAININGCNTRFINE_MASK			GENMASK_32(9, 0)
+#define CSR_TRAININGCNTRCOARSE_LSB			10
+#define CSR_TRAININGCNTRCOARSE_MASK			GENMASK_32(15, 10)
+/* CSR_VREFDAC0 */
+#define CSR_VREFDAC0_LSB				0
+#define CSR_VREFDAC0_MASK				GENMASK_32(6, 0)
+/* CSR_TXIMPEDANCECTRL0 */
+#define CSR_TXIMPEDANCECTRL0_LSB			0
+#define CSR_TXIMPEDANCECTRL0_MASK			GENMASK_32(11, 0)
+#define CSR_DRVSTRENDQP_LSB				0
+#define CSR_DRVSTRENDQP_MASK				GENMASK_32(5, 0)
+#define CSR_DRVSTRENDQN_LSB				6
+#define CSR_DRVSTRENDQN_MASK				GENMASK_32(11, 6)
+/* CSR_DQDQSRCVCNTRL */
+#define CSR_DQDQSRCVCNTRL_LSB				0
+#define CSR_DQDQSRCVCNTRL_MASK				GENMASK_32(15, 0)
+#define CSR_SELANALOGVREF_LSB				0
+#define CSR_SELANALOGVREF_MASK				BIT(0)
+#define CSR_EXTVREFRANGE_LSB				1
+#define CSR_EXTVREFRANGE_MASK				BIT(1)
+#define CSR_DFECTRL_LSB					2
+#define CSR_DFECTRL_MASK				GENMASK_32(3, 2)
+#define CSR_MAJORMODEDBYTE_LSB				4
+#define CSR_MAJORMODEDBYTE_MASK				GENMASK_32(6, 4)
+#define CSR_GAINCURRADJ_LSB				7
+#define CSR_GAINCURRADJ_MASK				GENMASK_32(11, 7)
+#define CSR_RESERVED_LSB				12
+#define CSR_RESERVED_MASK				GENMASK_32(15, 12)
+/* CSR_TXEQUALIZATIONMODE */
+#define CSR_TXEQUALIZATIONMODE_LSB			0
+#define CSR_TXEQUALIZATIONMODE_MASK			GENMASK_32(1, 0)
+#define CSR_TXEQMODE_LSB				0
+#define CSR_TXEQMODE_MASK				GENMASK_32(1, 0)
+/* CSR_TXIMPEDANCECTRL1 */
+#define CSR_TXIMPEDANCECTRL1_LSB			0
+#define CSR_TXIMPEDANCECTRL1_MASK			GENMASK_32(11, 0)
+#define CSR_DRVSTRENFSDQP_LSB				0
+#define CSR_DRVSTRENFSDQP_MASK				GENMASK_32(5, 0)
+#define CSR_DRVSTRENFSDQN_LSB				6
+#define CSR_DRVSTRENFSDQN_MASK				GENMASK_32(11, 6)
+/* CSR_DQDQSRCVCNTRL1 */
+#define CSR_DQDQSRCVCNTRL1_LSB				0
+#define CSR_DQDQSRCVCNTRL1_MASK				GENMASK_32(11, 0)
+#define CSR_POWERDOWNRCVR_LSB				0
+#define CSR_POWERDOWNRCVR_MASK				GENMASK_32(8, 0)
+#define CSR_POWERDOWNRCVRDQS_LSB			9
+#define CSR_POWERDOWNRCVRDQS_MASK			BIT(9)
+#define CSR_RXPADSTANDBYEN_LSB				10
+#define CSR_RXPADSTANDBYEN_MASK				BIT(10)
+#define CSR_ENLPREQPDR_LSB				11
+#define CSR_ENLPREQPDR_MASK				BIT(11)
+/* CSR_TXIMPEDANCECTRL2 */
+#define CSR_TXIMPEDANCECTRL2_LSB			0
+#define CSR_TXIMPEDANCECTRL2_MASK			GENMASK_32(11, 0)
+#define CSR_DRVSTRENEQHIDQP_LSB				0
+#define CSR_DRVSTRENEQHIDQP_MASK			GENMASK_32(5, 0)
+#define CSR_DRVSTRENEQLODQN_LSB				6
+#define CSR_DRVSTRENEQLODQN_MASK			GENMASK_32(11, 6)
+/* CSR_DQDQSRCVCNTRL2 */
+#define CSR_DQDQSRCVCNTRL2_LSB				0
+#define CSR_DQDQSRCVCNTRL2_MASK				BIT(0)
+#define CSR_ENRXAGRESSIVEPDR_LSB			0
+#define CSR_ENRXAGRESSIVEPDR_MASK			BIT(0)
+/* CSR_TXODTDRVSTREN */
+#define CSR_TXODTDRVSTREN_LSB				0
+#define CSR_TXODTDRVSTREN_MASK				GENMASK_32(11, 0)
+#define CSR_ODTSTRENP_LSB				0
+#define CSR_ODTSTRENP_MASK				GENMASK_32(5, 0)
+#define CSR_ODTSTRENN_LSB				6
+#define CSR_ODTSTRENN_MASK				GENMASK_32(11, 6)
+/* CSR_RXFIFOCHECKSTATUS */
+#define CSR_RXFIFOCHECKSTATUS_LSB			0
+#define CSR_RXFIFOCHECKSTATUS_MASK			GENMASK_32(1, 0)
+#define CSR_RXFIFOLOCERR_LSB				0
+#define CSR_RXFIFOLOCERR_MASK				BIT(0)
+#define CSR_RXFIFOLOCUERR_LSB				1
+#define CSR_RXFIFOLOCUERR_MASK				BIT(1)
+/* CSR_RXFIFOCHECKERRVALUES */
+#define CSR_RXFIFOCHECKERRVALUES_LSB			0
+#define CSR_RXFIFOCHECKERRVALUES_MASK			GENMASK_32(15, 0)
+#define CSR_RXFIFORDLOCERRVALUE_LSB			0
+#define CSR_RXFIFORDLOCERRVALUE_MASK			GENMASK_32(3, 0)
+#define CSR_RXFIFOWRLOCERRVALUE_LSB			4
+#define CSR_RXFIFOWRLOCERRVALUE_MASK			GENMASK_32(7, 4)
+#define CSR_RXFIFORDLOCUERRVALUE_LSB			8
+#define CSR_RXFIFORDLOCUERRVALUE_MASK			GENMASK_32(11, 8)
+#define CSR_RXFIFOWRLOCUERRVALUE_LSB			12
+#define CSR_RXFIFOWRLOCUERRVALUE_MASK			GENMASK_32(15, 12)
+/* CSR_RXFIFOINFO */
+#define CSR_RXFIFOINFO_LSB				0
+#define CSR_RXFIFOINFO_MASK				GENMASK_32(15, 0)
+#define CSR_RXFIFORDLOC_LSB				0
+#define CSR_RXFIFORDLOC_MASK				GENMASK_32(3, 0)
+#define CSR_RXFIFOWRLOC_LSB				4
+#define CSR_RXFIFOWRLOC_MASK				GENMASK_32(7, 4)
+#define CSR_RXFIFORDLOCU_LSB				8
+#define CSR_RXFIFORDLOCU_MASK				GENMASK_32(11, 8)
+#define CSR_RXFIFOWRLOCU_LSB				12
+#define CSR_RXFIFOWRLOCU_MASK				GENMASK_32(15, 12)
+/* CSR_RXFIFOVISIBILITY */
+#define CSR_RXFIFOVISIBILITY_LSB			0
+#define CSR_RXFIFOVISIBILITY_MASK			GENMASK_32(4, 0)
+#define CSR_RXFIFORDPTR_LSB				0
+#define CSR_RXFIFORDPTR_MASK				GENMASK_32(2, 0)
+#define CSR_RXFIFORDPTROVR_LSB				3
+#define CSR_RXFIFORDPTROVR_MASK				BIT(3)
+#define CSR_RXFIFORDEN_LSB				4
+#define CSR_RXFIFORDEN_MASK				BIT(4)
+/* CSR_RXFIFOCONTENTSDQ3210 */
+#define CSR_RXFIFOCONTENTSDQ3210_LSB			0
+#define CSR_RXFIFOCONTENTSDQ3210_MASK			GENMASK_32(15, 0)
+/* CSR_RXFIFOCONTENTSDQ7654 */
+#define CSR_RXFIFOCONTENTSDQ7654_LSB			0
+#define CSR_RXFIFOCONTENTSDQ7654_MASK			GENMASK_32(15, 0)
+/* CSR_RXFIFOCONTENTSDBI */
+#define CSR_RXFIFOCONTENTSDBI_LSB			0
+#define CSR_RXFIFOCONTENTSDBI_MASK			GENMASK_32(3, 0)
+/* CSR_TXSLEWRATE */
+#define CSR_TXSLEWRATE_LSB				0
+#define CSR_TXSLEWRATE_MASK				GENMASK_32(10, 0)
+#define CSR_TXPREP_LSB					0
+#define CSR_TXPREP_MASK					GENMASK_32(3, 0)
+#define CSR_TXPREN_LSB					4
+#define CSR_TXPREN_MASK					GENMASK_32(7, 4)
+#define CSR_TXPREDRVMODE_LSB				8
+#define CSR_TXPREDRVMODE_MASK				GENMASK_32(10, 8)
+/* CSR_TRAININGINCDECDTSMEN */
+#define CSR_TRAININGINCDECDTSMEN_LSB			0
+#define CSR_TRAININGINCDECDTSMEN_MASK			GENMASK_32(8, 0)
+/* CSR_RXPBDLYTG0 */
+#define CSR_RXPBDLYTG0_LSB				0
+#define CSR_RXPBDLYTG0_MASK				GENMASK_32(6, 0)
+/* CSR_RXPBDLYTG1 */
+#define CSR_RXPBDLYTG1_LSB				0
+#define CSR_RXPBDLYTG1_MASK				GENMASK_32(6, 0)
+/* CSR_RXPBDLYTG2 */
+#define CSR_RXPBDLYTG2_LSB				0
+#define CSR_RXPBDLYTG2_MASK				GENMASK_32(6, 0)
+/* CSR_RXPBDLYTG3 */
+#define CSR_RXPBDLYTG3_LSB				0
+#define CSR_RXPBDLYTG3_MASK				GENMASK_32(6, 0)
+/* CSR_RXENDLYTG0 */
+#define CSR_RXENDLYTG0_LSB				0
+#define CSR_RXENDLYTG0_MASK				GENMASK_32(10, 0)
+/* CSR_RXENDLYTG1 */
+#define CSR_RXENDLYTG1_LSB				0
+#define CSR_RXENDLYTG1_MASK				GENMASK_32(10, 0)
+/* CSR_RXENDLYTG2 */
+#define CSR_RXENDLYTG2_LSB				0
+#define CSR_RXENDLYTG2_MASK				GENMASK_32(10, 0)
+/* CSR_RXENDLYTG3 */
+#define CSR_RXENDLYTG3_LSB				0
+#define CSR_RXENDLYTG3_MASK				GENMASK_32(10, 0)
+/* CSR_RXCLKDLYTG0 */
+#define CSR_RXCLKDLYTG0_LSB				0
+#define CSR_RXCLKDLYTG0_MASK				GENMASK_32(5, 0)
+/* CSR_RXCLKDLYTG1 */
+#define CSR_RXCLKDLYTG1_LSB				0
+#define CSR_RXCLKDLYTG1_MASK				GENMASK_32(5, 0)
+/* CSR_RXCLKDLYTG2 */
+#define CSR_RXCLKDLYTG2_LSB				0
+#define CSR_RXCLKDLYTG2_MASK				GENMASK_32(5, 0)
+/* CSR_RXCLKDLYTG3 */
+#define CSR_RXCLKDLYTG3_LSB				0
+#define CSR_RXCLKDLYTG3_MASK				GENMASK_32(5, 0)
+/* CSR_RXCLKCDLYTG0 */
+#define CSR_RXCLKCDLYTG0_LSB				0
+#define CSR_RXCLKCDLYTG0_MASK				GENMASK_32(5, 0)
+/* CSR_RXCLKCDLYTG1 */
+#define CSR_RXCLKCDLYTG1_LSB				0
+#define CSR_RXCLKCDLYTG1_MASK				GENMASK_32(5, 0)
+/* CSR_RXCLKCDLYTG2 */
+#define CSR_RXCLKCDLYTG2_LSB				0
+#define CSR_RXCLKCDLYTG2_MASK				GENMASK_32(5, 0)
+/* CSR_RXCLKCDLYTG3 */
+#define CSR_RXCLKCDLYTG3_LSB				0
+#define CSR_RXCLKCDLYTG3_MASK				GENMASK_32(5, 0)
+/* CSR_DQ0LNSEL */
+#define CSR_DQ0LNSEL_LSB				0
+#define CSR_DQ0LNSEL_MASK				GENMASK_32(2, 0)
+/* CSR_DQ1LNSEL */
+#define CSR_DQ1LNSEL_LSB				0
+#define CSR_DQ1LNSEL_MASK				GENMASK_32(2, 0)
+/* CSR_DQ2LNSEL */
+#define CSR_DQ2LNSEL_LSB				0
+#define CSR_DQ2LNSEL_MASK				GENMASK_32(2, 0)
+/* CSR_DQ3LNSEL */
+#define CSR_DQ3LNSEL_LSB				0
+#define CSR_DQ3LNSEL_MASK				GENMASK_32(2, 0)
+/* CSR_DQ4LNSEL */
+#define CSR_DQ4LNSEL_LSB				0
+#define CSR_DQ4LNSEL_MASK				GENMASK_32(2, 0)
+/* CSR_DQ5LNSEL */
+#define CSR_DQ5LNSEL_LSB				0
+#define CSR_DQ5LNSEL_MASK				GENMASK_32(2, 0)
+/* CSR_DQ6LNSEL */
+#define CSR_DQ6LNSEL_LSB				0
+#define CSR_DQ6LNSEL_MASK				GENMASK_32(2, 0)
+/* CSR_DQ7LNSEL */
+#define CSR_DQ7LNSEL_LSB				0
+#define CSR_DQ7LNSEL_MASK				GENMASK_32(2, 0)
+/* CSR_PPTCTLSTATIC */
+#define CSR_PPTCTLSTATIC_LSB				0
+#define CSR_PPTCTLSTATIC_MASK				GENMASK_32(11, 0)
+#define CSR_PPTENDQS2DQTG0_LSB				0
+#define CSR_PPTENDQS2DQTG0_MASK				BIT(0)
+#define CSR_PPTENDQS2DQTG1_LSB				1
+#define CSR_PPTENDQS2DQTG1_MASK				BIT(1)
+#define CSR_DOCBYTESELTG0_LSB				2
+#define CSR_DOCBYTESELTG0_MASK				BIT(2)
+#define CSR_DOCBYTESELTG1_LSB				3
+#define CSR_DOCBYTESELTG1_MASK				BIT(3)
+#define CSR_PPTINFOSEL_LSB				4
+#define CSR_PPTINFOSEL_MASK				GENMASK_32(7, 4)
+#define CSR_PPTENRXENDLYTG0_LSB				8
+#define CSR_PPTENRXENDLYTG0_MASK			BIT(8)
+#define CSR_PPTENRXENDLYTG1_LSB				9
+#define CSR_PPTENRXENDLYTG1_MASK			BIT(9)
+#define CSR_PPTENRXENBACKOFF_LSB			10
+#define CSR_PPTENRXENBACKOFF_MASK			GENMASK_32(11, 10)
+/* CSR_PPTCTLDYN */
+#define CSR_PPTCTLDYN_LSB				0
+#define CSR_PPTCTLDYN_MASK				GENMASK_32(1, 0)
+#define CSR_PPTDQS2DQACTIVE_LSB				0
+#define CSR_PPTDQS2DQACTIVE_MASK			BIT(0)
+#define CSR_PPTENRXENUSEDQSSAMPVAL_LSB			1
+#define CSR_PPTENRXENUSEDQSSAMPVAL_MASK			BIT(1)
+/* CSR_PPTINFO */
+#define CSR_PPTINFO_LSB					0
+#define CSR_PPTINFO_MASK				GENMASK_32(15, 0)
+/* CSR_PPTRXENEVNT */
+#define CSR_PPTRXENEVNT_LSB				0
+#define CSR_PPTRXENEVNT_MASK				GENMASK_32(1, 0)
+#define CSR_PPTRXENINIT_LSB				0
+#define CSR_PPTRXENINIT_MASK				BIT(0)
+#define CSR_PPTRXENMHUI_LSB				1
+#define CSR_PPTRXENMHUI_MASK				BIT(1)
+/* CSR_PPTDQSCNTINVTRNTG0 */
+#define CSR_PPTDQSCNTINVTRNTG0_LSB			0
+#define CSR_PPTDQSCNTINVTRNTG0_MASK			GENMASK_32(15, 0)
+/* CSR_PPTDQSCNTINVTRNTG1 */
+#define CSR_PPTDQSCNTINVTRNTG1_LSB			0
+#define CSR_PPTDQSCNTINVTRNTG1_MASK			GENMASK_32(15, 0)
+/* CSR_DTSMBLANKINGCTRL */
+#define CSR_DTSMBLANKINGCTRL_LSB			0
+#define CSR_DTSMBLANKINGCTRL_MASK			GENMASK_32(9, 0)
+#define CSR_DTSMBLANK_LSB				0
+#define CSR_DTSMBLANK_MASK				GENMASK_32(9, 0)
+/* CSR_TSM0 */
+#define CSR_TSM0_LSB					0
+#define CSR_TSM0_MASK					GENMASK_32(13, 0)
+#define CSR_DTSMENB_LSB					0
+#define CSR_DTSMENB_MASK				BIT(0)
+#define CSR_DTSMDIR_LSB					1
+#define CSR_DTSMDIR_MASK				BIT(1)
+#define CSR_DTSMIGNFRST_LSB				2
+#define CSR_DTSMIGNFRST_MASK				BIT(2)
+#define CSR_DTSMODDPHASE_LSB				3
+#define CSR_DTSMODDPHASE_MASK				BIT(3)
+#define CSR_DTSMFLTPRE_LSB				4
+#define CSR_DTSMFLTPRE_MASK				BIT(4)
+#define CSR_DTSMFLTCUR_LSB				5
+#define CSR_DTSMFLTCUR_MASK				BIT(5)
+#define CSR_DTSMFLTNXT_LSB				6
+#define CSR_DTSMFLTNXT_MASK				BIT(6)
+#define CSR_DTSMFLTVAL_LSB				7
+#define CSR_DTSMFLTVAL_MASK				GENMASK_32(9, 7)
+#define CSR_DTSMMSKBIT_LSB				10
+#define CSR_DTSMMSKBIT_MASK				GENMASK_32(13, 10)
+/* CSR_TSM1 */
+#define CSR_TSM1_LSB					0
+#define CSR_TSM1_MASK					GENMASK_32(15, 0)
+#define CSR_DTSMERRCNT_LSB				0
+#define CSR_DTSMERRCNT_MASK				GENMASK_32(15, 0)
+/* CSR_TSM2 */
+#define CSR_TSM2_LSB					0
+#define CSR_TSM2_MASK					BIT(0)
+#define CSR_DTSMDISERRCHK_LSB				0
+#define CSR_DTSMDISERRCHK_MASK				BIT(0)
+/* CSR_TSM3 */
+#define CSR_TSM3_LSB					0
+#define CSR_TSM3_MASK					GENMASK_32(9, 0)
+#define CSR_DTSMCLRERRCNTMSK_LSB			0
+#define CSR_DTSMCLRERRCNTMSK_MASK			GENMASK_32(8, 0)
+#define CSR_DTSMCLRERRCNT_LSB				9
+#define CSR_DTSMCLRERRCNT_MASK				BIT(9)
+/* CSR_TXCHKDATASELECTS */
+#define CSR_TXCHKDATASELECTS_LSB			0
+#define CSR_TXCHKDATASELECTS_MASK			GENMASK_32(1, 0)
+#define CSR_SELCHKTOTX_LSB				0
+#define CSR_SELCHKTOTX_MASK				BIT(0)
+#define CSR_SELTXTOCHK_LSB				1
+#define CSR_SELTXTOCHK_MASK				BIT(1)
+/* CSR_DTSMUPTHLDXINGIND */
+#define CSR_DTSMUPTHLDXINGIND_LSB			0
+#define CSR_DTSMUPTHLDXINGIND_MASK			GENMASK_32(8, 0)
+/* CSR_DTSMLOTHLDXINGIND */
+#define CSR_DTSMLOTHLDXINGIND_LSB			0
+#define CSR_DTSMLOTHLDXINGIND_MASK			GENMASK_32(8, 0)
+/* CSR_DBYTEALLDTSMCTRL0 */
+#define CSR_DBYTEALLDTSMCTRL0_LSB			0
+#define CSR_DBYTEALLDTSMCTRL0_MASK			GENMASK_32(8, 0)
+#define CSR_DTSMINHIBDTSM_LSB				0
+#define CSR_DTSMINHIBDTSM_MASK				GENMASK_32(8, 0)
+/* CSR_DBYTEALLDTSMCTRL1 */
+#define CSR_DBYTEALLDTSMCTRL1_LSB			0
+#define CSR_DBYTEALLDTSMCTRL1_MASK			GENMASK_32(8, 0)
+#define CSR_DTSMGATEINC_LSB				0
+#define CSR_DTSMGATEINC_MASK				GENMASK_32(8, 0)
+/* CSR_DBYTEALLDTSMCTRL2 */
+#define CSR_DBYTEALLDTSMCTRL2_LSB			0
+#define CSR_DBYTEALLDTSMCTRL2_MASK			GENMASK_32(8, 0)
+#define CSR_DTSMGATEDEC_LSB				0
+#define CSR_DTSMGATEDEC_MASK				GENMASK_32(8, 0)
+/* CSR_TXDQDLYTG0 */
+#define CSR_TXDQDLYTG0_LSB				0
+#define CSR_TXDQDLYTG0_MASK				GENMASK_32(8, 0)
+/* CSR_TXDQDLYTG1 */
+#define CSR_TXDQDLYTG1_LSB				0
+#define CSR_TXDQDLYTG1_MASK				GENMASK_32(8, 0)
+/* CSR_TXDQDLYTG2 */
+#define CSR_TXDQDLYTG2_LSB				0
+#define CSR_TXDQDLYTG2_MASK				GENMASK_32(8, 0)
+/* CSR_TXDQDLYTG3 */
+#define CSR_TXDQDLYTG3_LSB				0
+#define CSR_TXDQDLYTG3_MASK				GENMASK_32(8, 0)
+/* CSR_TXDQSDLYTG0 */
+#define CSR_TXDQSDLYTG0_LSB				0
+#define CSR_TXDQSDLYTG0_MASK				GENMASK_32(9, 0)
+/* CSR_TXDQSDLYTG1 */
+#define CSR_TXDQSDLYTG1_LSB				0
+#define CSR_TXDQSDLYTG1_MASK				GENMASK_32(9, 0)
+/* CSR_TXDQSDLYTG2 */
+#define CSR_TXDQSDLYTG2_LSB				0
+#define CSR_TXDQSDLYTG2_MASK				GENMASK_32(9, 0)
+/* CSR_TXDQSDLYTG3 */
+#define CSR_TXDQSDLYTG3_LSB				0
+#define CSR_TXDQSDLYTG3_MASK				GENMASK_32(9, 0)
+/* CSR_DXLCDLSTATUS_ADDR */
+#define CSR_DXLCDLSTATUS_LSB				0
+#define CSR_DXLCDLSTATUS_MASK				GENMASK_32(13, 0)
+#define CSR_DXLCDLFINESNAPVAL_LSB			0
+#define CSR_DXLCDLFINESNAPVAL_MASK			GENMASK_32(9, 0)
+#define CSR_DXLCDLPHDSNAPVAL_LSB			10
+#define CSR_DXLCDLPHDSNAPVAL_MASK			BIT(10)
+#define CSR_DXLCDLSTICKYLOCK_LSB			11
+#define CSR_DXLCDLSTICKYLOCK_MASK			BIT(11)
+#define CSR_DXLCDLSTICKYUNLOCK_LSB			12
+#define CSR_DXLCDLSTICKYUNLOCK_MASK			BIT(12)
+#define CSR_DXLCDLLIVELOCK_LSB				13
+#define CSR_DXLCDLLIVELOCK_MASK				BIT(13)
+
+/* MASTER0 register offsets */
+/* CSR_RXFIFOINIT */
+#define CSR_RXFIFOINIT_LSB				0
+#define CSR_RXFIFOINIT_MASK				GENMASK_32(1, 0)
+#define CSR_RXFIFOINITPTR_LSB				0
+#define CSR_RXFIFOINITPTR_MASK				BIT(0)
+#define CSR_INHIBITRXFIFORD_LSB				1
+#define CSR_INHIBITRXFIFORD_MASK			BIT(1)
+/* CSR_FORCECLKDISABLE */
+#define CSR_FORCECLKDISABLE_LSB				0
+#define CSR_FORCECLKDISABLE_MASK			GENMASK_32(3, 0)
+/* CSR_CLOCKINGCTRL */
+#define CSR_CLOCKINGCTRL_LSB				0
+#define CSR_CLOCKINGCTRL_MASK				GENMASK_32(1, 0)
+#define CSR_PCLKENASYNCCTRL_LSB				0
+#define CSR_PCLKENASYNCCTRL_MASK			BIT(0)
+#define CSR_DLLTRACKENCTRL_LSB				1
+#define CSR_DLLTRACKENCTRL_MASK				BIT(1)
+/* CSR_FORCEINTERNALUPDATE */
+#define CSR_FORCEINTERNALUPDATE_LSB			0
+#define CSR_FORCEINTERNALUPDATE_MASK			BIT(0)
+/* CSR_PHYCONFIG */
+#define CSR_PHYCONFIG_LSB				0
+#define CSR_PHYCONFIG_MASK				GENMASK_32(9, 0)
+#define CSR_PHYCONFIGANIBS_LSB				0
+#define CSR_PHYCONFIGANIBS_MASK				GENMASK_32(3, 0)
+#define CSR_PHYCONFIGDBYTES_LSB				4
+#define CSR_PHYCONFIGDBYTES_MASK			GENMASK_32(7, 4)
+#define CSR_PHYCONFIGDFI_LSB				8
+#define CSR_PHYCONFIGDFI_MASK				GENMASK_32(9, 8)
+/* CSR_PGCR */
+#define CSR_PGCR_LSB					0
+#define CSR_PGCR_MASK					BIT(0)
+#define CSR_RXCLKRISEFALLMODE_LSB			0
+#define CSR_RXCLKRISEFALLMODE_MASK			BIT(0)
+/* CSR_TESTBUMPCNTRL1 */
+#define CSR_TESTBUMPCNTRL1_LSB				0
+#define CSR_TESTBUMPCNTRL1_MASK				GENMASK_32(15, 0)
+#define CSR_TESTMAJORMODE_LSB				0
+#define CSR_TESTMAJORMODE_MASK				GENMASK_32(2, 0)
+#define CSR_TESTBIASBYPASSEN_LSB			3
+#define CSR_TESTBIASBYPASSEN_MASK			BIT(3)
+#define CSR_TESTANALOGOUTCTRL_LSB			4
+#define CSR_TESTANALOGOUTCTRL_MASK			GENMASK_32(7, 4)
+#define CSR_TESTGAINCURRADJ_LSB				8
+#define CSR_TESTGAINCURRADJ_MASK			GENMASK_32(12, 8)
+#define CSR_TESTSELEXTERNALVREF_LSB			13
+#define CSR_TESTSELEXTERNALVREF_MASK			BIT(13)
+#define CSR_TESTEXTVREFRANGE_LSB			14
+#define CSR_TESTEXTVREFRANGE_MASK			BIT(14)
+#define CSR_TESTPOWERGATEEN_LSB				15
+#define CSR_TESTPOWERGATEEN_MASK			BIT(15)
+/* CSR_CALUCLKINFO */
+#define CSR_CALUCLKINFO_LSB				0
+#define CSR_CALUCLKINFO_MASK				GENMASK_32(10, 0)
+#define CSR_CALUCLKTICKSPER1US_LSB			0
+#define CSR_CALUCLKTICKSPER1US_MASK			GENMASK_32(10, 0)
+/* CSR_TESTBUMPCNTRL */
+#define CSR_TESTBUMPCNTRL_LSB				0
+#define CSR_TESTBUMPCNTRL_MASK				GENMASK_32(9, 0)
+#define CSR_TESTBUMPEN_LSB				0
+#define CSR_TESTBUMPEN_MASK				GENMASK_32(1, 0)
+#define CSR_TESTBUMPTOGGLE_LSB				2
+#define CSR_TESTBUMPTOGGLE_MASK				BIT(2)
+#define CSR_TESTBUMPDATASEL_LSB				3
+#define CSR_TESTBUMPDATASEL_MASK			GENMASK_32(8, 3)
+#define CSR_FORCEMTESTONALERT_LSB			9
+#define CSR_FORCEMTESTONALERT_MASK			BIT(9)
+/* CSR_SEQ0BDLY0 */
+#define CSR_SEQ0BDLY0_LSB				0
+#define CSR_SEQ0BDLY0_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BDLY1 */
+#define CSR_SEQ0BDLY1_LSB				0
+#define CSR_SEQ0BDLY1_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BDLY2 */
+#define CSR_SEQ0BDLY2_LSB				0
+#define CSR_SEQ0BDLY2_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BDLY3 */
+#define CSR_SEQ0BDLY3_LSB				0
+#define CSR_SEQ0BDLY3_MASK				GENMASK_32(15, 0)
+/* CSR_PHYALERTSTATUS */
+#define CSR_PHYALERTSTATUS_LSB				0
+#define CSR_PHYALERTSTATUS_MASK				BIT(0)
+#define CSR_PHYALERT_LSB				0
+#define CSR_PHYALERT_MASK				BIT(0)
+/* CSR_PPTTRAINSETUP */
+#define CSR_PPTTRAINSETUP_LSB				0
+#define CSR_PPTTRAINSETUP_MASK				GENMASK_32(6, 0)
+#define CSR_PHYMSTRTRAININTERVAL_LSB			0
+#define CSR_PHYMSTRTRAININTERVAL_MASK			GENMASK_32(3, 0)
+#define CSR_PHYMSTRMAXREQTOACK_LSB			4
+#define CSR_PHYMSTRMAXREQTOACK_MASK			GENMASK_32(6, 4)
+/* CSR_PPTTRAINSETUP2 */
+#define CSR_PPTTRAINSETUP2_LSB				0
+#define CSR_PPTTRAINSETUP2_MASK				GENMASK_32(2, 0)
+#define CSR_PHYMSTRFREQOVERRIDE_LSB			0
+#define CSR_PHYMSTRFREQOVERRIDE_MASK			GENMASK_32(2, 0)
+/* CSR_ATESTMODE */
+#define CSR_ATESTMODE_LSB				0
+#define CSR_ATESTMODE_MASK				GENMASK_32(4, 0)
+#define CSR_ATESTPRBSEN_LSB				0
+#define CSR_ATESTPRBSEN_MASK				BIT(0)
+#define CSR_ATESTCLKEN_LSB				1
+#define CSR_ATESTCLKEN_MASK				BIT(1)
+#define CSR_ATESTMODESEL_LSB				2
+#define CSR_ATESTMODESEL_MASK				GENMASK_32(4, 2)
+/* CSR_TXCALBINP */
+#define CSR_TXCALBINP_LSB				0
+#define CSR_TXCALBINP_MASK				GENMASK_32(4, 0)
+/* CSR_TXCALBINN */
+#define CSR_TXCALBINN_LSB				0
+#define CSR_TXCALBINN_MASK				GENMASK_32(4, 0)
+/* CSR_TXCALPOVR */
+#define CSR_TXCALPOVR_LSB				0
+#define CSR_TXCALPOVR_MASK				GENMASK_32(5, 0)
+#define CSR_TXCALBINPOVRVAL_LSB				0
+#define CSR_TXCALBINPOVRVAL_MASK			GENMASK_32(4, 0)
+#define CSR_TXCALBINPOVREN_LSB				5
+#define CSR_TXCALBINPOVREN_MASK				BIT(5)
+/* CSR_TXCALNOVR */
+#define CSR_TXCALNOVR_LSB				0
+#define CSR_TXCALNOVR_MASK				GENMASK_32(5, 0)
+#define CSR_TXCALBINNOVRVAL_LSB				0
+#define CSR_TXCALBINNOVRVAL_MASK			GENMASK_32(4, 0)
+#define CSR_TXCALBINNOVREN_LSB				5
+#define CSR_TXCALBINNOVREN_MASK				BIT(5)
+/* CSR_DFIMODE */
+#define CSR_DFIMODE_LSB					0
+#define CSR_DFIMODE_MASK				GENMASK_32(2, 0)
+#define CSR_DFI0ENABLE_LSB				0
+#define CSR_DFI0ENABLE_MASK				BIT(0)
+#define CSR_DFI1ENABLE_LSB				1
+#define CSR_DFI1ENABLE_MASK				BIT(1)
+#define CSR_DFI1OVERRIDE_LSB				2
+#define CSR_DFI1OVERRIDE_MASK				BIT(2)
+/* CSR_TRISTATEMODECA */
+#define CSR_TRISTATEMODECA_LSB				0
+#define CSR_TRISTATEMODECA_MASK				GENMASK_32(3, 0)
+#define CSR_DISDYNADRTRI_LSB				0
+#define CSR_DISDYNADRTRI_MASK				BIT(0)
+#define CSR_DDR2TMODE_LSB				1
+#define CSR_DDR2TMODE_MASK				BIT(1)
+#define CSR_CKDISVAL_LSB				2
+#define CSR_CKDISVAL_MASK				GENMASK_32(3, 2)
+/* MTESTMUXSEL already defined in ANIBx section */
+/* CSR_MTESTPGMINFO */
+#define CSR_MTESTPGMINFO_LSB				0
+#define CSR_MTESTPGMINFO_MASK				BIT(0)
+/* CSR_DYNPWRDNUP */
+#define CSR_DYNPWRDNUP_LSB				0
+#define CSR_DYNPWRDNUP_MASK				BIT(0)
+#define CSR_DYNPOWERDOWN_LSB				0
+#define CSR_DYNPOWERDOWN_MASK				BIT(0)
+/* CSR_PMIENABLE */
+#define CSR_PMIENABLE_LSB				0
+#define CSR_PMIENABLE_MASK				BIT(0)
+/* CSR_PHYTID */
+#define CSR_PHYTID_LSB					0
+#define CSR_PHYTID_MASK					GENMASK_32(15, 0)
+/* CSR_HWTMRL */
+#define CSR_HWTMRL_LSB					0
+#define CSR_HWTMRL_MASK					GENMASK_32(4, 0)
+/* CSR_DFIPHYUPD */
+#define CSR_DFIPHYUPD_LSB				0
+#define CSR_DFIPHYUPD_MASK				GENMASK_32(15, 0)
+#define CSR_DFIPHYUPDCNT_LSB				0
+#define CSR_DFIPHYUPDCNT_MASK				GENMASK_32(3, 0)
+#define CSR_DFIPHYUPDRESP_LSB				4
+#define CSR_DFIPHYUPDRESP_MASK				GENMASK_32(6, 4)
+#define CSR_DFIPHYUPDMODE_LSB				7
+#define CSR_DFIPHYUPDMODE_MASK				BIT(7)
+#define CSR_DFIPHYUPDTHRESHOLD_LSB			8
+#define CSR_DFIPHYUPDTHRESHOLD_MASK			GENMASK_32(11, 8)
+#define CSR_DFIPHYUPDINTTHRESHOLD_LSB			12
+#define CSR_DFIPHYUPDINTTHRESHOLD_MASK			GENMASK_32(15, 12)
+/* CSR_PDAMRSWRITEMODE */
+#define CSR_PDAMRSWRITEMODE_LSB				0
+#define CSR_PDAMRSWRITEMODE_MASK			BIT(0)
+/* CSR_DFIGEARDOWNCTL */
+#define CSR_DFIGEARDOWNCTL_LSB				0
+#define CSR_DFIGEARDOWNCTL_MASK				GENMASK_32(1, 0)
+/* CSR_DQSPREAMBLECONTROL */
+#define CSR_DQSPREAMBLECONTROL_LSB			0
+#define CSR_DQSPREAMBLECONTROL_MASK			GENMASK_32(8, 0)
+#define CSR_TWOTCKRXDQSPRE_LSB				0
+#define CSR_TWOTCKRXDQSPRE_MASK				BIT(0)
+#define CSR_TWOTCKTXDQSPRE_LSB				1
+#define CSR_TWOTCKTXDQSPRE_MASK				BIT(1)
+#define CSR_POSITIONDFEINIT_LSB				2
+#define CSR_POSITIONDFEINIT_MASK			GENMASK_32(4, 2)
+#define CSR_LP4TGLTWOTCKTXDQSPRE_LSB			5
+#define CSR_LP4TGLTWOTCKTXDQSPRE_MASK			BIT(5)
+#define CSR_LP4POSTAMBLEEXT_LSB				6
+#define CSR_LP4POSTAMBLEEXT_MASK			BIT(6)
+#define CSR_LP4STTCPREBRIDGERXEN_LSB			7
+#define CSR_LP4STTCPREBRIDGERXEN_MASK			BIT(7)
+#define CSR_WDQSEXTENSION_LSB				8
+#define CSR_WDQSEXTENSION_MASK				BIT(8)
+/* CSR_MASTERX4CONFIG */
+#define CSR_MASTERX4CONFIG_LSB				0
+#define CSR_MASTERX4CONFIG_MASK				GENMASK_32(3, 0)
+#define CSR_X4TG_LSB					0
+#define CSR_X4TG_MASK					GENMASK_32(3, 0)
+/* CSR_WRLEVBITS */
+#define CSR_WRLEVBITS_LSB				0
+#define CSR_WRLEVBITS_MASK				GENMASK_32(7, 0)
+#define CSR_WRLEVFORDQSL_LSB				0
+#define CSR_WRLEVFORDQSL_MASK				GENMASK_32(3, 0)
+#define CSR_WRLEVFORDQSU_LSB				4
+#define CSR_WRLEVFORDQSU_MASK				GENMASK_32(7, 4)
+/* CSR_ENABLECSMULTICAST */
+#define CSR_ENABLECSMULTICAST_LSB			0
+#define CSR_ENABLECSMULTICAST_MASK			BIT(0)
+/* CSR_HWTLPCSMULTICAST */
+#define CSR_HWTLPCSMULTICAST_LSB			0
+#define CSR_HWTLPCSMULTICAST_MASK			BIT(0)
+/* CSR_ACX4ANIBDIS */
+#define CSR_ACX4ANIBDIS_LSB				0
+#define CSR_ACX4ANIBDIS_MASK				GENMASK_32(11, 0)
+/* CSR_DMIPINPRESENT */
+#define CSR_DMIPINPRESENT_LSB				0
+#define CSR_DMIPINPRESENT_MASK				BIT(0)
+#define CSR_RDDBIENABLED_LSB				0
+#define CSR_RDDBIENABLED_MASK				BIT(0)
+/* CSR_ARDPTRINITVAL */
+#define CSR_ARDPTRINITVAL_LSB				0
+#define CSR_ARDPTRINITVAL_MASK				GENMASK_32(3, 0)
+/* CSR_DB0LCDLCALPHDETOUT */
+#define CSR_DB0LCDLCALPHDETOUT_LSB			0
+#define CSR_DB0LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DB1LCDLCALPHDETOUT */
+#define CSR_DB1LCDLCALPHDETOUT_LSB			0
+#define CSR_DB1LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DB2LCDLCALPHDETOUT */
+#define CSR_DB2LCDLCALPHDETOUT_LSB			0
+#define CSR_DB2LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DB3LCDLCALPHDETOUT */
+#define CSR_DB3LCDLCALPHDETOUT_LSB			0
+#define CSR_DB3LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DB4LCDLCALPHDETOUT */
+#define CSR_DB4LCDLCALPHDETOUT_LSB			0
+#define CSR_DB4LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DB5LCDLCALPHDETOUT */
+#define CSR_DB5LCDLCALPHDETOUT_LSB			0
+#define CSR_DB5LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DB6LCDLCALPHDETOUT */
+#define CSR_DB6LCDLCALPHDETOUT_LSB			0
+#define CSR_DB6LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DB7LCDLCALPHDETOUT */
+#define CSR_DB7LCDLCALPHDETOUT_LSB			0
+#define CSR_DB7LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DB8LCDLCALPHDETOUT */
+#define CSR_DB8LCDLCALPHDETOUT_LSB			0
+#define CSR_DB8LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DB9LCDLCALPHDETOUT */
+#define CSR_DB9LCDLCALPHDETOUT_LSB			0
+#define CSR_DB9LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DBYTEDLLMODECNTRL */
+#define CSR_DBYTEDLLMODECNTRL_LSB			1
+#define CSR_DBYTEDLLMODECNTRL_MASK			BIT(1)
+#define CSR_DLLRXPREAMBLEMODE_LSB			1
+#define CSR_DLLRXPREAMBLEMODE_MASK			BIT(1)
+/* CSR_DBYTERXENTRAIN */
+#define CSR_DBYTERXENTRAIN_LSB				0
+#define CSR_DBYTERXENTRAIN_MASK				BIT(0)
+#define CSR_RXENTRAIN_LSB				0
+#define CSR_RXENTRAIN_MASK				BIT(0)
+/* CSR_ANLCDLCALPHDETOUT */
+#define CSR_ANLCDLCALPHDETOUT_LSB			0
+#define CSR_ANLCDLCALPHDETOUT_MASK			GENMASK_32(11, 0)
+/* CSR_CALOFFSETS */
+#define CSR_CALOFFSETS_LSB				0
+#define CSR_CALOFFSETS_MASK				GENMASK_32(13, 0)
+#define CSR_CALCMPR5OFFSET_LSB				0
+#define CSR_CALCMPR5OFFSET_MASK				GENMASK_32(5, 0)
+#define CSR_CALDRVPDTHOFFSET_LSB			6
+#define CSR_CALDRVPDTHOFFSET_MASK			GENMASK_32(9, 6)
+#define CSR_CALDRVPUTHOFFSET_LSB			10
+#define CSR_CALDRVPUTHOFFSET_MASK			GENMASK_32(13, 10)
+/* CSR_SARINITVALS */
+#define CSR_SARINITVALS_LSB				0
+#define CSR_SARINITVALS_MASK				GENMASK_32(8, 0)
+#define CSR_SARINITOFFSET05_LSB				0
+#define CSR_SARINITOFFSET05_MASK			GENMASK_32(2, 0)
+#define CSR_SARINITNINT_LSB				3
+#define CSR_SARINITNINT_MASK				GENMASK_32(5, 3)
+#define CSR_SARINITPEXT_LSB				6
+#define CSR_SARINITPEXT_MASK				GENMASK_32(8, 6)
+/* CSR_CALPEXTOVR */
+#define CSR_CALPEXTOVR_LSB				0
+#define CSR_CALPEXTOVR_MASK				GENMASK_32(4, 0)
+/* CSR_CALCMPR5OVR */
+#define CSR_CALCMPR5OVR_LSB				0
+#define CSR_CALCMPR5OVR_MASK				GENMASK_32(7, 0)
+/* CSR_CALNINTOVR */
+#define CSR_CALNINTOVR_LSB				0
+#define CSR_CALNINTOVR_MASK				GENMASK_32(4, 0)
+/* CSR_CALDRVSTR0 */
+#define CSR_CALDRVSTR0_LSB				0
+#define CSR_CALDRVSTR0_MASK				GENMASK_32(7, 0)
+#define CSR_CALDRVSTRPD50_LSB				0
+#define CSR_CALDRVSTRPD50_MASK				GENMASK_32(3, 0)
+#define CSR_CALDRVSTRPU50_LSB				4
+#define CSR_CALDRVSTRPU50_MASK				GENMASK_32(7, 4)
+/* CSR_PROCODTCTL */
+#define CSR_PROCODTCTL_LSB				0
+#define CSR_PROCODTCTL_MASK				GENMASK_32(1, 0)
+#define CSR_PROCODTALWAYSOFF_LSB			0
+#define CSR_PROCODTALWAYSOFF_MASK			BIT(0)
+#define CSR_PROCODTALWAYSON_LSB				1
+#define CSR_PROCODTALWAYSON_MASK			BIT(1)
+/* CSR_PROCODTTIMECTL */
+#define CSR_PROCODTTIMECTL_LSB				0
+#define CSR_PROCODTTIMECTL_MASK				GENMASK_32(5, 0)
+#define CSR_PODTTAILWIDTH_LSB				0
+#define CSR_PODTTAILWIDTH_MASK				GENMASK_32(1, 0)
+#define CSR_PODTSTARTDELAY_LSB				2
+#define CSR_PODTSTARTDELAY_MASK				GENMASK_32(3, 2)
+#define CSR_PODTTAILWIDTHEXT_LSB			4
+#define CSR_PODTTAILWIDTHEXT_MASK			GENMASK_32(5, 4)
+/* CSR_MEMALERTCONTROL */
+#define CSR_MEMALERTCONTROL_LSB				0
+#define CSR_MEMALERTCONTROL_MASK			GENMASK_32(15, 0)
+#define CSR_MALERTVREFLEVEL_LSB				0
+#define CSR_MALERTVREFLEVEL_MASK			GENMASK_32(6, 0)
+#define CSR_MALERTVREFEXTEN_LSB				7
+#define CSR_MALERTVREFEXTEN_MASK			BIT(7)
+#define CSR_MALERTPUSTREN_LSB				8
+#define CSR_MALERTPUSTREN_MASK				GENMASK_32(11, 8)
+#define CSR_MALERTPUEN_LSB				12
+#define CSR_MALERTPUEN_MASK				BIT(12)
+#define CSR_MALERTRXEN_LSB				13
+#define CSR_MALERTRXEN_MASK				BIT(13)
+#define CSR_MALERTDISABLEVAL_LSB			14
+#define CSR_MALERTDISABLEVAL_MASK			BIT(14)
+#define CSR_MALERTFORCEERROR_LSB			15
+#define CSR_MALERTFORCEERROR_MASK			BIT(15)
+/* CSR_MEMALERTCONTROL2 */
+#define CSR_MEMALERTCONTROL2_LSB			0
+#define CSR_MEMALERTCONTROL2_MASK			BIT(0)
+#define CSR_MALERTSYNCBYPASS_LSB			0
+#define CSR_MALERTSYNCBYPASS_MASK			BIT(0)
+/* CSR_MEMRESETL */
+#define CSR_MEMRESETL_LSB				0
+#define CSR_MEMRESETL_MASK				GENMASK_32(1, 0)
+#define CSR_MEMRESETLVALUE_LSB				0
+#define CSR_MEMRESETLVALUE_MASK				BIT(0)
+#define CSR_PROTECTMEMRESET_LSB				1
+#define CSR_PROTECTMEMRESET_MASK			BIT(1)
+/* CSR_PUBMODE */
+#define CSR_PUBMODE_LSB					0
+#define CSR_PUBMODE_MASK				BIT(0)
+#define CSR_HWTMEMSRC_LSB				0
+#define CSR_HWTMEMSRC_MASK				BIT(0)
+/* CSR_MISCPHYSTATUS */
+#define CSR_MISCPHYSTATUS_LSB				0
+#define CSR_MISCPHYSTATUS_MASK				GENMASK_32(1, 0)
+#define CSR_DCTSANE_LSB					0
+#define CSR_DCTSANE_MASK				BIT(0)
+#define CSR_PORMEMRESET_LSB				1
+#define CSR_PORMEMRESET_MASK				BIT(1)
+/* CSR_CORELOOPBACKSEL */
+#define CSR_CORELOOPBACKSEL_LSB				0
+#define CSR_CORELOOPBACKSEL_MASK			BIT(0)
+/* CSR_DLLTRAINPARAM */
+#define CSR_DLLTRAINPARAM_LSB				0
+#define CSR_DLLTRAINPARAM_MASK				GENMASK_32(1, 0)
+#define CSR_EXTENDPHDTIME_LSB				0
+#define CSR_EXTENDPHDTIME_MASK				GENMASK_32(1, 0)
+/* CSR_HWTLPCSENA */
+#define CSR_HWTLPCSENA_LSB				0
+#define CSR_HWTLPCSENA_MASK				GENMASK_32(1, 0)
+/* CSR_HWTLPCSENB */
+#define CSR_HWTLPCSENB_LSB				0
+#define CSR_HWTLPCSENB_MASK				GENMASK_32(1, 0)
+/* CSR_HWTLPCSENBYPASS */
+#define CSR_HWTLPCSENBYPASS_LSB				0
+#define CSR_HWTLPCSENBYPASS_MASK			BIT(0)
+/* CSR_DFICAMODE */
+#define CSR_DFICAMODE_LSB				0
+#define CSR_DFICAMODE_MASK				GENMASK_32(3, 0)
+#define CSR_DFILP3CAMODE_LSB				0
+#define CSR_DFILP3CAMODE_MASK				BIT(0)
+#define CSR_DFID4CAMODE_LSB				1
+#define CSR_DFID4CAMODE_MASK				BIT(1)
+#define CSR_DFILP4CAMODE_LSB				2
+#define CSR_DFILP4CAMODE_MASK				BIT(2)
+#define CSR_DFID4ALTCAMODE_LSB				3
+#define CSR_DFID4ALTCAMODE_MASK				BIT(3)
+/* CSR_HWTCACTL */
+#define CSR_HWTCACTL_LSB				0
+#define CSR_HWTCACTL_MASK				BIT(0)
+#define CSR_HWTDISDYNADRTRI_LSB				0
+#define CSR_HWTDISDYNADRTRI_MASK			BIT(0)
+/* CSR_HWTCAMODE */
+#define CSR_HWTCAMODE_LSB				0
+#define CSR_HWTCAMODE_MASK				GENMASK_32(5, 0)
+#define CSR_HWTLP3CAMODE_LSB				0
+#define CSR_HWTLP3CAMODE_MASK				BIT(0)
+#define CSR_HWTD4CAMODE_LSB				1
+#define CSR_HWTD4CAMODE_MASK				BIT(1)
+#define CSR_HWTLP4CAMODE_LSB				2
+#define CSR_HWTLP4CAMODE_MASK				BIT(2)
+#define CSR_HWTD4ALTCAMODE_LSB				3
+#define CSR_HWTD4ALTCAMODE_MASK				BIT(3)
+#define CSR_HWTCSINVERT_LSB				4
+#define CSR_HWTCSINVERT_MASK				BIT(4)
+#define CSR_HWTDBIINVERT_LSB				5
+#define CSR_HWTDBIINVERT_MASK				BIT(5)
+/* CSR_DLLCONTROL */
+#define CSR_DLLCONTROL_LSB				0
+#define CSR_DLLCONTROL_MASK				GENMASK_32(2, 0)
+#define CSR_DLLRESETRELOCK_LSB				0
+#define CSR_DLLRESETRELOCK_MASK				BIT(0)
+#define CSR_DLLRESETSLAVE_LSB				1
+#define CSR_DLLRESETSLAVE_MASK				BIT(1)
+#define CSR_DLLRESETRSVD_LSB				2
+#define CSR_DLLRESETRSVD_MASK				BIT(2)
+/* CSR_PULSEDLLUPDATEPHASE */
+#define CSR_PULSEDLLUPDATEPHASE_LSB			0
+#define CSR_PULSEDLLUPDATEPHASE_MASK			GENMASK_32(7, 0)
+#define CSR_PULSEDBYTEDLLUPDATEPHASE_LSB		0
+#define CSR_PULSEDBYTEDLLUPDATEPHASE_MASK		BIT(0)
+#define CSR_PULSEACKDLLUPDATEPHASE_LSB			1
+#define CSR_PULSEACKDLLUPDATEPHASE_MASK			BIT(1)
+#define CSR_PULSEACADLLUPDATEPHASE_LSB			2
+#define CSR_PULSEACADLLUPDATEPHASE_MASK			BIT(2)
+#define CSR_UPDATEPHASEDESTRESERVED_LSB			3
+#define CSR_UPDATEPHASEDESTRESERVED_MASK		GENMASK_32(5, 3)
+#define CSR_TRAINUPDATEPHASEONLONGBUBBLE_LSB		6
+#define CSR_TRAINUPDATEPHASEONLONGBUBBLE_MASK		BIT(6)
+#define CSR_ALWAYSUPDATELCDLPHASE_LSB			7
+#define CSR_ALWAYSUPDATELCDLPHASE_MASK			BIT(7)
+/* CSR_HWTCONTROLOVR0 */
+#define CSR_HWTCONTROLOVR0_LSB				0
+#define CSR_HWTCONTROLOVR0_MASK				GENMASK_32(12, 0)
+#define CSR_HWTCS0OVR0_LSB				0
+#define CSR_HWTCS0OVR0_MASK				BIT(0)
+#define CSR_HWTCS1OVR0_LSB				1
+#define CSR_HWTCS1OVR0_MASK				BIT(1)
+#define CSR_HWTCS2OVR0_LSB				2
+#define CSR_HWTCS2OVR0_MASK				BIT(2)
+#define CSR_HWTCS3OVR0_LSB				3
+#define CSR_HWTCS3OVR0_MASK				BIT(3)
+#define CSR_HWTCKE0OVR0_LSB				4
+#define CSR_HWTCKE0OVR0_MASK				BIT(4)
+#define CSR_HWTCKE1OVR0_LSB				5
+#define CSR_HWTCKE1OVR0_MASK				BIT(5)
+#define CSR_HWTCKE2OVR0_LSB				6
+#define CSR_HWTCKE2OVR0_MASK				BIT(6)
+#define CSR_HWTCKE3OVR0_LSB				7
+#define CSR_HWTCKE3OVR0_MASK				BIT(7)
+#define CSR_HWTODT0OVR0_LSB				8
+#define CSR_HWTODT0OVR0_MASK				BIT(8)
+#define CSR_HWTODT1OVR0_LSB				9
+#define CSR_HWTODT1OVR0_MASK				BIT(9)
+#define CSR_HWTODT2OVR0_LSB				10
+#define CSR_HWTODT2OVR0_MASK				BIT(10)
+#define CSR_HWTODT3OVR0_LSB				11
+#define CSR_HWTODT3OVR0_MASK				BIT(11)
+#define CSR_HWTPARITYOVR0_LSB				12
+#define CSR_HWTPARITYOVR0_MASK				BIT(12)
+/* CSR_HWTCONTROLOVR1 */
+#define CSR_HWTCONTROLOVR1_LSB				0
+#define CSR_HWTCONTROLOVR1_MASK				GENMASK_32(12, 0)
+#define CSR_HWTCS0OVR1_LSB				0
+#define CSR_HWTCS0OVR1_MASK				BIT(0)
+#define CSR_HWTCS1OVR1_LSB				1
+#define CSR_HWTCS1OVR1_MASK				BIT(1)
+#define CSR_HWTCS2OVR1_LSB				2
+#define CSR_HWTCS2OVR1_MASK				BIT(2)
+#define CSR_HWTCS3OVR1_LSB				3
+#define CSR_HWTCS3OVR1_MASK				BIT(3)
+#define CSR_HWTCKE0OVR1_LSB				4
+#define CSR_HWTCKE0OVR1_MASK				BIT(4)
+#define CSR_HWTCKE1OVR1_LSB				5
+#define CSR_HWTCKE1OVR1_MASK				BIT(5)
+#define CSR_HWTCKE2OVR1_LSB				6
+#define CSR_HWTCKE2OVR1_MASK				BIT(6)
+#define CSR_HWTCKE3OVR1_LSB				7
+#define CSR_HWTCKE3OVR1_MASK				BIT(7)
+#define CSR_HWTODT0OVR1_LSB				8
+#define CSR_HWTODT0OVR1_MASK				BIT(8)
+#define CSR_HWTODT1OVR1_LSB				9
+#define CSR_HWTODT1OVR1_MASK				BIT(9)
+#define CSR_HWTODT2OVR1_LSB				10
+#define CSR_HWTODT2OVR1_MASK				BIT(10)
+#define CSR_HWTODT3OVR1_LSB				11
+#define CSR_HWTODT3OVR1_MASK				BIT(11)
+#define CSR_HWTPARITYOVR1_LSB				12
+#define CSR_HWTPARITYOVR1_MASK				BIT(12)
+/* CSR_DLLGAINCTL */
+#define CSR_DLLGAINCTL_LSB				0
+#define CSR_DLLGAINCTL_MASK				GENMASK_32(11, 0)
+#define CSR_DLLGAINIV_LSB				0
+#define CSR_DLLGAINIV_MASK				GENMASK_32(3, 0)
+#define CSR_DLLGAINTV_LSB				4
+#define CSR_DLLGAINTV_MASK				GENMASK_32(7, 4)
+#define CSR_DLLSEEDSEL_LSB				8
+#define CSR_DLLSEEDSEL_MASK				GENMASK_32(11, 8)
+/* CSR_DLLLOCKPARAM */
+#define CSR_DLLLOCKPARAM_LSB				0
+#define CSR_DLLLOCKPARAM_MASK				GENMASK_32(12, 0)
+#define CSR_DISDLLSEEDSEL_LSB				0
+#define CSR_DISDLLSEEDSEL_MASK				BIT(0)
+#define CSR_DISDLLGAINIVSEED_LSB			1
+#define CSR_DISDLLGAINIVSEED_MASK			BIT(1)
+#define CSR_DLLLOCKPARAMSPARE_LSB			2
+#define CSR_DLLLOCKPARAMSPARE_MASK			GENMASK_32(3, 2)
+#define CSR_LCDLSEED0_LSB				4
+#define CSR_LCDLSEED0_MASK				GENMASK_32(12, 4)
+/* CSR_HWTCONTROLVAL0 */
+#define CSR_HWTCONTROLVAL0_LSB				0
+#define CSR_HWTCONTROLVAL0_MASK				GENMASK_32(12, 0)
+#define CSR_HWTCS0VAL0_LSB				0
+#define CSR_HWTCS0VAL0_MASK				BIT(0)
+#define CSR_HWTCS1VAL0_LSB				1
+#define CSR_HWTCS1VAL0_MASK				BIT(1)
+#define CSR_HWTCS2VAL0_LSB				2
+#define CSR_HWTCS2VAL0_MASK				BIT(2)
+#define CSR_HWTCS3VAL0_LSB				3
+#define CSR_HWTCS3VAL0_MASK				BIT(3)
+#define CSR_HWTCKE0VAL0_LSB				4
+#define CSR_HWTCKE0VAL0_MASK				BIT(4)
+#define CSR_HWTCKE1VAL0_LSB				5
+#define CSR_HWTCKE1VAL0_MASK				BIT(5)
+#define CSR_HWTCKE2VAL0_LSB				6
+#define CSR_HWTCKE2VAL0_MASK				BIT(6)
+#define CSR_HWTCKE3VAL0_LSB				7
+#define CSR_HWTCKE3VAL0_MASK				BIT(7)
+#define CSR_HWTODT0VAL0_LSB				8
+#define CSR_HWTODT0VAL0_MASK				BIT(8)
+#define CSR_HWTODT1VAL0_LSB				9
+#define CSR_HWTODT1VAL0_MASK				BIT(9)
+#define CSR_HWTODT2VAL0_LSB				10
+#define CSR_HWTODT2VAL0_MASK				BIT(10)
+#define CSR_HWTODT3VAL0_LSB				11
+#define CSR_HWTODT3VAL0_MASK				BIT(11)
+#define CSR_HWTPARITYVAL0_LSB				12
+#define CSR_HWTPARITYVAL0_MASK				BIT(12)
+/* CSR_HWTCONTROLVAL1 */
+#define CSR_HWTCONTROLVAL1_LSB				0
+#define CSR_HWTCONTROLVAL1_MASK				GENMASK_32(12, 0)
+#define CSR_HWTCS0VAL1_LSB				0
+#define CSR_HWTCS0VAL1_MASK				BIT(0)
+#define CSR_HWTCS1VAL1_LSB				1
+#define CSR_HWTCS1VAL1_MASK				BIT(1)
+#define CSR_HWTCS2VAL1_LSB				2
+#define CSR_HWTCS2VAL1_MASK				BIT(2)
+#define CSR_HWTCS3VAL1_LSB				3
+#define CSR_HWTCS3VAL1_MASK				BIT(3)
+#define CSR_HWTCKE0VAL1_LSB				4
+#define CSR_HWTCKE0VAL1_MASK				BIT(4)
+#define CSR_HWTCKE1VAL1_LSB				5
+#define CSR_HWTCKE1VAL1_MASK				BIT(5)
+#define CSR_HWTCKE2VAL1_LSB				6
+#define CSR_HWTCKE2VAL1_MASK				BIT(6)
+#define CSR_HWTCKE3VAL1_LSB				7
+#define CSR_HWTCKE3VAL1_MASK				BIT(7)
+#define CSR_HWTODT0VAL1_LSB				8
+#define CSR_HWTODT0VAL1_MASK				BIT(8)
+#define CSR_HWTODT1VAL1_LSB				9
+#define CSR_HWTODT1VAL1_MASK				BIT(9)
+#define CSR_HWTODT2VAL1_LSB				10
+#define CSR_HWTODT2VAL1_MASK				BIT(10)
+#define CSR_HWTODT3VAL1_LSB				11
+#define CSR_HWTODT3VAL1_MASK				BIT(11)
+#define CSR_HWTPARITYVAL1_LSB				12
+#define CSR_HWTPARITYVAL1_MASK				BIT(12)
+/* CSR_ACSMGLBLSTART */
+#define CSR_ACSMGLBLSTART_LSB				0
+#define CSR_ACSMGLBLSTART_MASK				BIT(0)
+/* CSR_ACSMGLBLSGLSTPCTRL */
+#define CSR_ACSMGLBLSGLSTPCTRL_LSB			0
+#define CSR_ACSMGLBLSGLSTPCTRL_MASK			GENMASK_32(1, 0)
+#define CSR_ACSMSGLSTPMODE_LSB				0
+#define CSR_ACSMSGLSTPMODE_MASK				BIT(0)
+#define CSR_ACSMSGLSTP_LSB				1
+#define CSR_ACSMSGLSTP_MASK				BIT(1)
+/* CSR_LCDLCALPHASE */
+#define CSR_LCDLCALPHASE_LSB				0
+#define CSR_LCDLCALPHASE_MASK				GENMASK_32(8, 0)
+/* CSR_LCDLCALCTRL */
+#define CSR_LCDLCALCTRL_LSB				0
+#define CSR_LCDLCALCTRL_MASK				GENMASK_32(6, 0)
+#define CSR_LCDLCALMODE_LSB				0
+#define CSR_LCDLCALMODE_MASK				BIT(0)
+#define CSR_LCDLCALSLOWCLKSEL_LSB			1
+#define CSR_LCDLCALSLOWCLKSEL_MASK			BIT(1)
+#define CSR_LCDLCALEN_LSB				2
+#define CSR_LCDLCALEN_MASK				BIT(2)
+#define CSR_LCDLCALPHASEUPDATE_LSB			3
+#define CSR_LCDLCALPHASEUPDATE_MASK			BIT(3)
+#define CSR_LCDLCALCLKEN_LSB				4
+#define CSR_LCDLCALCLKEN_MASK				BIT(4)
+#define CSR_LCDLCALSAMPEN_LSB				5
+#define CSR_LCDLCALSAMPEN_MASK				BIT(5)
+#define CSR_LCDLCALSLOWCLKEN_LSB			6
+#define CSR_LCDLCALSLOWCLKEN_MASK			BIT(6)
+/* CSR_CALRATE */
+#define CSR_CALRATE_LSB					0
+#define CSR_CALRATE_MASK				GENMASK_32(6, 0)
+#define CSR_CALINTERVAL_LSB				0
+#define CSR_CALINTERVAL_MASK				GENMASK_32(3, 0)
+#define CSR_CALRUN_LSB					4
+#define CSR_CALRUN_MASK					BIT(4)
+#define CSR_CALONCE_LSB					5
+#define CSR_CALONCE_MASK				BIT(5)
+#define CSR_DISABLEBACKGROUNDZQUPDATES_LSB		6
+#define CSR_DISABLEBACKGROUNDZQUPDATES_MASK		BIT(6)
+/* CSR_CALZAP */
+#define CSR_CALZAP_LSB					0
+#define CSR_CALZAP_MASK					BIT(0)
+/* CSR_PSTATE */
+#define CSR_PSTATE_LSB					0
+#define CSR_PSTATE_MASK					GENMASK_32(3, 0)
+/* CSR_CALPREDRIVEROVERRIDE */
+#define CSR_CALPREDRIVEROVERRIDE_LSB			0
+#define CSR_CALPREDRIVEROVERRIDE_MASK			GENMASK_32(7, 0)
+#define CSR_TXPREOVN_LSB				0
+#define CSR_TXPREOVN_MASK				GENMASK_32(3, 0)
+#define CSR_TXPREOVP_LSB				4
+#define CSR_TXPREOVP_MASK				GENMASK_32(7, 4)
+/* CSR_PLLOUTGATECONTROL */
+#define CSR_PLLOUTGATECONTROL_LSB			0
+#define CSR_PLLOUTGATECONTROL_MASK			GENMASK_32(1, 0)
+#define CSR_PCLKGATEEN_LSB				0
+#define CSR_PCLKGATEEN_MASK				BIT(0)
+#define CSR_RESERVED2X1_LSB				1
+#define CSR_RESERVED2X1_MASK				BIT(1)
+/* CSR_UCMEMRESETCONTROL */
+#define CSR_UCMEMRESETCONTROL_LSB			0
+#define CSR_UCMEMRESETCONTROL_MASK			BIT(0)
+#define CSR_UCDCTSANE_LSB				0
+#define CSR_UCDCTSANE_MASK				BIT(0)
+/* CSR_PORCONTROL */
+#define CSR_PORCONTROL_LSB				0
+#define CSR_PORCONTROL_MASK				BIT(0)
+#define CSR_PLLDLLLOCKDONE_LSB				0
+#define CSR_PLLDLLLOCKDONE_MASK				BIT(0)
+/* CSR_CALBUSY */
+#define CSR_CALBUSY_LSB					0
+#define CSR_CALBUSY_MASK				BIT(0)
+/* CSR_CALMISC2 */
+#define CSR_CALMISC2_LSB				0
+#define CSR_CALMISC2_MASK				GENMASK_32(15, 0)
+#define CSR_CALNUMVOTES_LSB				0
+#define CSR_CALNUMVOTES_MASK				GENMASK_32(2, 0)
+#define CSR_RESERVED10X3_LSB				3
+#define CSR_RESERVED10X3_MASK				GENMASK_32(10, 3)
+#define CSR_RESERVED11_LSB				11
+#define CSR_RESERVED11_MASK				BIT(11)
+#define CSR_CALCMPTRRESTRIM_LSB				12
+#define CSR_CALCMPTRRESTRIM_MASK			BIT(12)
+#define CSR_CALCANCELROUNDERRDIS_LSB			13
+#define CSR_CALCANCELROUNDERRDIS_MASK			BIT(13)
+#define CSR_CALSLOWCMPANA_LSB				14
+#define CSR_CALSLOWCMPANA_MASK				BIT(14)
+#define CSR_RESERVED15_LSB				15
+#define CSR_RESERVED15_MASK				BIT(15)
+/* CSR_CALMISC */
+#define CSR_CALMISC_LSB					0
+#define CSR_CALMISC_MASK				GENMASK_32(2, 0)
+#define CSR_CALCMPR5DIS_LSB				0
+#define CSR_CALCMPR5DIS_MASK				BIT(0)
+#define CSR_CALNINTDIS_LSB				1
+#define CSR_CALNINTDIS_MASK				BIT(1)
+#define CSR_CALPEXTDIS_LSB				2
+#define CSR_CALPEXTDIS_MASK				BIT(2)
+/* CSR_CALVREFS */
+#define CSR_CALVREFS_LSB				0
+#define CSR_CALVREFS_MASK				GENMASK_32(1, 0)
+/* CSR_CALCMPR5 */
+#define CSR_CALCMPR5_LSB				0
+#define CSR_CALCMPR5_MASK				GENMASK_32(7, 0)
+/* CSR_CALNINT */
+#define CSR_CALNINT_LSB					0
+#define CSR_CALNINT_MASK				GENMASK_32(4, 0)
+#define CSR_CALNINTTHB_LSB				0
+#define CSR_CALNINTTHB_MASK				GENMASK_32(4, 0)
+/* CSR_CALPEXT */
+#define CSR_CALPEXT_LSB					0
+#define CSR_CALPEXT_MASK				GENMASK_32(4, 0)
+#define CSR_CALPEXTTHB_LSB				0
+#define CSR_CALPEXTTHB_MASK				GENMASK_32(4, 0)
+/* CSR_CALCMPINVERT */
+#define CSR_CALCMPINVERT_LSB				0
+#define CSR_CALCMPINVERT_MASK				GENMASK_32(4, 0)
+#define CSR_CMPINVERTCALDAC50_LSB			0
+#define CSR_CMPINVERTCALDAC50_MASK			BIT(0)
+#define CSR_CMPINVERTCALDRVPD50_LSB			1
+#define CSR_CMPINVERTCALDRVPD50_MASK			BIT(1)
+#define CSR_CMPINVERTCALDRVPU50_LSB			2
+#define CSR_CMPINVERTCALDRVPU50_MASK			BIT(2)
+#define CSR_CMPINVERTCALODTPD_LSB			3
+#define CSR_CMPINVERTCALODTPD_MASK			BIT(3)
+#define CSR_CMPINVERTCALODTPU_LSB			4
+#define CSR_CMPINVERTCALODTPU_MASK			BIT(4)
+/* CSR_CALCMPANACNTRL */
+#define CSR_CALCMPANACNTRL_LSB				0
+#define CSR_CALCMPANACNTRL_MASK				GENMASK_32(9, 0)
+#define CSR_CMPRGAINCURRADJ_LSB				0
+#define CSR_CMPRGAINCURRADJ_MASK			GENMASK_32(7, 0)
+#define CSR_CMPRGAINRESADJ_LSB				8
+#define CSR_CMPRGAINRESADJ_MASK				BIT(8)
+#define CSR_CMPRBIASBYPASSEN_LSB			9
+#define CSR_CMPRBIASBYPASSEN_MASK			BIT(9)
+/* CSR_DFIRDDATACSDESTMAP */
+#define CSR_DFIRDDATACSDESTMAP_LSB			0
+#define CSR_DFIRDDATACSDESTMAP_MASK			GENMASK_32(7, 0)
+#define CSR_DFIRDDESTM0_LSB				0
+#define CSR_DFIRDDESTM0_MASK				GENMASK_32(1, 0)
+#define CSR_DFIRDDESTM1_LSB				2
+#define CSR_DFIRDDESTM1_MASK				GENMASK_32(3, 2)
+#define CSR_DFIRDDESTM2_LSB				4
+#define CSR_DFIRDDESTM2_MASK				GENMASK_32(5, 4)
+#define CSR_DFIRDDESTM3_LSB				6
+#define CSR_DFIRDDESTM3_MASK				GENMASK_32(7, 6)
+/* CSR_VREFINGLOBAL */
+#define CSR_VREFINGLOBAL_LSB				0
+#define CSR_VREFINGLOBAL_MASK				GENMASK_32(14, 0)
+#define CSR_GLOBALVREFINSEL_LSB				0
+#define CSR_GLOBALVREFINSEL_MASK			GENMASK_32(2, 0)
+#define CSR_GLOBALVREFINDAC_LSB				3
+#define CSR_GLOBALVREFINDAC_MASK			GENMASK_32(9, 3)
+#define CSR_GLOBALVREFINTRIM_LSB			10
+#define CSR_GLOBALVREFINTRIM_MASK			GENMASK_32(13, 10)
+#define CSR_GLOBALVREFINMODE_LSB			14
+#define CSR_GLOBALVREFINMODE_MASK			BIT(14)
+/* CSR_DFIWRDATACSDESTMAP */
+#define CSR_DFIWRDATACSDESTMAP_LSB			0
+#define CSR_DFIWRDATACSDESTMAP_MASK			GENMASK_32(7, 0)
+#define CSR_DFIWRDESTM0_LSB				0
+#define CSR_DFIWRDESTM0_MASK				GENMASK_32(1, 0)
+#define CSR_DFIWRDESTM1_LSB				2
+#define CSR_DFIWRDESTM1_MASK				GENMASK_32(3, 2)
+#define CSR_DFIWRDESTM2_LSB				4
+#define CSR_DFIWRDESTM2_MASK				GENMASK_32(5, 4)
+#define CSR_DFIWRDESTM3_LSB				6
+#define CSR_DFIWRDESTM3_MASK				GENMASK_32(7, 6)
+/* CSR_MASUPDGOODCTR */
+#define CSR_MASUPDGOODCTR_LSB				0
+#define CSR_MASUPDGOODCTR_MASK				GENMASK_32(15, 0)
+/* CSR_PHYUPD0GOODCTR */
+#define CSR_PHYUPD0GOODCTR_LSB				0
+#define CSR_PHYUPD0GOODCTR_MASK				GENMASK_32(15, 0)
+/* CSR_PHYUPD1GOODCTR */
+#define CSR_PHYUPD1GOODCTR_LSB				0
+#define CSR_PHYUPD1GOODCTR_MASK				GENMASK_32(15, 0)
+/* CSR_CTLUPD0GOODCTR */
+#define CSR_CTLUPD0GOODCTR_LSB				0
+#define CSR_CTLUPD0GOODCTR_MASK				GENMASK_32(15, 0)
+/* CSR_CTLUPD1GOODCTR */
+#define CSR_CTLUPD1GOODCTR_LSB				0
+#define CSR_CTLUPD1GOODCTR_MASK				GENMASK_32(15, 0)
+/* CSR_MASUPDFAILCTR */
+#define CSR_MASUPDFAILCTR_LSB				0
+#define CSR_MASUPDFAILCTR_MASK				GENMASK_32(15, 0)
+/* CSR_PHYUPD0FAILCTR */
+#define CSR_PHYUPD0FAILCTR_LSB				0
+#define CSR_PHYUPD0FAILCTR_MASK				GENMASK_32(15, 0)
+/* CSR_PHYUPD1FAILCTR */
+#define CSR_PHYUPD1FAILCTR_LSB				0
+#define CSR_PHYUPD1FAILCTR_MASK				GENMASK_32(15, 0)
+/* CSR_PHYPERFCTRENABLE */
+#define CSR_PHYPERFCTRENABLE_LSB			0
+#define CSR_PHYPERFCTRENABLE_MASK			GENMASK_32(7, 0)
+#define CSR_MASUPDGOODCTL_LSB				0
+#define CSR_MASUPDGOODCTL_MASK				BIT(0)
+#define CSR_PHYUPD0GOODCTL_LSB				1
+#define CSR_PHYUPD0GOODCTL_MASK				BIT(1)
+#define CSR_PHYUPD1GOODCTL_LSB				2
+#define CSR_PHYUPD1GOODCTL_MASK				BIT(2)
+#define CSR_CTLUPD0GOODCTL_LSB				3
+#define CSR_CTLUPD0GOODCTL_MASK				BIT(3)
+#define CSR_CTLUPD1GOODCTL_LSB				4
+#define CSR_CTLUPD1GOODCTL_MASK				BIT(4)
+#define CSR_MASUPDFAILCTL_LSB				5
+#define CSR_MASUPDFAILCTL_MASK				BIT(5)
+#define CSR_PHYUPD0FAILCTL_LSB				6
+#define CSR_PHYUPD0FAILCTL_MASK				BIT(6)
+#define CSR_PHYUPD1FAILCTL_LSB				7
+#define CSR_PHYUPD1FAILCTL_MASK				BIT(7)
+/* CSR_DFIWRRDDATACSCONFIG */
+#define CSR_DFIWRRDDATACSCONFIG_LSB			0
+#define CSR_DFIWRRDDATACSCONFIG_MASK			GENMASK_32(1, 0)
+#define CSR_DFIWRDATACSPOLARITY_LSB			0
+#define CSR_DFIWRDATACSPOLARITY_MASK			BIT(0)
+#define CSR_DFIRDDATACSPOLARITY_LSB			1
+#define CSR_DFIRDDATACSPOLARITY_MASK			BIT(1)
+/* CSR_PLLPWRDN */
+#define CSR_PLLPWRDN_LSB				0
+#define CSR_PLLPWRDN_MASK				BIT(0)
+/* CSR_PLLRESET */
+#define CSR_PLLRESET_LSB				0
+#define CSR_PLLRESET_MASK				BIT(0)
+/* CSR_PLLCTRL2 */
+#define CSR_PLLCTRL2_LSB				0
+#define CSR_PLLCTRL2_MASK				GENMASK_32(4, 0)
+#define CSR_PLLFREQSEL_LSB				0
+#define CSR_PLLFREQSEL_MASK				GENMASK_32(4, 0)
+/* CSR_PLLCTRL0 */
+#define CSR_PLLCTRL0_LSB				0
+#define CSR_PLLCTRL0_MASK				GENMASK_32(15, 0)
+#define CSR_PLLSTANDBY_LSB				0
+#define CSR_PLLSTANDBY_MASK				BIT(0)
+#define CSR_PLLBYPSEL_LSB				1
+#define CSR_PLLBYPSEL_MASK				BIT(1)
+#define CSR_PLLX2MODE_LSB				2
+#define CSR_PLLX2MODE_MASK				BIT(2)
+#define CSR_PLLOUTBYPEN_LSB				3
+#define CSR_PLLOUTBYPEN_MASK				BIT(3)
+#define CSR_PLLPRESET_LSB				4
+#define CSR_PLLPRESET_MASK				BIT(4)
+#define CSR_PLLBYPASSMODE_LSB				5
+#define CSR_PLLBYPASSMODE_MASK				BIT(5)
+#define CSR_PLLSELDFIFREQRATIO_LSB			6
+#define CSR_PLLSELDFIFREQRATIO_MASK			BIT(6)
+#define CSR_PLLSYNCBUSFLUSH_LSB				7
+#define CSR_PLLSYNCBUSFLUSH_MASK			BIT(7)
+#define CSR_PLLSYNCBUSBYP_LSB				8
+#define CSR_PLLSYNCBUSBYP_MASK				BIT(8)
+#define CSR_PLLRESERVED10X9_LSB				9
+#define CSR_PLLRESERVED10X9_MASK			GENMASK_32(10, 9)
+#define CSR_PLLGEARSHIFT_LSB				11
+#define CSR_PLLGEARSHIFT_MASK				BIT(11)
+#define CSR_PLLLOCKCNTSEL_LSB				12
+#define CSR_PLLLOCKCNTSEL_MASK				BIT(12)
+#define CSR_PLLLOCKPHSEL_LSB				13
+#define CSR_PLLLOCKPHSEL_MASK				GENMASK_32(14, 13)
+#define CSR_PLLSPARECTRL0_LSB				15
+#define CSR_PLLSPARECTRL0_MASK				BIT(15)
+/* CSR_PLLCTRL1 */
+#define CSR_PLLCTRL1_LSB				0
+#define CSR_PLLCTRL1_MASK				GENMASK_32(8, 0)
+#define CSR_PLLCPINTCTRL_LSB				0
+#define CSR_PLLCPINTCTRL_MASK				GENMASK_32(4, 0)
+#define CSR_PLLCPPROPCTRL_LSB				5
+#define CSR_PLLCPPROPCTRL_MASK				GENMASK_32(8, 5)
+/* CSR_PLLTST */
+#define CSR_PLLTST_LSB					0
+#define CSR_PLLTST_MASK					GENMASK_32(8, 0)
+#define CSR_PLLANATSTEN_LSB				0
+#define CSR_PLLANATSTEN_MASK				BIT(0)
+#define CSR_PLLANATSTSEL_LSB				1
+#define CSR_PLLANATSTSEL_MASK				GENMASK_32(4, 1)
+#define CSR_PLLDIGTSTSEL_LSB				5
+#define CSR_PLLDIGTSTSEL_MASK				GENMASK_32(8, 5)
+/* CSR_PLLLOCKSTATUS */
+#define CSR_PLLLOCKSTATUS_LSB				0
+#define CSR_PLLLOCKSTATUS_MASK				BIT(0)
+/* CSR_PLLTESTMODE */
+#define CSR_PLLTESTMODE_LSB				0
+#define CSR_PLLTESTMODE_MASK				GENMASK_32(15, 0)
+/* CSR_PLLCTRL3 */
+#define CSR_PLLCTRL3_LSB				0
+#define CSR_PLLCTRL3_MASK				GENMASK_32(15, 0)
+#define CSR_PLLSPARE_LSB				0
+#define CSR_PLLSPARE_MASK				GENMASK_32(3, 0)
+#define CSR_PLLMAXRANGE_LSB				4
+#define CSR_PLLMAXRANGE_MASK				GENMASK_32(8, 4)
+#define CSR_PLLDACVALIN_LSB				9
+#define CSR_PLLDACVALIN_MASK				GENMASK_32(13, 9)
+#define CSR_PLLFORCECAL_LSB				14
+#define CSR_PLLFORCECAL_MASK				BIT(14)
+#define CSR_PLLENCAL_LSB				15
+#define CSR_PLLENCAL_MASK				BIT(15)
+/* CSR_PLLCTRL4 */
+#define CSR_PLLCTRL4_LSB				0
+#define CSR_PLLCTRL4_MASK				GENMASK_32(8, 0)
+#define CSR_PLLCPINTGSCTRL_LSB				0
+#define CSR_PLLCPINTGSCTRL_MASK				GENMASK_32(4, 0)
+#define CSR_PLLCPPROPGSCTRL_LSB				5
+#define CSR_PLLCPPROPGSCTRL_MASK			GENMASK_32(8, 5)
+/* CSR_PLLENDOFCAL */
+#define CSR_PLLENDOFCAL_LSB				0
+#define CSR_PLLENDOFCAL_MASK				BIT(0)
+/* CSR_PLLSTANDBYEFF */
+#define CSR_PLLSTANDBYEFF_LSB				0
+#define CSR_PLLSTANDBYEFF_MASK				BIT(0)
+/* CSR_PLLDACVALOUT */
+#define CSR_PLLDACVALOUT_LSB				0
+#define CSR_PLLDACVALOUT_MASK				GENMASK_32(4, 0)
+/* CSR_DLYTESTSEQ */
+#define CSR_DLYTESTSEQ_LSB				0
+#define CSR_DLYTESTSEQ_MASK				GENMASK_32(5, 0)
+#define CSR_DLYTESTEN_LSB				0
+#define CSR_DLYTESTEN_MASK				BIT(0)
+#define CSR_DLYTESTCNTINIT_LSB				1
+#define CSR_DLYTESTCNTINIT_MASK				BIT(1)
+#define CSR_DLYTESTENOVERRIDE1_LSB			2
+#define CSR_DLYTESTENOVERRIDE1_MASK			BIT(2)
+#define CSR_DLYTESTENOVERRIDE2_LSB			3
+#define CSR_DLYTESTENOVERRIDE2_MASK			BIT(3)
+#define CSR_SYNCDLYMULTIPLIER_LSB			4
+#define CSR_SYNCDLYMULTIPLIER_MASK			GENMASK_32(5, 4)
+/* CSR_DLYTESTRINGSELDB */
+#define CSR_DLYTESTRINGSELDB_LSB			0
+#define CSR_DLYTESTRINGSELDB_MASK			GENMASK_32(4, 0)
+#define CSR_DLYTESTCUTDB_LSB				0
+#define CSR_DLYTESTCUTDB_MASK				GENMASK_32(4, 0)
+/* CSR_DLYTESTRINGSELAC */
+#define CSR_DLYTESTRINGSELAC_LSB			0
+#define CSR_DLYTESTRINGSELAC_MASK			GENMASK_32(4, 0)
+#define CSR_DLYTESTCUTAC_LSB				0
+#define CSR_DLYTESTCUTAC_MASK				GENMASK_32(4, 0)
+/* CSR_DLYTESTCNTDFICLKIV */
+#define CSR_DLYTESTCNTDFICLKIV_LSB			0
+#define CSR_DLYTESTCNTDFICLKIV_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTDFICLK */
+#define CSR_DLYTESTCNTDFICLK_LSB			0
+#define CSR_DLYTESTCNTDFICLK_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB0 */
+#define CSR_DLYTESTCNTRINGOSCDB0_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB0_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB1 */
+#define CSR_DLYTESTCNTRINGOSCDB1_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB1_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB2 */
+#define CSR_DLYTESTCNTRINGOSCDB2_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB2_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB3 */
+#define CSR_DLYTESTCNTRINGOSCDB3_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB3_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB4 */
+#define CSR_DLYTESTCNTRINGOSCDB4_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB4_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB5 */
+#define CSR_DLYTESTCNTRINGOSCDB5_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB5_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB6 */
+#define CSR_DLYTESTCNTRINGOSCDB6_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB6_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB7 */
+#define CSR_DLYTESTCNTRINGOSCDB7_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB7_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB8 */
+#define CSR_DLYTESTCNTRINGOSCDB8_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB8_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB9 */
+#define CSR_DLYTESTCNTRINGOSCDB9_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB9_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCAC */
+#define CSR_DLYTESTCNTRINGOSCAC_LSB			0
+#define CSR_DLYTESTCNTRINGOSCAC_MASK			GENMASK_32(15, 0)
+/* CSR_MSTLCDLDBGCNTL */
+#define CSR_MSTLCDLDBGCNTL_LSB				0
+#define CSR_MSTLCDLDBGCNTL_MASK				GENMASK_32(11, 0)
+#define CSR_MSTLCDLFINEOVRVAL_LSB			0
+#define CSR_MSTLCDLFINEOVRVAL_MASK			GENMASK_32(8, 0)
+#define CSR_MSTLCDLFINEOVR_LSB				9
+#define CSR_MSTLCDLFINEOVR_MASK				BIT(9)
+#define CSR_MSTLCDLFINESNAP_LSB				10
+#define CSR_MSTLCDLFINESNAP_MASK			BIT(10)
+#define CSR_MSTLCDLTSTENABLE_LSB			11
+#define CSR_MSTLCDLTSTENABLE_MASK			BIT(11)
+/* CSR_MSTLCDL0DBGRES */
+#define CSR_MSTLCDL0DBGRES_LSB				0
+#define CSR_MSTLCDL0DBGRES_MASK				GENMASK_32(12, 0)
+#define CSR_MSTLCDL0FINESNAPVAL_LSB			0
+#define CSR_MSTLCDL0FINESNAPVAL_MASK			GENMASK_32(8, 0)
+#define CSR_MSTLCDL0PHDSNAPVAL_LSB			9
+#define CSR_MSTLCDL0PHDSNAPVAL_MASK			BIT(9)
+#define CSR_MSTLCDL0STICKYLOCK_LSB			10
+#define CSR_MSTLCDL0STICKYLOCK_MASK			BIT(10)
+#define CSR_MSTLCDL0STICKYUNLOCK_LSB			11
+#define CSR_MSTLCDL0STICKYUNLOCK_MASK			BIT(11)
+#define CSR_MSTLCDL0LIVELOCK_LSB			12
+#define CSR_MSTLCDL0LIVELOCK_MASK			BIT(12)
+/* CSR_MSTLCDL1DBGRES */
+#define CSR_MSTLCDL1DBGRES_LSB				0
+#define CSR_MSTLCDL1DBGRES_MASK				GENMASK_32(12, 0)
+#define CSR_MSTLCDL1FINESNAPVAL_LSB			0
+#define CSR_MSTLCDL1FINESNAPVAL_MASK			GENMASK_32(8, 0)
+#define CSR_MSTLCDL1PHDSNAPVAL_LSB			9
+#define CSR_MSTLCDL1PHDSNAPVAL_MASK			BIT(9)
+#define CSR_MSTLCDL1STICKYLOCK_LSB			10
+#define CSR_MSTLCDL1STICKYLOCK_MASK			BIT(10)
+#define CSR_MSTLCDL1STICKYUNLOCK_LSB			11
+#define CSR_MSTLCDL1STICKYUNLOCK_MASK			BIT(11)
+#define CSR_MSTLCDL1LIVELOCK_LSB			12
+#define CSR_MSTLCDL1LIVELOCK_MASK			BIT(12)
+/* CSR_LCDLDBGCNTL */
+#define CSR_LCDLDBGCNTL_LSB				0
+#define CSR_LCDLDBGCNTL_MASK				GENMASK_32(15, 0)
+#define CSR_LCDLFINEOVRVAL_LSB				0
+#define CSR_LCDLFINEOVRVAL_MASK				GENMASK_32(8, 0)
+#define CSR_LCDLFINEOVR_LSB				9
+#define CSR_LCDLFINEOVR_MASK				BIT(9)
+#define CSR_LCDLFINESNAP_LSB				10
+#define CSR_LCDLFINESNAP_MASK				BIT(10)
+#define CSR_LCDLTSTENABLE_LSB				11
+#define CSR_LCDLTSTENABLE_MASK				BIT(11)
+#define CSR_LCDLSTATUSSEL_LSB				12
+#define CSR_LCDLSTATUSSEL_MASK				GENMASK_32(15, 12)
+/* CSR_ACLCDLSTATUS */
+#define CSR_ACLCDLSTATUS_LSB				0
+#define CSR_ACLCDLSTATUS_MASK				GENMASK_32(13, 0)
+#define CSR_ACLCDLFINESNAPVAL_LSB			0
+#define CSR_ACLCDLFINESNAPVAL_MASK			GENMASK_32(9, 0)
+#define CSR_ACLCDLPHDSNAPVAL_LSB			10
+#define CSR_ACLCDLPHDSNAPVAL_MASK			BIT(10)
+#define CSR_ACLCDLSTICKYLOCK_LSB			11
+#define CSR_ACLCDLSTICKYLOCK_MASK			BIT(11)
+#define CSR_ACLCDLSTICKYUNLOCK_LSB			12
+#define CSR_ACLCDLSTICKYUNLOCK_MASK			BIT(12)
+#define CSR_ACLCDLLIVELOCK_LSB				13
+#define CSR_ACLCDLLIVELOCK_MASK				BIT(13)
+/* CSR_CUSTPHYREV */
+#define CSR_CUSTPHYREV_LSB				0
+#define CSR_CUSTPHYREV_MASK				GENMASK_32(5, 0)
+/* CSR_PHYREV */
+#define CSR_PHYREV_LSB					0
+#define CSR_PHYREV_MASK					GENMASK_32(15, 0)
+#define CSR_PHYMNR_LSB					0
+#define CSR_PHYMNR_MASK					GENMASK_32(3, 0)
+#define CSR_PHYMDR_LSB					4
+#define CSR_PHYMDR_MASK					GENMASK_32(7, 4)
+#define CSR_PHYMJR_LSB					8
+#define CSR_PHYMJR_MASK					GENMASK_32(15, 8)
+/* CSR_LP3EXITSEQ0BSTARTVECTOR */
+#define CSR_LP3EXITSEQ0BSTARTVECTOR_LSB			0
+#define CSR_LP3EXITSEQ0BSTARTVECTOR_MASK		GENMASK_32(7, 0)
+#define CSR_LP3EXITSEQ0BSTARTVECPLLENABLED_LSB		0
+#define CSR_LP3EXITSEQ0BSTARTVECPLLENABLED_MASK		GENMASK_32(3, 0)
+#define CSR_LP3EXITSEQ0BSTARTVECPLLBYPASSED_LSB		4
+#define CSR_LP3EXITSEQ0BSTARTVECPLLBYPASSED_MASK	GENMASK_32(7, 4)
+/* CSR_DFIFREQXLAT0 */
+#define CSR_DFIFREQXLAT0_LSB				0
+#define CSR_DFIFREQXLAT0_MASK				GENMASK_32(15, 0)
+#define CSR_DFIFREQXLATVAL0_LSB				0
+#define CSR_DFIFREQXLATVAL0_MASK			GENMASK_32(3, 0)
+#define CSR_DFIFREQXLATVAL1_LSB				4
+#define CSR_DFIFREQXLATVAL1_MASK			GENMASK_32(7, 4)
+#define CSR_DFIFREQXLATVAL2_LSB				8
+#define CSR_DFIFREQXLATVAL2_MASK			GENMASK_32(11, 8)
+#define CSR_DFIFREQXLATVAL3_LSB				12
+#define CSR_DFIFREQXLATVAL3_MASK			GENMASK_32(15, 12)
+/* CSR_DFIFREQXLAT1 */
+#define CSR_DFIFREQXLAT1_LSB				0
+#define CSR_DFIFREQXLAT1_MASK				GENMASK_32(15, 0)
+#define CSR_DFIFREQXLATVAL4_LSB				0
+#define CSR_DFIFREQXLATVAL4_MASK			GENMASK_32(3, 0)
+#define CSR_DFIFREQXLATVAL5_LSB				4
+#define CSR_DFIFREQXLATVAL5_MASK			GENMASK_32(7, 4)
+#define CSR_DFIFREQXLATVAL6_LSB				8
+#define CSR_DFIFREQXLATVAL6_MASK			GENMASK_32(11, 8)
+#define CSR_DFIFREQXLATVAL7_LSB				12
+#define CSR_DFIFREQXLATVAL7_MASK			GENMASK_32(15, 12)
+/* CSR_DFIFREQXLAT2 */
+#define CSR_DFIFREQXLAT2_LSB				0
+#define CSR_DFIFREQXLAT2_MASK				GENMASK_32(15, 0)
+#define CSR_DFIFREQXLATVAL8_LSB				0
+#define CSR_DFIFREQXLATVAL8_MASK			GENMASK_32(3, 0)
+#define CSR_DFIFREQXLATVAL9_LSB				4
+#define CSR_DFIFREQXLATVAL9_MASK			GENMASK_32(7, 4)
+#define CSR_DFIFREQXLATVAL10_LSB			8
+#define CSR_DFIFREQXLATVAL10_MASK			GENMASK_32(11, 8)
+#define CSR_DFIFREQXLATVAL11_LSB			12
+#define CSR_DFIFREQXLATVAL11_MASK			GENMASK_32(15, 12)
+/* CSR_DFIFREQXLAT3 */
+#define CSR_DFIFREQXLAT3_LSB				0
+#define CSR_DFIFREQXLAT3_MASK				GENMASK_32(15, 0)
+#define CSR_DFIFREQXLATVAL12_LSB			0
+#define CSR_DFIFREQXLATVAL12_MASK			GENMASK_32(3, 0)
+#define CSR_DFIFREQXLATVAL13_LSB			4
+#define CSR_DFIFREQXLATVAL13_MASK			GENMASK_32(7, 4)
+#define CSR_DFIFREQXLATVAL14_LSB			8
+#define CSR_DFIFREQXLATVAL14_MASK			GENMASK_32(11, 8)
+#define CSR_DFIFREQXLATVAL15_LSB			12
+#define CSR_DFIFREQXLATVAL15_MASK			GENMASK_32(15, 12)
+/* CSR_DFIFREQXLAT4 */
+#define CSR_DFIFREQXLAT4_LSB				0
+#define CSR_DFIFREQXLAT4_MASK				GENMASK_32(15, 0)
+#define CSR_DFIFREQXLATVAL16_LSB			0
+#define CSR_DFIFREQXLATVAL16_MASK			GENMASK_32(3, 0)
+#define CSR_DFIFREQXLATVAL17_LSB			4
+#define CSR_DFIFREQXLATVAL17_MASK			GENMASK_32(7, 4)
+#define CSR_DFIFREQXLATVAL18_LSB			8
+#define CSR_DFIFREQXLATVAL18_MASK			GENMASK_32(11, 8)
+#define CSR_DFIFREQXLATVAL19_LSB			12
+#define CSR_DFIFREQXLATVAL19_MASK			GENMASK_32(15, 12)
+/* CSR_DFIFREQXLAT5 */
+#define CSR_DFIFREQXLAT5_LSB				0
+#define CSR_DFIFREQXLAT5_MASK				GENMASK_32(15, 0)
+#define CSR_DFIFREQXLATVAL20_LSB			0
+#define CSR_DFIFREQXLATVAL20_MASK			GENMASK_32(3, 0)
+#define CSR_DFIFREQXLATVAL21_LSB			4
+#define CSR_DFIFREQXLATVAL21_MASK			GENMASK_32(7, 4)
+#define CSR_DFIFREQXLATVAL22_LSB			8
+#define CSR_DFIFREQXLATVAL22_MASK			GENMASK_32(11, 8)
+#define CSR_DFIFREQXLATVAL23_LSB			12
+#define CSR_DFIFREQXLATVAL23_MASK			GENMASK_32(15, 12)
+/* CSR_DFIFREQXLAT6 */
+#define CSR_DFIFREQXLAT6_LSB				0
+#define CSR_DFIFREQXLAT6_MASK				GENMASK_32(15, 0)
+#define CSR_DFIFREQXLATVAL24_LSB			0
+#define CSR_DFIFREQXLATVAL24_MASK			GENMASK_32(3, 0)
+#define CSR_DFIFREQXLATVAL25_LSB			4
+#define CSR_DFIFREQXLATVAL25_MASK			GENMASK_32(7, 4)
+#define CSR_DFIFREQXLATVAL26_LSB			8
+#define CSR_DFIFREQXLATVAL26_MASK			GENMASK_32(11, 8)
+#define CSR_DFIFREQXLATVAL27_LSB			12
+#define CSR_DFIFREQXLATVAL27_MASK			GENMASK_32(15, 12)
+/* CSR_DFIFREQXLAT7 */
+#define CSR_DFIFREQXLAT7_LSB				0
+#define CSR_DFIFREQXLAT7_MASK				GENMASK_32(15, 0)
+#define CSR_DFIFREQXLATVAL28_LSB			0
+#define CSR_DFIFREQXLATVAL28_MASK			GENMASK_32(3, 0)
+#define CSR_DFIFREQXLATVAL29_LSB			4
+#define CSR_DFIFREQXLATVAL29_MASK			GENMASK_32(7, 4)
+#define CSR_DFIFREQXLATVAL30_LSB			8
+#define CSR_DFIFREQXLATVAL30_MASK			GENMASK_32(11, 8)
+#define CSR_DFIFREQXLATVAL31_LSB			12
+#define CSR_DFIFREQXLATVAL31_MASK			GENMASK_32(15, 12)
+/* CSR_TXRDPTRINIT */
+#define CSR_TXRDPTRINIT_LSB				0
+#define CSR_TXRDPTRINIT_MASK				BIT(0)
+/* CSR_DFIINITCOMPLETE */
+#define CSR_DFIINITCOMPLETE_LSB				0
+#define CSR_DFIINITCOMPLETE_MASK			BIT(0)
+/* CSR_DFIFREQRATIO */
+#define CSR_DFIFREQRATIO_LSB				0
+#define CSR_DFIFREQRATIO_MASK				GENMASK_32(1, 0)
+/* CSR_RXFIFOCHECKS */
+#define CSR_RXFIFOCHECKS_LSB				0
+#define CSR_RXFIFOCHECKS_MASK				BIT(0)
+#define CSR_DOFREQUENTRXFIFOCHECKS_LSB			0
+#define CSR_DOFREQUENTRXFIFOCHECKS_MASK			BIT(0)
+/* CSR_MTESTDTOCTRL */
+#define CSR_MTESTDTOCTRL_LSB				0
+#define CSR_MTESTDTOCTRL_MASK				BIT(0)
+#define CSR_MTESTDTOEN_LSB				0
+#define CSR_MTESTDTOEN_MASK				BIT(0)
+/* CSR_MAPCAA0TODFI */
+#define CSR_MAPCAA0TODFI_LSB				0
+#define CSR_MAPCAA0TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAA1TODFI */
+#define CSR_MAPCAA1TODFI_LSB				0
+#define CSR_MAPCAA1TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAA2TODFI */
+#define CSR_MAPCAA2TODFI_LSB				0
+#define CSR_MAPCAA2TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAA3TODFI */
+#define CSR_MAPCAA3TODFI_LSB				0
+#define CSR_MAPCAA3TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAA4TODFI */
+#define CSR_MAPCAA4TODFI_LSB				0
+#define CSR_MAPCAA4TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAA5TODFI */
+#define CSR_MAPCAA5TODFI_LSB				0
+#define CSR_MAPCAA5TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAA6TODFI */
+#define CSR_MAPCAA6TODFI_LSB				0
+#define CSR_MAPCAA6TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAA7TODFI */
+#define CSR_MAPCAA7TODFI_LSB				0
+#define CSR_MAPCAA7TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAA8TODFI */
+#define CSR_MAPCAA8TODFI_LSB				0
+#define CSR_MAPCAA8TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAA9TODFI */
+#define CSR_MAPCAA9TODFI_LSB				0
+#define CSR_MAPCAA9TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB0TODFI */
+#define CSR_MAPCAB0TODFI_LSB				0
+#define CSR_MAPCAB0TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB1TODFI */
+#define CSR_MAPCAB1TODFI_LSB				0
+#define CSR_MAPCAB1TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB2TODFI */
+#define CSR_MAPCAB2TODFI_LSB				0
+#define CSR_MAPCAB2TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB3TODFI */
+#define CSR_MAPCAB3TODFI_LSB				0
+#define CSR_MAPCAB3TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB4TODFI */
+#define CSR_MAPCAB4TODFI_LSB				0
+#define CSR_MAPCAB4TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB5TODFI */
+#define CSR_MAPCAB5TODFI_LSB				0
+#define CSR_MAPCAB5TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB6TODFI */
+#define CSR_MAPCAB6TODFI_LSB				0
+#define CSR_MAPCAB6TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB7TODFI */
+#define CSR_MAPCAB7TODFI_LSB				0
+#define CSR_MAPCAB7TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB8TODFI */
+#define CSR_MAPCAB8TODFI_LSB				0
+#define CSR_MAPCAB8TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB9TODFI */
+#define CSR_MAPCAB9TODFI_LSB				0
+#define CSR_MAPCAB9TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_PHYINTERRUPTENABLE */
+#define CSR_PHYINTERRUPTENABLE_LSB			0
+#define CSR_PHYINTERRUPTENABLE_MASK			GENMASK_32(15, 0)
+#define CSR_PHYTRNGCMPLTEN_LSB				0
+#define CSR_PHYTRNGCMPLTEN_MASK				BIT(0)
+#define CSR_PHYINITCMPLTEN_LSB				1
+#define CSR_PHYINITCMPLTEN_MASK				BIT(1)
+#define CSR_PHYTRNGFAILEN_LSB				2
+#define CSR_PHYTRNGFAILEN_MASK				BIT(2)
+#define CSR_PHYFWRESERVEDEN_LSB				3
+#define CSR_PHYFWRESERVEDEN_MASK			GENMASK_32(7, 3)
+#define CSR_PHYVTDRIFTALARMEN_LSB			8
+#define CSR_PHYVTDRIFTALARMEN_MASK			GENMASK_32(9, 8)
+#define CSR_PHYRXFIFOCHECKEN_LSB			10
+#define CSR_PHYRXFIFOCHECKEN_MASK			BIT(10)
+#define CSR_PHYHWRESERVEDEN_LSB				11
+#define CSR_PHYHWRESERVEDEN_MASK			GENMASK_32(15, 11)
+/* CSR_PHYINTERRUPTFWCONTROL */
+#define CSR_PHYINTERRUPTFWCONTROL_LSB			0
+#define CSR_PHYINTERRUPTFWCONTROL_MASK			GENMASK_32(7, 0)
+#define CSR_PHYTRNGCMPLTFW_LSB				0
+#define CSR_PHYTRNGCMPLTFW_MASK				BIT(0)
+#define CSR_PHYINITCMPLTFW_LSB				1
+#define CSR_PHYINITCMPLTFW_MASK				BIT(1)
+#define CSR_PHYTRNGFAILFW_LSB				2
+#define CSR_PHYTRNGFAILFW_MASK				BIT(2)
+#define CSR_PHYFWRESERVEDFW_LSB				3
+#define CSR_PHYFWRESERVEDFW_MASK			GENMASK_32(7, 3)
+/* CSR_PHYINTERRUPTMASK */
+#define CSR_PHYINTERRUPTMASK_LSB			0
+#define CSR_PHYINTERRUPTMASK_MASK			GENMASK_32(15, 0)
+#define CSR_PHYTRNGCMPLTMSK_LSB				0
+#define CSR_PHYTRNGCMPLTMSK_MASK			BIT(0)
+#define CSR_PHYINITCMPLTMSK_LSB				1
+#define CSR_PHYINITCMPLTMSK_MASK			BIT(1)
+#define CSR_PHYTRNGFAILMSK_LSB				2
+#define CSR_PHYTRNGFAILMSK_MASK				BIT(2)
+#define CSR_PHYFWRESERVEDMSK_LSB			3
+#define CSR_PHYFWRESERVEDMSK_MASK			GENMASK_32(7, 3)
+#define CSR_PHYVTDRIFTALARMMSK_LSB			8
+#define CSR_PHYVTDRIFTALARMMSK_MASK			GENMASK_32(9, 8)
+#define CSR_PHYRXFIFOCHECKMSK_LSB			10
+#define CSR_PHYRXFIFOCHECKMSK_MASK			BIT(10)
+#define CSR_PHYHWRESERVEDMSK_LSB			11
+#define CSR_PHYHWRESERVEDMSK_MASK			GENMASK_32(15, 11)
+/* CSR_PHYINTERRUPTCLEAR */
+#define CSR_PHYINTERRUPTCLEAR_LSB			0
+#define CSR_PHYINTERRUPTCLEAR_MASK			GENMASK_32(15, 0)
+#define CSR_PHYTRNGCMPLTCLR_LSB				0
+#define CSR_PHYTRNGCMPLTCLR_MASK			BIT(0)
+#define CSR_PHYINITCMPLTCLR_LSB				1
+#define CSR_PHYINITCMPLTCLR_MASK			BIT(1)
+#define CSR_PHYTRNGFAILCLR_LSB				2
+#define CSR_PHYTRNGFAILCLR_MASK				BIT(2)
+#define CSR_PHYFWRESERVEDCLR_LSB			3
+#define CSR_PHYFWRESERVEDCLR_MASK			GENMASK_32(7, 3)
+#define CSR_PHYVTDRIFTALARMCLR_LSB			8
+#define CSR_PHYVTDRIFTALARMCLR_MASK			GENMASK_32(9, 8)
+#define CSR_PHYRXFIFOCHECKCLR_LSB			10
+#define CSR_PHYRXFIFOCHECKCLR_MASK			BIT(10)
+#define CSR_PHYHWRESERVEDCLR_LSB			11
+#define CSR_PHYHWRESERVEDCLR_MASK			GENMASK_32(15, 11)
+/* CSR_PHYINTERRUPTSTATUS */
+#define CSR_PHYINTERRUPTSTATUS_LSB			0
+#define CSR_PHYINTERRUPTSTATUS_MASK			GENMASK_32(15, 0)
+#define CSR_PHYTRNGCMPLT_LSB				0
+#define CSR_PHYTRNGCMPLT_MASK				BIT(0)
+#define CSR_PHYINITCMPLT_LSB				1
+#define CSR_PHYINITCMPLT_MASK				BIT(1)
+#define CSR_PHYTRNGFAIL_LSB				2
+#define CSR_PHYTRNGFAIL_MASK				BIT(2)
+#define CSR_PHYFWRESERVED_LSB				3
+#define CSR_PHYFWRESERVED_MASK				GENMASK_32(7, 3)
+#define CSR_VTDRIFTALARM_LSB				8
+#define CSR_VTDRIFTALARM_MASK				GENMASK_32(9, 8)
+#define CSR_PHYRXFIFOCHECK_LSB				10
+#define CSR_PHYRXFIFOCHECK_MASK				BIT(10)
+#define CSR_PHYHWRESERVED_LSB				11
+#define CSR_PHYHWRESERVED_MASK				GENMASK_32(15, 11)
+/* CSR_HWTSWIZZLEHWTADDRESS0 */
+#define CSR_HWTSWIZZLEHWTADDRESS0_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS0_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS1 */
+#define CSR_HWTSWIZZLEHWTADDRESS1_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS1_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS2 */
+#define CSR_HWTSWIZZLEHWTADDRESS2_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS2_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS3 */
+#define CSR_HWTSWIZZLEHWTADDRESS3_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS3_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS4 */
+#define CSR_HWTSWIZZLEHWTADDRESS4_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS4_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS5 */
+#define CSR_HWTSWIZZLEHWTADDRESS5_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS5_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS6 */
+#define CSR_HWTSWIZZLEHWTADDRESS6_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS6_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS7 */
+#define CSR_HWTSWIZZLEHWTADDRESS7_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS7_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS8 */
+#define CSR_HWTSWIZZLEHWTADDRESS8_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS8_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS9 */
+#define CSR_HWTSWIZZLEHWTADDRESS9_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS9_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS10 */
+#define CSR_HWTSWIZZLEHWTADDRESS10_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS10_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS11 */
+#define CSR_HWTSWIZZLEHWTADDRESS11_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS11_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS12 */
+#define CSR_HWTSWIZZLEHWTADDRESS12_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS12_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS13 */
+#define CSR_HWTSWIZZLEHWTADDRESS13_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS13_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS14 */
+#define CSR_HWTSWIZZLEHWTADDRESS14_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS14_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS15 */
+#define CSR_HWTSWIZZLEHWTADDRESS15_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS15_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS17 */
+#define CSR_HWTSWIZZLEHWTADDRESS17_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS17_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTACTN */
+#define CSR_HWTSWIZZLEHWTACTN_LSB			0
+#define CSR_HWTSWIZZLEHWTACTN_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTBANK0 */
+#define CSR_HWTSWIZZLEHWTBANK0_LSB			0
+#define CSR_HWTSWIZZLEHWTBANK0_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTBANK1 */
+#define CSR_HWTSWIZZLEHWTBANK1_LSB			0
+#define CSR_HWTSWIZZLEHWTBANK1_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTBANK2 */
+#define CSR_HWTSWIZZLEHWTBANK2_LSB			0
+#define CSR_HWTSWIZZLEHWTBANK2_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTBG0 */
+#define CSR_HWTSWIZZLEHWTBG0_LSB			0
+#define CSR_HWTSWIZZLEHWTBG0_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTBG1 */
+#define CSR_HWTSWIZZLEHWTBG1_LSB			0
+#define CSR_HWTSWIZZLEHWTBG1_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTCASN */
+#define CSR_HWTSWIZZLEHWTCASN_LSB			0
+#define CSR_HWTSWIZZLEHWTCASN_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTRASN */
+#define CSR_HWTSWIZZLEHWTRASN_LSB			0
+#define CSR_HWTSWIZZLEHWTRASN_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTWEN */
+#define CSR_HWTSWIZZLEHWTWEN_LSB			0
+#define CSR_HWTSWIZZLEHWTWEN_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTPARITYIN */
+#define CSR_HWTSWIZZLEHWTPARITYIN_LSB			0
+#define CSR_HWTSWIZZLEHWTPARITYIN_MASK			GENMASK_32(4, 0)
+/* CSR_DFIHANDSHAKEDELAYS0 */
+#define CSR_DFIHANDSHAKEDELAYS0_LSB			0
+#define CSR_DFIHANDSHAKEDELAYS0_MASK			GENMASK_32(15, 0)
+#define CSR_PHYUPDACKDELAY0_LSB				0
+#define CSR_PHYUPDACKDELAY0_MASK			GENMASK_32(3, 0)
+#define CSR_PHYUPDREQDELAY0_LSB				4
+#define CSR_PHYUPDREQDELAY0_MASK			GENMASK_32(7, 4)
+#define CSR_CTRLUPDACKDELAY0_LSB			8
+#define CSR_CTRLUPDACKDELAY0_MASK			GENMASK_32(11, 8)
+#define CSR_CTRLUPDREQDELAY0_LSB			12
+#define CSR_CTRLUPDREQDELAY0_MASK			GENMASK_32(15, 12)
+/* CSR_DFIHANDSHAKEDELAYS1 */
+#define CSR_DFIHANDSHAKEDELAYS1_LSB			0
+#define CSR_DFIHANDSHAKEDELAYS1_MASK			GENMASK_32(15, 0)
+#define CSR_PHYUPDACKDELAY1_LSB				0
+#define CSR_PHYUPDACKDELAY1_MASK			GENMASK_32(3, 0)
+#define CSR_PHYUPDREQDELAY1_LSB				4
+#define CSR_PHYUPDREQDELAY1_MASK			GENMASK_32(7, 4)
+#define CSR_CTRLUPDACKDELAY1_LSB			8
+#define CSR_CTRLUPDACKDELAY1_MASK			GENMASK_32(11, 8)
+#define CSR_CTRLUPDREQDELAY1_LSB			12
+#define CSR_CTRLUPDREQDELAY1_MASK			GENMASK_32(15, 12)
+/* CSR_REMOTEIMPCAL */
+#define CSR_REMOTEIMPCAL_LSB				0
+#define CSR_REMOTEIMPCAL_MASK				GENMASK_32(1, 0)
+#define CSR_CALIBSLAVE_LSB				0
+#define CSR_CALIBSLAVE_MASK				BIT(0)
+#define CSR_SLAVECODEUPDATED_LSB			1
+#define CSR_SLAVECODEUPDATED_MASK			BIT(1)
+/* CSR_ACLOOPBACKCTL */
+#define CSR_ACLOOPBACKCTL_LSB				0
+#define CSR_ACLOOPBACKCTL_MASK				GENMASK_32(1, 0)
+#define CSR_TERMINATION_LSB				0
+#define CSR_TERMINATION_MASK				BIT(0)
+#define CSR_NOISECANCEL_LSB				1
+#define CSR_NOISECANCEL_MASK				BIT(1)
+
+/* ACSM0 register offsets */
+/* CSR_ACSMSEQ0X0 */
+#define CSR_ACSMSEQ0X0_LSB				0
+#define CSR_ACSMSEQ0X0_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY0_LSB				0
+#define CSR_ACSMMCLKDLY0_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE0_LSB				8
+#define CSR_ACSMDDRWE0_MASK				BIT(8)
+#define CSR_ACSMDDRCAS0_LSB				9
+#define CSR_ACSMDDRCAS0_MASK				BIT(9)
+#define CSR_ACSMDDRRAS0_LSB				10
+#define CSR_ACSMDDRRAS0_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET0_LSB				11
+#define CSR_ACSMDDRCKESET0_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR0_LSB				12
+#define CSR_ACSMDDRCKECLR0_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD0_LSB				13
+#define CSR_ACSMSEQGATECMD0_MASK			BIT(13)
+#define CSR_ACSMSEQTERM0_LSB				14
+#define CSR_ACSMSEQTERM0_MASK				BIT(14)
+#define CSR_ACSMLP3CA30_LSB				15
+#define CSR_ACSMLP3CA30_MASK				BIT(15)
+/* CSR_ACSMSEQ0X1 */
+#define CSR_ACSMSEQ0X1_LSB				0
+#define CSR_ACSMSEQ0X1_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY1_LSB				0
+#define CSR_ACSMMCLKDLY1_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE1_LSB				8
+#define CSR_ACSMDDRWE1_MASK				BIT(8)
+#define CSR_ACSMDDRCAS1_LSB				9
+#define CSR_ACSMDDRCAS1_MASK				BIT(9)
+#define CSR_ACSMDDRRAS1_LSB				10
+#define CSR_ACSMDDRRAS1_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET1_LSB				11
+#define CSR_ACSMDDRCKESET1_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR1_LSB				12
+#define CSR_ACSMDDRCKECLR1_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD1_LSB				13
+#define CSR_ACSMSEQGATECMD1_MASK			BIT(13)
+#define CSR_ACSMSEQTERM1_LSB				14
+#define CSR_ACSMSEQTERM1_MASK				BIT(14)
+#define CSR_ACSMLP3CA31_LSB				15
+#define CSR_ACSMLP3CA31_MASK				BIT(15)
+/* CSR_ACSMSEQ0X2 */
+#define CSR_ACSMSEQ0X2_LSB				0
+#define CSR_ACSMSEQ0X2_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY2_LSB				0
+#define CSR_ACSMMCLKDLY2_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE2_LSB				8
+#define CSR_ACSMDDRWE2_MASK				BIT(8)
+#define CSR_ACSMDDRCAS2_LSB				9
+#define CSR_ACSMDDRCAS2_MASK				BIT(9)
+#define CSR_ACSMDDRRAS2_LSB				10
+#define CSR_ACSMDDRRAS2_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET2_LSB				11
+#define CSR_ACSMDDRCKESET2_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR2_LSB				12
+#define CSR_ACSMDDRCKECLR2_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD2_LSB				13
+#define CSR_ACSMSEQGATECMD2_MASK			BIT(13)
+#define CSR_ACSMSEQTERM2_LSB				14
+#define CSR_ACSMSEQTERM2_MASK				BIT(14)
+#define CSR_ACSMLP3CA32_LSB				15
+#define CSR_ACSMLP3CA32_MASK				BIT(15)
+/* CSR_ACSMSEQ0X3 */
+#define CSR_ACSMSEQ0X3_LSB				0
+#define CSR_ACSMSEQ0X3_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY3_LSB				0
+#define CSR_ACSMMCLKDLY3_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE3_LSB				8
+#define CSR_ACSMDDRWE3_MASK				BIT(8)
+#define CSR_ACSMDDRCAS3_LSB				9
+#define CSR_ACSMDDRCAS3_MASK				BIT(9)
+#define CSR_ACSMDDRRAS3_LSB				10
+#define CSR_ACSMDDRRAS3_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET3_LSB				11
+#define CSR_ACSMDDRCKESET3_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR3_LSB				12
+#define CSR_ACSMDDRCKECLR3_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD3_LSB				13
+#define CSR_ACSMSEQGATECMD3_MASK			BIT(13)
+#define CSR_ACSMSEQTERM3_LSB				14
+#define CSR_ACSMSEQTERM3_MASK				BIT(14)
+#define CSR_ACSMLP3CA33_LSB				15
+#define CSR_ACSMLP3CA33_MASK				BIT(15)
+/* CSR_ACSMSEQ0X4 */
+#define CSR_ACSMSEQ0X4_LSB				0
+#define CSR_ACSMSEQ0X4_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY4_LSB				0
+#define CSR_ACSMMCLKDLY4_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE4_LSB				8
+#define CSR_ACSMDDRWE4_MASK				BIT(8)
+#define CSR_ACSMDDRCAS4_LSB				9
+#define CSR_ACSMDDRCAS4_MASK				BIT(9)
+#define CSR_ACSMDDRRAS4_LSB				10
+#define CSR_ACSMDDRRAS4_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET4_LSB				11
+#define CSR_ACSMDDRCKESET4_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR4_LSB				12
+#define CSR_ACSMDDRCKECLR4_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD4_LSB				13
+#define CSR_ACSMSEQGATECMD4_MASK			BIT(13)
+#define CSR_ACSMSEQTERM4_LSB				14
+#define CSR_ACSMSEQTERM4_MASK				BIT(14)
+#define CSR_ACSMLP3CA34_LSB				15
+#define CSR_ACSMLP3CA34_MASK				BIT(15)
+/* CSR_ACSMSEQ0X5 */
+#define CSR_ACSMSEQ0X5_LSB				0
+#define CSR_ACSMSEQ0X5_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY5_LSB				0
+#define CSR_ACSMMCLKDLY5_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE5_LSB				8
+#define CSR_ACSMDDRWE5_MASK				BIT(8)
+#define CSR_ACSMDDRCAS5_LSB				9
+#define CSR_ACSMDDRCAS5_MASK				BIT(9)
+#define CSR_ACSMDDRRAS5_LSB				10
+#define CSR_ACSMDDRRAS5_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET5_LSB				11
+#define CSR_ACSMDDRCKESET5_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR5_LSB				12
+#define CSR_ACSMDDRCKECLR5_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD5_LSB				13
+#define CSR_ACSMSEQGATECMD5_MASK			BIT(13)
+#define CSR_ACSMSEQTERM5_LSB				14
+#define CSR_ACSMSEQTERM5_MASK				BIT(14)
+#define CSR_ACSMLP3CA35_LSB				15
+#define CSR_ACSMLP3CA35_MASK				BIT(15)
+/* CSR_ACSMSEQ0X6 */
+#define CSR_ACSMSEQ0X6_LSB				0
+#define CSR_ACSMSEQ0X6_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY6_LSB				0
+#define CSR_ACSMMCLKDLY6_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE6_LSB				8
+#define CSR_ACSMDDRWE6_MASK				BIT(8)
+#define CSR_ACSMDDRCAS6_LSB				9
+#define CSR_ACSMDDRCAS6_MASK				BIT(9)
+#define CSR_ACSMDDRRAS6_LSB				10
+#define CSR_ACSMDDRRAS6_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET6_LSB				11
+#define CSR_ACSMDDRCKESET6_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR6_LSB				12
+#define CSR_ACSMDDRCKECLR6_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD6_LSB				13
+#define CSR_ACSMSEQGATECMD6_MASK			BIT(13)
+#define CSR_ACSMSEQTERM6_LSB				14
+#define CSR_ACSMSEQTERM6_MASK				BIT(14)
+#define CSR_ACSMLP3CA36_LSB				15
+#define CSR_ACSMLP3CA36_MASK				BIT(15)
+/* CSR_ACSMSEQ0X7 */
+#define CSR_ACSMSEQ0X7_LSB				0
+#define CSR_ACSMSEQ0X7_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY7_LSB				0
+#define CSR_ACSMMCLKDLY7_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE7_LSB				8
+#define CSR_ACSMDDRWE7_MASK				BIT(8)
+#define CSR_ACSMDDRCAS7_LSB				9
+#define CSR_ACSMDDRCAS7_MASK				BIT(9)
+#define CSR_ACSMDDRRAS7_LSB				10
+#define CSR_ACSMDDRRAS7_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET7_LSB				11
+#define CSR_ACSMDDRCKESET7_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR7_LSB				12
+#define CSR_ACSMDDRCKECLR7_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD7_LSB				13
+#define CSR_ACSMSEQGATECMD7_MASK			BIT(13)
+#define CSR_ACSMSEQTERM7_LSB				14
+#define CSR_ACSMSEQTERM7_MASK				BIT(14)
+#define CSR_ACSMLP3CA37_LSB				15
+#define CSR_ACSMLP3CA37_MASK				BIT(15)
+/* CSR_ACSMSEQ0X8 */
+#define CSR_ACSMSEQ0X8_LSB				0
+#define CSR_ACSMSEQ0X8_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY8_LSB				0
+#define CSR_ACSMMCLKDLY8_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE8_LSB				8
+#define CSR_ACSMDDRWE8_MASK				BIT(8)
+#define CSR_ACSMDDRCAS8_LSB				9
+#define CSR_ACSMDDRCAS8_MASK				BIT(9)
+#define CSR_ACSMDDRRAS8_LSB				10
+#define CSR_ACSMDDRRAS8_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET8_LSB				11
+#define CSR_ACSMDDRCKESET8_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR8_LSB				12
+#define CSR_ACSMDDRCKECLR8_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD8_LSB				13
+#define CSR_ACSMSEQGATECMD8_MASK			BIT(13)
+#define CSR_ACSMSEQTERM8_LSB				14
+#define CSR_ACSMSEQTERM8_MASK				BIT(14)
+#define CSR_ACSMLP3CA38_LSB				15
+#define CSR_ACSMLP3CA38_MASK				BIT(15)
+/* CSR_ACSMSEQ0X9 */
+#define CSR_ACSMSEQ0X9_LSB				0
+#define CSR_ACSMSEQ0X9_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY9_LSB				0
+#define CSR_ACSMMCLKDLY9_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE9_LSB				8
+#define CSR_ACSMDDRWE9_MASK				BIT(8)
+#define CSR_ACSMDDRCAS9_LSB				9
+#define CSR_ACSMDDRCAS9_MASK				BIT(9)
+#define CSR_ACSMDDRRAS9_LSB				10
+#define CSR_ACSMDDRRAS9_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET9_LSB				11
+#define CSR_ACSMDDRCKESET9_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR9_LSB				12
+#define CSR_ACSMDDRCKECLR9_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD9_LSB				13
+#define CSR_ACSMSEQGATECMD9_MASK			BIT(13)
+#define CSR_ACSMSEQTERM9_LSB				14
+#define CSR_ACSMSEQTERM9_MASK				BIT(14)
+#define CSR_ACSMLP3CA39_LSB				15
+#define CSR_ACSMLP3CA39_MASK				BIT(15)
+/* CSR_ACSMSEQ0X10 */
+#define CSR_ACSMSEQ0X10_LSB				0
+#define CSR_ACSMSEQ0X10_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY10_LSB				0
+#define CSR_ACSMMCLKDLY10_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE10_LSB				8
+#define CSR_ACSMDDRWE10_MASK				BIT(8)
+#define CSR_ACSMDDRCAS10_LSB				9
+#define CSR_ACSMDDRCAS10_MASK				BIT(9)
+#define CSR_ACSMDDRRAS10_LSB				10
+#define CSR_ACSMDDRRAS10_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET10_LSB				11
+#define CSR_ACSMDDRCKESET10_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR10_LSB				12
+#define CSR_ACSMDDRCKECLR10_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD10_LSB			13
+#define CSR_ACSMSEQGATECMD10_MASK			BIT(13)
+#define CSR_ACSMSEQTERM10_LSB				14
+#define CSR_ACSMSEQTERM10_MASK				BIT(14)
+#define CSR_ACSMLP3CA310_LSB				15
+#define CSR_ACSMLP3CA310_MASK				BIT(15)
+/* CSR_ACSMSEQ0X11 */
+#define CSR_ACSMSEQ0X11_LSB				0
+#define CSR_ACSMSEQ0X11_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY11_LSB				0
+#define CSR_ACSMMCLKDLY11_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE11_LSB				8
+#define CSR_ACSMDDRWE11_MASK				BIT(8)
+#define CSR_ACSMDDRCAS11_LSB				9
+#define CSR_ACSMDDRCAS11_MASK				BIT(9)
+#define CSR_ACSMDDRRAS11_LSB				10
+#define CSR_ACSMDDRRAS11_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET11_LSB				11
+#define CSR_ACSMDDRCKESET11_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR11_LSB				12
+#define CSR_ACSMDDRCKECLR11_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD11_LSB			13
+#define CSR_ACSMSEQGATECMD11_MASK			BIT(13)
+#define CSR_ACSMSEQTERM11_LSB				14
+#define CSR_ACSMSEQTERM11_MASK				BIT(14)
+#define CSR_ACSMLP3CA311_LSB				15
+#define CSR_ACSMLP3CA311_MASK				BIT(15)
+/* CSR_ACSMSEQ0X12 */
+#define CSR_ACSMSEQ0X12_LSB				0
+#define CSR_ACSMSEQ0X12_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY12_LSB				0
+#define CSR_ACSMMCLKDLY12_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE12_LSB				8
+#define CSR_ACSMDDRWE12_MASK				BIT(8)
+#define CSR_ACSMDDRCAS12_LSB				9
+#define CSR_ACSMDDRCAS12_MASK				BIT(9)
+#define CSR_ACSMDDRRAS12_LSB				10
+#define CSR_ACSMDDRRAS12_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET12_LSB				11
+#define CSR_ACSMDDRCKESET12_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR12_LSB				12
+#define CSR_ACSMDDRCKECLR12_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD12_LSB			13
+#define CSR_ACSMSEQGATECMD12_MASK			BIT(13)
+#define CSR_ACSMSEQTERM12_LSB				14
+#define CSR_ACSMSEQTERM12_MASK				BIT(14)
+#define CSR_ACSMLP3CA312_LSB				15
+#define CSR_ACSMLP3CA312_MASK				BIT(15)
+/* CSR_ACSMSEQ0X13 */
+#define CSR_ACSMSEQ0X13_LSB				0
+#define CSR_ACSMSEQ0X13_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY13_LSB				0
+#define CSR_ACSMMCLKDLY13_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE13_LSB				8
+#define CSR_ACSMDDRWE13_MASK				BIT(8)
+#define CSR_ACSMDDRCAS13_LSB				9
+#define CSR_ACSMDDRCAS13_MASK				BIT(9)
+#define CSR_ACSMDDRRAS13_LSB				10
+#define CSR_ACSMDDRRAS13_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET13_LSB				11
+#define CSR_ACSMDDRCKESET13_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR13_LSB				12
+#define CSR_ACSMDDRCKECLR13_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD13_LSB			13
+#define CSR_ACSMSEQGATECMD13_MASK			BIT(13)
+#define CSR_ACSMSEQTERM13_LSB				14
+#define CSR_ACSMSEQTERM13_MASK				BIT(14)
+#define CSR_ACSMLP3CA313_LSB				15
+#define CSR_ACSMLP3CA313_MASK				BIT(15)
+/* CSR_ACSMSEQ0X14 */
+#define CSR_ACSMSEQ0X14_LSB				0
+#define CSR_ACSMSEQ0X14_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY14_LSB				0
+#define CSR_ACSMMCLKDLY14_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE14_LSB				8
+#define CSR_ACSMDDRWE14_MASK				BIT(8)
+#define CSR_ACSMDDRCAS14_LSB				9
+#define CSR_ACSMDDRCAS14_MASK				BIT(9)
+#define CSR_ACSMDDRRAS14_LSB				10
+#define CSR_ACSMDDRRAS14_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET14_LSB				11
+#define CSR_ACSMDDRCKESET14_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR14_LSB				12
+#define CSR_ACSMDDRCKECLR14_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD14_LSB			13
+#define CSR_ACSMSEQGATECMD14_MASK			BIT(13)
+#define CSR_ACSMSEQTERM14_LSB				14
+#define CSR_ACSMSEQTERM14_MASK				BIT(14)
+#define CSR_ACSMLP3CA314_LSB				15
+#define CSR_ACSMLP3CA314_MASK				BIT(15)
+/* CSR_ACSMSEQ0X15 */
+#define CSR_ACSMSEQ0X15_LSB				0
+#define CSR_ACSMSEQ0X15_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY15_LSB				0
+#define CSR_ACSMMCLKDLY15_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE15_LSB				8
+#define CSR_ACSMDDRWE15_MASK				BIT(8)
+#define CSR_ACSMDDRCAS15_LSB				9
+#define CSR_ACSMDDRCAS15_MASK				BIT(9)
+#define CSR_ACSMDDRRAS15_LSB				10
+#define CSR_ACSMDDRRAS15_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET15_LSB				11
+#define CSR_ACSMDDRCKESET15_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR15_LSB				12
+#define CSR_ACSMDDRCKECLR15_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD15_LSB			13
+#define CSR_ACSMSEQGATECMD15_MASK			BIT(13)
+#define CSR_ACSMSEQTERM15_LSB				14
+#define CSR_ACSMSEQTERM15_MASK				BIT(14)
+#define CSR_ACSMLP3CA315_LSB				15
+#define CSR_ACSMLP3CA315_MASK				BIT(15)
+/* CSR_ACSMSEQ0X16 */
+#define CSR_ACSMSEQ0X16_LSB				0
+#define CSR_ACSMSEQ0X16_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY16_LSB				0
+#define CSR_ACSMMCLKDLY16_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE16_LSB				8
+#define CSR_ACSMDDRWE16_MASK				BIT(8)
+#define CSR_ACSMDDRCAS16_LSB				9
+#define CSR_ACSMDDRCAS16_MASK				BIT(9)
+#define CSR_ACSMDDRRAS16_LSB				10
+#define CSR_ACSMDDRRAS16_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET16_LSB				11
+#define CSR_ACSMDDRCKESET16_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR16_LSB				12
+#define CSR_ACSMDDRCKECLR16_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD16_LSB			13
+#define CSR_ACSMSEQGATECMD16_MASK			BIT(13)
+#define CSR_ACSMSEQTERM16_LSB				14
+#define CSR_ACSMSEQTERM16_MASK				BIT(14)
+#define CSR_ACSMLP3CA316_LSB				15
+#define CSR_ACSMLP3CA316_MASK				BIT(15)
+/* CSR_ACSMSEQ0X17 */
+#define CSR_ACSMSEQ0X17_LSB				0
+#define CSR_ACSMSEQ0X17_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY17_LSB				0
+#define CSR_ACSMMCLKDLY17_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE17_LSB				8
+#define CSR_ACSMDDRWE17_MASK				BIT(8)
+#define CSR_ACSMDDRCAS17_LSB				9
+#define CSR_ACSMDDRCAS17_MASK				BIT(9)
+#define CSR_ACSMDDRRAS17_LSB				10
+#define CSR_ACSMDDRRAS17_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET17_LSB				11
+#define CSR_ACSMDDRCKESET17_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR17_LSB				12
+#define CSR_ACSMDDRCKECLR17_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD17_LSB			13
+#define CSR_ACSMSEQGATECMD17_MASK			BIT(13)
+#define CSR_ACSMSEQTERM17_LSB				14
+#define CSR_ACSMSEQTERM17_MASK				BIT(14)
+#define CSR_ACSMLP3CA317_LSB				15
+#define CSR_ACSMLP3CA317_MASK				BIT(15)
+/* CSR_ACSMSEQ0X18 */
+#define CSR_ACSMSEQ0X18_LSB				0
+#define CSR_ACSMSEQ0X18_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY18_LSB				0
+#define CSR_ACSMMCLKDLY18_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE18_LSB				8
+#define CSR_ACSMDDRWE18_MASK				BIT(8)
+#define CSR_ACSMDDRCAS18_LSB				9
+#define CSR_ACSMDDRCAS18_MASK				BIT(9)
+#define CSR_ACSMDDRRAS18_LSB				10
+#define CSR_ACSMDDRRAS18_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET18_LSB				11
+#define CSR_ACSMDDRCKESET18_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR18_LSB				12
+#define CSR_ACSMDDRCKECLR18_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD18_LSB			13
+#define CSR_ACSMSEQGATECMD18_MASK			BIT(13)
+#define CSR_ACSMSEQTERM18_LSB				14
+#define CSR_ACSMSEQTERM18_MASK				BIT(14)
+#define CSR_ACSMLP3CA318_LSB				15
+#define CSR_ACSMLP3CA318_MASK				BIT(15)
+/* CSR_ACSMSEQ0X19 */
+#define CSR_ACSMSEQ0X19_LSB				0
+#define CSR_ACSMSEQ0X19_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY19_LSB				0
+#define CSR_ACSMMCLKDLY19_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE19_LSB				8
+#define CSR_ACSMDDRWE19_MASK				BIT(8)
+#define CSR_ACSMDDRCAS19_LSB				9
+#define CSR_ACSMDDRCAS19_MASK				BIT(9)
+#define CSR_ACSMDDRRAS19_LSB				10
+#define CSR_ACSMDDRRAS19_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET19_LSB				11
+#define CSR_ACSMDDRCKESET19_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR19_LSB				12
+#define CSR_ACSMDDRCKECLR19_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD19_LSB			13
+#define CSR_ACSMSEQGATECMD19_MASK			BIT(13)
+#define CSR_ACSMSEQTERM19_LSB				14
+#define CSR_ACSMSEQTERM19_MASK				BIT(14)
+#define CSR_ACSMLP3CA319_LSB				15
+#define CSR_ACSMLP3CA319_MASK				BIT(15)
+/* CSR_ACSMSEQ0X20 */
+#define CSR_ACSMSEQ0X20_LSB				0
+#define CSR_ACSMSEQ0X20_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY20_LSB				0
+#define CSR_ACSMMCLKDLY20_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE20_LSB				8
+#define CSR_ACSMDDRWE20_MASK				BIT(8)
+#define CSR_ACSMDDRCAS20_LSB				9
+#define CSR_ACSMDDRCAS20_MASK				BIT(9)
+#define CSR_ACSMDDRRAS20_LSB				10
+#define CSR_ACSMDDRRAS20_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET20_LSB				11
+#define CSR_ACSMDDRCKESET20_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR20_LSB				12
+#define CSR_ACSMDDRCKECLR20_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD20_LSB			13
+#define CSR_ACSMSEQGATECMD20_MASK			BIT(13)
+#define CSR_ACSMSEQTERM20_LSB				14
+#define CSR_ACSMSEQTERM20_MASK				BIT(14)
+#define CSR_ACSMLP3CA320_LSB				15
+#define CSR_ACSMLP3CA320_MASK				BIT(15)
+/* CSR_ACSMSEQ0X21 */
+#define CSR_ACSMSEQ0X21_LSB				0
+#define CSR_ACSMSEQ0X21_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY21_LSB				0
+#define CSR_ACSMMCLKDLY21_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE21_LSB				8
+#define CSR_ACSMDDRWE21_MASK				BIT(8)
+#define CSR_ACSMDDRCAS21_LSB				9
+#define CSR_ACSMDDRCAS21_MASK				BIT(9)
+#define CSR_ACSMDDRRAS21_LSB				10
+#define CSR_ACSMDDRRAS21_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET21_LSB				11
+#define CSR_ACSMDDRCKESET21_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR21_LSB				12
+#define CSR_ACSMDDRCKECLR21_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD21_LSB			13
+#define CSR_ACSMSEQGATECMD21_MASK			BIT(13)
+#define CSR_ACSMSEQTERM21_LSB				14
+#define CSR_ACSMSEQTERM21_MASK				BIT(14)
+#define CSR_ACSMLP3CA321_LSB				15
+#define CSR_ACSMLP3CA321_MASK				BIT(15)
+/* CSR_ACSMSEQ0X22 */
+#define CSR_ACSMSEQ0X22_LSB				0
+#define CSR_ACSMSEQ0X22_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY22_LSB				0
+#define CSR_ACSMMCLKDLY22_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE22_LSB				8
+#define CSR_ACSMDDRWE22_MASK				BIT(8)
+#define CSR_ACSMDDRCAS22_LSB				9
+#define CSR_ACSMDDRCAS22_MASK				BIT(9)
+#define CSR_ACSMDDRRAS22_LSB				10
+#define CSR_ACSMDDRRAS22_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET22_LSB				11
+#define CSR_ACSMDDRCKESET22_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR22_LSB				12
+#define CSR_ACSMDDRCKECLR22_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD22_LSB			13
+#define CSR_ACSMSEQGATECMD22_MASK			BIT(13)
+#define CSR_ACSMSEQTERM22_LSB				14
+#define CSR_ACSMSEQTERM22_MASK				BIT(14)
+#define CSR_ACSMLP3CA322_LSB				15
+#define CSR_ACSMLP3CA322_MASK				BIT(15)
+/* CSR_ACSMSEQ0X23 */
+#define CSR_ACSMSEQ0X23_LSB				0
+#define CSR_ACSMSEQ0X23_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY23_LSB				0
+#define CSR_ACSMMCLKDLY23_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE23_LSB				8
+#define CSR_ACSMDDRWE23_MASK				BIT(8)
+#define CSR_ACSMDDRCAS23_LSB				9
+#define CSR_ACSMDDRCAS23_MASK				BIT(9)
+#define CSR_ACSMDDRRAS23_LSB				10
+#define CSR_ACSMDDRRAS23_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET23_LSB				11
+#define CSR_ACSMDDRCKESET23_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR23_LSB				12
+#define CSR_ACSMDDRCKECLR23_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD23_LSB			13
+#define CSR_ACSMSEQGATECMD23_MASK			BIT(13)
+#define CSR_ACSMSEQTERM23_LSB				14
+#define CSR_ACSMSEQTERM23_MASK				BIT(14)
+#define CSR_ACSMLP3CA323_LSB				15
+#define CSR_ACSMLP3CA323_MASK				BIT(15)
+/* CSR_ACSMSEQ0X24 */
+#define CSR_ACSMSEQ0X24_LSB				0
+#define CSR_ACSMSEQ0X24_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY24_LSB				0
+#define CSR_ACSMMCLKDLY24_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE24_LSB				8
+#define CSR_ACSMDDRWE24_MASK				BIT(8)
+#define CSR_ACSMDDRCAS24_LSB				9
+#define CSR_ACSMDDRCAS24_MASK				BIT(9)
+#define CSR_ACSMDDRRAS24_LSB				10
+#define CSR_ACSMDDRRAS24_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET24_LSB				11
+#define CSR_ACSMDDRCKESET24_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR24_LSB				12
+#define CSR_ACSMDDRCKECLR24_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD24_LSB			13
+#define CSR_ACSMSEQGATECMD24_MASK			BIT(13)
+#define CSR_ACSMSEQTERM24_LSB				14
+#define CSR_ACSMSEQTERM24_MASK				BIT(14)
+#define CSR_ACSMLP3CA324_LSB				15
+#define CSR_ACSMLP3CA324_MASK				BIT(15)
+/* CSR_ACSMSEQ0X25 */
+#define CSR_ACSMSEQ0X25_LSB				0
+#define CSR_ACSMSEQ0X25_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY25_LSB				0
+#define CSR_ACSMMCLKDLY25_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE25_LSB				8
+#define CSR_ACSMDDRWE25_MASK				BIT(8)
+#define CSR_ACSMDDRCAS25_LSB				9
+#define CSR_ACSMDDRCAS25_MASK				BIT(9)
+#define CSR_ACSMDDRRAS25_LSB				10
+#define CSR_ACSMDDRRAS25_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET25_LSB				11
+#define CSR_ACSMDDRCKESET25_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR25_LSB				12
+#define CSR_ACSMDDRCKECLR25_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD25_LSB			13
+#define CSR_ACSMSEQGATECMD25_MASK			BIT(13)
+#define CSR_ACSMSEQTERM25_LSB				14
+#define CSR_ACSMSEQTERM25_MASK				BIT(14)
+#define CSR_ACSMLP3CA325_LSB				15
+#define CSR_ACSMLP3CA325_MASK				BIT(15)
+/* CSR_ACSMSEQ0X26 */
+#define CSR_ACSMSEQ0X26_LSB				0
+#define CSR_ACSMSEQ0X26_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY26_LSB				0
+#define CSR_ACSMMCLKDLY26_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE26_LSB				8
+#define CSR_ACSMDDRWE26_MASK				BIT(8)
+#define CSR_ACSMDDRCAS26_LSB				9
+#define CSR_ACSMDDRCAS26_MASK				BIT(9)
+#define CSR_ACSMDDRRAS26_LSB				10
+#define CSR_ACSMDDRRAS26_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET26_LSB				11
+#define CSR_ACSMDDRCKESET26_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR26_LSB				12
+#define CSR_ACSMDDRCKECLR26_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD26_LSB			13
+#define CSR_ACSMSEQGATECMD26_MASK			BIT(13)
+#define CSR_ACSMSEQTERM26_LSB				14
+#define CSR_ACSMSEQTERM26_MASK				BIT(14)
+#define CSR_ACSMLP3CA326_LSB				15
+#define CSR_ACSMLP3CA326_MASK				BIT(15)
+/* CSR_ACSMSEQ0X27 */
+#define CSR_ACSMSEQ0X27_LSB				0
+#define CSR_ACSMSEQ0X27_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY27_LSB				0
+#define CSR_ACSMMCLKDLY27_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE27_LSB				8
+#define CSR_ACSMDDRWE27_MASK				BIT(8)
+#define CSR_ACSMDDRCAS27_LSB				9
+#define CSR_ACSMDDRCAS27_MASK				BIT(9)
+#define CSR_ACSMDDRRAS27_LSB				10
+#define CSR_ACSMDDRRAS27_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET27_LSB				11
+#define CSR_ACSMDDRCKESET27_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR27_LSB				12
+#define CSR_ACSMDDRCKECLR27_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD27_LSB			13
+#define CSR_ACSMSEQGATECMD27_MASK			BIT(13)
+#define CSR_ACSMSEQTERM27_LSB				14
+#define CSR_ACSMSEQTERM27_MASK				BIT(14)
+#define CSR_ACSMLP3CA327_LSB				15
+#define CSR_ACSMLP3CA327_MASK				BIT(15)
+/* CSR_ACSMSEQ0X28 */
+#define CSR_ACSMSEQ0X28_LSB				0
+#define CSR_ACSMSEQ0X28_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY28_LSB				0
+#define CSR_ACSMMCLKDLY28_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE28_LSB				8
+#define CSR_ACSMDDRWE28_MASK				BIT(8)
+#define CSR_ACSMDDRCAS28_LSB				9
+#define CSR_ACSMDDRCAS28_MASK				BIT(9)
+#define CSR_ACSMDDRRAS28_LSB				10
+#define CSR_ACSMDDRRAS28_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET28_LSB				11
+#define CSR_ACSMDDRCKESET28_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR28_LSB				12
+#define CSR_ACSMDDRCKECLR28_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD28_LSB			13
+#define CSR_ACSMSEQGATECMD28_MASK			BIT(13)
+#define CSR_ACSMSEQTERM28_LSB				14
+#define CSR_ACSMSEQTERM28_MASK				BIT(14)
+#define CSR_ACSMLP3CA328_LSB				15
+#define CSR_ACSMLP3CA328_MASK				BIT(15)
+/* CSR_ACSMSEQ0X29 */
+#define CSR_ACSMSEQ0X29_LSB				0
+#define CSR_ACSMSEQ0X29_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY29_LSB				0
+#define CSR_ACSMMCLKDLY29_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE29_LSB				8
+#define CSR_ACSMDDRWE29_MASK				BIT(8)
+#define CSR_ACSMDDRCAS29_LSB				9
+#define CSR_ACSMDDRCAS29_MASK				BIT(9)
+#define CSR_ACSMDDRRAS29_LSB				10
+#define CSR_ACSMDDRRAS29_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET29_LSB				11
+#define CSR_ACSMDDRCKESET29_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR29_LSB				12
+#define CSR_ACSMDDRCKECLR29_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD29_LSB			13
+#define CSR_ACSMSEQGATECMD29_MASK			BIT(13)
+#define CSR_ACSMSEQTERM29_LSB				14
+#define CSR_ACSMSEQTERM29_MASK				BIT(14)
+#define CSR_ACSMLP3CA329_LSB				15
+#define CSR_ACSMLP3CA329_MASK				BIT(15)
+/* CSR_ACSMSEQ0X30 */
+#define CSR_ACSMSEQ0X30_LSB				0
+#define CSR_ACSMSEQ0X30_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY30_LSB				0
+#define CSR_ACSMMCLKDLY30_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE30_LSB				8
+#define CSR_ACSMDDRWE30_MASK				BIT(8)
+#define CSR_ACSMDDRCAS30_LSB				9
+#define CSR_ACSMDDRCAS30_MASK				BIT(9)
+#define CSR_ACSMDDRRAS30_LSB				10
+#define CSR_ACSMDDRRAS30_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET30_LSB				11
+#define CSR_ACSMDDRCKESET30_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR30_LSB				12
+#define CSR_ACSMDDRCKECLR30_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD30_LSB			13
+#define CSR_ACSMSEQGATECMD30_MASK			BIT(13)
+#define CSR_ACSMSEQTERM30_LSB				14
+#define CSR_ACSMSEQTERM30_MASK				BIT(14)
+#define CSR_ACSMLP3CA330_LSB				15
+#define CSR_ACSMLP3CA330_MASK				BIT(15)
+/* CSR_ACSMSEQ0X31 */
+#define CSR_ACSMSEQ0X31_LSB				0
+#define CSR_ACSMSEQ0X31_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY31_LSB				0
+#define CSR_ACSMMCLKDLY31_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE31_LSB				8
+#define CSR_ACSMDDRWE31_MASK				BIT(8)
+#define CSR_ACSMDDRCAS31_LSB				9
+#define CSR_ACSMDDRCAS31_MASK				BIT(9)
+#define CSR_ACSMDDRRAS31_LSB				10
+#define CSR_ACSMDDRRAS31_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET31_LSB				11
+#define CSR_ACSMDDRCKESET31_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR31_LSB				12
+#define CSR_ACSMDDRCKECLR31_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD31_LSB			13
+#define CSR_ACSMSEQGATECMD31_MASK			BIT(13)
+#define CSR_ACSMSEQTERM31_LSB				14
+#define CSR_ACSMSEQTERM31_MASK				BIT(14)
+#define CSR_ACSMLP3CA331_LSB				15
+#define CSR_ACSMLP3CA331_MASK				BIT(15)
+/* CSR_ACSMSEQ1X0 */
+#define CSR_ACSMSEQ1X0_LSB				0
+#define CSR_ACSMSEQ1X0_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS0_LSB				0
+#define CSR_ACSMDDRCS0_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN0_LSB				8
+#define CSR_ACSMSAVEGEN0_MASK				BIT(8)
+#define CSR_ACSMLOADCHK0_LSB				9
+#define CSR_ACSMLOADCHK0_MASK				BIT(9)
+#define CSR_ACSMNORXENB0_LSB				10
+#define CSR_ACSMNORXENB0_MASK				BIT(10)
+#define CSR_ACSMNORXVAL0_LSB				11
+#define CSR_ACSMNORXVAL0_MASK				BIT(11)
+#define CSR_ACSMDDRBNK0_LSB				12
+#define CSR_ACSMDDRBNK0_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X1 */
+#define CSR_ACSMSEQ1X1_LSB				0
+#define CSR_ACSMSEQ1X1_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS1_LSB				0
+#define CSR_ACSMDDRCS1_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN1_LSB				8
+#define CSR_ACSMSAVEGEN1_MASK				BIT(8)
+#define CSR_ACSMLOADCHK1_LSB				9
+#define CSR_ACSMLOADCHK1_MASK				BIT(9)
+#define CSR_ACSMNORXENB1_LSB				10
+#define CSR_ACSMNORXENB1_MASK				BIT(10)
+#define CSR_ACSMNORXVAL1_LSB				11
+#define CSR_ACSMNORXVAL1_MASK				BIT(11)
+#define CSR_ACSMDDRBNK1_LSB				12
+#define CSR_ACSMDDRBNK1_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X2 */
+#define CSR_ACSMSEQ1X2_LSB				0
+#define CSR_ACSMSEQ1X2_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS2_LSB				0
+#define CSR_ACSMDDRCS2_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN2_LSB				8
+#define CSR_ACSMSAVEGEN2_MASK				BIT(8)
+#define CSR_ACSMLOADCHK2_LSB				9
+#define CSR_ACSMLOADCHK2_MASK				BIT(9)
+#define CSR_ACSMNORXENB2_LSB				10
+#define CSR_ACSMNORXENB2_MASK				BIT(10)
+#define CSR_ACSMNORXVAL2_LSB				11
+#define CSR_ACSMNORXVAL2_MASK				BIT(11)
+#define CSR_ACSMDDRBNK2_LSB				12
+#define CSR_ACSMDDRBNK2_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X3 */
+#define CSR_ACSMSEQ1X3_LSB				0
+#define CSR_ACSMSEQ1X3_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS3_LSB				0
+#define CSR_ACSMDDRCS3_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN3_LSB				8
+#define CSR_ACSMSAVEGEN3_MASK				BIT(8)
+#define CSR_ACSMLOADCHK3_LSB				9
+#define CSR_ACSMLOADCHK3_MASK				BIT(9)
+#define CSR_ACSMNORXENB3_LSB				10
+#define CSR_ACSMNORXENB3_MASK				BIT(10)
+#define CSR_ACSMNORXVAL3_LSB				11
+#define CSR_ACSMNORXVAL3_MASK				BIT(11)
+#define CSR_ACSMDDRBNK3_LSB				12
+#define CSR_ACSMDDRBNK3_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X4 */
+#define CSR_ACSMSEQ1X4_LSB				0
+#define CSR_ACSMSEQ1X4_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS4_LSB				0
+#define CSR_ACSMDDRCS4_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN4_LSB				8
+#define CSR_ACSMSAVEGEN4_MASK				BIT(8)
+#define CSR_ACSMLOADCHK4_LSB				9
+#define CSR_ACSMLOADCHK4_MASK				BIT(9)
+#define CSR_ACSMNORXENB4_LSB				10
+#define CSR_ACSMNORXENB4_MASK				BIT(10)
+#define CSR_ACSMNORXVAL4_LSB				11
+#define CSR_ACSMNORXVAL4_MASK				BIT(11)
+#define CSR_ACSMDDRBNK4_LSB				12
+#define CSR_ACSMDDRBNK4_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X5 */
+#define CSR_ACSMSEQ1X5_LSB				0
+#define CSR_ACSMSEQ1X5_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS5_LSB				0
+#define CSR_ACSMDDRCS5_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN5_LSB				8
+#define CSR_ACSMSAVEGEN5_MASK				BIT(8)
+#define CSR_ACSMLOADCHK5_LSB				9
+#define CSR_ACSMLOADCHK5_MASK				BIT(9)
+#define CSR_ACSMNORXENB5_LSB				10
+#define CSR_ACSMNORXENB5_MASK				BIT(10)
+#define CSR_ACSMNORXVAL5_LSB				11
+#define CSR_ACSMNORXVAL5_MASK				BIT(11)
+#define CSR_ACSMDDRBNK5_LSB				12
+#define CSR_ACSMDDRBNK5_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X6 */
+#define CSR_ACSMSEQ1X6_LSB				0
+#define CSR_ACSMSEQ1X6_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS6_LSB				0
+#define CSR_ACSMDDRCS6_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN6_LSB				8
+#define CSR_ACSMSAVEGEN6_MASK				BIT(8)
+#define CSR_ACSMLOADCHK6_LSB				9
+#define CSR_ACSMLOADCHK6_MASK				BIT(9)
+#define CSR_ACSMNORXENB6_LSB				10
+#define CSR_ACSMNORXENB6_MASK				BIT(10)
+#define CSR_ACSMNORXVAL6_LSB				11
+#define CSR_ACSMNORXVAL6_MASK				BIT(11)
+#define CSR_ACSMDDRBNK6_LSB				12
+#define CSR_ACSMDDRBNK6_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X7 */
+#define CSR_ACSMSEQ1X7_LSB				0
+#define CSR_ACSMSEQ1X7_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS7_LSB				0
+#define CSR_ACSMDDRCS7_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN7_LSB				8
+#define CSR_ACSMSAVEGEN7_MASK				BIT(8)
+#define CSR_ACSMLOADCHK7_LSB				9
+#define CSR_ACSMLOADCHK7_MASK				BIT(9)
+#define CSR_ACSMNORXENB7_LSB				10
+#define CSR_ACSMNORXENB7_MASK				BIT(10)
+#define CSR_ACSMNORXVAL7_LSB				11
+#define CSR_ACSMNORXVAL7_MASK				BIT(11)
+#define CSR_ACSMDDRBNK7_LSB				12
+#define CSR_ACSMDDRBNK7_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X8 */
+#define CSR_ACSMSEQ1X8_LSB				0
+#define CSR_ACSMSEQ1X8_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS8_LSB				0
+#define CSR_ACSMDDRCS8_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN8_LSB				8
+#define CSR_ACSMSAVEGEN8_MASK				BIT(8)
+#define CSR_ACSMLOADCHK8_LSB				9
+#define CSR_ACSMLOADCHK8_MASK				BIT(9)
+#define CSR_ACSMNORXENB8_LSB				10
+#define CSR_ACSMNORXENB8_MASK				BIT(10)
+#define CSR_ACSMNORXVAL8_LSB				11
+#define CSR_ACSMNORXVAL8_MASK				BIT(11)
+#define CSR_ACSMDDRBNK8_LSB				12
+#define CSR_ACSMDDRBNK8_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X9 */
+#define CSR_ACSMSEQ1X9_LSB				0
+#define CSR_ACSMSEQ1X9_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS9_LSB				0
+#define CSR_ACSMDDRCS9_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN9_LSB				8
+#define CSR_ACSMSAVEGEN9_MASK				BIT(8)
+#define CSR_ACSMLOADCHK9_LSB				9
+#define CSR_ACSMLOADCHK9_MASK				BIT(9)
+#define CSR_ACSMNORXENB9_LSB				10
+#define CSR_ACSMNORXENB9_MASK				BIT(10)
+#define CSR_ACSMNORXVAL9_LSB				11
+#define CSR_ACSMNORXVAL9_MASK				BIT(11)
+#define CSR_ACSMDDRBNK9_LSB				12
+#define CSR_ACSMDDRBNK9_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X10 */
+#define CSR_ACSMSEQ1X10_LSB				0
+#define CSR_ACSMSEQ1X10_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS10_LSB				0
+#define CSR_ACSMDDRCS10_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN10_LSB				8
+#define CSR_ACSMSAVEGEN10_MASK				BIT(8)
+#define CSR_ACSMLOADCHK10_LSB				9
+#define CSR_ACSMLOADCHK10_MASK				BIT(9)
+#define CSR_ACSMNORXENB10_LSB				10
+#define CSR_ACSMNORXENB10_MASK				BIT(10)
+#define CSR_ACSMNORXVAL10_LSB				11
+#define CSR_ACSMNORXVAL10_MASK				BIT(11)
+#define CSR_ACSMDDRBNK10_LSB				12
+#define CSR_ACSMDDRBNK10_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X11 */
+#define CSR_ACSMSEQ1X11_LSB				0
+#define CSR_ACSMSEQ1X11_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS11_LSB				0
+#define CSR_ACSMDDRCS11_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN11_LSB				8
+#define CSR_ACSMSAVEGEN11_MASK				BIT(8)
+#define CSR_ACSMLOADCHK11_LSB				9
+#define CSR_ACSMLOADCHK11_MASK				BIT(9)
+#define CSR_ACSMNORXENB11_LSB				10
+#define CSR_ACSMNORXENB11_MASK				BIT(10)
+#define CSR_ACSMNORXVAL11_LSB				11
+#define CSR_ACSMNORXVAL11_MASK				BIT(11)
+#define CSR_ACSMDDRBNK11_LSB				12
+#define CSR_ACSMDDRBNK11_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X12 */
+#define CSR_ACSMSEQ1X12_LSB				0
+#define CSR_ACSMSEQ1X12_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS12_LSB				0
+#define CSR_ACSMDDRCS12_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN12_LSB				8
+#define CSR_ACSMSAVEGEN12_MASK				BIT(8)
+#define CSR_ACSMLOADCHK12_LSB				9
+#define CSR_ACSMLOADCHK12_MASK				BIT(9)
+#define CSR_ACSMNORXENB12_LSB				10
+#define CSR_ACSMNORXENB12_MASK				BIT(10)
+#define CSR_ACSMNORXVAL12_LSB				11
+#define CSR_ACSMNORXVAL12_MASK				BIT(11)
+#define CSR_ACSMDDRBNK12_LSB				12
+#define CSR_ACSMDDRBNK12_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X13 */
+#define CSR_ACSMSEQ1X13_LSB				0
+#define CSR_ACSMSEQ1X13_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS13_LSB				0
+#define CSR_ACSMDDRCS13_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN13_LSB				8
+#define CSR_ACSMSAVEGEN13_MASK				BIT(8)
+#define CSR_ACSMLOADCHK13_LSB				9
+#define CSR_ACSMLOADCHK13_MASK				BIT(9)
+#define CSR_ACSMNORXENB13_LSB				10
+#define CSR_ACSMNORXENB13_MASK				BIT(10)
+#define CSR_ACSMNORXVAL13_LSB				11
+#define CSR_ACSMNORXVAL13_MASK				BIT(11)
+#define CSR_ACSMDDRBNK13_LSB				12
+#define CSR_ACSMDDRBNK13_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X14 */
+#define CSR_ACSMSEQ1X14_LSB				0
+#define CSR_ACSMSEQ1X14_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS14_LSB				0
+#define CSR_ACSMDDRCS14_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN14_LSB				8
+#define CSR_ACSMSAVEGEN14_MASK				BIT(8)
+#define CSR_ACSMLOADCHK14_LSB				9
+#define CSR_ACSMLOADCHK14_MASK				BIT(9)
+#define CSR_ACSMNORXENB14_LSB				10
+#define CSR_ACSMNORXENB14_MASK				BIT(10)
+#define CSR_ACSMNORXVAL14_LSB				11
+#define CSR_ACSMNORXVAL14_MASK				BIT(11)
+#define CSR_ACSMDDRBNK14_LSB				12
+#define CSR_ACSMDDRBNK14_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X15 */
+#define CSR_ACSMSEQ1X15_LSB				0
+#define CSR_ACSMSEQ1X15_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS15_LSB				0
+#define CSR_ACSMDDRCS15_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN15_LSB				8
+#define CSR_ACSMSAVEGEN15_MASK				BIT(8)
+#define CSR_ACSMLOADCHK15_LSB				9
+#define CSR_ACSMLOADCHK15_MASK				BIT(9)
+#define CSR_ACSMNORXENB15_LSB				10
+#define CSR_ACSMNORXENB15_MASK				BIT(10)
+#define CSR_ACSMNORXVAL15_LSB				11
+#define CSR_ACSMNORXVAL15_MASK				BIT(11)
+#define CSR_ACSMDDRBNK15_LSB				12
+#define CSR_ACSMDDRBNK15_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X16 */
+#define CSR_ACSMSEQ1X16_LSB				0
+#define CSR_ACSMSEQ1X16_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS16_LSB				0
+#define CSR_ACSMDDRCS16_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN16_LSB				8
+#define CSR_ACSMSAVEGEN16_MASK				BIT(8)
+#define CSR_ACSMLOADCHK16_LSB				9
+#define CSR_ACSMLOADCHK16_MASK				BIT(9)
+#define CSR_ACSMNORXENB16_LSB				10
+#define CSR_ACSMNORXENB16_MASK				BIT(10)
+#define CSR_ACSMNORXVAL16_LSB				11
+#define CSR_ACSMNORXVAL16_MASK				BIT(11)
+#define CSR_ACSMDDRBNK16_LSB				12
+#define CSR_ACSMDDRBNK16_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X17 */
+#define CSR_ACSMSEQ1X17_LSB				0
+#define CSR_ACSMSEQ1X17_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS17_LSB				0
+#define CSR_ACSMDDRCS17_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN17_LSB				8
+#define CSR_ACSMSAVEGEN17_MASK				BIT(8)
+#define CSR_ACSMLOADCHK17_LSB				9
+#define CSR_ACSMLOADCHK17_MASK				BIT(9)
+#define CSR_ACSMNORXENB17_LSB				10
+#define CSR_ACSMNORXENB17_MASK				BIT(10)
+#define CSR_ACSMNORXVAL17_LSB				11
+#define CSR_ACSMNORXVAL17_MASK				BIT(11)
+#define CSR_ACSMDDRBNK17_LSB				12
+#define CSR_ACSMDDRBNK17_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X18 */
+#define CSR_ACSMSEQ1X18_LSB				0
+#define CSR_ACSMSEQ1X18_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS18_LSB				0
+#define CSR_ACSMDDRCS18_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN18_LSB				8
+#define CSR_ACSMSAVEGEN18_MASK				BIT(8)
+#define CSR_ACSMLOADCHK18_LSB				9
+#define CSR_ACSMLOADCHK18_MASK				BIT(9)
+#define CSR_ACSMNORXENB18_LSB				10
+#define CSR_ACSMNORXENB18_MASK				BIT(10)
+#define CSR_ACSMNORXVAL18_LSB				11
+#define CSR_ACSMNORXVAL18_MASK				BIT(11)
+#define CSR_ACSMDDRBNK18_LSB				12
+#define CSR_ACSMDDRBNK18_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X19 */
+#define CSR_ACSMSEQ1X19_LSB				0
+#define CSR_ACSMSEQ1X19_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS19_LSB				0
+#define CSR_ACSMDDRCS19_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN19_LSB				8
+#define CSR_ACSMSAVEGEN19_MASK				BIT(8)
+#define CSR_ACSMLOADCHK19_LSB				9
+#define CSR_ACSMLOADCHK19_MASK				BIT(9)
+#define CSR_ACSMNORXENB19_LSB				10
+#define CSR_ACSMNORXENB19_MASK				BIT(10)
+#define CSR_ACSMNORXVAL19_LSB				11
+#define CSR_ACSMNORXVAL19_MASK				BIT(11)
+#define CSR_ACSMDDRBNK19_LSB				12
+#define CSR_ACSMDDRBNK19_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X20 */
+#define CSR_ACSMSEQ1X20_LSB				0
+#define CSR_ACSMSEQ1X20_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS20_LSB				0
+#define CSR_ACSMDDRCS20_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN20_LSB				8
+#define CSR_ACSMSAVEGEN20_MASK				BIT(8)
+#define CSR_ACSMLOADCHK20_LSB				9
+#define CSR_ACSMLOADCHK20_MASK				BIT(9)
+#define CSR_ACSMNORXENB20_LSB				10
+#define CSR_ACSMNORXENB20_MASK				BIT(10)
+#define CSR_ACSMNORXVAL20_LSB				11
+#define CSR_ACSMNORXVAL20_MASK				BIT(11)
+#define CSR_ACSMDDRBNK20_LSB				12
+#define CSR_ACSMDDRBNK20_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X21 */
+#define CSR_ACSMSEQ1X21_LSB				0
+#define CSR_ACSMSEQ1X21_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS21_LSB				0
+#define CSR_ACSMDDRCS21_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN21_LSB				8
+#define CSR_ACSMSAVEGEN21_MASK				BIT(8)
+#define CSR_ACSMLOADCHK21_LSB				9
+#define CSR_ACSMLOADCHK21_MASK				BIT(9)
+#define CSR_ACSMNORXENB21_LSB				10
+#define CSR_ACSMNORXENB21_MASK				BIT(10)
+#define CSR_ACSMNORXVAL21_LSB				11
+#define CSR_ACSMNORXVAL21_MASK				BIT(11)
+#define CSR_ACSMDDRBNK21_LSB				12
+#define CSR_ACSMDDRBNK21_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X22 */
+#define CSR_ACSMSEQ1X22_LSB				0
+#define CSR_ACSMSEQ1X22_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS22_LSB				0
+#define CSR_ACSMDDRCS22_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN22_LSB				8
+#define CSR_ACSMSAVEGEN22_MASK				BIT(8)
+#define CSR_ACSMLOADCHK22_LSB				9
+#define CSR_ACSMLOADCHK22_MASK				BIT(9)
+#define CSR_ACSMNORXENB22_LSB				10
+#define CSR_ACSMNORXENB22_MASK				BIT(10)
+#define CSR_ACSMNORXVAL22_LSB				11
+#define CSR_ACSMNORXVAL22_MASK				BIT(11)
+#define CSR_ACSMDDRBNK22_LSB				12
+#define CSR_ACSMDDRBNK22_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X23 */
+#define CSR_ACSMSEQ1X23_LSB				0
+#define CSR_ACSMSEQ1X23_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS23_LSB				0
+#define CSR_ACSMDDRCS23_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN23_LSB				8
+#define CSR_ACSMSAVEGEN23_MASK				BIT(8)
+#define CSR_ACSMLOADCHK23_LSB				9
+#define CSR_ACSMLOADCHK23_MASK				BIT(9)
+#define CSR_ACSMNORXENB23_LSB				10
+#define CSR_ACSMNORXENB23_MASK				BIT(10)
+#define CSR_ACSMNORXVAL23_LSB				11
+#define CSR_ACSMNORXVAL23_MASK				BIT(11)
+#define CSR_ACSMDDRBNK23_LSB				12
+#define CSR_ACSMDDRBNK23_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X24 */
+#define CSR_ACSMSEQ1X24_LSB				0
+#define CSR_ACSMSEQ1X24_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS24_LSB				0
+#define CSR_ACSMDDRCS24_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN24_LSB				8
+#define CSR_ACSMSAVEGEN24_MASK				BIT(8)
+#define CSR_ACSMLOADCHK24_LSB				9
+#define CSR_ACSMLOADCHK24_MASK				BIT(9)
+#define CSR_ACSMNORXENB24_LSB				10
+#define CSR_ACSMNORXENB24_MASK				BIT(10)
+#define CSR_ACSMNORXVAL24_LSB				11
+#define CSR_ACSMNORXVAL24_MASK				BIT(11)
+#define CSR_ACSMDDRBNK24_LSB				12
+#define CSR_ACSMDDRBNK24_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X25 */
+#define CSR_ACSMSEQ1X25_LSB				0
+#define CSR_ACSMSEQ1X25_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS25_LSB				0
+#define CSR_ACSMDDRCS25_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN25_LSB				8
+#define CSR_ACSMSAVEGEN25_MASK				BIT(8)
+#define CSR_ACSMLOADCHK25_LSB				9
+#define CSR_ACSMLOADCHK25_MASK				BIT(9)
+#define CSR_ACSMNORXENB25_LSB				10
+#define CSR_ACSMNORXENB25_MASK				BIT(10)
+#define CSR_ACSMNORXVAL25_LSB				11
+#define CSR_ACSMNORXVAL25_MASK				BIT(11)
+#define CSR_ACSMDDRBNK25_LSB				12
+#define CSR_ACSMDDRBNK25_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X26 */
+#define CSR_ACSMSEQ1X26_LSB				0
+#define CSR_ACSMSEQ1X26_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS26_LSB				0
+#define CSR_ACSMDDRCS26_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN26_LSB				8
+#define CSR_ACSMSAVEGEN26_MASK				BIT(8)
+#define CSR_ACSMLOADCHK26_LSB				9
+#define CSR_ACSMLOADCHK26_MASK				BIT(9)
+#define CSR_ACSMNORXENB26_LSB				10
+#define CSR_ACSMNORXENB26_MASK				BIT(10)
+#define CSR_ACSMNORXVAL26_LSB				11
+#define CSR_ACSMNORXVAL26_MASK				BIT(11)
+#define CSR_ACSMDDRBNK26_LSB				12
+#define CSR_ACSMDDRBNK26_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X27 */
+#define CSR_ACSMSEQ1X27_LSB				0
+#define CSR_ACSMSEQ1X27_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS27_LSB				0
+#define CSR_ACSMDDRCS27_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN27_LSB				8
+#define CSR_ACSMSAVEGEN27_MASK				BIT(8)
+#define CSR_ACSMLOADCHK27_LSB				9
+#define CSR_ACSMLOADCHK27_MASK				BIT(9)
+#define CSR_ACSMNORXENB27_LSB				10
+#define CSR_ACSMNORXENB27_MASK				BIT(10)
+#define CSR_ACSMNORXVAL27_LSB				11
+#define CSR_ACSMNORXVAL27_MASK				BIT(11)
+#define CSR_ACSMDDRBNK27_LSB				12
+#define CSR_ACSMDDRBNK27_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X28 */
+#define CSR_ACSMSEQ1X28_LSB				0
+#define CSR_ACSMSEQ1X28_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS28_LSB				0
+#define CSR_ACSMDDRCS28_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN28_LSB				8
+#define CSR_ACSMSAVEGEN28_MASK				BIT(8)
+#define CSR_ACSMLOADCHK28_LSB				9
+#define CSR_ACSMLOADCHK28_MASK				BIT(9)
+#define CSR_ACSMNORXENB28_LSB				10
+#define CSR_ACSMNORXENB28_MASK				BIT(10)
+#define CSR_ACSMNORXVAL28_LSB				11
+#define CSR_ACSMNORXVAL28_MASK				BIT(11)
+#define CSR_ACSMDDRBNK28_LSB				12
+#define CSR_ACSMDDRBNK28_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X29 */
+#define CSR_ACSMSEQ1X29_LSB				0
+#define CSR_ACSMSEQ1X29_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS29_LSB				0
+#define CSR_ACSMDDRCS29_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN29_LSB				8
+#define CSR_ACSMSAVEGEN29_MASK				BIT(8)
+#define CSR_ACSMLOADCHK29_LSB				9
+#define CSR_ACSMLOADCHK29_MASK				BIT(9)
+#define CSR_ACSMNORXENB29_LSB				10
+#define CSR_ACSMNORXENB29_MASK				BIT(10)
+#define CSR_ACSMNORXVAL29_LSB				11
+#define CSR_ACSMNORXVAL29_MASK				BIT(11)
+#define CSR_ACSMDDRBNK29_LSB				12
+#define CSR_ACSMDDRBNK29_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X30 */
+#define CSR_ACSMSEQ1X30_LSB				0
+#define CSR_ACSMSEQ1X30_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS30_LSB				0
+#define CSR_ACSMDDRCS30_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN30_LSB				8
+#define CSR_ACSMSAVEGEN30_MASK				BIT(8)
+#define CSR_ACSMLOADCHK30_LSB				9
+#define CSR_ACSMLOADCHK30_MASK				BIT(9)
+#define CSR_ACSMNORXENB30_LSB				10
+#define CSR_ACSMNORXENB30_MASK				BIT(10)
+#define CSR_ACSMNORXVAL30_LSB				11
+#define CSR_ACSMNORXVAL30_MASK				BIT(11)
+#define CSR_ACSMDDRBNK30_LSB				12
+#define CSR_ACSMDDRBNK30_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X31 */
+#define CSR_ACSMSEQ1X31_LSB				0
+#define CSR_ACSMSEQ1X31_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS31_LSB				0
+#define CSR_ACSMDDRCS31_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN31_LSB				8
+#define CSR_ACSMSAVEGEN31_MASK				BIT(8)
+#define CSR_ACSMLOADCHK31_LSB				9
+#define CSR_ACSMLOADCHK31_MASK				BIT(9)
+#define CSR_ACSMNORXENB31_LSB				10
+#define CSR_ACSMNORXENB31_MASK				BIT(10)
+#define CSR_ACSMNORXVAL31_LSB				11
+#define CSR_ACSMNORXVAL31_MASK				BIT(11)
+#define CSR_ACSMDDRBNK31_LSB				12
+#define CSR_ACSMDDRBNK31_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ2X0 */
+#define CSR_ACSMSEQ2X0_LSB				0
+#define CSR_ACSMSEQ2X0_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X0_LSB			0
+#define CSR_ACSMDDRADRX15X0X0_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X1 */
+#define CSR_ACSMSEQ2X1_LSB				0
+#define CSR_ACSMSEQ2X1_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X1_LSB			0
+#define CSR_ACSMDDRADRX15X0X1_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X2 */
+#define CSR_ACSMSEQ2X2_LSB				0
+#define CSR_ACSMSEQ2X2_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X2_LSB			0
+#define CSR_ACSMDDRADRX15X0X2_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X3 */
+#define CSR_ACSMSEQ2X3_LSB				0
+#define CSR_ACSMSEQ2X3_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X3_LSB			0
+#define CSR_ACSMDDRADRX15X0X3_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X4 */
+#define CSR_ACSMSEQ2X4_LSB				0
+#define CSR_ACSMSEQ2X4_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X4_LSB			0
+#define CSR_ACSMDDRADRX15X0X4_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X5 */
+#define CSR_ACSMSEQ2X5_LSB				0
+#define CSR_ACSMSEQ2X5_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X5_LSB			0
+#define CSR_ACSMDDRADRX15X0X5_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X6 */
+#define CSR_ACSMSEQ2X6_LSB				0
+#define CSR_ACSMSEQ2X6_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X6_LSB			0
+#define CSR_ACSMDDRADRX15X0X6_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X7 */
+#define CSR_ACSMSEQ2X7_LSB				0
+#define CSR_ACSMSEQ2X7_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X7_LSB			0
+#define CSR_ACSMDDRADRX15X0X7_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X8 */
+#define CSR_ACSMSEQ2X8_LSB				0
+#define CSR_ACSMSEQ2X8_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X8_LSB			0
+#define CSR_ACSMDDRADRX15X0X8_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X9 */
+#define CSR_ACSMSEQ2X9_LSB				0
+#define CSR_ACSMSEQ2X9_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X9_LSB			0
+#define CSR_ACSMDDRADRX15X0X9_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X10 */
+#define CSR_ACSMSEQ2X10_LSB				0
+#define CSR_ACSMSEQ2X10_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X10_LSB			0
+#define CSR_ACSMDDRADRX15X0X10_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X11 */
+#define CSR_ACSMSEQ2X11_LSB				0
+#define CSR_ACSMSEQ2X11_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X11_LSB			0
+#define CSR_ACSMDDRADRX15X0X11_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X12 */
+#define CSR_ACSMSEQ2X12_LSB				0
+#define CSR_ACSMSEQ2X12_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X12_LSB			0
+#define CSR_ACSMDDRADRX15X0X12_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X13 */
+#define CSR_ACSMSEQ2X13_LSB				0
+#define CSR_ACSMSEQ2X13_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X13_LSB			0
+#define CSR_ACSMDDRADRX15X0X13_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X14 */
+#define CSR_ACSMSEQ2X14_LSB				0
+#define CSR_ACSMSEQ2X14_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X14_LSB			0
+#define CSR_ACSMDDRADRX15X0X14_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X15 */
+#define CSR_ACSMSEQ2X15_LSB				0
+#define CSR_ACSMSEQ2X15_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X15_LSB			0
+#define CSR_ACSMDDRADRX15X0X15_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X16 */
+#define CSR_ACSMSEQ2X16_LSB				0
+#define CSR_ACSMSEQ2X16_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X16_LSB			0
+#define CSR_ACSMDDRADRX15X0X16_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X17 */
+#define CSR_ACSMSEQ2X17_LSB				0
+#define CSR_ACSMSEQ2X17_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X17_LSB			0
+#define CSR_ACSMDDRADRX15X0X17_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X18 */
+#define CSR_ACSMSEQ2X18_LSB				0
+#define CSR_ACSMSEQ2X18_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X18_LSB			0
+#define CSR_ACSMDDRADRX15X0X18_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X19 */
+#define CSR_ACSMSEQ2X19_LSB				0
+#define CSR_ACSMSEQ2X19_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X19_LSB			0
+#define CSR_ACSMDDRADRX15X0X19_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X20 */
+#define CSR_ACSMSEQ2X20_LSB				0
+#define CSR_ACSMSEQ2X20_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X20_LSB			0
+#define CSR_ACSMDDRADRX15X0X20_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X21 */
+#define CSR_ACSMSEQ2X21_LSB				0
+#define CSR_ACSMSEQ2X21_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X21_LSB			0
+#define CSR_ACSMDDRADRX15X0X21_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X22 */
+#define CSR_ACSMSEQ2X22_LSB				0
+#define CSR_ACSMSEQ2X22_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X22_LSB			0
+#define CSR_ACSMDDRADRX15X0X22_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X23 */
+#define CSR_ACSMSEQ2X23_LSB				0
+#define CSR_ACSMSEQ2X23_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X23_LSB			0
+#define CSR_ACSMDDRADRX15X0X23_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X24 */
+#define CSR_ACSMSEQ2X24_LSB				0
+#define CSR_ACSMSEQ2X24_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X24_LSB			0
+#define CSR_ACSMDDRADRX15X0X24_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X25 */
+#define CSR_ACSMSEQ2X25_LSB				0
+#define CSR_ACSMSEQ2X25_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X25_LSB			0
+#define CSR_ACSMDDRADRX15X0X25_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X26 */
+#define CSR_ACSMSEQ2X26_LSB				0
+#define CSR_ACSMSEQ2X26_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X26_LSB			0
+#define CSR_ACSMDDRADRX15X0X26_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X27 */
+#define CSR_ACSMSEQ2X27_LSB				0
+#define CSR_ACSMSEQ2X27_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X27_LSB			0
+#define CSR_ACSMDDRADRX15X0X27_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X28 */
+#define CSR_ACSMSEQ2X28_LSB				0
+#define CSR_ACSMSEQ2X28_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X28_LSB			0
+#define CSR_ACSMDDRADRX15X0X28_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X29 */
+#define CSR_ACSMSEQ2X29_LSB				0
+#define CSR_ACSMSEQ2X29_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X29_LSB			0
+#define CSR_ACSMDDRADRX15X0X29_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X30 */
+#define CSR_ACSMSEQ2X30_LSB				0
+#define CSR_ACSMSEQ2X30_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X30_LSB			0
+#define CSR_ACSMDDRADRX15X0X30_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X31 */
+#define CSR_ACSMSEQ2X31_LSB				0
+#define CSR_ACSMSEQ2X31_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X31_LSB			0
+#define CSR_ACSMDDRADRX15X0X31_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ3X0 */
+#define CSR_ACSMSEQ3X0_LSB				0
+#define CSR_ACSMSEQ3X0_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT0_LSB				0
+#define CSR_ACSMCMDREPCNT0_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV0_LSB				8
+#define CSR_ACSMADRADV0_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV0_LSB				10
+#define CSR_ACSMBNKADV0_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD0_LSB				12
+#define CSR_ACSMADRSELLOAD0_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD0_LSB				14
+#define CSR_ACSMBNKSELLOAD0_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE0_LSB				15
+#define CSR_ACSMLONGBUBBLE0_MASK			BIT(15)
+/* CSR_ACSMSEQ3X1 */
+#define CSR_ACSMSEQ3X1_LSB				0
+#define CSR_ACSMSEQ3X1_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT1_LSB				0
+#define CSR_ACSMCMDREPCNT1_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV1_LSB				8
+#define CSR_ACSMADRADV1_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV1_LSB				10
+#define CSR_ACSMBNKADV1_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD1_LSB				12
+#define CSR_ACSMADRSELLOAD1_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD1_LSB				14
+#define CSR_ACSMBNKSELLOAD1_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE1_LSB				15
+#define CSR_ACSMLONGBUBBLE1_MASK			BIT(15)
+/* CSR_ACSMSEQ3X2 */
+#define CSR_ACSMSEQ3X2_LSB				0
+#define CSR_ACSMSEQ3X2_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT2_LSB				0
+#define CSR_ACSMCMDREPCNT2_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV2_LSB				8
+#define CSR_ACSMADRADV2_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV2_LSB				10
+#define CSR_ACSMBNKADV2_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD2_LSB				12
+#define CSR_ACSMADRSELLOAD2_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD2_LSB				14
+#define CSR_ACSMBNKSELLOAD2_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE2_LSB				15
+#define CSR_ACSMLONGBUBBLE2_MASK			BIT(15)
+/* CSR_ACSMSEQ3X3 */
+#define CSR_ACSMSEQ3X3_LSB				0
+#define CSR_ACSMSEQ3X3_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT3_LSB				0
+#define CSR_ACSMCMDREPCNT3_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV3_LSB				8
+#define CSR_ACSMADRADV3_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV3_LSB				10
+#define CSR_ACSMBNKADV3_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD3_LSB				12
+#define CSR_ACSMADRSELLOAD3_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD3_LSB				14
+#define CSR_ACSMBNKSELLOAD3_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE3_LSB				15
+#define CSR_ACSMLONGBUBBLE3_MASK			BIT(15)
+/* CSR_ACSMSEQ3X4 */
+#define CSR_ACSMSEQ3X4_LSB				0
+#define CSR_ACSMSEQ3X4_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT4_LSB				0
+#define CSR_ACSMCMDREPCNT4_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV4_LSB				8
+#define CSR_ACSMADRADV4_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV4_LSB				10
+#define CSR_ACSMBNKADV4_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD4_LSB				12
+#define CSR_ACSMADRSELLOAD4_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD4_LSB				14
+#define CSR_ACSMBNKSELLOAD4_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE4_LSB				15
+#define CSR_ACSMLONGBUBBLE4_MASK			BIT(15)
+/* CSR_ACSMSEQ3X5 */
+#define CSR_ACSMSEQ3X5_LSB				0
+#define CSR_ACSMSEQ3X5_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT5_LSB				0
+#define CSR_ACSMCMDREPCNT5_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV5_LSB				8
+#define CSR_ACSMADRADV5_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV5_LSB				10
+#define CSR_ACSMBNKADV5_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD5_LSB				12
+#define CSR_ACSMADRSELLOAD5_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD5_LSB				14
+#define CSR_ACSMBNKSELLOAD5_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE5_LSB				15
+#define CSR_ACSMLONGBUBBLE5_MASK			BIT(15)
+/* CSR_ACSMSEQ3X6 */
+#define CSR_ACSMSEQ3X6_LSB				0
+#define CSR_ACSMSEQ3X6_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT6_LSB				0
+#define CSR_ACSMCMDREPCNT6_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV6_LSB				8
+#define CSR_ACSMADRADV6_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV6_LSB				10
+#define CSR_ACSMBNKADV6_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD6_LSB				12
+#define CSR_ACSMADRSELLOAD6_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD6_LSB				14
+#define CSR_ACSMBNKSELLOAD6_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE6_LSB				15
+#define CSR_ACSMLONGBUBBLE6_MASK			BIT(15)
+/* CSR_ACSMSEQ3X7 */
+#define CSR_ACSMSEQ3X7_LSB				0
+#define CSR_ACSMSEQ3X7_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT7_LSB				0
+#define CSR_ACSMCMDREPCNT7_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV7_LSB				8
+#define CSR_ACSMADRADV7_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV7_LSB				10
+#define CSR_ACSMBNKADV7_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD7_LSB				12
+#define CSR_ACSMADRSELLOAD7_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD7_LSB				14
+#define CSR_ACSMBNKSELLOAD7_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE7_LSB				15
+#define CSR_ACSMLONGBUBBLE7_MASK			BIT(15)
+/* CSR_ACSMSEQ3X8 */
+#define CSR_ACSMSEQ3X8_LSB				0
+#define CSR_ACSMSEQ3X8_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT8_LSB				0
+#define CSR_ACSMCMDREPCNT8_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV8_LSB				8
+#define CSR_ACSMADRADV8_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV8_LSB				10
+#define CSR_ACSMBNKADV8_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD8_LSB				12
+#define CSR_ACSMADRSELLOAD8_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD8_LSB				14
+#define CSR_ACSMBNKSELLOAD8_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE8_LSB				15
+#define CSR_ACSMLONGBUBBLE8_MASK			BIT(15)
+/* CSR_ACSMSEQ3X9 */
+#define CSR_ACSMSEQ3X9_LSB				0
+#define CSR_ACSMSEQ3X9_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT9_LSB				0
+#define CSR_ACSMCMDREPCNT9_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV9_LSB				8
+#define CSR_ACSMADRADV9_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV9_LSB				10
+#define CSR_ACSMBNKADV9_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD9_LSB				12
+#define CSR_ACSMADRSELLOAD9_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD9_LSB				14
+#define CSR_ACSMBNKSELLOAD9_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE9_LSB				15
+#define CSR_ACSMLONGBUBBLE9_MASK			BIT(15)
+/* CSR_ACSMSEQ3X10 */
+#define CSR_ACSMSEQ3X10_LSB				0
+#define CSR_ACSMSEQ3X10_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT10_LSB				0
+#define CSR_ACSMCMDREPCNT10_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV10_LSB				8
+#define CSR_ACSMADRADV10_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV10_LSB				10
+#define CSR_ACSMBNKADV10_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD10_LSB			12
+#define CSR_ACSMADRSELLOAD10_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD10_LSB			14
+#define CSR_ACSMBNKSELLOAD10_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE10_LSB			15
+#define CSR_ACSMLONGBUBBLE10_MASK			BIT(15)
+/* CSR_ACSMSEQ3X11 */
+#define CSR_ACSMSEQ3X11_LSB				0
+#define CSR_ACSMSEQ3X11_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT11_LSB				0
+#define CSR_ACSMCMDREPCNT11_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV11_LSB				8
+#define CSR_ACSMADRADV11_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV11_LSB				10
+#define CSR_ACSMBNKADV11_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD11_LSB			12
+#define CSR_ACSMADRSELLOAD11_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD11_LSB			14
+#define CSR_ACSMBNKSELLOAD11_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE11_LSB			15
+#define CSR_ACSMLONGBUBBLE11_MASK			BIT(15)
+/* CSR_ACSMSEQ3X12 */
+#define CSR_ACSMSEQ3X12_LSB				0
+#define CSR_ACSMSEQ3X12_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT12_LSB				0
+#define CSR_ACSMCMDREPCNT12_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV12_LSB				8
+#define CSR_ACSMADRADV12_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV12_LSB				10
+#define CSR_ACSMBNKADV12_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD12_LSB			12
+#define CSR_ACSMADRSELLOAD12_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD12_LSB			14
+#define CSR_ACSMBNKSELLOAD12_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE12_LSB			15
+#define CSR_ACSMLONGBUBBLE12_MASK			BIT(15)
+/* CSR_ACSMSEQ3X13 */
+#define CSR_ACSMSEQ3X13_LSB				0
+#define CSR_ACSMSEQ3X13_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT13_LSB				0
+#define CSR_ACSMCMDREPCNT13_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV13_LSB				8
+#define CSR_ACSMADRADV13_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV13_LSB				10
+#define CSR_ACSMBNKADV13_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD13_LSB			12
+#define CSR_ACSMADRSELLOAD13_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD13_LSB			14
+#define CSR_ACSMBNKSELLOAD13_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE13_LSB			15
+#define CSR_ACSMLONGBUBBLE13_MASK			BIT(15)
+/* CSR_ACSMSEQ3X14 */
+#define CSR_ACSMSEQ3X14_LSB				0
+#define CSR_ACSMSEQ3X14_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT14_LSB				0
+#define CSR_ACSMCMDREPCNT14_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV14_LSB				8
+#define CSR_ACSMADRADV14_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV14_LSB				10
+#define CSR_ACSMBNKADV14_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD14_LSB			12
+#define CSR_ACSMADRSELLOAD14_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD14_LSB			14
+#define CSR_ACSMBNKSELLOAD14_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE14_LSB			15
+#define CSR_ACSMLONGBUBBLE14_MASK			BIT(15)
+/* CSR_ACSMSEQ3X15 */
+#define CSR_ACSMSEQ3X15_LSB				0
+#define CSR_ACSMSEQ3X15_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT15_LSB				0
+#define CSR_ACSMCMDREPCNT15_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV15_LSB				8
+#define CSR_ACSMADRADV15_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV15_LSB				10
+#define CSR_ACSMBNKADV15_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD15_LSB			12
+#define CSR_ACSMADRSELLOAD15_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD15_LSB			14
+#define CSR_ACSMBNKSELLOAD15_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE15_LSB			15
+#define CSR_ACSMLONGBUBBLE15_MASK			BIT(15)
+/* CSR_ACSMSEQ3X16 */
+#define CSR_ACSMSEQ3X16_LSB				0
+#define CSR_ACSMSEQ3X16_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT16_LSB				0
+#define CSR_ACSMCMDREPCNT16_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV16_LSB				8
+#define CSR_ACSMADRADV16_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV16_LSB				10
+#define CSR_ACSMBNKADV16_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD16_LSB			12
+#define CSR_ACSMADRSELLOAD16_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD16_LSB			14
+#define CSR_ACSMBNKSELLOAD16_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE16_LSB			15
+#define CSR_ACSMLONGBUBBLE16_MASK			BIT(15)
+/* CSR_ACSMSEQ3X17 */
+#define CSR_ACSMSEQ3X17_LSB				0
+#define CSR_ACSMSEQ3X17_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT17_LSB				0
+#define CSR_ACSMCMDREPCNT17_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV17_LSB				8
+#define CSR_ACSMADRADV17_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV17_LSB				10
+#define CSR_ACSMBNKADV17_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD17_LSB			12
+#define CSR_ACSMADRSELLOAD17_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD17_LSB			14
+#define CSR_ACSMBNKSELLOAD17_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE17_LSB			15
+#define CSR_ACSMLONGBUBBLE17_MASK			BIT(15)
+/* CSR_ACSMSEQ3X18 */
+#define CSR_ACSMSEQ3X18_LSB				0
+#define CSR_ACSMSEQ3X18_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT18_LSB				0
+#define CSR_ACSMCMDREPCNT18_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV18_LSB				8
+#define CSR_ACSMADRADV18_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV18_LSB				10
+#define CSR_ACSMBNKADV18_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD18_LSB			12
+#define CSR_ACSMADRSELLOAD18_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD18_LSB			14
+#define CSR_ACSMBNKSELLOAD18_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE18_LSB			15
+#define CSR_ACSMLONGBUBBLE18_MASK			BIT(15)
+/* CSR_ACSMSEQ3X19 */
+#define CSR_ACSMSEQ3X19_LSB				0
+#define CSR_ACSMSEQ3X19_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT19_LSB				0
+#define CSR_ACSMCMDREPCNT19_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV19_LSB				8
+#define CSR_ACSMADRADV19_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV19_LSB				10
+#define CSR_ACSMBNKADV19_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD19_LSB			12
+#define CSR_ACSMADRSELLOAD19_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD19_LSB			14
+#define CSR_ACSMBNKSELLOAD19_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE19_LSB			15
+#define CSR_ACSMLONGBUBBLE19_MASK			BIT(15)
+/* CSR_ACSMSEQ3X20 */
+#define CSR_ACSMSEQ3X20_LSB				0
+#define CSR_ACSMSEQ3X20_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT20_LSB				0
+#define CSR_ACSMCMDREPCNT20_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV20_LSB				8
+#define CSR_ACSMADRADV20_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV20_LSB				10
+#define CSR_ACSMBNKADV20_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD20_LSB			12
+#define CSR_ACSMADRSELLOAD20_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD20_LSB			14
+#define CSR_ACSMBNKSELLOAD20_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE20_LSB			15
+#define CSR_ACSMLONGBUBBLE20_MASK			BIT(15)
+/* CSR_ACSMSEQ3X21 */
+#define CSR_ACSMSEQ3X21_LSB				0
+#define CSR_ACSMSEQ3X21_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT21_LSB				0
+#define CSR_ACSMCMDREPCNT21_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV21_LSB				8
+#define CSR_ACSMADRADV21_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV21_LSB				10
+#define CSR_ACSMBNKADV21_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD21_LSB			12
+#define CSR_ACSMADRSELLOAD21_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD21_LSB			14
+#define CSR_ACSMBNKSELLOAD21_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE21_LSB			15
+#define CSR_ACSMLONGBUBBLE21_MASK			BIT(15)
+/* CSR_ACSMSEQ3X22 */
+#define CSR_ACSMSEQ3X22_LSB				0
+#define CSR_ACSMSEQ3X22_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT22_LSB				0
+#define CSR_ACSMCMDREPCNT22_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV22_LSB				8
+#define CSR_ACSMADRADV22_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV22_LSB				10
+#define CSR_ACSMBNKADV22_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD22_LSB			12
+#define CSR_ACSMADRSELLOAD22_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD22_LSB			14
+#define CSR_ACSMBNKSELLOAD22_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE22_LSB			15
+#define CSR_ACSMLONGBUBBLE22_MASK			BIT(15)
+/* CSR_ACSMSEQ3X23 */
+#define CSR_ACSMSEQ3X23_LSB				0
+#define CSR_ACSMSEQ3X23_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT23_LSB				0
+#define CSR_ACSMCMDREPCNT23_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV23_LSB				8
+#define CSR_ACSMADRADV23_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV23_LSB				10
+#define CSR_ACSMBNKADV23_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD23_LSB			12
+#define CSR_ACSMADRSELLOAD23_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD23_LSB			14
+#define CSR_ACSMBNKSELLOAD23_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE23_LSB			15
+#define CSR_ACSMLONGBUBBLE23_MASK			BIT(15)
+/* CSR_ACSMSEQ3X24 */
+#define CSR_ACSMSEQ3X24_LSB				0
+#define CSR_ACSMSEQ3X24_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT24_LSB				0
+#define CSR_ACSMCMDREPCNT24_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV24_LSB				8
+#define CSR_ACSMADRADV24_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV24_LSB				10
+#define CSR_ACSMBNKADV24_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD24_LSB			12
+#define CSR_ACSMADRSELLOAD24_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD24_LSB			14
+#define CSR_ACSMBNKSELLOAD24_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE24_LSB			15
+#define CSR_ACSMLONGBUBBLE24_MASK			BIT(15)
+/* CSR_ACSMSEQ3X25 */
+#define CSR_ACSMSEQ3X25_LSB				0
+#define CSR_ACSMSEQ3X25_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT25_LSB				0
+#define CSR_ACSMCMDREPCNT25_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV25_LSB				8
+#define CSR_ACSMADRADV25_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV25_LSB				10
+#define CSR_ACSMBNKADV25_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD25_LSB			12
+#define CSR_ACSMADRSELLOAD25_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD25_LSB			14
+#define CSR_ACSMBNKSELLOAD25_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE25_LSB			15
+#define CSR_ACSMLONGBUBBLE25_MASK			BIT(15)
+/* CSR_ACSMSEQ3X26 */
+#define CSR_ACSMSEQ3X26_LSB				0
+#define CSR_ACSMSEQ3X26_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT26_LSB				0
+#define CSR_ACSMCMDREPCNT26_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV26_LSB				8
+#define CSR_ACSMADRADV26_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV26_LSB				10
+#define CSR_ACSMBNKADV26_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD26_LSB			12
+#define CSR_ACSMADRSELLOAD26_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD26_LSB			14
+#define CSR_ACSMBNKSELLOAD26_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE26_LSB			15
+#define CSR_ACSMLONGBUBBLE26_MASK			BIT(15)
+/* CSR_ACSMSEQ3X27 */
+#define CSR_ACSMSEQ3X27_LSB				0
+#define CSR_ACSMSEQ3X27_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT27_LSB				0
+#define CSR_ACSMCMDREPCNT27_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV27_LSB				8
+#define CSR_ACSMADRADV27_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV27_LSB				10
+#define CSR_ACSMBNKADV27_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD27_LSB			12
+#define CSR_ACSMADRSELLOAD27_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD27_LSB			14
+#define CSR_ACSMBNKSELLOAD27_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE27_LSB			15
+#define CSR_ACSMLONGBUBBLE27_MASK			BIT(15)
+/* CSR_ACSMSEQ3X28 */
+#define CSR_ACSMSEQ3X28_LSB				0
+#define CSR_ACSMSEQ3X28_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT28_LSB				0
+#define CSR_ACSMCMDREPCNT28_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV28_LSB				8
+#define CSR_ACSMADRADV28_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV28_LSB				10
+#define CSR_ACSMBNKADV28_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD28_LSB			12
+#define CSR_ACSMADRSELLOAD28_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD28_LSB			14
+#define CSR_ACSMBNKSELLOAD28_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE28_LSB			15
+#define CSR_ACSMLONGBUBBLE28_MASK			BIT(15)
+/* CSR_ACSMSEQ3X29 */
+#define CSR_ACSMSEQ3X29_LSB				0
+#define CSR_ACSMSEQ3X29_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT29_LSB				0
+#define CSR_ACSMCMDREPCNT29_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV29_LSB				8
+#define CSR_ACSMADRADV29_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV29_LSB				10
+#define CSR_ACSMBNKADV29_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD29_LSB			12
+#define CSR_ACSMADRSELLOAD29_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD29_LSB			14
+#define CSR_ACSMBNKSELLOAD29_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE29_LSB			15
+#define CSR_ACSMLONGBUBBLE29_MASK			BIT(15)
+/* CSR_ACSMSEQ3X30 */
+#define CSR_ACSMSEQ3X30_LSB				0
+#define CSR_ACSMSEQ3X30_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT30_LSB				0
+#define CSR_ACSMCMDREPCNT30_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV30_LSB				8
+#define CSR_ACSMADRADV30_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV30_LSB				10
+#define CSR_ACSMBNKADV30_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD30_LSB			12
+#define CSR_ACSMADRSELLOAD30_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD30_LSB			14
+#define CSR_ACSMBNKSELLOAD30_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE30_LSB			15
+#define CSR_ACSMLONGBUBBLE30_MASK			BIT(15)
+/* CSR_ACSMSEQ3X31 */
+#define CSR_ACSMSEQ3X31_LSB				0
+#define CSR_ACSMSEQ3X31_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT31_LSB				0
+#define CSR_ACSMCMDREPCNT31_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV31_LSB				8
+#define CSR_ACSMADRADV31_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV31_LSB				10
+#define CSR_ACSMBNKADV31_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD31_LSB			12
+#define CSR_ACSMADRSELLOAD31_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD31_LSB			14
+#define CSR_ACSMBNKSELLOAD31_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE31_LSB			15
+#define CSR_ACSMLONGBUBBLE31_MASK			BIT(15)
+/* CSR_ACSMPLAYBACK0X0 */
+#define CSR_ACSMPLAYBACK0X0_LSB				0
+#define CSR_ACSMPLAYBACK0X0_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK1X0 */
+#define CSR_ACSMPLAYBACK1X0_LSB				0
+#define CSR_ACSMPLAYBACK1X0_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK0X1 */
+#define CSR_ACSMPLAYBACK0X1_LSB				0
+#define CSR_ACSMPLAYBACK0X1_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK1X1 */
+#define CSR_ACSMPLAYBACK1X1_LSB				0
+#define CSR_ACSMPLAYBACK1X1_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK0X2 */
+#define CSR_ACSMPLAYBACK0X2_LSB				0
+#define CSR_ACSMPLAYBACK0X2_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK1X2 */
+#define CSR_ACSMPLAYBACK1X2_LSB				0
+#define CSR_ACSMPLAYBACK1X2_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK0X3 */
+#define CSR_ACSMPLAYBACK0X3_LSB				0
+#define CSR_ACSMPLAYBACK0X3_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK1X3 */
+#define CSR_ACSMPLAYBACK1X3_LSB				0
+#define CSR_ACSMPLAYBACK1X3_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK0X4 */
+#define CSR_ACSMPLAYBACK0X4_LSB				0
+#define CSR_ACSMPLAYBACK0X4_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK1X4 */
+#define CSR_ACSMPLAYBACK1X4_LSB				0
+#define CSR_ACSMPLAYBACK1X4_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK0X5 */
+#define CSR_ACSMPLAYBACK0X5_LSB				0
+#define CSR_ACSMPLAYBACK0X5_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK1X5 */
+#define CSR_ACSMPLAYBACK1X5_LSB				0
+#define CSR_ACSMPLAYBACK1X5_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK0X6 */
+#define CSR_ACSMPLAYBACK0X6_LSB				0
+#define CSR_ACSMPLAYBACK0X6_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK1X6 */
+#define CSR_ACSMPLAYBACK1X6_LSB				0
+#define CSR_ACSMPLAYBACK1X6_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK0X7 */
+#define CSR_ACSMPLAYBACK0X7_LSB				0
+#define CSR_ACSMPLAYBACK0X7_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK1X7 */
+#define CSR_ACSMPLAYBACK1X7_LSB				0
+#define CSR_ACSMPLAYBACK1X7_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPSTATEOVREN */
+#define CSR_ACSMPSTATEOVREN_LSB				0
+#define CSR_ACSMPSTATEOVREN_MASK			BIT(0)
+/* CSR_ACSMPSTATEOVRVAL */
+#define CSR_ACSMPSTATEOVRVAL_LSB			0
+#define CSR_ACSMPSTATEOVRVAL_MASK			GENMASK_32(3, 0)
+/* CSR_ACSMCTRL23 */
+#define CSR_ACSMCTRL23_LSB				0
+#define CSR_ACSMCTRL23_MASK				GENMASK_32(12, 0)
+#define CSR_ACSMCSMASK_LSB				0
+#define CSR_ACSMCSMASK_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMCSMODE_LSB				8
+#define CSR_ACSMCSMODE_MASK				BIT(8)
+#define CSR_ACSMPARMASK_LSB				9
+#define CSR_ACSMPARMASK_MASK				GENMASK_32(12, 9)
+/* CSR_ACSMCKEVAL */
+#define CSR_ACSMCKEVAL_LSB				0
+#define CSR_ACSMCKEVAL_MASK				GENMASK_32(3, 0)
+/* CSR_LOWSPEEDCLOCKDIVIDER */
+#define CSR_LOWSPEEDCLOCKDIVIDER_LSB			0
+#define CSR_LOWSPEEDCLOCKDIVIDER_MASK			GENMASK_32(5, 0)
+/* CSR_ACSMCSMAPCTRL0 */
+#define CSR_ACSMCSMAPCTRL0_LSB				0
+#define CSR_ACSMCSMAPCTRL0_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP0_LSB				0
+#define CSR_ACSMCSMAP0_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP0_LSB				8
+#define CSR_ACSMDESTMAP0_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP0_LSB				12
+#define CSR_ACSMODTMAP0_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL1 */
+#define CSR_ACSMCSMAPCTRL1_LSB				0
+#define CSR_ACSMCSMAPCTRL1_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP1_LSB				0
+#define CSR_ACSMCSMAP1_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP1_LSB				8
+#define CSR_ACSMDESTMAP1_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP1_LSB				12
+#define CSR_ACSMODTMAP1_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL2 */
+#define CSR_ACSMCSMAPCTRL2_LSB				0
+#define CSR_ACSMCSMAPCTRL2_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP2_LSB				0
+#define CSR_ACSMCSMAP2_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP2_LSB				8
+#define CSR_ACSMDESTMAP2_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP2_LSB				12
+#define CSR_ACSMODTMAP2_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL3 */
+#define CSR_ACSMCSMAPCTRL3_LSB				0
+#define CSR_ACSMCSMAPCTRL3_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP3_LSB				0
+#define CSR_ACSMCSMAP3_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP3_LSB				8
+#define CSR_ACSMDESTMAP3_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP3_LSB				12
+#define CSR_ACSMODTMAP3_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL4 */
+#define CSR_ACSMCSMAPCTRL4_LSB				0
+#define CSR_ACSMCSMAPCTRL4_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP4_LSB				0
+#define CSR_ACSMCSMAP4_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP4_LSB				8
+#define CSR_ACSMDESTMAP4_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP4_LSB				12
+#define CSR_ACSMODTMAP4_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL5 */
+#define CSR_ACSMCSMAPCTRL5_LSB				0
+#define CSR_ACSMCSMAPCTRL5_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP5_LSB				0
+#define CSR_ACSMCSMAP5_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP5_LSB				8
+#define CSR_ACSMDESTMAP5_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP5_LSB				12
+#define CSR_ACSMODTMAP5_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL6 */
+#define CSR_ACSMCSMAPCTRL6_LSB				0
+#define CSR_ACSMCSMAPCTRL6_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP6_LSB				0
+#define CSR_ACSMCSMAP6_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP6_LSB				8
+#define CSR_ACSMDESTMAP6_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP6_LSB				12
+#define CSR_ACSMODTMAP6_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL7 */
+#define CSR_ACSMCSMAPCTRL7_LSB				0
+#define CSR_ACSMCSMAPCTRL7_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP7_LSB				0
+#define CSR_ACSMCSMAP7_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP7_LSB				8
+#define CSR_ACSMDESTMAP7_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP7_LSB				12
+#define CSR_ACSMODTMAP7_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL8 */
+#define CSR_ACSMCSMAPCTRL8_LSB				0
+#define CSR_ACSMCSMAPCTRL8_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP8_LSB				0
+#define CSR_ACSMCSMAP8_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP8_LSB				8
+#define CSR_ACSMDESTMAP8_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP8_LSB				12
+#define CSR_ACSMODTMAP8_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL9 */
+#define CSR_ACSMCSMAPCTRL9_LSB				0
+#define CSR_ACSMCSMAPCTRL9_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP9_LSB				0
+#define CSR_ACSMCSMAP9_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP9_LSB				8
+#define CSR_ACSMDESTMAP9_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP9_LSB				12
+#define CSR_ACSMODTMAP9_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL10 */
+#define CSR_ACSMCSMAPCTRL10_LSB				0
+#define CSR_ACSMCSMAPCTRL10_MASK			GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP10_LSB				0
+#define CSR_ACSMCSMAP10_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP10_LSB				8
+#define CSR_ACSMDESTMAP10_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP10_LSB				12
+#define CSR_ACSMODTMAP10_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL11 */
+#define CSR_ACSMCSMAPCTRL11_LSB				0
+#define CSR_ACSMCSMAPCTRL11_MASK			GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP11_LSB				0
+#define CSR_ACSMCSMAP11_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP11_LSB				8
+#define CSR_ACSMDESTMAP11_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP11_LSB				12
+#define CSR_ACSMODTMAP11_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL12 */
+#define CSR_ACSMCSMAPCTRL12_LSB				0
+#define CSR_ACSMCSMAPCTRL12_MASK			GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP12_LSB				0
+#define CSR_ACSMCSMAP12_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP12_LSB				8
+#define CSR_ACSMDESTMAP12_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP12_LSB				12
+#define CSR_ACSMODTMAP12_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL13 */
+#define CSR_ACSMCSMAPCTRL13_LSB				0
+#define CSR_ACSMCSMAPCTRL13_MASK			GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP13_LSB				0
+#define CSR_ACSMCSMAP13_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP13_LSB				8
+#define CSR_ACSMDESTMAP13_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP13_LSB				12
+#define CSR_ACSMODTMAP13_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL14 */
+#define CSR_ACSMCSMAPCTRL14_LSB				0
+#define CSR_ACSMCSMAPCTRL14_MASK			GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP14_LSB				0
+#define CSR_ACSMCSMAP14_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP14_LSB				8
+#define CSR_ACSMDESTMAP14_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP14_LSB				12
+#define CSR_ACSMODTMAP14_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL15 */
+#define CSR_ACSMCSMAPCTRL15_LSB				0
+#define CSR_ACSMCSMAPCTRL15_MASK			GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP15_LSB				0
+#define CSR_ACSMCSMAP15_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP15_LSB				8
+#define CSR_ACSMDESTMAP15_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP15_LSB				12
+#define CSR_ACSMODTMAP15_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMODTCTRL0 */
+#define CSR_ACSMODTCTRL0_LSB				0
+#define CSR_ACSMODTCTRL0_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMODTWRPATCS0_LSB				0
+#define CSR_ACSMODTWRPATCS0_MASK			GENMASK_32(3, 0)
+#define CSR_ACSMODTRDPATCS0_LSB				4
+#define CSR_ACSMODTRDPATCS0_MASK			GENMASK_32(7, 4)
+/* CSR_ACSMODTCTRL1 */
+#define CSR_ACSMODTCTRL1_LSB				0
+#define CSR_ACSMODTCTRL1_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMODTWRPATCS1_LSB				0
+#define CSR_ACSMODTWRPATCS1_MASK			GENMASK_32(3, 0)
+#define CSR_ACSMODTRDPATCS1_LSB				4
+#define CSR_ACSMODTRDPATCS1_MASK			GENMASK_32(7, 4)
+/* CSR_ACSMODTCTRL2 */
+#define CSR_ACSMODTCTRL2_LSB				0
+#define CSR_ACSMODTCTRL2_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMODTWRPATCS2_LSB				0
+#define CSR_ACSMODTWRPATCS2_MASK			GENMASK_32(3, 0)
+#define CSR_ACSMODTRDPATCS2_LSB				4
+#define CSR_ACSMODTRDPATCS2_MASK			GENMASK_32(7, 4)
+/* CSR_ACSMODTCTRL3 */
+#define CSR_ACSMODTCTRL3_LSB				0
+#define CSR_ACSMODTCTRL3_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMODTWRPATCS3_LSB				0
+#define CSR_ACSMODTWRPATCS3_MASK			GENMASK_32(3, 0)
+#define CSR_ACSMODTRDPATCS3_LSB				4
+#define CSR_ACSMODTRDPATCS3_MASK			GENMASK_32(7, 4)
+/* CSR_ACSMODTCTRL4 */
+#define CSR_ACSMODTCTRL4_LSB				0
+#define CSR_ACSMODTCTRL4_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMODTWRPATCS4_LSB				0
+#define CSR_ACSMODTWRPATCS4_MASK			GENMASK_32(3, 0)
+#define CSR_ACSMODTRDPATCS4_LSB				4
+#define CSR_ACSMODTRDPATCS4_MASK			GENMASK_32(7, 4)
+/* CSR_ACSMODTCTRL5 */
+#define CSR_ACSMODTCTRL5_LSB				0
+#define CSR_ACSMODTCTRL5_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMODTWRPATCS5_LSB				0
+#define CSR_ACSMODTWRPATCS5_MASK			GENMASK_32(3, 0)
+#define CSR_ACSMODTRDPATCS5_LSB				4
+#define CSR_ACSMODTRDPATCS5_MASK			GENMASK_32(7, 4)
+/* CSR_ACSMODTCTRL6 */
+#define CSR_ACSMODTCTRL6_LSB				0
+#define CSR_ACSMODTCTRL6_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMODTWRPATCS6_LSB				0
+#define CSR_ACSMODTWRPATCS6_MASK			GENMASK_32(3, 0)
+#define CSR_ACSMODTRDPATCS6_LSB				4
+#define CSR_ACSMODTRDPATCS6_MASK			GENMASK_32(7, 4)
+/* CSR_ACSMODTCTRL7 */
+#define CSR_ACSMODTCTRL7_LSB				0
+#define CSR_ACSMODTCTRL7_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMODTWRPATCS7_LSB				0
+#define CSR_ACSMODTWRPATCS7_MASK			GENMASK_32(3, 0)
+#define CSR_ACSMODTRDPATCS7_LSB				4
+#define CSR_ACSMODTRDPATCS7_MASK			GENMASK_32(7, 4)
+/* CSR_ACSMODTCTRL8 */
+#define CSR_ACSMODTCTRL8_LSB				0
+#define CSR_ACSMODTCTRL8_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMODTWRDURCTRL_LSB			0
+#define CSR_ACSMODTWRDURCTRL_MASK			GENMASK_32(3, 0)
+#define CSR_ACSMODTRDDURCTRL_LSB			4
+#define CSR_ACSMODTRDDURCTRL_MASK			GENMASK_32(7, 4)
+#define CSR_ACSMODTWRSTRTCTRL_LSB			8
+#define CSR_ACSMODTWRSTRTCTRL_MASK			GENMASK_32(11, 8)
+#define CSR_ACSMODTRDSTRTCTRL_LSB			12
+#define CSR_ACSMODTRDSTRTCTRL_MASK			GENMASK_32(15, 12)
+/* CSR_ACSMCTRL16 */
+#define CSR_ACSMCTRL16_LSB				0
+#define CSR_ACSMCTRL16_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRUP_LSB				0
+#define CSR_ACSMDDRADRUP_MASK				GENMASK_32(3, 0)
+#define CSR_ACSMHIGHADDR_LSB				4
+#define CSR_ACSMHIGHADDR_MASK				BIT(4)
+#define CSR_ACSMADR13PLUGHOLE_LSB			5
+#define CSR_ACSMADR13PLUGHOLE_MASK			BIT(5)
+#define CSR_ACSMCTRL16RSVD_LSB				6
+#define CSR_ACSMCTRL16RSVD_MASK				BIT(6)
+#define CSR_ACSMWRTLVLODTCTRL_LSB			7
+#define CSR_ACSMWRTLVLODTCTRL_MASK			BIT(7)
+#define CSR_ACSMWRTLVLODT_LSB				8
+#define CSR_ACSMWRTLVLODT_MASK				GENMASK_32(11, 8)
+#define CSR_ACSM2TGRPINHIBIT_LSB			12
+#define CSR_ACSM2TGRPINHIBIT_MASK			GENMASK_32(15, 12)
+/* CSR_LOWSPEEDCLOCKSTOPVAL */
+#define CSR_LOWSPEEDCLOCKSTOPVAL_LSB			0
+#define CSR_LOWSPEEDCLOCKSTOPVAL_MASK			BIT(0)
+/* CSR_ACSMCTRL18 */
+#define CSR_ACSMCTRL18_LSB				0
+#define CSR_ACSMCTRL18_MASK				GENMASK_32(1, 0)
+#define CSR_ACSMLOCALDONE_LSB				0
+#define CSR_ACSMLOCALDONE_MASK				BIT(0)
+#define CSR_ACSMSTOPONERRASRTD_LSB			1
+#define CSR_ACSMSTOPONERRASRTD_MASK			BIT(1)
+/* CSR_ACSMCTRL19 */
+#define CSR_ACSMCTRL19_LSB				0
+#define CSR_ACSMCTRL19_MASK				GENMASK_32(2, 0)
+#define CSR_ACSMVISSEL_LSB				0
+#define CSR_ACSMVISSEL_MASK				GENMASK_32(2, 0)
+/* CSR_ACSMCTRL20 */
+#define CSR_ACSMCTRL20_LSB				0
+#define CSR_ACSMCTRL20_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMVISVAL_LSB				0
+#define CSR_ACSMVISVAL_MASK				GENMASK_32(15, 0)
+/* CSR_ACSMCTRL21 */
+#define CSR_ACSMCTRL21_LSB				0
+#define CSR_ACSMCTRL21_MASK				GENMASK_32(11, 0)
+#define CSR_ACSMMAPDIMMCS0_LSB				0
+#define CSR_ACSMMAPDIMMCS0_MASK				GENMASK_32(2, 0)
+#define CSR_ACSMMAPDIMMCS1_LSB				3
+#define CSR_ACSMMAPDIMMCS1_MASK				GENMASK_32(5, 3)
+#define CSR_ACSMMAPDIMMCS2_LSB				6
+#define CSR_ACSMMAPDIMMCS2_MASK				GENMASK_32(8, 6)
+#define CSR_ACSMMAPDIMMCS3_LSB				9
+#define CSR_ACSMMAPDIMMCS3_MASK				GENMASK_32(11, 9)
+/* CSR_ACSMCTRL22 */
+#define CSR_ACSMCTRL22_LSB				0
+#define CSR_ACSMCTRL22_MASK				GENMASK_32(11, 0)
+#define CSR_ACSMMAPDIMMCS4_LSB				0
+#define CSR_ACSMMAPDIMMCS4_MASK				GENMASK_32(2, 0)
+#define CSR_ACSMMAPDIMMCS5_LSB				3
+#define CSR_ACSMMAPDIMMCS5_MASK				GENMASK_32(5, 3)
+#define CSR_ACSMMAPDIMMCS6_LSB				6
+#define CSR_ACSMMAPDIMMCS6_MASK				GENMASK_32(8, 6)
+#define CSR_ACSMMAPDIMMCS7_LSB				9
+#define CSR_ACSMMAPDIMMCS7_MASK				GENMASK_32(11, 9)
+/* CSR_ACSMCTRL0 */
+#define CSR_ACSMCTRL0_LSB				0
+#define CSR_ACSMCTRL0_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMRSVDCTRL00_LSB				0
+#define CSR_ACSMRSVDCTRL00_MASK				BIT(0)
+#define CSR_ACSMDYNBLMODE_LSB				1
+#define CSR_ACSMDYNBLMODE_MASK				BIT(1)
+#define CSR_ACSMBURSTLEN_LSB				2
+#define CSR_ACSMBURSTLEN_MASK				BIT(2)
+#define CSR_ACSMINFLOOP_LSB				3
+#define CSR_ACSMINFLOOP_MASK				BIT(3)
+#define CSR_ACSMRXVALMODE_LSB				4
+#define CSR_ACSMRXVALMODE_MASK				BIT(4)
+#define CSR_ACSMSTPONERRMODE_LSB			5
+#define CSR_ACSMSTPONERRMODE_MASK			BIT(5)
+#define CSR_ACSM2TMODE_LSB				6
+#define CSR_ACSM2TMODE_MASK				BIT(6)
+#define CSR_ACSMTRAINSOEMODE_LSB			7
+#define CSR_ACSMTRAINSOEMODE_MASK			BIT(7)
+#define CSR_ACSMGATEDDRCMD_LSB				8
+#define CSR_ACSMGATEDDRCMD_MASK				BIT(8)
+#define CSR_ACSMGEARDOWNMODE_LSB			9
+#define CSR_ACSMGEARDOWNMODE_MASK			BIT(9)
+#define CSR_ACSMGEARDOWNPHASE_LSB			10
+#define CSR_ACSMGEARDOWNPHASE_MASK			BIT(10)
+#define CSR_ACSMGEARDOWNSYNC_LSB			11
+#define CSR_ACSMGEARDOWNSYNC_MASK			BIT(11)
+#define CSR_ACSMCAPRBSMODE_LSB				12
+#define CSR_ACSMCAPRBSMODE_MASK				BIT(12)
+#define CSR_ACSMGATERXFIFOWRITE_LSB			13
+#define CSR_ACSMGATERXFIFOWRITE_MASK			BIT(13)
+#define CSR_ACSMPARMODE_LSB				14
+#define CSR_ACSMPARMODE_MASK				BIT(14)
+#define CSR_ACSMTDSMODE_LSB				15
+#define CSR_ACSMTDSMODE_MASK				BIT(15)
+/* CSR_ACSMCTRL1 */
+#define CSR_ACSMCTRL1_LSB				0
+#define CSR_ACSMCTRL1_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMREPCNT_LSB				0
+#define CSR_ACSMREPCNT_MASK				GENMASK_32(15, 0)
+/* CSR_ACSMCTRL2 */
+#define CSR_ACSMCTRL2_LSB				0
+#define CSR_ACSMCTRL2_MASK				GENMASK_32(4, 0)
+#define CSR_ACSMSTARTPTR_LSB				0
+#define CSR_ACSMSTARTPTR_MASK				GENMASK_32(4, 0)
+/* CSR_ACSMCTRL3 */
+#define CSR_ACSMCTRL3_LSB				0
+#define CSR_ACSMCTRL3_MASK				GENMASK_32(4, 0)
+#define CSR_ACSMLOOPPTR_LSB				0
+#define CSR_ACSMLOOPPTR_MASK				GENMASK_32(4, 0)
+/* CSR_ACSMCTRL4 */
+#define CSR_ACSMCTRL4_LSB				0
+#define CSR_ACSMCTRL4_MASK				GENMASK_32(4, 0)
+#define CSR_ACSMENDPTR_LSB				0
+#define CSR_ACSMENDPTR_MASK				GENMASK_32(4, 0)
+/* CSR_ACSMCTRL5 */
+#define CSR_ACSMCTRL5_LSB				0
+#define CSR_ACSMCTRL5_MASK				GENMASK_32(13, 0)
+#define CSR_ACSMMXRDLAT_LSB				0
+#define CSR_ACSMMXRDLAT_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMRCASLAT_LSB				8
+#define CSR_ACSMRCASLAT_MASK				GENMASK_32(13, 8)
+/* CSR_ACSMCTRL6 */
+#define CSR_ACSMCTRL6_LSB				0
+#define CSR_ACSMCTRL6_MASK				GENMASK_32(10, 0)
+#define CSR_ACSMWCASLAT_LSB				0
+#define CSR_ACSMWCASLAT_MASK				GENMASK_32(5, 0)
+#define CSR_ACSMWRRSVD_LSB				6
+#define CSR_ACSMWRRSVD_MASK				GENMASK_32(7, 6)
+#define CSR_ACSMWRDATLAT_LSB				8
+#define CSR_ACSMWRDATLAT_MASK				GENMASK_32(10, 8)
+/* CSR_ACSMCTRL7 */
+#define CSR_ACSMCTRL7_LSB				0
+#define CSR_ACSMCTRL7_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMRASPCFG_LSB				0
+#define CSR_ACSMRASPCFG_MASK				GENMASK_32(15, 0)
+/* CSR_ACSMCTRL8 */
+#define CSR_ACSMCTRL8_LSB				0
+#define CSR_ACSMCTRL8_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMRASPSEED_LSB				0
+#define CSR_ACSMRASPSEED_MASK				GENMASK_32(15, 0)
+/* CSR_ACSMCTRL9 */
+#define CSR_ACSMCTRL9_LSB				0
+#define CSR_ACSMCTRL9_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCASPCFG_LSB				0
+#define CSR_ACSMCASPCFG_MASK				GENMASK_32(15, 0)
+/* CSR_ACSMCTRL10 */
+#define CSR_ACSMCTRL10_LSB				0
+#define CSR_ACSMCTRL10_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCASPSEED_LSB				0
+#define CSR_ACSMCASPSEED_MASK				GENMASK_32(15, 0)
+/* CSR_ACSMCTRL11 */
+#define CSR_ACSMCTRL11_LSB				0
+#define CSR_ACSMCTRL11_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMRASADRINC_LSB				0
+#define CSR_ACSMRASADRINC_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMCASADRINC_LSB				8
+#define CSR_ACSMCASADRINC_MASK				GENMASK_32(15, 8)
+/* CSR_ACSMCTRL12 */
+#define CSR_ACSMCTRL12_LSB				0
+#define CSR_ACSMCTRL12_MASK				GENMASK_32(11, 0)
+#define CSR_ACSMBNKPCFG_LSB				0
+#define CSR_ACSMBNKPCFG_MASK				GENMASK_32(3, 0)
+#define CSR_ACSMBNKPSEED_LSB				4
+#define CSR_ACSMBNKPSEED_MASK				GENMASK_32(7, 4)
+#define CSR_ACSMBNKADRINC_LSB				8
+#define CSR_ACSMBNKADRINC_MASK				GENMASK_32(11, 8)
+/* CSR_ACSMCTRL13 */
+#define CSR_ACSMCTRL13_LSB				0
+#define CSR_ACSMCTRL13_MASK				GENMASK_32(3, 0)
+#define CSR_ACSMCKEENB_LSB				0
+#define CSR_ACSMCKEENB_MASK				GENMASK_32(3, 0)
+/* CSR_ACSMCTRL14 */
+#define CSR_ACSMCTRL14_LSB				0
+#define CSR_ACSMCTRL14_MASK				GENMASK_32(3, 0)
+#define CSR_ACSMRASPCFGUP_LSB				0
+#define CSR_ACSMRASPCFGUP_MASK				GENMASK_32(3, 0)
+/* CSR_ACSMCTRL15 */
+#define CSR_ACSMCTRL15_LSB				0
+#define CSR_ACSMCTRL15_MASK				GENMASK_32(3, 0)
+#define CSR_ACSMRASPSEEDUP_LSB				0
+#define CSR_ACSMRASPSEEDUP_MASK				GENMASK_32(3, 0)
+
+/* PPGC0 register offsets */
+/* CSR_PPGCCTRL1 */
+#define CSR_PPGCCTRL1_LSB				1
+#define CSR_PPGCCTRL1_MASK				GENMASK_32(4, 1)
+#define CSR_HWTTXDBIEN_LSB				1
+#define CSR_HWTTXDBIEN_MASK				BIT(1)
+#define CSR_HWTRXDBIEN_LSB				2
+#define CSR_HWTRXDBIEN_MASK				BIT(2)
+#define CSR_HWTTXDMDBIVAL_LSB				3
+#define CSR_HWTTXDMDBIVAL_MASK				BIT(3)
+#define CSR_HWTTXDMDBISEL_LSB				4
+#define CSR_HWTTXDMDBISEL_MASK				BIT(4)
+/* CSR_PPGCLANE2CRCINMAP0 */
+#define CSR_PPGCLANE2CRCINMAP0_LSB			0
+#define CSR_PPGCLANE2CRCINMAP0_MASK			GENMASK_32(11, 0)
+#define CSR_PPGCCRCLANEMAP0_LSB				0
+#define CSR_PPGCCRCLANEMAP0_MASK			GENMASK_32(2, 0)
+#define CSR_PPGCCRCLANEMAP1_LSB				3
+#define CSR_PPGCCRCLANEMAP1_MASK			GENMASK_32(5, 3)
+#define CSR_PPGCCRCLANEMAP2_LSB				6
+#define CSR_PPGCCRCLANEMAP2_MASK			GENMASK_32(8, 6)
+#define CSR_PPGCCRCLANEMAP3_LSB				9
+#define CSR_PPGCCRCLANEMAP3_MASK			GENMASK_32(11, 9)
+/* CSR_PPGCLANE2CRCINMAP1 */
+#define CSR_PPGCLANE2CRCINMAP1_LSB			0
+#define CSR_PPGCLANE2CRCINMAP1_MASK			GENMASK_32(11, 0)
+#define CSR_PPGCCRCLANEMAP4_LSB				0
+#define CSR_PPGCCRCLANEMAP4_MASK			GENMASK_32(2, 0)
+#define CSR_PPGCCRCLANEMAP5_LSB				3
+#define CSR_PPGCCRCLANEMAP5_MASK			GENMASK_32(5, 3)
+#define CSR_PPGCCRCLANEMAP6_LSB				6
+#define CSR_PPGCCRCLANEMAP6_MASK			GENMASK_32(8, 6)
+#define CSR_PPGCCRCLANEMAP7_LSB				9
+#define CSR_PPGCCRCLANEMAP7_MASK			GENMASK_32(11, 9)
+/* CSR_PRBSTAPDLY0 */
+#define CSR_PRBSTAPDLY0_LSB				0
+#define CSR_PRBSTAPDLY0_MASK				GENMASK_32(15, 0)
+/* CSR_PRBSTAPDLY1 */
+#define CSR_PRBSTAPDLY1_LSB				0
+#define CSR_PRBSTAPDLY1_MASK				GENMASK_32(15, 0)
+/* CSR_PRBSTAPDLY2 */
+#define CSR_PRBSTAPDLY2_LSB				0
+#define CSR_PRBSTAPDLY2_MASK				GENMASK_32(15, 0)
+/* CSR_PRBSTAPDLY3 */
+#define CSR_PRBSTAPDLY3_LSB				0
+#define CSR_PRBSTAPDLY3_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE0 */
+#define CSR_GENPRBSBYTE0_LSB				0
+#define CSR_GENPRBSBYTE0_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE1² */
+#define CSR_GENPRBSBYTE1_LSB				0
+#define CSR_GENPRBSBYTE1_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE2 */
+#define CSR_GENPRBSBYTE2_LSB				0
+#define CSR_GENPRBSBYTE2_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE3 */
+#define CSR_GENPRBSBYTE3_LSB				0
+#define CSR_GENPRBSBYTE3_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE4 */
+#define CSR_GENPRBSBYTE4_LSB				0
+#define CSR_GENPRBSBYTE4_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE5 */
+#define CSR_GENPRBSBYTE5_LSB				0
+#define CSR_GENPRBSBYTE5_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE6 */
+#define CSR_GENPRBSBYTE6_LSB				0
+#define CSR_GENPRBSBYTE6_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE7 */
+#define CSR_GENPRBSBYTE7_LSB				0
+#define CSR_GENPRBSBYTE7_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE8 */
+#define CSR_GENPRBSBYTE8_LSB				0
+#define CSR_GENPRBSBYTE8_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE9 */
+#define CSR_GENPRBSBYTE9_LSB				0
+#define CSR_GENPRBSBYTE9_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE10 */
+#define CSR_GENPRBSBYTE10_LSB				0
+#define CSR_GENPRBSBYTE10_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE11 */
+#define CSR_GENPRBSBYTE11_LSB				0
+#define CSR_GENPRBSBYTE11_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE12 */
+#define CSR_GENPRBSBYTE12_LSB				0
+#define CSR_GENPRBSBYTE12_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE13 */
+#define CSR_GENPRBSBYTE13_LSB				0
+#define CSR_GENPRBSBYTE13_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE14 */
+#define CSR_GENPRBSBYTE14_LSB				0
+#define CSR_GENPRBSBYTE14_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE15 */
+#define CSR_GENPRBSBYTE15_LSB				0
+#define CSR_GENPRBSBYTE15_MASK				GENMASK_32(15, 0)
+/* CSR_PRBSGENCTL */
+#define CSR_PRBSGENCTL_LSB				0
+#define CSR_PRBSGENCTL_MASK				GENMASK_32(6, 0)
+#define CSR_PPGCMODE_LSB				0
+#define CSR_PPGCMODE_MASK				BIT(0)
+#define CSR_PPGCDMMODE_LSB				1
+#define CSR_PPGCDMMODE_MASK				BIT(1)
+#define CSR_PPGCLDFFMODE_LSB				2
+#define CSR_PPGCLDFFMODE_MASK				BIT(2)
+#define CSR_PPGCSEL23BPRBS_LSB				3
+#define CSR_PPGCSEL23BPRBS_MASK				BIT(3)
+#define CSR_PPGCPATADV_LSB				4
+#define CSR_PPGCPATADV_MASK				GENMASK_32(5, 4)
+#define CSR_PPGCENBPATSTRESSMODE_LSB			6
+#define CSR_PPGCENBPATSTRESSMODE_MASK			BIT(6)
+/* CSR_PRBSGENSTATELO */
+#define CSR_PRBSGENSTATELO_LSB				0
+#define CSR_PRBSGENSTATELO_MASK				GENMASK_32(15, 0)
+/* CSR_PRBSGENSTATEHI */
+#define CSR_PRBSGENSTATEHI_LSB				0
+#define CSR_PRBSGENSTATEHI_MASK				GENMASK_32(6, 0)
+/* CSR_PRBSCHKSTATELO */
+#define CSR_PRBSCHKSTATELO_LSB				0
+#define CSR_PRBSCHKSTATELO_MASK				GENMASK_32(15, 0)
+/* CSR_PRBSCHKSTATEHI */
+#define CSR_PRBSCHKSTATEHI_LSB				0
+#define CSR_PRBSCHKSTATEHI_MASK				GENMASK_32(6, 0)
+/* CSR_PRBSGENCTL1 */
+#define CSR_PRBSGENCTL1_LSB				0
+#define CSR_PRBSGENCTL1_MASK				GENMASK_32(8, 0)
+#define CSR_PPGCMODELANE_LSB				0
+#define CSR_PPGCMODELANE_MASK				GENMASK_32(8, 0)
+/* CSR_PRBSGENCTL2 */
+#define CSR_PRBSGENCTL2_LSB				0
+#define CSR_PRBSGENCTL2_MASK				GENMASK_32(15, 0)
+#define CSR_PPGCMSKPERIODLIM_LSB			0
+#define CSR_PPGCMSKPERIODLIM_MASK			GENMASK_32(15, 0)
+
+/* INITENG0 register offsets */
+/* CSR_PRESEQUENCEREG0B0S0 */
+#define CSR_PRESEQUENCEREG0B0S0_LSB			0
+#define CSR_PRESEQUENCEREG0B0S0_MASK			GENMASK_32(15, 0)
+/* CSR_PRESEQUENCEREG0B0S1 */
+#define CSR_PRESEQUENCEREG0B0S1_LSB			0
+#define CSR_PRESEQUENCEREG0B0S1_MASK			GENMASK_32(15, 0)
+/* CSR_PRESEQUENCEREG0B0S2 */
+#define CSR_PRESEQUENCEREG0B0S2_LSB			0
+#define CSR_PRESEQUENCEREG0B0S2_MASK			GENMASK_32(8, 0)
+/* CSR_PRESEQUENCEREG0B1S0 */
+#define CSR_PRESEQUENCEREG0B1S0_LSB			0
+#define CSR_PRESEQUENCEREG0B1S0_MASK			GENMASK_32(15, 0)
+/* CSR_PRESEQUENCEREG0B1S1 */
+#define CSR_PRESEQUENCEREG0B1S1_LSB			0
+#define CSR_PRESEQUENCEREG0B1S1_MASK			GENMASK_32(15, 0)
+/* CSR_PRESEQUENCEREG0B1S2 */
+#define CSR_PRESEQUENCEREG0B1S2_LSB			0
+#define CSR_PRESEQUENCEREG0B1S2_MASK			GENMASK_32(8, 0)
+/* CSR_POSTSEQUENCEREG0B0S0 */
+#define CSR_POSTSEQUENCEREG0B0S0_LSB			0
+#define CSR_POSTSEQUENCEREG0B0S0_MASK			GENMASK_32(15, 0)
+/* CSR_POSTSEQUENCEREG0B0S1 */
+#define CSR_POSTSEQUENCEREG0B0S1_LSB			0
+#define CSR_POSTSEQUENCEREG0B0S1_MASK			GENMASK_32(15, 0)
+/* CSR_POSTSEQUENCEREG0B0S2 */
+#define CSR_POSTSEQUENCEREG0B0S2_LSB			0
+#define CSR_POSTSEQUENCEREG0B0S2_MASK			GENMASK_32(8, 0)
+/* CSR_POSTSEQUENCEREG0B1S0 */
+#define CSR_POSTSEQUENCEREG0B1S0_LSB			0
+#define CSR_POSTSEQUENCEREG0B1S0_MASK			GENMASK_32(15, 0)
+/* CSR_POSTSEQUENCEREG0B1S1 */
+#define CSR_POSTSEQUENCEREG0B1S1_LSB			0
+#define CSR_POSTSEQUENCEREG0B1S1_MASK			GENMASK_32(15, 0)
+/* CSR_POSTSEQUENCEREG0B1S2 */
+#define CSR_POSTSEQUENCEREG0B1S2_LSB			0
+#define CSR_POSTSEQUENCEREG0B1S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQ0BDISABLEFLAG0 */
+#define CSR_SEQ0BDISABLEFLAG0_LSB			0
+#define CSR_SEQ0BDISABLEFLAG0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQ0BDISABLEFLAG1 */
+#define CSR_SEQ0BDISABLEFLAG1_LSB			0
+#define CSR_SEQ0BDISABLEFLAG1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQ0BDISABLEFLAG2 */
+#define CSR_SEQ0BDISABLEFLAG2_LSB			0
+#define CSR_SEQ0BDISABLEFLAG2_MASK			GENMASK_32(15, 0)
+/* CSR_SEQ0BDISABLEFLAG3 */
+#define CSR_SEQ0BDISABLEFLAG3_LSB			0
+#define CSR_SEQ0BDISABLEFLAG3_MASK			GENMASK_32(15, 0)
+/* CSR_SEQ0BDISABLEFLAG4 */
+#define CSR_SEQ0BDISABLEFLAG4_LSB			0
+#define CSR_SEQ0BDISABLEFLAG4_MASK			GENMASK_32(15, 0)
+/* CSR_SEQ0BDISABLEFLAG5 */
+#define CSR_SEQ0BDISABLEFLAG5_LSB			0
+#define CSR_SEQ0BDISABLEFLAG5_MASK			GENMASK_32(15, 0)
+/* CSR_SEQ0BDISABLEFLAG6 */
+#define CSR_SEQ0BDISABLEFLAG6_LSB			0
+#define CSR_SEQ0BDISABLEFLAG6_MASK			GENMASK_32(15, 0)
+/* CSR_SEQ0BDISABLEFLAG7 */
+#define CSR_SEQ0BDISABLEFLAG7_LSB			0
+#define CSR_SEQ0BDISABLEFLAG7_MASK			GENMASK_32(15, 0)
+/* CSR_STARTVECTOR0B0 */
+#define CSR_STARTVECTOR0B0_LSB				0
+#define CSR_STARTVECTOR0B0_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC0_LSB				0
+#define CSR_SEQ0BSTARTVEC0_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B1 */
+#define CSR_STARTVECTOR0B1_LSB				0
+#define CSR_STARTVECTOR0B1_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC1_LSB				0
+#define CSR_SEQ0BSTARTVEC1_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B2 */
+#define CSR_STARTVECTOR0B2_LSB				0
+#define CSR_STARTVECTOR0B2_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC2_LSB				0
+#define CSR_SEQ0BSTARTVEC2_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B3 */
+#define CSR_STARTVECTOR0B3_LSB				0
+#define CSR_STARTVECTOR0B3_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC3_LSB				0
+#define CSR_SEQ0BSTARTVEC3_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B4 */
+#define CSR_STARTVECTOR0B4_LSB				0
+#define CSR_STARTVECTOR0B4_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC4_LSB				0
+#define CSR_SEQ0BSTARTVEC4_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B5 */
+#define CSR_STARTVECTOR0B5_LSB				0
+#define CSR_STARTVECTOR0B5_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC5_LSB				0
+#define CSR_SEQ0BSTARTVEC5_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B6 */
+#define CSR_STARTVECTOR0B6_LSB				0
+#define CSR_STARTVECTOR0B6_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC6_LSB				0
+#define CSR_SEQ0BSTARTVEC6_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B7 */
+#define CSR_STARTVECTOR0B7_LSB				0
+#define CSR_STARTVECTOR0B7_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC7_LSB				0
+#define CSR_SEQ0BSTARTVEC7_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B8 */
+#define CSR_STARTVECTOR0B8_LSB				0
+#define CSR_STARTVECTOR0B8_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC8_LSB				0
+#define CSR_SEQ0BSTARTVEC8_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B9 */
+#define CSR_STARTVECTOR0B9_LSB				0
+#define CSR_STARTVECTOR0B9_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC9_LSB				0
+#define CSR_SEQ0BSTARTVEC9_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B10 */
+#define CSR_STARTVECTOR0B10_LSB				0
+#define CSR_STARTVECTOR0B10_MASK			GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC10_LSB				0
+#define CSR_SEQ0BSTARTVEC10_MASK			GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B11 */
+#define CSR_STARTVECTOR0B11_LSB				0
+#define CSR_STARTVECTOR0B11_MASK			GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC11_LSB				0
+#define CSR_SEQ0BSTARTVEC11_MASK			GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B12 */
+#define CSR_STARTVECTOR0B12_LSB				0
+#define CSR_STARTVECTOR0B12_MASK			GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC12_LSB				0
+#define CSR_SEQ0BSTARTVEC12_MASK			GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B13 */
+#define CSR_STARTVECTOR0B13_LSB				0
+#define CSR_STARTVECTOR0B13_MASK			GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC13_LSB				0
+#define CSR_SEQ0BSTARTVEC13_MASK			GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B14 */
+#define CSR_STARTVECTOR0B14_LSB				0
+#define CSR_STARTVECTOR0B14_MASK			GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC14_LSB				0
+#define CSR_SEQ0BSTARTVEC14_MASK			GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B15 */
+#define CSR_STARTVECTOR0B15_LSB				0
+#define CSR_STARTVECTOR0B15_MASK			GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC15_LSB				0
+#define CSR_SEQ0BSTARTVEC15_MASK			GENMASK_32(6, 0)
+/* CSR_SEQ0BWAITCONDSEL */
+#define CSR_SEQ0BWAITCONDSEL_LSB			0
+#define CSR_SEQ0BWAITCONDSEL_MASK			GENMASK_32(2, 0)
+/* CSR_PHYINLP3 */
+#define CSR_PHYINLP3_LSB				0
+#define CSR_PHYINLP3_MASK				BIT(0)
+/* CSR_SEQUENCEREG0B0S0 */
+#define CSR_SEQUENCEREG0B0S0_LSB			0
+#define CSR_SEQUENCEREG0B0S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B0S1 */
+#define CSR_SEQUENCEREG0B0S1_LSB			0
+#define CSR_SEQUENCEREG0B0S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B0S2 */
+#define CSR_SEQUENCEREG0B0S2_LSB			0
+#define CSR_SEQUENCEREG0B0S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B1S0 */
+#define CSR_SEQUENCEREG0B1S0_LSB			0
+#define CSR_SEQUENCEREG0B1S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B1S1 */
+#define CSR_SEQUENCEREG0B1S1_LSB			0
+#define CSR_SEQUENCEREG0B1S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B1S2 */
+#define CSR_SEQUENCEREG0B1S2_LSB			0
+#define CSR_SEQUENCEREG0B1S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B2S0 */
+#define CSR_SEQUENCEREG0B2S0_LSB			0
+#define CSR_SEQUENCEREG0B2S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B2S1 */
+#define CSR_SEQUENCEREG0B2S1_LSB			0
+#define CSR_SEQUENCEREG0B2S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B2S2 */
+#define CSR_SEQUENCEREG0B2S2_LSB			0
+#define CSR_SEQUENCEREG0B2S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B3S0 */
+#define CSR_SEQUENCEREG0B3S0_LSB			0
+#define CSR_SEQUENCEREG0B3S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B3S1 */
+#define CSR_SEQUENCEREG0B3S1_LSB			0
+#define CSR_SEQUENCEREG0B3S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B3S2 */
+#define CSR_SEQUENCEREG0B3S2_LSB			0
+#define CSR_SEQUENCEREG0B3S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B4S0 */
+#define CSR_SEQUENCEREG0B4S0_LSB			0
+#define CSR_SEQUENCEREG0B4S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B4S1 */
+#define CSR_SEQUENCEREG0B4S1_LSB			0
+#define CSR_SEQUENCEREG0B4S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B4S2 */
+#define CSR_SEQUENCEREG0B4S2_LSB			0
+#define CSR_SEQUENCEREG0B4S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B5S0 */
+#define CSR_SEQUENCEREG0B5S0_LSB			0
+#define CSR_SEQUENCEREG0B5S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B5S1 */
+#define CSR_SEQUENCEREG0B5S1_LSB			0
+#define CSR_SEQUENCEREG0B5S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B5S2 */
+#define CSR_SEQUENCEREG0B5S2_LSB			0
+#define CSR_SEQUENCEREG0B5S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B6S0 */
+#define CSR_SEQUENCEREG0B6S0_LSB			0
+#define CSR_SEQUENCEREG0B6S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B6S1 */
+#define CSR_SEQUENCEREG0B6S1_LSB			0
+#define CSR_SEQUENCEREG0B6S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B6S2 */
+#define CSR_SEQUENCEREG0B6S2_LSB			0
+#define CSR_SEQUENCEREG0B6S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B7S0 */
+#define CSR_SEQUENCEREG0B7S0_LSB			0
+#define CSR_SEQUENCEREG0B7S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B7S1 */
+#define CSR_SEQUENCEREG0B7S1_LSB			0
+#define CSR_SEQUENCEREG0B7S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B7S2 */
+#define CSR_SEQUENCEREG0B7S2_LSB			0
+#define CSR_SEQUENCEREG0B7S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B8S0 */
+#define CSR_SEQUENCEREG0B8S0_LSB			0
+#define CSR_SEQUENCEREG0B8S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B8S1 */
+#define CSR_SEQUENCEREG0B8S1_LSB			0
+#define CSR_SEQUENCEREG0B8S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B8S2 */
+#define CSR_SEQUENCEREG0B8S2_LSB			0
+#define CSR_SEQUENCEREG0B8S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B9S0 */
+#define CSR_SEQUENCEREG0B9S0_LSB			0
+#define CSR_SEQUENCEREG0B9S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B9S1 */
+#define CSR_SEQUENCEREG0B9S1_LSB			0
+#define CSR_SEQUENCEREG0B9S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B9S2 */
+#define CSR_SEQUENCEREG0B9S2_LSB			0
+#define CSR_SEQUENCEREG0B9S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B10S0 */
+#define CSR_SEQUENCEREG0B10S0_LSB			0
+#define CSR_SEQUENCEREG0B10S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B10S1 */
+#define CSR_SEQUENCEREG0B10S1_LSB			0
+#define CSR_SEQUENCEREG0B10S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B10S2 */
+#define CSR_SEQUENCEREG0B10S2_LSB			0
+#define CSR_SEQUENCEREG0B10S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B11S0 */
+#define CSR_SEQUENCEREG0B11S0_LSB			0
+#define CSR_SEQUENCEREG0B11S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B11S1 */
+#define CSR_SEQUENCEREG0B11S1_LSB			0
+#define CSR_SEQUENCEREG0B11S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B11S2 */
+#define CSR_SEQUENCEREG0B11S2_LSB			0
+#define CSR_SEQUENCEREG0B11S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B12S0 */
+#define CSR_SEQUENCEREG0B12S0_LSB			0
+#define CSR_SEQUENCEREG0B12S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B12S1 */
+#define CSR_SEQUENCEREG0B12S1_LSB			0
+#define CSR_SEQUENCEREG0B12S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B12S2 */
+#define CSR_SEQUENCEREG0B12S2_LSB			0
+#define CSR_SEQUENCEREG0B12S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B13S0 */
+#define CSR_SEQUENCEREG0B13S0_LSB			0
+#define CSR_SEQUENCEREG0B13S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B13S1 */
+#define CSR_SEQUENCEREG0B13S1_LSB			0
+#define CSR_SEQUENCEREG0B13S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B13S2 */
+#define CSR_SEQUENCEREG0B13S2_LSB			0
+#define CSR_SEQUENCEREG0B13S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B14S0 */
+#define CSR_SEQUENCEREG0B14S0_LSB			0
+#define CSR_SEQUENCEREG0B14S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B14S1 */
+#define CSR_SEQUENCEREG0B14S1_LSB			0
+#define CSR_SEQUENCEREG0B14S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B14S2 */
+#define CSR_SEQUENCEREG0B14S2_LSB			0
+#define CSR_SEQUENCEREG0B14S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B15S0 */
+#define CSR_SEQUENCEREG0B15S0_LSB			0
+#define CSR_SEQUENCEREG0B15S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B15S1 */
+#define CSR_SEQUENCEREG0B15S1_LSB			0
+#define CSR_SEQUENCEREG0B15S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B15S2 */
+#define CSR_SEQUENCEREG0B15S2_LSB			0
+#define CSR_SEQUENCEREG0B15S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B16S0 */
+#define CSR_SEQUENCEREG0B16S0_LSB			0
+#define CSR_SEQUENCEREG0B16S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B16S1 */
+#define CSR_SEQUENCEREG0B16S1_LSB			0
+#define CSR_SEQUENCEREG0B16S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B16S2 */
+#define CSR_SEQUENCEREG0B16S2_LSB			0
+#define CSR_SEQUENCEREG0B16S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B17S0 */
+#define CSR_SEQUENCEREG0B17S0_LSB			0
+#define CSR_SEQUENCEREG0B17S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B17S1 */
+#define CSR_SEQUENCEREG0B17S1_LSB			0
+#define CSR_SEQUENCEREG0B17S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B17S2 */
+#define CSR_SEQUENCEREG0B17S2_LSB			0
+#define CSR_SEQUENCEREG0B17S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B18S0 */
+#define CSR_SEQUENCEREG0B18S0_LSB			0
+#define CSR_SEQUENCEREG0B18S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B18S1 */
+#define CSR_SEQUENCEREG0B18S1_LSB			0
+#define CSR_SEQUENCEREG0B18S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B18S2 */
+#define CSR_SEQUENCEREG0B18S2_LSB			0
+#define CSR_SEQUENCEREG0B18S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B19S0 */
+#define CSR_SEQUENCEREG0B19S0_LSB			0
+#define CSR_SEQUENCEREG0B19S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B19S1 */
+#define CSR_SEQUENCEREG0B19S1_LSB			0
+#define CSR_SEQUENCEREG0B19S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B19S2 */
+#define CSR_SEQUENCEREG0B19S2_LSB			0
+#define CSR_SEQUENCEREG0B19S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B20S0 */
+#define CSR_SEQUENCEREG0B20S0_LSB			0
+#define CSR_SEQUENCEREG0B20S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B20S1 */
+#define CSR_SEQUENCEREG0B20S1_LSB			0
+#define CSR_SEQUENCEREG0B20S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B20S2 */
+#define CSR_SEQUENCEREG0B20S2_LSB			0
+#define CSR_SEQUENCEREG0B20S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B21S0 */
+#define CSR_SEQUENCEREG0B21S0_LSB			0
+#define CSR_SEQUENCEREG0B21S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B21S1 */
+#define CSR_SEQUENCEREG0B21S1_LSB			0
+#define CSR_SEQUENCEREG0B21S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B21S2 */
+#define CSR_SEQUENCEREG0B21S2_LSB			0
+#define CSR_SEQUENCEREG0B21S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B22S0 */
+#define CSR_SEQUENCEREG0B22S0_LSB			0
+#define CSR_SEQUENCEREG0B22S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B22S1 */
+#define CSR_SEQUENCEREG0B22S1_LSB			0
+#define CSR_SEQUENCEREG0B22S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B22S2 */
+#define CSR_SEQUENCEREG0B22S2_LSB			0
+#define CSR_SEQUENCEREG0B22S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B23S0 */
+#define CSR_SEQUENCEREG0B23S0_LSB			0
+#define CSR_SEQUENCEREG0B23S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B23S1 */
+#define CSR_SEQUENCEREG0B23S1_LSB			0
+#define CSR_SEQUENCEREG0B23S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B23S2 */
+#define CSR_SEQUENCEREG0B23S2_LSB			0
+#define CSR_SEQUENCEREG0B23S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B24S0 */
+#define CSR_SEQUENCEREG0B24S0_LSB			0
+#define CSR_SEQUENCEREG0B24S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B24S1 */
+#define CSR_SEQUENCEREG0B24S1_LSB			0
+#define CSR_SEQUENCEREG0B24S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B24S2 */
+#define CSR_SEQUENCEREG0B24S2_LSB			0
+#define CSR_SEQUENCEREG0B24S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B25S0 */
+#define CSR_SEQUENCEREG0B25S0_LSB			0
+#define CSR_SEQUENCEREG0B25S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B25S1 */
+#define CSR_SEQUENCEREG0B25S1_LSB			0
+#define CSR_SEQUENCEREG0B25S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B25S2 */
+#define CSR_SEQUENCEREG0B25S2_LSB			0
+#define CSR_SEQUENCEREG0B25S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B26S0 */
+#define CSR_SEQUENCEREG0B26S0_LSB			0
+#define CSR_SEQUENCEREG0B26S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B26S1 */
+#define CSR_SEQUENCEREG0B26S1_LSB			0
+#define CSR_SEQUENCEREG0B26S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B26S2 */
+#define CSR_SEQUENCEREG0B26S2_LSB			0
+#define CSR_SEQUENCEREG0B26S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B27S0 */
+#define CSR_SEQUENCEREG0B27S0_LSB			0
+#define CSR_SEQUENCEREG0B27S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B27S1 */
+#define CSR_SEQUENCEREG0B27S1_LSB			0
+#define CSR_SEQUENCEREG0B27S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B27S2 */
+#define CSR_SEQUENCEREG0B27S2_LSB			0
+#define CSR_SEQUENCEREG0B27S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B28S0 */
+#define CSR_SEQUENCEREG0B28S0_LSB			0
+#define CSR_SEQUENCEREG0B28S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B28S1 */
+#define CSR_SEQUENCEREG0B28S1_LSB			0
+#define CSR_SEQUENCEREG0B28S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B28S2 */
+#define CSR_SEQUENCEREG0B28S2_LSB			0
+#define CSR_SEQUENCEREG0B28S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B29S0 */
+#define CSR_SEQUENCEREG0B29S0_LSB			0
+#define CSR_SEQUENCEREG0B29S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B29S1 */
+#define CSR_SEQUENCEREG0B29S1_LSB			0
+#define CSR_SEQUENCEREG0B29S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B29S2 */
+#define CSR_SEQUENCEREG0B29S2_LSB			0
+#define CSR_SEQUENCEREG0B29S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B30S0 */
+#define CSR_SEQUENCEREG0B30S0_LSB			0
+#define CSR_SEQUENCEREG0B30S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B30S1 */
+#define CSR_SEQUENCEREG0B30S1_LSB			0
+#define CSR_SEQUENCEREG0B30S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B30S2 */
+#define CSR_SEQUENCEREG0B30S2_LSB			0
+#define CSR_SEQUENCEREG0B30S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B31S0 */
+#define CSR_SEQUENCEREG0B31S0_LSB			0
+#define CSR_SEQUENCEREG0B31S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B31S1 */
+#define CSR_SEQUENCEREG0B31S1_LSB			0
+#define CSR_SEQUENCEREG0B31S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B31S2 */
+#define CSR_SEQUENCEREG0B31S2_LSB			0
+#define CSR_SEQUENCEREG0B31S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B32S0 */
+#define CSR_SEQUENCEREG0B32S0_LSB			0
+#define CSR_SEQUENCEREG0B32S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B32S1 */
+#define CSR_SEQUENCEREG0B32S1_LSB			0
+#define CSR_SEQUENCEREG0B32S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B32S2 */
+#define CSR_SEQUENCEREG0B32S2_LSB			0
+#define CSR_SEQUENCEREG0B32S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B33S0 */
+#define CSR_SEQUENCEREG0B33S0_LSB			0
+#define CSR_SEQUENCEREG0B33S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B33S1 */
+#define CSR_SEQUENCEREG0B33S1_LSB			0
+#define CSR_SEQUENCEREG0B33S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B33S2 */
+#define CSR_SEQUENCEREG0B33S2_LSB			0
+#define CSR_SEQUENCEREG0B33S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B34S0 */
+#define CSR_SEQUENCEREG0B34S0_LSB			0
+#define CSR_SEQUENCEREG0B34S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B34S1 */
+#define CSR_SEQUENCEREG0B34S1_LSB			0
+#define CSR_SEQUENCEREG0B34S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B34S2 */
+#define CSR_SEQUENCEREG0B34S2_LSB			0
+#define CSR_SEQUENCEREG0B34S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B35S0 */
+#define CSR_SEQUENCEREG0B35S0_LSB			0
+#define CSR_SEQUENCEREG0B35S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B35S1 */
+#define CSR_SEQUENCEREG0B35S1_LSB			0
+#define CSR_SEQUENCEREG0B35S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B35S2 */
+#define CSR_SEQUENCEREG0B35S2_LSB			0
+#define CSR_SEQUENCEREG0B35S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B36S0 */
+#define CSR_SEQUENCEREG0B36S0_LSB			0
+#define CSR_SEQUENCEREG0B36S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B36S1 */
+#define CSR_SEQUENCEREG0B36S1_LSB			0
+#define CSR_SEQUENCEREG0B36S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B36S2 */
+#define CSR_SEQUENCEREG0B36S2_LSB			0
+#define CSR_SEQUENCEREG0B36S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B37S0 */
+#define CSR_SEQUENCEREG0B37S0_LSB			0
+#define CSR_SEQUENCEREG0B37S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B37S1 */
+#define CSR_SEQUENCEREG0B37S1_LSB			0
+#define CSR_SEQUENCEREG0B37S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B37S2 */
+#define CSR_SEQUENCEREG0B37S2_LSB			0
+#define CSR_SEQUENCEREG0B37S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B38S0 */
+#define CSR_SEQUENCEREG0B38S0_LSB			0
+#define CSR_SEQUENCEREG0B38S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B38S1 */
+#define CSR_SEQUENCEREG0B38S1_LSB			0
+#define CSR_SEQUENCEREG0B38S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B38S2 */
+#define CSR_SEQUENCEREG0B38S2_LSB			0
+#define CSR_SEQUENCEREG0B38S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B39S0 */
+#define CSR_SEQUENCEREG0B39S0_LSB			0
+#define CSR_SEQUENCEREG0B39S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B39S1 */
+#define CSR_SEQUENCEREG0B39S1_LSB			0
+#define CSR_SEQUENCEREG0B39S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B39S2 */
+#define CSR_SEQUENCEREG0B39S2_LSB			0
+#define CSR_SEQUENCEREG0B39S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B40S0 */
+#define CSR_SEQUENCEREG0B40S0_LSB			0
+#define CSR_SEQUENCEREG0B40S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B40S1 */
+#define CSR_SEQUENCEREG0B40S1_LSB			0
+#define CSR_SEQUENCEREG0B40S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B40S2 */
+#define CSR_SEQUENCEREG0B40S2_LSB			0
+#define CSR_SEQUENCEREG0B40S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B41S0 */
+#define CSR_SEQUENCEREG0B41S0_LSB			0
+#define CSR_SEQUENCEREG0B41S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B41S1 */
+#define CSR_SEQUENCEREG0B41S1_LSB			0
+#define CSR_SEQUENCEREG0B41S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B41S2 */
+#define CSR_SEQUENCEREG0B41S2_LSB			0
+#define CSR_SEQUENCEREG0B41S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B42S0 */
+#define CSR_SEQUENCEREG0B42S0_LSB			0
+#define CSR_SEQUENCEREG0B42S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B42S1 */
+#define CSR_SEQUENCEREG0B42S1_LSB			0
+#define CSR_SEQUENCEREG0B42S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B42S2 */
+#define CSR_SEQUENCEREG0B42S2_LSB			0
+#define CSR_SEQUENCEREG0B42S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B43S0 */
+#define CSR_SEQUENCEREG0B43S0_LSB			0
+#define CSR_SEQUENCEREG0B43S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B43S1 */
+#define CSR_SEQUENCEREG0B43S1_LSB			0
+#define CSR_SEQUENCEREG0B43S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B43S2 */
+#define CSR_SEQUENCEREG0B43S2_LSB			0
+#define CSR_SEQUENCEREG0B43S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B44S0 */
+#define CSR_SEQUENCEREG0B44S0_LSB			0
+#define CSR_SEQUENCEREG0B44S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B44S1 */
+#define CSR_SEQUENCEREG0B44S1_LSB			0
+#define CSR_SEQUENCEREG0B44S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B44S2 */
+#define CSR_SEQUENCEREG0B44S2_LSB			0
+#define CSR_SEQUENCEREG0B44S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B45S0 */
+#define CSR_SEQUENCEREG0B45S0_LSB			0
+#define CSR_SEQUENCEREG0B45S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B45S1 */
+#define CSR_SEQUENCEREG0B45S1_LSB			0
+#define CSR_SEQUENCEREG0B45S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B45S2 */
+#define CSR_SEQUENCEREG0B45S2_LSB			0
+#define CSR_SEQUENCEREG0B45S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B46S0 */
+#define CSR_SEQUENCEREG0B46S0_LSB			0
+#define CSR_SEQUENCEREG0B46S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B46S1 */
+#define CSR_SEQUENCEREG0B46S1_LSB			0
+#define CSR_SEQUENCEREG0B46S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B46S2 */
+#define CSR_SEQUENCEREG0B46S2_LSB			0
+#define CSR_SEQUENCEREG0B46S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B47S0 */
+#define CSR_SEQUENCEREG0B47S0_LSB			0
+#define CSR_SEQUENCEREG0B47S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B47S1 */
+#define CSR_SEQUENCEREG0B47S1_LSB			0
+#define CSR_SEQUENCEREG0B47S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B47S2 */
+#define CSR_SEQUENCEREG0B47S2_LSB			0
+#define CSR_SEQUENCEREG0B47S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B48S0 */
+#define CSR_SEQUENCEREG0B48S0_LSB			0
+#define CSR_SEQUENCEREG0B48S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B48S1 */
+#define CSR_SEQUENCEREG0B48S1_LSB			0
+#define CSR_SEQUENCEREG0B48S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B48S2 */
+#define CSR_SEQUENCEREG0B48S2_LSB			0
+#define CSR_SEQUENCEREG0B48S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B49S0 */
+#define CSR_SEQUENCEREG0B49S0_LSB			0
+#define CSR_SEQUENCEREG0B49S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B49S1 */
+#define CSR_SEQUENCEREG0B49S1_LSB			0
+#define CSR_SEQUENCEREG0B49S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B49S2 */
+#define CSR_SEQUENCEREG0B49S2_LSB			0
+#define CSR_SEQUENCEREG0B49S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B50S0 */
+#define CSR_SEQUENCEREG0B50S0_LSB			0
+#define CSR_SEQUENCEREG0B50S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B50S1 */
+#define CSR_SEQUENCEREG0B50S1_LSB			0
+#define CSR_SEQUENCEREG0B50S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B50S2 */
+#define CSR_SEQUENCEREG0B50S2_LSB			0
+#define CSR_SEQUENCEREG0B50S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B51S0 */
+#define CSR_SEQUENCEREG0B51S0_LSB			0
+#define CSR_SEQUENCEREG0B51S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B51S1 */
+#define CSR_SEQUENCEREG0B51S1_LSB			0
+#define CSR_SEQUENCEREG0B51S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B51S2 */
+#define CSR_SEQUENCEREG0B51S2_LSB			0
+#define CSR_SEQUENCEREG0B51S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B52S0 */
+#define CSR_SEQUENCEREG0B52S0_LSB			0
+#define CSR_SEQUENCEREG0B52S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B52S1 */
+#define CSR_SEQUENCEREG0B52S1_LSB			0
+#define CSR_SEQUENCEREG0B52S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B52S2 */
+#define CSR_SEQUENCEREG0B52S2_LSB			0
+#define CSR_SEQUENCEREG0B52S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B53S0 */
+#define CSR_SEQUENCEREG0B53S0_LSB			0
+#define CSR_SEQUENCEREG0B53S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B53S1 */
+#define CSR_SEQUENCEREG0B53S1_LSB			0
+#define CSR_SEQUENCEREG0B53S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B53S2 */
+#define CSR_SEQUENCEREG0B53S2_LSB			0
+#define CSR_SEQUENCEREG0B53S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B54S0 */
+#define CSR_SEQUENCEREG0B54S0_LSB			0
+#define CSR_SEQUENCEREG0B54S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B54S1 */
+#define CSR_SEQUENCEREG0B54S1_LSB			0
+#define CSR_SEQUENCEREG0B54S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B54S2 */
+#define CSR_SEQUENCEREG0B54S2_LSB			0
+#define CSR_SEQUENCEREG0B54S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B55S0 */
+#define CSR_SEQUENCEREG0B55S0_LSB			0
+#define CSR_SEQUENCEREG0B55S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B55S1 */
+#define CSR_SEQUENCEREG0B55S1_LSB			0
+#define CSR_SEQUENCEREG0B55S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B55S2 */
+#define CSR_SEQUENCEREG0B55S2_LSB			0
+#define CSR_SEQUENCEREG0B55S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B56S0 */
+#define CSR_SEQUENCEREG0B56S0_LSB			0
+#define CSR_SEQUENCEREG0B56S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B56S1 */
+#define CSR_SEQUENCEREG0B56S1_LSB			0
+#define CSR_SEQUENCEREG0B56S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B56S2 */
+#define CSR_SEQUENCEREG0B56S2_LSB			0
+#define CSR_SEQUENCEREG0B56S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B57S0 */
+#define CSR_SEQUENCEREG0B57S0_LSB			0
+#define CSR_SEQUENCEREG0B57S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B57S1 */
+#define CSR_SEQUENCEREG0B57S1_LSB			0
+#define CSR_SEQUENCEREG0B57S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B57S2 */
+#define CSR_SEQUENCEREG0B57S2_LSB			0
+#define CSR_SEQUENCEREG0B57S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B58S0 */
+#define CSR_SEQUENCEREG0B58S0_LSB			0
+#define CSR_SEQUENCEREG0B58S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B58S1 */
+#define CSR_SEQUENCEREG0B58S1_LSB			0
+#define CSR_SEQUENCEREG0B58S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B58S2 */
+#define CSR_SEQUENCEREG0B58S2_LSB			0
+#define CSR_SEQUENCEREG0B58S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B59S0 */
+#define CSR_SEQUENCEREG0B59S0_LSB			0
+#define CSR_SEQUENCEREG0B59S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B59S1 */
+#define CSR_SEQUENCEREG0B59S1_LSB			0
+#define CSR_SEQUENCEREG0B59S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B59S2 */
+#define CSR_SEQUENCEREG0B59S2_LSB			0
+#define CSR_SEQUENCEREG0B59S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B60S0 */
+#define CSR_SEQUENCEREG0B60S0_LSB			0
+#define CSR_SEQUENCEREG0B60S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B60S1 */
+#define CSR_SEQUENCEREG0B60S1_LSB			0
+#define CSR_SEQUENCEREG0B60S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B60S2 */
+#define CSR_SEQUENCEREG0B60S2_LSB			0
+#define CSR_SEQUENCEREG0B60S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B61S0 */
+#define CSR_SEQUENCEREG0B61S0_LSB			0
+#define CSR_SEQUENCEREG0B61S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B61S1 */
+#define CSR_SEQUENCEREG0B61S1_LSB			0
+#define CSR_SEQUENCEREG0B61S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B61S2 */
+#define CSR_SEQUENCEREG0B61S2_LSB			0
+#define CSR_SEQUENCEREG0B61S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B62S0 */
+#define CSR_SEQUENCEREG0B62S0_LSB			0
+#define CSR_SEQUENCEREG0B62S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B62S1 */
+#define CSR_SEQUENCEREG0B62S1_LSB			0
+#define CSR_SEQUENCEREG0B62S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B62S2 */
+#define CSR_SEQUENCEREG0B62S2_LSB			0
+#define CSR_SEQUENCEREG0B62S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B63S0 */
+#define CSR_SEQUENCEREG0B63S0_LSB			0
+#define CSR_SEQUENCEREG0B63S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B63S1 */
+#define CSR_SEQUENCEREG0B63S1_LSB			0
+#define CSR_SEQUENCEREG0B63S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B63S2 */
+#define CSR_SEQUENCEREG0B63S2_LSB			0
+#define CSR_SEQUENCEREG0B63S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B64S0 */
+#define CSR_SEQUENCEREG0B64S0_LSB			0
+#define CSR_SEQUENCEREG0B64S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B64S1 */
+#define CSR_SEQUENCEREG0B64S1_LSB			0
+#define CSR_SEQUENCEREG0B64S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B64S2 */
+#define CSR_SEQUENCEREG0B64S2_LSB			0
+#define CSR_SEQUENCEREG0B64S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B65S0 */
+#define CSR_SEQUENCEREG0B65S0_LSB			0
+#define CSR_SEQUENCEREG0B65S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B65S1 */
+#define CSR_SEQUENCEREG0B65S1_LSB			0
+#define CSR_SEQUENCEREG0B65S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B65S2 */
+#define CSR_SEQUENCEREG0B65S2_LSB			0
+#define CSR_SEQUENCEREG0B65S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B66S0 */
+#define CSR_SEQUENCEREG0B66S0_LSB			0
+#define CSR_SEQUENCEREG0B66S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B66S1 */
+#define CSR_SEQUENCEREG0B66S1_LSB			0
+#define CSR_SEQUENCEREG0B66S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B66S2 */
+#define CSR_SEQUENCEREG0B66S2_LSB			0
+#define CSR_SEQUENCEREG0B66S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B67S0 */
+#define CSR_SEQUENCEREG0B67S0_LSB			0
+#define CSR_SEQUENCEREG0B67S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B67S1 */
+#define CSR_SEQUENCEREG0B67S1_LSB			0
+#define CSR_SEQUENCEREG0B67S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B67S2 */
+#define CSR_SEQUENCEREG0B67S2_LSB			0
+#define CSR_SEQUENCEREG0B67S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B68S0 */
+#define CSR_SEQUENCEREG0B68S0_LSB			0
+#define CSR_SEQUENCEREG0B68S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B68S1 */
+#define CSR_SEQUENCEREG0B68S1_LSB			0
+#define CSR_SEQUENCEREG0B68S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B68S2 */
+#define CSR_SEQUENCEREG0B68S2_LSB			0
+#define CSR_SEQUENCEREG0B68S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B69S0 */
+#define CSR_SEQUENCEREG0B69S0_LSB			0
+#define CSR_SEQUENCEREG0B69S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B69S1 */
+#define CSR_SEQUENCEREG0B69S1_LSB			0
+#define CSR_SEQUENCEREG0B69S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B69S2 */
+#define CSR_SEQUENCEREG0B69S2_LSB			0
+#define CSR_SEQUENCEREG0B69S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B70S0 */
+#define CSR_SEQUENCEREG0B70S0_LSB			0
+#define CSR_SEQUENCEREG0B70S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B70S1 */
+#define CSR_SEQUENCEREG0B70S1_LSB			0
+#define CSR_SEQUENCEREG0B70S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B70S2 */
+#define CSR_SEQUENCEREG0B70S2_LSB			0
+#define CSR_SEQUENCEREG0B70S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B71S0 */
+#define CSR_SEQUENCEREG0B71S0_LSB			0
+#define CSR_SEQUENCEREG0B71S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B71S1 */
+#define CSR_SEQUENCEREG0B71S1_LSB			0
+#define CSR_SEQUENCEREG0B71S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B71S2 */
+#define CSR_SEQUENCEREG0B71S2_LSB			0
+#define CSR_SEQUENCEREG0B71S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B72S0 */
+#define CSR_SEQUENCEREG0B72S0_LSB			0
+#define CSR_SEQUENCEREG0B72S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B72S1 */
+#define CSR_SEQUENCEREG0B72S1_LSB			0
+#define CSR_SEQUENCEREG0B72S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B72S2 */
+#define CSR_SEQUENCEREG0B72S2_LSB			0
+#define CSR_SEQUENCEREG0B72S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B73S0 */
+#define CSR_SEQUENCEREG0B73S0_LSB			0
+#define CSR_SEQUENCEREG0B73S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B73S1 */
+#define CSR_SEQUENCEREG0B73S1_LSB			0
+#define CSR_SEQUENCEREG0B73S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B73S2 */
+#define CSR_SEQUENCEREG0B73S2_LSB			0
+#define CSR_SEQUENCEREG0B73S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B74S0 */
+#define CSR_SEQUENCEREG0B74S0_LSB			0
+#define CSR_SEQUENCEREG0B74S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B74S1 */
+#define CSR_SEQUENCEREG0B74S1_LSB			0
+#define CSR_SEQUENCEREG0B74S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B74S2 */
+#define CSR_SEQUENCEREG0B74S2_LSB			0
+#define CSR_SEQUENCEREG0B74S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B75S0 */
+#define CSR_SEQUENCEREG0B75S0_LSB			0
+#define CSR_SEQUENCEREG0B75S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B75S1 */
+#define CSR_SEQUENCEREG0B75S1_LSB			0
+#define CSR_SEQUENCEREG0B75S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B75S2 */
+#define CSR_SEQUENCEREG0B75S2_LSB			0
+#define CSR_SEQUENCEREG0B75S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B76S0 */
+#define CSR_SEQUENCEREG0B76S0_LSB			0
+#define CSR_SEQUENCEREG0B76S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B76S1 */
+#define CSR_SEQUENCEREG0B76S1_LSB			0
+#define CSR_SEQUENCEREG0B76S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B76S2 */
+#define CSR_SEQUENCEREG0B76S2_LSB			0
+#define CSR_SEQUENCEREG0B76S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B77S0 */
+#define CSR_SEQUENCEREG0B77S0_LSB			0
+#define CSR_SEQUENCEREG0B77S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B77S1 */
+#define CSR_SEQUENCEREG0B77S1_LSB			0
+#define CSR_SEQUENCEREG0B77S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B77S2 */
+#define CSR_SEQUENCEREG0B77S2_LSB			0
+#define CSR_SEQUENCEREG0B77S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B78S0 */
+#define CSR_SEQUENCEREG0B78S0_LSB			0
+#define CSR_SEQUENCEREG0B78S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B78S1 */
+#define CSR_SEQUENCEREG0B78S1_LSB			0
+#define CSR_SEQUENCEREG0B78S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B78S2 */
+#define CSR_SEQUENCEREG0B78S2_LSB			0
+#define CSR_SEQUENCEREG0B78S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B79S0 */
+#define CSR_SEQUENCEREG0B79S0_LSB			0
+#define CSR_SEQUENCEREG0B79S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B79S1 */
+#define CSR_SEQUENCEREG0B79S1_LSB			0
+#define CSR_SEQUENCEREG0B79S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B79S2 */
+#define CSR_SEQUENCEREG0B79S2_LSB			0
+#define CSR_SEQUENCEREG0B79S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B80S0 */
+#define CSR_SEQUENCEREG0B80S0_LSB			0
+#define CSR_SEQUENCEREG0B80S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B80S1 */
+#define CSR_SEQUENCEREG0B80S1_LSB			0
+#define CSR_SEQUENCEREG0B80S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B80S2 */
+#define CSR_SEQUENCEREG0B80S2_LSB			0
+#define CSR_SEQUENCEREG0B80S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B81S0 */
+#define CSR_SEQUENCEREG0B81S0_LSB			0
+#define CSR_SEQUENCEREG0B81S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B81S1 */
+#define CSR_SEQUENCEREG0B81S1_LSB			0
+#define CSR_SEQUENCEREG0B81S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B81S2 */
+#define CSR_SEQUENCEREG0B81S2_LSB			0
+#define CSR_SEQUENCEREG0B81S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B82S0 */
+#define CSR_SEQUENCEREG0B82S0_LSB			0
+#define CSR_SEQUENCEREG0B82S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B82S1 */
+#define CSR_SEQUENCEREG0B82S1_LSB			0
+#define CSR_SEQUENCEREG0B82S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B82S2 */
+#define CSR_SEQUENCEREG0B82S2_LSB			0
+#define CSR_SEQUENCEREG0B82S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B83S0 */
+#define CSR_SEQUENCEREG0B83S0_LSB			0
+#define CSR_SEQUENCEREG0B83S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B83S1 */
+#define CSR_SEQUENCEREG0B83S1_LSB			0
+#define CSR_SEQUENCEREG0B83S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B83S2 */
+#define CSR_SEQUENCEREG0B83S2_LSB			0
+#define CSR_SEQUENCEREG0B83S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B84S0 */
+#define CSR_SEQUENCEREG0B84S0_LSB			0
+#define CSR_SEQUENCEREG0B84S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B84S1 */
+#define CSR_SEQUENCEREG0B84S1_LSB			0
+#define CSR_SEQUENCEREG0B84S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B84S2 */
+#define CSR_SEQUENCEREG0B84S2_LSB			0
+#define CSR_SEQUENCEREG0B84S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B85S0 */
+#define CSR_SEQUENCEREG0B85S0_LSB			0
+#define CSR_SEQUENCEREG0B85S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B85S1 */
+#define CSR_SEQUENCEREG0B85S1_LSB			0
+#define CSR_SEQUENCEREG0B85S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B85S2 */
+#define CSR_SEQUENCEREG0B85S2_LSB			0
+#define CSR_SEQUENCEREG0B85S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B86S0 */
+#define CSR_SEQUENCEREG0B86S0_LSB			0
+#define CSR_SEQUENCEREG0B86S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B86S1 */
+#define CSR_SEQUENCEREG0B86S1_LSB			0
+#define CSR_SEQUENCEREG0B86S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B86S2 */
+#define CSR_SEQUENCEREG0B86S2_LSB			0
+#define CSR_SEQUENCEREG0B86S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B87S0 */
+#define CSR_SEQUENCEREG0B87S0_LSB			0
+#define CSR_SEQUENCEREG0B87S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B87S1 */
+#define CSR_SEQUENCEREG0B87S1_LSB			0
+#define CSR_SEQUENCEREG0B87S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B87S2 */
+#define CSR_SEQUENCEREG0B87S2_LSB			0
+#define CSR_SEQUENCEREG0B87S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B88S0 */
+#define CSR_SEQUENCEREG0B88S0_LSB			0
+#define CSR_SEQUENCEREG0B88S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B88S1 */
+#define CSR_SEQUENCEREG0B88S1_LSB			0
+#define CSR_SEQUENCEREG0B88S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B88S2 */
+#define CSR_SEQUENCEREG0B88S2_LSB			0
+#define CSR_SEQUENCEREG0B88S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B89S0 */
+#define CSR_SEQUENCEREG0B89S0_LSB			0
+#define CSR_SEQUENCEREG0B89S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B89S1 */
+#define CSR_SEQUENCEREG0B89S1_LSB			0
+#define CSR_SEQUENCEREG0B89S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B89S2 */
+#define CSR_SEQUENCEREG0B89S2_LSB			0
+#define CSR_SEQUENCEREG0B89S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B90S0 */
+#define CSR_SEQUENCEREG0B90S0_LSB			0
+#define CSR_SEQUENCEREG0B90S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B90S1 */
+#define CSR_SEQUENCEREG0B90S1_LSB			0
+#define CSR_SEQUENCEREG0B90S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B90S2 */
+#define CSR_SEQUENCEREG0B90S2_LSB			0
+#define CSR_SEQUENCEREG0B90S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B91S0 */
+#define CSR_SEQUENCEREG0B91S0_LSB			0
+#define CSR_SEQUENCEREG0B91S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B91S1 */
+#define CSR_SEQUENCEREG0B91S1_LSB			0
+#define CSR_SEQUENCEREG0B91S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B91S2 */
+#define CSR_SEQUENCEREG0B91S2_LSB			0
+#define CSR_SEQUENCEREG0B91S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B92S0 */
+#define CSR_SEQUENCEREG0B92S0_LSB			0
+#define CSR_SEQUENCEREG0B92S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B92S1 */
+#define CSR_SEQUENCEREG0B92S1_LSB			0
+#define CSR_SEQUENCEREG0B92S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B92S2 */
+#define CSR_SEQUENCEREG0B92S2_LSB			0
+#define CSR_SEQUENCEREG0B92S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B93S0 */
+#define CSR_SEQUENCEREG0B93S0_LSB			0
+#define CSR_SEQUENCEREG0B93S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B93S1 */
+#define CSR_SEQUENCEREG0B93S1_LSB			0
+#define CSR_SEQUENCEREG0B93S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B93S2 */
+#define CSR_SEQUENCEREG0B93S2_LSB			0
+#define CSR_SEQUENCEREG0B93S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B94S0 */
+#define CSR_SEQUENCEREG0B94S0_LSB			0
+#define CSR_SEQUENCEREG0B94S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B94S1 */
+#define CSR_SEQUENCEREG0B94S1_LSB			0
+#define CSR_SEQUENCEREG0B94S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B94S2 */
+#define CSR_SEQUENCEREG0B94S2_LSB			0
+#define CSR_SEQUENCEREG0B94S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B95S0 */
+#define CSR_SEQUENCEREG0B95S0_LSB			0
+#define CSR_SEQUENCEREG0B95S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B95S1 */
+#define CSR_SEQUENCEREG0B95S1_LSB			0
+#define CSR_SEQUENCEREG0B95S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B95S2 */
+#define CSR_SEQUENCEREG0B95S2_LSB			0
+#define CSR_SEQUENCEREG0B95S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B96S0 */
+#define CSR_SEQUENCEREG0B96S0_LSB			0
+#define CSR_SEQUENCEREG0B96S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B96S1 */
+#define CSR_SEQUENCEREG0B96S1_LSB			0
+#define CSR_SEQUENCEREG0B96S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B96S2 */
+#define CSR_SEQUENCEREG0B96S2_LSB			0
+#define CSR_SEQUENCEREG0B96S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B97S0 */
+#define CSR_SEQUENCEREG0B97S0_LSB			0
+#define CSR_SEQUENCEREG0B97S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B97S1 */
+#define CSR_SEQUENCEREG0B97S1_LSB			0
+#define CSR_SEQUENCEREG0B97S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B97S2 */
+#define CSR_SEQUENCEREG0B97S2_LSB			0
+#define CSR_SEQUENCEREG0B97S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B98S0 */
+#define CSR_SEQUENCEREG0B98S0_LSB			0
+#define CSR_SEQUENCEREG0B98S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B98S1 */
+#define CSR_SEQUENCEREG0B98S1_LSB			0
+#define CSR_SEQUENCEREG0B98S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B98S2 */
+#define CSR_SEQUENCEREG0B98S2_LSB			0
+#define CSR_SEQUENCEREG0B98S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B99S0 */
+#define CSR_SEQUENCEREG0B99S0_LSB			0
+#define CSR_SEQUENCEREG0B99S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B99S1 */
+#define CSR_SEQUENCEREG0B99S1_LSB			0
+#define CSR_SEQUENCEREG0B99S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B99S2 */
+#define CSR_SEQUENCEREG0B99S2_LSB			0
+#define CSR_SEQUENCEREG0B99S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B100S0 */
+#define CSR_SEQUENCEREG0B100S0_LSB			0
+#define CSR_SEQUENCEREG0B100S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B100S1 */
+#define CSR_SEQUENCEREG0B100S1_LSB			0
+#define CSR_SEQUENCEREG0B100S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B100S2 */
+#define CSR_SEQUENCEREG0B100S2_LSB			0
+#define CSR_SEQUENCEREG0B100S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B101S0 */
+#define CSR_SEQUENCEREG0B101S0_LSB			0
+#define CSR_SEQUENCEREG0B101S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B101S1 */
+#define CSR_SEQUENCEREG0B101S1_LSB			0
+#define CSR_SEQUENCEREG0B101S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B101S2 */
+#define CSR_SEQUENCEREG0B101S2_LSB			0
+#define CSR_SEQUENCEREG0B101S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B102S0 */
+#define CSR_SEQUENCEREG0B102S0_LSB			0
+#define CSR_SEQUENCEREG0B102S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B102S1 */
+#define CSR_SEQUENCEREG0B102S1_LSB			0
+#define CSR_SEQUENCEREG0B102S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B102S2 */
+#define CSR_SEQUENCEREG0B102S2_LSB			0
+#define CSR_SEQUENCEREG0B102S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B103S0 */
+#define CSR_SEQUENCEREG0B103S0_LSB			0
+#define CSR_SEQUENCEREG0B103S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B103S1 */
+#define CSR_SEQUENCEREG0B103S1_LSB			0
+#define CSR_SEQUENCEREG0B103S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B103S2 */
+#define CSR_SEQUENCEREG0B103S2_LSB			0
+#define CSR_SEQUENCEREG0B103S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B104S0 */
+#define CSR_SEQUENCEREG0B104S0_LSB			0
+#define CSR_SEQUENCEREG0B104S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B104S1 */
+#define CSR_SEQUENCEREG0B104S1_LSB			0
+#define CSR_SEQUENCEREG0B104S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B104S2 */
+#define CSR_SEQUENCEREG0B104S2_LSB			0
+#define CSR_SEQUENCEREG0B104S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B105S0 */
+#define CSR_SEQUENCEREG0B105S0_LSB			0
+#define CSR_SEQUENCEREG0B105S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B105S1 */
+#define CSR_SEQUENCEREG0B105S1_LSB			0
+#define CSR_SEQUENCEREG0B105S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B105S2 */
+#define CSR_SEQUENCEREG0B105S2_LSB			0
+#define CSR_SEQUENCEREG0B105S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B106S0 */
+#define CSR_SEQUENCEREG0B106S0_LSB			0
+#define CSR_SEQUENCEREG0B106S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B106S1 */
+#define CSR_SEQUENCEREG0B106S1_LSB			0
+#define CSR_SEQUENCEREG0B106S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B106S2 */
+#define CSR_SEQUENCEREG0B106S2_LSB			0
+#define CSR_SEQUENCEREG0B106S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B107S0 */
+#define CSR_SEQUENCEREG0B107S0_LSB			0
+#define CSR_SEQUENCEREG0B107S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B107S1 */
+#define CSR_SEQUENCEREG0B107S1_LSB			0
+#define CSR_SEQUENCEREG0B107S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B107S2 */
+#define CSR_SEQUENCEREG0B107S2_LSB			0
+#define CSR_SEQUENCEREG0B107S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B108S0 */
+#define CSR_SEQUENCEREG0B108S0_LSB			0
+#define CSR_SEQUENCEREG0B108S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B108S1 */
+#define CSR_SEQUENCEREG0B108S1_LSB			0
+#define CSR_SEQUENCEREG0B108S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B108S2 */
+#define CSR_SEQUENCEREG0B108S2_LSB			0
+#define CSR_SEQUENCEREG0B108S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B109S0 */
+#define CSR_SEQUENCEREG0B109S0_LSB			0
+#define CSR_SEQUENCEREG0B109S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B109S1 */
+#define CSR_SEQUENCEREG0B109S1_LSB			0
+#define CSR_SEQUENCEREG0B109S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B109S2 */
+#define CSR_SEQUENCEREG0B109S2_LSB			0
+#define CSR_SEQUENCEREG0B109S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B110S0 */
+#define CSR_SEQUENCEREG0B110S0_LSB			0
+#define CSR_SEQUENCEREG0B110S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B110S1 */
+#define CSR_SEQUENCEREG0B110S1_LSB			0
+#define CSR_SEQUENCEREG0B110S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B110S2 */
+#define CSR_SEQUENCEREG0B110S2_LSB			0
+#define CSR_SEQUENCEREG0B110S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B111S0 */
+#define CSR_SEQUENCEREG0B111S0_LSB			0
+#define CSR_SEQUENCEREG0B111S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B111S1 */
+#define CSR_SEQUENCEREG0B111S1_LSB			0
+#define CSR_SEQUENCEREG0B111S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B111S2 */
+#define CSR_SEQUENCEREG0B111S2_LSB			0
+#define CSR_SEQUENCEREG0B111S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B112S0 */
+#define CSR_SEQUENCEREG0B112S0_LSB			0
+#define CSR_SEQUENCEREG0B112S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B112S1 */
+#define CSR_SEQUENCEREG0B112S1_LSB			0
+#define CSR_SEQUENCEREG0B112S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B112S2 */
+#define CSR_SEQUENCEREG0B112S2_LSB			0
+#define CSR_SEQUENCEREG0B112S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B113S0 */
+#define CSR_SEQUENCEREG0B113S0_LSB			0
+#define CSR_SEQUENCEREG0B113S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B113S1 */
+#define CSR_SEQUENCEREG0B113S1_LSB			0
+#define CSR_SEQUENCEREG0B113S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B113S2 */
+#define CSR_SEQUENCEREG0B113S2_LSB			0
+#define CSR_SEQUENCEREG0B113S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B114S0 */
+#define CSR_SEQUENCEREG0B114S0_LSB			0
+#define CSR_SEQUENCEREG0B114S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B114S1 */
+#define CSR_SEQUENCEREG0B114S1_LSB			0
+#define CSR_SEQUENCEREG0B114S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B114S2 */
+#define CSR_SEQUENCEREG0B114S2_LSB			0
+#define CSR_SEQUENCEREG0B114S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B115S0 */
+#define CSR_SEQUENCEREG0B115S0_LSB			0
+#define CSR_SEQUENCEREG0B115S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B115S1 */
+#define CSR_SEQUENCEREG0B115S1_LSB			0
+#define CSR_SEQUENCEREG0B115S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B115S2 */
+#define CSR_SEQUENCEREG0B115S2_LSB			0
+#define CSR_SEQUENCEREG0B115S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B116S0 */
+#define CSR_SEQUENCEREG0B116S0_LSB			0
+#define CSR_SEQUENCEREG0B116S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B116S1 */
+#define CSR_SEQUENCEREG0B116S1_LSB			0
+#define CSR_SEQUENCEREG0B116S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B116S2 */
+#define CSR_SEQUENCEREG0B116S2_LSB			0
+#define CSR_SEQUENCEREG0B116S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B117S0 */
+#define CSR_SEQUENCEREG0B117S0_LSB			0
+#define CSR_SEQUENCEREG0B117S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B117S1 */
+#define CSR_SEQUENCEREG0B117S1_LSB			0
+#define CSR_SEQUENCEREG0B117S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B117S2 */
+#define CSR_SEQUENCEREG0B117S2_LSB			0
+#define CSR_SEQUENCEREG0B117S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B118S0 */
+#define CSR_SEQUENCEREG0B118S0_LSB			0
+#define CSR_SEQUENCEREG0B118S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B118S1 */
+#define CSR_SEQUENCEREG0B118S1_LSB			0
+#define CSR_SEQUENCEREG0B118S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B118S2 */
+#define CSR_SEQUENCEREG0B118S2_LSB			0
+#define CSR_SEQUENCEREG0B118S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B119S0 */
+#define CSR_SEQUENCEREG0B119S0_LSB			0
+#define CSR_SEQUENCEREG0B119S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B119S1 */
+#define CSR_SEQUENCEREG0B119S1_LSB			0
+#define CSR_SEQUENCEREG0B119S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B119S2 */
+#define CSR_SEQUENCEREG0B119S2_LSB			0
+#define CSR_SEQUENCEREG0B119S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B120S0 */
+#define CSR_SEQUENCEREG0B120S0_LSB			0
+#define CSR_SEQUENCEREG0B120S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B120S1 */
+#define CSR_SEQUENCEREG0B120S1_LSB			0
+#define CSR_SEQUENCEREG0B120S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B120S2 */
+#define CSR_SEQUENCEREG0B120S2_LSB			0
+#define CSR_SEQUENCEREG0B120S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B121S0 */
+#define CSR_SEQUENCEREG0B121S0_LSB			0
+#define CSR_SEQUENCEREG0B121S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B121S1 */
+#define CSR_SEQUENCEREG0B121S1_LSB			0
+#define CSR_SEQUENCEREG0B121S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B121S2 */
+#define CSR_SEQUENCEREG0B121S2_LSB			0
+#define CSR_SEQUENCEREG0B121S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQ0BGPR1 */
+#define CSR_SEQ0BGPR1_LSB				0
+#define CSR_SEQ0BGPR1_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BGPR2 */
+#define CSR_SEQ0BGPR2_LSB				0
+#define CSR_SEQ0BGPR2_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BGPR3 */
+#define CSR_SEQ0BGPR3_LSB				0
+#define CSR_SEQ0BGPR3_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BGPR4 */
+#define CSR_SEQ0BGPR4_LSB				0
+#define CSR_SEQ0BGPR4_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BGPR5 */
+#define CSR_SEQ0BGPR5_LSB				0
+#define CSR_SEQ0BGPR5_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BGPR6 */
+#define CSR_SEQ0BGPR6_LSB				0
+#define CSR_SEQ0BGPR6_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BGPR7 */
+#define CSR_SEQ0BGPR7_LSB				0
+#define CSR_SEQ0BGPR7_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BGPR8 */
+#define CSR_SEQ0BGPR8_LSB				0
+#define CSR_SEQ0BGPR8_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BFIXEDADDRBITS */
+#define CSR_SEQ0BFIXEDADDRBITS_LSB			0
+#define CSR_SEQ0BFIXEDADDRBITS_MASK			GENMASK_32(6, 0)
+#define CSR_SEQ0BCHIPLETBITS_LSB			0
+#define CSR_SEQ0BCHIPLETBITS_MASK			GENMASK_32(3, 0)
+#define CSR_SEQ0BPSTATEBITS_LSB				4
+#define CSR_SEQ0BPSTATEBITS_MASK			GENMASK_32(6, 4)
+
+/* DRTUB0 register offsets */
+/* CSR_DCTSHADOWREGS */
+#define CSR_DCTSHADOWREGS_LSB				0
+#define CSR_DCTSHADOWREGS_MASK				BIT(0)
+#define CSR_DCTWRITEPROTSHADOW_LSB			0
+#define CSR_DCTWRITEPROTSHADOW_MASK			BIT(0)
+/* CSR_DCTWRITEONLYSHADOW */
+#define CSR_DCTWRITEONLYSHADOW_LSB			0
+#define CSR_DCTWRITEONLYSHADOW_MASK			GENMASK_32(15, 0)
+/* CSR_UCTWRITEONLY */
+#define CSR_UCTWRITEONLY_LSB				0
+#define CSR_UCTWRITEONLY_MASK				GENMASK_32(15, 0)
+/* CSR_UCTWRITEPROT */
+#define CSR_UCTWRITEPROT_LSB				0
+#define CSR_UCTWRITEPROT_MASK				BIT(0)
+/* CSR_UCTDATWRITEONLY */
+#define CSR_UCTDATWRITEONLY_LSB				0
+#define CSR_UCTDATWRITEONLY_MASK			GENMASK_32(15, 0)
+/* CSR_UCTDATWRITEPROT */
+#define CSR_UCTDATWRITEPROT_LSB				0
+#define CSR_UCTDATWRITEPROT_MASK			BIT(0)
+/* CSR_UCTLERR */
+#define CSR_UCTLERR_LSB					0
+#define CSR_UCTLERR_MASK				BIT(0)
+/* CSR_UCCLKHCLKENABLES */
+#define CSR_UCCLKHCLKENABLES_LSB			0
+#define CSR_UCCLKHCLKENABLES_MASK			GENMASK_32(1, 0)
+#define CSR_UCCLKEN_LSB					0
+#define CSR_UCCLKEN_MASK				BIT(0)
+#define CSR_HCLKEN_LSB					1
+#define CSR_HCLKEN_MASK					BIT(1)
+/* CSR_CURPSTATE0B */
+#define CSR_CURPSTATE0B_LSB				0
+#define CSR_CURPSTATE0B_MASK				GENMASK_32(3, 0)
+/* CSR_CLRWAKEUPSTICKY */
+#define CSR_CLRWAKEUPSTICKY_LSB				0
+#define CSR_CLRWAKEUPSTICKY_MASK			GENMASK_32(3, 0)
+/* CSR_WAKEUPMASK */
+#define CSR_WAKEUPMASK_LSB				0
+#define CSR_WAKEUPMASK_MASK				GENMASK_32(3, 0)
+/* CSR_CUSTPUBREV */
+#define CSR_CUSTPUBREV_LSB				0
+#define CSR_CUSTPUBREV_MASK				GENMASK_32(5, 0)
+/* CSR_PUBREV */
+#define CSR_PUBREV_LSB					0
+#define CSR_PUBREV_MASK					GENMASK_32(15, 0)
+#define CSR_RESERVEDPUBREV_LSB				0
+#define CSR_RESERVEDPUBREV_MASK				GENMASK_32(3, 0)
+#define CSR_PUBMNR_LSB					4
+#define CSR_PUBMNR_MASK					GENMASK_32(7, 4)
+#define CSR_PUBMDR_LSB					8
+#define CSR_PUBMDR_MASK					GENMASK_32(11, 8)
+#define CSR_PUBMJR_LSB					12
+#define CSR_PUBMJR_MASK					GENMASK_32(15, 12)
+
+/* APBONLY0 register offsets */
+/* CSR_MICROCONTMUXSEL */
+#define CSR_MICROCONTMUXSEL_LSB				0
+#define CSR_MICROCONTMUXSEL_MASK			BIT(0)
+/* CSR_UCTSHADOWREGS */
+#define CSR_UCTSHADOWREGS_LSB				0
+#define CSR_UCTSHADOWREGS_MASK				GENMASK_32(1, 0)
+#define CSR_UCTWRITEPROTSHADOW_LSB			0
+#define CSR_UCTWRITEPROTSHADOW_MASK			BIT(0)
+#define CSR_UCTDATWRITEPROTSHADOW_LSB			1
+#define CSR_UCTDATWRITEPROTSHADOW_MASK			BIT(1)
+/* CSR_DCTWRITEONLY */
+#define CSR_DCTWRITEONLY_LSB				0
+#define CSR_DCTWRITEONLY_MASK				GENMASK_32(15, 0)
+/* CSR_DCTWRITEPROT */
+#define CSR_DCTWRITEPROT_LSB				0
+#define CSR_DCTWRITEPROT_MASK				BIT(0)
+/* CSR_UCTWRITEONLYSHADOW */
+#define CSR_UCTWRITEONLYSHADOW_LSB			0
+#define CSR_UCTWRITEONLYSHADOW_MASK			GENMASK_32(15, 0)
+/* CSR_UCTDATWRITEONLYSHADOW */
+#define CSR_UCTDATWRITEONLYSHADOW_LSB			0
+#define CSR_UCTDATWRITEONLYSHADOW_MASK			GENMASK_32(15, 0)
+/* CSR_NEVERGATECSRCLOCK */
+#define CSR_NEVERGATECSRCLOCK_LSB			0
+#define CSR_NEVERGATECSRCLOCK_MASK			BIT(0)
+/* CSR_DFICFGRDDATAVALIDTICKS */
+#define CSR_DFICFGRDDATAVALIDTICKS_LSB			0
+#define CSR_DFICFGRDDATAVALIDTICKS_MASK			GENMASK_32(5, 0)
+/* CSR_MICRORESET */
+#define CSR_MICRORESET_LSB				0
+#define CSR_MICRORESET_MASK				GENMASK_32(3, 0)
+#define CSR_STALLTOMICRO_LSB				0
+#define CSR_STALLTOMICRO_MASK				BIT(0)
+#define CSR_TESTWAKEUP_LSB				1
+#define CSR_TESTWAKEUP_MASK				BIT(1)
+#define CSR_RSVDMICRO_LSB				2
+#define CSR_RSVDMICRO_MASK				BIT(2)
+#define CSR_RESETTOMICRO_LSB				3
+#define CSR_RESETTOMICRO_MASK				BIT(3)
+/* CSR_SEQUENCEROVERRIDE */
+#define CSR_SEQUENCEROVERRIDE_LSB			0
+#define CSR_SEQUENCEROVERRIDE_MASK			GENMASK_32(10, 0)
+#define CSR_FORCESEQ0BDFIFREQ_LSB			0
+#define CSR_FORCESEQ0BDFIFREQ_MASK			GENMASK_32(4, 0)
+#define CSR_FORCESEQ0BSTART_LSB				5
+#define CSR_FORCESEQ0BSTART_MASK			BIT(5)
+#define CSR_FORCESEQ0BSTOP_LSB				6
+#define CSR_FORCESEQ0BSTOP_MASK				BIT(6)
+#define CSR_BLOCKSEQ0BREQUESTS_LSB			7
+#define CSR_BLOCKSEQ0BREQUESTS_MASK			BIT(7)
+#define CSR_BLOCKSEQ0BACK_LSB				8
+#define CSR_BLOCKSEQ0BACK_MASK				BIT(8)
+#define CSR_DISABLETERMINATEFLAG_LSB			9
+#define CSR_DISABLETERMINATEFLAG_MASK			BIT(9)
+#define CSR_SELECTDFIFREQTOGPRMUX_LSB			10
+#define CSR_SELECTDFIFREQTOGPRMUX_MASK			BIT(10)
+/* CSR_DFIINITCOMPLETESHADOW */
+#define CSR_DFIINITCOMPLETESHADOW_LSB			0
+#define CSR_DFIINITCOMPLETESHADOW_MASK			BIT(0)
+
+
+/* Fields brought to you by the letter B */
+#define BB_MIN						0
+#define BB_MAX						15
+#define BB0						0x0U
+#define BB1						0x1000U
+#define BB2						0x2000U
+#define BB3						0x3000U
+#define BB4						0x4000U
+#define BB5						0x5000U
+#define BB6						0x6000U
+#define BB7						0x7000U
+#define BB8						0x8000U
+#define BB9						0x9000U
+#define BB10						0xA000U
+#define BB11						0xB000U
+#define BB12						0xC000U
+#define BB13						0xD000U
+#define BB14						0xE000U
+#define BB15						0xF000U
+#define BBBRD						0xF000U
+/* Fields brought to you by the letter D */
+#define D_MIN						0
+#define D_MAX						3
+#define D0						0x0U
+#define D1						0x100U
+#define D2						0x200U
+#define D3						0x300U
+#define DBRD						0xF00U
+/* Fields brought to you by the letter L */
+#define L_MIN						0
+#define L_MAX						13
+#define L0						0x0U
+#define L1						0x100U
+#define L2						0x200U
+#define L3						0x300U
+#define L4						0x400U
+#define L5						0x500U
+#define L6						0x600U
+#define L7						0x700U
+#define L8						0x800U
+#define L9						0x900U
+#define L10						0xA00U
+#define L11						0xB00U
+#define L12						0xC00U
+#define L13						0xD00U
+#define LBRD						0xF00U
+/* Fields brought to you by the letter N */
+#define N_MIN						0
+#define N_MAX						15
+#define N0						0x0U
+#define N1						0x100U
+#define N2						0x200U
+#define N3						0x300U
+#define N4						0x400U
+#define N5						0x500U
+#define N6						0x600U
+#define N7						0x700U
+#define N8						0x800U
+#define N9						0x900U
+#define N10						0xA00U
+#define N11						0xB00U
+#define N12						0xC00U
+#define N13						0xD00U
+#define N14						0xE00U
+#define N15						0xF00U
+#define NBRD						0xF00U
+/* Fields brought to you by the letter P */
+#define PP_MIN						0
+#define PP_MAX						3
+#define PP0						0x0U
+#define PP1						0x100000U
+#define PP2						0x200000U
+#define PP3						0x300000U
+#define PPBRD						0x700000U
+/* Fields brought to you by the letter Q */
+#define Q_MIN						0
+#define Q_MAX						3
+#define Q0						0x0U
+#define Q1						0x100000U
+#define Q2						0x200000U
+#define Q3						0x300000U
+#define QBRD						0x700000U
+/* Fields brought to you by the letter Y */
+#define Y_MIN						0
+#define Y_MAX						0
+#define Y0						0x0U
+#define YBRD						0xF000000U
+/* Fields brought to you by the letter b */
+#define B_MIN						0
+#define B_MAX						1
+#define B0						0x0U
+#define B1						0x100U
+#define BBRD						0xF00U
+/* Fields brought to you by the letter c */
+#define C_MIN						0
+#define C_MAX						15
+#define C0						0x0U
+#define C1						0x1000U
+#define C2						0x2000U
+#define C3						0x3000U
+#define C4						0x4000U
+#define C5						0x5000U
+#define C6						0x6000U
+#define C7						0x7000U
+#define C8						0x8000U
+#define C9						0x9000U
+#define C10						0xA000U
+#define C11						0xB000U
+#define C12						0xC000U
+#define C13						0xD000U
+#define C14						0xE000U
+#define C15						0xF000U
+#define CBRD						0xF000U
+/* Fields brought to you by the letter i */
+#define I_MIN						0
+#define I_MAX						8
+#define I0						0x0U
+#define I1						0x100U
+#define I2						0x200U
+#define I3						0x300U
+#define I4						0x400U
+#define I5						0x500U
+#define I6						0x600U
+#define I7						0x700U
+#define I8						0x800U
+#define IBRD						0xF00U
+/* Fields brought to you by the letter j */
+#define J_MIN						0
+#define J_MAX						0
+#define J0						0x0U
+#define JBRD						0xF00U
+/* Fields brought to you by the letter m */
+#define M_MIN						0
+#define M_MAX						8
+#define M0						0x0U
+#define M1						0x100U
+#define M2						0x200U
+#define M3						0x300U
+#define M4						0x400U
+#define M5						0x500U
+#define M6						0x600U
+#define M7						0x700U
+#define M8						0x800U
+#define MBRD						0xF00U
+/* Fields brought to you by the letter p */
+#define P_MIN						0
+#define P_MAX						3
+#define P0						0x0U
+#define P1						0x100000U
+#define P2						0x200000U
+#define P3						0x300000U
+#define PBRD						0x700000U
+/* Fields brought to you by the letter r */
+#define R_MIN						0
+#define R_MAX						8
+#define R0						0x0U
+#define R1						0x100U
+#define R2						0x200U
+#define R3						0x300U
+#define R4						0x400U
+#define R5						0x500U
+#define R6						0x600U
+#define R7						0x700U
+#define R8						0x800U
+#define RBRD						0xF00U
+/* Fields brought to you by the letter t */
+#define T_MIN						0
+#define T_MAX						15
+#define T0						0x0U
+#define T1						0x10000U
+#define T2						0x20000U
+#define T3						0x30000U
+#define T4						0x40000U
+#define T5						0x50000U
+#define T6						0x60000U
+#define T7						0x70000U
+#define T8						0x80000U
+#define T9						0x90000U
+#define T10						0xA0000U
+#define T11						0xB0000U
+#define T12						0xC0000U
+#define T13						0xD0000U
+#define T14						0xE0000U
+#define T15						0xF0000U
+#define TBRD						0xF0000U
+/* Fields brought to you by the letter u */
+#define U_MIN						0
+#define U_MAX						1
+#define U0						0x0U
+#define U1						0x100U
+#define UBRD						0xF00U
+
+#define TACSM						0x40000U
+#define TACSMBRD					0x4F000U
+#define TALL						0xF0000U
+#define TALLBRD						0xFF000U
+#define TANIB						0x0U
+#define TANIBBRD					0xF000U
+#define TAPBONLY					0xD0000U
+#define TAPBONLYBRD					0xDF000U
+#define TDBYTE						0x10000U
+#define TDBYTEBRD					0x1F000U
+#define TDRTUB						0xC0000U
+#define TDRTUBBRD					0xCF000U
+#define TINITENG					0x90000U
+#define TINITENGBRD					0x9F000U
+#define TMASTER						0x20000U
+#define TMASTERBRD					0x2F000U
+#define TPPGC						0x70000U
+#define TPPGCBRD					0x7F000U
+#define TUCTL_MEM					0x50000U
+#define TUCTL_MEMBRD					0x5F000U
+
+#define DBYTE_NUM					9
+#define ANIB_NUM					12
+
+#endif /* DDRPHY_PHYINIT_CSR_ALL_DEFINES_H */
diff --git a/drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit.h b/drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit.h
new file mode 100644
index 000000000..97603e1bb
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef DDRPHY_PHYINIT_H
+#define DDRPHY_PHYINIT_H
+
+#include <ddrphy_phyinit_usercustom.h>
+
+#define DDRPHY_PHYINIT_RID 202006
+
+/* Global Structures : instantiated in ddrphy_globals.c */
+extern runtime_config_t runtimeconfig;
+
+extern user_input_basic_t userinputbasic;
+extern user_input_advanced_t userinputadvanced;
+extern user_input_mode_register_t userinputmoderegister;
+extern user_input_swizzle_t userinputswizzle;
+
+extern pmu_smb_ddr_1d_t mb_ddr_1d[NB_PS];
+extern pmu_smb_ddr_1d_t shdw_ddr_1d[NB_PS];
+
+/* Function definitions */
+int ddrphy_phyinit_softsetmb(int ps, char *field, int value);
+void ddrphy_phyinit_initstruct(void);
+void *ddrphy_phyinit_get_user_input_basic_base(void);
+int ddrphy_phyinit_get_user_input_basic_pllbypass_0(void);
+void *ddrphy_phyinit_get_user_input_advanced_base(void);
+void *ddrphy_phyinit_get_user_input_mode_register_base(void);
+void *ddrphy_phyinit_get_user_input_swizzle_base(void);
+
+#endif /* DDRPHY_PHYINIT_H */
diff --git a/drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit_struct.h b/drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit_struct.h
new file mode 100644
index 000000000..f381a269e
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit_struct.h
@@ -0,0 +1,1083 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef DDRPHY_PHYINIT_STRUCT_H
+#define DDRPHY_PHYINIT_STRUCT_H
+
+/*
+ * This file defines the internal data structures used in PhyInit to store user configuration.
+ *
+ * Please see \ref docref to obtain necessary information for program variables
+ * correctly for your PHY variant and process technology.
+ */
+
+#define NB_PS		1
+
+/* Enumerator for DRAM Type */
+enum dramtypes {
+	DDR4,	/* DDR4 */
+	DDR3,	/* DDR3 */
+	LPDDR4, /* LPDDR4 */
+};
+
+/* Enumerator for DIMM Type */
+enum dimmtypes {
+	NODIMM = 0x4 /* No DIMM (Soldered-on) */
+};
+
+/*
+ * Structure for basic (mandatory) user inputs
+ *
+ * The following basic data structure must be set and completed correctly so
+ * that the PhyInit software package can accurate program PHY registers.
+ */
+typedef struct user_input_basic {
+	int dramtype; /* DRAM Module Type */
+
+	/*
+	 * - must be set as hex
+	 *
+	 * Value | Description
+	 * ----- | ------
+	 *   0x0 | DDR4
+	 *   0x1 | DDR3
+	 *   0x2 | LPDDR4
+	 */
+
+	int dimmtype; /* Choose the Dimm type from one of below */
+
+	/*
+	 * - must be set as hex
+	 *
+	 * Value | Description
+	 * ----- | ------
+	 *   0x4 | No DIMM (Soldered-on)
+	 */
+
+	int lp4xmode; /* Indicates LPDDR4X mode support */
+
+	/*
+	 * - must be set as hex
+	 * - Only used for LPDDR4, but not valid here.
+	 *
+	 * Value | Description
+	 * ----- | ------
+	 *   0x0 | LPDDR4 mode, when dramtype is LPDDR4
+	 */
+
+	int numdbyte; /* Enter number of dbytes physically instantiated in RTL */
+
+	/*
+	 * - Must be decimal integer.
+	 * - Must match verilog define DDRPHY_NUM_DBYTE_*in ddrphy_*_VDEFINES.v.
+	 *   For example if DDRPHY_NUM_DBYTE_8 is defined in
+	 *   RTL ddrphy_ac12d8ch2_VDEFINES.v, this variable must be set to decimal 8.
+	 */
+
+	int numactivedbytedfi0; /* Enter number of active dbytes to be controlled by dfi0 */
+
+	/*
+	 * - See PUB databook section on supported PHY configurations for valid settings.
+	 * - Must be decimal integer.
+	 */
+
+	int numactivedbytedfi1; /* Enter number of active dbytes to be controlled by dfi1 */
+
+	/*
+	 * - See PUB databook section on supported PHY configurations for valid settings.
+	 * - Only used for LPDDR4
+	 * - Must be decimal integer.
+	 */
+
+	int numanib; /* Enter number of ANIBs physically instantiated */
+
+	/*
+	 * - See PUB databook section on supported PHY configurations for valid settings.
+	 * - Must be decimal integer.
+	 * - Must match verilog define DDRPHY_NUM_ANIB_* in ddrphy_*_VDEFINES.v
+	 *   for example if DDRPHY_NUM_ANIB_12 is defined in RTL ddrphy_ac12d8ch2_VDEFINES.v
+	 *   this variable must be set to decimal 8.
+	 */
+
+	int numrank_dfi0; /* Number of ranks in DFI0 channel */
+
+	/*
+	 * - See PUB databook section on supported PHY configurations for valid settings.
+	 * - Must match the number of DRAM ranks attached to the PHY.
+	 * - Must be decimal integer.
+	 */
+
+	int numrank_dfi1; /* Number of ranks in DFI1 channel (if DFI1 exists) */
+
+	/*
+	 * - See PUB databook section on supported PHY configurations for valid settings.
+	 * - Only used for LPDDR4
+	 * - Must match the number of DRAM ranks attached to the PHY.
+	 * - Must be decimal integer.
+	 */
+
+	int dramdatawidth; /* Width of the DRAM device */
+
+	/*
+	 * - Enter 4,8,16 or 32 depending on protocol and dram type according below table.
+	 * - Must be decimal integer.
+	 * - See PUB databook section "Supported System Configurations" for DRAM width options
+	 *   supported by your PHY product.
+	 *
+	 * Protocol | Valid Options | Default
+	 * -------- | ------------- | ---
+	 * DDR3     | 4,8,16        | 8
+	 * DDR4     | 4,8,16        | 8
+	 * LPDDR4   | 8,16          | 16
+	 *
+	 * \note LPDDR4 x8 width device will be supported in future PHY product.
+	 * For mixed x8 and x16 width devices, set variable to x8.
+	 *
+	 */
+
+	int numpstates; /* Number of p-states used */
+
+	/*
+	 * - Must be decimal integer, lower or equal to NB_PS.
+	 *   this variable must be set to decimal 1.
+	 */
+
+	int frequency[NB_PS]; /* Memclk Frequency for each PState */
+
+	/*
+	 * - Must be decimal integer.
+	 * - Memclk frequency in MHz round up to next highest integer. Enter 334 for 333.333, etc.
+	 *
+	 * [0] - P0 Memclk frequency in MHz
+	 * [1] - P1 Memclk frequency in MHz
+	 * [2] - P2 Memclk frequency in MHz
+	 * [3] - P3 Memclk frequency in MHz
+	 */
+
+	int pllbypass[NB_PS]; /* Indicates if PLL should be in Bypass mode */
+
+	/*
+	 * - See PUB Databook section "PLL Bypass Mode" under "Clocking and Timing" for
+	 *   requirements.
+	 * - At datarates below DDR333 rate PLL must be in Bypass Mode.
+	 * - Must be set as hex.
+	 *
+	 * [0] - PLL Bypass Enable for P0
+	 * [1] - PLL Bypass Enable for P1
+	 * [2] - PLL Bypass Enable for P2
+	 * [3] - PLL Bypass Enable for P3
+	 *
+	 * Value | Description
+	 * ----- | ------
+	 *   0x1 | Enabled
+	 *   0x0 | Disabled
+	 */
+
+	int dfifreqratio[NB_PS]; /* Selected Dfi Frequency ratio */
+
+	/*
+	 * - Used to program the dfifreqratio register. This register controls how dfi_freq_ratio
+	 *   input pin should be driven inaccordance with DFI Spec.
+	 * - See PUB databook section "DfiClk" on detailes on how set value.
+	 * - must be set as hex
+	 *
+	 * [0] - DFI Frequency Ratio for P0
+	 * [1] - DFI Frequency Ratio for P1
+	 * [2] - DFI Frequency Ratio for P2
+	 * [3] - DFI Frequency Ratio for P3
+	 *
+	 * Binary Value | Description
+	 *        ----- | ------
+	 *        2'b01 | 1:2 DFI Frequency Ratio (default)
+	 */
+
+	int dfi1exists; /* Indicates whether they PHY configuration has Dfi1 channel */
+
+	/*
+	 * - Must match value of Verilog define DDRPHY_DFI1_EXISTS in RTL file
+	 *   ddrphy_*_VDEFINES.v.
+	 * - must be set as hex
+	 */
+
+	int train2d; /* Obsolete. Not used. */
+
+	/*
+	 * - This variable is set via input variable to function ddrphy_phyinit_sequence()
+	 * - This exists for backward compatibility and no longer used.
+	 */
+
+	int hardmacrover; /* Hard Macro Family version in use */
+
+	/*
+	 * - Please see technology specific PHY Databook for "Hard Macro Family" version. The
+	 *   variable is used to fine tune analog register value settings.
+	 * - Must be decimal integer.
+	 *
+	 * Value | Description
+	 * ----- | ------
+	 *   3   | hardmacro family D
+	 */
+
+	int readdbienable[NB_PS]; /* Obsolete. Not Used. */
+
+	/*
+	 * - Use messageBlock DMIPinPreset instead if DBI is enabled.
+	 * - This exists for backward compatibility and no longer used.
+	 */
+
+	int dfimode; /* Obsolete. Not Used. */
+
+	/*
+	 * - dfimode register is programed based on other parameters
+	 * - This exists for backward compatibility and no longer used.
+	 */
+} user_input_basic_t;
+
+
+/* Structure for advanced (optional) user inputs
+ *
+ * If user does not enter a value for these parameters, a default recommended or
+ * default value will be used
+ */
+typedef struct user_input_advanced {
+	int lp4rxpreamblemode[NB_PS]; /* Selects between DRAM static read vs toggle read preamble */
+
+	/*
+	 * - Determine desired DRAM Read Preamble Mode based on SI Analysis and DRAM Part in use.
+	 * - the PHY training firmware will program DRAM mr1-OP[3] after training based on setting.
+	 * - must be set as hex
+	 *
+	 * [0] - setting for P0
+	 * [1] - setting for P1
+	 * [2] - setting for P2
+	 * [3] - setting for P3
+	 *
+	 * Value | Description
+	 * ----- | ------
+	 *   0x1 | toggling preamble
+	 *   0x0 | static preamble
+	 */
+
+	int lp4postambleext[NB_PS]; /* Extend write postamble in LPDDR4 */
+
+	/*
+	 * - This variable is used to calculate LPDDR4 mr3-OP[1] set in the meessageBlock.
+	 *   The training firmware will set DRAM MR according to MR value
+	 *   in the messageBlock at the end of training.
+	 * - Set value according to your SI analysis and DRAM requirement.
+	 * - Applicable only if dramtype == LPDDR4
+	 * - must be set as hex
+	 *
+	 * [0] - setting for P0
+	 * [1] - setting for P1
+	 * [2] - setting for P2
+	 * [3] - setting for P3
+	 *
+	 * Value | Description
+	 * ----- | ------
+	 *   0x0 | half Memclk postamble
+	 *   0x1 | 1.5 Memclk postabmle (defualt)
+	 */
+
+	int d4rxpreamblelength[NB_PS]; /* Length of read preamble in DDR4 mode */
+
+	/*
+	 * - This variable is used to calculate DDR4 mr4-OP[11] set in the meessageBlock.
+	 *   The training firmware will set DRAM MR according to MR value
+	 *   in the messageBlock at the end of training.
+	 * - Set value according to your SI analysis and DRAM requirement.
+	 * - Applicable only if dramtype == DDR4
+	 * - must be set as hex
+	 *
+	 * [0] - setting for P0
+	 * [1] - setting for P1
+	 * [2] - setting for P2
+	 * [3] - setting for P3
+	 *
+	 * Value | Description
+	 * ----- | ------
+	 *   0x0 |  1 Tck
+	 *   0x1 |  2 Tck (default)
+	 */
+
+	int d4txpreamblelength[NB_PS]; /* Length of write preamble in DDR4 mode */
+
+	/*
+	 * - This variable is used to calculate DDR4 mr4-OP[12] set in the meessageBlock.
+	 *   The training firmware will set DRAM MR according to MR value
+	 *   in the messageBlock at the end of training.
+	 * - Set value according to your SI analysis and DRAM requirement.
+	 * - Applicable only if dramtype == DDR4
+	 * - must be set as hex
+	 *
+	 * [0] - setting for P0
+	 * [1] - setting for P1
+	 * [2] - setting for P2
+	 * [3] - setting for P3
+	 *
+	 * Value | Description
+	 * ----- | ------
+	 *   0x0 | 1 Tck (default)
+	 *   0x1 | 2 Tck
+	 */
+
+	int extcalresval; /* External Impedance calibration pull-down resistor value select */
+
+	/*
+	 * - Indicates value of impedance calibration pull-down resistor connected to BP_ZN pin of
+	 *   the PHY. See Section "Impedance Calibrator" section in the PUB Databook for details
+	 *   on PHY impedance engine and the ZN requirements for the reference external resistor.
+	 * - must be set as hex
+	 * - Drop-down menu:
+	 *
+	 * Value | Description
+	 * ----- | ------
+	 *   0x0 | 240 ohm (default)
+	 */
+
+	int is2ttiming[NB_PS];	/*
+				 * Set to 1 to use 2T timing for address/command, otherwise 1T
+				 * timing will be used.
+				 */
+
+	/*
+	 * - See section "2T Timing and Geardown Support" in PUB Databook.
+	 *   Determine 1T or 2T Timing operation mode based on SI Analysis and DRAM Timing.
+	 *   - In 1T mode, CK, CS, CA all have the same nominal timing, ie. ATxDly[6:0] will have
+	 *     same value for all ANIBs
+	 *   - In 2T mode, CK, CS,have the same nominal timing (e.g. AtxDly[6:0]=0x00), while CA is
+	 *     delayed by 1UI
+	 *     (e.g. ATxDly[6:0]=0x40)
+	 * - This values is used to program phycfg setting in messageBlock.
+	 * - must be set as hex
+	 *
+	 * [0] - setting for P0
+	 * [1] - setting for P1
+	 * [2] - setting for P2
+	 * [3] - setting for P3
+	 *
+	 * Value | Description
+	 * ----- | ------
+	 *   0x0 | 1T Timing (default)
+	 *   0x1 | 2T Timing
+	 */
+
+	int odtimpedance[NB_PS]; /* Enter desired ODT impedance in ohm */
+
+	/*
+	 * - Used for programming TxOdtDrvStren registers.
+	 * - See "Electrical Parameters" in PHY Databook for supported ODT impedance
+	 *   range given your Hard Macro Family. Set based on Typical values from
+	 *   "On-die termination (ODT) programable resistances" in the input conditions
+	 *   table for each protocol. See table foot notes for more details.
+	 * - Based on SI Analysis and DRAM modules, select from supported values in the PHY
+	 *   Databook. Only values in the PUB databook are supported.
+	 * - Enter 0 for open/high-impedance
+	 * - Must be decimal integer.
+	 * - default:60
+	 *
+	 * [0] - ODT in Ohm for P0
+	 * [1] - ODT in Ohm for P1
+	 * [2] - ODT in Ohm for P2
+	 * [3] - ODT in Ohm for P3
+	 *
+	 */
+
+	int tximpedance[NB_PS]; /* Tx Drive Impedance for DQ/DQS in ohm */
+
+	/*
+	 * - Used for programming TxImpedanceCtrl1 registers.
+	 * - See "Electrical Parameters" in PHY Databook for supported impedance
+	 *   range given your Hard Macro Family. Set based on Typical values from
+	 *   "Outpu drive pull-up/down Impedance: DQ, DQS outputs" in "Common DC Output Paremeters"
+	 *   table for each protocol. See table foot notes for more details.
+	 * - Based on SI Analysis and DRAM modules, select from supported values in the PHY
+	 *   Databook. Only values in the PUB databook are supported.
+	 * - Enter 0 for open/high-impedance
+	 * - Must be decimal integer.
+	 * - Default value: 60
+	 * - Must be decimal integer.
+	 *
+	 * [0] - impedance in Ohm for P0
+	 * [1] - impedance in Ohm for P1
+	 * [2] - impedance in Ohm for P2
+	 * [3] - impedance in Ohm for P3
+	 */
+
+	int atximpedance; /* Tx Drive Impedance for AC in ohm */
+
+	/*
+	 * - Used for programming ATxImpedance register.
+	 * - See "Electrical Parameters" in PHY Databook for supported impedance
+	 *   range given your Hard Macro Family. Set based on Typical values from
+	 *   "Outpu drive pull-up/down Impedance: address, command, CLK outputs" in "Common DC
+	 *   Output Paremeters" table for each protocol. See table foot notes for more details.
+	 * - Based on SI Analysis and DRAM modules, select from supported values in the PHY
+	 *   Databook. Only values in the PUB databook are supported.
+	 * - Enter 0 for open/high-impedance
+	 * - Must be decimal integer.
+	 * - Default value: 20 (HMA,HMB,HMC,HMD), 40 (HME)
+	 * - Must be decimal integer.
+	 */
+
+	int memalerten; /* Enables BP_ALERT programming of PHY registers */
+
+	/*
+	 * - Used for programming MemAlertControl and MemAlertControl2 register.
+	 * - Program if you require using BP_ALERT pin (to receive or terminate signal) of the PHY
+	 *   otherwise leave at default value, otherwise leave at default value to save power.
+	 * - Applicable only if dramtype == DDR3 or DDR4, but not valid here.
+	 * - Must be hex.
+	 *
+	 * Value | Description
+	 * ----- | ------
+	 * 0x0 | Disable BP_ALERT (default)
+	 */
+
+	int memalertpuimp; /* Specify MemAlert Pull-up Termination Impedance */
+
+	/*
+	 * - Programs the pull-up termination on BP_ALERT.
+	 * - Not valid here (fixed 0 value)
+	 */
+
+	int memalertvreflevel; /* Specify the Vref level for BP_ALERT(MemAlert) Receiver */
+
+	/*
+	 * - See register description for MemAlertControl.MALERTVrefLevel in the PUB databook for
+	 *   the formula to set desired VREF by :
+	 *     Vref = VDDQ \times (0.51 + MALERTVrefLevel[6:0] \times 0.00345)
+	 * - Default VREF = 0.65 * VDDQ --> MemAlertVrefLevel[6:0] = 7'd41 = 0x29
+	 * - Must be set as hex.
+	 * - Not valid here (fixed 0 value)
+	 */
+
+	int memalertsyncbypass;	/*
+				 * When set, this bit bypasses the DfiClk synchronizer on
+				 * dfi_alert_n.
+				 */
+
+	/*
+	 * - See PUB databook register description for MemAlertControl2 for further details.
+	 * - Default = 0x0
+	 * - Must be set as hex.
+	 * - Not valid here (fixed 0 value)
+	 */
+
+	int disdynadrtri[NB_PS]; /* Disable Dynamic Per-MEMCLK Address Tristate feature */
+
+	/*
+	 * - See PUB databook section "Dynamic Per-MEMCLK Address Tristate" and register
+	 *   description of TristateModeCA.DisDynAdrTri for detailed explanation of this feature.
+	 *   Program this variable if you require to disable this feature.
+	 *   - In DDR3/2T mode, the dynamic tristate feature should be disabled
+	 *     if the controller cannot follow the 2T PHY tristate protocol.
+	 *   - In DDR4/2T/2N mode, the dynamic tristate feature should be disabled
+	 *     if the controller cannot follow the 2T PHY tristate protocol.
+	 *   - In LPDDR4 mode, the dynamic tristate feature should be disabled.
+	 * - Must be set as hex.
+	 *
+	 * Value | Description
+	 * ----- | ------
+	 *  0x1  | Disable Dynamic Tristate
+	 */
+
+	int phymstrtraininterval[NB_PS];	/*
+						 * Specifies the how frequent dfi_phymstr_req is
+						 * issued by PHY
+						 */
+
+	/*
+	 * - See PUB databook section "DFI Master Interface" and DFI 3.1
+	 *   Spec + 4.0v2 Addendum for details of DFI PHY Master interface.
+	 * - Based on SI analysis determine how frequent DRAM drift compensation and
+	 *   re-training is required.
+	 * - Determine if Memory controller supports DFI PHY Master Interface.
+	 * - Program based on desired setting for PPTTrainSetup.PhyMstrTrainInterval register.
+	 *   See register description in PUB Databook for translation table
+	 *   of values to MEMCLKs. Example values provided in below table.
+	 * - Only required in LPDDR4.
+	 * - default : 0xa
+	 * - Must be set as hex.
+	 * - Example :
+	 *
+	 * Example Value | Description
+	 * ----- | ------
+	 *   0xa | PPT Train Interval = 268435456 MEMCLKs (default)
+	 */
+
+	int phymstrmaxreqtoack[NB_PS];	/*
+					 * Max time from dfi_phymstr_req asserted to
+					 * dfi_phymstr_ack asserted.
+					 */
+
+	/*
+	 * - Based on your Memory controller's(MC) specification determine how long the PHY
+	 *   should wait for the assertion of dfi_phymstr_ack once dfi_phymstr_req has
+	 *   been issued by the PHY. If the MC does not ack the PHY's request, PHY may issue
+	 *   dfi_error.
+	 * - See PUB databook section "DFI Master Interface" and DFI 3.1
+	 *   Spec + 4.0v2 Addendum for details of DFI PHY Master interface.
+	 * - This value will be used to program PPTTrainSetup.PhyMstrMaxReqToAck register.
+	 *   See detailed register description in PUB Databook.
+	 * - default: 0x5
+	 * - Only required in LPDDR4.
+	 * - Must be set as hex.
+	 * - Example:
+	 *
+	 * Value | Description
+	 * ----- | ------
+	 *   0x5 | PPT Max. Req to Ack. = 8192 MEMCLKs (default)
+	 */
+
+	int wdqsext; /* Enable Write DQS Extension feature of PHY */
+
+	/*
+	 * - See App Note "Cores LPDDR4 MultiPHY : WDQS Extension Application Note"
+	 * - Must be set as hex.
+	 *
+	 * Value | Description
+	 * ----- | ------
+	 *   0x0 | Disable Write DQS Extension feature. (default)
+	 *   0x1 | Enable Write DQS Extension feature.
+	 */
+
+	int calinterval; /* Specifies the interval between successive calibrations, in mS */
+
+	/*
+	 * - See PUB Databook section "Impedance Calibrator" to learn about PHY Impedance
+	 *   calibration FSM. Based on feedback from SI analysis, determine desired
+	 *   calibration interval for your System.
+	 * - Program variable based on desired setting for CalRate.CalInterval register.
+	 *   See detailed register description in PUB Databook.
+	 * - must be set as hex
+	 * - Fixed 0x9 value (20mS interval)
+	 */
+
+	int calonce; /* This setting changes the behaviour of CalRun register */
+
+	/*
+	 * - See PUB Databook section "Impedance Calibrator" to learn about PHY Impedance
+	 *   calibration FSM. Based on feedback from SI analysis, determine desired
+	 *   calibration interval for your System.
+	 * - If you desire to manually trigger impedance calibration in mission mode set
+	 *   this variable to 1, and toggle CalRun in mission mode. See PUB Databook section
+	 *   "Impedance Calibration Engine Setup" and register description for CalRate.CalOnce.
+	 * - must be set as hex
+	 *
+	 * Value | Description
+	 * ----- | ------
+	 * 0x0   | Calibration will proceed at the rate determined by CalInterval. This field should
+	 *         only be changed while the calibrator is idle. ie before csr CalRun is set.
+	 */
+
+	int lp4rl[NB_PS]; /* LPDDR4 Dram Read Latency */
+
+	/*
+	 * - This variable is used to calculate LPDDR4 mr2-OP[2:0] set in the meessageBlock.
+	 *   The training firmware will set DRAM MR according to MR value
+	 *   in the messageBlock at the end of training.
+	 * - Please refer to JEDEC JESD209-4A (LPDDR4) Spec for definition of MR.
+	 * - Determine values based on your DRAM part's supported speed and
+	 *   latency bin.
+	 * - Default: calculated based on user_input_basic.frequency
+	 *   and "JEDEC JESD209-4A (LPDDR4)" Table 28 "Read and Write Latencies".
+	 *   Lowest latency selected when more than one latency can be used.
+	 *   for example given configuration for LPDDR4, x16, NoDbi and DDR533,
+	 *   RL=10 is selected rather than 14.
+	 * - must be set as hex
+	 * - Applicable only if dramtype == LPDDR4
+	 *
+	 * [0] - setting for P0
+	 * [1] - setting for P1
+	 * [2] - setting for P2
+	 * [3] - setting for P3
+	 */
+
+	int lp4wl[NB_PS]; /* LPDDR4 Dram Write Latency */
+
+	/*
+	 * - This variable is used to calculate LPDDR4 mr2-OP[5:3] set in the meessageBlock.
+	 *   The training firmware will set DRAM MR according to MR value
+	 *   in the messageBlock at the end of training.
+	 * - Please refer to JEDEC JESD209-4A (LPDDR4) Spec for definition of MR.
+	 * - Determine values based on your DRAM part's supported speed and
+	 *   latency bin.
+	 * - Default: calculated based on user_input_basic.frequency
+	 *   and "JEDEC JESD209-4A (LPDDR4)" Table 28 "Read and Write Latencies".
+	 *   Lowest latency selected when more than one latency can be used.
+	 * - must be set as hex
+	 * - Applicable only if dramtype == LPDDR4
+	 *
+	 * [0] - setting for P0
+	 * [1] - setting for P1
+	 * [2] - setting for P2
+	 * [3] - setting for P3
+	 */
+
+	int lp4wls[NB_PS]; /* LPDDR4 Dram WL Set */
+
+	/*
+	 * - This variable is used to calculate LPDDR4 mr2-OP[6] set in the meessageBlock.
+	 *   The training firmware will set DRAM MR according to MR value
+	 *   in the messageBlock at the end of training.
+	 * - Please refer to JEDEC JESD209-4A (LPDDR4) Spec for definition of MR.
+	 * - Determine value based on Memory controllers requirement of DRAM State after
+	 *   PHY training.
+	 * - must be set as hex
+	 * - Applicable only if dramtype == LPDDR4
+	 */
+
+	/*
+	 * [0] - setting for P0
+	 * [1] - setting for P1
+	 * [2] - setting for P2
+	 * [3] - setting for P3
+	 *
+	 * Value | Description
+	 *   --- | ---
+	 *   0x0 | WL Set "A" (default)
+	 */
+
+	int lp4dbird[NB_PS]; /* LPDDR4 Dram DBI-Read Enable */
+
+	/*
+	 * - Determine if you require to using DBI for the given PState.
+	 *   If Read DBI is not used PHY receivers are turned off to save power.
+	 * - This variable is used to calculate LPDDR4 mr3-OP[6] set in the meessageBlock.
+	 *   The training firmware will set DRAM MR according to MR value
+	 *   in the messageBlock at the end of training.
+	 * - PHY register DMIPinPresent is programmed based on this parameter.
+	 * - Please refer to JEDEC JESD209-4A (LPDDR4) Spec for definition of MR.
+	 * - Applicable only if dramtype == LPDDR4
+	 * - must be set as hex
+	 *
+	 * [0] - setting for P0
+	 * [1] - setting for P1
+	 * [2] - setting for P2
+	 * [3] - setting for P3
+	 *
+	 * Value | Description
+	 *   --- | ---
+	 *   0x0 | Disabled (default)
+	 *   0x1 | Enabled
+	 */
+
+	int lp4dbiwr[NB_PS]; /* LPDDR4 Dram DBI-Write Enable */
+
+	/*
+	 * - This variable is used to calculate LPDDR4 mr3-OP[7] set in the meessageBlock.
+	 *   The training firmware will set DRAM MR according to MR value
+	 *   in the messageBlock at the end of training.
+	 * - Please refer to JEDEC JESD209-4A (LPDDR4) Spec for definition of MR.
+	 * - Applicable only if dramtype == LPDDR4
+	 * - must be set as hex
+	 *
+	 * [0] - setting for P0
+	 * [1] - setting for P1
+	 * [2] - setting for P2
+	 * [3] - setting for P3
+	 *
+	 * Value | Description
+	 *   --- | ---
+	 *   0x0 | Disabled (default)
+	 *   0x1 | Enabled
+	 */
+
+	int lp4nwr[NB_PS]; /* LPDDR4 Write-Recovery for Auto- Pre-charge commands */
+
+	/*
+	 * - This variable is used to calculate LPDDR4 mr1-OP[6:4] set in the meessageBlock.
+	 *   The training firmware will set DRAM MR according to MR value
+	 *   in the messageBlock at the end of training.
+	 * - Please refer to JEDEC JESD209-4A (LPDDR4) Spec for definition of MR.
+	 * - Determine values based on your DRAM part's supported speed and
+	 *   latency bin.
+	 * - Default: calculated based on user_input_basic.frequency
+	 *   and "JEDEC JESD209-4A (LPDDR4)" Table 28 "Read and Write Latencies".
+	 *   Lowest latency selected when more than one latency can be used.
+	 * - must be set as hex
+	 * - Applicable only if dramtype == LPDDR4
+	 *
+	 * [0] - setting for P0
+	 * [1] - setting for P1
+	 * [2] - setting for P2
+	 * [3] - setting for P3
+	 *
+	 * Binary Value | Description
+	 * --- | ---
+	 * 000 | nWR = 6 (default)
+	 * 001 | nWR = 10
+	 * 010 | nWR = 16
+	 * 011 | nWR = 20
+	 * 100 | nWR = 24
+	 * 101 | nWR = 30
+	 * 110 | nWR = 34
+	 * 111 | nWR = 40
+	 */
+
+	int lp4lowpowerdrv; /* Configure output Driver in Low power mode */
+
+	/*
+	 * - Feature only supported for Hard Macro Family E (HME)
+	 * - Use NMOS Pull-up for Low-Power IO
+	 * - Not valid here
+	 */
+
+	int drambyteswap; /* DRAM Oscillator count source mapping for skip_training */
+
+	/*
+	 * - The PHY supports swapping of DRAM oscillator count values between paired DBytes for the
+	 *   purpose of tDQSDQ DRAM Drift Compensation(DDC).
+	 * - Each DByte has a register bit to control the source of the oscillator count value used
+	 *   to perform tDQSDQ Drift compensation.
+	 *   On silicon the training firmware will determine the DByte swap and program
+	 *   PptCtlStatic register to select oscillator count source. When skip_train is used,
+	 *   training firmware is skipped thus manual programming may be required depending on
+	 *   configuration.
+	 * - The default hardware configuration is for odd Dbyte instance n to use oscillator count
+	 *   values from its paired Dbyte instance n-1. So Dbyte1 will use the oscillator count
+	 *   values from Dbyte0, Dbyte3 will use Dbyte2 and so on. This is required for DRAM Data
+	 *   width =16.
+	 * - Each bit of this field corresponds to a DBYTE:
+	 *   - bit-0 = setting for DBYTE0
+	 *   - bit-1 = setting for DBYTE1
+	 *   - bit-2 = setting for DBYTE2
+	 *   - . . .
+	 *   - bit-n = setting for DBYTEn
+	 * - By setting the associated bit for each DByte to 1, PHY will use non-default source for
+	 *   count value.
+	 *   - for even Dbytes, non-default source is to use the odd pair count value.
+	 *   - for odd Dbytes, no-default source to use data received directly from the DRAM.
+	 * - Byte swapping must be the same across different ranks.
+	 * - must be set as hex
+	 * - default : 0x0
+	 * - if Byte mode devices are indicated via the x8mode messageBlock parameter, this variable
+	 *   is ignored as PHY only supports a limited configuration set based on Byte mode
+	 *   configuration.
+	 *
+	 * Example:
+	 *   DramByteSwap = 0x03 - Dbyte0: use count values from Dbyte1, Dbyte1 uses count values
+	 *   received directly received from DRAM.
+	 *   Rest of Dbytes have default source for DRAM oscilator count.
+	 */
+
+	int rxenbackoff; /* Determines the Placement of PHY Read Gate signal */
+
+	/*
+	 * - Only used in LPDDR4 when lp4rxpreamblemode==0 (static preamble) for skip_train==true
+	 *   For other dramtypes or LPDDR4-toggling-preamble no options are available and
+	 *   PhyInit will set position as required. See source code in
+	 *   ddrphy_phyinit_c_initphyconfig() to see how the RxEnBackOff register is set.
+	 * - For skip_train==false, FW will set the position based on Preamble.
+	 * - We recommend keeping this setting at default value.
+	 *   SI analysis is required to determine if default value needs to be changed.
+	 * - must be set as hex
+	 *
+	 * Value | Description
+	 * ----- | ---
+	 *   0x1 | Position read gate 1UI from the first valid edge of DQS_t
+	 *         (LPDDR4 Static preamble only) (default)
+	 */
+
+	int trainsequencectrl; /* Firmware Training Sequence Control */
+
+	/*
+	 * - This input is used to program sequencectrl in messageBlock.
+	 *   It controls the training stages executed by firmware.
+	 *   consult the training firmware App Note section "1D Training Steps" for details on
+	 *   training stages.
+	 * - For production silicon we recommend to use default value programmed by PhyInit.
+	 * - If running simulation for the first time, program value according to "Initial
+	 *   interactions with the firmware" section in Training firmware App Note.
+	 */
+
+	int snpsumctlopt;	/*
+				 * Enable Fast Frequency Change (FFC) Optimizations specific to
+				 * UMCTL2.
+				 */
+
+	/*
+	 * - Consult UMCTL2 documentation to ensure when optimizations can be enabled.
+	 * - Not valid for dimmtype=NODIMM
+	 * - must be set as hex
+	 *
+	 * Value | Description
+	 * ----- | ---
+	 * 0 | Disable FFC MRW optimization (default)
+	 */
+
+	int snpsumctlf0rc5x[NB_PS];	/*
+					 * F0RX5x RCD Control Word when using Fast Frequency
+					 * Change(FFC) optimizations specific to UMCTL2
+					 */
+
+	/*
+	 * - When UMCTL2 optimizations are enabled PHY will perform RCD MRW during fast frequency
+	 *   change request.
+	 *   The correct RCD control word value for each PState must be programmed in this field.
+	 *   Consult the RCD spec and UMCTL documentation to determine the correct value based on
+	 *   DRAM configuration and operating speed.
+	 * - Not valid for dimmtype=NODIMM
+	 * - Only valid for when SnpsUmctlOpt=1
+	 * - must be set as hex
+	 *
+	 * [0] - F0RC5x for PState 0
+	 * [1] - F0RC5x for PState 1
+	 * [2] - F0RC5x for PState 2
+	 * [3] - F0RC5x for PState 3
+	 */
+
+	int txslewrisedq[NB_PS]; /* Pull-up slew rate control for DBYTE Tx */
+
+	/*
+	 * - Value specified here will be written to register TxSlewRate.TxPreP by PhyInit.
+	 *   See register description for more information.
+	 * - Please consult the "Output Slew Rate" section of DQ Hspice App Note in
+	 *   specific technology for recommended settings for your technology and Hard Macro Family.
+	 *   Protocol specific values are provided under the rise_index column.
+	 * - must be set as hex
+	 *
+	 * [0] - setting for PState 0
+	 * [1] - setting for PState 1
+	 * [2] - setting for PState 2
+	 * [3] - setting for PState 3
+	 */
+
+	int txslewfalldq[NB_PS]; /* Pull-down slew rate control for DBYTE Tx */
+
+	/*
+	 * - Value specified here will be written to TxSlewRate.TxPreN by PhyInit.
+	 *   See register description for more information.
+	 * - Please consult the "Output Slew Rate" section of DQ HSPICE App Note in
+	 *   specific technology for recommended settings for your technology and Hard Macro Family.
+	 * - Protocol specific values are provided under the fall_index column.
+	 * - must be set as hex
+	 *
+	 * [0] - setting for PState 0
+	 * [1] - setting for PState 1
+	 * [2] - setting for PState 2
+	 * [3] - setting for PState 3
+	 */
+
+	int txslewriseac; /* Pull-up slew rate control for ANIB Tx */
+
+	/*
+	 * - Value specified here will be written to ATxSlewRate.ATxPreP
+	 *   See register description for more information.
+	 * - Please consult the "Output Slew Rate" section of CA HSPICE Model App Note in
+	 *   specific technology for recommended settings for your technology and Hard Macro Family.
+	 * - Protocol specific values are provided under the rise_index column.
+	 * - must be set as hex
+	 */
+
+	int txslewfallac; /* Pull-down slew rate control for ANIB Tx */
+
+	/*
+	 * - Value specified here will be written to ATxSlewRate.ATxPreN
+	 *   See register description for more information.
+	 * - Please consult the "Output Slew Rate" section of CA HSPICE Model App Note in
+	 *   specific technology for recommended settings for your technology and Hard Macro Family.
+	 * - Protocol specific values are provided under the fall_index column.
+	 * - must be set as hex
+	 */
+
+	int disableretraining; /* Disable PHY DRAM Drift compensation re-training */
+
+	/*
+	 * - Disable PHY re-training during DFI frequency change requests in LPDDR4.
+	 *   See Firmware Training App Note section "DRAM Drift Compensation" for details of steps
+	 *   in re-training.
+	 * - The purpose of retraining is to compensate for drift in the DRAM.
+	 *   Determine based on SI analysis and DRAM datasheet if retraining can be disabled.
+	 * - Only applied to LPDDR4. No retraining is required in DDR4/3.
+	 * - must be set as hex
+	 *
+	 * Value | Description
+	 * ----- | ---
+	 *   0x1 | Disable retraining
+	 *   0x0 | Enable retraining
+	 */
+
+	int disablephyupdate; /* Disable DFI PHY Update feature */
+
+	/*
+	 * - Disable DFI PHY Update feature. When set PHY will not assert dfi0/1_phyupd_req.
+	 *   See DFI specification for DFI PHY update interface. See PUB databook section
+	 *   "PHY Update" for details of the DFI PHY update interface implementation.
+	 * - Only effects LPDDR4
+	 * - must be set as hex
+	 *
+	 * Value | Description
+	 * ----- | ---
+	 *   0x1 | Disable DFI PHY Update
+	 *   0x0 | Enable DFI PHY Update
+	 */
+
+
+	int enablehighclkskewfix;	/*
+					 * Enable alternative PIE program
+					 *
+					 * See STAR 9001264921 for details on this workaround.
+					 * If enabled the PIE reinitializes the FIFO pointers a
+					 * second time due for designs with large skew between
+					 * chiplet DfiClk branches. If enabled PIE latencies in all
+					 * protocols are increased by 60 DfiClks.
+					 *
+					 * Value | Description
+					 * ----- | ---
+					 *   0x0 | Disable (default)
+					 */
+
+	int disableunusedaddrlns;       /*
+					 * Turn off or tristate Address Lanes when possible.
+					 *
+					 * - When enabled, PHY will tristate unused address lanes to
+					 *   save power when possible by using Acx4AnibDis and
+					 *   AForceTriCont registers.
+					 * - This feature is only implemented for the default PHY
+					 *   Address bump mapping and Ranks must be populated in
+					 *   order. ie Rank1 cannot be used if Rank0 is unpopulated.
+					 * - For alternative bump mapping follow the following
+					 *   guideline to achieve maximum power savings:
+					 *   - For each unused BP_A bump program AForceTriCont[4:0]
+					 *     bits based on register description.
+					 *   - if all lanes of an Anib are unused _AND_ ANIB is not
+					 *     the first or last instance set bit associated with
+					 *     the instance in Acs4AnibDis registers. see register
+					 *     description for details.
+					 *
+					 * \note This feature is BETA and untested. Future PhyInit
+					 *       version will fully enable this feature.
+					 *
+					 * Value | Description
+					 * ----- | ---
+					 *   0x1 | Enable
+					 */
+
+	int phyinitsequencenum;		/*
+					 * Switches between supported phyinit training sequences
+					 *   refer to "Alternative PHY Training sequence" document
+					 *   for further details.
+					 *
+					 * Value | Description
+					 * ----- | ---
+					 *   0x0 | Minimizes number of Imem/Dmem loads (default)
+					 */
+
+	int enabledficspolarityfix;     /*
+					 * Enable alternative PIE program
+					 *
+					 * See STAR 9001524249 for details on this workaround. Set
+					 * to 1 if PUB_VERSION <2.43a, otherwise set to 0. If
+					 * enabled the PIE programs Dfi{Rd,Wr}DataCsDestMap CSR's
+					 * to default values 0x00E4 before running PPT.
+					 * Before exiting PPT, PIE will restore
+					 * Dfi{Rd,Wr}DataCsDestMap CSR's to 0x00E1.
+					 *
+					 * Value | Description
+					 * ----- | ---
+					 *   0x0 | Disable (default)
+					 */
+
+	int phyvref;			/*
+					 * Must be programmed with the Vref level to be used by the
+					 * PHY during reads
+					 *
+					 * The units of this field are a percentage of VDDQ
+					 * according to the following equation:
+					 *
+					 * Receiver Vref = VDDQ*phyvref[6:0]/128
+					 *
+					 * For example to set Vref at 0.75*VDDQ, set this field to
+					 * 0x60.
+					 *
+					 * For digital simulation, any legal value can be used. For
+					 * silicon, the users must calculate the analytical Vref by
+					 * using the impedances, terminations, and series resistance
+					 * present in the system.
+					 */
+
+	int sequencectrl[NB_PS];	/*
+					 * Controls the training steps to be run. Each bit
+					 * corresponds to a training step.
+					 *
+					 * If the bit is set to 1, the training step will run.
+					 * If the bit is set to 0, the training step will be
+					 * skipped.
+					 *
+					 * Training step to bit mapping:
+					 * sequencectrl[0] = Run DevInit - Device/phy
+					 *		     initialization. Should always be set.
+					 * sequencectrl[1] = Run WrLvl - Write leveling
+					 * sequencectrl[2] = Run RxEn - Read gate training
+					 * sequencectrl[3] = Run RdDQS1D - 1d read dqs training
+					 * sequencectrl[4] = Run WrDQ1D - 1d write dq training
+					 * sequencectrl[5] = RFU, must be zero
+					 * sequencectrl[6] = RFU, must be zero
+					 * sequencectrl[7] = RFU, must be zero
+					 * sequencectrl[8] = Run RdDeskew - Per lane read dq deskew
+					 *		     training
+					 * sequencectrl[9] = Run MxRdLat - Max read latency training
+					 * sequencectrl[10] = RFU, must be zero
+					 * sequencectrl[11] = RFU, must be zero
+					 * sequencectrl[12] = RFU, must be zero
+					 * sequencectrl[13] = RFU, must be zero
+					 * sequencectrl[15-14] = RFU, must be zero
+					 */
+} user_input_advanced_t;
+
+/*
+ * Structure for mode register (mandatory) user inputs
+ *
+ * The following basic data structure must be set and completed correctly so
+ * that the PhyInit software package can accurate fill message block structure.
+ * Only some mrx are used per DDR type, on related width:
+ * - DDR3: mr0..2 are used (16-bits values)
+ * - DDR4: mr0..6 are used (16-bits values)
+ * - LPDDR4: mr1..4 and mr11..22 are used (8-bits values)
+ */
+typedef struct user_input_mode_register {
+	int mr0[NB_PS];
+	int mr1[NB_PS];
+	int mr2[NB_PS];
+	int mr3[NB_PS];
+	int mr4[NB_PS];
+	int mr5[NB_PS];
+	int mr6[NB_PS];
+	int mr11[NB_PS];
+	int mr12[NB_PS];
+	int mr13[NB_PS];
+	int mr14[NB_PS];
+	int mr22[NB_PS];
+} user_input_mode_register_t;
+
+/*
+ * Structure for swizzle (mandatory) user inputs
+ *
+ * The following basic data structure must be set and completed correctly so
+ * that the PhyInit software package can accurate set swizzle (IO muxing) config.
+ * Only some swizzles are used per DDR type:
+ * - DDR3/DDR3: swizzle 0..32 are used
+ *   - 26 for hwtswizzle
+ *   - 7 for acswizzle
+ * - LPDDR4:  swizzle 0..43 are used
+ *   - 8 per byte for dqlnsel (total 32)
+ *   - 6 for mapcaatodfi
+ *   - 6 for mapcabtodfi
+ */
+#define NB_HWT_SWIZZLE			26
+#define NB_AC_SWIZZLE			7
+#define NB_DQLNSEL_SWIZZLE_PER_BYTE	8
+#define NB_MAPCAATODFI_SWIZZLE		6
+#define NB_MAPCABTODFI_SWIZZLE		6
+#define NB_SWIZZLE	44
+typedef struct user_input_swizzle {
+	int swizzle[NB_SWIZZLE];
+} user_input_swizzle_t;
+
+#endif /* DDRPHY_PHYINIT_STRUCT_H */
+
diff --git a/drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit_usercustom.h b/drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit_usercustom.h
new file mode 100644
index 000000000..b4c659e20
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit_usercustom.h
@@ -0,0 +1,184 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef DDRPHY_PHYINIT_USERCUSTOM_H
+#define DDRPHY_PHYINIT_USERCUSTOM_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include <ddrphy_phyinit_struct.h>
+
+/*
+ * -------------------------------------------------------------
+ * Defines for Firmware Images
+ * - point to IMEM/DMEM incv files,
+ * - indicate IMEM/DMEM size (bytes)
+ * -------------------------------------------------------------
+ *
+ * FW_FILES_LOC set the location of training firmware uncompressed path.
+ *   PhyInit will use this path to load the imem and dmem incv files of the
+ *   firmware image.
+ *
+ * IMEM_INCV_FILENAME firmware instruction memory (imem) filename for 1D training
+ *
+ * DMEM_INCV_FILENAME firmware data memory (dmem) filename for 1D training.
+ *
+ * IMEM_SIZE max size of instruction memory.
+ *
+ * DMEM_SIZE max size of data memory.
+ *
+ * DMEM_ST_ADDR start of DMEM address in memory.
+ */
+#ifndef FW_FILES_LOC
+#define FW_FILES_LOC "./fw"
+#endif /* FW_FILES_LOC */
+
+#if STM32MP_DDR3_TYPE
+#define IMEM_INCV_FILENAME	FW_FILES_LOC "/ddr3/ddr3_pmu_train_imem.incv"
+#define DMEM_INCV_FILENAME	FW_FILES_LOC "/ddr3/ddr3_pmu_train_dmem.incv"
+#elif STM32MP_DDR4_TYPE
+#define IMEM_INCV_FILENAME	FW_FILES_LOC "/ddr4/ddr4_pmu_train_imem.incv"
+#define DMEM_INCV_FILENAME	FW_FILES_LOC "/ddr4/ddr4_pmu_train_dmem.incv"
+#elif STM32MP_LPDDR4_TYPE
+#define IMEM_INCV_FILENAME	FW_FILES_LOC "/lpddr4/lpddr4_pmu_train_imem.incv"
+#define DMEM_INCV_FILENAME	FW_FILES_LOC "/lpddr4/lpddr4_pmu_train_dmem.incv"
+#endif /* STM32MP_LPDDR4_TYPE */
+
+#if STM32MP_DDR3_TYPE
+#define IMEM_SIZE			0x4b94
+#define DMEM_SIZE			0x6c8
+#elif STM32MP_DDR4_TYPE
+#define IMEM_SIZE			0x6ac8
+#define DMEM_SIZE			0x6cc
+#elif STM32MP_LPDDR4_TYPE
+#define IMEM_SIZE			0x7ec6
+#define DMEM_SIZE			0x67c
+#endif
+#define IMEM_ST_ADDR			0x50000
+#define DMEM_ST_ADDR			0x54000
+#define DMEM_BIN_OFFSET			0x200
+
+/*
+ * -------------------------------------------------------------
+ * Defines for SR Firmware Images
+ * - point to IMEM incv files,
+ * - indicate IMEM size (bytes)
+ * -------------------------------------------------------------
+ *
+ * SR_FW_FILES_LOC location of optional retention save restore firmware image.
+ *
+ * SR_IMEM_SIZE max IMEM size of retention save/restore firmware.
+ *
+ * SR_IMEM_INCV_FILENAME file name of retention save/restore IMEM image.
+ */
+#ifndef SR_FW_FILES_LOC
+#define SR_FW_FILES_LOC		FW_FILES_LOC "/save_restore"
+#endif /* SR_FW_FILES_LOC */
+
+#define SR_IMEM_SIZE		16384
+#define SR_IMEM_INCV_FILENAME	SR_FW_FILES_LOC "/ddrphy_io_retention_save_restore_imem.incv"
+
+/* Message Block Structure Definitions */
+#if STM32MP_DDR3_TYPE
+#include <mnpmusrammsgblock_ddr3.h>
+#elif STM32MP_DDR4_TYPE
+#include <mnpmusrammsgblock_ddr4.h>
+#elif STM32MP_LPDDR4_TYPE
+#include <mnpmusrammsgblock_lpddr4.h>
+#endif /* STM32MP_LPDDR4_TYPE */
+
+/*
+ * ------------------
+ * Type definitions
+ * ------------------
+ */
+
+/* A structure used to SRAM memory address space. */
+typedef enum { return_offset, return_lastaddr } return_offset_lastaddr_t;
+
+/* A structure to store the sequence function runtime input variables. */
+typedef struct runtime_config {
+	bool	skip_train;	/* skip_train input parameter */
+	bool	reten;		/*
+				 * Retention Enable input parameter, instructs phyinit to issue
+				 * register reads during initialization to retention registers.
+				 */
+} runtime_config_t;
+
+/* Enumeration of instructions for PhyInit Register Interface */
+typedef enum {
+	starttrack,	/* Start register tracking */
+	stoptrack,	/* Stop register tracking */
+	saveregs,	/* Save(read) tracked register values */
+	restoreregs,	/* Restore (write) saved register values */
+	dumpregs,	/* Write register address,value pairs to file */
+	importregs	/* Import register address,value pairs to file */
+} reginstr;
+
+/* Data structure to store register address, value pairs */
+typedef struct reg_addr_val {
+	uint32_t	address;	/* Register address */
+	uint16_t	value;		/* Register value */
+} reg_addr_val_t;
+
+/* TargetCSR Target CSR for the impedance value for ddrphy_phyinit_mapdrvstren() */
+enum drvtype {
+	drvstrenfsdqp,
+	drvstrenfsdqn,
+	odtstrenp,
+	odtstrenn,
+	adrvstrenp,
+	adrvstrenn
+};
+
+/*
+ * -------------------------------
+ * Global variables - defined in ddrphy_phyinit_globals.c
+ * -------------------------------
+ */
+
+extern int ardptrinitval[NB_PS];
+
+/*
+ * -------------------------------------------------------------
+ * Fixed Function prototypes
+ * -------------------------------------------------------------
+ */
+int ddrphy_phyinit_sequence(bool skip_training, bool reten);
+int ddrphy_phyinit_restore_sequence(void);
+int ddrphy_phyinit_c_initphyconfig(void);
+void ddrphy_phyinit_d_loadimem(void);
+void ddrphy_phyinit_progcsrskiptrain(bool skip_training);
+int ddrphy_phyinit_f_loaddmem(int pstate);
+int ddrphy_phyinit_g_execfw(void);
+void ddrphy_phyinit_h_readmsgblock(void);
+void ddrphy_phyinit_i_loadpieimage(bool skip_training);
+void ddrphy_phyinit_loadpieprodcode(void);
+int ddrphy_phyinit_mapdrvstren(int drvstren_ohm, enum drvtype targetcsr);
+void ddrphy_phyinit_storemsgblk(void *msgblkptr, int sizeofmsgblk, int mem[]);
+int ddrphy_phyinit_calcmb(void);
+int ddrphy_phyinit_storeincvfile(char *incv_file_name, int mem[],
+				 return_offset_lastaddr_t return_type);
+void ddrphy_phyinit_writeoutmem(uint32_t *mem, int mem_offset, int mem_size);
+void ddrphy_phyinit_writeoutmsgblk(uint16_t *mem, int mem_offset, int mem_size);
+int ddrphy_phyinit_isdbytedisabled(int dbytenumber);
+int ddrphy_phyinit_trackreg(uint32_t adr);
+int ddrphy_phyinit_reginterface(reginstr myreginstr, uint32_t adr, uint16_t dat);
+
+extern void ddrphy_phyinit_usercustom_a_bringuppower(void);
+extern void ddrphy_phyinit_usercustom_b_startclockresetphy(void);
+extern void ddrphy_phyinit_usercustom_custompretrain(void);
+extern void ddrphy_phyinit_usercustom_customposttrain(void);
+extern int ddrphy_phyinit_usercustom_e_setdficlk(int dfi_frequency);
+extern int ddrphy_phyinit_usercustom_g_waitfwdone(void);
+extern void ddrphy_phyinit_usercustom_h_readmsgblock(void);
+extern void ddrphy_phyinit_usercustom_j_entermissionmode(void);
+extern int ddrphy_phyinit_usercustom_saveretregs(void);
+
+#include <ddrphy_csr_all_cdefines.h>
+
+#endif /* DDRPHY_PHYINIT_USERCUSTOM_H */
diff --git a/drivers/st/ddr/phy/phyinit/include/ddrphy_wrapper.h b/drivers/st/ddr/phy/phyinit/include/ddrphy_wrapper.h
new file mode 100644
index 000000000..165aeaed9
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/include/ddrphy_wrapper.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef DDRPHY_WRAPPER_H
+#define DDRPHY_WRAPPER_H
+
+static inline long long fmodll(long long x, long long y)
+{
+	return x - ((x / y) * y);
+}
+
+static inline int fmodi(int x, int y)
+{
+	return (int)fmodll((long long)x, (long long)y);
+}
+
+#endif /* DDRPHY_WRAPPER_H */
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_c_initphyconfig.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_c_initphyconfig.c
new file mode 100644
index 000000000..9e87a49d8
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_c_initphyconfig.c
@@ -0,0 +1,1331 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdlib.h>
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+#include <lib/utils_def.h>
+
+#include <ddrphy_phyinit.h>
+#include <ddrphy_wrapper.h>
+
+#include <platform_def.h>
+
+/*
+ * Program txslewrate:
+ * - txslewrate::txpredrvmode is dependent on dramtype.
+ * - txslewrate::txprep and txslewrate::txpren are technology-specific.
+ *   User should consult the "Output Slew Rate" section of HSpice Model App Note in specific
+ *   technology for recommended settings.
+ */
+static void txslewrate_program(void)
+{
+	int pstate;
+	int txpredrvmode;
+
+#if STM32MP_DDR3_TYPE
+	txpredrvmode = 0x3;
+#elif STM32MP_DDR4_TYPE
+	txpredrvmode = 0x2;
+#elif STM32MP_LPDDR4_TYPE
+	txpredrvmode = 0x1;
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int byte;
+		int p_addr;
+		int txpren; /* Default to 0xf (max). Optimal setting is technology specific. */
+		int txprep; /* Default to 0xf (max). Optimal setting is technology specific. */
+		uint16_t txslewrate;
+
+		p_addr = pstate << 20;
+
+		txprep = userinputadvanced.txslewrisedq[pstate];
+		txpren = userinputadvanced.txslewfalldq[pstate];
+
+		txslewrate = (uint16_t)((txpredrvmode << CSR_TXPREDRVMODE_LSB) |
+					(txpren << CSR_TXPREN_LSB) |
+					(txprep << CSR_TXPREP_LSB));
+
+		for (byte = 0; byte < userinputbasic.numdbyte; byte++) {
+			int c_addr;
+			int lane;
+
+			c_addr = byte << 12;
+			for (lane = 0; lane <= B_MAX; lane++) {
+				int b_addr;
+
+				b_addr = lane << 8;
+				mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TDBYTE |
+									      c_addr | b_addr |
+									      CSR_TXSLEWRATE_ADDR)),
+					      txslewrate);
+			}
+		}
+	}
+}
+
+/*
+ * Program atxslewrate:
+ * - atxslewrate::atxpredrvmode is dependent on dramtype and whether
+ *   the ACX4 instance is used for AC or CK
+ * - atxslewrate::atxprep and atxslewrate::atxpren are technology-specific
+ *   User should consult the "Output Slew Rate" section of
+ *   HSpice Model App Note in specific technology for recommended settings
+ */
+static void atxslewrate_program(void)
+{
+	int anib;
+	int atxpren; /* Default to 0xf (max). Optimal setting is technology specific. */
+	int atxprep; /* Default to 0xf (max). Optimal setting is technology specific. */
+	int ck_anib_inst[2];
+
+	atxprep = userinputadvanced.txslewriseac;
+	atxpren = userinputadvanced.txslewfallac;
+
+	/*
+	 * # of ANIBs      CK ANIB Instance
+	 * ACX8            ANIB 1
+	 */
+	if (userinputbasic.numanib == 8) {
+		ck_anib_inst[0] = 1;
+		ck_anib_inst[1] = 1;
+	}
+
+	for (anib = 0; anib < userinputbasic.numanib; anib++) {
+		int atxpredrvmode;
+		int c_addr;
+		uint16_t atxslewrate;
+
+		c_addr = anib << 12;
+
+		if (anib == ck_anib_inst[0] || anib == ck_anib_inst[1]) { /* CK ANIB instance */
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+			atxpredrvmode = 0x0;
+#elif STM32MP_LPDDR4_TYPE
+			atxpredrvmode = 0x1;
+#endif /* STM32MP_LPDDR4_TYPE */
+		} else { /* non-CK ANIB instance */
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+			atxpredrvmode = 0x3;
+#elif STM32MP_LPDDR4_TYPE
+			atxpredrvmode = 0x1;
+#endif /* STM32MP_LPDDR4_TYPE */
+		}
+
+		atxslewrate = (uint16_t)((atxpredrvmode << CSR_ATXPREDRVMODE_LSB) |
+					 (atxpren << CSR_ATXPREN_LSB) |
+					 (atxprep << CSR_ATXPREP_LSB));
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TANIB | c_addr |
+							      CSR_ATXSLEWRATE_ADDR)),
+					  atxslewrate);
+	}
+}
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+/*
+ * Program dfirddatacsdestmap and dfiwrdatacsdestmap
+ * - Dependencies: mb_ddr_1d[0].msgmisc[6] Determine Partial Rank Support
+ */
+static void dfidatacsdestmap_program(void)
+{
+
+	if ((mb_ddr_1d[0].msgmisc & 0x40) != 0) {
+		int pstate;
+		uint16_t dfirddatacsdestmap = 0xA0U;
+		uint16_t dfiwrdatacsdestmap = 0xA0U;
+
+		for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+			int p_addr;
+
+			p_addr = pstate << 20;
+
+			mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TMASTER |
+								      CSR_DFIRDDATACSDESTMAP_ADDR)),
+				      dfirddatacsdestmap);
+			mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TMASTER |
+								      CSR_DFIWRDATACSDESTMAP_ADDR)),
+				      dfiwrdatacsdestmap);
+		}
+	}
+}
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+/*
+ * Program pllctrl2:
+ * - Calculate PLL controls per p-state from frequency
+ */
+static void pllctrl2_program(void)
+{
+	int pstate;
+
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int p_addr;
+		uint16_t pllctrl2;
+
+		p_addr = pstate << 20;
+
+		if (userinputbasic.frequency[pstate] / 2 < 235) {
+			pllctrl2 = 0x7U;
+		} else if (userinputbasic.frequency[pstate] / 2 < 313) {
+			pllctrl2 = 0x6U;
+		} else if (userinputbasic.frequency[pstate] / 2 < 469) {
+			pllctrl2 = 0xBU;
+		} else if (userinputbasic.frequency[pstate] / 2 < 625) {
+			pllctrl2 = 0xAU;
+		} else if (userinputbasic.frequency[pstate] / 2 < 938) {
+			pllctrl2 = 0x19U;
+		} else if (userinputbasic.frequency[pstate] / 2 < 1067) {
+			pllctrl2 = 0x18U;
+		} else {
+			pllctrl2 = 0x19U;
+		}
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TMASTER |
+							      CSR_PLLCTRL2_ADDR)),
+			      pllctrl2);
+	}
+}
+
+/*
+ * Program ardptrinitval:
+ * - The values programmed here assume ideal properties of DfiClk and Pclk including:
+ *   - DfiClk skew
+ *   - DfiClk jitter
+ *   - DfiClk PVT variations
+ *   - Pclk skew
+ *   - Pclk jitter
+ *
+ * ardptrinitval Programmed differently based on PLL Bypass mode and frequency:
+ * - PLL Bypassed mode:
+ *   - For MemClk frequency > 933MHz, the valid range of ardptrinitval_p0[3:0] is: 2-5
+ *   - For MemClk frequency < 933MHz, the valid range of ardptrinitval_p0[3:0] is: 1-5
+ * - PLL Enabled mode:
+ *   - For MemClk frequency > 933MHz, the valid range of ardptrinitval_p0[3:0] is: 1-5
+ *   - For MemClk frequency < 933MHz, the valid range of ardptrinitval_p0[3:0] is: 0-5
+ */
+static void ardptrinitval_program(void)
+{
+	int pstate;
+
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int p_addr;
+
+		p_addr = pstate << 20;
+
+		if (userinputbasic.frequency[pstate] >= 933) {
+			ardptrinitval[pstate] = 0x2;
+		} else {
+			ardptrinitval[pstate] = 0x1;
+		}
+
+		/* Add one UI for synchronizer on SyncBus when PLL is bypassed */
+		if (userinputbasic.pllbypass[pstate] == 1) {
+			ardptrinitval[pstate]++;
+		}
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TMASTER |
+							      CSR_ARDPTRINITVAL_ADDR)),
+			      (uint16_t)ardptrinitval[pstate]);
+	}
+}
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+/*
+ * Program ProcOdtCtl:
+ * - Sets procodtalwayson/procodtalwaysoff for LPDDR4 for 4 different pstates using the PIE
+ *   register seq0bgpr4.
+ */
+static void procodtctl_program(void)
+{
+	int pstate;
+
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int p_addr;
+		int procodtalwayson;
+		int procodtalwaysoff;
+		uint16_t seq0bgpr4;
+
+		p_addr = pstate << 20;
+
+		procodtalwaysoff = 0;
+		procodtalwayson = 0;
+
+		seq0bgpr4 = (uint16_t)(0x00000000U |
+				       (procodtalwayson << CSR_PROCODTALWAYSON_LSB) |
+				       (procodtalwaysoff << CSR_PROCODTALWAYSOFF_LSB));
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TINITENG | C0 |
+							      CSR_SEQ0BGPR4_ADDR)),
+			      seq0bgpr4);
+	}
+}
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+/*
+ * Program dbytedllmodecntrl:
+ * - dllrxpreamblemode
+ * Program dqspreamblecontrol:
+ * - Fields:
+ *   - twotckrxdqspre
+ *   - twotcktxdqspre
+ *   - positiondfeinit
+ *   - lp4tgltwotcktxdqspre
+ *   - lp4postambleext
+ *   - lp4sttcprebridgerxen
+ * - Dependencies:
+ *   - user_input_basic.dramtype
+ *   - user_input_advanced.lp4rxpreamblemode (LPDDR4)
+ *   - user_input_advanced.wdqsext (LPDDR4)
+ *   - user_input_advanced.d4txpreamblelength (DDR4)
+ */
+static void dbytedllmodecntrl_program(int *twotckrxdqspre)
+{
+	int pstate;
+
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int disdllgainivseed = 1;
+		int disdllseedsel = 0;
+		int dllgainiv = 0x1;
+		int dllgaintv = 0x6;
+		int dllrxpreamblemode = 0;
+		int lcdlseed0 = 0x21;
+		int lp4postambleext = 0;
+		int lp4sttcprebridgerxen = 0;
+		int lp4tgltwotcktxdqspre = 0;
+		int p_addr;
+		int positiondfeinit;
+		int twotcktxdqspre = 0;
+		int wdqsextension = 0;
+		uint16_t dbytedllmodecntrl;
+		uint16_t dllgainctl;
+		uint16_t dlllockparam;
+		uint16_t dqspreamblecontrol;
+
+		p_addr = pstate << 20;
+
+#if STM32MP_DDR3_TYPE
+		/* Same as default */
+		twotckrxdqspre[pstate]  = 0x0;
+		lp4sttcprebridgerxen    = 0x0;
+		dllrxpreamblemode       = 0x0;
+		twotcktxdqspre          = 0x0;
+		lp4tgltwotcktxdqspre    = 0x0;
+		positiondfeinit         = 0x0;
+		lp4postambleext         = 0x0;
+#elif STM32MP_DDR4_TYPE
+		twotckrxdqspre[pstate]  = userinputadvanced.d4rxpreamblelength[pstate];
+		lp4sttcprebridgerxen    = 0x0;
+		dllrxpreamblemode       = 0x1;
+		twotcktxdqspre          = userinputadvanced.d4txpreamblelength[pstate];
+		lp4tgltwotcktxdqspre    = 0x0;
+		positiondfeinit         = 0x2;
+		lp4postambleext         = 0x0;
+#elif STM32MP_LPDDR4_TYPE
+		/* Set to 1 if static Rx preamble */
+		twotckrxdqspre[pstate] = !userinputadvanced.lp4rxpreamblemode[pstate];
+		/* Set to 1 if static Rx preamble */
+		lp4sttcprebridgerxen = !userinputadvanced.lp4rxpreamblemode[pstate];
+		dllrxpreamblemode = 0x1;
+		/* Must be 2*Tck Tx preamble according to JEDEC (mr1.OP[2] = 1) */
+		twotcktxdqspre = 0x1;
+		/* Must be toggling Tx preamble */
+		lp4tgltwotcktxdqspre = 0x1;
+		positiondfeinit = 0x0;
+		lp4postambleext = userinputadvanced.lp4postambleext[pstate];
+		wdqsextension = userinputadvanced.wdqsext;
+#endif /* STM32MP_LPDDR4_TYPE */
+
+		dqspreamblecontrol = (uint16_t)(
+					(wdqsextension << CSR_WDQSEXTENSION_LSB) |
+					(lp4sttcprebridgerxen << CSR_LP4STTCPREBRIDGERXEN_LSB) |
+					(lp4postambleext << CSR_LP4POSTAMBLEEXT_LSB) |
+					(lp4tgltwotcktxdqspre << CSR_LP4TGLTWOTCKTXDQSPRE_LSB) |
+					(positiondfeinit << CSR_POSITIONDFEINIT_LSB) |
+					(twotcktxdqspre << CSR_TWOTCKTXDQSPRE_LSB) |
+					(twotckrxdqspre[pstate] << CSR_TWOTCKRXDQSPRE_LSB));
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TMASTER |
+							      CSR_DQSPREAMBLECONTROL_ADDR)),
+			      dqspreamblecontrol);
+
+		dbytedllmodecntrl = (uint16_t)(dllrxpreamblemode << CSR_DLLRXPREAMBLEMODE_LSB);
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER |
+							      CSR_DBYTEDLLMODECNTRL_ADDR)),
+			      dbytedllmodecntrl);
+
+		dllgainctl = (uint16_t)(dllgainiv | (dllgaintv << CSR_DLLGAINTV_LSB));
+		dlllockparam = (uint16_t)(disdllseedsel |
+					  (disdllgainivseed << CSR_DISDLLGAINIVSEED_LSB) |
+					  (lcdlseed0 << CSR_LCDLSEED0_LSB));
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TMASTER |
+							      CSR_DLLLOCKPARAM_ADDR)),
+			      dlllockparam);
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TMASTER |
+							      CSR_DLLGAINCTL_ADDR)),
+			      dllgainctl);
+	}
+}
+
+/*
+ * Program procodttimectl:
+ * - Fields:
+ *   - POdtStartDelay[3:2]
+ *   - POdtTailWidth[1:0]
+ * - Dependencies:
+ *   - user_input_basic.frequency
+ *   - user_input_basic.dramtype
+ */
+static void procodttimectl_program(int *twotckrxdqspre)
+{
+	int pstate;
+
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int p_addr;
+		uint16_t procodttimectl;
+
+		p_addr = pstate << 20;
+
+		if (userinputadvanced.wdqsext) {
+			/* POdtStartDelay = 0x0 and  POdtTailWidth  = 0x3 */
+			procodttimectl = 0x3U;
+		} else if (userinputbasic.frequency[pstate] <= 933) {
+			/* Memclk Freq <= 933MHz: POdtStartDelay = 0x2 and POdtTailWidth  = 0x2 */
+			procodttimectl = 0xAU;
+		} else if (userinputbasic.frequency[pstate] <= 1200) {
+			/* 933MHz < Memclk Freq <= 1200MHz */
+			if (twotckrxdqspre[pstate] == 1) {
+				/* POdtStartDelay = 0x0 and  POdtTailWidth  = 0x2 */
+				procodttimectl = 0x2U;
+			} else {
+				/* POdtStartDelay = 0x1 and POdtTailWidth  = 0x2 */
+				procodttimectl = 0x6U;
+			}
+		} else {
+			/* Memclk Freq > 1200MHz */
+			if (twotckrxdqspre[pstate] == 1) {
+				/* POdtStartDelay = 0x0 and POdtTailWidth  = 0x3 */
+				procodttimectl = 0x3U;
+			} else {
+				/* POdtStartDelay = 0x1 and POdtTailWidth  = 0x3 */
+				procodttimectl = 0x7U;
+			}
+		}
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TMASTER |
+							      CSR_PROCODTTIMECTL_ADDR)),
+			      procodttimectl);
+	}
+}
+
+/*
+ * Program txodtdrvstren:
+ * - Fields:
+ *   - ODTStrenP_px[5:0]
+ *   - ODTStrenN_px[11:6]
+ * - Dependencies:
+ *   - user_input_basic.dramtype
+ *   - user_input_advanced.odtimpedance
+ * \return 0 on success.
+ */
+static int txodtdrvstren_program(void)
+{
+	int pstate;
+
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int byte;
+		int odtstrenn_state;
+		int odtstrenp_state;
+		int p_addr;
+		uint16_t txodtdrvstren;
+
+		p_addr = pstate << 20;
+
+		odtstrenp_state = ddrphy_phyinit_mapdrvstren(
+							(int)userinputadvanced.odtimpedance[pstate],
+							odtstrenp);
+		if (odtstrenp_state < 0) {
+			return odtstrenp_state;
+		}
+
+		odtstrenn_state = ddrphy_phyinit_mapdrvstren(
+							(int)userinputadvanced.odtimpedance[pstate],
+							odtstrenn);
+		if (odtstrenn_state < 0) {
+			return odtstrenn_state;
+		}
+
+		txodtdrvstren = (uint16_t)((odtstrenn_state << CSR_ODTSTRENN_LSB) |
+					   odtstrenp_state);
+
+		for (byte = 0; byte < userinputbasic.numdbyte; byte++) {
+			int c_addr;
+			int lane;
+
+			c_addr = byte << 12;
+			for (lane = 0; lane <= B_MAX; lane++) {
+				int b_addr;
+
+				b_addr = lane << 8;
+				mmio_write_16((uintptr_t)
+					      (DDRPHYC_BASE + 4 * (p_addr | TDBYTE | c_addr |
+								   b_addr |
+								   CSR_TXODTDRVSTREN_ADDR)),
+					      txodtdrvstren);
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Program tximpedancectrl1:
+ * - Fields:
+ *   - DrvStrenFSDqP[5:0]
+ *   - DrvStrenFSDqN[11:6]
+ * - Dependencies:
+ *   - user_input_basic.dramtype
+ *   - user_input_advanced.tximpedance
+ * \return 0 on success.
+ */
+static int tximpedancectrl1_program(void)
+{
+	int pstate;
+
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int byte;
+		int drvstrenfsdqn_state;
+		int drvstrenfsdqp_state;
+		int p_addr;
+		uint16_t tximpedancectrl1;
+
+		p_addr = pstate << 20;
+
+		drvstrenfsdqp_state = ddrphy_phyinit_mapdrvstren(
+							(int)userinputadvanced.tximpedance[pstate],
+							drvstrenfsdqp);
+		if (drvstrenfsdqp_state < 0) {
+			return drvstrenfsdqp_state;
+		}
+
+		drvstrenfsdqn_state = ddrphy_phyinit_mapdrvstren(
+							(int)userinputadvanced.tximpedance[pstate],
+							drvstrenfsdqn);
+		if (drvstrenfsdqn_state < 0) {
+			return drvstrenfsdqn_state;
+		}
+
+		tximpedancectrl1 = (uint16_t)((drvstrenfsdqn_state << CSR_DRVSTRENFSDQN_LSB) |
+					      (drvstrenfsdqp_state << CSR_DRVSTRENFSDQP_LSB));
+
+		for (byte = 0; byte < userinputbasic.numdbyte; byte++) {
+			int c_addr;
+			int lane;
+
+			c_addr = byte << 12;
+			for (lane = 0; lane <= B_MAX; lane++) {
+				int b_addr;
+
+				b_addr = lane << 8;
+				mmio_write_16((uintptr_t)
+					      (DDRPHYC_BASE + 4 * (p_addr | TDBYTE | c_addr |
+								   b_addr |
+								   CSR_TXIMPEDANCECTRL1_ADDR)),
+					      tximpedancectrl1);
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Program atximpedance:
+ * - Fields:
+ *   - ADrvStrenP[4:0]
+ *   - ADrvStrenN[9:5]
+ * - Dependencies:
+ *   - user_input_basic.dramtype
+ *   - user_input_advanced.atximpedance
+ * \return 0 on success.
+ */
+static int atximpedance_program(void)
+{
+	int adrvstrenn_state;
+	int adrvstrenp_state;
+	int anib;
+	uint16_t atximpedance;
+
+	adrvstrenp_state = ddrphy_phyinit_mapdrvstren((int)userinputadvanced.atximpedance,
+						      adrvstrenp);
+	if (adrvstrenp_state < 0) {
+		return adrvstrenp_state;
+	}
+
+	adrvstrenn_state = ddrphy_phyinit_mapdrvstren((int)userinputadvanced.atximpedance,
+						      adrvstrenn);
+	if (adrvstrenn_state < 0) {
+		return adrvstrenn_state;
+	}
+
+	atximpedance = (uint16_t)((adrvstrenn_state << CSR_ADRVSTRENN_LSB) |
+				  (adrvstrenp_state << CSR_ADRVSTRENP_LSB));
+
+	for (anib = 0; anib < userinputbasic.numanib; anib++) {
+		int c_addr;
+
+		c_addr = anib << 12;
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TANIB | c_addr |
+							      CSR_ATXIMPEDANCE_ADDR)),
+			      atximpedance);
+	}
+
+	return 0;
+}
+
+/*
+ * Program dfimode:
+ * - Dependencies:
+ *   - user_input_basic.dramtype
+ *   - user_input_basic.dfi1exists
+ *   - user_input_basic.numactivedbytedfi0
+ *   - user_input_basic.numactivedbytedfi1
+ */
+static void dfimode_program(void)
+{
+	uint16_t dfimode;
+
+	if (userinputbasic.dfi1exists == 1) {
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+		dfimode = 0x5U; /* DFI1 exists but disabled; DFI0 controls entire PHY */
+#elif STM32MP_LPDDR4_TYPE
+		if (userinputbasic.numactivedbytedfi1 > 0) {
+			dfimode = 0x3U; /* Both DFI0 and DFI1 active */
+		} else if (userinputbasic.numactivedbytedfi0 > userinputbasic.numdbyte / 2 &&
+			   userinputbasic.numdbyte == 4) {
+			dfimode = 0x5U; /* DFI1 exists but disabled; DFI0 controls entire PHY */
+		} else {
+			dfimode = 0x1U; /* DFI1 exists but disabled; DFI0 controls 1/2 PHY */
+		}
+#endif /* STM32MP_LPDDR4_TYPE */
+	} else {
+		dfimode = 0x1U; /* DFI1 does not physically exists */
+	}
+
+#if STM32MP_LPDDR4_TYPE
+	dfimode = 0x5U;
+#endif
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_DFIMODE_ADDR)), dfimode);
+}
+
+/*
+ * Program dficamode:
+ * - Fields:
+ *   - DfiLp3CAMode
+ *   - DfiD4CAMode
+ *   - DfiLp4CAMode
+ *   - DfiD4AltCAMode
+ * - Dependencies:
+ *   - user_input_basic.dramtype
+ */
+static void dficamode_program(void)
+{
+	uint16_t dficamode;
+
+#if STM32MP_DDR3_TYPE
+	dficamode = 0U;
+#elif STM32MP_DDR4_TYPE
+	dficamode = 2U;
+#elif STM32MP_LPDDR4_TYPE
+	dficamode = 4U;
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_DFICAMODE_ADDR)), dficamode);
+}
+
+/*
+ * Program caldrvstr0:
+ * - Fields:
+ *   - caldrvstrpd50[3:0]
+ *   - caldrvstrpu50[7:4]
+ * - Dependencies:
+ *   - user_input_advanced.extcalresval
+ *   - userinputadvanced.lp4lowpowerdrv (LPDDR4)
+ *   - mb_ddr_1d[0].mr3_a0 (LPDDR4)
+ */
+static void caldrvstr0_program(void)
+{
+	uint16_t caldrvstr0;
+	uint16_t caldrvstrpd50;
+	uint16_t caldrvstrpu50;
+
+	caldrvstrpu50 = (uint16_t)userinputadvanced.extcalresval;
+
+	caldrvstrpd50 = caldrvstrpu50;
+	caldrvstr0 = (caldrvstrpu50 << CSR_CALDRVSTRPU50_LSB) | caldrvstrpd50;
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_CALDRVSTR0_ADDR)), caldrvstr0);
+}
+
+/*
+ * Program CalUclkInfo:
+ * - Impedance calibration CLK Counter.
+ * - Fields:
+ *   - caluclkticksper1us
+ * - Dependencies:
+ *   - user_input_basic.frequency
+ */
+static void caluclkinfo_program(void)
+{
+	int pstate;
+
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int p_addr;
+		long long caluclkticksper1us_x10;
+		uint16_t caluclkticksper1us;
+
+		p_addr = pstate << 20;
+
+		/* Number of DfiClk cycles per 1us */
+		caluclkticksper1us_x10 = (long long)(10 * 1 * userinputbasic.frequency[pstate]) / 2;
+		caluclkticksper1us = (uint16_t)(caluclkticksper1us_x10 / 10);
+
+		if (((long long)(userinputbasic.frequency[pstate]) % 2) != 0) {
+			caluclkticksper1us++;
+		}
+
+		if (caluclkticksper1us < 24U) {
+			/* Minimum value of caluclkticksper1us = 24 */
+			caluclkticksper1us = 24U;
+		}
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TMASTER |
+							      CSR_CALUCLKINFO_ADDR)),
+			      caluclkticksper1us);
+	}
+}
+
+/*
+ * Program Calibration CSRs based on user input
+ *
+ * CSRs to program:
+ *      calrate: calinterval
+ *               calonce
+ * User input dependencies:
+ *      calinterval
+ *      calonce
+ */
+static void calibration_program(void)
+{
+	int calinterval;
+	int calonce;
+	uint16_t calrate;
+
+	calinterval = userinputadvanced.calinterval;
+	calonce = userinputadvanced.calonce;
+
+	calrate = (uint16_t)((calonce << CSR_CALONCE_LSB) | (calinterval << CSR_CALINTERVAL_LSB));
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_CALRATE_ADDR)), calrate);
+}
+
+/*
+ * Program vrefinglobal:
+ * - dqdqsrcvcntrl and csrvrefinglobal to select Global VREF
+ *   from Master to be used in each DQ
+ * - Fields:
+ *   - globalvrefinsel: Select Range of GlobalVref DAC. Default: set to 1.
+ *   - globalvrefindac: Vref level is set based on mb_ddr_1d[pstate].phyvref value.
+ *     The following formula is used to convert the phyvref into the register setting.
+ *       \f{eqnarray*}{
+ *           PhyVrefPrcnt &=& \frac{mb_ddr_1d[pstate].phyvref}{128} \\
+ *        if globalvrefinsel = 1 :
+ *           globalvrefindac &=& 1+\frac{PhyVrefPrcnt}{0.005} \\
+ *        if globalvrefinsel = 0 :
+ *           globalvrefindac &=& \frac{(PhyVrefPrcnt-0.345)}{0.005} \\
+ *           RxVref &=& (globalvrefindac == 0) ? Hi-Z : (PhyVrefPrcnt \times VDDQ)
+ *        \f}
+ * - Dependencies:
+ *   - user_input_basic.dramtype
+ *
+ * Program dqdqsrcvcntrl:
+ * - dqdqsrcvcntrl and csrvrefinglobal to select Global VREF
+ *   from Master to be used in each DQ
+ * - Fields:
+ *  - selanalogvref
+ *  - majormodedbyte
+ *  - ExtVrefRange
+ *  - DfeCtrl
+ *  - GainCurrAdj
+ * - Dependencies:
+ *   - user_input_basic.dramtype
+ */
+static void vrefinglobal_program(void)
+{
+	int majormodedbyte;
+	int pstate;
+
+#if STM32MP_DDR3_TYPE
+	majormodedbyte = 0;
+#elif STM32MP_DDR4_TYPE
+	majormodedbyte = 3;
+#elif STM32MP_LPDDR4_TYPE
+	majormodedbyte = 2;
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int32_t vref_percentvddq = (mb_ddr_1d[pstate].phyvref) * 1000 * 100 / 128;
+		uint8_t globalvrefindac = 0x0;
+		uint8_t globalvrefinsel = 0x4;
+		int byte;
+		int dfectrl_defval = 0;
+		int extvrefrange_defval = 0;
+		int gaincurradj_defval = 0xb;
+		int p_addr;
+		int selanalogvref = 1; /* Use Global VREF from Master */
+		uint16_t dqdqsrcvcntrl;
+		uint16_t vrefinglobal;
+
+		p_addr = pstate << 20;
+
+		/* Check range1 first. Only use range0 if customer input maxes out range1. */
+		globalvrefindac = (uint8_t)((vref_percentvddq / 500) + 1); /* Min value is 1 */
+		if (globalvrefindac > 127) {
+			/* Min value is 1 */
+			globalvrefindac = (uint8_t)(MAX((vref_percentvddq - 34500), 500) / 500);
+			globalvrefinsel = 0x0;
+		}
+		globalvrefindac = MIN(globalvrefindac, (uint8_t)127);
+
+		vrefinglobal = (uint16_t)((globalvrefindac << CSR_GLOBALVREFINDAC_LSB) |
+					  globalvrefinsel);
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TMASTER |
+							      CSR_VREFINGLOBAL_ADDR)),
+			      vrefinglobal);
+
+		dqdqsrcvcntrl = (uint16_t)((gaincurradj_defval << CSR_GAINCURRADJ_LSB) |
+					   (majormodedbyte << CSR_MAJORMODEDBYTE_LSB) |
+					   (dfectrl_defval << CSR_DFECTRL_LSB) |
+					   (extvrefrange_defval << CSR_EXTVREFRANGE_LSB) |
+					   (selanalogvref << CSR_SELANALOGVREF_LSB));
+
+		for (byte = 0; byte < userinputbasic.numdbyte; byte++) {
+			int c_addr;
+			int lane;
+
+			c_addr = byte << 12;
+			for (lane = 0; lane <= B_MAX; lane++) {
+				int b_addr;
+
+				b_addr = lane << 8;
+				mmio_write_16((uintptr_t)
+					      (DDRPHYC_BASE + 4 * (p_addr | TDBYTE | c_addr |
+								   b_addr |
+								   CSR_DQDQSRCVCNTRL_ADDR)),
+					      dqdqsrcvcntrl);
+			}
+		}
+	}
+}
+
+/*
+ * Program dfifreqratio :
+ * - Dependencies:
+ *   - user_input_basic.dfifreqratio
+ */
+static void dfifreqratio_program(void)
+{
+	int pstate;
+
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int p_addr;
+		uint16_t dfifreqratio;
+
+		p_addr = pstate << 20;
+
+		dfifreqratio = (uint16_t)userinputbasic.dfifreqratio[pstate];
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TMASTER |
+							      CSR_DFIFREQRATIO_ADDR)),
+			      dfifreqratio);
+	}
+}
+
+/*
+ * Program tristatemodeca based on dramtype and 2T Timing
+ * - Fields:
+ *   - CkDisVal
+ *   - disdynadrtri
+ *   - ddr2tmode
+ * - Dependencies:
+ *   - user_input_basic.dramtype
+ *   - user_input_advanced.is2ttiming
+ *   - user_input_advanced.disdynadrtri
+ */
+static void tristatemodeca_program(void)
+{
+	int ckdisval_def;
+	int pstate;
+
+	/* CkDisVal depends on dramtype */
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	ckdisval_def = 1; /* {CLK_t,CLK_c} = 2'b00; */
+#elif STM32MP_LPDDR4_TYPE
+	ckdisval_def = 0; /* {CLK_t,CLK_c} = 2'b01; */
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int ddr2tmode;
+		int disdynadrtri;
+		int p_addr;
+		uint16_t tristatemodeca;
+
+		p_addr = pstate << 20;
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+		disdynadrtri = userinputadvanced.disdynadrtri[pstate];
+#elif STM32MP_LPDDR4_TYPE
+		disdynadrtri = 1;
+#endif /* STM32MP_LPDDR4_TYPE */
+
+		ddr2tmode = userinputadvanced.is2ttiming[pstate];
+
+		tristatemodeca = (uint16_t)((ckdisval_def << CSR_CKDISVAL_LSB) |
+					    (ddr2tmode << CSR_DDR2TMODE_LSB) |
+					    (disdynadrtri << CSR_DISDYNADRTRI_LSB));
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TMASTER |
+							      CSR_TRISTATEMODECA_ADDR)),
+			      tristatemodeca);
+	}
+}
+
+/*
+ * Program DfiXlat based on Pll Bypass Input
+ * - Dependencies:
+ *   - user_input_basic.dramtype
+ *   - user_input_basic.pllbypass
+ */
+static void dfixlat_program(void)
+{
+	int pstate;
+	uint16_t loopvector;
+	uint16_t pllbypass_dat = 0U;
+	uint16_t skipddc_dat = 0U;	/*
+					 * Set to vector offset based on pstate frequency to disable
+					 * dram drift compensation.
+					 */
+
+	for (pstate = 0; pstate < NB_PS; pstate++) {
+		pllbypass_dat |= (uint16_t)(userinputbasic.pllbypass[pstate] << (4 * pstate));
+
+		if (userinputbasic.frequency[pstate] < 333) {
+			skipddc_dat |= 0x5U << (4 * pstate);
+		}
+	}
+
+	for (loopvector = 0U; loopvector < 8U; loopvector++) {
+		uint16_t dfifreqxlat_dat;
+		uintptr_t reg = (uintptr_t)(DDRPHYC_BASE + 4 * (C0 | TMASTER |
+								(CSR_DFIFREQXLAT0_ADDR +
+								 loopvector)));
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+		if (loopvector == 0U) {
+			/*
+			 * Relock DfiFreq = 00,01,02,03)  Use StartVec 5 (pll_enabled) or
+			 * StartVec 6 (pll_bypassed).
+			 */
+			dfifreqxlat_dat = pllbypass_dat + 0x5555U;
+
+			mmio_write_16(reg, dfifreqxlat_dat);
+		} else if (loopvector == 7U) {
+			/* LP3-entry DfiFreq = 1F */
+			mmio_write_16(reg, 0xF000U);
+		} else {
+			/*
+			 * Everything else = skip retrain  (could also map to 0000 since retrain
+			 * code is excluded, but this is cleaner).
+			 */
+			mmio_write_16(reg, 0x5555U);
+		}
+#elif STM32MP_LPDDR4_TYPE
+		if (loopvector == 0U) {
+			/*
+			 * Retrain & Relock DfiFreq = 00,01,02,03)  Use StartVec 0 (pll_enabled) or
+			 * StartVec 1 (pll_bypassed).
+			 */
+			dfifreqxlat_dat = pllbypass_dat + skipddc_dat + 0x0000U;
+			mmio_write_16(reg, dfifreqxlat_dat);
+		} else if (loopvector == 2U) {
+			/*
+			 * Retrain only DfiFreq = 08,09,0A,0B)  Use StartVec 4 (1, and maybe 2,3,
+			 * used by verif).
+			 */
+			mmio_write_16(reg, 0x4444U);
+		} else if (loopvector == 3U) {
+			/* Phymstr type state change, StartVec 8 */
+			mmio_write_16(reg, 0x8888U);
+		} else if (loopvector == 4U) {
+			/*
+			 * Relock only DfiFreq = 10,11,12,13   Use StartVec 5 (pll_enabled) or
+			 * StartVec 6 (pll_bypassed).
+			 */
+			dfifreqxlat_dat = pllbypass_dat + 0x5555U;
+			mmio_write_16(reg, dfifreqxlat_dat);
+		} else if (loopvector == 7U) {
+			/* LP3-entry DfiFreq = 1F */
+			mmio_write_16(reg, 0xF000U);
+		} else {
+			/* Everything else */
+			mmio_write_16(reg, 0x0000U);
+		}
+#endif /* STM32MP_LPDDR4_TYPE */
+	}
+}
+
+/*
+ * Program dqdqsrcvcntrl1 (Receiver Powerdown) and DbyteMiscMode
+ * - see function ddrphy_phyinit_isdbytedisabled() to determine
+ *   which DBytes are turned off completely based on PHY configuration.
+ * - Fields:
+ *   - DByteDisable
+ *   - PowerDownRcvr
+ *   - PowerDownRcvrDqs
+ *   - RxPadStandbyEn
+ * - Dependencies:
+ *   - user_input_basic.dramtype
+ *   - user_input_basic.dfi1exists
+ *   - user_input_basic.numactivedbytedfi0
+ *   - user_input_basic.numactivedbytedfi1
+ *   - user_input_basic.numdbyte
+ *   - user_input_basic.dramdatawidth (DDR3/DDR4)
+ *   - mb_ddr_1d[0].mr5 (DDR4)
+ *   - user_input_advanced.lp4dbird (LPDDR4)
+ */
+static void dqdqsrcvcntrl1_program(void)
+{
+	int lp4dbird __unused;
+	int pstate __unused;
+	int d;
+	uint16_t mr5 __unused;
+	uint16_t regdata;
+	uint16_t regdata1;
+	uint16_t regdata2; /* Turn off Rx of DBI lane */
+
+	regdata = 0x1U << CSR_DBYTEDISABLE_LSB;
+
+	regdata1 = (0x1FFU << CSR_POWERDOWNRCVR_LSB |
+		    0x1U << CSR_POWERDOWNRCVRDQS_LSB |
+		    0x1U << CSR_RXPADSTANDBYEN_LSB);
+
+	regdata2 = (0x100U << CSR_POWERDOWNRCVR_LSB | CSR_RXPADSTANDBYEN_MASK);
+
+#if STM32MP_DDR4_TYPE
+	mr5 = 0U;
+#elif STM32MP_LPDDR4_TYPE
+	lp4dbird = 0;
+#endif /* STM32MP_LPDDR4_TYPE */
+
+#if !STM32MP_DDR3_TYPE
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+#if STM32MP_DDR4_TYPE
+		/* OR all mr4 masked values, to help check in next loop */
+		mr5 |= (mb_ddr_1d[pstate].mr5 >> 12) & 0x1U;
+#elif STM32MP_LPDDR4_TYPE
+		/* OR all Lp4DbiRd values, to help check in next loop */
+		lp4dbird |= userinputadvanced.lp4dbird[pstate];
+#endif /* STM32MP_LPDDR4_TYPE */
+	}
+#endif /* !STM32MP_DDR3_TYPE */
+
+	/* Implements Section 1.3 of Pub Databook */
+	for (d = 0; d < userinputbasic.numdbyte; d++) { /* For each dbyte */
+		int c_addr;
+
+		c_addr = d * C1;
+		if (ddrphy_phyinit_isdbytedisabled(d)) {
+			mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (c_addr | TDBYTE |
+								      CSR_DBYTEMISCMODE_ADDR)),
+				      regdata);
+			mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (c_addr | TDBYTE |
+								      CSR_DQDQSRCVCNTRL1_ADDR)),
+				      regdata1);
+		} else {
+			/* Disable RDBI lane if not used. */
+#if STM32MP_DDR3_TYPE
+			if ((userinputbasic.dramdatawidth != 4)) {
+#elif STM32MP_DDR4_TYPE
+			if ((userinputbasic.dramdatawidth != 4) && mr5 == 0U) {
+#elif STM32MP_LPDDR4_TYPE
+			if (lp4dbird == 0) {
+#endif /* STM32MP_LPDDR4_TYPE */
+				mmio_write_16((uintptr_t)
+					      (DDRPHYC_BASE + 4 * (c_addr | TDBYTE |
+								   CSR_DQDQSRCVCNTRL1_ADDR)),
+					      regdata2);
+			} /* DBI */
+		} /* DbyteDisable */
+	} /* for each dbyte */
+}
+
+/*
+ * Program masterx4config
+ * - Fields:
+ *   - x4tg
+ *   - masterx4config
+ * - Dependencies:
+ *   - user_input_basic.dramdatawidth
+ *
+ * \note PHY does not support mixed dram device data width
+ */
+static void masterx4config_program(void)
+{
+	int x4tg;
+	uint16_t masterx4config;
+
+	if (userinputbasic.dramdatawidth == 4) {
+		x4tg = 0xF;
+	} else {
+		x4tg = 0x0;
+	}
+
+	masterx4config = (uint16_t)(x4tg << CSR_X4TG_LSB);
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_MASTERX4CONFIG_ADDR)),
+		      masterx4config);
+}
+
+#if !STM32MP_DDR3_TYPE
+/*
+ * Program dmipinpresent based on dramtype and Read-DBI enable
+ * - Fields:
+ *   - RdDbiEnabled
+ * - Dependencies:
+ *   - user_input_basic.dramdatawidth
+ *   - mb_ddr_1d[0].mr5 (DDR4)
+ *   - user_input_advanced.lp4dbird (LPDDR4)
+ */
+static void dmipinpresent_program(void)
+{
+	int pstate;
+
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int p_addr;
+		uint16_t dmipinpresent;
+
+		p_addr = pstate << 20;
+
+#if STM32MP_DDR4_TYPE
+		/* For DDR4, Read DBI is enabled in mr5-A12 */
+		dmipinpresent = (mb_ddr_1d[pstate].mr5 >> 12) & 0x1U;
+#elif STM32MP_LPDDR4_TYPE
+		dmipinpresent = (uint16_t)userinputadvanced.lp4dbird[pstate];
+#endif /* STM32MP_LPDDR4_TYPE */
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TMASTER |
+							      CSR_DMIPINPRESENT_ADDR)),
+			      dmipinpresent);
+	}
+}
+#endif /* !STM32MP_DDR3_TYPE */
+
+/*
+ * Program aforcetricont and acx4anibdis
+ * - Fields:
+ *   - aforcetricont
+ *   - acx4anibdis
+ * - Dependencies:
+ *   - user_input_basic.numrank_dfi0
+ *   - user_input_basic.numrank_dfi1
+ *   - user_input_basic.numanib
+ *   - user_input_advanced.disableunusedaddrlns
+ */
+static void aforcetricont_acx4anibdis_program(void)
+{
+	int anib;
+	uint16_t acx4anibdis = 0x0U;
+
+	for (anib = 0;
+	     (anib < userinputbasic.numanib) && userinputadvanced.disableunusedaddrlns;
+	     anib++) {
+		int c_addr;
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+		int numrank = userinputbasic.numrank_dfi0 + userinputbasic.numrank_dfi1;
+#elif STM32MP_LPDDR4_TYPE
+		int numrank0 = userinputbasic.numrank_dfi0;
+		int numrank1 = userinputbasic.numrank_dfi1;
+#endif /* STM32MP_LPDDR4_TYPE */
+		uint16_t aforcetricont = 0x0U;
+
+		c_addr = anib << 12;
+		aforcetricont = 0x0U;
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+		if (anib == 0 && numrank == 1) {
+			aforcetricont = 0x2U;
+		} else if (anib == 1 && numrank == 1) {
+			aforcetricont = 0xCU;
+		} else if (anib == 6) {
+			aforcetricont = 0x1U;
+		}
+#elif STM32MP_LPDDR4_TYPE
+		if (anib == 0 && numrank0 == 0) {
+			aforcetricont = 0xFU;
+		} else if (anib == 0 && numrank0 == 1) {
+			aforcetricont = 0x2U;
+		} else if (anib == 1 && numrank0 == 0) {
+			aforcetricont = 0xFU;
+		} else if (anib == 1 && numrank0 == 1) {
+			aforcetricont = 0x8U;
+		} else if (anib == 2 && numrank0 == 0) {
+			aforcetricont = 0xFU;
+		} else if (anib == 3 && numrank1 == 0) {
+			aforcetricont = 0xFU;
+		} else if (anib == 3 && numrank1 == 1) {
+			aforcetricont = 0x2U;
+		} else if (anib == 4 && numrank1 == 0) {
+			aforcetricont = 0xFU;
+		} else if (anib == 4 && numrank1 == 1) {
+			aforcetricont = 0x8U;
+		} else if (anib == 5 && numrank1 == 0) {
+			aforcetricont = 0xFU;
+		} else if (anib == 6) {
+			aforcetricont = 0xFU;
+		} else if (anib == 7) {
+			aforcetricont = 0xFU;
+		}
+#endif /* STM32MP_LPDDR4_TYPE */
+
+		/*
+		 * If all the lanes can be disabled, and Anib is not the first or last disable
+		 * entire chiplet
+		 */
+		if (aforcetricont == 0xFU && anib != 0 && anib != userinputbasic.numanib - 1) {
+			acx4anibdis = acx4anibdis | (0x1U << anib);
+		}
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TANIB | c_addr |
+							      CSR_AFORCETRICONT_ADDR)),
+			      aforcetricont);
+	}
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_ACX4ANIBDIS_ADDR)),
+		      acx4anibdis);
+}
+
+/*
+ * Implements Step C of initialization sequence
+ *
+ * This function programs majority of PHY configuration registers based
+ * on data input into PhyInit data structures.
+ *
+ * This function programs PHY configuration registers based on information
+ * provided in the PhyInit data structures (userinputbasic, userinputadvanced).
+ * The user can overwrite the programming of this function by modifying
+ * ddrphy_phyinit_usercustom_custompretrain().  Please see
+ * ddrphy_phyinit_struct.h for PhyInit data structure definition.
+ *
+ * \return 0 on success.
+ */
+int ddrphy_phyinit_c_initphyconfig(void)
+{
+	int twotckrxdqspre[NB_PS] = { };
+	int ret;
+
+	/*
+	 * Step (C) Initialize PHY Configuration
+	 * Load the required PHY configuration registers for the appropriate mode and memory
+	 * configuration.
+	 */
+
+	VERBOSE("%s Start\n", __func__);
+
+	txslewrate_program();
+
+	atxslewrate_program();
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	dfidatacsdestmap_program();
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+	pllctrl2_program();
+
+	ardptrinitval_program();
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	procodtctl_program();
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+	dbytedllmodecntrl_program(twotckrxdqspre);
+
+	procodttimectl_program(twotckrxdqspre);
+
+	ret = txodtdrvstren_program();
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = tximpedancectrl1_program();
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = atximpedance_program();
+	if (ret != 0) {
+		return ret;
+	}
+
+	dfimode_program();
+
+	dficamode_program();
+
+	caldrvstr0_program();
+
+	caluclkinfo_program();
+
+	calibration_program();
+
+	vrefinglobal_program();
+
+	dfifreqratio_program();
+
+	tristatemodeca_program();
+
+	dfixlat_program();
+
+	dqdqsrcvcntrl1_program();
+
+	masterx4config_program();
+
+#if !STM32MP_DDR3_TYPE
+	dmipinpresent_program();
+
+#if STM32MP_LPDDR4_TYPE
+	/*
+	 * Program DFIPHYUPD
+	 * - Fields:
+	 *   - DFIPHYUPDMODE
+	 *   - DFIPHYUPDCNT
+	 * - Dependencies:
+	 *   - user_input_advanced.disablephyupdate
+	 */
+	if (userinputadvanced.disablephyupdate) {
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_DFIPHYUPD_ADDR)), 0x0U);
+	}
+#endif /* STM32MP_LPDDR4_TYPE */
+#endif /* !STM32MP_DDR3_TYPE */
+
+	aforcetricont_acx4anibdis_program();
+
+	VERBOSE("%s End\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_calcmb.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_calcmb.c
new file mode 100644
index 000000000..708021596
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_calcmb.c
@@ -0,0 +1,218 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdlib.h>
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit.h>
+
+/*
+ * Reads PhyInit inputs structures and sets relevant message block
+ * parameters.
+ *
+ * This function sets Message Block parameters based on user_input_basic and
+ * user_input_advanced. user changes in these files takes precedence
+ * over this function call.
+ *
+ * MessageBlock fields set ::
+ *
+ *  - dramtype
+ *  - pstate
+ *  - dramfreq
+ *  - pllbypassen
+ *  - dfifreqratio
+ *  - phyodtimpedance
+ *  - phydrvimpedance
+ *  - bpznresval
+ *  - enableddqscha (LPDDR4)
+ *  - cspresentcha (LPDDR4)
+ *  - enableddqsChb (LPDDR4)
+ *  - cspresentchb (LPDDR4)
+ *  - enableddqs (DDR3/DDR4)
+ *  - phycfg (DDR3/DDR4)
+ *  - x16present (DDR4)
+ *
+ * \return 0 on success.
+ */
+int ddrphy_phyinit_calcmb(void)
+{
+	int myps = 0;
+	int nad0 = userinputbasic.numactivedbytedfi0;
+	int nad1 = 0;
+	uint16_t mr4 __unused;
+
+	VERBOSE("%s Start\n", __func__);
+
+#if STM32MP_LPDDR4_TYPE
+	nad1 = userinputbasic.numactivedbytedfi1;
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	/* A few checks to make sure valid programming */
+	if (nad0 <= 0 || nad1 < 0 || userinputbasic.numdbyte <= 0) {
+		ERROR("%s numactivedbytedfi0, numactivedbytedfi0, NumByte out of range.\n",
+		      __func__);
+		return -1;
+	}
+
+	if ((nad0 + nad1) > userinputbasic.numdbyte) {
+		ERROR("%s numactivedbytedfi0+numactivedbytedfi1 is larger than numdbyteDfi0\n",
+		      __func__);
+		return -1;
+	}
+
+	if (userinputbasic.dfi1exists == 0 && nad1 != 0) {
+		ERROR("%s dfi1exists==0 but numdbyteDfi0 != 0\n", __func__);
+		return -1;
+	}
+
+#if STM32MP_DDR4_TYPE
+	/* OR all mr4 masked values, to help check in next loop */
+	mr4 = 0;
+	for (myps = 0; myps < userinputbasic.numpstates; myps++) {
+		mr4 |= mb_ddr_1d[myps].mr4 & 0x1C0U;
+	}
+#endif /* STM32MP_DDR4_TYPE */
+
+	/* 1D message block defaults */
+	for (myps = 0; myps < userinputbasic.numpstates; myps++) {
+		uint16_t disableddbyte __unused;
+		int dbyte __unused;
+		int ret;
+
+#if STM32MP_DDR4_TYPE
+		if (mr4 != 0x0) {
+			ERROR("%s Setting DRAM CAL mode is not supported by the PHY.\n", __func__);
+			ERROR("Memory controller may set CAL mode after PHY has entered mission\n");
+			ERROR("mode. Please check value programmed in mb_ddr_1d[*].mr4\n");
+			ERROR("and unset A8:6\n");
+			return -1;
+		}
+#endif /* STM32MP_DDR4_TYPE */
+
+#if STM32MP_DDR3_TYPE
+		if (userinputbasic.dimmtype == NODIMM) {
+			ret = ddrphy_phyinit_softsetmb(myps,"dramtype",0x1);
+			if (ret != 0) {
+				return ret;
+			}
+		}
+#elif STM32MP_DDR4_TYPE
+		if (userinputbasic.dimmtype == NODIMM) {
+			ret = ddrphy_phyinit_softsetmb(myps,"dramtype",0x2);
+			if (ret != 0) {
+				return ret;
+			}
+		}
+#endif /* STM32MP_DDR4_TYPE */
+
+		ret = ddrphy_phyinit_softsetmb(myps, "pstate", myps);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_softsetmb(myps, "dramfreq",
+					       userinputbasic.frequency[myps] * 2);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_softsetmb(myps, "pllbypassen", userinputbasic.pllbypass[myps]);
+		if (ret != 0) {
+			return ret;
+		}
+
+		if (userinputbasic.dfifreqratio[myps] == 1) {
+			ret = ddrphy_phyinit_softsetmb(myps, "dfifreqratio", 0x2);
+			if (ret != 0) {
+				return ret;
+			}
+		}
+
+		ret = ddrphy_phyinit_softsetmb(myps, "phyodtimpedance", 0);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_softsetmb(myps, "phydrvimpedance", 0);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_softsetmb(myps, "bpznresval", 0);
+		if (ret != 0) {
+			return ret;
+		}
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+		ret = ddrphy_phyinit_softsetmb(myps,"enableddqs",nad0 * 8);
+		if (ret != 0) {
+			return ret;
+		}
+
+		disableddbyte = 0x0U;
+
+		for (dbyte = 0; dbyte < userinputbasic.numdbyte && dbyte < 8; dbyte++) {
+			disableddbyte |= (ddrphy_phyinit_isdbytedisabled(dbyte) ?
+									(0x1U << dbyte) : 0x0U);
+		}
+
+		ret = ddrphy_phyinit_softsetmb(myps, "disableddbyte", disableddbyte);
+		if (ret != 0) {
+			return ret;
+		}
+
+#if STM32MP_DDR3_TYPE
+		ret = ddrphy_phyinit_softsetmb(myps, "phycfg", userinputadvanced.is2ttiming[myps]);
+		if (ret != 0) {
+			return ret;
+		}
+#else
+		ret = ddrphy_phyinit_softsetmb(myps, "phycfg",
+					       (mb_ddr_1d[myps].mr3 & 0x8U) ?
+					       0 : userinputadvanced.is2ttiming[myps]);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_softsetmb(myps, "x16present",
+					       (0x10 == userinputbasic.dramdatawidth) ?
+					       mb_ddr_1d[myps].cspresent : 0x0);
+		if (ret != 0) {
+			return ret;
+		}
+#endif /* STM32MP_DDR3_TYPE */
+#elif STM32MP_LPDDR4_TYPE
+		ret = ddrphy_phyinit_softsetmb(myps, "enableddqscha", nad0 * 8);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_softsetmb(myps, "cspresentcha",
+					       (2 == userinputbasic.numrank_dfi0) ?
+					       0x3 : userinputbasic.numrank_dfi0);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_softsetmb(myps, "enableddqschb", nad1 * 8);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_softsetmb(myps, "cspresentchb",
+					       (2 == userinputbasic.numrank_dfi1) ?
+					       0x3 : userinputbasic.numrank_dfi1);
+		if (ret != 0) {
+			return ret;
+		}
+#endif /* STM32MP_LPDDR4_TYPE */
+	} /* myps */
+
+	VERBOSE("%s End\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_d_loadimem.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_d_loadimem.c
new file mode 100644
index 000000000..fc6a34ff6
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_d_loadimem.c
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+/*
+ * This function loads the training firmware IMEM image into the SRAM.
+ *
+ * This function reads the incv files form the firmware package to generate a
+ * set of apb writes to load IMEM image into the SRAM. The exact steps in this
+ * function are as follows:
+ *
+ * -# Ensure DRAM is in reset.
+ * -# Load the microcontroller memory with the provided training firmware
+ * -# Initialize the firmware mailbox structures to be able to communicate with
+ * the firmware (see "Mailbox facility for firmware" in the "Cores
+ * DDR PHY Training Application Note".
+ *
+ * \return void
+ */
+void ddrphy_phyinit_d_loadimem(void)
+{
+	uint16_t memresetl;
+	uint32_t *ptr32;
+
+	VERBOSE("%s Start\n", __func__);
+
+	/*
+	 * Set memresetl to avoid glitch on BP_MemReset_L during training
+	 */
+	memresetl = CSR_PROTECTMEMRESET_MASK;
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_MEMRESETL_ADDR)), memresetl);
+
+	ptr32 = (uint32_t *)(STM32MP_DDR_FW_BASE + STM32MP_DDR_FW_IMEM_OFFSET);
+	ddrphy_phyinit_writeoutmem(ptr32, IMEM_ST_ADDR, IMEM_SIZE);
+
+	VERBOSE("%s End\n", __func__);
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_f_loaddmem.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_f_loaddmem.c
new file mode 100644
index 000000000..2709c9d8d
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_f_loaddmem.c
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+/*
+ * This function loads the training firmware DMEM image and write the
+ * Message Block parameters for the training firmware into the SRAM.
+ *
+ * This function performs the following tasks:
+ *
+ * -# Load the firmware DMEM segment to initialize the data structures from the
+ * DMEM incv file provided in the training firmware package.
+ * -# Write the Firmware Message Block with the required contents detailing the training parameters.
+ *
+ * \return 0 on success.
+ */
+int ddrphy_phyinit_f_loaddmem(int pstate)
+{
+	pmu_smb_ddr_1d_t *msgblkptr;
+	int sizeofmsgblk;
+	uint16_t *ptr16;
+	uint32_t *ptr32;
+
+	VERBOSE("%s Start (pstate=%d)\n", __func__, pstate);
+
+	/* Set a pointer to the message block */
+	msgblkptr = &mb_ddr_1d[pstate];
+
+	/* Some basic checks on MessageBlock */
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	if ((msgblkptr->enableddqs > 8 * (userinputbasic.numactivedbytedfi0)) ||
+	    (msgblkptr->enableddqs <= 0)) {
+		ERROR("%s enableddqs is Zero or greater than NumActiveDbytes for Dfi0\n",__func__);
+		return -1;
+	}
+#elif STM32MP_LPDDR4_TYPE
+	if (msgblkptr->enableddqscha % 16 != 0 || msgblkptr->enableddqschb % 16 != 0) {
+		ERROR("%s Lp3/Lp4 - Number of Dq's Enabled per Channel much be multipe of 16\n",
+		      __func__);
+		return -1;
+	}
+
+	if ((msgblkptr->enableddqscha > 8 * (userinputbasic.numactivedbytedfi0)) ||
+	    (msgblkptr->enableddqschb > 8 * (userinputbasic.numactivedbytedfi1)) ||
+	    (msgblkptr->enableddqscha == 0 && msgblkptr->enableddqschb == 0)) {
+		ERROR("%s EnabledDqsChA/B are not set correctly./1\n", __func__);
+		return -1;
+	}
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	sizeofmsgblk = sizeof(mb_ddr_1d[pstate]);
+
+	ptr16 = (uint16_t *)msgblkptr;
+	ddrphy_phyinit_writeoutmsgblk(ptr16, DMEM_ST_ADDR, sizeofmsgblk);
+
+	ptr32 = (uint32_t *)(STM32MP_DDR_FW_BASE + STM32MP_DDR_FW_DMEM_OFFSET);
+	ddrphy_phyinit_writeoutmem(ptr32, DMEM_ST_ADDR + DMEM_BIN_OFFSET,
+				   DMEM_SIZE - STM32MP_DDR_FW_DMEM_OFFSET);
+
+	VERBOSE("%s End\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_g_execfw.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_g_execfw.c
new file mode 100644
index 000000000..53f411d9e
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_g_execfw.c
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+/*
+ * Execute the Training Firmware
+ *
+ * The training firmware is executed with the following procedure:
+ *
+ * -# Reset the firmware microcontroller by writing the MicroReset register to
+ * set the StallToMicro and ResetToMicro fields to 1 (all other fields should be
+ * zero). Then rewrite the registers so that only the StallToMicro remains set
+ * (all other fields should be zero).
+ * -# Begin execution of the training firmware by setting the MicroReset
+ * register to 4'b0000.
+ * -# Wait for the training firmware to complete by following the procedure in
+ * "uCtrl Initialization and Mailbox Messaging" implemented in
+ * ddrphy_phyinit_usercustom_g_waitfwdone() function.
+ * -# Halt the microcontroller.
+ *
+ * \return 0 on success.
+ */
+int ddrphy_phyinit_g_execfw(void)
+{
+	int ret;
+
+	VERBOSE("%s Start\n", __func__);
+
+	/*
+	 * 1. Reset the firmware microcontroller by writing the MicroReset CSR to set the
+	 * StallToMicro and ResetToMicro fields to 1 (all other fields should be zero).
+	 * Then rewrite the CSR so that only the StallToMicro remains set (all other fields should
+	 * be zero).
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR)),
+		      CSR_STALLTOMICRO_MASK);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICRORESET_ADDR)),
+		      CSR_RESETTOMICRO_MASK | CSR_STALLTOMICRO_MASK);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICRORESET_ADDR)),
+		      CSR_STALLTOMICRO_MASK);
+
+	/* 2. Begin execution of the training firmware by setting the MicroReset CSR to 0 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICRORESET_ADDR)), 0x0U);
+
+	/*
+	 * 3. Wait for the training firmware to complete by following the procedure in
+	 * "uCtrl Initialization and Mailbox Messaging".
+	 */
+	ret = ddrphy_phyinit_usercustom_g_waitfwdone();
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* 4. Halt the microcontroller */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICRORESET_ADDR)),
+		      CSR_STALLTOMICRO_MASK);
+
+	VERBOSE("%s End\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_globals.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_globals.c
new file mode 100644
index 000000000..270f8e160
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_globals.c
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdio.h>
+
+#include <ddrphy_phyinit.h>
+
+/* Global struct defines */
+runtime_config_t runtimeconfig;
+user_input_basic_t userinputbasic;
+user_input_advanced_t userinputadvanced;
+user_input_mode_register_t userinputmoderegister;
+user_input_swizzle_t userinputswizzle;
+
+/* Firmware 1D Message Block structures */
+pmu_smb_ddr_1d_t mb_ddr_1d[NB_PS];
+/* Shadow of 1D message block. Used by PhyInit to track user changes to the data structure */
+pmu_smb_ddr_1d_t shdw_ddr_1d[NB_PS];
+
+/* PHY Identifier when using multiple PHY's */
+int currentphyinst;
+
+/*
+ * Represent the value stored in Step C into the register with the same name.
+ * Defined as a global variable so that implementation of ddrphy_phyinit_progcsrskiptrain()
+ * function does not require a PHY read register implementation.
+ */
+int ardptrinitval[NB_PS];
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_h_readmsgblock.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_h_readmsgblock.c
new file mode 100644
index 000000000..8930ce17e
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_h_readmsgblock.c
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+/*
+ * Read the Training Firmware Message Block results
+ *
+ * The procedure is as follows:
+ *
+ * -# Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0.
+ * -# Read the Firmware Message Block to obtain the results from the training.
+ * The user customizable function ddrphy_phyinit_usercustom_h_readmsgblock()
+ * is called for the user to read any specific results from training.
+ * -# Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1.
+ * -# If training is required at another frequency, repeat the operations starting at step (E)
+ *
+ * \return void
+ */
+void ddrphy_phyinit_h_readmsgblock(void)
+{
+	VERBOSE("%s Start\n", __func__);
+
+	/* 1. Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR)), 0x0U);
+
+	/* 2. Read the Firmware Message Block to obtain the results from the training */
+	ddrphy_phyinit_usercustom_h_readmsgblock();
+
+	/*
+	 * 3. Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR)), 0x1U);
+
+	/*
+	 * 4. If training is required at another frequency, repeat the operations starting at step
+	 * (E).
+	 */
+
+	VERBOSE("%s End\n", __func__);
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_i_loadpieimage.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_i_loadpieimage.c
new file mode 100644
index 000000000..6c2a6e98d
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_i_loadpieimage.c
@@ -0,0 +1,429 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch_helpers.h>
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+#if STM32MP_LPDDR4_TYPE
+/*
+ * Program DfiWrRdDataCsConfig
+ * - Fields:
+ *   - dfiwrdatacspolarity
+ *   - dfirddatacspolarity
+ * - Dependencies:
+ *   - user_input_advanced.EnableDfiCsPolarityFix
+ */
+static void dfiwrrddatacsconfig_program(void)
+{
+	uint16_t dfiwrdatacspolarity;
+	uint16_t dfirddatacspolarity;
+
+	/*
+	 * DfiWrRdDataCsConfig : dfiwrdatacspolarity=0x1 and dfirddatacspolarity=0x1.
+	 * Set DataCsPolarity bits to enable active high
+	 */
+	dfiwrdatacspolarity = 0x1U;
+	dfirddatacspolarity = 0x1U;
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | C0 | CSR_DFIWRRDDATACSCONFIG_ADDR)),
+		      (dfiwrdatacspolarity << CSR_DFIWRDATACSPOLARITY_LSB |
+		       dfirddatacspolarity << CSR_DFIRDDATACSPOLARITY_LSB));
+}
+#endif /* STM32MP_LPDDR4_TYPE */
+
+/*
+ * Registers: Seq0BDLY0, Seq0BDLY1, Seq0BDLY2, Seq0BDLY3
+ * - Program PIE instruction delays
+ * - Dependencies:
+ *   - user_input_basic.frequency
+ */
+static void seq0bdly_program(void)
+{
+	int pstate;
+
+	/*
+	 * Calculate the counts to obtain the correct delay for each frequency
+	 * Need to divide by 4 since the delay value are specified in units of
+	 * 4 clocks.
+	 */
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int lowfreqopt __unused;
+		int delayscale_x100 = 100;
+		int p_addr;
+		long long dfifrq_x10;
+		long long dlllock_x10;
+		uint16_t pscount[4]; /* Need delays for 0.5us, 1us, 10us, and 25us */
+
+		p_addr = pstate << 20;
+		dfifrq_x10 = (10 * userinputbasic.frequency[pstate] / 2);
+		pscount[0] = (uint16_t)((dfifrq_x10 * delayscale_x100) / (10 * 100 * 2 * 4));
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+		if ( userinputbasic.frequency[pstate] < 400) {
+			lowfreqopt = 3;
+		} else if ( userinputbasic.frequency[pstate] < 533) {
+			lowfreqopt = 11;
+		} else {
+			lowfreqopt = 0;
+		}
+
+		pscount[1] = (uint16_t)(( 1 * dfifrq_x10 * delayscale_x100) / (10 * 100 * 4)) -
+				     lowfreqopt;
+#elif STM32MP_LPDDR4_TYPE
+		pscount[1] = (uint16_t)((1 * dfifrq_x10 * delayscale_x100) / (10 * 100 * 4));
+#endif /* STM32MP_LPDDR4_TYPE */
+		pscount[2] = (uint16_t)((10 * dfifrq_x10 * delayscale_x100) / (10 * 100 * 4));
+
+		if (dfifrq_x10 > 2665) {
+			dlllock_x10 = 1760;
+		} else if (dfifrq_x10 <= 2665 && dfifrq_x10 > 2000) {
+			dlllock_x10 = 1320;
+		} else {
+			dlllock_x10 = 640;
+		}
+
+		pscount[3] = (uint16_t)(dlllock_x10 / (10 * 4));
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | C0 | TMASTER |
+							      CSR_SEQ0BDLY0_ADDR)),
+			      pscount[0]);
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | C0 | TMASTER |
+							      CSR_SEQ0BDLY1_ADDR)),
+			      pscount[1]);
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | C0 | TMASTER |
+							      CSR_SEQ0BDLY2_ADDR)),
+			      pscount[2]);
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | C0 | TMASTER |
+							      CSR_SEQ0BDLY3_ADDR)),
+			      pscount[3]);
+	}
+}
+
+/*
+ * Registers: Seq0BDisableFlag0 Seq0BDisableFlag1 Seq0BDisableFlag2
+ * Seq0BDisableFlag3 Seq0BDisableFlag4 Seq0BDisableFlag5
+ * - Program PIE Instruction Disable Flags
+ * - Dependencies:
+ *   - user_input_advanced.DisableRetraining (DDR3/DDR4)
+ *   - skip_training (DDR3/DDR4)
+ *   - user_input_basic.frequency (DDR3/DDR4)
+ */
+static void seq0bdisableflag_program(bool skip_training)
+{
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TINITENG | CSR_SEQ0BDISABLEFLAG0_ADDR)),
+		      0x0000U);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TINITENG | CSR_SEQ0BDISABLEFLAG1_ADDR)),
+		      0x0173U);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TINITENG | CSR_SEQ0BDISABLEFLAG2_ADDR)),
+		      0x0060U);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TINITENG | CSR_SEQ0BDISABLEFLAG3_ADDR)),
+		      0x6110U);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TINITENG | CSR_SEQ0BDISABLEFLAG4_ADDR)),
+		      0x2152U);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TINITENG | CSR_SEQ0BDISABLEFLAG5_ADDR)),
+		      0xDFBDU);
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TINITENG | CSR_SEQ0BDISABLEFLAG6_ADDR)),
+		      0xFFFFU);
+#elif STM32MP_LPDDR4_TYPE
+	if (skip_training || userinputadvanced.disableretraining ||
+	    userinputbasic.frequency[0] < 333) {
+		/* Disabling DRAM drift compensation */
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TINITENG |
+							      CSR_SEQ0BDISABLEFLAG6_ADDR)),
+			      0xFFFFU);
+	} else {
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TINITENG |
+							      CSR_SEQ0BDISABLEFLAG6_ADDR)),
+			      0x2060U);
+	}
+#endif /* STM32MP_LPDDR4_TYPE */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TINITENG | CSR_SEQ0BDISABLEFLAG7_ADDR)),
+		      0x6152U);
+}
+
+#if STM32MP_LPDDR4_TYPE
+/*
+ * Registers: ppttrainsetup and ppttrainsetup2
+ * - Related to DFI PHY Master Interface (PMI). See Register description in PUB.
+ * - Enable DFI PMI if training firmware was run
+ * - Fields:
+ *   - PhyMstrTrainInterval
+ *   - PhyMstrMaxReqToAck
+ *   - PhyMstrFreqOverride
+ * - Dependencies:
+ *   - skip_training
+ *   - user_input_basic.frequency
+ *   - user_input_advanced.PhyMstrTrainInterval
+ *   - user_input_advanced.PhyMstrMaxReqToAck
+ */
+static void ppttrainsetup_program(void)
+{
+	int pstate;
+
+	/* Enabling Phy Master Interface for DRAM drift compensation */
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int p_addr;
+		uint16_t ppttrainsetup;
+
+		p_addr = pstate << 20;
+		if (userinputbasic.frequency[pstate] >= 333) {
+			ppttrainsetup =	(uint16_t)(
+						(userinputadvanced.phymstrtraininterval[pstate] <<
+						CSR_PHYMSTRTRAININTERVAL_LSB) |
+						(userinputadvanced.phymstrmaxreqtoack[pstate] <<
+						CSR_PHYMSTRMAXREQTOACK_LSB));
+
+			mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TMASTER |
+									CSR_PPTTRAINSETUP_ADDR)),
+				      ppttrainsetup);
+			mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TMASTER |
+									CSR_PPTTRAINSETUP2_ADDR)),
+				      0x0003U);
+		}
+	}
+}
+
+/*
+ * Registers AcsmPlayback*x*
+ * - Program Address/Command Sequence Engine (ACSM) registers with
+ *   required instructions for retraining algorithm.
+ * - Dependencies:
+ *   - user_input_basic.numpstates
+ */
+static void acsmplayback_program(void)
+{
+	int pstate;
+
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		uint16_t acsmplayback[2][4] = { { 0U, 0U, 0U, 0U },
+						{ 0U, 0U, 0U, 0U } };
+		int numvec;
+		int p_addr;
+		int vec;
+
+		p_addr = pstate << 20;
+		numvec = 0;
+		acsmplayback[0][0] = 0x3U << 6 | 0x20U;
+		acsmplayback[1][0] = 0x0U << 6 | 0x12U;
+		acsmplayback[0][1] = 0x3U << 6 | 0x20U;
+		acsmplayback[1][1] = 0x0U << 6 | 0x12U;
+		acsmplayback[0][2] = 0x3U << 6 | 0x20U;
+		acsmplayback[1][2] = 0x0U << 6 | 0x12u;
+		numvec = 3;
+
+		for (vec = 0; vec < numvec; vec++) {
+			mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TACSM |
+								      (CSR_ACSMPLAYBACK0X0_ADDR +
+								       vec * 2))),
+				      acsmplayback[0][vec]);
+
+			mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TACSM |
+								      (CSR_ACSMPLAYBACK1X0_ADDR +
+								       vec * 2))),
+				      acsmplayback[1][vec]);
+		}
+	}
+}
+
+/*
+ * Program Training Hardware Registers for mission mode retraining
+ * and DRAM drift compensation algorithm.
+ */
+static void traininghwreg_program(void)
+{
+	int byte;
+	uint16_t regdata;
+
+	/* Programing Training Hardware Registers for mission mode retraining */
+
+	/*
+	 * - Register: AcsmCtrl13
+	 *   - Fields: AcsmCkeEnb
+	 */
+	regdata = (0xFU << CSR_ACSMCKEENB_LSB);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (C0 | TACSM | CSR_ACSMCTRL13_ADDR)), regdata);
+
+	/*
+	 * - Register: TsmByte1, TsmByte2
+	 *   - Dependencies: userinputbasic.numdbyte
+	 */
+
+	for (byte = 0; byte < userinputbasic.numdbyte; byte++) {
+		int c_addr;
+		int i_addr;
+		int vec;
+
+		/* for each chiplet */
+		c_addr = byte * C1;
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (c_addr | TDBYTE | CSR_TSMBYTE1_ADDR)),
+			      0x1U);   /* [15:8] gstep; [7:0]bstep; */
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (c_addr | TDBYTE | CSR_TSMBYTE2_ADDR)),
+			      0x1U);   /* [15:0] good_bar; */
+
+		regdata = (CSR_DTSMSTATICCMPR_MASK | CSR_DTSMSTATICCMPRVAL_MASK);
+
+		/*
+		 * - Register: TsmByte3, TsmByte5
+		 *   - Fields:
+		 *     - DtsmStaticCmpr
+		 *     - DtsmStaticCmprVal
+		 */
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (c_addr | TDBYTE | CSR_TSMBYTE3_ADDR)),
+			      regdata);
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (c_addr | TDBYTE | CSR_TSMBYTE5_ADDR)),
+			      0x1U); /* [15:0] bad_bar; */
+
+		/*
+		 * - Register: TrainingParam
+		 *   - Fields:
+		 *     - EnDynRateReduction
+		 *     - RollIntoCoarse
+		 *     - IncDecRate
+		 *     - TrainEnRxEn
+		 *   - Dependencies:
+		 *     - user_input_advanced.DisableRetraining
+		 */
+		regdata = (CSR_ENDYNRATEREDUCTION_MASK | CSR_ROLLINTOCOARSE_MASK |
+			   (0x3U << CSR_INCDECRATE_LSB));
+		regdata = userinputadvanced.disableretraining ?
+			  regdata : (regdata | CSR_TRAINENRXEN_MASK);
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (c_addr | TDBYTE |
+							      CSR_TRAININGPARAM_ADDR)),
+			      regdata);
+
+		/*
+		 * - Register: Tsm0
+		 *   - Fields:
+		 *     - DtsmEnb
+		 */
+		regdata = (0x1U << CSR_DTSMENB_LSB);
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (c_addr | I0 | TDBYTE |
+							      CSR_TSM0_ADDR)),
+			      regdata);
+
+		/*
+		 * - Register: Tsm2
+		 *   - Fields:
+		 *     - DtsmDisErrChk
+		 */
+		regdata = (0x1U << CSR_DTSMDISERRCHK_LSB);
+		for (vec = 1; vec <= I_MAX; vec++) {
+			i_addr = vec * I1;
+			mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (c_addr | i_addr | TDBYTE |
+								      CSR_TSM2_ADDR)),
+				      regdata);
+		} /* for vec */
+	} /* for byte */
+}
+#endif /* STM32MP_LPDDR4_TYPE */
+
+/*
+ * - Register: calrate
+ *   - Fields:
+ *     - calOnce
+ *     - calinterval
+ *   - Dependencies
+ *     - user_input_advanced.calinterval
+ *     - user_input_advanced.calonce
+ */
+static void calrate_program(void)
+{
+	int calinterval;
+	int calonce;
+	uint16_t calrate;
+
+	calinterval = userinputadvanced.calinterval;
+	calonce = userinputadvanced.calonce;
+
+	calrate = (uint16_t)((0x1 << CSR_CALRUN_LSB) | (calonce << CSR_CALONCE_LSB) |
+			     (calinterval << CSR_CALINTERVAL_LSB));
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_CALRATE_ADDR)), calrate);
+}
+
+/*
+ * Loads registers after training
+ *
+ * This function programs the PHY Initialization Engine (PIE) instructions and
+ * the associated registers.
+ * Training hardware registers are also programmed to for mission mode
+ * retraining. (LPDDR4)
+ *
+ * \return void
+ */
+void ddrphy_phyinit_i_loadpieimage(bool skip_training)
+{
+	VERBOSE("%s Start\n", __func__);
+
+	/*
+	 * Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0.
+	 * This allows the memory controller unrestricted access to the configuration CSRs.
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR)), 0x0U);
+
+	ddrphy_phyinit_loadpieprodcode();
+
+#if STM32MP_LPDDR4_TYPE
+	/*
+	 * No user specified EnableDfiCsPolarityFix, running with new PUB with DFI CS polarity fix
+	 * so program the data polarity CSR.
+	 */
+	dfiwrrddatacsconfig_program();
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	seq0bdly_program();
+
+	seq0bdisableflag_program(skip_training);
+
+#if STM32MP_LPDDR4_TYPE
+	if (!skip_training) {
+		ppttrainsetup_program();
+	}
+
+	acsmplayback_program();
+
+	traininghwreg_program();
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	/*
+	 * - Register: CalZap
+	 *   - Prepare the calibration controller for mission mode.
+	 *     Turn on calibration and hold idle until dfi_init_start is asserted sequence is
+	 *     triggered.
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_CALZAP_ADDR)), 0x1U);
+
+	calrate_program();
+
+	/*
+	 * At the end of this function, PHY Clk gating register UcclkHclkEnables is
+	 * set for mission mode.  Additionally APB access is Isolated by setting
+	 * MicroContMuxSel.
+	 */
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	/* Disabling Ucclk (PMU) and Hclk (training hardware) */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TDRTUB | CSR_UCCLKHCLKENABLES_ADDR)), 0x0U);
+#elif STM32MP_LPDDR4_TYPE
+	/* Disabling Ucclk (PMU) */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TDRTUB | CSR_UCCLKHCLKENABLES_ADDR)), 0x2U);
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	/* Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR)), 0x1U);
+
+	VERBOSE("%s End\n", __func__);
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_initstruct.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_initstruct.c
new file mode 100644
index 000000000..e4cef3a92
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_initstruct.c
@@ -0,0 +1,454 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <string.h>
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit.h>
+
+void *ddrphy_phyinit_get_user_input_basic_base(void)
+{
+	return (void *)&userinputbasic;
+}
+
+int ddrphy_phyinit_get_user_input_basic_pllbypass_0(void)
+{
+	return userinputbasic.pllbypass[0];
+}
+
+void *ddrphy_phyinit_get_user_input_advanced_base(void)
+{
+	return (void *)&userinputadvanced;
+}
+
+void *ddrphy_phyinit_get_user_input_mode_register_base(void)
+{
+	return (void *)&userinputmoderegister;
+}
+
+void *ddrphy_phyinit_get_user_input_swizzle_base(void)
+{
+	return (void *)&userinputswizzle;
+}
+
+/*
+ * This is used to initialize the PhyInit structures before user defaults and overrides are applied.
+ *
+ * @return Void
+ */
+void ddrphy_phyinit_initstruct(void)
+{
+	/*
+	 * ##############################################################
+	 * Basic Message Block Variables
+	 * ##############################################################
+	 */
+	int myps;
+
+	/*
+	 * ##############################################################
+	 * These are typically invariant across pstate
+	 * ##############################################################
+	 */
+	uint8_t msgmisc = 0x00U;	/* For fast simulation */
+	uint8_t reserved00 = 0x0U;	/*
+					 * Set reserved00[7] = 1 (If using T28 attenuated receivers)
+					 * Set reserved00[6:0] = 0 (Reserved; must be set to 0)
+					 */
+
+	uint8_t hdtctrl = 0xFFU;
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	uint8_t cspresent = 0x01U;	/*
+					 * Indicates presence of DRAM at each chip select for PHY.
+					 *
+					 * If the bit is set to 1, the CS is connected to DRAM.
+					 * If the bit is set to 0, the CS is not connected to DRAM.
+					 *
+					 * Set cspresent[0]   = 1 (if CS0 is populated with DRAM)
+					 * Set cspresent[1]   = 1 (if CS1 is populated with DRAM)
+					 * Set cspresent[2]   = 1 (if CS2 is populated with DRAM)
+					 * Set cspresent[3]   = 1 (if CS3 is populated with DRAM)
+					 * Set cspresent[7:4] = 0 (Reserved; must be set to 0)
+					 */
+	uint8_t dfimrlmargin = 0x01U;	/* 1 is typically good in DDR3 */
+#if STM32MP_DDR3_TYPE
+	uint8_t addrmirror = 0x00U;	/*
+					 * Set addrmirror[pstate] if CS[pstate] is mirrored.
+					 * (typically odd CS are mirroed in DIMMs)
+					 */
+#else
+	uint8_t addrmirror = 0xAAU;	/*
+					 * Set addrmirror[pstate] if CS[pstate] is mirrored.
+					 * (typically odd CS are mirroed in DIMMs)
+					 */
+#endif /* STM32MP_DDR3_TYPE */
+	uint8_t wrodtpat_rank0 = 0x01U;	/*
+					 * When Writing Rank0 : Bits[3:0] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+	uint8_t wrodtpat_rank1 = 0x02U;	/*
+					 * When Writing Rank1 : Bits[3:0] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+#if STM32MP_DDR3_TYPE
+	uint8_t wrodtpat_rank2 = 0x04U;	/*
+					 * When Writing Rank2 : Bits[3:0] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+	uint8_t wrodtpat_rank3 = 0x08U;	/*
+					 * When Writing Rank3 : Bits[3:0] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+#else
+	uint8_t wrodtpat_rank2 = 0x00U;	/*
+					 * When Writing Rank2 : Bits[3:0] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+	uint8_t wrodtpat_rank3 = 0x00U;	/*
+					 * When Writing Rank3 : Bits[3:0] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+#endif /* STM32MP_DDR3_TYPE */
+	uint8_t rdodtpat_rank0 = 0x20U;	/*
+					 * When Reading Rank0 : Bits[7:4] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+	uint8_t rdodtpat_rank1 = 0x10U;	/*
+					 * When Reading Rank1 : Bits[7:4] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+#if STM32MP_DDR3_TYPE
+	uint8_t rdodtpat_rank2 = 0x80U;	/*
+					 * When Reading Rank2 : Bits[7:4] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+	uint8_t rdodtpat_rank3 = 0x40U;	/*
+					 * When Reading Rank3 : Bits[7:4] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+#else
+	uint8_t rdodtpat_rank2 = 0x00U;	/*
+					 * When Reading Rank2 : Bits[7:4] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+	uint8_t rdodtpat_rank3 = 0x00U;	/*
+					 * When Reading Rank3 : Bits[7:4] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+
+	uint8_t d4misc = 0x1U;		/*
+					 * Protect memory reset:
+					 * 0x1 = dfi_reset_n cannot control BP_MEMRESERT_L to
+					 *       devices after training.
+					 * 0x0 = dfi_resert_n can control BP_MEMRESERT_L to
+					 *       devices after training.
+					 */
+#endif /* STM32MP_DDR3_TYPE */
+#elif STM32MP_LPDDR4_TYPE
+	uint8_t caterminatingrankcha = 0x00U; /*Usually Rank0 is terminating rank */
+	uint8_t caterminatingrankchb = 0x00U; /*Usually Rank0 is terminating rank */
+	uint8_t dfimrlmargin = 0x02U; /*This needs to be large enough for max tDQSCK variation */
+#endif /* STM32MP_LPDDR4_TYPE */
+
+#if STM32MP_DDR3_TYPE
+	uint8_t share2dvrefresult = 0x0U;
+#elif STM32MP_DDR4_TYPE
+	uint8_t share2dvrefresult = 0x1U;
+#elif STM32MP_LPDDR4_TYPE
+	uint8_t share2dvrefresult = 0x1U;	/*
+						 * Bitmap that controls which vref generator the
+						 * phy will use per pstate
+						 *     If share2dvrefresult[x] = 1, pstate x will
+						 *     use the per-lane VrefDAC0/1 CSRs which can be
+						 *     trained by 2d training. If 2D has not run
+						 *     yet, VrefDAC0/1 will default to pstate 0's
+						 *     1D phyVref messageBlock setting.
+						 *     If share2dvrefresult[x] = 0, pstate x will
+						 *     use the per-phy VrefInGlobal CSR, which are
+						 *     set to pstate x's 1D phyVref messageBlock
+						 *     setting.
+						 */
+	uint8_t usebroadcastmr = 0x00U;
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	/*
+	 * ##############################################################
+	 * These typically change across pstate
+	 * ##############################################################
+	 */
+
+#if STM32MP_DDR4_TYPE
+	uint16_t alt_cas_l[NB_PS]; /* Need to set if using RDDBI */
+	uint16_t alt_wcas_l[NB_PS]; /* Need to set if using 2tck Write Preambles */
+	uint16_t rtt_nom_wr_park0[NB_PS];
+	uint16_t rtt_nom_wr_park1[NB_PS];
+	uint16_t rtt_nom_wr_park2[NB_PS];
+	uint16_t rtt_nom_wr_park3[NB_PS];
+	uint16_t rtt_nom_wr_park4[NB_PS];
+	uint16_t rtt_nom_wr_park5[NB_PS];
+	uint16_t rtt_nom_wr_park6[NB_PS];
+	uint16_t rtt_nom_wr_park7[NB_PS];
+#endif /* STM32MP_DDR4_TYPE */
+
+	VERBOSE("%s Start\n", __func__);
+
+#if STM32MP_DDR4_TYPE
+	for (myps = 0; myps < NB_PS; myps++) {
+		alt_cas_l[myps] = 0x0000U;
+		alt_wcas_l[myps] = 0x0000U;
+	}
+#endif /* STM32MP_DDR4_TYPE */
+
+	/*
+	 * ##############################################################
+	 * These are per-pstate Control Words for RCD
+	 * Please enter the correct values for your configuration
+	 * ##############################################################
+	 */
+
+	/*
+	 * ##############################################################
+	 * 95% of users will not need to edit below
+	 * ##############################################################
+	 */
+
+#if STM32MP_DDR4_TYPE
+	/*
+	 * Per Rank MR seeting for RTT_NOM, RTT_WR, RTT_PARK per rank. Options unlikely need to be
+	 * used. See MB details on how to program if required.
+	 */
+	for (myps = 0; myps < NB_PS; myps++) {
+		rtt_nom_wr_park0[myps] = 0x0U;
+		rtt_nom_wr_park1[myps] = 0x0U;
+		rtt_nom_wr_park2[myps] = 0x0U;
+		rtt_nom_wr_park3[myps] = 0x0U;
+		rtt_nom_wr_park4[myps] = 0x0U;
+		rtt_nom_wr_park5[myps] = 0x0U;
+		rtt_nom_wr_park6[myps] = 0x0U;
+		rtt_nom_wr_park7[myps] = 0x0U;
+	}
+#endif /* STM32MP_DDR4_TYPE */
+
+	/* 1D message block defaults */
+	for (myps = 0; myps < NB_PS; myps++) {
+		mb_ddr_1d[myps].pstate = (uint8_t)myps;
+		mb_ddr_1d[myps].sequencectrl = (uint16_t)userinputadvanced.sequencectrl[myps];
+		mb_ddr_1d[myps].phyconfigoverride = 0x0U;
+		mb_ddr_1d[myps].hdtctrl = hdtctrl;
+		mb_ddr_1d[myps].msgmisc = msgmisc;
+		mb_ddr_1d[myps].reserved00 = reserved00;
+		mb_ddr_1d[myps].dfimrlmargin = dfimrlmargin;
+		mb_ddr_1d[myps].phyvref = (uint8_t)userinputadvanced.phyvref;
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+		mb_ddr_1d[myps].cspresent = cspresent;
+		mb_ddr_1d[myps].cspresentd0 = cspresent;
+		mb_ddr_1d[myps].cspresentd1 = 0x0U; /* Unused */
+		mb_ddr_1d[myps].addrmirror = addrmirror;
+
+		mb_ddr_1d[myps].acsmodtctrl0 = wrodtpat_rank0 | rdodtpat_rank0;
+		mb_ddr_1d[myps].acsmodtctrl1 = wrodtpat_rank1 | rdodtpat_rank1;
+		mb_ddr_1d[myps].acsmodtctrl2 = wrodtpat_rank2 | rdodtpat_rank2;
+		mb_ddr_1d[myps].acsmodtctrl3 = wrodtpat_rank3 | rdodtpat_rank3;
+
+		mb_ddr_1d[myps].acsmodtctrl4 = 0x0U; /* Unused */
+		mb_ddr_1d[myps].acsmodtctrl5 = 0x0U; /* Unused */
+		mb_ddr_1d[myps].acsmodtctrl6 = 0x0U; /* Unused */
+		mb_ddr_1d[myps].acsmodtctrl7 = 0x0U; /* Unused */
+		mb_ddr_1d[myps].enableddqs = (uint8_t)((userinputbasic.numactivedbytedfi0 +
+							userinputbasic.numactivedbytedfi1) * 8);
+#if STM32MP_DDR3_TYPE
+		mb_ddr_1d[myps].phycfg = (uint8_t)userinputadvanced.is2ttiming[myps];
+#else
+		mb_ddr_1d[myps].phycfg = (userinputmoderegister.mr3[myps] & 0x8) ?
+					 0U : (uint8_t)userinputadvanced.is2ttiming[myps];
+		mb_ddr_1d[myps].x16present = (0x10 == userinputbasic.dramdatawidth) ?
+					     mb_ddr_1d[myps].cspresent : 0x0U;
+		mb_ddr_1d[myps].d4misc = d4misc;
+		mb_ddr_1d[myps].cssetupgddec = 0x1U;	/*
+							 * If Geardown is chosen, dynamically modify
+							 * CS timing.
+							 */
+		mb_ddr_1d[myps].rtt_nom_wr_park0 = rtt_nom_wr_park0[myps];
+		mb_ddr_1d[myps].rtt_nom_wr_park1 = rtt_nom_wr_park1[myps];
+		mb_ddr_1d[myps].rtt_nom_wr_park2 = rtt_nom_wr_park2[myps];
+		mb_ddr_1d[myps].rtt_nom_wr_park3 = rtt_nom_wr_park3[myps];
+		mb_ddr_1d[myps].rtt_nom_wr_park4 = rtt_nom_wr_park4[myps];
+		mb_ddr_1d[myps].rtt_nom_wr_park5 = rtt_nom_wr_park5[myps];
+		mb_ddr_1d[myps].rtt_nom_wr_park6 = rtt_nom_wr_park6[myps];
+		mb_ddr_1d[myps].rtt_nom_wr_park7 = rtt_nom_wr_park7[myps];
+#endif /* STM32MP_DDR3_TYPE */
+
+		mb_ddr_1d[myps].mr0 = (uint16_t)userinputmoderegister.mr0[myps];
+		mb_ddr_1d[myps].mr1 = (uint16_t)userinputmoderegister.mr1[myps];
+		mb_ddr_1d[myps].mr2 = (uint16_t)userinputmoderegister.mr2[myps];
+#if STM32MP_DDR4_TYPE
+		mb_ddr_1d[myps].mr3 = (uint16_t)userinputmoderegister.mr3[myps];
+		mb_ddr_1d[myps].mr4 = (uint16_t)userinputmoderegister.mr4[myps];
+		mb_ddr_1d[myps].mr5 = (uint16_t)userinputmoderegister.mr5[myps];
+		mb_ddr_1d[myps].mr6 = (uint16_t)userinputmoderegister.mr6[myps];
+
+		mb_ddr_1d[myps].alt_cas_l = alt_cas_l[myps];
+		mb_ddr_1d[myps].alt_wcas_l = (uint8_t)alt_wcas_l[myps];
+
+		/* Outputs - just initialize these to zero */
+		mb_ddr_1d[myps].vrefdqr0nib0 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr0nib1 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr0nib2 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr0nib3 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr0nib4 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr0nib5 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr0nib6 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr0nib7 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr0nib8 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr0nib9 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr0nib10 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr0nib11 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr0nib12 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr0nib13 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr0nib14 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr0nib15 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr0nib16 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr0nib17 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr0nib18 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr0nib19 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib0 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib1 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib2 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib3 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib4 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib5 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib6 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib7 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib8 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib9 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib10 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib11 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib12 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib13 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib14 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib15 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib16 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib17 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib18 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr1nib19 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib0 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib1 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib2 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib3 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib4 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib5 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib6 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib7 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib8 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib9 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib10 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib11 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib12 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib13 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib14 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib15 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib16 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib17 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib18 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr2nib19 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib0 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib1 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib2 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib3 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib4 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib5 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib6 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib7 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib8 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib9 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib10 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib11 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib12 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib13 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib14 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib15 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib16 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib17 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib18 = 0x00U;
+		mb_ddr_1d[myps].vrefdqr3nib19 = 0x00U;
+#endif /* STM32MP_DDR4_TYPE */
+#elif STM32MP_LPDDR4_TYPE
+		mb_ddr_1d[myps].enableddqscha = (uint8_t)(userinputbasic.numactivedbytedfi0 * 8);
+		mb_ddr_1d[myps].cspresentcha = (2 == userinputbasic.numrank_dfi0) ?
+					       0x3U : (uint8_t)userinputbasic.numrank_dfi0;
+		mb_ddr_1d[myps].enableddqschb = (uint8_t)(userinputbasic.numactivedbytedfi1 * 8);
+		mb_ddr_1d[myps].cspresentchb = (2 == userinputbasic.numrank_dfi1) ?
+					       0x3U : (uint8_t)userinputbasic.numrank_dfi1;
+		mb_ddr_1d[myps].usebroadcastmr = usebroadcastmr;
+
+		mb_ddr_1d[myps].lp4misc = 0x00U;
+		mb_ddr_1d[myps].caterminatingrankcha = caterminatingrankcha;
+		mb_ddr_1d[myps].caterminatingrankchb = caterminatingrankchb;
+		mb_ddr_1d[myps].lp4quickboot = 0x00U;
+		mb_ddr_1d[myps].catrainopt = 0x00U;
+		mb_ddr_1d[myps].x8mode = 0x00U;
+
+		mb_ddr_1d[myps].mr1_a0 = (uint8_t)userinputmoderegister.mr1[myps];
+		mb_ddr_1d[myps].mr2_a0 = (uint8_t)userinputmoderegister.mr2[myps];
+		mb_ddr_1d[myps].mr3_a0 = (uint8_t)userinputmoderegister.mr3[myps];
+		mb_ddr_1d[myps].mr4_a0 = (uint8_t)userinputmoderegister.mr4[myps];
+		mb_ddr_1d[myps].mr11_a0 = (uint8_t)userinputmoderegister.mr11[myps];
+		mb_ddr_1d[myps].mr12_a0 = (uint8_t)userinputmoderegister.mr12[myps];
+		mb_ddr_1d[myps].mr13_a0 = (uint8_t)userinputmoderegister.mr13[myps];
+		mb_ddr_1d[myps].mr14_a0 = (uint8_t)userinputmoderegister.mr14[myps];
+		mb_ddr_1d[myps].mr16_a0 = 0x00U;
+		mb_ddr_1d[myps].mr17_a0 = 0x00U;
+		mb_ddr_1d[myps].mr22_a0 = (uint8_t)userinputmoderegister.mr22[myps];
+		mb_ddr_1d[myps].mr24_a0 = 0x00U;
+		mb_ddr_1d[myps].mr1_a1 = (uint8_t)userinputmoderegister.mr1[myps];
+		mb_ddr_1d[myps].mr2_a1 = (uint8_t)userinputmoderegister.mr2[myps];
+		mb_ddr_1d[myps].mr3_a1 = (uint8_t)userinputmoderegister.mr3[myps];
+		mb_ddr_1d[myps].mr4_a1 = (uint8_t)userinputmoderegister.mr4[myps];
+		mb_ddr_1d[myps].mr11_a1 = (uint8_t)userinputmoderegister.mr11[myps];
+		mb_ddr_1d[myps].mr12_a1 = (uint8_t)userinputmoderegister.mr12[myps];
+		mb_ddr_1d[myps].mr13_a1 = (uint8_t)userinputmoderegister.mr13[myps];
+		mb_ddr_1d[myps].mr14_a1 = (uint8_t)userinputmoderegister.mr14[myps];
+		mb_ddr_1d[myps].mr16_a1 = 0x00U;
+		mb_ddr_1d[myps].mr17_a1 = 0x00U;
+		mb_ddr_1d[myps].mr22_a1 = (uint8_t)userinputmoderegister.mr22[myps];
+		mb_ddr_1d[myps].mr24_a1 = 0x00U;
+
+		mb_ddr_1d[myps].mr1_b0 = (uint8_t)userinputmoderegister.mr1[myps];
+		mb_ddr_1d[myps].mr2_b0 = (uint8_t)userinputmoderegister.mr2[myps];
+		mb_ddr_1d[myps].mr3_b0 = (uint8_t)userinputmoderegister.mr3[myps];
+		mb_ddr_1d[myps].mr4_b0 = (uint8_t)userinputmoderegister.mr4[myps];
+		mb_ddr_1d[myps].mr11_b0 = (uint8_t)userinputmoderegister.mr11[myps];
+		mb_ddr_1d[myps].mr12_b0 = (uint8_t)userinputmoderegister.mr12[myps];
+		mb_ddr_1d[myps].mr13_b0 = (uint8_t)userinputmoderegister.mr13[myps];
+		mb_ddr_1d[myps].mr14_b0 = (uint8_t)userinputmoderegister.mr14[myps];
+		mb_ddr_1d[myps].mr16_b0 = 0x00U;
+		mb_ddr_1d[myps].mr17_b0 = 0x00U;
+		mb_ddr_1d[myps].mr22_b0 = (uint8_t)userinputmoderegister.mr22[myps];
+		mb_ddr_1d[myps].mr24_b0 = 0x00U;
+		mb_ddr_1d[myps].mr1_b1 = (uint8_t)userinputmoderegister.mr1[myps];
+		mb_ddr_1d[myps].mr2_b1 = (uint8_t)userinputmoderegister.mr2[myps];
+		mb_ddr_1d[myps].mr3_b1 = (uint8_t)userinputmoderegister.mr3[myps];
+		mb_ddr_1d[myps].mr4_b1 = (uint8_t)userinputmoderegister.mr4[myps];
+		mb_ddr_1d[myps].mr11_b1 = (uint8_t)userinputmoderegister.mr11[myps];
+		mb_ddr_1d[myps].mr12_b1 = (uint8_t)userinputmoderegister.mr12[myps];
+		mb_ddr_1d[myps].mr13_b1 = (uint8_t)userinputmoderegister.mr13[myps];
+		mb_ddr_1d[myps].mr14_b1 = (uint8_t)userinputmoderegister.mr14[myps];
+		mb_ddr_1d[myps].mr16_b1 = 0x00U;
+		mb_ddr_1d[myps].mr17_b1 = 0x00U;
+		mb_ddr_1d[myps].mr22_b1 = (uint8_t)userinputmoderegister.mr22[myps];
+		mb_ddr_1d[myps].mr24_b1 = 0x00U;
+#endif /* STM32MP_LPDDR4_TYPE */
+
+		mb_ddr_1d[myps].share2dvrefresult = share2dvrefresult;
+
+		/* Zero out struct contents */
+		memset((void *) &shdw_ddr_1d[myps], 0, sizeof(pmu_smb_ddr_1d_t));
+	} /* myps */
+
+	VERBOSE("%s End\n", __func__);
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_isdbytedisabled.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_isdbytedisabled.c
new file mode 100644
index 000000000..d0ec3a626
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_isdbytedisabled.c
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdlib.h>
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit.h>
+#include <ddrphy_wrapper.h>
+
+/*
+ * Helper function to determine if a given DByte is Disabled given PhyInit inputs.
+ * @return 1 if disabled, 0 if enabled.
+ */
+int ddrphy_phyinit_isdbytedisabled(int dbytenumber)
+{
+	int disabledbyte;
+	int nad0 __unused;
+	int nad1 __unused;
+
+	disabledbyte = 0; /* Default assume Dbyte is Enabled */
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	/* Implements Section 1.3 of Pub Databook */
+	disabledbyte = (dbytenumber > userinputbasic.numactivedbytedfi0 - 1) ? 1 : 0;
+#elif STM32MP_LPDDR4_TYPE
+	nad0 = userinputbasic.numactivedbytedfi0;
+	nad1 = userinputbasic.numactivedbytedfi1;
+
+	if (nad0 + nad1 > userinputbasic.numdbyte) {
+		ERROR("%s invalid PHY configuration:\n", __func__);
+		ERROR("numactivedbytedfi0(%d)+numactivedbytedfi1(%d)>numdbytes(%d).\n",
+		      nad0, nad1, userinputbasic.numdbyte);
+	}
+
+	/* Implements Section 1.3 of Pub Databook */
+	if (userinputbasic.dfi1exists) {
+		if (userinputbasic.numactivedbytedfi1 == 0) {
+			/* Only dfi0 (ChA) is enabled, dfi1 (ChB) disabled */
+			disabledbyte = (dbytenumber > userinputbasic.numactivedbytedfi0 - 1) ?
+				       1 : 0;
+		} else {
+			/* DFI1 enabled */
+			disabledbyte = ((userinputbasic.numactivedbytedfi0 - 1 < dbytenumber) &&
+					(dbytenumber < (userinputbasic.numdbyte / 2))) ?
+				       1 : (dbytenumber >
+					    ((userinputbasic.numdbyte / 2) +
+					     userinputbasic.numactivedbytedfi1 - 1)) ? 1 : 0;
+		}
+	} else if (userinputbasic.dfi1exists == 0x0) {
+		disabledbyte = (dbytenumber > userinputbasic.numactivedbytedfi0 - 1) ? 1 : 0;
+	} else {
+		ERROR("%s invalid PHY configuration:dfi1exists is neither 1 or 0.\n", __func__);
+	}
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	/* Qualify results against MessageBlock */
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	if (mb_ddr_1d[0].enableddqs < 1 ||
+	    mb_ddr_1d[0].enableddqs > 8 * userinputbasic.numactivedbytedfi0) {
+		ERROR("%s enableddqs(%d)\n", __func__, mb_ddr_1d[0].enableddqs);
+		ERROR("Value must be 0 < enableddqs < userinputbasic.numactivedbytedfi0 * 8.\n");
+	}
+
+	if (dbytenumber < 8) {
+		disabledbyte = disabledbyte | (mb_ddr_1d[0].disableddbyte & (0x1 << dbytenumber));
+	}
+#elif STM32MP_LPDDR4_TYPE
+	if (mb_ddr_1d[0].enableddqscha < 1 ||
+	    mb_ddr_1d[0].enableddqscha > 8 * userinputbasic.numactivedbytedfi0) {
+		ERROR("%s enableddqscha(%d)\n", __func__, mb_ddr_1d[0].enableddqscha);
+		ERROR("Value must be 0 < enableddqscha < userinputbasic.numactivedbytedfi0 * 8.\n");
+	}
+
+	if (userinputbasic.dfi1exists && userinputbasic.numactivedbytedfi1 > 0 &&
+	    (mb_ddr_1d[0].enableddqschb < 1 ||
+	     mb_ddr_1d[0].enableddqschb > 8 * userinputbasic.numactivedbytedfi1)) {
+		ERROR("%s enableddqschb(%d)\n", __func__, mb_ddr_1d[0].enableddqschb);
+		ERROR("Value must be 0 < enableddqschb < userinputbasic.numactivedbytedfi1 * 8.\n");
+	}
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	return disabledbyte;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_load_sr_fw.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_load_sr_fw.c
new file mode 100644
index 000000000..7cf8a23d1
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_load_sr_fw.c
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdio.h>
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit.h>
+
+/*
+ * Loads Save/Restore firmware IMEM and DMEM image
+ *
+ * This function is used when the Micro-Controller is used to Save/Restore PHY registers.
+ * \return void
+ */
+void ddrphy_phyinit_load_sr_fw(void)
+{
+	int i;
+	int imem[SR_IMEM_SIZE];
+	int imem_offset = 0;
+	return_offset_lastaddr_t return_type = return_offset;
+
+	VERBOSE("Start of loading Universal Resident Retention IMEM\n");
+
+	/* Initialize the dmem structure */
+	for (i = 0; i < SR_IMEM_SIZE; i++) {
+		imem[i] = 0;
+	}
+
+	/* Start of loading Universal Resident Retention IMEM */
+	imem_offset = ddrphy_phyinit_storeincvfile(SR_IMEM_INCV_FILENAME, imem, return_type);
+	/* Write local imem array */
+	ddrphy_phyinit_writeoutmem(imem, imem_offset, SR_IMEM_SIZE);
+
+	VERBOSE("End of loading Universal Resident Retention IMEM\n");
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_loadpieprodcode.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_loadpieprodcode.c
new file mode 100644
index 000000000..0ae1fee9a
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_loadpieprodcode.c
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdint.h>
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+#define PRODCODE_SIZE	171
+
+static const uint32_t prodcode_addr[PRODCODE_SIZE] = {
+	0x90000U, 0x90001U, 0x90002U, 0x90003U, 0x90004U, 0x90005U, 0x90029U, 0x9002AU, 0x9002BU,
+	0x9002CU, 0x9002DU, 0x9002EU, 0x9002FU, 0x90030U, 0x90031U, 0x90032U, 0x90033U, 0x90034U,
+	0x90035U, 0x90036U, 0x90037U, 0x90038U, 0x90039U, 0x9003AU, 0x9003BU, 0x9003CU, 0x9003DU,
+	0x9003EU, 0x9003FU, 0x90040U, 0x90041U, 0x90042U, 0x90043U, 0x90044U, 0x90045U, 0x90046U,
+	0x90047U, 0x90048U, 0x90049U, 0x9004AU, 0x9004BU, 0x9004CU, 0x9004DU, 0x9004EU, 0x9004FU,
+	0x90050U, 0x90051U, 0x90052U, 0x90053U, 0x90054U, 0x90055U, 0x90056U, 0x90057U, 0x90058U,
+	0x90059U, 0x9005AU, 0x9005BU, 0x9005CU, 0x9005DU, 0x9005EU, 0x9005FU, 0x90060U, 0x90061U,
+	0x90062U, 0x90063U, 0x90064U, 0x90065U, 0x90066U, 0x90067U, 0x90068U, 0x90069U, 0x9006AU,
+	0x9006BU, 0x9006CU, 0x9006DU, 0x9006EU, 0x9006FU, 0x90070U, 0x90071U, 0x90072U, 0x90073U,
+	0x90074U, 0x90075U, 0x90076U, 0x90077U, 0x90078U, 0x90079U, 0x9007AU, 0x9007BU, 0x9007CU,
+	0x9007DU, 0x9007EU, 0x9007FU, 0x90080U, 0x90081U, 0x90082U, 0x90083U, 0x90084U, 0x90085U,
+	0x90086U, 0x90087U, 0x90088U, 0x90089U, 0x9008AU, 0x9008BU, 0x9008CU, 0x9008DU, 0x9008EU,
+	0x9008FU, 0x90090U, 0x90091U, 0x90092U, 0x90093U, 0x90094U, 0x90095U, 0x90096U, 0x90097U,
+	0x90098U, 0x90099U, 0x9009AU, 0x9009BU, 0x9009CU, 0x9009DU, 0x9009EU, 0x9009FU, 0x900A0U,
+	0x900A1U, 0x900A2U, 0x900A3U, 0x900A4U, 0x900A5U, 0x900A6U, 0x900A7U, 0x900A8U, 0x900A9U,
+	0x900AAU, 0x900ABU, 0x900ACU, 0x900ADU, 0x900AEU, 0x900AFU, 0x900B0U, 0x900B1U, 0x900B2U,
+	0x900B3U, 0x900B4U, 0x900B5U, 0x900B6U, 0x900B7U, 0x900B8U, 0x900B9U, 0x900BAU, 0x900BBU,
+	0x900BCU, 0x900BDU, 0x900BEU, 0x900BFU, 0x900C0U, 0x900C1U, 0x900C2U, 0x900C3U, 0x900C4U,
+	0x90006U, 0x90007U, 0x90008U, 0x90009U, 0x9000AU, 0x9000BU, 0xD00E7U, 0x90017U, 0x90026U,
+};
+
+static const uint16_t prodcode_data[PRODCODE_SIZE] = {
+	0x0010U, 0x0400U, 0x010EU, 0x0000U, 0x0000U, 0x0008U, 0x000BU, 0x0480U, 0x0109U, 0x0008U,
+	0x0448U, 0x0139U, 0x0008U, 0x0478U, 0x0109U, 0x0002U, 0x0010U, 0x0139U, 0x000BU, 0x07C0U,
+	0x0139U, 0x0044U, 0x0633U, 0x0159U, 0x014FU, 0x0630U, 0x0159U, 0x0047U, 0x0633U, 0x0149U,
+	0x004FU, 0x0633U, 0x0179U, 0x0008U, 0x00E0U, 0x0109U, 0x0000U, 0x07C8U, 0x0109U, 0x0000U,
+	0x0001U, 0x0008U, 0x0000U, 0x045AU, 0x0009U, 0x0000U, 0x0448U, 0x0109U, 0x0040U, 0x0633U,
+	0x0179U, 0x0001U, 0x0618U, 0x0109U, 0x40C0U, 0x0633U, 0x0149U, 0x0008U, 0x0004U, 0x0048U,
+	0x4040U, 0x0633U, 0x0149U, 0x0000U, 0x0004U, 0x0048U, 0x0040U, 0x0633U, 0x0149U, 0x0010U,
+	0x0004U, 0x0018U, 0x0000U, 0x0004U, 0x0078U, 0x0549U, 0x0633U, 0x0159U, 0x0D49U, 0x0633U,
+	0x0159U, 0x094AU, 0x0633U, 0x0159U, 0x0441U, 0x0633U, 0x0149U, 0x0042U, 0x0633U, 0x0149U,
+	0x0001U, 0x0633U, 0x0149U, 0x0000U, 0x00E0U, 0x0109U, 0x000AU, 0x0010U, 0x0109U, 0x0009U,
+	0x03C0U, 0x0149U, 0x0009U, 0x03C0U, 0x0159U, 0x0018U, 0x0010U, 0x0109U, 0x0000U, 0x03C0U,
+	0x0109U, 0x0018U, 0x0004U, 0x0048U, 0x0018U, 0x0004U, 0x0058U, 0x000BU, 0x0010U, 0x0109U,
+	0x0001U, 0x0010U, 0x0109U, 0x0005U, 0x07C0U, 0x0109U, 0x0000U, 0x8140U, 0x010CU, 0x0010U,
+	0x8138U, 0x0104U, 0x0008U, 0x0448U, 0x0109U, 0x000FU, 0x07C0U, 0x0109U, 0x0047U, 0x0630U,
+	0x0109U, 0x0008U, 0x0618U, 0x0109U, 0x0008U, 0x00E0U, 0x0109U, 0x0000U, 0x07C8U, 0x0109U,
+	0x0008U, 0x8140U, 0x010CU, 0x0000U, 0x0478U, 0x0109U, 0x0000U, 0x0001U, 0x0008U, 0x0008U,
+	0x0004U, 0x0000U, 0x0008U, 0x07C8U, 0x0109U, 0x0000U, 0x0400U, 0x0106U, 0x0400U, 0x0000U,
+	0x002AU,
+	};
+
+#elif STM32MP_LPDDR4_TYPE
+#define PRODCODE_SIZE		478
+
+static const uint32_t prodcode_addr[PRODCODE_SIZE] = {
+	0x90000U, 0x90001U, 0x90002U, 0x90003U, 0x90004U, 0x90005U, 0x90029U, 0x9002AU, 0x9002BU,
+	0x9002CU, 0x9002DU, 0x9002EU, 0x9002FU, 0x90030U, 0x90031U, 0x90032U, 0x90033U, 0x90034U,
+	0x90035U, 0x90036U, 0x90037U, 0x90038U, 0x90039U, 0x9003AU, 0x9003BU, 0x9003CU, 0x9003DU,
+	0x9003EU, 0x9003FU, 0x90040U, 0x90041U, 0x90042U, 0x90043U, 0x90044U, 0x90045U, 0x90046U,
+	0x90047U, 0x90048U, 0x90049U, 0x9004AU, 0x9004BU, 0x9004CU, 0x9004DU, 0x9004EU, 0x9004FU,
+	0x90050U, 0x90051U, 0x90052U, 0x90053U, 0x90054U, 0x90055U, 0x90056U, 0x90057U, 0x90058U,
+	0x90059U, 0x9005AU, 0x9005BU, 0x9005CU, 0x9005DU, 0x9005EU, 0x9005FU, 0x90060U, 0x90061U,
+	0x90062U, 0x90063U, 0x90064U, 0x90065U, 0x90066U, 0x90067U, 0x90068U, 0x90069U, 0x9006AU,
+	0x9006BU, 0x9006CU, 0x9006DU, 0x9006EU, 0x9006FU, 0x90070U, 0x90071U, 0x90072U, 0x90073U,
+	0x90074U, 0x90075U, 0x90076U, 0x90077U, 0x90078U, 0x90079U, 0x9007AU, 0x9007BU, 0x9007CU,
+	0x9007DU, 0x9007EU, 0x9007FU, 0x90080U, 0x90081U, 0x90082U, 0x90083U, 0x90084U, 0x90085U,
+	0x90086U, 0x90087U, 0x90088U, 0x90089U, 0x9008AU, 0x9008BU, 0x9008CU, 0x9008DU, 0x9008EU,
+	0x9008FU, 0x90090U, 0x90091U, 0x90092U, 0x90093U, 0x90094U, 0x90095U, 0x90096U, 0x90097U,
+	0x90098U, 0x90099U, 0x9009AU, 0x9009BU, 0x9009CU, 0x9009DU, 0x9009EU, 0x9009FU, 0x900A0U,
+	0x900A1U, 0x900A2U, 0x900A3U, 0x40000U, 0x40020U, 0x40040U, 0x40060U, 0x40001U, 0x40021U,
+	0x40041U, 0x40061U, 0x40002U, 0x40022U, 0x40042U, 0x40062U, 0x40003U, 0x40023U, 0x40043U,
+	0x40063U, 0x40004U, 0x40024U, 0x40044U, 0x40064U, 0x40005U, 0x40025U, 0x40045U, 0x40065U,
+	0x40006U, 0x40026U, 0x40046U, 0x40066U, 0x40007U, 0x40027U, 0x40047U, 0x40067U, 0x40008U,
+	0x40028U, 0x40048U, 0x40068U, 0x40009U, 0x40029U, 0x40049U, 0x40069U, 0x4000AU, 0x4002AU,
+	0x4004AU, 0x4006AU, 0x4000BU, 0x4002BU, 0x4004BU, 0x4006BU, 0x4000CU, 0x4002CU, 0x4004CU,
+	0x4006CU, 0x4000DU, 0x4002DU, 0x4004DU, 0x4006DU, 0x4000EU, 0x4002EU, 0x4004EU, 0x4006EU,
+	0x4000FU, 0x4002FU, 0x4004FU, 0x4006FU, 0x40010U, 0x40030U, 0x40050U, 0x40070U, 0x40011U,
+	0x40031U, 0x40051U, 0x40071U, 0x40012U, 0x40032U, 0x40052U, 0x40072U, 0x40013U, 0x40033U,
+	0x40053U, 0x40073U, 0x40014U, 0x40034U, 0x40054U, 0x40074U, 0x40015U, 0x40035U, 0x40055U,
+	0x40075U, 0x40016U, 0x40036U, 0x40056U, 0x40076U, 0x40017U, 0x40037U, 0x40057U, 0x40077U,
+	0x40018U, 0x40038U, 0x40058U, 0x40078U, 0x40019U, 0x40039U, 0x40059U, 0x40079U, 0x4001AU,
+	0x4003AU, 0x4005AU, 0x4007AU, 0x900A4U, 0x900A5U, 0x900A6U, 0x900A7U, 0x900A8U, 0x900A9U,
+	0x900AAU, 0x900ABU, 0x900ACU, 0x900ADU, 0x900AEU, 0x900AFU, 0x900B0U, 0x900B1U, 0x900B2U,
+	0x900B3U, 0x900B4U, 0x900B5U, 0x900B6U, 0x900B7U, 0x900B8U, 0x900B9U, 0x900BAU, 0x900BBU,
+	0x900BCU, 0x900BDU, 0x900BEU, 0x900BFU, 0x900C0U, 0x900C1U, 0x900C2U, 0x900C3U, 0x900C4U,
+	0x900C5U, 0x900C6U, 0x900C7U, 0x900C8U, 0x900C9U, 0x900CAU, 0x900CBU, 0x900CCU, 0x900CDU,
+	0x900CEU, 0x900CFU, 0x900D0U, 0x900D1U, 0x900D2U, 0x900D3U, 0x900D4U, 0x900D5U, 0x900D6U,
+	0x900D7U, 0x900D8U, 0x900D9U, 0x900DAU, 0x900DBU, 0x900DCU, 0x900DDU, 0x900DEU, 0x900DFU,
+	0x900E0U, 0x900E1U, 0x900E2U, 0x900E3U, 0x900E4U, 0x900E5U, 0x900E6U, 0x900E7U, 0x900E8U,
+	0x900E9U, 0x900EAU, 0x900EBU, 0x900ECU, 0x900EDU, 0x900EEU, 0x900EFU, 0x900F0U, 0x900F1U,
+	0x900F2U, 0x900F3U, 0x900F4U, 0x900F5U, 0x900F6U, 0x900F7U, 0x900F8U, 0x900F9U, 0x900FAU,
+	0x900FBU, 0x900FCU, 0x900FDU, 0x900FEU, 0x900FFU, 0x90100U, 0x90101U, 0x90102U, 0x90103U,
+	0x90104U, 0x90105U, 0x90106U, 0x90107U, 0x90108U, 0x90109U, 0x9010AU, 0x9010BU, 0x9010CU,
+	0x9010DU, 0x9010EU, 0x9010FU, 0x90110U, 0x90111U, 0x90112U, 0x90113U, 0x90114U,	0x90115U,
+	0x90116U, 0x90117U, 0x90118U, 0x90119U, 0x9011AU, 0x9011BU, 0x9011CU, 0x9011DU, 0x9011EU,
+	0x9011FU, 0x90120U, 0x90121U, 0x90122U, 0x90123U, 0x90124U, 0x90125U, 0x90126U, 0x90127U,
+	0x90128U, 0x90129U, 0x9012AU, 0x9012BU, 0x9012CU, 0x9012DU, 0x9012EU, 0x9012FU, 0x90130U,
+	0x90131U, 0x90132U, 0x90133U, 0x90134U, 0x90135U, 0x90136U, 0x90137U, 0x90138U, 0x90139U,
+	0x9013AU, 0x9013BU, 0x9013CU, 0x9013DU, 0x9013EU, 0x9013FU, 0x90140U, 0x90141U, 0x90142U,
+	0x90143U, 0x90144U, 0x90145U, 0x90146U, 0x90147U, 0x90148U, 0x90149U, 0x9014AU, 0x9014BU,
+	0x9014CU, 0x9014DU, 0x9014EU, 0x9014FU, 0x90150U, 0x90151U, 0x90152U, 0x90153U, 0x90154U,
+	0x90155U, 0x90156U, 0x90157U, 0x90158U, 0x90159U, 0x9015AU, 0x9015BU, 0x9015CU, 0x9015DU,
+	0x9015EU, 0x9015FU, 0x90160U, 0x90161U, 0x90162U, 0x90163U, 0x90164U, 0x90165U, 0x90166U,
+	0x90167U, 0x90168U, 0x90169U, 0x9016AU, 0x9016BU, 0x9016CU, 0x9016DU, 0x9016EU, 0x9016FU,
+	0x90170U, 0x90171U, 0x90172U, 0x90173U, 0x90174U, 0x90175U, 0x90176U, 0x90177U, 0x90178U,
+	0x90179U, 0x9017AU, 0x9017BU, 0x9017CU, 0x9017DU, 0x9017EU, 0x9017FU, 0x90180U, 0x90181U,
+	0x90006U, 0x90007U, 0x90008U, 0x90009U, 0x9000AU, 0x9000BU, 0xD00E7U, 0x90017U, 0x9001FU,
+	0x90026U, 0x400D0U, 0x400D1U, 0x400D2U, 0x400D3U, 0x400D4U, 0x400D5U, 0x400D6U, 0x400D7U,
+	0x2003AU,
+	};
+
+static const uint16_t prodcode_data[PRODCODE_SIZE] = {
+	0x0010U, 0x0400U, 0x010EU, 0x0000U, 0x0000U, 0x0008U, 0x000BU, 0x0480U, 0x0109U, 0x0008U,
+	0x0448U, 0x0139U, 0x0008U, 0x0478U, 0x0109U, 0x0000U, 0x00E8U, 0x0109U, 0x0002U, 0x0010U,
+	0x0139U, 0x000BU, 0x07C0U, 0x0139U, 0x0044U, 0x0633U, 0x0159U, 0x014FU, 0x0630U, 0x0159U,
+	0x0047U, 0x0633U, 0x0149U, 0x004FU, 0x0633U, 0x0179U, 0x0008U, 0x00E0U, 0x0109U, 0x0000U,
+	0x07C8U, 0x0109U, 0x0000U, 0x0001U, 0x0008U, 0x0000U, 0x045AU, 0x0009U, 0x0000U, 0x0448U,
+	0x0109U, 0x0040U, 0x0633U, 0x0179U, 0x0001U, 0x0618U, 0x0109U, 0x40C0U, 0x0633U, 0x0149U,
+	0x0008U, 0x0004U, 0x0048U, 0x4040U, 0x0633U, 0x0149U, 0x0000U, 0x0004U, 0x0048U, 0x0040U,
+	0x0633U, 0x0149U, 0x0010U, 0x0004U, 0x0018U, 0x0000U, 0x0004U, 0x0078U, 0x0549U, 0x0633U,
+	0x0159U, 0x0D49U, 0x0633U, 0x0159U, 0x094AU, 0x0633U, 0x0159U, 0x0441U, 0x0633U, 0x0149U,
+	0x0042U, 0x0633U, 0x0149U, 0x0001U, 0x0633U, 0x0149U, 0x0000U, 0x00E0U, 0x0109U, 0x000AU,
+	0x0010U, 0x0109U, 0x0009U, 0x03C0U, 0x0149U, 0x0009U, 0x03C0U, 0x0159U, 0x0018U, 0x0010U,
+	0x0109U, 0x0000U, 0x03C0U, 0x0109U, 0x0018U, 0x0004U, 0x0048U, 0x0018U, 0x0004U, 0x0058U,
+	0x000BU, 0x0010U, 0x0109U, 0x0001U, 0x0010U, 0x0109U, 0x0005U, 0x07C0U, 0x0109U, 0x0811U,
+	0x0880U, 0x0000U, 0x0000U, 0x4008U, 0x0083U, 0x004FU, 0x0000U, 0x4040U, 0x0083U, 0x0051U,
+	0x0000U, 0x0811U, 0x0880U, 0x0000U, 0x0000U, 0x0720U, 0x000FU, 0x1740U, 0x0000U, 0x0016U,
+	0x0083U, 0x004BU, 0x0000U, 0x0716U, 0x000FU, 0x2001U, 0x0000U, 0x0716U, 0x000FU, 0x2800U,
+	0x0000U, 0x0716U, 0x000FU, 0x0F00U, 0x0000U, 0x0720U, 0x000FU, 0x1400U, 0x0000U, 0x0E08U,
+	0x0C15U, 0x0000U, 0x0000U, 0x0625U, 0x0015U, 0x0000U, 0x0000U, 0x4028U, 0x0080U, 0x0000U,
+	0x0000U, 0x0E08U, 0x0C1AU, 0x0000U, 0x0000U, 0x0625U, 0x001AU, 0x0000U, 0x0000U, 0x4040U,
+	0x0080U, 0x0000U, 0x0000U, 0x2604U, 0x0015U, 0x0000U, 0x0000U, 0x0708U, 0x0005U, 0x0000U,
+	0x2002U, 0x0008U, 0x0080U, 0x0000U, 0x0000U, 0x2604U, 0x001AU, 0x0000U, 0x0000U, 0x0708U,
+	0x000AU, 0x0000U, 0x2002U, 0x4040U, 0x0080U, 0x0000U, 0x0000U, 0x060AU, 0x0015U, 0x1200U,
+	0x0000U, 0x061AU, 0x0015U, 0x1300U, 0x0000U, 0x060AU, 0x001AU, 0x1200U, 0x0000U, 0x0642U,
+	0x001AU, 0x1300U, 0x0000U, 0x4808U, 0x0880U, 0x0000U, 0x0000U, 0x0000U, 0x0790U, 0x011AU,
+	0x0008U, 0x07AAU, 0x002AU, 0x0010U, 0x07B2U, 0x002AU, 0x0000U, 0x07C8U, 0x0109U, 0x0010U,
+	0x0010U, 0x0109U, 0x0010U, 0x02A8U, 0x0129U, 0x0008U, 0x0370U, 0x0129U, 0x000AU, 0x03C8U,
+	0x01A9U, 0x000CU, 0x0408U, 0x0199U, 0x0014U, 0x0790U, 0x011AU, 0x0008U, 0x0004U, 0x0018U,
+	0x000EU, 0x0408U, 0x0199U, 0x0008U, 0x8568U, 0x0108U, 0x0018U, 0x0790U, 0x016AU, 0x0008U,
+	0x01D8U, 0x0169U, 0x0010U, 0x8558U, 0x0168U, 0x0070U, 0x0788U, 0x016AU, 0x1FF8U, 0x85A8U,
+	0x01E8U, 0x0050U, 0x0798U, 0x016AU, 0x0060U, 0x07A0U, 0x016AU, 0x0008U, 0x8310U, 0x0168U,
+	0x0008U, 0xA310U, 0x0168U, 0x000AU, 0x0408U, 0x0169U, 0x006EU, 0x0000U, 0x0068U, 0x0000U,
+	0x0408U, 0x0169U, 0x0000U, 0x8310U, 0x0168U, 0x0000U, 0xA310U, 0x0168U, 0x1FF8U, 0x85A8U,
+	0x01E8U, 0x0068U, 0x0798U, 0x016AU, 0x0078U, 0x07A0U, 0x016AU, 0x0068U, 0x0790U, 0x016AU,
+	0x0008U, 0x8B10U, 0x0168U, 0x0008U, 0xAB10U, 0x0168U, 0x000AU, 0x0408U, 0x0169U, 0x0058U,
+	0x0000U, 0x0068U, 0x0000U, 0x0408U, 0x0169U, 0x0000U, 0x8B10U, 0x0168U, 0x0001U, 0xAB10U,
+	0x0168U, 0x0000U, 0x01D8U, 0x0169U, 0x0080U, 0x0790U, 0x016AU, 0x0018U, 0x07AAU, 0x006AU,
+	0x000AU, 0x0000U, 0x01E9U, 0x0008U, 0x8080U, 0x0108U, 0x000FU, 0x0408U, 0x0169U, 0x000CU,
+	0x0000U, 0x0068U, 0x0009U, 0x0000U, 0x01A9U, 0x0000U, 0x0408U, 0x0169U, 0x0000U, 0x8080U,
+	0x0108U, 0x0008U, 0x07AAU, 0x006AU, 0x0000U, 0x8568U, 0x0108U, 0x00B7U, 0x0790U, 0x016AU,
+	0x001FU, 0x0000U, 0x0068U, 0x0008U, 0x8558U, 0x0168U, 0x000FU, 0x0408U, 0x0169U, 0x000DU,
+	0x0000U, 0x0068U, 0x0000U, 0x0408U, 0x0169U, 0x0000U, 0x8558U, 0x0168U, 0x0008U, 0x03C8U,
+	0x01A9U, 0x0003U, 0x0370U, 0x0129U, 0x0020U, 0x02AAU, 0x0009U, 0x0008U, 0x00E8U, 0x0109U,
+	0x0000U, 0x8140U, 0x010CU, 0x0010U, 0x8138U, 0x0104U, 0x0008U, 0x0448U, 0x0109U, 0x000FU,
+	0x07C0U, 0x0109U, 0x0000U, 0x00E8U, 0x0109U, 0x0047U, 0x0630U, 0x0109U, 0x0008U, 0x0618U,
+	0x0109U, 0x0008U, 0x00E0U, 0x0109U, 0x0000U, 0x07C8U, 0x0109U, 0x0008U, 0x8140U, 0x010CU,
+	0x0000U, 0x0478U, 0x0109U, 0x0000U, 0x0001U, 0x0008U, 0x0008U, 0x0004U, 0x0000U, 0x0008U,
+	0x07C8U, 0x0109U, 0x0000U, 0x0400U, 0x0106U, 0x0400U, 0x0000U, 0x0029U, 0x0068U, 0x0000U,
+	0x0101U, 0x0105U, 0x0107U, 0x010FU, 0x0202U, 0x020aU, 0x020BU, 0x0002U,
+	};
+#endif /* STM32MP_LPDDR4_TYPE */
+
+/*
+ * Loads PIE instruction sequence PHY registers
+ * @returns void
+ */
+void ddrphy_phyinit_loadpieprodcode(void)
+{
+	int i;
+
+	for (i = 0; i < PRODCODE_SIZE; i++) {
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * prodcode_addr[i]), prodcode_data[i]);
+	}
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_main.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_main.c
new file mode 100644
index 000000000..13373f262
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_main.c
@@ -0,0 +1,227 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <stdio.h>
+#include <math.h>
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit.h>
+
+extern FILE *outfileptr; /* defined in the ddrphy_phyinit_globals.c */
+extern char *cmntstr; /* defined in the ddrphy_phyinit_globals.c */
+extern char *apbstr; /* defined in the ddrphy_phyinit_globals.c */
+
+/*
+ * Main function of PhyInit standalone executable.
+ *
+ * Only used for the purpose of generating output.txt file. Parses input
+ * arguments and makes a call to ddrphy_phyinit_sequence(for single PHY instance)
+ *
+ *  ### Required Arguments
+ *
+ *  - train2d <0|1>
+ *    - if set to 0 only 1D training is executed in the sequence.
+ *    - if set to 1 both 1D and 2D training is executed
+ *    - ignored if skip_train !=0
+ *
+ *  - output filename
+ *    - filename of the output txt file.
+ *
+ *  - skip_train <0|1|2>
+ *    - if set to 0 firmware training is executed.
+ *    - if set to 1 training is skipped and registers are programed to work with
+ *      zero board delay.
+ *    - if set to 2 training is used to skip training but execute the firmware to
+ *      initialize the DRAM state while registers are programed to work with zero
+ *      board delay.
+ *
+ *  #### Optional Arguments
+ *
+ *  - debug \<level\>
+ *    - useful for generating additional print statements for debug purpose.
+ *      Currently only level must be 0. default=0.
+ *
+ *  - comment_string
+ *    - a custom comment string to place on non-system verilog compatible lines in
+ *      the output txt files. default is an empty string.
+ *
+ *  - apb_string
+ *    - a custom comment string to place on register write commands in
+ *      the output txt files. default is an empty string.
+ *
+ *  - retention_exit
+ *    - if set to 1 creates additional output_retention_exit.txt file with sequence for IO
+ *      retention exit.
+ *
+ * Example: generating output txt file for 1D/2D training.
+ * \code{.sh}
+ * phyinit -train2d 1 -skip_train 0
+ * \endcode
+ *
+ * @param argc number of input arguments.
+ * @param argv char array of input arguments.
+ */
+int main(int argc, char *argv[])
+{
+	int skip_train = -1;
+	int train2d = -1;
+	int debug = 0;
+	int retexit = 0;
+	int i;
+	char *outfilename = NULL;
+
+	char *usage = "\
+\n \
+    phyinit execuable \n \
+\n \
+    This executable will generate a txt file output with register write instructions\n \
+    to initialize the DDRPHY phy. \n \
+    phyinit <required arguments> [options] \n \
+\n \
+    <required arguments> \n \
+    -train2d <0|1> \n \
+        if set to 0 only 1D training is executed in the sequenct. \n \
+        if set to 1 both 1D and 2D training is executed \n \
+        ignored if skip_train !=0 \n \
+\n \
+    -output filename \n \
+        filename of the output txt file.\n \
+\n \
+    -skip_train <0|1|2> \n \
+        if set to 0 firmware training is executed.\n \
+        if set to 1 training is skipped and registers are programed to work with\n \
+        zero board delay. \n \
+        if set to 2 training is used to skip training but execute the firmware to\n \
+        initialize the DRAM state while registers are programed to work with zero\n \
+        board delay. \n \
+\n \
+    [optional arguments] \n \
+    -debug <level> \n \
+        useful for generating additional print statements for debug purpose.\n \
+        Currently only level must be 0.\n \
+\n \
+    -comment_string \n \
+        a custom comment string to place on non-system verilog compatible lines in\n \
+        the output txt files. default is an empty string.\n \
+\n \
+    -apb_string \n \
+        a custom comment string to place on register write commands in\n \
+        the output txt files. default is an empty string.\n \
+\n \
+    - retention_exit <0|1> \n \
+        if set to 1 creates additional output_retention_exit.txt file with sequence for IO retention exit.  \n \
+\n \
+   Example:\n \
+   phyinit -train2d 1 -skip_train 0 -debug 1\n \
+";
+
+	for (i = 1; i < argc; i = i + 2) {
+		if (strcmp("-skip_train", argv[i]) == 0) {
+			skip_train = atoi(argv[i + 1]);
+		} else if (strcmp("-train2d", argv[i]) == 0) {
+			train2d = atoi(argv[i + 1]);
+		} else if (strcmp("-debug", argv[i]) == 0) {
+			debug = atoi(argv[i + 1]);
+		} else if (strcmp("-comment_string", argv[i]) == 0) {
+			cmntstr = argv[i + 1];
+		} else if (strcmp("-apb_string", argv[i]) == 0) {
+			apbstr = argv[i + 1];
+		} else if (strcmp("-retention_exit", argv[i]) == 0) {
+			retexit = atoi(argv[i + 1]);
+		} else if (strcmp("-output", argv[i]) == 0) {
+			outfilename = argv[i + 1];
+		} else {
+			ERROR("Unsupported argument %s is supplied.\n", argv[i]);
+		}
+	}
+
+	if (train2d != 0 && train2d != 1) {
+		ERROR("train2d(%d) no set or invalid input. See usage.\n%s\n", train2d, usage);
+	}
+
+	if (skip_train != 0 && skip_train != 1 && skip_train != 2) {
+		ERROR("skip_train(%d) no set or invalid input. See usage.\n%s\n",
+		      skip_train, usage);
+	}
+
+	if (outfilename == NULL) {
+		ERROR("output file not specified. See usage.\n%s\n", usage);
+	}
+
+	if (cmntstr == NULL) {
+		VERROR("Comments String is NULL. See usage.\n%s\n", usage);
+	}
+
+	if (apbstr == NULL) {
+		ERROR("abp_strings is NULL. See usage.\n%s\n", usage);
+	}
+
+	INFO("Running with values of skip_train = %0d, train2d = %0d, debug = %0d output=%s\n",
+	     skip_train, train2d, debug, outfilename);
+
+	/* Registering function inputs */
+	runtimeconfig.skip_train = skip_train;
+	runtimeconfig.debug = debug;
+	runtimeconfig.reten = retexit;
+
+	/* Function calls to generate output files when only one PHY instance is present */
+	if (DDRPHY_NUM_PHY == 1) {
+		/* Open Txt output Stream */
+		if ((outfileptr = fopen(outfilename, "w")) == NULL) {
+			ERROR("Error:  Can't open file for writing %s/\n\n", outfilename);
+		} else {
+			INFO("writing output file: %s\n\n", outfilename);
+		}
+
+		VERBOSE("Start of ddrphy_phyinit_main()\n");
+
+		/* Execute phyinit sequence */
+		ddrphy_phyinit_sequence(skip_train, train2d, debug);
+
+		VERBOSE("End of ddrphy_phyinit_main()\n");
+
+		fclose(outfileptr);
+
+		if (retexit) {
+			/* Printing retention exit sequence txt files */
+			strcat(outfilename, "_retention_exit");
+
+			/* Open Txt output Stream */
+			if ((outfileptr = fopen(outfilename, "w")) == NULL) {
+				ERROR("Error:  Can't open file for writing %s/\n\n", outfilename);
+			} else {
+				INFO("writing output file: %s\n\n", outfilename);
+			}
+
+			VERBOSE("Start of ddrphy_phyinit_retention_sequence()\n");
+
+			/* Execute PhyInit retention exit sequence */
+			ddrphy_phyinit_restore_sequence();
+
+			VERBOSE("End of ddrphy_phyinit_retention_sequence()\n");
+
+			fclose(outfileptr);
+		}
+	} else if (DDRPHY_NUM_PHY < 5 && DDRPHY_NUM_PHY > 1) {
+		INFO("Start of multi sequence()\n");
+
+		/* Multiple PHY instances. */
+
+		ERROR("This release of PhyInit does not support multiple PHY instances.\n");
+		ERROR("Please contact Support.\n");
+		INFO("End of ddrphy_phyinit_multi_sequence()\n");
+	} else {
+		ERROR("invalid value for DDRPHY_NUM_PHY= %s\n", DDRPHY_NUM_PHY);
+		return EXIT_FAILURE;
+	}
+
+	fflush(stdout);
+	return EXIT_SUCCESS;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_mapdrvstren.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_mapdrvstren.c
new file mode 100644
index 000000000..4f0074bb5
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_mapdrvstren.c
@@ -0,0 +1,292 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit.h>
+
+/*
+ * Maps impedance values to register settings
+ *
+ * Reads the pull-up/pull-down driver impedance from drvstren_ohm input
+ * and encodes that value for the CSR field specified in targetcsr input,
+ * based on DDR protocol.
+ *
+ * @param[in] drvstren_ohm drive strenght / ODT impedance in Ohms
+ *
+ * @param[in] targetcsr Target CSR for the impedance value. on of following
+ * enum drvtype:
+ *   - drvstrenfsdqp
+ *   - drvstrenfsdqn
+ *   - odtstrenp
+ *   - odtstrenn
+ *   - adrvstrenp
+ *   - adrvstrenn
+ *
+ * \return >=0 value on success, else negative.
+ */
+int ddrphy_phyinit_mapdrvstren(int drvstren_ohm, enum drvtype targetcsr)
+{
+	int stren_setting = -1;
+
+	if ((targetcsr == drvstrenfsdqp) || (targetcsr == drvstrenfsdqn)) {
+		/* drvstrenfsdqp or drvstrenfsdqn */
+
+		if (drvstren_ohm == 0) {
+			stren_setting = 0x00; /* High-impedance */
+		} else if (drvstren_ohm < 29) {
+			stren_setting = 0x3f;
+		} else if (drvstren_ohm < 31) {
+			stren_setting = 0x3e;
+		} else if (drvstren_ohm < 33) {
+			stren_setting = 0x3b;
+		} else if (drvstren_ohm < 35) {
+			stren_setting = 0x3a;
+		} else if (drvstren_ohm < 38) {
+			stren_setting = 0x39;
+		} else if (drvstren_ohm < 41) {
+			stren_setting = 0x38;
+		} else if (drvstren_ohm < 45) {
+			stren_setting = 0x1b;
+		} else if (drvstren_ohm < 50) {
+			stren_setting = 0x1a;
+		} else if (drvstren_ohm < 56) {
+			stren_setting = 0x19;
+		} else if (drvstren_ohm < 64) {
+			stren_setting = 0x18;
+		} else if (drvstren_ohm < 74) {
+			stren_setting = 0x0b;
+		} else if (drvstren_ohm < 88) {
+			stren_setting = 0x0a;
+		} else if (drvstren_ohm < 108) {
+			stren_setting = 0x09;
+		} else if (drvstren_ohm < 140) {
+			stren_setting = 0x08;
+		} else if (drvstren_ohm < 200) {
+			stren_setting = 0x03;
+		} else if (drvstren_ohm < 360) {
+			stren_setting = 0x02;
+		} else if (drvstren_ohm < 481) {
+			stren_setting = 0x01;
+		} else {
+			stren_setting = 0x00; /* High-impedance */
+		}
+	} else if (targetcsr == odtstrenp) {
+		/* odtstrenp */
+
+#if STM32MP_DDR3_TYPE
+		/*
+		 * DDR3 - P and N has the same impedance and non-zero
+		 * user input is half the individual pull-up and pull-down impedances values
+		 * because of parallel between them
+		 */
+		if (drvstren_ohm == 0) {
+			stren_setting = 0x00; /* High-impedance */
+		} else if (drvstren_ohm < 15) {
+			stren_setting = 0x3f;
+		} else if (drvstren_ohm < 16) {
+			stren_setting = 0x3e;
+		} else if (drvstren_ohm < 17) {
+			stren_setting = 0x3b;
+		} else if (drvstren_ohm < 18) {
+			stren_setting = 0x3a;
+		} else if (drvstren_ohm < 20) {
+			stren_setting = 0x39;
+		} else if (drvstren_ohm < 21) {
+			stren_setting = 0x38;
+		} else if (drvstren_ohm < 23) {
+			stren_setting = 0x1b;
+		} else if (drvstren_ohm < 26) {
+			stren_setting = 0x1a;
+		} else if (drvstren_ohm < 29) {
+			stren_setting = 0x19;
+		} else if (drvstren_ohm < 33) {
+			stren_setting = 0x18;
+		} else if (drvstren_ohm < 38) {
+			stren_setting = 0x0b;
+		} else if (drvstren_ohm < 45) {
+			stren_setting = 0x0a;
+		} else if (drvstren_ohm < 55) {
+			stren_setting = 0x09;
+		} else if (drvstren_ohm < 71) {
+			stren_setting = 0x08;
+		} else if (drvstren_ohm < 101) {
+			stren_setting = 0x03;
+		} else if (drvstren_ohm < 181) {
+			stren_setting = 0x02;
+		} else if (drvstren_ohm < 241) {
+			stren_setting = 0x01;
+		} else {
+			stren_setting = 0x00; /* High-impedance */
+		}
+#elif STM32MP_DDR4_TYPE
+		/* DDR4 - P is non-zero */
+		if (drvstren_ohm == 0) {
+			stren_setting = 0x00; /* High-impedance */
+		} else if (drvstren_ohm < 29) {
+			stren_setting = 0x3f;
+		} else if (drvstren_ohm < 31) {
+			stren_setting = 0x3e;
+		} else if (drvstren_ohm < 33) {
+			stren_setting = 0x3b;
+		} else if (drvstren_ohm < 35) {
+			stren_setting = 0x3a;
+		} else if (drvstren_ohm < 38) {
+			stren_setting = 0x39;
+		} else if (drvstren_ohm < 41) {
+			stren_setting = 0x38;
+		} else if (drvstren_ohm < 45) {
+			stren_setting = 0x1b;
+		} else if (drvstren_ohm < 50) {
+			stren_setting = 0x1a;
+		} else if (drvstren_ohm < 56) {
+			stren_setting = 0x19;
+		} else if (drvstren_ohm < 64) {
+			stren_setting = 0x18;
+		} else if (drvstren_ohm < 74) {
+			stren_setting = 0x0b;
+		} else if (drvstren_ohm < 88) {
+			stren_setting = 0x0a;
+		} else if (drvstren_ohm < 108) {
+			stren_setting = 0x09;
+		} else if (drvstren_ohm < 140) {
+			stren_setting = 0x08;
+		} else if (drvstren_ohm < 200) {
+			stren_setting = 0x03;
+		} else if (drvstren_ohm < 360) {
+			stren_setting = 0x02;
+		} else if (drvstren_ohm < 481) {
+			stren_setting = 0x01;
+		} else {
+			stren_setting = 0x00; /* High-impedance */
+		}
+#elif STM32MP_LPDDR4_TYPE
+		/* LPDDR4 - P is high-Z */
+		stren_setting = 0x00; /* High-impedance */
+#endif /* STM32MP_LPDDR4_TYPE */
+	} else if (targetcsr == odtstrenn) {
+		/* odtstrenn */
+
+#if STM32MP_DDR3_TYPE
+		/*
+		 * DDR3 - P and N has the same impedance and non-zero
+		 * Times 2 of user input because of parallel pull-up and pull-down termination
+		 */
+		if (drvstren_ohm == 0) {
+			stren_setting = 0x00; /* High-impedance */
+		} else if (drvstren_ohm < 15) {
+			stren_setting = 0x3f;
+		} else if (drvstren_ohm < 16) {
+			stren_setting = 0x3e;
+		} else if (drvstren_ohm < 17) {
+			stren_setting = 0x3b;
+		} else if (drvstren_ohm < 18) {
+			stren_setting = 0x3a;
+		} else if (drvstren_ohm < 20) {
+			stren_setting = 0x39;
+		} else if (drvstren_ohm < 21) {
+			stren_setting = 0x38;
+		} else if (drvstren_ohm < 23) {
+			stren_setting = 0x1b;
+		} else if (drvstren_ohm < 26) {
+			stren_setting = 0x1a;
+		} else if (drvstren_ohm < 29) {
+			stren_setting = 0x19;
+		} else if (drvstren_ohm < 33) {
+			stren_setting = 0x18;
+		} else if (drvstren_ohm < 38) {
+			stren_setting = 0x0b;
+		} else if (drvstren_ohm < 45) {
+			stren_setting = 0x0a;
+		} else if (drvstren_ohm < 55) {
+			stren_setting = 0x09;
+		} else if (drvstren_ohm < 71) {
+			stren_setting = 0x08;
+		} else if (drvstren_ohm < 101) {
+			stren_setting = 0x03;
+		} else if (drvstren_ohm < 181) {
+			stren_setting = 0x02;
+		} else if (drvstren_ohm < 241) {
+			stren_setting = 0x01;
+		} else {
+			stren_setting = 0x00; /* High-impedance */
+		}
+#elif STM32MP_DDR4_TYPE
+		/* DDR4 - N is high-Z */
+		stren_setting = 0x00; /* High-impedance */
+#elif STM32MP_LPDDR4_TYPE
+		/* LPDDR4 - N is non-zero */
+		if (drvstren_ohm == 0) {
+			stren_setting = 0x00; /* High-impedance */
+		} else if (drvstren_ohm < 29) {
+			stren_setting = 0x3f;
+		} else if (drvstren_ohm < 31) {
+			stren_setting = 0x3e;
+		} else if (drvstren_ohm < 33) {
+			stren_setting = 0x3b;
+		} else if (drvstren_ohm < 35) {
+			stren_setting = 0x3a;
+		} else if (drvstren_ohm < 38) {
+			stren_setting = 0x39;
+		} else if (drvstren_ohm < 41) {
+			stren_setting = 0x38;
+		} else if (drvstren_ohm < 45) {
+			stren_setting = 0x1b;
+		} else if (drvstren_ohm < 50) {
+			stren_setting = 0x1a;
+		} else if (drvstren_ohm < 56) {
+			stren_setting = 0x19;
+		} else if (drvstren_ohm < 64) {
+			stren_setting = 0x18;
+		} else if (drvstren_ohm < 74) {
+			stren_setting = 0x0b;
+		} else if (drvstren_ohm < 88) {
+			stren_setting = 0x0a;
+		} else if (drvstren_ohm < 108) {
+			stren_setting = 0x09;
+		} else if (drvstren_ohm < 140) {
+			stren_setting = 0x08;
+		} else if (drvstren_ohm < 200) {
+			stren_setting = 0x03;
+		} else if (drvstren_ohm < 360) {
+			stren_setting = 0x02;
+		} else if (drvstren_ohm < 481) {
+			stren_setting = 0x01;
+		} else {
+			stren_setting = 0x00; /* High-impedance */
+		}
+#endif /* STM32MP_LPDDR4_TYPE */
+	} else if ((targetcsr == adrvstrenp) || (targetcsr == adrvstrenn)) {
+		/* adrvstrenp or adrvstrenn */
+
+		if (drvstren_ohm == 120) {
+			stren_setting = 0x00;
+		} else if (drvstren_ohm == 60) {
+			stren_setting = 0x01;
+		} else if (drvstren_ohm == 40) {
+			stren_setting = 0x03;
+		} else if (drvstren_ohm == 30) {
+			stren_setting = 0x07;
+		} else if (drvstren_ohm == 24) {
+			stren_setting = 0x0F;
+		} else if (drvstren_ohm == 20) {
+			stren_setting = 0x1F;
+		} else {
+			ERROR("%s userinputadvanced.atximpedance %d Ohms value is not valid.\n",
+			      __func__, drvstren_ohm);
+			ERROR("Valid values are: 20, 24, 30, 40, 60 and 120 Ohms.\n");
+		}
+
+	} else {
+		ERROR("targetcsr = %u, in %s, is not valid.\n",
+		      targetcsr, __func__);
+	}
+
+	return stren_setting;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_progcsrskiptrain.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_progcsrskiptrain.c
new file mode 100644
index 000000000..af01fe1df
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_progcsrskiptrain.c
@@ -0,0 +1,1016 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch_helpers.h>
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+#include <ddrphy_wrapper.h>
+
+#include <platform_def.h>
+
+struct phyinit_timings {
+	int tstaoff[NB_PS];
+	int tpdm[NB_PS];
+	int tcasl_add[NB_PS];
+};
+
+static struct phyinit_timings timings;
+
+/*
+ * set tstaoff, tpdm and tcasl_add
+ */
+static void set_timings(void)
+{
+	int pstate;
+
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		timings.tstaoff[pstate] = 0;
+		timings.tpdm[pstate] = 0;
+
+		timings.tcasl_add[pstate] = 0;
+	}
+}
+
+/*
+ * Program dfimrl per P-state according to this formula:
+ *
+ *         dfimrl = ceiling( (ARdPtrinitval*UI + phy_tx_insertion_dly +
+ *                            phy_rx_insertion_dly + PHY_Rx_Fifo_dly + tDQSCK + tstaoff) /
+ *                           dficlk_period)
+ *
+ * All terms in above equation specified in ps
+ * tDQSCK - determine from memory model
+ * tstaoff - determine from memory model
+ * phy_tx_insertion_dly = 200ps
+ * phy_rx_insertion_dly = 200ps
+ * phy_rx_fifo_dly      = 200ps + 4UI
+ */
+static void dfimrl_program(void)
+{
+	int pstate;
+
+	/* ### Set dfimrl per p-state ### // */
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int byte;
+		int dfimrl_in_dficlk;
+		int p_addr;
+		int phy_rx_fifo_dly;
+		int phy_rx_insertion_dly = 200;
+		int phy_tx_insertion_dly = 200;
+		long long dficlk_period_x1000;
+		long long dfimrl_in_fs;
+		long long uifs;
+		uint16_t dfimrl;
+
+		p_addr = pstate << 20;
+
+		uifs = (1000 * 1000000 * 1) / (userinputbasic.frequency[pstate] * 2);
+		dficlk_period_x1000 = 4 * uifs;
+
+		phy_rx_fifo_dly = (int)(((200 * 1000) + 4 * uifs) / 1000);
+
+		dfimrl_in_fs = (ardptrinitval[pstate] * uifs) +
+			       ((phy_tx_insertion_dly + phy_rx_insertion_dly + phy_rx_fifo_dly +
+				 timings.tstaoff[pstate] + timings.tcasl_add[pstate] +
+				 timings.tpdm[pstate]) * 1000);
+
+		dfimrl_in_dficlk = (int)dfimrl_in_fs / dficlk_period_x1000;
+		if ((dfimrl_in_fs % dficlk_period_x1000) != 0) {
+			dfimrl_in_dficlk++;
+		}
+		dfimrl = (uint16_t)(dfimrl_in_dficlk + mb_ddr_1d[pstate].dfimrlmargin);
+
+		/*
+		 * mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TDBYTE | CBRD |
+		 *                                              CSR_DFIMRL_ADDR)),
+		 *              dfimrl);
+		 */
+		for (byte = 0; byte < userinputbasic.numdbyte; byte++) {
+			int c_addr;
+
+			c_addr = byte << 12;
+			mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TDBYTE | c_addr |
+								      CSR_DFIMRL_ADDR)),
+				      dfimrl);
+		}
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TMASTER | CSR_HWTMRL_ADDR)),
+			      dfimrl);
+	}
+}
+
+/*
+ * Program txdqsdlytg0/1[9:0] per P-State:
+ *
+ *         txdqsdlytg*[9:6] = floor( (4*UI + tstaoff) / UI)
+ *         txdqsdlytg*[5:0] = ceiling( (tstaoff%UI / UI) * 32)
+ *
+ * tstaoff and UI expressed in ps
+ *
+ * For HMD and LPDDR4X and MEMCLK <= 533 mhz:
+ *    txdqsdlytg*[9:6] = 0x5
+ *
+ * For other dimm types, leave TDqsDlyTg*[9:0] at default 0x100
+ *
+ * ppp_0001_cccc_uuuu_1101_0000
+ *
+ * if DDR3 or DDR4
+ *      num_timingroup = numrank_dfi0;
+ * else
+ *      num_timingroup = numrank_dfi0 + numrank_dfi1 * dfi1exists;
+ */
+static void txdqsdlytg_program(uint16_t *txdqsdly)
+{
+	int pstate;
+
+	/* ### Set per p-state ### // */
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int byte;
+		int p_addr;
+		int txdqsdlytg_5to0; /* Fine delay - 1/32UI per increment */
+		int txdqsdlytg_9to6; /* Coarse delay - 1UI per increment */
+		int txdqsdlytg_fine_default = 0;
+		int txdqsdlytg_coarse_default = 4;
+		long long tmp_value;
+		long long uifs;
+
+		p_addr = pstate << 20;
+
+		uifs = (1000 * 1000000 * 1) / (userinputbasic.frequency[pstate] * 2);
+
+		txdqsdlytg_9to6 = (int)(((int)((txdqsdlytg_coarse_default * uifs) / 1000) +
+					 timings.tstaoff[pstate] + timings.tcasl_add[pstate]
+					 - timings.tpdm[pstate]) / (int)(uifs / 1000));
+
+		tmp_value = fmodll((txdqsdlytg_fine_default * uifs / 32 +
+				    ((timings.tstaoff[pstate] +	timings.tcasl_add[pstate]) * 1000) -
+				    (timings.tpdm[pstate] * 1000)), uifs);
+		txdqsdlytg_5to0 = (int)(tmp_value / uifs * 32);
+		if ((tmp_value % uifs) != 0) {
+			txdqsdlytg_5to0++;
+		}
+
+		/* Bit-5 of LCDL is no longer used, so bumping bit-5 of fine_dly up to coarse_dly */
+		if (txdqsdlytg_5to0 >= 32) {
+			txdqsdlytg_9to6 = txdqsdlytg_9to6 + 1;
+			txdqsdlytg_5to0 = txdqsdlytg_5to0 - 32;
+		}
+
+		txdqsdly[pstate] = (uint16_t)((txdqsdlytg_9to6 << 6) | txdqsdlytg_5to0);
+
+		for (byte = 0; byte < userinputbasic.numdbyte; byte++) {
+			int c_addr;
+			int nibble;
+
+			c_addr = byte << 12;
+			for (nibble = 0; nibble < 2; nibble++) {
+				int u_addr;
+
+				if (ddrphy_phyinit_isdbytedisabled(byte)) {
+					continue;
+				}
+
+				u_addr = nibble << 8;
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+				if ((mb_ddr_1d[pstate].cspresent & 0x1) >> 0) {
+					mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr |
+										      TDBYTE |
+										      c_addr |
+										      u_addr |
+									CSR_TXDQSDLYTG0_ADDR)),
+						      txdqsdly[pstate]);
+				}
+#elif STM32MP_LPDDR4_TYPE
+				if (((mb_ddr_1d[pstate].cspresentcha & 0x1) >> 0) |
+				    ((mb_ddr_1d[pstate].cspresentchb & 0x1) >> 0)) {
+					mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr |
+										      TDBYTE |
+										      c_addr |
+										      u_addr |
+									CSR_TXDQSDLYTG0_ADDR)),
+						      txdqsdly[pstate]);
+				}
+
+				if (((mb_ddr_1d[pstate].cspresentcha & 0x2) >> 1) |
+				    ((mb_ddr_1d[pstate].cspresentchb & 0x2) >> 1)) {
+					mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr |
+										      TDBYTE |
+										      c_addr |
+										      u_addr |
+									CSR_TXDQSDLYTG1_ADDR)),
+						      txdqsdly[pstate]);
+				}
+#endif /* STM32MP_LPDDR4_TYPE */
+			}
+		}
+	}
+}
+
+/*
+ * ##############################################################
+ *
+ * Program txdqdlyTg0/1[8:0] per P-state:
+ *
+ *     txdqdlyTg*[8:6] = floor( (txdqsdlytg*[5:0]*UI/32 + tDQS2DQ + 0.5UI) / UI)
+ *     txdqdlyTg*[5:0] = ceil( ((txdqsdlytg*[5:0]*UI/32 + tDQS2DQ + 0.5UI)%UI / UI) * 32)
+ *
+ * ##############################################################
+ */
+static void txdqdlytg_program(uint16_t *txdqsdly)
+{
+	int pstate;
+
+	/* ### Set per p-state ### // */
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int byte;
+		int p_addr;
+		int txdqdly_5to0; /* Fine delay - 1/32UI per increment */
+		int txdqdly_8to6; /* Coarse delay - 1UI per increment */
+		int txdqsdlytg_5to0; /* Fine delay - 1/32UI per increment */
+		long long tmp_value;
+		long long uifs;
+		uint16_t txdqdly;
+
+		p_addr = pstate << 20;
+
+		uifs = (1000 * 1000000 * 1) / (userinputbasic.frequency[pstate] * 2);
+
+		txdqsdlytg_5to0 = (int)txdqsdly[pstate] & 0x3f;
+
+		txdqdly_8to6 = (int)(((txdqsdlytg_5to0 * uifs / 32) + (uifs / 2)) / uifs);
+		tmp_value = fmodll(((txdqsdlytg_5to0 * uifs / 32) + (uifs / 2)), uifs);
+		txdqdly_5to0 = (int)(((tmp_value * 32) / uifs));
+		if ((tmp_value % uifs) != 0) {
+			txdqdly_5to0++;
+		}
+
+		/* Bit-5 of LCDL is no longer used, so bumping bit-5 of fine_dly up to coarse_dly */
+		if (txdqdly_5to0 >= 32) {
+			txdqdly_8to6 = txdqdly_8to6 + 1;
+			txdqdly_5to0 = txdqdly_5to0 - 32;
+		}
+
+		txdqdly = (uint16_t)((txdqdly_8to6 << 6) | txdqdly_5to0);
+
+		for (byte = 0; byte < userinputbasic.numdbyte; byte++) {
+			int c_addr;
+			int lane;
+
+			c_addr = byte << 12;
+			for (lane = 0; lane < 9; lane++) {
+				int r_addr;
+
+				if (ddrphy_phyinit_isdbytedisabled(byte)) {
+					continue;
+				}
+
+				r_addr = lane << 8;
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+				if ((mb_ddr_1d[pstate].cspresent & 0x1) >> 0) {
+					mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr |
+										      TDBYTE |
+										      c_addr |
+										      r_addr |
+									CSR_TXDQDLYTG0_ADDR)),
+						      txdqdly);
+				}
+#elif STM32MP_LPDDR4_TYPE
+				if (((mb_ddr_1d[pstate].cspresentcha & 0x1) >> 0) |
+				    ((mb_ddr_1d[pstate].cspresentchb & 0x1) >> 0)) {
+					mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr |
+										      TDBYTE |
+										      c_addr |
+										      r_addr |
+									CSR_TXDQDLYTG0_ADDR)),
+						      txdqdly);
+				}
+
+				if (((mb_ddr_1d[pstate].cspresentcha & 0x2) >> 1) |
+				    ((mb_ddr_1d[pstate].cspresentchb & 0x2) >> 1)) {
+					mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr |
+										      TDBYTE |
+										      c_addr |
+										      r_addr |
+									CSR_TXDQDLYTG1_ADDR)),
+						      txdqdly);
+				}
+#endif /* STM32MP_LPDDR4_TYPE */
+			}
+		}
+	}
+}
+
+/*
+ * Program rxendly0/1[10:0] per P-State:
+ *
+ *         rxendly[10:6] = floor( (4*UI + tDQSCK + tstaoff) / UI)
+ *         rxendly[5:0]  = ceil( ((tDQSCK + tstaoff) % UI) * 32)
+ *
+ * tDQSCK, tstaoff and UI expressed in ps
+ */
+static void rxendly_program(bool skip_train)
+{
+	int pstate;
+
+
+	int rxendly_coarse_default = 4;
+	int rxendly_fine_default = 0;
+
+	/* ### Set per p-state ### // */
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int backoff_x1000 __unused;
+		int zerobackoff_x1000 __unused;
+		int byte;
+		int p_addr;
+		int rxendly_10to6; /* Coarse delay - 1UI per increment */
+		int rxendly_5to0; /* Fine delay - 1/32UI per increment */
+		int totfinestep;
+		long long finestepfs; /* fine steps in fs */
+		long long rxendly_offset_x1000000 = 0; /* 0 offset is 1UI before the first DQS. */
+		long long totfs;
+		long long uifs;
+		uint16_t rxendly;
+
+		p_addr = pstate << 20;
+
+		uifs = (1000 * 1000000 * 1) / (userinputbasic.frequency[pstate] * 2);
+
+#if STM32MP_LPDDR4_TYPE
+		/* Compensate for pptenrxenbackoff */
+		zerobackoff_x1000 = (1000 * 24) / 32;
+		if (userinputadvanced.lp4rxpreamblemode[pstate] == 1) {
+			backoff_x1000 = (1000 * 1) - ((1000 * 4) / 32);
+		} else {
+			backoff_x1000 = (1000 * userinputadvanced.rxenbackoff) - ((1000 * 4) / 32);
+		}
+
+		if (skip_train && !userinputadvanced.disableretraining) {
+			rxendly_offset_x1000000 = userinputbasic.frequency[pstate] < 333 ?
+						  backoff_x1000 * uifs : zerobackoff_x1000 * uifs;
+		} else if (skip_train && userinputadvanced.disableretraining) {
+			rxendly_offset_x1000000 = zerobackoff_x1000 * uifs;
+		}
+#endif /* STM32MP_LPDDR4_TYPE */
+
+		finestepfs = uifs / 32;
+		totfs = ((32 * rxendly_coarse_default * finestepfs) +
+			 (rxendly_fine_default * finestepfs) +
+			 ((timings.tstaoff[pstate] + timings.tcasl_add[pstate] +
+			   timings.tpdm[pstate]) * 1000) + (rxendly_offset_x1000000 / 1000));
+		totfinestep = totfs / finestepfs;
+
+		rxendly_10to6 = totfinestep / 32;
+		rxendly_5to0  = fmodi(totfinestep, 32);
+
+		/* Bit-5 of LCDL is no longer used, so bumping bit-5 of fine_dly up to coarse_dly */
+		if (rxendly_5to0 >= 32) {
+			rxendly_10to6 = rxendly_10to6 + 1;
+			rxendly_5to0 = rxendly_5to0 - 32;
+		}
+
+		rxendly = (uint16_t)((rxendly_10to6 << 6) | rxendly_5to0);
+
+		for (byte = 0; byte < userinputbasic.numdbyte; byte++) {
+			int c_addr;
+			int nibble;
+
+			c_addr = byte << 12;
+			for (nibble = 0; nibble < 2; nibble++) {
+				int u_addr;
+
+				if (ddrphy_phyinit_isdbytedisabled(byte)) {
+					continue;
+				}
+
+				u_addr = nibble << 8;
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+				if ((mb_ddr_1d[pstate].cspresent & 0x1) >> 0) {
+					mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr |
+										      TDBYTE |
+										      c_addr |
+										      u_addr |
+									CSR_RXENDLYTG0_ADDR)),
+						      rxendly);
+				}
+#elif STM32MP_LPDDR4_TYPE
+				if (((mb_ddr_1d[pstate].cspresentcha & 0x1) >> 0) |
+				    ((mb_ddr_1d[pstate].cspresentchb & 0x1) >> 0)) {
+					mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr |
+										      TDBYTE |
+										      c_addr |
+										      u_addr |
+									CSR_RXENDLYTG0_ADDR)),
+						      rxendly);
+				}
+
+				if (((mb_ddr_1d[pstate].cspresentcha & 0x2) >> 1) |
+				    ((mb_ddr_1d[pstate].cspresentchb & 0x2) >> 1)) {
+					mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr |
+										      TDBYTE |
+										      c_addr |
+										      u_addr |
+									CSR_RXENDLYTG1_ADDR)),
+						      rxendly);
+				}
+#endif /* STM32MP_LPDDR4_TYPE */
+			}
+		}
+	}
+}
+
+#if STM32MP_LPDDR4_TYPE
+/*
+ * Programming Seq0BGPR1/2/3 for LPDDR4
+ */
+static void seq0bgpr_program(void)
+{
+	int pstate;
+
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) { /* for each p_addr */
+		int extradly;
+		int rl = 0; /* computed read latency */
+		int wl = 0; /* computed write latency */
+		uint16_t mr_dbi_rd; /* extracted field from MR */
+		uint16_t mr_rl;
+		uint16_t mr_wl;
+		uint16_t mr_wls;
+		uint16_t regdata;
+		unsigned int p;
+
+		extradly = 3; /* LPDDR4 */
+
+		switch (pstate) {
+		case 0:
+			p = P0;
+			break;
+		case 1:
+			p = P1;
+			break;
+		case 2:
+			p = P2;
+			break;
+		case 3:
+			p = P3;
+			break;
+		default:
+			p = P0;
+			break;
+		}
+
+		mr_rl = (uint16_t)userinputadvanced.lp4rl[pstate];	/* RL[2:0] */
+		mr_wl = (uint16_t)userinputadvanced.lp4wl[pstate];	/* WL[5:3] */
+		mr_wls = (uint16_t)userinputadvanced.lp4wls[pstate];	/* WLS */
+		mr_dbi_rd = (uint16_t)userinputadvanced.lp4dbird[pstate]; /* DBI-RD */
+
+		switch (mr_dbi_rd << 3 | mr_rl) {
+		/* DBI-RD Disabled */
+		case  0U:
+			rl = 6;
+			break;
+		case  1U:
+			rl = 10;
+			break;
+		case  2U:
+			rl = 14;
+			break;
+		case  3U:
+			rl = 20;
+			break;
+		case  4U:
+			rl = 24;
+			break;
+		case  5U:
+			rl = 28;
+			break;
+		case  6U:
+			rl = 32;
+			break;
+		case  7U:
+			rl = 36;
+			break;
+		/* DBI-RD Enabled */
+		case  8U:
+			rl = 6;
+			break;
+		case  9U:
+			rl = 12;
+			break;
+		case 10U:
+			rl = 16;
+			break;
+		case 11U:
+			rl = 22;
+			break;
+		case 12U:
+			rl = 28;
+			break;
+		case 13U:
+			rl = 32;
+			break;
+		case 14U:
+			rl = 36;
+			break;
+		case 15U:
+			rl = 40;
+			break;
+		default:
+			rl = 6;
+			break;
+		}
+
+		switch (mr_wls << 3 | mr_wl) {
+		/* DBI-RD Disabled */
+		case  0U:
+			wl = 4;
+			break;
+		case  1U:
+			wl = 6;
+			break;
+		case  2U:
+			wl = 8;
+			break;
+		case  3U:
+			wl = 10;
+			break;
+		case  4U:
+			wl = 12;
+			break;
+		case  5U:
+			wl = 14;
+			break;
+		case  6U:
+			wl = 16;
+			break;
+		case  7U:
+			wl = 18;
+			break;
+		/* DBI-RD Enabled */
+		case  8U:
+			wl = 4;
+			break;
+		case  9U:
+			wl = 8;
+			break;
+		case 10U:
+			wl = 12;
+			break;
+		case 11U:
+			wl = 18;
+			break;
+		case 12U:
+			wl = 22;
+			break;
+		case 13U:
+			wl = 26;
+			break;
+		case 14U:
+			wl = 30;
+			break;
+		case 15U:
+			wl = 34;
+			break;
+		default:
+			wl = 4;
+			break;
+		}
+
+
+		/* Program Seq0b_GPRx */
+		regdata = (uint16_t)((rl - 5 + extradly) << CSR_ACSMRCASLAT_LSB);
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p | C0 | TINITENG | R2 |
+							      CSR_SEQ0BGPR1_ADDR)), regdata);
+
+		regdata = (uint16_t)((wl - 5 + extradly) << CSR_ACSMWCASLAT_LSB);
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p | C0 | TINITENG | R2 |
+							      CSR_SEQ0BGPR2_ADDR)), regdata);
+
+		regdata = (uint16_t)((rl - 5 + extradly + 4 + 8) << CSR_ACSMRCASLAT_LSB);
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p | C0 | TINITENG | R2 |
+							      CSR_SEQ0BGPR3_ADDR)), regdata);
+	} /* for each p_addr */
+}
+
+/*
+ * Program hwtlpcsena and hwtlpcsenb based on number of ranks per channel
+ * Applicable only for LPDDR4.  These CSRs have no effect
+ * for DDR3/4
+ *
+ * CSRs to program:
+ *      hwtlpcsena
+ *      hwtlpcsenb
+ *
+ * User input dependencies:
+ *      dramtype
+ *      dfi1exists
+ *      numrank_dfi0
+ *      numrank_dfi1
+ */
+static void hwtlpcsen_program(void)
+{
+	uint16_t hwtlpcsena;
+	uint16_t hwtlpcsenb;
+
+	/* Channel A - 1'b01 if signal-rank, 2'b11 if dual-rank */
+	hwtlpcsena = (uint16_t)userinputbasic.numrank_dfi0 | 0x1U;
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_HWTLPCSENA_ADDR)), hwtlpcsena);
+
+	/*
+	 * Channel B - 1'b01 if signal-rank, 2'b11 if dual-rank
+	 * If DFI1 exists but disabled, numrank_dfi0 is used to program CsEnB
+	 */
+	if (userinputbasic.dfi1exists == 1 && userinputbasic.numactivedbytedfi1 == 0) {
+		hwtlpcsenb = (uint16_t)userinputbasic.numrank_dfi0 | 0x1U;
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_HWTLPCSENB_ADDR)),
+			      hwtlpcsenb);
+	} else if (userinputbasic.dfi1exists == 1 && userinputbasic.numactivedbytedfi1 > 0) {
+		hwtlpcsenb = (uint16_t)userinputbasic.numrank_dfi1 | 0x1U;
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_HWTLPCSENB_ADDR)),
+			      hwtlpcsenb);
+	} else { /* Disable Channel B */
+		hwtlpcsenb = 0x0U;
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_HWTLPCSENB_ADDR)),
+			      hwtlpcsenb);
+	}
+}
+
+/*
+ * Program pptdqscntinvtrntg0 and pptdqscntinvtrntg1
+ * Calculated based on tDQS2DQ and Frequencey
+ * Applicable to LPDDR4 only
+ *
+ * 65536*(tdqs2dq_value_rank<rank>_chan<chan>*2)/(2*2048*UI(ps)_int)
+ *
+ * CSRs to program:
+ *      pptdqscntinvtrntg0
+ *      pptdqscntinvtrntg1
+ *
+ * User input dependencies:
+ *      tDQS2DQ
+ *      frequency
+ */
+static void pptdqscntinvtrntg_program(void)
+{
+	int pstate;
+
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int p_addr;
+		int numrank_total;
+		int rank;
+
+		/* Calculate total number of timing groups (ranks) */
+		numrank_total = userinputbasic.numrank_dfi0 +
+				userinputbasic.numrank_dfi1 * userinputbasic.dfi1exists;
+
+		p_addr = pstate << 20;
+
+		/* ### Set per timing group ### // */
+		for (rank = 0; rank < numrank_total; rank++) {
+			int byte;
+			uint16_t pptdqscntinvtrntg0;
+			uint16_t pptdqscntinvtrntg1;
+
+			switch (rank) {
+			case 0:
+				pptdqscntinvtrntg0 = 0U;
+				break;
+			case 1:
+				pptdqscntinvtrntg1 = 0U;
+				break;
+			}
+
+			for (byte = 0; byte < userinputbasic.numdbyte; byte++) {
+				int c_addr;
+
+				c_addr = byte << 12;
+				if (rank == 0) {
+					mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr |
+										      TDBYTE |
+										      c_addr |
+								CSR_PPTDQSCNTINVTRNTG0_ADDR)),
+						      pptdqscntinvtrntg0);
+				} else if (rank == 1) {
+					mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr |
+										      TDBYTE |
+										      c_addr |
+								CSR_PPTDQSCNTINVTRNTG1_ADDR)),
+						      pptdqscntinvtrntg1);
+				}
+			}
+		}
+	}
+}
+
+/*
+ * CSRs to program:
+ *      PptCtlStatic:: DOCByteSelTg0/1
+ *                   :: pptenrxenbackoff
+ *
+ * User input dependencies::
+ *      dramtype
+ *      dramdatawidth
+ * Sim dependencies::
+ *      DramByteSwap
+ */
+static void pptctlstatic_program(void)
+{
+	int byte;
+	int pptenrxenbackoff;
+
+	/*
+	 * The customer will setup some fields in this csr so the fw needs to do a
+	 * read-modify-write here.
+	 */
+
+	if (userinputadvanced.lp4rxpreamblemode[0] == 1) { /* Rx-preamble mode for PS0 */
+		/* Programming PptCtlStatic detected toggling preamble */
+		pptenrxenbackoff = 0x1; /* toggling RD_PRE */
+	} else {
+		pptenrxenbackoff = userinputadvanced.rxenbackoff; /* static RD_PRE */
+	}
+
+	for (byte = 0; byte < userinputbasic.numdbyte; byte++) {
+		int c_addr;
+		uint16_t regdata;
+		uint8_t pptentg1;
+		unsigned int docbytetg0;
+		unsigned int docbytetg1;
+
+		/* Each Dbyte could have a different configuration. */
+		c_addr = byte * C1;
+		if (byte % 2 == 0) {
+			docbytetg0 = 0x1U & (unsigned int)(userinputadvanced.drambyteswap >> byte);
+			docbytetg1 = 0x1U & (unsigned int)(userinputadvanced.drambyteswap >> byte);
+		} else {
+			docbytetg0 = 0x1U &
+				     (unsigned int)(~(userinputadvanced.drambyteswap >> byte));
+			docbytetg1 = 0x1U &
+				     (unsigned int)(~(userinputadvanced.drambyteswap >> byte));
+		}
+
+		pptentg1 = ((userinputbasic.numrank_dfi0 == 2) ||
+			    (userinputbasic.numrank_dfi1 == 2)) ? 0x1U : 0x0U;
+		regdata = (uint16_t)(0x1U << CSR_PPTENDQS2DQTG0_LSB |
+				     pptentg1 << CSR_PPTENDQS2DQTG1_LSB |
+				     0x1U << CSR_PPTENRXENDLYTG0_LSB |
+				     pptentg1 << CSR_PPTENRXENDLYTG1_LSB |
+				     pptenrxenbackoff << CSR_PPTENRXENBACKOFF_LSB |
+				     docbytetg0 << CSR_DOCBYTESELTG0_LSB |
+				     docbytetg1 << CSR_DOCBYTESELTG1_LSB);
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (c_addr | TDBYTE |
+							      CSR_PPTCTLSTATIC_ADDR)), regdata);
+	}
+}
+#endif /* STM32MP_LPDDR4_TYPE */
+
+/*
+ * Program hwtcamode based on dram type
+ *
+ * CSRs to program:
+ *      hwtcamode::hwtlp3camode
+ *               ::hwtd4camode
+ *               ::hwtlp4camode
+ *               ::hwtd4altcamode
+ *               ::hwtcsinvert
+ *               ::hwtdbiinvert
+ *
+ * User input dependencies::
+ *      dramtype
+ */
+static void hwtcamode_program(void)
+{
+	int hwtlp3camode = 0;
+	int hwtd4camode = 0;
+	int hwtlp4camode = 0;
+	int hwtd4altcamode = 0;
+	int hwtcsinvert = 0;
+	int hwtdbiinvert = 0;
+	uint16_t hwtcamode;
+
+#if STM32MP_DDR4_TYPE
+	hwtd4camode = 1;
+#elif STM32MP_LPDDR4_TYPE
+	hwtlp4camode = 1;
+	hwtcsinvert = 1;
+	hwtdbiinvert = 1;
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	hwtcamode = (uint16_t)((hwtdbiinvert << CSR_HWTDBIINVERT_LSB) |
+			       (hwtcsinvert << CSR_HWTCSINVERT_LSB) |
+			       (hwtd4altcamode << CSR_HWTD4ALTCAMODE_LSB) |
+			       (hwtlp4camode << CSR_HWTLP4CAMODE_LSB) |
+			       (hwtd4camode << CSR_HWTD4CAMODE_LSB) |
+			       (hwtlp3camode << CSR_HWTLP3CAMODE_LSB));
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_HWTCAMODE_ADDR)), hwtcamode);
+}
+
+/*
+ * Program DllGainCtl and DllLockParam based on frequency
+ */
+static void dllgainctl_dlllockparam_program(void)
+{
+	int pstate;
+
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		int dllgainiv;
+		int dllgaintv;
+		int lcdlseed;
+		int memck_freq;
+		int p_addr;
+		int stepsize_x10 = 47;	/*
+					 * Nominal stepsize, in units of tenths of a ps,
+					 * if nominal=4.7ps use 47
+					 */
+		uint16_t wddllgainctl;
+		uint16_t wddlllockparam;
+
+		memck_freq = userinputbasic.frequency[pstate];
+		/*
+		 * lcdlseed = ((1000000/memck_freq)/2)/lcdl_stepsize  ...
+		 * where default lcdl_stepsize=4.7  in simulation
+		 */
+		p_addr = pstate << 20;
+
+		dllgainiv = 0x00;
+		dllgaintv = 0x02;
+
+		if (memck_freq >= 332) {
+			dllgainiv = 0x01;
+			dllgaintv = 0x03;
+		}
+		if (memck_freq >= 532) {
+			dllgainiv = 0x02;
+			dllgaintv = 0x04;
+		}
+		if (memck_freq >= 800) {
+			dllgainiv = 0x03;
+			dllgaintv = 0x05;
+		}
+		if (memck_freq >= 1200) {
+			dllgainiv = 0x04;
+			dllgaintv = 0x05;
+		}
+
+		/*
+		 * lcdlseed= (1000000/(2*memck_freq)) * (100/(120*(stepsize_nominal)));
+		 * *100/105 is to bias the seed low
+		 */
+		lcdlseed = (1000000 * 10 * 100) / (2 * memck_freq * stepsize_x10 * 105);
+
+		if (lcdlseed > 511 - 32) {
+			lcdlseed = 511 - 32;
+		}
+
+		if (lcdlseed < 32) {
+			lcdlseed = 32;
+		}
+
+		wddllgainctl = (uint16_t)((CSR_DLLSEEDSEL_MASK & 0x0000U) |
+					  (CSR_DLLGAINTV_MASK & (dllgaintv << CSR_DLLGAINTV_LSB)) |
+					  (CSR_DLLGAINIV_MASK & (dllgainiv << CSR_DLLGAINIV_LSB)));
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TMASTER |
+							      CSR_DLLGAINCTL_ADDR)), wddllgainctl);
+
+
+		wddlllockparam = (uint16_t)((CSR_LCDLSEED0_MASK & (lcdlseed << CSR_LCDLSEED0_LSB)) |
+					    (CSR_DISDLLGAINIVSEED_MASK & 0xFFFFU) |
+					    (CSR_DISDLLSEEDSEL_MASK & 0x0000U));
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (p_addr | TMASTER |
+							      CSR_DLLLOCKPARAM_ADDR)),
+			      wddlllockparam);
+	}
+}
+
+/*
+ * Program AcsmCtrl23 for Fw and Ppt.
+ *
+ * CSRs to program:
+ *   AcsmCtrl23::AcsmCsMask
+ *               AcsmCsMode
+ */
+static void acsmctrl23_program(void)
+{
+	uint16_t regdata;
+
+	regdata = (0x0FU << CSR_ACSMCSMASK_LSB | 0x1U << CSR_ACSMCSMODE_LSB);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (C0 | TACSM | CSR_ACSMCTRL23_ADDR)), regdata);
+}
+
+/*
+ * Set PllForceCal to 1 and PllDacValIn to some arbitrary value
+ */
+static void pllforcecal_plldacvalin_program(void)
+{
+	int dacval_in = 0x10;
+	int force_cal = 1;
+	int maxrange = 0x1f;
+	uint16_t pllctrl3;
+
+	pllctrl3 = (uint16_t)((dacval_in << CSR_PLLDACVALIN_LSB) |
+			      (force_cal << CSR_PLLFORCECAL_LSB) |
+			      (maxrange << CSR_PLLMAXRANGE_LSB));
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_PLLCTRL3_ADDR)), pllctrl3);
+}
+
+/*
+ * This function programs registers that are normally set by training
+ * firmware.
+ *
+ * This function is used in lieu of running 1D or 1D training steps. PhyInit
+ * calls this function when skip_train = true. In that case, PhyInit does not
+ * execute training firmware and this function is called instead to program
+ * PHY registers according to DRAM timing parameters specified in userInputSim
+ * data structure. See documentation of ddrphy_phyinit_struct.h file
+ * details of timing parameters available in skip training.
+ *
+ * \warning ddrphy_phyinit_progcsrskiptrain() only supports zero board
+ * delay model. If system board delays are set or randomized, full 1D or 1D
+ * initialization flow must be executed.
+ *
+ * This function replaces these steps in the PHY Initialization sequence:
+ *  - (E) Set the PHY input clocks to the desired frequency
+ *  - (F) Write the Message Block parameters for the training firmware
+ *  - (G) Execute the Training Firmware
+ *  - (H) Read the Message Block results
+ *
+ * \returns \c void
+ */
+void ddrphy_phyinit_progcsrskiptrain(bool skip_train)
+{
+	uint16_t txdqsdly[NB_PS] = { };
+
+	VERBOSE("%s Start\n", __func__);
+
+	set_timings();
+
+	/*
+	 * Program ATxDlY
+	 * For DDR4, DDR3 and LPDDR4, leave AtxDly[6:0] at default (0x0)
+	 */
+
+	dfimrl_program();
+
+	txdqsdlytg_program(txdqsdly);
+
+	txdqdlytg_program(txdqsdly);
+
+	rxendly_program(skip_train);
+
+#if STM32MP_LPDDR4_TYPE
+	seq0bgpr_program();
+
+	hwtlpcsen_program();
+
+	pptdqscntinvtrntg_program();
+
+	pptctlstatic_program();
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	hwtcamode_program();
+
+	dllgainctl_dlllockparam_program();
+
+	acsmctrl23_program();
+
+	pllforcecal_plldacvalin_program();
+
+	/*
+	 * ##############################################################
+	 *
+	 * Setting PhyInLP3 to 0 to cause PIE to execute LP2 sequence instead of INIT on first
+	 * dfi_init_start.
+	 * This prevents any DRAM commands before DRAM is initialized, which is the case for
+	 * skip_train.
+	 *
+	 * Moved to here from dddrphy_phyinit_I_loadPIEImage()
+	 * These should not be needed on S3-exit
+	 *
+	 * Note this executes for SkipTrain only, *not* DevInit+SkipTrain
+	 * DevInit+SkipTrain already initializes DRAM and thus don't need to avoid DRAM commands
+	 *
+	 * ##############################################################
+	 */
+	if (skip_train) {
+		/*
+		 * Special skipTraining configuration to Prevent DRAM Commands on the first dfi
+		 * status interface handshake. In order to see this behavior, the first dfi_freq
+		 * should be in the range of 0x0f < dfi_freq_sel[4:0] < 0x14.
+		 */
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TINITENG | CSR_PHYINLP3_ADDR)), 0x0U);
+	}
+
+	VERBOSE("%s End\n", __func__);
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_reginterface.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_reginterface.c
new file mode 100644
index 000000000..7b96eb9d2
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_reginterface.c
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*
+ * This file provides a group of functions that are used to track PHY register
+ * writes by intercepting io_write16 function calls.  Once the registers are
+ * tracked, their value can be saved at a given time spot, and restored later
+ * as required.  This implementation is useful to capture any PHY register
+ * programing in any function during PHY initialization.
+ */
+
+#include <stdint.h>
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+/*
+ * MAX_NUM_RET_REGS default Max number of retention registers
+ *
+ * This define is only used by the PhyInit Register interface to define the max
+ * amount of registered that can be saved. The user may increase this variable
+ * as desired if a larger number of registers need to be restored.
+ */
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+#define MAX_NUM_RET_REGS	129
+#elif STM32MP_LPDDR4_TYPE
+#define MAX_NUM_RET_REGS	282
+#endif /* STM32MP_LPDDR4_TYPE */
+
+/*
+ * Array of Address/value pairs used to store register values for the purpose
+ * of retention restore.
+ */
+reg_addr_val_t retreglist[MAX_NUM_RET_REGS];
+
+int numregsaved = 0;    /* Current Number of registers saved. */
+int tracken = 1;        /* Enabled tracking of registers */
+
+/*
+ * Tags a register if tracking is enabled in the register
+ * interface
+ *
+ * during PhyInit registers writes, keeps track of address
+ * for the purpose of restoring the PHY register state during PHY
+ * retention exit process.  Tracking can be turned on/off via the
+ * ddrphy_phyinit_reginterface starttrack, stoptrack instructions. By
+ * default tracking is always turned on.
+ *
+ * \return 0 on success.
+ */
+int ddrphy_phyinit_trackreg(uint32_t adr)
+{
+	int regindx = 0;
+
+	/* Return if tracking is disabled */
+	if (!tracken) {
+		return 0;
+	}
+
+	/* Search register address within the array */
+	for (regindx = 0; regindx < numregsaved; regindx++) {
+		if (retreglist[regindx].address == adr) {
+			/* Register found */
+			return 0;
+		}
+	}
+
+	/* Register not found, so add it. */
+	if (numregsaved > MAX_NUM_RET_REGS) {
+		ERROR("[ddrphy_phyinit_reginterface:ddrphy_phyinit_trackreg]\n");
+		ERROR("Max Number of Restore Registers reached: %d.\n", numregsaved);
+		ERROR("Please recompile PhyInit with larger MAX_NUM_RET_REG value.\n");
+		return -1;
+	}
+
+	retreglist[regindx].address = adr;
+	numregsaved++;
+
+	return 0;
+}
+
+/*
+ * Register interface function used to track, save and restore retention registers.
+ *
+ * ### Usage
+ * Register tracking is enabled by calling:
+ *
+ *  \code
+ *  ddrphy_phyinit_reginterface(starttrack,0,0);
+ *  \endcode
+ *
+ * from this point on any call to ddrphy_phyinit_usercustom_io_write16() in
+ * return will be capture by the register interface via a call to
+ * ddrphy_phyinit_trackreg(). Tracking is disabled by calling:
+ *
+ *  \code
+ *  ddrphy_phyinit_reginterface(stoptrack,0,0);
+ *  \endcode
+ *
+ * On calling this function, register write via
+ * ddrphy_phyinit_usercustom_io_write16 are no longer tracked until a
+ * starttrack call is made.  Once all the register write are complete, saveRegs
+ * command can be issue to save register values into the internal data array of
+ * the register interface.  Upon retention exit restoreregs are command can be
+ * used to issue register write commands to the PHY based on values stored in
+ * the array.
+ *  \code
+ *   ddrphy_phyinit_reginterface(saveregs,0,0);
+ *   ddrphy_phyinit_reginterface(restoreregs,0,0);
+ *  \endcode
+ * \return 0 on success.
+ */
+int ddrphy_phyinit_reginterface(reginstr myreginstr, uint32_t adr, uint16_t dat)
+{
+	if (myreginstr == saveregs) {
+		int regindx;
+
+		/*
+		 * go through all the tracked registers, issue a register read and place
+		 * the result in the data structure for future recovery.
+		 */
+		for (regindx = 0; regindx < numregsaved; regindx++) {
+			uint16_t data;
+
+			data = mmio_read_16((uintptr_t)(DDRPHYC_BASE +
+							(4 * retreglist[regindx].address)));
+			retreglist[regindx].value = data;
+		}
+
+		return 0;
+	} else if (myreginstr == restoreregs) {
+		int regindx;
+
+		/*
+		 * write PHY registers based on Address, Data value pairs stores in
+		 * retreglist
+		 */
+		for (regindx = 0; regindx < numregsaved; regindx++) {
+			mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * retreglist[regindx].address),
+				      retreglist[regindx].value);
+		}
+
+		return 0;
+	} else if (myreginstr == starttrack) { /* Enable tracking */
+		tracken = 1;
+		return 0;
+	} else if (myreginstr == stoptrack) { /* Disable tracking */
+		tracken = 0;
+		return 0;
+	} else if (myreginstr == dumpregs) { /* Dump restore state to file. */
+		/* TBD */
+		return 0;
+	} else if (myreginstr == importregs) { /* import register state from file. */
+		/* TBD */
+		return 0;
+	} else {
+		/* future instructions. */
+		return -1;
+	}
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_restore_sequence.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_restore_sequence.c
new file mode 100644
index 000000000..0aaf417d2
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_restore_sequence.c
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+/*
+ * This function implements the register restore portion of S3/IO
+ * retention sequence.
+ *
+ * \note This function requiers the runtime_config.reten=1 to enable PhyInit exit retention feature.
+ * This variable can be set as in
+ * \return 0 on completion of the sequence, EXIT_FAILURE on error.
+ */
+int ddrphy_phyinit_restore_sequence(void)
+{
+	int ret;
+
+	if (!runtimeconfig.reten) {
+		ERROR("%s retention restore sequence function is called but register save\n",
+		      __func__);
+		ERROR("process was not executed during initialzation sequence\n");
+		ERROR("(runtimeconfig.reten != 0)\n");
+	}
+
+	VERBOSE("%s Start\n", __func__);
+
+	/*
+	 * Before you call this functions perform the following:
+	 * --------------------------------------------------------------------------
+	 * -# Bring up VDD, VDDQ should already be up
+	 * -# Since the CKE* and MEMRESET pin state must be protected, special care
+	 *    must be taken to ensure that the following signals
+	 *    - atpg_mode = 1'b0
+	 *    - PwrOkIn = 1'b0
+	 *
+	 * -# The {BypassModeEn*, WRSTN} signals may be defined at VDD power-on, but
+	 *    must be driven to ZERO at least 10ns prior to the asserting edge of PwrOkIn.
+	 *
+	 * -# Start Clocks and Reset the PHY
+	 *    This step is identical to ddrphy_phyinit_usercustom_b_startclockresetphy()
+	 */
+
+	/* -# Write the MicroContMuxSel CSR to 0x0 to allow access to the internal CSRs */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR)), 0x0U);
+
+	/*
+	 * -# Write the UcclkHclkEnables CSR to 0x3 to enable all the clocks so the reads can
+	 *  complete
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TDRTUB | CSR_UCCLKHCLKENABLES_ADDR)), 0x3U);
+
+	/*
+	 * -# Assert CalZap to force impedance calibration FSM to idle.
+	 *    de-asserted as part of dfi_init_start/complete handshake
+	 *    by the PIE when DfiClk is valid.
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_CALZAP_ADDR)), 0x1U);
+
+	/* -# Issue register writes to restore registers values. */
+	ret = ddrphy_phyinit_reginterface(restoreregs, 0, 0);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/*
+	 * -# Write the UcclkHclkEnables CSR to disable the appropriate clocks after all reads done.
+	 */
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	/* Disabling Ucclk (PMU) and Hclk (training hardware) */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TDRTUB | CSR_UCCLKHCLKENABLES_ADDR)), 0x0U);
+#elif STM32MP_LPDDR4_TYPE
+	/* Disabling Ucclk (PMU) */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TDRTUB | CSR_UCCLKHCLKENABLES_ADDR)), 0x2U);
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	/*
+	 * -# Write the MicroContMuxSel CSR to 0x1 to isolate the internal CSRs during mission mode.
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR)), 0x1U);
+
+	/*
+	 * After Function Call
+	 * --------------------------------------------------------------------------
+	 * To complete the Retention Exit sequence:
+	 *
+	 * -# Initialize the PHY to Mission Mode through DFI Initialization
+	 *    You may use the same sequence implemented in
+	 *    ddrphy_phyinit_usercustom_j_entermissionmode()
+	 */
+
+	VERBOSE("%s End\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_sequence.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_sequence.c
new file mode 100644
index 000000000..620245c7a
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_sequence.c
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch_helpers.h>
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit.h>
+
+/*
+ * This function implements the flow of PhyInit software to initialize the PHY.
+ *
+ * The execution sequence follows the overview figure provided in the PhyInit App Note.
+ *
+ * \returns 0 on completion of the sequence, EXIT_FAILURE on error.
+ */
+int ddrphy_phyinit_sequence(bool skip_training, bool reten)
+{
+	int ret;
+
+	/* Check user input pstate number consistency vs. SW capabilities */
+	if (userinputbasic.numpstates > NB_PS) {
+		return -1;
+	}
+
+	/* registering function inputs */
+	runtimeconfig.skip_train = skip_training;
+
+	VERBOSE("%s Start\n", __func__);
+
+	/* Initialize structures */
+	ddrphy_phyinit_initstruct();
+
+	/* Re-calculate Firmware Message Block input based on final user input */
+	ret = ddrphy_phyinit_calcmb();
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* (A) Bring up VDD, VDDQ, and VAA */
+	/* ddrphy_phyinit_usercustom_a_bringuppower(); */
+
+	/* (B) Start Clocks and Reset the PHY */
+	/* ddrphy_phyinit_usercustom_b_startclockresetphy(); */
+
+	/* (C) Initialize PHY Configuration */
+	ret = ddrphy_phyinit_c_initphyconfig();
+	if (ret != 0) {
+		return ret;
+	}
+	/*
+	 * Customize any register write desired; This can include any CSR not covered by PhyInit
+	 * or user wish to override values calculated in step_C
+	 */
+	ddrphy_phyinit_usercustom_custompretrain();
+
+	/* Stop retention register tracking for training firmware related registers */
+	ret = ddrphy_phyinit_reginterface(stoptrack, 0, 0);
+	if (ret != 0) {
+		return ret;
+	}
+
+	if (runtimeconfig.skip_train) {
+		/* Skip running training firmware entirely */
+		ddrphy_phyinit_progcsrskiptrain(runtimeconfig.skip_train);
+	} else {
+		int pstate;
+
+		/* Run all 1D power states, then 2D P0, to reduce total Imem/Dmem loads. */
+
+		/* (D) Load the IMEM Memory for 1D training */
+		ddrphy_phyinit_d_loadimem();
+
+		for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+			/* (E) Set the PHY input clocks to the desired frequency */
+			/* ddrphy_phyinit_usercustom_e_setdficlk(pstate); */
+
+			/*
+			 * Note: this routine implies other items such as dfifreqratio, DfiCtlClk
+			 * are also set properly.
+			 * Because the clocks are controlled in the SOC, external to the software
+			 * and PHY, this step intended to be replaced by the user with the necessary
+			 * SOC operations to achieve the new input frequency to the PHY.
+			 */
+
+			/* (F) Write the Message Block parameters for the training firmware */
+			ret = ddrphy_phyinit_f_loaddmem(pstate);
+			if (ret != 0) {
+				return ret;
+			}
+
+			/* (G) Execute the Training Firmware */
+			ret = ddrphy_phyinit_g_execfw();
+			if (ret != 0) {
+				return ret;
+			}
+
+			/* (H) Read the Message Block results */
+			ddrphy_phyinit_h_readmsgblock();
+		}
+	}
+
+	/* Start retention register tracking for training firmware related registers */
+	ret = ddrphy_phyinit_reginterface(starttrack, 0, 0);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* (I) Load PHY Init Engine Image */
+	ddrphy_phyinit_i_loadpieimage(runtimeconfig.skip_train);
+
+	/*
+	 * Customize any CSR write desired to override values programmed by firmware or
+	 * ddrphy_phyinit_i_loadpieimage()
+	 */
+	ddrphy_phyinit_usercustom_customposttrain();
+
+	if (reten) {
+		/* Save value of tracked registers for retention restore sequence. */
+		ret = ddrphy_phyinit_usercustom_saveretregs();
+		if (ret != 0) {
+			return ret;
+		}
+
+		runtimeconfig.reten = reten;
+	}
+
+	/* (J) Initialize the PHY to Mission Mode through DFI Initialization */
+	/* ddrphy_phyinit_usercustom_j_entermissionmode(); */
+
+	VERBOSE("%s End\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_softsetmb.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_softsetmb.c
new file mode 100644
index 000000000..bef08749b
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_softsetmb.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <string.h>
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit.h>
+
+/*
+ * Set messageBlock variable only if not set by user
+ *
+ * This function is used by ddrphy_phyinit_calcmb() to set calculated
+ * messageBlock variables only when the user has not directly programmed them.
+ *
+ * @param[in]   ps      integer between 0-3. Specifies the PState for which the messageBlock field should be set.
+ * @param[in]   field   A string representing the messageBlock field to be programed.
+ * @param[in]   value   filed value
+ *
+ * @return 0 on success.
+ * On error  returns the following values based on error:
+ * - -1 : message block field specified by the input \c field string is not
+ * found in the message block data structure.
+ * - -2 : when dramtype does not support 2D training but a 2D training field is
+ * programmed.
+ */
+int ddrphy_phyinit_softsetmb(int ps, char *field, int value)
+{
+		if (strcmp(field, "pstate") == 0) {
+			if (shdw_ddr_1d[ps].pstate == 0) {
+				mb_ddr_1d[ps].pstate = value;
+			}
+		} else if (strcmp(field, "pllbypassen") == 0) {
+			if (shdw_ddr_1d[ps].pllbypassen == 0) {
+				mb_ddr_1d[ps].pllbypassen = value;
+			}
+		} else if (strcmp(field, "dramfreq") == 0) {
+			if (shdw_ddr_1d[ps].dramfreq == 0) {
+				mb_ddr_1d[ps].dramfreq = value;
+			}
+		} else if (strcmp(field, "dfifreqratio") == 0) {
+			if (shdw_ddr_1d[ps].dfifreqratio == 0) {
+				mb_ddr_1d[ps].dfifreqratio = value;
+			}
+		} else if (strcmp(field, "bpznresval") == 0) {
+			if (shdw_ddr_1d[ps].bpznresval == 0) {
+				mb_ddr_1d[ps].bpznresval = value;
+			}
+		} else if (strcmp(field, "phyodtimpedance") == 0) {
+			if (shdw_ddr_1d[ps].phyodtimpedance == 0) {
+				mb_ddr_1d[ps].phyodtimpedance = value;
+			}
+		} else if (strcmp(field, "phydrvimpedance") == 0) {
+			if (shdw_ddr_1d[ps].phydrvimpedance == 0) {
+				mb_ddr_1d[ps].phydrvimpedance = value;
+			}
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+		} else if (strcmp(field, "dramtype") == 0) {
+			if (shdw_ddr_1d[ps].dramtype == 0) {
+				mb_ddr_1d[ps].dramtype = value;
+			}
+		} else if (strcmp(field, "disableddbyte") == 0) {
+			if (shdw_ddr_1d[ps].disableddbyte == 0) {
+				mb_ddr_1d[ps].disableddbyte = value;
+			}
+		} else if (strcmp(field, "enableddqs") == 0) {
+			if (shdw_ddr_1d[ps].enableddqs == 0) {
+				mb_ddr_1d[ps].enableddqs = value;
+			}
+		} else if (strcmp(field, "phycfg") == 0) {
+			if (shdw_ddr_1d[ps].phycfg == 0) {
+				mb_ddr_1d[ps].phycfg = value;
+			}
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+#if STM32MP_DDR4_TYPE
+		} else if (strcmp(field, "x16present") == 0) {
+			if (shdw_ddr_1d[ps].x16present == 0) {
+				mb_ddr_1d[ps].x16present = value;
+			}
+#endif /* STM32MP_DDR4_TYPE */
+#if STM32MP_LPDDR4_TYPE
+		} else if (strcmp(field, "enableddqscha") == 0) {
+			if (shdw_ddr_1d[ps].enableddqscha == 0) {
+				mb_ddr_1d[ps].enableddqscha = value;
+			}
+		} else if (strcmp(field, "cspresentcha") == 0) {
+			if (shdw_ddr_1d[ps].cspresentcha == 0) {
+				mb_ddr_1d[ps].cspresentcha = value;
+			}
+		} else if (strcmp(field, "enableddqschb") == 0) {
+			if (shdw_ddr_1d[ps].enableddqschb == 0) {
+				mb_ddr_1d[ps].enableddqschb = value;
+			}
+		} else if (strcmp(field, "cspresentchb") == 0) {
+			if (shdw_ddr_1d[ps].cspresentchb == 0) {
+				mb_ddr_1d[ps].cspresentchb = value;
+			}
+#endif /* STM32MP_LPDDR4_TYPE */
+		} else {
+			ERROR("%s unknown message block field name '%s'\n", __func__, field);
+			return -1;
+		}
+
+	return 0;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_sr_complete_function.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_sr_complete_function.c
new file mode 100644
index 000000000..5cb920802
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_sr_complete_function.c
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+/*
+ * End of Micro-Controller based Save/Restore function.
+ *
+ * This function Halts the Micro Controller, Gate clocks in prepration for
+ * mission mode during for the Micro Controller based Save/Restore sequence.
+ *
+ * \return void
+ */
+void ddrphy_phyinit_sr_complete_function(void)
+{
+	VERBOSE("%s Start\n", __func__);
+
+	/*
+	 * ##############################################################
+	 *
+	 * / To Halt Micro Controller after save operation completed
+	 * CSRs to program:
+	 *   MicroReset
+	 *
+	 * ##############################################################
+	 */
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICRORESET_ADDR)), 0x1U);
+
+	/*
+	 * ##############################################################
+	 *
+	 * To gain control of the APB bus
+	 * To gate the micro controller clock and/or training hardware clock accordingly
+	 * To isolate the APB bus access
+	 * CSRs to program:
+	 *   MicroContMuxSel UcclkHclkEnables
+	 *
+	 * ##############################################################
+	 */
+
+	/* Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR)), 0x0U);
+
+	/*
+	 * For DDR3 and DDR4, gate-off Ucclk and Hclk after training is done
+	 * LPDDR4 will need ACSM for PPT, and thus not gating Hclk (only gates Ucclk)
+	 */
+	if (userinputbasic.dramtype == DDR4 || userinputbasic.dramtype == DDR3) {
+		/* Disabling Ucclk (PMU) and Hclk (training hardware) */
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TDRTUB | CSR_UCCLKHCLKENABLES_ADDR)),
+			      0x0U);
+	} else {
+		/* Disabling Ucclk (PMU) */
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TDRTUB | CSR_UCCLKHCLKENABLES_ADDR)),
+			      0x2U);
+	}
+
+	/* Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR)), 0x1U);
+
+	VERBOSE("%s End\n", __func__);
+}
+
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_sr_start_function.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_sr_start_function.c
new file mode 100644
index 000000000..40cb25943
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_sr_start_function.c
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+/*
+ * Start of the Micro Controller based Save/Restore function
+ *
+ * Start of SR function.
+ * Load Universal Resident Retention FW image and kick off Micro Controller,
+ * Wait for save operation to be completed. The exact steps of the functions
+ * are:
+ */
+void ddrphy_phyinit_sr_start_function(void)
+{
+	VERBOSE("%s Start\n", __func__);
+
+	/*
+	 * - Program MicroContMuxSel to gain control of the APB bus
+	 * - Program UcclkHclkEnables to have PHY micro controller and training
+	 *   hardware clocks enabled
+	 */
+
+	/* Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR)), 0x0U);
+
+	/* Enable Ucclk (PMU) and Hclk (training hardware) */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TDRTUB | CSR_UCCLKHCLKENABLES_ADDR)), 0x3U);
+
+	/*
+	 * - To load IMEM and DMEM with universal resident retention FW image by
+	 *   calling ddrphy_phyinit_load_sr_fw().
+	 */
+	ddrphy_phyinit_load_sr_fw();
+
+	/*
+	 * - Program MicroContMuxSel:
+	 *   - To give micro controller control of the APB bus
+	 * - Program MicroReset :
+	 *   - To execute universal resident retention FW image
+	 */
+
+	/*
+	 * Allow Micro Controller to gain control of the APB bus by setting the MicroContMuxSel
+	 * CSR to 1.
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR)), 0x1U);
+
+	/* Halt and reset Micro Controller */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICRORESET_ADDR)), 0x9U);
+	/* Halt Micro Controller */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICRORESET_ADDR)), 0x1U);
+	/* Kick off Micro Controller and execute universal resident retention FW */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICRORESET_ADDR)), 0x0U);
+
+	/*
+	 * - Wait for a SAVE_NUM_CYCLE of DFI clock cycles by calling
+	 *   ddrphy_phyinit_usercustom_sr_wait().
+	 */
+	ddrphy_phyinit_usercustom_sr_wait();
+
+	VERBOSE("%s End\n", __func__);
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_storeincvfile.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_storeincvfile.c
new file mode 100644
index 000000000..8083c5763
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_storeincvfile.c
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit.h>
+
+/*
+ * Reads firmware image incv file
+ *
+ * Routine to read an incv file into an internal mem array.
+ *
+ * \return the address of the first apb write in the incv file to use as the mem
+ * offset.
+ */
+int ddrphy_phyinit_storeincvfile(char *incv_file_name, int mem[],
+				 return_offset_lastaddr_t return_type)
+{
+	FILE *incvfile_ptr;
+	char *p;
+	char instr[255];
+	int adr, dat, x, first, offset = 0;
+
+	/* die if can't open incv file */
+	if ((incvfile_ptr = fopen(incv_file_name, "r")) == NULL) {
+		ERROR("%s Error:  Error opening input file %s/\n\n", __func__, incv_file_name);
+	} else {
+		INFO("%s Reading input file: %s\n\n", __func__, incv_file_name);
+	}
+
+	/*
+	 * Assume entire incv file is made of lines that look like
+	 * apb_wr(32'haaaa,16'hdddd);
+	 * and capture the aaaa and dddd values to load array
+	 */
+
+	first = 0;
+	while (fgets(instr, 255, incvfile_ptr) != NULL) {
+		p = strtok(instr, "(");
+		x = 0;
+		do {
+			p = strtok(NULL, "h,)");
+			if (p) {
+				if (x == 1) {
+					sscanf(p, "%x", &adr);
+				} else if (x == 3) {
+					sscanf(p, "%x", &dat);
+					if (first == 0) {
+						offset = adr;
+						first = 1;
+					}
+					mem[adr - offset] = dat; /* load array */
+				}
+			}
+			x++;
+		} while (p);
+	}
+	fclose(incvfile_ptr);
+
+	if (return_type == return_lastaddr) {
+		offset = adr; /*return the last addr */
+	}
+
+	return offset;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_storemsgblk.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_storemsgblk.c
new file mode 100644
index 000000000..07d178f86
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_storemsgblk.c
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <ddrphy_phyinit.h>
+
+/*
+ * Store the message block into the bottom of the local DMEM array
+ *
+ * \return void
+ */
+void ddrphy_phyinit_storemsgblk(void *msgblkptr, int sizeofmsgblk, int mem[])
+{
+	/* Local variables */
+	int loop;
+	uint16_t *dataarray;
+
+	/* Recast the structure pointer as a pointer to an array of 16-bit values */
+	dataarray = (uint16_t *)msgblkptr;
+
+	/* Loop over the structure 16 bits at a time and load dmem */
+	for (loop = 0; loop < (int)(sizeofmsgblk / sizeof(uint16_t)); loop++) {
+		/* The data is the data in the structure at the loop offset */
+		mem[loop] = dataarray[loop];
+	}
+
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_writeoutmem.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_writeoutmem.c
new file mode 100644
index 000000000..9347d669d
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_writeoutmem.c
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdio.h>
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+/*
+ * Writes local memory content into the SRAM via APB interface.
+ *
+ * This function issued APB writes commands to SRAM address based on values
+ * stored in a local PhyInit array that contains consolidated IMEM and DMEM
+ * data.
+ * @param[in] mem[] Local memory array.
+ * @param[in] mem_offset offset index. if provided, skips to the offset index
+ * from the local array and issues APB commands from mem_offset to mem_size.
+ * @param[in] mem_size size of the memroy (in mem array index)
+ * @returns void
+ */
+void ddrphy_phyinit_writeoutmem(uint32_t *mem, int mem_offset, int mem_size)
+{
+	int index;
+
+	/*
+	 * 1. Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0.
+	 *    This allows the memory controller unrestricted access to the configuration CSRs.
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR)), 0x0U);
+
+	for (index = 0; index < (int)(mem_size / sizeof(uint16_t)); index++) {
+		uint32_t data = mem[index];
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * ((index * 2) + mem_offset)),
+			     data & 0xFFFFU);
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * ((index * 2) + 1 + mem_offset)),
+			     (data >> 16) & 0xFFFFU);
+	}
+
+	/*
+	 * 2. Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1.
+	 *    This allows the firmware unrestricted access to the configuration CSRs.
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR)), 0x1U);
+}
+
+/*
+ * Similar function for message block
+ */
+void ddrphy_phyinit_writeoutmsgblk(uint16_t *mem, int mem_offset, int mem_size)
+{
+	int index;
+
+	/*
+	 * 1. Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0.
+	 *    This allows the memory controller unrestricted access to the configuration CSRs.
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR)), 0x0U);
+
+
+	for (index = 0; index < (int)(mem_size / sizeof(uint16_t)); index++) {
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (index + mem_offset)), mem[index]);
+	}
+
+	/*
+	 * 2. Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1.
+	 *    This allows the firmware unrestricted access to the configuration CSRs.
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR)), 0x1U);
+}
diff --git a/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_a_bringuppower.c b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_a_bringuppower.c
new file mode 100644
index 000000000..fef6c9f92
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_a_bringuppower.c
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit_usercustom.h>
+
+/*
+ * This function can be used to apply power to the PHY.
+ *
+ * This function entry point in the initialization sequence can be used to
+ * implement Step (A) of the initialization sequence described in PUB the
+ * databook.
+ *
+ * The User can choose to leave this function as is, or implement a mechanism
+ * to trigger power ramp-up event in simulation. In the output text file, this
+ * function by default prints a call to a function of the same name.
+ *
+ * If the user chooses to use this function, the PHY expects all power pins
+ * (VDD, VDDQ and VAA) to transition from off to on stage as part of this step.
+ *
+ * The power supplies can come up and stabilize in any order. While the power
+ * supplies are coming up, all outputs will be unknown and the values of the
+ * inputs are don't cares.
+ *
+ * @return Void
+ *
+ */
+void ddrphy_phyinit_usercustom_a_bringuppower(void)
+{
+	VERBOSE("%s Start\n", __func__);
+
+	VERBOSE("%s End\n", __func__);
+}
diff --git a/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_b_startclockresetphy.c b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_b_startclockresetphy.c
new file mode 100644
index 000000000..4d53c627a
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_b_startclockresetphy.c
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit_usercustom.h>
+
+/*
+ * The user can use this function to initiate the clocks and reset the
+ * PHY.
+ *
+ * The default behavior of this function is to print comments relating to this
+ * process. A function call of the same name will be printed in the output text
+ * file. The user can choose to leave this function as is, or implement
+ * mechanism within this function to trigger start clock and reset events in
+ * simulation.
+ *
+ * Following is one possible sequence to reset the PHY. Other sequences are also
+ * possible. See section "Clocks, Reset, Initialization" of the PUB for other
+ * possible reset sequences.
+ *
+ * -# Drive PwrOkIn to 0. Note: Reset, DfiClk, and APBCLK can be X.
+ * -# Start DfiClk and APBCLK
+ * -# Drive Reset to 1 and PRESETn_APB to 0.
+ *    Note: The combination of PwrOkIn=0 and Reset=1 signals a cold reset to the PHY.
+ * -# Wait a minimum of 8 cycles.
+ * -# Drive PwrOkIn to 1. Once the PwrOkIn is asserted (and Reset is still asserted),
+ *    DfiClk synchronously switches to any legal input frequency.
+ * -# Wait a minimum of 64 cycles. Note: This is the reset period for the PHY.
+ * -# Drive Reset to 0. Note: All DFI and APB inputs must be driven at valid
+ *    reset states before the de-assertion of Reset.
+ * -# Wait a minimum of 1 Cycle.
+ * -# Drive PRESETn_APB to 1 to de-assert reset on the ABP bus.
+ * -# The PHY is now in the reset state and is ready to accept APB transactions.
+ *
+ * \return Void
+ */
+void ddrphy_phyinit_usercustom_b_startclockresetphy(void)
+{
+	VERBOSE("%s Start\n", __func__);
+
+	VERBOSE("%s End\n", __func__);
+}
diff --git a/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_customposttrain.c b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_customposttrain.c
new file mode 100644
index 000000000..b95650dd0
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_customposttrain.c
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit_usercustom.h>
+
+#include <platform_def.h>
+
+/*
+ * This function is called after the execution of training firmware is
+ * complete. The user can use this function to override any CSR value programmed
+ * by PhyInit or training firmware.
+ *
+ * The purpose of this function is to override any register values programmed
+ * by the training firmware or ddrphy_phyinit_progcsrskiptrain() when
+ * skip_train is used. This function is executed after training firmware has
+ * completed.
+ *
+ * \note **Warning!**
+ * This function must not override any values in userinputbasic,
+ * userinputadvanced or message block data structures.  Only PHY register values
+ * are to be modified with this function. To override PHY register values
+ * programmed by PhyInit, users must use mmio_write_16() function calls placed
+ * within this function.
+ *
+ * Sequence of Events in this function must be:
+ * -# Enable APB access
+ * -# Issue register writes
+ * -# Isolate APB access
+ *
+ * A \ref examples/simple/ddrphy_phyinit_usercustom_customposttrain.c example of this function
+ *
+ * \return void
+ */
+void ddrphy_phyinit_usercustom_customposttrain(void)
+{
+	VERBOSE("%s Start\n", __func__);
+
+	VERBOSE("%s End\n", __func__);
+}
+
diff --git a/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_custompretrain.c b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_custompretrain.c
new file mode 100644
index 000000000..3f226268e
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_custompretrain.c
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit_usercustom.h>
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+/* DDRDBG registers */
+#define DDRDBG_DDR34_AC_SWIZZLE_ADD3_0		U(0x100)
+
+/*
+ * This function is called before training firmware is executed. Any
+ * register override in this function might affect the firmware training
+ * results.
+ *
+ * This function is executed before firmware execution loop. Thus this function
+ * should be used only for the following:
+ *
+ *  - Override PHY register values written by
+ *  ddrphy_phyinit_c_initphyconfig.  An example use case is when this
+ *  function does not perform the exact programing desired by the user.
+ *  - Write custom PHY registers that need to take effect before training
+ *  firmware execution.
+ *
+ * User shall use mmio_write_16 to write PHY registers in order for the register
+ * to be tracked by PhyInit for retention restore.
+ *
+ * To override settings in the message block, users can assign values to the
+ * fields in the message block data structure directly
+ *
+ * \ref examples/simple/ddrphy_phyinit_usercustom_custompretrain.c example of this function
+ *
+ * @return Void
+ */
+void ddrphy_phyinit_usercustom_custompretrain(void)
+{
+	int byte __unused;
+	int i = 0;
+	int j;
+	uintptr_t base;
+
+	VERBOSE("%s Start\n", __func__);
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	base = (uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_HWTSWIZZLEHWTADDRESS0_ADDR));
+
+	for (i = 0; i < NB_HWT_SWIZZLE; i++) {
+		mmio_write_16(base + i * sizeof(uint32_t),
+			      (uint16_t)userinputswizzle.swizzle[i]);
+	}
+
+	base = (uintptr_t)(stm32_ddrdbg_get_base() + DDRDBG_DDR34_AC_SWIZZLE_ADD3_0);
+
+	for (j = 0; j < NB_AC_SWIZZLE; j++, i++) {
+		mmio_write_32(base + j * sizeof(uint32_t), userinputswizzle.swizzle[i]);
+	}
+#else
+	for (byte = 0; byte < userinputbasic.numdbyte; byte++) {
+		base = (uintptr_t)(DDRPHYC_BASE + 4 * ((byte << 12) | TDBYTE | CSR_DQ0LNSEL_ADDR));
+
+		for (j = 0; j < NB_DQLNSEL_SWIZZLE_PER_BYTE; j++, i++) {
+			mmio_write_16(base + j * sizeof(uint32_t),
+				      (uint16_t)userinputswizzle.swizzle[i]);
+		}
+	}
+
+	base = (uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_MAPCAA0TODFI_ADDR));
+
+	for (j = 0; j < NB_MAPCAATODFI_SWIZZLE; j++, i++) {
+		mmio_write_16(base + j * sizeof(uint32_t),
+			      (uint16_t)userinputswizzle.swizzle[i]);
+	}
+
+	base = (uintptr_t)(DDRPHYC_BASE + 4 * (TMASTER | CSR_MAPCAB0TODFI_ADDR));
+
+	for (j = 0; j < NB_MAPCABTODFI_SWIZZLE; j++, i++) {
+		mmio_write_16(base + j * sizeof(uint32_t),
+			      (uint16_t)userinputswizzle.swizzle[i]);
+	}
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+	VERBOSE("%s End\n", __func__);
+}
diff --git a/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_e_setdficlk.c b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_e_setdficlk.c
new file mode 100644
index 000000000..230409561
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_e_setdficlk.c
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit_usercustom.h>
+
+/*
+ * This function must be used to trigger setting DfiClk to the
+ * frequency associated with the input PState.
+ *
+ * The purpose of this function is to change DfiClk to the desired frequency for
+ * the input PState before proceeding to the next step. The default behavior of
+ * this function is to print comments relating to this process.  A function call
+ * of the same name will be printed in the output text file. The PhyInit
+ * ddrphy_phyinit_sequence() function calls this function multiple times in
+ * order to set DfiClk before triggering training firmware execution for
+ * different PStates. The User can edit this function to their needs in order to
+ * implement this functionality.
+ *
+ * the clock should be stable at the new frequency. For more information on
+ * clocking requirements, see "Clocks" section in the PUB documentation.
+ *
+ * \note this routine implies other items such as dfifreqratio, DfiCtlClk are
+ * also set properly.  Because the clocks are controlled in the SOC, external to
+ * the software and PHY, this step is intended to be replaced by the user with
+ * the necessary SOC operations to achieve the new input frequency to the PHY.
+ *
+ * \return integer value = Pstate
+ */
+int ddrphy_phyinit_usercustom_e_setdficlk(int pstate) {
+	/*!< Input Pstate indicating associated DfiClk requency*/
+
+	VERBOSE("%s Start\n", __func__);
+
+	VERBOSE("%s End\n", __func__);
+
+	return pstate;
+}
diff --git a/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_g_waitfwdone.c b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_g_waitfwdone.c
new file mode 100644
index 000000000..d095efab7
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_g_waitfwdone.c
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+#include <drivers/delay_timer.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+#include <platform_def.h>
+
+/* Firmware major messages */
+#define FW_MAJ_MSG_TRAINING_SUCCESS	0x0000007
+#define FW_MAJ_MSG_START_STREAMING	0x0000008
+#define FW_MAJ_MSG_TRAINING_FAILED	0x00000FF
+
+#define PHYINIT_DELAY_1US		1U
+#define PHYINIT_DELAY_10US		10U
+#define PHYINIT_TIMEOUT_US_1S		1000000U
+
+static int wait_uctwriteprotshadow(bool state)
+{
+	uint64_t timeout;
+	uint16_t read_data;
+	uint16_t value = state ? BIT(0) : 0U;
+
+	timeout = timeout_init_us(PHYINIT_TIMEOUT_US_1S);
+
+	do {
+		read_data = mmio_read_16((uintptr_t)(DDRPHYC_BASE +
+						     (4 * (TAPBONLY | CSR_UCTSHADOWREGS_ADDR))));
+		udelay(PHYINIT_DELAY_1US);
+		if (timeout_elapsed(timeout)) {
+			return -1;
+		}
+	} while ((read_data & BIT(0)) != value);
+
+	return 0;
+}
+
+static int ack_message_receipt(void)
+{
+	int ret;
+
+	/* Acknowledge the receipt of the message */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4 * (TAPBONLY | CSR_DCTWRITEPROT_ADDR))), 0U);
+
+	udelay(PHYINIT_DELAY_1US);
+
+	ret = wait_uctwriteprotshadow(true);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Complete the 4-phase protocol */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4 * (TAPBONLY | CSR_DCTWRITEPROT_ADDR))), 1U);
+
+	udelay(PHYINIT_DELAY_1US);
+
+	return 0;
+}
+
+static int get_major_message(int *msg)
+{
+	int message_number;
+	int ret;
+
+	ret = wait_uctwriteprotshadow(false);
+	if (ret != 0) {
+		return ret;
+	}
+
+	message_number = mmio_read_16((uintptr_t)(DDRPHYC_BASE +
+						  (4 * (TAPBONLY | CSR_UCTWRITEONLYSHADOW_ADDR))));
+
+	ret = ack_message_receipt();
+	if (ret != 0) {
+		return ret;
+	}
+
+	*msg = message_number;
+
+	return 0;
+}
+
+static int get_streaming_message(int *msg)
+{
+	int stream_word_lower_part;
+	int stream_word_upper_part;
+	int ret;
+
+	ret = wait_uctwriteprotshadow(false);
+	if (ret != 0) {
+		return ret;
+	}
+
+	stream_word_lower_part = mmio_read_16((uintptr_t)(DDRPHYC_BASE +
+							  (4 * (TAPBONLY |
+								CSR_UCTWRITEONLYSHADOW_ADDR))));
+
+	stream_word_upper_part = mmio_read_16((uintptr_t)(DDRPHYC_BASE +
+							  (4 * (TAPBONLY |
+								CSR_UCTDATWRITEONLYSHADOW_ADDR))));
+
+	ret = ack_message_receipt();
+	if (ret != 0) {
+		return ret;
+	}
+
+	*msg = stream_word_lower_part | (stream_word_upper_part << 16);
+
+	return 0;
+}
+
+/*
+ * Implements the mechanism to wait for completion of training firmware execution.
+ *
+ * The purpose of user this function is to wait for firmware to finish training.
+ * The user can either implement a counter to wait or implement the polling
+ * mechanism described in the Training Firmware App Note section "Running the
+ * Firmware".  The wait time is highly dependent on the training features
+ * enabled via sequencectrl input to the message block.  See Training Firmware
+ * App note for details.
+ *
+ * The default behavior of this function is to print comments relating to this
+ * process.  A function call of the same name will be printed in the output text
+ * file.
+ *
+ * The user can choose to leave this function as is, or implement mechanism to
+ * trigger mailbox poling event in simulation.
+ *
+ * \return 0 on success.
+ */
+int ddrphy_phyinit_usercustom_g_waitfwdone(void)
+{
+	int fw_major_message;
+	int ret;
+
+	VERBOSE("%s Start\n", __func__);
+
+	do {
+		ret = get_major_message(&fw_major_message);
+		if (ret != 0) {
+			return ret;
+		}
+
+		VERBOSE("fw_major_message = %x\n", (unsigned int)fw_major_message);
+
+		if (fw_major_message == FW_MAJ_MSG_START_STREAMING) {
+			int i;
+			int read_data;
+			int stream_len;
+
+			ret = get_streaming_message(&read_data);
+			if (ret != 0) {
+				return ret;
+			}
+
+			stream_len = read_data & 0xFFFF;
+
+			for (i = 0; i < stream_len; i++) {
+				ret = get_streaming_message(&read_data);
+				if (ret != 0) {
+					return ret;
+				}
+
+				VERBOSE("streaming message = %x\n", (unsigned int)read_data);
+			}
+		}
+	} while ((fw_major_message != FW_MAJ_MSG_TRAINING_SUCCESS) &&
+		 (fw_major_message != FW_MAJ_MSG_TRAINING_FAILED));
+
+	udelay(PHYINIT_DELAY_10US);
+
+	if (fw_major_message == FW_MAJ_MSG_TRAINING_FAILED) {
+		ERROR("%s Training has failed.\n", __func__);
+		return -1;
+	}
+
+	VERBOSE("%s End\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_h_readmsgblock.c b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_h_readmsgblock.c
new file mode 100644
index 000000000..776a60169
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_h_readmsgblock.c
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit.h>
+
+/*
+ * Reads training results
+ *
+ * Read the Firmware Message Block via APB read commands to the DMEM address to
+ * obtain training results.
+ *
+ * The default behavior of this function is to print comments relating to this
+ * process. An example pseudo code for implementing this function is as follows:
+ *
+ * @code{.c}
+ * {
+ *   _read_1d_message_block_outputs_
+ * }
+ * @endcode
+ *
+ * A function call of the same name will be printed in the output text file.
+ * User can choose to leave this function as is, or implement mechanism to
+ * trigger message block read events in simulation.
+ *
+ * \return void
+ */
+void ddrphy_phyinit_usercustom_h_readmsgblock(void)
+{
+	VERBOSE(" 2. Read the Firmware Message Block to obtain the results from the training.\n");
+	VERBOSE(" This can be accomplished by issuing APB read commands to the DMEM addresses.\n");
+	VERBOSE(" Example:\n");
+	VERBOSE("   _read_1d_message_block_outputs_\n");
+
+	VERBOSE("%s Start\n", __func__);
+
+	VERBOSE("%s End\n", __func__);
+}
diff --git a/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_j_entermissionmode.c b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_j_entermissionmode.c
new file mode 100644
index 000000000..2efc9292c
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_j_entermissionmode.c
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <ddrphy_phyinit_usercustom.h>
+
+/*
+ * Initialize the PHY to Mission Mode through DFI Initialization
+ *
+ * The default behavior of this function is to print comments relating to this
+ * process. User can choose to leave this function as is, or implement mechanism
+ * to trigger DFI Initialization in simulation.
+ *
+ * Initialize the PHY to mission mode as follows:
+ * -# Set the PHY input clocks to the desired frequency.
+ * -# Initialize the PHY to mission mode by performing DFI Initialization. See
+ * PUB Databook section on "DFI Frequency Change" for details on this step.
+ *
+ * \note to ensure DRAM MR state matches the destination frequency, the first
+ * dfi_freq[4:0] must be to a PState matching the last trained PState.  For
+ * Example 1) if 3 PStates are used and only 1D training is run, the first
+ * dfi_freq[4:0] must be 0x3 on the first dfi_init_start transaction.
+ * PState selected via dfi_freq[4:0] must match the
+ * Example 2) if 3 PStates are used with 2D training enabled, the first
+ * dfi_freq[4:0] must be 0x0 on the first dfi_init_start transaction.
+ *
+ * \note The PHY training firmware initializes the DRAM state. if skip
+ * training is used, the DRAM state is not initialized.
+ *
+ *
+ *
+ * \returns void
+ */
+void ddrphy_phyinit_usercustom_j_entermissionmode(void)
+{
+	VERBOSE("%s Start\n", __func__);
+
+	VERBOSE("%s End\n", __func__);
+}
diff --git a/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_saveretregs.c b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_saveretregs.c
new file mode 100644
index 000000000..0da09435b
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_saveretregs.c
@@ -0,0 +1,414 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdlib.h>
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+/*
+ * This function can be used to implement saving of PHY registers to be
+ * restored on retention exit.
+ *
+ * The requirement of this function is to issue register reads and store the
+ * value to be recovered on retention exit.  The following is an example
+ * implementation and the user may implement alternate methods that suit their
+ * specific SoC system needs.
+ *
+ * In this implementation PhyInit saves register values in an internal C array.
+ * During retention exit it restores register values from the array.  The exact
+ * list of registers to save and later restore can be seen in the output txt
+ * file with an associated calls to ddrphy_phyinit_usercustom_io_read16().
+ *
+ * PhyInit provides a register interface and a tracking mechanism to minimize
+ * the number registers needing restore. Refer to source code for
+ * ddrphy_phyinit_reginterface() for detailed implementation of tracking
+ * mechanism. Tracking is disabled from step D to Step H as these involve
+ * loading, executing and checking the state of training firmware execution
+ * which are not required to implement the retention exit sequence. The registers
+ * specified in firmware training App Note representing training results are
+ * also saved in addition to registers written by PhyInit during PHY
+ * initialization.
+ *
+ * \return 0 on success.
+ */
+int ddrphy_phyinit_usercustom_saveretregs(void)
+{
+	int pstate = 0;
+	int anib;
+	int byte;
+	int nibble;
+	int lane;
+	int p_addr;
+	int c_addr;
+	int u_addr;
+	int b_addr;
+	int r_addr;
+	int ret;
+
+	VERBOSE("%s Start\n", __func__);
+
+	/* In short the implementation of this function performs tasks: */
+
+	/*
+	 * --------------------------------------------------------------------------
+	 * 1. Enable tracking of training firmware result registers\n
+	 *    See firmware training App Note section "IO Retention" for reference
+	 *    table registers that need to be saved.
+	 *
+	 *    \note  The tagged registers in this step are in
+	 *    addition to what is automatically tagged during Steps C to I.
+	 *
+	 * --------------------------------------------------------------------------
+	 */
+
+	/* 95% of users should not require to change the code below */
+
+	ret = ddrphy_phyinit_trackreg(TMASTER | CSR_PLLCTRL3_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Non-PState Dbyte Registers */
+	for (byte = 0; byte < userinputbasic.numdbyte; byte++) {
+		c_addr = byte << 12;
+
+		for (lane = 0; lane <= R_MAX; lane++) {
+			r_addr = lane << 8;
+
+			ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | r_addr |
+						      CSR_RXPBDLYTG0_ADDR);
+			if (ret != 0) {
+				return ret;
+			}
+#if STM32MP_LPDDR4_TYPE
+			ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | r_addr |
+						      CSR_RXPBDLYTG1_ADDR);
+			if (ret != 0) {
+				return ret;
+			}
+#endif /* STM32MP_LPDDR4_TYPE */
+		} /* r_addr */
+
+#if STM32MP_LPDDR4_TYPE
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_PPTCTLSTATIC_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_TRAININGINCDECDTSMEN_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_TSMBYTE0_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_DQ0LNSEL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_DQ1LNSEL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_DQ2LNSEL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_DQ3LNSEL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_DQ4LNSEL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_DQ5LNSEL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_DQ6LNSEL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_DQ7LNSEL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+#endif /* STM32MP_LPDDR4_TYPE */
+	} /* c_addr */
+
+	/* PState variable registers */
+	for (pstate = 0; pstate < userinputbasic.numpstates; pstate++) {
+		p_addr = pstate << 20;
+
+		ret = ddrphy_phyinit_trackreg(p_addr | TMASTER | CSR_VREFINGLOBAL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		/* Anig Registers */
+		for (anib = 0; anib < userinputbasic.numanib; anib++) {
+			c_addr = anib << 12;
+
+			ret = ddrphy_phyinit_trackreg(p_addr | TANIB | c_addr | CSR_ATXDLY_ADDR);
+			if (ret != 0) {
+				return ret;
+			}
+		}
+
+		/* Dbyte Registers */
+		for (byte = 0; byte < userinputbasic.numdbyte; byte++) {
+			c_addr = byte << 12;
+
+			ret = ddrphy_phyinit_trackreg(p_addr | TDBYTE | c_addr | CSR_DFIMRL_ADDR);
+			if (ret != 0) {
+				return ret;
+			}
+
+			for (nibble = 0; nibble <= B_MAX; nibble++) {
+				b_addr = nibble << 8;
+
+				ret = ddrphy_phyinit_trackreg(p_addr | TDBYTE | c_addr | b_addr |
+							      CSR_DQDQSRCVCNTRL_ADDR);
+				if (ret != 0) {
+					return ret;
+				}
+			}
+
+			for (nibble = 0; nibble < 2; nibble++) {
+				u_addr = nibble << 8;
+
+				ret = ddrphy_phyinit_trackreg(p_addr | TDBYTE | c_addr | u_addr |
+							      CSR_RXENDLYTG0_ADDR);
+				if (ret != 0) {
+					return ret;
+				}
+#if STM32MP_LPDDR4_TYPE
+				ret = ddrphy_phyinit_trackreg(p_addr | TDBYTE | c_addr | u_addr |
+							      CSR_RXENDLYTG1_ADDR);
+				if (ret != 0) {
+					return ret;
+				}
+#endif /* STM32MP_LPDDR4_TYPE */
+				ret = ddrphy_phyinit_trackreg(p_addr | TDBYTE | c_addr | u_addr |
+							      CSR_TXDQSDLYTG0_ADDR);
+				if (ret != 0) {
+					return ret;
+				}
+#if STM32MP_LPDDR4_TYPE
+				ret = ddrphy_phyinit_trackreg(p_addr | TDBYTE | c_addr | u_addr |
+							      CSR_TXDQSDLYTG1_ADDR);
+				if (ret != 0) {
+					return ret;
+				}
+#endif /* STM32MP_LPDDR4_TYPE */
+				ret = ddrphy_phyinit_trackreg(p_addr | TDBYTE | c_addr | u_addr |
+							      CSR_RXCLKDLYTG0_ADDR);
+				if (ret != 0) {
+					return ret;
+				}
+#if STM32MP_LPDDR4_TYPE
+				ret = ddrphy_phyinit_trackreg(p_addr | TDBYTE | c_addr | u_addr |
+							      CSR_RXCLKDLYTG1_ADDR);
+				if (ret != 0) {
+					return ret;
+				}
+#endif /* STM32MP_LPDDR4_TYPE */
+			} /* nibble */
+
+			for (lane = R_MIN; lane <= R_MAX; lane++) {
+				r_addr = lane << 8;
+
+				ret = ddrphy_phyinit_trackreg(p_addr | TDBYTE | c_addr | r_addr |
+							      CSR_TXDQDLYTG0_ADDR);
+				if (ret != 0) {
+					return ret;
+				}
+#if STM32MP_LPDDR4_TYPE
+				ret = ddrphy_phyinit_trackreg(p_addr | TDBYTE | c_addr | r_addr |
+							      CSR_TXDQDLYTG1_ADDR);
+				if (ret != 0) {
+					return ret;
+				}
+#endif /* STM32MP_LPDDR4_TYPE */
+			} /* r_addr */
+
+#if STM32MP_LPDDR4_TYPE
+			ret = ddrphy_phyinit_trackreg(p_addr | TDBYTE | c_addr |
+						CSR_PPTDQSCNTINVTRNTG0_ADDR);
+			if (ret != 0) {
+				return ret;
+			}
+			ret = ddrphy_phyinit_trackreg(p_addr | TDBYTE | c_addr |
+						CSR_PPTDQSCNTINVTRNTG1_ADDR);
+			if (ret != 0) {
+				return ret;
+			}
+#endif /* STM32MP_LPDDR4_TYPE */
+		} /* c_addr */
+
+		/* PIE Registers */
+		ret = ddrphy_phyinit_trackreg(p_addr | TINITENG | CSR_SEQ0BGPR1_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(p_addr | TINITENG | CSR_SEQ0BGPR2_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(p_addr | TINITENG | CSR_SEQ0BGPR3_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(p_addr | TINITENG | CSR_SEQ0BGPR4_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(p_addr | TINITENG | CSR_SEQ0BGPR5_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(p_addr | TINITENG | CSR_SEQ0BGPR6_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(p_addr | TINITENG | CSR_SEQ0BGPR7_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(p_addr | TINITENG | CSR_SEQ0BGPR8_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		/* Master Registers */
+		ret = ddrphy_phyinit_trackreg(p_addr | TMASTER | CSR_DLLGAINCTL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(p_addr | TMASTER | CSR_DLLLOCKPARAM_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+#if STM32MP_LPDDR4_TYPE
+		ret = ddrphy_phyinit_trackreg(p_addr | TMASTER | CSR_HWTMRL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+#endif /* STM32MP_LPDDR4_TYPE */
+	} /* p_addr */
+
+	/* Master Registers */
+	ret = ddrphy_phyinit_trackreg(TMASTER | CSR_HWTCAMODE_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+#if STM32MP_LPDDR4_TYPE
+	ret = ddrphy_phyinit_trackreg(TMASTER | CSR_HWTLPCSENA_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_trackreg(TMASTER | CSR_HWTLPCSENB_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* ACSM registers */
+	ret = ddrphy_phyinit_trackreg(TACSM | CSR_ACSMCTRL13_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_trackreg(TACSM | CSR_ACSMCTRL23_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	/*
+	 * --------------------------------------------------------------------------
+	 * 2. Track any additional registers\n
+	 *    Register writes made using the any of the PhyInit functions are
+	 *    automatically tracked using the call to ddrphy_phyinit_trackreg() in
+	 *    mmio_write_16(). Use this section to track additional registers.
+	 * --------------------------------------------------------------------------
+	 */
+
+	/*
+	 * Example:
+	 * ddrphy_phyinit_trackreg(<addr>);
+	 */
+
+	/*
+	 * --------------------------------------------------------------------------
+	 * 3. Prepare for register reads\n
+	 *    - Write the MicroContMuxSel CSR to 0x0 to allow access to the internal CSRs
+	 *    - Write the UcclkHclkEnables CSR to 0x3 to enable all the clocks so the reads
+	 *      can complete.
+	 * --------------------------------------------------------------------------
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR)), 0x0U);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TDRTUB | CSR_UCCLKHCLKENABLES_ADDR)), 0x3U);
+
+	/*
+	 * --------------------------------------------------------------------------
+	 * / 4. Read and save all the registers
+	 * /    - The list of registers differ depending on protocol and 1D training.
+	 * --------------------------------------------------------------------------
+	 */
+
+	ret = ddrphy_phyinit_reginterface(saveregs, 0, 0);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/*
+	 * --------------------------------------------------------------------------
+	 * 5. Prepare for mission mode
+	 *  - Write the UcclkHclkEnables CSR to disable the appropriate clocks after all reads done.
+	 *  - Write the MicroContMuxSel CSR to 0x1 to isolate the internal CSRs during mission mode
+	 * --------------------------------------------------------------------------
+	 */
+
+#if STM32MP_DDR4_TYPE
+	/* Disabling Ucclk (PMU) and Hclk (training hardware) */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TDRTUB | CSR_UCCLKHCLKENABLES_ADDR)), 0x0U);
+#elif STM32MP_LPDDR4_TYPE
+	/* Disabling Ucclk (PMU) */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TDRTUB | CSR_UCCLKHCLKENABLES_ADDR)), 0x2U);
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + 4 * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR)), 0x1U);
+
+	VERBOSE("%s End\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_sr_wait.c b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_sr_wait.c
new file mode 100644
index 000000000..8e19b1a21
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_sr_wait.c
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <ddrphy_phyinit.h>
+
+/*
+ * Implements a wait function to Save-Retention firmware to finish.
+ *
+ * The purpose of this function is to wait for the Save-Retention (SR) Firmware to finish.
+ * The number of DfiClk cycles to wait is specific in the statements below.
+ *
+ * The default behavior of ddrphy_phyinit_usercustom_sr_wait() is to print the comments
+ * relating to its functions.
+ *
+ * User can edit this function to print differently, or implement a mechanism
+ * to wait for the SR event to finish in simulation
+ *
+ *   - Save operation depends on PHY configurations.
+ *   - Users may use the following table values as reference
+ *
+ *     Num of DBYTE |  DDR4  | LPDDR4
+ *     ------------ | ------ | ------
+ *     1            |  43k   | n/a
+ *     4            |  85k   | 62k
+ *     8            | 140k   | 96k
+ *     9            | 155k   | 104k
+ *
+ * @returns void
+ */
+void ddrphy_phyinit_usercustom_sr_wait(void)
+{
+	/* - Wait for a SAVE_NUM_CYCLE of DFI clock cycles */
+
+	VERBOSE("%s Start\n", __func__);
+
+	VERBOSE("%s End\n", __func__);
+}
diff --git a/drivers/st/ddr/stm32mp1_ddr.c b/drivers/st/ddr/stm32mp1_ddr.c
index 7d89d027e..4376f5dce 100644
--- a/drivers/st/ddr/stm32mp1_ddr.c
+++ b/drivers/st/ddr/stm32mp1_ddr.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2018-2019, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2018-2022, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
  */
@@ -12,8 +12,9 @@
 #include <arch.h>
 #include <arch_helpers.h>
 #include <common/debug.h>
+#include <drivers/clk.h>
 #include <drivers/delay_timer.h>
-#include <drivers/st/stm32mp_pmic.h>
+#include <drivers/st/stm32mp_ddr.h>
 #include <drivers/st/stm32mp1_ddr.h>
 #include <drivers/st/stm32mp1_ddr_regs.h>
 #include <drivers/st/stm32mp1_pwr.h>
@@ -21,32 +22,45 @@
 #include <lib/mmio.h>
 #include <plat/common/platform.h>
 
-struct reg_desc {
-	const char *name;
-	uint16_t offset;	/* Offset for base address */
-	uint8_t par_offset;	/* Offset for parameter array */
-};
-
-#define INVALID_OFFSET	0xFFU
-
-#define TIMEOUT_US_1S	1000000U
+#define TIMESLOT_US_1US	1U
 
 #define DDRCTL_REG(x, y)					\
 	{							\
 		.name = #x,					\
-		.offset = offsetof(struct stm32mp1_ddrctl, x),	\
+		.offset = offsetof(struct stm32mp_ddrctl, x),	\
 		.par_offset = offsetof(struct y, x)		\
 	}
 
 #define DDRPHY_REG(x, y)					\
 	{							\
 		.name = #x,					\
-		.offset = offsetof(struct stm32mp1_ddrphy, x),	\
+		.offset = offsetof(struct stm32mp_ddrphy, x),	\
 		.par_offset = offsetof(struct y, x)		\
 	}
 
+/*
+ * PARAMETERS: value get from device tree :
+ *             size / order need to be aligned with binding
+ *             modification NOT ALLOWED !!!
+ */
+#define DDRCTL_REG_REG_SIZE	25	/* st,ctl-reg */
+#define DDRCTL_REG_TIMING_SIZE	12	/* st,ctl-timing */
+#define DDRCTL_REG_MAP_SIZE	9	/* st,ctl-map */
+#if STM32MP_DDR_DUAL_AXI_PORT
+#define DDRCTL_REG_PERF_SIZE	17	/* st,ctl-perf */
+#else
+#define DDRCTL_REG_PERF_SIZE	11	/* st,ctl-perf */
+#endif
+
+#if STM32MP_DDR_32BIT_INTERFACE
+#define DDRPHY_REG_REG_SIZE	11	/* st,phy-reg */
+#else
+#define DDRPHY_REG_REG_SIZE	9	/* st,phy-reg */
+#endif
+#define	DDRPHY_REG_TIMING_SIZE	10	/* st,phy-timing */
+
 #define DDRCTL_REG_REG(x)	DDRCTL_REG(x, stm32mp1_ddrctrl_reg)
-static const struct reg_desc ddr_reg[] = {
+static const struct stm32mp_ddr_reg_desc ddr_reg[DDRCTL_REG_REG_SIZE] = {
 	DDRCTL_REG_REG(mstr),
 	DDRCTL_REG_REG(mrctrl0),
 	DDRCTL_REG_REG(mrctrl1),
@@ -75,7 +89,7 @@ static const struct reg_desc ddr_reg[] = {
 };
 
 #define DDRCTL_REG_TIMING(x)	DDRCTL_REG(x, stm32mp1_ddrctrl_timing)
-static const struct reg_desc ddr_timing[] = {
+static const struct stm32mp_ddr_reg_desc ddr_timing[DDRCTL_REG_TIMING_SIZE] = {
 	DDRCTL_REG_TIMING(rfshtmg),
 	DDRCTL_REG_TIMING(dramtmg0),
 	DDRCTL_REG_TIMING(dramtmg1),
@@ -91,7 +105,7 @@ static const struct reg_desc ddr_timing[] = {
 };
 
 #define DDRCTL_REG_MAP(x)	DDRCTL_REG(x, stm32mp1_ddrctrl_map)
-static const struct reg_desc ddr_map[] = {
+static const struct stm32mp_ddr_reg_desc ddr_map[DDRCTL_REG_MAP_SIZE] = {
 	DDRCTL_REG_MAP(addrmap1),
 	DDRCTL_REG_MAP(addrmap2),
 	DDRCTL_REG_MAP(addrmap3),
@@ -104,7 +118,7 @@ static const struct reg_desc ddr_map[] = {
 };
 
 #define DDRCTL_REG_PERF(x)	DDRCTL_REG(x, stm32mp1_ddrctrl_perf)
-static const struct reg_desc ddr_perf[] = {
+static const struct stm32mp_ddr_reg_desc ddr_perf[DDRCTL_REG_PERF_SIZE] = {
 	DDRCTL_REG_PERF(sched),
 	DDRCTL_REG_PERF(sched1),
 	DDRCTL_REG_PERF(perfhpr1),
@@ -116,16 +130,18 @@ static const struct reg_desc ddr_perf[] = {
 	DDRCTL_REG_PERF(pcfgqos1_0),
 	DDRCTL_REG_PERF(pcfgwqos0_0),
 	DDRCTL_REG_PERF(pcfgwqos1_0),
+#if STM32MP_DDR_DUAL_AXI_PORT
 	DDRCTL_REG_PERF(pcfgr_1),
 	DDRCTL_REG_PERF(pcfgw_1),
 	DDRCTL_REG_PERF(pcfgqos0_1),
 	DDRCTL_REG_PERF(pcfgqos1_1),
 	DDRCTL_REG_PERF(pcfgwqos0_1),
 	DDRCTL_REG_PERF(pcfgwqos1_1),
+#endif
 };
 
 #define DDRPHY_REG_REG(x)	DDRPHY_REG(x, stm32mp1_ddrphy_reg)
-static const struct reg_desc ddrphy_reg[] = {
+static const struct stm32mp_ddr_reg_desc ddrphy_reg[DDRPHY_REG_REG_SIZE] = {
 	DDRPHY_REG_REG(pgcr),
 	DDRPHY_REG_REG(aciocr),
 	DDRPHY_REG_REG(dxccr),
@@ -135,12 +151,14 @@ static const struct reg_desc ddrphy_reg[] = {
 	DDRPHY_REG_REG(zq0cr1),
 	DDRPHY_REG_REG(dx0gcr),
 	DDRPHY_REG_REG(dx1gcr),
+#if STM32MP_DDR_32BIT_INTERFACE
 	DDRPHY_REG_REG(dx2gcr),
 	DDRPHY_REG_REG(dx3gcr),
+#endif
 };
 
 #define DDRPHY_REG_TIMING(x)	DDRPHY_REG(x, stm32mp1_ddrphy_timing)
-static const struct reg_desc ddrphy_timing[] = {
+static const struct stm32mp_ddr_reg_desc ddrphy_timing[DDRPHY_REG_TIMING_SIZE] = {
 	DDRPHY_REG_TIMING(ptr0),
 	DDRPHY_REG_TIMING(ptr1),
 	DDRPHY_REG_TIMING(ptr2),
@@ -153,178 +171,53 @@ static const struct reg_desc ddrphy_timing[] = {
 	DDRPHY_REG_TIMING(mr3),
 };
 
-#define DDRPHY_REG_CAL(x)	DDRPHY_REG(x, stm32mp1_ddrphy_cal)
-static const struct reg_desc ddrphy_cal[] = {
-	DDRPHY_REG_CAL(dx0dllcr),
-	DDRPHY_REG_CAL(dx0dqtr),
-	DDRPHY_REG_CAL(dx0dqstr),
-	DDRPHY_REG_CAL(dx1dllcr),
-	DDRPHY_REG_CAL(dx1dqtr),
-	DDRPHY_REG_CAL(dx1dqstr),
-	DDRPHY_REG_CAL(dx2dllcr),
-	DDRPHY_REG_CAL(dx2dqtr),
-	DDRPHY_REG_CAL(dx2dqstr),
-	DDRPHY_REG_CAL(dx3dllcr),
-	DDRPHY_REG_CAL(dx3dqtr),
-	DDRPHY_REG_CAL(dx3dqstr),
-};
-
-#define DDR_REG_DYN(x)						\
-	{							\
-		.name = #x,					\
-		.offset = offsetof(struct stm32mp1_ddrctl, x),	\
-		.par_offset = INVALID_OFFSET \
-	}
-
-static const struct reg_desc ddr_dyn[] = {
-	DDR_REG_DYN(stat),
-	DDR_REG_DYN(init0),
-	DDR_REG_DYN(dfimisc),
-	DDR_REG_DYN(dfistat),
-	DDR_REG_DYN(swctl),
-	DDR_REG_DYN(swstat),
-	DDR_REG_DYN(pctrl_0),
-	DDR_REG_DYN(pctrl_1),
-};
-
-#define DDRPHY_REG_DYN(x)					\
-	{							\
-		.name = #x,					\
-		.offset = offsetof(struct stm32mp1_ddrphy, x),	\
-		.par_offset = INVALID_OFFSET			\
-	}
-
-static const struct reg_desc ddrphy_dyn[] = {
-	DDRPHY_REG_DYN(pir),
-	DDRPHY_REG_DYN(pgsr),
-};
-
-enum reg_type {
-	REG_REG,
-	REG_TIMING,
-	REG_PERF,
-	REG_MAP,
-	REGPHY_REG,
-	REGPHY_TIMING,
-	REGPHY_CAL,
 /*
- * Dynamic registers => managed in driver or not changed,
- * can be dumped in interactive mode.
+ * REGISTERS ARRAY: used to parse device tree and interactive mode
  */
-	REG_DYN,
-	REGPHY_DYN,
-	REG_TYPE_NB
-};
-
-enum base_type {
-	DDR_BASE,
-	DDRPHY_BASE,
-	NONE_BASE
-};
-
-struct ddr_reg_info {
-	const char *name;
-	const struct reg_desc *desc;
-	uint8_t size;
-	enum base_type base;
-};
-
-static const struct ddr_reg_info ddr_registers[REG_TYPE_NB] = {
+static const struct stm32mp_ddr_reg_info ddr_registers[REG_TYPE_NB] = {
 	[REG_REG] = {
 		.name = "static",
 		.desc = ddr_reg,
-		.size = ARRAY_SIZE(ddr_reg),
+		.size = DDRCTL_REG_REG_SIZE,
 		.base = DDR_BASE
 	},
 	[REG_TIMING] = {
 		.name = "timing",
 		.desc = ddr_timing,
-		.size = ARRAY_SIZE(ddr_timing),
+		.size = DDRCTL_REG_TIMING_SIZE,
 		.base = DDR_BASE
 	},
 	[REG_PERF] = {
 		.name = "perf",
 		.desc = ddr_perf,
-		.size = ARRAY_SIZE(ddr_perf),
+		.size = DDRCTL_REG_PERF_SIZE,
 		.base = DDR_BASE
 	},
 	[REG_MAP] = {
 		.name = "map",
 		.desc = ddr_map,
-		.size = ARRAY_SIZE(ddr_map),
+		.size = DDRCTL_REG_MAP_SIZE,
 		.base = DDR_BASE
 	},
 	[REGPHY_REG] = {
 		.name = "static",
 		.desc = ddrphy_reg,
-		.size = ARRAY_SIZE(ddrphy_reg),
+		.size = DDRPHY_REG_REG_SIZE,
 		.base = DDRPHY_BASE
 	},
 	[REGPHY_TIMING] = {
 		.name = "timing",
 		.desc = ddrphy_timing,
-		.size = ARRAY_SIZE(ddrphy_timing),
-		.base = DDRPHY_BASE
-	},
-	[REGPHY_CAL] = {
-		.name = "cal",
-		.desc = ddrphy_cal,
-		.size = ARRAY_SIZE(ddrphy_cal),
-		.base = DDRPHY_BASE
-	},
-	[REG_DYN] = {
-		.name = "dyn",
-		.desc = ddr_dyn,
-		.size = ARRAY_SIZE(ddr_dyn),
-		.base = DDR_BASE
-	},
-	[REGPHY_DYN] = {
-		.name = "dyn",
-		.desc = ddrphy_dyn,
-		.size = ARRAY_SIZE(ddrphy_dyn),
+		.size = DDRPHY_REG_TIMING_SIZE,
 		.base = DDRPHY_BASE
 	},
 };
 
-static uintptr_t get_base_addr(const struct ddr_info *priv, enum base_type base)
-{
-	if (base == DDRPHY_BASE) {
-		return (uintptr_t)priv->phy;
-	} else {
-		return (uintptr_t)priv->ctl;
-	}
-}
-
-static void set_reg(const struct ddr_info *priv,
-		    enum reg_type type,
-		    const void *param)
-{
-	unsigned int i;
-	unsigned int value;
-	enum base_type base = ddr_registers[type].base;
-	uintptr_t base_addr = get_base_addr(priv, base);
-	const struct reg_desc *desc = ddr_registers[type].desc;
-
-	VERBOSE("init %s\n", ddr_registers[type].name);
-	for (i = 0; i < ddr_registers[type].size; i++) {
-		uintptr_t ptr = base_addr + desc[i].offset;
-
-		if (desc[i].par_offset == INVALID_OFFSET) {
-			ERROR("invalid parameter offset for %s", desc[i].name);
-			panic();
-		} else {
-			value = *((uint32_t *)((uintptr_t)param +
-					       desc[i].par_offset));
-			mmio_write_32(ptr, value);
-		}
-	}
-}
-
-static void stm32mp1_ddrphy_idone_wait(struct stm32mp1_ddrphy *phy)
+static void stm32mp1_ddrphy_idone_wait(struct stm32mp_ddrphy *phy)
 {
 	uint32_t pgsr;
 	int error = 0;
-	uint64_t timeout = timeout_init_us(TIMEOUT_US_1S);
+	uint64_t timeout = timeout_init_us(DDR_TIMEOUT_US_1S);
 
 	do {
 		pgsr = mmio_read_32((uintptr_t)&phy->pgsr);
@@ -365,7 +258,7 @@ static void stm32mp1_ddrphy_idone_wait(struct stm32mp1_ddrphy *phy)
 		(uintptr_t)&phy->pgsr, pgsr);
 }
 
-static void stm32mp1_ddrphy_init(struct stm32mp1_ddrphy *phy, uint32_t pir)
+static void stm32mp1_ddrphy_init(struct stm32mp_ddrphy *phy, uint32_t pir)
 {
 	uint32_t pir_init = pir | DDRPHYC_PIR_INIT;
 
@@ -375,52 +268,20 @@ static void stm32mp1_ddrphy_init(struct stm32mp1_ddrphy *phy, uint32_t pir)
 		mmio_read_32((uintptr_t)&phy->pir));
 
 	/* Need to wait 10 configuration clock before start polling */
-	udelay(10);
+	udelay(DDR_DELAY_10US);
 
 	/* Wait DRAM initialization and Gate Training Evaluation complete */
 	stm32mp1_ddrphy_idone_wait(phy);
 }
 
-/* Start quasi dynamic register update */
-static void stm32mp1_start_sw_done(struct stm32mp1_ddrctl *ctl)
-{
-	mmio_clrbits_32((uintptr_t)&ctl->swctl, DDRCTRL_SWCTL_SW_DONE);
-	VERBOSE("[0x%lx] swctl = 0x%x\n",
-		(uintptr_t)&ctl->swctl,  mmio_read_32((uintptr_t)&ctl->swctl));
-}
-
-/* Wait quasi dynamic register update */
-static void stm32mp1_wait_sw_done_ack(struct stm32mp1_ddrctl *ctl)
-{
-	uint64_t timeout;
-	uint32_t swstat;
-
-	mmio_setbits_32((uintptr_t)&ctl->swctl, DDRCTRL_SWCTL_SW_DONE);
-	VERBOSE("[0x%lx] swctl = 0x%x\n",
-		(uintptr_t)&ctl->swctl, mmio_read_32((uintptr_t)&ctl->swctl));
-
-	timeout = timeout_init_us(TIMEOUT_US_1S);
-	do {
-		swstat = mmio_read_32((uintptr_t)&ctl->swstat);
-		VERBOSE("[0x%lx] swstat = 0x%x ",
-			(uintptr_t)&ctl->swstat, swstat);
-		if (timeout_elapsed(timeout)) {
-			panic();
-		}
-	} while ((swstat & DDRCTRL_SWSTAT_SW_DONE_ACK) == 0U);
-
-	VERBOSE("[0x%lx] swstat = 0x%x\n",
-		(uintptr_t)&ctl->swstat, swstat);
-}
-
 /* Wait quasi dynamic register update */
-static void stm32mp1_wait_operating_mode(struct ddr_info *priv, uint32_t mode)
+static void stm32mp1_wait_operating_mode(struct stm32mp_ddr_priv *priv, uint32_t mode)
 {
 	uint64_t timeout;
 	uint32_t stat;
 	int break_loop = 0;
 
-	timeout = timeout_init_us(TIMEOUT_US_1S);
+	timeout = timeout_init_us(DDR_TIMEOUT_US_1S);
 	for ( ; ; ) {
 		uint32_t operating_mode;
 		uint32_t selref_type;
@@ -463,7 +324,7 @@ static void stm32mp1_wait_operating_mode(struct ddr_info *priv, uint32_t mode)
 }
 
 /* Mode Register Writes (MRW or MRS) */
-static void stm32mp1_mode_register_write(struct ddr_info *priv, uint8_t addr,
+static void stm32mp1_mode_register_write(struct stm32mp_ddr_priv *priv, uint8_t addr,
 					 uint32_t data)
 {
 	uint32_t mrctrl0;
@@ -518,7 +379,7 @@ static void stm32mp1_mode_register_write(struct ddr_info *priv, uint8_t addr,
 }
 
 /* Switch DDR3 from DLL-on to DLL-off */
-static void stm32mp1_ddr3_dll_off(struct ddr_info *priv)
+static void stm32mp1_ddr3_dll_off(struct stm32mp_ddr_priv *priv)
 {
 	uint32_t mr1 = mmio_read_32((uintptr_t)&priv->phy->mr1);
 	uint32_t mr2 = mmio_read_32((uintptr_t)&priv->phy->mr2);
@@ -609,14 +470,14 @@ static void stm32mp1_ddr3_dll_off(struct ddr_info *priv)
 	 * 9. Set the MSTR.dll_off_mode = 1.
 	 *    warning: MSTR.dll_off_mode is a quasi-dynamic type 2 field
 	 */
-	stm32mp1_start_sw_done(priv->ctl);
+	stm32mp_ddr_start_sw_done(priv->ctl);
 
 	mmio_setbits_32((uintptr_t)&priv->ctl->mstr, DDRCTRL_MSTR_DLL_OFF_MODE);
 	VERBOSE("[0x%lx] mstr = 0x%x\n",
 		(uintptr_t)&priv->ctl->mstr,
 		mmio_read_32((uintptr_t)&priv->ctl->mstr));
 
-	stm32mp1_wait_sw_done_ack(priv->ctl);
+	stm32mp_ddr_wait_sw_done_ack(priv->ctl);
 
 	/* 10. Change the clock frequency to the desired value. */
 
@@ -627,7 +488,7 @@ static void stm32mp1_ddr3_dll_off(struct ddr_info *priv)
 	 */
 
 	/* Change Bypass Mode Frequency Range */
-	if (stm32mp_clk_get_rate(DDRPHYC) < 100000000U) {
+	if (clk_get_rate(DDRPHYC) < 100000000U) {
 		mmio_clrbits_32((uintptr_t)&priv->phy->dllgcr,
 				DDRPHYC_DLLGCR_BPS200);
 	} else {
@@ -641,14 +502,15 @@ static void stm32mp1_ddr3_dll_off(struct ddr_info *priv)
 			DDRPHYC_DXNDLLCR_DLLDIS);
 	mmio_setbits_32((uintptr_t)&priv->phy->dx1dllcr,
 			DDRPHYC_DXNDLLCR_DLLDIS);
+#if STM32MP_DDR_32BIT_INTERFACE
 	mmio_setbits_32((uintptr_t)&priv->phy->dx2dllcr,
 			DDRPHYC_DXNDLLCR_DLLDIS);
 	mmio_setbits_32((uintptr_t)&priv->phy->dx3dllcr,
 			DDRPHYC_DXNDLLCR_DLLDIS);
+#endif
 
 	/* 12. Exit the self-refresh state by setting PWRCTL.selfref_sw = 0. */
-	mmio_clrbits_32((uintptr_t)&priv->ctl->pwrctl,
-			DDRCTRL_PWRCTL_SELFREF_SW);
+	stm32mp_ddr_sw_selfref_exit(priv->ctl);
 	stm32mp1_wait_operating_mode(priv, DDRCTRL_STAT_OPERATING_MODE_NORMAL);
 
 	/*
@@ -663,62 +525,153 @@ static void stm32mp1_ddr3_dll_off(struct ddr_info *priv)
 	 */
 
 	/* 15. Write DBG1.dis_hif = 0 to re-enable reads and writes. */
-	mmio_clrbits_32((uintptr_t)&priv->ctl->dbg1, DDRCTRL_DBG1_DIS_HIF);
-	VERBOSE("[0x%lx] dbg1 = 0x%x\n",
-		(uintptr_t)&priv->ctl->dbg1,
-		mmio_read_32((uintptr_t)&priv->ctl->dbg1));
+	stm32mp_ddr_enable_host_interface(priv->ctl);
 }
 
-static void stm32mp1_refresh_disable(struct stm32mp1_ddrctl *ctl)
+static void stm32mp1_refresh_disable(struct stm32mp_ddrctl *ctl)
 {
-	stm32mp1_start_sw_done(ctl);
-	/* Quasi-dynamic register update*/
+	/*
+	 * Manage quasi-dynamic registers modification
+	 * dfimisc.dfi_init_complete_en : Group 3
+	 * AXI ports not yet enabled, don't disable them
+	 */
+	stm32mp_ddr_disable_host_interface(ctl);
+	stm32mp_ddr_start_sw_done(ctl);
+
 	mmio_setbits_32((uintptr_t)&ctl->rfshctl3,
 			DDRCTRL_RFSHCTL3_DIS_AUTO_REFRESH);
-	mmio_clrbits_32((uintptr_t)&ctl->pwrctl, DDRCTRL_PWRCTL_POWERDOWN_EN);
+	stm32mp_ddr_wait_refresh_update_done_ack(ctl);
+
+	mmio_clrbits_32((uintptr_t)&ctl->pwrctl, DDRCTRL_PWRCTL_POWERDOWN_EN |
+						 DDRCTRL_PWRCTL_SELFREF_EN);
 	mmio_clrbits_32((uintptr_t)&ctl->dfimisc,
 			DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
-	stm32mp1_wait_sw_done_ack(ctl);
+
+	stm32mp_ddr_wait_sw_done_ack(ctl);
+	stm32mp_ddr_enable_host_interface(ctl);
 }
 
-static void stm32mp1_refresh_restore(struct stm32mp1_ddrctl *ctl,
+static void stm32mp1_refresh_restore(struct stm32mp_ddrctl *ctl,
 				     uint32_t rfshctl3, uint32_t pwrctl)
 {
-	stm32mp1_start_sw_done(ctl);
+	/*
+	 * Manage quasi-dynamic registers modification
+	 * dfimisc.dfi_init_complete_en : Group 3
+	 * AXI ports not yet enabled, don't disable them
+	 */
+	stm32mp_ddr_disable_host_interface(ctl);
+	stm32mp_ddr_start_sw_done(ctl);
+
 	if ((rfshctl3 & DDRCTRL_RFSHCTL3_DIS_AUTO_REFRESH) == 0U) {
 		mmio_clrbits_32((uintptr_t)&ctl->rfshctl3,
 				DDRCTRL_RFSHCTL3_DIS_AUTO_REFRESH);
+		stm32mp_ddr_wait_refresh_update_done_ack(ctl);
 	}
 	if ((pwrctl & DDRCTRL_PWRCTL_POWERDOWN_EN) != 0U) {
 		mmio_setbits_32((uintptr_t)&ctl->pwrctl,
 				DDRCTRL_PWRCTL_POWERDOWN_EN);
 	}
+	if ((pwrctl & DDRCTRL_PWRCTL_SELFREF_EN) != 0U) {
+		mmio_setbits_32((uintptr_t)&ctl->pwrctl,
+				DDRCTRL_PWRCTL_SELFREF_EN);
+	}
 	mmio_setbits_32((uintptr_t)&ctl->dfimisc,
 			DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
-	stm32mp1_wait_sw_done_ack(ctl);
+
+	stm32mp_ddr_wait_sw_done_ack(ctl);
+	stm32mp_ddr_enable_host_interface(ctl);
 }
 
-static int board_ddr_power_init(enum ddr_type ddr_type)
+static void stm32mp1_refresh_cmd(struct stm32mp_ddrctl *ctl)
 {
-	if (dt_pmic_status() > 0) {
-		return pmic_ddr_power_init(ddr_type);
+	uint32_t dbgstat;
+
+	do {
+		dbgstat = mmio_read_32((uintptr_t)&ctl->dbgstat);
+	} while ((dbgstat & DDRCTRL_DBGSTAT_RANK0_REFRESH_BUSY) != 0U);
+
+	mmio_setbits_32((uintptr_t)&ctl->dbgcmd, DDRCTRL_DBGCMD_RANK0_REFRESH);
+}
+
+/* Refresh compensation by forcing refresh command
+ * Rule1: Tref should be always < tREFW ? R x tREBW/8
+ * Rule2: refcomp = RU(Tref/tREFI)  = RU(RxTref/tREFW)
+ */
+static
+void stm32mp1_refresh_compensation(const struct stm32mp_ddr_config *config,
+				   struct stm32mp_ddrctl *ctl,
+				   uint64_t start)
+{
+	uint32_t tck_ps;
+	uint64_t time_us, tref, trefi, refcomp, i;
+
+	time_us = timeout_init_us(0) - start;
+	tck_ps = 1000000000U / config->info.speed;
+	if (tck_ps == 0U) {
+		return;
 	}
+	/* ref = refresh time in tck */
+	tref = time_us * 1000000U / tck_ps;
+	trefi = ((mmio_read_32((uintptr_t)&ctl->rfshtmg) &
+		  DDRCTRL_RFSHTMG_T_RFC_NOM_X1_X32_MASK)
+		 >> DDRCTRL_RFSHTMG_T_RFC_NOM_X1_X32_SHIFT) * 32U;
+	if (trefi == 0U) {
+		return;
+	}
+
+	/* div round up : number of refresh to compensate */
+	refcomp = (tref + trefi - 1U) / trefi;
+
+	for (i = 0; i < refcomp; i++) {
+		stm32mp1_refresh_cmd(ctl);
+	}
+}
+
+static void stm32mp1_self_refresh_zcal(struct stm32mp_ddr_priv *priv, uint32_t zdata)
+{
+	/* sequence for PUBL I/O Data Retention during Power-Down */
 
-	return 0;
+	/* 10. Override ZQ calibration with previously (pre-retention)
+	 *     calibrated values. This is done by writing 1 to ZQ0CRN.ZDEN
+	 *     and the override data to ZQ0CRN.ZDATA.
+	 */
+	mmio_setbits_32((uintptr_t)&priv->phy->zq0cr0, DDRPHYC_ZQ0CRN_ZDEN);
+
+	mmio_clrsetbits_32((uintptr_t)&priv->phy->zq0cr0,
+			   DDRPHYC_ZQ0CRN_ZDATA_MASK,
+			   zdata << DDRPHYC_ZQ0CRN_ZDATA_SHIFT);
+
+	/* 11. De-assert the PHY_top data retention enable signals
+	 *     (ret_en or ret_en_i/ret_en_n_i).
+	 */
+	mmio_setbits_32((uintptr_t)(priv->pwr) + PWR_CR3, PWR_CR3_DDRSRDIS);
+	mmio_clrbits_32((uintptr_t)(priv->pwr) + PWR_CR3, PWR_CR3_DDRRETEN);
+
+	/* 12. Remove ZQ calibration override by writing 0 to ZQ0CRN.ZDEN. */
+	mmio_clrbits_32((uintptr_t)&priv->phy->zq0cr0, DDRPHYC_ZQ0CRN_ZDEN);
+
+	/* 13. Trigger ZQ calibration by writing 1 to PIR.INIT
+	 *     and '1' to PIR.ZCAL
+	 */
+	/* 14. Wait for ZQ calibration to finish by polling a 1 status
+	 * on PGSR.IDONE.
+	 */
+	stm32mp1_ddrphy_init(priv->phy, DDRPHYC_PIR_ZCAL);
 }
 
-void stm32mp1_ddr_init(struct ddr_info *priv,
-		       struct stm32mp1_ddr_config *config)
+void stm32mp1_ddr_init(struct stm32mp_ddr_priv *priv,
+		       struct stm32mp_ddr_config *config)
 {
-	uint32_t pir;
+	uint32_t pir, ddr_reten;
+	uint64_t time;
 	int ret = -EINVAL;
 
 	if ((config->c_reg.mstr & DDRCTRL_MSTR_DDR3) != 0U) {
-		ret = board_ddr_power_init(STM32MP_DDR3);
+		ret = stm32mp_board_ddr_power_init(STM32MP_DDR3);
 	} else if ((config->c_reg.mstr & DDRCTRL_MSTR_LPDDR2) != 0U) {
-		ret = board_ddr_power_init(STM32MP_LPDDR2);
+		ret = stm32mp_board_ddr_power_init(STM32MP_LPDDR2);
 	} else if ((config->c_reg.mstr & DDRCTRL_MSTR_LPDDR3) != 0U) {
-		ret = board_ddr_power_init(STM32MP_LPDDR3);
+		ret = stm32mp_board_ddr_power_init(STM32MP_LPDDR3);
 	} else {
 		ERROR("DDR type not supported\n");
 	}
@@ -728,8 +681,27 @@ void stm32mp1_ddr_init(struct ddr_info *priv,
 	}
 
 	VERBOSE("name = %s\n", config->info.name);
-	VERBOSE("speed = %d kHz\n", config->info.speed);
+	VERBOSE("speed = %u kHz\n", config->info.speed);
 	VERBOSE("size  = 0x%x\n", config->info.size);
+	if (config->self_refresh) {
+		VERBOSE("sel-refresh exit (zdata = 0x%x)\n", config->zdata);
+	}
+
+	/* Check DDR PHY pads retention */
+	ddr_reten = mmio_read_32((uint32_t)(priv->pwr) + PWR_CR3) &
+		    PWR_CR3_DDRRETEN;
+	if (config->self_refresh) {
+		if (ddr_reten == 0U) {
+			VERBOSE("self-refresh aborted: no retention\n");
+			config->self_refresh = false;
+		}
+	}
+
+	if (!config->self_refresh) {
+		VERBOSE("disable DDR PHY retention\n");
+		mmio_setbits_32((uint32_t)(priv->pwr) + PWR_CR3, PWR_CR3_DDRSRDIS);
+		mmio_clrbits_32((uint32_t)(priv->pwr) + PWR_CR3, PWR_CR3_DDRRETEN);
+	}
 
 	/* DDR INIT SEQUENCE */
 
@@ -762,7 +734,7 @@ void stm32mp1_ddr_init(struct ddr_info *priv,
 	mmio_clrbits_32(priv->rcc + RCC_DDRITFCR, RCC_DDRITFCR_DDRCAPBRST);
 
 	/* 1.4. wait 128 cycles to permit initialization of end logic */
-	udelay(2);
+	udelay(DDR_DELAY_2US);
 	/* For PCLK = 133MHz => 1 us is enough, 2 to allow lower frequency */
 
 	/* 1.5. initialize registers ddr_umctl2 */
@@ -773,7 +745,7 @@ void stm32mp1_ddr_init(struct ddr_info *priv,
 		(uintptr_t)&priv->ctl->dfimisc,
 		mmio_read_32((uintptr_t)&priv->ctl->dfimisc));
 
-	set_reg(priv, REG_REG, &config->c_reg);
+	stm32mp_ddr_set_reg(priv, REG_REG, &config->c_reg, ddr_registers);
 
 	/* DDR3 = don't set DLLOFF for init mode */
 	if ((config->c_reg.mstr &
@@ -787,8 +759,14 @@ void stm32mp1_ddr_init(struct ddr_info *priv,
 			mmio_read_32((uintptr_t)&priv->ctl->mstr));
 	}
 
-	set_reg(priv, REG_TIMING, &config->c_timing);
-	set_reg(priv, REG_MAP, &config->c_map);
+	stm32mp_ddr_set_reg(priv, REG_TIMING, &config->c_timing, ddr_registers);
+	stm32mp_ddr_set_reg(priv, REG_MAP, &config->c_map, ddr_registers);
+
+	/* Keep the controller in self-refresh mode */
+	if (config->self_refresh) {
+		mmio_setbits_32((uintptr_t)&priv->ctl->pwrctl,
+				DDRCTRL_PWRCTL_SELFREF_SW);
+	}
 
 	/* Skip CTRL init, SDRAM init is done by PHY PUBL */
 	mmio_clrsetbits_32((uintptr_t)&priv->ctl->init0,
@@ -798,7 +776,7 @@ void stm32mp1_ddr_init(struct ddr_info *priv,
 		(uintptr_t)&priv->ctl->init0,
 		mmio_read_32((uintptr_t)&priv->ctl->init0));
 
-	set_reg(priv, REG_PERF, &config->c_perf);
+	stm32mp_ddr_set_reg(priv, REG_PERF, &config->c_perf, ddr_registers);
 
 	/*  2. deassert reset signal core_ddrc_rstn, aresetn and presetn */
 	mmio_clrbits_32(priv->rcc + RCC_DDRITFCR, RCC_DDRITFCR_DDRCORERST);
@@ -809,9 +787,8 @@ void stm32mp1_ddr_init(struct ddr_info *priv,
 	 * 3. start PHY init by accessing relevant PUBL registers
 	 *    (DXGCR, DCR, PTR*, MR*, DTPR*)
 	 */
-	set_reg(priv, REGPHY_REG, &config->p_reg);
-	set_reg(priv, REGPHY_TIMING, &config->p_timing);
-	set_reg(priv, REGPHY_CAL, &config->p_cal);
+	stm32mp_ddr_set_reg(priv, REGPHY_REG, &config->p_reg, ddr_registers);
+	stm32mp_ddr_set_reg(priv, REGPHY_TIMING, &config->p_timing, ddr_registers);
 
 	/* DDR3 = don't set DLLOFF for init mode */
 	if ((config->c_reg.mstr &
@@ -843,13 +820,25 @@ void stm32mp1_ddr_init(struct ddr_info *priv,
 		pir |= DDRPHYC_PIR_DRAMRST; /* Only for DDR3 */
 	}
 
+	/* Treat self-refresh exit : hot boot */
+	if (config->self_refresh) {
+		/* DDR in self refresh mode, remove zcal & reset & init */
+		pir &= ~(DDRPHYC_PIR_ZCAL & DDRPHYC_PIR_DRAMRST
+			 & DDRPHYC_PIR_DRAMINIT);
+		pir |= DDRPHYC_PIR_ZCALBYP;
+	}
+
 	stm32mp1_ddrphy_init(priv->phy, pir);
 
+	if (config->self_refresh) {
+		stm32mp1_self_refresh_zcal(priv, config->zdata);
+	}
+
 	/*
 	 *  6. SET DFIMISC.dfi_init_complete_en to 1
 	 *  Enable quasi-dynamic register programming.
 	 */
-	stm32mp1_start_sw_done(priv->ctl);
+	stm32mp_ddr_start_sw_done(priv->ctl);
 
 	mmio_setbits_32((uintptr_t)&priv->ctl->dfimisc,
 			DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
@@ -857,7 +846,7 @@ void stm32mp1_ddr_init(struct ddr_info *priv,
 		(uintptr_t)&priv->ctl->dfimisc,
 		mmio_read_32((uintptr_t)&priv->ctl->dfimisc));
 
-	stm32mp1_wait_sw_done_ack(priv->ctl);
+	stm32mp_ddr_wait_sw_done_ack(priv->ctl);
 
 	/*
 	 *  7. Wait for DWC_ddr_umctl2 to move to normal operation mode
@@ -865,6 +854,12 @@ void stm32mp1_ddr_init(struct ddr_info *priv,
 	 */
 
 	/* Wait uMCTL2 ready */
+
+	/* Trigger self-refresh exit */
+	if (config->self_refresh) {
+		stm32mp_ddr_sw_selfref_exit(priv->ctl);
+	}
+
 	stm32mp1_wait_operating_mode(priv, DDRCTRL_STAT_OPERATING_MODE_NORMAL);
 
 	/* Switch to DLL OFF mode */
@@ -872,7 +867,9 @@ void stm32mp1_ddr_init(struct ddr_info *priv,
 		stm32mp1_ddr3_dll_off(priv);
 	}
 
-	VERBOSE("DDR DQS training : ");
+	VERBOSE("DDR DQS training.\n");
+
+	time = timeout_init_us(0);
 
 	/*
 	 *  8. Disable Auto refresh and power down by setting
@@ -891,30 +888,28 @@ void stm32mp1_ddr_init(struct ddr_info *priv,
 	/*
 	 * 10. configure PUBL PIR register to specify which training step
 	 * to run
-	 * Warning : RVTRN  is not supported by this PUBL
+	 * RVTRN is executed only on LPDDR2/LPDDR3
 	 */
-	stm32mp1_ddrphy_init(priv->phy, DDRPHYC_PIR_QSTRN);
+	pir = DDRPHYC_PIR_QSTRN;
+	if ((config->c_reg.mstr & DDRCTRL_MSTR_DDR3) == 0U) {
+		pir |= DDRPHYC_PIR_RVTRN;
+	}
 
-	/* 11. monitor PUB PGSR.IDONE to poll cpmpletion of training sequence */
+	stm32mp1_ddrphy_init(priv->phy, pir);
+
+	/* 11. monitor PUB PGSR.IDONE to poll completion of training sequence */
 	stm32mp1_ddrphy_idone_wait(priv->phy);
 
+	/* Refresh compensation: forcing refresh command */
+	if (config->self_refresh) {
+		stm32mp1_refresh_compensation(config, priv->ctl, time);
+	}
+
 	/*
 	 * 12. set back registers in step 8 to the orginal values if desidered
 	 */
 	stm32mp1_refresh_restore(priv->ctl, config->c_reg.rfshctl3,
 				 config->c_reg.pwrctl);
 
-	/* Enable uMCTL2 AXI port 0 */
-	mmio_setbits_32((uintptr_t)&priv->ctl->pctrl_0,
-			DDRCTRL_PCTRL_N_PORT_EN);
-	VERBOSE("[0x%lx] pctrl_0 = 0x%x\n",
-		(uintptr_t)&priv->ctl->pctrl_0,
-		mmio_read_32((uintptr_t)&priv->ctl->pctrl_0));
-
-	/* Enable uMCTL2 AXI port 1 */
-	mmio_setbits_32((uintptr_t)&priv->ctl->pctrl_1,
-			DDRCTRL_PCTRL_N_PORT_EN);
-	VERBOSE("[0x%lx] pctrl_1 = 0x%x\n",
-		(uintptr_t)&priv->ctl->pctrl_1,
-		mmio_read_32((uintptr_t)&priv->ctl->pctrl_1));
+	stm32mp_ddr_enable_axi_port(priv->ctl);
 }
diff --git a/drivers/st/ddr/stm32mp1_ddr_helpers.c b/drivers/st/ddr/stm32mp1_ddr_helpers.c
index fcb4cfcfd..facac102b 100644
--- a/drivers/st/ddr/stm32mp1_ddr_helpers.c
+++ b/drivers/st/ddr/stm32mp1_ddr_helpers.c
@@ -1,13 +1,20 @@
 /*
- * Copyright (c) 2017-2019, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2017-2022, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
 #include <platform_def.h>
 
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32mp_ddr.h>
+#include <drivers/st/stm32mp1_ddr.h>
 #include <drivers/st/stm32mp1_ddr_helpers.h>
+#include <drivers/st/stm32mp1_ddr_regs.h>
 #include <lib/mmio.h>
+#include <plat/common/platform.h>
 
 void ddr_enable_clock(void)
 {
@@ -15,10 +22,547 @@ void ddr_enable_clock(void)
 
 	mmio_setbits_32(stm32mp_rcc_base() + RCC_DDRITFCR,
 			RCC_DDRITFCR_DDRC1EN |
+#if STM32MP_DDR_DUAL_AXI_PORT
 			RCC_DDRITFCR_DDRC2EN |
+#endif
 			RCC_DDRITFCR_DDRPHYCEN |
 			RCC_DDRITFCR_DDRPHYCAPBEN |
 			RCC_DDRITFCR_DDRCAPBEN);
 
 	stm32mp1_clk_rcc_regs_unlock();
 }
+
+static int ddr_sw_self_refresh_in(void)
+{
+	uintptr_t rcc_base = stm32mp_rcc_base();
+	uintptr_t pwr_base = stm32mp_pwr_base();
+	uintptr_t ddrctrl_base = stm32mp_ddrctrl_base();
+	uintptr_t ddrphyc_base = stm32mp_ddrphyc_base();
+
+	stm32mp1_clk_rcc_regs_lock();
+
+	mmio_clrbits_32(rcc_base + RCC_DDRITFCR, RCC_DDRITFCR_AXIDCGEN);
+
+	stm32mp1_clk_rcc_regs_unlock();
+
+	/* Blocks AXI ports from taking anymore transactions */
+	if (stm32mp_ddr_disable_axi_port((struct stm32mp_ddrctl *)ddrctrl_base) != 0U) {
+		goto pstat_failed;
+	}
+
+	/* SW Self-Refresh entry */
+	if (stm32mp_ddr_sw_selfref_entry((struct stm32mp_ddrctl *)ddrctrl_base) != 0U) {
+		goto selfref_sw_failed;
+	}
+
+	/* IOs powering down (PUBL registers) */
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_ACIOCR, DDRPHYC_ACIOCR_ACPDD);
+
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_ACIOCR, DDRPHYC_ACIOCR_ACPDR);
+
+	mmio_clrsetbits_32(ddrphyc_base + DDRPHYC_ACIOCR,
+			   DDRPHYC_ACIOCR_CKPDD_MASK,
+			   DDRPHYC_ACIOCR_CKPDD_0);
+
+	mmio_clrsetbits_32(ddrphyc_base + DDRPHYC_ACIOCR,
+			   DDRPHYC_ACIOCR_CKPDR_MASK,
+			   DDRPHYC_ACIOCR_CKPDR_0);
+
+	mmio_clrsetbits_32(ddrphyc_base + DDRPHYC_ACIOCR,
+			   DDRPHYC_ACIOCR_CSPDD_MASK,
+			   DDRPHYC_ACIOCR_CSPDD_0);
+
+	/* Disable command/address output driver */
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_ACIOCR, DDRPHYC_ACIOCR_ACOE);
+
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_DXCCR, DDRPHYC_DXCCR_DXPDD);
+
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_DXCCR, DDRPHYC_DXCCR_DXPDR);
+
+	mmio_clrsetbits_32(ddrphyc_base + DDRPHYC_DSGCR,
+			   DDRPHYC_DSGCR_ODTPDD_MASK,
+			   DDRPHYC_DSGCR_ODTPDD_0);
+
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_DSGCR, DDRPHYC_DSGCR_NL2PD);
+
+	mmio_clrsetbits_32(ddrphyc_base + DDRPHYC_DSGCR,
+			   DDRPHYC_DSGCR_CKEPDD_MASK,
+			   DDRPHYC_DSGCR_CKEPDD_0);
+
+	/* Disable PZQ cell (PUBL register) */
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_ZQ0CR0, DDRPHYC_ZQ0CRN_ZQPD);
+
+	/* Set latch */
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DSGCR, DDRPHYC_DSGCR_CKOE);
+
+	/* Additional delay to avoid early latch */
+	udelay(DDR_DELAY_10US);
+
+	/* Activate sw retention in PWRCTRL */
+	stm32mp_pwr_regs_lock();
+	mmio_setbits_32(pwr_base + PWR_CR3, PWR_CR3_DDRRETEN);
+	stm32mp_pwr_regs_unlock();
+
+	/* Switch controller clocks (uMCTL2/PUBL) to DLL ref clock */
+	stm32mp1_clk_rcc_regs_lock();
+	mmio_setbits_32(rcc_base + RCC_DDRITFCR, RCC_DDRITFCR_GSKPCTRL);
+	stm32mp1_clk_rcc_regs_unlock();
+
+	/* Disable all DLLs: GLITCH window */
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_ACDLLCR,
+			DDRPHYC_ACDLLCR_DLLDIS);
+
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_DX0DLLCR,
+			DDRPHYC_DXNDLLCR_DLLDIS);
+
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_DX1DLLCR,
+			DDRPHYC_DXNDLLCR_DLLDIS);
+
+#if STM32MP_DDR_32BIT_INTERFACE
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_DX2DLLCR,
+			DDRPHYC_DXNDLLCR_DLLDIS);
+
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_DX3DLLCR,
+			DDRPHYC_DXNDLLCR_DLLDIS);
+#endif
+
+	stm32mp1_clk_rcc_regs_lock();
+
+	/* Switch controller clocks (uMCTL2/PUBL) to DLL output clock */
+	mmio_clrbits_32(rcc_base + RCC_DDRITFCR, RCC_DDRITFCR_GSKPCTRL);
+
+	/* Deactivate all DDR clocks */
+	mmio_clrbits_32(rcc_base + RCC_DDRITFCR,
+			RCC_DDRITFCR_DDRC1EN |
+#if STM32MP_DDR_DUAL_AXI_PORT
+			RCC_DDRITFCR_DDRC2EN |
+#endif
+			RCC_DDRITFCR_DDRCAPBEN |
+			RCC_DDRITFCR_DDRPHYCAPBEN);
+
+	stm32mp1_clk_rcc_regs_unlock();
+
+	return 0;
+
+selfref_sw_failed:
+	/* Restore DDR in its previous state */
+	stm32mp_ddr_sw_selfref_exit((struct stm32mp_ddrctl *)ddrctrl_base);
+
+pstat_failed:
+	stm32mp_ddr_enable_axi_port((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	return -1;
+}
+
+int ddr_sw_self_refresh_exit(void)
+{
+	uint64_t timeout;
+	uintptr_t rcc_base = stm32mp_rcc_base();
+	uintptr_t pwr_base = stm32mp_pwr_base();
+	uintptr_t ddrctrl_base = stm32mp_ddrctrl_base();
+	uintptr_t ddrphyc_base = stm32mp_ddrphyc_base();
+
+	/* Enable all clocks */
+	ddr_enable_clock();
+
+	/*
+	 * Manage quasi-dynamic registers modification
+	 * dfimisc.dfi_init_complete_en : Group 3
+	 */
+	stm32mp_ddr_set_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/* Mask dfi_init_complete_en */
+	mmio_clrbits_32(ddrctrl_base + DDRCTRL_DFIMISC,
+			DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
+
+	stm32mp_ddr_unset_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/* Switch controller clocks (uMCTL2/PUBL) to DLL ref clock */
+	stm32mp1_clk_rcc_regs_lock();
+	mmio_setbits_32(rcc_base + RCC_DDRITFCR, RCC_DDRITFCR_GSKPCTRL);
+	stm32mp1_clk_rcc_regs_unlock();
+
+	/* Enable all DLLs: GLITCH window */
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_ACDLLCR,
+			DDRPHYC_ACDLLCR_DLLDIS);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DX0DLLCR,
+			DDRPHYC_DXNDLLCR_DLLDIS);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DX1DLLCR,
+			DDRPHYC_DXNDLLCR_DLLDIS);
+
+#if STM32MP_DDR_32BIT_INTERFACE
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DX2DLLCR,
+			DDRPHYC_DXNDLLCR_DLLDIS);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DX3DLLCR,
+			DDRPHYC_DXNDLLCR_DLLDIS);
+#endif
+
+	/* Additional delay to avoid early DLL clock switch */
+	udelay(DDR_DELAY_50US);
+
+	/* Switch controller clocks (uMCTL2/PUBL) to DLL ref clock */
+	stm32mp1_clk_rcc_regs_lock();
+	mmio_clrbits_32(rcc_base + RCC_DDRITFCR, RCC_DDRITFCR_GSKPCTRL);
+	stm32mp1_clk_rcc_regs_unlock();
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_ACDLLCR,
+			DDRPHYC_ACDLLCR_DLLSRST);
+
+	udelay(DDR_DELAY_10US);
+
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_ACDLLCR,
+			DDRPHYC_ACDLLCR_DLLSRST);
+
+	/* PHY partial init: (DLL lock and ITM reset) */
+	mmio_write_32(ddrphyc_base + DDRPHYC_PIR,
+		      DDRPHYC_PIR_DLLSRST | DDRPHYC_PIR_DLLLOCK |
+		      DDRPHYC_PIR_ITMSRST | DDRPHYC_PIR_INIT);
+
+	/* Need to wait at least 10 clock cycles before accessing PGSR */
+	udelay(DDR_DELAY_1US);
+
+	/* Pool end of init */
+	timeout = timeout_init_us(DDR_TIMEOUT_500US);
+
+	while ((mmio_read_32(ddrphyc_base + DDRPHYC_PGSR) &
+		DDRPHYC_PGSR_IDONE) == 0U) {
+		if (timeout_elapsed(timeout)) {
+			return -1;
+		}
+	}
+
+	/*
+	 * Manage quasi-dynamic registers modification
+	 * dfimisc.dfi_init_complete_en : Group 3
+	 */
+	stm32mp_ddr_set_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/* Unmask dfi_init_complete_en to uMCTL2 */
+	mmio_setbits_32(ddrctrl_base + DDRCTRL_DFIMISC,
+			DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
+
+	stm32mp_ddr_unset_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/* Deactivate sw retention in PWR */
+	stm32mp_pwr_regs_lock();
+	mmio_clrbits_32(pwr_base + PWR_CR3, PWR_CR3_DDRRETEN);
+	stm32mp_pwr_regs_unlock();
+
+	/* Enable PZQ cell (PUBL register) */
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_ZQ0CR0, DDRPHYC_ZQ0CRN_ZQPD);
+
+	/* Enable pad drivers */
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_ACIOCR, DDRPHYC_ACIOCR_ACPDD);
+
+	/* Enable command/address output driver */
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_ACIOCR, DDRPHYC_ACIOCR_ACOE);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_ACIOCR,
+			DDRPHYC_ACIOCR_CKPDD_MASK);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_ACIOCR,
+			DDRPHYC_ACIOCR_CSPDD_MASK);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DXCCR, DDRPHYC_DXCCR_DXPDD);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DXCCR, DDRPHYC_DXCCR_DXPDR);
+
+	/* Release latch */
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_DSGCR, DDRPHYC_DSGCR_CKOE);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DSGCR,
+			DDRPHYC_DSGCR_ODTPDD_MASK);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DSGCR, DDRPHYC_DSGCR_NL2PD);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DSGCR,
+			DDRPHYC_DSGCR_CKEPDD_MASK);
+
+	/* Remove selfrefresh */
+	stm32mp_ddr_sw_selfref_exit((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/* Wait operating_mode == normal */
+	timeout = timeout_init_us(DDR_TIMEOUT_500US);
+	while ((mmio_read_32(ddrctrl_base + DDRCTRL_STAT) &
+		DDRCTRL_STAT_OPERATING_MODE_MASK) !=
+	       DDRCTRL_STAT_OPERATING_MODE_NORMAL) {
+		if (timeout_elapsed(timeout)) {
+			return -1;
+		}
+	}
+
+	/* AXI ports are no longer blocked from taking transactions */
+	stm32mp_ddr_enable_axi_port((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	stm32mp1_clk_rcc_regs_lock();
+
+	mmio_setbits_32(rcc_base + RCC_DDRITFCR, RCC_DDRITFCR_AXIDCGEN);
+
+	stm32mp1_clk_rcc_regs_unlock();
+
+	return 0;
+}
+
+uint32_t ddr_get_io_calibration_val(void)
+{
+	uintptr_t ddrphyc_base = stm32mp_ddrphyc_base();
+
+	return mmio_read_32(ddrphyc_base + DDRPHYC_ZQ0CR0) &
+		DDRPHYC_ZQ0CRN_ZDATA_MASK;
+}
+
+int ddr_standby_sr_entry(void)
+{
+	uintptr_t pwr_base = stm32mp_pwr_base();
+
+	/* Put DDR in Self-Refresh */
+	if (ddr_sw_self_refresh_in() != 0) {
+		return -1;
+	}
+
+	/* Enable I/O retention mode in standby */
+	stm32mp_pwr_regs_lock();
+	mmio_setbits_32(pwr_base + PWR_CR3, PWR_CR3_DDRSREN);
+	stm32mp_pwr_regs_unlock();
+
+	return 0;
+}
+
+static void ddr_sr_mode_ssr(void)
+{
+	uintptr_t rcc_ddritfcr = stm32mp_rcc_base() + RCC_DDRITFCR;
+	uintptr_t ddrctrl_base = stm32mp_ddrctrl_base();
+
+	stm32mp1_clk_rcc_regs_lock();
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRC1LPEN);
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRC1EN);
+
+#if STM32MP_DDR_DUAL_AXI_PORT
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRC2LPEN);
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRC2EN);
+#endif
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRCAPBLPEN);
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRPHYCAPBLPEN);
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRCAPBEN);
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRPHYCAPBEN);
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRPHYCEN);
+
+	mmio_clrbits_32(rcc_ddritfcr, RCC_DDRITFCR_AXIDCGEN);
+
+	mmio_clrbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRCKMOD_MASK);
+
+	stm32mp1_clk_rcc_regs_unlock();
+
+	/*
+	 * Manage quasi-dynamic registers modification
+	 * hwlpctl.hw_lp_en : Group 3
+	 * pwrtmg.selfref_to_x32 & powerdown_to_x32 : Group 4
+	 * Group 3 is the most restrictive, apply its conditions for all
+	 */
+	stm32mp_ddr_set_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/* Disable HW LP interface of uMCTL2 */
+	mmio_clrbits_32(ddrctrl_base + DDRCTRL_HWLPCTL,
+			DDRCTRL_HWLPCTL_HW_LP_EN);
+
+	/* Configure Automatic LP modes of uMCTL2 */
+	mmio_clrsetbits_32(ddrctrl_base + DDRCTRL_PWRTMG,
+			   DDRCTRL_PWRTMG_SELFREF_TO_X32_MASK,
+			   DDRCTRL_PWRTMG_SELFREF_TO_X32_0);
+
+	stm32mp_ddr_unset_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/*
+	 * Disable Clock disable with LP modes
+	 * (used in RUN mode for LPDDR2 with specific timing).
+	 */
+	mmio_clrbits_32(ddrctrl_base + DDRCTRL_PWRCTL,
+			DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE);
+
+	/* Disable automatic Self-Refresh mode */
+	mmio_clrbits_32(ddrctrl_base + DDRCTRL_PWRCTL,
+			DDRCTRL_PWRCTL_SELFREF_EN);
+}
+
+static void ddr_sr_mode_asr(void)
+{
+	uintptr_t rcc_ddritfcr = stm32mp_rcc_base() + RCC_DDRITFCR;
+	uintptr_t ddrctrl_base = stm32mp_ddrctrl_base();
+
+	stm32mp1_clk_rcc_regs_lock();
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_AXIDCGEN);
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRC1LPEN);
+
+#if STM32MP_DDR_DUAL_AXI_PORT
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRC2LPEN);
+#endif
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRPHYCLPEN);
+
+	mmio_clrsetbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRCKMOD_MASK,
+			   RCC_DDRITFCR_DDRCKMOD_ASR1);
+
+	stm32mp1_clk_rcc_regs_unlock();
+
+	/*
+	 * Manage quasi-dynamic registers modification
+	 * hwlpctl.hw_lp_en : Group 3
+	 * pwrtmg.selfref_to_x32 & powerdown_to_x32 : Group 4
+	 * Group 3 is the most restrictive, apply its conditions for all
+	 */
+	stm32mp_ddr_set_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/* Enable HW LP interface of uMCTL2 */
+	mmio_setbits_32(ddrctrl_base + DDRCTRL_HWLPCTL,
+			DDRCTRL_HWLPCTL_HW_LP_EN);
+
+	/* Configure Automatic LP modes of uMCTL2 */
+	mmio_clrsetbits_32(ddrctrl_base + DDRCTRL_PWRTMG,
+			   DDRCTRL_PWRTMG_SELFREF_TO_X32_MASK,
+			   DDRCTRL_PWRTMG_SELFREF_TO_X32_0);
+
+	stm32mp_ddr_unset_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/*
+	 * Enable Clock disable with LP modes
+	 * (used in RUN mode for LPDDR2 with specific timing).
+	 */
+	mmio_setbits_32(ddrctrl_base + DDRCTRL_PWRCTL,
+			DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE);
+
+	/* Enable automatic Self-Refresh for ASR mode */
+	mmio_setbits_32(ddrctrl_base + DDRCTRL_PWRCTL,
+			DDRCTRL_PWRCTL_SELFREF_EN);
+}
+
+static void ddr_sr_mode_hsr(void)
+{
+	uintptr_t rcc_ddritfcr = stm32mp_rcc_base() + RCC_DDRITFCR;
+	uintptr_t ddrctrl_base = stm32mp_ddrctrl_base();
+
+	stm32mp1_clk_rcc_regs_lock();
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_AXIDCGEN);
+
+	mmio_clrbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRC1LPEN);
+
+#if STM32MP_DDR_DUAL_AXI_PORT
+	mmio_clrbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRC2LPEN);
+#endif
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRPHYCLPEN);
+
+	mmio_clrsetbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRCKMOD_MASK,
+			   RCC_DDRITFCR_DDRCKMOD_HSR1);
+
+	stm32mp1_clk_rcc_regs_unlock();
+
+	/*
+	 * Manage quasi-dynamic registers modification
+	 * hwlpctl.hw_lp_en : Group 3
+	 * pwrtmg.selfref_to_x32 & powerdown_to_x32 : Group 4
+	 * Group 3 is the most restrictive, apply its conditions for all
+	 */
+	stm32mp_ddr_set_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/* Enable HW LP interface of uMCTL2 */
+	mmio_setbits_32(ddrctrl_base + DDRCTRL_HWLPCTL,
+			DDRCTRL_HWLPCTL_HW_LP_EN);
+
+	/* Configure Automatic LP modes of uMCTL2 */
+	mmio_clrsetbits_32(ddrctrl_base + DDRCTRL_PWRTMG,
+			   DDRCTRL_PWRTMG_SELFREF_TO_X32_MASK,
+			   DDRCTRL_PWRTMG_SELFREF_TO_X32_0);
+
+	stm32mp_ddr_unset_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/*
+	 * Enable Clock disable with LP modes
+	 * (used in RUN mode for LPDDR2 with specific timing).
+	 */
+	mmio_setbits_32(ddrctrl_base + DDRCTRL_PWRCTL,
+			DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE);
+}
+
+enum stm32mp1_ddr_sr_mode ddr_read_sr_mode(void)
+{
+	uint32_t pwrctl = mmio_read_32(stm32mp_ddrctrl_base() + DDRCTRL_PWRCTL);
+
+	switch (pwrctl & (DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE |
+			  DDRCTRL_PWRCTL_SELFREF_EN)) {
+	case 0U:
+		return DDR_SSR_MODE;
+
+	case DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE:
+		return DDR_HSR_MODE;
+
+	case DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE | DDRCTRL_PWRCTL_SELFREF_EN:
+		return DDR_ASR_MODE;
+
+	default:
+		return DDR_SR_MODE_INVALID;
+	}
+}
+
+void ddr_set_sr_mode(enum stm32mp1_ddr_sr_mode mode)
+{
+	switch (mode) {
+	case DDR_SSR_MODE:
+		ddr_sr_mode_ssr();
+		break;
+
+	case DDR_HSR_MODE:
+		ddr_sr_mode_hsr();
+		break;
+
+	case DDR_ASR_MODE:
+		ddr_sr_mode_asr();
+		break;
+
+	default:
+		ERROR("Unknown Self Refresh mode\n");
+		panic();
+	}
+}
+
+bool ddr_is_nonsecured_area(uintptr_t address, uint32_t length)
+{
+	uint64_t pa;
+
+	write_ats1cpw(address);
+
+	isb();
+
+	pa = read64_par();
+
+	if  ((((pa >> PAR_NS_SHIFT) & PAR_NS_MASK) != PAR_NS_MASK) ||
+	     (((pa >> PAR_F_SHIFT) & PAR_F_MASK) == PAR_F_MASK)) {
+		return false;
+	}
+
+	write_ats1cpw(address + length - 1U);
+
+	isb();
+
+	pa = read64_par();
+
+	if  ((((pa >> PAR_NS_SHIFT) & PAR_NS_MASK) == PAR_NS_MASK) &&
+	     (((pa >> PAR_F_SHIFT) & PAR_F_MASK) != PAR_F_MASK)) {
+		return true;
+	}
+
+	return false;
+}
diff --git a/drivers/st/ddr/stm32mp1_ram.c b/drivers/st/ddr/stm32mp1_ram.c
index b21c8949f..48b287d5b 100644
--- a/drivers/st/ddr/stm32mp1_ram.c
+++ b/drivers/st/ddr/stm32mp1_ram.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2018-2020, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2018-2022, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
  */
@@ -13,25 +13,27 @@
 #include <arch_helpers.h>
 #include <common/debug.h>
 #include <common/fdt_wrappers.h>
+#include <drivers/clk.h>
+#include <drivers/st/stm32mp_ddr.h>
+#include <drivers/st/stm32mp_ddr_test.h>
+#include <drivers/st/stm32mp_ram.h>
 #include <drivers/st/stm32mp1_ddr.h>
 #include <drivers/st/stm32mp1_ddr_helpers.h>
 #include <drivers/st/stm32mp1_ram.h>
 #include <lib/mmio.h>
 
-#define DDR_PATTERN	0xAAAAAAAAU
-#define DDR_ANTIPATTERN	0x55555555U
+static struct stm32mp_ddr_priv ddr_priv_data;
+static bool ddr_self_refresh;
 
-static struct ddr_info ddr_priv_data;
-
-int stm32mp1_ddr_clk_enable(struct ddr_info *priv, uint32_t mem_speed)
+int stm32mp1_ddr_clk_enable(struct stm32mp_ddr_priv *priv, uint32_t mem_speed)
 {
 	unsigned long ddrphy_clk, ddr_clk, mem_speed_hz;
 
 	ddr_enable_clock();
 
-	ddrphy_clk = stm32mp_clk_get_rate(DDRPHYC);
+	ddrphy_clk = clk_get_rate(DDRPHYC);
 
-	VERBOSE("DDR: mem_speed (%d kHz), RCC %ld kHz\n",
+	VERBOSE("DDR: mem_speed (%u kHz), RCC %lu kHz\n",
 		mem_speed, ddrphy_clk / 1000U);
 
 	mem_speed_hz = mem_speed * 1000U;
@@ -43,157 +45,29 @@ int stm32mp1_ddr_clk_enable(struct ddr_info *priv, uint32_t mem_speed)
 		ddr_clk = mem_speed_hz - ddrphy_clk;
 	}
 	if (ddr_clk > (mem_speed_hz / 10)) {
-		ERROR("DDR expected freq %d kHz, current is %ld kHz\n",
+		ERROR("DDR expected freq %u kHz, current is %lu kHz\n",
 		      mem_speed, ddrphy_clk / 1000U);
 		return -1;
 	}
 	return 0;
 }
 
-/*******************************************************************************
- * This function tests the DDR data bus wiring.
- * This is inspired from the Data Bus Test algorithm written by Michael Barr
- * in "Programming Embedded Systems in C and C++" book.
- * resources.oreilly.com/examples/9781565923546/blob/master/Chapter6/
- * File: memtest.c - This source code belongs to Public Domain.
- * Returns 0 if success, and address value else.
- ******************************************************************************/
-static uint32_t ddr_test_data_bus(void)
-{
-	uint32_t pattern;
-
-	for (pattern = 1U; pattern != 0U; pattern <<= 1) {
-		mmio_write_32(STM32MP_DDR_BASE, pattern);
-
-		if (mmio_read_32(STM32MP_DDR_BASE) != pattern) {
-			return (uint32_t)STM32MP_DDR_BASE;
-		}
-	}
-
-	return 0;
-}
-
-/*******************************************************************************
- * This function tests the DDR address bus wiring.
- * This is inspired from the Data Bus Test algorithm written by Michael Barr
- * in "Programming Embedded Systems in C and C++" book.
- * resources.oreilly.com/examples/9781565923546/blob/master/Chapter6/
- * File: memtest.c - This source code belongs to Public Domain.
- * Returns 0 if success, and address value else.
- ******************************************************************************/
-static uint32_t ddr_test_addr_bus(void)
-{
-	uint64_t addressmask = (ddr_priv_data.info.size - 1U);
-	uint64_t offset;
-	uint64_t testoffset = 0;
-
-	/* Write the default pattern at each of the power-of-two offsets. */
-	for (offset = sizeof(uint32_t); (offset & addressmask) != 0U;
-	     offset <<= 1) {
-		mmio_write_32(STM32MP_DDR_BASE + (uint32_t)offset,
-			      DDR_PATTERN);
-	}
-
-	/* Check for address bits stuck high. */
-	mmio_write_32(STM32MP_DDR_BASE + (uint32_t)testoffset,
-		      DDR_ANTIPATTERN);
-
-	for (offset = sizeof(uint32_t); (offset & addressmask) != 0U;
-	     offset <<= 1) {
-		if (mmio_read_32(STM32MP_DDR_BASE + (uint32_t)offset) !=
-		    DDR_PATTERN) {
-			return (uint32_t)(STM32MP_DDR_BASE + offset);
-		}
-	}
-
-	mmio_write_32(STM32MP_DDR_BASE + (uint32_t)testoffset, DDR_PATTERN);
-
-	/* Check for address bits stuck low or shorted. */
-	for (testoffset = sizeof(uint32_t); (testoffset & addressmask) != 0U;
-	     testoffset <<= 1) {
-		mmio_write_32(STM32MP_DDR_BASE + (uint32_t)testoffset,
-			      DDR_ANTIPATTERN);
-
-		if (mmio_read_32(STM32MP_DDR_BASE) != DDR_PATTERN) {
-			return STM32MP_DDR_BASE;
-		}
-
-		for (offset = sizeof(uint32_t); (offset & addressmask) != 0U;
-		     offset <<= 1) {
-			if ((mmio_read_32(STM32MP_DDR_BASE +
-					  (uint32_t)offset) != DDR_PATTERN) &&
-			    (offset != testoffset)) {
-				return (uint32_t)(STM32MP_DDR_BASE + offset);
-			}
-		}
-
-		mmio_write_32(STM32MP_DDR_BASE + (uint32_t)testoffset,
-			      DDR_PATTERN);
-	}
-
-	return 0;
-}
-
-/*******************************************************************************
- * This function checks the DDR size. It has to be run with Data Cache off.
- * This test is run before data have been put in DDR, and is only done for
- * cold boot. The DDR data can then be overwritten, and it is not useful to
- * restore its content.
- * Returns DDR computed size.
- ******************************************************************************/
-static uint32_t ddr_check_size(void)
-{
-	uint32_t offset = sizeof(uint32_t);
-
-	mmio_write_32(STM32MP_DDR_BASE, DDR_PATTERN);
-
-	while (offset < STM32MP_DDR_MAX_SIZE) {
-		mmio_write_32(STM32MP_DDR_BASE + offset, DDR_ANTIPATTERN);
-		dsb();
-
-		if (mmio_read_32(STM32MP_DDR_BASE) != DDR_PATTERN) {
-			break;
-		}
-
-		offset <<= 1;
-	}
-
-	INFO("Memory size = 0x%x (%d MB)\n", offset, offset / (1024U * 1024U));
-
-	return offset;
-}
-
 static int stm32mp1_ddr_setup(void)
 {
-	struct ddr_info *priv = &ddr_priv_data;
+	struct stm32mp_ddr_priv *priv = &ddr_priv_data;
 	int ret;
-	struct stm32mp1_ddr_config config;
-	int node, len;
-	uint32_t uret, idx;
+	struct stm32mp_ddr_config config;
+	int node;
+	uint32_t uret;
 	void *fdt;
 
-#define PARAM(x, y)							\
-	{								\
-		.name = x,						\
-		.offset = offsetof(struct stm32mp1_ddr_config, y),	\
-		.size = sizeof(config.y) / sizeof(uint32_t)		\
-	}
-
-#define CTL_PARAM(x) PARAM("st,ctl-"#x, c_##x)
-#define PHY_PARAM(x) PARAM("st,phy-"#x, p_##x)
-
-	const struct {
-		const char *name; /* Name in DT */
-		const uint32_t offset; /* Offset in config struct */
-		const uint32_t size;   /* Size of parameters */
-	} param[] = {
+	const struct stm32mp_ddr_param param[] = {
 		CTL_PARAM(reg),
 		CTL_PARAM(timing),
 		CTL_PARAM(map),
 		CTL_PARAM(perf),
 		PHY_PARAM(reg),
 		PHY_PARAM(timing),
-		PHY_PARAM(cal)
 	};
 
 	if (fdt_get_address(&fdt) == 0) {
@@ -206,36 +80,21 @@ static int stm32mp1_ddr_setup(void)
 		return -EINVAL;
 	}
 
-	ret = fdt_read_uint32(fdt, node, "st,mem-speed", &config.info.speed);
+	ret = stm32mp_ddr_dt_get_info(fdt, node, &config.info);
 	if (ret < 0) {
-		VERBOSE("%s: no st,mem-speed\n", __func__);
-		return -EINVAL;
+		return ret;
 	}
-	ret = fdt_read_uint32(fdt, node, "st,mem-size", &config.info.size);
+
+	ret = stm32mp_ddr_dt_get_param(fdt, node, param, ARRAY_SIZE(param), (uintptr_t)&config);
 	if (ret < 0) {
-		VERBOSE("%s: no st,mem-size\n", __func__);
-		return -EINVAL;
-	}
-	config.info.name = fdt_getprop(fdt, node, "st,mem-name", &len);
-	if (config.info.name == NULL) {
-		VERBOSE("%s: no st,mem-name\n", __func__);
-		return -EINVAL;
+		return ret;
 	}
-	INFO("RAM: %s\n", config.info.name);
-
-	for (idx = 0; idx < ARRAY_SIZE(param); idx++) {
-		ret = fdt_read_uint32_array(fdt, node, param[idx].name,
-					    param[idx].size,
-					    (void *)((uintptr_t)&config +
-						     param[idx].offset));
-
-		VERBOSE("%s: %s[0x%x] = %d\n", __func__,
-			param[idx].name, param[idx].size, ret);
-		if (ret != 0) {
-			ERROR("%s: Cannot read %s\n",
-			      __func__, param[idx].name);
-			return -EINVAL;
-		}
+
+	config.self_refresh = false;
+
+	if (stm32mp1_is_wakeup_from_standby()) {
+		config.self_refresh = true;
+		config.zdata = stm32_get_zdata_from_context();
 	}
 
 	/* Disable axidcg clock gating during init */
@@ -255,42 +114,72 @@ static int stm32mp1_ddr_setup(void)
 		panic();
 	}
 
-	uret = ddr_test_data_bus();
-	if (uret != 0U) {
-		ERROR("DDR data bus test: can't access memory @ 0x%x\n",
-		      uret);
-		panic();
-	}
+	if (config.self_refresh) {
+		uret = stm32mp_ddr_test_rw_access();
+		if (uret != 0U) {
+			ERROR("DDR rw test: Can't access memory @ 0x%x\n",
+			      uret);
+			panic();
+		}
 
-	uret = ddr_test_addr_bus();
-	if (uret != 0U) {
-		ERROR("DDR addr bus test: can't access memory @ 0x%x\n",
-		      uret);
-		panic();
-	}
+		/* Restore area overwritten by training */
+		stm32_restore_ddr_training_area();
+	} else {
+		uret = stm32mp_ddr_test_data_bus();
+		if (uret != 0U) {
+			ERROR("DDR data bus test: can't access memory @ 0x%x\n",
+			      uret);
+			panic();
+		}
 
-	uret = ddr_check_size();
-	if (uret < config.info.size) {
-		ERROR("DDR size: 0x%x does not match DT config: 0x%x\n",
-		      uret, config.info.size);
-		panic();
+		uret = stm32mp_ddr_test_addr_bus(config.info.size);
+		if (uret != 0U) {
+			ERROR("DDR addr bus test: can't access memory @ 0x%x\n",
+			      uret);
+			panic();
+		}
+
+		uret = stm32mp_ddr_check_size();
+		if (uret < config.info.size) {
+			ERROR("DDR size: 0x%x does not match DT config: 0x%x\n",
+			      uret, config.info.size);
+			panic();
+		}
 	}
 
+	/*
+	 * Initialization sequence has configured DDR registers with settings.
+	 * The Self Refresh (SR) mode corresponding to these settings has now
+	 * to be set.
+	 */
+	ddr_set_sr_mode(ddr_read_sr_mode());
+
 	if (stm32mp_unmap_ddr() != 0) {
 		panic();
 	}
 
+	/* Save DDR self_refresh state */
+	ddr_self_refresh = config.self_refresh;
+
+	/* Flush the value that will be used during MMU OFF sequence */
+	flush_dcache_range((uintptr_t)&ddr_self_refresh, sizeof(ddr_self_refresh));
+
 	return 0;
 }
 
+bool stm32mp1_ddr_is_restored(void)
+{
+	return ddr_self_refresh;
+}
+
 int stm32mp1_ddr_probe(void)
 {
-	struct ddr_info *priv = &ddr_priv_data;
+	struct stm32mp_ddr_priv *priv = &ddr_priv_data;
 
 	VERBOSE("STM32MP DDR probe\n");
 
-	priv->ctl = (struct stm32mp1_ddrctl *)stm32mp_ddrctrl_base();
-	priv->phy = (struct stm32mp1_ddrphy *)stm32mp_ddrphyc_base();
+	priv->ctl = (struct stm32mp_ddrctl *)stm32mp_ddrctrl_base();
+	priv->phy = (struct stm32mp_ddrphy *)stm32mp_ddrphyc_base();
 	priv->pwr = stm32mp_pwr_base();
 	priv->rcc = stm32mp_rcc_base();
 
diff --git a/drivers/st/ddr/stm32mp2_ddr.c b/drivers/st/ddr/stm32mp2_ddr.c
new file mode 100644
index 000000000..a437ffb49
--- /dev/null
+++ b/drivers/st/ddr/stm32mp2_ddr.c
@@ -0,0 +1,411 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <errno.h>
+
+#include <common/debug.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32mp_ddr.h>
+#include <drivers/st/stm32mp2_ddr.h>
+#include <drivers/st/stm32mp2_ddr_regs.h>
+#include <drivers/st/stm32mp2_rcc.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+#define DDRDBG_FRAC_PLL_LOCK	U(0x10)
+
+#define DDRCTL_REG(x, y)					\
+	{							\
+		.name = #x,					\
+		.offset = offsetof(struct stm32mp_ddrctl, x),	\
+		.par_offset = offsetof(struct y, x)		\
+	}
+
+#define DDRPHY_REG(x, y)					\
+	{							\
+		.name = #x,					\
+		.offset = offsetof(struct stm32mp_ddrphy, x),	\
+		.par_offset = offsetof(struct y, x)		\
+	}
+
+/*
+ * PARAMETERS: value get from device tree :
+ *             size / order need to be aligned with binding
+ *             modification NOT ALLOWED !!!
+ */
+#define DDRCTL_REG_REG_SIZE	46	/* st,ctl-reg */
+#define DDRCTL_REG_TIMING_SIZE	20	/* st,ctl-timing */
+#define DDRCTL_REG_MAP_SIZE	12	/* st,ctl-map */
+#if STM32MP_DDR_DUAL_AXI_PORT
+#define DDRCTL_REG_PERF_SIZE	19	/* st,ctl-perf */
+#else
+#define DDRCTL_REG_PERF_SIZE	12	/* st,ctl-perf */
+#endif
+
+#define DDRPHY_REG_REG_SIZE	0	/* st,phy-reg */
+#define	DDRPHY_REG_TIMING_SIZE	0	/* st,phy-timing */
+
+#define DDRCTL_REG_REG(x)	DDRCTL_REG(x, stm32mp2_ddrctrl_reg)
+static const struct stm32mp_ddr_reg_desc ddr_reg[DDRCTL_REG_REG_SIZE] = {
+	DDRCTL_REG_REG(mstr),
+	DDRCTL_REG_REG(mrctrl0),
+	DDRCTL_REG_REG(mrctrl1),
+	DDRCTL_REG_REG(mrctrl2),
+	DDRCTL_REG_REG(derateen),
+	DDRCTL_REG_REG(derateint),
+	DDRCTL_REG_REG(deratectl),
+	DDRCTL_REG_REG(pwrctl),
+	DDRCTL_REG_REG(pwrtmg),
+	DDRCTL_REG_REG(hwlpctl),
+	DDRCTL_REG_REG(rfshctl0),
+	DDRCTL_REG_REG(rfshctl1),
+	DDRCTL_REG_REG(rfshctl3),
+	DDRCTL_REG_REG(crcparctl0),
+	DDRCTL_REG_REG(crcparctl1),
+	DDRCTL_REG_REG(init0),
+	DDRCTL_REG_REG(init1),
+	DDRCTL_REG_REG(init2),
+	DDRCTL_REG_REG(init3),
+	DDRCTL_REG_REG(init4),
+	DDRCTL_REG_REG(init5),
+	DDRCTL_REG_REG(init6),
+	DDRCTL_REG_REG(init7),
+	DDRCTL_REG_REG(dimmctl),
+	DDRCTL_REG_REG(rankctl),
+	DDRCTL_REG_REG(zqctl0),
+	DDRCTL_REG_REG(zqctl1),
+	DDRCTL_REG_REG(zqctl2),
+	DDRCTL_REG_REG(dfitmg0),
+	DDRCTL_REG_REG(dfitmg1),
+	DDRCTL_REG_REG(dfilpcfg0),
+	DDRCTL_REG_REG(dfilpcfg1),
+	DDRCTL_REG_REG(dfiupd0),
+	DDRCTL_REG_REG(dfiupd1),
+	DDRCTL_REG_REG(dfiupd2),
+	DDRCTL_REG_REG(dfimisc),
+	DDRCTL_REG_REG(dfitmg2),
+	DDRCTL_REG_REG(dfitmg3),
+	DDRCTL_REG_REG(dbictl),
+	DDRCTL_REG_REG(dfiphymstr),
+	DDRCTL_REG_REG(dbg0),
+	DDRCTL_REG_REG(dbg1),
+	DDRCTL_REG_REG(dbgcmd),
+	DDRCTL_REG_REG(swctl),
+	DDRCTL_REG_REG(poisoncfg),
+	DDRCTL_REG_REG(pccfg),
+};
+
+#define DDRCTL_REG_TIMING(x)	DDRCTL_REG(x, stm32mp2_ddrctrl_timing)
+static const struct stm32mp_ddr_reg_desc ddr_timing[DDRCTL_REG_TIMING_SIZE] = {
+	DDRCTL_REG_TIMING(rfshtmg),
+	DDRCTL_REG_TIMING(rfshtmg1),
+	DDRCTL_REG_TIMING(dramtmg0),
+	DDRCTL_REG_TIMING(dramtmg1),
+	DDRCTL_REG_TIMING(dramtmg2),
+	DDRCTL_REG_TIMING(dramtmg3),
+	DDRCTL_REG_TIMING(dramtmg4),
+	DDRCTL_REG_TIMING(dramtmg5),
+	DDRCTL_REG_TIMING(dramtmg6),
+	DDRCTL_REG_TIMING(dramtmg7),
+	DDRCTL_REG_TIMING(dramtmg8),
+	DDRCTL_REG_TIMING(dramtmg9),
+	DDRCTL_REG_TIMING(dramtmg10),
+	DDRCTL_REG_TIMING(dramtmg11),
+	DDRCTL_REG_TIMING(dramtmg12),
+	DDRCTL_REG_TIMING(dramtmg13),
+	DDRCTL_REG_TIMING(dramtmg14),
+	DDRCTL_REG_TIMING(dramtmg15),
+	DDRCTL_REG_TIMING(odtcfg),
+	DDRCTL_REG_TIMING(odtmap),
+};
+
+#define DDRCTL_REG_MAP(x)	DDRCTL_REG(x, stm32mp2_ddrctrl_map)
+static const struct stm32mp_ddr_reg_desc ddr_map[DDRCTL_REG_MAP_SIZE] = {
+	DDRCTL_REG_MAP(addrmap0),
+	DDRCTL_REG_MAP(addrmap1),
+	DDRCTL_REG_MAP(addrmap2),
+	DDRCTL_REG_MAP(addrmap3),
+	DDRCTL_REG_MAP(addrmap4),
+	DDRCTL_REG_MAP(addrmap5),
+	DDRCTL_REG_MAP(addrmap6),
+	DDRCTL_REG_MAP(addrmap7),
+	DDRCTL_REG_MAP(addrmap8),
+	DDRCTL_REG_MAP(addrmap9),
+	DDRCTL_REG_MAP(addrmap10),
+	DDRCTL_REG_MAP(addrmap11),
+};
+
+#define DDRCTL_REG_PERF(x)	DDRCTL_REG(x, stm32mp2_ddrctrl_perf)
+static const struct stm32mp_ddr_reg_desc ddr_perf[DDRCTL_REG_PERF_SIZE] = {
+	DDRCTL_REG_PERF(sched),
+	DDRCTL_REG_PERF(sched1),
+	DDRCTL_REG_PERF(perfhpr1),
+	DDRCTL_REG_PERF(perflpr1),
+	DDRCTL_REG_PERF(perfwr1),
+	DDRCTL_REG_PERF(pcfgr_0),
+	DDRCTL_REG_PERF(pcfgw_0),
+	DDRCTL_REG_PERF(pctrl_0),
+	DDRCTL_REG_PERF(pcfgqos0_0),
+	DDRCTL_REG_PERF(pcfgqos1_0),
+	DDRCTL_REG_PERF(pcfgwqos0_0),
+	DDRCTL_REG_PERF(pcfgwqos1_0),
+#if STM32MP_DDR_DUAL_AXI_PORT
+	DDRCTL_REG_PERF(pcfgr_1),
+	DDRCTL_REG_PERF(pcfgw_1),
+	DDRCTL_REG_PERF(pctrl_1),
+	DDRCTL_REG_PERF(pcfgqos0_1),
+	DDRCTL_REG_PERF(pcfgqos1_1),
+	DDRCTL_REG_PERF(pcfgwqos0_1),
+	DDRCTL_REG_PERF(pcfgwqos1_1),
+#endif
+};
+
+static const struct stm32mp_ddr_reg_desc ddrphy_reg[DDRPHY_REG_REG_SIZE] = {};
+
+static const struct stm32mp_ddr_reg_desc ddrphy_timing[DDRPHY_REG_TIMING_SIZE] = {};
+
+/*
+ * REGISTERS ARRAY: used to parse device tree and interactive mode
+ */
+static const struct stm32mp_ddr_reg_info ddr_registers[REG_TYPE_NB] __unused = {
+	[REG_REG] = {
+		.name = "static",
+		.desc = ddr_reg,
+		.size = DDRCTL_REG_REG_SIZE,
+		.base = DDR_BASE
+	},
+	[REG_TIMING] = {
+		.name = "timing",
+		.desc = ddr_timing,
+		.size = DDRCTL_REG_TIMING_SIZE,
+		.base = DDR_BASE
+	},
+	[REG_PERF] = {
+		.name = "perf",
+		.desc = ddr_perf,
+		.size = DDRCTL_REG_PERF_SIZE,
+		.base = DDR_BASE
+	},
+	[REG_MAP] = {
+		.name = "map",
+		.desc = ddr_map,
+		.size = DDRCTL_REG_MAP_SIZE,
+		.base = DDR_BASE
+	},
+	[REGPHY_REG] = {
+		.name = "static",
+		.desc = ddrphy_reg,
+		.size = DDRPHY_REG_REG_SIZE,
+		.base = DDRPHY_BASE
+	},
+	[REGPHY_TIMING] = {
+		.name = "timing",
+		.desc = ddrphy_timing,
+		.size = DDRPHY_REG_TIMING_SIZE,
+		.base = DDRPHY_BASE
+	},
+};
+
+static void ddr_reset(struct stm32mp_ddr_priv *priv)
+{
+	udelay(DDR_DELAY_1US);
+
+	mmio_write_32(priv->rcc + RCC_DDRITFCFGR, RCC_DDRITFCFGR_DDRRST);
+	mmio_write_32(priv->rcc + RCC_DDRPHYCAPBCFGR,
+		      RCC_DDRPHYCAPBCFGR_DDRPHYCAPBEN | RCC_DDRPHYCAPBCFGR_DDRPHYCAPBLPEN |
+		      RCC_DDRPHYCAPBCFGR_DDRPHYCAPBRST);
+	mmio_write_32(priv->rcc + RCC_DDRCAPBCFGR,
+		      RCC_DDRCAPBCFGR_DDRCAPBEN | RCC_DDRCAPBCFGR_DDRCAPBLPEN |
+		      RCC_DDRCAPBCFGR_DDRCAPBRST);
+	mmio_write_32(priv->rcc + RCC_DDRCFGR,
+		      RCC_DDRCFGR_DDRCFGEN | RCC_DDRCFGR_DDRCFGLPEN | RCC_DDRCFGR_DDRCFGRST);
+
+	udelay(DDR_DELAY_1US);
+
+	mmio_write_32(priv->rcc + RCC_DDRITFCFGR, RCC_DDRITFCFGR_DDRRST);
+	mmio_write_32(priv->rcc + RCC_DDRPHYCAPBCFGR,
+		      RCC_DDRPHYCAPBCFGR_DDRPHYCAPBEN | RCC_DDRPHYCAPBCFGR_DDRPHYCAPBLPEN);
+	mmio_write_32(priv->rcc + RCC_DDRCAPBCFGR,
+		      RCC_DDRCAPBCFGR_DDRCAPBEN | RCC_DDRCAPBCFGR_DDRCAPBLPEN);
+	mmio_write_32(priv->rcc + RCC_DDRCFGR, RCC_DDRCFGR_DDRCFGEN | RCC_DDRCFGR_DDRCFGLPEN);
+
+	udelay(DDR_DELAY_1US);
+}
+
+static void ddr_sysconf_configuration(struct stm32mp_ddr_priv *priv)
+{
+	mmio_write_32(stm32_ddrdbg_get_base() + DDRDBG_LP_DISABLE,
+		      DDRDBG_LP_DISABLE_LPI_XPI_DISABLE | DDRDBG_LP_DISABLE_LPI_DDRC_DISABLE);
+
+	mmio_write_32(stm32_ddrdbg_get_base() + DDRDBG_BYPASS_PCLKEN,
+		      (uint32_t)ddrphy_phyinit_get_user_input_basic_pllbypass_0());
+
+	mmio_write_32(priv->rcc + RCC_DDRPHYCCFGR, RCC_DDRPHYCCFGR_DDRPHYCEN);
+	mmio_write_32(priv->rcc + RCC_DDRITFCFGR, RCC_DDRITFCFGR_DDRRST);
+
+	udelay(DDR_DELAY_1US);
+}
+
+static void disable_refresh(struct stm32mp_ddrctl *ctl)
+{
+	mmio_setbits_32((uintptr_t)&ctl->rfshctl3, DDRCTRL_RFSHCTL3_DIS_AUTO_REFRESH);
+
+	stm32mp_ddr_wait_refresh_update_done_ack(ctl);
+
+	udelay(DDR_DELAY_1US);
+
+	mmio_clrbits_32((uintptr_t)&ctl->pwrctl,
+			DDRCTRL_PWRCTL_POWERDOWN_EN | DDRCTRL_PWRCTL_SELFREF_EN);
+
+	udelay(DDR_DELAY_1US);
+
+	/*
+	 * manage quasi-dynamic registers modification
+	 * dfimisc.dfi_init_complete_en : Group 3
+	 */
+	stm32mp_ddr_set_qd3_update_conditions(ctl);
+
+	udelay(DDR_DELAY_1US);
+
+	mmio_clrbits_32((uintptr_t)&ctl->dfimisc, DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
+
+	udelay(DDR_DELAY_1US);
+
+	stm32mp_ddr_unset_qd3_update_conditions(ctl);
+}
+
+static void enable_refresh(struct stm32mp_ddrctl *ctl)
+{
+	mmio_clrbits_32((uintptr_t)&ctl->pwrctl, DDRCTRL_PWRCTL_SELFREF_SW);
+
+	udelay(DDR_DELAY_1US);
+
+	mmio_clrbits_32((uintptr_t)&ctl->rfshctl3, DDRCTRL_RFSHCTL3_DIS_AUTO_REFRESH);
+
+	stm32mp_ddr_wait_refresh_update_done_ack(ctl);
+}
+
+static void wait_dfi_init_complete(struct stm32mp_ddrctl *ctl)
+{
+	uint64_t timeout;
+	uint32_t dfistat;
+
+	timeout = timeout_init_us(DDR_TIMEOUT_US_1S);
+	do {
+		dfistat = mmio_read_32((uintptr_t)&ctl->dfistat);
+		VERBOSE("[0x%lx] dfistat = 0x%x ", (uintptr_t)&ctl->dfistat, dfistat);
+		if (timeout_elapsed(timeout)) {
+			panic();
+		}
+	} while ((dfistat & DDRCTRL_DFISTAT_DFI_INIT_COMPLETE) == 0U);
+
+	VERBOSE("[0x%lx] dfistat = 0x%x\n", (uintptr_t)&ctl->dfistat, dfistat);
+}
+
+static void activate_controller(struct stm32mp_ddrctl *ctl)
+{
+	stm32mp_ddr_set_qd3_update_conditions(ctl);
+
+	mmio_setbits_32((uintptr_t)&ctl->dfimisc, DDRCTRL_DFIMISC_DFI_INIT_START);
+
+	stm32mp_ddr_unset_qd3_update_conditions(ctl);
+
+	wait_dfi_init_complete(ctl);
+
+	udelay(DDR_DELAY_1US);
+
+	stm32mp_ddr_set_qd3_update_conditions(ctl);
+
+	mmio_clrsetbits_32((uintptr_t)&ctl->dfimisc, DDRCTRL_DFIMISC_DFI_INIT_START,
+			   DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
+
+	udelay(DDR_DELAY_1US);
+
+	stm32mp_ddr_unset_qd3_update_conditions(ctl);
+}
+
+void stm32mp2_ddr_init(struct stm32mp_ddr_priv *priv,
+		       struct stm32mp_ddr_config *config)
+{
+	int ret = -EINVAL;
+	uint32_t ddr_retdis;
+
+	if ((config->c_reg.mstr & DDRCTRL_MSTR_DDR3) != 0U) {
+		ret = stm32mp_board_ddr_power_init(STM32MP_DDR3);
+	} else if ((config->c_reg.mstr & DDRCTRL_MSTR_DDR4) != 0U) {
+		ret = stm32mp_board_ddr_power_init(STM32MP_DDR4);
+	} else if ((config->c_reg.mstr & DDRCTRL_MSTR_LPDDR4) != 0U) {
+		ret = stm32mp_board_ddr_power_init(STM32MP_LPDDR4);
+	} else {
+		ERROR("DDR type not supported\n");
+	}
+
+	if (ret != 0) {
+		panic();
+	}
+
+	VERBOSE("name = %s\n", config->info.name);
+	VERBOSE("speed = %u kHz\n", config->info.speed);
+	VERBOSE("size  = 0x%x\n", config->info.size);
+	if (config->self_refresh) {
+		VERBOSE("sel-refresh exit (zdata = 0x%x)\n", config->zdata);
+	}
+
+	/* Check DDR PHY pads retention */
+	ddr_retdis = mmio_read_32((uint32_t)(priv->pwr) + PWR_CR11) &
+		     PWR_CR11_DDRRETDIS;
+	if (config->self_refresh) {
+		if (ddr_retdis == PWR_CR11_DDRRETDIS) {
+			VERBOSE("self-refresh aborted: no retention\n");
+			config->self_refresh = false;
+		}
+	}
+
+	if (!config->self_refresh) {
+		VERBOSE("disable DDR PHY retention\n");
+		mmio_setbits_32((uint32_t)(priv->pwr) + PWR_CR11, PWR_CR11_DDRRETDIS);
+	}
+
+	ddr_reset(priv);
+
+	ddr_sysconf_configuration(priv);
+
+	stm32mp_ddr_set_reg(priv, REG_REG, &config->c_reg, ddr_registers);
+	stm32mp_ddr_set_reg(priv, REG_TIMING, &config->c_timing, ddr_registers);
+	stm32mp_ddr_set_reg(priv, REG_MAP, &config->c_map, ddr_registers);
+	stm32mp_ddr_set_reg(priv, REG_PERF, &config->c_perf, ddr_registers);
+
+	/*  DDR core and PHY reset de-assert */
+	mmio_clrbits_32(priv->rcc + RCC_DDRITFCFGR, RCC_DDRITFCFGR_DDRRST);
+
+	disable_refresh(priv->ctl);
+
+	if (false /* TODO stm32mp1_is_wakeup_from_standby() */) {
+		/* Initialize DDR by skipping training and disabling result saving */
+		ret = ddrphy_phyinit_sequence(true, false);
+
+		if (ret == 0) {
+			ret = ddrphy_phyinit_restore_sequence();
+		}
+	} else {
+		/* Initialize DDR including training and result saving */
+		ret = ddrphy_phyinit_sequence(false, true);
+	}
+
+	if (ret != 0) {
+		ERROR("DDR PHY init: Error %d\n", ret);
+		panic();
+	}
+
+	activate_controller(priv->ctl);
+
+	enable_refresh(priv->ctl);
+
+	stm32mp_ddr_enable_axi_port(priv->ctl);
+}
diff --git a/drivers/st/ddr/stm32mp2_ddr_helpers.c b/drivers/st/ddr/stm32mp2_ddr_helpers.c
new file mode 100644
index 000000000..11d7e752d
--- /dev/null
+++ b/drivers/st/ddr/stm32mp2_ddr_helpers.c
@@ -0,0 +1,265 @@
+/*
+ * Copyright (c) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <errno.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32mp_ddr.h>
+#include <drivers/st/stm32mp2_ddr.h>
+#include <drivers/st/stm32mp2_ddr_helpers.h>
+#include <drivers/st/stm32mp2_ddr_regs.h>
+#include <lib/mmio.h>
+
+#include <platform_def.h>
+
+/* HW idle period (unit: Multiples of 32 DFI clock cycles) */
+#define HW_IDLE_PERIOD			0x3
+
+static enum stm32mp2_ddr_sr_mode saved_ddr_sr_mode;
+
+#pragma weak stm32_ddrdbg_get_base
+uintptr_t stm32_ddrdbg_get_base(void)
+{
+	return 0U;
+}
+
+static int sr_loop(bool is_entry)
+{
+	uint32_t read_data;
+	uint64_t timeout = timeout_init_us(DDR_TIMEOUT_US_1S);
+	bool repeat_loop = false;
+
+	/* Wait for DDRCTRL to be out of or back to "normal/mission mode" */
+	do {
+		read_data = mmio_read_32(stm32mp_ddrctrl_base() + DDRCTRL_STAT) &
+			    DDRCTRL_STAT_SELFREF_TYPE_MASK;
+
+		if (timeout_elapsed(timeout)) {
+			return -ETIMEDOUT;
+		}
+
+		if (is_entry) {
+			repeat_loop = (read_data == 0x0);
+		} else {
+			repeat_loop = (read_data != 0x0);
+		}
+	} while (repeat_loop);
+
+	return 0;
+}
+
+static int sr_entry_loop(void)
+{
+	return sr_loop(true);
+}
+
+static int sr_exit_loop(void)
+{
+	return sr_loop(false);
+}
+
+static int sr_ssr_set(void)
+{
+	return 0;
+}
+
+static int sr_ssr_entry(void)
+{
+	/* Enable APB access to internal CSR registers */
+	mmio_write_32(stm32mp_ddrphyc_base() + DDRPHY_APBONLY0_MICROCONTMUXSEL, 0);
+
+	/* SW self refresh entry prequested */
+	mmio_write_32(stm32mp_ddrctrl_base() + DDRCTRL_PWRCTL, DDRCTRL_PWRCTL_SELFREF_SW);
+
+	return sr_entry_loop();
+}
+
+static int sr_ssr_exit(void)
+{
+	/* Enable APB access to internal CSR registers */
+	mmio_write_32(stm32mp_ddrphyc_base() + DDRPHY_APBONLY0_MICROCONTMUXSEL, 0);
+
+	/* SW self refresh entry prequested */
+	mmio_write_32(stm32mp_ddrctrl_base() + DDRCTRL_PWRCTL, 0);
+
+	return sr_exit_loop();
+}
+
+static int sr_hsr_set(void)
+{
+	uintptr_t ddrctrl_base = stm32mp_ddrctrl_base();
+
+	mmio_write_32(stm32mp_rcc_base() + RCC_DDRITFCFGR, RCC_DDRITFCFGR_DDRCKMOD_HSR);
+
+	/*
+	 * manage quasi-dynamic registers modification
+	 * hwlpctl.hw_lp_en : Group 2
+	 */
+	if (stm32mp_ddr_sw_selfref_entry((struct stm32mp_ddrctl *)ddrctrl_base) != 0) {
+		panic();
+	}
+	stm32mp_ddr_start_sw_done((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	mmio_write_32(ddrctrl_base + DDRCTRL_HWLPCTL,
+		      DDRCTRL_HWLPCTL_HW_LP_EN | DDRCTRL_HWLPCTL_HW_LP_EXIT_IDLE_EN |
+		      (HW_IDLE_PERIOD << DDRCTRL_HWLPCTL_HW_LP_IDLE_X32_SHIFT));
+
+	stm32mp_ddr_wait_sw_done_ack((struct stm32mp_ddrctl *)ddrctrl_base);
+	stm32mp_ddr_sw_selfref_exit((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	return 0;
+}
+
+static int sr_hsr_entry(void)
+{
+	mmio_write_32(stm32mp_rcc_base() + RCC_DDRCPCFGR, RCC_DDRCPCFGR_DDRCPLPEN);
+
+	return sr_entry_loop(); /* read_data should be equal to 0x223 */
+}
+
+static int sr_hsr_exit(void)
+{
+	mmio_write_32(stm32mp_rcc_base() + RCC_DDRCPCFGR,
+		      RCC_DDRCPCFGR_DDRCPLPEN | RCC_DDRCPCFGR_DDRCPEN);
+
+	/* TODO: check if sr_exit_loop() is needed here */
+
+	return 0;
+}
+
+static int sr_asr_set(void)
+{
+	mmio_write_32(stm32_ddrdbg_get_base() + DDRDBG_LP_DISABLE, 0);
+
+	return 0;
+}
+
+static int sr_asr_entry(void)
+{
+	/*
+	 * Automatically enter into self refresh when there is no ddr traffic
+	 * for the delay programmed into SYSCONF_DDRC_AUTO_SR_DELAY register.
+	 * Default value is 0x20 (unit: Multiples of 32 DFI clock cycles).
+	 */
+	return sr_entry_loop();
+}
+
+static int sr_asr_exit(void)
+{
+	return sr_exit_loop();
+}
+
+int ddr_sw_self_refresh_exit(void)
+{
+	int ret = -1;
+
+	switch (saved_ddr_sr_mode) {
+	case DDR_SSR_MODE:
+		ret = sr_ssr_exit();
+		break;
+	case DDR_HSR_MODE:
+		ret = sr_hsr_exit();
+		break;
+	case DDR_ASR_MODE:
+		ret = sr_asr_exit();
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+uint32_t ddr_get_io_calibration_val(void)
+{
+	/* TODO create related service */
+
+	return 0U;
+}
+
+int ddr_standby_sr_entry(void)
+{
+	int ret = -1;
+
+	switch (saved_ddr_sr_mode) {
+	case DDR_SSR_MODE:
+		ret = sr_ssr_entry();
+		break;
+	case DDR_HSR_MODE:
+		ret = sr_hsr_entry();
+		break;
+	case DDR_ASR_MODE:
+		ret = sr_asr_entry();
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+enum stm32mp2_ddr_sr_mode ddr_read_sr_mode(void)
+{
+	uint32_t pwrctl = mmio_read_32(stm32mp_ddrctrl_base() + DDRCTRL_PWRCTL);
+	enum stm32mp2_ddr_sr_mode mode = DDR_SR_MODE_INVALID;
+
+	switch (pwrctl & (DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE |
+			  DDRCTRL_PWRCTL_SELFREF_EN)) {
+	case 0U:
+		mode = DDR_SSR_MODE;
+		break;
+	case DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE:
+		mode = DDR_HSR_MODE;
+		break;
+	case DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE | DDRCTRL_PWRCTL_SELFREF_EN:
+		mode = DDR_ASR_MODE;
+		break;
+	default:
+		break;
+	}
+
+	return mode;
+}
+
+void ddr_set_sr_mode(enum stm32mp2_ddr_sr_mode mode)
+{
+	int ret = -1;
+
+	if (mode == saved_ddr_sr_mode) {
+		return;
+	}
+
+	switch (mode) {
+	case DDR_SSR_MODE:
+		ret = sr_ssr_set();
+		break;
+	case DDR_HSR_MODE:
+		ret = sr_hsr_set();
+		break;
+	case DDR_ASR_MODE:
+		ret = sr_asr_set();
+		break;
+	default:
+		break;
+	}
+
+	if (ret != 0) {
+		ERROR("Unknown Self Refresh mode\n");
+		panic();
+	}
+}
+
+void ddr_save_sr_mode(void)
+{
+	saved_ddr_sr_mode = ddr_read_sr_mode();
+}
+
+void ddr_restore_sr_mode(void)
+{
+	ddr_set_sr_mode(saved_ddr_sr_mode);
+}
diff --git a/drivers/st/ddr/stm32mp2_ram.c b/drivers/st/ddr/stm32mp2_ram.c
new file mode 100644
index 000000000..7d02c33e3
--- /dev/null
+++ b/drivers/st/ddr/stm32mp2_ram.c
@@ -0,0 +1,215 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ */
+
+#include <errno.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <drivers/clk.h>
+#include <drivers/st/stm32mp_ddr.h>
+#include <drivers/st/stm32mp_ddr_test.h>
+#include <drivers/st/stm32mp_ram.h>
+#include <drivers/st/stm32mp2_ddr.h>
+#include <drivers/st/stm32mp2_ddr_helpers.h>
+#include <drivers/st/stm32mp2_ram.h>
+#include <lib/mmio.h>
+#include <libfdt.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+struct stm32mp2_ddr_ui_config {
+	void *basic;		/* Pointer to user_input basic structure */
+	void *advanced;		/* Pointer to user_input advanced structure */
+	void *mode_register;	/* Pointer to user_input mode register structure */
+	void *swizzle;		/* Pointer to user_input swizzle structure */
+};
+
+static struct stm32mp_ddr_priv ddr_priv_data;
+static bool ddr_self_refresh;
+
+static int ddr_dt_get_ui_param(void *fdt, int node, struct stm32mp2_ddr_ui_config *ui_config)
+{
+	int ret;
+	uint32_t size;
+
+	size = sizeof(struct user_input_basic) / sizeof(int);
+	ret = fdt_read_uint32_array(fdt, node, "st,phy-basic", size, ui_config->basic);
+
+	VERBOSE("%s: %s[0x%x] = %d\n", __func__, "st,phy-basic", size, ret);
+	if (ret != 0) {
+		ERROR("%s: Cannot read %s, error=%d\n", __func__, "st,phy-basic", ret);
+		return -EINVAL;
+	}
+
+	size = sizeof(struct user_input_advanced) / sizeof(int);
+	ret = fdt_read_uint32_array(fdt, node, "st,phy-advanced", size, ui_config->advanced);
+
+	VERBOSE("%s: %s[0x%x] = %d\n", __func__, "st,phy-advanced", size, ret);
+	if (ret != 0) {
+		ERROR("%s: Cannot read %s, error=%d\n", __func__, "st,phy-advanced", ret);
+		return -EINVAL;
+	}
+
+	size = sizeof(struct user_input_mode_register) / sizeof(int);
+	ret = fdt_read_uint32_array(fdt, node, "st,phy-mr", size, ui_config->mode_register);
+
+	VERBOSE("%s: %s[0x%x] = %d\n", __func__, "st,phy-mr", size, ret);
+	if (ret != 0) {
+		ERROR("%s: Cannot read %s, error=%d\n", __func__, "st,phy-mr", ret);
+		return -EINVAL;
+	}
+
+	size = sizeof(struct user_input_swizzle) / sizeof(int);
+	ret = fdt_read_uint32_array(fdt, node, "st,phy-swizzle", size, ui_config->swizzle);
+
+	VERBOSE("%s: %s[0x%x] = %d\n", __func__, "st,phy-swizzle", size, ret);
+	if (ret != 0) {
+		ERROR("%s: Cannot read %s, error=%d\n", __func__, "st,phy-swizzle", ret);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int stm32mp2_ddr_setup(void)
+{
+	struct stm32mp_ddr_priv *priv = &ddr_priv_data;
+	int ret;
+	struct stm32mp_ddr_config config;
+	struct stm32mp2_ddr_ui_config ui_config = {
+		ddrphy_phyinit_get_user_input_basic_base(),
+		ddrphy_phyinit_get_user_input_advanced_base(),
+		ddrphy_phyinit_get_user_input_mode_register_base(),
+		ddrphy_phyinit_get_user_input_swizzle_base(),
+	};
+	int node;
+	uint32_t uret;
+	void *fdt;
+
+	const struct stm32mp_ddr_param param[] = {
+		CTL_PARAM(reg),
+		CTL_PARAM(timing),
+		CTL_PARAM(map),
+		CTL_PARAM(perf)
+	};
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -ENOENT;
+	}
+
+	node = fdt_node_offset_by_compatible(fdt, -1, DT_DDR_COMPAT);
+	if (node < 0) {
+		ERROR("%s: Cannot read DDR node in DT\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = stm32mp_ddr_dt_get_info(fdt, node, &config.info);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = stm32mp_ddr_dt_get_param(fdt, node, param, ARRAY_SIZE(param), (uintptr_t)&config);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = ddr_dt_get_ui_param(fdt, node, &ui_config);
+	if (ret < 0) {
+		return ret;
+	}
+
+	config.self_refresh = false;
+
+	/* TODO if (stm32mp1_is_wakeup_from_standby()) {
+		config.self_refresh = true;
+		config.zdata = stm32_get_zdata_from_context();
+	}*/
+
+	stm32mp2_ddr_init(priv, &config);
+
+	priv->info.size = config.info.size;
+
+	VERBOSE("%s : ram size(%x, %x)\n", __func__,
+		(uint32_t)priv->info.base, (uint32_t)priv->info.size);
+
+	if (stm32mp_map_ddr_non_cacheable() != 0) {
+		panic();
+	}
+
+	if (config.self_refresh) {
+		uret = stm32mp_ddr_test_rw_access();
+		if (uret != 0U) {
+			ERROR("DDR rw test: Can't access memory @ 0x%x\n",
+			      uret);
+			panic();
+		}
+
+		/* TODO Restore area overwritten by training */
+		//stm32_restore_ddr_training_area();
+	} else {
+		uret = stm32mp_ddr_test_data_bus();
+		if (uret != 0U) {
+			ERROR("DDR data bus test: can't access memory @ 0x%x\n",
+			      uret);
+			panic();
+		}
+
+		uret = stm32mp_ddr_test_addr_bus(config.info.size);
+		if (uret != 0U) {
+			ERROR("DDR addr bus test: can't access memory @ 0x%x\n",
+			      uret);
+			panic();
+		}
+
+		uret = stm32mp_ddr_check_size();
+		if (uret < config.info.size) {
+			ERROR("DDR size: 0x%x does not match DT config: 0x%x\n",
+			      uret, config.info.size);
+			panic();
+		}
+	}
+
+	/*
+	 * Initialization sequence has configured DDR registers with settings.
+	 * The Self Refresh (SR) mode corresponding to these settings has now
+	 * to be set.
+	 */
+	ddr_set_sr_mode(ddr_read_sr_mode());
+
+	if (stm32mp_unmap_ddr() != 0) {
+		panic();
+	}
+
+	/* Save DDR self_refresh state */
+	ddr_self_refresh = config.self_refresh;
+
+	return 0;
+}
+
+bool stm32mp2_ddr_is_restored(void)
+{
+	return ddr_self_refresh;
+}
+
+int stm32mp2_ddr_probe(void)
+{
+	struct stm32mp_ddr_priv *priv = &ddr_priv_data;
+
+	VERBOSE("STM32MP DDR probe\n");
+
+	priv->ctl = (struct stm32mp_ddrctl *)stm32mp_ddrctrl_base();
+	priv->phy = (struct stm32mp_ddrphy *)stm32mp_ddrphyc_base();
+	priv->pwr = stm32mp_pwr_base();
+	priv->rcc = stm32mp_rcc_base();
+
+	priv->info.base = STM32MP_DDR_BASE;
+	priv->info.size = 0;
+
+	return stm32mp2_ddr_setup();
+}
diff --git a/drivers/st/ddr/stm32mp_ddr.c b/drivers/st/ddr/stm32mp_ddr.c
new file mode 100644
index 000000000..6e261ba69
--- /dev/null
+++ b/drivers/st/ddr/stm32mp_ddr.c
@@ -0,0 +1,297 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32mp_ddr.h>
+#include <drivers/st/stm32mp_ddrctrl_regs.h>
+#include <drivers/st/stm32mp_pmic.h>
+#include <lib/mmio.h>
+
+#include <platform_def.h>
+
+#define INVALID_OFFSET	0xFFU
+
+static bool axi_port_reenable_request;
+static bool host_interface_reenable_request;
+
+static uintptr_t get_base_addr(const struct stm32mp_ddr_priv *priv, enum stm32mp_ddr_base_type base)
+{
+	if (base == DDRPHY_BASE) {
+		return (uintptr_t)priv->phy;
+	} else {
+		return (uintptr_t)priv->ctl;
+	}
+}
+
+void stm32mp_ddr_set_reg(const struct stm32mp_ddr_priv *priv, enum stm32mp_ddr_reg_type type,
+			 const void *param, const struct stm32mp_ddr_reg_info *ddr_registers)
+{
+	unsigned int i;
+	unsigned int value;
+	enum stm32mp_ddr_base_type base = ddr_registers[type].base;
+	uintptr_t base_addr = get_base_addr(priv, base);
+	const struct stm32mp_ddr_reg_desc *desc = ddr_registers[type].desc;
+
+	VERBOSE("init %s\n", ddr_registers[type].name);
+	for (i = 0; i < ddr_registers[type].size; i++) {
+		uintptr_t ptr = base_addr + desc[i].offset;
+
+		if (desc[i].par_offset == INVALID_OFFSET) {
+			ERROR("invalid parameter offset for %s", desc[i].name);
+			panic();
+		} else {
+			value = *((uint32_t *)((uintptr_t)param +
+					       desc[i].par_offset));
+			mmio_write_32(ptr, value);
+		}
+	}
+}
+
+/* Start quasi dynamic register update */
+void stm32mp_ddr_start_sw_done(struct stm32mp_ddrctl *ctl)
+{
+	mmio_clrbits_32((uintptr_t)&ctl->swctl, DDRCTRL_SWCTL_SW_DONE);
+	VERBOSE("[0x%lx] swctl = 0x%x\n",
+		(uintptr_t)&ctl->swctl,  mmio_read_32((uintptr_t)&ctl->swctl));
+}
+
+/* Wait quasi dynamic register update */
+void stm32mp_ddr_wait_sw_done_ack(struct stm32mp_ddrctl *ctl)
+{
+	uint64_t timeout;
+	uint32_t swstat;
+
+	mmio_setbits_32((uintptr_t)&ctl->swctl, DDRCTRL_SWCTL_SW_DONE);
+	VERBOSE("[0x%lx] swctl = 0x%x\n",
+		(uintptr_t)&ctl->swctl, mmio_read_32((uintptr_t)&ctl->swctl));
+
+	timeout = timeout_init_us(DDR_TIMEOUT_US_1S);
+	do {
+		swstat = mmio_read_32((uintptr_t)&ctl->swstat);
+		VERBOSE("[0x%lx] swstat = 0x%x ",
+			(uintptr_t)&ctl->swstat, swstat);
+		if (timeout_elapsed(timeout)) {
+			panic();
+		}
+	} while ((swstat & DDRCTRL_SWSTAT_SW_DONE_ACK) == 0U);
+
+	VERBOSE("[0x%lx] swstat = 0x%x\n",
+		(uintptr_t)&ctl->swstat, swstat);
+}
+
+void stm32mp_ddr_enable_axi_port(struct stm32mp_ddrctl *ctl)
+{
+	/* Enable uMCTL2 AXI port 0 */
+	mmio_setbits_32((uintptr_t)&ctl->pctrl_0, DDRCTRL_PCTRL_N_PORT_EN);
+	VERBOSE("[0x%lx] pctrl_0 = 0x%x\n", (uintptr_t)&ctl->pctrl_0,
+		mmio_read_32((uintptr_t)&ctl->pctrl_0));
+
+#if STM32MP_DDR_DUAL_AXI_PORT
+	/* Enable uMCTL2 AXI port 1 */
+	mmio_setbits_32((uintptr_t)&ctl->pctrl_1, DDRCTRL_PCTRL_N_PORT_EN);
+	VERBOSE("[0x%lx] pctrl_1 = 0x%x\n", (uintptr_t)&ctl->pctrl_1,
+		mmio_read_32((uintptr_t)&ctl->pctrl_1));
+#endif
+}
+
+int stm32mp_ddr_disable_axi_port(struct stm32mp_ddrctl *ctl)
+{
+	uint64_t timeout;
+	uint32_t pstat;
+
+	/* Disable uMCTL2 AXI port 0 */
+	mmio_clrbits_32((uintptr_t)&ctl->pctrl_0, DDRCTRL_PCTRL_N_PORT_EN);
+	VERBOSE("[0x%lx] pctrl_0 = 0x%x\n", (uintptr_t)&ctl->pctrl_0,
+		mmio_read_32((uintptr_t)&ctl->pctrl_0));
+
+#if STM32MP_DDR_DUAL_AXI_PORT
+	/* Disable uMCTL2 AXI port 1 */
+	mmio_clrbits_32((uintptr_t)&ctl->pctrl_1, DDRCTRL_PCTRL_N_PORT_EN);
+	VERBOSE("[0x%lx] pctrl_1 = 0x%x\n", (uintptr_t)&ctl->pctrl_1,
+		mmio_read_32((uintptr_t)&ctl->pctrl_1));
+#endif
+
+	/*
+	 * Waits until all AXI ports are idle
+	 * Poll PSTAT.rd_port_busy_n = 0
+	 * Poll PSTAT.wr_port_busy_n = 0
+	 */
+	timeout = timeout_init_us(DDR_TIMEOUT_US_1S);
+	do {
+		pstat = mmio_read_32((uintptr_t)&ctl->pstat);
+		VERBOSE("[0x%lx] pstat = 0x%x ",
+			(uintptr_t)&ctl->pstat, pstat);
+		if (timeout_elapsed(timeout)) {
+			return -1;
+		}
+	} while (pstat != 0U);
+
+	return 0;
+}
+
+static bool ddr_is_axi_port_enabled(struct stm32mp_ddrctl *ctl)
+{
+	return (mmio_read_32((uintptr_t)&ctl->pctrl_0) & DDRCTRL_PCTRL_N_PORT_EN) != 0U;
+}
+
+void stm32mp_ddr_enable_host_interface(struct stm32mp_ddrctl *ctl)
+{
+	mmio_clrbits_32((uintptr_t)&ctl->dbg1, DDRCTRL_DBG1_DIS_HIF);
+	VERBOSE("[0x%lx] dbg1 = 0x%x\n",
+		(uintptr_t)&ctl->dbg1,
+		mmio_read_32((uintptr_t)&ctl->dbg1));
+}
+
+void stm32mp_ddr_disable_host_interface(struct stm32mp_ddrctl *ctl)
+{
+	uint64_t timeout;
+	uint32_t dbgcam;
+	int count = 0;
+
+	mmio_setbits_32((uintptr_t)&ctl->dbg1, DDRCTRL_DBG1_DIS_HIF);
+	VERBOSE("[0x%lx] dbg1 = 0x%x\n",
+		(uintptr_t)&ctl->dbg1,
+		mmio_read_32((uintptr_t)&ctl->dbg1));
+
+	/*
+	 * Waits until all queues and pipelines are empty
+	 * Poll DBGCAM.dbg_wr_q_empty = 1
+	 * Poll DBGCAM.dbg_rd_q_empty = 1
+	 * Poll DBGCAM.dbg_wr_data_pipeline_empty = 1
+	 * Poll DBGCAM.dbg_rd_data_pipeline_empty = 1
+	 *
+	 * data_pipeline fields must be polled twice to ensure
+	 * value propoagation, so count is added to loop condition.
+	 */
+	timeout = timeout_init_us(DDR_TIMEOUT_US_1S);
+	do {
+		dbgcam = mmio_read_32((uintptr_t)&ctl->dbgcam);
+		VERBOSE("[0x%lx] dbgcam = 0x%x ",
+			(uintptr_t)&ctl->dbgcam, dbgcam);
+		if (timeout_elapsed(timeout)) {
+			panic();
+		}
+		count++;
+	} while (((dbgcam & DDRCTRL_DBG_Q_AND_DATA_PIPELINE_EMPTY) !=
+		  DDRCTRL_DBG_Q_AND_DATA_PIPELINE_EMPTY) || (count < 2));
+}
+
+static bool ddr_is_host_interface_enabled(struct stm32mp_ddrctl *ctl)
+{
+	return (mmio_read_32((uintptr_t)&ctl->dbg1) & DDRCTRL_DBG1_DIS_HIF) == 0U;
+}
+
+int stm32mp_ddr_sw_selfref_entry(struct stm32mp_ddrctl *ctl)
+{
+	uint64_t timeout;
+	uint32_t stat;
+	uint32_t operating_mode;
+	uint32_t selref_type;
+
+	mmio_setbits_32((uintptr_t)&ctl->pwrctl, DDRCTRL_PWRCTL_SELFREF_SW);
+	VERBOSE("[0x%lx] pwrctl = 0x%x\n",
+		(uintptr_t)&ctl->pwrctl,
+		mmio_read_32((uintptr_t)&ctl->pwrctl));
+
+	/*
+	 * Wait operating mode change in self-refresh mode
+	 * with STAT.operating_mode[1:0]==11.
+	 * Ensure transition to self-refresh was due to software
+	 * by checking also that STAT.selfref_type[1:0]=2.
+	 */
+	timeout = timeout_init_us(DDR_TIMEOUT_500US);
+	while (!timeout_elapsed(timeout)) {
+		stat = mmio_read_32((uintptr_t)&ctl->stat);
+		operating_mode = stat & DDRCTRL_STAT_OPERATING_MODE_MASK;
+		selref_type = stat & DDRCTRL_STAT_SELFREF_TYPE_MASK;
+
+		if ((operating_mode == DDRCTRL_STAT_OPERATING_MODE_SR) &&
+		    (selref_type == DDRCTRL_STAT_SELFREF_TYPE_SR)) {
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+void stm32mp_ddr_sw_selfref_exit(struct stm32mp_ddrctl *ctl)
+{
+	mmio_clrbits_32((uintptr_t)&ctl->pwrctl, DDRCTRL_PWRCTL_SELFREF_SW);
+	VERBOSE("[0x%lx] pwrctl = 0x%x\n",
+		(uintptr_t)&ctl->pwrctl,
+		mmio_read_32((uintptr_t)&ctl->pwrctl));
+}
+
+void stm32mp_ddr_set_qd3_update_conditions(struct stm32mp_ddrctl *ctl)
+{
+	if (ddr_is_axi_port_enabled(ctl)) {
+		if (stm32mp_ddr_disable_axi_port(ctl) != 0) {
+			panic();
+		}
+		axi_port_reenable_request = true;
+	}
+
+	if (ddr_is_host_interface_enabled(ctl)) {
+		stm32mp_ddr_disable_host_interface(ctl);
+		host_interface_reenable_request = true;
+	}
+
+	stm32mp_ddr_start_sw_done(ctl);
+}
+
+void stm32mp_ddr_unset_qd3_update_conditions(struct stm32mp_ddrctl *ctl)
+{
+	stm32mp_ddr_wait_sw_done_ack(ctl);
+
+	if (host_interface_reenable_request) {
+		stm32mp_ddr_enable_host_interface(ctl);
+		host_interface_reenable_request = false;
+	}
+
+	if (axi_port_reenable_request) {
+		stm32mp_ddr_enable_axi_port(ctl);
+		axi_port_reenable_request = false;
+	}
+}
+
+void stm32mp_ddr_wait_refresh_update_done_ack(struct stm32mp_ddrctl *ctl)
+{
+	uint64_t timeout;
+	uint32_t rfshctl3;
+	uint32_t refresh_update_level = DDRCTRL_RFSHCTL3_REFRESH_UPDATE_LEVEL;
+
+	/* Toggle rfshctl3.refresh_update_level */
+	rfshctl3 = mmio_read_32((uintptr_t)&ctl->rfshctl3);
+	if ((rfshctl3 & refresh_update_level) == refresh_update_level) {
+		mmio_setbits_32((uintptr_t)&ctl->rfshctl3, refresh_update_level);
+	} else {
+		mmio_clrbits_32((uintptr_t)&ctl->rfshctl3, refresh_update_level);
+		refresh_update_level = 0U;
+	}
+
+	VERBOSE("[0x%lx] rfshctl3 = 0x%x\n",
+		(uintptr_t)&ctl->rfshctl3, mmio_read_32((uintptr_t)&ctl->rfshctl3));
+
+	timeout = timeout_init_us(DDR_TIMEOUT_US_1S);
+	do {
+		rfshctl3 = mmio_read_32((uintptr_t)&ctl->rfshctl3);
+		VERBOSE("[0x%lx] rfshctl3 = 0x%x ", (uintptr_t)&ctl->rfshctl3, rfshctl3);
+		if (timeout_elapsed(timeout)) {
+			panic();
+		}
+	} while ((rfshctl3 & DDRCTRL_RFSHCTL3_REFRESH_UPDATE_LEVEL) != refresh_update_level);
+
+	VERBOSE("[0x%lx] rfshctl3 = 0x%x\n", (uintptr_t)&ctl->rfshctl3, rfshctl3);
+}
+
+int stm32mp_board_ddr_power_init(enum ddr_type ddr_type)
+{
+	if (dt_pmic_status() > 0) {
+		return pmic_ddr_power_init(ddr_type);
+	}
+
+	return 0;
+}
diff --git a/drivers/st/ddr/stm32mp_ddr_test.c b/drivers/st/ddr/stm32mp_ddr_test.c
new file mode 100644
index 000000000..45920b7f8
--- /dev/null
+++ b/drivers/st/ddr/stm32mp_ddr_test.c
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <platform_def.h>
+
+#include <drivers/st/stm32mp_ddr_test.h>
+
+#include <lib/mmio.h>
+
+#define DDR_PATTERN	0xAAAAAAAAU
+#define DDR_ANTIPATTERN	0x55555555U
+
+/*******************************************************************************
+ * This function tests a simple read/write access to the DDR.
+ * Note that the previous content is restored after test.
+ * Returns 0 if success, and address value else.
+ ******************************************************************************/
+uint32_t stm32mp_ddr_test_rw_access(void)
+{
+	uint32_t saved_value = mmio_read_32(STM32MP_DDR_BASE);
+
+	mmio_write_32(STM32MP_DDR_BASE, DDR_PATTERN);
+
+	if (mmio_read_32(STM32MP_DDR_BASE) != DDR_PATTERN) {
+		return (uint32_t)STM32MP_DDR_BASE;
+	}
+
+	mmio_write_32(STM32MP_DDR_BASE, saved_value);
+
+	return 0;
+}
+
+/*******************************************************************************
+ * This function tests the DDR data bus wiring.
+ * This is inspired from the Data Bus Test algorithm written by Michael Barr
+ * in "Programming Embedded Systems in C and C++" book.
+ * resources.oreilly.com/examples/9781565923546/blob/master/Chapter6/
+ * File: memtest.c - This source code belongs to Public Domain.
+ * Returns 0 if success, and address value else.
+ ******************************************************************************/
+uint32_t stm32mp_ddr_test_data_bus(void)
+{
+	uint32_t pattern;
+
+	for (pattern = 1U; pattern != 0U; pattern <<= 1) {
+		mmio_write_32(STM32MP_DDR_BASE, pattern);
+
+		if (mmio_read_32(STM32MP_DDR_BASE) != pattern) {
+			return (uint32_t)STM32MP_DDR_BASE;
+		}
+	}
+
+	return 0;
+}
+
+/*******************************************************************************
+ * This function tests the DDR address bus wiring.
+ * This is inspired from the Data Bus Test algorithm written by Michael Barr
+ * in "Programming Embedded Systems in C and C++" book.
+ * resources.oreilly.com/examples/9781565923546/blob/master/Chapter6/
+ * File: memtest.c - This source code belongs to Public Domain.
+ * size: size in bytes of the DDR memory device.
+ * Returns 0 if success, and address value else.
+ ******************************************************************************/
+uint32_t stm32mp_ddr_test_addr_bus(uint64_t size)
+{
+	uint64_t addressmask = size - 1U;
+	uint64_t offset;
+	uint64_t testoffset = 0;
+
+	/* Write the default pattern at each of the power-of-two offsets. */
+	for (offset = sizeof(uint32_t); (offset & addressmask) != 0U;
+	     offset <<= 1) {
+		mmio_write_32(STM32MP_DDR_BASE + (uint32_t)offset,
+			      DDR_PATTERN);
+	}
+
+	/* Check for address bits stuck high. */
+	mmio_write_32(STM32MP_DDR_BASE + (uint32_t)testoffset,
+		      DDR_ANTIPATTERN);
+
+	for (offset = sizeof(uint32_t); (offset & addressmask) != 0U;
+	     offset <<= 1) {
+		if (mmio_read_32(STM32MP_DDR_BASE + (uint32_t)offset) !=
+		    DDR_PATTERN) {
+			return (uint32_t)(STM32MP_DDR_BASE + offset);
+		}
+	}
+
+	mmio_write_32(STM32MP_DDR_BASE + (uint32_t)testoffset, DDR_PATTERN);
+
+	/* Check for address bits stuck low or shorted. */
+	for (testoffset = sizeof(uint32_t); (testoffset & addressmask) != 0U;
+	     testoffset <<= 1) {
+		mmio_write_32(STM32MP_DDR_BASE + (uint32_t)testoffset,
+			      DDR_ANTIPATTERN);
+
+		if (mmio_read_32(STM32MP_DDR_BASE) != DDR_PATTERN) {
+			return STM32MP_DDR_BASE;
+		}
+
+		for (offset = sizeof(uint32_t); (offset & addressmask) != 0U;
+		     offset <<= 1) {
+			if ((mmio_read_32(STM32MP_DDR_BASE +
+					  (uint32_t)offset) != DDR_PATTERN) &&
+			    (offset != testoffset)) {
+				return (uint32_t)(STM32MP_DDR_BASE + offset);
+			}
+		}
+
+		mmio_write_32(STM32MP_DDR_BASE + (uint32_t)testoffset,
+			      DDR_PATTERN);
+	}
+
+	return 0;
+}
+
+/*******************************************************************************
+ * This function checks the DDR size. It has to be run with Data Cache off.
+ * This test is run before data have been put in DDR, and is only done for
+ * cold boot. The DDR data can then be overwritten, and it is not useful to
+ * restore its content.
+ * Returns DDR computed size.
+ ******************************************************************************/
+uint32_t stm32mp_ddr_check_size(void)
+{
+	uint32_t offset = sizeof(uint32_t);
+
+	mmio_write_32(STM32MP_DDR_BASE, DDR_PATTERN);
+
+	while (offset < STM32MP_DDR_MAX_SIZE) {
+		mmio_write_32(STM32MP_DDR_BASE + offset, DDR_ANTIPATTERN);
+		dsb();
+
+		if (mmio_read_32(STM32MP_DDR_BASE) != DDR_PATTERN) {
+			break;
+		}
+
+		offset <<= 1;
+	}
+
+	INFO("Memory size = 0x%x (%d MB)\n", offset, offset / (1024U * 1024U));
+
+	return offset;
+}
diff --git a/drivers/st/ddr/stm32mp_ram.c b/drivers/st/ddr/stm32mp_ram.c
new file mode 100644
index 000000000..c20a65f6b
--- /dev/null
+++ b/drivers/st/ddr/stm32mp_ram.c
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <errno.h>
+#include <stdbool.h>
+
+#include <common/fdt_wrappers.h>
+#include <drivers/st/stm32mp_ram.h>
+#include <libfdt.h>
+
+#include <platform_def.h>
+
+int stm32mp_ddr_dt_get_info(void *fdt, int node, struct stm32mp_ddr_info *info)
+{
+	int ret;
+
+	ret = fdt_read_uint32(fdt, node, "st,mem-speed", &info->speed);
+	if (ret < 0) {
+		VERBOSE("%s: no st,mem-speed\n", __func__);
+		return -EINVAL;
+	}
+	ret = fdt_read_uint32(fdt, node, "st,mem-size", &info->size);
+	if (ret < 0) {
+		VERBOSE("%s: no st,mem-size\n", __func__);
+		return -EINVAL;
+	}
+	info->name = fdt_getprop(fdt, node, "st,mem-name", NULL);
+	if (info->name == NULL) {
+		VERBOSE("%s: no st,mem-name\n", __func__);
+		return -EINVAL;
+	}
+
+	INFO("RAM: %s\n", info->name);
+
+	return 0;
+}
+
+int stm32mp_ddr_dt_get_param(void *fdt, int node, const struct stm32mp_ddr_param *param,
+			     uint32_t param_size, uintptr_t config)
+{
+	int ret;
+	uint32_t idx;
+
+	for (idx = 0U; idx < param_size; idx++) {
+		ret = fdt_read_uint32_array(fdt, node, param[idx].name, param[idx].size,
+					    (void *)(config + param[idx].offset));
+
+		VERBOSE("%s: %s[0x%x] = %d\n", __func__, param[idx].name, param[idx].size, ret);
+		if (ret != 0) {
+			ERROR("%s: Cannot read %s, error=%d\n", __func__, param[idx].name, ret);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
diff --git a/drivers/st/etzpc/etzpc.c b/drivers/st/etzpc/etzpc.c
index ff52a22d9..94f3721bd 100644
--- a/drivers/st/etzpc/etzpc.c
+++ b/drivers/st/etzpc/etzpc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2020, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2017-2022, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -66,6 +66,10 @@ struct etzpc_instance {
 /* Only 1 instance of the ETZPC is expected per platform */
 static struct etzpc_instance etzpc_dev;
 
+struct dt_id_attr {
+	fdt32_t id_attr[STM32MP1_ETZPC_MAX_ID];
+};
+
 /*
  * Implementation uses uint8_t to store each securable DECPROT configuration.
  * When resuming from deep suspend, the DECPROT configurations are restored.
@@ -85,6 +89,56 @@ static bool valid_tzma_id(unsigned int id)
 }
 #endif
 
+static int etzpc_dt_conf_decprot(void)
+{
+	const struct dt_id_attr *conf_list;
+	void *fdt;
+	unsigned int i;
+	int len = 0;
+	int node;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -ENOENT;
+	}
+
+	node = fdt_node_offset_by_compatible(fdt, -1, ETZPC_COMPAT);
+	if (node < 0) {
+		return -EIO;
+	}
+
+	conf_list = (const struct dt_id_attr *)fdt_getprop(fdt, node,
+							   "st,decprot", &len);
+	if (conf_list == NULL) {
+		INFO("No ETZPC configuration in DT, use default\n");
+		return 0;
+	}
+
+	for (i = 0U; i < (unsigned int)len / sizeof(uint32_t); i++) {
+		enum etzpc_decprot_attributes attr;
+		uint32_t value;
+		uint32_t id;
+		uint32_t mode;
+
+		value = fdt32_to_cpu(conf_list->id_attr[i]);
+
+		id = ((value >> ETZPC_ID_SHIFT) & ETZPC_ID_MASK);
+		assert(valid_decprot_id(id));
+
+		mode = (value >> ETZPC_MODE_SHIFT) & ETZPC_MODE_MASK;
+		attr = stm32mp_etzpc_binding2decprot(mode);
+
+		stm32mp1_register_etzpc_decprot(id, attr);
+
+		etzpc_configure_decprot(id, attr);
+
+		if ((value & ETZPC_LOCK_MASK) != 0U) {
+			etzpc_lock_decprot(id);
+		}
+	}
+
+	return 0;
+}
+
 /*
  * etzpc_configure_decprot : Load a DECPROT configuration
  * decprot_id : ID of the IP
@@ -225,20 +279,8 @@ uintptr_t etzpc_get_base_address(void)
 int etzpc_init(void)
 {
 	uint32_t hwcfg;
-	int node;
-	struct dt_node_info etzpc_info;
-
-	node = dt_get_node(&etzpc_info, -1, ETZPC_COMPAT);
-	if (node < 0) {
-		return -EIO;
-	}
-
-	/* Check ETZPC is secure only */
-	if (etzpc_info.status != DT_SECURE) {
-		return -EACCES;
-	}
 
-	etzpc_dev.base = etzpc_info.base;
+	etzpc_dev.base = STM32MP1_ETZPC_BASE;
 
 	hwcfg = mmio_read_32(etzpc_dev.base + ETZPC_HWCFGR);
 
@@ -254,5 +296,5 @@ int etzpc_init(void)
 
 	VERBOSE("ETZPC version 0x%x", etzpc_dev.revision);
 
-	return 0;
+	return etzpc_dt_conf_decprot();
 }
diff --git a/drivers/st/fmc/stm32_fmc2_nand.c b/drivers/st/fmc/stm32_fmc2_nand.c
index 453069bae..18195df14 100644
--- a/drivers/st/fmc/stm32_fmc2_nand.c
+++ b/drivers/st/fmc/stm32_fmc2_nand.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2019-2022, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
  */
@@ -14,6 +14,7 @@
 #include <platform_def.h>
 
 #include <common/debug.h>
+#include <drivers/clk.h>
 #include <drivers/delay_timer.h>
 #include <drivers/raw_nand.h>
 #include <drivers/st/stm32_fmc2_nand.h>
@@ -26,13 +27,21 @@
 #define TIMEOUT_US_1_MS			1000U
 
 /* FMC2 Compatibility */
+#if STM32MP13 || STM32MP15
 #define DT_FMC2_EBI_COMPAT		"st,stm32mp1-fmc2-ebi"
 #define DT_FMC2_NFC_COMPAT		"st,stm32mp1-fmc2-nfc"
 #define MAX_CS				2U
+#endif
+#if STM32MP25
+#define DT_FMC2_EBI_COMPAT		"st,stm32mp25-fmc2-ebi"
+#define DT_FMC2_NFC_COMPAT		"st,stm32mp25-fmc2-nfc"
+#define MAX_CS				4U
+#endif
 #define MAX_BANK			5U
 
 /* FMC2 Controller Registers */
 #define FMC2_BCR1			0x00U
+#define FMC2_CFGR			0x20U
 #define FMC2_PCR			0x80U
 #define FMC2_SR				0x84U
 #define FMC2_PMEM			0x88U
@@ -45,9 +54,16 @@
 #define FMC2_BCHDSR2			0x284U
 #define FMC2_BCHDSR3			0x288U
 #define FMC2_BCHDSR4			0x28CU
+#define FMC2_SECCFGR			0x300U
+#define FMC2_CIDCFGR0			0x30CU
+#define FMC2_CIDCFGR(x)			((x) * 0x8U + FMC2_CIDCFGR0)
+#define FMC2_SEMCR0			0x310U
+#define FMC2_SEMCR(x)			((x) * 0x8U + FMC2_SEMCR0)
 
 /* FMC2_BCR1 register */
 #define FMC2_BCR1_FMC2EN		BIT(31)
+/* FMC2_CFGR register */
+#define FMC2_CFGR_FMC2EN		BIT(31)
 /* FMC2_PCR register */
 #define FMC2_PCR_PWAITEN		BIT(1)
 #define FMC2_PCR_PBKEN			BIT(2)
@@ -70,6 +86,7 @@
 #define FMC2_PCR_BCHECC			BIT(24)
 #define FMC2_PCR_WEN			BIT(25)
 /* FMC2_SR register */
+#define FMC2_SR_ISOST			GENMASK_32(1, 0)
 #define FMC2_SR_NWRF			BIT(6)
 /* FMC2_PMEM register*/
 #define FMC2_PMEM_MEMSET(x)		(((x) & GENMASK_32(7, 0)) << 0)
@@ -108,6 +125,16 @@
 #define FMC2_BCHDSR4_EBP7_MASK		GENMASK_32(12, 0)
 #define FMC2_BCHDSR4_EBP8_MASK		GENMASK_32(28, 16)
 #define FMC2_BCHDSR4_EBP8_SHIFT		16U
+/* FMC2_CIDCFGR register */
+#define FMC2_CIDCFGR_CFEN		BIT(0)
+#define FMC2_CIDCFGR_SEMEN		BIT(1)
+#define FMC2_CIDCFGR_SCID_MASK		GENMASK_32(6, 4)
+#define FMC2_CIDCFGR_SCID_SHIFT		4U
+#define FMC2_CIDCFGR_SEMWLC1		BIT(17)
+/* FMC2_SEMCR register */
+#define FMC2_SEMCR_SEM_MUTEX		BIT(0)
+#define FMC2_SEMCR_SEMCID_MASK		GENMASK_32(7, 5)
+#define FMC2_SEMCR_SEMCID_SHIFT		5U
 
 /* Timings */
 #define FMC2_THIZ			0x01U
@@ -116,6 +143,10 @@
 #define FMC2_PCR_TIMING_MASK		GENMASK_32(3, 0)
 #define FMC2_PMEM_PATT_TIMING_MASK	GENMASK_32(7, 0)
 
+#define FMC2_MAX_RESOURCES		6U
+#define FMC2_RESOURCE_CFGR		0U
+#define FMC2_RESOURCE_NAND		5U
+#define FMC2_CID1			1U
 #define FMC2_BBM_LEN			2U
 #define FMC2_MAX_ECC_BYTES		14U
 #define TIMEOUT_US_10_MS		10000U
@@ -148,7 +179,6 @@ struct stm32_fmc2_nfc {
 	uintptr_t reg_base;
 	struct stm32_fmc2_cs_reg cs[MAX_CS];
 	unsigned long clock_id;
-	unsigned int reset_id;
 	uint8_t cs_sel;
 };
 
@@ -162,7 +192,7 @@ static uintptr_t fmc2_base(void)
 static void stm32_fmc2_nand_setup_timing(void)
 {
 	struct stm32_fmc2_nand_timings tims;
-	unsigned long hclk = stm32mp_clk_get_rate(stm32_fmc2.clock_id);
+	unsigned long hclk = clk_get_rate(stm32_fmc2.clock_id);
 	unsigned long hclkp = FMC2_PSEC_PER_MSEC / (hclk / 1000U);
 	unsigned long timing, tar, tclr, thiz, twait;
 	unsigned long tset_mem, tset_att, thold_mem, thold_att;
@@ -658,10 +688,64 @@ static void stm32_fmc2_write_data(struct nand_device *nand,
 	}
 }
 
+#if STM32MP25
+static int stm32_fmc2_check_rif(unsigned int resource)
+{
+	uint32_t cidcfgr;
+	uint32_t semcr;
+	unsigned int cid;
+
+	if (resource >= FMC2_MAX_RESOURCES) {
+		return -EINVAL;
+	}
+
+	cidcfgr = mmio_read_32(fmc2_base() + FMC2_CIDCFGR(resource));
+	if ((cidcfgr & FMC2_CIDCFGR_CFEN) == 0U) {
+		/* CID filtering is turned off: access granted */
+		return 0;
+	}
+
+	if ((cidcfgr & FMC2_CIDCFGR_SEMEN) == 0U) {
+		/* Static CID mode */
+		cid = (cidcfgr & FMC2_CIDCFGR_SCID_MASK) >>
+		      FMC2_CIDCFGR_SCID_SHIFT;
+		if (cid != FMC2_CID1) {
+			ERROR("%s: static CID%u set for resource %u\n",
+			      __func__, cid, resource);
+			return -EACCES;
+		}
+
+		return 0;
+	}
+
+	/* Pass-list with semaphore mode */
+	if ((cidcfgr & FMC2_CIDCFGR_SEMWLC1) != 0U) {
+		ERROR("%s: CID1 is block-listed for resource %u\n",
+		      __func__, resource);
+		return -EACCES;
+	}
+
+	semcr = mmio_read_32(fmc2_base() + FMC2_SEMCR(resource));
+	if ((semcr & FMC2_SEMCR_SEM_MUTEX) != 0U) {
+		mmio_setbits_32(fmc2_base() + FMC2_SEMCR(resource),
+				FMC2_SEMCR_SEM_MUTEX);
+		semcr = mmio_read_32(fmc2_base() + FMC2_SEMCR(resource));
+	}
+
+	cid = (semcr & FMC2_SEMCR_SEMCID_MASK) >> FMC2_SEMCR_SEMCID_SHIFT;
+	if (cid != FMC2_CID1) {
+		ERROR("%s: resource %u is already used by CID%u\n",
+		      __func__, resource, cid);
+		return -EACCES;
+	}
+
+	return 0;
+}
+#endif
+
 static void stm32_fmc2_ctrl_init(void)
 {
 	uint32_t pcr = mmio_read_32(fmc2_base() + FMC2_PCR);
-	uint32_t bcr1 = mmio_read_32(fmc2_base() + FMC2_BCR1);
 
 	/* Enable wait feature and NAND flash memory bank */
 	pcr |= FMC2_PCR_PWAITEN;
@@ -689,9 +773,22 @@ static void stm32_fmc2_ctrl_init(void)
 	pcr |= FMC2_PCR_TAR(FMC2_PCR_TAR_DEFAULT);
 
 	/* Enable FMC2 controller */
-	bcr1 |= FMC2_BCR1_FMC2EN;
+#if STM32MP13 || STM32MP15
+	mmio_setbits_32(fmc2_base() + FMC2_BCR1, FMC2_BCR1_FMC2EN);
+#endif
+#if STM32MP25
+	if ((mmio_read_32(fmc2_base() + FMC2_SR) & FMC2_SR_ISOST) != 0U) {
+		/* FMC2 is disabled */
+		if (stm32_fmc2_check_rif(FMC2_RESOURCE_CFGR) == 0) {
+			mmio_setbits_32(fmc2_base() + FMC2_CFGR,
+					FMC2_CFGR_FMC2EN);
+		} else {
+			/* FMC2 can not be enabled */
+			panic();
+		}
+	}
+#endif
 
-	mmio_write_32(fmc2_base() + FMC2_BCR1, bcr1);
 	mmio_write_32(fmc2_base() + FMC2_PCR, pcr);
 	mmio_write_32(fmc2_base() + FMC2_PMEM, FMC2_PMEM_DEFAULT);
 	mmio_write_32(fmc2_base() + FMC2_PATT, FMC2_PATT_DEFAULT);
@@ -814,12 +911,11 @@ int stm32_fmc2_init(void)
 
 	stm32_fmc2.reg_base = info.base;
 
-	if ((info.clock < 0) || (info.reset < 0)) {
+	if (info.clock < 0) {
 		return -FDT_ERR_BADVALUE;
 	}
 
 	stm32_fmc2.clock_id = (unsigned long)info.clock;
-	stm32_fmc2.reset_id = (unsigned int)info.reset;
 
 	cuint = fdt_getprop(fdt, fmc_ebi_node, "ranges", NULL);
 	if (cuint == NULL) {
@@ -909,17 +1005,38 @@ int stm32_fmc2_init(void)
 	}
 
 	/* Enable Clock */
-	stm32mp_clk_enable(stm32_fmc2.clock_id);
+	clk_enable(stm32_fmc2.clock_id);
 
 	/* Reset IP */
-	ret = stm32mp_reset_assert(stm32_fmc2.reset_id, TIMEOUT_US_1_MS);
-	if (ret != 0) {
-		panic();
+#if STM32MP25
+	if ((info.reset >= 0) &&
+	    (stm32_fmc2_check_rif(FMC2_RESOURCE_CFGR) != -EACCES)) {
+#else
+	if (info.reset >= 0) {
+#endif
+		unsigned int reset_id = (unsigned int)info.reset;
+
+		ret = stm32mp_reset_assert(reset_id, TIMEOUT_US_1_MS);
+		if (ret != 0) {
+			panic();
+		}
+
+		ret = stm32mp_reset_deassert(reset_id, TIMEOUT_US_1_MS);
+		if (ret != 0) {
+			panic();
+		}
 	}
-	ret = stm32mp_reset_deassert(stm32_fmc2.reset_id, TIMEOUT_US_1_MS);
-	if (ret != 0) {
+
+#if STM32MP25
+	/* Check if FMC2 NAND controller can be used */
+	if (stm32_fmc2_check_rif(FMC2_RESOURCE_NAND) == 0) {
+		/* Secure the FMC2 NAND controller */
+		mmio_setbits_32(fmc2_base() + FMC2_SECCFGR,
+				BIT(FMC2_RESOURCE_NAND));
+	} else {
 		panic();
 	}
+#endif
 
 	/* Setup default IP registers */
 	stm32_fmc2_ctrl_init();
diff --git a/drivers/st/gpio/stm32_gpio.c b/drivers/st/gpio/stm32_gpio.c
index 7d63262d7..259445866 100644
--- a/drivers/st/gpio/stm32_gpio.c
+++ b/drivers/st/gpio/stm32_gpio.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2020, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2016-2021, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -14,8 +14,11 @@
 
 #include <common/bl_common.h>
 #include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <drivers/clk.h>
 #include <drivers/st/stm32_gpio.h>
 #include <drivers/st/stm32mp_clkfunc.h>
+#include <dt-bindings/gpio/stm32-gpio.h>
 #include <lib/mmio.h>
 #include <lib/utils_def.h>
 
@@ -25,6 +28,10 @@
 #define DT_GPIO_PIN_MASK	GENMASK(11, 8)
 #define DT_GPIO_MODE_MASK	GENMASK(7, 0)
 
+static void set_gpio(uint32_t bank, uint32_t pin, uint32_t mode, uint32_t type,
+		     uint32_t speed, uint32_t pull, uint32_t od,
+		     uint32_t alternate, uint8_t status);
+
 /*******************************************************************************
  * This function gets GPIO bank node in DT.
  * Returns node offset if status is okay in DT, else return 0
@@ -99,6 +106,8 @@ static int dt_set_gpio_config(void *fdt, int node, uint8_t status)
 		uint32_t pin;
 		uint32_t mode;
 		uint32_t alternate = GPIO_ALTERNATE_(0);
+		uint32_t type;
+		uint32_t od = 0U;
 		int bank_node;
 		int clk;
 
@@ -128,7 +137,23 @@ static int dt_set_gpio_config(void *fdt, int node, uint8_t status)
 		}
 
 		if (fdt_getprop(fdt, node, "drive-open-drain", NULL) != NULL) {
-			mode |= GPIO_OPEN_DRAIN;
+			type = GPIO_TYPE_OPEN_DRAIN;
+		} else {
+			type = GPIO_TYPE_PUSH_PULL;
+		}
+
+		if (fdt_getprop(fdt, node, "output-high", NULL) != NULL) {
+			if (mode == GPIO_MODE_INPUT) {
+				mode = GPIO_MODE_OUTPUT;
+				od = 1U;
+			}
+		}
+
+		if (fdt_getprop(fdt, node, "output-low", NULL) != NULL) {
+			if (mode == GPIO_MODE_INPUT) {
+				mode = GPIO_MODE_OUTPUT;
+				od = 0U;
+			}
 		}
 
 		bank_node = ckeck_gpio_bank(fdt, bank, pinctrl_node);
@@ -145,7 +170,7 @@ static int dt_set_gpio_config(void *fdt, int node, uint8_t status)
 		/* Platform knows the clock: assert it is okay */
 		assert((unsigned long)clk == stm32_get_gpio_bank_clock(bank));
 
-		set_gpio(bank, pin, mode, speed, pull, alternate, status);
+		set_gpio(bank, pin, mode, type, speed, pull, od, alternate, status);
 	}
 
 	return 0;
@@ -159,7 +184,7 @@ static int dt_set_gpio_config(void *fdt, int node, uint8_t status)
 int dt_set_pinctrl_config(int node)
 {
 	const fdt32_t *cuint;
-	int lenp = 0;
+	int lenp;
 	uint32_t i;
 	uint8_t status;
 	void *fdt;
@@ -200,51 +225,53 @@ int dt_set_pinctrl_config(int node)
 	return 0;
 }
 
-void set_gpio(uint32_t bank, uint32_t pin, uint32_t mode, uint32_t speed,
-	      uint32_t pull, uint32_t alternate, uint8_t status)
+static void set_gpio(uint32_t bank, uint32_t pin, uint32_t mode, uint32_t type,
+		     uint32_t speed, uint32_t pull, uint32_t od,
+		     uint32_t alternate, uint8_t status)
 {
 	uintptr_t base = stm32_get_gpio_bank_base(bank);
 	unsigned long clock = stm32_get_gpio_bank_clock(bank);
 
 	assert(pin <= GPIO_PIN_MAX);
 
-	stm32mp_clk_enable(clock);
+	clk_enable(clock);
 
-	mmio_clrbits_32(base + GPIO_MODE_OFFSET,
-			((uint32_t)GPIO_MODE_MASK << (pin << 1)));
-	mmio_setbits_32(base + GPIO_MODE_OFFSET,
-			(mode & ~GPIO_OPEN_DRAIN) << (pin << 1));
+	mmio_clrsetbits_32(base + GPIO_MODE_OFFSET,
+			   (uint32_t)GPIO_MODE_MASK << (pin << 1),
+			   mode << (pin << 1));
 
-	if ((mode & GPIO_OPEN_DRAIN) != 0U) {
-		mmio_setbits_32(base + GPIO_TYPE_OFFSET, BIT(pin));
-	} else {
-		mmio_clrbits_32(base + GPIO_TYPE_OFFSET, BIT(pin));
-	}
+	mmio_clrsetbits_32(base + GPIO_TYPE_OFFSET,
+			   (uint32_t)GPIO_TYPE_MASK << pin,
+			   type << pin);
 
-	mmio_clrbits_32(base + GPIO_SPEED_OFFSET,
-			((uint32_t)GPIO_SPEED_MASK << (pin << 1)));
-	mmio_setbits_32(base + GPIO_SPEED_OFFSET, speed << (pin << 1));
+	mmio_clrsetbits_32(base + GPIO_SPEED_OFFSET,
+			   (uint32_t)GPIO_SPEED_MASK << (pin << 1),
+			   speed << (pin << 1));
 
-	mmio_clrbits_32(base + GPIO_PUPD_OFFSET,
-			((uint32_t)GPIO_PULL_MASK << (pin << 1)));
-	mmio_setbits_32(base + GPIO_PUPD_OFFSET, pull << (pin << 1));
+	mmio_clrsetbits_32(base + GPIO_PUPD_OFFSET,
+			   (uint32_t)GPIO_PULL_MASK << (pin << 1),
+			   pull << (pin << 1));
 
 	if (pin < GPIO_ALT_LOWER_LIMIT) {
-		mmio_clrbits_32(base + GPIO_AFRL_OFFSET,
-				((uint32_t)GPIO_ALTERNATE_MASK << (pin << 2)));
-		mmio_setbits_32(base + GPIO_AFRL_OFFSET,
-				alternate << (pin << 2));
+		mmio_clrsetbits_32(base + GPIO_AFRL_OFFSET,
+				   (uint32_t)GPIO_ALTERNATE_MASK << (pin << 2),
+				   alternate << (pin << 2));
 	} else {
-		mmio_clrbits_32(base + GPIO_AFRH_OFFSET,
-				((uint32_t)GPIO_ALTERNATE_MASK <<
-				 ((pin - GPIO_ALT_LOWER_LIMIT) << 2)));
-		mmio_setbits_32(base + GPIO_AFRH_OFFSET,
-				alternate << ((pin - GPIO_ALT_LOWER_LIMIT) <<
-					      2));
+		size_t shift = (pin - GPIO_ALT_LOWER_LIMIT) << 2;
+
+		mmio_clrsetbits_32(base + GPIO_AFRH_OFFSET,
+				   (uint32_t)GPIO_ALTERNATE_MASK << shift,
+				   alternate << shift);
 	}
 
+	mmio_clrsetbits_32(base + GPIO_OD_OFFSET,
+			   (uint32_t)GPIO_OD_MASK << pin,
+			   od << pin);
+
 	VERBOSE("GPIO %u mode set to 0x%x\n", bank,
 		mmio_read_32(base + GPIO_MODE_OFFSET));
+	VERBOSE("GPIO %u type set to 0x%x\n", bank,
+		mmio_read_32(base + GPIO_TYPE_OFFSET));
 	VERBOSE("GPIO %u speed set to 0x%x\n", bank,
 		mmio_read_32(base + GPIO_SPEED_OFFSET));
 	VERBOSE("GPIO %u mode pull to 0x%x\n", bank,
@@ -253,16 +280,22 @@ void set_gpio(uint32_t bank, uint32_t pin, uint32_t mode, uint32_t speed,
 		mmio_read_32(base + GPIO_AFRL_OFFSET));
 	VERBOSE("GPIO %u mode alternate high to 0x%x\n", bank,
 		mmio_read_32(base + GPIO_AFRH_OFFSET));
+	VERBOSE("GPIO %u output data set to 0x%x\n", bank,
+		mmio_read_32(base + GPIO_OD_OFFSET));
 
-	stm32mp_clk_disable(clock);
+	clk_disable(clock);
 
 	if (status == DT_SECURE) {
 		stm32mp_register_secure_gpio(bank, pin);
+#if !IMAGE_BL2
 		set_gpio_secure_cfg(bank, pin, true);
+#endif
 
 	} else {
 		stm32mp_register_non_secure_gpio(bank, pin);
+#if !IMAGE_BL2
 		set_gpio_secure_cfg(bank, pin, false);
+#endif
 	}
 }
 
@@ -273,7 +306,7 @@ void set_gpio_secure_cfg(uint32_t bank, uint32_t pin, bool secure)
 
 	assert(pin <= GPIO_PIN_MAX);
 
-	stm32mp_clk_enable(clock);
+	clk_enable(clock);
 
 	if (secure) {
 		mmio_setbits_32(base + GPIO_SECR_OFFSET, BIT(pin));
@@ -281,5 +314,83 @@ void set_gpio_secure_cfg(uint32_t bank, uint32_t pin, bool secure)
 		mmio_clrbits_32(base + GPIO_SECR_OFFSET, BIT(pin));
 	}
 
-	stm32mp_clk_disable(clock);
+	clk_disable(clock);
+}
+
+void set_gpio_reset_cfg(uint32_t bank, uint32_t pin)
+{
+	set_gpio(bank, pin, GPIO_MODE_ANALOG, GPIO_TYPE_PUSH_PULL,
+		 GPIO_SPEED_LOW, GPIO_NO_PULL, 0U, GPIO_ALTERNATE_(0), DT_DISABLED);
+	set_gpio_secure_cfg(bank, pin, stm32_gpio_is_secure_at_reset(bank));
+}
+
+void set_gpio_level(uint32_t bank, uint32_t pin, enum gpio_level level)
+{
+	uintptr_t base = stm32_get_gpio_bank_base(bank);
+	unsigned long clock = stm32_get_gpio_bank_clock(bank);
+
+	assert(pin <= GPIO_PIN_MAX);
+
+	clk_enable(clock);
+
+	if (level == GPIO_LEVEL_HIGH) {
+		mmio_write_32(base + GPIO_BSRR_OFFSET, BIT(pin));
+	} else {
+		mmio_write_32(base + GPIO_BSRR_OFFSET, BIT(pin + 16U));
+	}
+
+	VERBOSE("GPIO %u level set to 0x%x\n", bank,
+		mmio_read_32(base + GPIO_IDR_OFFSET));
+
+	clk_disable(clock);
+}
+
+enum gpio_level get_gpio_level(uint32_t bank, uint32_t pin)
+{
+	uintptr_t base = stm32_get_gpio_bank_base(bank);
+	unsigned long clock = stm32_get_gpio_bank_clock(bank);
+	enum gpio_level level = GPIO_LEVEL_LOW;
+
+	assert(pin <= GPIO_PIN_MAX);
+
+	clk_enable(clock);
+
+	if (mmio_read_32(base + GPIO_IDR_OFFSET) & BIT(pin)) {
+		level = GPIO_LEVEL_HIGH;
+	}
+
+	VERBOSE("GPIO %u get level 0x%x\n", bank,
+		mmio_read_32(base + GPIO_IDR_OFFSET));
+
+	clk_disable(clock);
+
+	return level;
+}
+
+void set_gpio_config(uint32_t bank, uint32_t pin, uint32_t config, uint8_t status)
+{
+	uint32_t mode = GPIO_MODE_OUTPUT;
+	uint32_t od = 0U;
+	uint32_t pull = GPIO_NO_PULL;
+
+	VERBOSE("GPIO %u:%u set config to 0x%x\n", bank, pin, config);
+
+	if (config & GPIOF_DIR_IN) {
+		mode = GPIO_MODE_INPUT;
+	}
+
+	if (config & GPIOF_OUT_INIT_HIGH) {
+		od = 1U;
+	}
+
+	if (config & GPIOF_PULL_UP) {
+		pull |= GPIO_PULL_UP;
+	}
+
+	if (config & GPIOF_PULL_DOWN) {
+		pull |= GPIO_PULL_DOWN;
+	}
+
+	set_gpio(bank, pin, mode, GPIO_TYPE_PUSH_PULL, GPIO_SPEED_LOW,
+		 pull, od, GPIO_ALTERNATE_(0), status);
 }
diff --git a/drivers/st/i2c/stm32_i2c.c b/drivers/st/i2c/stm32_i2c.c
index ed880522b..068a99810 100644
--- a/drivers/st/i2c/stm32_i2c.c
+++ b/drivers/st/i2c/stm32_i2c.c
@@ -1,10 +1,11 @@
 /*
- * Copyright (c) 2016-2019, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2016-2021, STMicroelectronics - All Rights Reserved
  *
- * SPDX-License-Identifier: BSD-3-Clause
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
  */
 
 #include <errno.h>
+#include <limits.h>
 #include <stdbool.h>
 #include <stdlib.h>
 
@@ -13,6 +14,8 @@
 #include <platform_def.h>
 
 #include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <drivers/clk.h>
 #include <drivers/delay_timer.h>
 #include <drivers/st/stm32_gpio.h>
 #include <drivers/st/stm32_i2c.h>
@@ -38,8 +41,87 @@
 
 #define I2C_NSEC_PER_SEC	1000000000L
 
-/* I2C Timing hard-coded value, for I2C clock source is HSI at 64MHz */
-#define I2C_TIMING			0x10D07DB5
+/*
+ * struct i2c_spec_s - Private I2C timing specifications.
+ * @rate: I2C bus speed (Hz)
+ * @fall_max: Max fall time of both SDA and SCL signals (ns)
+ * @rise_max: Max rise time of both SDA and SCL signals (ns)
+ * @hddat_min: Min data hold time (ns)
+ * @vddat_max: Max data valid time (ns)
+ * @sudat_min: Min data setup time (ns)
+ * @l_min: Min low period of the SCL clock (ns)
+ * @h_min: Min high period of the SCL clock (ns)
+ */
+struct i2c_spec_s {
+	uint32_t rate;
+	uint32_t fall_max;
+	uint32_t rise_max;
+	uint32_t hddat_min;
+	uint32_t vddat_max;
+	uint32_t sudat_min;
+	uint32_t l_min;
+	uint32_t h_min;
+};
+
+/*
+ * struct i2c_timing_s - Private I2C output parameters.
+ * @scldel: Data setup time
+ * @sdadel: Data hold time
+ * @sclh: SCL high period (master mode)
+ * @sclh: SCL low period (master mode)
+ * @is_saved: True if relating to a configuration candidate
+ */
+struct i2c_timing_s {
+	uint8_t scldel;
+	uint8_t sdadel;
+	uint8_t sclh;
+	uint8_t scll;
+	bool is_saved;
+};
+
+/*
+ * I2C specification values as per version 6.0, 4th of April 2014 [1],
+ * table 10 page 48: Characteristics of the SDA and SCL bus lines for
+ * Standard, Fast, and Fast-mode Plus I2C-bus devices.
+ *
+ * [1] https://www.i2c-bus.org/specification/
+ */
+static const struct i2c_spec_s i2c_specs[] = {
+	/* Standard - 100KHz */
+	{
+		.rate = STANDARD_RATE,
+		.fall_max = 300,
+		.rise_max = 1000,
+		.hddat_min = 0,
+		.vddat_max = 3450,
+		.sudat_min = 250,
+		.l_min = 4700,
+		.h_min = 4000,
+	},
+	/* Fast - 400KHz */
+	{
+		.rate = FAST_RATE,
+		.fall_max = 300,
+		.rise_max = 300,
+		.hddat_min = 0,
+		.vddat_max = 900,
+		.sudat_min = 100,
+		.l_min = 1300,
+		.h_min = 600,
+	},
+	/* FastPlus - 1MHz */
+	{
+		.rate = FAST_PLUS_RATE,
+		.fall_max = 100,
+		.rise_max = 120,
+		.hddat_min = 0,
+		.vddat_max = 450,
+		.sudat_min = 50,
+		.l_min = 500,
+		.h_min = 260,
+	},
+};
+
 
 static void notif_i2c_timeout(struct i2c_handle_s *hi2c)
 {
@@ -48,6 +130,298 @@ static void notif_i2c_timeout(struct i2c_handle_s *hi2c)
 	hi2c->i2c_state = I2C_STATE_READY;
 }
 
+static const struct i2c_spec_s *get_specs(uint32_t rate)
+{
+	size_t i;
+
+	for (i = 0U; i < ARRAY_SIZE(i2c_specs); i++) {
+		if (rate <= i2c_specs[i].rate) {
+			return &i2c_specs[i];
+		}
+	}
+
+	/* NOT REACHED */
+	return NULL;
+}
+
+#define RATE_MIN(rate)	(((rate) / 100U) * 80U)
+/*
+ * @brief  Compute the I2C device timings.
+ * @param  init: Ref to the initialization configuration structure
+ * @param  clock_src: I2C clock source frequency (Hz)
+ * @param  timing: Pointer to the final computed timing result
+ * @retval 0 if OK, negative value else
+ */
+static int i2c_compute_timing(struct stm32_i2c_init_s *init,
+			      uint32_t clock_src, uint32_t *timing)
+{
+	const struct i2c_spec_s *specs;
+	uint32_t speed_freq;
+	uint32_t i2cclk = udiv_round_nearest(I2C_NSEC_PER_SEC, clock_src);
+	uint32_t i2cbus;
+	uint32_t p_prev = I2C_TIMINGR_PRESC_MAX;
+	uint32_t af_delay_min;
+	uint32_t af_delay_max;
+	uint32_t dnf_delay;
+	uint32_t tsync;
+	uint32_t clk_min;
+	uint32_t clk_max;
+	int clk_error_prev;
+	uint16_t p;
+	uint16_t l;
+	uint16_t a;
+	uint16_t h;
+	int sdadel_min;
+	int sdadel_max;
+	uint32_t sdadel_min_u;
+	uint32_t sdadel_max_u;
+	uint32_t scldel_min;
+	int s = -1;
+	struct i2c_timing_s solutions[I2C_TIMINGR_PRESC_MAX];
+
+	specs = get_specs(init->bus_rate);
+	if (specs == NULL) {
+		ERROR("I2C speed out of bound {%d}\n", init->bus_rate);
+		return -EINVAL;
+	}
+
+	speed_freq = specs->rate;
+	i2cbus = udiv_round_nearest(I2C_NSEC_PER_SEC, speed_freq);
+	clk_error_prev = INT_MAX;
+
+	if ((init->rise_time > specs->rise_max) ||
+	    (init->fall_time > specs->fall_max)) {
+		ERROR(" I2C timings out of bound Rise{%d>%d}/Fall{%d>%d}\n",
+		      init->rise_time, specs->rise_max,
+		      init->fall_time, specs->fall_max);
+		return -EINVAL;
+	}
+
+	if (init->digital_filter_coef > STM32_I2C_DIGITAL_FILTER_MAX) {
+		ERROR("DNF out of bound %d/%d\n",
+		      init->digital_filter_coef, STM32_I2C_DIGITAL_FILTER_MAX);
+		return -EINVAL;
+	}
+
+	/*  Analog and Digital Filters */
+	af_delay_min = (init->analog_filter ?
+			STM32_I2C_ANALOG_FILTER_DELAY_MIN : 0);
+	af_delay_max = (init->analog_filter ?
+			STM32_I2C_ANALOG_FILTER_DELAY_MAX : 0);
+	dnf_delay = init->digital_filter_coef * i2cclk;
+
+	sdadel_min = specs->hddat_min + init->fall_time -
+		     af_delay_min - ((init->digital_filter_coef + 3) * i2cclk);
+
+	sdadel_max = specs->vddat_max - init->rise_time -
+		     af_delay_max - ((init->digital_filter_coef + 4) * i2cclk);
+
+	scldel_min = init->rise_time + specs->sudat_min;
+
+	if (sdadel_min < 0) {
+		sdadel_min_u = 0;
+	} else {
+		sdadel_min_u = (uint32_t)sdadel_min;
+	}
+
+	if (sdadel_max < 0) {
+		sdadel_max_u = 0;
+	} else {
+		sdadel_max_u = (uint32_t)sdadel_max;
+	}
+
+	VERBOSE("I2C SDADEL(min/max): %u/%u, SCLDEL(Min): %u\n",
+		sdadel_min_u, sdadel_max_u, scldel_min);
+
+	zeromem(&solutions, sizeof(solutions));
+
+	/* Compute possible values for PRESC, SCLDEL and SDADEL */
+	for (p = 0; p < I2C_TIMINGR_PRESC_MAX; p++) {
+		for (l = 0; l < I2C_TIMINGR_SCLDEL_MAX; l++) {
+			uint32_t scldel = (l + 1) * (p + 1) * i2cclk;
+
+			if (scldel < scldel_min) {
+				continue;
+			}
+
+			for (a = 0; a < I2C_TIMINGR_SDADEL_MAX; a++) {
+				uint32_t sdadel = (a * (p + 1) + 1) * i2cclk;
+
+				if ((sdadel >= sdadel_min_u) &&
+				    (sdadel <= sdadel_max_u) &&
+				    (p != p_prev)) {
+					solutions[p].scldel = l;
+					solutions[p].sdadel = a;
+					solutions[p].is_saved = true;
+					p_prev = p;
+					break;
+				}
+			}
+
+			if (p_prev == p) {
+				break;
+			}
+		}
+	}
+
+	if (p_prev == I2C_TIMINGR_PRESC_MAX) {
+		ERROR(" I2C no Prescaler solution\n");
+		return -EPERM;
+	}
+
+	tsync = af_delay_min + dnf_delay + (2 * i2cclk);
+	clk_max = I2C_NSEC_PER_SEC / RATE_MIN(specs->rate);
+	clk_min = I2C_NSEC_PER_SEC / specs->rate;
+
+	/*
+	 * Among prescaler possibilities discovered above figures out SCL Low
+	 * and High Period. Provided:
+	 * - SCL Low Period has to be higher than Low Period of the SCL Clock
+	 *   defined by I2C Specification. I2C Clock has to be lower than
+	 *   (SCL Low Period - Analog/Digital filters) / 4.
+	 * - SCL High Period has to be lower than High Period of the SCL Clock
+	 *   defined by I2C Specification.
+	 * - I2C Clock has to be lower than SCL High Period.
+	 */
+	for (p = 0; p < I2C_TIMINGR_PRESC_MAX; p++) {
+		uint32_t prescaler = (p + 1) * i2cclk;
+
+		if (!solutions[p].is_saved) {
+			continue;
+		}
+
+		for (l = 0; l < I2C_TIMINGR_SCLL_MAX; l++) {
+			uint32_t tscl_l = ((l + 1) * prescaler) + tsync;
+
+			if ((tscl_l < specs->l_min) ||
+			    (i2cclk >=
+			     ((tscl_l - af_delay_min - dnf_delay) / 4))) {
+				continue;
+			}
+
+			for (h = 0; h < I2C_TIMINGR_SCLH_MAX; h++) {
+				uint32_t tscl_h = ((h + 1) * prescaler) + tsync;
+				uint32_t tscl = tscl_l + tscl_h +
+						init->rise_time +
+						init->fall_time;
+
+				if ((tscl >= clk_min) && (tscl <= clk_max) &&
+				    (tscl_h >= specs->h_min) &&
+				    (i2cclk < tscl_h)) {
+					int clk_error = tscl - i2cbus;
+
+					if (clk_error < 0) {
+						clk_error = -clk_error;
+					}
+
+					if (clk_error < clk_error_prev) {
+						clk_error_prev = clk_error;
+						solutions[p].scll = l;
+						solutions[p].sclh = h;
+						s = p;
+					}
+				}
+			}
+		}
+	}
+
+	if (s < 0) {
+		ERROR(" I2C no solution at all\n");
+		return -EPERM;
+	}
+
+	/* Finalize timing settings */
+	*timing = I2C_SET_TIMINGR_PRESC(s) |
+		  I2C_SET_TIMINGR_SCLDEL(solutions[s].scldel) |
+		  I2C_SET_TIMINGR_SDADEL(solutions[s].sdadel) |
+		  I2C_SET_TIMINGR_SCLH(solutions[s].sclh) |
+		  I2C_SET_TIMINGR_SCLL(solutions[s].scll);
+
+	VERBOSE("I2C TIMINGR (PRESC/SCLDEL/SDADEL): %i/%i/%i\n",
+		s, solutions[s].scldel, solutions[s].sdadel);
+	VERBOSE("I2C TIMINGR (SCLH/SCLL): %i/%i\n",
+		solutions[s].sclh, solutions[s].scll);
+	VERBOSE("I2C TIMINGR: 0x%x\n", *timing);
+
+	return 0;
+}
+
+static uint32_t get_lower_rate(uint32_t rate)
+{
+	int i;
+
+	for (i = ARRAY_SIZE(i2c_specs) - 1; i >= 0; i--) {
+		if (rate > i2c_specs[i].rate) {
+			return i2c_specs[i].rate;
+		}
+	}
+
+	return i2c_specs[0].rate;
+}
+
+/*
+ * @brief  Setup the I2C device timings.
+ * @param  hi2c: Pointer to a struct i2c_handle_s structure that contains
+ *               the configuration information for the specified I2C.
+ * @param  init: Ref to the initialization configuration structure
+ * @param  timing: Pointer to the final computed timing result
+ * @retval 0 if OK, negative value else
+ */
+static int i2c_setup_timing(struct i2c_handle_s *hi2c,
+			    struct stm32_i2c_init_s *init,
+			    uint32_t *timing)
+{
+	int rc = 0;
+	uint32_t clock_src;
+
+	clock_src = (uint32_t)clk_get_rate(hi2c->clock);
+	if (clock_src == 0U) {
+		ERROR("I2C clock rate is 0\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * If the timing has already been computed, and the frequency is the
+	 * same as when it was computed, then use the saved timing.
+	 */
+	if (clock_src == hi2c->saved_frequency) {
+		*timing = hi2c->saved_timing;
+		return 0;
+	}
+
+	do {
+		rc = i2c_compute_timing(init, clock_src, timing);
+		if (rc != 0) {
+			ERROR("Failed to compute I2C timings\n");
+			if (init->bus_rate > STANDARD_RATE) {
+				init->bus_rate = get_lower_rate(init->bus_rate);
+				WARN("Downgrade I2C speed to %uHz)\n",
+				     init->bus_rate);
+			} else {
+				break;
+			}
+		}
+	} while (rc != 0);
+
+	if (rc != 0) {
+		ERROR("Impossible to compute I2C timings\n");
+		return rc;
+	}
+
+	VERBOSE("I2C Freq(%i), Clk Source(%i)\n",
+		init->bus_rate, clock_src);
+	VERBOSE("I2C Rise(%i) and Fall(%i) Time\n",
+		init->rise_time, init->fall_time);
+	VERBOSE("I2C Analog Filter(%s), DNF(%i)\n",
+		(init->analog_filter ? "On" : "Off"),
+		init->digital_filter_coef);
+
+	hi2c->saved_timing = *timing;
+	hi2c->saved_frequency = clock_src;
+
+	return 0;
+}
+
 /*
  * @brief  Configure I2C Analog noise filter.
  * @param  hi2c: Pointer to a struct i2c_handle_s structure that contains
@@ -96,41 +470,24 @@ static int i2c_config_analog_filter(struct i2c_handle_s *hi2c,
 int stm32_i2c_get_setup_from_fdt(void *fdt, int node,
 				 struct stm32_i2c_init_s *init)
 {
-	const fdt32_t *cuint;
-
-	cuint = fdt_getprop(fdt, node, "i2c-scl-rising-time-ns", NULL);
-	if (cuint == NULL) {
-		init->rise_time = STM32_I2C_RISE_TIME_DEFAULT;
-	} else {
-		init->rise_time = fdt32_to_cpu(*cuint);
-	}
-
-	cuint = fdt_getprop(fdt, node, "i2c-scl-falling-time-ns", NULL);
-	if (cuint == NULL) {
-		init->fall_time = STM32_I2C_FALL_TIME_DEFAULT;
-	} else {
-		init->fall_time = fdt32_to_cpu(*cuint);
-	}
-
-	cuint = fdt_getprop(fdt, node, "clock-frequency", NULL);
-	if (cuint == NULL) {
-		init->speed_mode = STM32_I2C_SPEED_DEFAULT;
-	} else {
-		switch (fdt32_to_cpu(*cuint)) {
-		case STANDARD_RATE:
-			init->speed_mode = I2C_SPEED_STANDARD;
-			break;
-		case FAST_RATE:
-			init->speed_mode = I2C_SPEED_FAST;
-			break;
-		case FAST_PLUS_RATE:
-			init->speed_mode = I2C_SPEED_FAST_PLUS;
-			break;
-		default:
-			init->speed_mode = STM32_I2C_SPEED_DEFAULT;
-			break;
-		}
+	uint32_t read_val;
+
+	init->rise_time = fdt_read_uint32_default(fdt, node,
+						  "i2c-scl-rising-time-ns",
+						  STM32_I2C_RISE_TIME_DEFAULT);
+
+	init->fall_time = fdt_read_uint32_default(fdt, node,
+						  "i2c-scl-falling-time-ns",
+						  STM32_I2C_FALL_TIME_DEFAULT);
+
+	read_val = fdt_read_uint32_default(fdt, node, "clock-frequency",
+					   STANDARD_RATE);
+	if (read_val > FAST_PLUS_RATE) {
+		ERROR("Invalid bus speed (%i > %i)\n", read_val,
+		      FAST_PLUS_RATE);
+		return -FDT_ERR_BADVALUE;
 	}
+	init->bus_rate = read_val;
 
 	return dt_set_pinctrl_config(node);
 }
@@ -146,7 +503,7 @@ int stm32_i2c_init(struct i2c_handle_s *hi2c,
 		   struct stm32_i2c_init_s *init_data)
 {
 	int rc = 0;
-	uint32_t timing = I2C_TIMING;
+	uint32_t timing;
 
 	if (hi2c == NULL) {
 		return -ENOENT;
@@ -158,7 +515,12 @@ int stm32_i2c_init(struct i2c_handle_s *hi2c,
 
 	hi2c->i2c_state = I2C_STATE_BUSY;
 
-	stm32mp_clk_enable(hi2c->clock);
+	rc = i2c_setup_timing(hi2c, init_data, &timing);
+	if (rc != 0) {
+		return rc;
+	}
+
+	clk_enable(hi2c->clock);
 
 	/* Disable the selected I2C peripheral */
 	mmio_clrbits_32(hi2c->i2c_base_addr + I2C_CR1, I2C_CR1_PE);
@@ -220,11 +582,11 @@ int stm32_i2c_init(struct i2c_handle_s *hi2c,
 						I2C_ANALOGFILTER_DISABLE);
 	if (rc != 0) {
 		ERROR("Cannot initialize I2C analog filter (%d)\n", rc);
-		stm32mp_clk_disable(hi2c->clock);
+		clk_disable(hi2c->clock);
 		return rc;
 	}
 
-	stm32mp_clk_disable(hi2c->clock);
+	clk_disable(hi2c->clock);
 
 	return rc;
 }
@@ -548,7 +910,7 @@ static int i2c_write(struct i2c_handle_s *hi2c, uint16_t dev_addr,
 		return -EINVAL;
 	}
 
-	stm32mp_clk_enable(hi2c->clock);
+	clk_enable(hi2c->clock);
 
 	hi2c->lock = 1;
 
@@ -648,7 +1010,7 @@ static int i2c_write(struct i2c_handle_s *hi2c, uint16_t dev_addr,
 
 bail:
 	hi2c->lock = 0;
-	stm32mp_clk_disable(hi2c->clock);
+	clk_disable(hi2c->clock);
 
 	return rc;
 }
@@ -729,7 +1091,7 @@ static int i2c_read(struct i2c_handle_s *hi2c, uint16_t dev_addr,
 		return  -EINVAL;
 	}
 
-	stm32mp_clk_enable(hi2c->clock);
+	clk_enable(hi2c->clock);
 
 	hi2c->lock = 1;
 
@@ -817,7 +1179,7 @@ static int i2c_read(struct i2c_handle_s *hi2c, uint16_t dev_addr,
 
 bail:
 	hi2c->lock = 0;
-	stm32mp_clk_disable(hi2c->clock);
+	clk_disable(hi2c->clock);
 
 	return rc;
 }
@@ -882,7 +1244,7 @@ bool stm32_i2c_is_device_ready(struct i2c_handle_s *hi2c,
 		return rc;
 	}
 
-	stm32mp_clk_enable(hi2c->clock);
+	clk_enable(hi2c->clock);
 
 	hi2c->lock = 1;
 	hi2c->i2c_mode = I2C_MODE_NONE;
@@ -974,8 +1336,7 @@ bool stm32_i2c_is_device_ready(struct i2c_handle_s *hi2c,
 
 bail:
 	hi2c->lock = 0;
-	stm32mp_clk_disable(hi2c->clock);
+	clk_disable(hi2c->clock);
 
 	return rc;
 }
-
diff --git a/drivers/st/io/io_stm32image.c b/drivers/st/io/io_stm32image.c
deleted file mode 100644
index 9fa0c50fd..000000000
--- a/drivers/st/io/io_stm32image.c
+++ /dev/null
@@ -1,379 +0,0 @@
-/*
- * Copyright (c) 2018-2021, ARM Limited and Contributors. All rights reserved.
- *
- * SPDX-License-Identifier: BSD-3-Clause
- */
-
-#include <assert.h>
-#include <errno.h>
-#include <stdint.h>
-#include <string.h>
-
-#include <platform_def.h>
-
-#include <common/debug.h>
-#include <drivers/io/io_driver.h>
-#include <drivers/io/io_storage.h>
-#include <drivers/st/io_stm32image.h>
-#include <lib/utils.h>
-#include <plat/common/platform.h>
-
-static uintptr_t backend_dev_handle;
-static uintptr_t backend_image_spec;
-static uint32_t *stm32_img;
-static uint8_t first_lba_buffer[MAX_LBA_SIZE] __aligned(4);
-static struct stm32image_part_info *current_part;
-
-/* STM32 Image driver functions */
-static int stm32image_dev_open(const uintptr_t init_params,
-			       io_dev_info_t **dev_info);
-static int stm32image_partition_open(io_dev_info_t *dev_info,
-				     const uintptr_t spec, io_entity_t *entity);
-static int stm32image_partition_size(io_entity_t *entity, size_t *length);
-static int stm32image_partition_read(io_entity_t *entity, uintptr_t buffer,
-				     size_t length, size_t *length_read);
-static int stm32image_partition_close(io_entity_t *entity);
-static int stm32image_dev_init(io_dev_info_t *dev_info,
-			       const uintptr_t init_params);
-static int stm32image_dev_close(io_dev_info_t *dev_info);
-
-/* Identify the device type as a virtual driver */
-static io_type_t device_type_stm32image(void)
-{
-	return IO_TYPE_STM32IMAGE;
-}
-
-static const io_dev_connector_t stm32image_dev_connector = {
-	.dev_open = stm32image_dev_open
-};
-
-static const io_dev_funcs_t stm32image_dev_funcs = {
-	.type = device_type_stm32image,
-	.open = stm32image_partition_open,
-	.size = stm32image_partition_size,
-	.read = stm32image_partition_read,
-	.close = stm32image_partition_close,
-	.dev_init = stm32image_dev_init,
-	.dev_close = stm32image_dev_close,
-};
-
-static io_dev_info_t stm32image_dev_info = {
-	.funcs = &stm32image_dev_funcs,
-	.info = (uintptr_t)0,
-};
-
-static struct stm32image_device_info stm32image_dev;
-
-static int get_part_idx_by_binary_type(uint32_t binary_type)
-{
-	int i;
-
-	for (i = 0; i < STM32_PART_NUM; i++) {
-		if (stm32image_dev.part_info[i].binary_type == binary_type) {
-			return i;
-		}
-	}
-
-	return -EINVAL;
-}
-
-/* Open a connection to the STM32IMAGE device */
-static int stm32image_dev_open(const uintptr_t init_params,
-			       io_dev_info_t **dev_info)
-{
-	int i;
-	struct stm32image_device_info *device_info =
-		(struct stm32image_device_info *)init_params;
-
-	assert(dev_info != NULL);
-	*dev_info = (io_dev_info_t *)&stm32image_dev_info;
-
-	stm32image_dev.device_size = device_info->device_size;
-	stm32image_dev.lba_size = device_info->lba_size;
-
-	for (i = 0; i < STM32_PART_NUM; i++) {
-		memcpy(stm32image_dev.part_info[i].name,
-		       device_info->part_info[i].name, MAX_PART_NAME_SIZE);
-		stm32image_dev.part_info[i].binary_type =
-			device_info->part_info[i].binary_type;
-		stm32image_dev.part_info[i].part_offset =
-			device_info->part_info[i].part_offset;
-		stm32image_dev.part_info[i].bkp_offset =
-			device_info->part_info[i].bkp_offset;
-	}
-
-	return 0;
-}
-
-/* Do some basic package checks */
-static int stm32image_dev_init(io_dev_info_t *dev_info,
-			       const uintptr_t init_params)
-{
-	int result;
-
-	if ((backend_dev_handle != 0U) || (backend_image_spec != 0U)) {
-		ERROR("STM32 Image io supports only one session\n");
-		return -ENOMEM;
-	}
-
-	/* Obtain a reference to the image by querying the platform layer */
-	result = plat_get_image_source(STM32_IMAGE_ID, &backend_dev_handle,
-				       &backend_image_spec);
-	if (result != 0) {
-		ERROR("STM32 image error (%i)\n", result);
-		return -EINVAL;
-	}
-
-	return result;
-}
-
-/* Close a connection to the STM32 Image device */
-static int stm32image_dev_close(io_dev_info_t *dev_info)
-{
-	backend_dev_handle = 0U;
-	backend_image_spec = 0U;
-	stm32_img = NULL;
-
-	return 0;
-}
-
-/* Open a partition */
-static int stm32image_partition_open(io_dev_info_t *dev_info,
-				     const uintptr_t spec, io_entity_t *entity)
-{
-	const struct stm32image_part_info *partition_spec;
-	int idx;
-
-	assert(entity != NULL);
-
-	partition_spec = (struct stm32image_part_info *)spec;
-	assert(partition_spec != NULL);
-
-	idx = get_part_idx_by_binary_type(partition_spec->binary_type);
-	if ((idx < 0) || (idx > STM32_PART_NUM)) {
-		ERROR("Wrong partition index (%d)\n", idx);
-		return -EINVAL;
-	}
-
-	current_part = &stm32image_dev.part_info[idx];
-	stm32_img = (uint32_t *)&current_part->part_offset;
-
-	return 0;
-}
-
-/* Return the size of a partition */
-static int stm32image_partition_size(io_entity_t *entity, size_t *length)
-{
-	int result;
-	uintptr_t backend_handle;
-	size_t bytes_read;
-	boot_api_image_header_t *header =
-		(boot_api_image_header_t *)first_lba_buffer;
-
-	assert(entity != NULL);
-	assert(length != NULL);
-
-	/* Attempt to access the image */
-	result = io_open(backend_dev_handle, backend_image_spec,
-			 &backend_handle);
-
-	if (result < 0) {
-		ERROR("%s: io_open (%i)\n", __func__, result);
-		return result;
-	}
-
-	/* Reset magic header value */
-	header->magic = 0;
-
-	while (header->magic == 0U) {
-		result = io_seek(backend_handle, IO_SEEK_SET, *stm32_img);
-		if (result != 0) {
-			ERROR("%s: io_seek (%i)\n", __func__, result);
-			break;
-		}
-
-		result = io_read(backend_handle, (uintptr_t)header,
-				 MAX_LBA_SIZE, (size_t *)&bytes_read);
-		if (result != 0) {
-			if (current_part->bkp_offset == 0U) {
-				ERROR("%s: io_read (%i)\n", __func__, result);
-			}
-			header->magic = 0;
-		}
-
-		if ((header->magic != BOOT_API_IMAGE_HEADER_MAGIC_NB) ||
-		    (header->binary_type != current_part->binary_type) ||
-		    (header->image_length >= stm32image_dev.device_size)) {
-			VERBOSE("%s: partition %s not found at %x\n",
-				__func__, current_part->name, *stm32_img);
-
-			if (current_part->bkp_offset == 0U) {
-				result = -ENOMEM;
-				break;
-			}
-
-			/* Header not correct, check next offset for backup */
-			*stm32_img += current_part->bkp_offset;
-			if (*stm32_img > stm32image_dev.device_size) {
-				/* No backup found, end of device reached */
-				WARN("%s : partition %s not found\n",
-				     __func__, current_part->name);
-				result = -ENOMEM;
-				break;
-			}
-			header->magic = 0;
-		}
-	}
-
-	io_close(backend_handle);
-
-	if (result != 0) {
-		return result;
-	}
-
-	if (header->image_length < stm32image_dev.lba_size) {
-		*length = stm32image_dev.lba_size;
-	} else {
-		*length = header->image_length;
-	}
-
-	INFO("STM32 Image size : %lu\n", (unsigned long)*length);
-
-	return 0;
-}
-
-/* Read data from a partition */
-static int stm32image_partition_read(io_entity_t *entity, uintptr_t buffer,
-				     size_t length, size_t *length_read)
-{
-	int result = -EINVAL;
-	uint8_t *local_buffer;
-	boot_api_image_header_t *header =
-		(boot_api_image_header_t *)first_lba_buffer;
-	size_t hdr_sz = sizeof(boot_api_image_header_t);
-
-	assert(entity != NULL);
-	assert(buffer != 0U);
-	assert(length_read != NULL);
-
-	local_buffer = (uint8_t *)buffer;
-	*length_read = 0U;
-
-	while (*length_read == 0U) {
-		int offset;
-		int local_length;
-		uintptr_t backend_handle;
-
-		if (header->magic != BOOT_API_IMAGE_HEADER_MAGIC_NB) {
-			/* Check for backup as image is corrupted */
-			if (current_part->bkp_offset == 0U) {
-				result = -ENOMEM;
-				break;
-			}
-
-			*stm32_img += current_part->bkp_offset;
-			if (*stm32_img >= stm32image_dev.device_size) {
-				/* End of device reached */
-				result = -ENOMEM;
-				break;
-			}
-
-			local_buffer = (uint8_t *)buffer;
-
-			result = stm32image_partition_size(entity, &length);
-			if (result != 0) {
-				break;
-			}
-		}
-
-		/* Part of image already loaded with the header */
-		memcpy(local_buffer, (uint8_t *)first_lba_buffer + hdr_sz,
-		       MAX_LBA_SIZE - hdr_sz);
-		local_buffer += MAX_LBA_SIZE - hdr_sz;
-		offset = MAX_LBA_SIZE;
-
-		/* New image length to be read */
-		local_length = round_up(length - ((MAX_LBA_SIZE) - hdr_sz),
-					stm32image_dev.lba_size);
-
-		if ((header->load_address != 0U) &&
-		    (header->load_address != buffer)) {
-			ERROR("Wrong load address\n");
-			panic();
-		}
-
-		result = io_open(backend_dev_handle, backend_image_spec,
-				 &backend_handle);
-
-		if (result != 0) {
-			ERROR("%s: io_open (%i)\n", __func__, result);
-			break;
-		}
-
-		result = io_seek(backend_handle, IO_SEEK_SET,
-				 *stm32_img + offset);
-
-		if (result != 0) {
-			ERROR("%s: io_seek (%i)\n", __func__, result);
-			*length_read = 0;
-			io_close(backend_handle);
-			break;
-		}
-
-		result = io_read(backend_handle, (uintptr_t)local_buffer,
-				 local_length, length_read);
-
-		/* Adding part of size already read from header */
-		*length_read += MAX_LBA_SIZE - hdr_sz;
-
-		if (result != 0) {
-			ERROR("%s: io_read (%i)\n", __func__, result);
-			*length_read = 0;
-			header->magic = 0;
-			continue;
-		}
-
-		result = stm32mp_check_header(header, buffer);
-		if (result != 0) {
-			ERROR("Header check failed\n");
-			*length_read = 0;
-			header->magic = 0;
-		}
-
-		result = stm32mp_auth_image(header, buffer);
-		if (result != 0) {
-			ERROR("Authentication Failed (%i)\n", result);
-			return result;
-		}
-
-		inv_dcache_range(round_up((uintptr_t)(local_buffer + length - hdr_sz),
-					  CACHE_WRITEBACK_GRANULE), *length_read - length + hdr_sz);
-
-		io_close(backend_handle);
-	}
-
-	return result;
-}
-
-/* Close a partition */
-static int stm32image_partition_close(io_entity_t *entity)
-{
-	current_part = NULL;
-
-	return 0;
-}
-
-/* Register the stm32image driver with the IO abstraction */
-int register_io_dev_stm32image(const io_dev_connector_t **dev_con)
-{
-	int result;
-
-	assert(dev_con != NULL);
-
-	result = io_register_device(&stm32image_dev_info);
-	if (result == 0) {
-		*dev_con = &stm32image_dev_connector;
-	}
-
-	return result;
-}
diff --git a/drivers/st/iwdg/stm32_iwdg.c b/drivers/st/iwdg/stm32_iwdg.c
index c052b4dfb..a9f86d722 100644
--- a/drivers/st/iwdg/stm32_iwdg.c
+++ b/drivers/st/iwdg/stm32_iwdg.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2019, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2017-2021, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -15,6 +15,7 @@
 #include <arch_helpers.h>
 #include <common/debug.h>
 #include <drivers/arm/gicv2.h>
+#include <drivers/clk.h>
 #include <drivers/delay_timer.h>
 #include <drivers/st/stm32_iwdg.h>
 #include <drivers/st/stm32mp_clkfunc.h>
@@ -22,11 +23,30 @@
 #include <lib/utils.h>
 #include <plat/common/platform.h>
 
+#define IWDG_TIMEOUT_MS		U(100)
+
 /* IWDG registers offsets */
 #define IWDG_KR_OFFSET		0x00U
+#define IWDG_PR_OFFSET		0x04U
+#define IWDG_RLR_OFFSET		0x08U
+#define IWDG_SR_OFFSET		0x0CU
+#define IWDG_EWCR_OFFSET	0x14U
 
 /* Registers values */
+#define IWDG_KR_ACCESS_KEY	0x5555
 #define IWDG_KR_RELOAD_KEY	0xAAAA
+#define IWDG_KR_START_KEY	0xCCCC
+
+#define IWDG_PR_DIV_4		0x00
+#define IWDG_PR_DIV_256		0x06
+
+#define IWDG_RLR_MAX_VAL	0xFFF
+
+#define IWDG_SR_EWU		BIT(3)
+
+#define IWDG_EWCR_EWIE		BIT(15)
+#define IWDG_EWCR_EWIC		BIT(14)
+#define IWDG_EWCR_EWIT_MASK	GENMASK(11, 0)
 
 struct stm32_iwdg_instance {
 	uintptr_t base;
@@ -52,6 +72,122 @@ static int stm32_iwdg_get_dt_node(struct dt_node_info *info, int offset)
 	return node;
 }
 
+#if defined(IMAGE_BL32)
+void __dead2 stm32_iwdg_it_handler(int id)
+{
+	struct stm32_iwdg_instance *iwdg;
+	unsigned int instance;
+
+	for (instance = 0; instance < IWDG_MAX_INSTANCE; instance++) {
+		if (stm32_iwdg[instance].num_irq == id) {
+			break;
+		}
+	}
+
+	if (instance == IWDG_MAX_INSTANCE) {
+		panic();
+	}
+
+	iwdg = &stm32_iwdg[instance];
+
+#if DEBUG
+	INFO("CPU %x IT Watchdog %u\n", plat_my_core_pos(), instance + 1U);
+
+	stm32mp_dump_core_registers(true);
+#endif
+	stm32_iwdg_refresh();
+
+	clk_enable(iwdg->clock);
+
+	mmio_clrsetbits_32(iwdg->base + IWDG_EWCR_OFFSET,
+			   IWDG_EWCR_EWIE, IWDG_EWCR_EWIC);
+
+	clk_disable(iwdg->clock);
+
+	/* Ack interrupt as we do not return from next call */
+	gicv2_end_of_interrupt(id);
+
+#if DEBUG
+	if (!stm32mp_is_single_core()) {
+		unsigned int sec_cpu = (plat_my_core_pos() == STM32MP_PRIMARY_CPU) ?
+			STM32MP_SECONDARY_CPU : STM32MP_PRIMARY_CPU;
+
+		gicv2_raise_sgi(ARM_IRQ_SEC_SGI_1, sec_cpu);
+	}
+#endif
+
+	for ( ; ; ) {
+		;
+	}
+}
+
+static int stm32_iwdg_get_secure_timeout(int node)
+{
+	void *fdt;
+	const fdt32_t *cuint;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -1;
+	}
+
+	cuint = fdt_getprop(fdt, node, "secure-timeout-sec", NULL);
+	if (cuint == NULL) {
+		return -1;
+	}
+
+	return (int)fdt32_to_cpu(*cuint);
+}
+
+static int stm32_iwdg_conf_etimeout(int node, struct stm32_iwdg_instance *iwdg)
+{
+	int id_lsi;
+	int dt_secure_timeout = stm32_iwdg_get_secure_timeout(node);
+	uint32_t reload, status;
+	unsigned int timeout = IWDG_TIMEOUT_MS;
+	unsigned long long reload_ll;
+
+	if (dt_secure_timeout < 0) {
+		return 0;
+	}
+
+	if (dt_secure_timeout == 0) {
+		return -EINVAL;
+	}
+
+	id_lsi = fdt_get_clock_id_by_name(node, "lsi");
+	if (id_lsi < 0) {
+		return -EINVAL;
+	}
+
+	/* Prescaler fix to 256 */
+	reload_ll = (unsigned long long)dt_secure_timeout * clk_get_rate(id_lsi);
+	reload = ((uint32_t)(reload_ll >> 8) - 1U) & IWDG_EWCR_EWIT_MASK;
+
+	clk_enable(iwdg->clock);
+
+	mmio_write_32(iwdg->base + IWDG_KR_OFFSET, IWDG_KR_START_KEY);
+	mmio_write_32(iwdg->base + IWDG_KR_OFFSET, IWDG_KR_ACCESS_KEY);
+	mmio_write_32(iwdg->base + IWDG_PR_OFFSET, IWDG_PR_DIV_256);
+	mmio_write_32(iwdg->base + IWDG_EWCR_OFFSET, IWDG_EWCR_EWIE | reload);
+
+	do {
+		status = mmio_read_32(iwdg->base + IWDG_SR_OFFSET) &
+			 IWDG_SR_EWU;
+		timeout--;
+		mdelay(1);
+	} while ((status != 0U) && (timeout != 0U));
+
+	iwdg->num_irq = stm32mp_gic_enable_spi(node, NULL);
+	if (iwdg->num_irq < 0) {
+		panic();
+	}
+
+	clk_disable(iwdg->clock);
+
+	return (timeout == 0U) ? -ETIMEDOUT : 0;
+}
+#endif
+
 void stm32_iwdg_refresh(void)
 {
 	uint8_t i;
@@ -61,12 +197,12 @@ void stm32_iwdg_refresh(void)
 
 		/* 0x00000000 is not a valid address for IWDG peripherals */
 		if (iwdg->base != 0U) {
-			stm32mp_clk_enable(iwdg->clock);
+			clk_enable(iwdg->clock);
 
 			mmio_write_32(iwdg->base + IWDG_KR_OFFSET,
 				      IWDG_KR_RELOAD_KEY);
 
-			stm32mp_clk_disable(iwdg->clock);
+			clk_disable(iwdg->clock);
 		}
 	}
 }
@@ -74,6 +210,7 @@ void stm32_iwdg_refresh(void)
 int stm32_iwdg_init(void)
 {
 	int node = -1;
+	int __unused res;
 	struct dt_node_info dt_info;
 	void *fdt;
 	uint32_t __unused count = 0;
@@ -143,6 +280,14 @@ int stm32_iwdg_init(void)
 			stm32mp_register_secure_periph_iomem(iwdg->base);
 		}
 
+#if defined(IMAGE_BL32)
+		res = stm32_iwdg_conf_etimeout(node, iwdg);
+		if (res != 0) {
+			ERROR("IWDG%x early timeout config failed (%d)\n",
+			      idx + 1, res);
+			return res;
+		}
+#endif
 #if defined(IMAGE_BL2)
 		if (stm32_iwdg_shadow_update(idx, iwdg->flags) != BSEC_OK) {
 			return -1;
diff --git a/drivers/st/mce/stm32_mce.c b/drivers/st/mce/stm32_mce.c
new file mode 100644
index 000000000..9ceb58c12
--- /dev/null
+++ b/drivers/st/mce/stm32_mce.c
@@ -0,0 +1,425 @@
+/*
+ * Copyright (c) 2020-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32_mce.h>
+#include <lib/mmio.h>
+
+#include <stm32mp_fconf_getter.h>
+
+/* MCE registers (base relative) */
+#define MCE_CR		U(0x0000) /* MCE configuration register */
+#define MCE_SR		U(0x0004) /* MCE status register */
+#define MCE_IASR	U(0x0008) /* MCE illegal access status register */
+#define MCE_IACR	U(0x000C) /* MCE illegal access clear register */
+#define MCE_IAIER	U(0x0010) /* MCE illegal access interrupt enable reg */
+#define MCE_PRIVCFGR	U(0x001C) /* MCE privileged configuration register */
+#define MCE_REGCR	U(0x0040) /* MCE region configuration register */
+#define MCE_SADDR	U(0x0044) /* MCE start address for region register */
+#define MCE_EADDR	U(0x0048) /* MCE end address for region register */
+#define MCE_MKEYR	U(0x0200) /* MCE master key register offset */
+#define MCE_HWCFGR3	U(0x03E8) /* MCE hardware configuration register 3 */
+#define MCE_HWCFGR2	U(0x03EC) /* MCE hardware configuration register 2 */
+#define MCE_HWCFGR1	U(0x03F0) /* MCE hardware configuration register 1 */
+#define MCE_VERR	U(0x03F4) /* MCE version register */
+#define MCE_IPIDR	U(0x03F8) /* MCE identification register */
+#define MCE_SIDR	U(0x03FC) /* MCE size ID register */
+
+/* MCE configuration register */
+#define MCE_CR_GLOCK			BIT(0)
+#define MCE_CR_MKLOCK			BIT(1)
+
+/* MCE status register */
+#define MCE_SR_MKVALID			BIT(0)
+#define MCE_SR_ENCDIS			BIT(4)
+
+/* MCE privileged configuration register */
+#define MCE_PRIVCFGR_PRIV		BIT(0)
+
+/* MCE region configuration register */
+#define MCE_REGCR_BREN			BIT(0)
+#define MCE_REGCR_ENC			BIT(15)
+
+/* MCE start address for region register */
+#define MCE_SADDR_BADDSTART_MASK	GENMASK(31, 16)
+
+/* MCE end address for region register */
+#define MCE_EADDR_BADDEND_MASK		GENMASK(31, 16)
+
+/* MCE version register */
+#define MCE_VERR_MINREV_MASK		GENMASK(3, 0)
+#define MCE_VERR_MINREV_SHIFT		0
+#define MCE_VERR_MAJREV_MASK		GENMASK(7, 4)
+#define MCE_VERR_MAJREV_SHIFT		4
+
+/* IP configuration */
+#define MCE_MAJREV			1U
+#define MCE_MINREV			0U
+#define MCE_IP_ID			0x00170081U
+#define MCE_SIZE_ID			0xA3C5DD01U
+#define MCE_ADDR_GRANULARITY		0x10000U
+
+/* Other definitions */
+#define MCE_TIMEOUT_1MS_IN_US		1000U
+#define DDR_BASE_EXTRA_MASK		GENMASK_32(31, 30)
+#define MCE_REGION_PARAMS		3
+
+struct mce_version_s {
+	uint32_t major;
+	uint32_t minor;
+	uint32_t ip_id;
+	uint32_t size_id;
+};
+
+struct mce_dt_id_attr {
+	fdt32_t id_attr[MCE_IP_MAX_REGION_NB];
+};
+
+/*
+ * @brief  Configure privileged access to the MCE registers.
+ * @param  privilege: Only privileged (true) or all (false) access are granted.
+ * @retval None.
+ */
+static void configure_privilege(bool privilege)
+{
+	if (privilege) {
+		mmio_setbits_32(MCE_BASE + MCE_PRIVCFGR, MCE_PRIVCFGR_PRIV);
+	} else {
+		mmio_clrbits_32(MCE_BASE + MCE_PRIVCFGR, MCE_PRIVCFGR_PRIV);
+	}
+}
+
+/*
+ * @brief  Check consistency of region settings.
+ * @param  config: Ref to the region configuration structure.
+ * @retval 0 if OK, negative value else.
+ */
+static int check_region_settings(struct stm32_mce_region_s *config)
+{
+	uint32_t end;
+
+	if (config->encrypt_mode > MCE_ENCRYPTION_MODE_MAX) {
+		ERROR("MCE: encryption mode out of range error\n");
+		return -EINVAL;
+	}
+
+	if ((config->start_address < STM32MP_DDR_BASE) ||
+	    (config->end_address < STM32MP_DDR_BASE)) {
+		ERROR("MCE: start/end address lower than DDR base\n");
+		return -EINVAL;
+	}
+
+	end = STM32MP_DDR_BASE + dt_get_ddr_size() - 1U;
+	if ((config->start_address > end) || (config->end_address > end)) {
+		ERROR("MCE: start/end address higher than physical end\n");
+		return -EINVAL;
+	}
+
+	if (config->start_address >= config->end_address) {
+		ERROR("MCE: start address higher than or equal to end one\n");
+		return -EINVAL;
+	}
+
+	if (((config->start_address % MCE_ADDR_GRANULARITY) != 0U) ||
+	   (((config->end_address + 1U) % MCE_ADDR_GRANULARITY) != 0U)) {
+		ERROR("MCE: start/end address granularity not respected\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * @brief  Configure (and enable) the MCE region.
+ * @param  index: Region index (first region is 0).
+ * @param  config: Ref to the region configuration structure.
+ * @retval 0 if OK, negative value else.
+ */
+static int stm32_mce_configure_region(uint32_t index, struct stm32_mce_region_s *config)
+{
+	int ret;
+
+	if ((index >= MCE_IP_MAX_REGION_NB) || (config == NULL)) {
+		return -EINVAL;
+	}
+
+	ret = check_region_settings(config);
+	if (ret != 0) {
+		return ret;
+	}
+
+	mmio_clrbits_32(MCE_BASE + MCE_REGCR, MCE_REGCR_BREN);
+
+	mmio_clrsetbits_32(MCE_BASE + MCE_SADDR, MCE_SADDR_BADDSTART_MASK,
+			   config->start_address & MCE_SADDR_BADDSTART_MASK);
+	mmio_clrsetbits_32(MCE_BASE + MCE_EADDR, MCE_EADDR_BADDEND_MASK,
+			   config->end_address & MCE_EADDR_BADDEND_MASK);
+
+	if (config->encrypt_mode == MCE_ENCRYPT_MODE) {
+		mmio_setbits_32(MCE_BASE + MCE_REGCR, MCE_REGCR_BREN | MCE_REGCR_ENC);
+
+		if (!stm32_mce_is_hw_encryption_functional()) {
+			ERROR("MCE: encryption feature error\n");
+			return -EIO;
+		}
+	} else {
+		mmio_clrbits_32(MCE_BASE + MCE_REGCR, MCE_REGCR_ENC);
+		mmio_setbits_32(MCE_BASE + MCE_REGCR, MCE_REGCR_BREN);
+	}
+
+	return 0;
+}
+
+/*
+ * @brief  Initialize the MCE driver.
+ * @param  None.
+ * @retval None.
+ */
+void stm32_mce_init(void)
+{
+	const struct mce_version_s exp_version = {
+		.major = MCE_MAJREV,
+		.minor = MCE_MINREV,
+		.ip_id = MCE_IP_ID,
+		.size_id = MCE_SIZE_ID
+	};
+	struct mce_version_s version;
+
+	clk_enable(MCE);
+
+	version = (struct mce_version_s) {
+		.major = (mmio_read_32(MCE_BASE + MCE_VERR) &
+			  MCE_VERR_MAJREV_MASK) >> MCE_VERR_MAJREV_SHIFT,
+		.minor = (mmio_read_32(MCE_BASE + MCE_VERR) &
+			  MCE_VERR_MINREV_MASK) >> MCE_VERR_MINREV_SHIFT,
+		.ip_id = mmio_read_32(MCE_BASE + MCE_IPIDR),
+		.size_id = mmio_read_32(MCE_BASE + MCE_SIDR)
+	};
+
+	if ((version.major != exp_version.major) ||
+	    (version.minor != exp_version.minor) ||
+	    (version.ip_id != exp_version.ip_id) ||
+	    (version.size_id != exp_version.size_id)) {
+		ERROR("MCE: unexpected IP version { 0x%x, 0x%x, 0x%x, 0x%x }\n",
+		      version.major, version.minor, version.ip_id, version.size_id);
+		panic();
+	}
+
+	configure_privilege(true);
+}
+
+/*
+ * @brief  Write the MCE master key.
+ * @param  mkey: Pointer to the master key buffer.
+ * @retval 0 if OK, negative value else.
+ */
+int stm32_mce_write_master_key(uint8_t *mkey)
+{
+	uint64_t timeout_ref;
+	uint8_t i;
+
+	if (mkey == NULL) {
+		return -EINVAL;
+	}
+
+	if ((mmio_read_32(MCE_BASE + MCE_CR) & MCE_CR_MKLOCK) == MCE_CR_MKLOCK) {
+		return -EPERM;
+	}
+
+	for (i = 0U; i < MCE_KEY_SIZE_IN_BYTES; i += sizeof(uint32_t)) {
+		uint32_t key_val = 0U;
+
+		memcpy(&key_val, mkey + i, sizeof(uint32_t));
+
+		mmio_write_32(MCE_BASE + MCE_MKEYR + i, key_val);
+	}
+
+	timeout_ref = timeout_init_us(MCE_TIMEOUT_1MS_IN_US);
+
+	while ((mmio_read_32(MCE_BASE + MCE_SR) & MCE_SR_MKVALID) != MCE_SR_MKVALID) {
+		if (timeout_elapsed(timeout_ref)) {
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * @brief  Lock the MCE master key.
+ * @param  None.
+ * @retval None.
+ */
+void stm32_mce_lock_master_key(void)
+{
+	mmio_setbits_32(MCE_BASE + MCE_CR, MCE_CR_MKLOCK);
+}
+
+/*
+ * @brief  Get the MCE master key lock state.
+ * @param  None.
+ * @retval True if locked, false else.
+ */
+bool stm32_mce_is_master_key_locked(void)
+{
+	return (mmio_read_32(MCE_BASE + MCE_CR) & MCE_CR_MKLOCK) == MCE_CR_MKLOCK;
+}
+
+/*
+ * @brief  Lock the MCE IP registers.
+ * @param  None.
+ * @retval None.
+ */
+void stm32_mce_lock_global(void)
+{
+	mmio_setbits_32(MCE_BASE + MCE_CR, MCE_CR_GLOCK);
+}
+
+/*
+ * @brief  Get the MCE global lock state.
+ * @param  None.
+ * @retval True if locked, false else.
+ */
+bool stm32_mce_is_globally_locked(void)
+{
+	return (mmio_read_32(MCE_BASE + MCE_CR) & MCE_CR_GLOCK) == MCE_CR_GLOCK;
+}
+
+/*
+ * @brief  Get the MCE encryption HW feature state.
+ * @param  None.
+ * @retval True if functional, false else.
+ */
+bool stm32_mce_is_hw_encryption_functional(void)
+{
+	return (mmio_read_32(MCE_BASE + MCE_SR) & MCE_SR_ENCDIS) != MCE_SR_ENCDIS;
+}
+
+/*
+ * @brief  Get the encryption state of an address.
+ * @param  index: Memory address.
+ * @param  state: Ref to the encryption state.
+ * @retval 0 if OK, negative value else.
+ */
+int stm32_mce_get_address_encryption_state(uint32_t address, uint32_t *state)
+{
+	struct stm32_mce_region_s config;
+
+	if ((address < STM32MP_DDR_BASE) ||
+	    (address > (STM32MP_DDR_BASE + dt_get_ddr_size() - 1U)) ||
+	    (state == NULL)) {
+		return -EINVAL;
+	}
+
+	if ((mmio_read_32(MCE_BASE + MCE_REGCR) & MCE_REGCR_ENC) != MCE_REGCR_ENC) {
+		/* No encrypted region, all DDR area is in plain text */
+		*state = MCE_BYPASS_MODE;
+		return 0;
+	}
+
+	if (!stm32_mce_is_hw_encryption_functional()) {
+		ERROR("MCE: encryption feature error\n");
+		return -EIO;
+	}
+
+	/*
+	 * When MCE_SADDR and MCE_EADDR are accessed in read, the 2 MSB bits
+	 * return zeros. So DDR base address mask has to be ORed.
+	 */
+	config.start_address = mmio_read_32(MCE_BASE + MCE_SADDR) |
+			       (STM32MP_DDR_BASE & DDR_BASE_EXTRA_MASK);
+
+	config.end_address = mmio_read_32(MCE_BASE + MCE_EADDR) |
+			     (STM32MP_DDR_BASE & DDR_BASE_EXTRA_MASK);
+
+	if ((address >= config.start_address) && (address <= config.end_address)) {
+		*state = MCE_ENCRYPT_MODE;
+	} else {
+		*state = MCE_BYPASS_MODE;
+	}
+
+	return 0;
+}
+
+void stm32_mce_reload_configuration(void)
+{
+	uint32_t idx;
+
+	for (idx = 0U; idx < MCE_IP_MAX_REGION_NB; idx++) {
+		struct stm32_mce_region_s region;
+
+		stm32mp1_pm_get_mce_region(idx, &region);
+
+		if (region.end_address == 0U) {
+			break;
+		}
+
+		VERBOSE("%s: mce cell found with value = 0x%x 0x%x 0x%x\n", __func__,
+			region.start_address, region.end_address, region.encrypt_mode);
+
+		if (stm32_mce_configure_region(idx, &region) != 0) {
+			panic();
+		}
+	}
+}
+
+static int fconf_populate_mce(uintptr_t config)
+{
+	int node, len;
+	unsigned int i;
+	const struct mce_dt_id_attr *conf_list;
+	const void *dtb = (const void *)config;
+
+	/* Check the node offset point to "st,mem-encrypt" compatible property */
+	const char *compatible_str = "st,mem-encrypt";
+
+	if (!stm32mp_is_closed_device() && !stm32mp_is_auth_supported()) {
+		return 0;
+	}
+
+	node = fdt_node_offset_by_compatible(dtb, -1, compatible_str);
+	if (node < 0) {
+		ERROR("FCONF: Can't find %s compatible in dtb\n", compatible_str);
+		return node;
+	}
+
+	conf_list = (const struct mce_dt_id_attr *)fdt_getprop(dtb, node, "memory-ranges", &len);
+	if (conf_list == NULL) {
+		WARN("FCONF: Read cell failed for %s\n", "memory-ranges");
+		return -1;
+	}
+
+	/* Consider only complete set of values */
+	len -= len % MCE_REGION_PARAMS;
+
+	/* Locate the memory cells and read all values */
+	for (i = 0U; i < (unsigned int)(len / (sizeof(uint32_t) * MCE_REGION_PARAMS)); i++) {
+		uint32_t size;
+		struct stm32_mce_region_s region;
+
+		region.start_address = fdt32_to_cpu(conf_list->id_attr[i * MCE_REGION_PARAMS]);
+		size = fdt32_to_cpu(conf_list->id_attr[i * MCE_REGION_PARAMS + 1U]);
+		region.end_address = region.start_address + size - 1U;
+		region.encrypt_mode = fdt32_to_cpu(conf_list->id_attr[i * MCE_REGION_PARAMS + 2U]);
+
+		VERBOSE("FCONF: mce cell found with value = 0x%x 0x%x 0x%x\n",
+			region.start_address, size, region.encrypt_mode);
+
+		if (stm32_mce_configure_region(i, &region) != 0) {
+			panic();
+		}
+
+		stm32mp1_pm_save_mce_region(i, &region);
+	}
+
+	return 0;
+}
+
+FCONF_REGISTER_POPULATOR(FW_CONFIG, mce_config, fconf_populate_mce);
diff --git a/drivers/st/mmc/stm32_sdmmc2.c b/drivers/st/mmc/stm32_sdmmc2.c
index d3adeab13..988a01eeb 100644
--- a/drivers/st/mmc/stm32_sdmmc2.c
+++ b/drivers/st/mmc/stm32_sdmmc2.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2020, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2018-2022, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -15,6 +15,7 @@
 #include <arch.h>
 #include <arch_helpers.h>
 #include <common/debug.h>
+#include <drivers/clk.h>
 #include <drivers/delay_timer.h>
 #include <drivers/mmc.h>
 #include <drivers/st/stm32_gpio.h>
@@ -50,6 +51,7 @@
 
 /* SDMMC power control register */
 #define SDMMC_POWER_PWRCTRL		GENMASK(1, 0)
+#define SDMMC_POWER_PWRCTRL_PWR_CYCLE	BIT(1)
 #define SDMMC_POWER_DIRPOL		BIT(4)
 
 /* SDMMC clock control register */
@@ -117,7 +119,23 @@
 #define TIMEOUT_US_10_MS		10000U
 #define TIMEOUT_US_1_S			1000000U
 
+/* Power cycle delays in ms */
+#define VCC_POWER_OFF_DELAY		2
+#define VCC_POWER_ON_DELAY		2
+#define POWER_CYCLE_DELAY		2
+#define POWER_OFF_DELAY			2
+#define POWER_ON_DELAY			1
+
+#ifndef DT_SDMMC2_COMPAT
 #define DT_SDMMC2_COMPAT		"st,stm32-sdmmc2"
+#endif
+
+#if STM32MP13 || STM32MP15
+#define SDMMC_FIFO_SIZE			64U
+#endif
+#if STM32MP25
+#define SDMMC_FIFO_SIZE			1024U
+#endif
 
 static void stm32_sdmmc2_init(void);
 static int stm32_sdmmc2_send_cmd_req(struct mmc_cmd *cmd);
@@ -138,6 +156,8 @@ static const struct mmc_ops stm32_sdmmc2_ops = {
 
 static struct stm32_sdmmc2_params sdmmc2_params;
 
+static bool next_cmd_is_acmd;
+
 #pragma weak plat_sdmmc2_use_dma
 bool plat_sdmmc2_use_dma(unsigned int instance, unsigned int memory)
 {
@@ -154,6 +174,25 @@ static void stm32_sdmmc2_init(void)
 		freq = MIN(sdmmc2_params.max_freq, freq);
 	}
 
+	if (sdmmc2_params.vmmc_regu != NULL) {
+		regulator_disable(sdmmc2_params.vmmc_regu);
+	}
+
+	mdelay(VCC_POWER_OFF_DELAY);
+
+	mmio_write_32(base + SDMMC_POWER,
+		      SDMMC_POWER_PWRCTRL_PWR_CYCLE | sdmmc2_params.dirpol);
+	mdelay(POWER_CYCLE_DELAY);
+
+	if (sdmmc2_params.vmmc_regu != NULL) {
+		regulator_enable(sdmmc2_params.vmmc_regu);
+	}
+
+	mdelay(VCC_POWER_ON_DELAY);
+
+	mmio_write_32(base + SDMMC_POWER, sdmmc2_params.dirpol);
+	mdelay(POWER_OFF_DELAY);
+
 	clock_div = div_round_up(sdmmc2_params.clk_rate, freq * 2U);
 
 	mmio_write_32(base + SDMMC_CLKCR, SDMMC_CLKCR_HWFC_EN | clock_div |
@@ -163,7 +202,7 @@ static void stm32_sdmmc2_init(void)
 	mmio_write_32(base + SDMMC_POWER,
 		      SDMMC_POWER_PWRCTRL | sdmmc2_params.dirpol);
 
-	mdelay(1);
+	mdelay(POWER_ON_DELAY);
 }
 
 static int stm32_sdmmc2_stop_transfer(void)
@@ -221,6 +260,20 @@ static int stm32_sdmmc2_send_cmd_req(struct mmc_cmd *cmd)
 	case MMC_CMD(1):
 		arg_reg |= OCR_POWERUP;
 		break;
+	case MMC_CMD(6):
+		if ((sdmmc2_params.device_info->mmc_dev_type == MMC_IS_SD_HC) &&
+		    (!next_cmd_is_acmd)) {
+			cmd_reg |= SDMMC_CMDR_CMDTRANS;
+			if (sdmmc2_params.use_dma) {
+				flags_data |= SDMMC_STAR_DCRCFAIL |
+					SDMMC_STAR_DTIMEOUT |
+					SDMMC_STAR_DATAEND |
+					SDMMC_STAR_RXOVERR |
+					SDMMC_STAR_IDMATE |
+					SDMMC_STAR_DBCKEND;
+			}
+		}
+		break;
 	case MMC_CMD(8):
 		if (sdmmc2_params.device_info->mmc_dev_type == MMC_IS_EMMC) {
 			cmd_reg |= SDMMC_CMDR_CMDTRANS;
@@ -258,6 +311,8 @@ static int stm32_sdmmc2_send_cmd_req(struct mmc_cmd *cmd)
 		break;
 	}
 
+	next_cmd_is_acmd = (cmd->cmd_idx == MMC_CMD(55));
+
 	mmio_write_32(base + SDMMC_ICR, SDMMC_STATIC_FLAGS);
 
 	/*
@@ -265,8 +320,7 @@ static int stm32_sdmmc2_send_cmd_req(struct mmc_cmd *cmd)
 	 * Skip CMD55 as the next command could be data related, and
 	 * the register could have been set in prepare function.
 	 */
-	if (((cmd_reg & SDMMC_CMDR_CMDTRANS) == 0U) &&
-	    (cmd->cmd_idx != MMC_CMD(55))) {
+	if (((cmd_reg & SDMMC_CMDR_CMDTRANS) == 0U) && !next_cmd_is_acmd) {
 		mmio_write_32(base + SDMMC_DCTRLR, 0U);
 	}
 
@@ -591,7 +645,7 @@ static int stm32_sdmmc2_read(int lba, uintptr_t buf, size_t size)
 			return -ETIMEDOUT;
 		}
 
-		if (size < (8U * sizeof(uint32_t))) {
+		if (size < (SDMMC_FIFO_SIZE / 2U)) {
 			if ((mmio_read_32(base + SDMMC_DCNTR) > 0U) &&
 			    ((status & SDMMC_STAR_RXFIFOE) == 0U)) {
 				*buffer = mmio_read_32(fifo_reg);
@@ -601,7 +655,8 @@ static int stm32_sdmmc2_read(int lba, uintptr_t buf, size_t size)
 			uint32_t count;
 
 			/* Read data from SDMMC Rx FIFO */
-			for (count = 0; count < 8U; count++) {
+			for (count = 0; count < (SDMMC_FIFO_SIZE / 2U);
+			     count += sizeof(uint32_t)) {
 				*buffer = mmio_read_32(fifo_reg);
 				buffer++;
 			}
@@ -689,6 +744,8 @@ static int stm32_sdmmc2_dt_get_config(void)
 		sdmmc2_params.max_freq = fdt32_to_cpu(*cuint);
 	}
 
+	sdmmc2_params.vmmc_regu = regulator_get_by_supply_name(fdt, sdmmc_node, "vmmc");
+
 	return 0;
 }
 
@@ -699,8 +756,6 @@ unsigned long long stm32_sdmmc2_mmc_get_device_size(void)
 
 int stm32_sdmmc2_mmc_init(struct stm32_sdmmc2_params *params)
 {
-	int rc;
-
 	assert((params != NULL) &&
 	       ((params->reg_base & MMC_BLOCK_MASK) == 0U) &&
 	       ((params->bus_width == MMC_BUS_WIDTH_1) ||
@@ -709,25 +764,31 @@ int stm32_sdmmc2_mmc_init(struct stm32_sdmmc2_params *params)
 
 	memcpy(&sdmmc2_params, params, sizeof(struct stm32_sdmmc2_params));
 
+	sdmmc2_params.vmmc_regu = NULL;
+
 	if (stm32_sdmmc2_dt_get_config() != 0) {
 		ERROR("%s: DT error\n", __func__);
 		return -ENOMEM;
 	}
 
-	stm32mp_clk_enable(sdmmc2_params.clock_id);
+	clk_enable(sdmmc2_params.clock_id);
 
-	rc = stm32mp_reset_assert(sdmmc2_params.reset_id, TIMEOUT_US_1_MS);
-	if (rc != 0) {
-		panic();
-	}
-	udelay(2);
-	rc = stm32mp_reset_deassert(sdmmc2_params.reset_id, TIMEOUT_US_1_MS);
-	if (rc != 0) {
-		panic();
+	if ((int)sdmmc2_params.reset_id >= 0) {
+		int rc;
+
+		rc = stm32mp_reset_assert(sdmmc2_params.reset_id, TIMEOUT_US_1_MS);
+		if (rc != 0) {
+			panic();
+		}
+		udelay(2);
+		rc = stm32mp_reset_deassert(sdmmc2_params.reset_id, TIMEOUT_US_1_MS);
+		if (rc != 0) {
+			panic();
+		}
+		mdelay(1);
 	}
-	mdelay(1);
 
-	sdmmc2_params.clk_rate = stm32mp_clk_get_rate(sdmmc2_params.clock_id);
+	sdmmc2_params.clk_rate = clk_get_rate(sdmmc2_params.clock_id);
 	sdmmc2_params.device_info->ocr_voltage = OCR_3_2_3_3 | OCR_3_3_3_4;
 
 	return mmc_init(&stm32_sdmmc2_ops, sdmmc2_params.clk_rate,
diff --git a/drivers/st/pmic/stm32mp_pmic.c b/drivers/st/pmic/stm32mp_pmic.c
index be410a1f4..bb1bf6da6 100644
--- a/drivers/st/pmic/stm32mp_pmic.c
+++ b/drivers/st/pmic/stm32mp_pmic.c
@@ -1,57 +1,72 @@
 /*
- * Copyright (c) 2017-2021, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2017-2022, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
+#include <assert.h>
 #include <errno.h>
 
-#include <libfdt.h>
-
-#include <platform_def.h>
-
 #include <common/debug.h>
 #include <drivers/delay_timer.h>
+#include <drivers/regulator.h>
 #include <drivers/st/stm32_i2c.h>
 #include <drivers/st/stm32mp_pmic.h>
 #include <drivers/st/stpmic1.h>
 #include <lib/mmio.h>
+#include <lib/spinlock.h>
 #include <lib/utils_def.h>
+#include <libfdt.h>
 
-#define STPMIC1_LDO12356_OUTPUT_MASK	(uint8_t)(GENMASK(6, 2))
-#define STPMIC1_LDO12356_OUTPUT_SHIFT	2
-#define STPMIC1_LDO3_MODE		(uint8_t)(BIT(7))
-#define STPMIC1_LDO3_DDR_SEL		31U
-#define STPMIC1_LDO3_1800000		(9U << STPMIC1_LDO12356_OUTPUT_SHIFT)
-
-#define STPMIC1_BUCK_OUTPUT_SHIFT	2
-#define STPMIC1_BUCK3_1V8		(39U << STPMIC1_BUCK_OUTPUT_SHIFT)
-
-#define STPMIC1_DEFAULT_START_UP_DELAY_MS	1
+#include <platform_def.h>
 
 static struct i2c_handle_s i2c_handle;
 static uint32_t pmic_i2c_addr;
+#if defined(IMAGE_BL32)
+static struct spinlock lock;
+#endif
+
+static int register_pmic(void);
 
 static int dt_get_pmic_node(void *fdt)
 {
-	return fdt_node_offset_by_compatible(fdt, -1, "st,stpmic1");
+	static int node = -FDT_ERR_BADOFFSET;
+
+	if (node == -FDT_ERR_BADOFFSET) {
+		node = fdt_node_offset_by_compatible(fdt, -1, "st,stpmic1");
+	}
+
+	return node;
 }
 
 int dt_pmic_status(void)
 {
+	static int status = -FDT_ERR_BADVALUE;
 	int node;
 	void *fdt;
 
+	if (status != -FDT_ERR_BADVALUE) {
+		return status;
+	}
+
 	if (fdt_get_address(&fdt) == 0) {
 		return -ENOENT;
 	}
 
 	node = dt_get_pmic_node(fdt);
 	if (node <= 0) {
-		return -FDT_ERR_NOTFOUND;
+		status = -FDT_ERR_NOTFOUND;
+
+		return status;
 	}
 
-	return fdt_get_status(node);
+#if defined(IMAGE_BL2)
+	status = DT_SECURE;
+#else
+	status = (int)fdt_get_status(node);
+#endif
+
+	return status;
 }
 
 static bool dt_pmic_is_secure(void)
@@ -65,125 +80,53 @@ static bool dt_pmic_is_secure(void)
 
 /*
  * Get PMIC and its I2C bus configuration from the device tree.
- * Return 0 on success, negative on error, 1 if no PMIC node is found.
+ * Return 0 on success, negative on error, 1 if no PMIC node is defined.
  */
 static int dt_pmic_i2c_config(struct dt_node_info *i2c_info,
 			      struct stm32_i2c_init_s *init)
 {
-	int pmic_node, i2c_node;
-	void *fdt;
-	const fdt32_t *cuint;
-
-	if (fdt_get_address(&fdt) == 0) {
-		return -ENOENT;
-	}
-
-	pmic_node = dt_get_pmic_node(fdt);
-	if (pmic_node < 0) {
-		return 1;
-	}
-
-	cuint = fdt_getprop(fdt, pmic_node, "reg", NULL);
-	if (cuint == NULL) {
-		return -FDT_ERR_NOTFOUND;
-	}
-
-	pmic_i2c_addr = fdt32_to_cpu(*cuint) << 1;
-	if (pmic_i2c_addr > UINT16_MAX) {
-		return -EINVAL;
-	}
-
-	i2c_node = fdt_parent_offset(fdt, pmic_node);
-	if (i2c_node < 0) {
-		return -FDT_ERR_NOTFOUND;
-	}
-
-	dt_fill_device_info(i2c_info, i2c_node);
-	if (i2c_info->base == 0U) {
-		return -FDT_ERR_NOTFOUND;
-	}
-
-	return stm32_i2c_get_setup_from_fdt(fdt, i2c_node, init);
-}
-
-int dt_pmic_configure_boot_on_regulators(void)
-{
-	int pmic_node, regulators_node, regulator_node;
+	static int i2c_node = -FDT_ERR_NOTFOUND;
 	void *fdt;
 
 	if (fdt_get_address(&fdt) == 0) {
-		return -ENOENT;
-	}
-
-	pmic_node = dt_get_pmic_node(fdt);
-	if (pmic_node < 0) {
 		return -FDT_ERR_NOTFOUND;
 	}
 
-	regulators_node = fdt_subnode_offset(fdt, pmic_node, "regulators");
-	if (regulators_node < 0) {
-		return -ENOENT;
-	}
-
-	fdt_for_each_subnode(regulator_node, fdt, regulators_node) {
+	if (i2c_node == -FDT_ERR_NOTFOUND) {
+		int pmic_node;
 		const fdt32_t *cuint;
-		const char *node_name = fdt_get_name(fdt, regulator_node, NULL);
-		uint16_t voltage;
-		int status;
 
-#if defined(IMAGE_BL2)
-		if ((fdt_getprop(fdt, regulator_node, "regulator-boot-on",
-				 NULL) == NULL) &&
-		    (fdt_getprop(fdt, regulator_node, "regulator-always-on",
-				 NULL) == NULL)) {
-#else
-		if (fdt_getprop(fdt, regulator_node, "regulator-boot-on",
-				NULL) == NULL) {
-#endif
-			continue;
+		pmic_node = dt_get_pmic_node(fdt);
+		if (pmic_node < 0) {
+			return 1;
 		}
 
-		if (fdt_getprop(fdt, regulator_node, "regulator-pull-down",
-				NULL) != NULL) {
-
-			status = stpmic1_regulator_pull_down_set(node_name);
-			if (status != 0) {
-				return status;
-			}
-		}
-
-		if (fdt_getprop(fdt, regulator_node, "st,mask-reset",
-				NULL) != NULL) {
-
-			status = stpmic1_regulator_mask_reset_set(node_name);
-			if (status != 0) {
-				return status;
-			}
-		}
-
-		cuint = fdt_getprop(fdt, regulator_node,
-				    "regulator-min-microvolt", NULL);
+		cuint = fdt_getprop(fdt, pmic_node, "reg", NULL);
 		if (cuint == NULL) {
-			continue;
+			return -FDT_ERR_NOTFOUND;
 		}
 
-		/* DT uses microvolts, whereas driver awaits millivolts */
-		voltage = (uint16_t)(fdt32_to_cpu(*cuint) / 1000U);
-
-		status = stpmic1_regulator_voltage_set(node_name, voltage);
-		if (status != 0) {
-			return status;
+		pmic_i2c_addr = fdt32_to_cpu(*cuint) << 1;
+		if (pmic_i2c_addr > UINT16_MAX) {
+			return -FDT_ERR_BADVALUE;
 		}
 
-		if (stpmic1_is_regulator_enabled(node_name) == 0U) {
-			status = stpmic1_regulator_enable(node_name);
-			if (status != 0) {
-				return status;
-			}
+		i2c_node = fdt_parent_offset(fdt, pmic_node);
+		if (i2c_node < 0) {
+			return -FDT_ERR_NOTFOUND;
 		}
 	}
 
-	return 0;
+	dt_fill_device_info(i2c_info, i2c_node);
+	if (i2c_info->base == 0U) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+#if defined(IMAGE_BL2)
+	i2c_info->status = DT_SECURE;
+#endif
+
+	return stm32_i2c_get_setup_from_fdt(fdt, i2c_node, init);
 }
 
 bool initialize_pmic_i2c(void)
@@ -251,8 +194,6 @@ static void register_pmic_shared_peripherals(void)
 
 void initialize_pmic(void)
 {
-	unsigned long pmic_version;
-
 	if (!initialize_pmic_i2c()) {
 		VERBOSE("No PMIC\n");
 		return;
@@ -260,70 +201,90 @@ void initialize_pmic(void)
 
 	register_pmic_shared_peripherals();
 
+	if (register_pmic() < 0) {
+		panic();
+	}
+
+	if (stpmic1_powerctrl_on() < 0) {
+		panic();
+	}
+
+}
+
+#if DEBUG
+void print_pmic_info_and_debug(void)
+{
+	unsigned long pmic_version;
+
 	if (stpmic1_get_version(&pmic_version) != 0) {
 		ERROR("Failed to access PMIC\n");
 		panic();
 	}
 
 	INFO("PMIC version = 0x%02lx\n", pmic_version);
-	stpmic1_dump_regulators();
-
-#if defined(IMAGE_BL2)
-	if (dt_pmic_configure_boot_on_regulators() != 0) {
-		panic();
-	};
+#if defined(IMAGE_BL32)
+#if LOG_LEVEL >= LOG_LEVEL_VERBOSE
+	regulator_core_dump();
+#endif
 #endif
 }
+#endif
 
 int pmic_ddr_power_init(enum ddr_type ddr_type)
 {
-	bool buck3_at_1v8 = false;
-	uint8_t read_val;
+#if STM32MP13 || STM32MP15
 	int status;
+	uint16_t buck3_min_mv;
+	struct rdev *buck2, *buck3, *vref;
+	struct rdev *ldo3 __unused;
 
-	switch (ddr_type) {
-	case STM32MP_DDR3:
-		/* Set LDO3 to sync mode */
-		status = stpmic1_register_read(LDO3_CONTROL_REG, &read_val);
-		if (status != 0) {
-			return status;
-		}
+	buck2 = regulator_get_by_name("buck2");
+	if (buck2 == NULL) {
+		return -ENOENT;
+	}
+
+#if STM32MP15
+	ldo3 = regulator_get_by_name("ldo3");
+	if (ldo3 == NULL) {
+		return -ENOENT;
+	}
+#endif
 
-		read_val &= ~STPMIC1_LDO3_MODE;
-		read_val &= ~STPMIC1_LDO12356_OUTPUT_MASK;
-		read_val |= STPMIC1_LDO3_DDR_SEL <<
-			    STPMIC1_LDO12356_OUTPUT_SHIFT;
+	vref = regulator_get_by_name("vref_ddr");
+	if (vref == NULL) {
+		return -ENOENT;
+	}
 
-		status = stpmic1_register_write(LDO3_CONTROL_REG, read_val);
+	switch (ddr_type) {
+	case STM32MP_DDR3:
+#if STM32MP15
+		status = regulator_set_flag(ldo3, REGUL_SINK_SOURCE);
 		if (status != 0) {
 			return status;
 		}
+#endif
 
-		status = stpmic1_regulator_voltage_set("buck2", 1350);
+		status = regulator_set_min_voltage(buck2);
 		if (status != 0) {
 			return status;
 		}
 
-		status = stpmic1_regulator_enable("buck2");
+		status = regulator_enable(buck2);
 		if (status != 0) {
 			return status;
 		}
 
-		mdelay(STPMIC1_DEFAULT_START_UP_DELAY_MS);
-
-		status = stpmic1_regulator_enable("vref_ddr");
+		status = regulator_enable(vref);
 		if (status != 0) {
 			return status;
 		}
 
-		mdelay(STPMIC1_DEFAULT_START_UP_DELAY_MS);
-
-		status = stpmic1_regulator_enable("ldo3");
+#if STM32MP15
+		status = regulator_enable(ldo3);
 		if (status != 0) {
 			return status;
 		}
-
-		mdelay(STPMIC1_DEFAULT_START_UP_DELAY_MS);
+#endif
 		break;
 
 	case STM32MP_LPDDR2:
@@ -333,62 +294,315 @@ int pmic_ddr_power_init(enum ddr_type ddr_type)
 		 * Set LDO3 to bypass mode if BUCK3 = 1.8V
 		 * Set LDO3 to normal mode if BUCK3 != 1.8V
 		 */
-		status = stpmic1_register_read(BUCK3_CONTROL_REG, &read_val);
-		if (status != 0) {
-			return status;
+		buck3 = regulator_get_by_name("buck3");
+		if (buck3 == NULL) {
+			return -ENOENT;
 		}
 
-		if ((read_val & STPMIC1_BUCK3_1V8) == STPMIC1_BUCK3_1V8) {
-			buck3_at_1v8 = true;
+		regulator_get_range(buck3, &buck3_min_mv, NULL);
+
+#if STM32MP15
+		if (buck3_min_mv != 1800) {
+			status = regulator_set_min_voltage(ldo3);
+			if (status != 0) {
+				return status;
+			}
+		} else {
+			status = regulator_set_flag(ldo3, REGUL_ENABLE_BYPASS);
+			if (status != 0) {
+				return status;
+			}
 		}
+#endif
 
-		status = stpmic1_register_read(LDO3_CONTROL_REG, &read_val);
+		status = regulator_set_min_voltage(buck2);
 		if (status != 0) {
 			return status;
 		}
 
-		read_val &= ~STPMIC1_LDO3_MODE;
-		read_val &= ~STPMIC1_LDO12356_OUTPUT_MASK;
-		read_val |= STPMIC1_LDO3_1800000;
-		if (buck3_at_1v8) {
-			read_val |= STPMIC1_LDO3_MODE;
-		}
-
-		status = stpmic1_register_write(LDO3_CONTROL_REG, read_val);
+#if STM32MP15
+		status = regulator_enable(ldo3);
 		if (status != 0) {
 			return status;
 		}
+#endif
 
-		status = stpmic1_regulator_voltage_set("buck2", 1200);
+		status = regulator_enable(buck2);
 		if (status != 0) {
 			return status;
 		}
 
-		status = stpmic1_regulator_enable("ldo3");
+		status = regulator_enable(vref);
 		if (status != 0) {
 			return status;
 		}
+		break;
 
-		mdelay(STPMIC1_DEFAULT_START_UP_DELAY_MS);
+	default:
+		break;
+	};
+#endif /* STM32MP13 || STM32MP15 */
 
-		status = stpmic1_regulator_enable("buck2");
-		if (status != 0) {
-			return status;
+	return 0;
+}
+
+int pmic_voltages_init(void)
+{
+#if STM32MP13
+	struct rdev *buck1, *buck4;
+	int status;
+
+	buck1 = regulator_get_by_name("buck1");
+	if (buck1 == NULL) {
+		return -ENOENT;
+	}
+
+	buck4 = regulator_get_by_name("buck4");
+	if (buck4 == NULL) {
+		return -ENOENT;
+	}
+
+	status = regulator_set_min_voltage(buck1);
+	if (status != 0) {
+		return status;
+	}
+
+	status = regulator_set_min_voltage(buck4);
+	if (status != 0) {
+		return status;
+	}
+#endif
+
+	return 0;
+}
+
+void pmic_switch_off(void)
+{
+	stpmic1_switch_off();
+	udelay(100);
+
+	/* Shouldn't be reached */
+	panic();
+}
+
+enum {
+	STPMIC1_BUCK1 = 0,
+	STPMIC1_BUCK2,
+	STPMIC1_BUCK3,
+	STPMIC1_BUCK4,
+	STPMIC1_LDO1,
+	STPMIC1_LDO2,
+	STPMIC1_LDO3,
+	STPMIC1_LDO4,
+	STPMIC1_LDO5,
+	STPMIC1_LDO6,
+	STPMIC1_VREF_DDR,
+	STPMIC1_BOOST,
+	STPMIC1_VBUS_OTG,
+	STPMIC1_SW_OUT,
+};
+
+static int pmic_set_state(const struct regul_description *desc, bool enable)
+{
+	VERBOSE("%s: set state to %u\n", desc->node_name, enable);
+
+	if (enable == STATE_ENABLE) {
+		return stpmic1_regulator_enable(desc->node_name);
+	} else {
+		return stpmic1_regulator_disable(desc->node_name);
+	}
+}
+
+static int pmic_get_state(const struct regul_description *desc)
+{
+	VERBOSE("%s: get state\n", desc->node_name);
+
+	return stpmic1_is_regulator_enabled(desc->node_name);
+}
+
+static int pmic_get_voltage(const struct regul_description *desc)
+{
+	VERBOSE("%s: get volt\n", desc->node_name);
+
+	return stpmic1_regulator_voltage_get(desc->node_name);
+}
+
+static int pmic_set_voltage(const struct regul_description *desc, uint16_t mv)
+{
+	VERBOSE("%s: get volt\n", desc->node_name);
+
+	return stpmic1_regulator_voltage_set(desc->node_name, mv);
+}
+
+static int pmic_list_voltages(const struct regul_description *desc,
+			      const uint16_t **levels, size_t *count)
+{
+	VERBOSE("%s: list volt\n", desc->node_name);
+
+	return stpmic1_regulator_levels_mv(desc->node_name, levels, count);
+}
+
+static int pmic_set_flag(const struct regul_description *desc, uint16_t flag)
+{
+	VERBOSE("%s: set_flag 0x%x\n", desc->node_name, flag);
+
+	switch (flag) {
+	case REGUL_OCP:
+		return stpmic1_regulator_icc_set(desc->node_name);
+
+	case REGUL_ACTIVE_DISCHARGE:
+		return stpmic1_active_discharge_mode_set(desc->node_name);
+
+	case REGUL_PULL_DOWN:
+		return stpmic1_regulator_pull_down_set(desc->node_name);
+
+	case REGUL_MASK_RESET:
+		return stpmic1_regulator_mask_reset_set(desc->node_name);
+
+	case REGUL_SINK_SOURCE:
+		return stpmic1_regulator_sink_mode_set(desc->node_name);
+
+	case REGUL_ENABLE_BYPASS:
+		return stpmic1_regulator_bypass_mode_set(desc->node_name);
+
+	default:
+		return -EINVAL;
+	}
+}
+
+#if defined(IMAGE_BL32)
+static int driver_suspend(const struct regul_description *desc, uint8_t state, uint16_t mv)
+{
+	int ret;
+
+	VERBOSE("%s: suspend state:%d volt:%d\n", desc->node_name, (int)state, mv);
+
+	ret = stpmic1_lp_copy_reg(desc->node_name);
+	if (ret != 0) {
+		return ret;
+	}
+
+	if ((state & LP_STATE_OFF) != 0U) {
+		ret = stpmic1_lp_reg_on_off(desc->node_name, 0);
+		if (ret != 0) {
+			return ret;
 		}
+	}
 
-		mdelay(STPMIC1_DEFAULT_START_UP_DELAY_MS);
+	if ((state & LP_STATE_ON) != 0U) {
+		ret = stpmic1_lp_reg_on_off(desc->node_name, 1);
+		if (ret != 0) {
+			return ret;
+		}
+	}
 
-		status = stpmic1_regulator_enable("vref_ddr");
-		if (status != 0) {
-			return status;
+	if ((state & LP_STATE_SET_VOLT) != 0U) {
+		ret = stpmic1_lp_set_voltage(desc->node_name, mv);
+		if (ret != 0) {
+			return ret;
 		}
+	}
 
-		mdelay(STPMIC1_DEFAULT_START_UP_DELAY_MS);
-		break;
+	return 0;
+}
 
-	default:
-		break;
-	};
+static void driver_lock(const struct regul_description *desc)
+{
+	if (stm32mp_lock_available()) {
+		spin_lock(&lock);
+	}
+}
+
+static void driver_unlock(const struct regul_description *desc)
+{
+	if (stm32mp_lock_available()) {
+		spin_unlock(&lock);
+	}
+}
+#endif
+
+struct regul_ops pmic_ops = {
+	.set_state = pmic_set_state,
+	.get_state = pmic_get_state,
+	.set_voltage = pmic_set_voltage,
+	.get_voltage = pmic_get_voltage,
+	.list_voltages = pmic_list_voltages,
+	.set_flag = pmic_set_flag,
+#if defined(IMAGE_BL32)
+	.lock = driver_lock,
+	.unlock = driver_unlock,
+	.suspend = driver_suspend,
+#endif
+};
+
+#define DEFINE_REGU(name) { \
+	.node_name = name, \
+	.ops = &pmic_ops, \
+	.driver_data = NULL, \
+	.enable_ramp_delay = 1000, \
+}
+
+static const struct regul_description pmic_regs[] = {
+	[STPMIC1_BUCK1] = DEFINE_REGU("buck1"),
+	[STPMIC1_BUCK2] = DEFINE_REGU("buck2"),
+	[STPMIC1_BUCK3] = DEFINE_REGU("buck3"),
+	[STPMIC1_BUCK4] = DEFINE_REGU("buck4"),
+	[STPMIC1_LDO1] = DEFINE_REGU("ldo1"),
+	[STPMIC1_LDO2] = DEFINE_REGU("ldo2"),
+	[STPMIC1_LDO3] = DEFINE_REGU("ldo3"),
+	[STPMIC1_LDO4] = DEFINE_REGU("ldo4"),
+	[STPMIC1_LDO5] = DEFINE_REGU("ldo5"),
+	[STPMIC1_LDO6] = DEFINE_REGU("ldo6"),
+	[STPMIC1_VREF_DDR] = DEFINE_REGU("vref_ddr"),
+	[STPMIC1_BOOST] = DEFINE_REGU("boost"),
+	[STPMIC1_VBUS_OTG] = DEFINE_REGU("pwr_sw1"),
+	[STPMIC1_SW_OUT] = DEFINE_REGU("pwr_sw2"),
+};
+
+#define NB_REG ARRAY_SIZE(pmic_regs)
+
+static int register_pmic(void)
+{
+	void *fdt;
+	int pmic_node, regulators_node, subnode;
+
+	VERBOSE("Register pmic\n");
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	pmic_node = dt_get_pmic_node(fdt);
+	if (pmic_node < 0) {
+		return pmic_node;
+	}
+
+	regulators_node = fdt_subnode_offset(fdt, pmic_node, "regulators");
+	if (regulators_node < 0) {
+		return -ENOENT;
+	}
+
+	fdt_for_each_subnode(subnode, fdt, regulators_node) {
+		const char *reg_name = fdt_get_name(fdt, subnode, NULL);
+		const struct regul_description *desc;
+		unsigned int i;
+		int ret;
+
+		for (i = 0; i < NB_REG; i++) {
+			desc = &pmic_regs[i];
+			if (strcmp(desc->node_name, reg_name) == 0) {
+				break;
+			}
+		}
+		assert(i < NB_REG);
+
+		ret = regulator_register(desc, subnode);
+		if (ret != 0) {
+			WARN("%s:%d failed to register %s\n", __func__,
+			     __LINE__, reg_name);
+			return ret;
+		}
+	}
 
 	return 0;
 }
diff --git a/drivers/st/pmic/stpmic1.c b/drivers/st/pmic/stpmic1.c
index 0a35df372..6a0f893a1 100644
--- a/drivers/st/pmic/stpmic1.c
+++ b/drivers/st/pmic/stpmic1.c
@@ -23,10 +23,17 @@ struct regul_struct {
 	uint8_t pull_down;
 	uint8_t mask_reset_reg;
 	uint8_t mask_reset;
+	uint8_t icc_reg;
+	uint8_t icc_mask;
 };
 
 static struct i2c_handle_s *pmic_i2c_handle;
 static uint16_t pmic_i2c_addr;
+/*
+ * Special mode corresponds to LDO3 in sink source mode or in bypass mode.
+ * LDO3 doesn't switch back from special to normal mode.
+ */
+static bool ldo3_special_mode;
 
 /* Voltage tables in mV */
 static const uint16_t buck1_voltage_table[] = {
@@ -347,8 +354,11 @@ static const uint16_t ldo3_voltage_table[] = {
 	3300,
 	3300,
 	3300,
-	500,
-	0xFFFF, /* VREFDDR */
+};
+
+/* Special mode table is used for sink source OR bypass mode */
+static const uint16_t ldo3_special_mode_table[] = {
+	0,
 };
 
 static const uint16_t ldo5_voltage_table[] = {
@@ -421,6 +431,10 @@ static const uint16_t vref_ddr_voltage_table[] = {
 	3300,
 };
 
+static const uint16_t fixed_5v_voltage_table[] = {
+	5000,
+};
+
 /* Table of Regulators in PMIC SoC */
 static const struct regul_struct regulators_table[] = {
 	{
@@ -434,6 +448,8 @@ static const struct regul_struct regulators_table[] = {
 		.pull_down	= BUCK1_PULL_DOWN_SHIFT,
 		.mask_reset_reg	= MASK_RESET_BUCK_REG,
 		.mask_reset	= BUCK1_MASK_RESET,
+		.icc_reg	= BUCK_ICC_TURNOFF_REG,
+		.icc_mask	= BUCK1_ICC_SHIFT,
 	},
 	{
 		.dt_node_name	= "buck2",
@@ -446,6 +462,8 @@ static const struct regul_struct regulators_table[] = {
 		.pull_down	= BUCK2_PULL_DOWN_SHIFT,
 		.mask_reset_reg	= MASK_RESET_BUCK_REG,
 		.mask_reset	= BUCK2_MASK_RESET,
+		.icc_reg	= BUCK_ICC_TURNOFF_REG,
+		.icc_mask	= BUCK2_ICC_SHIFT,
 	},
 	{
 		.dt_node_name	= "buck3",
@@ -458,6 +476,8 @@ static const struct regul_struct regulators_table[] = {
 		.pull_down	= BUCK3_PULL_DOWN_SHIFT,
 		.mask_reset_reg	= MASK_RESET_BUCK_REG,
 		.mask_reset	= BUCK3_MASK_RESET,
+		.icc_reg	= BUCK_ICC_TURNOFF_REG,
+		.icc_mask	= BUCK3_ICC_SHIFT,
 	},
 	{
 		.dt_node_name	= "buck4",
@@ -470,6 +490,8 @@ static const struct regul_struct regulators_table[] = {
 		.pull_down	= BUCK4_PULL_DOWN_SHIFT,
 		.mask_reset_reg	= MASK_RESET_BUCK_REG,
 		.mask_reset	= BUCK4_MASK_RESET,
+		.icc_reg	= BUCK_ICC_TURNOFF_REG,
+		.icc_mask	= BUCK4_ICC_SHIFT,
 	},
 	{
 		.dt_node_name	= "ldo1",
@@ -480,6 +502,8 @@ static const struct regul_struct regulators_table[] = {
 		.low_power_reg	= LDO1_PWRCTRL_REG,
 		.mask_reset_reg	= MASK_RESET_LDO_REG,
 		.mask_reset	= LDO1_MASK_RESET,
+		.icc_reg	= LDO_ICC_TURNOFF_REG,
+		.icc_mask	= LDO1_ICC_SHIFT,
 	},
 	{
 		.dt_node_name	= "ldo2",
@@ -490,6 +514,8 @@ static const struct regul_struct regulators_table[] = {
 		.low_power_reg	= LDO2_PWRCTRL_REG,
 		.mask_reset_reg	= MASK_RESET_LDO_REG,
 		.mask_reset	= LDO2_MASK_RESET,
+		.icc_reg	= LDO_ICC_TURNOFF_REG,
+		.icc_mask	= LDO2_ICC_SHIFT,
 	},
 	{
 		.dt_node_name	= "ldo3",
@@ -500,6 +526,8 @@ static const struct regul_struct regulators_table[] = {
 		.low_power_reg	= LDO3_PWRCTRL_REG,
 		.mask_reset_reg	= MASK_RESET_LDO_REG,
 		.mask_reset	= LDO3_MASK_RESET,
+		.icc_reg	= LDO_ICC_TURNOFF_REG,
+		.icc_mask	= LDO3_ICC_SHIFT,
 	},
 	{
 		.dt_node_name	= "ldo4",
@@ -510,6 +538,8 @@ static const struct regul_struct regulators_table[] = {
 		.low_power_reg	= LDO4_PWRCTRL_REG,
 		.mask_reset_reg	= MASK_RESET_LDO_REG,
 		.mask_reset	= LDO4_MASK_RESET,
+		.icc_reg	= LDO_ICC_TURNOFF_REG,
+		.icc_mask	= LDO4_ICC_SHIFT,
 	},
 	{
 		.dt_node_name	= "ldo5",
@@ -520,6 +550,8 @@ static const struct regul_struct regulators_table[] = {
 		.low_power_reg	= LDO5_PWRCTRL_REG,
 		.mask_reset_reg	= MASK_RESET_LDO_REG,
 		.mask_reset	= LDO5_MASK_RESET,
+		.icc_reg	= LDO_ICC_TURNOFF_REG,
+		.icc_mask	= LDO5_ICC_SHIFT,
 	},
 	{
 		.dt_node_name	= "ldo6",
@@ -530,6 +562,8 @@ static const struct regul_struct regulators_table[] = {
 		.low_power_reg	= LDO6_PWRCTRL_REG,
 		.mask_reset_reg	= MASK_RESET_LDO_REG,
 		.mask_reset	= LDO6_MASK_RESET,
+		.icc_reg	= LDO_ICC_TURNOFF_REG,
+		.icc_mask	= LDO6_ICC_SHIFT,
 	},
 	{
 		.dt_node_name	= "vref_ddr",
@@ -541,6 +575,33 @@ static const struct regul_struct regulators_table[] = {
 		.mask_reset_reg	= MASK_RESET_LDO_REG,
 		.mask_reset	= VREF_DDR_MASK_RESET,
 	},
+	{
+		.dt_node_name	= "boost",
+		.voltage_table	= fixed_5v_voltage_table,
+		.voltage_table_size = ARRAY_SIZE(fixed_5v_voltage_table),
+		.control_reg	= USB_CONTROL_REG,
+		.enable_mask	= BOOST_ENABLED,
+		.icc_reg	= BUCK_ICC_TURNOFF_REG,
+		.icc_mask	= BOOST_ICC_SHIFT,
+	},
+	{
+		.dt_node_name	= "pwr_sw1",
+		.voltage_table	= fixed_5v_voltage_table,
+		.voltage_table_size = ARRAY_SIZE(fixed_5v_voltage_table),
+		.control_reg	= USB_CONTROL_REG,
+		.enable_mask	= USBSW_OTG_SWITCH_ENABLED,
+		.icc_reg	= BUCK_ICC_TURNOFF_REG,
+		.icc_mask	= PWR_SW1_ICC_SHIFT,
+	},
+	{
+		.dt_node_name	= "pwr_sw2",
+		.voltage_table	= fixed_5v_voltage_table,
+		.voltage_table_size = ARRAY_SIZE(fixed_5v_voltage_table),
+		.control_reg	= USB_CONTROL_REG,
+		.enable_mask	= SWIN_SWOUT_ENABLED,
+		.icc_reg	= BUCK_ICC_TURNOFF_REG,
+		.icc_mask	= PWR_SW2_ICC_SHIFT,
+	},
 };
 
 #define MAX_REGUL	ARRAY_SIZE(regulators_table)
@@ -606,7 +667,7 @@ int stpmic1_regulator_disable(const char *name)
 				       regul->enable_mask);
 }
 
-uint8_t stpmic1_is_regulator_enabled(const char *name)
+bool stpmic1_is_regulator_enabled(const char *name)
 {
 	uint8_t val;
 	const struct regul_struct *regul = get_regulator_data(name);
@@ -615,7 +676,7 @@ uint8_t stpmic1_is_regulator_enabled(const char *name)
 		panic();
 	}
 
-	return (val & regul->enable_mask);
+	return (val & regul->enable_mask) == regul->enable_mask;
 }
 
 int stpmic1_regulator_voltage_set(const char *name, uint16_t millivolts)
@@ -624,6 +685,16 @@ int stpmic1_regulator_voltage_set(const char *name, uint16_t millivolts)
 	const struct regul_struct *regul = get_regulator_data(name);
 	uint8_t mask;
 
+	if ((strncmp(name, "ldo3", 4) == 0) && ldo3_special_mode) {
+		/*
+		 * when the LDO3 is in special mode, we do not change voltage,
+		 * because by setting voltage, the LDO would leaves sink-source
+		 * mode. There is obviously no reason to leave sink-source mode
+		 * at runtime.
+		 */
+		return 0;
+	}
+
 	/* Voltage can be set for buck<N> or ldo<N> (except ldo4) regulators */
 	if (strncmp(name, "buck", 4) == 0) {
 		mask = BUCK_VOLTAGE_MASK;
@@ -657,12 +728,146 @@ int stpmic1_regulator_mask_reset_set(const char *name)
 {
 	const struct regul_struct *regul = get_regulator_data(name);
 
+	if (regul->mask_reset_reg == 0U) {
+		return -EPERM;
+	}
+
 	return stpmic1_register_update(regul->mask_reset_reg,
 				       BIT(regul->mask_reset),
 				       LDO_BUCK_RESET_MASK <<
 				       regul->mask_reset);
 }
 
+int stpmic1_regulator_icc_set(const char *name)
+{
+	const struct regul_struct *regul = get_regulator_data(name);
+
+	if (regul->mask_reset_reg == 0U) {
+		return -EPERM;
+	}
+
+	return stpmic1_register_update(regul->icc_reg,
+				       BIT(regul->icc_mask),
+				       BIT(regul->icc_mask));
+}
+
+int stpmic1_regulator_sink_mode_set(const char *name)
+{
+	if (strncmp(name, "ldo3", 4) != 0) {
+		return -EPERM;
+	}
+
+	ldo3_special_mode = true;
+
+	/* disable bypass mode, enable sink mode */
+	return stpmic1_register_update(LDO3_CONTROL_REG,
+				       LDO3_DDR_SEL << LDO_BUCK_VOLTAGE_SHIFT,
+				       LDO3_BYPASS | LDO_VOLTAGE_MASK);
+}
+
+int stpmic1_regulator_bypass_mode_set(const char *name)
+{
+	if (strncmp(name, "ldo3", 4) != 0) {
+		return -EPERM;
+	}
+
+	ldo3_special_mode = true;
+
+	/* enable bypass mode, disable sink mode */
+	return stpmic1_register_update(LDO3_CONTROL_REG,
+				       LDO3_BYPASS,
+				       LDO3_BYPASS | LDO_VOLTAGE_MASK);
+}
+
+int stpmic1_active_discharge_mode_set(const char *name)
+{
+	if (strncmp(name, "pwr_sw1", 7) == 0) {
+		return stpmic1_register_update(USB_CONTROL_REG,
+					       VBUS_OTG_DISCHARGE,
+					       VBUS_OTG_DISCHARGE);
+	}
+
+	if (strncmp(name, "pwr_sw2", 7) == 0) {
+		return stpmic1_register_update(USB_CONTROL_REG,
+					       SW_OUT_DISCHARGE,
+					       SW_OUT_DISCHARGE);
+	}
+
+	return -EPERM;
+}
+
+/* Low-power functions */
+int stpmic1_lp_copy_reg(const char *name)
+{
+	uint8_t val;
+	int status;
+	const struct regul_struct *regul = get_regulator_data(name);
+
+	if (regul->low_power_reg == 0U) {
+		return 0;
+	}
+
+	status = stpmic1_register_read(regul->control_reg, &val);
+	if (status != 0) {
+		return status;
+	}
+
+	return stpmic1_register_write(regul->low_power_reg, val);
+}
+
+int stpmic1_lp_reg_on_off(const char *name, uint8_t enable)
+{
+	const struct regul_struct *regul = get_regulator_data(name);
+
+	return stpmic1_register_update(regul->low_power_reg, enable,
+				       LDO_BUCK_ENABLE_MASK);
+}
+
+int stpmic1_lp_set_mode(const char *name, uint8_t hplp)
+{
+	const struct regul_struct *regul = get_regulator_data(name);
+
+	return stpmic1_register_update(regul->low_power_reg,
+				       hplp << LDO_BUCK_HPLP_SHIFT,
+				       LDO_BUCK_HPLP_ENABLE_MASK);
+}
+
+int stpmic1_lp_set_voltage(const char *name, uint16_t millivolts)
+{
+	uint8_t voltage_index = voltage_to_index(name, millivolts);
+	const struct regul_struct *regul = get_regulator_data(name);
+	uint8_t mask;
+
+	/* Voltage can be set for buck<N> or ldo<N> (except ldo4) regulators */
+	if (strncmp(name, "buck", 4) == 0) {
+		mask = BUCK_VOLTAGE_MASK;
+	} else if ((strncmp(name, "ldo", 3) == 0) &&
+		   (strncmp(name, "ldo4", 4) != 0)) {
+		mask = LDO_VOLTAGE_MASK;
+	} else {
+		return 0;
+	}
+
+	return stpmic1_register_update(regul->low_power_reg, voltage_index << 2,
+				       mask);
+}
+
+int stpmic1_regulator_levels_mv(const char *name, const uint16_t **levels,
+				size_t *levels_count)
+{
+	const struct regul_struct *regul = get_regulator_data(name);
+
+	if ((strncmp(name, "ldo3", 4) == 0) && ldo3_special_mode) {
+		*levels_count = ARRAY_SIZE(ldo3_special_mode_table);
+		*levels = ldo3_special_mode_table;
+	} else {
+		*levels_count = regul->voltage_table_size;
+		*levels = regul->voltage_table;
+	}
+
+	return 0;
+}
+
 int stpmic1_regulator_voltage_get(const char *name)
 {
 	const struct regul_struct *regul = get_regulator_data(name);
@@ -670,6 +875,10 @@ int stpmic1_regulator_voltage_get(const char *name)
 	uint8_t mask;
 	int status;
 
+	if ((strncmp(name, "ldo3", 4) == 0) && ldo3_special_mode) {
+		return 0;
+	}
+
 	/* Voltage can be set for buck<N> or ldo<N> (except ldo4) regulators */
 	if (strncmp(name, "buck", 4) == 0) {
 		mask = BUCK_VOLTAGE_MASK;
diff --git a/drivers/st/regulator/regulator_fixed.c b/drivers/st/regulator/regulator_fixed.c
new file mode 100644
index 000000000..3001b362e
--- /dev/null
+++ b/drivers/st/regulator/regulator_fixed.c
@@ -0,0 +1,91 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (c) 2020-2021, STMicroelectronics
+ */
+
+#include <assert.h>
+#include <errno.h>
+
+#include <libfdt.h>
+
+#include <common/debug.h>
+#include <drivers/regulator.h>
+#include <drivers/st/regulator_fixed.h>
+
+#ifndef PLAT_NB_FIXED_REGUS
+#error "Missing PLAT_NB_FIXED_REGUS"
+#endif
+
+#define FIXED_NAME_LEN 32U
+
+struct fixed_data {
+	char name[FIXED_NAME_LEN];
+	uint16_t volt;
+	struct regul_description desc;
+};
+
+static struct fixed_data data[PLAT_NB_FIXED_REGUS];
+
+static int fixed_set_state(const struct regul_description *desc, bool state)
+{
+	return 0;
+}
+
+static int fixed_get_state(const struct regul_description *desc)
+{
+	return 1;
+}
+
+static struct regul_ops fixed_ops = {
+	.set_state = fixed_set_state,
+	.get_state = fixed_get_state,
+};
+
+int fixed_regulator_register(void)
+{
+	uint32_t count = 0;
+	void *fdt;
+	int node = 0;
+
+	VERBOSE("fixed reg init!\n");
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	do {
+		size_t len __unused;
+		int ret;
+		struct fixed_data *d = &data[count];
+		const char *reg_name;
+
+		node = fdt_node_offset_by_compatible(fdt, node, "regulator-fixed");
+		if (node < 0) {
+			break;
+		}
+
+		reg_name = fdt_get_name(fdt, node, NULL);
+
+		VERBOSE("register fixed reg %s!\n", reg_name);
+
+		len = snprintf(d->name, FIXED_NAME_LEN - 1, "%s", reg_name);
+		assert((len > 0) && (len < (FIXED_NAME_LEN - 1)));
+
+		d->desc.node_name = d->name;
+		d->desc.driver_data = d;
+		d->desc.ops = &fixed_ops;
+
+		ret = regulator_register(&d->desc, node);
+		if (ret != 0) {
+			WARN("%s:%d failed to register %s\n", __func__,
+			     __LINE__, reg_name);
+			return ret;
+		}
+
+		count++;
+		assert(count <= PLAT_NB_FIXED_REGUS);
+
+	} while (node > 0);
+
+	return 0;
+}
diff --git a/drivers/st/regulator/regulator_gpio.c b/drivers/st/regulator/regulator_gpio.c
new file mode 100644
index 000000000..36311e9df
--- /dev/null
+++ b/drivers/st/regulator/regulator_gpio.c
@@ -0,0 +1,166 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+
+#include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <drivers/regulator.h>
+#include <drivers/st/regulator_gpio.h>
+#include <drivers/st/stm32_gpio.h>
+#include <libfdt.h>
+
+#ifndef PLAT_NB_GPIO_REGUS
+#error "Missing PLAT_NB_GPIO_REGUS"
+#endif
+
+#define MAX_NAME_LEN 32
+
+#define REGU_DISABLED 0
+#define REGU_ENABLED 1
+
+#define GPIO_DESC_SIZE 3U
+
+struct gpio_config {
+	uint32_t bank;
+	uint32_t pin;
+	uint32_t config;
+	uint8_t status;
+};
+
+struct gpio_regu_data {
+	char name[MAX_NAME_LEN];
+	struct regul_description desc;
+	struct gpio_config en_gpio;
+	bool active_high;
+};
+
+static struct gpio_regu_data data[PLAT_NB_GPIO_REGUS];
+
+static int gpio_set_state(const struct regul_description *desc, bool state)
+{
+	struct gpio_regu_data *d = (struct gpio_regu_data *)desc->driver_data;
+	enum gpio_level level = GPIO_LEVEL_LOW;
+
+	VERBOSE("regul %s set state=%d\n", d->name, state);
+
+	if ((d->active_high && state) || (!d->active_high && !state)) {
+		level = GPIO_LEVEL_HIGH;
+	}
+
+	set_gpio_level(d->en_gpio.bank, d->en_gpio.pin, level);
+
+	return 0;
+}
+
+static int gpio_get_state(const struct regul_description *desc)
+{
+	struct gpio_regu_data *d = (struct gpio_regu_data *)desc->driver_data;
+	enum gpio_level level = get_gpio_level(d->en_gpio.bank, d->en_gpio.pin);
+
+	if ((d->active_high && level == GPIO_LEVEL_HIGH) ||
+	    (!d->active_high && level == GPIO_LEVEL_LOW)) {
+		return REGU_ENABLED;
+	}
+
+	return REGU_DISABLED;
+}
+
+static struct regul_ops gpio_regu_ops = {
+	.set_state = gpio_set_state,
+	.get_state = gpio_get_state,
+};
+
+static int read_gpio_config_from_dt(const void *fdt, int node, char *name,
+				    struct gpio_config *gpio)
+{
+	uint32_t utable[GPIO_DESC_SIZE];
+	int ret;
+
+	gpio->status = fdt_get_status(node);
+	if (gpio->status == DT_DISABLED) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	ret = fdt_read_uint32_array(fdt, node, name, GPIO_DESC_SIZE, utable);
+	if (ret != 0) {
+		ERROR("Missing gpio description\n");
+		return ret;
+	}
+
+	gpio->bank = utable[0];
+	gpio->pin = utable[1];
+	gpio->config = utable[2];
+
+	return 0;
+}
+
+int gpio_regulator_register(void)
+{
+	uint32_t count = 0U;
+	void *fdt;
+	int node = 0;
+
+	VERBOSE("gpio_regu reg init\n");
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	do {
+		int len __unused;
+		int ret;
+		struct gpio_regu_data *d = &data[count];
+		const char *reg_name;
+
+		node = fdt_node_offset_by_compatible(fdt, node, "st,stm32-regulator-gpio");
+		if (node < 0) {
+			break;
+		}
+
+		reg_name = fdt_get_name(fdt, node, NULL);
+
+		VERBOSE("register gpio_regu reg %s\n", reg_name);
+
+		if (count == PLAT_NB_GPIO_REGUS) {
+			WARN("Not enough place for regulators, PLAT_NB_GPIO_REGUS should be increased.\n");
+			return -ENOMEM;
+		}
+
+		len = snprintf(d->name, MAX_NAME_LEN - 1, "%s", reg_name);
+		assert((len > 0) && (len < (MAX_NAME_LEN - 1)));
+
+		d->desc.node_name = d->name;
+		d->desc.driver_data = d;
+		d->desc.ops = &gpio_regu_ops;
+
+		ret = read_gpio_config_from_dt(fdt, node, "st,enable-gpios", &d->en_gpio);
+		if (ret != 0) {
+			ERROR("Incorrect gpio regul description\n");
+			return ret;
+		}
+
+		VERBOSE("%s: en_gpio bank=%u pin=%u cfg=%x\n", d->name,
+			d->en_gpio.bank, d->en_gpio.pin, d->en_gpio.config);
+
+		set_gpio_config(d->en_gpio.bank, d->en_gpio.pin, d->en_gpio.config,
+				d->en_gpio.status);
+
+		if (fdt_getprop(fdt, node, "enable-active-high", NULL))
+			d->active_high = true;
+
+		ret = regulator_register(&d->desc, node);
+		if (ret != 0) {
+			WARN("Failed to register %s\n", reg_name);
+			return ret;
+		}
+
+		count++;
+	} while (node > 0);
+
+	return 0;
+}
diff --git a/drivers/st/reset/stm32mp1_reset.c b/drivers/st/reset/stm32mp1_reset.c
index 98c8dcf71..fb025cad3 100644
--- a/drivers/st/reset/stm32mp1_reset.c
+++ b/drivers/st/reset/stm32mp1_reset.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2019, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2018-2020, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -67,3 +67,34 @@ int stm32mp_reset_deassert(uint32_t id, unsigned int to_us)
 
 	return 0;
 }
+
+#if STM32MP15
+void stm32mp_reset_assert_deassert_to_mcu(bool assert_not_deassert)
+{
+	uintptr_t rcc_base = stm32mp_rcc_base();
+
+	/*
+	 * The RCC_MP_GCR is a read/write register.
+	 * Assert the MCU HOLD_BOOT means clear the BOOT_MCU bit
+	 * Deassert the MCU HOLD_BOOT means set the BOOT_MCU the bit
+	 */
+	if (assert_not_deassert) {
+		mmio_clrbits_32(rcc_base + RCC_MP_GCR, RCC_MP_GCR_BOOT_MCU);
+	} else {
+		mmio_setbits_32(rcc_base + RCC_MP_GCR, RCC_MP_GCR_BOOT_MCU);
+	}
+}
+#endif
+
+void __dead2 stm32mp_system_reset(void)
+{
+	uintptr_t rcc_base = stm32mp_rcc_base();
+
+	mmio_setbits_32(rcc_base + RCC_MP_GRSTCSETR,
+			RCC_MP_GRSTCSETR_MPSYSRST);
+
+	/* Loop in case system reset is not immediately caught */
+	for ( ; ; ) {
+		;
+	}
+}
diff --git a/drivers/st/reset/stm32mp2_reset.c b/drivers/st/reset/stm32mp2_reset.c
new file mode 100644
index 000000000..435415f1b
--- /dev/null
+++ b/drivers/st/reset/stm32mp2_reset.c
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2018-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <errno.h>
+#include <stdbool.h>
+
+#include <platform_def.h>
+
+#include <common/debug.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32mp_reset.h>
+#include <lib/mmio.h>
+#include <lib/utils_def.h>
+
+static uint32_t id2reg_offset(unsigned int reset_id)
+{
+	return ((reset_id & GENMASK(31, 5)) >> 5) * sizeof(uint32_t);
+}
+
+static uint8_t id2reg_bit_pos(unsigned int reset_id)
+{
+	return (uint8_t)(reset_id & GENMASK(4, 0));
+}
+
+static int reset_toggle(uint32_t id, unsigned int to_us, bool reset_status)
+{
+	uint32_t offset = id2reg_offset(id);
+	uint32_t bitmsk = BIT(id2reg_bit_pos(id));
+	uint32_t bit_check;
+	uintptr_t rcc_base = stm32mp_rcc_base();
+
+	if (reset_status) {
+		mmio_setbits_32(rcc_base + offset, bitmsk);
+		bit_check = bitmsk;
+	} else {
+		mmio_clrbits_32(rcc_base + offset, bitmsk);
+		bit_check = 0U;
+	}
+
+	if (to_us != 0U) {
+		uint64_t timeout_ref = timeout_init_us(to_us);
+
+		while ((mmio_read_32(rcc_base + offset) & bitmsk) != bit_check) {
+			if (timeout_elapsed(timeout_ref)) {
+				return -ETIMEDOUT;
+			}
+		}
+	}
+
+	return 0;
+}
+
+int stm32mp_reset_assert(uint32_t id, unsigned int to_us)
+{
+	return reset_toggle(id, to_us, true);
+}
+
+int stm32mp_reset_deassert(uint32_t id, unsigned int to_us)
+{
+	return reset_toggle(id, to_us, false);
+}
+
+void __dead2 stm32mp_system_reset(void)
+{
+	uintptr_t rcc_base = stm32mp_rcc_base();
+
+	mmio_setbits_32(rcc_base + RCC_GRSTCSETR, RCC_GRSTCSETR_SYSRST);
+
+	/* Loop in case system reset is not immediately caught */
+	for ( ; ; ) {
+		;
+	}
+}
diff --git a/drivers/st/rif/stm32mp2_risaf.c b/drivers/st/rif/stm32mp2_risaf.c
new file mode 100644
index 000000000..55500e82b
--- /dev/null
+++ b/drivers/st/rif/stm32mp2_risaf.c
@@ -0,0 +1,624 @@
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <stdint.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32mp2_risaf.h>
+#include <dt-bindings/soc/rif.h>
+#include <lib/mmio.h>
+#include <lib/utils_def.h>
+
+#ifdef CFG_DT
+#include <libfdt.h>
+#endif
+
+#include <platform_def.h>
+#include <plat/common/platform.h>
+#include <stm32mp_fconf_getter.h>
+
+/* RISAF general registers (base relative) */
+#define _RISAF_CR			U(0x00)
+#define _RISAF_SR			U(0x04)
+#define _RISAF_KEYR			U(0x30)
+#define _RISAF_HWCFGR			U(0xFF0)
+#define _RISAF_VERR			U(0xFF4)
+#define _RISAF_IPIDR			U(0xFF8)
+#define _RISAF_SIDR			U(0xFFC)
+
+/* RISAF general register field description */
+/* _RISAF_CR register fields */
+#define _RISAF_CR_GLOCK			BIT(0)
+/* _RISAF_SR register fields */
+#define _RISAF_SR_KEYVALID		BIT(0)
+#define _RISAF_SR_KEYRDY		BIT(1)
+#define _RISAF_SR_ENCDIS		BIT(2)
+/* _RISAF_HWCFGR register fields */
+#define _RISAF_HWCFGR_CFG1_SHIFT	0
+#define _RISAF_HWCFGR_CFG1_MASK		GENMASK_32(7, 0)
+#define _RISAF_HWCFGR_CFG2_SHIFT	8
+#define _RISAF_HWCFGR_CFG2_MASK		GENMASK_32(15, 8)
+#define _RISAF_HWCFGR_CFG3_SHIFT	16
+#define _RISAF_HWCFGR_CFG3_MASK		GENMASK_32(23, 16)
+#define _RISAF_HWCFGR_CFG4_SHIFT	24
+#define _RISAF_HWCFGR_CFG4_MASK		GENMASK_32(31, 24)
+/* _RISAF_VERR register fields */
+#define _RISAF_VERR_MINREV_SHIFT	0
+#define _RISAF_VERR_MINREV_MASK		GENMASK_32(3, 0)
+#define _RISAF_VERR_MAJREV_SHIFT	4
+#define _RISAF_VERR_MAJREV_MASK		GENMASK_32(7, 4)
+
+/* RISAF region registers (base relative) */
+#define _RISAF_REG_BASE			U(0x40)
+#define _RISAF_REG_SIZE			U(0x40)
+#define _RISAF_REG(n)			(_RISAF_REG_BASE + (((n) - 1) * _RISAF_REG_SIZE))
+#define _RISAF_REG_CFGR_OFFSET		U(0x0)
+#define _RISAF_REG_CFGR(n)		(_RISAF_REG(n) + _RISAF_REG_CFGR_OFFSET)
+#define _RISAF_REG_STARTR_OFFSET	U(0x4)
+#define _RISAF_REG_STARTR(n)		(_RISAF_REG(n) + _RISAF_REG_STARTR_OFFSET)
+#define _RISAF_REG_ENDR_OFFSET		U(0x8)
+#define _RISAF_REG_ENDR(n)		(_RISAF_REG(n) + _RISAF_REG_ENDR_OFFSET)
+#define _RISAF_REG_CIDCFGR_OFFSET	U(0xC)
+#define _RISAF_REG_CIDCFGR(n)		(_RISAF_REG(n) + _RISAF_REG_CIDCFGR_OFFSET)
+
+/* RISAF region register field description */
+/* _RISAF_REG_CFGR(n) register fields */
+#define _RISAF_REG_CFGR_BREN_SHIFT	0
+#define _RISAF_REG_CFGR_BREN		BIT(_RISAF_REG_CFGR_BREN_SHIFT)
+#define _RISAF_REG_CFGR_SEC_SHIFT	8
+#define _RISAF_REG_CFGR_SEC		BIT(_RISAF_REG_CFGR_SEC_SHIFT)
+#define _RISAF_REG_CFGR_ENC_SHIFT	15
+#define _RISAF_REG_CFGR_ENC		BIT(_RISAF_REG_CFGR_ENC_SHIFT)
+#define _RISAF_REG_CFGR_PRIVC_SHIFT	16
+#define _RISAF_REG_CFGR_PRIVC_MASK	GENMASK_32(23, 16)
+#define _RISAF_REG_CFGR_ALL_MASK	(_RISAF_REG_CFGR_BREN | _RISAF_REG_CFGR_SEC | \
+					 _RISAF_REG_CFGR_ENC | _RISAF_REG_CFGR_PRIVC_MASK)
+/* _RISAF_REG_CIDCFGR(n) register fields */
+#define _RISAF_REG_CIDCFGR_RDENC_SHIFT		0
+#define _RISAF_REG_CIDCFGR_RDENC_MASK		GENMASK_32(7, 0)
+#define _RISAF_REG_CIDCFGR_WRENC_SHIFT		16
+#define _RISAF_REG_CIDCFGR_WRENC_MASK		GENMASK_32(23, 16)
+#define _RISAF_REG_CIDCFGR_ALL_MASK		(_RISAF_REG_CIDCFGR_RDENC_MASK | \
+						 _RISAF_REG_CIDCFGR_WRENC_MASK)
+
+/* Device Tree related definitions */
+#define DT_RISAF_COMPAT			"st,stm32-risaf"
+#define DT_RISAF_REG_ID_MASK		U(0xF)
+#define DT_RISAF_EN_SHIFT		5
+#define DT_RISAF_EN_MASK		BIT(DT_RISAF_EN_SHIFT)
+#define DT_RISAF_SEC_SHIFT		6
+#define DT_RISAF_SEC_MASK		BIT(DT_RISAF_SEC_SHIFT)
+#define DT_RISAF_ENC_SHIFT		7
+#define DT_RISAF_ENC_MASK		BIT(DT_RISAF_ENC_SHIFT)
+#define DT_RISAF_PRIV_SHIFT		8
+#define DT_RISAF_PRIV_MASK		GENMASK_32(15, 8)
+#define DT_RISAF_READ_SHIFT		16
+#define DT_RISAF_READ_MASK		GENMASK_32(23, 16)
+#define DT_RISAF_WRITE_SHIFT		24
+#define DT_RISAF_WRITE_MASK		GENMASK_32(31, 24)
+
+/* RISAF max properties */
+#define RISAF_REGION_DT_PARAM		3
+#define RISAF_REGION_DT_SIZE		(RISAF_REGION_DT_PARAM * sizeof(uint32_t))
+#define RISAF_TIMEOUT_1MS_IN_US		U(1000)
+
+/* IP configuration */
+#define RISAF_MAJREV			U(0)
+#define RISAF_MINREV			U(1)
+#define RISAF_IP_ID			U(0x00100167)
+#define RISAF_SIZE_ID			U(0xA3C5DD01)
+
+#pragma weak stm32_risaf_get_instance
+#pragma weak stm32_risaf_get_base
+#pragma weak stm32_risaf_get_max_region
+#pragma weak stm32_risaf_get_memory_base
+#pragma weak stm32_risaf_get_memory_size
+#pragma weak stm32_risaf_preconf_process
+#pragma weak stm32_risaf_postconf_process
+
+struct stm32mp2_risaf_region {
+	int instance;
+	uint32_t cfg;
+	uint32_t addr;
+	uint32_t len;
+};
+
+struct stm32mp2_risaf_platdata {
+	uintptr_t *base;
+	struct stm32mp2_risaf_region *region;
+	int nregions;
+};
+
+struct stm32mp2_risaf_version {
+	uint32_t major;
+	uint32_t minor;
+	uint32_t ip_id;
+	uint32_t size_id;
+};
+
+struct risaf_dt_id_attr {
+	fdt32_t id_attr[RISAF_MAX_REGION * RISAF_REGION_DT_PARAM];
+};
+
+static struct stm32mp2_risaf_platdata stm32mp2_risaf;
+
+int stm32_risaf_get_instance(uintptr_t base)
+{
+	return -ENODEV;
+}
+
+uintptr_t stm32_risaf_get_base(int instance)
+{
+	return 0U;
+}
+
+int stm32_risaf_get_max_region(int instance)
+{
+	return -ENODEV;
+}
+
+uintptr_t stm32_risaf_get_memory_base(int instance)
+{
+	return 0U;
+}
+
+uint32_t stm32_risaf_get_memory_size(int instance)
+{
+	return 0U;
+}
+
+void stm32_risaf_preconf_process(uint32_t inst_mask)
+{
+}
+
+void stm32_risaf_postconf_process(uint32_t inst_mask)
+{
+}
+
+#if ENABLE_ASSERTIONS
+static bool valid_protreg_id(int instance, uint32_t id)
+{
+	uint32_t max_id;
+
+	max_id = mmio_read_32(stm32mp2_risaf.base[instance] + _RISAF_HWCFGR);
+	max_id = (max_id & _RISAF_HWCFGR_CFG1_MASK) >> _RISAF_HWCFGR_CFG1_SHIFT;
+
+	return id < max_id;
+}
+
+static bool valid_instance(int instance)
+{
+	return (instance < RISAF_MAX_INSTANCE) && (stm32mp2_risaf.base[instance] != 0U);
+}
+#endif
+
+static bool risaf_is_hw_encryption_functional(int instance)
+{
+	return (mmio_read_32(stm32mp2_risaf.base[instance] + _RISAF_SR) & _RISAF_SR_ENCDIS) !=
+	       _RISAF_SR_ENCDIS;
+}
+
+static int check_region_address(int instance, uint32_t addr, uint32_t len)
+{
+	uint32_t granularity;
+	uint64_t end_address;
+	uintptr_t mem_base = stm32_risaf_get_memory_base(instance);
+
+	if (addr < mem_base) {
+		ERROR("RISAF%d: region start address lower than memory base\n", instance + 1);
+		return -EINVAL;
+	}
+
+	if (len == 0) {
+		ERROR("RISAF%d: region length is equal to zero\n", instance + 1);
+		return -EINVAL;
+	}
+
+	/* Get physical end address */
+	end_address = mem_base + stm32_risaf_get_memory_size(instance) - 1U;
+	if (((uint64_t)addr > end_address) || ((uint64_t)(addr - 1U + len) > end_address)) {
+		ERROR("RISAF%d: start/end address higher than physical end\n", instance + 1);
+		return -EINVAL;
+	}
+
+	/* Get IP region granularity */
+	granularity = mmio_read_32(stm32mp2_risaf.base[instance] + _RISAF_HWCFGR);
+	granularity = BIT((granularity & _RISAF_HWCFGR_CFG3_MASK) >> _RISAF_HWCFGR_CFG3_SHIFT);
+	if (((addr % granularity) != 0U) || ((len % granularity) != 0U)) {
+		ERROR("RISAF%d: start/end address granularity not respected\n", instance + 1);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int risaf_configure_region(int instance, uint32_t region_id, uint32_t cfg,
+				  uint32_t cid_cfg, uint32_t saddr, uint32_t eaddr)
+{
+	uintptr_t base = stm32mp2_risaf.base[instance];
+	uint32_t hwcfgr;
+	uint32_t mask_lsb;
+	uint32_t mask_msb;
+	uint32_t mask;
+
+	assert(valid_instance(instance));
+	assert(valid_protreg_id(instance, region_id));
+
+	mmio_clrbits_32(base + _RISAF_REG_CFGR(region_id), _RISAF_REG_CFGR_BREN);
+
+	/* Get address mask depending on RISAF instance HW configuration */
+	hwcfgr =  mmio_read_32(base + _RISAF_HWCFGR);
+	mask_lsb = (hwcfgr & _RISAF_HWCFGR_CFG3_MASK) >> _RISAF_HWCFGR_CFG3_SHIFT;
+	mask_msb = mask_lsb + ((hwcfgr & _RISAF_HWCFGR_CFG4_MASK) >> _RISAF_HWCFGR_CFG4_SHIFT) - 1U;
+	mask = GENMASK_32(mask_msb, mask_lsb);
+
+	mmio_clrsetbits_32(base + _RISAF_REG_STARTR(region_id), mask, saddr & mask);
+	mmio_clrsetbits_32(base + _RISAF_REG_ENDR(region_id), mask, eaddr & mask);
+	mmio_clrsetbits_32(base + _RISAF_REG_CIDCFGR(region_id), _RISAF_REG_CIDCFGR_ALL_MASK,
+			   cid_cfg & _RISAF_REG_CIDCFGR_ALL_MASK);
+
+	mmio_clrsetbits_32(base + _RISAF_REG_CFGR(region_id),
+			   _RISAF_REG_CFGR_ALL_MASK, cfg & _RISAF_REG_CFGR_ALL_MASK);
+
+	if ((cfg & _RISAF_REG_CFGR_ENC) == _RISAF_REG_CFGR_ENC) {
+		if (!risaf_is_hw_encryption_functional(instance)) {
+			ERROR("RISAF%d: encryption feature error\n", instance + 1);
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+
+static void risaf_conf_protreg(void)
+{
+	struct stm32mp2_risaf_platdata *pdata = &stm32mp2_risaf;
+	int idx;
+
+	for (idx = 0; idx < RISAF_MAX_INSTANCE; idx++) {
+		int n;
+
+		if (pdata->base[idx] == 0) {
+			continue;
+		}
+
+		for (n = 0; n < pdata->nregions; n++) {
+			uint32_t id;
+			uint32_t value;
+			uint32_t cfg;
+			uint32_t cid_cfg;
+			uint32_t start_addr;
+			uint32_t end_addr;
+
+			if (pdata->region[n].instance != idx) {
+				continue;
+			}
+
+			if (check_region_address(idx, pdata->region[n].addr,
+						 pdata->region[n].len) != 0) {
+				panic();
+			}
+
+			value = pdata->region[n].cfg;
+			id = (value & DT_RISAF_REG_ID_MASK);
+			assert(valid_protreg_id(idx, id));
+
+			cfg = (((value & DT_RISAF_EN_MASK) >> DT_RISAF_EN_SHIFT) <<
+			       _RISAF_REG_CFGR_BREN_SHIFT) |
+			      (((value & DT_RISAF_SEC_MASK) >> DT_RISAF_SEC_SHIFT) <<
+			       _RISAF_REG_CFGR_SEC_SHIFT) |
+			      (((value & DT_RISAF_ENC_MASK) >> DT_RISAF_ENC_SHIFT) <<
+			       _RISAF_REG_CFGR_ENC_SHIFT) |
+			      (((value & DT_RISAF_PRIV_MASK) >> DT_RISAF_PRIV_SHIFT) <<
+			       _RISAF_REG_CFGR_PRIVC_SHIFT);
+
+			cid_cfg = (((value & DT_RISAF_WRITE_MASK) >> DT_RISAF_WRITE_SHIFT) <<
+				   _RISAF_REG_CIDCFGR_WRENC_SHIFT) |
+				  (((value & DT_RISAF_READ_MASK) >> DT_RISAF_READ_SHIFT) <<
+				   _RISAF_REG_CIDCFGR_RDENC_SHIFT);
+
+			start_addr = pdata->region[n].addr;
+			end_addr = (start_addr - 1U) + pdata->region[n].len;
+
+			if (risaf_configure_region(idx, id, cfg, cid_cfg,
+						   start_addr, end_addr) < 0) {
+				panic();
+			}
+		}
+	}
+}
+
+static void risaf_check_version(void)
+{
+	struct stm32mp2_risaf_platdata *pdata = &stm32mp2_risaf;
+	const struct stm32mp2_risaf_version exp_version = {
+		.major = RISAF_MAJREV,
+		.minor = RISAF_MINREV,
+		.ip_id = RISAF_IP_ID,
+		.size_id = RISAF_SIZE_ID
+	};
+	struct stm32mp2_risaf_version version;
+	int idx;
+
+	for (idx = 0; idx < RISAF_MAX_INSTANCE; idx++) {
+		if (pdata->base[idx] == 0) {
+			continue;
+		}
+
+		version = (struct stm32mp2_risaf_version) {
+			.major = (mmio_read_32(pdata->base[idx] + _RISAF_VERR) &
+				  _RISAF_VERR_MAJREV_MASK) >> _RISAF_VERR_MAJREV_SHIFT,
+			.minor = (mmio_read_32(pdata->base[idx] + _RISAF_VERR) &
+				  _RISAF_VERR_MINREV_MASK) >> _RISAF_VERR_MINREV_SHIFT,
+			.ip_id = mmio_read_32(pdata->base[idx] + _RISAF_IPIDR),
+			.size_id = mmio_read_32(pdata->base[idx] + _RISAF_SIDR)
+		};
+
+		if ((version.major != exp_version.major) ||
+		    (version.minor != exp_version.minor) ||
+		    (version.ip_id != exp_version.ip_id) ||
+		    (version.size_id != exp_version.size_id)) {
+			ERROR("RISAF%d: unexpected IP version { 0x%x, 0x%x, 0x%x, 0x%x }\n",
+			      idx + 1, version.major, version.minor, version.ip_id,
+			      version.size_id);
+			panic();
+		}
+	}
+}
+
+#ifdef CFG_DT
+static int risaf_get_dt_node(struct dt_node_info *info, int offset)
+{
+	return dt_get_node(info, offset, DT_RISAF_COMPAT);
+}
+
+static int risaf_get_base_from_fdt(void)
+{
+	struct dt_node_info risaf_info;
+	int node = -1;
+	void *fdt;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -ENOENT;
+	}
+
+	for (node = risaf_get_dt_node(&risaf_info, node); node >= 0;
+	     node = risaf_get_dt_node(&risaf_info, node)) {
+		int idx;
+
+		idx = stm32_risaf_get_instance(risaf_info.base);
+		if (idx < 0) {
+			continue;
+		}
+
+		stm32mp2_risaf.base[idx] = risaf_info.base;
+	}
+
+	return 0;
+}
+
+static int risaf_parse_fdt(void)
+{
+	struct stm32mp2_risaf_platdata *pdata = &stm32mp2_risaf;
+	struct dt_node_info risaf_info;
+	int node = -1;
+	void *fdt;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -ENOENT;
+	}
+
+	for (node = risaf_get_dt_node(&risaf_info, node); node >= 0;
+	     node = risaf_get_dt_node(&risaf_info, node)) {
+		int idx;
+		int nregions;
+		int inst_maxregions;
+		int i;
+		int len = 0;
+		const struct risaf_dt_id_attr *conf_list;
+
+		idx = stm32_risaf_get_instance(risaf_info.base);
+		if (idx < 0) {
+			continue;
+		}
+
+		conf_list = (const struct risaf_dt_id_attr *)fdt_getprop(fdt, node, "st,protreg",
+									 &len);
+		if (conf_list == NULL) {
+			INFO("RISAF%d: No configuration in DT, use default\n", idx + 1);
+			continue;
+		}
+
+		if ((len % RISAF_REGION_DT_SIZE) != 0) {
+			ERROR("RISAF%d: Wrongly formatted DT configuration\n", idx + 1);
+			return -EINVAL;
+		}
+
+		nregions = len / RISAF_REGION_DT_SIZE;
+
+		inst_maxregions = stm32_risaf_get_max_region(idx);
+		if (inst_maxregions <= 0) {
+			continue;
+		}
+
+		if ((nregions > inst_maxregions) ||
+		    ((pdata->nregions + nregions) > RISAF_MAX_REGION)) {
+			ERROR("RISAF%d: Too many entries in DT configuration\n", idx + 1);
+			return -EINVAL;
+		}
+
+		for (i = 0; i < nregions; i++) {
+			pdata->region[pdata->nregions + i].instance = idx;
+			pdata->region[pdata->nregions + i].cfg =
+				fdt32_to_cpu(conf_list->id_attr[i * RISAF_REGION_DT_PARAM]);
+			pdata->region[pdata->nregions + i].addr =
+				fdt32_to_cpu(conf_list->id_attr[(i * RISAF_REGION_DT_PARAM) + 1U]);
+			pdata->region[pdata->nregions + i].len =
+				fdt32_to_cpu(conf_list->id_attr[(i * RISAF_REGION_DT_PARAM) + 2U]);
+		}
+
+		pdata->nregions += nregions;
+	}
+
+	return 0;
+}
+#endif
+
+static uint32_t risaf_get_instance_mask(void)
+{
+	uint32_t inst_mask = 0U;
+	int idx;
+
+	/* Get all instances present in stm32mp2_risaf */
+	for (idx = 0; idx < RISAF_MAX_INSTANCE; idx++) {
+		if (stm32mp2_risaf.base[idx] != 0U) {
+			inst_mask |= BIT(idx);
+		}
+	}
+
+	return inst_mask;
+}
+
+uintptr_t risaf_base[RISAF_MAX_INSTANCE];
+struct stm32mp2_risaf_region risaf_region[RISAF_MAX_REGION];
+
+static int risaf_get_platdata(struct stm32mp2_risaf_platdata *pdata)
+{
+	pdata->base = risaf_base;
+	pdata->region = risaf_region;
+
+	return 0;
+}
+
+/*
+ * @brief  Write the MCE master key for a given instance.
+ * @param  instance: RISAF instance ID.
+ *         mkey: Pointer to the master key buffer.
+ * @retval 0 if OK, negative value else.
+ */
+int stm32mp2_risaf_write_master_key(int instance, uint8_t *mkey)
+{
+	uint64_t timeout_ref;
+	uint32_t i;
+	uintptr_t base = stm32mp2_risaf.base[instance];
+
+	if (base == 0U) {
+		return -EINVAL;
+	}
+
+	if (mkey == NULL) {
+		return -EINVAL;
+	}
+
+	for (i = 0U; i < RISAF_KEY_SIZE_IN_BYTES; i += sizeof(uint32_t)) {
+		uint32_t key_val = 0U;
+
+		memcpy(&key_val, mkey + i, sizeof(uint32_t));
+
+		mmio_write_32(base + _RISAF_KEYR + i, key_val);
+	}
+
+	timeout_ref = timeout_init_us(RISAF_TIMEOUT_1MS_IN_US);
+
+	while (((mmio_read_32(base + _RISAF_SR) & _RISAF_SR_KEYVALID) != _RISAF_SR_KEYVALID) ||
+	       ((mmio_read_32(base + _RISAF_SR) & _RISAF_SR_KEYRDY) != _RISAF_SR_KEYRDY)) {
+		if (timeout_elapsed(timeout_ref)) {
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * @brief  Lock the RISAF IP registers for a given instance.
+ * @param  instance: RISAF instance ID.
+ * @retval 0 if OK, negative value else.
+ */
+int stm32mp2_risaf_lock(int instance)
+{
+	uintptr_t base = stm32mp2_risaf.base[instance];
+
+	if (base == 0U) {
+		return -EINVAL;
+	}
+
+	mmio_setbits_32(base + _RISAF_CR, _RISAF_CR_GLOCK);
+
+	return 0;
+}
+
+/*
+ * @brief  Get the RISAF lock state for a given instance.
+ * @param  instance: RISAF instance ID.
+ *         state: lock state, true if locked, false else.
+ * @retval 0 if OK, negative value else.
+ */
+int stm32mp2_risaf_is_locked(int instance, bool *state)
+{
+	uintptr_t base = stm32mp2_risaf.base[instance];
+
+	if (base == 0U) {
+		return -EINVAL;
+	}
+
+	*state = (mmio_read_32(base + _RISAF_CR) & _RISAF_CR_GLOCK) == _RISAF_CR_GLOCK;
+
+	return 0;
+}
+
+int stm32mp2_risaf_init(void)
+{
+	int err;
+
+	err = risaf_get_platdata(&stm32mp2_risaf);
+	if (err != 0) {
+		return err;
+	}
+
+#ifdef CFG_DT
+	err = risaf_get_base_from_fdt();
+	if (err != 0) {
+		return err;
+	}
+#endif
+
+	stm32_risaf_preconf_process(risaf_get_instance_mask());
+
+	risaf_check_version();
+
+#ifndef CFG_DT
+	risaf_conf_protreg();
+
+	stm32_risaf_postconf_process(risaf_get_instance_mask());
+#endif
+
+	return err;
+}
+
+#ifdef CFG_DT
+static int fconf_populate_risaf(uintptr_t config)
+{
+	int err;
+
+	err = risaf_parse_fdt();
+	if (err != 0) {
+		return err;
+	}
+
+	risaf_conf_protreg();
+
+	stm32_risaf_postconf_process(risaf_get_instance_mask());
+
+	return err;
+}
+
+FCONF_REGISTER_POPULATOR(FW_CONFIG, risaf_config, fconf_populate_risaf);
+#endif
diff --git a/drivers/st/rng/stm32_rng.c b/drivers/st/rng/stm32_rng.c
new file mode 100644
index 000000000..90d1412d9
--- /dev/null
+++ b/drivers/st/rng/stm32_rng.c
@@ -0,0 +1,246 @@
+/*
+ * Copyright (c) 2018-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <stdbool.h>
+
+#include <libfdt.h>
+
+#include <platform_def.h>
+
+#include <arch_helpers.h>
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32_rng.h>
+#include <drivers/st/stm32mp_reset.h>
+#include <lib/mmio.h>
+
+#if STM32MP13 || STM32MP25
+#define DT_RNG_COMPAT		"st,stm32mp13-rng"
+#endif
+#if STM32MP15
+#define DT_RNG_COMPAT		"st,stm32-rng"
+#endif
+#define RNG_CR			0x00U
+#define RNG_SR			0x04U
+#define RNG_DR			0x08U
+
+#define RNG_CR_RNGEN		BIT(2)
+#define RNG_CR_IE		BIT(3)
+#define RNG_CR_CED		BIT(5)
+#define RNG_CR_CONDRST		BIT(30)
+
+#define RNG_SR_DRDY		BIT(0)
+#define RNG_SR_CECS		BIT(1)
+#define RNG_SR_SECS		BIT(2)
+#define RNG_SR_CEIS		BIT(5)
+#define RNG_SR_SEIS		BIT(6)
+
+#define RNG_TIMEOUT_US		100000
+#define RNG_TIMEOUT_STEP_US	10
+
+#define TIMEOUT_US_1MS		U(1000)
+
+struct stm32_rng_instance {
+	uintptr_t base;
+	unsigned long clock;
+};
+
+static struct stm32_rng_instance stm32_rng;
+
+static void seed_error_recovery(void)
+{
+	uint8_t i __unused;
+
+	/* Recommended by the SoC reference manual */
+	mmio_clrbits_32(stm32_rng.base + RNG_SR, RNG_SR_SEIS);
+	dmbsy();
+
+#if STM32MP15
+	/* No Auto-reset on STM32MP15, need to clean FIFO */
+	for (i = 12U; i != 0U; i--) {
+		(void)mmio_read_32(stm32_rng.base + RNG_DR);
+	}
+
+	dmbsy();
+#endif
+
+	if ((mmio_read_32(stm32_rng.base + RNG_SR) & RNG_SR_SEIS) != 0U) {
+		ERROR("RNG noise\n");
+		panic();
+	}
+}
+
+static int stm32_rng_enable(void)
+{
+	uint32_t sr;
+	uint64_t timeout;
+
+#if STM32MP13 || STM32MP25
+	/* Reset internal block and disable CED bit */
+	mmio_setbits_32(stm32_rng.base + RNG_CR, RNG_CR_CONDRST | RNG_CR_CED);
+	mmio_clrsetbits_32(stm32_rng.base + RNG_CR, RNG_CR_CONDRST, RNG_CR_RNGEN);
+#endif
+#if STM32MP15
+	mmio_write_32(stm32_rng.base + RNG_CR, RNG_CR_RNGEN | RNG_CR_CED);
+#endif
+
+	timeout = timeout_init_us(RNG_TIMEOUT_US);
+	sr = mmio_read_32(stm32_rng.base + RNG_SR);
+	while ((sr & RNG_SR_DRDY) == 0U) {
+		if (timeout_elapsed(timeout)) {
+			WARN("Timeout waiting\n");
+			return -ETIMEDOUT;
+		}
+
+		if ((sr & (RNG_SR_SECS | RNG_SR_SEIS)) != 0U) {
+			seed_error_recovery();
+			timeout = timeout_init_us(RNG_TIMEOUT_US);
+		}
+
+		udelay(RNG_TIMEOUT_STEP_US);
+		sr = mmio_read_32(stm32_rng.base + RNG_SR);
+	}
+
+	VERBOSE("Init RNG done\n");
+
+	return 0;
+}
+
+/*
+ * stm32_rng_read - Read a number of random bytes from RNG
+ * out: pointer to the output buffer
+ * size: number of bytes to be read
+ * Return 0 on success, non-0 on failure
+ */
+int stm32_rng_read(uint8_t *out, uint32_t size)
+{
+	uint8_t *buf = out;
+	size_t len = size;
+	int nb_tries;
+	uint32_t data32;
+	int rc = 0;
+	int count;
+
+	if (stm32_rng.base == 0U) {
+		return -EPERM;
+	}
+
+	while (len != 0U) {
+		nb_tries = RNG_TIMEOUT_US / RNG_TIMEOUT_STEP_US;
+		do {
+			uint32_t status = mmio_read_32(stm32_rng.base + RNG_SR);
+
+			if ((status & (RNG_SR_SECS | RNG_SR_SEIS)) != 0U) {
+				seed_error_recovery();
+			}
+
+			udelay(RNG_TIMEOUT_STEP_US);
+			nb_tries--;
+			if (nb_tries == 0) {
+				rc = -ETIMEDOUT;
+				goto bail;
+			}
+		} while ((mmio_read_32(stm32_rng.base + RNG_SR) &
+			  RNG_SR_DRDY) == 0U);
+
+		count = 4;
+		while (len != 0U) {
+			data32 = mmio_read_32(stm32_rng.base + RNG_DR);
+			count--;
+
+			memcpy(buf, &data32, MIN(len, sizeof(uint32_t)));
+			buf += MIN(len, sizeof(uint32_t));
+			len -= MIN(len, sizeof(uint32_t));
+
+			if (count == 0) {
+				break;
+			}
+		}
+	}
+
+bail:
+	if (rc != 0) {
+		memset(out, 0, buf - out);
+	}
+
+	return rc;
+}
+
+/*
+ * stm32_rng_init: Initialize rng from DT
+ * return 0 on success, negative value on failure
+ */
+int stm32_rng_init(void)
+{
+	void *fdt;
+	struct dt_node_info dt_rng;
+	int node;
+
+	if (stm32_rng.base != 0U) {
+		/* Driver is already initialized */
+		return 0;
+	}
+
+	if (fdt_get_address(&fdt) == 0) {
+		panic();
+	}
+
+	node = dt_get_node(&dt_rng, -1, DT_RNG_COMPAT);
+	if (node < 0) {
+		return 0;
+	}
+
+#if defined(IMAGE_BL2)
+	if (dt_rng.status == DT_DISABLED) {
+		return 0;
+	}
+#else
+	if ((dt_rng.status & DT_SECURE) == 0U) {
+		return 0;
+	}
+#endif
+
+	assert(dt_rng.base != 0U);
+
+	stm32_rng.base = dt_rng.base;
+
+#if defined(IMAGE_BL32)
+	if ((dt_rng.status & DT_NON_SECURE) == DT_NON_SECURE) {
+		stm32mp_register_non_secure_periph_iomem(stm32_rng.base);
+	} else {
+		stm32mp_register_secure_periph_iomem(stm32_rng.base);
+	}
+#endif
+
+	if (dt_rng.clock < 0) {
+		panic();
+	}
+
+	stm32_rng.clock = (unsigned long)dt_rng.clock;
+	clk_enable(stm32_rng.clock);
+
+	if (dt_rng.reset >= 0) {
+		int ret;
+
+		ret = stm32mp_reset_assert((unsigned long)dt_rng.reset,
+					   TIMEOUT_US_1MS);
+		if (ret != 0) {
+			panic();
+		}
+
+		udelay(20);
+
+		ret = stm32mp_reset_deassert((unsigned long)dt_rng.reset,
+					     TIMEOUT_US_1MS);
+		if (ret != 0) {
+			panic();
+		}
+	}
+
+	return stm32_rng_enable();
+}
diff --git a/drivers/st/rtc/stm32_rtc.c b/drivers/st/rtc/stm32_rtc.c
new file mode 100644
index 000000000..58d599b17
--- /dev/null
+++ b/drivers/st/rtc/stm32_rtc.c
@@ -0,0 +1,480 @@
+/*
+ * Copyright (c) 2018-2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+
+#include <platform_def.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/clk.h>
+#include <drivers/st/stm32_rtc.h>
+#include <drivers/st/stm32mp_clkfunc.h>
+#include <lib/mmio.h>
+#include <lib/spinlock.h>
+
+#define RTC_COMPAT		"st,stm32mp1-rtc"
+
+#define RTC_TR_SU_MASK		GENMASK(3, 0)
+#define RTC_TR_ST_MASK		GENMASK(6, 4)
+#define RTC_TR_ST_SHIFT		4
+#define RTC_TR_MNU_MASK		GENMASK(11, 8)
+#define RTC_TR_MNU_SHIFT	8
+#define RTC_TR_MNT_MASK		GENMASK(14, 12)
+#define RTC_TR_MNT_SHIFT	12
+#define RTC_TR_HU_MASK		GENMASK(19, 16)
+#define RTC_TR_HU_SHIFT		16
+#define RTC_TR_HT_MASK		GENMASK(21, 20)
+#define RTC_TR_HT_SHIFT		20
+#define RTC_TR_PM		BIT(22)
+
+#define RTC_DR_DU_MASK		GENMASK(3, 0)
+#define RTC_DR_DT_MASK		GENMASK(5, 4)
+#define RTC_DR_DT_SHIFT		4
+#define RTC_DR_MU_MASK		GENMASK(11, 8)
+#define RTC_DR_MU_SHIFT		8
+#define RTC_DR_MT		BIT(12)
+#define RTC_DR_MT_SHIFT		12
+#define RTC_DR_WDU_MASK		GENMASK(15, 13)
+#define RTC_DR_WDU_SHIFT	13
+#define RTC_DR_YU_MASK		GENMASK(19, 16)
+#define RTC_DR_YU_SHIFT		16
+#define RTC_DR_YT_MASK		GENMASK(23, 20)
+#define RTC_DR_YT_SHIFT		20
+
+#define RTC_SSR_SS_MASK		GENMASK(15, 0)
+
+#define RTC_ICSR_ALRAWF		BIT(0)
+#define RTC_ICSR_RSF		BIT(5)
+
+#define RTC_PRER_PREDIV_S_MASK	GENMASK(14, 0)
+
+#define RTC_CR_BYPSHAD		BIT(5)
+#define RTC_CR_BYPSHAD_SHIFT	5
+#define RTC_CR_ALRAE		BIT(8)
+#define RTC_CR_ALRAIE		BIT(12)
+#define RTC_CR_TAMPTS		BIT(25)
+
+#define RTC_SMCR_TS_DPROT	BIT(3)
+
+#define RTC_TSDR_DU_MASK	GENMASK(3, 0)
+#define RTC_TSDR_DU_SHIFT	0
+#define RTC_TSDR_DT_MASK	GENMASK(5, 4)
+#define RTC_TSDR_DT_SHIFT	4
+#define RTC_TSDR_MU_MASK	GENMASK(11, 8)
+#define RTC_TSDR_MU_SHIFT	8
+
+#define RTC_ALRMAR_DU_SHIFT	24
+
+#define RTC_SR_TSF		BIT(3)
+#define RTC_SR_TSOVF		BIT(4)
+
+#define RTC_SCR_CTSF		BIT(3)
+#define RTC_SCR_CTSOVF		BIT(4)
+
+#define RTC_WPR_KEY1		0xCA
+#define RTC_WPR_KEY2		0x53
+#define RTC_WPR_KEY_LOCK	0xFF
+
+static struct dt_node_info rtc_dev;
+
+static struct spinlock lock;
+
+void stm32_rtc_regs_lock(void)
+{
+	if (stm32mp_lock_available()) {
+		spin_lock(&lock);
+	}
+}
+
+void stm32_rtc_regs_unlock(void)
+{
+	if (stm32mp_lock_available()) {
+		spin_unlock(&lock);
+	}
+}
+
+static void stm32_rtc_write_unprotect(void)
+{
+	mmio_write_32(rtc_dev.base + RTC_WPR, RTC_WPR_KEY1);
+	mmio_write_32(rtc_dev.base + RTC_WPR, RTC_WPR_KEY2);
+}
+
+static void stm32_rtc_write_protect(void)
+{
+	mmio_write_32(rtc_dev.base + RTC_WPR, RTC_WPR_KEY_LOCK);
+}
+
+/*******************************************************************************
+ * This function gets the BYPSHAD bit value of the RTC_CR register.
+ * It will determine if we need to reset RTC_ISCR.RSF after each RTC calendar
+ * read, and also wait for RTC_ISCR.RSF=1 before next read.
+ * Returns true or false depending on the bit value.
+ ******************************************************************************/
+static bool stm32_rtc_get_bypshad(void)
+{
+	return ((mmio_read_32(rtc_dev.base + RTC_CR) & RTC_CR_BYPSHAD) >>
+		RTC_CR_BYPSHAD_SHIFT) != 0U;
+}
+
+/*******************************************************************************
+ * This function reads the RTC calendar register values.
+ * If shadow registers are not bypassed, then a reset/poll is done.
+ ******************************************************************************/
+static void stm32_rtc_read_calendar(struct stm32_rtc_calendar *calendar)
+{
+	bool bypshad = stm32_rtc_get_bypshad();
+
+	if (!bypshad) {
+		mmio_clrbits_32((uint32_t)(rtc_dev.base + RTC_ICSR),
+				RTC_ICSR_RSF);
+		while ((mmio_read_32(rtc_dev.base + RTC_ICSR) & RTC_ICSR_RSF) !=
+		       RTC_ICSR_RSF) {
+			;
+		}
+	}
+
+	calendar->ssr = mmio_read_32(rtc_dev.base + RTC_SSR);
+	calendar->tr = mmio_read_32(rtc_dev.base + RTC_TR);
+	calendar->dr = mmio_read_32(rtc_dev.base + RTC_DR);
+}
+
+/*******************************************************************************
+ * This function fill the rtc_time structure based on rtc_calendar register.
+ ******************************************************************************/
+static void stm32_rtc_get_time(struct stm32_rtc_calendar *cal,
+			       struct stm32_rtc_time *tm)
+{
+	assert(cal != NULL);
+	assert(tm != NULL);
+
+	tm->hour = (((cal->tr & RTC_TR_HT_MASK) >> RTC_TR_HT_SHIFT) * 10U) +
+		((cal->tr & RTC_TR_HU_MASK) >> RTC_TR_HU_SHIFT);
+
+	if ((cal->tr & RTC_TR_PM) != 0U) {
+		tm->hour += 12U;
+	}
+
+	tm->min = (((cal->tr & RTC_TR_MNT_MASK) >> RTC_TR_MNT_SHIFT) * 10U) +
+		  ((cal->tr & RTC_TR_MNU_MASK) >> RTC_TR_MNU_SHIFT);
+	tm->sec = (((cal->tr & RTC_TR_ST_MASK) >> RTC_TR_ST_SHIFT) * 10U) +
+		  (cal->tr & RTC_TR_SU_MASK);
+}
+
+/*******************************************************************************
+ * This function fill the rtc_time structure with the given date register.
+ ******************************************************************************/
+static void stm32_rtc_get_date(struct stm32_rtc_calendar *cal,
+			       struct stm32_rtc_time *tm)
+{
+	assert(cal != NULL);
+	assert(tm != NULL);
+
+	tm->wday = (((cal->dr & RTC_DR_WDU_MASK) >> RTC_DR_WDU_SHIFT));
+
+	tm->day = (((cal->dr & RTC_DR_DT_MASK) >> RTC_DR_DT_SHIFT) * 10U) +
+		  (cal->dr & RTC_DR_DU_MASK);
+
+	tm->month = (((cal->dr & RTC_DR_MT) >> RTC_DR_MT_SHIFT) * 10U) +
+		    ((cal->dr & RTC_DR_MU_MASK) >> RTC_DR_MU_SHIFT);
+
+	tm->year = (((cal->dr & RTC_DR_YT_MASK) >> RTC_DR_YT_SHIFT) * 10U) +
+		   ((cal->dr & RTC_DR_YU_MASK) >> RTC_DR_YU_SHIFT) + 2000U;
+}
+
+/*******************************************************************************
+ * This function reads the RTC timestamp register values and update time
+ * structure with the corresponding value.
+ ******************************************************************************/
+static void stm32_rtc_read_timestamp(struct stm32_rtc_time *time)
+{
+	assert(time != NULL);
+
+	struct stm32_rtc_calendar cal_tamp;
+
+	cal_tamp.tr = mmio_read_32(rtc_dev.base + RTC_TSTR);
+	cal_tamp.dr = mmio_read_32(rtc_dev.base + RTC_TSDR);
+	stm32_rtc_get_time(&cal_tamp, time);
+	stm32_rtc_get_date(&cal_tamp, time);
+}
+
+/*******************************************************************************
+ * This function gets the RTC calendar register values.
+ * It takes into account the need of reading twice or not, depending on
+ * frequencies previously setted, and the bypass or not of the shadow
+ * registers. This service is exposed externally.
+ ******************************************************************************/
+void stm32_rtc_get_calendar(struct stm32_rtc_calendar *calendar)
+{
+	bool read_twice = stm32mp1_rtc_get_read_twice();
+
+	stm32_rtc_regs_lock();
+	clk_enable(rtc_dev.clock);
+
+	stm32_rtc_read_calendar(calendar);
+
+	if (read_twice) {
+		uint32_t tr_save = calendar->tr;
+
+		stm32_rtc_read_calendar(calendar);
+
+		if (calendar->tr != tr_save) {
+			stm32_rtc_read_calendar(calendar);
+		}
+	}
+
+	clk_disable(rtc_dev.clock);
+	stm32_rtc_regs_unlock();
+}
+
+/*******************************************************************************
+ * This function computes the second fraction in milliseconds.
+ * The returned value is a uint32_t between 0 and 1000.
+ ******************************************************************************/
+static uint32_t stm32_rtc_get_second_fraction(struct stm32_rtc_calendar *cal)
+{
+	uint32_t prediv_s = mmio_read_32(rtc_dev.base + RTC_PRER) &
+			    RTC_PRER_PREDIV_S_MASK;
+	uint32_t ss = cal->ssr & RTC_SSR_SS_MASK;
+
+	return ((prediv_s - ss) * 1000U) / (prediv_s + 1U);
+}
+
+/*******************************************************************************
+ * This function computes the fraction difference between two timestamps.
+ * Here again the returned value is in milliseconds.
+ ******************************************************************************/
+static signed long long stm32_rtc_diff_frac(struct stm32_rtc_calendar *cur,
+					    struct stm32_rtc_calendar *ref)
+{
+	return (signed long long)stm32_rtc_get_second_fraction(cur) -
+	       (signed long long)stm32_rtc_get_second_fraction(ref);
+}
+
+/*******************************************************************************
+ * This function computes the time difference between two timestamps.
+ * It includes seconds, minutes and hours.
+ * Here again the returned value is in milliseconds.
+ ******************************************************************************/
+static signed long long stm32_rtc_diff_time(struct stm32_rtc_time *current,
+					    struct stm32_rtc_time *ref)
+{
+	signed long long curr_s;
+	signed long long ref_s;
+
+	curr_s = (signed long long)current->sec +
+		 (((signed long long)current->min +
+		  (((signed long long)current->hour * 60))) * 60);
+
+	ref_s = (signed long long)ref->sec +
+		(((signed long long)ref->min +
+		 (((signed long long)ref->hour * 60))) * 60);
+
+	return (curr_s - ref_s) * 1000;
+}
+
+/*******************************************************************************
+ * This function determines if the year is leap or not.
+ * Returned value is true or false.
+ ******************************************************************************/
+static bool stm32_is_a_leap_year(uint32_t year)
+{
+	return ((year % 4U) == 0U) &&
+	       (((year % 100U) != 0U) || ((year % 400U) == 0U));
+}
+
+/*******************************************************************************
+ * This function computes the date difference between two timestamps.
+ * It includes days, months, years, with exceptions.
+ * Here again the returned value is in milliseconds.
+ ******************************************************************************/
+static signed long long stm32_rtc_diff_date(struct stm32_rtc_time *current,
+					    struct stm32_rtc_time *ref)
+{
+	uint32_t diff_in_days = 0;
+	uint32_t m;
+	static const uint8_t month_len[NB_MONTHS] = {
+		31, 28, 31, 30, 31, 30,
+		31, 31, 30, 31, 30, 31
+	};
+
+	/* Get the number of non-entire month days */
+	if (current->day >= ref->day) {
+		diff_in_days += current->day - ref->day;
+	} else {
+		diff_in_days += (uint32_t)month_len[ref->month - 1U] -
+				ref->day + current->day;
+	}
+
+	/* Get the number of entire months, and compute the related days */
+	if (current->month > (ref->month + 1U)) {
+		for (m = (ref->month + 1U); (m < current->month) &&
+		     (m < 12U); m++) {
+			diff_in_days += (uint32_t)month_len[m - 1U];
+		}
+	}
+
+	if (current->month < (ref->month - 1U)) {
+		for (m = 1U; (m < current->month) && (m < 12U); m++) {
+			diff_in_days += (uint32_t)month_len[m - 1U];
+		}
+
+		for (m = (ref->month + 1U); m < 12U; m++) {
+			diff_in_days += (uint32_t)month_len[m - 1U];
+		}
+	}
+
+	/* Get complete years */
+	if (current->year > (ref->year + 1U)) {
+		diff_in_days += (current->year - ref->year - 1U) * 365U;
+	}
+
+	/* Particular cases: leap years (one day more) */
+	if (diff_in_days > 0U) {
+		if (current->year == ref->year) {
+			if (stm32_is_a_leap_year(current->year)) {
+				if ((ref->month <= 2U) &&
+				    (current->month >= 3U) &&
+				    (current->day <= 28U)) {
+					diff_in_days++;
+				}
+			}
+		} else {
+			uint32_t y;
+
+			/* Ref year is leap */
+			if ((stm32_is_a_leap_year(ref->year)) &&
+			    (ref->month <= 2U) && (ref->day <= 28U)) {
+				diff_in_days++;
+			}
+
+			/* Current year is leap */
+			if ((stm32_is_a_leap_year(current->year)) &&
+			    (current->month >= 3U)) {
+				diff_in_days++;
+			}
+
+			/* Interleaved years are leap */
+			for (y = ref->year + 1U; y < current->year; y++) {
+				if (stm32_is_a_leap_year(y)) {
+					diff_in_days++;
+				}
+			}
+		}
+	}
+
+	return (24 * 60 * 60 * 1000) * (signed long long)diff_in_days;
+}
+
+/*******************************************************************************
+ * This function computes the date difference between two rtc value.
+ * Here again the returned value is in milliseconds.
+ ******************************************************************************/
+unsigned long long stm32_rtc_diff_calendar(struct stm32_rtc_calendar *cur,
+					   struct stm32_rtc_calendar *ref)
+{
+	signed long long diff_in_ms = 0;
+	struct stm32_rtc_time curr_t;
+	struct stm32_rtc_time ref_t;
+
+	clk_enable(rtc_dev.clock);
+
+	stm32_rtc_get_date(cur, &curr_t);
+	stm32_rtc_get_date(ref, &ref_t);
+	stm32_rtc_get_time(cur, &curr_t);
+	stm32_rtc_get_time(ref, &ref_t);
+
+	diff_in_ms += stm32_rtc_diff_frac(cur, ref);
+	diff_in_ms += stm32_rtc_diff_time(&curr_t, &ref_t);
+	diff_in_ms += stm32_rtc_diff_date(&curr_t, &ref_t);
+
+	clk_disable(rtc_dev.clock);
+
+	return (unsigned long long)diff_in_ms;
+}
+
+/*******************************************************************************
+ * This function fill the RTC timestamp structure.
+ ******************************************************************************/
+void stm32_rtc_get_timestamp(struct stm32_rtc_time *tamp_ts)
+{
+	stm32_rtc_regs_lock();
+	clk_enable(rtc_dev.clock);
+
+	if ((mmio_read_32(rtc_dev.base + RTC_SR) & RTC_SR_TSF) != 0U) {
+		/* Print timestamp for tamper event */
+		stm32_rtc_read_timestamp(tamp_ts);
+		mmio_setbits_32(rtc_dev.base + RTC_SCR, RTC_SCR_CTSF);
+		if ((mmio_read_32(rtc_dev.base + RTC_SR) & RTC_SR_TSOVF) !=
+		    0U) {
+			/* Overflow detected */
+			mmio_setbits_32(rtc_dev.base + RTC_SCR, RTC_SCR_CTSOVF);
+		}
+	}
+
+	clk_disable(rtc_dev.clock);
+	stm32_rtc_regs_unlock();
+}
+
+/*******************************************************************************
+ * This function enable the timestamp bit for tamper and secure timestamp
+ * access.
+ ******************************************************************************/
+void stm32_rtc_set_tamper_timestamp(void)
+{
+	stm32_rtc_regs_lock();
+	clk_enable(rtc_dev.clock);
+
+	stm32_rtc_write_unprotect();
+
+	/* Enable tamper timestamper */
+	mmio_setbits_32(rtc_dev.base + RTC_CR, RTC_CR_TAMPTS);
+
+	/* Secure Timestamp bit */
+	mmio_clrbits_32(rtc_dev.base + RTC_SMCR, RTC_SMCR_TS_DPROT);
+
+	stm32_rtc_write_protect();
+
+	clk_disable(rtc_dev.clock);
+	stm32_rtc_regs_unlock();
+}
+
+/*******************************************************************************
+ * This function return state of tamper timestamp.
+ ******************************************************************************/
+bool stm32_rtc_is_timestamp_enable(void)
+{
+	bool ret;
+
+	clk_enable(rtc_dev.clock);
+
+	ret = (mmio_read_32(rtc_dev.base + RTC_CR) & RTC_CR_TAMPTS) != 0U;
+
+	clk_disable(rtc_dev.clock);
+
+	return ret;
+}
+
+/*******************************************************************************
+ * RTC initialisation function.
+ ******************************************************************************/
+int stm32_rtc_init(void)
+{
+	int node;
+
+	node = dt_get_node(&rtc_dev, -1, RTC_COMPAT);
+	if (node < 0) {
+		return node;
+	}
+
+	if (rtc_dev.status == DT_SECURE) {
+		stm32mp_register_secure_periph_iomem(rtc_dev.base);
+	} else {
+		stm32mp_register_non_secure_periph_iomem(rtc_dev.base);
+	}
+
+	return 0;
+}
diff --git a/drivers/st/spi/stm32_ospi.c b/drivers/st/spi/stm32_ospi.c
new file mode 100644
index 000000000..9c099767b
--- /dev/null
+++ b/drivers/st/spi/stm32_ospi.c
@@ -0,0 +1,595 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ */
+
+#include <inttypes.h>
+
+#include <libfdt.h>
+
+#include <platform_def.h>
+
+#include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/spi_mem.h>
+#include <drivers/st/stm32_gpio.h>
+#include <drivers/st/stm32_ospi.h>
+#include <drivers/st/stm32mp_reset.h>
+#include <lib/mmio.h>
+#include <lib/utils_def.h>
+
+/* Timeout for device interface reset */
+#define _TIMEOUT_US_1_MS	1000U
+
+/* OCTOSPI registers */
+#define _OSPI_CR		0x00U
+#define _OSPI_DCR1		0x08U
+#define _OSPI_DCR2		0x0CU
+#define _OSPI_SR		0x20U
+#define _OSPI_FCR		0x24U
+#define _OSPI_DLR		0x40U
+#define _OSPI_AR		0x48U
+#define _OSPI_DR		0x50U
+#define _OSPI_CCR		0x100U
+#define _OSPI_TCR		0x108U
+#define _OSPI_IR		0x110U
+#define _OSPI_ABR		0x120U
+
+/* OCTOSPI control register */
+#define _OSPI_CR_EN		BIT(0)
+#define _OSPI_CR_ABORT		BIT(1)
+#define _OSPI_CR_CSSEL		BIT(24)
+#define _OSPI_CR_FMODE		GENMASK_32(29, 28)
+#define _OSPI_CR_FMODE_SHIFT	28U
+#define _OSPI_CR_FMODE_INDW	0U
+#define _OSPI_CR_FMODE_INDR	1U
+#define _OSPI_CR_FMODE_MM	3U
+
+/* OCTOSPI device configuration register 1 */
+#define _OSPI_DCR1_CKMODE	BIT(0)
+#define _OSPI_DCR1_DLYBYP	BIT(3)
+#define _OSPI_DCR1_CSHT		GENMASK_32(13, 8)
+#define _OSPI_DCR1_CSHT_SHIFT	8U
+#define _OSPI_DCR1_DEVSIZE	GENMASK_32(20, 16)
+
+/* OCTOSPI device configuration register 2 */
+#define _OSPI_DCR2_PRESCALER	GENMASK_32(7, 0)
+
+/* OCTOSPI status register */
+#define _OSPI_SR_TEF		BIT(0)
+#define _OSPI_SR_TCF		BIT(1)
+#define _OSPI_SR_FTF		BIT(2)
+#define _OSPI_SR_SMF		BIT(3)
+#define _OSPI_SR_BUSY		BIT(5)
+
+/* OCTOSPI flag clear register */
+#define _OSPI_FCR_CTEF		BIT(0)
+#define _OSPI_FCR_CTCF		BIT(1)
+#define _OSPI_FCR_CSMF		BIT(3)
+
+/* OCTOSPI communication configuration register */
+#define _OSPI_CCR_ADMODE_SHIFT	8U
+#define _OSPI_CCR_ADSIZE_SHIFT	12U
+#define _OSPI_CCR_ABMODE_SHIFT	16U
+#define _OSPI_CCR_ABSIZE_SHIFT	20U
+#define _OSPI_CCR_DMODE_SHIFT	24U
+
+/* OCTOSPI timing configuration register */
+#define _OSPI_TCR_DCYC		GENMASK_32(4, 0)
+#define _OSPI_TCR_SSHIFT	BIT(30)
+
+#define _OSPI_MAX_CHIP		2U
+#define _OSPI_MAX_RESET		2U
+
+#define _OSPI_FIFO_TIMEOUT_US	30U
+#define _OSPI_CMD_TIMEOUT_US	1000U
+#define _OSPI_BUSY_TIMEOUT_US	100U
+#define _OSPI_ABT_TIMEOUT_US	100U
+
+#define _OMM_MAX_OSPI		2U
+
+#define _DT_IOM_COMPAT		"st,stm32mp25-omm"
+#define _DT_OSPI_COMPAT		"st,stm32mp25-omi"
+
+#define _FREQ_100MHZ		100000000U
+
+struct stm32_ospi_ctrl {
+	uintptr_t reg_base;
+	uintptr_t mm_base;
+	size_t mm_size;
+	unsigned long clock_id;
+};
+
+static struct stm32_ospi_ctrl stm32_ospi;
+
+static uintptr_t ospi_base(void)
+{
+	return stm32_ospi.reg_base;
+}
+
+static int stm32_ospi_wait_for_not_busy(void)
+{
+	uint64_t timeout = timeout_init_us(_OSPI_BUSY_TIMEOUT_US);
+
+	while ((mmio_read_32(ospi_base() + _OSPI_SR) & _OSPI_SR_BUSY) != 0U) {
+		if (timeout_elapsed(timeout)) {
+			ERROR("%s: busy timeout\n", __func__);
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_ospi_wait_cmd(const struct spi_mem_op *op)
+{
+	int ret = 0;
+	uint64_t timeout;
+
+	timeout = timeout_init_us(_OSPI_CMD_TIMEOUT_US);
+	while ((mmio_read_32(ospi_base() + _OSPI_SR) & _OSPI_SR_TCF) == 0U) {
+		if (timeout_elapsed(timeout)) {
+			ret = -ETIMEDOUT;
+			ERROR("%s: cmd timeout\n", __func__);
+			break;
+		}
+	}
+
+	if ((ret == 0) && ((mmio_read_32(ospi_base() + _OSPI_SR) &
+			   _OSPI_SR_TEF) != 0U)) {
+		ERROR("%s: transfer error\n", __func__);
+		ret = -EIO;
+	}
+
+	/* Clear flags */
+	mmio_write_32(ospi_base() + _OSPI_FCR, _OSPI_FCR_CTCF | _OSPI_FCR_CTEF);
+
+	if (ret == 0) {
+		ret = stm32_ospi_wait_for_not_busy();
+	}
+
+	return ret;
+}
+
+static void stm32_ospi_read_fifo(uint8_t *val, uintptr_t addr)
+{
+	*val = mmio_read_8(addr);
+}
+
+static void stm32_ospi_write_fifo(uint8_t *val, uintptr_t addr)
+{
+	mmio_write_8(addr, *val);
+}
+
+static int stm32_ospi_poll(const struct spi_mem_op *op)
+{
+	void (*fifo)(uint8_t *val, uintptr_t addr);
+	uint32_t len;
+	uint8_t *buf;
+
+	if (op->data.dir == SPI_MEM_DATA_IN) {
+		fifo = stm32_ospi_read_fifo;
+	} else {
+		fifo = stm32_ospi_write_fifo;
+	}
+
+	buf = (uint8_t *)op->data.buf;
+
+	for (len = op->data.nbytes; len != 0U; len--) {
+		uint64_t timeout = timeout_init_us(_OSPI_FIFO_TIMEOUT_US);
+
+		while ((mmio_read_32(ospi_base() + _OSPI_SR) &
+			_OSPI_SR_FTF) == 0U) {
+			if (timeout_elapsed(timeout)) {
+				ERROR("%s: fifo timeout\n", __func__);
+				return -ETIMEDOUT;
+			}
+		}
+
+		fifo(buf++, ospi_base() + _OSPI_DR);
+	}
+
+	return 0;
+}
+
+static int stm32_ospi_mm(const struct spi_mem_op *op)
+{
+	memcpy(op->data.buf,
+	       (void *)(stm32_ospi.mm_base + (size_t)op->addr.val),
+	       op->data.nbytes);
+
+	return 0;
+}
+
+static int stm32_ospi_tx(const struct spi_mem_op *op, uint8_t fmode)
+{
+	if (op->data.nbytes == 0U) {
+		return 0;
+	}
+
+	if (fmode == _OSPI_CR_FMODE_MM) {
+		return stm32_ospi_mm(op);
+	}
+
+	return stm32_ospi_poll(op);
+}
+
+static unsigned int stm32_ospi_get_mode(uint8_t buswidth)
+{
+	switch (buswidth) {
+	case SPI_MEM_BUSWIDTH_8_LINE:
+		return 4U;
+	case SPI_MEM_BUSWIDTH_4_LINE:
+		return 3U;
+	default:
+		return buswidth;
+	}
+}
+
+static int stm32_ospi_send(const struct spi_mem_op *op, uint8_t fmode)
+{
+	uint64_t timeout;
+	uint32_t ccr;
+	uint32_t dcyc = 0U;
+	int ret;
+
+	VERBOSE("%s: cmd:%x mode:%d.%d.%d.%d addr:%" PRIx64 " len:%x\n",
+		__func__, op->cmd.opcode, op->cmd.buswidth, op->addr.buswidth,
+		op->dummy.buswidth, op->data.buswidth,
+		op->addr.val, op->data.nbytes);
+
+	ret = stm32_ospi_wait_for_not_busy();
+	if (ret != 0) {
+		return ret;
+	}
+
+	if (op->data.nbytes != 0U) {
+		mmio_write_32(ospi_base() + _OSPI_DLR, op->data.nbytes - 1U);
+	}
+
+	if ((op->dummy.buswidth != 0U) && (op->dummy.nbytes != 0U)) {
+		dcyc = op->dummy.nbytes * 8U / op->dummy.buswidth;
+	}
+
+	mmio_clrsetbits_32(ospi_base() + _OSPI_TCR, _OSPI_TCR_DCYC, dcyc);
+
+	mmio_clrsetbits_32(ospi_base() + _OSPI_CR, _OSPI_CR_FMODE,
+			   fmode << _OSPI_CR_FMODE_SHIFT);
+
+	ccr = stm32_ospi_get_mode(op->cmd.buswidth);
+
+	if (op->addr.nbytes != 0U) {
+		ccr |= (op->addr.nbytes - 1U) << _OSPI_CCR_ADSIZE_SHIFT;
+		ccr |= stm32_ospi_get_mode(op->addr.buswidth) <<
+		       _OSPI_CCR_ADMODE_SHIFT;
+	}
+
+	if (op->data.nbytes != 0U) {
+		ccr |= stm32_ospi_get_mode(op->data.buswidth) <<
+		       _OSPI_CCR_DMODE_SHIFT;
+	}
+
+	mmio_write_32(ospi_base() + _OSPI_CCR, ccr);
+
+	mmio_write_32(ospi_base() + _OSPI_IR, op->cmd.opcode);
+
+	if ((op->addr.nbytes != 0U) && (fmode != _OSPI_CR_FMODE_MM)) {
+		mmio_write_32(ospi_base() + _OSPI_AR, op->addr.val);
+	}
+
+	ret = stm32_ospi_tx(op, fmode);
+
+	/*
+	 * Abort in:
+	 * - Error case.
+	 * - Memory mapped read: prefetching must be stopped if we read the last
+	 *   byte of device (device size - fifo size). If device size is not
+	 *   known then prefetching is always stopped.
+	 */
+	if ((ret != 0) || (fmode == _OSPI_CR_FMODE_MM)) {
+		goto abort;
+	}
+
+	/* Wait end of TX in indirect mode */
+	ret = stm32_ospi_wait_cmd(op);
+	if (ret != 0) {
+		goto abort;
+	}
+
+	return 0;
+
+abort:
+	mmio_setbits_32(ospi_base() + _OSPI_CR, _OSPI_CR_ABORT);
+
+	/* Wait clear of abort bit by hardware */
+	timeout = timeout_init_us(_OSPI_ABT_TIMEOUT_US);
+	while ((mmio_read_32(ospi_base() + _OSPI_CR) & _OSPI_CR_ABORT) != 0U) {
+		if (timeout_elapsed(timeout)) {
+			ret = -ETIMEDOUT;
+			break;
+		}
+	}
+
+	mmio_write_32(ospi_base() + _OSPI_FCR, _OSPI_FCR_CTCF);
+
+	if (ret != 0) {
+		ERROR("%s: exec op error\n", __func__);
+	}
+
+	return ret;
+}
+
+static int stm32_ospi_exec_op(const struct spi_mem_op *op)
+{
+	uint8_t fmode = _OSPI_CR_FMODE_INDW;
+
+	if ((op->data.dir == SPI_MEM_DATA_IN) && (op->data.nbytes != 0U)) {
+		fmode = _OSPI_CR_FMODE_INDR;
+	}
+
+	return stm32_ospi_send(op, fmode);
+}
+
+static int stm32_ospi_dirmap_read(const struct spi_mem_op *op)
+{
+	size_t addr_max;
+	uint8_t fmode = _OSPI_CR_FMODE_INDR;
+
+	addr_max = op->addr.val + op->data.nbytes + 1U;
+	if ((addr_max < stm32_ospi.mm_size) && (op->addr.buswidth != 0U)) {
+		fmode = _OSPI_CR_FMODE_MM;
+	}
+
+	return stm32_ospi_send(op, fmode);
+}
+
+static int stm32_ospi_claim_bus(unsigned int cs)
+{
+	uint32_t cr;
+
+	if (cs >= _OSPI_MAX_CHIP) {
+		return -ENODEV;
+	}
+
+	/* Set chip select and enable the controller */
+	cr = _OSPI_CR_EN;
+	if (cs == 1U) {
+		cr |= _OSPI_CR_CSSEL;
+	}
+
+	mmio_clrsetbits_32(ospi_base() + _OSPI_CR, _OSPI_CR_CSSEL, cr);
+
+	return 0;
+}
+
+static void stm32_ospi_release_bus(void)
+{
+	mmio_clrbits_32(ospi_base() + _OSPI_CR, _OSPI_CR_EN);
+}
+
+static int stm32_ospi_set_speed(unsigned int hz)
+{
+	unsigned long ospi_clk = clk_get_rate(stm32_ospi.clock_id);
+	uint32_t prescaler = UINT8_MAX;
+	uint32_t csht;
+	int ret;
+
+	if (ospi_clk == 0U) {
+		return -EINVAL;
+	}
+
+	if (hz > 0U) {
+		prescaler = div_round_up(ospi_clk, hz) - 1U;
+		if (prescaler > UINT8_MAX) {
+			prescaler = UINT8_MAX;
+		}
+	}
+
+	csht = div_round_up((5U * ospi_clk) / (prescaler + 1U), _FREQ_100MHZ);
+	csht = ((csht - 1U) << _OSPI_DCR1_CSHT_SHIFT) & _OSPI_DCR1_CSHT;
+
+	ret = stm32_ospi_wait_for_not_busy();
+	if (ret != 0) {
+		return ret;
+	}
+
+	mmio_clrsetbits_32(ospi_base() + _OSPI_DCR2, _OSPI_DCR2_PRESCALER,
+			   prescaler);
+
+	mmio_clrsetbits_32(ospi_base() + _OSPI_DCR1, _OSPI_DCR1_CSHT, csht);
+
+	VERBOSE("%s: speed=%lu\n", __func__, ospi_clk / (prescaler + 1U));
+
+	return 0;
+}
+
+static int stm32_ospi_set_mode(unsigned int mode)
+{
+	int ret;
+
+	if ((mode & SPI_CS_HIGH) != 0U) {
+		return -ENODEV;
+	}
+
+	ret = stm32_ospi_wait_for_not_busy();
+	if (ret != 0) {
+		return ret;
+	}
+
+	if (((mode & SPI_CPHA) != 0U) && ((mode & SPI_CPOL) != 0U)) {
+		mmio_setbits_32(ospi_base() + _OSPI_DCR1, _OSPI_DCR1_CKMODE);
+	} else if (((mode & SPI_CPHA) == 0U) && ((mode & SPI_CPOL) == 0U)) {
+		mmio_clrbits_32(ospi_base() + _OSPI_DCR1, _OSPI_DCR1_CKMODE);
+	} else {
+		return -ENODEV;
+	}
+
+#if DEBUG
+	VERBOSE("%s: mode=0x%x\n", __func__, mode);
+
+	if ((mode & SPI_RX_OCTAL) != 0U) {
+		VERBOSE("rx: octal\n");
+	} else if ((mode & SPI_RX_QUAD) != 0U) {
+		VERBOSE("rx: quad\n");
+	} else if ((mode & SPI_RX_DUAL) != 0U) {
+		VERBOSE("rx: dual\n");
+	} else {
+		VERBOSE("rx: single\n");
+	}
+
+	if ((mode & SPI_TX_OCTAL) != 0U) {
+		VERBOSE("tx: octal\n");
+	} else if ((mode & SPI_TX_QUAD) != 0U) {
+		VERBOSE("tx: quad\n");
+	} else if ((mode & SPI_TX_DUAL) != 0U) {
+		VERBOSE("tx: dual\n");
+	} else {
+		VERBOSE("tx: single\n");
+	}
+#endif
+
+	return 0;
+}
+
+static const struct spi_bus_ops stm32_ospi_bus_ops = {
+	.claim_bus = stm32_ospi_claim_bus,
+	.release_bus = stm32_ospi_release_bus,
+	.set_speed = stm32_ospi_set_speed,
+	.set_mode = stm32_ospi_set_mode,
+	.exec_op = stm32_ospi_exec_op,
+	.dirmap_read = stm32_ospi_dirmap_read,
+};
+
+int stm32_ospi_init(void)
+{
+	int iom_node;
+	int ospi_node;
+	int ret;
+	int len;
+	const fdt32_t *cuint;
+	void *fdt = NULL;
+	unsigned int i;
+	unsigned int nb_ospi_nodes = 0U;
+	unsigned int reset_id;
+	uintptr_t bank_address[_OMM_MAX_OSPI] = { 0U, 0U };
+	uintptr_t mm_base;
+	uint8_t bank_assigned = 0U;
+	uint8_t bank;
+	size_t mm_size;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	iom_node = fdt_node_offset_by_compatible(fdt, -1, _DT_IOM_COMPAT);
+	if (iom_node < 0) {
+		return iom_node;
+	}
+
+	if (fdt_get_status(iom_node) == DT_DISABLED) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	ret = fdt_get_reg_props_by_name(fdt, iom_node, "omm_mm",
+					&mm_base, &mm_size);
+	if (ret != 0) {
+		return ret;
+	}
+
+	cuint = fdt_getprop(fdt, iom_node, "ranges", NULL);
+	if (cuint == NULL) {
+		return -FDT_ERR_BADVALUE;
+	}
+
+	for (i = 0U; i < _OMM_MAX_OSPI; i++) {
+		bank = fdt32_to_cpu(*cuint);
+		if ((bank >= _OMM_MAX_OSPI) ||
+		    ((bank_assigned & BIT(bank)) != 0U)) {
+			return -FDT_ERR_BADVALUE;
+		}
+
+		bank_assigned |= BIT(bank);
+		bank_address[bank] = fdt32_to_cpu(*(cuint + 2U));
+		cuint += 4U;
+	}
+
+	if (dt_set_pinctrl_config(iom_node) != 0) {
+		return -FDT_ERR_BADVALUE;
+	}
+
+	fdt_for_each_subnode(ospi_node, fdt, iom_node) {
+		nb_ospi_nodes++;
+	}
+
+	if (nb_ospi_nodes != 1U) {
+		WARN("Only one OSPI node supported\n");
+		return -FDT_ERR_BADVALUE;
+	}
+
+	/* Parse OSPI controller node */
+	ospi_node = fdt_node_offset_by_compatible(fdt, iom_node,
+						  _DT_OSPI_COMPAT);
+	if (ospi_node < 0) {
+		return ospi_node;
+	}
+
+	if (fdt_get_status(ospi_node) == DT_DISABLED) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	cuint = fdt_getprop(fdt, ospi_node, "reg", NULL);
+	if (cuint == NULL) {
+		return -FDT_ERR_BADVALUE;
+	}
+
+	bank = fdt32_to_cpu(*cuint);
+	if (bank >= _OMM_MAX_OSPI) {
+		return -FDT_ERR_BADVALUE;
+	}
+
+	stm32_ospi.reg_base = fdt32_to_cpu(*(cuint + 1U)) + bank_address[bank];
+	stm32_ospi.mm_size = stm32mp2_syscfg_get_mm_size(bank);
+	stm32_ospi.mm_base = bank == 0U ?
+			     mm_base : mm_base + mm_size - stm32_ospi.mm_size;
+
+	cuint = fdt_getprop(fdt, ospi_node, "clocks", NULL);
+	if (cuint == NULL) {
+		return -FDT_ERR_BADVALUE;
+	}
+
+	cuint++;
+	stm32_ospi.clock_id = (unsigned long)fdt32_to_cpu(*cuint);
+	clk_enable(stm32_ospi.clock_id);
+
+	cuint = fdt_getprop(fdt, ospi_node, "resets", &len);
+	if (cuint != NULL) {
+		cuint++;
+
+		/* Reset: array of <phandle, reset_id> */
+		for (i = 0U;
+		     i < ((uint32_t)len / (sizeof(uint32_t) * _OSPI_MAX_RESET));
+		     i++, cuint += _OSPI_MAX_RESET) {
+			reset_id = (unsigned int)fdt32_to_cpu(*cuint);
+
+			ret = stm32mp_reset_assert(reset_id, _TIMEOUT_US_1_MS);
+			if (ret != 0) {
+				panic();
+			}
+
+			ret = stm32mp_reset_deassert(reset_id,
+						     _TIMEOUT_US_1_MS);
+			if (ret != 0) {
+				panic();
+			}
+		}
+	}
+
+	mmio_write_32(ospi_base() + _OSPI_TCR, _OSPI_TCR_SSHIFT);
+	mmio_write_32(ospi_base() + _OSPI_DCR1,
+		      _OSPI_DCR1_DEVSIZE | _OSPI_DCR1_DLYBYP);
+
+	return spi_mem_init_slave(fdt, ospi_node, &stm32_ospi_bus_ops);
+};
diff --git a/drivers/st/spi/stm32_qspi.c b/drivers/st/spi/stm32_qspi.c
index 4b1a0296c..731844067 100644
--- a/drivers/st/spi/stm32_qspi.c
+++ b/drivers/st/spi/stm32_qspi.c
@@ -11,6 +11,7 @@
 
 #include <common/debug.h>
 #include <common/fdt_wrappers.h>
+#include <drivers/clk.h>
 #include <drivers/delay_timer.h>
 #include <drivers/spi_mem.h>
 #include <drivers/st/stm32_gpio.h>
@@ -138,10 +139,6 @@ static int stm32_qspi_wait_cmd(const struct spi_mem_op *op)
 	int ret = 0;
 	uint64_t timeout;
 
-	if (op->data.nbytes == 0U) {
-		return stm32_qspi_wait_for_not_busy();
-	}
-
 	timeout = timeout_init_us(QSPI_CMD_TIMEOUT_US);
 	while ((mmio_read_32(qspi_base() + QSPI_SR) & QSPI_SR_TCF) == 0U) {
 		if (timeout_elapsed(timeout)) {
@@ -162,6 +159,10 @@ static int stm32_qspi_wait_cmd(const struct spi_mem_op *op)
 	/* Clear flags */
 	mmio_write_32(qspi_base() + QSPI_FCR, QSPI_FCR_CTCF | QSPI_FCR_CTEF);
 
+	if (ret == 0) {
+		ret = stm32_qspi_wait_for_not_busy();
+	}
+
 	return ret;
 }
 
@@ -250,11 +251,6 @@ static int stm32_qspi_exec_op(const struct spi_mem_op *op)
 		op->dummy.buswidth, op->data.buswidth,
 		op->addr.val, op->data.nbytes);
 
-	ret = stm32_qspi_wait_for_not_busy();
-	if (ret != 0) {
-		return ret;
-	}
-
 	addr_max = op->addr.val + op->data.nbytes + 1U;
 
 	if ((op->data.dir == SPI_MEM_DATA_IN) && (op->data.nbytes != 0U)) {
@@ -364,7 +360,7 @@ static void stm32_qspi_release_bus(void)
 
 static int stm32_qspi_set_speed(unsigned int hz)
 {
-	unsigned long qspi_clk = stm32mp_clk_get_rate(stm32_qspi.clock_id);
+	unsigned long qspi_clk = clk_get_rate(stm32_qspi.clock_id);
 	uint32_t prescaler = UINT8_MAX;
 	uint32_t csht;
 	int ret;
@@ -494,7 +490,7 @@ int stm32_qspi_init(void)
 	stm32_qspi.clock_id = (unsigned long)info.clock;
 	stm32_qspi.reset_id = (unsigned int)info.reset;
 
-	stm32mp_clk_enable(stm32_qspi.clock_id);
+	clk_enable(stm32_qspi.clock_id);
 
 	ret = stm32mp_reset_assert(stm32_qspi.reset_id, TIMEOUT_US_1_MS);
 	if (ret != 0) {
diff --git a/drivers/st/tamper/stm32_tamp.c b/drivers/st/tamper/stm32_tamp.c
new file mode 100644
index 000000000..e75caee29
--- /dev/null
+++ b/drivers/st/tamper/stm32_tamp.c
@@ -0,0 +1,681 @@
+/*
+ * Copyright (c) 2018-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+
+#include <libfdt.h>
+
+#include <platform_def.h>
+
+#include <drivers/arm/gicv2.h>
+#include <drivers/clk.h>
+#include <drivers/st/stm32_gpio.h>
+#include <drivers/st/stm32mp_reset.h>
+#include <drivers/st/stm32_rng.h>
+#include <drivers/st/stm32_rtc.h>
+#include <drivers/st/stm32_tamp.h>
+#include <lib/mmio.h>
+
+#define DT_TAMP_COMPAT			"st,stm32-tamp"
+/* STM32 Registers */
+#define _TAMP_CR1			0x00U
+#define _TAMP_CR2			0x04U
+#define _TAMP_FLTCR			0x0CU
+#define _TAMP_ATCR1			0x10U
+#define _TAMP_ATSEEDR			0x14U
+#define _TAMP_ATOR			0x18U
+#define _TAMP_SMCR			0x20U
+#define _TAMP_IER			0x2CU
+#define _TAMP_SR			0x30U
+#define _TAMP_MISR			0x34U
+#define _TAMP_SMISR			0x38U
+#define _TAMP_SCR			0x3CU
+#define _TAMP_COUNTR			0x40U
+#define _TAMP_OR			0x50U
+#define _TAMP_HWCFGR2			0x3ECU
+#define _TAMP_HWCFGR1			0x3F0U
+#define _TAMP_VERR			0x3F4U
+#define _TAMP_IPIDR			0x3F8U
+#define _TAMP_SIDR			0x3FCU
+
+/* _TAMP_CR1 bit filds */
+#define _TAMP_CR1_ITAMP(id)		BIT((id) + 16U)
+#define _TAMP_CR1_ETAMP(id)		BIT((id))
+
+/* _TAMP_CR2 bit filds */
+#define _TAMP_CR2_ETAMPTRG(id)		BIT((id) + 24U)
+#define _TAMP_CR2_ETAMPMSK_MAX_ID	3U
+#define _TAMP_CR2_ETAMPMSK(id)		BIT((id) + 16U)
+#define _TAMP_CR2_ETAMPNOER(id)		BIT((id))
+
+/* _TAMP_FLTCR bit fields */
+#define _TAMP_FLTCR_TAMPFREQ		GENMASK(2, 0)
+#define _TAMP_FLTCR_TAMPFLT		GENMASK(4, 3)
+#define _TAMP_FLTCR_TAMPPRCH		GENMASK(6, 5)
+#define _TAMP_FLTCR_TAMPPUDIS		BIT(7)
+
+/* _TAMP_ATCR bit fields */
+#define _TAMP_ATCR1_ATCKSEL		GENMASK(18, 16)
+#define _TAMP_ATCR1_ATPER		GENMASK(26, 24)
+#define _TAMP_ATCR1_COMMON_MASK		GENMASK(31, 16)
+#define _TAMP_ATCR1_ETAMPAM(id)		BIT((id))
+#define _TAMP_ATCR1_ATOSEL_MASK(i)	GENMASK(((i) + 1) * 2U + 7U, (i) * 2U + 8U)
+#define _TAMP_ATCR1_ATOSEL(i, o)	(((o) - 1U) << ((i) * 2U + 8U))
+
+/* _TAMP_ATOR bit fields */
+#define _TAMP_PRNG			GENMASK(7, 0)
+#define _TAMP_SEEDF			BIT(14)
+#define _TAMP_INITS			BIT(15)
+
+/* _TAMP_IER bit fields */
+#define _TAMP_IER_ITAMP(id)		BIT((id) + 16U)
+#define _TAMP_IER_ETAMP(id)		BIT((id))
+
+/* _TAMP_SR bit fields */
+#define _TAMP_SR_ETAMPXF_MASK		GENMASK(7, 0)
+#define _TAMP_SR_ITAMPXF_MASK		GENMASK(31, 16)
+#define _TAMP_SR_ITAMP(id)		BIT((id) + 16U)
+#define _TAMP_SR_ETAMP(id)		BIT((id))
+
+/* _TAMP_SCR bit fields */
+#define _TAMP_SCR_ITAMP(id)		BIT((id) + 16U)
+#define _TAMP_SCR_ETAMP(id)		BIT((id))
+
+/* _TAMP_SMCR bit fields */
+#define _TAMP_SMCR_BKPRWDPROT_MASK	GENMASK(7, 0)
+#define _TAMP_SMCR_BKPRWDPROT_SHIFT	U(0)
+#define _TAMP_SMCR_BKPWDPROT_MASK	GENMASK(23, 16)
+#define _TAMP_SMCR_BKPWDPROT_SHIFT	U(16)
+#define _TAMP_SMCR_DPROT		BIT(31)
+
+/* _TAMP_OR bit fields */
+#define _TAMP_OR_OUT3RMP_PI8		0U
+#define _TAMP_OR_OUT3RMP_PC13		BIT(0)
+
+/* _TAMP_HWCFGR2 bit fields */
+#define _TAMP_HWCFGR2_TZ		GENMASK(11, 8)
+#define _TAMP_HWCFGR2_OR		GENMASK(7, 0)
+
+/* _TAMP_HWCFGR1 bit fields */
+#define _TAMP_HWCFGR1_BKPREG		GENMASK(7, 0)
+#define _TAMP_HWCFGR1_TAMPER		GENMASK(11, 8)
+#define _TAMP_HWCFGR1_ACTIVE		GENMASK(15, 12)
+#define _TAMP_HWCFGR1_INTERN		GENMASK(31, 16)
+#define _TAMP_HWCFGR1_ITAMP_MAX_ID	16U
+#define _TAMP_HWCFGR1_ITAMP(id)		BIT((id) + 16U)
+
+/* _TAMP_VERR bit fields */
+#define _TAMP_VERR_MINREV		GENMASK(3, 0)
+#define _TAMP_VERR_MAJREV		GENMASK(7, 4)
+
+#define _TAMP_NB_MONOTONIC_COUNTER	0x1
+
+/*
+ * Macro to manage bit manipulation when we work on local variable
+ * before writing only once to the real register
+ */
+
+#define CLRBITS(v, bits)		(v) &= ~(bits)
+#define SETBITS(v, bits)		(v) |= (bits)
+#define CLRSETBITS(v, mask, bits)	(v) = ((v) & ~(mask)) | (bits)
+
+struct stm32_tamp_int {
+	const uint32_t id;
+	uint32_t mode;
+	int (*func)(int id);
+};
+
+struct stm32_tamp_ext {
+	const uint32_t id;
+	uint32_t mode;
+	uint8_t out_pin;
+	int (*func)(int id);
+};
+
+struct stm32_tamp_instance {
+	uintptr_t base;
+	uint32_t clock;
+	uint32_t hwconf1;
+	uint32_t hwconf2;
+	uint32_t secret_list_conf;
+	uint32_t privilege_conf;
+	uint32_t secure_conf;
+	uint32_t passive_conf;
+	uint32_t active_conf;
+	struct stm32_tamp_int int_tamp[PLAT_MAX_TAMP_INT];
+	struct stm32_tamp_ext ext_tamp[PLAT_MAX_TAMP_EXT];
+};
+
+/* 0 is the expected initial values for all fields but .id */
+static struct stm32_tamp_instance stm32_tamp = {
+	.int_tamp = {
+		{
+			.id = INT_TAMP1,
+		},
+		{
+			.id = INT_TAMP2,
+		},
+		{
+			.id = INT_TAMP3,
+		},
+		{
+			.id = INT_TAMP4,
+		},
+		{
+			.id = INT_TAMP5,
+		},
+		{
+			.id = INT_TAMP8,
+		},
+	},
+	.ext_tamp = {
+		{
+			.id = EXT_TAMP1,
+		},
+		{
+			.id = EXT_TAMP2,
+		},
+		{
+			.id = EXT_TAMP3,
+		},
+	}
+};
+
+static void stm32_tamp_set_secure(unsigned long base, uint32_t mode)
+{
+	if (mode & TAMP_REGS_IT_SECURE) {
+		mmio_clrbits_32(base + _TAMP_SMCR, _TAMP_SMCR_DPROT);
+	} else {
+		mmio_setbits_32(base + _TAMP_SMCR, _TAMP_SMCR_DPROT);
+	}
+}
+
+static void stm32_tamp_set_privilege(unsigned long base __unused, uint32_t mode __unused)
+{
+}
+
+static void stm32_tamp_set_output_pin(unsigned long base, uint32_t out)
+{
+	mmio_setbits_32(base + _TAMP_OR, out);
+}
+
+static int stm32_tamp_set_seed(unsigned long base)
+{
+	/* Need RNG access. */
+	uint32_t timeout = 100;
+	uint8_t idx;
+
+	for (idx = 0; idx < 4U; idx++) {
+		uint32_t rnd;
+
+		if (stm32_rng_read((uint8_t *)&rnd, sizeof(uint32_t)) != 0) {
+			return -1;
+		}
+
+		VERBOSE("Seed init %u\n", rnd);
+		mmio_write_32(base + _TAMP_ATSEEDR, rnd);
+	}
+
+	while (((mmio_read_32(base + _TAMP_ATOR) & _TAMP_SEEDF) != 0U) &&
+	       (timeout != 0U)) {
+		timeout--;
+	}
+
+	if (timeout == 0U) {
+		return -1;
+	}
+
+	return 0;
+}
+
+static bool is_int_tamp_id_valid(uint32_t id)
+{
+	if (id > _TAMP_HWCFGR1_ITAMP_MAX_ID) {
+		return false;
+	}
+
+	return (stm32_tamp.hwconf1 & _TAMP_HWCFGR1_ITAMP(id))
+		== _TAMP_HWCFGR1_ITAMP(id);
+}
+
+static bool is_ext_tamp_id_valid(uint32_t id)
+{
+	if (id > PLAT_MAX_TAMP_EXT) {
+		return false;
+	}
+
+	return true;
+}
+
+static int stm32_tamp_set_int_config(struct stm32_tamp_int *tamp_int,
+				     uint32_t *cr1, uint32_t *cr3, uint32_t *ier)
+{
+	uint32_t id;
+
+	if (tamp_int == NULL) {
+		return -EINVAL;
+	}
+
+	id = tamp_int->id;
+
+	if (!is_int_tamp_id_valid(id)) {
+		return -EINVAL;
+	}
+
+	/* If etamp is disabled */
+	if ((tamp_int->mode & TAMP_ENABLE) != TAMP_ENABLE) {
+		CLRBITS(*cr1, _TAMP_CR1_ITAMP(id));
+		CLRBITS(*ier, _TAMP_IER_ITAMP(id));
+		return 0;
+	}
+
+	SETBITS(*cr1, _TAMP_CR1_ITAMP(id));
+	SETBITS(*ier, _TAMP_IER_ITAMP(id));
+
+	return 0;
+}
+
+static int stm32_tamp_set_ext_config(struct stm32_tamp_ext *tamp_ext,
+				     uint32_t *cr1, uint32_t *cr2,
+				     uint32_t *atcr1, uint32_t *atcr2, uint32_t *ier)
+{
+	uint32_t id;
+
+	if (tamp_ext == NULL) {
+		return -EINVAL;
+	}
+
+	id = tamp_ext->id;
+
+	/* Exit if not a valid TAMP_ID */
+	if (!is_ext_tamp_id_valid(id)) {
+		return -EINVAL;
+	}
+
+	/* If etamp is disabled */
+	if ((tamp_ext->mode & TAMP_ENABLE) != TAMP_ENABLE) {
+		CLRBITS(*cr1, _TAMP_CR1_ETAMP(id));
+		CLRBITS(*cr2, _TAMP_CR2_ETAMPMSK(id));
+		CLRBITS(*cr2, _TAMP_CR2_ETAMPTRG(id));
+		CLRBITS(*cr2, _TAMP_CR2_ETAMPNOER(id));
+		CLRBITS(*ier, _TAMP_IER_ETAMP(id));
+		return 0;
+	}
+
+	SETBITS(*cr1, _TAMP_CR1_ETAMP(id));
+
+	if ((tamp_ext->mode & TAMP_TRIG_ON) == TAMP_TRIG_ON) {
+		SETBITS(*cr2, _TAMP_CR2_ETAMPTRG(id));
+	} else {
+		CLRBITS(*cr2, _TAMP_CR2_ETAMPTRG(id));
+	}
+
+	if ((tamp_ext->mode & TAMP_ACTIVE) == TAMP_ACTIVE) {
+		SETBITS(*atcr1, _TAMP_ATCR1_ETAMPAM(id));
+	} else {
+		CLRBITS(*atcr1, _TAMP_ATCR1_ETAMPAM(id));
+	}
+
+	if ((tamp_ext->mode & TAMP_NOERASE) == TAMP_NOERASE) {
+		SETBITS(*cr2, _TAMP_CR2_ETAMPNOER(id));
+	} else {
+		CLRBITS(*cr2, _TAMP_CR2_ETAMPNOER(id));
+	}
+
+	/* Configure output pin:
+	 * For the case out_pin = 0, we select same output pin than the input one.
+	 */
+	if (tamp_ext->out_pin == TAMPOUTSEL_SAME_AS_INPUT) {
+		tamp_ext->out_pin = id + 1;
+	}
+
+	if (tamp_ext->out_pin < PLAT_MAX_TAMP_EXT + 1U) {
+		CLRSETBITS(*atcr1, _TAMP_ATCR1_ATOSEL_MASK(id),
+			   _TAMP_ATCR1_ATOSEL(id, tamp_ext->out_pin));
+	}
+
+	if (id < _TAMP_CR2_ETAMPMSK_MAX_ID) {
+		/*
+		 * Only external TAMP 1, 2 and 3 can be masked
+		 */
+		if ((tamp_ext->mode & TAMP_EVT_MASK) == TAMP_EVT_MASK) {
+			/*
+			 * ETAMP(id) event generates a trigger event. This ETAMP(id) is masked
+			 * and internally cleared by hardware. The backup registers are not erased.
+			 */
+			CLRBITS(*ier, _TAMP_IER_ETAMP(id));
+			SETBITS(*cr2, _TAMP_CR2_ETAMPMSK(id));
+		} else {
+			/*
+			 * normal ETAMP interrupt:
+			 * ETAMP(id) event generates a trigger event and TAMP(id)F must be cleared
+			 * by software to * allow next tamper event detection.
+			 */
+			CLRBITS(*cr2, _TAMP_CR2_ETAMPMSK(id));
+			SETBITS(*ier, _TAMP_IER_ETAMP(id));
+		}
+	} else {
+		/* other than 1,2,3 external TAMP, we want its interruption */
+		SETBITS(*ier, _TAMP_IER_ETAMP(id));
+	}
+
+	return 0;
+}
+
+int stm32_tamp_set_secure_bkpregs(struct bkpregs_conf *bkpregs_conf)
+{
+	uint32_t first_z2;
+	uint32_t first_z3;
+
+	if (bkpregs_conf == NULL) {
+		return -EINVAL;
+	}
+
+	first_z2 = bkpregs_conf->nb_zone1_regs;
+	first_z3 = bkpregs_conf->nb_zone1_regs + bkpregs_conf->nb_zone2_regs;
+
+	if ((first_z2 > (stm32_tamp.hwconf1 & _TAMP_HWCFGR1_BKPREG)) ||
+	    (first_z3 > (stm32_tamp.hwconf1 & _TAMP_HWCFGR1_BKPREG))) {
+		return -ENODEV;
+	}
+
+	mmio_clrsetbits_32(stm32_tamp.base + _TAMP_SMCR,
+			   _TAMP_SMCR_BKPRWDPROT_MASK,
+			   (first_z2 << _TAMP_SMCR_BKPRWDPROT_SHIFT) &
+			   _TAMP_SMCR_BKPRWDPROT_MASK);
+
+	mmio_clrsetbits_32(stm32_tamp.base + _TAMP_SMCR,
+			   _TAMP_SMCR_BKPWDPROT_MASK,
+			   (first_z3 << _TAMP_SMCR_BKPWDPROT_SHIFT) &
+			   _TAMP_SMCR_BKPWDPROT_MASK);
+	return 0;
+}
+
+int stm32_tamp_set_config(void)
+{
+	int ret;
+	uint32_t i;
+	uint32_t cr1 = 0, cr2 = 0, cr3 = 0;
+	uint32_t atcr1 = 0, atcr2 = 0;
+	uint32_t fltcr = 0;
+	uint32_t ier = 0;
+
+	/* Select access in secure or unsecure */
+	stm32_tamp_set_secure(stm32_tamp.base, stm32_tamp.secure_conf);
+
+	/* Select acces in privileged mode or unprivileged mode */
+	stm32_tamp_set_privilege(stm32_tamp.base, stm32_tamp.privilege_conf);
+
+	if (stm32_tamp.passive_conf != 0U) {
+		/* Filter mode register set */
+		fltcr = stm32_tamp.passive_conf;
+	}
+
+	if (stm32_tamp.active_conf != 0U) {
+		/* Active mode configuration */
+		CLRSETBITS(atcr1, _TAMP_ATCR1_COMMON_MASK,
+			   (stm32_tamp.active_conf & _TAMP_ATCR1_COMMON_MASK));
+	}
+
+	for (i = 0U; i < PLAT_MAX_TAMP_INT; i++) {
+		ret = stm32_tamp_set_int_config(&(stm32_tamp.int_tamp[i]),
+						&cr1, &cr3, &ier);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	for (i = 0U; i < PLAT_MAX_TAMP_EXT; i++) {
+		ret = stm32_tamp_set_ext_config(&(stm32_tamp.ext_tamp[i]),
+						&cr1, &cr2, &atcr1, &atcr2, &ier);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	/*
+	 * We apply configuration all in a row:
+	 * As for active ext tamper "all the needed tampers must be enabled in the same write
+	 * access".
+	 */
+	mmio_write_32(stm32_tamp.base + _TAMP_FLTCR, fltcr);
+	/* Active filter configuration applied only if not already done. */
+	if (((mmio_read_32(stm32_tamp.base + _TAMP_ATOR) & _TAMP_INITS) != _TAMP_INITS)) {
+		mmio_write_32(stm32_tamp.base + _TAMP_ATCR1, atcr1);
+	}
+
+	mmio_write_32(stm32_tamp.base + _TAMP_CR1, cr1);
+	mmio_write_32(stm32_tamp.base + _TAMP_CR2, cr2);
+	/* If active tamper we reinit the seed. */
+	if (stm32_tamp.active_conf != 0U) {
+		if (stm32_tamp_set_seed(stm32_tamp.base) != 0) {
+			ERROR("Active tamper: SEED not initialized\n");
+			return -EPERM;
+		}
+	}
+
+	/* Ack all pending interrupt */
+	mmio_write_32(stm32_tamp.base + _TAMP_SCR, ~0U);
+	/* Enable interrupts. */
+	mmio_write_32(stm32_tamp.base + _TAMP_IER, ier);
+
+	return 0;
+}
+
+int stm32_tamp_write_mcounter(int counter_idx)
+{
+	mmio_write_32(stm32_tamp.base + _TAMP_COUNTR, 1U);
+
+	return 0;
+}
+
+uint32_t stm32_tamp_read_mcounter(int counter_idx)
+{
+	return mmio_read_32(stm32_tamp.base + _TAMP_COUNTR);
+}
+
+void stm32_tamp_configure_secret_list(uint32_t secret_list_conf)
+{
+	stm32_tamp.secret_list_conf = secret_list_conf;
+}
+
+void stm32_tamp_configure_privilege_access(uint32_t privilege_conf)
+{
+	stm32_tamp.privilege_conf = privilege_conf;
+}
+
+void stm32_tamp_configure_secure_access(uint32_t secure_conf)
+{
+	stm32_tamp.secure_conf = secure_conf;
+}
+
+void stm32_tamp_configure_passive(uint32_t passive_conf)
+{
+	stm32_tamp.passive_conf = passive_conf;
+}
+
+void stm32_tamp_configure_active(uint32_t active_conf)
+{
+	stm32_tamp.active_conf = active_conf;
+}
+
+int stm32_tamp_configure_internal(enum stm32_tamp_int_id id, uint32_t mode, int (*callback)(int id))
+{
+	uint32_t i;
+	uint32_t itamp_id = id;
+	struct stm32_tamp_int *tamp_int = NULL;
+
+	/* Find internal Tamp struct*/
+	for (i = 0U; i < PLAT_MAX_TAMP_INT; i++) {
+		if (stm32_tamp.int_tamp[i].id == itamp_id) {
+			tamp_int = &(stm32_tamp.int_tamp[i]);
+			break;
+		}
+	}
+
+	if (tamp_int == NULL) {
+		return -EINVAL;
+	}
+
+	tamp_int->mode = mode;
+	tamp_int->func = callback;
+
+	return 0;
+}
+
+int stm32_tamp_configure_external(enum stm32_tamp_ext_id id, uint32_t mode,
+				  enum stm32_tamp_ext_out_id out_pin, int (*callback)(int id))
+{
+	uint32_t i;
+	uint32_t etamp_id = id;
+	struct stm32_tamp_ext *tamp_ext = NULL;
+
+	/* Find external Tamp struct */
+	for (i = 0U; i < PLAT_MAX_TAMP_EXT; i++) {
+		if (stm32_tamp.ext_tamp[i].id == etamp_id) {
+			tamp_ext = &(stm32_tamp.ext_tamp[i]);
+			break;
+		}
+	}
+
+	if (tamp_ext == NULL) {
+		return -EINVAL;
+	}
+
+	tamp_ext->mode = mode;
+	tamp_ext->out_pin = out_pin;
+	tamp_ext->func = callback;
+
+	return 0;
+}
+
+void stm32_tamp_it_handler(void)
+{
+	uint32_t it = mmio_read_32(stm32_tamp.base + _TAMP_SR);
+	uint32_t int_it = it & _TAMP_SR_ITAMPXF_MASK;
+	uint32_t ext_it = it & _TAMP_SR_ETAMPXF_MASK;
+	uint8_t tamp = 0;
+	struct stm32_rtc_time tamp_ts;
+
+	if (stm32_rtc_is_timestamp_enable()) {
+		stm32_rtc_get_timestamp(&tamp_ts);
+		INFO("Tamper Event Occurred\n");
+		INFO("Date : %u/%u\n \t Time : %u:%u:%u\n",
+		     tamp_ts.day, tamp_ts.month, tamp_ts.hour,
+		     tamp_ts.min, tamp_ts.sec);
+	}
+
+	while ((int_it != 0U) && (tamp < PLAT_MAX_TAMP_INT)) {
+		int ret = -1;
+		uint32_t int_id = stm32_tamp.int_tamp[tamp].id;
+
+		if ((it & _TAMP_SR_ITAMP(int_id)) != 0U) {
+			if (stm32_tamp.int_tamp[tamp].func != NULL) {
+				ret = stm32_tamp.int_tamp[tamp].func(int_id);
+			}
+
+			if (ret >= 0) {
+				mmio_setbits_32(stm32_tamp.base + _TAMP_SCR,
+						_TAMP_SR_ITAMP(int_id));
+				ext_it &= ~_TAMP_SR_ITAMP(int_id);
+
+				if (ret > 0) {
+					stm32mp_system_reset();
+				}
+			}
+		}
+		tamp++;
+	}
+
+	tamp = 0;
+	/* External tamper interrupt */
+	while ((ext_it != 0U) && (tamp < PLAT_MAX_TAMP_EXT)) {
+		int ret = -1;
+		uint32_t ext_id = stm32_tamp.ext_tamp[tamp].id;
+
+		if ((ext_it & _TAMP_SR_ETAMP(ext_id)) != 0U) {
+			if (stm32_tamp.ext_tamp[tamp].func != NULL) {
+				ret = stm32_tamp.ext_tamp[tamp].func(ext_id);
+			}
+
+			if (ret >= 0) {
+				mmio_setbits_32(stm32_tamp.base + _TAMP_SCR,
+						_TAMP_SCR_ETAMP(ext_id));
+				ext_it &= ~_TAMP_SR_ETAMP(ext_id);
+
+				if (ret > 0) {
+					stm32mp_system_reset();
+				}
+			}
+		}
+		tamp++;
+	}
+
+	gicv2_end_of_interrupt(STM32MP1_IRQ_TAMPSERRS);
+}
+
+int stm32_tamp_init(void)
+{
+	int node;
+	struct dt_node_info dt_tamp;
+	void *fdt;
+	uint32_t rev __unused;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -EPERM;
+	}
+
+	node = dt_get_node(&dt_tamp, -1, DT_TAMP_COMPAT);
+	if (node < 0) {
+		return -EINVAL;
+	}
+
+	assert(dt_tamp.base != 0U);
+	assert(dt_tamp.clock != -1);
+
+	stm32_tamp.base = dt_tamp.base;
+	stm32_tamp.clock = (uint32_t)dt_tamp.clock;
+
+	/* Init Tamp clock */
+	clk_enable(stm32_tamp.clock);
+
+	/* Check if TAMP is enabled */
+	if (dt_tamp.status == DT_DISABLED) {
+		return 0;
+	}
+
+	stm32_tamp.hwconf1 = mmio_read_32(stm32_tamp.base + _TAMP_HWCFGR1);
+	stm32_tamp.hwconf2 = mmio_read_32(stm32_tamp.base + _TAMP_HWCFGR2);
+
+#if LOG_LEVEL >= LOG_LEVEL_VERBOSE
+	rev = mmio_read_32(stm32_tamp.base + _TAMP_VERR);
+	VERBOSE("STM32 TAMPER V%u.%u\n", (rev & _TAMP_VERR_MAJREV) >> 4,
+		rev & _TAMP_VERR_MINREV);
+#endif
+
+	if ((stm32_tamp.hwconf2 & _TAMP_HWCFGR2_TZ) == 0U) {
+		ERROR("Tamper IP doesn't support trustzone");
+		return -EPERM;
+	}
+
+	if (dt_set_pinctrl_config(node) != -FDT_ERR_NOTFOUND) {
+		if (fdt_getprop(fdt, node, "st,out3-pc13", NULL) != NULL) {
+			stm32_tamp_set_output_pin(stm32_tamp.base, _TAMP_OR_OUT3RMP_PC13);
+		}
+	}
+
+	if (stm32mp_gic_enable_spi(node, NULL) < 0) {
+		return -EPERM;
+	}
+
+	if (fdt_getprop(fdt, node, "wakeup-source", NULL) != NULL) {
+		mmio_setbits_32(EXTI_BASE + EXTI_TZENR1, EXTI_TZENR1_TZEN18);
+		mmio_setbits_32(EXTI_BASE + EXTI_C1IMR1, EXTI_IMR1_IM18);
+	}
+
+	return 1;
+}
diff --git a/drivers/st/timer/stm32_timer.c b/drivers/st/timer/stm32_timer.c
new file mode 100644
index 000000000..980367688
--- /dev/null
+++ b/drivers/st/timer/stm32_timer.c
@@ -0,0 +1,322 @@
+/*
+ * Copyright (c) 2018-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <stdbool.h>
+
+#include <libfdt.h>
+
+#include <platform_def.h>
+
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32_timer.h>
+#include <lib/mmio.h>
+
+#define TIM_CR1			0x00U		/* Control Register 1      */
+#define TIM_CR2			0x04U		/* Control Register 2      */
+#define TIM_SMCR		0x08U		/* Slave mode control reg  */
+#define TIM_DIER		0x0CU		/* DMA/interrupt register  */
+#define TIM_SR			0x10U		/* Status register	   */
+#define TIM_EGR			0x14U		/* Event Generation Reg    */
+#define TIM_CCMR1		0x18U		/* Capt/Comp 1 Mode Reg    */
+#define TIM_CCMR2		0x1CU		/* Capt/Comp 2 Mode Reg    */
+#define TIM_CCER		0x20U		/* Capt/Comp Enable Reg    */
+#define TIM_CNT			0x24U		/* Counter		   */
+#define TIM_PSC			0x28U		/* Prescaler               */
+#define TIM_ARR			0x2CU		/* Auto-Reload Register    */
+#define TIM_CCR1		0x34U		/* Capt/Comp Register 1    */
+#define TIM_CCR2		0x38U		/* Capt/Comp Register 2    */
+#define TIM_CCR3		0x3CU		/* Capt/Comp Register 3    */
+#define TIM_CCR4		0x40U		/* Capt/Comp Register 4    */
+#define TIM_BDTR		0x44U		/* Break and Dead-Time Reg */
+#define TIM_DCR			0x48U		/* DMA control register    */
+#define TIM_DMAR		0x4CU		/* DMA transfer register   */
+#define TIM_AF1			0x60U		/* Alt Function Reg 1      */
+#define TIM_AF2			0x64U		/* Alt Function Reg 2      */
+#define TIM_TISEL		0x68U		/* Input Selection         */
+
+#define TIM_CR1_CEN		BIT(0)
+#define TIM_SMCR_SMS		GENMASK(2, 0)	/* Slave mode selection */
+#define TIM_SMCR_TS		GENMASK(6, 4)	/* Trigger selection */
+#define TIM_CCMR_CC1S_TI1	BIT(0)		/* IC1/IC3 selects TI1/TI3 */
+#define TIM_CCMR_CC1S_TI2	BIT(1)		/* IC1/IC3 selects TI2/TI4 */
+#define TIM_CCMR_CC2S_TI2	BIT(8)		/* IC2/IC4 selects TI2/TI4 */
+#define TIM_CCMR_CC2S_TI1	BIT(9)		/* IC2/IC4 selects TI1/TI3 */
+#define TIM_CCER_CC1E		BIT(0)		/* Capt/Comp 1  out Ena    */
+#define TIM_CCER_CC1P		BIT(1)		/* Capt/Comp 1  Polarity   */
+#define TIM_CCER_CC1NP		BIT(3)		/* Capt/Comp 1N Polarity   */
+#define TIM_SR_UIF		BIT(0)		/* UIF interrupt flag      */
+#define TIM_SR_CC1IF		BIT(1)		/* CC1 interrupt flag      */
+#define TIM_TISEL_TI1SEL_MASK	GENMASK(3, 0)
+#define TIM_SMCR_SMS_RESET	0x4U
+#define TIM_SMCR_TS_SHIFT	4U
+#define TIM_SMCR_TS_TI1FP1	0x5U
+
+#define TIM_COMPAT		"st,stm32-timers"
+#define TIM_TIMEOUT_US		100000
+#define TIM_TIMEOUT_STEP_US	10
+#define TIM_PRESCAL_HSI		10U
+#define TIM_PRESCAL_CSI		7U
+#define TIM_MIN_FREQ_CALIB	50000000U
+#define TIM_THRESHOLD		1U
+
+struct stm32_timer_instance {
+	uintptr_t base;
+	unsigned long clk;
+	unsigned long freq;
+	uint8_t cal_input;
+};
+
+static struct stm32_timer_instance stm32_timer[TIM_MAX_INSTANCE];
+
+static int stm32_timer_get_dt_node(struct dt_node_info *info, int offset)
+{
+	int node;
+
+	node = dt_get_node(info, offset, TIM_COMPAT);
+	if (node < 0) {
+		if (offset == -1) {
+			WARN("%s: No TIMER found\n", __func__);
+		}
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	return node;
+}
+
+static int stm32_timer_config(struct stm32_timer_instance *timer)
+{
+	clk_enable(timer->clk);
+
+	timer->freq = clk_get_rate(timer->clk);
+
+	if (timer->freq < TIM_MIN_FREQ_CALIB) {
+		WARN("Timer is not accurate enough for calibration\n");
+		clk_disable(timer->clk);
+		return -EINVAL;
+	}
+
+	if ((mmio_read_32(timer->base + TIM_TISEL) & TIM_TISEL_TI1SEL_MASK) !=
+	    timer->cal_input) {
+		mmio_clrsetbits_32(timer->base + TIM_CCMR1,
+				   TIM_CCMR_CC1S_TI1 | TIM_CCMR_CC1S_TI2,
+				   TIM_CCMR_CC1S_TI1);
+
+		mmio_clrbits_32(timer->base + TIM_CCER,
+				TIM_CCER_CC1P | TIM_CCER_CC1NP);
+
+		mmio_clrsetbits_32(timer->base + TIM_SMCR,
+				   TIM_SMCR_TS | TIM_SMCR_SMS,
+				   (TIM_SMCR_TS_TI1FP1 << TIM_SMCR_TS_SHIFT) |
+				   TIM_SMCR_SMS_RESET);
+
+		mmio_write_32(timer->base + TIM_TISEL, timer->cal_input);
+		mmio_setbits_32(timer->base + TIM_CR1, TIM_CR1_CEN);
+		mmio_setbits_32(timer->base + TIM_CCER, TIM_CCER_CC1E);
+	}
+
+	clk_disable(timer->clk);
+
+	return 0;
+}
+
+static uint32_t stm32_timer_start_capture(struct stm32_timer_instance *timer)
+{
+	uint32_t timeout = TIM_TIMEOUT_US / TIM_TIMEOUT_STEP_US;
+	uint32_t counter = 0U;
+	uint32_t old_counter;
+	uint64_t conv_timeout;
+
+	if (stm32_timer_config(timer) < 0) {
+		return 0U;
+	}
+
+	clk_enable(timer->clk);
+
+	mmio_write_32(timer->base + TIM_SR, 0U);
+	while (((mmio_read_32(timer->base + TIM_SR) &
+		 TIM_SR_UIF) == 0U) && (timeout != 0U)) {
+		udelay(TIM_TIMEOUT_STEP_US);
+		timeout--;
+	}
+
+	if (timeout == 0U) {
+		goto out;
+	}
+
+	mmio_write_32(timer->base + TIM_SR, 0U);
+
+	conv_timeout = timeout_init_us(TIM_TIMEOUT_US);
+	do {
+		if (timeout_elapsed(conv_timeout)) {
+			WARN("Timer counter not stable\n");
+			timeout = 0U;
+			goto out;
+		}
+
+		timeout = TIM_TIMEOUT_US / TIM_TIMEOUT_STEP_US;
+		while (((mmio_read_32(timer->base + TIM_SR) &
+			 TIM_SR_CC1IF) == 0U) && (timeout != 0U)) {
+			udelay(TIM_TIMEOUT_STEP_US);
+			timeout--;
+		}
+
+		if (timeout == 0U) {
+			goto out;
+		}
+
+		old_counter = counter;
+		counter = mmio_read_32(timer->base + TIM_CCR1);
+	} while ((MAX(counter, old_counter) - MIN(counter, old_counter)) >
+		 TIM_THRESHOLD);
+
+out:
+	clk_disable(timer->clk);
+
+	if (timeout == 0U) {
+		return 0U;
+	}
+
+	return counter;
+}
+
+unsigned long stm32_timer_hsi_freq(void)
+{
+	struct stm32_timer_instance *timer = &stm32_timer[HSI_CAL];
+	unsigned long hsi_freq;
+	uint32_t counter;
+
+	if (timer->base == 0) {
+		return 0;
+	}
+
+	counter = stm32_timer_start_capture(timer);
+	VERBOSE("Counter value %i\n", counter);
+
+	if (counter == 0U) {
+		return 0;
+	}
+
+	hsi_freq = (timer->freq / counter) << TIM_PRESCAL_HSI;
+
+	return hsi_freq;
+}
+
+unsigned long stm32_timer_csi_freq(void)
+{
+	struct stm32_timer_instance *timer = &stm32_timer[CSI_CAL];
+	unsigned long csi_freq;
+	uint32_t counter;
+
+	if (timer->base == 0) {
+		return 0;
+	}
+
+	counter = stm32_timer_start_capture(timer);
+	VERBOSE("Counter value %i\n", counter);
+
+	if (counter == 0U) {
+		return 0;
+	}
+
+	csi_freq = (timer->freq / counter) << TIM_PRESCAL_CSI;
+
+	return csi_freq;
+}
+
+/*
+ * Get the timer frequence callback function for a target clock calibration
+ * @timer_freq_cb - Output callback function
+ * @type - Target clock calibration ID
+ */
+void stm32_timer_freq_func(unsigned long (**timer_freq_cb)(void),
+			   enum timer_cal type)
+{
+	switch (type) {
+	case HSI_CAL:
+		if (stm32_timer[HSI_CAL].base != 0) {
+			*timer_freq_cb = stm32_timer_hsi_freq;
+		}
+		break;
+
+	case CSI_CAL:
+		if (stm32_timer[CSI_CAL].base != 0) {
+			*timer_freq_cb = stm32_timer_csi_freq;
+		}
+		break;
+
+	default:
+		panic();
+	}
+}
+
+/*
+ * Initialize timer from DT
+ * return 0 if disabled, 1 if enabled, else < 0
+ */
+int stm32_timer_init(void)
+{
+	void *fdt;
+	struct dt_node_info dt_timer;
+	int node = -1;
+	uint8_t nb_timer = 0;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -EPERM;
+	}
+
+	for (node = stm32_timer_get_dt_node(&dt_timer, node);
+	     node != -FDT_ERR_NOTFOUND;
+	     node = stm32_timer_get_dt_node(&dt_timer, node)) {
+		if (dt_timer.status != DT_DISABLED) {
+			struct stm32_timer_instance *timer;
+			const fdt32_t *cuint;
+
+			nb_timer++;
+
+			cuint = fdt_getprop(fdt, node, "st,hsi-cal-input",
+					    NULL);
+			if (cuint != NULL) {
+				timer = &stm32_timer[HSI_CAL];
+				timer->base = dt_timer.base;
+				timer->clk = dt_timer.clock;
+				timer->freq = clk_get_rate(timer->clk);
+				timer->cal_input =
+					(uint8_t)fdt32_to_cpu(*cuint);
+				if (stm32_timer_config(timer) < 0) {
+					timer->base = 0;
+					continue;
+				}
+			}
+
+			cuint = fdt_getprop(fdt, node, "st,csi-cal-input",
+					    NULL);
+			if (cuint != NULL) {
+				timer = &stm32_timer[CSI_CAL];
+				timer->base = dt_timer.base;
+				timer->clk = dt_timer.clock;
+				timer->freq = clk_get_rate(timer->clk);
+				timer->cal_input =
+					(uint8_t)fdt32_to_cpu(*cuint);
+				if (stm32_timer_config(timer) < 0) {
+					timer->base = 0;
+					continue;
+				}
+			}
+		}
+	}
+
+	VERBOSE("%u TIMER instance%s found\n", nb_timer,
+		nb_timer > 1 ? "s" : "");
+
+	if (nb_timer == 0U) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	return 0;
+}
diff --git a/drivers/st/uart/aarch32/stm32_console.S b/drivers/st/uart/aarch32/stm32_console.S
index 2b8879a11..abe47b53f 100644
--- a/drivers/st/uart/aarch32/stm32_console.S
+++ b/drivers/st/uart/aarch32/stm32_console.S
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2018-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -46,10 +46,16 @@ func console_stm32_core_init
 	cmp	r0, #0
 	beq	core_init_fail
 #if !defined(IMAGE_BL2)
+#if STM32MP_RECONFIGURE_CONSOLE
+	/* UART clock rate is set to 0 in BL32, skip init in that case */
+	cmp	r1, #0
+	beq	1f
+#else /* STM32MP_RECONFIGURE_CONSOLE */
 	/* Skip UART initialization if it is already enabled */
 	ldr	r3, [r0, #USART_CR1]
 	ands	r3, r3, #USART_CR1_UE
 	bne	1f
+#endif /* STM32MP_RECONFIGURE_CONSOLE */
 #endif /* IMAGE_BL2 */
 	/* Check baud rate and uart clock for sanity */
 	cmp	r1, #0
@@ -67,9 +73,24 @@ func console_stm32_core_init
 	bic	r3, r3, #USART_CR2_STOP
 	str	r3, [r0, #USART_CR2]
 	/* Divisor =  (Uart clock + (baudrate / 2)) / baudrate */
-	lsl	r3, r2, #1
+	lsr	r3, r2, #1
 	add	r3, r1, r3
 	udiv	r3, r3, r2
+	cmp	r3, #16
+	bhi	2f
+	/* Oversampling 8 */
+	/* Divisor =  (2 * Uart clock + (baudrate / 2)) / baudrate */
+	lsr	r3, r2, #1
+	add	r3, r3, r1, lsl #1
+	udiv	r3, r3, r2
+	and	r1, r3, #USART_BRR_DIV_FRACTION
+	lsr	r1, r1, #1
+	bic	r3, r3, #USART_BRR_DIV_FRACTION
+	orr	r3, r3, r1
+	ldr	r1, [r0, #USART_CR1]
+	orr	r1, r1, #USART_CR1_OVER8
+	str	r1, [r0, #USART_CR1]
+2:
 	str	r3, [r0, #USART_BRR]
 	/* Enable UART */
 	ldr	r3, [r0, #USART_CR1]
@@ -127,17 +148,15 @@ register_fail:
 	pop	{r4, pc}
 endfunc console_stm32_register
 
-	/* ---------------------------------------------------------------
+	/* --------------------------------------------------------
 	 * int console_core_putc(int c, uintptr_t base_addr)
-	 *
-	 * Function to output a character over the console. It returns the
-	 * character printed on success or -1 on error.
-	 *
+	 * Function to output a character over the console. It
+	 * returns the character printed on success or -1 on error.
 	 * In : r0 - character to be printed
 	 *      r1 - console base address
 	 * Out : return -1 on error else return character.
-	 * Clobber list : r2
-	 * ---------------------------------------------------------------
+	 * Clobber list : r2, r3
+	 * --------------------------------------------------------
 	 */
 func console_stm32_core_putc
 	/* Check the input parameter */
@@ -145,13 +164,19 @@ func console_stm32_core_putc
 	beq	putc_error
 
 	/* Check Transmit Data Register Empty */
+	mov	r3, #USART_TIMEOUT
 txe_loop:
+	subs	r3, r3, #1
+	beq	putc_error
 	ldr	r2, [r1, #USART_ISR]
 	tst	r2, #USART_ISR_TXE
 	beq	txe_loop
 	str	r0, [r1, #USART_TDR]
 	/* Check transmit complete flag */
+	mov	r3, #USART_TIMEOUT
 tc_loop:
+	subs	r3, r3, #1
+	beq	putc_error
 	ldr	r2, [r1, #USART_ISR]
 	tst	r2, #USART_ISR_TC
 	beq	tc_loop
@@ -205,7 +230,7 @@ endfunc console_stm32_core_getc
 	 *
 	 * In : r0 - console base address
 	 * Out : void.
-	 * Clobber list : r0, r1
+	 * Clobber list : r0, r1, r2
 	 * ---------------------------------------------------------------
 	 */
 func console_stm32_core_flush
@@ -214,7 +239,10 @@ func console_stm32_core_flush
 	ASM_ASSERT(ne)
 #endif /* ENABLE_ASSERTIONS */
 	/* Check Transmit Data Register Empty */
+	mov	r2, #USART_TIMEOUT
 txe_loop_3:
+	subs	r2, r2, #1
+	beq	plat_panic_handler
 	ldr	r1, [r0, #USART_ISR]
 	tst	r1, #USART_ISR_TXE
 	beq	txe_loop_3
diff --git a/drivers/st/uart/aarch64/stm32_console.S b/drivers/st/uart/aarch64/stm32_console.S
new file mode 100644
index 000000000..8902f48df
--- /dev/null
+++ b/drivers/st/uart/aarch64/stm32_console.S
@@ -0,0 +1,254 @@
+/*
+ * Copyright (c) 2018-2022, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#include <asm_macros.S>
+#include <assert_macros.S>
+#include <console_macros.S>
+#include <drivers/st/stm32_console.h>
+#include <drivers/st/stm32_uart_regs.h>
+
+#define USART_TIMEOUT		0x1000
+
+	/*
+	 * "core" functions are low-level implementations that don't require
+	 * writeable memory and are thus safe to call in BL1 crash context.
+	 */
+	.globl	console_stm32_core_init
+	.globl	console_stm32_core_putc
+	.globl	console_stm32_core_getc
+	.globl	console_stm32_core_flush
+
+	.globl	console_stm32_putc
+	.globl	console_stm32_flush
+
+
+
+	/* -----------------------------------------------------------------
+	 * int console_core_init(uintptr_t base_addr,
+	 *			 unsigned int uart_clk,
+	 *			 unsigned int baud_rate)
+	 *
+	 * Function to initialize the console without a C Runtime to print
+	 * debug information. This function will be accessed by console_init
+	 * and crash reporting.
+	 *
+	 * In: x0 - console base address
+	 *     w1 - Uart clock in Hz
+	 *     w2 - Baud rate
+	 * Out: return 1 on success else 0 on error
+	 * Clobber list : x1, x2, x3, x4
+	 * -----------------------------------------------
+	 */
+func console_stm32_core_init
+	/* Check the input base address */
+	cbz	x0, core_init_fail
+#if !defined(IMAGE_BL2)
+#if STM32MP_RECONFIGURE_CONSOLE
+	/* UART clock rate is set to 0 in BL32, skip init in that case */
+	cbz	x1, 1f
+#else /* STM32MP_RECONFIGURE_CONSOLE */
+	/* Skip UART initialization if it is already enabled */
+	ldr	w3, [x0, #USART_CR1]
+	tst	w3, #USART_CR1_UE
+	b.ne	1f
+#endif /* STM32MP_RECONFIGURE_CONSOLE */
+#endif /* IMAGE_BL2 */
+	/* Check baud rate and uart clock for sanity */
+	cbz	w1, core_init_fail
+	cbz	w2, core_init_fail
+	/* Disable UART */
+	ldr	w3, [x0, #USART_CR1]
+	mov	w4, #USART_CR1_UE
+	bic	w3, w3, w4
+	str	w3, [x0, #USART_CR1]
+	/* Configure UART */
+	mov	w4, #(USART_CR1_TE)
+	orr	w4, w4, #(USART_CR1_FIFOEN)
+	orr	w3, w3, w4
+	str	w3, [x0, #USART_CR1]
+	ldr	w3, [x0, #USART_CR2]
+	mov	w4, #USART_CR2_STOP
+	bic	w3, w3, w4
+	str	w3, [x0, #USART_CR2]
+	/* Divisor =  (Uart clock + (baudrate / 2)) / baudrate */
+	lsr	w3, w2, #1
+	add	w3, w1, w3
+	udiv	w3, w3, w2
+	cmp	w3, #16
+	b.hi	2f
+	/* Oversampling 8 */
+	/* Divisor =  (2 * Uart clock + (baudrate / 2)) / baudrate */
+	lsr	w3, w2, #1
+	add	w3, w3, w1, lsl #1
+	udiv	w3, w3, w2
+	and	w1, w3, #USART_BRR_DIV_FRACTION
+	lsr	w1, w1, #1
+	bic	w3, w3, #USART_BRR_DIV_FRACTION
+	orr	w3, w3, w1
+	ldr	w1, [x0, #USART_CR1]
+	orr	w1, w1, #USART_CR1_OVER8
+	str	w1, [x0, #USART_CR1]
+2:
+	str	w3, [x0, #USART_BRR]
+	/* Enable UART */
+	ldr	w3, [x0, #USART_CR1]
+	mov	w4, #USART_CR1_UE
+	orr	w3, w3, w4
+	str	w3, [x0, #USART_CR1]
+	/* Check TEACK bit */
+	mov	w2, #USART_TIMEOUT
+teack_loop:
+	subs	w2, w2, #1
+	beq	core_init_fail
+	ldr	w3, [x0, #USART_ISR]
+	tst	w3, #USART_ISR_TEACK
+	beq	teack_loop
+1:
+	mov	w0, #1
+	ret
+core_init_fail:
+	mov	w0, wzr
+	ret
+endfunc console_stm32_core_init
+
+	.globl console_stm32_register
+
+	/* -------------------------------------------------------
+	 * int console_stm32_register(uintptr_t baseaddr,
+	 *     uint32_t clock, uint32_t baud,
+	 *     console_t *console);
+	 * Function to initialize and register a new STM32
+	 * console. Storage passed in for the console struct
+	 * *must* be persistent (i.e. not from the stack).
+	 * In: x0 - UART register base address
+	 *     w1 - UART clock in Hz
+	 *     w2 - Baud rate
+	 *     x3 - pointer to empty console_t struct
+	 * Out: return 1 on success, 0 on error
+	 * Clobber list : x0, x1, x2, x6, x7, x14
+	 * -------------------------------------------------------
+	 */
+func console_stm32_register
+	mov	x7, x30
+	mov	x6, x3
+	cbz	x6, register_fail
+	str	x0, [x6, #CONSOLE_T_BASE]
+
+	bl	console_stm32_core_init
+	cbz	x0, register_fail
+
+	mov	x0, x6
+	mov	x30, x7
+	finish_console_register stm32 putc=1, getc=0, flush=1
+
+register_fail:
+	ret	x7
+endfunc console_stm32_register
+
+	/* --------------------------------------------------------
+	 * int console_stm32_core_putc(int c, uintptr_t base_addr)
+	 * Function to output a character over the console. It
+	 * returns the character printed on success or -1 on error.
+	 * In : w0 - character to be printed
+	 *      x1 - console base address
+	 * Out : return -1 on error else return character.
+	 * Clobber list : x2
+	 * --------------------------------------------------------
+	 */
+func console_stm32_core_putc
+#if ENABLE_ASSERTIONS
+	cmp	x1, #0
+	ASM_ASSERT(ne)
+#endif /* ENABLE_ASSERTIONS */
+
+	/* Check Transmit Data Register Empty */
+txe_loop:
+	ldr	w2, [x1, #USART_ISR]
+	tst	w2, #USART_ISR_TXE
+	beq	txe_loop
+	str	w0, [x1, #USART_TDR]
+	/* Check transmit complete flag */
+tc_loop:
+	ldr	w2, [x1, #USART_ISR]
+	tst	w2, #USART_ISR_TC
+	beq	tc_loop
+	ret
+endfunc console_stm32_core_putc
+
+	/* --------------------------------------------------------
+	 * int console_stm32_putc(int c, console_t *console)
+	 * Function to output a character over the console. It
+	 * returns the character printed on success or -1 on error.
+	 * In : w0 - character to be printed
+	 *      x1 - pointer to console_t structure
+	 * Out : return -1 on error else return character.
+	 * Clobber list : x2
+	 * --------------------------------------------------------
+	 */
+func console_stm32_putc
+#if ENABLE_ASSERTIONS
+	cmp	x1, #0
+	ASM_ASSERT(ne)
+#endif /* ENABLE_ASSERTIONS */
+	ldr	x1, [x1, #CONSOLE_T_BASE]
+	b	console_stm32_core_putc
+endfunc console_stm32_putc
+
+	/* ---------------------------------------------
+	 * int console_stm32_core_getc(uintptr_t base_addr)
+	 * Function to get a character from the console.
+	 * It returns the character grabbed on success
+	 * or -1 if no character is available.
+	 * In : x0 - console base address
+	 * Out: w0 - character if available, else -1
+	 * Clobber list : x0, x1
+	 * ---------------------------------------------
+	 */
+func console_stm32_core_getc
+	/* Not supported */
+	mov	w0, #-1
+	ret
+endfunc console_stm32_core_getc
+
+	/* ---------------------------------------------
+	 * int console_stm32_core_flush(uintptr_t base_addr)
+	 * Function to force a write of all buffered
+	 * data that hasn't been output.
+	 * In : x0 - console base address
+	 * Out : return -1 on error else return 0.
+	 * Clobber list : x0, x1
+	 * ---------------------------------------------
+	 */
+func console_stm32_core_flush
+#if ENABLE_ASSERTIONS
+	cmp	x0, #0
+	ASM_ASSERT(ne)
+#endif /* ENABLE_ASSERTIONS */
+	/* Check Transmit Data Register Empty */
+txe_loop_3:
+	ldr	w1, [x0, #USART_ISR]
+	tst	w1, #USART_ISR_TXE
+	beq	txe_loop_3
+	mov	w0, #0
+	ret
+endfunc console_stm32_core_flush
+
+	/* ---------------------------------------------
+	 * int console_stm32_flush(console_t *console)
+	 * Function to force a write of all buffered
+	 * data that hasn't been output.
+	 * In : x0 - pointer to console_t structure
+	 * Out : return -1 on error else return 0.
+	 * Clobber list : x0, x1
+	 * ---------------------------------------------
+	 */
+func console_stm32_flush
+#if ENABLE_ASSERTIONS
+	cmp	x0, #0
+	ASM_ASSERT(ne)
+#endif /* ENABLE_ASSERTIONS */
+	ldr	x0, [x0, #CONSOLE_T_BASE]
+	b	console_stm32_core_flush
+endfunc console_stm32_flush
diff --git a/drivers/st/uart/stm32_uart.c b/drivers/st/uart/stm32_uart.c
new file mode 100644
index 000000000..588a634aa
--- /dev/null
+++ b/drivers/st/uart/stm32_uart.c
@@ -0,0 +1,440 @@
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <string.h>
+
+#include <common/bl_common.h>
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32mp_clkfunc.h>
+#include <drivers/st/stm32_gpio.h>
+#include <drivers/st/stm32_uart.h>
+#include <drivers/st/stm32_uart_regs.h>
+#include <lib/mmio.h>
+
+#include <platform_def.h>
+
+/* UART time-out value */
+#define STM32_UART_TIMEOUT_US	20000U
+
+/* Mask to clear ALL the configuration registers */
+
+#define STM32_UART_CR1_FIELDS \
+		(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
+		 USART_CR1_RE | USART_CR1_OVER8 | USART_CR1_FIFOEN)
+
+#define STM32_UART_CR2_FIELDS \
+		(USART_CR2_SLVEN | USART_CR2_DIS_NSS | USART_CR2_ADDM7 | \
+		 USART_CR2_LBDL | USART_CR2_LBDIE | USART_CR2_LBCL | \
+		 USART_CR2_CPHA | USART_CR2_CPOL | USART_CR2_CLKEN | \
+		 USART_CR2_STOP | USART_CR2_LINEN | USART_CR2_SWAP | \
+		 USART_CR2_RXINV | USART_CR2_TXINV | USART_CR2_DATAINV | \
+		 USART_CR2_MSBFIRST | USART_CR2_ABREN | USART_CR2_ABRMODE | \
+		 USART_CR2_RTOEN | USART_CR2_ADD)
+
+#define STM32_UART_CR3_FIELDS \
+		(USART_CR3_EIE | USART_CR3_IREN | USART_CR3_IRLP | \
+		 USART_CR3_HDSEL | USART_CR3_NACK | USART_CR3_SCEN | \
+		 USART_CR3_DMAR | USART_CR3_DMAT | USART_CR3_RTSE | \
+		 USART_CR3_CTSE | USART_CR3_CTSIE | USART_CR3_ONEBIT | \
+		 USART_CR3_OVRDIS | USART_CR3_DDRE | USART_CR3_DEM | \
+		 USART_CR3_DEP | USART_CR3_SCARCNT | USART_CR3_WUS | \
+		 USART_CR3_WUFIE | USART_CR3_TXFTIE | USART_CR3_TCBGTIE | \
+		 USART_CR3_RXFTCFG | USART_CR3_RXFTIE | USART_CR3_TXFTCFG)
+
+#define STM32_UART_ISR_ERRORS	 \
+		(USART_ISR_ORE | USART_ISR_NE |  USART_ISR_FE | USART_ISR_PE)
+
+static const uint16_t presc_table[STM32_UART_PRESCALER_NB] = {
+	1U, 2U, 4U, 6U, 8U, 10U, 12U, 16U, 32U, 64U, 128U, 256U
+};
+
+/* @brief  BRR division operation to set BRR register in 8-bit oversampling
+ * mode.
+ * @param  clockfreq: UART clock.
+ * @param  baud_rate: Baud rate set by the user.
+ * @param  prescaler: UART prescaler value.
+ * @retval Division result.
+ */
+static uint32_t uart_div_sampling8(unsigned long clockfreq,
+				   uint32_t baud_rate,
+				   uint32_t prescaler)
+{
+	uint32_t scaled_freq = clockfreq / presc_table[prescaler];
+
+	return ((scaled_freq * 2) + (baud_rate / 2)) / baud_rate;
+
+}
+
+/* @brief  BRR division operation to set BRR register in 16-bit oversampling
+ * mode.
+ * @param  clockfreq: UART clock.
+ * @param  baud_rate: Baud rate set by the user.
+ * @param  prescaler: UART prescaler value.
+ * @retval Division result.
+ */
+static uint32_t uart_div_sampling16(unsigned long clockfreq,
+				    uint32_t baud_rate,
+				    uint32_t prescaler)
+{
+	uint32_t scaled_freq = clockfreq / presc_table[prescaler];
+
+	return (scaled_freq + (baud_rate / 2)) / baud_rate;
+
+}
+
+/*
+ * @brief  Return the UART clock frequency.
+ * @param  huart: UART handle.
+ * @retval Frequency value in Hz.
+ */
+static unsigned long uart_get_clock_freq(struct stm32_uart_handle_s *huart)
+{
+	return fdt_get_uart_clock_freq((uintptr_t)huart->base);
+}
+
+/*
+ * @brief  Configure the UART peripheral.
+ * @param  huart: UART handle.
+ * @retval UART status.
+ */
+static int uart_set_config(struct stm32_uart_handle_s *huart,
+			   const struct stm32_uart_init_s *init)
+{
+	uint32_t tmpreg;
+	unsigned long clockfreq;
+	unsigned long int_div;
+	uint32_t brrtemp;
+	uint32_t over_sampling;
+
+
+	/*---------------------- USART BRR configuration --------------------*/
+	clockfreq = uart_get_clock_freq(huart);
+	if (clockfreq == 0UL) {
+		return -ENODEV;
+	}
+
+	int_div = clockfreq / init->baud_rate;
+	if (int_div < 16U) {
+		uint32_t usartdiv = uart_div_sampling8(clockfreq,
+						       init->baud_rate,
+						       init->prescaler);
+
+		brrtemp = (usartdiv & USART_BRR_DIV_MANTISSA) |
+			  ((usartdiv & USART_BRR_DIV_FRACTION) >> 1);
+		over_sampling = USART_CR1_OVER8;
+	} else {
+		brrtemp = uart_div_sampling16(clockfreq,
+					      init->baud_rate,
+					      init->prescaler) &
+			  (USART_BRR_DIV_FRACTION | USART_BRR_DIV_MANTISSA);
+		over_sampling = 0x0U;
+	}
+	mmio_write_32(huart->base + USART_BRR, brrtemp);
+
+	/*
+	 * ---------------------- USART CR1 Configuration --------------------
+	 * Clear M, PCE, PS, TE, RE and OVER8 bits and configure
+	 * the UART word length, parity, mode and oversampling:
+	 * - set the M bits according to init->word_length value,
+	 * - set PCE and PS bits according to init->parity value,
+	 * - set TE and RE bits according to init->mode value,
+	 * - set OVER8 bit according baudrate and clock.
+	 */
+	tmpreg = init->word_length |
+		 init->parity |
+		 init->mode |
+		 over_sampling |
+		 init->fifo_mode;
+	mmio_clrsetbits_32(huart->base + USART_CR1, STM32_UART_CR1_FIELDS, tmpreg);
+
+	/*
+	 * --------------------- USART CR2 Configuration ---------------------
+	 * Configure the UART Stop Bits: Set STOP[13:12] bits according
+	 * to init->stop_bits value.
+	 */
+	mmio_clrsetbits_32(huart->base + USART_CR2, STM32_UART_CR2_FIELDS,
+			   init->stop_bits);
+
+	/*
+	 * --------------------- USART CR3 Configuration ---------------------
+	 * Configure:
+	 * - UART HardWare Flow Control: set CTSE and RTSE bits according
+	 *   to init->hw_flow_control value,
+	 * - one-bit sampling method versus three samples' majority rule
+	 *   according to init->one_bit_sampling (not applicable to
+	 *   LPUART),
+	 * - set TXFTCFG bit according to init->tx_fifo_threshold value,
+	 * - set RXFTCFG bit according to init->rx_fifo_threshold value.
+	 */
+	tmpreg = init->hw_flow_control | init->one_bit_sampling;
+
+	if (init->fifo_mode == USART_CR1_FIFOEN) {
+		tmpreg |= init->tx_fifo_threshold |
+			  init->rx_fifo_threshold;
+	}
+
+	mmio_clrsetbits_32(huart->base + USART_CR3, STM32_UART_CR3_FIELDS, tmpreg);
+
+	/*
+	 * --------------------- USART PRESC Configuration -------------------
+	 * Configure UART Clock Prescaler : set PRESCALER according to
+	 * init->prescaler value.
+	 */
+	assert(init->prescaler < STM32_UART_PRESCALER_NB);
+	mmio_clrsetbits_32(huart->base + USART_PRESC, USART_PRESC_PRESCALER,
+			   init->prescaler);
+
+	return 0;
+}
+
+/*
+ * @brief  Handle UART communication timeout.
+ * @param  huart: UART handle.
+ * @param  flag: Specifies the UART flag to check.
+ * @retval UART status.
+ */
+static int stm32_uart_wait_flag(struct stm32_uart_handle_s *huart, uint32_t flag)
+{
+	uint64_t timeout_ref = timeout_init_us(STM32_UART_TIMEOUT_US);
+
+	while ((mmio_read_32(huart->base + USART_ISR) & flag) == 0U) {
+		if (timeout_elapsed(timeout_ref)) {
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * @brief  Check the UART idle State.
+ * @param  huart: UART handle.
+ * @retval UART status.
+ */
+static int stm32_uart_check_idle(struct stm32_uart_handle_s *huart)
+{
+	int ret;
+
+	/* Check if the transmitter is enabled */
+	if ((mmio_read_32(huart->base + USART_CR1) & USART_CR1_TE) == USART_CR1_TE) {
+		ret = stm32_uart_wait_flag(huart, USART_ISR_TEACK);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	/* Check if the receiver is enabled */
+	if ((mmio_read_32(huart->base + USART_CR1) & USART_CR1_RE) == USART_CR1_RE) {
+		ret = stm32_uart_wait_flag(huart, USART_ISR_REACK);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * @brief  Compute RDR register mask depending on word length.
+ * @param  huart: UART handle.
+ * @retval Mask value.
+ */
+static unsigned int stm32_uart_rdr_mask(const struct stm32_uart_init_s *init)
+{
+	unsigned int mask = 0U;
+
+	switch (init->word_length) {
+	case STM32_UART_WORDLENGTH_9B:
+		mask = GENMASK(8, 0);
+		break;
+	case STM32_UART_WORDLENGTH_8B:
+		mask = GENMASK(7, 0);
+		break;
+	case STM32_UART_WORDLENGTH_7B:
+		mask = GENMASK(6, 0);
+		break;
+	default:
+		break; /* not reached */
+	}
+
+	if (init->parity != STM32_UART_PARITY_NONE) {
+		mask >>= 1;
+	}
+
+	return mask;
+}
+
+/*
+ * @brief  Check interrupt and status errors.
+ * @retval True if error detected, false otherwise.
+ */
+static bool stm32_uart_error_detected(struct stm32_uart_handle_s *huart)
+{
+	return (mmio_read_32(huart->base + USART_ISR) & STM32_UART_ISR_ERRORS) != 0U;
+}
+
+/*
+ * @brief  Clear status errors.
+ */
+static void stm32_uart_error_clear(struct stm32_uart_handle_s *huart)
+{
+	mmio_write_32(huart->base + USART_ICR, STM32_UART_ISR_ERRORS);
+}
+
+/*
+ * @brief  Stop the UART.
+ * @param  base: UART base address.
+ */
+void stm32_uart_stop(uintptr_t base)
+{
+	mmio_clrbits_32(base + USART_CR1, USART_CR1_UE);
+}
+
+/*
+ * @brief  Initialize UART.
+ * @param  huart: UART handle.
+ * @param  base_addr: base address of UART.
+ * @param  init: UART initialization parameter.
+ * @retval UART status.
+ */
+int stm32_uart_init(struct stm32_uart_handle_s *huart,
+		    uintptr_t base_addr,
+		    const struct stm32_uart_init_s *init)
+{
+	int ret;
+	int uart_node;
+	int clk;
+	void *fdt = NULL;
+
+	if (huart == NULL || init == NULL || base_addr == 0U) {
+		return -EINVAL;
+	}
+
+	huart->base = base_addr;
+
+	/* Search UART instance in DT */
+	if (fdt_get_address(&fdt) == 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	if (fdt == NULL) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	uart_node = dt_match_instance_by_compatible(DT_UART_COMPAT, base_addr);
+	if (uart_node == -FDT_ERR_NOTFOUND) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	/* Pinctrl initialization */
+	if (dt_set_pinctrl_config(uart_node) != 0) {
+		return -FDT_ERR_BADVALUE;
+	}
+
+	/* Clock initialization */
+	clk = fdt_get_clock_id(uart_node);
+	if (clk < 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+	clk_enable(clk);
+
+	/* Disable the peripheral */
+	stm32_uart_stop(huart->base);
+
+	/* Computation of UART mask to apply to RDR register */
+	huart->rdr_mask = stm32_uart_rdr_mask(init);
+
+	/* Init the peripheral */
+	ret = uart_set_config(huart, init);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Enable the peripheral */
+	mmio_setbits_32(huart->base + USART_CR1, USART_CR1_UE);
+
+	/* TEACK and/or REACK to check */
+	return stm32_uart_check_idle(huart);
+}
+
+/*
+ * @brief  Transmit one data in no blocking mode.
+ * @param  huart: UART handle.
+ * @param  c: data to sent.
+ * @retval UART status.
+ */
+int stm32_uart_putc(struct stm32_uart_handle_s *huart, int c)
+{
+	int ret;
+
+	if (huart == NULL) {
+		return -EINVAL;
+	}
+
+	ret = stm32_uart_wait_flag(huart, USART_ISR_TXE);
+	if (ret != 0) {
+		return ret;
+	}
+
+	mmio_write_32(huart->base + USART_TDR, c);
+	if (stm32_uart_error_detected(huart)) {
+		stm32_uart_error_clear(huart);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*
+ * @brief  Flush TX Transmit fifo
+ * @param  huart: UART handle.
+ * @retval UART status.
+ */
+int stm32_uart_flush(struct stm32_uart_handle_s *huart)
+{
+	int ret;
+
+	if (huart == NULL) {
+		return -EINVAL;
+	}
+
+	ret = stm32_uart_wait_flag(huart, USART_ISR_TXE);
+	if (ret != 0) {
+		return ret;
+	}
+
+	return stm32_uart_wait_flag(huart, USART_ISR_TC);
+}
+
+/*
+ * @brief  Receive a data in no blocking mode.
+ * @retval value if >0 or UART status.
+ */
+int stm32_uart_getc(struct stm32_uart_handle_s *huart)
+{
+	uint32_t data;
+
+	if (huart == NULL) {
+		return -EINVAL;
+	}
+
+	/* Check if data is available */
+	if ((mmio_read_32(huart->base + USART_ISR) & USART_ISR_RXNE) == 0U) {
+		return -EAGAIN;
+	}
+
+	data = mmio_read_32(huart->base + USART_RDR) & huart->rdr_mask;
+
+	if (stm32_uart_error_detected(huart)) {
+		stm32_uart_error_clear(huart);
+		return -EFAULT;
+	}
+
+	return (int)data;
+}
diff --git a/drivers/st/usb_dwc3/usb_dwc3.c b/drivers/st/usb_dwc3/usb_dwc3.c
new file mode 100644
index 000000000..5f2d7b7bf
--- /dev/null
+++ b/drivers/st/usb_dwc3/usb_dwc3.c
@@ -0,0 +1,2357 @@
+/*
+ * Copyright (c) 2015-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdint.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/usb_dwc3.h>
+#include <lib/mmio.h>
+#include <lib/libc/assert.h>
+#include <lib/xlat_tables/xlat_tables_v2.h>
+
+#include "usb_dwc3_regs.h"
+
+/*
+ * @brief USB EP Type
+ */
+#define EP_TYPE_CTRL	0U
+#define EP_TYPE_ISOC	1U
+#define EP_TYPE_BULK	2U
+#define EP_TYPE_INTR	3U
+#define EP_TYPE_MSK	3U
+
+#define USB_DWC3_GLOBAL_BASE	0xc100
+#define USB_DWC3_DEVICE_BASE	0xc700
+
+/* Global Registers */
+#define DWC3_GSBUSCFG0	_DWC3_GSBUSCFG0
+#define DWC3_GSBUSCFG1	_DWC3_GSBUSCFG1
+#define DWC3_GTXTHRCFG	_DWC3_GTXTHRCFG
+#define DWC3_GRXTHRCFG	_DWC3_GRXTHRCFG
+#define DWC3_GCTL	_DWC3_GCTL
+#define DWC3_GEVTEN	_DWC3_GEVTEN
+#define DWC3_GSTS	_DWC3_GSTS
+#define DWC3_GUCTL1	_DWC3_GUCTL1
+#define DWC3_GSNPSID	_DWC3_GSNPSID
+#define DWC3_GGPIO	_DWC3_GGPIO
+#define DWC3_GUID	_DWC3_GUID
+#define DWC3_GUCTL	_DWC3_GUCTL
+#define DWC3_GBUSERRADDR0	_DWC3_GBUSERRADDRLO
+#define DWC3_GBUSERRADDR1	_DWC3_GBUSERRADDRHI
+#define DWC3_GPRTBIMAP0	_DWC3_GPRTBIMAPLO
+#define DWC3_GPRTBIMAP1	_DWC3_GPRTBIMAPHI
+#define DWC3_GHWPARAMS0	_DWC3_GHWPARAMS0
+#define DWC3_GHWPARAMS1	_DWC3_GHWPARAMS1
+#define DWC3_GHWPARAMS2	_DWC3_GHWPARAMS2
+#define DWC3_GHWPARAMS3	_DWC3_GHWPARAMS3
+#define DWC3_GHWPARAMS4	_DWC3_GHWPARAMS4
+#define DWC3_GHWPARAMS5	_DWC3_GHWPARAMS5
+#define DWC3_GHWPARAMS6	_DWC3_GHWPARAMS6
+#define DWC3_GHWPARAMS7	_DWC3_GHWPARAMS7
+#define DWC3_GDBGFIFOSPACE	_DWC3_GDBGFIFOSPACE
+#define DWC3_GDBGLTSSM	_DWC3_GDBGLTSSM
+#define DWC3_GPRTBIMAP_HS0	_DWC3_GPRTBIMAP_HSLO
+#define DWC3_GPRTBIMAP_HS1	_DWC3_GPRTBIMAP_HSHI
+#define DWC3_GPRTBIMAP_FS0	_DWC3_GPRTBIMAP_FSLO
+#define DWC3_GPRTBIMAP_FS1	_DWC3_GPRTBIMAP_FSHI
+
+#define DWC3_GUSB2PHYCFG(n)	(_DWC3_GUSB2PHYCFG + (4UL * (n)))
+#define DWC3_GUSB2I2CCTL(n)	(_DWC3_GUSB2I2CCTL + (4UL * (n)))
+
+#define DWC3_GUSB2PHYACC(n)	(_DWC3_GUSB2PHYACC + (4UL * (n)))
+
+#define DWC3_GUSB3PIPECTL(n)	(_DWC3_GUSB3PIPECTL + (4UL * (n)))
+
+#define DWC3_GTXFIFOSIZ(n)	(_DWC3_GTXFIFOSIZ0 + (4UL * (n)))
+#define DWC3_GRXFIFOSIZ(n)	(_DWC3_GRXFIFOSIZ0 + (4UL * (n)))
+
+#define DWC3_GEVNTADRLO(n)	(_DWC3_GEVNTADRLO + (16UL * (n)))
+#define DWC3_GEVNTADRHI(n)	(_DWC3_GEVNTADRHI + (16UL * (n)))
+#define DWC3_GEVNTSIZ(n)	(_DWC3_GEVNTSIZ + (16UL * (n)))
+#define DWC3_GEVNTCOUNT(n)	(_DWC3_GEVNTCOUNT + (16UL * (n)))
+
+#define DWC3_GUSB2PHYACC_ADDR(n)	((n) << USB3_GUSB2PHYACC_ULPI_REGADDR_POS)
+#define DWC3_GUSB2PHYACC_EXTEND_ADDR(n)	((n) << USB3_GUSB2PHYACC_ULPI_EXTREGADDR_POS)
+#define DWC3_GUSB2PHYACC_DATA(n)	((n) & USB3_GUSB2PHYACC_ULPI_REGDATA_MSK)
+
+/* Device Registers */
+#define DWC3_DCFG	_DWC3_DCFG
+#define DWC3_DCTL	_DWC3_DCTL
+#define DWC3_DEVTEN	_DWC3_DEVTEN
+#define DWC3_DSTS	_DWC3_DSTS
+#define DWC3_DGCMDPAR	_DWC3_DGCMDPAR
+#define DWC3_DGCMD	_DWC3_DGCMD
+#define DWC3_DALEPENA	_DWC3_DALEPENA
+#define DWC3_DEPCMDPAR2(n)	(_DWC3_DEPCMDPAR2 + (16UL * (n)))
+#define DWC3_DEPCMDPAR1(n)	(_DWC3_DEPCMDPAR1 + (16UL * (n)))
+#define DWC3_DEPCMDPAR0(n)	(_DWC3_DEPCMDPAR0 + (16UL * (n)))
+#define DWC3_DEPCMD(n)	(_DWC3_DEPCMD + (16UL * (n)))
+
+/* The EP number goes 0..31 so ep0 is always out and ep1 is always in */
+#define DWC3_DALEPENA_EP(n)	(1UL << (n))
+
+/*
+ * @brief USB EP Type
+ */
+#define EP_TYPE_CTRL	0U
+#define EP_TYPE_ISOC	1U
+#define EP_TYPE_BULK	2U
+#define EP_TYPE_INTR	3U
+#define EP_TYPE_MSK	3U
+
+/* Event Size */
+#define USB_DWC3_EVENT_SIZE	4U
+
+/* USB_ExecuteDevEPCmd::USB_DWC3_EPCmd */
+#define USB_DWC3_DEPCMD_DEPSTARTCFG	(0x09UL << USB3_DEPCMD_CMDTYP_POS)
+#define USB_DWC3_DEPCMD_ENDTRANSFER	(0x08UL << USB3_DEPCMD_CMDTYP_POS)
+#define USB_DWC3_DEPCMD_UPDATETRANSFER	(0x07UL << USB3_DEPCMD_CMDTYP_POS)
+#define USB_DWC3_DEPCMD_STARTTRANSFER	(0x06UL << USB3_DEPCMD_CMDTYP_POS)
+#define USB_DWC3_DEPCMD_CLEARSTALL	(0x05UL << USB3_DEPCMD_CMDTYP_POS)
+#define USB_DWC3_DEPCMD_SETSTALL	(0x04UL << USB3_DEPCMD_CMDTYP_POS)
+/* This applies for core versions 1.94a and later */
+#define USB_DWC3_DEPCMD_GETEPSTATE	(0x03UL << USB3_DEPCMD_CMDTYP_POS)
+#define USB_DWC3_DEPCMD_SETTRANSFRESOURCE	(0x02UL << USB3_DEPCMD_CMDTYP_POS)
+#define USB_DWC3_DEPCMD_SETEPCONFIG	(0x01UL << USB3_DEPCMD_CMDTYP_POS)
+
+/* USB_ConfigureEP::action */
+#define USB_DWC3_DEPCFG_ACTION_INIT	0
+#define USB_DWC3_DEPCFG_ACTION_RESTORE	1
+#define USB_DWC3_DEPCFG_ACTION_MODIFY	2
+
+/* USB_ReadEndpointEventType @return EPEventType */
+#define USB_DWC3_DEPEVT_XFERCOMPLETE	0x01
+#define USB_DWC3_DEPEVT_XFERINPROGRESS	0x02
+#define USB_DWC3_DEPEVT_XFERNOTREADY	0x03
+#define USB_DWC3_DEPEVT_RXTXFIFOEVT	0x04
+#define USB_DWC3_DEPEVT_STREAMEVT	0x06
+#define USB_DWC3_DEPEVT_EPCMDCMPLT	0x07
+
+/* USB_ReadEndpointEventStatus @return EPEventStatus */
+#define USB_DWC3_DEPEVT_XFERNOTREADY_STATUS_CTRL_DATA	0x01
+#define USB_DWC3_DEPEVT_XFERNOTREADY_STATUS_CTRL_STATUS	0x02
+
+/* USB_ReadDeviceEventType @return DevEventType */
+#define USB_DWC3_DEVICE_EVENT_DISCONNECT	0
+#define USB_DWC3_DEVICE_EVENT_RESET	1
+#define USB_DWC3_DEVICE_EVENT_CONNECT_DONE	2
+#define USB_DWC3_DEVICE_EVENT_LINK_STATUS_CHANGE	3
+#define USB_DWC3_DEVICE_EVENT_WAKEUP	4
+#define USB_DWC3_DEVICE_EVENT_HIBER_REQ	5
+#define USB_DWC3_DEVICE_EVENT_EOPF	6
+#define USB_DWC3_DEVICE_EVENT_SOF	7
+#define USB_DWC3_DEVICE_EVENT_L1SUSPEND	8
+#define USB_DWC3_DEVICE_EVENT_ERRATIC_ERROR	9
+#define USB_DWC3_DEVICE_EVENT_CMD_CMPL	10
+#define USB_DWC3_DEVICE_EVENT_OVERFLOW	11
+#define USB_DWC3_DEVICE_EVENT_L1WAKEUP	14
+
+#define USB_DWC3_TRBSTS_OK	0
+#define USB_DWC3_TRBSTS_MISSED_ISOC	1
+#define USB_DWC3_TRBSTS_SETUP_PENDING	2
+#define USB_DWC3_TRBSTS_XFER_IN_PROG	4
+
+#define USB_DWC3_SPEED_SUPER	0U
+#define USB_DWC3_SPEED_HIGH	1U
+#define USB_DWC3_SPEED_FULL_48	2U
+#define USB_DWC3_SPEED_FULL	3U
+#define USB_DWC3_SPEED_LOW	4U
+#define USB_DWC3_SPEED_INVALID	15U
+
+#define DWC3_DEPCMD_TYPE_CONTROL	0
+#define DWC3_DEPCMD_TYPE_ISOC	1
+#define DWC3_DEPCMD_TYPE_BULK	2
+#define DWC3_DEPCMD_TYPE_INTR	3
+
+#define DWC3_GCTL_PRTCAP(n)	(((n) & USB3_GCTL_PRTCAPDIR_MSK) >> USB3_GCTL_PRTCAPDIR_POS)
+#define DWC3_GCTL_PRTCAPDIR(n)	((n) << USB3_GCTL_PRTCAPDIR_POS)
+#define DWC3_GCTL_PRTCAP_HOST	1
+#define DWC3_GCTL_PRTCAP_DEVICE	2
+#define DWC3_GCTL_PRTCAP_OTG	3
+
+#define DWC3_DSTS_SUPERSPEED	(4U << USB3_DSTS_CONNECTSPD_POS)
+#define DWC3_DSTS_HIGHSPEED	(0U << USB3_DSTS_CONNECTSPD_POS)
+#define DWC3_DSTS_FULLSPEED2	BIT(USB3_DSTS_CONNECTSPD_POS)
+#define DWC3_DSTS_LOWSPEED	(2U << USB3_DSTS_CONNECTSPD_POS)
+#define DWC3_DSTS_FULLSPEED1	(3U << USB3_DSTS_CONNECTSPD_POS)
+
+#define DWC3_GEVNTCOUNT_MASK	0xfffcU
+#define DWC3_GSNPSID_MASK	0xffff0000
+#define DWC3_GSNPSREV_MASK	0xffff
+
+#define DWC3_DCFG_DEVADDR(addr)	((addr) << 3)
+
+#define DWC3_EVENT_TYPE_DEV	0
+#define DWC3_EVENT_TYPE_CARKIT	3
+#define DWC3_EVENT_TYPE_I2C	4
+
+#define DWC3_DEVICE_EVENT_DISCONNECT	0
+#define DWC3_DEVICE_EVENT_RESET	1
+#define DWC3_DEVICE_EVENT_CONNECT_DONE	2
+#define DWC3_DEVICE_EVENT_LINK_STATUS_CHANGE	3
+#define DWC3_DEVICE_EVENT_WAKEUP	4
+#define DWC3_DEVICE_EVENT_HIBER_REQ	5
+#define DWC3_DEVICE_EVENT_EOPF	6
+#define DWC3_DEVICE_EVENT_SOF	7
+#define DWC3_DEVICE_EVENT_ERRATIC_ERROR	9
+#define DWC3_DEVICE_EVENT_CMD_CMPL	10
+#define DWC3_DEVICE_EVENT_OVERFLOW	11
+
+/* DEPCFG parameter 1 */
+#define DWC3_DEPCFG_INT_NUM(n)	(((n) & 0x1f) << 0)
+#define DWC3_DEPCFG_XFER_COMPLETE_EN	BIT(8)
+#define DWC3_DEPCFG_XFER_IN_PROGRESS_EN	BIT(9)
+#define DWC3_DEPCFG_XFER_NOT_READY_EN	BIT(10)
+#define DWC3_DEPCFG_FIFO_ERROR_EN	BIT(11)
+#define DWC3_DEPCFG_STREAM_EVENT_EN	BIT(13)
+#define DWC3_DEPCFG_BINTERVAL_M1(n)	(((n) & 0xffU) << 16)
+#define DWC3_DEPCFG_STREAM_CAPABLE	BIT(24)
+#define DWC3_DEPCFG_EP_NUMBER(n)	(((n) & 0x1fUL) << 25)
+#define DWC3_DEPCFG_BULK_BASED	BIT(30)
+#define DWC3_DEPCFG_FIFO_BASED	BIT(31)
+
+/* DEPCFG parameter 0 */
+#define DWC3_DEPCFG_EP_TYPE(n)	(((n) & 0x3UL) << 1)
+#define DWC3_DEPCFG_MAX_PACKET_SIZE(n)	(((n) & 0x7ffU) << 3)
+#define DWC3_DEPCFG_FIFO_NUMBER(n)	(((n) & 0x1fUL) << 17)
+#define DWC3_DEPCFG_BURST_SIZE(n)	(((n) & 0xf) << 22)
+#define DWC3_DEPCFG_DATA_SEQ_NUM(n)	((n) << 26)
+/* DEPCFG parameter 1 */
+#define DWC3_DEPCFG_EP_INTR_NUM(n)	((n) & 0x1fUL)
+/* This applies for core versions earlier than 1.94a */
+#define DWC3_DEPCFG_IGN_SEQ_NUM	BIT(31)
+/* These apply for core versions 1.94a and later */
+#define DWC3_DEPCFG_ACTION_INIT	(0U << 30)
+#define DWC3_DEPCFG_ACTION_RESTORE	BIT(30)
+#define DWC3_DEPCFG_ACTION_MODIFY	(2U << 30)
+#define DWC3_DEPCFG_ACTION_VALUE(n)	(((n) & 0x3) << 30)
+
+/* DEPXFERCFG parameter 0 */
+#define DWC3_DEPXFERCFG_NUM_XFER_RES(n)	((n) & 0xffffU)
+
+#define DWC3_DEPCMD_GET_RSC_IDX(x)	(((x) >> USB3_DEPCMD_COMMANDPARAM_POS) & 0x7fU)
+#define DWC3_DEPCMD_STATUS(x)	(((x) & USB3_DEPCMD_CMDSTATUS_MSK) >> 12)
+#define DWC3_DGCMD_STATUS(n)	(((n) & USB3_DGCMD_CMDSTATUS_MSK) >> USB3_DGCMD_CMDSTATUS_POS)
+
+#define DWC3_DEPCMD_PARAM(x)	((x) << USB3_DEPCMD_COMMANDPARAM_POS)
+
+#define DWC3_LINK_STATE_SS_U0	0x00 /* in HS, means ON */
+#define DWC3_LINK_STATE_SS_U1	0x01
+#define DWC3_LINK_STATE_SS_U2	0x02 /* in HS, means SLEEP */
+#define DWC3_LINK_STATE_SS_U3	0x03 /* in HS, means SUSPEND */
+#define DWC3_LINK_STATE_SS_DIS	0x04 /* Default State */
+#define DWC3_LINK_STATE_SS_RX_DET	0x05 /* in HS, means Early Suspend */
+#define DWC3_LINK_STATE_SS_INACT	0x06
+#define DWC3_LINK_STATE_SS_POLL	0x07
+#define DWC3_LINK_STATE_SS_RECOV	0x08
+#define DWC3_LINK_STATE_SS_HRESET	0x09
+#define DWC3_LINK_STATE_SS_CMPLY	0x0a
+#define DWC3_LINK_STATE_SS_LPBK	0x0b
+#define DWC3_LINK_STATE_SS_RESET	0x0e
+#define DWC3_LINK_STATE_SS_RESUME	0x0f
+
+#define DWC3_LINK_STATE_ON	0x00U /* in HS, means ON */
+#define DWC3_LINK_STATE_L1	0x02U /* in HS, means SLEEP */
+#define DWC3_LINK_STATE_L2	0x03U /* in HS, means SUSPEND */
+#define DWC3_LINK_STATE_DIS	0x04U /* Default State */
+#define DWC3_LINK_STATE_EARLY_SUS	0x05U /* in HS, means Early Suspend */
+#define DWC3_LINK_STATE_RESET	0x0eU
+#define DWC3_LINK_STATE_RESUME	0x0fU
+
+#define DWC3_DCTL_ULSTCHNG_NO_ACTION	0
+#define DWC3_DCTL_ULSTCHNG_SS_DISABLED	4
+#define DWC3_DCTL_ULSTCHNG_RX_DETECT	5
+#define DWC3_DCTL_ULSTCHNG_SS_INACTIVE	6
+#define DWC3_DCTL_ULSTCHNG_RECOVERY	8
+#define DWC3_DCTL_ULSTCHNG_COMPLIANCE	10
+#define DWC3_DCTL_ULSTCHNG_LOOPBACK	11
+
+#define DWC3_DCTL_ULSTCHNGREQ(n)	(((n) << USB3_DCTL_ULSTCHNGREQ_POS) & \
+					USB3_DCTL_ULSTCHNGREQ_MSK)
+
+#define DWC3_DSTS_USBLNKST(n)	(((n) & USB3_DSTS_USBLNKST_MSK) >> USB3_DSTS_USBLNKST_POS)
+
+/* TRB Length, PCM and Status */
+#define DWC3_TRB_SIZE_MASK	(0x00ffffffU)
+#define DWC3_TRB_SIZE_LENGTH(n)	((n) & DWC3_TRB_SIZE_MASK)
+#define DWC3_TRB_SIZE_PCM1(n)	(((n) & 0x03) << 24)
+#define DWC3_TRB_SIZE_TRBSTS(n)	(((n) & (0x0fU << 28)) >> 28)
+
+#define DWC3_TRBSTS_OK	0
+#define DWC3_TRBSTS_MISSED_ISOC	1
+#define DWC3_TRBSTS_SETUP_PENDING	2
+#define DWC3_TRBSTS_XFER_IN_PROG	4
+
+/* TRB Control */
+#define DWC3_TRB_CTRL_HWO	BIT(0)
+#define DWC3_TRB_CTRL_LST	BIT(1)
+#define DWC3_TRB_CTRL_CHN	BIT(2)
+#define DWC3_TRB_CTRL_CSP	BIT(3)
+#define DWC3_TRB_CTRL_TRBCTL(n)	(((n) & 0x3fU) << 4)
+#define DWC3_TRB_CTRL_ISP_IMI	BIT(10)
+#define DWC3_TRB_CTRL_IOC	BIT(11)
+#define DWC3_TRB_CTRL_SID_SOFN(n)	(((n) & 0xffffU) << 14)
+
+#define DWC3_TRBCTL_NORMAL	DWC3_TRB_CTRL_TRBCTL(1U)
+#define DWC3_TRBCTL_CONTROL_SETUP	DWC3_TRB_CTRL_TRBCTL(2U)
+#define DWC3_TRBCTL_CONTROL_STATUS2	DWC3_TRB_CTRL_TRBCTL(3U)
+#define DWC3_TRBCTL_CONTROL_STATUS3	DWC3_TRB_CTRL_TRBCTL(4U)
+#define DWC3_TRBCTL_CONTROL_DATA	DWC3_TRB_CTRL_TRBCTL(5U)
+#define DWC3_TRBCTL_ISOCHRONOUS_FIRST	DWC3_TRB_CTRL_TRBCTL(6U)
+#define DWC3_TRBCTL_ISOCHRONOUS	DWC3_TRB_CTRL_TRBCTL(7U)
+#define DWC3_TRBCTL_LINK_TRB	DWC3_TRB_CTRL_TRBCTL(8U)
+
+#define MASK(len, pos)	GENMASK_32((len-1) + pos, pos)
+
+/* event */
+#define DWC3_EVT_TYPE_EP	0x0U
+#define DWC3_EVT_TYPE_LEN	0x1
+#define DWC3_EVT_TYPE_BITPOS	0x0
+#define DWC3_EVT_TYPE_MASK	MASK(DWC3_EVT_TYPE_LEN, DWC3_EVT_TYPE_BITPOS)
+#define DWC3_EVT_TYPE_DEVSPEC	0x1U
+#define DWC3_EVT_TYPE_NEP_TYPE_BITPOS	1
+#define DWC3_EVT_TYPE_NEP_TYPE_LEN	7
+#define DWC3_EVT_TYPE_NEP_TYPE_MASK	MASK(DWC3_EVT_TYPE_NEP_TYPE_LEN, \
+					DWC3_EVT_TYPE_NEP_TYPE_BITPOS)
+
+#define DWC3_DEPEVT_XFERCOMPLETE	0x01
+#define DWC3_DEPEVT_XFERINPROGRESS	0x02
+#define DWC3_DEPEVT_XFERNOTREADY	0x03
+#define DWC3_DEPEVT_RXTXFIFOEVT	0x04
+#define DWC3_DEPEVT_STREAMEVT	0x06
+#define DWC3_DEPEVT_EPCMDCMPLT	0x07
+
+#define DWC3_EVT_DEPEVT_TYPE_BITPOS	6
+#define DWC3_EVT_DEPEVT_TYPE_LEN	4
+#define DWC3_EVT_DEPEVT_TYPE_MASK	MASK(DWC3_EVT_DEPEVT_TYPE_LEN, DWC3_EVT_DEPEVT_TYPE_BITPOS)
+
+#define DWC3_EVT_DEPEVT_EPNUM_BITPOS	1
+#define DWC3_EVT_DEPEVT_EPNUM_LEN	5
+#define DWC3_EVT_DEPEVT_EPNUM_MASK	MASK(DWC3_EVT_DEPEVT_EPNUM_LEN, \
+					DWC3_EVT_DEPEVT_EPNUM_BITPOS)
+
+#define DWC3_EVT_DEPEVT_STATUS_BITPOS	12
+#define DWC3_EVT_DEPEVT_STATUS_LEN	4
+#define DWC3_EVT_DEPEVT_STATUS_MASK	MASK(DWC3_EVT_DEPEVT_STATUS_LEN, \
+					DWC3_EVT_DEPEVT_STATUS_BITPOS)
+
+/* Control-only Status */
+#define DWC3_EVT_DEPEVT_STATUS_CONTROL_DATA	1
+#define DWC3_EVT_DEPEVT_STATUS_CONTROL_STATUS	2
+
+#define DWC3_EVT_DEPEVT_PARAM_BITPOS	16
+#define DWC3_EVT_DEPEVT_PARAM_LEN	16
+#define DWC3_EVT_DEPEVT_PARAM_MASK	MASK(DWC3_EVT_DEPEVT_PARAM_LEN, \
+					DWC3_EVT_DEPEVT_PARAM_BITPOS)
+
+#define DWC3_EVT_DEVEVT_TYPE_BITPOS	8
+#define DWC3_EVT_DEVEVT_TYPE_LEN	4
+#define DWC3_EVT_DEVEVT_TYPE_MASK	MASK(DWC3_EVT_DEVEVT_TYPE_LEN, DWC3_EVT_DEVEVT_TYPE_BITPOS)
+
+#define DWC3_EVT_DEVEVT_LNKSTS_BITPOS	16
+#define DWC3_EVT_DEVEVT_LNKSTS_LEN	4
+#define DWC3_EVT_DEVEVT_LNKSTS_MASK	MASK(DWC3_EVT_DEVEVT_LNKSTS_LEN, \
+					DWC3_EVT_DEVEVT_LNKSTS_BITPOS)
+
+/* Bit fields for USB3_GCTL register */
+#define USB3_GCTL_CORESOFTRESET	_DWC3_GCTL_CORESOFTRESET
+#define USB3_GCTL_PRTCAPDIR_POS	_DWC3_GCTL_PRTCAPDIR_SHIFT
+#define USB3_GCTL_PRTCAPDIR_MSK	_DWC3_GCTL_PRTCAPDIR_MASK
+
+/* Bit fields for USB3_GUSB2PHYCFG register */
+#define USB3_GUSB2PHYCFG_ULPI_UTMI_SEL	_DWC3_GUSB2PHYCFG_ULPI_UTMI_SEL
+#define USB3_GUSB2PHYCFG_PHYSOFTRST	_DWC3_GUSB2PHYCFG_PHYSOFTRST
+
+/* Bit fields for USB3_GUSB3PIPECTL register */
+#define USB3_GUSB3PIPECTL_PHYSOFTRST	_DWC3_GUSB3PIPECTL_PHYSOFTRST
+
+/* Bit fields for USB3_GEVNTSIZ register */
+#define USB3_GEVNTSIZ_EVNTINTRPTMASK_MSK	_DWC3_GEVNTSIZ_EVNTINTRPTMASK
+
+/* Bit fields for USB3_DCFG register */
+#define USB3_DCFG_DEVSPD_POS	_DWC3_DCFG_DEVSPD_SHIFT
+#define USB3_DCFG_DEVSPD_MSK	_DWC3_DCFG_DEVSPD_MASK
+#define USB3_DCFG_DEVADDR_POS	_DWC3_DCFG_DEVADDR_SHIFT
+#define USB3_DCFG_DEVADDR_MSK	_DWC3_DCFG_DEVADDR_MASK
+#define USB3_DCFG_INTRNUM_POS	_DWC3_DCFG_INTRNUM_SHIFT
+#define USB3_DCFG_INTRNUM_MSK	_DWC3_DCFG_INTRNUM_MASK
+#define USB3_DCFG_NUMP_POS	_DWC3_DCFG_NUMP_SHIFT
+#define USB3_DCFG_NUMP_MSK	_DWC3_DCFG_NUMP_MASK
+#define USB3_DCFG_LPMCAP	_DWC3_DCFG_LPMCAP
+#define USB3_DCFG_IGNSTRMPP	_DWC3_DCFG_IGNSTRMPP
+
+/* Bit fields for USB3_DCTL register */
+#define USB3_DCTL_TSTCTL_POS	_DWC3_DCTL_TSTCTL_SHIFT
+#define USB3_DCTL_TSTCTL_MSK	_DWC3_DCTL_TSTCTL_MASK
+#define USB3_DCTL_ULSTCHNGREQ_POS	_DWC3_DCTL_ULSTCHNGREQ_SHIFT
+#define USB3_DCTL_ULSTCHNGREQ_MSK	_DWC3_DCTL_ULSTCHNGREQ_MASK
+#define USB3_DCTL_ACCEPTU1ENA	_DWC3_DCTL_ACCEPTU1ENA
+#define USB3_DCTL_INITU1ENA	_DWC3_DCTL_INITU1ENA
+#define USB3_DCTL_ACCEPTU2ENA	_DWC3_DCTL_ACCEPTU2ENA
+#define USB3_DCTL_INITU2ENA	_DWC3_DCTL_INITU2ENA
+#define USB3_DCTL_CSS	_DWC3_DCTL_CSS
+#define USB3_DCTL_CRS	_DWC3_DCTL_CRS
+#define USB3_DCTL_L1HIBERNATIONEN	_DWC3_DCTL_L1HIBERNATIONEN
+#define USB3_DCTL_KEEPCONNECT	_DWC3_DCTL_KEEPCONNECT
+#define USB3_DCTL_LPM_NYET_THRES_POS	_DWC3_DCTL_LPM_NYET_THRES_SHIFT
+#define USB3_DCTL_LPM_NYET_THRES_MSK	_DWC3_DCTL_LPM_NYET_THRES_MASK
+#define USB3_DCTL_HIRDTHRES_POS	_DWC3_DCTL_HIRDTHRES_SHIFT
+#define USB3_DCTL_HIRDTHRES_MSK	_DWC3_DCTL_HIRDTHRES_MASK
+#define USB3_DCTL_CSFTRST	_DWC3_DCTL_CSFTRST
+#define USB3_DCTL_RUN_STOP	_DWC3_DCTL_RUN_STOP
+
+/* Bit fields for USB3_DEVTEN register */
+#define USB3_DEVTEN_DISSCONNEVTEN	_DWC3_DEVTEN_DISSCONNEVTEN
+#define USB3_DEVTEN_USBRSTEVTEN	_DWC3_DEVTEN_USBRSTEVTEN
+#define USB3_DEVTEN_CONNECTDONEEVTEN	_DWC3_DEVTEN_CONNECTDONEEVTEN
+#define USB3_DEVTEN_ULSTCNGEN	_DWC3_DEVTEN_ULSTCNGEN
+#define USB3_DEVTEN_WKUPEVTEN	_DWC3_DEVTEN_WKUPEVTEN
+#define USB3_DEVTEN_HIBERNATIONREQEVTEN	_DWC3_DEVTEN_HIBERNATIONREQEVTEN
+#define USB3_DEVTEN_U3L2L1SUSPEN	_DWC3_DEVTEN_U3L2L1SUSPEN
+#define USB3_DEVTEN_SOFTEVTEN	_DWC3_DEVTEN_SOFTEVTEN
+#define USB3_DEVTEN_L1SUSPEN	_DWC3_DEVTEN_L1SUSPEN
+#define USB3_DEVTEN_ERRTICERREVTEN	_DWC3_DEVTEN_ERRTICERREVTEN
+#define USB3_DEVTEN_CMDCMPLTEN	_DWC3_DEVTEN_CMDCMPLTEN
+#define USB3_DEVTEN_EVNTOVERFLOWEN	_DWC3_DEVTEN_EVNTOVERFLOWEN
+#define USB3_DEVTEN_VENDEVTSTRCVDEN	_DWC3_DEVTEN_VENDEVTSTRCVDEN
+#define USB3_DEVTEN_L1WKUPEVTEN	_DWC3_DEVTEN_L1WKUPEVTEN
+#define USB3_DEVTEN_ECCERREN	_DWC3_DEVTEN_ECCERREN
+
+/* Bit fields for USB3_DSTS register */
+#define USB3_DSTS_CONNECTSPD_POS	_DWC3_DSTS_CONNECTSPD_SHIFT
+#define USB3_DSTS_CONNECTSPD_MSK	_DWC3_DSTS_CONNECTSPD_MASK
+#define USB3_DSTS_CONNECTSPD	_DWC3_DSTS_CONNECTSPD_MASK
+#define USB3_DSTS_SOFFN_POS	_DWC3_DSTS_SOFFN_SHIFT
+#define USB3_DSTS_SOFFN_MSK	_DWC3_DSTS_SOFFN_MASK
+#define USB3_DSTS_RXFIFOEMPTY	_DWC3_DSTS_RXFIFOEMPTY
+#define USB3_DSTS_USBLNKST_POS	_DWC3_DSTS_USBLNKST_SHIFT
+#define USB3_DSTS_USBLNKST_MSK	_DWC3_DSTS_USBLNKST_MASK
+#define USB3_DSTS_DEVCTRLHLT	_DWC3_DSTS_DEVCTRLHLT
+#define USB3_DSTS_COREIDLE	_DWC3_DSTS_COREIDLE
+#define USB3_DSTS_SSS	_DWC3_DSTS_SSS
+#define USB3_DSTS_RSS	_DWC3_DSTS_RSS
+#define USB3_DSTS_SRE	_DWC3_DSTS_SRE
+#define USB3_DSTS_DCNRD	_DWC3_DSTS_DCNRD
+
+/* Bit fields for USB3_DGCMD register */
+#define USB3_DGCMD_CMDTYP_POS	_DWC3_DEPCMD_CMDTYP_SHIFT
+#define USB3_DGCMD_CMDTYP_MSK	_DWC3_DEPCMD_CMDTYP_MASK
+#define USB3_DGCMD_CMDIOC	_DWC3_DGCMD_CMDIOC
+#define USB3_DGCMD_CMDACT	_DWC3_DGCMD_CMDACT
+#define USB3_DGCMD_CMDSTATUS_POS	_DWC3_DGCMD_CMDSTATUS_SHIFT
+#define USB3_DGCMD_CMDSTATUS_MSK	_DWC3_DGCMD_CMDSTATUS_MASK
+
+/* Bit fields for USB3_DEPCMD register */
+#define USB3_DEPCMD_CMDTYP_POS	_DWC3_DEPCMD_CMDTYP_SHIFT
+#define USB3_DEPCMD_CMDTYP_MSK	_DWC3_DEPCMD_CMDTYP_MASK
+#define USB3_DEPCMD_CMDTYP	_DWC3_DEPCMD_CMDTYP_MASK
+#define USB3_DEPCMD_CMDIOC	_DWC3_DEPCMD_CMDIOC
+#define USB3_DEPCMD_CMDACT	_DWC3_DEPCMD_CMDACT
+#define USB3_DEPCMD_HIPRI_FORCERM	_DWC3_DEPCMD_HIPRI_FORCERM
+#define USB3_DEPCMD_CMDSTATUS_POS	_DWC3_DEPCMD_CMDSTATUS_SHIFT
+#define USB3_DEPCMD_CMDSTATUS_MSK	_DWC3_DEPCMD_CMDSTATUS_MASK
+#define USB3_DEPCMD_COMMANDPARAM_POS	_DWC3_DEPCMD_COMMANDPARAM_SHIFT
+#define USB3_DEPCMD_COMMANDPARAM_MSK	_DWC3_DEPCMD_COMMANDPARAM_MASK
+
+/* Bit fields for USB3_DEV_IMOD register */
+#define USB3_DEV_IMOD_DEVICE_IMODI_POS	_DWC3_DEV_IMOD_DEVICE_IMODI_SHIFT
+#define USB3_DEV_IMOD_DEVICE_IMODI_MSK	_DWC3_DEV_IMOD_DEVICE_IMODI_MASK
+#define USB3_DEV_IMOD_DEVICE_IMODC_POS	_DWC3_DEV_IMOD_DEVICE_IMODC_SHIFT
+#define USB3_DEV_IMOD_DEVICE_IMODC_MSK	_DWC3_DEV_IMOD_DEVICE_IMODC_MASK
+
+#define IS_MULTIPLE(x, a)	(((x) % (a)) == 0U)
+#define ALIGN_MULTIPLE(x, a)	((a) * (((x) / (a)) + ((((x) % (a)) != 0U) ? 1U : 0U)))
+#define PAGE_ALIGN(addr, mask)	((addr) & ~(mask))
+
+#define upper_32_bits(n)	((uint32_t)(((n) >> 16) >> 16))
+#define lower_32_bits(n)	((uint32_t)(n))
+
+/* DWC3 IP Parameter */
+#define DWC3_IP_DEVICE_NUM_INT	2
+#define DWC3_IP_NUM_EPS	32U
+#define DWC3_IP_NUM_IN_EPS	16
+
+/* HAL_PCD defines */
+#define __HAL_PCD_ENABLE_INTR(__HANDLE__, intr)	usb_dwc3_enable_eventint(__HANDLE__, intr)
+#define __HAL_PCD_DISABLE_INTR(__HANDLE__, intr)	usb_dwc3_disable_eventint(__HANDLE__, intr)
+
+#define __HAL_PCD_SETUP_REQ_LEN(addr)	(((uint16_t)(*((uint8_t *)(addr) + 6))) + \
+						(((uint16_t)(*((uint8_t *)(addr) + 7))) << 8))
+
+#define __HAL_PCD_SETUP_REQ_DATA_DIR_IN(addr)	((*(uint8_t *)(addr)) & EP_DIR_IN)
+
+#define __HAL_PCD_INCR_EVENT_POS(__HANDLE__, intr, incr) \
+						(__HANDLE__)->intbuffers.evtbufferpos[intr] = \
+						((__HANDLE__)->intbuffers.evtbufferpos[intr] + \
+						 (incr)) % USB_DWC3_EVENT_BUFFER_SIZE
+#define __HAL_PCD_READ_EVENT(__HANDLE__, intr)	*(volatile uint32_t *)&((__HANDLE__)->\
+						intbuffers.evtbuffer_addr[intr][(__HANDLE__)->\
+						intbuffers.evtbufferpos[intr]])
+
+#define __HAL_PCD_EPADDR_TO_PHYEPNUM(ep_addr)	((2U * ((ep_addr) & ADDRESS_MASK)) + \
+						((((ep_addr) & EP_DIR_MASK) != 0U) ? 1U : 0U))
+#define __HAL_PCD_PHYEPNUM_TO_EPADDR(phy_epnum)	(((phy_epnum) / 2U) | \
+						((((phy_epnum) & 0x1U) != 0U) ? EP_DIR_IN : 0U))
+
+#define PCD_DEV_EVENTS_INTR	0 /* Interrupt to use for device events */
+
+#define GET_DWC3EP_FROM_USBEP(__HANDLE__, usb_ep)	*(volatile uint32_t *)&((__HANDLE__)->\
+						intbuffers.evtbuffer_addr[intr][(__HANDLE__)->\
+						intbuffers.evtbufferpos[intr]])
+
+typedef uint32_t dwc3_epcmd_t;
+typedef struct {
+	uint32_t  param2;
+	uint32_t  param1;
+	uint32_t  param0;
+} dwc3_epcmd_params_t;
+
+static uint32_t DWC3_regread(void *base, uint32_t offset)
+{
+	return mmio_read_32((uintptr_t)base + offset);
+}
+
+static void DWC3_regwrite(void *base, uint32_t offset, uint32_t value)
+{
+	mmio_write_32((uintptr_t)base + offset, value);
+}
+
+static void DWC3_regupdateset(void *base, uint32_t offset, uint32_t set_mask)
+{
+	mmio_setbits_32((uintptr_t)base + offset, set_mask);
+}
+
+static void DWC3_regupdateclr(void *base, uint32_t offset, uint32_t clr_mask)
+{
+	mmio_clrbits_32((uintptr_t)base + offset, clr_mask);
+}
+
+static void usb_dwc3_enable_eventint(dwc3_handle_t *handle, uint8_t intr_num)
+{
+	DWC3_regupdateclr(handle->usb_global, DWC3_GEVNTSIZ(intr_num),
+			  USB3_GEVNTSIZ_EVNTINTRPTMASK_MSK);
+}
+
+static void usb_dwc3_disable_eventint(dwc3_handle_t *handle, uint8_t intr_num)
+{
+	DWC3_regupdateset(handle->usb_global, DWC3_GEVNTSIZ(intr_num),
+			  USB3_GEVNTSIZ_EVNTINTRPTMASK_MSK);
+}
+
+static uintptr_t api_mapdmaaddr(uint8_t buf[], uint32_t size, uint8_t to_device)
+{
+	if (to_device)
+		clean_dcache_range((uintptr_t)buf, size);
+	else
+		inv_dcache_range((uintptr_t)buf, size);
+
+	return (uintptr_t)buf;
+}
+
+static void api_unmapdmaaddr(uintptr_t dma_addr __unused, uint32_t size __unused,
+			     uint8_t to_device __unused)
+{
+}
+
+static uintptr_t api_getdmaaddr(uint8_t buf[], uint32_t size __unused, uint8_t to_device __unused)
+{
+	return (uintptr_t)buf;
+}
+
+__unused static void api_putdmaaddr(uintptr_t dma_addr __unused, uint32_t size __unused,
+				    uint8_t to_device __unused)
+{
+}
+
+static void api_memcpy(void *dest, const void *src, uint32_t n)
+{
+#ifdef AVOID_COMPILER_MEMCPY
+	uint8_t *pcdst = (uint8_t *)dest;
+	uint8_t const *pcsrc = (uint8_t const *)src;
+
+	while (n--) {
+		*pcdst++ = *pcsrc++;
+	}
+#else
+	(void)memcpy(dest, src, n);
+#endif
+}
+
+static uint32_t dwc3_get_trb_ctltype(uint32_t trb_type)
+{
+	uint32_t ret;
+
+	switch (trb_type) {
+	case USB_DWC3_TRBCTL_NORMAL:
+		ret = DWC3_TRBCTL_NORMAL;
+		break;
+	case USB_DWC3_TRBCTL_CONTROL_SETUP:
+		ret = DWC3_TRBCTL_CONTROL_SETUP;
+		break;
+	case USB_DWC3_TRBCTL_CONTROL_STATUS2:
+		ret = DWC3_TRBCTL_CONTROL_STATUS2;
+		break;
+	case USB_DWC3_TRBCTL_CONTROL_STATUS3:
+		ret = DWC3_TRBCTL_CONTROL_STATUS3;
+		break;
+	case USB_DWC3_TRBCTL_CONTROL_DATA:
+		ret = DWC3_TRBCTL_CONTROL_DATA;
+		break;
+	case USB_DWC3_TRBCTL_ISOCHRONOUS_FIRST:
+		ret = DWC3_TRBCTL_ISOCHRONOUS_FIRST;
+		break;
+	case USB_DWC3_TRBCTL_ISOCHRONOUS:
+		ret = DWC3_TRBCTL_ISOCHRONOUS;
+		break;
+	case USB_DWC3_TRBCTL_LINK_TRB:
+		ret = DWC3_TRBCTL_LINK_TRB;
+		break;
+	default:
+		ret = 0U;
+		break;
+	}
+
+	return ret;
+}
+
+static inline const char *dwc3_get_ep_cmd_str(uint32_t cmd)
+{
+	const char *ret;
+
+	switch (cmd & USB3_DEPCMD_CMDTYP_MSK) {
+	case USB_DWC3_DEPCMD_DEPSTARTCFG:
+		ret = "Start New Configuration";
+		break;
+	case USB_DWC3_DEPCMD_ENDTRANSFER:
+		ret = "End Transfer";
+		break;
+	case USB_DWC3_DEPCMD_UPDATETRANSFER:
+		ret = "Update Transfer";
+		break;
+	case USB_DWC3_DEPCMD_STARTTRANSFER:
+		ret = "Start Transfer";
+		break;
+	case USB_DWC3_DEPCMD_CLEARSTALL:
+		ret = "Clear Stall";
+		break;
+	case USB_DWC3_DEPCMD_SETSTALL:
+		ret = "Set Stall";
+		break;
+	case USB_DWC3_DEPCMD_GETEPSTATE:
+		ret = "Get Endpoint State";
+		break;
+	case USB_DWC3_DEPCMD_SETTRANSFRESOURCE:
+		ret = "Set Endpoint Transfer Resource";
+		break;
+	case USB_DWC3_DEPCMD_SETEPCONFIG:
+		ret = "Set Endpoint Configuration";
+		break;
+	default:
+		ret = "UNKNOWN command";
+		break;
+	}
+
+	return ret;
+}
+
+static enum usb_status dwc3_execute_dep_cmd(dwc3_handle_t *dwc3_handle, uint8_t phy_epnum,
+					    dwc3_epcmd_t cmd, dwc3_epcmd_params_t *params)
+{
+	uint32_t reg;
+	uint64_t timeout;
+
+	VERBOSE("PHYEP%d: cmd '%s' %08x params %08x %08x %08x\n", phy_epnum,
+		   dwc3_get_ep_cmd_str(cmd), (uint32_t)cmd, (uint32_t)params->param0,
+		   (uint32_t)params->param1, (uint32_t)params->param2);
+
+	DWC3_regwrite(dwc3_handle->usb_device, DWC3_DEPCMDPAR0(phy_epnum), params->param0);
+	DWC3_regwrite(dwc3_handle->usb_device, DWC3_DEPCMDPAR1(phy_epnum), params->param1);
+	DWC3_regwrite(dwc3_handle->usb_device, DWC3_DEPCMDPAR2(phy_epnum), params->param2);
+
+	DWC3_regwrite(dwc3_handle->usb_device, DWC3_DEPCMD(phy_epnum), cmd | USB3_DEPCMD_CMDACT);
+
+	timeout = timeout_init_us(500); /* usec */
+	do {
+		reg = DWC3_regread(dwc3_handle->usb_device, DWC3_DEPCMD(phy_epnum));
+		/* "Command Complete" */
+		if ((reg & USB3_DEPCMD_CMDACT) == 0U) {
+			VERBOSE("Command Complete --> %d PHYEP%d %x\n", DWC3_DEPCMD_STATUS(reg),
+				   phy_epnum, reg);
+			if (DWC3_DEPCMD_STATUS(reg) != 0U) {
+				return USBD_FAIL;
+			}
+			return USBD_OK;
+		}
+
+		/* Can be called from interrupt context hence cannot wait for Tick */
+		if (timeout_elapsed(timeout)) {
+			ERROR("TIMEOUT Command Complete --> %d PHYEP%d %x\n",
+				   DWC3_DEPCMD_STATUS(reg), phy_epnum, reg);
+			/* "Command Timed Out" */
+			return USBD_TIMEOUT;
+		}
+	} while (true);
+
+	return USBD_OK;
+}
+
+static bool dwc3_is_ep_enabled(dwc3_handle_t *dwc3_handle, uint8_t phy_epnum)
+{
+	if ((DWC3_regread(dwc3_handle->usb_device,
+			  DWC3_DALEPENA) & DWC3_DALEPENA_EP(phy_epnum)) != 0U) {
+		return true;
+	}
+
+	return false;
+}
+
+static enum usb_status dwc3_ep_start_xfer(dwc3_handle_t *dwc3_handle, struct usbd_ep *ep)
+{
+	enum usb_status ret;
+	dwc3_epcmd_t cmd;
+	dwc3_epcmd_params_t params;
+
+	usb_dwc3_endpoint_t *dwc3_ep = ((ep->is_in) ? &dwc3_handle->IN_ep[ep->num] :
+					&dwc3_handle->OUT_ep[ep->num]);
+
+	VERBOSE("%s PHYEP%d %x\n", __func__, dwc3_ep->phy_epnum, dwc3_ep->flags);
+
+	/* Wait for XferNotReady to get the uF interval to srat ISOC transfers */
+	if ((ep->type == EP_TYPE_ISOC) &&
+	    ((dwc3_ep->flags & USB_DWC3_EP_ISOC_START_PENDING) == 0U) &&
+	    ((dwc3_ep->flags & USB_DWC3_EP_ISOC_STARTED) == 0U)) {
+		dwc3_ep->flags |= USB_DWC3_EP_ISOC_START_PENDING;
+		VERBOSE("INSIDE IF\n");
+		return USBD_OK;
+	}
+
+	if ((ep->type == EP_TYPE_ISOC) &&
+	    ((dwc3_ep->flags & USB_DWC3_EP_ISOC_START_PENDING) != 0U)) {
+		dwc3_ep->flags &= ~USB_DWC3_EP_ISOC_START_PENDING;
+	}
+
+	dwc3_ep->trb_addr->bpl = lower_32_bits(dwc3_ep->dma_addr);
+	dwc3_ep->trb_addr->bph = upper_32_bits(dwc3_ep->dma_addr);
+	dwc3_ep->trb_addr->size = DWC3_TRB_SIZE_LENGTH(ep->xfer_len);
+	/* also initializes other bits to 0 */
+	dwc3_ep->trb_addr->ctrl = dwc3_get_trb_ctltype(dwc3_ep->trb_flag & USB_DWC3_TRBCTL_MASK);
+
+	dwc3_ep->trb_addr->ctrl |= ((ep->num == 0U) ? DWC3_TRB_CTRL_ISP_IMI : 0U);
+
+	dwc3_ep->trb_addr->ctrl |= DWC3_TRB_CTRL_IOC;
+
+	if ((ep->type == EP_TYPE_ISOC) && ((dwc3_ep->flags & USB_DWC3_EP_ISOC_STARTED) != 0U)) {
+		cmd = USB_DWC3_DEPCMD_UPDATETRANSFER;
+	} else {
+		cmd = USB_DWC3_DEPCMD_STARTTRANSFER;
+	}
+
+	if (ep->type != EP_TYPE_ISOC) {
+		dwc3_ep->trb_addr->ctrl |= DWC3_TRB_CTRL_LST;
+	}
+
+	dwc3_ep->trb_addr->ctrl |= DWC3_TRB_CTRL_HWO;
+
+	(void)memset(&params, 0x00, sizeof(params));
+
+	if ((cmd & USB3_DEPCMD_CMDTYP_MSK) == USB_DWC3_DEPCMD_STARTTRANSFER) {
+		params.param0 = upper_32_bits(dwc3_ep->trb_dma_addr);
+		params.param1 = lower_32_bits(dwc3_ep->trb_dma_addr);
+	}
+
+	dwc3_ep->flags |= USB_DWC3_EP_REQ_QUEUED;
+	if ((ep->type == EP_TYPE_ISOC) &&
+	    ((cmd & USB3_DEPCMD_CMDTYP_MSK) == USB_DWC3_DEPCMD_STARTTRANSFER)) {
+		dwc3_ep->flags |= USB_DWC3_EP_ISOC_STARTED;
+	}
+
+	VERBOSE("EP%d%s: trb %p:%08x:%08x:%08x:%08x length %d %d\n",
+		   ep->num, ep->is_in ? "IN" : "OUT", dwc3_ep->trb_addr,
+		   (uint32_t)dwc3_ep->trb_addr->bph, (uint32_t)dwc3_ep->trb_addr->bpl,
+		   (uint32_t)dwc3_ep->trb_addr->size, (uint32_t)dwc3_ep->trb_addr->ctrl,
+		   ep->xfer_len, dwc3_ep->flags);
+
+	ret = dwc3_execute_dep_cmd(dwc3_handle, dwc3_ep->phy_epnum, cmd, &params);
+	if (ret != USBD_OK) {
+		dwc3_ep->flags &= ~USB_DWC3_EP_REQ_QUEUED;
+		if ((ep->type == EP_TYPE_ISOC) &&
+		    ((cmd & USB3_DEPCMD_CMDTYP_MSK) == USB_DWC3_DEPCMD_STARTTRANSFER)) {
+			dwc3_ep->flags &= ~USB_DWC3_EP_ISOC_STARTED;
+		}
+		return ret;
+	}
+
+	if ((cmd & USB3_DEPCMD_CMDTYP_MSK) == USB_DWC3_DEPCMD_STARTTRANSFER) {
+		dwc3_ep->resc_idx =
+		(uint8_t)DWC3_DEPCMD_GET_RSC_IDX(DWC3_regread(dwc3_handle->usb_device,
+							      DWC3_DEPCMD(dwc3_ep->phy_epnum)));
+	}
+
+	return ret;
+}
+
+static enum usb_status usb_dwc3_ep_start_xfer(void *handle, struct usbd_ep *ep)
+{
+	dwc3_handle_t *dwc3_handle = (dwc3_handle_t *)handle;
+	usb_dwc3_endpoint_t *dwc3_ep = ((ep->is_in) ? &dwc3_handle->IN_ep[ep->num] :
+					&dwc3_handle->OUT_ep[ep->num]);
+	uint32_t len = ep->xfer_len;
+
+	if (!dwc3_is_ep_enabled(dwc3_handle, dwc3_ep->phy_epnum) && ep->num != 0U) {
+		return USBD_FAIL;
+	}
+
+	if (!ep->is_in) {
+		if ((len > ep->maxpacket) && !IS_MULTIPLE(len, ep->maxpacket)) {
+			WARN("WARNING : Packet size > Max_packet but non-multiple, buffer should be of at least Max_packet-size multiple\n");
+		}
+
+		/*setup and start the Xfer */
+		if ((len != 0U) && (len < ep->maxpacket)) {
+			dwc3_ep->xfer_dest_buff = ep->xfer_buff;
+			dwc3_ep->xfer_dest_len = ep->xfer_len;
+			ep->xfer_buff = dwc3_ep->bounce_buf;
+			ep->xfer_len = ALIGN_MULTIPLE(len, ep->maxpacket);
+		} else {
+//			ep->xfer_buff = pBuf;
+			ep->xfer_len = ALIGN_MULTIPLE(len, ep->maxpacket);
+		}
+	}
+
+	dwc3_ep->dma_addr = ((ep->xfer_buff != 0) ?
+			     api_mapdmaaddr(ep->xfer_buff, ep->xfer_len, ep->is_in ? 1 : 0) :
+			     0x0U);
+
+	if (ep->num == 0U) {
+		/* For Status ZLP packet */
+		if (len == 0U) {
+			/* 2-stage/3-stage control transfer */
+			if (__HAL_PCD_SETUP_REQ_LEN(dwc3_handle->setup_addr) == 0U) {
+				dwc3_ep->trb_flag = USB_DWC3_TRBCTL_CONTROL_STATUS2;
+			} else {
+				dwc3_ep->trb_flag = USB_DWC3_TRBCTL_CONTROL_STATUS3;
+			}
+			//udelay(10);
+		} else {
+			dwc3_ep->trb_flag = USB_DWC3_TRBCTL_CONTROL_DATA;
+		}
+	} else {
+		if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK)) {
+			dwc3_ep->trb_flag = USB_DWC3_TRBCTL_NORMAL;
+		} else {
+			dwc3_ep->trb_flag = USB_DWC3_TRBCTL_ISOCHRONOUS_FIRST;
+		}
+	}
+
+	return dwc3_ep_start_xfer(dwc3_handle, ep);
+}
+
+static enum usb_status dwc3_ep0_out_start(dwc3_handle_t *dwc3_handle, uintptr_t setup_buf_dma_addr)
+{
+	dwc3_handle->OUT_ep[0].dma_addr = setup_buf_dma_addr;
+	dwc3_handle->pcd_handle->out_ep[0].xfer_len = 8;
+	dwc3_handle->OUT_ep[0].trb_flag = USB_DWC3_TRBCTL_CONTROL_SETUP;
+
+	return dwc3_ep_start_xfer(dwc3_handle, &dwc3_handle->pcd_handle->out_ep[0]);
+}
+
+static enum usb_status usb_dwc3_ep0_out_start(void *handle)
+{
+	dwc3_handle_t *dwc3_handle = (dwc3_handle_t *)handle;
+
+	dwc3_handle->EP0_State = HAL_PCD_EP0_SETUP_QUEUED;
+	return dwc3_ep0_out_start(dwc3_handle, dwc3_handle->setup_dma_addr);
+}
+
+static enum usb_status usb_dwc3_start_device(void *handle)
+{
+	dwc3_handle_t *dwc3_handle = (dwc3_handle_t *)handle;
+
+	DWC3_regupdateset(dwc3_handle->usb_device, DWC3_DCTL, USB3_DCTL_RUN_STOP);
+
+	return USBD_OK;
+}
+
+static enum usb_status usb_dwc3_stop_device(void *handle)
+{
+	dwc3_handle_t *dwc3_handle = (dwc3_handle_t *)handle;
+	uint64_t timeout;
+
+	DWC3_regupdateclr(dwc3_handle->usb_device, DWC3_DCTL, USB3_DCTL_RUN_STOP);
+
+	timeout = timeout_init_us(500); /* usec */
+
+	while ((DWC3_regread(dwc3_handle->usb_device, DWC3_DSTS) &
+		     USB3_DSTS_DEVCTRLHLT) == 0U) {
+		/* Can be called from interrupt context hence cannot wait for Tick */
+		if (timeout_elapsed(timeout)) { /* "Reset Timed Out" */
+			ERROR("TIMEOUT Stop Device\n");
+			return USBD_TIMEOUT;
+		}
+	}
+
+	// "Halt Complete"
+
+	return USBD_OK;
+}
+
+static enum usb_status usb_dwc3_set_address(void *handle, uint8_t address)
+{
+	dwc3_handle_t *dwc3_handle = (dwc3_handle_t *)handle;
+
+	VERBOSE("%s: %d\n", __func__, address);
+
+	/* set device address */
+	DWC3_regupdateclr(dwc3_handle->usb_device, DWC3_DCFG, USB3_DCFG_DEVADDR_MSK);
+	DWC3_regupdateset(dwc3_handle->usb_device, DWC3_DCFG, DWC3_DCFG_DEVADDR((uint32_t)address));
+
+	return USBD_OK;
+}
+
+static enum usb_status usb_dwc3_ep0_start_xfer(void *handle, struct usbd_ep *ep)
+{
+	return usb_dwc3_ep_start_xfer(handle, ep);
+}
+
+static enum usb_status dwc3_ep_set_stall(dwc3_handle_t *dwc3_handle, usb_dwc3_endpoint_t *dwc3_ep)
+{
+	dwc3_epcmd_params_t params;
+
+	(void)memset(&params, 0x00, sizeof(params));
+
+	return dwc3_execute_dep_cmd(dwc3_handle, dwc3_ep->phy_epnum, USB_DWC3_DEPCMD_SETSTALL,
+				    &params);
+}
+
+static enum usb_status usb_dwc3_ep_set_stall(void *handle, struct usbd_ep *ep)
+{
+	dwc3_handle_t *dwc3_handle = (dwc3_handle_t *)handle;
+	usb_dwc3_endpoint_t *dwc3_ep = ((ep->is_in) ? &dwc3_handle->IN_ep[ep->num] :
+					&dwc3_handle->OUT_ep[ep->num]);
+
+	if (dwc3_ep->is_stall) {
+		return USBD_OK;
+	}
+
+	dwc3_ep->is_stall = true;
+
+	return dwc3_ep_set_stall(dwc3_handle, dwc3_ep);
+}
+
+static uint8_t dwc3_read_ep_evt_type(uint32_t event)
+{
+	uint8_t ret;
+
+	switch ((event & DWC3_EVT_DEPEVT_TYPE_MASK) >> DWC3_EVT_DEPEVT_TYPE_BITPOS) {
+	case DWC3_DEPEVT_XFERCOMPLETE:
+		ret =  USB_DWC3_DEPEVT_XFERCOMPLETE;
+		break;
+	case DWC3_DEPEVT_XFERINPROGRESS:
+		ret =  USB_DWC3_DEPEVT_XFERINPROGRESS;
+		break;
+	case DWC3_DEPEVT_XFERNOTREADY:
+		ret =  USB_DWC3_DEPEVT_XFERNOTREADY;
+		break;
+	case DWC3_DEPEVT_RXTXFIFOEVT:
+		ret =  USB_DWC3_DEPEVT_RXTXFIFOEVT;
+		break;
+	case DWC3_DEPEVT_STREAMEVT:
+		ret =  USB_DWC3_DEPEVT_STREAMEVT;
+		break;
+	case DWC3_DEPEVT_EPCMDCMPLT:
+		ret =  USB_DWC3_DEPEVT_EPCMDCMPLT;
+		break;
+	default:
+		ret = (event & DWC3_EVT_DEPEVT_TYPE_MASK) >> DWC3_EVT_DEPEVT_TYPE_BITPOS;
+		break;
+	}
+
+	return ret;
+}
+
+static uint8_t dwc3_read_ep_evt_epnum(uint32_t event)
+{
+	return (uint8_t)((event & DWC3_EVT_DEPEVT_EPNUM_MASK) >> DWC3_EVT_DEPEVT_EPNUM_BITPOS);
+}
+
+static uint8_t dwc3_read_ep_evt_status(uint32_t event)
+{
+	uint8_t ret;
+
+	switch ((event & DWC3_EVT_DEPEVT_STATUS_MASK) >> DWC3_EVT_DEPEVT_STATUS_BITPOS) {
+	case DWC3_EVT_DEPEVT_STATUS_CONTROL_DATA:
+		ret = USB_DWC3_DEPEVT_XFERNOTREADY_STATUS_CTRL_DATA;
+		break;
+	case DWC3_EVT_DEPEVT_STATUS_CONTROL_STATUS:
+		ret = USB_DWC3_DEPEVT_XFERNOTREADY_STATUS_CTRL_STATUS;
+		break;
+	default:
+		ret = (event & DWC3_EVT_DEPEVT_STATUS_MASK) >> DWC3_EVT_DEPEVT_STATUS_BITPOS;
+		break;
+	}
+
+	return ret;
+}
+
+static enum usb_status dwc3_epaddr_set_stall(dwc3_handle_t *dwc3_handle, uint8_t ep_addr)
+{
+	struct usbd_ep *ep;
+	enum usb_status ret;
+	usb_dwc3_endpoint_t *dwc3_ep;
+
+	if ((ep_addr & EP_DIR_MASK) == EP_DIR_IN) {
+		ep = &dwc3_handle->pcd_handle->in_ep[ep_addr & ADDRESS_MASK];
+		dwc3_ep = &dwc3_handle->IN_ep[ep_addr & ADDRESS_MASK];
+	} else {
+		ep = &dwc3_handle->pcd_handle->out_ep[ep_addr];
+		dwc3_ep = &dwc3_handle->OUT_ep[ep_addr];
+	}
+
+	/* For control endpoints, the application issues only the Set Stall command, and only on the
+	 * OUT direction of the control endpoint. The controller automatically clears the STALL when
+	 * it receives a SETUP token for the endpoint. The application must not issue the Clear
+	 * Stall command on a control endpoint
+	 */
+	if (ep_addr == EP0_IN) {
+		return USBD_OK;
+	}
+
+	if (dwc3_ep->is_stall) {
+		return USBD_OK;
+	}
+
+	dwc3_ep->is_stall = true;
+	ep->num   = ep_addr & ADDRESS_MASK;
+	ep->is_in = ((ep_addr & EP_DIR_MASK) == EP_DIR_IN);
+
+	ret = dwc3_ep_set_stall(dwc3_handle, dwc3_ep);
+	if (ret != USBD_OK) {
+		return ret;
+	}
+
+	if ((ep_addr & ADDRESS_MASK) == 0U) {
+		dwc3_handle->EP0_State = HAL_PCD_EP0_SETUP_QUEUED;
+		ret = dwc3_ep0_out_start(dwc3_handle, dwc3_handle->setup_dma_addr);
+	}
+
+	return ret;
+}
+
+static uint32_t dwc3_get_ep_trblen(usb_dwc3_endpoint_t *ep)
+{
+	return DWC3_TRB_SIZE_LENGTH(ep->trb_addr->size);
+}
+
+static uint32_t dwc3_get_ep_trbstatus(usb_dwc3_endpoint_t *ep)
+{
+	return DWC3_TRB_SIZE_TRBSTS(ep->trb_addr->size);
+}
+
+static enum usb_status dwc3_ep_stop_xfer(dwc3_handle_t *dwc3_handle, struct usbd_ep *ep)
+{
+	usb_dwc3_endpoint_t *dwc3_ep = ((ep->is_in) ? &dwc3_handle->IN_ep[ep->num] :
+					&dwc3_handle->OUT_ep[ep->num]);
+	enum usb_status ret;
+	dwc3_epcmd_t cmd;
+	dwc3_epcmd_params_t params;
+
+	VERBOSE("%s PHYEP%d %x\n", __func__, dwc3_ep->phy_epnum, dwc3_ep->flags);
+
+	// Reset ISOC flags
+	if (ep->type == EP_TYPE_ISOC) {
+		dwc3_ep->flags &= ~(USB_DWC3_EP_ISOC_START_PENDING | USB_DWC3_EP_ISOC_STARTED);
+	}
+
+	if ((dwc3_ep->flags & USB_DWC3_EP_REQ_QUEUED) == 0U) {
+		return USBD_FAIL;
+	}
+
+	(void)memset(&params, 0x00, sizeof(params));
+	cmd = USB_DWC3_DEPCMD_ENDTRANSFER | USB3_DEPCMD_HIPRI_FORCERM | USB3_DEPCMD_CMDIOC |
+	      DWC3_DEPCMD_PARAM((uint32_t)dwc3_ep->resc_idx);
+
+	ret = dwc3_execute_dep_cmd(dwc3_handle, dwc3_ep->phy_epnum, cmd, &params);
+	/* Need Delay 100us as mentioned in Linux Driver */
+	udelay(100);
+
+	ep->xfer_count = ep->xfer_len - (dwc3_ep->trb_addr->size & DWC3_TRB_SIZE_MASK);
+
+	dwc3_ep->flags &= ~USB_DWC3_EP_REQ_QUEUED;
+
+	return ret;
+}
+
+static enum usb_action dwc3_handle_ep0_xfernotready_event(dwc3_handle_t *dwc3_handle,
+							  uint32_t event, uint32_t *param)
+{
+	enum usb_action action = USB_NOTHING;
+	uint8_t phy_epnum = dwc3_read_ep_evt_epnum(event);
+	struct pcd_handle *pcd_handle = dwc3_handle->pcd_handle;
+	uint8_t status = dwc3_read_ep_evt_status(event);
+	uint8_t ep_addr, ep_num;
+	enum usb_status ret;
+
+	ep_addr = __HAL_PCD_PHYEPNUM_TO_EPADDR(phy_epnum);
+	ep_num = ep_addr & ADDRESS_MASK;
+
+	if (__HAL_PCD_SETUP_REQ_LEN(dwc3_handle->setup_addr) == 0U) {
+		switch (status) {
+		case USB_DWC3_DEPEVT_XFERNOTREADY_STATUS_CTRL_STATUS:
+			api_memcpy(dwc3_handle->pcd_handle->setup,
+				   dwc3_handle->setup_addr,
+				   sizeof(dwc3_handle->pcd_handle->setup));
+			action = USB_SETUP;
+			break;
+		case USB_DWC3_DEPEVT_XFERNOTREADY_STATUS_CTRL_DATA:
+			ret = dwc3_epaddr_set_stall(dwc3_handle, ep_num); // OUT EP0
+			if (ret != USBD_OK) {
+				ERROR("Error : %s: %d\n", __func__, __LINE__);
+			}
+			break;
+		default:
+			VERBOSE("Invalid Status %d: %s: %d\n", status, __func__, __LINE__);
+			break;
+		}
+	} else {
+		switch (status) {
+		case USB_DWC3_DEPEVT_XFERNOTREADY_STATUS_CTRL_STATUS:
+			if ((ep_addr & EP_DIR_MASK) == EP_DIR_IN) {
+				*param = ep_num;
+				action = USB_DATA_OUT;
+			} else {
+				*param = ep_num;
+				action = USB_DATA_IN;
+			}
+			break;
+		case USB_DWC3_DEPEVT_XFERNOTREADY_STATUS_CTRL_DATA:
+			if ((ep_addr & EP_DIR_MASK) == EP_DIR_IN) {
+				/* if wrong direction */
+				if (__HAL_PCD_SETUP_REQ_DATA_DIR_IN(dwc3_handle->setup_addr) ==
+				    0U) {
+					ret = dwc3_ep_stop_xfer(dwc3_handle,
+								&pcd_handle->out_ep[0]);
+					if (ret != USBD_OK) {
+						ERROR("Error : %s: %d\n", __func__, __LINE__);
+					}
+					ret = dwc3_epaddr_set_stall(dwc3_handle, ep_num); // OUT EP0
+					if (ret != USBD_OK) {
+						ERROR("Error : %s: %d\n", __func__, __LINE__);
+					}
+				}
+				/*
+				 * last packet is MPS multiple, so send ZLP packet,
+				 * handled by USBD_core.c
+				 */
+			} else {
+				/* if wrong direction */
+				if (__HAL_PCD_SETUP_REQ_DATA_DIR_IN(dwc3_handle->setup_addr) !=
+				    0U) {
+					ret = dwc3_ep_stop_xfer(dwc3_handle,
+								&pcd_handle->in_ep[0]);
+					if (ret != USBD_OK) {
+						ERROR("Error : %s: %d\n", __func__, __LINE__);
+					}
+					ret = dwc3_epaddr_set_stall(dwc3_handle, ep_num); // OUT EP0
+					if (ret != USBD_OK) {
+						ERROR("Error : %s: %d\n", __func__, __LINE__);
+					}
+				}
+			}
+			break;
+		default:
+			VERBOSE("Invalid Status %d: %s: %d\n", status, __func__, __LINE__);
+			break;
+		}
+	}
+
+	return action;
+}
+
+static enum usb_action dwc3_handle_ep_event(dwc3_handle_t *dwc3_handle, uint32_t event,
+					    uint32_t *param)
+{
+	enum usb_action action = USB_NOTHING;
+	uint8_t type = dwc3_read_ep_evt_type(event);
+	uint8_t phy_epnum = dwc3_read_ep_evt_epnum(event);
+	uint8_t ep_addr, ep_num;
+	struct usbd_ep *ep;
+	usb_dwc3_endpoint_t *dwc3_ep;
+	enum usb_status ret;
+
+	ep_addr = __HAL_PCD_PHYEPNUM_TO_EPADDR(phy_epnum);
+	ep_num = ep_addr & ADDRESS_MASK;
+
+	if ((ep_addr & EP_DIR_MASK) == EP_DIR_IN) {
+		ep = &dwc3_handle->pcd_handle->in_ep[ep_num];
+		dwc3_ep = &dwc3_handle->IN_ep[ep_num];
+	} else {
+		ep = &dwc3_handle->pcd_handle->out_ep[ep_num];
+		dwc3_ep = &dwc3_handle->OUT_ep[ep_num];
+	}
+
+	switch (type) {
+	case USB_DWC3_DEPEVT_XFERCOMPLETE:
+		VERBOSE("EP%d%s: Transfer Complete Event=%x\n", ep_num,
+			   ep->is_in ? "IN" : "OUT", event);
+
+		if (ep->type == EP_TYPE_ISOC) {
+			VERBOSE("EP%d%s is an Isochronous endpoint\n", ep_num,
+				   ep->is_in ? "IN" : "OUT");
+			break;
+		}
+
+		/* Just forr Log, since ctrl expects sw to follow the whole control
+		 * programming sequence, as also mentioned in Linux driver
+		 */
+		if ((ep_num == 0U) &&
+		    (dwc3_get_ep_trbstatus(dwc3_ep) == USB_DWC3_TRBSTS_SETUP_PENDING)) {
+			VERBOSE("EP%d%s Setup Pending received\n", ep_num,
+				   ep->is_in ? "IN" : "OUT");
+		}
+
+		VERBOSE("EP%d%s: Transfer Complete trb %p:%08x:%08x:%08x:%08x TRB-Status %d\n",
+			   ep_num, ep->is_in ? "IN" : "OUT", dwc3_ep->trb_addr,
+			   (uint32_t)dwc3_ep->trb_addr->bph, (uint32_t)dwc3_ep->trb_addr->bpl,
+			   (uint32_t)dwc3_ep->trb_addr->size, (uint32_t)dwc3_ep->trb_addr->ctrl,
+			   dwc3_get_ep_trbstatus(dwc3_ep));
+
+		if ((ep_addr & EP_DIR_MASK) == EP_DIR_IN) {  /* IN EP */
+			ep->xfer_count = ep->xfer_len - dwc3_get_ep_trblen(dwc3_ep);
+
+			dwc3_ep->flags &= ~USB_DWC3_EP_REQ_QUEUED;
+
+			if (ep->xfer_buff != NULL) {
+				api_unmapdmaaddr(dwc3_ep->dma_addr, ep->xfer_len, 1);
+			}
+
+			/*
+			 * For EP0IN, if packet is not sent completely,
+			 * then error, as done in Linux driver
+			 */
+			if ((ep_num == 0U) && (ep->xfer_len != ep->xfer_count)) {
+				ret = dwc3_epaddr_set_stall(dwc3_handle, ep_num); // OUT EP0
+				if (ret != USBD_OK) {
+					ERROR("Error : %s: %d\n", __func__, __LINE__);
+				}
+			}
+
+			/*
+			 * if 3-stage then wait for XFERNOTREADY(control-status) before
+			 * sending data to upper layer
+			 */
+			if ((ep_num != 0U) || (ep->xfer_len == 0U)) {
+				*param = ep_num;
+				action = USB_DATA_IN;
+			}
+
+			/* For EP0, this is ZLP, so prepare EP0 for next setup */
+			if ((ep_num == 0U) && (ep->xfer_len == 0U)) {
+				/* prepare to rx more setup packets */
+				dwc3_handle->EP0_State = HAL_PCD_EP0_SETUP_QUEUED;
+
+				ret = dwc3_ep0_out_start(dwc3_handle, dwc3_handle->setup_dma_addr);
+				if (ret != USBD_OK) {
+					ERROR("Error : %s: %d\n", __func__, __LINE__);
+					return action;
+				}
+			}
+		} else {
+			ep->xfer_count = ep->xfer_len - dwc3_get_ep_trblen(dwc3_ep);
+
+			dwc3_ep->flags &= ~USB_DWC3_EP_REQ_QUEUED;
+
+			/* For EP0OUT */
+			if ((ep_addr == 0U) &&
+			    (dwc3_handle->EP0_State == HAL_PCD_EP0_SETUP_QUEUED)) {
+
+				dwc3_handle->EP0_State = HAL_PCD_EP0_SETUP_COMPLETED;
+				dwc3_ep->is_stall = false;
+				VERBOSE("EP%d%s: SetupData %02x%02x%02x%02x:%02x%02x%02x%02x\n",
+					   ep_num, ep->is_in ? "IN" : "OUT",
+					   dwc3_handle->setup_addr[0], dwc3_handle->setup_addr[1],
+					   dwc3_handle->setup_addr[2], dwc3_handle->setup_addr[3],
+					   dwc3_handle->setup_addr[4], dwc3_handle->setup_addr[5],
+					   dwc3_handle->setup_addr[6], dwc3_handle->setup_addr[7]);
+
+				// if 2-stage then wait for the XFERNOTREADY(control-status)
+				if (__HAL_PCD_SETUP_REQ_LEN(dwc3_handle->setup_addr) != 0U) {
+					api_memcpy(dwc3_handle->pcd_handle->setup,
+						   dwc3_handle->setup_addr,
+						   sizeof(dwc3_handle->pcd_handle->setup));
+					action = USB_SETUP;
+				}
+			} else {
+
+				if (ep->xfer_buff != NULL) {
+					api_unmapdmaaddr(dwc3_ep->dma_addr, ep->xfer_len, 0);
+				}
+
+				if (ep->xfer_buff == dwc3_ep->bounce_buf) {
+					api_memcpy(dwc3_ep->xfer_dest_buff, ep->xfer_buff,
+						   ep->xfer_count);
+					ep->xfer_buff = dwc3_ep->xfer_dest_buff;
+				}
+
+				/*
+				 * if 3-stage then wait for XFERNOTREADY(control-status) before
+				 * sending data to upper layer
+				 */
+				if ((ep_num != 0U) || (ep->xfer_len == 0U)) {
+					*param = ep_num;
+					action = USB_DATA_OUT;
+				}
+
+				/* For EP0, this is ZLP, so prepare EP0 for next setup */
+				if ((ep_num == 0U) && (ep->xfer_len == 0U)) {
+					/* prepare to rx more setup packets */
+					dwc3_handle->EP0_State = HAL_PCD_EP0_SETUP_QUEUED;
+
+					ret = dwc3_ep0_out_start(dwc3_handle,
+								 dwc3_handle->setup_dma_addr);
+					if (ret != USBD_OK) {
+						ERROR("Error : %s: %d\n", __func__, __LINE__);
+						return action;
+					}
+				}
+			}
+		}
+
+		break;
+
+	case USB_DWC3_DEPEVT_XFERINPROGRESS:
+		VERBOSE("EP%d%s: Transfer In-Progress %d Event=%x\n", ep_num,
+			   ep->is_in ? "IN" : "OUT", dwc3_handle->intbuffers.evtbufferpos[0],
+			   event);
+
+		if (ep_num == 0U) { // ***ToCheck
+			break;
+		}
+
+		/*
+		 * currently not planned to issue multiple TRB transfer, hence there shouldn't
+		 * be any event like this
+		 */
+
+		/*
+		 * But for isoc transfers we need get it since transfer started with
+		 * loop(link) trb
+		 */
+		if (ep->type != EP_TYPE_ISOC) {
+			break;
+		}
+
+		break;
+
+	case USB_DWC3_DEPEVT_XFERNOTREADY:
+		VERBOSE("EP%d%s: Transfer Not Ready Event=%x\n", ep_num,
+			   ep->is_in ? "IN" : "OUT", event);
+		/* For EP0IN or EP0OUT, currently no plan to use xfernotready interrupt */
+
+		//active = PCD_READ_DEPEVT_STATUS(event);
+
+		if (ep_num == 0U) {
+
+			if (dwc3_handle->EP0_State == HAL_PCD_EP0_SETUP_QUEUED) {
+				ret = dwc3_epaddr_set_stall(dwc3_handle, ep_num);  // OUT EP0
+				if (ret != USBD_OK) {
+					ERROR("Error : %s: %d\n", __func__, __LINE__);
+					return action;
+				}
+			} else {
+				action = dwc3_handle_ep0_xfernotready_event(dwc3_handle, event,
+									    param);
+			}
+		}
+
+		/*
+		 * Currently we dont implement provide request queue to support On-demand transfers
+		 * for non-isoc EP, it only supports preset transfers so this event will not be
+		 * used, Section 9.2.4 "Transfer Setup Recommendations"
+		 */
+
+		/*
+		 * But for isoc transfers we need to issue the request from here using the
+		 * micro-frame number
+		 */
+		if (ep->type != EP_TYPE_ISOC) {
+			break;
+		}
+
+		break;
+
+	case USB_DWC3_DEPEVT_STREAMEVT: /* Stream event, Not used */
+		break;
+	case USB_DWC3_DEPEVT_RXTXFIFOEVT: /* FIFO Overrun */
+		break;
+	case USB_DWC3_DEPEVT_EPCMDCMPLT: /* Endpoint Command Complete */
+		VERBOSE("EP%d%s: Endpoint Command Complete Event=%x\n", ep_num,
+			   ep->is_in ? "IN" : "OUT", event);
+		break;
+	default:
+		VERBOSE("Invalid type %d: %s: %d\n", type, __func__, __LINE__);
+		break;
+	}
+
+	return action;
+}
+
+static uint8_t dwc3_read_dev_evt_type(uint32_t event)
+{
+	uint8_t ret;
+
+	switch ((event & DWC3_EVT_DEVEVT_TYPE_MASK) >> DWC3_EVT_DEVEVT_TYPE_BITPOS) {
+	case DWC3_DEVICE_EVENT_DISCONNECT:
+		ret = USB_DWC3_DEVICE_EVENT_DISCONNECT;
+		break;
+	case DWC3_DEVICE_EVENT_RESET:
+		ret = USB_DWC3_DEVICE_EVENT_RESET;
+		break;
+	case DWC3_DEVICE_EVENT_CONNECT_DONE:
+		ret = USB_DWC3_DEVICE_EVENT_CONNECT_DONE;
+		break;
+	case DWC3_DEVICE_EVENT_LINK_STATUS_CHANGE:
+		ret = USB_DWC3_DEVICE_EVENT_LINK_STATUS_CHANGE;
+		break;
+	case DWC3_DEVICE_EVENT_WAKEUP:
+		ret = USB_DWC3_DEVICE_EVENT_WAKEUP;
+		break;
+	case DWC3_DEVICE_EVENT_HIBER_REQ:
+		ret = USB_DWC3_DEVICE_EVENT_HIBER_REQ;
+		break;
+	case DWC3_DEVICE_EVENT_EOPF:
+		ret = USB_DWC3_DEVICE_EVENT_EOPF;
+		break;
+	case DWC3_DEVICE_EVENT_SOF:
+		ret = USB_DWC3_DEVICE_EVENT_SOF;
+		break;
+	case DWC3_DEVICE_EVENT_ERRATIC_ERROR:
+		ret = USB_DWC3_DEVICE_EVENT_ERRATIC_ERROR;
+		break;
+	case DWC3_DEVICE_EVENT_CMD_CMPL:
+		ret = USB_DWC3_DEVICE_EVENT_CMD_CMPL;
+		break;
+	case DWC3_DEVICE_EVENT_OVERFLOW:
+		ret = USB_DWC3_DEVICE_EVENT_OVERFLOW;
+		break;
+	default:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static enum usb_status dwc3_ep_clear_stall(dwc3_handle_t *dwc3_handle, usb_dwc3_endpoint_t *dwc3_ep)
+{
+	dwc3_epcmd_params_t params;
+
+	(void)memset(&params, 0x00, sizeof(params));
+
+	return dwc3_execute_dep_cmd(dwc3_handle, dwc3_ep->phy_epnum, USB_DWC3_DEPCMD_CLEARSTALL,
+				    &params);
+}
+
+static uint8_t dwc3_get_dev_speed(dwc3_handle_t *dwc3_handle)
+{
+	uint32_t reg;
+	uint8_t ret;
+
+	reg = DWC3_regread(dwc3_handle->usb_device, DWC3_DSTS) & USB3_DSTS_CONNECTSPD;
+
+	switch (reg) {
+	case DWC3_DSTS_SUPERSPEED:
+		ret = USB_DWC3_SPEED_SUPER;
+		NOTICE("%s = SuperSpeed\n", __func__);
+		break;
+	case DWC3_DSTS_HIGHSPEED:
+		ret = USB_DWC3_SPEED_HIGH;
+		NOTICE("%s = HighSpeed\n", __func__);
+		break;
+	case DWC3_DSTS_FULLSPEED1:
+		ret = USB_DWC3_SPEED_FULL_48;
+		NOTICE("%s = FullSpeed_48M\n", __func__);
+		break;
+	case DWC3_DSTS_FULLSPEED2:
+		ret = USB_DWC3_SPEED_FULL;
+		NOTICE("%s = FullSpeed\n", __func__);
+		break;
+	case DWC3_DSTS_LOWSPEED:
+		ret = USB_DWC3_SPEED_LOW;
+		NOTICE("%s = LowSpeed\n", __func__);
+		break;
+	default: /* Invalid */
+		ret = USB_DWC3_SPEED_INVALID;
+		NOTICE("%s = Invalid\n", __func__);
+		break;
+	}
+
+	return ret;
+}
+
+static uint32_t dwc3_get_epcfg_action(uint8_t action)
+{
+	uint32_t ret;
+
+	switch (action) {
+	case USB_DWC3_DEPCFG_ACTION_INIT:
+		ret = DWC3_DEPCFG_ACTION_INIT;
+		break;
+	case USB_DWC3_DEPCFG_ACTION_RESTORE:
+		ret = DWC3_DEPCFG_ACTION_RESTORE;
+		break;
+	case USB_DWC3_DEPCFG_ACTION_MODIFY:
+		ret = DWC3_DEPCFG_ACTION_MODIFY;
+		break;
+	default:
+		ret = 0U;
+		break;
+	}
+
+	return ret;
+}
+
+static enum usb_status dwc3_ep_configure(dwc3_handle_t *dwc3_handle, uint8_t epnum, bool is_in,
+					 uint8_t type, uint32_t max_packet, uint8_t tx_fifo,
+					 uint16_t binterval, uint8_t phy_epnum, uint8_t intr_num,
+					 uint8_t action)
+{
+	dwc3_epcmd_params_t params;
+
+	(void)memset(&params, 0x00, sizeof(params));
+	params.param0 = DWC3_DEPCFG_EP_TYPE(type) | DWC3_DEPCFG_MAX_PACKET_SIZE(max_packet);
+
+	/* Burst size is only needed in SuperSpeed mode */
+	//params.param0 |= DWC3_DEPCFG_BURST_SIZE(0);
+
+	params.param0 |= dwc3_get_epcfg_action(action);
+
+	params.param1 = DWC3_DEPCFG_XFER_COMPLETE_EN | DWC3_DEPCFG_XFER_NOT_READY_EN;
+	if (type == EP_TYPE_ISOC) {
+		params.param1 |= DWC3_DEPCFG_XFER_IN_PROGRESS_EN;
+	}
+
+	params.param1 |= DWC3_DEPCFG_EP_NUMBER(((uint32_t)epnum << 1) + (is_in ? 1UL : 0UL));
+
+	params.param1 |= DWC3_DEPCFG_EP_INTR_NUM(intr_num);
+
+	if (is_in) {
+		params.param0 |= DWC3_DEPCFG_FIFO_NUMBER(tx_fifo);
+	}
+
+	if (binterval != 0U) {
+		params.param1 |= DWC3_DEPCFG_BINTERVAL_M1(binterval - 1UL);
+	}
+
+	return dwc3_execute_dep_cmd(dwc3_handle, phy_epnum, USB_DWC3_DEPCMD_SETEPCONFIG, &params);
+}
+
+static inline uint8_t dwc3_read_dev_evt_linkstate(uint32_t event)
+{
+	return (uint8_t)((event & DWC3_EVT_DEVEVT_LNKSTS_MASK) >> DWC3_EVT_DEVEVT_LNKSTS_BITPOS);
+}
+
+static inline const char *dwc3_get_linkstate_str(uint8_t state)
+{
+	const char *ret;
+
+	switch (state) {
+	case DWC3_LINK_STATE_ON:
+		ret = "ON";
+		break;
+	case DWC3_LINK_STATE_L1:
+		ret = "L1";
+		break;
+	case DWC3_LINK_STATE_L2:
+		ret = "L2";
+		break;
+	case DWC3_LINK_STATE_DIS:
+		ret = "Disconnect";
+		break;
+	case DWC3_LINK_STATE_EARLY_SUS:
+		ret = "Early Suspend";
+		break;
+	case DWC3_LINK_STATE_RESET:
+		ret = "Reset";
+		break;
+	case DWC3_LINK_STATE_RESUME:
+		ret = "Resume";
+		break;
+	default:
+		ret = "UNKNOWN state";
+		break;
+	}
+
+	return ret;
+}
+
+static enum usb_action dwc3_handle_dev_event(dwc3_handle_t *dwc3_handle, uint32_t event,
+					     uint32_t *param)
+{
+	enum usb_action action = USB_NOTHING;
+	uint8_t type = dwc3_read_dev_evt_type(event);
+	uint8_t i, speed;
+	usb_dwc3_endpoint_t *ep;
+	enum usb_status ret;
+	uint32_t ep0_mps = USB3_MAX_PACKET_SIZE;
+
+	switch (type) {
+	case USB_DWC3_DEVICE_EVENT_DISCONNECT:
+		INFO("Event: Device Disconnect\n");
+		/* For SuperSpeed, set DCTL[8:5] to 5*/
+
+		action = USB_DISCONNECT;
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_RESET:
+		INFO("Event: Device Reset\n");
+		/*
+		 * Spec says, Wait till EP0 finishes current transfer and reaches Setup-Stage.
+		 * But there is no wait in Linux driver which means that Host will take care while
+		 * issuing a reset. Also its tricky to implement since we can't wait here
+		 * (in interrupt context) for further control EP interrupts
+		 */
+
+		if (dwc3_handle->EP0_State != HAL_PCD_EP0_SETUP_QUEUED) {
+			ret = dwc3_ep_stop_xfer(dwc3_handle, &dwc3_handle->pcd_handle->out_ep[0]);
+			if (ret != USBD_OK) {
+				ERROR("Error : %s: %d\n", __func__, __LINE__);
+			}
+			ret = dwc3_ep_set_stall(dwc3_handle, &dwc3_handle->OUT_ep[0]); // OUT EP0
+			if (ret != USBD_OK) {
+				ERROR("Error : %s: %d\n", __func__, __LINE__);
+			}
+		}
+
+		/*
+		 * Stop transfers for all(USB_DWC3_NUM_IN_EPS) EP
+		 * except EP0IN k = USB_DWC3_NUM_IN_EP
+		 */
+		for (i = 0; i < USB_DWC3_NUM_IN_EP; i++) {
+			dwc3_ep_stop_xfer(dwc3_handle,
+					      &dwc3_handle->pcd_handle->in_ep[i]);
+		}
+
+		/* Stop transfers for all EP except EP0OUT k = USB_DWC3_NUM_OUT_EP */
+		for (i = 1; i < USB_DWC3_NUM_OUT_EP; i++) {
+			dwc3_ep_stop_xfer(dwc3_handle,
+					      &dwc3_handle->pcd_handle->out_ep[i]);
+		}
+
+		/* Clear Stall for all EP except EP0IN k = USB_DWC3_NUM_IN_EP */
+		for (i = 1; i < USB_DWC3_NUM_IN_EP; i++) {
+			ep = &dwc3_handle->IN_ep[i];
+
+			if (!ep->is_stall) {
+				continue;
+			}
+
+			ep->is_stall = false;
+
+			ret = dwc3_ep_clear_stall(dwc3_handle, ep);
+			if (ret != USBD_OK) {
+				ERROR("Error : %s: %d\n", __func__, __LINE__);
+				return action;
+			}
+		}
+
+		/* Clear Stall for all EP except EP0OUT k = USB_DWC3_NUM_OUT_EP */
+		for (i = 1; i < USB_DWC3_NUM_OUT_EP; i++) {
+			ep = &dwc3_handle->OUT_ep[i];
+
+			if (!ep->is_stall) {
+				continue;
+			}
+
+			ep->is_stall = false;
+			//ep->num   = ep_addr & ADDRESS_MASK;
+			//ep->is_in = ((ep_addr & 0x80) == 0x80);
+
+			ret = dwc3_ep_clear_stall(dwc3_handle, ep);
+			if (ret != USBD_OK) {
+				ERROR("Error : %s: %d\n", __func__, __LINE__);
+				return action;
+			}
+		}
+
+		/* Reset device address to zero */
+		ret = usb_dwc3_set_address(dwc3_handle, 0);
+		if (ret != USBD_OK) {
+			ERROR("Error : %s: %d\n", __func__, __LINE__);
+			return action;
+		}
+
+		action = USB_RESET;
+
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_CONNECT_DONE:
+		INFO("Event: Device Connection Done\n");
+
+		/*
+		 * hpcd->Init.ep0_mps = MaxPacketSize to 512 (SuperSpeed), 64 (High-Speed),
+		 * 8/16/32/64 (Full-Speed), or 8 (Low-Speed).
+		 */
+		speed = dwc3_get_dev_speed(dwc3_handle);
+		switch (speed) {
+		case USB_DWC3_SPEED_SUPER:
+			ep0_mps = 512;
+			break;
+		case USB_DWC3_SPEED_HIGH:
+			ep0_mps = 64;
+			break;
+		case USB_DWC3_SPEED_FULL_48:
+		case USB_DWC3_SPEED_FULL:
+			ep0_mps = 64;
+			break;
+		case USB_DWC3_SPEED_LOW:
+			ep0_mps = 8;
+			break;
+		default:
+			ERROR("Error : %s: %d\n", __func__, __LINE__);
+			break;
+		}
+
+		/* Update DWC3_GCTL_RAMCLKSEL, but only for Superspeed */
+
+		/* Modify max packet size for EP 0 & 1 */
+		ret = dwc3_ep_configure(dwc3_handle, 0, false, EP_TYPE_CTRL, ep0_mps, 0, 0, 0,
+					dwc3_handle->OUT_ep[0].intr_num,
+					USB_DWC3_DEPCFG_ACTION_MODIFY);
+		if (ret != USBD_OK) {
+			ERROR("Error : %s: %d\n", __func__, __LINE__);
+			return action;
+		}
+		ret = dwc3_ep_configure(dwc3_handle, 0, true, EP_TYPE_CTRL, ep0_mps, 0, 0, 1,
+					dwc3_handle->IN_ep[0].intr_num,
+					USB_DWC3_DEPCFG_ACTION_MODIFY);
+		if (ret != USBD_OK) {
+			ERROR("Error : %s: %d\n", __func__, __LINE__);
+			return action;
+		}
+
+		dwc3_handle->pcd_handle->out_ep[0].maxpacket = ep0_mps;
+		dwc3_handle->pcd_handle->in_ep[0].maxpacket = ep0_mps;
+
+		/*
+		 * Depending on the connected speed, write to the other
+		 * PHY's control register to suspend it.
+		 */
+
+		/* Use default values for GTXFIFOSIZn and GRXFIFOSIZ0 */
+
+		action = USB_ENUM_DONE;
+
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_LINK_STATUS_CHANGE:
+		INFO("Event: Link Status Change : %s(%d)\n",
+			   dwc3_get_linkstate_str(dwc3_read_dev_evt_linkstate(event)),
+			   dwc3_read_dev_evt_linkstate(event));
+		/* Handle link state changes, U0,U1,U2,U3 with suspend/resume functions */
+
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_WAKEUP:
+		INFO("Event: Wake-UP\n");
+		// resume function
+		action = USB_RESUME;
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_HIBER_REQ:
+		INFO("Event: Hibernation Request\n");
+		/* hibernation function */
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_EOPF: /* End of Periodic Frame */
+		INFO("Event: Suspend\n");
+		action = USB_SUSPEND;
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_SOF: /* Start of Periodic Frame */
+		INFO("Event: Start of Periodic Frame\n");
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_L1SUSPEND:
+		INFO("Event: L1 Suspend\n");
+		action = USB_LPM;
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_ERRATIC_ERROR: /* Erratic Error */
+		INFO("Event: Erratic Error\n");
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_CMD_CMPL: /* Command Complete */
+		INFO("Event: Command Complete\n");
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_OVERFLOW: /* Overflow */
+		INFO("Event: Overflow\n");
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_L1WAKEUP:
+		INFO("Event: L1 Wake-UP\n");
+		// resume function
+		action = USB_RESUME;
+		break;
+
+	default:  /* UNKNOWN IRQ type */
+		break;
+	}
+
+	return action;
+}
+
+static inline void dwc3_ack_evt_count(dwc3_handle_t *dwc3_handle, uint8_t intr_num,
+				      uint32_t evt_count)
+{
+	DWC3_regwrite(dwc3_handle->usb_global, DWC3_GEVNTCOUNT(intr_num), evt_count);
+}
+
+static inline uint32_t dwc3_read_intr_count(dwc3_handle_t *dwc3_handle, uint8_t intr_num)
+{
+	return DWC3_regread(dwc3_handle->usb_global, DWC3_GEVNTCOUNT(intr_num)) &
+	       DWC3_GEVNTCOUNT_MASK;
+}
+
+static inline bool dwc3_is_ep_event(uint32_t event)
+{
+	return ((event & DWC3_EVT_TYPE_MASK) == (DWC3_EVT_TYPE_EP << DWC3_EVT_TYPE_BITPOS));
+}
+
+static inline bool dwc3_is_dev_event(uint32_t event)
+{
+	return ((event & DWC3_EVT_TYPE_MASK) == (DWC3_EVT_TYPE_DEVSPEC << DWC3_EVT_TYPE_BITPOS));
+}
+
+static enum usb_action usb_dwc3_it_handler(void *handle, uint32_t *param)
+{
+	dwc3_handle_t *dwc3_handle = (dwc3_handle_t *)handle;
+	enum usb_action action = USB_NOTHING;
+	uint32_t evtcnt, evt;
+	uint8_t i;
+
+	/* Use same handler for all the Evt-Buf IRQs */
+
+	/* Check for all Event Buffer interrupt k = USB_DWC3_INT_INUSE */
+	for (i = 0; i < USB_DWC3_INT_INUSE; i++) {
+		evtcnt = dwc3_read_intr_count(dwc3_handle, i);
+
+		if (!evtcnt)
+			break;
+
+		VERBOSE("Interrupt Count %d\n", evtcnt);
+
+		evt = __HAL_PCD_READ_EVENT(dwc3_handle, i);
+		VERBOSE("Event %08x\n", evt);
+
+		if (dwc3_is_ep_event(evt)) {   /* EP event */
+			action = dwc3_handle_ep_event(dwc3_handle, evt, param);
+		} else {     /* NON-EP event */
+			if (dwc3_is_dev_event(evt)) {  /* Device specific event */
+				action = dwc3_handle_dev_event(dwc3_handle, evt, param);
+			} else {
+			  /* Error, non supported events */
+			}
+		}
+
+		__HAL_PCD_INCR_EVENT_POS(dwc3_handle, i, USB_DWC3_EVENT_SIZE);
+
+		dwc3_ack_evt_count(dwc3_handle, i, USB_DWC3_EVENT_SIZE);
+	}
+
+	return action;
+}
+
+static enum usb_status usb_dwc3_write_packet(void *handle __unused, uint8_t *src __unused,
+					     uint8_t ch_ep_num __unused, uint16_t len __unused)
+{
+	return USBD_OK;
+}
+
+static void *usb_dwc3_read_packet(void *handle __unused, uint8_t *dest __unused,
+				  uint16_t len __unused)
+{
+	return NULL;
+}
+
+static enum usb_status usb_dwc3_write_empty_tx_fifo(void *handle __unused, uint32_t epnum,
+						    uint32_t xfer_len __unused,
+						    uint32_t *xfer_count __unused,
+						    uint32_t maxpacket __unused,
+						    uint8_t **xfer_buff __unused)
+{
+	return USBD_OK;
+}
+
+static const struct usb_driver usb_dwc3driver = {
+	.ep0_out_start = usb_dwc3_ep0_out_start,
+	.ep_start_xfer = usb_dwc3_ep_start_xfer,
+	.ep0_start_xfer = usb_dwc3_ep0_start_xfer,
+	.write_packet = usb_dwc3_write_packet,
+	.read_packet = usb_dwc3_read_packet,
+	.ep_set_stall = usb_dwc3_ep_set_stall,
+	.start_device = usb_dwc3_start_device,
+	.stop_device = usb_dwc3_stop_device,
+	.set_address = usb_dwc3_set_address,
+	.write_empty_tx_fifo = usb_dwc3_write_empty_tx_fifo,
+	.it_handler = usb_dwc3_it_handler
+};
+
+/* USB2 PHY Mask 0xf */
+#define USBPHY_ULPI	1U
+#define USBPHY_UTMI	2U
+#define USBPHY_EMBEDDED_USB2	8U
+#define USB2PHY_MASK	15U
+/* USB3 PHY Mask (0xf << 4) */
+#define USBPHY_PIPE3	16U
+#define USBPHY_EMBEDDED_USB3	128U
+#define USB3PHY_MASK	(15U << 4)
+
+static enum usb_status dwc3_soft_reset(dwc3_handle_t *dwc3_handle)
+{
+	uint64_t timeout;
+
+	DWC3_regwrite(dwc3_handle->usb_device, DWC3_DCTL, USB3_DCTL_CSFTRST);
+
+	timeout = timeout_init_us(500*1000); /* msec */
+
+	while (DWC3_regread(dwc3_handle->usb_device, DWC3_DCTL) & USB3_DCTL_CSFTRST) {
+
+		if (timeout_elapsed(timeout)) { /* "Reset Timed Out" */
+			return USBD_TIMEOUT;
+		}
+	}
+
+	return USBD_OK;
+}
+
+static enum usb_status dwc3_core_init(dwc3_handle_t *dwc3_handle, uint32_t phy_itface)
+{
+	enum usb_status ret;
+
+	NOTICE("Core ID %08x\n", (uint32_t)DWC3_regread(dwc3_handle->usb_global, DWC3_GSNPSID));
+
+	/* Set GUSB3PIPECTL for all USB3 ports (1-n), currently doing only for 0 */
+	if ((phy_itface & USB3PHY_MASK) != 0U) {
+		/* Relying on default value */
+	}
+
+	/* Set GUSB2PHYCFG for all USB2 ports (1-m), currently doing only for 0 */
+	if ((phy_itface & USB2PHY_MASK) != 0U) {
+		switch (phy_itface) {
+		case USBPHY_UTMI:
+			DWC3_regupdateclr(dwc3_handle->usb_global, DWC3_GUSB2PHYCFG(0UL),
+					  USB3_GUSB2PHYCFG_ULPI_UTMI_SEL);
+			break;
+		case USBPHY_ULPI:
+			DWC3_regupdateset(dwc3_handle->usb_global, DWC3_GUSB2PHYCFG(0UL),
+					  USB3_GUSB2PHYCFG_ULPI_UTMI_SEL);
+			break;
+		default:
+			/* Relying on default value. */
+			break;
+		}
+	}
+
+	/* issue device SoftReset */
+	ret = dwc3_soft_reset(dwc3_handle);
+	if (ret != USBD_OK) {
+		ERROR("Error : %s: %d\n", __func__, __LINE__);
+		return ret;
+	}
+
+	/* Put PHYs in reset */
+	/* Before Resetting PHY, put Core in Reset */
+	DWC3_regupdateset(dwc3_handle->usb_global, DWC3_GCTL, USB3_GCTL_CORESOFTRESET);
+
+	/* Assert USB3 PHY reset for all USB3 ports (1-n), currently doing only for 0 */
+	if ((phy_itface & USB3PHY_MASK) != 0U) {
+		DWC3_regupdateset(dwc3_handle->usb_global, DWC3_GUSB3PIPECTL(0UL),
+				  USB3_GUSB3PIPECTL_PHYSOFTRST);
+	}
+
+	/* Assert USB2 PHY reset for all USB2 ports (1-m), currently doing only for 0 */
+	if ((phy_itface & USB2PHY_MASK) != 0U) {
+		DWC3_regupdateset(dwc3_handle->usb_global, DWC3_GUSB2PHYCFG(0UL),
+				  USB3_GUSB2PHYCFG_PHYSOFTRST);
+	}
+
+	// Program PHY signals - PHY specific
+
+
+	// Phy Init not needed since will be done by bootrom
+
+	/* Release PHY out of reset */
+
+	/* Clear USB3 PHY reset for all USB3 ports (1-n), currently doing only for 0 */
+	if ((phy_itface & USB3PHY_MASK) != 0U) {
+		DWC3_regupdateclr(dwc3_handle->usb_global, DWC3_GUSB3PIPECTL(0UL),
+				  USB3_GUSB3PIPECTL_PHYSOFTRST);
+	}
+
+	/* Clear USB2 PHY reset */
+	if ((phy_itface & USB2PHY_MASK) != 0U) {
+		DWC3_regupdateclr(dwc3_handle->usb_global, DWC3_GUSB2PHYCFG(0UL),
+				  USB3_GUSB2PHYCFG_PHYSOFTRST);
+	}
+
+	// delay needed for phy reset
+	mdelay(100); // 100ms
+
+	/* After PHYs are stable we can take Core out of reset state */
+	DWC3_regupdateclr(dwc3_handle->usb_global, DWC3_GCTL, USB3_GCTL_CORESOFTRESET);
+
+	/* Disable Scale down mode - check if disabled by default */
+	//DWC3_regupdateclr(USBx, DWC3_GCTL, DWC3_GCTL_SCALEDOWN_MASK); ***ToCheck
+
+	/* Alloc and Setup Scratch buffers for hibernation */
+	// ***ToCheck
+
+	// From Linux Driver
+	DWC3_regwrite(dwc3_handle->usb_global, DWC3_GSBUSCFG0, 0xe);
+	DWC3_regwrite(dwc3_handle->usb_global, DWC3_GSBUSCFG1, 0xf00);
+
+	/* Use default values for GTXFIFOSIZn and GRXFIFOSIZ0 */
+
+	return USBD_OK;
+}
+
+typedef enum {
+	USB_DWC3_DEVICE_MODE  = 0U,
+	USB_DWC3_HOST_MODE    = 1U,
+	USB_DWC3_DRD_MODE     = 2U,
+	USB_DWC3_INVALID_MODE = 0xFU
+} USB_DWC3_modetypedef;
+
+static enum usb_status dwc3_set_current_mode(dwc3_handle_t *dwc3_handle, USB_DWC3_modetypedef mode)
+{
+	uint32_t reg;
+	enum usb_status ret = USBD_OK;
+
+	reg = DWC3_regread(dwc3_handle->usb_global, DWC3_GCTL) & ~USB3_GCTL_PRTCAPDIR_MSK;
+
+	switch (mode) {
+	case USB_DWC3_DEVICE_MODE:
+		DWC3_regwrite(dwc3_handle->usb_global, DWC3_GCTL, reg |
+			      DWC3_GCTL_PRTCAPDIR(DWC3_GCTL_PRTCAP_DEVICE));
+		break;
+	case USB_DWC3_HOST_MODE:
+		DWC3_regwrite(dwc3_handle->usb_global, DWC3_GCTL, reg |
+			      DWC3_GCTL_PRTCAPDIR(DWC3_GCTL_PRTCAP_HOST));
+		break;
+	case USB_DWC3_DRD_MODE:
+		DWC3_regwrite(dwc3_handle->usb_global, DWC3_GCTL, reg |
+			      DWC3_GCTL_PRTCAPDIR(DWC3_GCTL_PRTCAP_OTG));
+		break;
+	default:
+		ret = USBD_FAIL;
+		break;
+	}
+
+	return ret;
+}
+
+static enum usb_status dwc3_set_dev_speed(dwc3_handle_t *dwc3_handle, uint8_t speed)
+{
+	uint32_t reg;
+	enum usb_status ret = USBD_OK;
+
+	reg = DWC3_regread(dwc3_handle->usb_device, DWC3_DCFG) & ~USB3_DCFG_DEVSPD_MSK;
+
+	switch (speed) {
+	case USB_DWC3_SPEED_SUPER:
+		DWC3_regwrite(dwc3_handle->usb_device, DWC3_DCFG, reg | DWC3_DSTS_SUPERSPEED);
+		INFO("%s = SuperSpeed\n", __func__);
+		break;
+	case USB_DWC3_SPEED_HIGH:
+		DWC3_regwrite(dwc3_handle->usb_device, DWC3_DCFG, reg |  DWC3_DSTS_HIGHSPEED);
+		INFO("%s = HighSpeed\n", __func__);
+		break;
+	case USB_DWC3_SPEED_FULL_48:
+		DWC3_regwrite(dwc3_handle->usb_device, DWC3_DCFG, reg |  DWC3_DSTS_FULLSPEED1);
+		INFO("%s = FullSpeed_48M\n", __func__);
+		break;
+	case USB_DWC3_SPEED_FULL:
+		DWC3_regwrite(dwc3_handle->usb_device, DWC3_DCFG, reg |  DWC3_DSTS_FULLSPEED2);
+		INFO("%s = FullSpeed\n", __func__);
+		break;
+	case USB_DWC3_SPEED_LOW:
+		DWC3_regwrite(dwc3_handle->usb_device, DWC3_DCFG, reg |  DWC3_DSTS_LOWSPEED);
+		INFO("%s = LowSpeed\n", __func__);
+		break;
+	default:
+		ret = USBD_FAIL;
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * @brief  USB_DevInit : Initializes the USB3 controller registers
+ *         for device mode
+ * @param  USBx  Selected device
+ * @param  cfg   pointer to a USB_DWC3_CfgTypeDef structure that contains
+ *         the configuration information for the specified USBx peripheral.
+ * @retval HAL status
+ */
+enum usb_status dwc3_dev_init(dwc3_handle_t *dwc3_handle, uint8_t speed, uint8_t intr_dev)
+{
+	uint32_t reg;
+	uint8_t i;
+	dwc3_epcmd_params_t params;
+	enum usb_status ret;
+
+	/* Setup event buffers k = USB_DWC3_INT_INUSE */
+	for (i = 0; i < USB_DWC3_INT_INUSE; i++) {
+		DWC3_regwrite(dwc3_handle->usb_global, DWC3_GEVNTADRLO(i),
+			      lower_32_bits(dwc3_handle->intbuffers.evtbuffer_dma_addr[i]));
+		DWC3_regwrite(dwc3_handle->usb_global, DWC3_GEVNTADRHI(i),
+			      upper_32_bits(dwc3_handle->intbuffers.evtbuffer_dma_addr[i]));
+		DWC3_regwrite(dwc3_handle->usb_global, DWC3_GEVNTSIZ(i),
+			      USB_DWC3_EVENT_BUFFER_SIZE);
+		DWC3_regwrite(dwc3_handle->usb_global, DWC3_GEVNTCOUNT(i), 0);
+
+		/* EvtBufferPos[i] = 0;  Implicit since static done in HAL */
+	}
+
+	ret = dwc3_set_current_mode(dwc3_handle, USB_DWC3_DEVICE_MODE);
+	if (ret != USBD_OK) {
+		ERROR("Error : %s: %d\n", __func__, __LINE__);
+		return ret;
+	}
+
+	ret = dwc3_set_dev_speed(dwc3_handle, speed);
+	if (ret != USBD_OK) {
+		ERROR("Error : %s: %d\n", __func__, __LINE__);
+		return ret;
+	}
+
+	/* Issue a DEPSTARTCFG command with DEPCMD0.XferRscIdx set to 0,
+	 * to initialize the transfer resource allocation
+	 */
+	(void)memset(&params, 0x00, sizeof(params));
+	ret = dwc3_execute_dep_cmd(dwc3_handle, 0, DWC3_DEPCMD_PARAM(0) |
+				   USB_DWC3_DEPCMD_DEPSTARTCFG, &params);
+	if (ret != USBD_OK) {
+		ERROR("Error : %s: %d\n", __func__, __LINE__);
+		return ret;
+	}
+
+	/* Configure Control EP 0 & 1 mapped to physical EP 0 & 1*/
+	ret = dwc3_ep_configure(dwc3_handle, 0, false, EP_TYPE_CTRL,
+				dwc3_handle->pcd_handle->out_ep[0].maxpacket, 0, 0, 0,
+				dwc3_handle->OUT_ep[0].intr_num, USB_DWC3_DEPCFG_ACTION_INIT);
+	if (ret != USBD_OK) {
+		ERROR("Error : %s: %d\n", __func__, __LINE__);
+		return ret;
+	}
+	ret = dwc3_ep_configure(dwc3_handle, 0, true, EP_TYPE_CTRL,
+				dwc3_handle->pcd_handle->in_ep[0].maxpacket, 0, 0, 1,
+				dwc3_handle->IN_ep[0].intr_num, USB_DWC3_DEPCFG_ACTION_INIT);
+	if (ret != USBD_OK) {
+		ERROR("Error : %s: %d\n", __func__, __LINE__);
+		return ret;
+	}
+
+	/* Transfer Resource for Control EP 0 & 1*/
+	(void)memset(&params, 0x00, sizeof(params));
+	params.param0 = DWC3_DEPXFERCFG_NUM_XFER_RES(1U);
+	/* As per databook, "Issue a DEPSTARTCFG command with DEPCMD0.XferRscIdx set to 2 to
+	 * re-initialize the transfer resource allocation on SetConfiguration or SetInterface
+	 * Request", value is 2 since the EP0 & EP1 take up the transfer resource 1 & 2, hence
+	 * further EPs will take resources 2,3,&up.. But in HAL we are not decoding the
+	 * Setup-packet requests, this should ideally come from USB-MW core.
+	 * Instead we follow the same method as Linux dwc3-gadget controller driver, All hardware
+	 * endpoints can be assigned a transfer resource and this setting will stay persistent
+	 * until either a core reset or hibernation. So whenever we do a DEPSTARTCFG(0) we can go
+	 * ahead and do DEPXFERCFG for every hardware endpoint as well.
+	 * For all k = DWC3_IP_NUM_EPS
+	 */
+	for (i = 0; i < DWC3_IP_NUM_EPS; i++) {
+		ret = dwc3_execute_dep_cmd(dwc3_handle, i, USB_DWC3_DEPCMD_SETTRANSFRESOURCE,
+					   &params);
+		if (ret != USBD_OK) {
+			ERROR("Error : %s: %d\n", __func__, __LINE__);
+			return ret;
+		}
+	}
+
+	/* setup EP0 to receive SETUP packets */
+	ret = dwc3_ep0_out_start(dwc3_handle, dwc3_handle->setup_dma_addr);
+	if (ret != USBD_OK) {
+		ERROR("Error : %s: %d\n", __func__, __LINE__);
+		return ret;
+	}
+
+	/* Enable EP 0 & 1 */
+	DWC3_regupdateset(dwc3_handle->usb_device, DWC3_DALEPENA, DWC3_DALEPENA_EP(0) |
+			  DWC3_DALEPENA_EP(1));
+
+	/*
+	 * Set interrupt/EventQ number on which non-endpoint-specific device-related
+	 * interrupts are generated
+	 */
+	reg = DWC3_regread(dwc3_handle->usb_device, DWC3_DCFG) & ~USB3_DCFG_INTRNUM_MSK;
+	DWC3_regwrite(dwc3_handle->usb_device, DWC3_DCFG, reg |
+		      ((uint32_t)intr_dev << USB3_DCFG_INTRNUM_POS));
+
+	/* Enable all events but Start and End of Frame IRQs */
+	DWC3_regupdateset(dwc3_handle->usb_device, DWC3_DEVTEN, USB3_DEVTEN_VENDEVTSTRCVDEN |
+			  USB3_DEVTEN_EVNTOVERFLOWEN | USB3_DEVTEN_CMDCMPLTEN |
+			  USB3_DEVTEN_ERRTICERREVTEN | USB3_DEVTEN_U3L2L1SUSPEN |
+			  USB3_DEVTEN_HIBERNATIONREQEVTEN | USB3_DEVTEN_WKUPEVTEN |
+			  USB3_DEVTEN_ULSTCNGEN | USB3_DEVTEN_CONNECTDONEEVTEN |
+			  USB3_DEVTEN_USBRSTEVTEN | USB3_DEVTEN_DISSCONNEVTEN |
+			  USB3_DEVTEN_L1SUSPEN | USB3_DEVTEN_L1WKUPEVTEN
+			  /* | USB3_DEVTEN_SOFTEVTEN*/);
+
+	/* Enable Event Buffer interrupt k = USB_DWC3_INT_INUSE */
+	for (i = 0; i < USB_DWC3_INT_INUSE; i++) {
+		__HAL_PCD_ENABLE_INTR(dwc3_handle, i);
+	}
+
+	return USBD_OK;
+}
+
+void usb_dwc3_init_driver(struct usb_handle *usb_core_handle, struct pcd_handle *pcd_handle,
+			  dwc3_handle_t *dwc3_handle, void *base_addr)
+{
+	uint32_t i = 0;
+	enum usb_status ret;
+	uintptr_t base = (uintptr_t)base_addr;
+
+	dwc3_handle->usb_global = (usb_dwc3_global_t *)
+					(base + USB_DWC3_GLOBAL_BASE);
+
+	dwc3_handle->usb_device = (usb_dwc3_device_t *)
+					(base + USB_DWC3_DEVICE_BASE);
+
+	dwc3_handle->pcd_handle = pcd_handle;
+
+    /* Check hpcd->State is HAL_PCD_STATE_RESET, otherwise error */
+	assert(dwc3_handle->State == HAL_PCD_STATE_RESET);
+
+	dwc3_handle->State = HAL_PCD_STATE_BUSY;
+
+	/* Disable the Interrupts */
+	// Not required since USB device and EP interrupts are disabled at boot, ***ToCheck
+	for (i = 0; i < USB_DWC3_INT_INUSE; i++) {
+		__HAL_PCD_DISABLE_INTR(dwc3_handle, i);
+	}
+
+	/* Init the Core (common init.) */
+	ret = dwc3_core_init(dwc3_handle, USBPHY_UTMI);
+	if (ret != USBD_OK) {
+		panic();
+	}
+
+	/* Init endpoints structures */
+	for (i = 0; i < USB_DWC3_NUM_IN_EP ; i++) {
+		/* Init ep structure */
+		pcd_handle->in_ep[i].is_in = true;
+		pcd_handle->in_ep[i].num = i;
+		dwc3_handle->IN_ep[i].tx_fifo_num = i;
+		/* Control until ep is activated */
+		pcd_handle->in_ep[i].type = EP_TYPE_CTRL;
+
+		/*
+		 * We are doing 1:1 alternate mapping for endpoints, meaning
+		 * IN Endpoint X maps to Physical Endpoint 2*X +1 and
+		 * OUT Endpoint X maps to Physical Endpoint 2*X.
+		 * So USB endpoint 0x81 is 0x03.
+		 */
+		dwc3_handle->IN_ep[i].phy_epnum = __HAL_PCD_EPADDR_TO_PHYEPNUM(i | EP_DIR_IN);
+
+		dwc3_handle->IN_ep[i].intr_num = PCD_DEV_EVENTS_INTR;
+	}
+
+	for (i = 0; i < USB_DWC3_NUM_OUT_EP ; i++) {
+		/* Init ep structure */
+		pcd_handle->out_ep[i].is_in = false;
+		pcd_handle->out_ep[i].num = i;
+		dwc3_handle->OUT_ep[i].tx_fifo_num = i;
+		/* Control until ep is activated */
+		pcd_handle->out_ep[i].type = EP_TYPE_CTRL;
+
+		/*
+		 * We are doing 1:1 alternate mapping for endpoints, meaning
+		 * IN Endpoint X maps to Physical Endpoint 2*X +1 and
+		 * OUT Endpoint X maps to Physical Endpoint 2*X.
+		 * So USB endpoint 0x81 is 0x03.
+		 */
+		dwc3_handle->OUT_ep[i].phy_epnum = __HAL_PCD_EPADDR_TO_PHYEPNUM(i);
+
+		dwc3_handle->OUT_ep[i].intr_num = PCD_DEV_EVENTS_INTR;
+	}
+
+#define PHYS_AREA	STM32MP_USB_DWC3_BASE
+
+#define EVTBUF_AREA_OFFSET	0U
+#define TRB_OUT_AREA_OFFSET	(EVTBUF_AREA_OFFSET + USB_DWC3_EVENT_BUFFER_SIZE)
+#define TRB_IN_AREA_OFFSET	(TRB_OUT_AREA_OFFSET + sizeof(usb_dwc3_trb_t))
+#define SETUP_AREA_OFFSET	(TRB_IN_AREA_OFFSET + sizeof(usb_dwc3_trb_t))
+
+	void *coh_area = (void *)(uintptr_t)PHYS_AREA;
+
+#define EVTBUF_AREA	(coh_area + EVTBUF_AREA_OFFSET)
+#define TRB_OUT_AREA	(coh_area + TRB_OUT_AREA_OFFSET)
+#define TRB_IN_AREA	(coh_area + TRB_IN_AREA_OFFSET)
+#define SETUP_AREA	(coh_area + SETUP_AREA_OFFSET)
+
+	dwc3_handle->setup_dma_addr = (uintptr_t)api_getdmaaddr((void *)SETUP_AREA,
+								USB_SETUP_PACKET_SIZE, 1);
+	assert(dwc3_handle->setup_dma_addr != 0U);
+
+	dwc3_handle->setup_addr = SETUP_AREA;
+	assert(dwc3_handle->setup_addr != NULL);
+
+	/* Map DMA and Coherent address for event buffers k = USB_DWC3_INT_INUSE */
+	for (i = 0; i < USB_DWC3_INT_INUSE; i++) {
+		dwc3_handle->intbuffers.evtbuffer_dma_addr[i] =
+			api_getdmaaddr((void *)EVTBUF_AREA, USB_DWC3_EVENT_BUFFER_SIZE, 1);
+		assert(dwc3_handle->intbuffers.evtbuffer_dma_addr[i] != 0U);
+
+		dwc3_handle->intbuffers.evtbuffer_addr[i] = EVTBUF_AREA;
+		assert(dwc3_handle->intbuffers.evtbuffer_addr[i] != NULL);
+
+		dwc3_handle->intbuffers.evtbufferpos[i] = 0;
+
+		INFO("EventBuffer%d: BuffArea=%lx DmaAddr=%08x CoherentMapAddr=%p\n", i,
+			   (PHYS_AREA + EVTBUF_AREA_OFFSET),
+			   (uint32_t)dwc3_handle->intbuffers.evtbuffer_dma_addr[i],
+			   dwc3_handle->intbuffers.evtbuffer_addr[i]);
+	}
+
+	/* MAP TRB Coherent and DMA address for EP0IN and EP0OUT */
+	dwc3_handle->IN_ep[0].trb_dma_addr = (uint32_t)api_getdmaaddr((void *)TRB_IN_AREA,
+								      sizeof(usb_dwc3_trb_t), 1);
+	assert(dwc3_handle->IN_ep[0].trb_dma_addr != 0U);
+
+	dwc3_handle->IN_ep[0].trb_addr = (usb_dwc3_trb_t *)TRB_IN_AREA;
+	assert(dwc3_handle->IN_ep[0].trb_addr != NULL);
+
+	dwc3_handle->OUT_ep[0].trb_dma_addr = (uint32_t)api_getdmaaddr((void *)TRB_OUT_AREA,
+								       sizeof(usb_dwc3_trb_t),
+								       1);
+	assert(dwc3_handle->OUT_ep[0].trb_dma_addr != 0U);
+
+	dwc3_handle->OUT_ep[0].trb_addr = (usb_dwc3_trb_t *)TRB_OUT_AREA;
+	assert(dwc3_handle->OUT_ep[0].trb_addr != NULL);
+
+	/* Init Device */
+	dwc3_handle->EP0_State = HAL_PCD_EP0_SETUP_QUEUED;
+
+	ret = dwc3_dev_init(dwc3_handle, USB_DWC3_SPEED_HIGH, PCD_DEV_EVENTS_INTR);
+	assert(ret == USBD_OK);
+
+	dwc3_handle->State = HAL_PCD_STATE_READY;
+
+	register_usb_driver(usb_core_handle, pcd_handle, &usb_dwc3driver,
+			    dwc3_handle);
+}
diff --git a/drivers/st/usb_dwc3/usb_dwc3_regs.h b/drivers/st/usb_dwc3/usb_dwc3_regs.h
new file mode 100644
index 000000000..fbc4172d8
--- /dev/null
+++ b/drivers/st/usb_dwc3/usb_dwc3_regs.h
@@ -0,0 +1,1225 @@
+/*
+ * Copyright (c) 2015-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __USB_DWC3_REGS_H
+#define __USB_DWC3_REGS_H
+
+/*
+ * USB3 Global Register Block
+ */
+#define _DWC3_GSBUSCFG0					U(0x0)
+#define _DWC3_GSBUSCFG1					U(0x4)
+#define _DWC3_GTXTHRCFG					U(0x8)
+#define _DWC3_GRXTHRCFG					U(0xC)
+#define _DWC3_GCTL					U(0x10)
+#define _DWC3_GPMSTS					U(0x14)
+#define _DWC3_GSTS					U(0x18)
+#define _DWC3_GUCTL1					U(0x1C)
+#define _DWC3_GSNPSID					U(0x20)
+#define _DWC3_GGPIO					U(0x24)
+#define _DWC3_GUID					U(0x28)
+#define _DWC3_GUCTL					U(0x2C)
+#define _DWC3_GBUSERRADDRLO				U(0x30)
+#define _DWC3_GBUSERRADDRHI				U(0x34)
+#define _DWC3_GPRTBIMAPLO				U(0x38)
+#define _DWC3_GPRTBIMAPHI				U(0x3C)
+#define _DWC3_GHWPARAMS0				U(0x40)
+#define _DWC3_GHWPARAMS1				U(0x44)
+#define _DWC3_GHWPARAMS2				U(0x48)
+#define _DWC3_GHWPARAMS3				U(0x4C)
+#define _DWC3_GHWPARAMS4				U(0x50)
+#define _DWC3_GHWPARAMS5				U(0x54)
+#define _DWC3_GHWPARAMS6				U(0x58)
+#define _DWC3_GHWPARAMS7				U(0x5C)
+#define _DWC3_GDBGFIFOSPACE				U(0x60)
+#define _DWC3_GDBGLTSSM					U(0x64)
+#define _DWC3_GDBGLNMCC					U(0x68)
+#define _DWC3_GDBGBMU					U(0x6C)
+#define _DWC3_GDBGLSPMUX_HST				U(0x70)
+#define _DWC3_GDBGLSP					U(0x74)
+#define _DWC3_GDBGEPINFO0				U(0x78)
+#define _DWC3_GDBGEPINFO1				U(0x7C)
+#define _DWC3_GPRTBIMAP_HSLO				U(0x80)
+#define _DWC3_GPRTBIMAP_HSHI				U(0x84)
+#define _DWC3_GPRTBIMAP_FSLO				U(0x88)
+#define _DWC3_GPRTBIMAP_FSHI				U(0x8C)
+#define _DWC3_GUCTL2					U(0x9C)
+#define _DWC3_GUSB2PHYCFG				U(0x100)
+#define _DWC3_GUSB2I2CCTL				U(0x140)
+#define _DWC3_GUSB2PHYACC_ULPI				U(0x180)
+#define _DWC3_GUSB3PIPECTL				U(0x1c0)
+#define _DWC3_GTXFIFOSIZ0				U(0x200)
+#define _DWC3_GTXFIFOSIZ1				U(0x204)
+#define _DWC3_GTXFIFOSIZ2				U(0x208)
+#define _DWC3_GTXFIFOSIZ3				U(0x20c)
+#define _DWC3_GTXFIFOSIZ4				U(0x210)
+#define _DWC3_GTXFIFOSIZ5				U(0x214)
+#define _DWC3_GTXFIFOSIZ6				U(0x218)
+#define _DWC3_GTXFIFOSIZ7				U(0x21c)
+#define _DWC3_GTXFIFOSIZ8				U(0x220)
+#define _DWC3_GTXFIFOSIZ9				U(0x224)
+#define _DWC3_GTXFIFOSIZ10				U(0x228)
+#define _DWC3_GTXFIFOSIZ11				U(0x22c)
+#define _DWC3_GRXFIFOSIZ0				U(0x280)
+#define _DWC3_GRXFIFOSIZ1				U(0x284)
+#define _DWC3_GRXFIFOSIZ2				U(0x288)
+#define _DWC3_GEVNTADRLO				U(0x300)
+#define _DWC3_GEVNTADRHI				U(0x304)
+#define _DWC3_GEVNTSIZ					U(0x308)
+#define _DWC3_GEVNTCOUNT				U(0x30c)
+#define _DWC3_GHWPARAMS8				U(0x500)
+#define _DWC3_GTXFIFOPRIDEV				U(0x510)
+#define _DWC3_GTXFIFOPRIHST				U(0x518)
+#define _DWC3_GRXFIFOPRIHST				U(0x51C)
+#define _DWC3_GDMAHLRATIO				U(0x524)
+#define _DWC3_GFLADJ					U(0x530)
+
+/* _DWC3_GSBUSCFG0 register fields */
+#define _DWC3_GSBUSCFG0_INCRBRSTENA			BIT_32(0)
+#define _DWC3_GSBUSCFG0_INCR4BRSTENA			BIT_32(1)
+#define _DWC3_GSBUSCFG0_INCR8BRSTENA			BIT_32(2)
+#define _DWC3_GSBUSCFG0_INCR16BRSTENA			BIT_32(3)
+#define _DWC3_GSBUSCFG0_INCR32BRSTENA			BIT_32(4)
+#define _DWC3_GSBUSCFG0_INCR64BRSTENA			BIT_32(5)
+#define _DWC3_GSBUSCFG0_INCR128BRSTENA			BIT_32(6)
+#define _DWC3_GSBUSCFG0_INCR256BRSTENA			BIT_32(7)
+#define _DWC3_GSBUSCFG0_DESBIGEND			BIT_32(10)
+#define _DWC3_GSBUSCFG0_DATBIGEND			BIT_32(11)
+#define _DWC3_GSBUSCFG0_DESWRREQINFO_MASK		GENMASK_32(19, 16)
+#define _DWC3_GSBUSCFG0_DESWRREQINFO_SHIFT		16
+#define _DWC3_GSBUSCFG0_DATWRREQINFO_MASK		GENMASK_32(23, 20)
+#define _DWC3_GSBUSCFG0_DATWRREQINFO_SHIFT		20
+#define _DWC3_GSBUSCFG0_DESRDREQINFO_MASK		GENMASK_32(27, 24)
+#define _DWC3_GSBUSCFG0_DESRDREQINFO_SHIFT		24
+#define _DWC3_GSBUSCFG0_DATRDREQINFO_MASK		GENMASK_32(31, 28)
+#define _DWC3_GSBUSCFG0_DATRDREQINFO_SHIFT		28
+
+/* _DWC3_GSBUSCFG1 register fields */
+#define _DWC3_GSBUSCFG1_PIPETRANSLIMIT_MASK		GENMASK_32(11, 8)
+#define _DWC3_GSBUSCFG1_PIPETRANSLIMIT_SHIFT		8
+#define _DWC3_GSBUSCFG1_EN1KPAGE			BIT_32(12)
+
+/* _DWC3_GTXTHRCFG register fields */
+#define _DWC3_GTXTHRCFG_USBMAXTXBURSTSIZE_MASK		GENMASK_32(23, 16)
+#define _DWC3_GTXTHRCFG_USBMAXTXBURSTSIZE_SHIFT		16
+#define _DWC3_GTXTHRCFG_USBTXPKTCNT_MASK		GENMASK_32(27, 24)
+#define _DWC3_GTXTHRCFG_USBTXPKTCNT_SHIFT		24
+#define _DWC3_GTXTHRCFG_USBTXPKTCNTSEL			BIT_32(29)
+
+/* _DWC3_GRXTHRCFG register fields */
+#define _DWC3_GRXTHRCFG_RESVISOCOUTSPC_MASK		GENMASK_32(12, 0)
+#define _DWC3_GRXTHRCFG_RESVISOCOUTSPC_SHIFT		0
+#define _DWC3_GRXTHRCFG_USBMAXRXBURSTSIZE_MASK		GENMASK_32(23, 19)
+#define _DWC3_GRXTHRCFG_USBMAXRXBURSTSIZE_SHIFT		19
+#define _DWC3_GRXTHRCFG_USBRXPKTCNT_MASK		GENMASK_32(27, 24)
+#define _DWC3_GRXTHRCFG_USBRXPKTCNT_SHIFT		24
+#define _DWC3_GRXTHRCFG_USBRXPKTCNTSEL			BIT_32(29)
+
+/* _DWC3_GCTL register fields */
+#define _DWC3_GCTL_DSBLCLKGTNG				BIT_32(0)
+#define _DWC3_GCTL_GBLHIBERNATIONEN			BIT_32(1)
+#define _DWC3_GCTL_U2EXIT_LFPS				BIT_32(2)
+#define _DWC3_GCTL_DISSCRAMBLE				BIT_32(3)
+#define _DWC3_GCTL_SCALEDOWN_MASK			GENMASK_32(5, 4)
+#define _DWC3_GCTL_SCALEDOWN_SHIFT			4
+#define _DWC3_GCTL_RAMCLKSEL_MASK			GENMASK_32(7, 6)
+#define _DWC3_GCTL_RAMCLKSEL_SHIFT			6
+#define _DWC3_GCTL_DEBUGATTACH				BIT_32(8)
+#define _DWC3_GCTL_U1U2TIMERSCALE			BIT_32(9)
+#define _DWC3_GCTL_SOFITPSYNC				BIT_32(10)
+#define _DWC3_GCTL_CORESOFTRESET			BIT_32(11)
+#define _DWC3_GCTL_PRTCAPDIR_MASK			GENMASK_32(13, 12)
+#define _DWC3_GCTL_PRTCAPDIR_SHIFT			12
+#define _DWC3_GCTL_FRMSCLDWN_MASK			GENMASK_32(15, 14)
+#define _DWC3_GCTL_FRMSCLDWN_SHIFT			14
+#define _DWC3_GCTL_U2RSTECN				BIT_32(16)
+#define _DWC3_GCTL_BYPSSETADDR				BIT_32(17)
+#define _DWC3_GCTL_MASTERFILTBYPASS			BIT_32(18)
+#define _DWC3_GCTL_PWRDNSCALE_MASK			GENMASK_32(31, 19)
+#define _DWC3_GCTL_PWRDNSCALE_SHIFT			19
+
+/* _DWC3_GPMSTS register fields */
+#define _DWC3_GPMSTS_U2WAKEUP_MASK			GENMASK_32(9, 0)
+#define _DWC3_GPMSTS_U2WAKEUP_SHIFT			0
+#define _DWC3_GPMSTS_U3WAKEUP_MASK			GENMASK_32(16, 12)
+#define _DWC3_GPMSTS_U3WAKEUP_SHIFT			12
+#define _DWC3_GPMSTS_PORTSEL_MASK			GENMASK_32(31, 28)
+#define _DWC3_GPMSTS_PORTSEL_SHIFT			28
+
+/* _DWC3_GSTS register fields */
+#define _DWC3_GSTS_CURMOD_MASK				GENMASK_32(1, 0)
+#define _DWC3_GSTS_CURMOD_SHIFT				0
+#define _DWC3_GSTS_BUSERRADDRVLD			BIT_32(4)
+#define _DWC3_GSTS_CSRTIMEOUT				BIT_32(5)
+#define _DWC3_GSTS_DEVICE_IP				BIT_32(6)
+#define _DWC3_GSTS_HOST_IP				BIT_32(7)
+#define _DWC3_GSTS_ADP_IP				BIT_32(8)
+#define _DWC3_GSTS_BC_IP				BIT_32(9)
+#define _DWC3_GSTS_OTG_IP				BIT_32(10)
+#define _DWC3_GSTS_SSIC_IP				BIT_32(11)
+#define _DWC3_GSTS_CBELT_MASK				GENMASK_32(31, 20)
+#define _DWC3_GSTS_CBELT_SHIFT				20
+
+/* _DWC3_GUCTL1 register fields */
+#define _DWC3_GUCTL1_LOA_FILTER_EN			BIT_32(0)
+#define _DWC3_GUCTL1_OVRLD_L1_SUSP_COM			BIT_32(1)
+#define _DWC3_GUCTL1_HC_PARCHK_DISABLE			BIT_32(2)
+#define _DWC3_GUCTL1_HC_ERRATA_ENABLE			BIT_32(3)
+#define _DWC3_GUCTL1_L1_SUSP_THRLD_FOR_HOST_MASK	GENMASK_32(7, 4)
+#define _DWC3_GUCTL1_L1_SUSP_THRLD_FOR_HOST_SHIFT	4
+#define _DWC3_GUCTL1_L1_SUSP_THRLD_EN_FOR_HOST		BIT_32(8)
+#define _DWC3_GUCTL1_DEV_HS_NYET_BULK_SPR		BIT_32(9)
+#define _DWC3_GUCTL1_RESUME_OPMODE_HS_HOST		BIT_32(10)
+#define _DWC3_GUCTL1_PARKMODE_DISABLE_FSLS		BIT_32(15)
+#define _DWC3_GUCTL1_PARKMODE_DISABLE_HS		BIT_32(16)
+#define _DWC3_GUCTL1_PARKMODE_DISABLE_SS		BIT_32(17)
+#define _DWC3_GUCTL1_NAK_PER_ENH_HS			BIT_32(18)
+#define _DWC3_GUCTL1_NAK_PER_ENH_FS			BIT_32(19)
+#define _DWC3_GUCTL1_DEV_LSP_TAIL_LOCK_DIS		BIT_32(20)
+#define _DWC3_GUCTL1_IP_GAP_ADD_ON_MASK			GENMASK_32(23, 21)
+#define _DWC3_GUCTL1_IP_GAP_ADD_ON_SHIFT		21
+#define _DWC3_GUCTL1_DEV_L1_EXIT_BY_HW			BIT_32(24)
+#define _DWC3_GUCTL1_P3_IN_U2				BIT_32(25)
+#define _DWC3_GUCTL1_DEV_FORCE_20_CLK_FOR_30_CLK	BIT_32(26)
+#define _DWC3_GUCTL1_DEV_TRB_OUT_SPR_IND		BIT_32(27)
+#define _DWC3_GUCTL1_TX_IPGAP_LINECHECK_DIS		BIT_32(28)
+#define _DWC3_GUCTL1_FILTER_SE0_FSLS_EOP		BIT_32(29)
+#define _DWC3_GUCTL1_DS_RXDET_MAX_TOUT_CTRL		BIT_32(30)
+#define _DWC3_GUCTL1_DEV_DECOUPLE_L1L2_EVT		BIT_32(31)
+
+/* _DWC3_GGPIO register fields */
+#define _DWC3_GGPIO_GPI_MASK				GENMASK_32(15, 0)
+#define _DWC3_GGPIO_GPI_SHIFT				0
+#define _DWC3_GGPIO_GPO_MASK				GENMASK_32(31, 16)
+#define _DWC3_GGPIO_GPO_SHIFT				16
+
+/* _DWC3_GUCTL register fields */
+#define _DWC3_GUCTL_DTFT_MASK				GENMASK_32(8, 0)
+#define _DWC3_GUCTL_DTFT_SHIFT				0
+#define _DWC3_GUCTL_DTCT_MASK				GENMASK_32(10, 9)
+#define _DWC3_GUCTL_DTCT_SHIFT				9
+#define _DWC3_GUCTL_INSRTEXTRFSBODI			BIT_32(11)
+#define _DWC3_GUCTL_EXTCAPSUPPTEN			BIT_32(12)
+#define _DWC3_GUCTL_ENOVERLAPCHK			BIT_32(13)
+#define _DWC3_GUCTL_USBHSTINAUTORETRYEN			BIT_32(14)
+#define _DWC3_GUCTL_RESBWHSEPS				BIT_32(16)
+#define _DWC3_GUCTL_SPRSCTRLTRANSEN			BIT_32(17)
+#define _DWC3_GUCTL_NOEXTRDL				BIT_32(21)
+#define _DWC3_GUCTL_REFCLKPER_MASK			GENMASK_32(31, 22)
+#define _DWC3_GUCTL_REFCLKPER_SHIFT			22
+
+/* _DWC3_GPRTBIMAPLO register fields */
+#define _DWC3_GPRTBIMAPLO_BINUM1_MASK			GENMASK_32(3, 0)
+#define _DWC3_GPRTBIMAPLO_BINUM1_SHIFT			0
+#define _DWC3_GPRTBIMAPLO_BINUM2_MASK			GENMASK_32(7, 4)
+#define _DWC3_GPRTBIMAPLO_BINUM2_SHIFT			4
+#define _DWC3_GPRTBIMAPLO_BINUM3_MASK			GENMASK_32(11, 8)
+#define _DWC3_GPRTBIMAPLO_BINUM3_SHIFT			8
+#define _DWC3_GPRTBIMAPLO_BINUM4_MASK			GENMASK_32(15, 12)
+#define _DWC3_GPRTBIMAPLO_BINUM4_SHIFT			12
+#define _DWC3_GPRTBIMAPLO_BINUM5_MASK			GENMASK_32(19, 16)
+#define _DWC3_GPRTBIMAPLO_BINUM5_SHIFT			16
+#define _DWC3_GPRTBIMAPLO_BINUM6_MASK			GENMASK_32(23, 20)
+#define _DWC3_GPRTBIMAPLO_BINUM6_SHIFT			20
+#define _DWC3_GPRTBIMAPLO_BINUM7_MASK			GENMASK_32(27, 24)
+#define _DWC3_GPRTBIMAPLO_BINUM7_SHIFT			24
+#define _DWC3_GPRTBIMAPLO_BINUM8_MASK			GENMASK_32(31, 28)
+#define _DWC3_GPRTBIMAPLO_BINUM8_SHIFT			28
+
+/* _DWC3_GPRTBIMAPHI register fields */
+#define _DWC3_GPRTBIMAPHI_BINUM9_MASK			GENMASK_32(3, 0)
+#define _DWC3_GPRTBIMAPHI_BINUM9_SHIFT			0
+#define _DWC3_GPRTBIMAPHI_BINUM10_MASK			GENMASK_32(7, 4)
+#define _DWC3_GPRTBIMAPHI_BINUM10_SHIFT			4
+#define _DWC3_GPRTBIMAPHI_BINUM11_MASK			GENMASK_32(11, 8)
+#define _DWC3_GPRTBIMAPHI_BINUM11_SHIFT			8
+#define _DWC3_GPRTBIMAPHI_BINUM12_MASK			GENMASK_32(15, 12)
+#define _DWC3_GPRTBIMAPHI_BINUM12_SHIFT			12
+#define _DWC3_GPRTBIMAPHI_BINUM13_MASK			GENMASK_32(19, 16)
+#define _DWC3_GPRTBIMAPHI_BINUM13_SHIFT			16
+#define _DWC3_GPRTBIMAPHI_BINUM14_MASK			GENMASK_32(23, 20)
+#define _DWC3_GPRTBIMAPHI_BINUM14_SHIFT			20
+#define _DWC3_GPRTBIMAPHI_BINUM15_MASK			GENMASK_32(27, 24)
+#define _DWC3_GPRTBIMAPHI_BINUM15_SHIFT			24
+
+/* _DWC3_GHWPARAMS0 register fields */
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_2_0_MASK		GENMASK_32(2, 0)
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_2_0_SHIFT		0
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_5_3_MASK		GENMASK_32(5, 3)
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_5_3_SHIFT		3
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_7_6_MASK		GENMASK_32(7, 6)
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_7_6_SHIFT		6
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_15_8_MASK		GENMASK_32(15, 8)
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_15_8_SHIFT		8
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_23_16_MASK		GENMASK_32(23, 16)
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_23_16_SHIFT		16
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_31_24_MASK		GENMASK_32(31, 24)
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_31_24_SHIFT		24
+
+/* _DWC3_GHWPARAMS1 register fields */
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_2_0_MASK		GENMASK_32(2, 0)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_2_0_SHIFT		0
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_5_3_MASK		GENMASK_32(5, 3)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_5_3_SHIFT		3
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_8_6_MASK		GENMASK_32(8, 6)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_8_6_SHIFT		6
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_11_9_MASK		GENMASK_32(11, 9)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_11_9_SHIFT		9
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_14_12_MASK		GENMASK_32(14, 12)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_14_12_SHIFT		12
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_20_15_MASK		GENMASK_32(20, 15)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_20_15_SHIFT		15
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_22_21_MASK		GENMASK_32(22, 21)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_22_21_SHIFT		21
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_23			BIT_32(23)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_25_24_MASK		GENMASK_32(25, 24)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_25_24_SHIFT		24
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_26			BIT_32(26)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_27			BIT_32(27)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_28			BIT_32(28)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_29			BIT_32(29)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_30			BIT_32(30)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_31			BIT_32(31)
+
+/* _DWC3_GHWPARAMS3 register fields */
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_1_0_MASK		GENMASK_32(1, 0)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_1_0_SHIFT		0
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_3_2_MASK		GENMASK_32(3, 2)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_3_2_SHIFT		2
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_5_4_MASK		GENMASK_32(5, 4)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_5_4_SHIFT		4
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_7_6_MASK		GENMASK_32(7, 6)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_7_6_SHIFT		6
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_9_8_MASK		GENMASK_32(9, 8)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_9_8_SHIFT		8
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_10			BIT_32(10)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_11			BIT_32(11)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_17_12_MASK		GENMASK_32(17, 12)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_17_12_SHIFT		12
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_22_18_MASK		GENMASK_32(22, 18)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_22_18_SHIFT		18
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_30_23_MASK		GENMASK_32(30, 23)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_30_23_SHIFT		23
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_31			BIT_32(31)
+
+/* _DWC3_GHWPARAMS4 register fields */
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_5_0_MASK		GENMASK_32(5, 0)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_5_0_SHIFT		0
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_6			BIT_32(6)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_8_7_MASK		GENMASK_32(8, 7)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_8_7_SHIFT		7
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_10_9_MASK		GENMASK_32(10, 9)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_10_9_SHIFT		9
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_11			BIT_32(11)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_12			BIT_32(12)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_16_13_MASK		GENMASK_32(16, 13)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_16_13_SHIFT		13
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_20_17_MASK		GENMASK_32(20, 17)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_20_17_SHIFT		17
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_21			BIT_32(21)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_22			BIT_32(22)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_23			BIT_32(23)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_27_24_MASK		GENMASK_32(27, 24)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_27_24_SHIFT		24
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_31_28_MASK		GENMASK_32(31, 28)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_31_28_SHIFT		28
+
+/* _DWC3_GHWPARAMS5 register fields */
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_3_0_MASK		GENMASK_32(3, 0)
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_3_0_SHIFT		0
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_9_4_MASK		GENMASK_32(9, 4)
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_9_4_SHIFT		4
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_15_10_MASK		GENMASK_32(15, 10)
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_15_10_SHIFT		10
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_21_16_MASK		GENMASK_32(21, 16)
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_21_16_SHIFT		16
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_27_22_MASK		GENMASK_32(27, 22)
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_27_22_SHIFT		22
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_31_28_MASK		GENMASK_32(31, 28)
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_31_28_SHIFT		28
+
+/* _DWC3_GHWPARAMS6 register fields */
+#define _DWC3_GHWPARAMS6_GHWPARAMS6_5_0_MASK		GENMASK_32(5, 0)
+#define _DWC3_GHWPARAMS6_GHWPARAMS6_5_0_SHIFT		0
+#define _DWC3_GHWPARAMS6_GHWPARAMS6_6			BIT_32(6)
+#define _DWC3_GHWPARAMS6_GHWPARAMS6_7			BIT_32(7)
+#define _DWC3_GHWPARAMS6_GHWPARAMS6_9_8_MASK		GENMASK_32(9, 8)
+#define _DWC3_GHWPARAMS6_GHWPARAMS6_9_8_SHIFT		8
+#define _DWC3_GHWPARAMS6_SRPSUPPORT			BIT_32(10)
+#define _DWC3_GHWPARAMS6_HNPSUPPORT			BIT_32(11)
+#define _DWC3_GHWPARAMS6_ADPSUPPORT			BIT_32(12)
+#define _DWC3_GHWPARAMS6_OTG_SS_SUPPORT			BIT_32(13)
+#define _DWC3_GHWPARAMS6_BCSUPPORT			BIT_32(14)
+#define _DWC3_GHWPARAMS6_BUSFLTRSSUPPORT		BIT_32(15)
+#define _DWC3_GHWPARAMS6_GHWPARAMS6_31_16_MASK		GENMASK_32(31, 16)
+#define _DWC3_GHWPARAMS6_GHWPARAMS6_31_16_SHIFT		16
+
+/* _DWC3_GHWPARAMS7 register fields */
+#define _DWC3_GHWPARAMS7_GHWPARAMS7_15_0_MASK		GENMASK_32(15, 0)
+#define _DWC3_GHWPARAMS7_GHWPARAMS7_15_0_SHIFT		0
+#define _DWC3_GHWPARAMS7_GHWPARAMS7_31_16_MASK		GENMASK_32(31, 16)
+#define _DWC3_GHWPARAMS7_GHWPARAMS7_31_16_SHIFT		16
+
+/* _DWC3_GDBGFIFOSPACE register fields */
+#define _DWC3_GDBGFIFOSPACE_FIFO_QUEUE_SELECT_MASK	GENMASK_32(8, 0)
+#define _DWC3_GDBGFIFOSPACE_FIFO_QUEUE_SELECT_SHIFT	0
+#define _DWC3_GDBGFIFOSPACE_SPACE_AVAILABLE_MASK	GENMASK_32(31, 16)
+#define _DWC3_GDBGFIFOSPACE_SPACE_AVAILABLE_SHIFT	16
+
+/* _DWC3_GDBGLTSSM register fields */
+#define _DWC3_GDBGLTSSM_TXONESZEROS			BIT_32(0)
+#define _DWC3_GDBGLTSSM_RXTERMINATION			BIT_32(1)
+#define _DWC3_GDBGLTSSM_TXSWING				BIT_32(2)
+#define _DWC3_GDBGLTSSM_LTDBCLKSTATE_MASK		GENMASK_32(5, 3)
+#define _DWC3_GDBGLTSSM_LTDBCLKSTATE_SHIFT		3
+#define _DWC3_GDBGLTSSM_TXDEEMPHASIS_MASK		GENMASK_32(7, 6)
+#define _DWC3_GDBGLTSSM_TXDEEMPHASIS_SHIFT		6
+#define _DWC3_GDBGLTSSM_RXEQTRAIN			BIT_32(8)
+#define _DWC3_GDBGLTSSM_POWERDOWN_MASK			GENMASK_32(10, 9)
+#define _DWC3_GDBGLTSSM_POWERDOWN_SHIFT			9
+#define _DWC3_GDBGLTSSM_LTDBPHYCMDSTATE_MASK		GENMASK_32(13, 11)
+#define _DWC3_GDBGLTSSM_LTDBPHYCMDSTATE_SHIFT		11
+#define _DWC3_GDBGLTSSM_TXDETRXLOOPBACK			BIT_32(14)
+#define _DWC3_GDBGLTSSM_RXPOLARITY			BIT_32(15)
+#define _DWC3_GDBGLTSSM_TXELECLDLE			BIT_32(16)
+#define _DWC3_GDBGLTSSM_ELASTICBUFFERMODE		BIT_32(17)
+#define _DWC3_GDBGLTSSM_LTDBSUBSTATE_MASK		GENMASK_32(21, 18)
+#define _DWC3_GDBGLTSSM_LTDBSUBSTATE_SHIFT		18
+#define _DWC3_GDBGLTSSM_LTDBLINKSTATE_MASK		GENMASK_32(25, 22)
+#define _DWC3_GDBGLTSSM_LTDBLINKSTATE_SHIFT		22
+#define _DWC3_GDBGLTSSM_LTDBTIMEOUT			BIT_32(26)
+#define _DWC3_GDBGLTSSM_PRTDIRECTION			BIT_32(27)
+#define _DWC3_GDBGLTSSM_X3_DS_HOST_SHUTDOWN		BIT_32(28)
+#define _DWC3_GDBGLTSSM_X3_XS_SWAPPING			BIT_32(29)
+#define _DWC3_GDBGLTSSM_RXELECIDLE			BIT_32(30)
+
+/* _DWC3_GDBGLNMCC register fields */
+#define _DWC3_GDBGLNMCC_LNMCC_BERC_MASK			GENMASK_32(8, 0)
+#define _DWC3_GDBGLNMCC_LNMCC_BERC_SHIFT		0
+
+/* _DWC3_GDBGBMU register fields */
+#define _DWC3_GDBGBMU_BMU_CCU_MASK			GENMASK_32(3, 0)
+#define _DWC3_GDBGBMU_BMU_CCU_SHIFT			0
+#define _DWC3_GDBGBMU_BMU_DCU_MASK			GENMASK_32(7, 4)
+#define _DWC3_GDBGBMU_BMU_DCU_SHIFT			4
+#define _DWC3_GDBGBMU_BMU_BCU_MASK			GENMASK_32(31, 8)
+#define _DWC3_GDBGBMU_BMU_BCU_SHIFT			8
+
+/* _DWC3_GDBGLSPMUX_HST register fields */
+#define _DWC3_GDBGLSPMUX_HST_HOSTSELECT_MASK		GENMASK_32(13, 0)
+#define _DWC3_GDBGLSPMUX_HST_HOSTSELECT_SHIFT		0
+#define _DWC3_GDBGLSPMUX_HST_LOGIC_ANALYZER_TRACE_MASK	GENMASK_32(23, 16)
+#define _DWC3_GDBGLSPMUX_HST_LOGIC_ANALYZER_TRACE_SHIFT	16
+
+/* _DWC3_GPRTBIMAP_HSLO register fields */
+#define _DWC3_GPRTBIMAP_HSLO_BINUM1_MASK		GENMASK_32(3, 0)
+#define _DWC3_GPRTBIMAP_HSLO_BINUM1_SHIFT		0
+#define _DWC3_GPRTBIMAP_HSLO_BINUM2_MASK		GENMASK_32(7, 4)
+#define _DWC3_GPRTBIMAP_HSLO_BINUM2_SHIFT		4
+#define _DWC3_GPRTBIMAP_HSLO_BINUM3_MASK		GENMASK_32(11, 8)
+#define _DWC3_GPRTBIMAP_HSLO_BINUM3_SHIFT		8
+#define _DWC3_GPRTBIMAP_HSLO_BINUM4_MASK		GENMASK_32(15, 12)
+#define _DWC3_GPRTBIMAP_HSLO_BINUM4_SHIFT		12
+#define _DWC3_GPRTBIMAP_HSLO_BINUM5_MASK		GENMASK_32(19, 16)
+#define _DWC3_GPRTBIMAP_HSLO_BINUM5_SHIFT		16
+#define _DWC3_GPRTBIMAP_HSLO_BINUM6_MASK		GENMASK_32(23, 20)
+#define _DWC3_GPRTBIMAP_HSLO_BINUM6_SHIFT		20
+#define _DWC3_GPRTBIMAP_HSLO_BINUM7_MASK		GENMASK_32(27, 24)
+#define _DWC3_GPRTBIMAP_HSLO_BINUM7_SHIFT		24
+#define _DWC3_GPRTBIMAP_HSLO_BINUM8_MASK		GENMASK_32(31, 28)
+#define _DWC3_GPRTBIMAP_HSLO_BINUM8_SHIFT		28
+
+/* _DWC3_GPRTBIMAP_HSHI register fields */
+#define _DWC3_GPRTBIMAP_HSHI_BINUM9_MASK		GENMASK_32(3, 0)
+#define _DWC3_GPRTBIMAP_HSHI_BINUM9_SHIFT		0
+#define _DWC3_GPRTBIMAP_HSHI_BINUM10_MASK		GENMASK_32(7, 4)
+#define _DWC3_GPRTBIMAP_HSHI_BINUM10_SHIFT		4
+#define _DWC3_GPRTBIMAP_HSHI_BINUM11_MASK		GENMASK_32(11, 8)
+#define _DWC3_GPRTBIMAP_HSHI_BINUM11_SHIFT		8
+#define _DWC3_GPRTBIMAP_HSHI_BINUM12_MASK		GENMASK_32(15, 12)
+#define _DWC3_GPRTBIMAP_HSHI_BINUM12_SHIFT		12
+#define _DWC3_GPRTBIMAP_HSHI_BINUM13_MASK		GENMASK_32(19, 16)
+#define _DWC3_GPRTBIMAP_HSHI_BINUM13_SHIFT		16
+#define _DWC3_GPRTBIMAP_HSHI_BINUM14_MASK		GENMASK_32(23, 20)
+#define _DWC3_GPRTBIMAP_HSHI_BINUM14_SHIFT		20
+#define _DWC3_GPRTBIMAP_HSHI_BINUM15_MASK		GENMASK_32(27, 24)
+#define _DWC3_GPRTBIMAP_HSHI_BINUM15_SHIFT		24
+
+/* _DWC3_GPRTBIMAP_FSLO register fields */
+#define _DWC3_GPRTBIMAP_FSLO_BINUM1_MASK		GENMASK_32(3, 0)
+#define _DWC3_GPRTBIMAP_FSLO_BINUM1_SHIFT		0
+#define _DWC3_GPRTBIMAP_FSLO_BINUM2_MASK		GENMASK_32(7, 4)
+#define _DWC3_GPRTBIMAP_FSLO_BINUM2_SHIFT		4
+#define _DWC3_GPRTBIMAP_FSLO_BINUM3_MASK		GENMASK_32(11, 8)
+#define _DWC3_GPRTBIMAP_FSLO_BINUM3_SHIFT		8
+#define _DWC3_GPRTBIMAP_FSLO_BINUM4_MASK		GENMASK_32(15, 12)
+#define _DWC3_GPRTBIMAP_FSLO_BINUM4_SHIFT		12
+#define _DWC3_GPRTBIMAP_FSLO_BINUM5_MASK		GENMASK_32(19, 16)
+#define _DWC3_GPRTBIMAP_FSLO_BINUM5_SHIFT		16
+#define _DWC3_GPRTBIMAP_FSLO_BINUM6_MASK		GENMASK_32(23, 20)
+#define _DWC3_GPRTBIMAP_FSLO_BINUM6_SHIFT		20
+#define _DWC3_GPRTBIMAP_FSLO_BINUM7_MASK		GENMASK_32(27, 24)
+#define _DWC3_GPRTBIMAP_FSLO_BINUM7_SHIFT		24
+#define _DWC3_GPRTBIMAP_FSLO_BINUM8_MASK		GENMASK_32(31, 28)
+#define _DWC3_GPRTBIMAP_FSLO_BINUM8_SHIFT		28
+
+/* _DWC3_GPRTBIMAP_FSHI register fields */
+#define _DWC3_GPRTBIMAP_FSHI_BINUM9_MASK		GENMASK_32(3, 0)
+#define _DWC3_GPRTBIMAP_FSHI_BINUM9_SHIFT		0
+#define _DWC3_GPRTBIMAP_FSHI_BINUM10_MASK		GENMASK_32(7, 4)
+#define _DWC3_GPRTBIMAP_FSHI_BINUM10_SHIFT		4
+#define _DWC3_GPRTBIMAP_FSHI_BINUM11_MASK		GENMASK_32(11, 8)
+#define _DWC3_GPRTBIMAP_FSHI_BINUM11_SHIFT		8
+#define _DWC3_GPRTBIMAP_FSHI_BINUM12_MASK		GENMASK_32(15, 12)
+#define _DWC3_GPRTBIMAP_FSHI_BINUM12_SHIFT		12
+#define _DWC3_GPRTBIMAP_FSHI_BINUM13_MASK		GENMASK_32(19, 16)
+#define _DWC3_GPRTBIMAP_FSHI_BINUM13_SHIFT		16
+#define _DWC3_GPRTBIMAP_FSHI_BINUM14_MASK		GENMASK_32(23, 20)
+#define _DWC3_GPRTBIMAP_FSHI_BINUM14_SHIFT		20
+#define _DWC3_GPRTBIMAP_FSHI_BINUM15_MASK		GENMASK_32(27, 24)
+#define _DWC3_GPRTBIMAP_FSHI_BINUM15_SHIFT		24
+
+/* _DWC3_GUCTL2 register fields */
+#define _DWC3_GUCTL2_TXPINGDURATION_MASK		GENMASK_32(4, 0)
+#define _DWC3_GUCTL2_TXPINGDURATION_SHIFT		0
+#define _DWC3_GUCTL2_RXPINGDURATION_MASK		GENMASK_32(10, 5)
+#define _DWC3_GUCTL2_RXPINGDURATION_SHIFT		5
+#define _DWC3_GUCTL2_DISABLECFC				BIT_32(11)
+#define _DWC3_GUCTL2_ENABLEEPCACHEEVICT			BIT_32(12)
+#define _DWC3_GUCTL2_RST_ACTBITLATER			BIT_32(14)
+#define _DWC3_GUCTL2_NOLOWPWRDUR_MASK			GENMASK_32(18, 15)
+#define _DWC3_GUCTL2_NOLOWPWRDUR_SHIFT			15
+#define _DWC3_GUCTL2_EN_HP_PM_TIMER_MASK		GENMASK_32(25, 19)
+#define _DWC3_GUCTL2_EN_HP_PM_TIMER_SHIFT		19
+
+/* _DWC3_GTXFIFOPRIDEV register fields */
+#define _DWC3_GTXFIFOPRIDEV_GTXFIFOPRIDEV_MASK		GENMASK_32(11, 0)
+#define _DWC3_GTXFIFOPRIDEV_GTXFIFOPRIDEV_SHIFT		0
+
+/* _DWC3_GTXFIFOPRIHST register fields */
+#define _DWC3_GTXFIFOPRIHST_GTXFIFOPRIHST_MASK		GENMASK_32(2, 0)
+#define _DWC3_GTXFIFOPRIHST_GTXFIFOPRIHST_SHIFT		0
+
+/* _DWC3_GRXFIFOPRIHST register fields */
+#define _DWC3_GRXFIFOPRIHST_GRXFIFOPRIHST_MASK		GENMASK_32(2, 0)
+#define _DWC3_GRXFIFOPRIHST_GRXFIFOPRIHST_SHIFT		0
+
+/* _DWC3_GDMAHLRATIO register fields */
+#define _DWC3_GDMAHLRATIO_HSTTXFIFO_MASK		GENMASK_32(4, 0)
+#define _DWC3_GDMAHLRATIO_HSTTXFIFO_SHIFT		0
+#define _DWC3_GDMAHLRATIO_HSTRXFIFO_MASK		GENMASK_32(12, 8)
+#define _DWC3_GDMAHLRATIO_HSTRXFIFO_SHIFT		8
+
+/* _DWC3_GFLADJ register fields */
+#define _DWC3_GFLADJ_GFLADJ_30MHZ_MASK			GENMASK_32(5, 0)
+#define _DWC3_GFLADJ_GFLADJ_30MHZ_SHIFT			0
+#define _DWC3_GFLADJ_GFLADJ_30MHZ_SDBND_SEL		BIT_32(7)
+#define _DWC3_GFLADJ_GFLADJ_REFCLK_FLADJ_MASK		GENMASK_32(21, 8)
+#define _DWC3_GFLADJ_GFLADJ_REFCLK_FLADJ_SHIFT		8
+#define _DWC3_GFLADJ_GFLADJ_REFCLK_LPM_SEL		BIT_32(23)
+#define _DWC3_GFLADJ_GFLADJ_REFCLK_240MHZ_DECR_MASK	GENMASK_32(30, 24)
+#define _DWC3_GFLADJ_GFLADJ_REFCLK_240MHZ_DECR_SHIFT	24
+#define _DWC3_GFLADJ_GFLADJ_REFCLK_240MHZDECR_PLS1	BIT_32(31)
+
+/* _DWC3_GUSB2PHYCFG register fields */
+#define _DWC3_GUSB2PHYCFG_TOUTCAL_MASK			GENMASK_32(2, 0)
+#define _DWC3_GUSB2PHYCFG_TOUTCAL_SHIFT			0
+#define _DWC3_GUSB2PHYCFG_PHYIF				BIT_32(3)
+#define _DWC3_GUSB2PHYCFG_ULPI_UTMI_SEL			BIT_32(4)
+#define _DWC3_GUSB2PHYCFG_FSINTF			BIT_32(5)
+#define _DWC3_GUSB2PHYCFG_SUSPENDUSB20			BIT_32(6)
+#define _DWC3_GUSB2PHYCFG_PHYSEL			BIT_32(7)
+#define _DWC3_GUSB2PHYCFG_ENBLSLPM			BIT_32(8)
+#define _DWC3_GUSB2PHYCFG_XCVRDLY			BIT_32(9)
+#define _DWC3_GUSB2PHYCFG_USBTRDTIM_MASK		GENMASK_32(13, 10)
+#define _DWC3_GUSB2PHYCFG_USBTRDTIM_SHIFT		10
+#define _DWC3_GUSB2PHYCFG_ULPIAUTORES			BIT_32(15)
+#define _DWC3_GUSB2PHYCFG_ULPIEXTVBUSDRV		BIT_32(17)
+#define _DWC3_GUSB2PHYCFG_ULPIEXTVBUSINDIACTOR		BIT_32(18)
+#define _DWC3_GUSB2PHYCFG_LSIPD_MASK			GENMASK_32(21, 19)
+#define _DWC3_GUSB2PHYCFG_LSIPD_SHIFT			19
+#define _DWC3_GUSB2PHYCFG_LSTRD_MASK			GENMASK_32(24, 22)
+#define _DWC3_GUSB2PHYCFG_LSTRD_SHIFT			22
+#define _DWC3_GUSB2PHYCFG_INV_SEL_HSIC			BIT_32(26)
+#define _DWC3_GUSB2PHYCFG_HSIC_CON_WIDTH_ADJ_MASK	GENMASK_32(28, 27)
+#define _DWC3_GUSB2PHYCFG_HSIC_CON_WIDTH_ADJ_SHIFT	27
+#define _DWC3_GUSB2PHYCFG_ULPI_LPM_WITH_OPMODE_CHK	BIT_32(29)
+#define _DWC3_GUSB2PHYCFG_U2_FREECLK_EXISTS		BIT_32(30)
+#define _DWC3_GUSB2PHYCFG_PHYSOFTRST			BIT_32(31)
+
+/* _DWC3_GUSB2PHYACC_ULPI register fields */
+#define _DWC3_GUSB2PHYACC_ULPI_REGDATA_MASK		GENMASK_32(7, 0)
+#define _DWC3_GUSB2PHYACC_ULPI_REGDATA_SHIFT		0
+#define _DWC3_GUSB2PHYACC_ULPI_EXTREGADDR_MASK		GENMASK_32(15, 8)
+#define _DWC3_GUSB2PHYACC_ULPI_EXTREGADDR_SHIFT		8
+#define _DWC3_GUSB2PHYACC_ULPI_REGADDR_MASK		GENMASK_32(21, 16)
+#define _DWC3_GUSB2PHYACC_ULPI_REGADDR_SHIFT		16
+#define _DWC3_GUSB2PHYACC_ULPI_REGWR			BIT_32(22)
+#define _DWC3_GUSB2PHYACC_ULPI_VSTSBSY			BIT_32(23)
+#define _DWC3_GUSB2PHYACC_ULPI_VSTSDONE			BIT_32(24)
+#define _DWC3_GUSB2PHYACC_ULPI_NEWREGREQ		BIT_32(25)
+#define _DWC3_GUSB2PHYACC_ULPI_DISUIPIDRVR		BIT_32(26)
+
+/* _DWC3_GUSB3PIPECTL register fields */
+#define _DWC3_GUSB3PIPECTL_ELASTIC_BUFFER_MODE		BIT_32(0)
+#define _DWC3_GUSB3PIPECTL_SS_TX_DE_EMPHASIS_MASK	GENMASK_32(2, 1)
+#define _DWC3_GUSB3PIPECTL_SS_TX_DE_EMPHASIS_SHIFT	1
+#define _DWC3_GUSB3PIPECTL_TX_MARGIN_MASK		GENMASK_32(5, 3)
+#define _DWC3_GUSB3PIPECTL_TX_MARGIN_SHIFT		3
+#define _DWC3_GUSB3PIPECTL_TX_SWING			BIT_32(6)
+#define _DWC3_GUSB3PIPECTL_SSICEN			BIT_32(7)
+#define _DWC3_GUSB3PIPECTL_RX_DETECT_TO_POLLING_LFPS_CONTROL	BIT_32(8)
+#define _DWC3_GUSB3PIPECTL_LFPSFILTER			BIT_32(9)
+#define _DWC3_GUSB3PIPECTL_P3EXSIGP2			BIT_32(10)
+#define _DWC3_GUSB3PIPECTL_P3P2TRANOK			BIT_32(11)
+#define _DWC3_GUSB3PIPECTL_LFPSP0ALGN			BIT_32(12)
+#define _DWC3_GUSB3PIPECTL_SKIPRXDET			BIT_32(13)
+#define _DWC3_GUSB3PIPECTL_ABORTRXDETINU2		BIT_32(14)
+#define _DWC3_GUSB3PIPECTL_DATWIDTH_MASK		GENMASK_32(16, 15)
+#define _DWC3_GUSB3PIPECTL_DATWIDTH_SHIFT		15
+#define _DWC3_GUSB3PIPECTL_SUSPENDENABLE		BIT_32(17)
+#define _DWC3_GUSB3PIPECTL_DELAYP1TRANS			BIT_32(18)
+#define _DWC3_GUSB3PIPECTL_DELAYP1P2P3_MASK		GENMASK_32(21, 19)
+#define _DWC3_GUSB3PIPECTL_DELAYP1P2P3_SHIFT		19
+#define _DWC3_GUSB3PIPECTL_DISRXDETU3RXDET		BIT_32(22)
+#define _DWC3_GUSB3PIPECTL_STARTRXDETU3RXDET		BIT_32(23)
+#define _DWC3_GUSB3PIPECTL_REQUEST_P1P2P3		BIT_32(24)
+#define _DWC3_GUSB3PIPECTL_U1U2EXITFAIL_TO_RECOV	BIT_32(25)
+#define _DWC3_GUSB3PIPECTL_PING_ENHANCEMENT_EN		BIT_32(26)
+#define _DWC3_GUSB3PIPECTL_UX_EXIT_IN_PX		BIT_32(27)
+#define _DWC3_GUSB3PIPECTL_DISRXDETP3			BIT_32(28)
+#define _DWC3_GUSB3PIPECTL_U2P3OK			BIT_32(29)
+#define _DWC3_GUSB3PIPECTL_HSTPRTCMPL			BIT_32(30)
+#define _DWC3_GUSB3PIPECTL_PHYSOFTRST			BIT_32(31)
+
+/* _DWC3_GTXFIFOSIZ0 register fields */
+#define _DWC3_GTXFIFOSIZ0_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ0_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ0_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ0_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ1 register fields */
+#define _DWC3_GTXFIFOSIZ1_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ1_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ1_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ1_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ2 register fields */
+#define _DWC3_GTXFIFOSIZ2_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ2_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ2_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ2_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ3 register fields */
+#define _DWC3_GTXFIFOSIZ3_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ3_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ3_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ3_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ4 register fields */
+#define _DWC3_GTXFIFOSIZ4_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ4_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ4_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ4_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ5 register fields */
+#define _DWC3_GTXFIFOSIZ5_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ5_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ5_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ5_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ6 register fields */
+#define _DWC3_GTXFIFOSIZ6_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ6_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ6_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ6_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ7 register fields */
+#define _DWC3_GTXFIFOSIZ7_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ7_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ7_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ7_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ8 register fields */
+#define _DWC3_GTXFIFOSIZ8_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ8_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ8_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ8_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ9 register fields */
+#define _DWC3_GTXFIFOSIZ9_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ9_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ9_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ9_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ10 register fields */
+#define _DWC3_GTXFIFOSIZ10_TXFDEP_N_MASK		GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ10_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ10_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ10_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ11 register fields */
+#define _DWC3_GTXFIFOSIZ11_TXFDEP_N_MASK		GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ11_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ11_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ11_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GRXFIFOSIZ0 register fields */
+#define _DWC3_GRXFIFOSIZ0_RXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GRXFIFOSIZ0_RXFDEP_N_SHIFT		0
+#define _DWC3_GRXFIFOSIZ0_RXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GRXFIFOSIZ0_RXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GRXFIFOSIZ1 register fields */
+#define _DWC3_GRXFIFOSIZ1_RXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GRXFIFOSIZ1_RXFDEP_N_SHIFT		0
+#define _DWC3_GRXFIFOSIZ1_RXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GRXFIFOSIZ1_RXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GRXFIFOSIZ2 register fields */
+#define _DWC3_GRXFIFOSIZ2_RXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GRXFIFOSIZ2_RXFDEP_N_SHIFT		0
+#define _DWC3_GRXFIFOSIZ2_RXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GRXFIFOSIZ2_RXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GEVNTSIZ register fields */
+#define _DWC3_GEVNTSIZ_EVENTSIZ_MASK			GENMASK_32(15, 0)
+#define _DWC3_GEVNTSIZ_EVENTSIZ_SHIFT			0
+#define _DWC3_GEVNTSIZ_EVNTINTRPTMASK			BIT_32(31)
+
+/* _DWC3_GEVNTCOUNT register fields */
+#define _DWC3_GEVNTCOUNT_EVNTCOUNT_MASK			GENMASK_32(15, 0)
+#define _DWC3_GEVNTCOUNT_EVNTCOUNT_SHIFT		0
+#define _DWC3_GEVNTCOUNT_EVNT_HANDLER_BUSY		BIT_32(31)
+
+/*
+ * USB3 Device Register Block
+ */
+#define _DWC3_DCFG					U(0x0)
+#define _DWC3_DCTL					U(0x4)
+#define _DWC3_DEVTEN					U(0x8)
+#define _DWC3_DSTS					U(0xC)
+#define _DWC3_DGCMDPAR					U(0x10)
+#define _DWC3_DGCMD					U(0x14)
+#define _DWC3_DALEPENA					U(0x20)
+#define _DWC3_DEPCMDPAR2				U(0x100)
+#define _DWC3_DEPCMDPAR1				U(0x104)
+#define _DWC3_DEPCMDPAR0				U(0x108)
+#define _DWC3_DEPCMD					U(0x10c)
+#define _DWC3_DEV_IMOD					U(0x300)
+
+/* _DWC3_DCFG register fields */
+#define _DWC3_DCFG_DEVSPD_MASK				GENMASK_32(2, 0)
+#define _DWC3_DCFG_DEVSPD_SHIFT				0
+#define _DWC3_DCFG_DEVADDR_MASK				GENMASK_32(9, 3)
+#define _DWC3_DCFG_DEVADDR_SHIFT			3
+#define _DWC3_DCFG_INTRNUM_MASK				GENMASK_32(16, 12)
+#define _DWC3_DCFG_INTRNUM_SHIFT			12
+#define _DWC3_DCFG_NUMP_MASK				GENMASK_32(21, 17)
+#define _DWC3_DCFG_NUMP_SHIFT				17
+#define _DWC3_DCFG_LPMCAP				BIT_32(22)
+#define _DWC3_DCFG_IGNSTRMPP				BIT_32(23)
+
+/* _DWC3_DCTL register fields */
+#define _DWC3_DCTL_TSTCTL_MASK				GENMASK_32(4, 1)
+#define _DWC3_DCTL_TSTCTL_SHIFT				1
+#define _DWC3_DCTL_ULSTCHNGREQ_MASK			GENMASK_32(8, 5)
+#define _DWC3_DCTL_ULSTCHNGREQ_SHIFT			5
+#define _DWC3_DCTL_ACCEPTU1ENA				BIT_32(9)
+#define _DWC3_DCTL_INITU1ENA				BIT_32(10)
+#define _DWC3_DCTL_ACCEPTU2ENA				BIT_32(11)
+#define _DWC3_DCTL_INITU2ENA				BIT_32(12)
+#define _DWC3_DCTL_CSS					BIT_32(16)
+#define _DWC3_DCTL_CRS					BIT_32(17)
+#define _DWC3_DCTL_L1HIBERNATIONEN			BIT_32(18)
+#define _DWC3_DCTL_KEEPCONNECT				BIT_32(19)
+#define _DWC3_DCTL_LPM_NYET_THRES_MASK			GENMASK_32(23, 20)
+#define _DWC3_DCTL_LPM_NYET_THRES_SHIFT			20
+#define _DWC3_DCTL_HIRDTHRES_MASK			GENMASK_32(28, 24)
+#define _DWC3_DCTL_HIRDTHRES_SHIFT			24
+#define _DWC3_DCTL_CSFTRST				BIT_32(30)
+#define _DWC3_DCTL_RUN_STOP				BIT_32(31)
+
+/* _DWC3_DEVTEN register fields */
+#define _DWC3_DEVTEN_DISSCONNEVTEN			BIT_32(0)
+#define _DWC3_DEVTEN_USBRSTEVTEN			BIT_32(1)
+#define _DWC3_DEVTEN_CONNECTDONEEVTEN			BIT_32(2)
+#define _DWC3_DEVTEN_ULSTCNGEN				BIT_32(3)
+#define _DWC3_DEVTEN_WKUPEVTEN				BIT_32(4)
+#define _DWC3_DEVTEN_HIBERNATIONREQEVTEN		BIT_32(5)
+#define _DWC3_DEVTEN_U3L2L1SUSPEN			BIT_32(6)
+#define _DWC3_DEVTEN_SOFTEVTEN				BIT_32(7)
+#define _DWC3_DEVTEN_L1SUSPEN				BIT_32(8)
+#define _DWC3_DEVTEN_ERRTICERREVTEN			BIT_32(9)
+#define _DWC3_DEVTEN_CMDCMPLTEN				BIT_32(10)
+#define _DWC3_DEVTEN_EVNTOVERFLOWEN			BIT_32(11)
+#define _DWC3_DEVTEN_VENDEVTSTRCVDEN			BIT_32(12)
+#define _DWC3_DEVTEN_L1WKUPEVTEN			BIT_32(14)
+#define _DWC3_DEVTEN_ECCERREN				BIT_32(16)
+
+/* _DWC3_DSTS register fields */
+#define _DWC3_DSTS_CONNECTSPD_MASK			GENMASK_32(2, 0)
+#define _DWC3_DSTS_CONNECTSPD_SHIFT			0
+#define _DWC3_DSTS_SOFFN_MASK				GENMASK_32(16, 3)
+#define _DWC3_DSTS_SOFFN_SHIFT				3
+#define _DWC3_DSTS_RXFIFOEMPTY				BIT_32(17)
+#define _DWC3_DSTS_USBLNKST_MASK			GENMASK_32(21, 18)
+#define _DWC3_DSTS_USBLNKST_SHIFT			18
+#define _DWC3_DSTS_DEVCTRLHLT				BIT_32(22)
+#define _DWC3_DSTS_COREIDLE				BIT_32(23)
+#define _DWC3_DSTS_SSS					BIT_32(24)
+#define _DWC3_DSTS_RSS					BIT_32(25)
+#define _DWC3_DSTS_SRE					BIT_32(28)
+#define _DWC3_DSTS_DCNRD				BIT_32(29)
+
+/* _DWC3_DGCMD register fields */
+#define _DWC3_DGCMD_CMDTYP_MASK				GENMASK_32(7, 0)
+#define _DWC3_DGCMD_CMDTYP_SHIFT			0
+#define _DWC3_DGCMD_CMDIOC				BIT_32(8)
+#define _DWC3_DGCMD_CMDACT				BIT_32(10)
+#define _DWC3_DGCMD_CMDSTATUS_MASK			GENMASK_32(15, 12)
+#define _DWC3_DGCMD_CMDSTATUS_SHIFT			12
+
+/* _DWC3_DEPCMD register fields */
+#define _DWC3_DEPCMD_CMDTYP_MASK			GENMASK_32(3, 0)
+#define _DWC3_DEPCMD_CMDTYP_SHIFT			0
+#define _DWC3_DEPCMD_CMDIOC				BIT_32(8)
+#define _DWC3_DEPCMD_CMDACT				BIT_32(10)
+#define _DWC3_DEPCMD_HIPRI_FORCERM			BIT_32(11)
+#define _DWC3_DEPCMD_CMDSTATUS_MASK			GENMASK_32(15, 12)
+#define _DWC3_DEPCMD_CMDSTATUS_SHIFT			12
+#define _DWC3_DEPCMD_COMMANDPARAM_MASK			GENMASK_32(31, 16)
+#define _DWC3_DEPCMD_COMMANDPARAM_SHIFT			16
+
+/* _DWC3_DEV_IMOD register fields */
+#define _DWC3_DEV_IMOD_DEVICE_IMODI_MASK		GENMASK_32(15, 0)
+#define _DWC3_DEV_IMOD_DEVICE_IMODI_SHIFT		0
+#define _DWC3_DEV_IMOD_DEVICE_IMODC_MASK		GENMASK_32(31, 16)
+#define _DWC3_DEV_IMOD_DEVICE_IMODC_SHIFT		16
+
+/*
+ * USB3 BC Register Block
+ */
+#define _DWC3_BCFG					U(0x0)
+#define _DWC3_BCEVT					U(0x8)
+#define _DWC3_BCEVTEN					U(0xC)
+
+/* _DWC3_BCFG register fields */
+#define _DWC3_BCFG_CHIRP_EN				BIT_32(0)
+#define _DWC3_BCFG_IDDIG_SEL				BIT_32(1)
+
+/* _DWC3_BCEVT register fields */
+#define _DWC3_BCEVT_MULTVALIDBC_MASK			GENMASK_32(4, 0)
+#define _DWC3_BCEVT_MULTVALIDBC_SHIFT			0
+#define _DWC3_BCEVT_MV_CHNGEVNT				BIT_32(24)
+
+/* _DWC3_BCEVTEN register fields */
+#define _DWC3_BCEVTEN_MV_CHNGEVNTENA			BIT_32(24)
+
+/*
+ * USB3 eXtensible Host Controller Capability Register Block
+ */
+#define _DWC3_CAPLENGTH					U(0x0)
+#define _DWC3_HCSPARAMS1				U(0x4)
+#define _DWC3_HCSPARAMS2				U(0x8)
+#define _DWC3_HCSPARAMS3				U(0xC)
+#define _DWC3_HCCPARAMS1				U(0x10)
+#define _DWC3_DBOFF					U(0x14)
+#define _DWC3_RTSOFF					U(0x18)
+#define _DWC3_HCCPARAMS2				U(0x1C)
+
+/* _DWC3_CAPLENGTH register fields */
+#define _DWC3_CAPLENGTH_CAPLENGTH_MASK			GENMASK_32(7, 0)
+#define _DWC3_CAPLENGTH_CAPLENGTH_SHIFT			0
+#define _DWC3_CAPLENGTH_HCIVERSION_MASK			GENMASK_32(31, 16)
+#define _DWC3_CAPLENGTH_HCIVERSION_SHIFT		16
+
+/* _DWC3_HCSPARAMS1 register fields */
+#define _DWC3_HCSPARAMS1_MAXSLOTS_MASK			GENMASK_32(7, 0)
+#define _DWC3_HCSPARAMS1_MAXSLOTS_SHIFT			0
+#define _DWC3_HCSPARAMS1_MAXINTRS_MASK			GENMASK_32(18, 8)
+#define _DWC3_HCSPARAMS1_MAXINTRS_SHIFT			8
+#define _DWC3_HCSPARAMS1_MAXPORTS_MASK			GENMASK_32(31, 24)
+#define _DWC3_HCSPARAMS1_MAXPORTS_SHIFT			24
+
+/* _DWC3_HCSPARAMS2 register fields */
+#define _DWC3_HCSPARAMS2_IST_MASK			GENMASK_32(3, 0)
+#define _DWC3_HCSPARAMS2_IST_SHIFT			0
+#define _DWC3_HCSPARAMS2_ERSTMAX_MASK			GENMASK_32(7, 4)
+#define _DWC3_HCSPARAMS2_ERSTMAX_SHIFT			4
+#define _DWC3_HCSPARAMS2_MAXSCRATCHPADBUFS_HI_MASK	GENMASK_32(25, 21)
+#define _DWC3_HCSPARAMS2_MAXSCRATCHPADBUFS_HI_SHIFT	21
+#define _DWC3_HCSPARAMS2_SPR				BIT_32(26)
+#define _DWC3_HCSPARAMS2_MAXSCRATCHPADBUFS_MASK		GENMASK_32(31, 27)
+#define _DWC3_HCSPARAMS2_MAXSCRATCHPADBUFS_SHIFT	27
+
+/* _DWC3_HCSPARAMS3 register fields */
+#define _DWC3_HCSPARAMS3_U1_DEVICE_EXIT_LAT_MASK	GENMASK_32(7, 0)
+#define _DWC3_HCSPARAMS3_U1_DEVICE_EXIT_LAT_SHIFT	0
+#define _DWC3_HCSPARAMS3_U2_DEVICE_EXIT_LAT_MASK	GENMASK_32(31, 16)
+#define _DWC3_HCSPARAMS3_U2_DEVICE_EXIT_LAT_SHIFT	16
+
+/* _DWC3_HCCPARAMS1 register fields */
+#define _DWC3_HCCPARAMS1_AC64				BIT_32(0)
+#define _DWC3_HCCPARAMS1_BNC				BIT_32(1)
+#define _DWC3_HCCPARAMS1_CSZ				BIT_32(2)
+#define _DWC3_HCCPARAMS1_PPC				BIT_32(3)
+#define _DWC3_HCCPARAMS1_PIND				BIT_32(4)
+#define _DWC3_HCCPARAMS1_LHRC				BIT_32(5)
+#define _DWC3_HCCPARAMS1_LTC				BIT_32(6)
+#define _DWC3_HCCPARAMS1_NSS				BIT_32(7)
+#define _DWC3_HCCPARAMS1_PAE				BIT_32(8)
+#define _DWC3_HCCPARAMS1_SPC				BIT_32(9)
+#define _DWC3_HCCPARAMS1_SEC				BIT_32(10)
+#define _DWC3_HCCPARAMS1_CFC				BIT_32(11)
+#define _DWC3_HCCPARAMS1_MAXPSASIZE_MASK		GENMASK_32(15, 12)
+#define _DWC3_HCCPARAMS1_MAXPSASIZE_SHIFT		12
+#define _DWC3_HCCPARAMS1_XECP_MASK			GENMASK_32(31, 16)
+#define _DWC3_HCCPARAMS1_XECP_SHIFT			16
+
+/* _DWC3_DBOFF register fields */
+#define _DWC3_DBOFF_DOORBELL_ARRAY_OFFSET_MASK		GENMASK_32(31, 2)
+#define _DWC3_DBOFF_DOORBELL_ARRAY_OFFSET_SHIFT		2
+
+/* _DWC3_RTSOFF register fields */
+#define _DWC3_RTSOFF_RUNTIME_REG_SPACE_OFFSET_MASK	GENMASK_32(31, 5)
+#define _DWC3_RTSOFF_RUNTIME_REG_SPACE_OFFSET_SHIFT	5
+
+/* _DWC3_HCCPARAMS2 register fields */
+#define _DWC3_HCCPARAMS2_U3C				BIT_32(0)
+#define _DWC3_HCCPARAMS2_CMC				BIT_32(1)
+#define _DWC3_HCCPARAMS2_FSC				BIT_32(2)
+#define _DWC3_HCCPARAMS2_CTC				BIT_32(3)
+#define _DWC3_HCCPARAMS2_LEC				BIT_32(4)
+#define _DWC3_HCCPARAMS2_CIC				BIT_32(5)
+
+/*
+ * USB3 Host Cntrl Oper Regs Block
+ */
+#define _DWC3_USBCMD					U(0x0)
+#define _DWC3_USBSTS					U(0x4)
+#define _DWC3_PAGESIZE					U(0x8)
+#define _DWC3_DNCTRL					U(0x14)
+#define _DWC3_CRCR_LO					U(0x18)
+#define _DWC3_CRCR_HI					U(0x1C)
+#define _DWC3_DCBAAP_LO					U(0x30)
+#define _DWC3_DCBAAP_HI					U(0x34)
+#define _DWC3_CONFIG					U(0x38)
+
+/* _DWC3_USBCMD register fields */
+#define _DWC3_USBCMD_R_S				BIT_32(0)
+#define _DWC3_USBCMD_HCRST				BIT_32(1)
+#define _DWC3_USBCMD_INTE				BIT_32(2)
+#define _DWC3_USBCMD_HSEE				BIT_32(3)
+#define _DWC3_USBCMD_LHCRST				BIT_32(7)
+#define _DWC3_USBCMD_CSS				BIT_32(8)
+#define _DWC3_USBCMD_CRS				BIT_32(9)
+#define _DWC3_USBCMD_EWE				BIT_32(10)
+#define _DWC3_USBCMD_EU3S				BIT_32(11)
+#define _DWC3_USBCMD_CME				BIT_32(13)
+
+/* _DWC3_USBSTS register fields */
+#define _DWC3_USBSTS_HCH				BIT_32(0)
+#define _DWC3_USBSTS_HSE				BIT_32(2)
+#define _DWC3_USBSTS_EINT				BIT_32(3)
+#define _DWC3_USBSTS_PCD				BIT_32(4)
+#define _DWC3_USBSTS_SSS				BIT_32(8)
+#define _DWC3_USBSTS_RSS				BIT_32(9)
+#define _DWC3_USBSTS_SRE				BIT_32(10)
+#define _DWC3_USBSTS_CNR				BIT_32(11)
+#define _DWC3_USBSTS_HCE				BIT_32(12)
+
+/* _DWC3_PAGESIZE register fields */
+#define _DWC3_PAGESIZE_PAGE_SIZE_MASK			GENMASK_32(15, 0)
+#define _DWC3_PAGESIZE_PAGE_SIZE_SHIFT			0
+
+/* _DWC3_DNCTRL register fields */
+#define _DWC3_DNCTRL_N0_N15_MASK			GENMASK_32(15, 0)
+#define _DWC3_DNCTRL_N0_N15_SHIFT			0
+
+/* _DWC3_CRCR_LO register fields */
+#define _DWC3_CRCR_LO_RCS				BIT_32(0)
+#define _DWC3_CRCR_LO_CS				BIT_32(1)
+#define _DWC3_CRCR_LO_CA				BIT_32(2)
+#define _DWC3_CRCR_LO_CRR				BIT_32(3)
+#define _DWC3_CRCR_LO_CMD_RING_PNTR_MASK		GENMASK_32(31, 6)
+#define _DWC3_CRCR_LO_CMD_RING_PNTR_SHIFT		6
+
+/* _DWC3_DCBAAP_LO register fields */
+#define _DWC3_DCBAAP_LO_DEVICE_CONTEXT_BAAP_MASK	GENMASK_32(31, 6)
+#define _DWC3_DCBAAP_LO_DEVICE_CONTEXT_BAAP_SHIFT	6
+
+/* _DWC3_CONFIG register fields */
+#define _DWC3_CONFIG_MAXSLOTSEN_MASK			GENMASK_32(7, 0)
+#define _DWC3_CONFIG_MAXSLOTSEN_SHIFT			0
+#define _DWC3_CONFIG_U3E				BIT_32(8)
+#define _DWC3_CONFIG_CIE				BIT_32(9)
+
+/*
+ * USB3 Host Cntrl Port Reg Set Block
+ */
+#define _DWC3_PORTSC_20					U(0x0)
+#define _DWC3_PORTPMSC_20				U(0x4)
+#define _DWC3_PORTLI_20					U(0x8)
+#define _DWC3_PORTHLPMC_20				U(0xc)
+#define _DWC3_PORTSC_30					U(0x10)
+#define _DWC3_PORTPMSC_30				U(0x14)
+#define _DWC3_PORTLI_30					U(0x18)
+#define _DWC3_PORTHLPMC_30				U(0x1c)
+
+/* _DWC3_PORTSC_20 register fields */
+#define _DWC3_PORTSC_20_CCS				BIT_32(0)
+#define _DWC3_PORTSC_20_PED				BIT_32(1)
+#define _DWC3_PORTSC_20_OCA				BIT_32(3)
+#define _DWC3_PORTSC_20_PR				BIT_32(4)
+#define _DWC3_PORTSC_20_PLS_MASK			GENMASK_32(8, 5)
+#define _DWC3_PORTSC_20_PLS_SHIFT			5
+#define _DWC3_PORTSC_20_PP				BIT_32(9)
+#define _DWC3_PORTSC_20_PORTSPEED_MASK			GENMASK_32(13, 10)
+#define _DWC3_PORTSC_20_PORTSPEED_SHIFT			10
+#define _DWC3_PORTSC_20_PIC_MASK			GENMASK_32(15, 14)
+#define _DWC3_PORTSC_20_PIC_SHIFT			14
+#define _DWC3_PORTSC_20_LWS				BIT_32(16)
+#define _DWC3_PORTSC_20_CSC				BIT_32(17)
+#define _DWC3_PORTSC_20_PEC				BIT_32(18)
+#define _DWC3_PORTSC_20_OCC				BIT_32(20)
+#define _DWC3_PORTSC_20_PRC				BIT_32(21)
+#define _DWC3_PORTSC_20_PLC				BIT_32(22)
+#define _DWC3_PORTSC_20_CAS				BIT_32(24)
+#define _DWC3_PORTSC_20_WCE				BIT_32(25)
+#define _DWC3_PORTSC_20_WDE				BIT_32(26)
+#define _DWC3_PORTSC_20_WOE				BIT_32(27)
+#define _DWC3_PORTSC_20_DR				BIT_32(30)
+
+/* _DWC3_PORTPMSC_20 register fields */
+#define _DWC3_PORTPMSC_20_L1S_MASK			GENMASK_32(2, 0)
+#define _DWC3_PORTPMSC_20_L1S_SHIFT			0
+#define _DWC3_PORTPMSC_20_RWE				BIT_32(3)
+#define _DWC3_PORTPMSC_20_HIRD_MASK			GENMASK_32(7, 4)
+#define _DWC3_PORTPMSC_20_HIRD_SHIFT			4
+#define _DWC3_PORTPMSC_20_L1DSLOT_MASK			GENMASK_32(15, 8)
+#define _DWC3_PORTPMSC_20_L1DSLOT_SHIFT			8
+#define _DWC3_PORTPMSC_20_HLE				BIT_32(16)
+#define _DWC3_PORTPMSC_20_PRTTSTCTRL_MASK		GENMASK_32(31, 28)
+#define _DWC3_PORTPMSC_20_PRTTSTCTRL_SHIFT		28
+
+/* _DWC3_PORTHLPMC_20 register fields */
+#define _DWC3_PORTHLPMC_20_HIRDM_MASK			GENMASK_32(1, 0)
+#define _DWC3_PORTHLPMC_20_HIRDM_SHIFT			0
+#define _DWC3_PORTHLPMC_20_L1_TIMEOUT_MASK		GENMASK_32(9, 2)
+#define _DWC3_PORTHLPMC_20_L1_TIMEOUT_SHIFT		2
+#define _DWC3_PORTHLPMC_20_HIRDD_MASK			GENMASK_32(13, 10)
+#define _DWC3_PORTHLPMC_20_HIRDD_SHIFT			10
+
+/* _DWC3_PORTSC_30 register fields */
+#define _DWC3_PORTSC_30_CCS				BIT_32(0)
+#define _DWC3_PORTSC_30_PED				BIT_32(1)
+#define _DWC3_PORTSC_30_OCA				BIT_32(3)
+#define _DWC3_PORTSC_30_PR				BIT_32(4)
+#define _DWC3_PORTSC_30_PLS_MASK			GENMASK_32(8, 5)
+#define _DWC3_PORTSC_30_PLS_SHIFT			5
+#define _DWC3_PORTSC_30_PP				BIT_32(9)
+#define _DWC3_PORTSC_30_PORTSPEED_MASK			GENMASK_32(13, 10)
+#define _DWC3_PORTSC_30_PORTSPEED_SHIFT			10
+#define _DWC3_PORTSC_30_PIC_MASK			GENMASK_32(15, 14)
+#define _DWC3_PORTSC_30_PIC_SHIFT			14
+#define _DWC3_PORTSC_30_LWS				BIT_32(16)
+#define _DWC3_PORTSC_30_CSC				BIT_32(17)
+#define _DWC3_PORTSC_30_PEC				BIT_32(18)
+#define _DWC3_PORTSC_30_WRC				BIT_32(19)
+#define _DWC3_PORTSC_30_OCC				BIT_32(20)
+#define _DWC3_PORTSC_30_PRC				BIT_32(21)
+#define _DWC3_PORTSC_30_PLC				BIT_32(22)
+#define _DWC3_PORTSC_30_CEC				BIT_32(23)
+#define _DWC3_PORTSC_30_CAS				BIT_32(24)
+#define _DWC3_PORTSC_30_WCE				BIT_32(25)
+#define _DWC3_PORTSC_30_WDE				BIT_32(26)
+#define _DWC3_PORTSC_30_WOE				BIT_32(27)
+#define _DWC3_PORTSC_30_DR				BIT_32(30)
+#define _DWC3_PORTSC_30_WPR				BIT_32(31)
+
+/* _DWC3_PORTPMSC_30 register fields */
+#define _DWC3_PORTPMSC_30_U1_TIMEOUT_MASK		GENMASK_32(7, 0)
+#define _DWC3_PORTPMSC_30_U1_TIMEOUT_SHIFT		0
+#define _DWC3_PORTPMSC_30_U2_TIMEOUT_MASK		GENMASK_32(15, 8)
+#define _DWC3_PORTPMSC_30_U2_TIMEOUT_SHIFT		8
+#define _DWC3_PORTPMSC_30_FLA				BIT_32(16)
+
+/* _DWC3_PORTLI_30 register fields */
+#define _DWC3_PORTLI_30_LINK_ERROR_COUNT_MASK		GENMASK_32(15, 0)
+#define _DWC3_PORTLI_30_LINK_ERROR_COUNT_SHIFT		0
+
+/*
+ * USB3 Host Cntrl Runtime Regs Block
+ */
+#define _DWC3_MFINDEX					U(0x0)
+
+/* _DWC3_MFINDEX register fields */
+#define _DWC3_MFINDEX_MICROFRAME_INDEX_MASK		GENMASK_32(13, 0)
+#define _DWC3_MFINDEX_MICROFRAME_INDEX_SHIFT		0
+
+/*
+ * USB3 Interrupter Regs Block
+ */
+#define _DWC3_IMAN					U(0x0)
+#define _DWC3_IMOD					U(0x4)
+#define _DWC3_ERSTSZ					U(0x8)
+#define _DWC3_ERSTBA_LO					U(0x10)
+#define _DWC3_ERSTBA_HI					U(0x14)
+#define _DWC3_ERDP_LO					U(0x18)
+#define _DWC3_ERDP_HI					U(0x1c)
+
+/* _DWC3_IMAN register fields */
+#define _DWC3_IMAN_IP					BIT_32(0)
+#define _DWC3_IMAN_IE					BIT_32(1)
+
+/* _DWC3_IMOD register fields */
+#define _DWC3_IMOD_IMODI_MASK				GENMASK_32(15, 0)
+#define _DWC3_IMOD_IMODI_SHIFT				0
+#define _DWC3_IMOD_IMODC_MASK				GENMASK_32(31, 16)
+#define _DWC3_IMOD_IMODC_SHIFT				16
+
+/* _DWC3_ERSTSZ register fields */
+#define _DWC3_ERSTSZ_ERS_TABLE_SIZE_MASK		GENMASK_32(15, 0)
+#define _DWC3_ERSTSZ_ERS_TABLE_SIZE_SHIFT		0
+
+/* _DWC3_ERSTBA_LO register fields */
+#define _DWC3_ERSTBA_LO_ERS_TABLE_BAR_MASK		GENMASK_32(31, 6)
+#define _DWC3_ERSTBA_LO_ERS_TABLE_BAR_SHIFT		6
+
+/* _DWC3_ERDP_LO register fields */
+#define _DWC3_ERDP_LO_DESI_MASK				GENMASK_32(2, 0)
+#define _DWC3_ERDP_LO_DESI_SHIFT			0
+#define _DWC3_ERDP_LO_EHB				BIT_32(3)
+#define _DWC3_ERDP_LO_ERD_PNTR_MASK			GENMASK_32(31, 4)
+#define _DWC3_ERDP_LO_ERD_PNTR_SHIFT			4
+
+/*
+ * USB3 Doorbell Reg Block
+ */
+#define _DWC3_DB					U(0x0)
+
+/* _DWC3_DB register fields */
+#define _DWC3_DB_DB_TARGET_MASK				GENMASK_32(7, 0)
+#define _DWC3_DB_DB_TARGET_SHIFT			0
+#define _DWC3_DB_DB_STREAM_ID_MASK			GENMASK_32(31, 16)
+#define _DWC3_DB_DB_STREAM_ID_SHIFT			16
+
+/*
+ * USB3 internal RAM0 Register Block
+
+ * For a description of this standard USB register field, see the eXtensible Host Controller
+ * Interface for Universal Serial Bus (USB) Specification 3.0.
+
+ */
+
+/*
+ * USB3 internal RAM1 Register Block
+
+ * For a description of this standard USB register field, see the eXtensible Host Controller
+ * Interface for Universal Serial Bus (USB) Specification 3.0.
+
+ */
+
+/*
+ * USB3 internal RAM2 Register Block
+ */
+
+/*
+ * USB3 HC Extended Capability Register Block
+ */
+#define _DWC3_USBLEGSUP					U(0x0)
+#define _DWC3_USBLEGCTLSTS				U(0x4)
+
+/* _DWC3_USBLEGSUP register fields */
+#define _DWC3_USBLEGSUP_CAPABILITY_ID_MASK		GENMASK_32(7, 0)
+#define _DWC3_USBLEGSUP_CAPABILITY_ID_SHIFT		0
+#define _DWC3_USBLEGSUP_NEXT_CAPABILITY_POINTER_MASK	GENMASK_32(15, 8)
+#define _DWC3_USBLEGSUP_NEXT_CAPABILITY_POINTER_SHIFT	8
+#define _DWC3_USBLEGSUP_HC_BIOS_OWNED			BIT_32(16)
+#define _DWC3_USBLEGSUP_HC_OS_OWNED			BIT_32(24)
+
+/* _DWC3_USBLEGCTLSTS register fields */
+#define _DWC3_USBLEGCTLSTS_USB_SMI_ENABLE		BIT_32(0)
+#define _DWC3_USBLEGCTLSTS_SMI_ON_HOST_E		BIT_32(4)
+#define _DWC3_USBLEGCTLSTS_SMI_ON_OS_E			BIT_32(13)
+#define _DWC3_USBLEGCTLSTS_SMI_ON_PCI_E			BIT_32(14)
+#define _DWC3_USBLEGCTLSTS_SMI_ON_BAR_E			BIT_32(15)
+#define _DWC3_USBLEGCTLSTS_SMI_ON_EVENT			BIT_32(16)
+#define _DWC3_USBLEGCTLSTS_SMI_ON_HOST			BIT_32(20)
+#define _DWC3_USBLEGCTLSTS_SMI_ON_OS			BIT_32(29)
+#define _DWC3_USBLEGCTLSTS_SMI_ON_PCI			BIT_32(30)
+#define _DWC3_USBLEGCTLSTS_SMI_ON_BAR			BIT_32(31)
+
+/*
+ * USB3 xHCI Supported Protocol Capability (USB 2.0) Block
+ */
+#define _DWC3_SUPTPRT2_DW0				U(0x0)
+#define _DWC3_SUPTPRT2_DW1				U(0x4)
+#define _DWC3_SUPTPRT2_DW2				U(0x8)
+#define _DWC3_SUPTPRT2_DW3				U(0xC)
+
+/* _DWC3_SUPTPRT2_DW0 register fields */
+#define _DWC3_SUPTPRT2_DW0_CAPABILITY_ID_MASK		GENMASK_32(7, 0)
+#define _DWC3_SUPTPRT2_DW0_CAPABILITY_ID_SHIFT		0
+#define _DWC3_SUPTPRT2_DW0_NEXT_CAPABILITY_POINTER_MASK	GENMASK_32(15, 8)
+#define _DWC3_SUPTPRT2_DW0_NEXT_CAPABILITY_POINTER_SHIFT	8
+#define _DWC3_SUPTPRT2_DW0_MINOR_REVISION_MASK		GENMASK_32(23, 16)
+#define _DWC3_SUPTPRT2_DW0_MINOR_REVISION_SHIFT		16
+#define _DWC3_SUPTPRT2_DW0_MAJOR_REVISION_MASK		GENMASK_32(31, 24)
+#define _DWC3_SUPTPRT2_DW0_MAJOR_REVISION_SHIFT		24
+
+/* _DWC3_SUPTPRT2_DW2 register fields */
+#define _DWC3_SUPTPRT2_DW2_COMPATIBLE_PORT_OFFSET_MASK	GENMASK_32(7, 0)
+#define _DWC3_SUPTPRT2_DW2_COMPATIBLE_PORT_OFFSET_SHIFT	0
+#define _DWC3_SUPTPRT2_DW2_COMPATIBLE_PORT_COUNT_MASK	GENMASK_32(15, 8)
+#define _DWC3_SUPTPRT2_DW2_COMPATIBLE_PORT_COUNT_SHIFT	8
+#define _DWC3_SUPTPRT2_DW2_HSO				BIT_32(17)
+#define _DWC3_SUPTPRT2_DW2_IHI				BIT_32(18)
+#define _DWC3_SUPTPRT2_DW2_HLC				BIT_32(19)
+#define _DWC3_SUPTPRT2_DW2_BLC				BIT_32(20)
+#define _DWC3_SUPTPRT2_DW2_MHD_MASK			GENMASK_32(27, 25)
+#define _DWC3_SUPTPRT2_DW2_MHD_SHIFT			25
+#define _DWC3_SUPTPRT2_DW2_PSIC_MASK			GENMASK_32(31, 28)
+#define _DWC3_SUPTPRT2_DW2_PSIC_SHIFT			28
+
+/* _DWC3_SUPTPRT2_DW3 register fields */
+#define _DWC3_SUPTPRT2_DW3_PROTCL_SLT_TY_MASK		GENMASK_32(4, 0)
+#define _DWC3_SUPTPRT2_DW3_PROTCL_SLT_TY_SHIFT		0
+
+/*
+ * USB3 xHCI Supported Protocol Capability (USB 3.0) Block
+ */
+#define _DWC3_SUPTPRT3_DW0				U(0x0)
+#define _DWC3_SUPTPRT3_DW1				U(0x4)
+#define _DWC3_SUPTPRT3_DW2				U(0x8)
+#define _DWC3_SUPTPRT3_DW3				U(0xC)
+
+/* _DWC3_SUPTPRT3_DW0 register fields */
+#define _DWC3_SUPTPRT3_DW0_CAPABILITY_ID_MASK		GENMASK_32(7, 0)
+#define _DWC3_SUPTPRT3_DW0_CAPABILITY_ID_SHIFT		0
+#define _DWC3_SUPTPRT3_DW0_NEXT_CAPABILITY_POINTER_MASK	GENMASK_32(15, 8)
+#define _DWC3_SUPTPRT3_DW0_NEXT_CAPABILITY_POINTER_SHIFT	8
+#define _DWC3_SUPTPRT3_DW0_MINOR_REVISION_MASK		GENMASK_32(23, 16)
+#define _DWC3_SUPTPRT3_DW0_MINOR_REVISION_SHIFT		16
+#define _DWC3_SUPTPRT3_DW0_MAJOR_REVISION_MASK		GENMASK_32(31, 24)
+#define _DWC3_SUPTPRT3_DW0_MAJOR_REVISION_SHIFT		24
+
+/* _DWC3_SUPTPRT3_DW2 register fields */
+#define _DWC3_SUPTPRT3_DW2_COMPATIBLE_PORT_OFFSET_MASK	GENMASK_32(7, 0)
+#define _DWC3_SUPTPRT3_DW2_COMPATIBLE_PORT_OFFSET_SHIFT	0
+#define _DWC3_SUPTPRT3_DW2_COMPATIBLE_PORT_COUNT_MASK	GENMASK_32(15, 8)
+#define _DWC3_SUPTPRT3_DW2_COMPATIBLE_PORT_COUNT_SHIFT	8
+#define _DWC3_SUPTPRT3_DW2_MHD_MASK			GENMASK_32(27, 25)
+#define _DWC3_SUPTPRT3_DW2_MHD_SHIFT			25
+#define _DWC3_SUPTPRT3_DW2_PSIC_MASK			GENMASK_32(31, 28)
+#define _DWC3_SUPTPRT3_DW2_PSIC_SHIFT			28
+
+/* _DWC3_SUPTPRT3_DW3 register fields */
+#define _DWC3_SUPTPRT3_DW3_PROTCL_SLT_TY_MASK		GENMASK_32(4, 0)
+#define _DWC3_SUPTPRT3_DW3_PROTCL_SLT_TY_SHIFT		0
+
+#endif /* __USB_DWC3_REGS_H */
diff --git a/drivers/usb/usb_device.c b/drivers/usb/usb_device.c
index 031e67846..b71943fb2 100644
--- a/drivers/usb/usb_device.c
+++ b/drivers/usb/usb_device.c
@@ -10,17 +10,6 @@
 #include <common/debug.h>
 #include <drivers/usb_device.h>
 
-/* Define for EP address */
-#define EP_DIR_MASK		BIT(7)
-#define EP_DIR_IN		BIT(7)
-#define EP_NUM_MASK		GENMASK(3, 0)
-
-#define EP0_IN			(0U | EP_DIR_IN)
-#define EP0_OUT			0U
-
-/* USB address between 1 through 127 = 0x7F mask */
-#define ADDRESS_MASK		GENMASK(6, 0)
-
 /*
  * Set a STALL condition over an endpoint
  * pdev: USB handle
@@ -47,7 +36,7 @@ static enum usb_status usb_core_set_stall(struct usb_handle *pdev, uint8_t ep_ad
 	ep->num = num;
 
 	pdev->driver->ep_set_stall(hpcd->instance, ep);
-	if (num == 0U) {
+	if (ep_addr == EP0_OUT) {
 		pdev->driver->ep0_out_start(hpcd->instance);
 	}
 
@@ -711,7 +700,11 @@ enum usb_status usb_core_receive_ep0(struct usb_handle *pdev, uint8_t *buf,
 	}
 
 	pdev->ep_out[0].total_length = len;
+#ifdef USB_CORE_AVOID_PACKET_SPLIT_MPS
+	pdev->ep_out[0].rem_length = 0;
+#else
 	pdev->ep_out[0].rem_length = len;
+#endif
 
 	/* Start the transfer */
 	return usb_core_receive(pdev, 0U, buf, len);
@@ -736,7 +729,11 @@ enum usb_status usb_core_transmit_ep0(struct usb_handle *pdev, uint8_t *buf,
 	}
 
 	pdev->ep_in[0].total_length = len;
+#ifdef USB_CORE_AVOID_PACKET_SPLIT_MPS
+	pdev->ep_in[0].rem_length = 0;
+#else
 	pdev->ep_in[0].rem_length = len;
+#endif
 
 	/* Start the transfer */
 	return usb_core_transmit(pdev, 0U, buf, len);
diff --git a/fdts/stm32mp1-cot-descriptors.dtsi b/fdts/stm32mp1-cot-descriptors.dtsi
new file mode 100644
index 000000000..c47b2e737
--- /dev/null
+++ b/fdts/stm32mp1-cot-descriptors.dtsi
@@ -0,0 +1,158 @@
+/*
+ * Copyright (c) 2020-2022, ARM Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <tools_share/tbbr_oid.h>
+#include <common/tbbr/tbbr_img_def.h>
+#include <common/nv_cntr_ids.h>
+
+cot {
+	manifests {
+		compatible = "arm, cert-descs";
+
+		stm32mp_cfg_cert: stm32mp_cfg_cert {
+			root-certificate;
+			image-id = <STM32MP_CONFIG_CERT_ID>;
+			antirollback-counter = <&trusted_nv_counter>;
+
+			hw_config_hash: hw_config_hash {
+				oid = HW_CONFIG_HASH_OID;
+			};
+
+			fw_config_hash: fw_config_hash {
+				oid = FW_CONFIG_HASH_OID;
+			};
+		};
+
+		trusted_key_cert: trusted_key_cert {
+			root-certificate;
+			image-id = <TRUSTED_KEY_CERT_ID>;
+			antirollback-counter = <&trusted_nv_counter>;
+
+			trusted_world_pk: trusted_world_pk {
+				oid = TRUSTED_WORLD_PK_OID;
+			};
+			non_trusted_world_pk: non_trusted_world_pk {
+				oid = NON_TRUSTED_WORLD_PK_OID;
+			};
+		};
+
+		trusted_os_fw_key_cert: trusted_os_fw_key_cert {
+			image-id = <TRUSTED_OS_FW_KEY_CERT_ID>;
+			parent = <&trusted_key_cert>;
+			signing-key = <&trusted_world_pk>;
+			antirollback-counter = <&trusted_nv_counter>;
+
+			tos_fw_content_pk: tos_fw_content_pk {
+				oid = TRUSTED_OS_FW_CONTENT_CERT_PK_OID;
+			};
+		};
+
+		trusted_os_fw_content_cert: trusted_os_fw_content_cert {
+			image-id = <TRUSTED_OS_FW_CONTENT_CERT_ID>;
+			parent = <&trusted_os_fw_key_cert>;
+			signing-key = <&tos_fw_content_pk>;
+			antirollback-counter = <&trusted_nv_counter>;
+
+			tos_fw_hash: tos_fw_hash {
+				oid = TRUSTED_OS_FW_HASH_OID;
+			};
+			tos_fw_extra1_hash: tos_fw_extra1_hash {
+				oid = TRUSTED_OS_FW_EXTRA1_HASH_OID;
+			};
+			tos_fw_extra2_hash: tos_fw_extra2_hash {
+				oid = TRUSTED_OS_FW_EXTRA2_HASH_OID;
+			};
+			tos_fw_config_hash: tos_fw_config_hash {
+				oid = TRUSTED_OS_FW_CONFIG_HASH_OID;
+			};
+		};
+
+		non_trusted_fw_key_cert: non_trusted_fw_key_cert {
+			image-id = <NON_TRUSTED_FW_KEY_CERT_ID>;
+			parent = <&trusted_key_cert>;
+			signing-key = <&non_trusted_world_pk>;
+			antirollback-counter = <&non_trusted_nv_counter>;
+
+			nt_fw_content_pk: nt_fw_content_pk {
+				oid = NON_TRUSTED_FW_CONTENT_CERT_PK_OID;
+			};
+		};
+
+		non_trusted_fw_content_cert: non_trusted_fw_content_cert {
+			image-id = <NON_TRUSTED_FW_CONTENT_CERT_ID>;
+			parent = <&non_trusted_fw_key_cert>;
+			signing-key = <&nt_fw_content_pk>;
+			antirollback-counter = <&non_trusted_nv_counter>;
+
+			nt_world_bl_hash: nt_world_bl_hash {
+				oid = NON_TRUSTED_WORLD_BOOTLOADER_HASH_OID;
+			};
+		};
+	};
+
+	images {
+		compatible = "arm, img-descs";
+
+		hw_config {
+			image-id = <HW_CONFIG_ID>;
+			parent = <&stm32mp_cfg_cert>;
+			hash = <&hw_config_hash>;
+		};
+
+		fw_config {
+			image-id = <FW_CONFIG_ID>;
+			parent = <&stm32mp_cfg_cert>;
+			hash = <&fw_config_hash>;
+		};
+
+		bl32_image {
+			image-id = <BL32_IMAGE_ID>;
+			parent = <&trusted_os_fw_content_cert>;
+			hash = <&tos_fw_hash>;
+		};
+
+		bl32_extra1_image {
+			image-id = <BL32_EXTRA1_IMAGE_ID>;
+			parent = <&trusted_os_fw_content_cert>;
+			hash = <&tos_fw_extra1_hash>;
+		};
+
+		bl32_extra2_image {
+			image-id = <BL32_EXTRA2_IMAGE_ID>;
+			parent = <&trusted_os_fw_content_cert>;
+			hash = <&tos_fw_extra2_hash>;
+		};
+
+		tos_fw_config {
+			image-id = <TOS_FW_CONFIG_ID>;
+			parent = <&trusted_os_fw_content_cert>;
+			hash = <&tos_fw_config_hash>;
+		};
+
+		bl33_image {
+			image-id = <BL33_IMAGE_ID>;
+			parent = <&non_trusted_fw_content_cert>;
+			hash = <&nt_world_bl_hash>;
+		};
+	};
+};
+
+non_volatile_counters: non_volatile_counters {
+	compatible = "arm, non-volatile-counter";
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	trusted_nv_counter: trusted_nv_counter {
+		id  = <TRUSTED_NV_CTR_ID>;
+		oid = TRUSTED_FW_NVCOUNTER_OID;
+	};
+
+	non_trusted_nv_counter: non_trusted_nv_counter {
+		id  = <NON_TRUSTED_NV_CTR_ID>;
+		oid = NON_TRUSTED_FW_NVCOUNTER_OID;
+	};
+};
diff --git a/fdts/stm32mp13-bl2.dtsi b/fdts/stm32mp13-bl2.dtsi
new file mode 100644
index 000000000..983d66b66
--- /dev/null
+++ b/fdts/stm32mp13-bl2.dtsi
@@ -0,0 +1,87 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2020 - All Rights Reserved
+ */
+
+/ {
+	aliases {
+#if !STM32MP_EMMC && !STM32MP_SDMMC
+		/delete-property/ mmc0;
+#endif
+	};
+
+	soc {
+#if !STM32MP_USB_PROGRAMMER
+		/delete-node/ usb-otg@49000000;
+#endif
+#if !STM32MP_RAW_NAND
+		/delete-node/ memory-controller@58002000;
+#endif
+#if !STM32MP_SPI_NAND && !STM32MP_SPI_NOR
+		/delete-node/ spi@58003000;
+#endif
+#if !STM32MP_EMMC && !STM32MP_SDMMC
+		/delete-node/ mmc@58005000;
+		/delete-node/ mmc@58007000;
+#endif
+#if !STM32MP_USB_PROGRAMMER
+		/delete-node/ usbh-ohci@5800c000;
+		/delete-node/ usbh-ehci@5800d000;
+#endif
+#if !STM32MP_USB_PROGRAMMER
+		/delete-node/ usbphyc@5a006000;
+#endif
+
+		pinctrl@50002000 {
+#if !STM32MP_EMMC && !STM32MP_SDMMC
+			/delete-node/ sdmmc1-b4-0;
+			/delete-node/ sdmmc2-b4-0;
+#endif
+		};
+	};
+
+	/*
+	 * UUID's here are UUID RFC 4122 compliant meaning fieds are stored in
+	 * network order (big endian)
+	 */
+
+	st-io_policies {
+		fip-handles {
+			compatible = "st,io-fip-handle";
+			fw_cfg_uuid = "5807e16a-8459-47be-8ed5-648e8dddab0e";
+			bl32_uuid = "05d0e189-53dc-1347-8d2b-500a4b7a3e38";
+			bl32_extra1_uuid = "0b70c29b-2a5a-7840-9f65-0a5682738288";
+			bl32_extra2_uuid = "8ea87bb1-cfa2-3f4d-85fd-e7bba50220d9";
+			bl33_uuid = "d6d0eea7-fcea-d54b-9782-9934f234b6e4";
+			hw_cfg_uuid = "08b8f1d9-c9cf-9349-a962-6fbc6b7265cc";
+			tos_fw_cfg_uuid = "26257c1a-dbc6-7f47-8d96-c4c4b0248021";
+#if TRUSTED_BOARD_BOOT
+			stm32mp_cfg_cert_uuid = "501d8dd2-8bce-49a5-84eb-559a9f2eaeaf";
+			t_key_cert_uuid = "827ee890-f860-e411-a1b4-777a21b4f94c";
+			tos_fw_key_cert_uuid = "9477d603-fb60-e411-85dd-b7105b8cee04";
+			nt_fw_key_cert_uuid = "8ad5832a-fb60-e411-8aaf-df30bbc49859";
+			tos_fw_content_cert_uuid = "a49f4411-5e63-e411-8728-3f05722af33d";
+			nt_fw_content_cert_uuid = "8ec4c1f3-5d63-e411-a7a9-87ee40b23fa7";
+#endif
+		};
+	};
+
+#if TRUSTED_BOARD_BOOT
+	tb_fw-config {
+		compatible = "arm,tb_fw";
+
+		/* Disable authentication for development */
+		disable_auth = <0x0>;
+
+		/*
+		 * The following two entries are placeholders for Mbed TLS
+		 * heap information.
+		 */
+		mbedtls_heap_addr = <0x0 0x30004000>; /* SRAM2_BASE */
+		mbedtls_heap_size = <0x2000>; /* SRAM2_SIZE */
+	};
+
+#include "stm32mp1-cot-descriptors.dtsi"
+#endif
+
+};
diff --git a/fdts/stm32mp13-ddr.dtsi b/fdts/stm32mp13-ddr.dtsi
new file mode 100644
index 000000000..78cdbc3b3
--- /dev/null
+++ b/fdts/stm32mp13-ddr.dtsi
@@ -0,0 +1,184 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+&ddr {
+	st,mem-name = DDR_MEM_NAME;
+	st,mem-speed = <DDR_MEM_SPEED>;
+	st,mem-size = <DDR_MEM_SIZE>;
+
+	st,ctl-reg = <
+		DDR_MSTR
+		DDR_MRCTRL0
+		DDR_MRCTRL1
+		DDR_DERATEEN
+		DDR_DERATEINT
+		DDR_PWRCTL
+		DDR_PWRTMG
+		DDR_HWLPCTL
+		DDR_RFSHCTL0
+		DDR_RFSHCTL3
+		DDR_CRCPARCTL0
+		DDR_ZQCTL0
+		DDR_DFITMG0
+		DDR_DFITMG1
+		DDR_DFILPCFG0
+		DDR_DFIUPD0
+		DDR_DFIUPD1
+		DDR_DFIUPD2
+		DDR_DFIPHYMSTR
+		DDR_ODTMAP
+		DDR_DBG0
+		DDR_DBG1
+		DDR_DBGCMD
+		DDR_POISONCFG
+		DDR_PCCFG
+	>;
+
+	st,ctl-timing = <
+		DDR_RFSHTMG
+		DDR_DRAMTMG0
+		DDR_DRAMTMG1
+		DDR_DRAMTMG2
+		DDR_DRAMTMG3
+		DDR_DRAMTMG4
+		DDR_DRAMTMG5
+		DDR_DRAMTMG6
+		DDR_DRAMTMG7
+		DDR_DRAMTMG8
+		DDR_DRAMTMG14
+		DDR_ODTCFG
+	>;
+
+	st,ctl-map = <
+		DDR_ADDRMAP1
+		DDR_ADDRMAP2
+		DDR_ADDRMAP3
+		DDR_ADDRMAP4
+		DDR_ADDRMAP5
+		DDR_ADDRMAP6
+		DDR_ADDRMAP9
+		DDR_ADDRMAP10
+		DDR_ADDRMAP11
+	>;
+
+	st,ctl-perf = <
+		DDR_SCHED
+		DDR_SCHED1
+		DDR_PERFHPR1
+		DDR_PERFLPR1
+		DDR_PERFWR1
+		DDR_PCFGR_0
+		DDR_PCFGW_0
+		DDR_PCFGQOS0_0
+		DDR_PCFGQOS1_0
+		DDR_PCFGWQOS0_0
+		DDR_PCFGWQOS1_0
+	>;
+
+	st,phy-reg = <
+		DDR_PGCR
+		DDR_ACIOCR
+		DDR_DXCCR
+		DDR_DSGCR
+		DDR_DCR
+		DDR_ODTCR
+		DDR_ZQ0CR1
+		DDR_DX0GCR
+		DDR_DX1GCR
+	>;
+
+	st,phy-timing = <
+		DDR_PTR0
+		DDR_PTR1
+		DDR_PTR2
+		DDR_DTPR0
+		DDR_DTPR1
+		DDR_DTPR2
+		DDR_MR0
+		DDR_MR1
+		DDR_MR2
+		DDR_MR3
+	>;
+};
+
+#undef DDR_MEM_NAME
+#undef DDR_MEM_SPEED
+#undef DDR_MEM_SIZE
+#undef DDR_MSTR
+#undef DDR_MRCTRL0
+#undef DDR_MRCTRL1
+#undef DDR_DERATEEN
+#undef DDR_DERATEINT
+#undef DDR_PWRCTL
+#undef DDR_PWRTMG
+#undef DDR_HWLPCTL
+#undef DDR_RFSHCTL0
+#undef DDR_RFSHCTL3
+#undef DDR_RFSHTMG
+#undef DDR_CRCPARCTL0
+#undef DDR_DRAMTMG0
+#undef DDR_DRAMTMG1
+#undef DDR_DRAMTMG2
+#undef DDR_DRAMTMG3
+#undef DDR_DRAMTMG4
+#undef DDR_DRAMTMG5
+#undef DDR_DRAMTMG6
+#undef DDR_DRAMTMG7
+#undef DDR_DRAMTMG8
+#undef DDR_DRAMTMG14
+#undef DDR_ZQCTL0
+#undef DDR_DFITMG0
+#undef DDR_DFITMG1
+#undef DDR_DFILPCFG0
+#undef DDR_DFIUPD0
+#undef DDR_DFIUPD1
+#undef DDR_DFIUPD2
+#undef DDR_DFIPHYMSTR
+#undef DDR_ADDRMAP1
+#undef DDR_ADDRMAP2
+#undef DDR_ADDRMAP3
+#undef DDR_ADDRMAP4
+#undef DDR_ADDRMAP5
+#undef DDR_ADDRMAP6
+#undef DDR_ADDRMAP9
+#undef DDR_ADDRMAP10
+#undef DDR_ADDRMAP11
+#undef DDR_ODTCFG
+#undef DDR_ODTMAP
+#undef DDR_SCHED
+#undef DDR_SCHED1
+#undef DDR_PERFHPR1
+#undef DDR_PERFLPR1
+#undef DDR_PERFWR1
+#undef DDR_DBG0
+#undef DDR_DBG1
+#undef DDR_DBGCMD
+#undef DDR_POISONCFG
+#undef DDR_PCCFG
+#undef DDR_PCFGR_0
+#undef DDR_PCFGW_0
+#undef DDR_PCFGQOS0_0
+#undef DDR_PCFGQOS1_0
+#undef DDR_PCFGWQOS0_0
+#undef DDR_PCFGWQOS1_0
+#undef DDR_PGCR
+#undef DDR_PTR0
+#undef DDR_PTR1
+#undef DDR_PTR2
+#undef DDR_ACIOCR
+#undef DDR_DXCCR
+#undef DDR_DSGCR
+#undef DDR_DCR
+#undef DDR_DTPR0
+#undef DDR_DTPR1
+#undef DDR_DTPR2
+#undef DDR_MR0
+#undef DDR_MR1
+#undef DDR_MR2
+#undef DDR_MR3
+#undef DDR_ODTCR
+#undef DDR_ZQ0CR1
+#undef DDR_DX0GCR
+#undef DDR_DX1GCR
diff --git a/fdts/stm32mp13-ddr3-1x4Gb-1066-binF.dtsi b/fdts/stm32mp13-ddr3-1x4Gb-1066-binF.dtsi
new file mode 100644
index 000000000..f3844ce52
--- /dev/null
+++ b/fdts/stm32mp13-ddr3-1x4Gb-1066-binF.dtsi
@@ -0,0 +1,100 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * STM32MP135C DISCO BOARD configuration
+ * 1x DDR3L 4Gb, 16-bit, 533MHz.
+ * Reference used MT41K256M16TW-107 P from Micron
+ *
+ * DDR type / Platform	DDR3/3L
+ * freq		533MHz
+ * width	16
+ * datasheet	1
+ * DDR density	4
+ * timing mode	optimized
+ * Scheduling/QoS options : type = 6
+ * address mapping : RBC
+ * Tc > + 85C : N
+ */
+#define DDR_MEM_NAME "DDR3-1066 bin F 1x4Gb 533MHz v1.53"
+#define DDR_MEM_SPEED 533000
+#define DDR_MEM_SIZE 0x20000000
+
+#define DDR_MSTR 0x00040401
+#define DDR_MRCTRL0 0x00000010
+#define DDR_MRCTRL1 0x00000000
+#define DDR_DERATEEN 0x00000000
+#define DDR_DERATEINT 0x00800000
+#define DDR_PWRCTL 0x00000000
+#define DDR_PWRTMG 0x00400010
+#define DDR_HWLPCTL 0x00000000
+#define DDR_RFSHCTL0 0x00210000
+#define DDR_RFSHCTL3 0x00000000
+#define DDR_RFSHTMG 0x0081008B
+#define DDR_CRCPARCTL0 0x00000000
+#define DDR_DRAMTMG0 0x121B2414
+#define DDR_DRAMTMG1 0x000A041B
+#define DDR_DRAMTMG2 0x0607080F
+#define DDR_DRAMTMG3 0x0050400C
+#define DDR_DRAMTMG4 0x07040607
+#define DDR_DRAMTMG5 0x06060403
+#define DDR_DRAMTMG6 0x02020002
+#define DDR_DRAMTMG7 0x00000202
+#define DDR_DRAMTMG8 0x00001005
+#define DDR_DRAMTMG14 0x000000A0
+#define DDR_ZQCTL0 0xC2000040
+#define DDR_DFITMG0 0x02050105
+#define DDR_DFITMG1 0x00000202
+#define DDR_DFILPCFG0 0x07000000
+#define DDR_DFIUPD0 0xC0400003
+#define DDR_DFIUPD1 0x00000000
+#define DDR_DFIUPD2 0x00000000
+#define DDR_DFIPHYMSTR 0x00000000
+#define DDR_ADDRMAP1 0x00080808
+#define DDR_ADDRMAP2 0x00000000
+#define DDR_ADDRMAP3 0x00000000
+#define DDR_ADDRMAP4 0x00001F1F
+#define DDR_ADDRMAP5 0x07070707
+#define DDR_ADDRMAP6 0x0F070707
+#define DDR_ADDRMAP9 0x00000000
+#define DDR_ADDRMAP10 0x00000000
+#define DDR_ADDRMAP11 0x00000000
+#define DDR_ODTCFG 0x06000600
+#define DDR_ODTMAP 0x00000001
+#define DDR_SCHED 0x00000F01
+#define DDR_SCHED1 0x00000000
+#define DDR_PERFHPR1 0x00000001
+#define DDR_PERFLPR1 0x04000200
+#define DDR_PERFWR1 0x08000400
+#define DDR_DBG0 0x00000000
+#define DDR_DBG1 0x00000000
+#define DDR_DBGCMD 0x00000000
+#define DDR_POISONCFG 0x00000000
+#define DDR_PCCFG 0x00000010
+#define DDR_PCFGR_0 0x00000000
+#define DDR_PCFGW_0 0x00000000
+#define DDR_PCFGQOS0_0 0x00100009
+#define DDR_PCFGQOS1_0 0x00000020
+#define DDR_PCFGWQOS0_0 0x01100B03
+#define DDR_PCFGWQOS1_0 0x01000200
+#define DDR_PGCR 0x01442E02
+#define DDR_PTR0 0x0022AA5B
+#define DDR_PTR1 0x04841104
+#define DDR_PTR2 0x042DA068
+#define DDR_ACIOCR 0x10400812
+#define DDR_DXCCR 0x00000C40
+#define DDR_DSGCR 0xF200011F
+#define DDR_DCR 0x0000000B
+#define DDR_DTPR0 0x36D477D0
+#define DDR_DTPR1 0x098B00D8
+#define DDR_DTPR2 0x10023600
+#define DDR_MR0 0x00000830
+#define DDR_MR1 0x00000000
+#define DDR_MR2 0x00000208
+#define DDR_MR3 0x00000000
+#define DDR_ODTCR 0x00010000
+#define DDR_ZQ0CR1 0x00000038
+#define DDR_DX0GCR 0x0000CE81
+#define DDR_DX1GCR 0x0000CE81
+
+#include "stm32mp13-ddr.dtsi"
diff --git a/fdts/stm32mp13-fw-config-mem-encrypt.dtsi b/fdts/stm32mp13-fw-config-mem-encrypt.dtsi
new file mode 100644
index 000000000..f426ce1cf
--- /dev/null
+++ b/fdts/stm32mp13-fw-config-mem-encrypt.dtsi
@@ -0,0 +1,11 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+/ {
+	st-mem-encrypt {
+		compatible = "st,mem-encrypt";
+		memory-ranges = <DDR_SEC_BASE DDR_SEC_SIZE MCE_ENCRYPT>;
+	};
+};
diff --git a/fdts/stm32mp13-fw-config.dtsi b/fdts/stm32mp13-fw-config.dtsi
new file mode 100644
index 000000000..e6f6e637b
--- /dev/null
+++ b/fdts/stm32mp13-fw-config.dtsi
@@ -0,0 +1,56 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+#include <common/tbbr/tbbr_img_def.h>
+#include <dt-bindings/soc/stm32mp13-mce.h>
+#include <dt-bindings/soc/stm32mp13-tzc400.h>
+
+#include <platform_def.h>
+
+#ifndef DDR_SIZE
+#error "DDR_SIZE is not defined"
+#endif
+
+#define DDR_NS_BASE	STM32MP_DDR_BASE
+#define DDR_SEC_SIZE	0x01e00000
+#define DDR_SEC_BASE	(STM32MP_DDR_BASE + (DDR_SIZE - DDR_SEC_SIZE))
+#define DDR_SHARE_SIZE	0x00200000
+#define DDR_SHARE_BASE	(DDR_SEC_BASE - DDR_SHARE_SIZE)
+#define DDR_NS_SIZE	(DDR_SHARE_BASE - DDR_NS_BASE)
+
+/dts-v1/;
+
+/ {
+	dtb-registry {
+		compatible = "fconf,dyn_cfg-dtb_registry";
+
+		hw-config {
+			load-address = <0x0 STM32MP_HW_CONFIG_BASE>;
+			max-size = <STM32MP_HW_CONFIG_MAX_SIZE>;
+			id = <HW_CONFIG_ID>;
+		};
+
+		nt_fw {
+			load-address = <0x0 STM32MP_BL33_BASE>;
+			max-size = <STM32MP_BL33_MAX_SIZE>;
+			id = <BL33_IMAGE_ID>;
+		};
+
+		tos_fw {
+			load-address = <0x0 DDR_SEC_BASE>;
+			max-size = <DDR_SEC_SIZE>;
+			id = <BL32_IMAGE_ID>;
+		};
+	};
+
+	st-mem-firewall {
+		compatible = "st,mem-firewall";
+		memory-ranges = <
+			DDR_NS_BASE DDR_NS_SIZE TZC_REGION_S_NONE TZC_REGION_NSEC_ALL_ACCESS_RDWR
+			DDR_SHARE_BASE DDR_SHARE_SIZE TZC_REGION_S_NONE
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_A7_ID)
+			DDR_SEC_BASE DDR_SEC_SIZE TZC_REGION_S_RDWR 0>;
+	};
+};
diff --git a/fdts/stm32mp13-pinctrl.dtsi b/fdts/stm32mp13-pinctrl.dtsi
new file mode 100644
index 000000000..5d81f964c
--- /dev/null
+++ b/fdts/stm32mp13-pinctrl.dtsi
@@ -0,0 +1,103 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com>
+ */
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
+&pinctrl {
+	i2c4_pins_a: i2c4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 15, AF6)>, /* I2C4_SCL */
+				 <STM32_PINMUX('B', 9, AF6)>; /* I2C4_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	sdmmc1_b4_pins_a: sdmmc1-b4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('C', 11, AF12)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('D', 2, AF12)>; /* SDMMC1_CMD */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	sdmmc1_clk_pins_a: sdmmc1-clk-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 12, AF12)>; /* SDMMC1_CK */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	sdmmc2_b4_pins_a: sdmmc2-b4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 14, AF10)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('B', 15, AF10)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('B', 3, AF10)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('B', 4, AF10)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('G', 6, AF10)>; /* SDMMC2_CMD */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_clk_pins_a: sdmmc2-clk-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC2_CK */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	uart4_pins_a: uart4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 6, AF8)>; /* UART4_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 8, AF8)>; /* UART4_RX */
+			bias-disable;
+		};
+	};
+
+	usart1_pins_a: usart1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 0, AF7)>, /* USART1_TX */
+				 <STM32_PINMUX('C', 2, AF7)>; /* USART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 0, AF4)>, /* USART1_RX */
+				 <STM32_PINMUX('A', 7, AF7)>; /* USART1_CTS_NSS */
+			bias-pull-up;
+		};
+	};
+
+	uart8_pins_a: uart8-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 1, AF8)>; /* UART8_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 9, AF8)>; /* UART8_RX */
+			bias-pull-up;
+		};
+	};
+};
diff --git a/fdts/stm32mp13-ssp-bl2.dtsi b/fdts/stm32mp13-ssp-bl2.dtsi
new file mode 100644
index 000000000..8f5fc5b45
--- /dev/null
+++ b/fdts/stm32mp13-ssp-bl2.dtsi
@@ -0,0 +1,52 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2020 - All Rights Reserved
+ */
+
+/ {
+	aliases {
+		/delete-property/ mmc0;
+	};
+
+	soc {
+		efuse@5c005000 {
+			cfg0_otp: cfg0_otp@0 {
+				reg = <0x0 0x2>;
+			};
+			cfg2_otp: cfg2_otp@8 {
+				reg = <0x8 0x4>;
+			};
+			ssp_otp: cfg9_otp@24 {
+				reg = <0x24 0x4>;
+			};
+			chip_otp: chip_otp@a0 {
+				reg = <0xa0 0x40>;
+			};
+			rma_otp: rma_otp@e0 {
+				reg = <0xe0 0x4>;
+			};
+			pkh_otp: pkh_otp@60 {
+				reg = <0x60 0x20>;
+			};
+		};
+
+#if STM32MP_UART_PROGRAMMER
+		/delete-node/ usb-otg@49000000;
+#endif
+		/delete-node/ spi@58003000;
+		/delete-node/ mmc@58005000;
+		/delete-node/ mmc@58007000;
+#if STM32MP_UART_PROGRAMMER
+		/delete-node/ usbh-ohci@5800c000;
+		/delete-node/ usbh-ehci@5800d000;
+#endif
+#if STM32MP_UART_PROGRAMMER
+		/delete-node/ usbphyc@5a006000;
+#endif
+
+		pinctrl@50002000 {
+			/delete-node/ sdmmc1-b4-0;
+			/delete-node/ sdmmc2-b4-0;
+		};
+	};
+};
diff --git a/fdts/stm32mp131.dtsi b/fdts/stm32mp131.dtsi
new file mode 100644
index 000000000..737c86e57
--- /dev/null
+++ b/fdts/stm32mp131.dtsi
@@ -0,0 +1,579 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
+ * Author: Ludovic Barre <ludovic.barre@st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/clock/stm32mp13-clks.h>
+#include <dt-bindings/reset/stm32mp13-resets.h>
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,cortex-a7";
+			device_type = "cpu";
+			reg = <0>;
+			clocks = <&rcc CK_MPU>;
+			clock-names = "cpu";
+			nvmem-cells = <&part_number_otp>;
+			nvmem-cell-names = "part_number";
+		};
+	};
+
+	intc: interrupt-controller@a0021000 {
+		compatible = "arm,cortex-a7-gic";
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		reg = <0xa0021000 0x1000>,
+		      <0xa0022000 0x2000>;
+	};
+
+	clocks {
+		clk_hse: clk-hse {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+
+		clk_hsi: clk-hsi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <64000000>;
+		};
+
+		clk_lse: clk-lse {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <32768>;
+		};
+
+		clk_lsi: clk-lsi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <32000>;
+		};
+
+		clk_csi: clk-csi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <4000000>;
+		};
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&intc>;
+		ranges;
+
+		usart3: serial@4000f000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x4000f000 0x400>;
+			interrupts = <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc USART3_K>;
+			resets = <&rcc USART3_R>;
+			status = "disabled";
+		};
+
+		uart4: serial@40010000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40010000 0x400>;
+			interrupts = <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc UART4_K>;
+			resets = <&rcc UART4_R>;
+			status = "disabled";
+		};
+
+		uart5: serial@40011000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40011000 0x400>;
+			interrupts = <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc UART5_K>;
+			resets = <&rcc UART5_R>;
+			status = "disabled";
+		};
+
+		uart7: serial@40018000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40018000 0x400>;
+			interrupts = <GIC_SPI 83 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc UART7_K>;
+			resets = <&rcc UART7_R>;
+			status = "disabled";
+		};
+
+		uart8: serial@40019000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40019000 0x400>;
+			interrupts = <GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc UART8_K>;
+			resets = <&rcc UART8_R>;
+			status = "disabled";
+		};
+
+		usart6: serial@44003000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x44003000 0x400>;
+			interrupts = <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc USART6_K>;
+			resets = <&rcc USART6_R>;
+			status = "disabled";
+		};
+
+		usbotg_hs: usb-otg@49000000 {
+			compatible = "st,stm32mp15-hsotg", "snps,dwc2";
+			reg = <0x49000000 0x40000>;
+			clocks = <&rcc USBO_K>;
+			clock-names = "otg";
+			resets = <&rcc USBO_R>;
+			reset-names = "dwc2";
+			interrupts = <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
+			g-rx-fifo-size = <512>;
+			g-np-tx-fifo-size = <32>;
+			g-tx-fifo-size = <256 16 16 16 16 16 16 16>;
+			dr_mode = "otg";
+			usb33d-supply = <&usb33>;
+			status = "disabled";
+		};
+
+		usart1: serial@4c000000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x4c000000 0x400>;
+			interrupts = <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc USART1_K>;
+			resets = <&rcc USART1_R>;
+			status = "disabled";
+		};
+
+		usart2: serial@4c001000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x4c001000 0x400>;
+			interrupts = <GIC_SPI 39 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc USART2_K>;
+			resets = <&rcc USART2_R>;
+			status = "disabled";
+		};
+
+		i2c3: i2c@4c004000 {
+			compatible = "st,stm32mp13-i2c";
+			reg = <0x4c004000 0x400>;
+			interrupt-names = "event", "error";
+			interrupts-extended = <&exti 23 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc I2C3_K>;
+			resets = <&rcc I2C3_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			st,syscfg-fmp = <&syscfg 0x4 0x4>;
+			i2c-analog-filter;
+			status = "disabled";
+		};
+
+		i2c4: i2c@4c005000 {
+			compatible = "st,stm32mp13-i2c";
+			reg = <0x4c005000 0x400>;
+			interrupt-names = "event", "error";
+			interrupts-extended = <&exti 24 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc I2C4_K>;
+			resets = <&rcc I2C4_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			st,syscfg-fmp = <&syscfg 0x4 0x8>;
+			i2c-analog-filter;
+			status = "disabled";
+		};
+
+		i2c5: i2c@4c006000 {
+			compatible = "st,stm32mp13-i2c";
+			reg = <0x4c006000 0x400>;
+			interrupt-names = "event", "error";
+			interrupts-extended = <&exti 25 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc I2C5_K>;
+			resets = <&rcc I2C5_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			st,syscfg-fmp = <&syscfg 0x4 0x10>;
+			i2c-analog-filter;
+			status = "disabled";
+		};
+
+		rcc: rcc@50000000 {
+			compatible = "st,stm32mp13-rcc", "syscon";
+			reg = <0x50000000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>;
+			secure-interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+			secure-interrupt-names = "wakeup";
+		};
+
+		pwr_regulators: pwr@50001000 {
+			compatible = "st,stm32mp1,pwr-reg";
+			reg = <0x50001000 0x10>;
+
+			reg11: reg11 {
+				regulator-name = "reg11";
+				regulator-min-microvolt = <1100000>;
+				regulator-max-microvolt = <1100000>;
+			};
+
+			reg18: reg18 {
+				regulator-name = "reg18";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+			};
+
+			usb33: usb33 {
+				regulator-name = "usb33";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+		};
+
+		exti: interrupt-controller@5000d000 {
+			compatible = "st,stm32mp13-exti", "syscon";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x5000d000 0x400>;
+		};
+
+		syscfg: syscon@50020000 {
+			compatible = "st,stm32mp157-syscfg", "syscon";
+			reg = <0x50020000 0x400>;
+			clocks = <&rcc SYSCFG>;
+		};
+
+		hash: hash@54003000 {
+			compatible = "st,stm32mp13-hash";
+			reg = <0x54003000 0x400>;
+			clocks = <&rcc HASH1>;
+			resets = <&rcc HASH1_R>;
+			status = "disabled";
+		};
+
+		rng: rng@54004000 {
+			compatible = "st,stm32mp13-rng";
+			reg = <0x54004000 0x400>;
+			clocks = <&rcc RNG1_K>;
+			resets = <&rcc RNG1_R>;
+			status = "disabled";
+		};
+
+		fmc: memory-controller@58002000 {
+			#address-cells = <2>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp1-fmc2-ebi";
+			reg = <0x58002000 0x1000>;
+			clocks = <&rcc FMC_K>;
+			resets = <&rcc FMC_R>;
+			status = "disabled";
+
+			ranges = <0 0 0x60000000 0x04000000>, /* EBI CS 1 */
+				 <1 0 0x64000000 0x04000000>, /* EBI CS 2 */
+				 <2 0 0x68000000 0x04000000>, /* EBI CS 3 */
+				 <3 0 0x6c000000 0x04000000>, /* EBI CS 4 */
+				 <4 0 0x80000000 0x10000000>; /* NAND */
+
+			nand-controller@4,0 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp1-fmc2-nfc";
+				reg = <4 0x00000000 0x1000>,
+				      <4 0x08010000 0x1000>,
+				      <4 0x08020000 0x1000>,
+				      <4 0x01000000 0x1000>,
+				      <4 0x09010000 0x1000>,
+				      <4 0x09020000 0x1000>;
+				interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
+				status = "disabled";
+			};
+		};
+
+		qspi: spi@58003000 {
+			compatible = "st,stm32f469-qspi";
+			reg = <0x58003000 0x1000>, <0x70000000 0x10000000>;
+			reg-names = "qspi", "qspi_mm";
+			interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc QSPI_K>;
+			resets = <&rcc QSPI_R>;
+			status = "disabled";
+		};
+
+		sdmmc1: mmc@58005000 {
+			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+			arm,primecell-periphid = <0x20253180>;
+			reg = <0x58005000 0x1000>, <0x58006000 0x1000>;
+			clocks = <&rcc SDMMC1_K>;
+			clock-names = "apb_pclk";
+			resets = <&rcc SDMMC1_R>;
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			max-frequency = <130000000>;
+			status = "disabled";
+		};
+
+		sdmmc2: mmc@58007000 {
+			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+			arm,primecell-periphid = <0x20253180>;
+			reg = <0x58007000 0x1000>, <0x58008000 0x1000>;
+			clocks = <&rcc SDMMC2_K>;
+			clock-names = "apb_pclk";
+			resets = <&rcc SDMMC2_R>;
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			max-frequency = <130000000>;
+			status = "disabled";
+		};
+
+		usbh_ohci: usbh-ohci@5800c000 {
+			compatible = "generic-ohci";
+			reg = <0x5800c000 0x1000>;
+			clocks = <&rcc USBH>;
+			resets = <&rcc USBH_R>;
+			interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		usbh_ehci: usbh-ehci@5800d000 {
+			compatible = "generic-ehci";
+			reg = <0x5800d000 0x1000>;
+			clocks = <&rcc USBH>;
+			resets = <&rcc USBH_R>;
+			interrupts = <GIC_SPI 76 IRQ_TYPE_LEVEL_HIGH>;
+			companion = <&usbh_ohci>;
+			status = "disabled";
+		};
+
+		iwdg2: watchdog@5a002000 {
+			compatible = "st,stm32mp1-iwdg";
+			reg = <0x5a002000 0x400>;
+			clocks = <&rcc IWDG2>, <&rcc CK_LSI>;
+			clock-names = "pclk", "lsi";
+			status = "disabled";
+		};
+
+		ddr: ddr@5a003000{
+			compatible = "st,stm32mp13-ddr";
+			reg = <0x5a003000 0x550>, <0x5a004000 0x234>;
+			clocks = <&rcc AXIDCG>,
+				 <&rcc DDRC1>,
+				 <&rcc DDRPHYC>,
+				 <&rcc DDRCAPB>,
+				 <&rcc DDRPHYCAPB>;
+			clock-names = "axidcg",
+				      "ddrc1",
+				      "ddrphyc",
+				      "ddrcapb",
+				      "ddrphycapb";
+		};
+
+		usbphyc: usbphyc@5a006000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			#clock-cells = <0>;
+			compatible = "st,stm32mp1-usbphyc";
+			reg = <0x5a006000 0x1000>;
+			clocks = <&rcc USBPHY_K>;
+			resets = <&rcc USBPHY_R>;
+			vdda1v1-supply = <&reg11>;
+			vdda1v8-supply = <&reg18>;
+			status = "disabled";
+
+			usbphyc_port0: usb-phy@0 {
+				#phy-cells = <0>;
+				reg = <0>;
+			};
+
+			usbphyc_port1: usb-phy@1 {
+				#phy-cells = <1>;
+				reg = <1>;
+			};
+		};
+
+		iwdg1: watchdog@5c003000 {
+			compatible = "st,stm32mp1-iwdg";
+			reg = <0x5c003000 0x400>;
+			interrupts = <GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc IWDG1>, <&rcc CK_LSI>;
+			clock-names = "pclk", "lsi";
+			status = "disabled";
+		};
+
+		bsec: efuse@5c005000 {
+			compatible = "st,stm32mp13-bsec";
+			reg = <0x5c005000 0x400>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			cfg0_otp: cfg0_otp@0 {
+				reg = <0x0 0x2>;
+			};
+			part_number_otp: part_number_otp@4 {
+				reg = <0x4 0x2>;
+			};
+			monotonic_otp: monotonic_otp@10 {
+				reg = <0x10 0x4>;
+			};
+			nand_otp: cfg9_otp@24 {
+				reg = <0x24 0x4>;
+			};
+			nand2_otp: cfg10_otp@28 {
+				reg = <0x28 0x4>;
+			};
+			uid_otp: uid_otp@34 {
+				reg = <0x34 0xc>;
+			};
+			hw2_otp: hw2_otp@48 {
+				reg = <0x48 0x4>;
+			};
+			ts_cal1: calib@5c {
+				reg = <0x5c 0x2>;
+			};
+			ts_cal2: calib@5e {
+				reg = <0x5e 0x2>;
+			};
+			pkh_otp: pkh_otp@60 {
+				reg = <0x60 0x20>;
+			};
+			mac_addr: mac_addr@e4 {
+				reg = <0xe4 0xc>;
+				st,non-secure-otp;
+			};
+			oem_enc_key: oem_enc_key@170 {
+				reg = <0x170 0x10>;
+			};
+		};
+		/*
+		 * Break node order to solve dependency probe issue between
+		 * pinctrl and exti.
+		 */
+		pinctrl: pinctrl@50002000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp135-pinctrl";
+			ranges = <0 0x50002000 0x8400>;
+			interrupt-parent = <&exti>;
+			st,syscfg = <&exti 0x60 0xff>;
+			pins-are-numbered;
+
+			gpioa: gpio@50002000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x0 0x400>;
+				clocks = <&rcc GPIOA>;
+				st,bank-name = "GPIOA";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 0 16>;
+			};
+
+			gpiob: gpio@50003000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x1000 0x400>;
+				clocks = <&rcc GPIOB>;
+				st,bank-name = "GPIOB";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 16 16>;
+			};
+
+			gpioc: gpio@50004000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x2000 0x400>;
+				clocks = <&rcc GPIOC>;
+				st,bank-name = "GPIOC";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 32 16>;
+			};
+
+			gpiod: gpio@50005000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x3000 0x400>;
+				clocks = <&rcc GPIOD>;
+				st,bank-name = "GPIOD";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 48 16>;
+			};
+
+			gpioe: gpio@50006000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x4000 0x400>;
+				clocks = <&rcc GPIOE>;
+				st,bank-name = "GPIOE";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 64 16>;
+			};
+
+			gpiof: gpio@50007000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x5000 0x400>;
+				clocks = <&rcc GPIOF>;
+				st,bank-name = "GPIOF";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 80 16>;
+			};
+
+			gpiog: gpio@50008000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x6000 0x400>;
+				clocks = <&rcc GPIOG>;
+				st,bank-name = "GPIOG";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 96 16>;
+			};
+
+			gpioh: gpio@50009000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x7000 0x400>;
+				clocks = <&rcc GPIOH>;
+				st,bank-name = "GPIOH";
+				ngpios = <15>;
+				gpio-ranges = <&pinctrl 0 112 15>;
+			};
+
+			gpioi: gpio@5000a000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x8000 0x400>;
+				clocks = <&rcc GPIOI>;
+				st,bank-name = "GPIOI";
+				ngpios = <8>;
+				gpio-ranges = <&pinctrl 0 128 8>;
+			};
+		};
+	};
+};
diff --git a/fdts/stm32mp133.dtsi b/fdts/stm32mp133.dtsi
new file mode 100644
index 000000000..41d288f39
--- /dev/null
+++ b/fdts/stm32mp133.dtsi
@@ -0,0 +1,7 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+#include "stm32mp131.dtsi"
diff --git a/fdts/stm32mp135.dtsi b/fdts/stm32mp135.dtsi
new file mode 100644
index 000000000..c818b6480
--- /dev/null
+++ b/fdts/stm32mp135.dtsi
@@ -0,0 +1,7 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+#include "stm32mp133.dtsi"
diff --git a/fdts/stm32mp135f-dk-fw-config.dts b/fdts/stm32mp135f-dk-fw-config.dts
new file mode 100644
index 000000000..1bad8e2fe
--- /dev/null
+++ b/fdts/stm32mp135f-dk-fw-config.dts
@@ -0,0 +1,8 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+#define DDR_SIZE	0x20000000 /* 512MB */
+#include "stm32mp13-fw-config.dtsi"
+#include "stm32mp13-fw-config-mem-encrypt.dtsi"
diff --git a/fdts/stm32mp135f-dk.dts b/fdts/stm32mp135f-dk.dts
new file mode 100644
index 000000000..a6a864886
--- /dev/null
+++ b/fdts/stm32mp135f-dk.dts
@@ -0,0 +1,329 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/clock/stm32mp13-clksrc.h>
+#include "stm32mp135.dtsi"
+#include "stm32mp13xf.dtsi"
+#include "stm32mp13-ddr3-1x4Gb-1066-binF.dtsi"
+#include "stm32mp13-pinctrl.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP135F-DK Discovery Board";
+	compatible = "st,stm32mp135f-dk", "st,stm32mp135";
+
+	aliases {
+		serial0 = &uart4;
+		serial1 = &usart1;
+		serial2 = &uart8;
+		serial3 = &usart2;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xc0000000 0x20000000>;
+	};
+
+	vin: vin {
+		compatible = "regulator-fixed";
+		regulator-name = "vin";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+
+	v3v3_ao: v3v3_ao {
+		compatible = "regulator-fixed";
+		regulator-name = "v3v3_ao";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+	};
+};
+
+&bsec {
+	board_id: board_id@f0 {
+		reg = <0xf0 0x4>;
+		st,non-secure-otp;
+	};
+};
+
+&cpu0 {
+	cpu-supply = <&vddcpu>;
+};
+
+&hash {
+	status = "okay";
+};
+
+&i2c4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <400000>;
+	status = "okay";
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			buck1-supply = <&vin>;
+			buck2-supply = <&vin>;
+			buck3-supply = <&vin>;
+			buck4-supply = <&vin>;
+			ldo1-supply = <&vin>;
+			ldo4-supply = <&vin>;
+			ldo5-supply = <&vin>;
+			ldo6-supply = <&vin>;
+			vref_ddr-supply = <&vin>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&v3v3_ao>;
+
+			vddcpu: buck1 {
+				regulator-name = "vddcpu";
+				regulator-min-microvolt = <1250000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-over-current-protection;
+			};
+
+			vddcore: buck4 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <1250000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			vdd_adc: ldo1 {
+				regulator-name = "vdd_adc";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			vdd_sd: ldo5 {
+				regulator-name = "vdd_sd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+			};
+
+			v1v8_periph: ldo6 {
+				regulator-name = "v1v8_periph";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+			};
+
+			vref_ddr: vref_ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+			};
+
+			v3v3_sw: pwr_sw2 {
+				regulator-name = "v3v3_sw";
+				regulator-active-discharge = <1>;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
+&iwdg2 {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&pka {
+	status = "okay";
+};
+
+&pwr_regulators {
+	vdd-supply = <&vdd>;
+	vdd_3v3_usbfs-supply = <&vdd_usb>;
+};
+
+&rcc {
+	st,clksrc = <
+		CLK_MPU_PLL1P
+		CLK_AXI_PLL2P
+		CLK_MLAHBS_PLL3
+		CLK_CKPER_HSE
+		CLK_RTC_LSE
+		CLK_SDMMC1_PLL4P
+		CLK_SDMMC2_PLL4P
+		CLK_STGEN_HSE
+		CLK_USBPHY_HSE
+		CLK_I2C4_HSI
+		CLK_USBO_USBPHY
+		CLK_I2C12_HSI
+		CLK_UART2_HSI
+		CLK_UART4_HSI
+		CLK_SAES_AXI
+	>;
+
+	st,clkdiv = <
+		DIV(DIV_AXI, 0)
+		DIV(DIV_MLAHB, 0)
+		DIV(DIV_APB1, 1)
+		DIV(DIV_APB2, 1)
+		DIV(DIV_APB3, 1)
+		DIV(DIV_APB4, 1)
+		DIV(DIV_APB5, 2)
+		DIV(DIV_APB6, 1)
+		DIV(DIV_RTC, 0)
+	>;
+
+	st,pll_vco {
+		pll1_vco_1300Mhz: pll1-vco-1300Mhz {
+			src = < CLK_PLL12_HSE >;
+			divmn = < 2 80 >;
+			frac = < 0x800 >;
+		};
+
+		pll2_vco_1066Mhz: pll2-vco-1066Mhz {
+			src = < CLK_PLL12_HSE >;
+			divmn = < 2 65 >;
+			frac = < 0x1400 >;
+		};
+
+		pll3_vco_417_8Mhz: pll3-vco-417_8Mhz {
+			src = < CLK_PLL3_HSE >;
+			divmn = < 1 33 >;
+			frac = < 0x1a04 >;
+		};
+
+		pll4_vco_600Mhz: pll4-vco-600Mhz {
+			src = < CLK_PLL4_HSE >;
+			divmn = < 1 49 >;
+		};
+	};
+
+	/* VCO = 1300.0 MHz => P = 650 (CPU) */
+	pll1:st,pll@0 {
+		compatible = "st,stm32mp1-pll";
+		reg = <0>;
+
+		st,pll = < &pll1_cfg1 >;
+
+		pll1_cfg1: pll1_cfg1 {
+			st,pll_vco = < &pll1_vco_1300Mhz >;
+			st,pll_div_pqr = < 0 1 1 >;
+		};
+	};
+
+	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 266, R = 533 (DDR) */
+	pll2:st,pll@1 {
+		compatible = "st,stm32mp1-pll";
+		reg = <1>;
+
+		st,pll = < &pll2_cfg1 >;
+
+		pll2_cfg1: pll2_cfg1 {
+			st,pll_vco = < &pll2_vco_1066Mhz >;
+			st,pll_div_pqr = < 1 1 0 >;
+		};
+	};
+
+	/* VCO = 417.8 MHz => P = 209, Q = 24, R = 209 */
+	pll3:st,pll@2 {
+		compatible = "st,stm32mp1-pll";
+		reg = <2>;
+
+		st,pll = < &pll3_cfg1 >;
+
+		pll3_cfg1: pll3_cfg1 {
+			st,pll_vco = < &pll3_vco_417_8Mhz >;
+			st,pll_div_pqr = < 1 16 1 >;
+		};
+	};
+
+	/* VCO = 600.0 MHz => P = 50, Q = 10, R = 100 */
+	pll4:st,pll@3 {
+		compatible = "st,stm32mp1-pll";
+		reg = <3>;
+
+		st,pll = < &pll4_cfg1 >;
+
+		pll4_cfg1: pll4_cfg1 {
+			st,pll_vco = < &pll4_vco_600Mhz >;
+			st,pll_div_pqr = < 11 59 5 >;
+		};
+	};
+};
+
+&rng {
+	status = "okay";
+};
+
+&saes {
+	status = "okay";
+};
+
+&sdmmc1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_clk_pins_a>;
+	disable-wp;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&vdd_sd>;
+	status = "okay";
+};
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart4_pins_a>;
+	status = "okay";
+};
+
+&uart8 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart8_pins_a>;
+	status = "disabled";
+};
+
+&usart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&usart1_pins_a>;
+	uart-has-rtscts;
+	status = "disabled";
+};
diff --git a/fdts/stm32mp13xa.dtsi b/fdts/stm32mp13xa.dtsi
new file mode 100644
index 000000000..20e52cd27
--- /dev/null
+++ b/fdts/stm32mp13xa.dtsi
@@ -0,0 +1,5 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
diff --git a/fdts/stm32mp13xc.dtsi b/fdts/stm32mp13xc.dtsi
new file mode 100644
index 000000000..94ba3bc71
--- /dev/null
+++ b/fdts/stm32mp13xc.dtsi
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+#include "stm32mp13xa.dtsi"
+
+/ {
+	soc {
+		saes: saes@54005000 {
+			compatible = "st,stm32-saes";
+			reg = <0x54005000 0x400>;
+			clocks = <&rcc SAES_K>;
+			resets = <&rcc SAES_R>;
+			status = "disabled";
+		};
+
+		pka: pka@54006000 {
+			compatible = "st,stm32-pka64";
+			reg = <0x54006000 0x2000>;
+			clocks = <&rcc PKA>;
+			resets = <&rcc PKA_R>;
+			status = "disabled";
+		};
+	};
+};
diff --git a/fdts/stm32mp13xd.dtsi b/fdts/stm32mp13xd.dtsi
new file mode 100644
index 000000000..aa8e23568
--- /dev/null
+++ b/fdts/stm32mp13xd.dtsi
@@ -0,0 +1,5 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
diff --git a/fdts/stm32mp13xf.dtsi b/fdts/stm32mp13xf.dtsi
new file mode 100644
index 000000000..ca155ac50
--- /dev/null
+++ b/fdts/stm32mp13xf.dtsi
@@ -0,0 +1,26 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include "stm32mp13xd.dtsi"
+
+/ {
+	soc {
+		saes: saes@54005000 {
+			compatible = "st,stm32-saes";
+			reg = <0x54005000 0x400>;
+			clocks = <&rcc SAES_K>;
+			resets = <&rcc SAES_R>;
+			status = "disabled";
+		};
+
+		pka: pka@54006000 {
+			compatible = "st,stm32-pka64";
+			reg = <0x54006000 0x2000>;
+			clocks = <&rcc PKA>;
+			resets = <&rcc PKA_R>;
+			status = "disabled";
+		};
+	};
+};
diff --git a/fdts/stm32mp15-bl2.dtsi b/fdts/stm32mp15-bl2.dtsi
index 074414bb2..6938d9e3f 100644
--- a/fdts/stm32mp15-bl2.dtsi
+++ b/fdts/stm32mp15-bl2.dtsi
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
 /*
- * Copyright (C) STMicroelectronics 2020-2021 - All Rights Reserved
+ * Copyright (C) STMicroelectronics 2020-2022 - All Rights Reserved
  */
 
 / {
@@ -45,7 +45,7 @@
 		/delete-node/ i2c@5c009000;
 		/delete-node/ tamp@5c00a000;
 
-		pin-controller@50002000 {
+		pinctrl@50002000 {
 #if !STM32MP_RAW_NAND
 			/delete-node/ fmc-0;
 #endif
@@ -68,7 +68,6 @@
 		};
 	};
 
-#if !STM32MP_USE_STM32IMAGE
 	/*
 	 * UUID's here are UUID RFC 4122 compliant meaning fieds are stored in
 	 * network order (big endian)
@@ -84,8 +83,32 @@
 			bl33_uuid = "d6d0eea7-fcea-d54b-9782-9934f234b6e4";
 			hw_cfg_uuid = "08b8f1d9-c9cf-9349-a962-6fbc6b7265cc";
 			tos_fw_cfg_uuid = "26257c1a-dbc6-7f47-8d96-c4c4b0248021";
-			nt_fw_cfg_uuid = "28da9815-93e8-7e44-ac66-1aaf801550f9";
+#if TRUSTED_BOARD_BOOT
+			stm32mp_cfg_cert_uuid = "501d8dd2-8bce-49a5-84eb-559a9f2eaeaf";
+			t_key_cert_uuid = "827ee890-f860-e411-a1b4-777a21b4f94c";
+			tos_fw_key_cert_uuid = "9477d603-fb60-e411-85dd-b7105b8cee04";
+			nt_fw_key_cert_uuid = "8ad5832a-fb60-e411-8aaf-df30bbc49859";
+			tos_fw_content_cert_uuid = "a49f4411-5e63-e411-8728-3f05722af33d";
+			nt_fw_content_cert_uuid = "8ec4c1f3-5d63-e411-a7a9-87ee40b23fa7";
+#endif
 		};
 	};
-#endif /* !STM32MP_USE_STM32IMAGE */
+
+#if TRUSTED_BOARD_BOOT
+	tb_fw-config {
+		compatible = "arm,tb_fw";
+
+		/* Disable authentication for development */
+		disable_auth = <0x0>;
+
+		/*
+		 * The following two entries are placeholders for Mbed TLS
+		 * heap information.
+		 */
+		mbedtls_heap_addr = <0x0 0x0>;
+		mbedtls_heap_size = <0x0>;
+	};
+
+#include "stm32mp1-cot-descriptors.dtsi"
+#endif
 };
diff --git a/fdts/stm32mp15-bl32.dtsi b/fdts/stm32mp15-bl32.dtsi
index ca4bb3ea5..264aaf098 100644
--- a/fdts/stm32mp15-bl32.dtsi
+++ b/fdts/stm32mp15-bl32.dtsi
@@ -22,12 +22,11 @@
 		/delete-node/ spi@58003000;
 		/delete-node/ mmc@58005000;
 		/delete-node/ mmc@58007000;
-		/delete-node/ usbphyc@5a006000;
 		/delete-node/ spi@5c001000;
 		/delete-node/ stgen@5c008000;
 		/delete-node/ i2c@5c009000;
 
-		pin-controller@50002000 {
+		pinctrl@50002000 {
 			/delete-node/ fmc-0;
 			/delete-node/ qspi-clk-0;
 			/delete-node/ qspi-bk1-0;
diff --git a/fdts/stm32mp15-ddr.dtsi b/fdts/stm32mp15-ddr.dtsi
index e5efd9256..2e09a613c 100644
--- a/fdts/stm32mp15-ddr.dtsi
+++ b/fdts/stm32mp15-ddr.dtsi
@@ -109,19 +109,4 @@
 		DDR_MR2
 		DDR_MR3
 	>;
-
-	st,phy-cal = <
-		DDR_DX0DLLCR
-		DDR_DX0DQTR
-		DDR_DX0DQSTR
-		DDR_DX1DLLCR
-		DDR_DX1DQTR
-		DDR_DX1DQSTR
-		DDR_DX2DLLCR
-		DDR_DX2DQTR
-		DDR_DX2DQSTR
-		DDR_DX3DLLCR
-		DDR_DX3DQTR
-		DDR_DX3DQSTR
-	>;
 };
diff --git a/fdts/stm32mp15-ddr3-1x4Gb-1066-binG.dtsi b/fdts/stm32mp15-ddr3-1x4Gb-1066-binG.dtsi
index c6d6434a9..81c52b67f 100644
--- a/fdts/stm32mp15-ddr3-1x4Gb-1066-binG.dtsi
+++ b/fdts/stm32mp15-ddr3-1x4Gb-1066-binG.dtsi
@@ -100,20 +100,8 @@
 #define DDR_ODTCR 0x00010000
 #define DDR_ZQ0CR1 0x00000038
 #define DDR_DX0GCR 0x0000CE81
-#define DDR_DX0DLLCR 0x40000000
-#define DDR_DX0DQTR 0xFFFFFFFF
-#define DDR_DX0DQSTR 0x3DB02000
 #define DDR_DX1GCR 0x0000CE81
-#define DDR_DX1DLLCR 0x40000000
-#define DDR_DX1DQTR 0xFFFFFFFF
-#define DDR_DX1DQSTR 0x3DB02000
 #define DDR_DX2GCR 0x0000CE80
-#define DDR_DX2DLLCR 0x40000000
-#define DDR_DX2DQTR 0xFFFFFFFF
-#define DDR_DX2DQSTR 0x3DB02000
 #define DDR_DX3GCR 0x0000CE80
-#define DDR_DX3DLLCR 0x40000000
-#define DDR_DX3DQTR 0xFFFFFFFF
-#define DDR_DX3DQSTR 0x3DB02000
 
 #include "stm32mp15-ddr.dtsi"
diff --git a/fdts/stm32mp15-ddr3-2x4Gb-1066-binG.dtsi b/fdts/stm32mp15-ddr3-2x4Gb-1066-binG.dtsi
index 9614ab4c8..83867e512 100644
--- a/fdts/stm32mp15-ddr3-2x4Gb-1066-binG.dtsi
+++ b/fdts/stm32mp15-ddr3-2x4Gb-1066-binG.dtsi
@@ -100,20 +100,8 @@
 #define DDR_ODTCR 0x00010000
 #define DDR_ZQ0CR1 0x00000038
 #define DDR_DX0GCR 0x0000CE81
-#define DDR_DX0DLLCR 0x40000000
-#define DDR_DX0DQTR 0xFFFFFFFF
-#define DDR_DX0DQSTR 0x3DB02000
 #define DDR_DX1GCR 0x0000CE81
-#define DDR_DX1DLLCR 0x40000000
-#define DDR_DX1DQTR 0xFFFFFFFF
-#define DDR_DX1DQSTR 0x3DB02000
 #define DDR_DX2GCR 0x0000CE81
-#define DDR_DX2DLLCR 0x40000000
-#define DDR_DX2DQTR 0xFFFFFFFF
-#define DDR_DX2DQSTR 0x3DB02000
 #define DDR_DX3GCR 0x0000CE81
-#define DDR_DX3DLLCR 0x40000000
-#define DDR_DX3DQTR 0xFFFFFFFF
-#define DDR_DX3DQSTR 0x3DB02000
 
 #include "stm32mp15-ddr.dtsi"
diff --git a/fdts/stm32mp15-fw-config.dtsi b/fdts/stm32mp15-fw-config.dtsi
index 8aece289a..ef5808183 100644
--- a/fdts/stm32mp15-fw-config.dtsi
+++ b/fdts/stm32mp15-fw-config.dtsi
@@ -14,14 +14,14 @@
 
 #define DDR_NS_BASE	STM32MP_DDR_BASE
 #ifdef AARCH32_SP_OPTEE
-/* OP-TEE reserved shared memory: located at DDR top */
-#define DDR_SHARE_SIZE	STM32MP_DDR_SHMEM_SIZE
-#define DDR_SHARE_BASE	(STM32MP_DDR_BASE + (DDR_SIZE - DDR_SHARE_SIZE))
-/* OP-TEE secure memory: located right below OP-TEE reserved shared memory */
-#define DDR_SEC_SIZE	STM32MP_DDR_S_SIZE
-#define DDR_SEC_BASE	(DDR_SHARE_BASE - DDR_SEC_SIZE)
-#define DDR_NS_SIZE	(DDR_SEC_BASE - DDR_NS_BASE)
-#else /* !AARCH32_SP_OPTEE */
+/* OP-TEE secure memory: located at DDR top */
+#define DDR_SEC_SIZE	0x01e00000
+#define DDR_SEC_BASE	(STM32MP_DDR_BASE + (DDR_SIZE - DDR_SEC_SIZE))
+/* OP-TEE reserved shared memory: located right below OP-TEE secure memory */
+#define DDR_SHARE_SIZE	0x00200000
+#define DDR_SHARE_BASE	(DDR_SEC_BASE - DDR_SHARE_SIZE)
+#define DDR_NS_SIZE	(DDR_SHARE_BASE - DDR_NS_BASE)
+#else /* AARCH32_SP_OPTEE */
 #define DDR_NS_SIZE	DDR_SIZE
 #endif /* AARCH32_SP_OPTEE */
 
@@ -69,9 +69,9 @@
 #ifdef AARCH32_SP_OPTEE
 		memory-ranges = <
 			DDR_NS_BASE DDR_NS_SIZE TZC_REGION_S_NONE TZC_REGION_NSEC_ALL_ACCESS_RDWR
-			DDR_SEC_BASE DDR_SEC_SIZE TZC_REGION_S_RDWR 0
 			DDR_SHARE_BASE DDR_SHARE_SIZE TZC_REGION_S_NONE
-			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_A7_ID)>;
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_A7_ID)
+			DDR_SEC_BASE DDR_SEC_SIZE TZC_REGION_S_RDWR 0>;
 #else
 		memory-ranges = <
 			DDR_NS_BASE DDR_NS_SIZE TZC_REGION_S_NONE TZC_REGION_NSEC_ALL_ACCESS_RDWR>;
diff --git a/fdts/stm32mp15-ssp-bl2.dtsi b/fdts/stm32mp15-ssp-bl2.dtsi
new file mode 100644
index 000000000..b8c75c073
--- /dev/null
+++ b/fdts/stm32mp15-ssp-bl2.dtsi
@@ -0,0 +1,98 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2020 - All Rights Reserved
+ */
+
+/ {
+	cpus {
+		/delete-node/ cpu@1;
+	};
+
+#if STM32MP_USB_PROGRAMMER
+	aliases {
+		/delete-property/ serial1;
+		/delete-property/ serial2;
+		/delete-property/ serial3;
+	};
+#endif
+
+	/delete-node/ cpu0_opp_table;
+	/delete-node/ psci;
+
+	soc {
+		efuse@5c005000 {
+			cfg2_otp: cfg2_otp@8 {
+				reg = <0x8 0x4>;
+			};
+
+			ssp_otp: ssp_otp@20 {
+				reg = <0x20 0x4>;
+			};
+
+			chip_otp: chip_otp@a0 {
+				reg = <0xa0 0x40>;
+			};
+
+			rma_otp: rma_otp@e0 {
+				reg = <0xe0 0x4>;
+			};
+		};
+
+		/delete-node/ timer@40006000;
+#if STM32MP_USB_PROGRAMMER
+		/delete-node/ serial@4000e000;
+		/delete-node/ serial@4000f000;
+		/delete-node/ serial@40011000;
+		/delete-node/ serial@40018000;
+		/delete-node/ serial@40019000;
+		/delete-node/ serial@44003000;
+#endif
+		/delete-node/ timer@44006000;
+#if STM32MP_UART_PROGRAMMER
+		/delete-node/ usb-otg@49000000;
+#endif
+		/delete-node/ pwr_mcu@50001014;
+		/delete-node/ cryp@54001000;
+		/delete-node/ rng@54003000;
+		/delete-node/ memory-controller@58002000;
+		/delete-node/ spi@58003000;
+		/delete-node/ mmc@58005000;
+		/delete-node/ mmc@58007000;
+		/delete-node/ ddr@5a003000;
+#if STM32MP_UART_PROGRAMMER
+		/delete-node/ usbphyc@5a006000;
+#endif
+#if STM32MP_USB_PROGRAMMER
+		/delete-node/ serial@5c000000;
+#endif
+		/delete-node/ spi@5c001000;
+		/delete-node/ rtc@5c004000;
+		/delete-node/ etzpc@5c007000;
+		/delete-node/ stgen@5c008000;
+		/delete-node/ i2c@5c009000;
+		/delete-node/ tamp@5c00a000;
+
+		pinctrl@50002000 {
+			/delete-node/ fmc-0;
+			/delete-node/ qspi-clk-0;
+			/delete-node/ qspi-bk1-0;
+			/delete-node/ qspi-bk2-0;
+			/delete-node/ sdmmc1-b4-0;
+			/delete-node/ sdmmc1-dir-0;
+			/delete-node/ sdmmc2-b4-0;
+			/delete-node/ sdmmc2-b4-1;
+			/delete-node/ sdmmc2-d47-0;
+#if STM32MP_USB_PROGRAMMER
+			/delete-node/ uart7-0;
+			/delete-node/ uart7-1;
+			/delete-node/ usart2-0;
+			/delete-node/ usart3-0;
+			/delete-node/ usart3-1;
+#endif
+#if STM32MP_UART_PROGRAMMER
+			/delete-node/ usbotg_hs-0;
+			/delete-node/ usbotg-fs-dp-dm-0;
+#endif
+		};
+	};
+};
diff --git a/fdts/stm32mp151.dtsi b/fdts/stm32mp151.dtsi
index ca93f0c35..6e8a3a216 100644
--- a/fdts/stm32mp151.dtsi
+++ b/fdts/stm32mp151.dtsi
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
 /*
- * Copyright (c) 2017-2021, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2017-2022, STMicroelectronics - All Rights Reserved
  * Author: Ludovic Barre <ludovic.barre@st.com> for STMicroelectronics.
  */
 #include <dt-bindings/interrupt-controller/arm-gic.h>
@@ -19,9 +19,19 @@
 			compatible = "arm,cortex-a7";
 			device_type = "cpu";
 			reg = <0>;
+			clocks = <&rcc CK_MPU>;
+			clock-names = "cpu";
+			operating-points-v2 = <&cpu0_opp_table>;
+			nvmem-cells = <&part_number_otp>;
+			nvmem-cell-names = "part_number";
 		};
 	};
 
+	cpu0_opp_table: cpu0-opp-table {
+		compatible = "operating-points-v2";
+		opp-shared;
+	};
+
 	psci {
 		compatible = "arm,psci-1.0";
 		method = "smc";
@@ -87,7 +97,7 @@
 		usart2: serial@4000e000 {
 			compatible = "st,stm32h7-uart";
 			reg = <0x4000e000 0x400>;
-			interrupts-extended = <&exti 27 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc USART2_K>;
 			resets = <&rcc USART2_R>;
 			status = "disabled";
@@ -96,7 +106,7 @@
 		usart3: serial@4000f000 {
 			compatible = "st,stm32h7-uart";
 			reg = <0x4000f000 0x400>;
-			interrupts-extended = <&exti 28 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 39 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc USART3_K>;
 			resets = <&rcc USART3_R>;
 			status = "disabled";
@@ -115,7 +125,7 @@
 		uart5: serial@40011000 {
 			compatible = "st,stm32h7-uart";
 			reg = <0x40011000 0x400>;
-			interrupts-extended = <&exti 31 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc UART5_K>;
 			resets = <&rcc UART5_R>;
 			status = "disabled";
@@ -139,7 +149,7 @@
 		uart7: serial@40018000 {
 			compatible = "st,stm32h7-uart";
 			reg = <0x40018000 0x400>;
-			interrupts-extended = <&exti 32 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 82 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc UART7_K>;
 			resets = <&rcc UART7_R>;
 			status = "disabled";
@@ -148,7 +158,7 @@
 		uart8: serial@40019000 {
 			compatible = "st,stm32h7-uart";
 			reg = <0x40019000 0x400>;
-			interrupts-extended = <&exti 33 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 83 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc UART8_K>;
 			resets = <&rcc UART8_R>;
 			status = "disabled";
@@ -157,7 +167,7 @@
 		usart6: serial@44003000 {
 			compatible = "st,stm32h7-uart";
 			reg = <0x44003000 0x400>;
-			interrupts-extended = <&exti 29 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc USART6_K>;
 			resets = <&rcc USART6_R>;
 			status = "disabled";
@@ -180,7 +190,7 @@
 			clock-names = "otg";
 			resets = <&rcc USBO_R>;
 			reset-names = "dwc2";
-			interrupts-extended = <&exti 44 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>;
 			g-rx-fifo-size = <512>;
 			g-np-tx-fifo-size = <32>;
 			g-tx-fifo-size = <256 16 16 16 16 16 16 16>;
@@ -190,7 +200,7 @@
 		};
 
 		rcc: rcc@50000000 {
-			compatible = "st,stm32mp1-rcc", "syscon";
+			compatible = "st,stm32mp1-rcc-secure", "st,stm32mp1-rcc", "syscon";
 			reg = <0x50000000 0x1000>;
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -316,6 +326,8 @@
 			interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc QSPI_K>;
 			resets = <&rcc QSPI_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
 			status = "disabled";
 		};
 
@@ -457,20 +469,47 @@
 			reg = <0x5c005000 0x400>;
 			#address-cells = <1>;
 			#size-cells = <1>;
+
+			cfg0_otp: cfg0_otp@0 {
+				reg = <0x0 0x1>;
+			};
+			part_number_otp: part_number_otp@4 {
+				reg = <0x4 0x1>;
+			};
+			monotonic_otp: monotonic_otp@10 {
+				reg = <0x10 0x4>;
+			};
+			nand_otp: nand_otp@24 {
+				reg = <0x24 0x4>;
+			};
+			uid_otp: uid_otp@34 {
+				reg = <0x34 0xc>;
+			};
+			package_otp: package_otp@40 {
+				reg = <0x40 0x4>;
+			};
+			hw2_otp: hw2_otp@48 {
+				reg = <0x48 0x4>;
+			};
 			ts_cal1: calib@5c {
 				reg = <0x5c 0x2>;
 			};
 			ts_cal2: calib@5e {
 				reg = <0x5e 0x2>;
 			};
+			pkh_otp: pkh_otp@60 {
+				reg = <0x60 0x20>;
+			};
+			ethernet_mac_address: mac@e4 {
+				reg = <0xe4 0x8>;
+				st,non-secure-otp;
+			};
 		};
 
 		etzpc: etzpc@5c007000 {
 			compatible = "st,stm32-etzpc";
 			reg = <0x5C007000 0x400>;
 			clocks = <&rcc TZPC>;
-			status = "disabled";
-			secure-status = "okay";
 		};
 
 		stgen: stgen@5c008000 {
@@ -504,7 +543,7 @@
 		 * Break node order to solve dependency probe issue between
 		 * pinctrl and exti.
 		 */
-		pinctrl: pin-controller@50002000 {
+		pinctrl: pinctrl@50002000 {
 			#address-cells = <1>;
 			#size-cells = <1>;
 			compatible = "st,stm32mp157-pinctrl";
@@ -635,7 +674,7 @@
 			};
 		};
 
-		pinctrl_z: pin-controller-z@54004000 {
+		pinctrl_z: pinctrl@54004000 {
 			#address-cells = <1>;
 			#size-cells = <1>;
 			compatible = "st,stm32mp157-z-pinctrl";
diff --git a/fdts/stm32mp153.dtsi b/fdts/stm32mp153.dtsi
index 0a0bb8dc1..617380a52 100644
--- a/fdts/stm32mp153.dtsi
+++ b/fdts/stm32mp153.dtsi
@@ -14,6 +14,7 @@
 			reg = <1>;
 			clocks = <&rcc CK_MPU>;
 			clock-names = "cpu";
+			operating-points-v2 = <&cpu0_opp_table>;
 		};
 	};
 };
diff --git a/fdts/stm32mp157a-avenger96.dts b/fdts/stm32mp157a-avenger96.dts
index b967736e4..5d8f01c1f 100644
--- a/fdts/stm32mp157a-avenger96.dts
+++ b/fdts/stm32mp157a-avenger96.dts
@@ -10,9 +10,11 @@
 /dts-v1/;
 
 #include "stm32mp157.dtsi"
+#include "stm32mp15xa.dtsi"
 #include "stm32mp15-pinctrl.dtsi"
 #include "stm32mp15xxac-pinctrl.dtsi"
 #include <dt-bindings/clock/stm32mp1-clksrc.h>
+#include <dt-bindings/soc/st,stm32-etzpc.h>
 #include "stm32mp15-ddr3-2x4Gb-1066-binG.dtsi"
 
 / {
@@ -35,6 +37,22 @@
 	};
 };
 
+&etzpc {
+	st,decprot = <
+		DECPROT(STM32MP1_ETZPC_USART1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_SPI6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_I2C4_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_I2C6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_RNG1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_HASH1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_DDRCTRL_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_DDRPHYC_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_STGENC_ID, DECPROT_S_RW, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_BKPSRAM_ID, DECPROT_S_RW, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_IWDG1_ID, DECPROT_S_RW, DECPROT_LOCK)
+	>;
+};
+
 &i2c4 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&i2c4_pins_a>;
@@ -115,10 +133,9 @@
 
 			vtt_ddr: ldo3 {
 				regulator-name = "vtt_ddr";
-				regulator-min-microvolt = <500000>;
-				regulator-max-microvolt = <750000>;
 				regulator-always-on;
 				regulator-over-current-protection;
+				st,regulator-sink-source;
 			};
 
 			vdd_usb: ldo4 {
@@ -143,7 +160,6 @@
 			vref_ddr: vref_ddr {
 				regulator-name = "vref_ddr";
 				regulator-always-on;
-				regulator-over-current-protection;
 			};
 
 			bst_out: boost {
@@ -165,7 +181,6 @@
 &iwdg2 {
 	timeout-sec = <32>;
 	status = "okay";
-	secure-status = "okay";
 };
 
 &pwr_regulators {
@@ -174,7 +189,7 @@
 };
 
 &rcc {
-	secure-status = "disabled";
+	compatible = "st,stm32mp1-rcc", "syscon";
 	st,clksrc = <
 		CLK_MPU_PLL1P
 		CLK_AXI_PLL2P
diff --git a/fdts/stm32mp157a-dk1.dts b/fdts/stm32mp157a-dk1.dts
index a73bef8ee..5d5c0a5f7 100644
--- a/fdts/stm32mp157a-dk1.dts
+++ b/fdts/stm32mp157a-dk1.dts
@@ -7,9 +7,11 @@
 /dts-v1/;
 
 #include "stm32mp157.dtsi"
+#include "stm32mp15xa.dtsi"
 #include "stm32mp15-pinctrl.dtsi"
 #include "stm32mp15xxac-pinctrl.dtsi"
 #include "stm32mp15xx-dkx.dtsi"
+#include <dt-bindings/soc/st,stm32-etzpc.h>
 
 / {
 	model = "STMicroelectronics STM32MP157A-DK1 Discovery Board";
@@ -25,3 +27,19 @@
 		stdout-path = "serial0:115200n8";
 	};
 };
+
+&etzpc {
+	st,decprot = <
+		DECPROT(STM32MP1_ETZPC_USART1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_SPI6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_I2C4_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_I2C6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_RNG1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_HASH1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_DDRCTRL_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_DDRPHYC_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_STGENC_ID, DECPROT_S_RW, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_BKPSRAM_ID, DECPROT_S_RW, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_IWDG1_ID, DECPROT_S_RW, DECPROT_LOCK)
+	>;
+};
diff --git a/fdts/stm32mp157a-ed1.dts b/fdts/stm32mp157a-ed1.dts
new file mode 100644
index 000000000..1527b642a
--- /dev/null
+++ b/fdts/stm32mp157a-ed1.dts
@@ -0,0 +1,38 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xa.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxaa-pinctrl.dtsi"
+#include "stm32mp15xx-edx.dtsi"
+#include <dt-bindings/soc/st,stm32-etzpc.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157A eval daughter";
+	compatible = "st,stm32mp157a-ed1", "st,stm32mp157";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+};
+
+&etzpc {
+	st,decprot = <
+		DECPROT(STM32MP1_ETZPC_USART1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_SPI6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_I2C4_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_I2C6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_RNG1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_HASH1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_DDRCTRL_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_DDRPHYC_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_STGENC_ID, DECPROT_S_RW, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_BKPSRAM_ID, DECPROT_S_RW, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_IWDG1_ID, DECPROT_S_RW, DECPROT_LOCK)
+	>;
+};
diff --git a/fdts/stm32mp157a-ev1.dts b/fdts/stm32mp157a-ev1.dts
new file mode 100644
index 000000000..3cb35698a
--- /dev/null
+++ b/fdts/stm32mp157a-ev1.dts
@@ -0,0 +1,24 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157a-ed1.dts"
+#include "stm32mp15xx-evx.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP157A eval daughter on eval mother";
+	compatible = "st,stm32mp157a-ev1", "st,stm32mp157a-ed1", "st,stm32mp157";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		serial0 = &uart4;
+		serial1 = &usart3;
+	};
+};
+
diff --git a/fdts/stm32mp157c-dk2.dts b/fdts/stm32mp157c-dk2.dts
index be8300e9e..ff5c4509f 100644
--- a/fdts/stm32mp157c-dk2.dts
+++ b/fdts/stm32mp157c-dk2.dts
@@ -11,6 +11,7 @@
 #include "stm32mp15-pinctrl.dtsi"
 #include "stm32mp15xxac-pinctrl.dtsi"
 #include "stm32mp15xx-dkx.dtsi"
+#include <dt-bindings/soc/st,stm32-etzpc.h>
 
 / {
 	model = "STMicroelectronics STM32MP157C-DK2 Discovery Board";
@@ -31,3 +32,20 @@
 &cryp1 {
 	status = "okay";
 };
+
+&etzpc {
+	st,decprot = <
+		DECPROT(STM32MP1_ETZPC_USART1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_SPI6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_I2C4_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_I2C6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_RNG1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_HASH1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_CRYP1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_DDRCTRL_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_DDRPHYC_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_STGENC_ID, DECPROT_S_RW, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_BKPSRAM_ID, DECPROT_S_RW, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_IWDG1_ID, DECPROT_S_RW, DECPROT_LOCK)
+	>;
+};
diff --git a/fdts/stm32mp157c-ed1.dts b/fdts/stm32mp157c-ed1.dts
index 11e0a6111..55d16fa31 100644
--- a/fdts/stm32mp157c-ed1.dts
+++ b/fdts/stm32mp157c-ed1.dts
@@ -9,8 +9,8 @@
 #include "stm32mp15xc.dtsi"
 #include "stm32mp15-pinctrl.dtsi"
 #include "stm32mp15xxaa-pinctrl.dtsi"
-#include <dt-bindings/clock/stm32mp1-clksrc.h>
-#include "stm32mp15-ddr3-2x4Gb-1066-binG.dtsi"
+#include "stm32mp15xx-edx.dtsi"
+#include <dt-bindings/soc/st,stm32-etzpc.h>
 
 / {
 	model = "STMicroelectronics STM32MP157C eval daughter";
@@ -19,325 +19,26 @@
 	chosen {
 		stdout-path = "serial0:115200n8";
 	};
-
-	memory@c0000000 {
-		device_type = "memory";
-		reg = <0xC0000000 0x40000000>;
-	};
-
-	aliases {
-		serial0 = &uart4;
-	};
-};
-
-&bsec {
-	board_id: board_id@ec {
-		reg = <0xec 0x4>;
-		status = "okay";
-		secure-status = "okay";
-	};
-};
-
-&clk_hse {
-	st,digbypass;
-};
-
-&cpu0 {
-	cpu-supply = <&vddcore>;
-};
-
-&cpu1 {
-	cpu-supply = <&vddcore>;
 };
 
 &cryp1 {
 	status = "okay";
 };
 
-&hash1 {
-	status = "okay";
-};
-
-&i2c4 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&i2c4_pins_a>;
-	i2c-scl-rising-time-ns = <185>;
-	i2c-scl-falling-time-ns = <20>;
-	clock-frequency = <400000>;
-	status = "okay";
-
-	pmic: stpmic@33 {
-		compatible = "st,stpmic1";
-		reg = <0x33>;
-		interrupts-extended = <&exti_pwr 55 IRQ_TYPE_EDGE_FALLING>;
-		interrupt-controller;
-		#interrupt-cells = <2>;
-		status = "okay";
-
-		regulators {
-			compatible = "st,stpmic1-regulators";
-			ldo1-supply = <&v3v3>;
-			ldo2-supply = <&v3v3>;
-			ldo3-supply = <&vdd_ddr>;
-			ldo5-supply = <&v3v3>;
-			ldo6-supply = <&v3v3>;
-			pwr_sw1-supply = <&bst_out>;
-			pwr_sw2-supply = <&bst_out>;
-
-			vddcore: buck1 {
-				regulator-name = "vddcore";
-				regulator-min-microvolt = <1200000>;
-				regulator-max-microvolt = <1350000>;
-				regulator-always-on;
-				regulator-initial-mode = <0>;
-				regulator-over-current-protection;
-			};
-
-			vdd_ddr: buck2 {
-				regulator-name = "vdd_ddr";
-				regulator-min-microvolt = <1350000>;
-				regulator-max-microvolt = <1350000>;
-				regulator-always-on;
-				regulator-initial-mode = <0>;
-				regulator-over-current-protection;
-			};
-
-			vdd: buck3 {
-				regulator-name = "vdd";
-				regulator-min-microvolt = <3300000>;
-				regulator-max-microvolt = <3300000>;
-				regulator-always-on;
-				st,mask-reset;
-				regulator-initial-mode = <0>;
-				regulator-over-current-protection;
-			};
-
-			v3v3: buck4 {
-				regulator-name = "v3v3";
-				regulator-min-microvolt = <3300000>;
-				regulator-max-microvolt = <3300000>;
-				regulator-always-on;
-				regulator-over-current-protection;
-				regulator-initial-mode = <0>;
-			};
-
-			vdda: ldo1 {
-				regulator-name = "vdda";
-				regulator-min-microvolt = <2900000>;
-				regulator-max-microvolt = <2900000>;
-			};
-
-			v2v8: ldo2 {
-				regulator-name = "v2v8";
-				regulator-min-microvolt = <2800000>;
-				regulator-max-microvolt = <2800000>;
-			};
-
-			vtt_ddr: ldo3 {
-				regulator-name = "vtt_ddr";
-				regulator-min-microvolt = <500000>;
-				regulator-max-microvolt = <750000>;
-				regulator-always-on;
-				regulator-over-current-protection;
-			};
-
-			vdd_usb: ldo4 {
-				regulator-name = "vdd_usb";
-			};
-
-			vdd_sd: ldo5 {
-				regulator-name = "vdd_sd";
-				regulator-min-microvolt = <2900000>;
-				regulator-max-microvolt = <2900000>;
-				regulator-boot-on;
-			};
-
-			v1v8: ldo6 {
-				regulator-name = "v1v8";
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <1800000>;
-			};
-
-			vref_ddr: vref_ddr {
-				regulator-name = "vref_ddr";
-				regulator-always-on;
-			};
-
-			bst_out: boost {
-				regulator-name = "bst_out";
-			};
-
-			vbus_otg: pwr_sw1 {
-				regulator-name = "vbus_otg";
-			 };
-
-			 vbus_sw: pwr_sw2 {
-				regulator-name = "vbus_sw";
-				regulator-active-discharge = <1>;
-			 };
-		};
-
-		onkey {
-			compatible = "st,stpmic1-onkey";
-			power-off-time-sec = <10>;
-			status = "okay";
-		};
-
-		watchdog {
-			compatible = "st,stpmic1-wdt";
-			status = "disabled";
-		};
-	};
-};
-
-&iwdg2 {
-	timeout-sec = <32>;
-	status = "okay";
-};
-
-&pwr_regulators {
-	vdd-supply = <&vdd>;
-	vdd_3v3_usbfs-supply = <&vdd_usb>;
-};
-
-&rcc {
-	secure-status = "disabled";
-	st,clksrc = <
-		CLK_MPU_PLL1P
-		CLK_AXI_PLL2P
-		CLK_MCU_PLL3P
-		CLK_PLL12_HSE
-		CLK_PLL3_HSE
-		CLK_PLL4_HSE
-		CLK_RTC_LSE
-		CLK_MCO1_DISABLED
-		CLK_MCO2_DISABLED
+&etzpc {
+	st,decprot = <
+		DECPROT(STM32MP1_ETZPC_USART1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_SPI6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_I2C4_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_I2C6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_RNG1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_HASH1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_CRYP1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_DDRCTRL_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_DDRPHYC_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_STGENC_ID, DECPROT_S_RW, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_BKPSRAM_ID, DECPROT_S_RW, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_IWDG1_ID, DECPROT_S_RW, DECPROT_LOCK)
 	>;
-
-	st,clkdiv = <
-		1 /*MPU*/
-		0 /*AXI*/
-		0 /*MCU*/
-		1 /*APB1*/
-		1 /*APB2*/
-		1 /*APB3*/
-		1 /*APB4*/
-		2 /*APB5*/
-		23 /*RTC*/
-		0 /*MCO1*/
-		0 /*MCO2*/
-	>;
-
-	st,pkcs = <
-		CLK_CKPER_HSE
-		CLK_FMC_ACLK
-		CLK_QSPI_ACLK
-		CLK_ETH_PLL4P
-		CLK_SDMMC12_PLL4P
-		CLK_DSI_DSIPLL
-		CLK_STGEN_HSE
-		CLK_USBPHY_HSE
-		CLK_SPI2S1_PLL3Q
-		CLK_SPI2S23_PLL3Q
-		CLK_SPI45_HSI
-		CLK_SPI6_HSI
-		CLK_I2C46_HSI
-		CLK_SDMMC3_PLL4P
-		CLK_USBO_USBPHY
-		CLK_ADC_CKPER
-		CLK_CEC_LSE
-		CLK_I2C12_HSI
-		CLK_I2C35_HSI
-		CLK_UART1_HSI
-		CLK_UART24_HSI
-		CLK_UART35_HSI
-		CLK_UART6_HSI
-		CLK_UART78_HSI
-		CLK_SPDIF_PLL4P
-		CLK_FDCAN_PLL4R
-		CLK_SAI1_PLL3Q
-		CLK_SAI2_PLL3Q
-		CLK_SAI3_PLL3Q
-		CLK_SAI4_PLL3Q
-		CLK_RNG1_LSI
-		CLK_RNG2_LSI
-		CLK_LPTIM1_PCLK1
-		CLK_LPTIM23_PCLK3
-		CLK_LPTIM45_LSE
-	>;
-
-	/* VCO = 1300.0 MHz => P = 650 (CPU) */
-	pll1: st,pll@0 {
-		compatible = "st,stm32mp1-pll";
-		reg = <0>;
-		cfg = <2 80 0 0 0 PQR(1,0,0)>;
-		frac = <0x800>;
-	};
-
-	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
-	pll2: st,pll@1 {
-		compatible = "st,stm32mp1-pll";
-		reg = <1>;
-		cfg = <2 65 1 0 0 PQR(1,1,1)>;
-		frac = <0x1400>;
-	};
-
-	/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
-	pll3: st,pll@2 {
-		compatible = "st,stm32mp1-pll";
-		reg = <2>;
-		cfg = <1 33 1 16 36 PQR(1,1,1)>;
-		frac = <0x1a04>;
-	};
-
-	/* VCO = 594.0 MHz => P = 99, Q = 74, R = 74 */
-	pll4: st,pll@3 {
-		compatible = "st,stm32mp1-pll";
-		reg = <3>;
-		cfg = <3 98 5 7 7 PQR(1,1,1)>;
-	};
-};
-
-&rng1 {
-	status = "okay";
-};
-
-&rtc {
-	status = "okay";
 };
 
-&sdmmc1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_dir_pins_a>;
-	disable-wp;
-	st,sig-dir;
-	st,neg-edge;
-	st,use-ckin;
-	bus-width = <4>;
-	vmmc-supply = <&vdd_sd>;
-	sd-uhs-sdr12;
-	sd-uhs-sdr25;
-	sd-uhs-sdr50;
-	sd-uhs-ddr50;
-	status = "okay";
-};
-
-&sdmmc2 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
-	non-removable;
-	no-sd;
-	no-sdio;
-	st,neg-edge;
-	bus-width = <8>;
-	vmmc-supply = <&v3v3>;
-	vqmmc-supply = <&vdd>;
-	mmc-ddr-3_3v;
-	status = "okay";
-};
-
-&uart4 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&uart4_pins_a>;
-	status = "okay";
-};
diff --git a/fdts/stm32mp157c-ev1.dts b/fdts/stm32mp157c-ev1.dts
index 02840a2e5..9c9b04156 100644
--- a/fdts/stm32mp157c-ev1.dts
+++ b/fdts/stm32mp157c-ev1.dts
@@ -6,6 +6,7 @@
 /dts-v1/;
 
 #include "stm32mp157c-ed1.dts"
+#include "stm32mp15xx-evx.dtsi"
 
 / {
 	model = "STMicroelectronics STM32MP157C eval daughter on eval mother";
@@ -16,48 +17,7 @@
 	};
 
 	aliases {
+		serial0 = &uart4;
 		serial1 = &usart3;
 	};
 };
-
-&fmc {
-	pinctrl-names = "default";
-	pinctrl-0 = <&fmc_pins_a>;
-	status = "okay";
-
-	nand-controller@4,0 {
-		status = "okay";
-
-		nand@0 {
-			reg = <0>;
-			nand-on-flash-bbt;
-			#address-cells = <1>;
-			#size-cells = <1>;
-		};
-	};
-};
-
-&qspi {
-	pinctrl-names = "default";
-	pinctrl-0 = <&qspi_clk_pins_a &qspi_bk1_pins_a>;
-	reg = <0x58003000 0x1000>, <0x70000000 0x4000000>;
-	#address-cells = <1>;
-	#size-cells = <0>;
-	status = "okay";
-
-	flash0: mx66l51235l@0 {
-		compatible = "jedec,spi-nor";
-		reg = <0>;
-		spi-rx-bus-width = <4>;
-		spi-max-frequency = <108000000>;
-		#address-cells = <1>;
-		#size-cells = <1>;
-	};
-};
-
-&usart3 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&usart3_pins_b>;
-	uart-has-rtscts;
-	status = "disabled";
-};
diff --git a/fdts/stm32mp157c-odyssey-som.dtsi b/fdts/stm32mp157c-odyssey-som.dtsi
index 6bed33968..b7250f759 100644
--- a/fdts/stm32mp157c-odyssey-som.dtsi
+++ b/fdts/stm32mp157c-odyssey-som.dtsi
@@ -140,10 +140,9 @@
 
 			vtt_ddr: ldo3 {
 				regulator-name = "vtt_ddr";
-				regulator-min-microvolt = <500000>;
-				regulator-max-microvolt = <750000>;
 				regulator-always-on;
 				regulator-over-current-protection;
+				st,regulator-sink-source;
 			};
 
 			vdd_usb: ldo4 {
@@ -170,7 +169,6 @@
 			vref_ddr: vref_ddr {
 				regulator-name = "vref_ddr";
 				regulator-always-on;
-				regulator-over-current-protection;
 			};
 
 			bst_out: boost {
@@ -205,7 +203,7 @@
 };
 
 &rcc {
-	secure-status = "disabled";
+	compatible = "st,stm32mp1-rcc", "syscon";
 	st,clksrc = <
 		CLK_MPU_PLL1P
 		CLK_AXI_PLL2P
diff --git a/fdts/stm32mp157d-dk1.dts b/fdts/stm32mp157d-dk1.dts
new file mode 100644
index 000000000..79297b831
--- /dev/null
+++ b/fdts/stm32mp157d-dk1.dts
@@ -0,0 +1,45 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xd.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxac-pinctrl.dtsi"
+#include "stm32mp15xx-dkx.dtsi"
+#include <dt-bindings/soc/st,stm32-etzpc.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157D-DK1 Discovery Board";
+	compatible = "st,stm32mp157d-dk1", "st,stm32mp157";
+
+	aliases {
+		serial0 = &uart4;
+		serial1 = &usart3;
+		serial2 = &uart7;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+};
+
+&etzpc {
+	st,decprot = <
+		DECPROT(STM32MP1_ETZPC_USART1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_SPI6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_I2C4_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_I2C6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_RNG1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_HASH1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_DDRCTRL_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_DDRPHYC_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_STGENC_ID, DECPROT_S_RW, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_BKPSRAM_ID, DECPROT_S_RW, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_IWDG1_ID, DECPROT_S_RW, DECPROT_LOCK)
+	>;
+};
diff --git a/fdts/stm32mp157d-ed1.dts b/fdts/stm32mp157d-ed1.dts
new file mode 100644
index 000000000..2c67ec0ac
--- /dev/null
+++ b/fdts/stm32mp157d-ed1.dts
@@ -0,0 +1,39 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xd.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxaa-pinctrl.dtsi"
+#include "stm32mp15xx-edx.dtsi"
+#include <dt-bindings/soc/st,stm32-etzpc.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157D eval daughter";
+	compatible = "st,stm32mp157d-ed1", "st,stm32mp157";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+};
+
+
+&etzpc {
+	st,decprot = <
+		DECPROT(STM32MP1_ETZPC_USART1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_SPI6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_I2C4_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_I2C6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_RNG1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_HASH1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_DDRCTRL_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_DDRPHYC_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_STGENC_ID, DECPROT_S_RW, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_BKPSRAM_ID, DECPROT_S_RW, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_IWDG1_ID, DECPROT_S_RW, DECPROT_LOCK)
+	>;
+};
diff --git a/fdts/stm32mp157d-ev1.dts b/fdts/stm32mp157d-ev1.dts
new file mode 100644
index 000000000..4a40f5fe5
--- /dev/null
+++ b/fdts/stm32mp157d-ev1.dts
@@ -0,0 +1,23 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157d-ed1.dts"
+#include "stm32mp15xx-evx.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP157D eval daughter on eval mother";
+	compatible = "st,stm32mp157d-ev1", "st,stm32mp157d-ed1", "st,stm32mp157";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		serial0 = &uart4;
+		serial1 = &usart3;
+	};
+};
diff --git a/fdts/stm32mp157f-dk2.dts b/fdts/stm32mp157f-dk2.dts
new file mode 100644
index 000000000..680ca0f6e
--- /dev/null
+++ b/fdts/stm32mp157f-dk2.dts
@@ -0,0 +1,51 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xf.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxac-pinctrl.dtsi"
+#include "stm32mp15xx-dkx.dtsi"
+#include <dt-bindings/soc/st,stm32-etzpc.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157F-DK2 Discovery Board";
+	compatible = "st,stm32mp157f-dk2", "st,stm32mp157";
+
+	aliases {
+		serial0 = &uart4;
+		serial1 = &usart3;
+		serial2 = &uart7;
+		serial3 = &usart2;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&etzpc {
+	st,decprot = <
+		DECPROT(STM32MP1_ETZPC_USART1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_SPI6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_I2C4_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_I2C6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_RNG1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_HASH1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_CRYP1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_DDRCTRL_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_DDRPHYC_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_STGENC_ID, DECPROT_S_RW, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_BKPSRAM_ID, DECPROT_S_RW, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_IWDG1_ID, DECPROT_S_RW, DECPROT_LOCK)
+	>;
+};
diff --git a/fdts/stm32mp157f-ed1.dts b/fdts/stm32mp157f-ed1.dts
new file mode 100644
index 000000000..1aa26cdbb
--- /dev/null
+++ b/fdts/stm32mp157f-ed1.dts
@@ -0,0 +1,43 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xf.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxaa-pinctrl.dtsi"
+#include "stm32mp15xx-edx.dtsi"
+#include <dt-bindings/soc/st,stm32-etzpc.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157F eval daughter";
+	compatible = "st,stm32mp157f-ed1", "st,stm32mp157";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&etzpc {
+	st,decprot = <
+		DECPROT(STM32MP1_ETZPC_USART1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_SPI6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_I2C4_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_I2C6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_RNG1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_HASH1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_CRYP1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+		DECPROT(STM32MP1_ETZPC_DDRCTRL_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_DDRPHYC_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_STGENC_ID, DECPROT_S_RW, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_BKPSRAM_ID, DECPROT_S_RW, DECPROT_LOCK)
+		DECPROT(STM32MP1_ETZPC_IWDG1_ID, DECPROT_S_RW, DECPROT_LOCK)
+	>;
+};
diff --git a/fdts/stm32mp157f-ev1.dts b/fdts/stm32mp157f-ev1.dts
new file mode 100644
index 000000000..caf5dfe11
--- /dev/null
+++ b/fdts/stm32mp157f-ev1.dts
@@ -0,0 +1,23 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157f-ed1.dts"
+#include "stm32mp15xx-evx.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP157F eval daughter on eval mother";
+	compatible = "st,stm32mp157f-ev1", "st,stm32mp157f-ed1", "st,stm32mp157";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		serial0 = &uart4;
+		serial1 = &usart3;
+	};
+};
diff --git a/fdts/stm32mp15xa.dtsi b/fdts/stm32mp15xa.dtsi
new file mode 100644
index 000000000..5ed7e594f
--- /dev/null
+++ b/fdts/stm32mp15xa.dtsi
@@ -0,0 +1,13 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+&cpu0_opp_table {
+		opp-650000000 {
+			opp-hz = /bits/ 64 <650000000>;
+			opp-microvolt = <1200000>;
+			opp-supported-hw = <0x1>;
+		};
+};
diff --git a/fdts/stm32mp15xc.dtsi b/fdts/stm32mp15xc.dtsi
index b06a55a2f..f729b0d1b 100644
--- a/fdts/stm32mp15xc.dtsi
+++ b/fdts/stm32mp15xc.dtsi
@@ -4,6 +4,8 @@
  * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
  */
 
+#include "stm32mp15xa.dtsi"
+
 / {
 	soc {
 		cryp1: cryp@54001000 {
diff --git a/fdts/stm32mp15xd.dtsi b/fdts/stm32mp15xd.dtsi
new file mode 100644
index 000000000..18b05ee38
--- /dev/null
+++ b/fdts/stm32mp15xd.dtsi
@@ -0,0 +1,19 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+&cpu0_opp_table {
+		opp-800000000 {
+			opp-hz = /bits/ 64 <800000000>;
+			opp-microvolt = <1350000>;
+			opp-supported-hw = <0x2>;
+		};
+		opp-400000000 {
+			opp-hz = /bits/ 64 <400000000>;
+			opp-microvolt = <1200000>;
+			opp-supported-hw = <0x2>;
+			opp-suspend;
+		};
+};
diff --git a/fdts/stm32mp15xf.dtsi b/fdts/stm32mp15xf.dtsi
new file mode 100644
index 000000000..ae4a14af6
--- /dev/null
+++ b/fdts/stm32mp15xf.dtsi
@@ -0,0 +1,20 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+#include "stm32mp15xd.dtsi"
+
+/ {
+	soc {
+		cryp1: cryp@54001000 {
+			compatible = "st,stm32mp1-cryp";
+			reg = <0x54001000 0x400>;
+			interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CRYP1>;
+			resets = <&rcc CRYP1_R>;
+			status = "disabled";
+		};
+	};
+};
diff --git a/fdts/stm32mp15xx-dkx.dtsi b/fdts/stm32mp15xx-dkx.dtsi
index 9cc5368d8..c878f6368 100644
--- a/fdts/stm32mp15xx-dkx.dtsi
+++ b/fdts/stm32mp15xx-dkx.dtsi
@@ -1,10 +1,11 @@
 // SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
 /*
- * Copyright (c) 2019-2021, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2019-2022, STMicroelectronics - All Rights Reserved
  * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
  */
 
 #include <dt-bindings/clock/stm32mp1-clksrc.h>
+#include <dt-bindings/power/stm32mp1-power.h>
 #include "stm32mp15-ddr3-1x4Gb-1066-binG.dtsi"
 
 / {
@@ -131,10 +132,9 @@
 
 			vtt_ddr: ldo3 {
 				regulator-name = "vtt_ddr";
-				regulator-min-microvolt = <500000>;
-				regulator-max-microvolt = <750000>;
 				regulator-always-on;
 				regulator-over-current-protection;
+				st,regulator-sink-source;
 			};
 
 			vdd_usb: ldo4 {
@@ -160,7 +160,6 @@
 			vref_ddr: vref_ddr {
 				regulator-name = "vref_ddr";
 				regulator-always-on;
-				regulator-over-current-protection;
 			};
 
 			bst_out: boost {
@@ -181,17 +180,25 @@
 
 &iwdg2 {
 	timeout-sec = <32>;
+	secure-timeout-sec = <5>;
 	status = "okay";
-	secure-status = "okay";
 };
 
 &pwr_regulators {
+	system_suspend_supported_soc_modes = <
+		STM32_PM_CSLEEP_RUN
+		STM32_PM_CSTOP_ALLOW_LP_STOP
+		STM32_PM_CSTOP_ALLOW_STANDBY_DDR_SR
+	>;
+	system_off_soc_mode = <STM32_PM_CSTOP_ALLOW_STANDBY_DDR_OFF>;
 	vdd-supply = <&vdd>;
 	vdd_3v3_usbfs-supply = <&vdd_usb>;
 };
 
 &rcc {
-	secure-status = "disabled";
+	st,hsi-cal;
+	st,csi-cal;
+	st,cal-sec = <60>;
 	st,clksrc = <
 		CLK_MPU_PLL1P
 		CLK_AXI_PLL2P
@@ -249,21 +256,13 @@
 		CLK_SAI2_PLL3Q
 		CLK_SAI3_PLL3Q
 		CLK_SAI4_PLL3Q
-		CLK_RNG1_LSI
+		CLK_RNG1_CSI
 		CLK_RNG2_LSI
 		CLK_LPTIM1_PCLK1
 		CLK_LPTIM23_PCLK3
 		CLK_LPTIM45_LSE
 	>;
 
-	/* VCO = 1300.0 MHz => P = 650 (CPU) */
-	pll1: st,pll@0 {
-		compatible = "st,stm32mp1-pll";
-		reg = <0>;
-		cfg = < 2 80 0 0 0 PQR(1,0,0) >;
-		frac = < 0x800 >;
-	};
-
 	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
 	pll2: st,pll@1 {
 		compatible = "st,stm32mp1-pll";
@@ -307,7 +306,9 @@
 };
 
 &timers15 {
-	secure-status = "okay";
+	status = "okay";
+	st,hsi-cal-input = <7>;
+	st,csi-cal-input = <8>;
 };
 
 &uart4 {
@@ -347,3 +348,128 @@
 &usbphyc_port1 {
 	phy-supply = <&vdd_usb>;
 };
+
+/* Low-power states of regulators */
+&v1v2_hdmi {
+	standby-ddr-sr {
+		regulator-off-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
+
+&v1v8_audio {
+	standby-ddr-sr {
+		regulator-off-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
+
+&v3v3 {
+	lp-stop {
+		regulator-suspend-microvolt = <3300000>;
+		regulator-on-in-suspend;
+	};
+	standby-ddr-sr {
+		regulator-off-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
+
+&v3v3_hdmi {
+	standby-ddr-sr {
+		regulator-off-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
+
+&vdd {
+	lp-stop {
+		regulator-suspend-microvolt = <3300000>;
+		regulator-on-in-suspend;
+	};
+	standby-ddr-sr {
+		regulator-suspend-microvolt = <3300000>;
+		regulator-on-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-suspend-microvolt = <3300000>;
+		regulator-on-in-suspend;
+	};
+};
+
+&vdda {
+	standby-ddr-sr {
+		regulator-off-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
+
+&vddcore {
+	lp-stop {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <1200000>;
+	};
+	standby-ddr-sr {
+		regulator-off-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
+
+&vdd_ddr {
+	lp-stop {
+		regulator-suspend-microvolt = <1350000>;
+		regulator-on-in-suspend;
+	};
+	standby-ddr-sr {
+		regulator-suspend-microvolt = <1350000>;
+		regulator-on-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
+
+&vdd_usb {
+	standby-ddr-sr {
+		regulator-off-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
+
+&vref_ddr {
+	lp-stop {
+		regulator-on-in-suspend;
+	};
+	standby-ddr-sr {
+		regulator-on-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
+
+&vtt_ddr {
+	lp-stop {
+		regulator-off-in-suspend;
+	};
+	standby-ddr-sr {
+		regulator-off-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
diff --git a/fdts/stm32mp15xx-edx.dtsi b/fdts/stm32mp15xx-edx.dtsi
new file mode 100644
index 000000000..f906ed63a
--- /dev/null
+++ b/fdts/stm32mp15xx-edx.dtsi
@@ -0,0 +1,491 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
+ * Author: Ludovic Barre <ludovic.barre@st.com> for STMicroelectronics.
+ */
+
+#include <dt-bindings/clock/stm32mp1-clksrc.h>
+#include <dt-bindings/power/stm32mp1-power.h>
+#include "stm32mp15-ddr3-2x4Gb-1066-binG.dtsi"
+
+/ {
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xC0000000 0x40000000>;
+	};
+
+	aliases {
+		serial0 = &uart4;
+	};
+
+	vin: vin {
+		compatible = "regulator-fixed";
+		regulator-name = "vin";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+};
+
+&bsec {
+	board_id: board_id@ec {
+		reg = <0xec 0x4>;
+		st,non-secure-otp;
+	};
+};
+
+&clk_hse {
+	st,digbypass;
+};
+
+&cpu0{
+	cpu-supply = <&vddcore>;
+};
+
+&cpu1{
+	cpu-supply = <&vddcore>;
+};
+
+&hash1 {
+	status = "okay";
+};
+
+&i2c4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <400000>;
+	status = "okay";
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+		interrupts-extended = <&exti_pwr 55 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			buck1-supply = <&vin>;
+			buck2-supply = <&vin>;
+			buck3-supply = <&vin>;
+			buck4-supply = <&vin>;
+			ldo1-supply = <&v3v3>;
+			ldo2-supply = <&v3v3>;
+			ldo3-supply = <&vdd_ddr>;
+			ldo4-supply = <&vin>;
+			ldo5-supply = <&v3v3>;
+			ldo6-supply = <&v3v3>;
+			vref_ddr-supply = <&vin>;
+			boost-supply = <&vin>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&bst_out>;
+
+			vddcore: buck1 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			v3v3: buck4 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+				regulator-initial-mode = <0>;
+			};
+
+			vdda: ldo1 {
+				regulator-name = "vdda";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+			};
+
+			v2v8: ldo2 {
+				regulator-name = "v2v8";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+			};
+
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				regulator-always-on;
+				regulator-over-current-protection;
+				st,regulator-sink-source;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			vdd_sd: ldo5 {
+				regulator-name = "vdd_sd";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				regulator-boot-on;
+			};
+
+			v1v8: ldo6 {
+				regulator-name = "v1v8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+			};
+
+			vref_ddr: vref_ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+			};
+
+			vbus_otg: pwr_sw1 {
+				regulator-name = "vbus_otg";
+			};
+
+			vbus_sw: pwr_sw2 {
+				regulator-name = "vbus_sw";
+				regulator-active-discharge = <1>;
+			};
+		};
+	};
+};
+
+&iwdg2 {
+	timeout-sec = <32>;
+	secure-timeout-sec = <5>;
+	status = "okay";
+};
+
+&pwr_regulators {
+	system_suspend_supported_soc_modes = <
+		STM32_PM_CSLEEP_RUN
+		STM32_PM_CSTOP_ALLOW_LP_STOP
+		STM32_PM_CSTOP_ALLOW_LPLV_STOP
+		STM32_PM_CSTOP_ALLOW_STANDBY_DDR_SR
+	>;
+	system_off_soc_mode = <STM32_PM_CSTOP_ALLOW_STANDBY_DDR_OFF>;
+	vdd-supply = <&vdd>;
+	vdd_3v3_usbfs-supply = <&vdd_usb>;
+};
+
+&rcc {
+	st,hsi-cal;
+	st,csi-cal;
+	st,cal-sec = <60>;
+	st,clksrc = <
+		CLK_MPU_PLL1P
+		CLK_AXI_PLL2P
+		CLK_MCU_PLL3P
+		CLK_PLL12_HSE
+		CLK_PLL3_HSE
+		CLK_PLL4_HSE
+		CLK_RTC_LSE
+		CLK_MCO1_DISABLED
+		CLK_MCO2_DISABLED
+	>;
+
+	st,clkdiv = <
+		1 /*MPU*/
+		0 /*AXI*/
+		0 /*MCU*/
+		1 /*APB1*/
+		1 /*APB2*/
+		1 /*APB3*/
+		1 /*APB4*/
+		2 /*APB5*/
+		23 /*RTC*/
+		0 /*MCO1*/
+		0 /*MCO2*/
+	>;
+
+	st,pkcs = <
+		CLK_CKPER_HSE
+		CLK_FMC_ACLK
+		CLK_QSPI_ACLK
+		CLK_ETH_PLL4P
+		CLK_SDMMC12_PLL4P
+		CLK_DSI_DSIPLL
+		CLK_STGEN_HSE
+		CLK_USBPHY_HSE
+		CLK_SPI2S1_PLL3Q
+		CLK_SPI2S23_PLL3Q
+		CLK_SPI45_HSI
+		CLK_SPI6_HSI
+		CLK_I2C46_HSI
+		CLK_SDMMC3_PLL4P
+		CLK_USBO_USBPHY
+		CLK_ADC_CKPER
+		CLK_CEC_LSE
+		CLK_I2C12_HSI
+		CLK_I2C35_HSI
+		CLK_UART1_HSI
+		CLK_UART24_HSI
+		CLK_UART35_HSI
+		CLK_UART6_HSI
+		CLK_UART78_HSI
+		CLK_SPDIF_PLL4P
+		CLK_FDCAN_PLL4R
+		CLK_SAI1_PLL3Q
+		CLK_SAI2_PLL3Q
+		CLK_SAI3_PLL3Q
+		CLK_SAI4_PLL3Q
+		CLK_RNG1_CSI
+		CLK_RNG2_LSI
+		CLK_LPTIM1_PCLK1
+		CLK_LPTIM23_PCLK3
+		CLK_LPTIM45_LSE
+	>;
+
+	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
+	pll2: st,pll@1 {
+		compatible = "st,stm32mp1-pll";
+		reg = <1>;
+		cfg = <2 65 1 0 0 PQR(1,1,1)>;
+		frac = <0x1400>;
+	};
+
+	/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
+	pll3: st,pll@2 {
+		compatible = "st,stm32mp1-pll";
+		reg = <2>;
+		cfg = <1 33 1 16 36 PQR(1,1,1)>;
+		frac = <0x1a04>;
+	};
+
+	/* VCO = 594.0 MHz => P = 99, Q = 74, R = 74 */
+	pll4: st,pll@3 {
+		compatible = "st,stm32mp1-pll";
+		reg = <3>;
+		cfg = <3 98 5 7 7 PQR(1,1,1)>;
+	};
+};
+
+&rng1 {
+	status = "okay";
+};
+
+&rtc {
+	status = "okay";
+};
+
+&sdmmc1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_dir_pins_a>;
+	disable-wp;
+	st,sig-dir;
+	st,neg-edge;
+	st,use-ckin;
+	bus-width = <4>;
+	vmmc-supply = <&vdd_sd>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&v3v3>;
+	vqmmc-supply = <&vdd>;
+	mmc-ddr-3_3v;
+	status = "okay";
+};
+
+&timers15 {
+	status = "okay";
+	st,hsi-cal-input = <7>;
+	st,csi-cal-input = <8>;
+};
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart4_pins_a>;
+	status = "okay";
+};
+
+&usbotg_hs {
+	vbus-supply = <&vbus_otg>;
+};
+
+&usbphyc_port0 {
+	phy-supply = <&vdd_usb>;
+};
+
+&usbphyc_port1 {
+	phy-supply = <&vdd_usb>;
+};
+
+/* Low-power states of regulators */
+&v1v8 {
+	standby-ddr-sr {
+		regulator-off-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
+
+&v2v8 {
+	standby-ddr-sr {
+		regulator-off-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
+
+&v3v3 {
+	standby-ddr-sr {
+		regulator-off-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
+
+&vdd {
+	lp-stop {
+		regulator-suspend-microvolt = <3300000>;
+		regulator-on-in-suspend;
+	};
+	lplv-stop {
+		regulator-suspend-microvolt = <3300000>;
+		regulator-on-in-suspend;
+	};
+	standby-ddr-sr {
+		regulator-suspend-microvolt = <3300000>;
+		regulator-on-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-suspend-microvolt = <3300000>;
+		regulator-on-in-suspend;
+	};
+};
+
+&vdda {
+	standby-ddr-sr {
+		regulator-off-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
+
+&vddcore {
+	lp-stop {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <1200000>;
+	};
+	lplv-stop {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <900000>;
+	};
+	standby-ddr-sr {
+		regulator-off-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
+
+&vdd_ddr {
+	lp-stop {
+		regulator-suspend-microvolt = <1350000>;
+		regulator-on-in-suspend;
+	};
+	lplv-stop {
+		regulator-suspend-microvolt = <1350000>;
+		regulator-on-in-suspend;
+	};
+	standby-ddr-sr {
+		regulator-suspend-microvolt = <1350000>;
+		regulator-on-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
+
+&vdd_sd {
+	standby-ddr-sr {
+		regulator-off-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
+
+&vdd_usb {
+	standby-ddr-sr {
+		regulator-off-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
+
+&vref_ddr {
+	lp-stop {
+		regulator-on-in-suspend;
+	};
+	lplv-stop {
+		regulator-on-in-suspend;
+	};
+	standby-ddr-sr {
+		regulator-on-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
+
+&vtt_ddr {
+	lp-stop {
+		regulator-off-in-suspend;
+	};
+	lplv-stop {
+		regulator-off-in-suspend;
+	};
+	standby-ddr-sr {
+		regulator-off-in-suspend;
+	};
+	standby-ddr-off {
+		regulator-off-in-suspend;
+	};
+};
diff --git a/fdts/stm32mp15xx-evx.dtsi b/fdts/stm32mp15xx-evx.dtsi
new file mode 100644
index 000000000..8362b8d89
--- /dev/null
+++ b/fdts/stm32mp15xx-evx.dtsi
@@ -0,0 +1,73 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
+ * Author: Ludovic Barre <ludovic.barre@st.com> for STMicroelectronics.
+ */
+
+&fmc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&fmc_pins_a>;
+	status = "okay";
+
+	nand-controller@4,0 {
+		status = "okay";
+
+		nand@0 {
+			reg = <0>;
+			nand-on-flash-bbt;
+			#address-cells = <1>;
+			#size-cells = <1>;
+		};
+	};
+};
+
+&i2c4 {
+	pmic: stpmic@33 {
+		regulators {
+			v1v8: ldo6 {
+				regulator-enable-ramp-delay = <300000>;
+			};
+		};
+	};
+};
+
+&qspi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&qspi_clk_pins_a &qspi_bk1_pins_a>;
+	reg = <0x58003000 0x1000>, <0x70000000 0x4000000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	flash0: mx66l51235l@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&timers12 {
+	status = "disabled";
+};
+
+&usart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&usart3_pins_b>;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usbotg_hs {
+	pinctrl-0 = <&usbotg_hs_pins_a>;
+	pinctrl-names = "default";
+	phys = <&usbphyc_port1 0>;
+	phy-names = "usb2-phy";
+	status = "okay";
+};
+
+&usbphyc {
+	status = "okay";
+};
diff --git a/fdts/stm32mp15xx-osd32.dtsi b/fdts/stm32mp15xx-osd32.dtsi
index 76a25613a..18ebd61ae 100644
--- a/fdts/stm32mp15xx-osd32.dtsi
+++ b/fdts/stm32mp15xx-osd32.dtsi
@@ -81,10 +81,9 @@
 
 			vtt_ddr: ldo3 {
 				regulator-name = "vtt_ddr";
-				regulator-min-microvolt = <500000>;
-				regulator-max-microvolt = <750000>;
 				regulator-always-on;
 				regulator-over-current-protection;
+				st,regulator-sink-source;
 			};
 
 			vdd_usb: ldo4 {
@@ -110,7 +109,6 @@
 			vref_ddr: vref_ddr {
 				regulator-name = "vref_ddr";
 				regulator-always-on;
-				regulator-over-current-protection;
 			};
 
 			bst_out: boost {
@@ -183,7 +181,7 @@
 
 /* CLOCK init */
 &rcc {
-	secure-status = "disabled";
+	compatible = "st,stm32mp1-rcc", "syscon";
 	st,clksrc = <
 		CLK_MPU_PLL1P
 		CLK_AXI_PLL2P
diff --git a/fdts/stm32mp15xxaa-pinctrl.dtsi b/fdts/stm32mp15xxaa-pinctrl.dtsi
index f1d540abe..baf74d2c9 100644
--- a/fdts/stm32mp15xxaa-pinctrl.dtsi
+++ b/fdts/stm32mp15xxaa-pinctrl.dtsi
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
 /*
- * Copyright (c) 2019-2021, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2019-2022, STMicroelectronics - All Rights Reserved
  * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
  */
 
diff --git a/fdts/stm32mp15xxac-pinctrl.dtsi b/fdts/stm32mp15xxac-pinctrl.dtsi
index 11e7e0344..9b87e3309 100644
--- a/fdts/stm32mp15xxac-pinctrl.dtsi
+++ b/fdts/stm32mp15xxac-pinctrl.dtsi
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
 /*
- * Copyright (c) 2019-2021, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2019-2022, STMicroelectronics - All Rights Reserved
  * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
  */
 
diff --git a/fdts/stm32mp25-bl2.dtsi b/fdts/stm32mp25-bl2.dtsi
new file mode 100644
index 000000000..726e8583a
--- /dev/null
+++ b/fdts/stm32mp25-bl2.dtsi
@@ -0,0 +1,54 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2020-2022 - All Rights Reserved
+ */
+
+/ {
+	soc {
+#if !STM32MP_SPI_NAND && !STM32MP_SPI_NOR
+		/delete-node/ ommanager@40500000;
+#else
+		ommanager@40500000 {
+			/delete-node/ spi@40440000;
+		};
+#endif
+#if !STM32MP_RAW_NAND
+		/delete-node/ memory-controller@48200000;
+#endif
+#if !STM32MP_EMMC && !STM32MP_SDMMC
+		/delete-node/ mmc@48220000;
+		/delete-node/ mmc@48230000;
+#endif
+	};
+
+	/*
+	 * UUID's here are UUID RFC 4122 compliant meaning fieds are stored in
+	 * network order (big endian)
+	 */
+
+	st-io_policies {
+		fip-handles {
+			compatible = "st,io-fip-handle";
+#if STM32MP_DDR_FIP_IO_STORAGE
+			ddr_fw_uuid = "b11249be-92dd-4b10-867c-2c6a4b47a7fb";
+#endif
+			fw_cfg_uuid = "5807e16a-8459-47be-8ed5-648e8dddab0e";
+			bl31_uuid = "47d4086d-4cfe-9846-9b95-2950cbbd5a00";
+			bl32_uuid = "05d0e189-53dc-1347-8d2b-500a4b7a3e38";
+			bl32_extra1_uuid = "0b70c29b-2a5a-7840-9f65-0a5682738288";
+			bl32_extra2_uuid = "8ea87bb1-cfa2-3f4d-85fd-e7bba50220d9";
+			bl33_uuid = "d6d0eea7-fcea-d54b-9782-9934f234b6e4";
+			hw_cfg_uuid = "08b8f1d9-c9cf-9349-a962-6fbc6b7265cc";
+			tos_fw_cfg_uuid = "26257c1a-dbc6-7f47-8d96-c4c4b0248021";
+			nt_fw_cfg_uuid = "28da9815-93e8-7e44-ac66-1aaf801550f9";
+#if TRUSTED_BOARD_BOOT
+			t_key_cert_uuid = "827ee890-f860-e411-a1b4-777a21b4f94c";
+			t_boot_fw_cert_uuid = "d6e269ea-5d63-e411-8d8c-9fbabe9956a5";
+			tos_fw_key_cert_uuid = "9477d603-fb60-e411-85dd-b7105b8cee04";
+			nt_fw_key_cert_uuid = "8ad5832a-fb60-e411-8aaf-df30bbc49859";
+			tos_fw_content_cert_uuid = "a49f4411-5e63-e411-8728-3f05722af33d";
+			nt_fw_content_cert_uuid = "8ec4c1f3-5d63-e411-a7a9-87ee40b23fa7";
+#endif
+		};
+	};
+};
diff --git a/fdts/stm32mp25-ddr.dtsi b/fdts/stm32mp25-ddr.dtsi
new file mode 100644
index 000000000..c4eb077d3
--- /dev/null
+++ b/fdts/stm32mp25-ddr.dtsi
@@ -0,0 +1,249 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2019-2022, STMicroelectronics - All Rights Reserved
+ */
+
+&ddr{
+	st,mem-name = DDR_MEM_NAME;
+	st,mem-speed = <DDR_MEM_SPEED>;
+	st,mem-size = <DDR_MEM_SIZE>;
+
+	st,ctl-reg = <
+		DDR_MSTR
+		DDR_MRCTRL0
+		DDR_MRCTRL1
+		DDR_MRCTRL2
+		DDR_DERATEEN
+		DDR_DERATEINT
+		DDR_DERATECTL
+		DDR_PWRCTL
+		DDR_PWRTMG
+		DDR_HWLPCTL
+		DDR_RFSHCTL0
+		DDR_RFSHCTL1
+		DDR_RFSHCTL3
+		DDR_CRCPARCTL0
+		DDR_CRCPARCTL1
+		DDR_INIT0
+		DDR_INIT1
+		DDR_INIT2
+		DDR_INIT3
+		DDR_INIT4
+		DDR_INIT5
+		DDR_INIT6
+		DDR_INIT7
+		DDR_DIMMCTL
+		DDR_RANKCTL
+		DDR_ZQCTL0
+		DDR_ZQCTL1
+		DDR_ZQCTL2
+		DDR_DFITMG0
+		DDR_DFITMG1
+		DDR_DFILPCFG0
+		DDR_DFILPCFG1
+		DDR_DFIUPD0
+		DDR_DFIUPD1
+		DDR_DFIUPD2
+		DDR_DFIMISC
+		DDR_DFITMG2
+		DDR_DFITMG3
+		DDR_DBICTL
+		DDR_DFIPHYMSTR
+		DDR_DBG0
+		DDR_DBG1
+		DDR_DBGCMD
+		DDR_SWCTL
+		DDR_POISONCFG
+		DDR_PCCFG
+	>;
+
+	st,ctl-timing = <
+		DDR_RFSHTMG
+		DDR_RFSHTMG1
+		DDR_DRAMTMG0
+		DDR_DRAMTMG1
+		DDR_DRAMTMG2
+		DDR_DRAMTMG3
+		DDR_DRAMTMG4
+		DDR_DRAMTMG5
+		DDR_DRAMTMG6
+		DDR_DRAMTMG7
+		DDR_DRAMTMG8
+		DDR_DRAMTMG9
+		DDR_DRAMTMG10
+		DDR_DRAMTMG11
+		DDR_DRAMTMG12
+		DDR_DRAMTMG13
+		DDR_DRAMTMG14
+		DDR_DRAMTMG15
+		DDR_ODTCFG
+		DDR_ODTMAP
+	>;
+
+	st,ctl-map = <
+		DDR_ADDRMAP0
+		DDR_ADDRMAP1
+		DDR_ADDRMAP2
+		DDR_ADDRMAP3
+		DDR_ADDRMAP4
+		DDR_ADDRMAP5
+		DDR_ADDRMAP6
+		DDR_ADDRMAP7
+		DDR_ADDRMAP8
+		DDR_ADDRMAP9
+		DDR_ADDRMAP10
+		DDR_ADDRMAP11
+	>;
+
+	st,ctl-perf = <
+		DDR_SCHED
+		DDR_SCHED1
+		DDR_PERFHPR1
+		DDR_PERFLPR1
+		DDR_PERFWR1
+		DDR_PCFGR_0
+		DDR_PCFGW_0
+		DDR_PCTRL_0
+		DDR_PCFGQOS0_0
+		DDR_PCFGQOS1_0
+		DDR_PCFGWQOS0_0
+		DDR_PCFGWQOS1_0
+		DDR_PCFGR_1
+		DDR_PCFGW_1
+		DDR_PCTRL_1
+		DDR_PCFGQOS0_1
+		DDR_PCFGQOS1_1
+		DDR_PCFGWQOS0_1
+		DDR_PCFGWQOS1_1
+	>;
+
+	st,phy-basic = <
+		DDR_UIB_DRAMTYPE
+		DDR_UIB_DIMMTYPE
+		DDR_UIB_LP4XMODE
+		DDR_UIB_NUMDBYTE
+		DDR_UIB_NUMACTIVEDBYTEDFI0
+		DDR_UIB_NUMACTIVEDBYTEDFI1
+		DDR_UIB_NUMANIB
+		DDR_UIB_NUMRANK_DFI0
+		DDR_UIB_NUMRANK_DFI1
+		DDR_UIB_DRAMDATAWIDTH
+		DDR_UIB_NUMPSTATES
+		DDR_UIB_FREQUENCY_0
+		DDR_UIB_PLLBYPASS_0
+		DDR_UIB_DFIFREQRATIO_0
+		DDR_UIB_DFI1EXISTS
+		DDR_UIB_TRAIN2D
+		DDR_UIB_HARDMACROVER
+		DDR_UIB_READDBIENABLE_0
+		DDR_UIB_DFIMODE
+	>;
+
+	st,phy-advanced = <
+		DDR_UIA_LP4RXPREAMBLEMODE_0
+		DDR_UIA_LP4POSTAMBLEEXT_0
+		DDR_UIA_D4RXPREAMBLELENGTH_0
+		DDR_UIA_D4TXPREAMBLELENGTH_0
+		DDR_UIA_EXTCALRESVAL
+		DDR_UIA_IS2TTIMING_0
+		DDR_UIA_ODTIMPEDANCE_0
+		DDR_UIA_TXIMPEDANCE_0
+		DDR_UIA_ATXIMPEDANCE
+		DDR_UIA_MEMALERTEN
+		DDR_UIA_MEMALERTPUIMP
+		DDR_UIA_MEMALERTVREFLEVEL
+		DDR_UIA_MEMALERTSYNCBYPASS
+		DDR_UIA_DISDYNADRTRI_0
+		DDR_UIA_PHYMSTRTRAININTERVAL_0
+		DDR_UIA_PHYMSTRMAXREQTOACK_0
+		DDR_UIA_WDQSEXT
+		DDR_UIA_CALINTERVAL
+		DDR_UIA_CALONCE
+		DDR_UIA_LP4RL_0
+		DDR_UIA_LP4WL_0
+		DDR_UIA_LP4WLS_0
+		DDR_UIA_LP4DBIRD_0
+		DDR_UIA_LP4DBIWR_0
+		DDR_UIA_LP4NWR_0
+		DDR_UIA_LP4LOWPOWERDRV
+		DDR_UIA_DRAMBYTESWAP
+		DDR_UIA_RXENBACKOFF
+		DDR_UIA_TRAINSEQUENCECTRL
+		DDR_UIA_SNPSUMCTLOPT
+		DDR_UIA_SNPSUMCTLF0RC5X_0
+		DDR_UIA_TXSLEWRISEDQ_0
+		DDR_UIA_TXSLEWFALLDQ_0
+		DDR_UIA_TXSLEWRISEAC
+		DDR_UIA_TXSLEWFALLAC
+		DDR_UIA_DISABLERETRAINING
+		DDR_UIA_DISABLEPHYUPDATE
+		DDR_UIA_ENABLEHIGHCLKSKEWFIX
+		DDR_UIA_DISABLEUNUSEDADDRLNS
+		DDR_UIA_PHYINITSEQUENCENUM
+		DDR_UIA_ENABLEDFICSPOLARITYFIX
+		DDR_UIA_PHYVREF
+		DDR_UIA_SEQUENCECTRL_0
+	>;
+
+	st,phy-mr = <
+		DDR_UIM_MR0_0
+		DDR_UIM_MR1_0
+		DDR_UIM_MR2_0
+		DDR_UIM_MR3_0
+		DDR_UIM_MR4_0
+		DDR_UIM_MR5_0
+		DDR_UIM_MR6_0
+		DDR_UIM_MR11_0
+		DDR_UIM_MR12_0
+		DDR_UIM_MR13_0
+		DDR_UIM_MR14_0
+		DDR_UIM_MR22_0
+	>;
+
+	st,phy-swizzle = <
+		DDR_UIS_SWIZZLE_0
+		DDR_UIS_SWIZZLE_1
+		DDR_UIS_SWIZZLE_2
+		DDR_UIS_SWIZZLE_3
+		DDR_UIS_SWIZZLE_4
+		DDR_UIS_SWIZZLE_5
+		DDR_UIS_SWIZZLE_6
+		DDR_UIS_SWIZZLE_7
+		DDR_UIS_SWIZZLE_8
+		DDR_UIS_SWIZZLE_9
+		DDR_UIS_SWIZZLE_10
+		DDR_UIS_SWIZZLE_11
+		DDR_UIS_SWIZZLE_12
+		DDR_UIS_SWIZZLE_13
+		DDR_UIS_SWIZZLE_14
+		DDR_UIS_SWIZZLE_15
+		DDR_UIS_SWIZZLE_16
+		DDR_UIS_SWIZZLE_17
+		DDR_UIS_SWIZZLE_18
+		DDR_UIS_SWIZZLE_19
+		DDR_UIS_SWIZZLE_20
+		DDR_UIS_SWIZZLE_21
+		DDR_UIS_SWIZZLE_22
+		DDR_UIS_SWIZZLE_23
+		DDR_UIS_SWIZZLE_24
+		DDR_UIS_SWIZZLE_25
+		DDR_UIS_SWIZZLE_26
+		DDR_UIS_SWIZZLE_27
+		DDR_UIS_SWIZZLE_28
+		DDR_UIS_SWIZZLE_29
+		DDR_UIS_SWIZZLE_30
+		DDR_UIS_SWIZZLE_31
+		DDR_UIS_SWIZZLE_32
+		DDR_UIS_SWIZZLE_33
+		DDR_UIS_SWIZZLE_34
+		DDR_UIS_SWIZZLE_35
+		DDR_UIS_SWIZZLE_36
+		DDR_UIS_SWIZZLE_37
+		DDR_UIS_SWIZZLE_38
+		DDR_UIS_SWIZZLE_39
+		DDR_UIS_SWIZZLE_40
+		DDR_UIS_SWIZZLE_41
+		DDR_UIS_SWIZZLE_42
+		DDR_UIS_SWIZZLE_43
+	>;
+};
diff --git a/fdts/stm32mp25-ddr4-2x8Gbits-2x16bits-1200MHz.dtsi b/fdts/stm32mp25-ddr4-2x8Gbits-2x16bits-1200MHz.dtsi
new file mode 100644
index 000000000..46805e919
--- /dev/null
+++ b/fdts/stm32mp25-ddr4-2x8Gbits-2x16bits-1200MHz.dtsi
@@ -0,0 +1,246 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+/*
+ * STM32MP257D/F VALID3 board configuration
+ * DDR4 2x8Gbits 2x16bits 1200MHz
+ *
+ * References used:
+ * - MT40A512M16LY-062EIT:E from MICRON
+ * - NT5AD512M16C4-JRI from NANYA
+ *
+ * memclk	1199MHz		(2x DFI clock) + range check
+ * speed_bin	Worse		from JEDEC
+ * width	32		32: full width / 16: half width
+ * density	8Gbits		(per 16bit device)
+ * addressing	RBC		row/bank interleaving
+ * RDBI		No		Read DBI
+ */
+
+#define DDR_MEM_NAME	"DDR4 2x8Gbits 2x16bits 1200MHz"
+#define DDR_MEM_SPEED	1200000
+#define DDR_MEM_SIZE	0x80000000
+
+#define DDR_MSTR 0x01040010
+#define DDR_MRCTRL0 0x00000030
+#define DDR_MRCTRL1 0x00000000
+#define DDR_MRCTRL2 0x00000000
+#define DDR_DERATEEN 0x00000000
+#define DDR_DERATEINT 0x0124B980
+#define DDR_DERATECTL 0x00000000
+#define DDR_PWRCTL 0x00000028
+#define DDR_PWRTMG 0x00130001
+#define DDR_HWLPCTL 0x00000002
+#define DDR_RFSHCTL0 0x00210010
+#define DDR_RFSHCTL1 0x00000000
+#define DDR_RFSHCTL3 0x00000000
+#define DDR_RFSHTMG 0x009200D2
+#define DDR_RFSHTMG1 0x008C0000
+#define DDR_CRCPARCTL0 0x00000000
+#define DDR_CRCPARCTL1 0x00001000
+#define DDR_INIT0 0xC0020002
+#define DDR_INIT1 0x00010002
+#define DDR_INIT2 0x00000D00
+#define DDR_INIT3 0x09400103
+#define DDR_INIT4 0x00180000
+#define DDR_INIT5 0x00100004
+#define DDR_INIT6 0x00080440
+#define DDR_INIT7 0x0000080F
+#define DDR_DIMMCTL 0x00000000
+#define DDR_RANKCTL 0x0000066F
+#define DDR_DRAMTMG0 0x11152815
+#define DDR_DRAMTMG1 0x0004051E
+#define DDR_DRAMTMG2 0x0609060D
+#define DDR_DRAMTMG3 0x0050400C
+#define DDR_DRAMTMG4 0x0904050A
+#define DDR_DRAMTMG5 0x06060403
+#define DDR_DRAMTMG6 0x02020005
+#define DDR_DRAMTMG7 0x00000606
+#define DDR_DRAMTMG8 0x04040C07
+#define DDR_DRAMTMG9 0x0002040A
+#define DDR_DRAMTMG10 0x001C180A
+#define DDR_DRAMTMG11 0x4408021C
+#define DDR_DRAMTMG12 0x0C020010
+#define DDR_DRAMTMG13 0x1C200004
+#define DDR_DRAMTMG14 0x000000A0
+#define DDR_DRAMTMG15 0x00000000
+#define DDR_ZQCTL0 0x01000040
+#define DDR_ZQCTL1 0x2000492E
+#define DDR_ZQCTL2 0x00000000
+#define DDR_DFITMG0 0x038F8209
+#define DDR_DFITMG1 0x00080303
+#define DDR_DFILPCFG0 0x07004111
+#define DDR_DFILPCFG1 0x000000F0
+#define DDR_DFIUPD0 0xC0300018
+#define DDR_DFIUPD1 0x005700B4
+#define DDR_DFIUPD2 0x80000000
+#define DDR_DFIMISC 0x00000041
+#define DDR_DFITMG2 0x00000F09
+#define DDR_DFITMG3 0x00000000
+#define DDR_DBICTL 0x00000001
+#define DDR_DFIPHYMSTR 0x80000000
+#define DDR_ADDRMAP0 0x0000001F
+#define DDR_ADDRMAP1 0x003F0909
+#define DDR_ADDRMAP2 0x00000000
+#define DDR_ADDRMAP3 0x00000000
+#define DDR_ADDRMAP4 0x00001F1F
+#define DDR_ADDRMAP5 0x070F0707
+#define DDR_ADDRMAP6 0x07070707
+#define DDR_ADDRMAP7 0x00000F0F
+#define DDR_ADDRMAP8 0x00003F08
+#define DDR_ADDRMAP9 0x07070707
+#define DDR_ADDRMAP10 0x07070707
+#define DDR_ADDRMAP11 0x00000007
+#define DDR_ODTCFG 0x06000618
+#define DDR_ODTMAP 0x00000001
+#define DDR_SCHED 0x00000F00
+#define DDR_SCHED1 0x000000FF
+#define DDR_PERFHPR1 0x0F000001
+#define DDR_PERFLPR1 0x0F00007F
+#define DDR_PERFWR1 0x01000200
+#define DDR_DBG0 0x00000000
+#define DDR_DBG1 0x00000000
+#define DDR_DBGCMD 0x00000000
+#define DDR_SWCTL 0x00000002
+#define DDR_POISONCFG 0x00000000
+#define DDR_PCCFG 0x00000000
+#define DDR_PCFGR_0 0x00004100
+#define DDR_PCFGW_0 0x00004100
+#define DDR_PCTRL_0 0x00000000
+#define DDR_PCFGQOS0_0 0x00200007
+#define DDR_PCFGQOS1_0 0x01000100
+#define DDR_PCFGWQOS0_0 0x00000C07
+#define DDR_PCFGWQOS1_0 0x02000200
+#define DDR_PCFGR_1 0x00004100
+#define DDR_PCFGW_1 0x00004100
+#define DDR_PCTRL_1 0x00000000
+#define DDR_PCFGQOS0_1 0x00200007
+#define DDR_PCFGQOS1_1 0x01000180
+#define DDR_PCFGWQOS0_1 0x00000C07
+#define DDR_PCFGWQOS1_1 0x04000400
+
+#define DDR_UIB_DRAMTYPE 0x00000000
+#define DDR_UIB_DIMMTYPE 0x00000004
+#define DDR_UIB_LP4XMODE 0x00000000
+#define DDR_UIB_NUMDBYTE 0x00000004
+#define DDR_UIB_NUMACTIVEDBYTEDFI0 0x00000004
+#define DDR_UIB_NUMACTIVEDBYTEDFI1 0x00000000
+#define DDR_UIB_NUMANIB 0x00000008
+#define DDR_UIB_NUMRANK_DFI0 0x00000001
+#define DDR_UIB_NUMRANK_DFI1 0x00000001
+#define DDR_UIB_DRAMDATAWIDTH 0x00000010
+#define DDR_UIB_NUMPSTATES 0x00000001
+#define DDR_UIB_FREQUENCY_0 0x000004AF
+#define DDR_UIB_PLLBYPASS_0 0x00000000
+#define DDR_UIB_DFIFREQRATIO_0 0x00000001
+#define DDR_UIB_DFI1EXISTS 0x00000001
+#define DDR_UIB_TRAIN2D 0x00000000
+#define DDR_UIB_HARDMACROVER 0x00000003
+#define DDR_UIB_READDBIENABLE_0 0x00000000
+#define DDR_UIB_DFIMODE 0x00000000
+
+#define DDR_UIA_LP4RXPREAMBLEMODE_0 0x00000000
+#define DDR_UIA_LP4POSTAMBLEEXT_0 0x00000000
+#define DDR_UIA_D4RXPREAMBLELENGTH_0 0x00000000
+#define DDR_UIA_D4TXPREAMBLELENGTH_0 0x00000000
+#define DDR_UIA_EXTCALRESVAL 0x00000000
+#define DDR_UIA_IS2TTIMING_0 0x00000000
+#define DDR_UIA_ODTIMPEDANCE_0 0x00000035
+#define DDR_UIA_TXIMPEDANCE_0 0x00000028
+#define DDR_UIA_ATXIMPEDANCE 0x00000028
+#define DDR_UIA_MEMALERTEN 0x00000000
+#define DDR_UIA_MEMALERTPUIMP 0x00000000
+#define DDR_UIA_MEMALERTVREFLEVEL 0x00000000
+#define DDR_UIA_MEMALERTSYNCBYPASS 0x00000000
+#define DDR_UIA_DISDYNADRTRI_0 0x00000001
+#define DDR_UIA_PHYMSTRTRAININTERVAL_0 0x00000000
+#define DDR_UIA_PHYMSTRMAXREQTOACK_0 0x00000000
+#define DDR_UIA_WDQSEXT 0x00000000
+#define DDR_UIA_CALINTERVAL 0x00000009
+#define DDR_UIA_CALONCE 0x00000000
+#define DDR_UIA_LP4RL_0 0x00000000
+#define DDR_UIA_LP4WL_0 0x00000000
+#define DDR_UIA_LP4WLS_0 0x00000000
+#define DDR_UIA_LP4DBIRD_0 0x00000000
+#define DDR_UIA_LP4DBIWR_0 0x00000000
+#define DDR_UIA_LP4NWR_0 0x00000000
+#define DDR_UIA_LP4LOWPOWERDRV 0x00000000
+#define DDR_UIA_DRAMBYTESWAP 0x00000000
+#define DDR_UIA_RXENBACKOFF 0x00000000
+#define DDR_UIA_TRAINSEQUENCECTRL 0x00000000
+#define DDR_UIA_SNPSUMCTLOPT 0x00000000
+#define DDR_UIA_SNPSUMCTLF0RC5X_0 0x00000000
+#define DDR_UIA_TXSLEWRISEDQ_0 0x0000000F
+#define DDR_UIA_TXSLEWFALLDQ_0 0x0000000F
+#define DDR_UIA_TXSLEWRISEAC 0x0000000F
+#define DDR_UIA_TXSLEWFALLAC 0x0000000F
+#define DDR_UIA_DISABLERETRAINING 0x00000001
+#define DDR_UIA_DISABLEPHYUPDATE 0x00000000
+#define DDR_UIA_ENABLEHIGHCLKSKEWFIX 0x00000000
+#define DDR_UIA_DISABLEUNUSEDADDRLNS 0x00000001
+#define DDR_UIA_PHYINITSEQUENCENUM 0x00000000
+#define DDR_UIA_ENABLEDFICSPOLARITYFIX 0x00000000
+#define DDR_UIA_PHYVREF 0x0000005E
+#define DDR_UIA_SEQUENCECTRL_0 0x0000031F
+
+#define DDR_UIM_MR0_0 0x00000940
+#define DDR_UIM_MR1_0 0x00000103
+#define DDR_UIM_MR2_0 0x00000018
+#define DDR_UIM_MR3_0 0x00000000
+#define DDR_UIM_MR4_0 0x00000008
+#define DDR_UIM_MR5_0 0x00000440
+#define DDR_UIM_MR6_0 0x0000080F
+#define DDR_UIM_MR11_0 0x00000000
+#define DDR_UIM_MR12_0 0x00000000
+#define DDR_UIM_MR13_0 0x00000000
+#define DDR_UIM_MR14_0 0x00000000
+#define DDR_UIM_MR22_0 0x00000000
+
+#define DDR_UIS_SWIZZLE_0 0x0000000C
+#define DDR_UIS_SWIZZLE_1 0x00000005
+#define DDR_UIS_SWIZZLE_2 0x00000013
+#define DDR_UIS_SWIZZLE_3 0x0000001A
+#define DDR_UIS_SWIZZLE_4 0x00000009
+#define DDR_UIS_SWIZZLE_5 0x00000003
+#define DDR_UIS_SWIZZLE_6 0x00000001
+#define DDR_UIS_SWIZZLE_7 0x00000019
+#define DDR_UIS_SWIZZLE_8 0x00000007
+#define DDR_UIS_SWIZZLE_9 0x00000004
+#define DDR_UIS_SWIZZLE_10 0x0000000A
+#define DDR_UIS_SWIZZLE_11 0x0000000D
+#define DDR_UIS_SWIZZLE_12 0x00000014
+#define DDR_UIS_SWIZZLE_13 0x00000000
+#define DDR_UIS_SWIZZLE_14 0x00000000
+#define DDR_UIS_SWIZZLE_15 0x00000000
+#define DDR_UIS_SWIZZLE_16 0x00000000
+#define DDR_UIS_SWIZZLE_17 0x00000000
+#define DDR_UIS_SWIZZLE_18 0x00000006
+#define DDR_UIS_SWIZZLE_19 0x0000000B
+#define DDR_UIS_SWIZZLE_20 0x00000000
+#define DDR_UIS_SWIZZLE_21 0x00000000
+#define DDR_UIS_SWIZZLE_22 0x00000000
+#define DDR_UIS_SWIZZLE_23 0x00000008
+#define DDR_UIS_SWIZZLE_24 0x00000002
+#define DDR_UIS_SWIZZLE_25 0x00000018
+#define DDR_UIS_SWIZZLE_26 0x1A13050C
+#define DDR_UIS_SWIZZLE_27 0x19010309
+#define DDR_UIS_SWIZZLE_28 0x0D0A0407
+#define DDR_UIS_SWIZZLE_29 0x00000014
+#define DDR_UIS_SWIZZLE_30 0x000B0600
+#define DDR_UIS_SWIZZLE_31 0x02080000
+#define DDR_UIS_SWIZZLE_32 0x00000018
+#define DDR_UIS_SWIZZLE_33 0x00000000
+#define DDR_UIS_SWIZZLE_34 0x00000000
+#define DDR_UIS_SWIZZLE_35 0x00000000
+#define DDR_UIS_SWIZZLE_36 0x00000000
+#define DDR_UIS_SWIZZLE_37 0x00000000
+#define DDR_UIS_SWIZZLE_38 0x00000000
+#define DDR_UIS_SWIZZLE_39 0x00000000
+#define DDR_UIS_SWIZZLE_40 0x00000000
+#define DDR_UIS_SWIZZLE_41 0x00000000
+#define DDR_UIS_SWIZZLE_42 0x00000000
+#define DDR_UIS_SWIZZLE_43 0x00000000
+
+#include "stm32mp25-ddr.dtsi"
diff --git a/fdts/stm32mp25-ddr4-2x8Gbits-2x16bits-800MHz.dtsi b/fdts/stm32mp25-ddr4-2x8Gbits-2x16bits-800MHz.dtsi
new file mode 100644
index 000000000..f07e6aee0
--- /dev/null
+++ b/fdts/stm32mp25-ddr4-2x8Gbits-2x16bits-800MHz.dtsi
@@ -0,0 +1,246 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+/*
+ * STM32MP257D/F VALID3 board configuration
+ * DDR4 2x8Gbits 2x16bits 800MHz
+ *
+ * References used:
+ * - MT40A512M16LY-062EIT:E from MICRON
+ * - NT5AD512M16C4-JRI from NANYA
+ *
+ * memclk	801MHz		(2x DFI clock) + range check
+ * speed_bin	Worse		from JEDEC
+ * width	32		32: full width / 16: half width
+ * density	8Gbits		(per 16bit device)
+ * addressing	RBC		row/bank interleaving
+ * RDBI		No		Read DBI
+ */
+
+#define DDR_MEM_NAME	"DDR4 2x8Gbits 2x16bits 800MHz"
+#define DDR_MEM_SPEED	800000
+#define DDR_MEM_SIZE	0x80000000
+
+#define DDR_MSTR 0x01040010
+#define DDR_MRCTRL0 0x00000030
+#define DDR_MRCTRL1 0x00000000
+#define DDR_MRCTRL2 0x00000000
+#define DDR_DERATEEN 0x00000000
+#define DDR_DERATEINT 0x00C38E80
+#define DDR_DERATECTL 0x00000000
+#define DDR_PWRCTL 0x00000028
+#define DDR_PWRTMG 0x000D0001
+#define DDR_HWLPCTL 0x00000002
+#define DDR_RFSHCTL0 0x00210010
+#define DDR_RFSHCTL1 0x00000000
+#define DDR_RFSHCTL3 0x00000000
+#define DDR_RFSHTMG 0x0061008D
+#define DDR_RFSHTMG1 0x008C0000
+#define DDR_CRCPARCTL0 0x00000000
+#define DDR_CRCPARCTL1 0x00001000
+#define DDR_INIT0 0xC0020002
+#define DDR_INIT1 0x00010002
+#define DDR_INIT2 0x00000D00
+#define DDR_INIT3 0x05240103
+#define DDR_INIT4 0x00080000
+#define DDR_INIT5 0x00100004
+#define DDR_INIT6 0x00080440
+#define DDR_INIT7 0x0000040F
+#define DDR_DIMMCTL 0x00000000
+#define DDR_RANKCTL 0x0000066F
+#define DDR_DRAMTMG0 0x0E0F1A0F
+#define DDR_DRAMTMG1 0x00030415
+#define DDR_DRAMTMG2 0x0507050B
+#define DDR_DRAMTMG3 0x0050400C
+#define DDR_DRAMTMG4 0x07030407
+#define DDR_DRAMTMG5 0x05050403
+#define DDR_DRAMTMG6 0x02020005
+#define DDR_DRAMTMG7 0x00000505
+#define DDR_DRAMTMG8 0x03030A05
+#define DDR_DRAMTMG9 0x00020309
+#define DDR_DRAMTMG10 0x001C180A
+#define DDR_DRAMTMG11 0x4405021C
+#define DDR_DRAMTMG12 0x0C020010
+#define DDR_DRAMTMG13 0x1C200004
+#define DDR_DRAMTMG14 0x000000A0
+#define DDR_DRAMTMG15 0x00000000
+#define DDR_ZQCTL0 0x01000040
+#define DDR_ZQCTL1 0x200030E3
+#define DDR_ZQCTL2 0x00000000
+#define DDR_DFITMG0 0x038B8207
+#define DDR_DFITMG1 0x00080303
+#define DDR_DFILPCFG0 0x07004111
+#define DDR_DFILPCFG1 0x000000F0
+#define DDR_DFIUPD0 0xC0300018
+#define DDR_DFIUPD1 0x005700B4
+#define DDR_DFIUPD2 0x80000000
+#define DDR_DFIMISC 0x00000041
+#define DDR_DFITMG2 0x00000B07
+#define DDR_DFITMG3 0x00000000
+#define DDR_DBICTL 0x00000001
+#define DDR_DFIPHYMSTR 0x80000000
+#define DDR_ADDRMAP0 0x0000001F
+#define DDR_ADDRMAP1 0x003F0909
+#define DDR_ADDRMAP2 0x00000000
+#define DDR_ADDRMAP3 0x00000000
+#define DDR_ADDRMAP4 0x00001F1F
+#define DDR_ADDRMAP5 0x070F0707
+#define DDR_ADDRMAP6 0x07070707
+#define DDR_ADDRMAP7 0x00000F0F
+#define DDR_ADDRMAP8 0x00003F08
+#define DDR_ADDRMAP9 0x07070707
+#define DDR_ADDRMAP10 0x07070707
+#define DDR_ADDRMAP11 0x00000007
+#define DDR_ODTCFG 0x06000610
+#define DDR_ODTMAP 0x00000001
+#define DDR_SCHED 0x00000F00
+#define DDR_SCHED1 0x000000FF
+#define DDR_PERFHPR1 0x0F000001
+#define DDR_PERFLPR1 0x0F00007F
+#define DDR_PERFWR1 0x01000200
+#define DDR_DBG0 0x00000000
+#define DDR_DBG1 0x00000000
+#define DDR_DBGCMD 0x00000000
+#define DDR_SWCTL 0x00000002
+#define DDR_POISONCFG 0x00000000
+#define DDR_PCCFG 0x00000000
+#define DDR_PCFGR_0 0x00004100
+#define DDR_PCFGW_0 0x00004100
+#define DDR_PCTRL_0 0x00000000
+#define DDR_PCFGQOS0_0 0x00200007
+#define DDR_PCFGQOS1_0 0x01000100
+#define DDR_PCFGWQOS0_0 0x00000C07
+#define DDR_PCFGWQOS1_0 0x02000200
+#define DDR_PCFGR_1 0x00004100
+#define DDR_PCFGW_1 0x00004100
+#define DDR_PCTRL_1 0x00000000
+#define DDR_PCFGQOS0_1 0x00200007
+#define DDR_PCFGQOS1_1 0x01000180
+#define DDR_PCFGWQOS0_1 0x00000C07
+#define DDR_PCFGWQOS1_1 0x04000400
+
+#define DDR_UIB_DRAMTYPE 0x00000000
+#define DDR_UIB_DIMMTYPE 0x00000004
+#define DDR_UIB_LP4XMODE 0x00000000
+#define DDR_UIB_NUMDBYTE 0x00000004
+#define DDR_UIB_NUMACTIVEDBYTEDFI0 0x00000004
+#define DDR_UIB_NUMACTIVEDBYTEDFI1 0x00000000
+#define DDR_UIB_NUMANIB 0x00000008
+#define DDR_UIB_NUMRANK_DFI0 0x00000001
+#define DDR_UIB_NUMRANK_DFI1 0x00000001
+#define DDR_UIB_DRAMDATAWIDTH 0x00000010
+#define DDR_UIB_NUMPSTATES 0x00000001
+#define DDR_UIB_FREQUENCY_0 0x00000321
+#define DDR_UIB_PLLBYPASS_0 0x00000000
+#define DDR_UIB_DFIFREQRATIO_0 0x00000001
+#define DDR_UIB_DFI1EXISTS 0x00000001
+#define DDR_UIB_TRAIN2D 0x00000000
+#define DDR_UIB_HARDMACROVER 0x00000003
+#define DDR_UIB_READDBIENABLE_0 0x00000000
+#define DDR_UIB_DFIMODE 0x00000000
+
+#define DDR_UIA_LP4RXPREAMBLEMODE_0 0x00000000
+#define DDR_UIA_LP4POSTAMBLEEXT_0 0x00000000
+#define DDR_UIA_D4RXPREAMBLELENGTH_0 0x00000000
+#define DDR_UIA_D4TXPREAMBLELENGTH_0 0x00000000
+#define DDR_UIA_EXTCALRESVAL 0x00000000
+#define DDR_UIA_IS2TTIMING_0 0x00000000
+#define DDR_UIA_ODTIMPEDANCE_0 0x00000035
+#define DDR_UIA_TXIMPEDANCE_0 0x00000028
+#define DDR_UIA_ATXIMPEDANCE 0x00000028
+#define DDR_UIA_MEMALERTEN 0x00000000
+#define DDR_UIA_MEMALERTPUIMP 0x00000000
+#define DDR_UIA_MEMALERTVREFLEVEL 0x00000000
+#define DDR_UIA_MEMALERTSYNCBYPASS 0x00000000
+#define DDR_UIA_DISDYNADRTRI_0 0x00000001
+#define DDR_UIA_PHYMSTRTRAININTERVAL_0 0x00000000
+#define DDR_UIA_PHYMSTRMAXREQTOACK_0 0x00000000
+#define DDR_UIA_WDQSEXT 0x00000000
+#define DDR_UIA_CALINTERVAL 0x00000009
+#define DDR_UIA_CALONCE 0x00000000
+#define DDR_UIA_LP4RL_0 0x00000000
+#define DDR_UIA_LP4WL_0 0x00000000
+#define DDR_UIA_LP4WLS_0 0x00000000
+#define DDR_UIA_LP4DBIRD_0 0x00000000
+#define DDR_UIA_LP4DBIWR_0 0x00000000
+#define DDR_UIA_LP4NWR_0 0x00000000
+#define DDR_UIA_LP4LOWPOWERDRV 0x00000000
+#define DDR_UIA_DRAMBYTESWAP 0x00000000
+#define DDR_UIA_RXENBACKOFF 0x00000000
+#define DDR_UIA_TRAINSEQUENCECTRL 0x00000000
+#define DDR_UIA_SNPSUMCTLOPT 0x00000000
+#define DDR_UIA_SNPSUMCTLF0RC5X_0 0x00000000
+#define DDR_UIA_TXSLEWRISEDQ_0 0x0000000F
+#define DDR_UIA_TXSLEWFALLDQ_0 0x0000000F
+#define DDR_UIA_TXSLEWRISEAC 0x0000000F
+#define DDR_UIA_TXSLEWFALLAC 0x0000000F
+#define DDR_UIA_DISABLERETRAINING 0x00000001
+#define DDR_UIA_DISABLEPHYUPDATE 0x00000000
+#define DDR_UIA_ENABLEHIGHCLKSKEWFIX 0x00000000
+#define DDR_UIA_DISABLEUNUSEDADDRLNS 0x00000001
+#define DDR_UIA_PHYINITSEQUENCENUM 0x00000000
+#define DDR_UIA_ENABLEDFICSPOLARITYFIX 0x00000000
+#define DDR_UIA_PHYVREF 0x0000005E
+#define DDR_UIA_SEQUENCECTRL_0 0x0000031F
+
+#define DDR_UIM_MR0_0 0x00000524
+#define DDR_UIM_MR1_0 0x00000103
+#define DDR_UIM_MR2_0 0x00000008
+#define DDR_UIM_MR3_0 0x00000000
+#define DDR_UIM_MR4_0 0x00000008
+#define DDR_UIM_MR5_0 0x00000440
+#define DDR_UIM_MR6_0 0x0000040F
+#define DDR_UIM_MR11_0 0x00000000
+#define DDR_UIM_MR12_0 0x00000000
+#define DDR_UIM_MR13_0 0x00000000
+#define DDR_UIM_MR14_0 0x00000000
+#define DDR_UIM_MR22_0 0x00000000
+
+#define DDR_UIS_SWIZZLE_0 0x0000000C
+#define DDR_UIS_SWIZZLE_1 0x00000005
+#define DDR_UIS_SWIZZLE_2 0x00000013
+#define DDR_UIS_SWIZZLE_3 0x0000001A
+#define DDR_UIS_SWIZZLE_4 0x00000009
+#define DDR_UIS_SWIZZLE_5 0x00000003
+#define DDR_UIS_SWIZZLE_6 0x00000001
+#define DDR_UIS_SWIZZLE_7 0x00000019
+#define DDR_UIS_SWIZZLE_8 0x00000007
+#define DDR_UIS_SWIZZLE_9 0x00000004
+#define DDR_UIS_SWIZZLE_10 0x0000000A
+#define DDR_UIS_SWIZZLE_11 0x0000000D
+#define DDR_UIS_SWIZZLE_12 0x00000014
+#define DDR_UIS_SWIZZLE_13 0x00000000
+#define DDR_UIS_SWIZZLE_14 0x00000000
+#define DDR_UIS_SWIZZLE_15 0x00000000
+#define DDR_UIS_SWIZZLE_16 0x00000000
+#define DDR_UIS_SWIZZLE_17 0x00000000
+#define DDR_UIS_SWIZZLE_18 0x00000006
+#define DDR_UIS_SWIZZLE_19 0x0000000B
+#define DDR_UIS_SWIZZLE_20 0x00000000
+#define DDR_UIS_SWIZZLE_21 0x00000000
+#define DDR_UIS_SWIZZLE_22 0x00000000
+#define DDR_UIS_SWIZZLE_23 0x00000008
+#define DDR_UIS_SWIZZLE_24 0x00000002
+#define DDR_UIS_SWIZZLE_25 0x00000018
+#define DDR_UIS_SWIZZLE_26 0x1A13050C
+#define DDR_UIS_SWIZZLE_27 0x19010309
+#define DDR_UIS_SWIZZLE_28 0x0D0A0407
+#define DDR_UIS_SWIZZLE_29 0x00000014
+#define DDR_UIS_SWIZZLE_30 0x000B0600
+#define DDR_UIS_SWIZZLE_31 0x02080000
+#define DDR_UIS_SWIZZLE_32 0x00000018
+#define DDR_UIS_SWIZZLE_33 0x00000000
+#define DDR_UIS_SWIZZLE_34 0x00000000
+#define DDR_UIS_SWIZZLE_35 0x00000000
+#define DDR_UIS_SWIZZLE_36 0x00000000
+#define DDR_UIS_SWIZZLE_37 0x00000000
+#define DDR_UIS_SWIZZLE_38 0x00000000
+#define DDR_UIS_SWIZZLE_39 0x00000000
+#define DDR_UIS_SWIZZLE_40 0x00000000
+#define DDR_UIS_SWIZZLE_41 0x00000000
+#define DDR_UIS_SWIZZLE_42 0x00000000
+#define DDR_UIS_SWIZZLE_43 0x00000000
+
+#include "stm32mp25-ddr.dtsi"
diff --git a/fdts/stm32mp25-fw-config.dtsi b/fdts/stm32mp25-fw-config.dtsi
new file mode 100644
index 000000000..17d8f7039
--- /dev/null
+++ b/fdts/stm32mp25-fw-config.dtsi
@@ -0,0 +1,49 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (c) 2021-2022, STMicroelectronics - All Rights Reserved
+ */
+
+#include <common/tbbr/tbbr_img_def.h>
+
+#include <platform_def.h>
+
+#ifndef DDR_SIZE
+#error "DDR_SIZE is not defined"
+#endif
+
+#define DDR_SEC_BASE	(STM32MP_DDR_BASE + 0x02000000)
+#define DDR_SEC_SIZE	0x02000000
+#define DDR_NS_BASE	(DDR_SEC_BASE + DDR_SEC_SIZE)
+#define DDR_NS_SIZE	(STM32MP_DDR_BASE + DDR_SIZE - DDR_NS_BASE)
+
+/dts-v1/;
+
+/ {
+	dtb-registry {
+		compatible = "fconf,dyn_cfg-dtb_registry";
+
+		hw-config {
+			load-address = <0x0 STM32MP_HW_CONFIG_BASE>;
+			max-size = <STM32MP_HW_CONFIG_MAX_SIZE>;
+			id = <HW_CONFIG_ID>;
+		};
+
+		nt_fw {
+			load-address = <0x0 STM32MP_BL33_BASE>;
+			max-size = <STM32MP_BL33_MAX_SIZE>;
+			id = <BL33_IMAGE_ID>;
+		};
+
+		soc_fw {
+			load-address = <0x0 STM32MP_SYSRAM_BASE>;
+			max-size = <STM32MP_BL31_SIZE>;
+			id = <BL31_IMAGE_ID>;
+		};
+
+		tos_fw {
+			load-address = <0x0 DDR_SEC_BASE>;
+			max-size = <DDR_SEC_SIZE>;
+			id = <BL32_IMAGE_ID>;
+		};
+	};
+};
diff --git a/fdts/stm32mp25-lpddr4-1x16Gbits-1x32bits-1200MHz.dtsi b/fdts/stm32mp25-lpddr4-1x16Gbits-1x32bits-1200MHz.dtsi
new file mode 100644
index 000000000..ebfefc659
--- /dev/null
+++ b/fdts/stm32mp25-lpddr4-1x16Gbits-1x32bits-1200MHz.dtsi
@@ -0,0 +1,247 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+/*
+ * STM32MP257F VALID1 board configuration
+ * LPDDR4 1x16Gbits 1x32bits 1200MHz
+ *
+ * Reference used:
+ * - MT53D512M32D2DS-053EIT:E from MICRON
+ *
+ * memclk	1199MHz		(2x DFI clock) + range check
+ * width	32		32: full width / 16: half width
+ * density	8Gbits		(per 16bit device)
+ * addressing	RBC		row/bank interleaving
+ * RDBI		No		Read DBI
+ * WDBI		No		Write DBI
+ * RPST		1.5		Read Postamble (ck)
+ * per_bank_ref	Yes
+ */
+
+#define DDR_MEM_NAME	"LPDDR4 1x16Gbits 1x32bits 1200MHz"
+#define DDR_MEM_SPEED	1200000
+#define DDR_MEM_SIZE	0x80000000
+
+#define DDR_MSTR 0x01080020
+#define DDR_MRCTRL0 0x00000030
+#define DDR_MRCTRL1 0x00000000
+#define DDR_MRCTRL2 0x00000000
+#define DDR_DERATEEN 0x00000203
+#define DDR_DERATEINT 0x0124B980
+#define DDR_DERATECTL 0x00000000
+#define DDR_PWRCTL 0x00000128
+#define DDR_PWRTMG 0x00130001
+#define DDR_HWLPCTL 0x00000002
+#define DDR_RFSHCTL0 0x00210074
+#define DDR_RFSHCTL1 0x00000000
+#define DDR_RFSHCTL3 0x00000000
+#define DDR_RFSHTMG 0x81240054
+#define DDR_RFSHTMG1 0x00360000
+#define DDR_CRCPARCTL0 0x00000000
+#define DDR_CRCPARCTL1 0x00001000
+#define DDR_INIT0 0xC0020002
+#define DDR_INIT1 0x00010002
+#define DDR_INIT2 0x00000D00
+#define DDR_INIT3 0x00C40024
+#define DDR_INIT4 0x00310008
+#define DDR_INIT5 0x00100004
+#define DDR_INIT6 0x00660047
+#define DDR_INIT7 0x00040047
+#define DDR_DIMMCTL 0x00000000
+#define DDR_RANKCTL 0x0000066F
+#define DDR_DRAMTMG0 0x1718141A
+#define DDR_DRAMTMG1 0x00050524
+#define DDR_DRAMTMG2 0x060C0E11
+#define DDR_DRAMTMG3 0x0090900C
+#define DDR_DRAMTMG4 0x0B04060B
+#define DDR_DRAMTMG5 0x02030909
+#define DDR_DRAMTMG6 0x02020007
+#define DDR_DRAMTMG7 0x00000302
+#define DDR_DRAMTMG8 0x03034405
+#define DDR_DRAMTMG9 0x0004040D
+#define DDR_DRAMTMG10 0x001C180A
+#define DDR_DRAMTMG11 0x440C021C
+#define DDR_DRAMTMG12 0x1A020010
+#define DDR_DRAMTMG13 0x0B100002
+#define DDR_DRAMTMG14 0x000000AD
+#define DDR_DRAMTMG15 0x00000000
+#define DDR_ZQCTL0 0x02580012
+#define DDR_ZQCTL1 0x01E0492E
+#define DDR_ZQCTL2 0x00000000
+#define DDR_DFITMG0 0x0395820A
+#define DDR_DFITMG1 0x000A0303
+#define DDR_DFILPCFG0 0x07F04111
+#define DDR_DFILPCFG1 0x000000F0
+#define DDR_DFIUPD0 0x4040000C
+#define DDR_DFIUPD1 0x0040007F
+#define DDR_DFIUPD2 0x00000000
+#define DDR_DFIMISC 0x00000041
+#define DDR_DFITMG2 0x0000150A
+#define DDR_DFITMG3 0x00000000
+#define DDR_DBICTL 0x00000001
+#define DDR_DFIPHYMSTR 0x80000001
+#define DDR_ADDRMAP0 0x0000001F
+#define DDR_ADDRMAP1 0x00080808
+#define DDR_ADDRMAP2 0x00000000
+#define DDR_ADDRMAP3 0x00000000
+#define DDR_ADDRMAP4 0x00001F1F
+#define DDR_ADDRMAP5 0x070F0707
+#define DDR_ADDRMAP6 0x07070707
+#define DDR_ADDRMAP7 0x00000F0F
+#define DDR_ADDRMAP8 0x00003F3F
+#define DDR_ADDRMAP9 0x07070707
+#define DDR_ADDRMAP10 0x07070707
+#define DDR_ADDRMAP11 0x00000007
+#define DDR_ODTCFG 0x04000400
+#define DDR_ODTMAP 0x00000000
+#define DDR_SCHED 0x00001700
+#define DDR_SCHED1 0x000000FF
+#define DDR_PERFHPR1 0x08000400
+#define DDR_PERFLPR1 0x08000400
+#define DDR_PERFWR1 0x08000400
+#define DDR_DBG0 0x00000000
+#define DDR_DBG1 0x00000000
+#define DDR_DBGCMD 0x00000000
+#define DDR_SWCTL 0x00000002
+#define DDR_POISONCFG 0x00000000
+#define DDR_PCCFG 0x00000010
+#define DDR_PCFGR_0 0x00004100
+#define DDR_PCFGW_0 0x00004100
+#define DDR_PCTRL_0 0x00000000
+#define DDR_PCFGQOS0_0 0x0021000C
+#define DDR_PCFGQOS1_0 0x01000100
+#define DDR_PCFGWQOS0_0 0x01100C07
+#define DDR_PCFGWQOS1_0 0x02000200
+#define DDR_PCFGR_1 0x00004100
+#define DDR_PCFGW_1 0x00004100
+#define DDR_PCTRL_1 0x00000000
+#define DDR_PCFGQOS0_1 0x00100007
+#define DDR_PCFGQOS1_1 0x01000180
+#define DDR_PCFGWQOS0_1 0x01100C07
+#define DDR_PCFGWQOS1_1 0x04000400
+
+#define DDR_UIB_DRAMTYPE 0x00000002
+#define DDR_UIB_DIMMTYPE 0x00000004
+#define DDR_UIB_LP4XMODE 0x00000000
+#define DDR_UIB_NUMDBYTE 0x00000004
+#define DDR_UIB_NUMACTIVEDBYTEDFI0 0x00000002
+#define DDR_UIB_NUMACTIVEDBYTEDFI1 0x00000002
+#define DDR_UIB_NUMANIB 0x00000008
+#define DDR_UIB_NUMRANK_DFI0 0x00000001
+#define DDR_UIB_NUMRANK_DFI1 0x00000001
+#define DDR_UIB_DRAMDATAWIDTH 0x00000010
+#define DDR_UIB_NUMPSTATES 0x00000001
+#define DDR_UIB_FREQUENCY_0 0x000004AF
+#define DDR_UIB_PLLBYPASS_0 0x00000000
+#define DDR_UIB_DFIFREQRATIO_0 0x00000001
+#define DDR_UIB_DFI1EXISTS 0x00000001
+#define DDR_UIB_TRAIN2D 0x00000000
+#define DDR_UIB_HARDMACROVER 0x00000003
+#define DDR_UIB_READDBIENABLE_0 0x00000000
+#define DDR_UIB_DFIMODE 0x00000000
+
+#define DDR_UIA_LP4RXPREAMBLEMODE_0 0x00000000
+#define DDR_UIA_LP4POSTAMBLEEXT_0 0x00000001
+#define DDR_UIA_D4RXPREAMBLELENGTH_0 0x00000001
+#define DDR_UIA_D4TXPREAMBLELENGTH_0 0x00000000
+#define DDR_UIA_EXTCALRESVAL 0x00000000
+#define DDR_UIA_IS2TTIMING_0 0x00000000
+#define DDR_UIA_ODTIMPEDANCE_0 0x00000035
+#define DDR_UIA_TXIMPEDANCE_0 0x00000028
+#define DDR_UIA_ATXIMPEDANCE 0x00000028
+#define DDR_UIA_MEMALERTEN 0x00000000
+#define DDR_UIA_MEMALERTPUIMP 0x00000000
+#define DDR_UIA_MEMALERTVREFLEVEL 0x00000000
+#define DDR_UIA_MEMALERTSYNCBYPASS 0x00000000
+#define DDR_UIA_DISDYNADRTRI_0 0x00000001
+#define DDR_UIA_PHYMSTRTRAININTERVAL_0 0x0000000A
+#define DDR_UIA_PHYMSTRMAXREQTOACK_0 0x00000005
+#define DDR_UIA_WDQSEXT 0x00000000
+#define DDR_UIA_CALINTERVAL 0x00000009
+#define DDR_UIA_CALONCE 0x00000000
+#define DDR_UIA_LP4RL_0 0x00000004
+#define DDR_UIA_LP4WL_0 0x00000004
+#define DDR_UIA_LP4WLS_0 0x00000000
+#define DDR_UIA_LP4DBIRD_0 0x00000000
+#define DDR_UIA_LP4DBIWR_0 0x00000000
+#define DDR_UIA_LP4NWR_0 0x00000004
+#define DDR_UIA_LP4LOWPOWERDRV 0x00000000
+#define DDR_UIA_DRAMBYTESWAP 0x00000000
+#define DDR_UIA_RXENBACKOFF 0x00000000
+#define DDR_UIA_TRAINSEQUENCECTRL 0x00000000
+#define DDR_UIA_SNPSUMCTLOPT 0x00000000
+#define DDR_UIA_SNPSUMCTLF0RC5X_0 0x00000000
+#define DDR_UIA_TXSLEWRISEDQ_0 0x0000000F
+#define DDR_UIA_TXSLEWFALLDQ_0 0x0000000F
+#define DDR_UIA_TXSLEWRISEAC 0x0000000F
+#define DDR_UIA_TXSLEWFALLAC 0x0000000F
+#define DDR_UIA_DISABLERETRAINING 0x00000000
+#define DDR_UIA_DISABLEPHYUPDATE 0x00000001
+#define DDR_UIA_ENABLEHIGHCLKSKEWFIX 0x00000000
+#define DDR_UIA_DISABLEUNUSEDADDRLNS 0x00000001
+#define DDR_UIA_PHYINITSEQUENCENUM 0x00000000
+#define DDR_UIA_ENABLEDFICSPOLARITYFIX 0x00000000
+#define DDR_UIA_PHYVREF 0x00000014
+#define DDR_UIA_SEQUENCECTRL_0 0x0000131F
+
+#define DDR_UIM_MR0_0 0x00000000
+#define DDR_UIM_MR1_0 0x000000C4
+#define DDR_UIM_MR2_0 0x00000024
+#define DDR_UIM_MR3_0 0x00000031
+#define DDR_UIM_MR4_0 0x00000000
+#define DDR_UIM_MR5_0 0x00000000
+#define DDR_UIM_MR6_0 0x00000000
+#define DDR_UIM_MR11_0 0x00000066
+#define DDR_UIM_MR12_0 0x00000047
+#define DDR_UIM_MR13_0 0x00000008
+#define DDR_UIM_MR14_0 0x00000047
+#define DDR_UIM_MR22_0 0x00000004
+
+#define DDR_UIS_SWIZZLE_0 0x00000003
+#define DDR_UIS_SWIZZLE_1 0x00000002
+#define DDR_UIS_SWIZZLE_2 0x00000000
+#define DDR_UIS_SWIZZLE_3 0x00000001
+#define DDR_UIS_SWIZZLE_4 0x00000006
+#define DDR_UIS_SWIZZLE_5 0x00000007
+#define DDR_UIS_SWIZZLE_6 0x00000005
+#define DDR_UIS_SWIZZLE_7 0x00000004
+#define DDR_UIS_SWIZZLE_8 0x00000005
+#define DDR_UIS_SWIZZLE_9 0x00000004
+#define DDR_UIS_SWIZZLE_10 0x00000007
+#define DDR_UIS_SWIZZLE_11 0x00000006
+#define DDR_UIS_SWIZZLE_12 0x00000000
+#define DDR_UIS_SWIZZLE_13 0x00000003
+#define DDR_UIS_SWIZZLE_14 0x00000002
+#define DDR_UIS_SWIZZLE_15 0x00000001
+#define DDR_UIS_SWIZZLE_16 0x00000005
+#define DDR_UIS_SWIZZLE_17 0x00000007
+#define DDR_UIS_SWIZZLE_18 0x00000006
+#define DDR_UIS_SWIZZLE_19 0x00000004
+#define DDR_UIS_SWIZZLE_20 0x00000000
+#define DDR_UIS_SWIZZLE_21 0x00000001
+#define DDR_UIS_SWIZZLE_22 0x00000003
+#define DDR_UIS_SWIZZLE_23 0x00000002
+#define DDR_UIS_SWIZZLE_24 0x00000007
+#define DDR_UIS_SWIZZLE_25 0x00000004
+#define DDR_UIS_SWIZZLE_26 0x00000005
+#define DDR_UIS_SWIZZLE_27 0x00000006
+#define DDR_UIS_SWIZZLE_28 0x00000002
+#define DDR_UIS_SWIZZLE_29 0x00000003
+#define DDR_UIS_SWIZZLE_30 0x00000001
+#define DDR_UIS_SWIZZLE_31 0x00000000
+#define DDR_UIS_SWIZZLE_32 0x00000000
+#define DDR_UIS_SWIZZLE_33 0x00000001
+#define DDR_UIS_SWIZZLE_34 0x00000002
+#define DDR_UIS_SWIZZLE_35 0x00000003
+#define DDR_UIS_SWIZZLE_36 0x00000004
+#define DDR_UIS_SWIZZLE_37 0x00000005
+#define DDR_UIS_SWIZZLE_38 0x00000000
+#define DDR_UIS_SWIZZLE_39 0x00000001
+#define DDR_UIS_SWIZZLE_40 0x00000002
+#define DDR_UIS_SWIZZLE_41 0x00000003
+#define DDR_UIS_SWIZZLE_42 0x00000004
+#define DDR_UIS_SWIZZLE_43 0x00000005
+
+#include "stm32mp25-ddr.dtsi"
diff --git a/fdts/stm32mp25-lpddr4-1x16Gbits-1x32bits-800MHz.dtsi b/fdts/stm32mp25-lpddr4-1x16Gbits-1x32bits-800MHz.dtsi
new file mode 100644
index 000000000..c0b169841
--- /dev/null
+++ b/fdts/stm32mp25-lpddr4-1x16Gbits-1x32bits-800MHz.dtsi
@@ -0,0 +1,247 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+/*
+ * STM32MP257F VALID1 board configuration
+ * LPDDR4 1x16Gbits 1x32bits 800MHz
+ *
+ * Reference used:
+ * - MT53D512M32D2DS-053EIT:E from MICRON
+ *
+ * memclk	801MHz		(2x DFI clock) + range check
+ * width	32		32: full width / 16: half width
+ * density	8Gbits		(per 16bit device)
+ * addressing	RBC		row/bank interleaving
+ * RDBI		No		Read DBI
+ * WDBI		No		Write DBI
+ * RPST		1.5		Read Postamble (ck)
+ * per_bank_ref	Yes
+ */
+
+#define DDR_MEM_NAME	"LPDDR4 1x16Gbits 1x32bits 800MHz"
+#define DDR_MEM_SPEED	800000
+#define DDR_MEM_SIZE	0x80000000
+
+#define DDR_MSTR 0x01080020
+#define DDR_MRCTRL0 0x00000030
+#define DDR_MRCTRL1 0x00000000
+#define DDR_MRCTRL2 0x00000000
+#define DDR_DERATEEN 0x00000101
+#define DDR_DERATEINT 0x00C38E80
+#define DDR_DERATECTL 0x00000000
+#define DDR_PWRCTL 0x00000128
+#define DDR_PWRTMG 0x000D0001
+#define DDR_HWLPCTL 0x00000002
+#define DDR_RFSHCTL0 0x00210074
+#define DDR_RFSHCTL1 0x00000000
+#define DDR_RFSHCTL3 0x00000000
+#define DDR_RFSHTMG 0x80C30039
+#define DDR_RFSHTMG1 0x00250000
+#define DDR_CRCPARCTL0 0x00000000
+#define DDR_CRCPARCTL1 0x00001000
+#define DDR_INIT0 0xC0020002
+#define DDR_INIT1 0x00010002
+#define DDR_INIT2 0x00000D00
+#define DDR_INIT3 0x00B4001B
+#define DDR_INIT4 0x00310008
+#define DDR_INIT5 0x00100004
+#define DDR_INIT6 0x00660047
+#define DDR_INIT7 0x00040047
+#define DDR_DIMMCTL 0x00000000
+#define DDR_RANKCTL 0x0000066F
+#define DDR_DRAMTMG0 0x14110D11
+#define DDR_DRAMTMG1 0x00050419
+#define DDR_DRAMTMG2 0x050A0D0E
+#define DDR_DRAMTMG3 0x0060600C
+#define DDR_DRAMTMG4 0x08040508
+#define DDR_DRAMTMG5 0x02030707
+#define DDR_DRAMTMG6 0x02020007
+#define DDR_DRAMTMG7 0x00000301
+#define DDR_DRAMTMG8 0x03034405
+#define DDR_DRAMTMG9 0x0004040D
+#define DDR_DRAMTMG10 0x001C180A
+#define DDR_DRAMTMG11 0x440C021C
+#define DDR_DRAMTMG12 0x1A020010
+#define DDR_DRAMTMG13 0x0B100002
+#define DDR_DRAMTMG14 0x00000074
+#define DDR_DRAMTMG15 0x00000000
+#define DDR_ZQCTL0 0x0191000D
+#define DDR_ZQCTL1 0x015030E3
+#define DDR_ZQCTL2 0x00000000
+#define DDR_DFITMG0 0x03918208
+#define DDR_DFITMG1 0x000A0303
+#define DDR_DFILPCFG0 0x07F04111
+#define DDR_DFILPCFG1 0x000000F0
+#define DDR_DFIUPD0 0x4040000C
+#define DDR_DFIUPD1 0x0040007F
+#define DDR_DFIUPD2 0x00000000
+#define DDR_DFIMISC 0x00000041
+#define DDR_DFITMG2 0x00001108
+#define DDR_DFITMG3 0x00000000
+#define DDR_DBICTL 0x00000001
+#define DDR_DFIPHYMSTR 0x80000001
+#define DDR_ADDRMAP0 0x0000001F
+#define DDR_ADDRMAP1 0x00080808
+#define DDR_ADDRMAP2 0x00000000
+#define DDR_ADDRMAP3 0x00000000
+#define DDR_ADDRMAP4 0x00001F1F
+#define DDR_ADDRMAP5 0x070F0707
+#define DDR_ADDRMAP6 0x07070707
+#define DDR_ADDRMAP7 0x00000F0F
+#define DDR_ADDRMAP8 0x00003F3F
+#define DDR_ADDRMAP9 0x07070707
+#define DDR_ADDRMAP10 0x07070707
+#define DDR_ADDRMAP11 0x00000007
+#define DDR_ODTCFG 0x04000400
+#define DDR_ODTMAP 0x00000000
+#define DDR_SCHED 0x00001700
+#define DDR_SCHED1 0x000000FF
+#define DDR_PERFHPR1 0x08000400
+#define DDR_PERFLPR1 0x08000400
+#define DDR_PERFWR1 0x08000400
+#define DDR_DBG0 0x00000000
+#define DDR_DBG1 0x00000000
+#define DDR_DBGCMD 0x00000000
+#define DDR_SWCTL 0x00000002
+#define DDR_POISONCFG 0x00000000
+#define DDR_PCCFG 0x00000010
+#define DDR_PCFGR_0 0x00004100
+#define DDR_PCFGW_0 0x00004100
+#define DDR_PCTRL_0 0x00000000
+#define DDR_PCFGQOS0_0 0x0021000C
+#define DDR_PCFGQOS1_0 0x01000100
+#define DDR_PCFGWQOS0_0 0x01100C07
+#define DDR_PCFGWQOS1_0 0x02000200
+#define DDR_PCFGR_1 0x00004100
+#define DDR_PCFGW_1 0x00004100
+#define DDR_PCTRL_1 0x00000000
+#define DDR_PCFGQOS0_1 0x00100007
+#define DDR_PCFGQOS1_1 0x01000180
+#define DDR_PCFGWQOS0_1 0x01100C07
+#define DDR_PCFGWQOS1_1 0x04000400
+
+#define DDR_UIB_DRAMTYPE 0x00000002
+#define DDR_UIB_DIMMTYPE 0x00000004
+#define DDR_UIB_LP4XMODE 0x00000000
+#define DDR_UIB_NUMDBYTE 0x00000004
+#define DDR_UIB_NUMACTIVEDBYTEDFI0 0x00000002
+#define DDR_UIB_NUMACTIVEDBYTEDFI1 0x00000002
+#define DDR_UIB_NUMANIB 0x00000008
+#define DDR_UIB_NUMRANK_DFI0 0x00000001
+#define DDR_UIB_NUMRANK_DFI1 0x00000001
+#define DDR_UIB_DRAMDATAWIDTH 0x00000010
+#define DDR_UIB_NUMPSTATES 0x00000001
+#define DDR_UIB_FREQUENCY_0 0x00000321
+#define DDR_UIB_PLLBYPASS_0 0x00000000
+#define DDR_UIB_DFIFREQRATIO_0 0x00000001
+#define DDR_UIB_DFI1EXISTS 0x00000001
+#define DDR_UIB_TRAIN2D 0x00000000
+#define DDR_UIB_HARDMACROVER 0x00000003
+#define DDR_UIB_READDBIENABLE_0 0x00000000
+#define DDR_UIB_DFIMODE 0x00000000
+
+#define DDR_UIA_LP4RXPREAMBLEMODE_0 0x00000000
+#define DDR_UIA_LP4POSTAMBLEEXT_0 0x00000001
+#define DDR_UIA_D4RXPREAMBLELENGTH_0 0x00000001
+#define DDR_UIA_D4TXPREAMBLELENGTH_0 0x00000000
+#define DDR_UIA_EXTCALRESVAL 0x00000000
+#define DDR_UIA_IS2TTIMING_0 0x00000000
+#define DDR_UIA_ODTIMPEDANCE_0 0x00000035
+#define DDR_UIA_TXIMPEDANCE_0 0x00000028
+#define DDR_UIA_ATXIMPEDANCE 0x00000028
+#define DDR_UIA_MEMALERTEN 0x00000000
+#define DDR_UIA_MEMALERTPUIMP 0x00000000
+#define DDR_UIA_MEMALERTVREFLEVEL 0x00000000
+#define DDR_UIA_MEMALERTSYNCBYPASS 0x00000000
+#define DDR_UIA_DISDYNADRTRI_0 0x00000001
+#define DDR_UIA_PHYMSTRTRAININTERVAL_0 0x0000000A
+#define DDR_UIA_PHYMSTRMAXREQTOACK_0 0x00000005
+#define DDR_UIA_WDQSEXT 0x00000000
+#define DDR_UIA_CALINTERVAL 0x00000009
+#define DDR_UIA_CALONCE 0x00000000
+#define DDR_UIA_LP4RL_0 0x00000003
+#define DDR_UIA_LP4WL_0 0x00000003
+#define DDR_UIA_LP4WLS_0 0x00000000
+#define DDR_UIA_LP4DBIRD_0 0x00000000
+#define DDR_UIA_LP4DBIWR_0 0x00000000
+#define DDR_UIA_LP4NWR_0 0x00000003
+#define DDR_UIA_LP4LOWPOWERDRV 0x00000000
+#define DDR_UIA_DRAMBYTESWAP 0x00000000
+#define DDR_UIA_RXENBACKOFF 0x00000000
+#define DDR_UIA_TRAINSEQUENCECTRL 0x00000000
+#define DDR_UIA_SNPSUMCTLOPT 0x00000000
+#define DDR_UIA_SNPSUMCTLF0RC5X_0 0x00000000
+#define DDR_UIA_TXSLEWRISEDQ_0 0x0000000F
+#define DDR_UIA_TXSLEWFALLDQ_0 0x0000000F
+#define DDR_UIA_TXSLEWRISEAC 0x0000000F
+#define DDR_UIA_TXSLEWFALLAC 0x0000000F
+#define DDR_UIA_DISABLERETRAINING 0x00000000
+#define DDR_UIA_DISABLEPHYUPDATE 0x00000001
+#define DDR_UIA_ENABLEHIGHCLKSKEWFIX 0x00000000
+#define DDR_UIA_DISABLEUNUSEDADDRLNS 0x00000001
+#define DDR_UIA_PHYINITSEQUENCENUM 0x00000000
+#define DDR_UIA_ENABLEDFICSPOLARITYFIX 0x00000000
+#define DDR_UIA_PHYVREF 0x00000014
+#define DDR_UIA_SEQUENCECTRL_0 0x0000131F
+
+#define DDR_UIM_MR0_0 0x00000000
+#define DDR_UIM_MR1_0 0x000000B4
+#define DDR_UIM_MR2_0 0x0000001B
+#define DDR_UIM_MR3_0 0x00000031
+#define DDR_UIM_MR4_0 0x00000000
+#define DDR_UIM_MR5_0 0x00000000
+#define DDR_UIM_MR6_0 0x00000000
+#define DDR_UIM_MR11_0 0x00000066
+#define DDR_UIM_MR12_0 0x00000047
+#define DDR_UIM_MR13_0 0x00000008
+#define DDR_UIM_MR14_0 0x00000047
+#define DDR_UIM_MR22_0 0x00000004
+
+#define DDR_UIS_SWIZZLE_0 0x00000003
+#define DDR_UIS_SWIZZLE_1 0x00000002
+#define DDR_UIS_SWIZZLE_2 0x00000000
+#define DDR_UIS_SWIZZLE_3 0x00000001
+#define DDR_UIS_SWIZZLE_4 0x00000006
+#define DDR_UIS_SWIZZLE_5 0x00000007
+#define DDR_UIS_SWIZZLE_6 0x00000005
+#define DDR_UIS_SWIZZLE_7 0x00000004
+#define DDR_UIS_SWIZZLE_8 0x00000005
+#define DDR_UIS_SWIZZLE_9 0x00000004
+#define DDR_UIS_SWIZZLE_10 0x00000007
+#define DDR_UIS_SWIZZLE_11 0x00000006
+#define DDR_UIS_SWIZZLE_12 0x00000000
+#define DDR_UIS_SWIZZLE_13 0x00000003
+#define DDR_UIS_SWIZZLE_14 0x00000002
+#define DDR_UIS_SWIZZLE_15 0x00000001
+#define DDR_UIS_SWIZZLE_16 0x00000005
+#define DDR_UIS_SWIZZLE_17 0x00000007
+#define DDR_UIS_SWIZZLE_18 0x00000006
+#define DDR_UIS_SWIZZLE_19 0x00000004
+#define DDR_UIS_SWIZZLE_20 0x00000000
+#define DDR_UIS_SWIZZLE_21 0x00000001
+#define DDR_UIS_SWIZZLE_22 0x00000003
+#define DDR_UIS_SWIZZLE_23 0x00000002
+#define DDR_UIS_SWIZZLE_24 0x00000007
+#define DDR_UIS_SWIZZLE_25 0x00000004
+#define DDR_UIS_SWIZZLE_26 0x00000005
+#define DDR_UIS_SWIZZLE_27 0x00000006
+#define DDR_UIS_SWIZZLE_28 0x00000002
+#define DDR_UIS_SWIZZLE_29 0x00000003
+#define DDR_UIS_SWIZZLE_30 0x00000001
+#define DDR_UIS_SWIZZLE_31 0x00000000
+#define DDR_UIS_SWIZZLE_32 0x00000000
+#define DDR_UIS_SWIZZLE_33 0x00000001
+#define DDR_UIS_SWIZZLE_34 0x00000002
+#define DDR_UIS_SWIZZLE_35 0x00000003
+#define DDR_UIS_SWIZZLE_36 0x00000004
+#define DDR_UIS_SWIZZLE_37 0x00000005
+#define DDR_UIS_SWIZZLE_38 0x00000000
+#define DDR_UIS_SWIZZLE_39 0x00000001
+#define DDR_UIS_SWIZZLE_40 0x00000002
+#define DDR_UIS_SWIZZLE_41 0x00000003
+#define DDR_UIS_SWIZZLE_42 0x00000004
+#define DDR_UIS_SWIZZLE_43 0x00000005
+
+#include "stm32mp25-ddr.dtsi"
diff --git a/fdts/stm32mp25-pinctrl-test.dtsi b/fdts/stm32mp25-pinctrl-test.dtsi
new file mode 100644
index 000000000..be3ec98bc
--- /dev/null
+++ b/fdts/stm32mp25-pinctrl-test.dtsi
@@ -0,0 +1,74 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com>
+ */
+#include "stm32mp25-pinctrl.dtsi"
+
+&pinctrl {
+	sdmmc1_b4_test_pins_a: sdmmc1-b4-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 4, AF10)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('E', 5, AF10)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 0, AF10)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 1, AF10)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('E', 2, AF10)>; /* SDMMC1_CMD */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC1_CK */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_b4_test_pins_a: sdmmc2-b4-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 13, AF12)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('E', 11, AF12)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('E', 8, AF12)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('E', 12, AF12)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('E', 15, AF12)>; /* SDMMC2_CMD */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 14, AF12)>; /* SDMMC2_CK */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_d47_test_pins_a: sdmmc2-d47-test-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 10, AF12)>, /* SDMMC2_D4 */
+				 <STM32_PINMUX('E', 9, AF12)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('E', 6, AF12)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('E', 7, AF12)>; /* SDMMC2_D7 */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	usart2_test_pins_a: usart2-test-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 4, AF6)>; /* USART2_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 8, AF8)>; /* USART2_RX */
+			bias-disable;
+		};
+	};
+};
+
+&pinctrl_z {
+};
diff --git a/fdts/stm32mp25-pinctrl.dtsi b/fdts/stm32mp25-pinctrl.dtsi
new file mode 100644
index 000000000..a2489acc3
--- /dev/null
+++ b/fdts/stm32mp25-pinctrl.dtsi
@@ -0,0 +1,7 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
diff --git a/fdts/stm32mp251.dtsi b/fdts/stm32mp251.dtsi
new file mode 100644
index 000000000..a81fb6aae
--- /dev/null
+++ b/fdts/stm32mp251.dtsi
@@ -0,0 +1,568 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+#include <dt-bindings/clock/stm32mp2-clks.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/reset/stm32mp2-resets.h>
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,cortex-a35";
+			device_type = "cpu";
+			reg = <0>;
+			enable-method = "psci";
+		};
+	};
+
+	intc: interrupt-controller@4ac00000 {
+		compatible = "arm,cortex-a7-gic";
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		reg = <0x4ac10000 0x1000>,
+		      <0x4ac20000 0x2000>,
+		      <0x4ac40000 0x2000>,
+		      <0x4ac60000 0x2000>;
+	};
+
+	timer: timer {
+		compatible = "arm,armv8-timer";
+		interrupt-parent = <&intc>;
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>;
+		always-on;
+	};
+
+	clocks {
+		clk_hse: clk-hse {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <48000000>;
+		};
+
+		clk_hsi: clk-hsi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <64000000>;
+		};
+
+		clk_lse: clk-lse {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <32768>;
+		};
+
+		clk_lsi: clk-lsi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <32000>;
+		};
+
+		clk_msi: clk-msi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <16000000>;
+		};
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&intc>;
+		ranges;
+
+		usart2: serial@400e0000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x400e0000 0x400>;
+			clocks = <&rcc CK_KER_USART2>;
+			resets = <&rcc USART2_R>;
+			status = "disabled";
+		};
+
+		usart3: serial@400f0000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x400f0000 0x400>;
+			clocks = <&rcc CK_KER_USART3>;
+			resets = <&rcc USART3_R>;
+			status = "disabled";
+		};
+
+		uart4: serial@40100000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40100000 0x400>;
+			clocks = <&rcc CK_KER_UART4>;
+			resets = <&rcc UART4_R>;
+			status = "disabled";
+		};
+
+		uart5: serial@40110000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40110000 0x400>;
+			clocks = <&rcc CK_KER_UART5>;
+			resets = <&rcc UART5_R>;
+			status = "disabled";
+		};
+
+		i2c1: i2c@40120000 {
+			compatible = "st,stm32mp25-i2c";
+			reg = <0x40120000 0x400>;
+			clocks = <&rcc CK_KER_I2C1>;
+			resets = <&rcc I2C1_R>;
+			status = "disabled";
+		};
+
+		i2c2: i2c@40130000 {
+			compatible = "st,stm32mp25-i2c";
+			reg = <0x40130000 0x400>;
+			clocks = <&rcc CK_KER_I2C2>;
+			resets = <&rcc I2C2_R>;
+			status = "disabled";
+		};
+
+		i2c3: i2c@40140000 {
+			compatible = "st,stm32mp25-i2c";
+			reg = <0x40140000 0x400>;
+			clocks = <&rcc CK_KER_I2C3>;
+			resets = <&rcc I2C3_R>;
+			status = "disabled";
+		};
+
+		i2c4: i2c@40150000 {
+			compatible = "st,stm32mp25-i2c";
+			reg = <0x40150000 0x400>;
+			clocks = <&rcc CK_KER_I2C4>;
+			resets = <&rcc I2C4_R>;
+			status = "disabled";
+		};
+
+		i2c5: i2c@40160000 {
+			compatible = "st,stm32mp25-i2c";
+			reg = <0x40160000 0x400>;
+			clocks = <&rcc CK_KER_I2C5>;
+			resets = <&rcc I2C5_R>;
+			status = "disabled";
+		};
+
+		i2c6: i2c@40170000 {
+			compatible = "st,stm32mp25-i2c";
+			reg = <0x40170000 0x400>;
+			clocks = <&rcc CK_KER_I2C6>;
+			resets = <&rcc I2C6_R>;
+			status = "disabled";
+		};
+
+		i2c7: i2c@40180000 {
+			compatible = "st,stm32mp25-i2c";
+			reg = <0x40180000 0x400>;
+			clocks = <&rcc CK_KER_I2C7>;
+			resets = <&rcc I2C7_R>;
+			status = "disabled";
+		};
+
+		usart6: serial@40220000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40220000 0x400>;
+			clocks = <&rcc CK_KER_USART6>;
+			resets = <&rcc USART6_R>;
+			status = "disabled";
+		};
+
+		uart9: serial@402c0000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x402c0000 0x400>;
+			clocks = <&rcc CK_KER_UART9>;
+			resets = <&rcc UART9_R>;
+			status = "disabled";
+		};
+
+		usart1: serial@40330000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40330000 0x400>;
+			clocks = <&rcc CK_KER_USART1>;
+			resets = <&rcc USART1_R>;
+			status = "disabled";
+		};
+
+		uart7: serial@40370000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40370000 0x400>;
+			clocks = <&rcc CK_KER_UART7>;
+			resets = <&rcc UART7_R>;
+			status = "disabled";
+		};
+
+		uart8: serial@40380000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40380000 0x400>;
+			clocks = <&rcc CK_KER_UART8>;
+			resets = <&rcc UART8_R>;
+			status = "disabled";
+		};
+
+		ommanager: ommanager@40500000 {
+			#address-cells = <2>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp25-omm";
+			reg = <0x40500000 0x400>, <0x60000000 0x10000000>;
+			reg-names = "omm", "omm_mm";
+			clocks = <&rcc CK_BUS_OSPIIOM>;
+			resets = <&rcc OSPIIOM_R>;
+			status = "disabled";
+
+			ranges = <0 0 0x40430000 0x400>,
+				 <1 0 0x40440000 0x400>;
+
+			ospi1: spi@40430000 {
+				compatible = "st,stm32mp25-omi";
+				reg = <0 0 0x400>;
+				clocks = <&rcc CK_KER_OSPI1>;
+				resets = <&rcc OSPI1_R>, <&rcc OSPI1DLL_R>;
+				status = "disabled";
+			};
+
+			ospi2: spi@40440000 {
+				compatible = "st,stm32mp25-omi";
+				reg = <1 0 0x400>;
+				clocks = <&rcc CK_KER_OSPI2>;
+				resets = <&rcc OSPI2_R>, <&rcc OSPI2DLL_R>;
+				status = "disabled";
+			};
+		};
+
+		rng: rng@42020000 {
+			compatible = "st,stm32mp13-rng";
+			reg = <0x42020000 0x400>;
+			clocks = <&rcc CK_BUS_RNG>;
+			resets = <&rcc RNG_R>;
+			status = "disabled";
+		};
+
+		risaf2: risaf@420b0000 {
+			compatible = "st,stm32-risaf";
+			reg = <0x420b0000 0x1000>;
+			status = "disabled";
+		};
+
+		risaf4: risaf@420d0000 {
+			compatible = "st,stm32-risaf";
+			reg = <0x420d0000 0x1000>;
+			status = "disabled";
+		};
+
+		bsec: efuse@44000000 {
+			compatible = "st,stm32mp2-bsec";
+			reg = <0x44000000 0x400>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			part_number_otp@24 {
+				reg = <0x24 0x4>;
+			};
+			uid_otp@14 {
+				reg = <0x14 0xc>;
+			};
+			nand_otp: otp16@40 {
+				reg = <0x40 0x4>;
+			};
+			nand2_otp: otp20@50 {
+				reg = <0x50 0x4>;
+			};
+			package_otp@1e8 {
+				reg = <0x1e8 0x1>;
+			};
+			hconf1_otp: otp124@1f0 {
+				reg = <0x1f0 0x4>;
+			};
+		};
+
+		iwdg1: watchdog@44010000 {
+			compatible = "st,stm32mp2-iwdg";
+			reg = <0x44010000 0x400>;
+			clocks = <&rcc CK_BUS_IWDG1>, <&rcc LSI_CK>;
+			clock-names = "pclk", "lsi";
+			status = "disabled";
+		};
+
+		rcc: rcc@44200000 {
+			compatible = "st,stm32mp2-rcc";
+			reg = <0x44200000 0x10000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+
+		pwr: pwr@44210000 {
+			#address-cells = <2>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp25-pwr";
+			reg = <0x44210000 0x400>;
+
+			vddio1: vddio1 {
+				regulator-name = "vddio1";
+			};
+
+			vddio2: vddio2 {
+				regulator-name = "vddio2";
+			};
+
+			vddio3: vddio3 {
+				regulator-name = "vddio3";
+			};
+
+			vddio4: vddio4 {
+				regulator-name = "vddio4";
+			};
+
+			vddio: vddio {
+				regulator-name = "vddio";
+			};
+		};
+
+		syscfg: syscon@44230000 {
+			compatible = "st,stm32mp25-syscfg", "syscon";
+			reg = <0x44230000 0x10000>;
+		};
+
+		i2c8: i2c@46040000 {
+			compatible = "st,stm32mp25-i2c";
+			reg = <0x46040000 0x400>;
+			clocks = <&rcc CK_KER_I2C8>;
+			resets = <&rcc I2C8_R>;
+			status = "disabled";
+		};
+
+		ddr: ddr@48040000 {
+			compatible = "st,stm32mp2-ddr";
+			reg = <0x48040000 0x10000>,
+			      <0x48c00000 0x400000>;
+			status = "okay";
+		};
+
+		fmc: memory-controller@48200000 {
+			#address-cells = <2>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp25-fmc2-ebi";
+			reg = <0x48200000 0x400>;
+			clocks = <&rcc CK_KER_FMC>;
+			resets = <&rcc FMC_R>;
+			status = "disabled";
+
+			ranges = <0 0 0x70000000 0x04000000>, /* EBI CS 1 */
+				 <1 0 0x74000000 0x04000000>, /* EBI CS 2 */
+				 <2 0 0x78000000 0x04000000>, /* EBI CS 3 */
+				 <3 0 0x7c000000 0x04000000>, /* EBI CS 4 */
+				 <4 0 0x48810000 0x00001000>; /* NAND */
+
+			nand-controller@4,0 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-fmc2-nfc";
+				reg = <4 0x0000 0x10>,
+				      <4 0x0090 0x10>,
+				      <4 0x00a0 0x10>,
+				      <4 0x0400 0x10>,
+				      <4 0x0490 0x10>,
+				      <4 0x04a0 0x10>,
+				      <4 0x0800 0x10>,
+				      <4 0x0890 0x10>,
+				      <4 0x08a0 0x10>,
+				      <4 0x0c00 0x10>,
+				      <4 0x0c90 0x10>,
+				      <4 0x0ca0 0x10>;
+				interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+				status = "disabled";
+			};
+		};
+
+		sdmmc1: mmc@48220000 {
+			compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+			arm,primecell-periphid = <0x00353180>;
+			reg = <0x48220000 0x400>, <0x44230400 0x8>;
+			clocks = <&rcc CK_KER_SDMMC1>;
+			clock-names = "apb_pclk";
+			resets = <&rcc SDMMC1_R>;
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			max-frequency = <120000000>;
+			status = "disabled";
+		};
+
+		sdmmc2: mmc@48230000 {
+			compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+			arm,primecell-periphid = <0x00353180>;
+			reg = <0x48230000 0x400>, <0x44230800 0x8>;
+			clocks = <&rcc CK_KER_SDMMC2>;
+			clock-names = "apb_pclk";
+			resets = <&rcc SDMMC2_R>;
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			max-frequency = <120000000>;
+			status = "disabled";
+		};
+
+		/*
+		 * Break node order to solve dependency probe issue between
+		 * pinctrl and exti.
+		 */
+		pinctrl: pinctrl@44240000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp257-pinctrl";
+			ranges = <0 0x44240000 0xa0400>;
+			pins-are-numbered;
+
+			gpioa: gpio@44240000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x0 0x400>;
+				clocks = <&rcc CK_BUS_GPIOA>;
+				st,bank-name = "GPIOA";
+				status = "disabled";
+			};
+
+			gpiob: gpio@44250000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x10000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOB>;
+				st,bank-name = "GPIOB";
+				status = "disabled";
+			};
+
+			gpioc: gpio@44260000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x20000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOC>;
+				st,bank-name = "GPIOC";
+				status = "disabled";
+			};
+
+			gpiod: gpio@44270000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x30000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOD>;
+				st,bank-name = "GPIOD";
+				status = "disabled";
+			};
+
+			gpioe: gpio@44280000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x40000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOE>;
+				st,bank-name = "GPIOE";
+				status = "disabled";
+			};
+
+			gpiof: gpio@44290000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x50000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOF>;
+				st,bank-name = "GPIOF";
+				status = "disabled";
+			};
+
+			gpiog: gpio@442a0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x60000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOG>;
+				st,bank-name = "GPIOG";
+				status = "disabled";
+			};
+
+			gpioh: gpio@442b0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x70000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOH>;
+				st,bank-name = "GPIOH";
+				status = "disabled";
+			};
+
+			gpioi: gpio@442c0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x80000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOI>;
+				st,bank-name = "GPIOI";
+				status = "disabled";
+			};
+
+			gpioj: gpio@442d0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x90000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOJ>;
+				st,bank-name = "GPIOJ";
+				status = "disabled";
+			};
+
+			gpiok: gpio@442e0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0xa0000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOK>;
+				st,bank-name = "GPIOK";
+				status = "disabled";
+			};
+		};
+
+		pinctrl_z: pinctrl@46200000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp257-z-pinctrl";
+			ranges = <0 0x46200000 0x400>;
+			pins-are-numbered;
+
+			gpioz: gpio@46200000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0 0x400>;
+				clocks = <&rcc CK_BUS_GPIOZ>;
+				st,bank-name = "GPIOZ";
+				st,bank-ioport = <11>;
+				status = "disabled";
+			};
+
+		};
+	};
+};
diff --git a/fdts/stm32mp253.dtsi b/fdts/stm32mp253.dtsi
new file mode 100644
index 000000000..2033dd667
--- /dev/null
+++ b/fdts/stm32mp253.dtsi
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include "stm32mp251.dtsi"
diff --git a/fdts/stm32mp255.dtsi b/fdts/stm32mp255.dtsi
new file mode 100644
index 000000000..3602b9e5b
--- /dev/null
+++ b/fdts/stm32mp255.dtsi
@@ -0,0 +1,9 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include "stm32mp253.dtsi"
+
+/ {
+};
diff --git a/fdts/stm32mp257.dtsi b/fdts/stm32mp257.dtsi
new file mode 100644
index 000000000..3ab7cabfc
--- /dev/null
+++ b/fdts/stm32mp257.dtsi
@@ -0,0 +1,9 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include "stm32mp255.dtsi"
+
+/ {
+};
diff --git a/fdts/stm32mp257f-dk-fw-config.dts b/fdts/stm32mp257f-dk-fw-config.dts
new file mode 100644
index 000000000..e0f7ac7dd
--- /dev/null
+++ b/fdts/stm32mp257f-dk-fw-config.dts
@@ -0,0 +1,7 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (c) 2020-2021, STMicroelectronics - All Rights Reserved
+ */
+
+#define DDR_SIZE	0x80000000 /* 2GB */
+#include "stm32mp25-fw-config.dtsi"
diff --git a/fdts/stm32mp257f-dk.dts b/fdts/stm32mp257f-dk.dts
new file mode 100644
index 000000000..65f19fb21
--- /dev/null
+++ b/fdts/stm32mp257f-dk.dts
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp257.dtsi"
+#include "stm32mp25xf.dtsi"
+#include "stm32mp25-lpddr4-1x16Gbits-1x32bits-800MHz.dtsi"
+#include "stm32mp25-pinctrl.dtsi"
+#include "stm32mp25xxal-pinctrl.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP257F-DK Discovery Board";
+	compatible = "st,stm32mp257f-dk", "st,stm32mp257";
+
+	aliases {
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x80000000 0x80000000>;
+	};
+};
+
+&bsec {
+	board_id: board_id@3fc {
+		reg = <0x3fc 0x4>;
+	};
+};
diff --git a/fdts/stm32mp257f-ev-fw-config.dts b/fdts/stm32mp257f-ev-fw-config.dts
new file mode 100644
index 000000000..e0f7ac7dd
--- /dev/null
+++ b/fdts/stm32mp257f-ev-fw-config.dts
@@ -0,0 +1,7 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (c) 2020-2021, STMicroelectronics - All Rights Reserved
+ */
+
+#define DDR_SIZE	0x80000000 /* 2GB */
+#include "stm32mp25-fw-config.dtsi"
diff --git a/fdts/stm32mp257f-ev.dts b/fdts/stm32mp257f-ev.dts
new file mode 100644
index 000000000..a230b77d1
--- /dev/null
+++ b/fdts/stm32mp257f-ev.dts
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp257.dtsi"
+#include "stm32mp25xf.dtsi"
+#include "stm32mp25-ddr4-2x8Gbits-2x16bits-800MHz.dtsi"
+#include "stm32mp25-pinctrl.dtsi"
+#include "stm32mp25xxai-pinctrl.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP257F-EV Evaluation Board";
+	compatible = "st,stm32mp257f-ev", "st,stm32mp257";
+
+	aliases {
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x80000000 0x80000000>;
+	};
+};
+
+&bsec {
+	board_id: board_id@3fc {
+		reg = <0x3fc 0x4>;
+	};
+};
diff --git a/fdts/stm32mp257f-valid3-ca35tdcid-rcc.dtsi b/fdts/stm32mp257f-valid3-ca35tdcid-rcc.dtsi
new file mode 100644
index 000000000..26c6787ab
--- /dev/null
+++ b/fdts/stm32mp257f-valid3-ca35tdcid-rcc.dtsi
@@ -0,0 +1,94 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ */
+
+/*
+ * STM32MP25 Clock tree device tree configuration
+ * Project : valid3-bu
+ * Generated by XLmx tool version 2.2 - 8/23/2022 3:30:11 PM
+ */
+
+&clk_hse {
+	clock-frequency = <40000000>;
+};
+
+&clk_hsi {
+	clock-frequency = <64000000>;
+};
+
+&clk_lse {
+	clock-frequency = <32768>;
+};
+
+&clk_lsi {
+	clock-frequency = <32000>;
+};
+
+&clk_msi {
+	clock-frequency = <16000000>;
+};
+
+&rcc {
+	st,flexgen = <
+		FLEXGEN_CFG(0, XBAR_SRC_PLL4, 0, 2)
+		FLEXGEN_CFG(1, XBAR_SRC_PLL4, 0, 5)
+		FLEXGEN_CFG(2, XBAR_SRC_PLL4, 0, 1)
+		FLEXGEN_CFG(4, XBAR_SRC_PLL4, 0, 3)
+		FLEXGEN_CFG(5, XBAR_SRC_PLL4, 0, 2)
+		FLEXGEN_CFG(8, XBAR_SRC_PLL4, 0, 11)
+		FLEXGEN_CFG(51, XBAR_SRC_PLL4, 0, 5)
+		FLEXGEN_CFG(52, XBAR_SRC_PLL4, 0, 5)
+		FLEXGEN_CFG(58, XBAR_SRC_HSE, 0, 1)
+		FLEXGEN_CFG(63, XBAR_SRC_PLL4, 0, 2)
+	>;
+
+	st,busclk = <
+		DIV_CFG(DIV_LSMCU, 1)
+		DIV_CFG(DIV_APB1, 0)
+		DIV_CFG(DIV_APB2, 0)
+		DIV_CFG(DIV_APB3, 0)
+		DIV_CFG(DIV_APB4, 0)
+		DIV_CFG(DIV_APBDBG, 0)
+	>;
+
+	st,kerclk = <
+		MUX_CFG(MUX_USB2PHY1, MUX_USB2PHY1_FLEX57)
+		MUX_CFG(MUX_USB2PHY2, MUX_USB2PHY2_FLEX58)
+	>;
+
+	pll1: st,pll@0 {
+		st,pll = <&pll1_cfg_1200Mhz>;
+
+		pll1_cfg_1200Mhz: pll1-cfg-1200Mhz {
+			cfg = < 30 1 1 1 >;
+			src = < MUX_CFG(MUX_MUXSEL5, MUXSEL_HSE) >;
+		};
+	};
+
+	/* DRAM clock = 2 * PLL2 clock */
+	pll2: st,pll@1 {
+		st,pll = <&pll2_cfg_600Mhz>;
+
+		pll2_cfg_400Mhz: pll2-cfg-400Mhz {
+			cfg = < 60 1 6 1 >;
+			src = < MUX_CFG(MUX_MUXSEL6, MUXSEL_HSE) >;
+			frac = < 0x0C4C3F >;
+		};
+
+		pll2_cfg_600Mhz: pll2-cfg-600Mhz {
+			cfg = < 59 1 4 1 >;
+			src = < MUX_CFG(MUX_MUXSEL6, MUXSEL_HSE) >;
+			frac = < 0xF3B8CA >;
+		};
+	};
+
+	pll4: st,pll@3 {
+		st,pll = <&pll4_cfg_1200Mhz>;
+
+		pll4_cfg_1200Mhz: pll4-cfg-1200Mhz {
+			cfg = < 30 1 1 1 >;
+			src = < MUX_CFG(MUX_MUXSEL0, MUXSEL_HSE) >;
+		};
+	};
+};
diff --git a/fdts/stm32mp257f-valid3-daughter-fw-config.dts b/fdts/stm32mp257f-valid3-daughter-fw-config.dts
new file mode 100644
index 000000000..bee1eb65a
--- /dev/null
+++ b/fdts/stm32mp257f-valid3-daughter-fw-config.dts
@@ -0,0 +1,7 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+#define DDR_SIZE	0x80000000 /* 2GB */
+#include "stm32mp25-fw-config.dtsi"
diff --git a/fdts/stm32mp257f-valid3-daughter.dts b/fdts/stm32mp257f-valid3-daughter.dts
new file mode 100644
index 000000000..79de3e057
--- /dev/null
+++ b/fdts/stm32mp257f-valid3-daughter.dts
@@ -0,0 +1,172 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/clock/stm32mp2-clksrc.h>
+#include "stm32mp257.dtsi"
+#include "stm32mp257f-valid3-ca35tdcid-rcc.dtsi"
+#include "stm32mp25-ddr4-2x8Gbits-2x16bits-1200MHz.dtsi"
+#include "stm32mp25-pinctrl-test.dtsi"
+#include "stm32mp25xf.dtsi"
+#include "stm32mp25xxai-pinctrl.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP257F VALID3 DAUGHTER / MB1706 (DDR4 Power discrete)";
+	compatible = "st,stm32mp257f-valid3-daughter", "st,stm32mp257";
+
+	aliases {
+		serial0 = &usart2;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x80000000 0x80000000>;
+	};
+
+	shadow-prov {
+		compatible = "st,provisioning";
+
+		hconf1_prov {
+			nvmem-cells = <&hconf1_otp>;
+			st,shadow-value = <0x00018000>;
+		};
+	};
+
+	vdd: vdd {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	vddio_sdcard: vddio_sdcard {
+		/* ToDo: to define a gpio regulator */
+		/* PI15 = volt selection */
+		/* supplied by vdd_sdcard */
+		compatible = "regulator-fixed";
+		regulator-name = "vddio_sdcard";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	vdd_sdcard: vdd_sdcard {
+		/*
+		 * ToDo: to define a gpio regulator
+		 * PB12 = en / disable
+		 */
+		compatible = "regulator-fixed";
+		regulator-name = "vdd_sdcard";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+	};
+
+	v1v8: v1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "v1v8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-always-on;
+	};
+
+	v3v3: v3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "v3v3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	vdd_ddr: vdd_ddr {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd_ddr";
+		regulator-min-microvolt = <1350000>;
+		regulator-max-microvolt = <1350000>;
+		regulator-always-on;
+	};
+
+	vref_ddr: vref_ddr {
+		compatible = "regulator-fixed";
+		regulator-name = "vref_ddr";
+		regulator-min-microvolt = <675000>;
+		regulator-max-microvolt = <675000>;
+		regulator-always-on;
+	};
+
+	vtt_ddr: vtt_ddr {
+		compatible = "regulator-fixed";
+		regulator-name = "vtt_ddr";
+		regulator-min-microvolt = <675000>;
+		regulator-max-microvolt = <675000>;
+		regulator-always-on;
+	};
+};
+
+&bsec {
+	board_id: board_id@3fc {
+		reg = <0x3fc 0x4>;
+	};
+};
+
+&pwr {
+	vddio1: vddio1 {
+		vddio1-supply = <&vddio_sdcard>;
+	};
+
+	vddio2: vddio2 {
+		vddio2-supply = <&v1v8>;
+	};
+
+	vddio3: vddio3 {
+		vddio3-supply = <&v3v3>;
+	};
+
+	vddio4: vddio4 {
+		vddio4-supply = <&v3v3>;
+	};
+
+	vddio: vddio {
+		vdd-supply = <&vdd>;
+	};
+};
+
+&rng {
+	status = "okay";
+};
+
+&sdmmc1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc1_b4_test_pins_a>;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&vdd_sdcard>;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc2_b4_test_pins_a &sdmmc2_d47_test_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&v3v3>;
+	vqmmc-supply = <&vddio2>;
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	status = "okay";
+};
+
+&usart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&usart2_test_pins_a>;
+	status = "okay";
+};
diff --git a/fdts/stm32mp257f-valid3-fw-config.dts b/fdts/stm32mp257f-valid3-fw-config.dts
new file mode 100644
index 000000000..bee1eb65a
--- /dev/null
+++ b/fdts/stm32mp257f-valid3-fw-config.dts
@@ -0,0 +1,7 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+#define DDR_SIZE	0x80000000 /* 2GB */
+#include "stm32mp25-fw-config.dtsi"
diff --git a/fdts/stm32mp257f-valid3.dts b/fdts/stm32mp257f-valid3.dts
new file mode 100644
index 000000000..90d7825af
--- /dev/null
+++ b/fdts/stm32mp257f-valid3.dts
@@ -0,0 +1,14 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp257f-valid3-daughter.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP257F VALID3 / MB1706 (DDR4 Power discrete) + MB1703";
+	compatible = "st,stm32mp257f-valid3", "st,stm32mp257";
+};
diff --git a/fdts/stm32mp25xc.dtsi b/fdts/stm32mp25xc.dtsi
new file mode 100644
index 000000000..8a83e3235
--- /dev/null
+++ b/fdts/stm32mp25xc.dtsi
@@ -0,0 +1,8 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/ {
+};
diff --git a/fdts/stm32mp25xf.dtsi b/fdts/stm32mp25xf.dtsi
new file mode 100644
index 000000000..8a83e3235
--- /dev/null
+++ b/fdts/stm32mp25xf.dtsi
@@ -0,0 +1,8 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/ {
+};
diff --git a/fdts/stm32mp25xxai-pinctrl.dtsi b/fdts/stm32mp25xxai-pinctrl.dtsi
new file mode 100644
index 000000000..aab088863
--- /dev/null
+++ b/fdts/stm32mp25xxai-pinctrl.dtsi
@@ -0,0 +1,81 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 2 114 12>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 128 16>;
+	};
+
+	gpioj: gpio@442d0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 144 16>;
+	};
+
+	gpiok: gpio@442e0000 {
+		status = "okay";
+		ngpios = <8>;
+		gpio-ranges = <&pinctrl 0 160 8>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <10>;
+		gpio-ranges = <&pinctrl_z 0 400 10>;
+	};
+};
diff --git a/fdts/stm32mp25xxak-pinctrl.dtsi b/fdts/stm32mp25xxak-pinctrl.dtsi
new file mode 100644
index 000000000..e8dbe966d
--- /dev/null
+++ b/fdts/stm32mp25xxak-pinctrl.dtsi
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 2 114 12>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 0 128 12>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <10>;
+		gpio-ranges = <&pinctrl_z 0 400 10>;
+	};
+};
diff --git a/fdts/stm32mp25xxal-pinctrl.dtsi b/fdts/stm32mp25xxal-pinctrl.dtsi
new file mode 100644
index 000000000..e8dbe966d
--- /dev/null
+++ b/fdts/stm32mp25xxal-pinctrl.dtsi
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 2 114 12>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 0 128 12>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <10>;
+		gpio-ranges = <&pinctrl_z 0 400 10>;
+	};
+};
diff --git a/include/arch/aarch32/arch.h b/include/arch/aarch32/arch.h
index a1bd94291..ecc0746e6 100644
--- a/include/arch/aarch32/arch.h
+++ b/include/arch/aarch32/arch.h
@@ -486,13 +486,13 @@
  * system level implementation of the Generic Timer.
  ******************************************************************************/
 /* Physical Count register. */
-#define CNTPCT_LO		U(0x0)
+#define CNTBASEN_CNTPCT_LO		U(0x0)
 /* Counter Frequency register. */
 #define CNTBASEN_CNTFRQ		U(0x10)
 /* Physical Timer CompareValue register. */
-#define CNTP_CVAL_LO		U(0x20)
+#define CNTBASEN_CNTP_CVAL_LO	U(0x20)
 /* Physical Timer Control register. */
-#define CNTP_CTL		U(0x2c)
+#define CNTBASEN_CNTP_CTL	U(0x2c)
 
 /* Physical timer control register bit fields shifts and masks */
 #define CNTP_CTL_ENABLE_SHIFT   0
@@ -553,6 +553,9 @@
 #define HSTR		p15, 4, c1, c1, 3
 #define CNTHCTL		p15, 4, c14, c1, 0
 #define CNTKCTL		p15, 0, c14, c1, 0
+#define CNTP_TVAL	p15, 0, c14, c2, 0
+#define CNTP_CTL	p15, 0, c14, c2, 1
+#define CNTV_CTL	p15, 0, c14, c3, 1
 #define VPIDR		p15, 4, c0, c0, 0
 #define VMPIDR		p15, 4, c0, c0, 5
 #define ISR		p15, 0, c12, c1, 0
@@ -562,6 +565,7 @@
 #define HTCR		p15, 4, c2, c0, 2
 #define HMAIR0		p15, 4, c10, c2, 0
 #define ATS1CPR		p15, 0, c7, c8, 0
+#define ATS1CPW		p15, 0, c7, c8, 1
 #define ATS1HR		p15, 4, c7, c8, 0
 #define DBGOSDLR	p14, 0, c1, c3, 4
 
@@ -612,6 +616,12 @@
 #define ICC_ASGI1R_EL1_64	p15, 1, c12
 #define ICC_SGI0R_EL1_64	p15, 2, c12
 
+/* Fault registers. The format is: coproc, opt1, CRn, CRm, opt2 */
+#define DFSR		p15, 0, c5, c0, 0
+#define IFSR		p15, 0, c5, c0, 1
+#define DFAR		p15, 0, c6, c0, 0
+#define IFAR		p15, 0, c6, c0, 2
+
 /*******************************************************************************
  * Definitions of MAIR encodings for device and normal memory
  ******************************************************************************/
@@ -665,6 +675,8 @@
 /* PAR fields */
 #define PAR_F_SHIFT	U(0)
 #define PAR_F_MASK	ULL(0x1)
+#define PAR_NS_SHIFT	U(9)
+#define PAR_NS_MASK	U(0x1)
 #define PAR_ADDR_SHIFT	U(12)
 #define PAR_ADDR_MASK	(BIT_64(40) - ULL(1)) /* 40-bits-wide page address */
 
diff --git a/include/arch/aarch32/arch_helpers.h b/include/arch/aarch32/arch_helpers.h
index 033098915..310da7837 100644
--- a/include/arch/aarch32/arch_helpers.h
+++ b/include/arch/aarch32/arch_helpers.h
@@ -249,6 +249,9 @@ DEFINE_COPROCR_RW_FUNCS_64(ttbr1, TTBR1_64)
 DEFINE_COPROCR_RW_FUNCS_64(cntvoff, CNTVOFF_64)
 DEFINE_COPROCR_RW_FUNCS(csselr, CSSELR)
 DEFINE_COPROCR_RW_FUNCS(hstr, HSTR)
+DEFINE_COPROCR_RW_FUNCS(cntp_tval, CNTP_TVAL)
+DEFINE_COPROCR_RW_FUNCS(cntp_ctl, CNTP_CTL)
+DEFINE_COPROCR_RW_FUNCS(cntv_ctl, CNTV_CTL)
 DEFINE_COPROCR_RW_FUNCS(cnthp_ctl_el2, CNTHP_CTL)
 DEFINE_COPROCR_RW_FUNCS(cnthp_tval_el2, CNTHP_TVAL)
 DEFINE_COPROCR_RW_FUNCS_64(cnthp_cval_el2, CNTHP_CVAL_64)
@@ -292,6 +295,7 @@ DEFINE_COPROCR_READ_FUNC(pmcr, PMCR)
  * Address translation
  */
 DEFINE_COPROCR_WRITE_FUNC(ats1cpr, ATS1CPR)
+DEFINE_COPROCR_WRITE_FUNC(ats1cpw, ATS1CPW)
 DEFINE_COPROCR_WRITE_FUNC(ats1hr, ATS1HR)
 DEFINE_COPROCR_RW_FUNCS_64(par, PAR_64)
 
diff --git a/include/arch/aarch64/arch.h b/include/arch/aarch64/arch.h
index 0fb4e7436..c99fd5ab6 100644
--- a/include/arch/aarch64/arch.h
+++ b/include/arch/aarch64/arch.h
@@ -894,13 +894,13 @@
  * system level implementation of the Generic Timer.
  ******************************************************************************/
 /* Physical Count register. */
-#define CNTPCT_LO		U(0x0)
+#define CNTBASEN_CNTPCT_LO		U(0x0)
 /* Counter Frequency register. */
 #define CNTBASEN_CNTFRQ		U(0x10)
 /* Physical Timer CompareValue register. */
-#define CNTP_CVAL_LO		U(0x20)
+#define CNTBASEN_CNTP_CVAL_LO	U(0x20)
 /* Physical Timer Control register. */
-#define CNTP_CTL		U(0x2c)
+#define CNTBASEN_CNTP_CTL	U(0x2c)
 
 /* PMCR_EL0 definitions */
 #define PMCR_EL0_RESET_VAL	U(0x0)
diff --git a/include/common/tbbr/cot_def.h b/include/common/tbbr/cot_def.h
index 800ad07eb..dea5507e7 100644
--- a/include/common/tbbr/cot_def.h
+++ b/include/common/tbbr/cot_def.h
@@ -39,7 +39,7 @@
 #error "Invalid value for TF_MBEDTLS_KEY_SIZE"
 #endif
 #else /* Only using ECDSA keys. */
-#define PK_DER_LEN                      91
+#define PK_DER_LEN                      92
 #endif
 
 #if TF_MBEDTLS_HASH_ALG_ID == TF_MBEDTLS_SHA256
diff --git a/include/drivers/clk.h b/include/drivers/clk.h
new file mode 100644
index 000000000..84950eb7f
--- /dev/null
+++ b/include/drivers/clk.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2020-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef CLK_H
+#define CLK_H
+
+#include <stdbool.h>
+
+struct clk_ops {
+	int (*enable)(unsigned long id);
+	void (*disable)(unsigned long id);
+	unsigned long (*get_rate)(unsigned long id);
+	int (*get_parent)(unsigned long id);
+	bool (*is_enabled)(unsigned long id);
+};
+
+int clk_enable(unsigned long id);
+void clk_disable(unsigned long id);
+unsigned long clk_get_rate(unsigned long id);
+bool clk_is_enabled(unsigned long id);
+int clk_get_parent(unsigned long id);
+
+void clk_register(const struct clk_ops *ops);
+
+#endif /* CLK_H */
diff --git a/include/drivers/fwu/fwu.h b/include/drivers/fwu/fwu.h
index ae06da98f..9f18e221c 100644
--- a/include/drivers/fwu/fwu.h
+++ b/include/drivers/fwu/fwu.h
@@ -11,5 +11,6 @@
 
 void fwu_init(void);
 bool fwu_is_trial_run_state(void);
+const struct fwu_metadata *fwu_get_metadata(void);
 
 #endif /* FWU_H */
diff --git a/include/drivers/io/io_storage.h b/include/drivers/io/io_storage.h
index f2d641c2d..8f30ed050 100644
--- a/include/drivers/io/io_storage.h
+++ b/include/drivers/io/io_storage.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2014-2020, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2014-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -24,7 +24,6 @@ typedef enum {
 	IO_TYPE_BLOCK,
 	IO_TYPE_MTD,
 	IO_TYPE_MMC,
-	IO_TYPE_STM32IMAGE,
 	IO_TYPE_ENCRYPTED,
 	IO_TYPE_MAX
 } io_type_t;
diff --git a/include/drivers/mmc.h b/include/drivers/mmc.h
index 834a80f4a..ccf8e6b65 100644
--- a/include/drivers/mmc.h
+++ b/include/drivers/mmc.h
@@ -110,6 +110,7 @@
 #define MMC_STATE_SLP			10
 
 #define MMC_FLAG_CMD23			(U(1) << 0)
+#define MMC_FLAG_SD_CMD6		(U(1) << 1)
 
 #define CMD8_CHECK_PATTERN		U(0xAA)
 #define VHS_2_7_3_6_V			BIT(8)
@@ -117,6 +118,9 @@
 #define SD_SCR_BUS_WIDTH_1		BIT(8)
 #define SD_SCR_BUS_WIDTH_4		BIT(10)
 
+#define SD_SWITCH_FUNC_CHECK		0U
+#define SD_SWITCH_FUNC_SWITCH		1U
+
 struct mmc_cmd {
 	unsigned int	cmd_idx;
 	unsigned int	cmd_arg;
@@ -216,6 +220,27 @@ struct mmc_csd_sd_v2 {
 	unsigned int		csd_structure:		2;
 };
 
+struct sd_switch_status {
+	unsigned short		max_current;
+	unsigned short		support_g6;
+	unsigned short		support_g5;
+	unsigned short		support_g4;
+	unsigned short		support_g3;
+	unsigned short		support_g2;
+	unsigned short		support_g1;
+	unsigned char		sel_g6_g5;
+	unsigned char		sel_g4_g3;
+	unsigned char		sel_g2_g1;
+	unsigned char		data_struct_ver;
+	unsigned short		busy_g6;
+	unsigned short		busy_g5;
+	unsigned short		busy_g4;
+	unsigned short		busy_g3;
+	unsigned short		busy_g2;
+	unsigned short		busy_g1;
+	unsigned short		reserved[17];
+};
+
 enum mmc_device_type {
 	MMC_IS_EMMC,
 	MMC_IS_SD,
diff --git a/include/drivers/nand.h b/include/drivers/nand.h
index 1b78ad41b..bb0cdde60 100644
--- a/include/drivers/nand.h
+++ b/include/drivers/nand.h
@@ -33,6 +33,8 @@ struct nand_device {
 			     uintptr_t buffer);
 };
 
+void plat_get_scratch_buffer(void **buffer_addr, size_t *buf_size);
+
 /*
  * Read bytes from NAND device
  *
diff --git a/include/drivers/partition/efi.h b/include/drivers/partition/efi.h
new file mode 100644
index 000000000..e463f9657
--- /dev/null
+++ b/include/drivers/partition/efi.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2021, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+#ifndef DRIVERS_PARTITION_EFI_H
+#define DRIVERS_PARTITION_EFI_H
+
+#include <string.h>
+
+#include <tools_share/uuid.h>
+
+#define EFI_NAMELEN		36
+
+static inline int guidcmp(const void *g1, const void *g2)
+{
+	return memcmp(g1, g2, sizeof(struct efi_guid));
+}
+
+static inline void *guidcpy(void *dst, const void *src)
+{
+	return memcpy(dst, src, sizeof(struct efi_guid));
+}
+
+#define EFI_GUID(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7) \
+	{ (a) & 0xffffffff,		\
+	  (b) & 0xffff,			\
+	  (c) & 0xffff,			\
+	  { (d0), (d1), (d2), (d3), (d4), (d5), (d6), (d7) } }
+
+#define NULL_GUID \
+	EFI_GUID(0x00000000, 0x0000, 0x0000, 0x00, 0x00, \
+		 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
+
+#endif /* DRIVERS_PARTITION_EFI_H */
diff --git a/include/drivers/partition/gpt.h b/include/drivers/partition/gpt.h
index d923e9535..c2a229e33 100644
--- a/include/drivers/partition/gpt.h
+++ b/include/drivers/partition/gpt.h
@@ -7,19 +7,20 @@
 #ifndef GPT_H
 #define GPT_H
 
+#include <drivers/partition/efi.h>
 #include <drivers/partition/partition.h>
+#include <tools_share/uuid.h>
 
 #define PARTITION_TYPE_GPT		0xee
 #define GPT_HEADER_OFFSET		PLAT_PARTITION_BLOCK_SIZE
 #define GPT_ENTRY_OFFSET		(GPT_HEADER_OFFSET +		\
 					 PLAT_PARTITION_BLOCK_SIZE)
-#define GUID_LEN			16
 
 #define GPT_SIGNATURE			"EFI PART"
 
 typedef struct gpt_entry {
-	unsigned char		type_uuid[GUID_LEN];
-	unsigned char		unique_uuid[GUID_LEN];
+	struct efi_guid		type_uuid;
+	struct efi_guid		unique_uuid;
 	unsigned long long	first_lba;
 	unsigned long long	last_lba;
 	unsigned long long	attr;
@@ -36,7 +37,7 @@ typedef struct gpt_header {
 	unsigned long long	backup_lba;
 	unsigned long long	first_lba;
 	unsigned long long	last_lba;
-	unsigned char		disk_uuid[16];
+	struct efi_guid		disk_uuid;
 	/* starting LBA of array of partition entries */
 	unsigned long long	part_lba;
 	/* number of partition entries in array */
diff --git a/include/drivers/partition/partition.h b/include/drivers/partition/partition.h
index 5f6483373..31432a3f4 100644
--- a/include/drivers/partition/partition.h
+++ b/include/drivers/partition/partition.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2018, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2016-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -10,6 +10,8 @@
 #include <stdint.h>
 
 #include <lib/cassert.h>
+#include <drivers/partition/efi.h>
+#include <tools_share/uuid.h>
 
 #if !PLAT_PARTITION_MAX_ENTRIES
 # define PLAT_PARTITION_MAX_ENTRIES	128
@@ -27,12 +29,12 @@ CASSERT((PLAT_PARTITION_BLOCK_SIZE == 512) ||
 
 #define LEGACY_PARTITION_BLOCK_SIZE	512
 
-#define EFI_NAMELEN			36
-
 typedef struct partition_entry {
 	uint64_t		start;
 	uint64_t		length;
 	char			name[EFI_NAMELEN];
+	struct efi_guid		part_guid;
+	struct efi_guid		type_guid;
 } partition_entry_t;
 
 typedef struct partition_entry_list {
@@ -42,6 +44,8 @@ typedef struct partition_entry_list {
 
 int load_partition_table(unsigned int image_id);
 const partition_entry_t *get_partition_entry(const char *name);
+const partition_entry_t *get_partition_entry_by_type(const uuid_t *type_guid);
+const partition_entry_t *get_partition_entry_by_uuid(const uuid_t *part_uuid);
 const partition_entry_list_t *get_partition_entry_list(void);
 void partition_init(unsigned int image_id);
 
diff --git a/include/drivers/regulator.h b/include/drivers/regulator.h
new file mode 100644
index 000000000..06249eff8
--- /dev/null
+++ b/include/drivers/regulator.h
@@ -0,0 +1,155 @@
+/*
+ * Copyright (c) 2017-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#ifndef REGULATOR_H
+#define REGULATOR_H
+
+#include <platform_def.h>
+
+#ifndef PLAT_NB_RDEVS
+#error "Missing PLAT_NB_RDEVS"
+#endif
+
+#ifndef PLAT_NB_SUSPEND_MODES
+#error "Missing PLAT_NB_SUSPEND_MODES"
+#endif
+
+const char *plat_get_lp_mode_name(int mode);
+
+/*
+ * Consumer interface
+ */
+
+/* regulator-always-on : regulator should never be disabled */
+#define REGUL_ALWAYS_ON		BIT(0)
+/*
+ * regulator-boot-on:
+ * It's expected that this regulator was left on by the bootloader.
+ * The core shouldn't prevent it from being turned off later.
+ * The regulator is needed to exit from suspend so it is turned on during suspend entry.
+ */
+#define REGUL_BOOT_ON		BIT(1)
+/* regulator-over-current-protection: Enable over current protection. */
+#define REGUL_OCP		BIT(2)
+/* regulator-active-discharge: enable active discharge. */
+#define REGUL_ACTIVE_DISCHARGE	BIT(3)
+/* regulator-pull-down: Enable pull down resistor when the regulator is disabled. */
+#define REGUL_PULL_DOWN		BIT(4)
+/*
+ * st,mask-reset: set mask reset for the regulator, meaning that the regulator
+ * setting is maintained during pmic reset.
+ */
+#define REGUL_MASK_RESET	BIT(5)
+/* st,regulator-sink-source: set the regulator in sink source mode */
+#define REGUL_SINK_SOURCE	BIT(6)
+/* st,regulator-bypass: set the regulator in bypass mode */
+#define REGUL_ENABLE_BYPASS	BIT(7)
+
+struct rdev *regulator_get_by_name(const char *node_name);
+struct rdev *regulator_get_by_supply_name(const void *fdt, int node, const char *name);
+
+int regulator_enable(struct rdev *rdev);
+int regulator_disable(struct rdev *rdev);
+int regulator_is_enabled(const struct rdev *rdev);
+
+int regulator_set_voltage(struct rdev *rdev, uint16_t volt);
+int regulator_set_min_voltage(struct rdev *rdev);
+int regulator_get_voltage(const struct rdev *rdev);
+
+int regulator_list_voltages(const struct rdev *rdev, const uint16_t **levels, size_t *count);
+void regulator_get_range(const struct rdev *rdev, uint16_t *min_mv, uint16_t *max_mv);
+int regulator_set_flag(struct rdev *rdev, uint16_t flag);
+
+/*
+ * Driver Interface
+ */
+
+/* set_state() arguments */
+#define STATE_DISABLE		false
+#define STATE_ENABLE		true
+
+/* suspend() arguments */
+#define LP_STATE_OFF		BIT(0)
+#define LP_STATE_ON		BIT(1)
+#define LP_STATE_UNCHANGED	BIT(2)
+#define LP_STATE_SET_VOLT	BIT(3)
+
+struct regul_description {
+	const char *node_name;
+	const struct regul_ops *ops;
+	const void *driver_data;
+	const char *supply_name;
+	const uint32_t enable_ramp_delay;
+};
+
+struct regul_ops {
+	int (*set_state)(const struct regul_description *desc, bool state);
+	int (*get_state)(const struct regul_description *desc);
+	int (*set_voltage)(const struct regul_description *desc, uint16_t mv);
+	int (*get_voltage)(const struct regul_description *desc);
+	int (*list_voltages)(const struct regul_description *desc,
+			     const uint16_t **levels, size_t *count);
+	int (*set_flag)(const struct regul_description *desc, uint16_t flag);
+	void (*lock)(const struct regul_description *desc);
+	void (*unlock)(const struct regul_description *desc);
+#if defined(IMAGE_BL32)
+	int (*suspend)(const struct regul_description *desc, uint8_t state,
+		       uint16_t mv);
+#endif
+};
+
+int regulator_register(const struct regul_description *desc, int node);
+
+/*
+ * Internal regulator structure
+ * The structure is internal to the core, and the content should not be used
+ * by a consumer nor a driver.
+ */
+struct rdev {
+	const struct regul_description *desc;
+
+	int32_t phandle;
+
+	uint16_t min_mv;
+	uint16_t max_mv;
+
+	uint16_t flags;
+
+	uint32_t enable_ramp_delay;
+#if defined(IMAGE_BL32)
+	const char *reg_name;
+
+	uint8_t use_count;
+
+	int32_t supply_phandle;
+	struct rdev *supply_dev;
+
+	uint8_t lp_state[PLAT_NB_SUSPEND_MODES];
+	uint16_t lp_mv[PLAT_NB_SUSPEND_MODES];
+#endif
+};
+
+#if defined(IMAGE_BL32)
+
+/* Boot and init */
+int regulator_core_config(void);
+int regulator_core_cleanup(void);
+
+/* Suspend resume operations */
+#define PLAT_BACKUP_REGULATOR_SIZE (sizeof(int8_t) * PLAT_NB_RDEVS)
+
+int regulator_core_suspend(int mode);
+int regulator_core_resume(void);
+
+void regulator_core_backup_context(void *backup_area, size_t backup_size);
+void regulator_core_restore_context(void *backup_area, size_t backup_size);
+
+#if LOG_LEVEL >= LOG_LEVEL_VERBOSE
+void regulator_core_dump(void);
+#endif
+
+#endif
+
+#endif /* REGULATOR_H */
diff --git a/include/drivers/spi_mem.h b/include/drivers/spi_mem.h
index d1953acf4..539b741b9 100644
--- a/include/drivers/spi_mem.h
+++ b/include/drivers/spi_mem.h
@@ -14,6 +14,7 @@
 #define SPI_MEM_BUSWIDTH_1_LINE		1U
 #define SPI_MEM_BUSWIDTH_2_LINE		2U
 #define SPI_MEM_BUSWIDTH_4_LINE		4U
+#define SPI_MEM_BUSWIDTH_8_LINE		8U
 
 /*
  * enum spi_mem_data_dir - Describes the direction of a SPI memory data
@@ -82,6 +83,8 @@ struct spi_mem_op {
 #define SPI_TX_QUAD	BIT(7)			/* transmit with 4 wires */
 #define SPI_RX_DUAL	BIT(8)			/* receive with 2 wires */
 #define SPI_RX_QUAD	BIT(9)			/* receive with 4 wires */
+#define SPI_TX_OCTAL	BIT(10)			/* transmit with 8 wires */
+#define SPI_RX_OCTAL	BIT(11)			/* receive with 8 wires */
 
 struct spi_bus_ops {
 	/*
@@ -121,9 +124,18 @@ struct spi_bus_ops {
 	 * Returns: 0 on success, a negative error code otherwise.
 	 */
 	int (*exec_op)(const struct spi_mem_op *op);
+
+	/*
+	 * Read data through a direct mapping.
+	 *
+	 * @op: The memory operation to execute.
+	 * Returns: 0 on success, a negative error code otherwise.
+	 */
+	int (*dirmap_read)(const struct spi_mem_op *op);
 };
 
 int spi_mem_exec_op(const struct spi_mem_op *op);
+int spi_mem_dirmap_read(const struct spi_mem_op *op);
 int spi_mem_init_slave(void *fdt, int bus_node,
 		       const struct spi_bus_ops *ops);
 
diff --git a/include/drivers/spi_nand.h b/include/drivers/spi_nand.h
index 40e206375..1eddbb6c0 100644
--- a/include/drivers/spi_nand.h
+++ b/include/drivers/spi_nand.h
@@ -29,9 +29,13 @@
 #define SPI_NAND_STATUS_BUSY		BIT(0)
 #define SPI_NAND_STATUS_ECC_UNCOR	BIT(5)
 
+/* Flags for specific configuration */
+#define SPI_NAND_HAS_QE_BIT		BIT(0)
+
 struct spinand_device {
 	struct nand_device *nand_dev;
 	struct spi_mem_op spi_read_cache_op;
+	uint32_t flags;
 	uint8_t cfg_cache; /* Cached value of SPI NAND device register CFG */
 };
 
diff --git a/include/drivers/spi_nor.h b/include/drivers/spi_nor.h
index 72cfe5b34..07dee5a9d 100644
--- a/include/drivers/spi_nor.h
+++ b/include/drivers/spi_nor.h
@@ -29,6 +29,12 @@
 #define SPI_NOR_OP_READ_1_2_2	0xBBU	/* Read data bytes (Dual I/O SPI) */
 #define SPI_NOR_OP_READ_1_1_4	0x6BU	/* Read data bytes (Quad Output SPI) */
 #define SPI_NOR_OP_READ_1_4_4	0xEBU	/* Read data bytes (Quad I/O SPI) */
+#define SPI_NOR_OP_READ_1_1_8	0x8BU	/* Read data bytes (Octal Output SPI) */
+#define SPI_NOR_OP_READ_1_8_8	0xCBU	/* Read data bytes (Octal I/O SPI) */
+
+/* 4-bytes address opcodes */
+#define SPI_NOR_OP_READ_4B	0x13U	/* Read data bytes (low frequency) */
+#define SPI_NOR_OP_READ_FAST_4B	0x0CU	/* Read data bytes (high frequency) */
 
 /* Flags for NOR specific configuration */
 #define SPI_NOR_USE_FSR		BIT(0)
diff --git a/include/drivers/st/bsec.h b/include/drivers/st/bsec.h
index d833e7ab2..b9f4a0b9a 100644
--- a/include/drivers/st/bsec.h
+++ b/include/drivers/st/bsec.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2019, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2015-2022, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -12,20 +12,6 @@
 
 #include <lib/utils_def.h>
 
-/*
- * IP configuration
- */
-#define BSEC_OTP_MASK			GENMASK(4, 0)
-#define BSEC_OTP_BANK_SHIFT		5
-#define BSEC_TIMEOUT_VALUE		0xFFFF
-
-#define ADDR_LOWER_OTP_PERLOCK_SHIFT	0x03
-#define DATA_LOWER_OTP_PERLOCK_BIT	0x03U /* 2 significants bits are used */
-#define DATA_LOWER_OTP_PERLOCK_MASK	GENMASK(2, 0)
-#define ADDR_UPPER_OTP_PERLOCK_SHIFT	0x04
-#define DATA_UPPER_OTP_PERLOCK_BIT	0x01U /* 1 significants bits are used */
-#define DATA_UPPER_OTP_PERLOCK_MASK	GENMASK(3, 0)
-
 /*
  * Return status
  */
@@ -35,171 +21,59 @@
 #define BSEC_INVALID_PARAM		0xFFFFFFFCU
 #define BSEC_PROG_FAIL			0xFFFFFFFBU
 #define BSEC_LOCK_FAIL			0xFFFFFFFAU
-#define BSEC_WRITE_FAIL			0xFFFFFFF9U
-#define BSEC_SHADOW_FAIL		0xFFFFFFF8U
-#define BSEC_TIMEOUT			0xFFFFFFF7U
-
-/*
- * BSEC REGISTER OFFSET (base relative)
- */
-#define BSEC_OTP_CONF_OFF		0x000U
-#define BSEC_OTP_CTRL_OFF		0x004U
-#define BSEC_OTP_WRDATA_OFF		0x008U
-#define BSEC_OTP_STATUS_OFF		0x00CU
-#define BSEC_OTP_LOCK_OFF		0x010U
-#define BSEC_DEN_OFF			0x014U
-#define BSEC_DISTURBED_OFF		0x01CU
-#define BSEC_DISTURBED1_OFF		0x020U
-#define BSEC_DISTURBED2_OFF		0x024U
-#define BSEC_ERROR_OFF			0x034U
-#define BSEC_ERROR1_OFF			0x038U
-#define BSEC_ERROR2_OFF			0x03CU
-#define BSEC_WRLOCK_OFF			0x04CU /* Safmem permanent lock */
-#define BSEC_WRLOCK1_OFF		0x050U
-#define BSEC_WRLOCK2_OFF		0x054U
-#define BSEC_SPLOCK_OFF			0x064U /* Program safmem sticky lock */
-#define BSEC_SPLOCK1_OFF		0x068U
-#define BSEC_SPLOCK2_OFF		0x06CU
-#define BSEC_SWLOCK_OFF			0x07CU /* Write in OTP sticky lock */
-#define BSEC_SWLOCK1_OFF		0x080U
-#define BSEC_SWLOCK2_OFF		0x084U
-#define BSEC_SRLOCK_OFF			0x094U /* Shadowing sticky lock */
-#define BSEC_SRLOCK1_OFF		0x098U
-#define BSEC_SRLOCK2_OFF		0x09CU
-#define BSEC_JTAG_IN_OFF		0x0ACU
-#define BSEC_JTAG_OUT_OFF		0x0B0U
-#define BSEC_SCRATCH_OFF		0x0B4U
-#define BSEC_OTP_DATA_OFF		0x200U
-#define BSEC_IPHW_CFG_OFF		0xFF0U
-#define BSEC_IPVR_OFF			0xFF4U
-#define BSEC_IP_ID_OFF			0xFF8U
-#define BSEC_IP_MAGIC_ID_OFF		0xFFCU
-
-/*
- * BSEC_CONFIGURATION Register
- */
-#define BSEC_CONF_POWER_UP_MASK		BIT(0)
-#define BSEC_CONF_POWER_UP_SHIFT	0
-#define BSEC_CONF_FRQ_MASK		GENMASK(2, 1)
-#define BSEC_CONF_FRQ_SHIFT		1
-#define BSEC_CONF_PRG_WIDTH_MASK	GENMASK(6, 3)
-#define BSEC_CONF_PRG_WIDTH_SHIFT	3
-#define BSEC_CONF_TREAD_MASK		GENMASK(8, 7)
-#define BSEC_CONF_TREAD_SHIFT		7
-
-/*
- * BSEC_CONTROL Register
- */
-#define BSEC_READ			0x000U
-#define BSEC_WRITE			0x100U
-#define BSEC_LOCK			0x200U
-
-/*
- * BSEC_OTP_LOCK register
- */
-#define UPPER_OTP_LOCK_MASK		BIT(0)
-#define UPPER_OTP_LOCK_SHIFT		0
-#define DENREG_LOCK_MASK		BIT(2)
-#define DENREG_LOCK_SHIFT		2
-#define GPLOCK_LOCK_MASK		BIT(4)
-#define GPLOCK_LOCK_SHIFT		4
+#define BSEC_TIMEOUT			0xFFFFFFF9U
+#define BSEC_RETRY			0xFFFFFFF8U
+#define BSEC_NOT_SUPPORTED		0xFFFFFFF7U
+#define BSEC_WRITE_LOCKED		0xFFFFFFF6U
 
 /*
- * BSEC_OTP_STATUS Register
+ * get BSEC global state: result for bsec_get_secure_state()
+ * @state: global state
+ *           [1:0] BSEC state
+ *             00b: Sec Open
+ *             01b: Sec Closed
+ *             11b: Invalid
+ *           [8]: Hardware Key set = 1b
  */
-#define BSEC_MODE_STATUS_MASK		GENMASK(2, 0)
-#define BSEC_MODE_BUSY_MASK		BIT(3)
-#define BSEC_MODE_PROGFAIL_MASK		BIT(4)
-#define BSEC_MODE_PWR_MASK		BIT(5)
-#define BSEC_MODE_BIST1_LOCK_MASK	BIT(6)
-#define BSEC_MODE_BIST2_LOCK_MASK	BIT(7)
+#define BSEC_STATE_SEC_OPEN		U(0x0)
+#define BSEC_STATE_SEC_CLOSED		U(0x1)
+#define BSEC_STATE_INVALID		U(0x3)
+#define BSEC_STATE_MASK			GENMASK_32(1, 0)
 
-/* OTP MODE*/
-#define BSEC_MODE_OPEN1			0x00
-#define BSEC_MODE_SECURED		0x01
-#define BSEC_MODE_OPEN2			0x02
-#define BSEC_MODE_INVALID		0x04
-
-/* BSEC_DENABLE Register */
-#define BSEC_HDPEN			BIT(4)
-#define BSEC_SPIDEN			BIT(5)
-#define BSEC_SPINDEN			BIT(6)
-#define BSEC_DBGSWGEN			BIT(10)
-#define BSEC_DEN_ALL_MSK		GENMASK(10, 0)
-
-/* BSEC_FENABLE Register */
-#define BSEC_FEN_ALL_MSK		GENMASK(14, 0)
-
-/*
- * OTP Lock services definition
- * Value must corresponding to the bit number in the register
- */
-#define BSEC_LOCK_UPPER_OTP		0x00
-#define BSEC_LOCK_DEBUG			0x02
-#define BSEC_LOCK_PROGRAM		0x03
-
-/* Values for struct bsec_config::freq */
-#define FREQ_10_20_MHZ			0x0
-#define FREQ_20_30_MHZ			0x1
-#define FREQ_30_45_MHZ			0x2
-#define FREQ_45_67_MHZ			0x3
-
-/*
- * Device info structure, providing device-specific functions and a means of
- * adding driver-specific state
- */
-struct bsec_config {
-	uint8_t tread;		/* SAFMEM Reading current level default 0 */
-	uint8_t pulse_width;	/* SAFMEM Programming pulse width default 1 */
-	uint8_t freq;		/* SAFMEM CLOCK see freq value define
-				 * default FREQ_45_67_MHZ
-				 */
-	uint8_t power;		/* Power up SAFMEM. 1 power up, 0 power off */
-	uint8_t prog_lock;	/* Programming Sticky lock
-				 * 1 programming is locked until next reset
-				 */
-	uint8_t den_lock;	/* Debug enable sticky lock
-				 * 1 debug enable is locked until next reset
-				 */
-	uint8_t upper_otp_lock;	/* Shadowing of upper OTP sticky lock
-				 * 1 shadowing of upper OTP is locked
-				 * until next reset
-				 */
-};
+#define BSEC_HARDWARE_KEY		BIT(8)
 
 uint32_t bsec_probe(void);
-uint32_t bsec_get_base(void);
-
-uint32_t bsec_set_config(struct bsec_config *cfg);
-uint32_t bsec_get_config(struct bsec_config *cfg);
+int bsec_get_otp_by_phandle(const void *fdt, const uint32_t phandle,
+			    uint32_t *otp_id, uint32_t *otp_len);
 
-uint32_t bsec_shadow_register(uint32_t otp);
 uint32_t bsec_read_otp(uint32_t *val, uint32_t otp);
+uint32_t bsec_shadow_read_otp(uint32_t *otp_value, uint32_t word);
 uint32_t bsec_write_otp(uint32_t val, uint32_t otp);
 uint32_t bsec_program_otp(uint32_t val, uint32_t otp);
-uint32_t bsec_permanent_lock_otp(uint32_t otp);
 
-uint32_t bsec_write_debug_conf(uint32_t val);
 uint32_t bsec_read_debug_conf(void);
-uint32_t bsec_write_feature_conf(uint32_t val);
-uint32_t bsec_read_feature_conf(uint32_t *val);
 
-uint32_t bsec_get_status(void);
-uint32_t bsec_get_hw_conf(void);
-uint32_t bsec_get_version(void);
-uint32_t bsec_get_id(void);
-uint32_t bsec_get_magic_id(void);
+void bsec_write_scratch(uint32_t val);
 
-bool bsec_write_sr_lock(uint32_t otp, uint32_t value);
-bool bsec_read_sr_lock(uint32_t otp);
-bool bsec_write_sw_lock(uint32_t otp, uint32_t value);
-bool bsec_read_sw_lock(uint32_t otp);
-bool bsec_write_sp_lock(uint32_t otp, uint32_t value);
-bool bsec_read_sp_lock(uint32_t otp);
-bool bsec_wr_lock(uint32_t otp);
-uint32_t bsec_otp_lock(uint32_t service, uint32_t value);
+/* Sticky lock support */
+uint32_t bsec_set_sr_lock(uint32_t otp);
+uint32_t bsec_read_sr_lock(uint32_t otp, bool *value);
+uint32_t bsec_set_sw_lock(uint32_t otp);
+uint32_t bsec_read_sw_lock(uint32_t otp, bool *value);
+uint32_t bsec_set_sp_lock(uint32_t otp);
+uint32_t bsec_read_sp_lock(uint32_t otp, bool *value);
 
-uint32_t bsec_shadow_read_otp(uint32_t *otp_value, uint32_t word);
+uint32_t bsec_get_secure_state(void);
+static inline bool bsec_mode_is_closed_device(void)
+{
+	return (bsec_get_secure_state() & BSEC_STATE_MASK) == BSEC_STATE_SEC_CLOSED;
+}
+
+#if defined(IMAGE_BL32) || defined(STM32MP_SSP)
+uint32_t bsec_permanent_lock_otp(uint32_t otp);
+#endif
+#if defined(IMAGE_BL32)
 uint32_t bsec_check_nsec_access_rights(uint32_t otp);
+#endif
 
 #endif /* BSEC_H */
diff --git a/include/drivers/st/bsec2_reg.h b/include/drivers/st/bsec2_reg.h
new file mode 100644
index 000000000..5b8883eab
--- /dev/null
+++ b/include/drivers/st/bsec2_reg.h
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef BSEC2_REG_H
+#define BSEC2_REG_H
+
+#include <lib/utils_def.h>
+
+/* IP configuration */
+#define ADDR_LOWER_OTP_PERLOCK_SHIFT	0x03
+#define DATA_LOWER_OTP_PERLOCK_BIT	0x03U /* 2 significants bits are used */
+#define DATA_LOWER_OTP_PERLOCK_MASK	GENMASK(2, 0)
+#define ADDR_UPPER_OTP_PERLOCK_SHIFT	0x04
+#define DATA_UPPER_OTP_PERLOCK_BIT	0x01U /* 1 significants bits are used */
+#define DATA_UPPER_OTP_PERLOCK_MASK	GENMASK(3, 0)
+
+/* BSEC REGISTER OFFSET (base relative) */
+#define BSEC_OTP_CONF_OFF		U(0x000)
+#define BSEC_OTP_CTRL_OFF		U(0x004)
+#define BSEC_OTP_WRDATA_OFF		U(0x008)
+#define BSEC_OTP_STATUS_OFF		U(0x00C)
+#define BSEC_OTP_LOCK_OFF		U(0x010)
+#define BSEC_DEN_OFF			U(0x014)
+#define BSEC_DISTURBED_OFF		U(0x01C)
+#define BSEC_DISTURBED1_OFF		U(0x020)
+#define BSEC_DISTURBED2_OFF		U(0x024)
+#define BSEC_ERROR_OFF			U(0x034)
+#define BSEC_ERROR1_OFF			U(0x038)
+#define BSEC_ERROR2_OFF			U(0x03C)
+#define BSEC_WRLOCK_OFF			U(0x04C) /* Safmem permanent lock */
+#define BSEC_WRLOCK1_OFF		U(0x050)
+#define BSEC_WRLOCK2_OFF		U(0x054)
+#define BSEC_SPLOCK_OFF			U(0x064) /* Program safmem sticky lock */
+#define BSEC_SPLOCK1_OFF		U(0x068)
+#define BSEC_SPLOCK2_OFF		U(0x06C)
+#define BSEC_SWLOCK_OFF			U(0x07C) /* Write in OTP sticky lock */
+#define BSEC_SWLOCK1_OFF		U(0x080)
+#define BSEC_SWLOCK2_OFF		U(0x084)
+#define BSEC_SRLOCK_OFF			U(0x094) /* Shadowing sticky lock */
+#define BSEC_SRLOCK1_OFF		U(0x098)
+#define BSEC_SRLOCK2_OFF		U(0x09C)
+#define BSEC_JTAG_IN_OFF		U(0x0AC)
+#define BSEC_JTAG_OUT_OFF		U(0x0B0)
+#define BSEC_SCRATCH_OFF		U(0x0B4)
+#define BSEC_OTP_DATA_OFF		U(0x200)
+#define BSEC_IPHW_CFG_OFF		U(0xFF0)
+#define BSEC_IPVR_OFF			U(0xFF4)
+#define BSEC_IP_ID_OFF			U(0xFF8)
+#define BSEC_IP_MAGIC_ID_OFF		U(0xFFC)
+
+#define BSEC_WRLOCK(n)			(BSEC_WRLOCK_OFF + U(0x04) * (n))
+#define BSEC_SPLOCK(n)			(BSEC_SPLOCK_OFF + U(0x04) * (n))
+#define BSEC_SWLOCK(n)			(BSEC_SWLOCK_OFF + U(0x04) * (n))
+#define BSEC_SRLOCK(n)			(BSEC_SRLOCK_OFF + U(0x04) * (n))
+
+/* BSEC_CONFIGURATION Register */
+#define BSEC_CONF_POWER_UP_MASK		BIT(0)
+#define BSEC_CONF_POWER_UP_SHIFT	0
+#define BSEC_CONF_FRQ_MASK		GENMASK(2, 1)
+#define BSEC_CONF_FRQ_SHIFT		1
+#define BSEC_CONF_PRG_WIDTH_MASK	GENMASK(6, 3)
+#define BSEC_CONF_PRG_WIDTH_SHIFT	3
+#define BSEC_CONF_TREAD_MASK		GENMASK(8, 7)
+#define BSEC_CONF_TREAD_SHIFT		7
+
+/* BSEC_CONTROL Register */
+#define BSEC_READ			0
+#define BSEC_WRITE			BIT(8)
+#define BSEC_LOCK			BIT(9)
+
+/* BSEC_OTP_LOCK register */
+#define UPPER_OTP_LOCK_MASK		BIT(0)
+#define UPPER_OTP_LOCK_SHIFT		0
+#define DENREG_LOCK_MASK		BIT(2)
+#define DENREG_LOCK_SHIFT		2
+#define GPLOCK_LOCK_MASK		BIT(4)
+#define GPLOCK_LOCK_SHIFT		4
+
+/* BSEC_OTP_STATUS Register */
+#define BSEC_OTP_STATUS_SECURE		BIT(0)
+#define BSEC_OTP_STATUS_INVALID		BIT(2)
+#define BSEC_OTP_STATUS_BUSY		BIT(3)
+#define BSEC_OTP_STATUS_PROGFAIL	BIT(4)
+#define BSEC_OTP_STATUS_PWRON		BIT(5)
+
+/* BSEC_DENABLE Register */
+#define BSEC_HDPEN			BIT(4)
+#define BSEC_SPIDEN			BIT(5)
+#define BSEC_SPINDEN			BIT(6)
+#define BSEC_DBGSWGEN			BIT(10)
+#define BSEC_DEN_ALL_MSK		GENMASK(10, 0)
+
+/* BSEC_FENABLE Register */
+#define BSEC_FEN_ALL_MSK		GENMASK(14, 0)
+
+/* BSEC_IPVR Register */
+#define BSEC_IPVR_MSK			GENMASK(7, 0)
+
+#endif /* BSEC2_REG_H */
diff --git a/include/drivers/st/bsec3_reg.h b/include/drivers/st/bsec3_reg.h
new file mode 100644
index 000000000..5e92be3a6
--- /dev/null
+++ b/include/drivers/st/bsec3_reg.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef BSEC3_REG_H
+#define BSEC3_REG_H
+
+#include <lib/utils_def.h>
+
+/* BSEC REGISTER OFFSET (base relative) */
+#define BSEC_FVR(x)			(U(0x000) + 4U * (x))
+#define BSEC_SPLOCK(x)			(U(0x800) + 4U * (x))
+#define BSEC_SWLOCK(x)			(U(0x840) + 4U * (x))
+#define BSEC_SRLOCK(x)			(U(0x880) + 4U * (x))
+#define BSEC_OTPVLDR(x)			(U(0x8C0) + 4U * (x))
+#define BSEC_SFSR(x)			(U(0x940) + 4U * (x))
+#define BSEC_OTPCR			U(0xC04)
+#define BSEC_WDR			U(0xC08)
+#define BSEC_SCRATCHR0			U(0xE00)
+#define BSEC_SCRATCHR1			U(0xE04)
+#define BSEC_SCRATCHR2			U(0xE08)
+#define BSEC_SCRATCHR3			U(0xE0C)
+#define BSEC_LOCKR			U(0xE10)
+#define BSEC_JTAGINR			U(0xE14)
+#define BSEC_JTAGOUTR			U(0xE18)
+#define BSEC_DENR			U(0xE20)
+#define BSEC_UNMAPR			U(0xE24)
+#define BSEC_SR				U(0xE40)
+#define BSEC_OTPSR			U(0xE44)
+#define BSEC_WRCR			U(0xF00)
+#define BSEC_HWCFGR			U(0xFF0)
+#define BSEC_VERR			U(0xFF4)
+#define BSEC_IPIDR			U(0xFF8)
+#define BSEC_SIDR			U(0xFFC)
+
+/* BSEC_OTPCR register fields */
+#define BSEC_OTPCR_ADDR_MASK		GENMASK(8, 0)
+#define BSEC_OTPCR_ADDR_SHIFT		0
+#define BSEC_OTPCR_PROG			BIT(13)
+#define BSEC_OTPCR_PPLOCK		BIT(14)
+#define BSEC_OTPCR_LASTCID_MASK		GENMASK(21, 19)
+#define BSEC_OTPCR_LASTCID_SHIFT	19
+
+/* BSEC_LOCKR register fields */
+#define BSEC_LOCKR_GWLOCK_MASK		BIT(0)
+#define BSEC_LOCKR_GWLOCK_SHIFT		0
+#define BSEC_LOCKR_DENLOCK_MASK		BIT(1)
+#define BSEC_LOCKR_DENLOCK_SHIFT	1
+#define BSEC_LOCKR_HKLOCK_MASK		BIT(2)
+#define BSEC_LOCKR_HKLOCK_SHIFT		2
+
+/* BSEC_DENR register fields */
+#define BSEC_DENR_LPDBGEN		BIT(0)
+#define BSEC_DENR_DBGENA		BIT(1)
+#define BSEC_DENR_NIDENA		BIT(2)
+#define BSEC_DENR_DEVICEEN		BIT(3)
+#define BSEC_DENR_HDPEN			BIT(4)
+#define BSEC_DENR_SPIDENA		BIT(5)
+#define BSEC_DENR_SPNIDENA		BIT(6)
+#define BSEC_DENR_DBGSWEN		BIT(7)
+#define BSEC_DENR_DBGENM		BIT(8)
+#define BSEC_DENR_NIDENM		BIT(9)
+#define BSEC_DENR_SPIDENM		BIT(10)
+#define BSEC_DENR_SPNIDENM		BIT(11)
+#define BSEC_DENR_CFGSDIS		BIT(12)
+#define BSEC_DENR_CP15SDIS_MASK		GENMASK(14, 13)
+#define BSEC_DENR_CP15SDIS_SHIFT	13
+#define BSEC_DENR_LPDBGDIS		BIT(15)
+#define BSEC_DENR_ALL_MSK		GENMASK(15, 0)
+
+/* BSEC_SR register fields */
+#define BSEC_SR_BUSY			BIT(0)
+#define BSEC_SR_HVALID			BIT(1)
+#define BSEC_SR_RNGERR			BIT(2)
+#define BSEC_SR_HKWW_MASK		GENMASK(15, 8)
+#define BSEC_SR_HKWW_SHIFT		8
+#define BSEC_SR_NVSTATE_MASK		GENMASK(31, 26)
+#define BSEC_SR_NVSTATE_SHIFT		26
+#define BSEC_SR_NVSTATE_OPEN		U(0x16)
+#define BSEC_SR_NVSTATE_CLOSED		U(0x0D)
+#define BSEC_SR_NVSTATE_OTP_LOCKED	U(0x23)
+
+/* BSEC_OTPSR register fields */
+#define BSEC_OTPSR_BUSY			BIT(0)
+#define BSEC_OTPSR_FUSEOK		BIT(1)
+#define BSEC_OTPSR_HIDEUP		BIT(2)
+#define BSEC_OTPSR_OTPNVIR		BIT(4)
+#define BSEC_OTPSR_OTPERR		BIT(5)
+#define BSEC_OTPSR_OTPSEC		BIT(6)
+#define BSEC_OTPSR_PROGFAIL		BIT(16)
+#define BSEC_OTPSR_DISTURBF		BIT(17)
+#define BSEC_OTPSR_DEDF			BIT(18)
+#define BSEC_OTPSR_SECF			BIT(19)
+#define BSEC_OTPSR_PPLF			BIT(20)
+#define BSEC_OTPSR_PPLMF		BIT(21)
+#define BSEC_OTPSR_AMEF			BIT(22)
+
+/* BSEC_VERR register fields */
+#define BSEC_VERR_MASK			GENMASK(7, 0)
+
+#endif /* BSEC3_REG_H */
diff --git a/include/drivers/st/io_stm32image.h b/include/drivers/st/io_stm32image.h
deleted file mode 100644
index f9fa3630c..000000000
--- a/include/drivers/st/io_stm32image.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (c) 2018, ARM Limited and Contributors. All rights reserved.
- *
- * SPDX-License-Identifier: BSD-3-Clause
- */
-
-#ifndef IO_STM32IMAGE_H
-#define IO_STM32IMAGE_H
-
-#include <drivers/io/io_driver.h>
-#include <drivers/partition/partition.h>
-
-#define MAX_LBA_SIZE		512
-#define MAX_PART_NAME_SIZE	(EFI_NAMELEN + 1)
-#define STM32_PART_NUM		(PLAT_PARTITION_MAX_ENTRIES - STM32_TF_A_COPIES)
-
-struct stm32image_part_info {
-	char name[MAX_PART_NAME_SIZE];
-	uint32_t binary_type;
-	uintptr_t part_offset;
-	uint32_t bkp_offset;
-};
-
-struct stm32image_device_info {
-	struct stm32image_part_info part_info[STM32_PART_NUM];
-	unsigned long long device_size;
-	uint32_t lba_size;
-};
-
-int register_io_dev_stm32image(const io_dev_connector_t **dev_con);
-
-#endif /* IO_STM32IMAGE_H */
diff --git a/include/drivers/st/regulator_fixed.h b/include/drivers/st/regulator_fixed.h
new file mode 100644
index 000000000..b03c6e38c
--- /dev/null
+++ b/include/drivers/st/regulator_fixed.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright (c) 2020-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef REGULATOR_FIXED_H
+#define REGULATOR_FIXED_H
+
+int fixed_regulator_register(void);
+
+#endif /* REGULATOR_FIXED_H */
diff --git a/include/drivers/st/regulator_gpio.h b/include/drivers/st/regulator_gpio.h
new file mode 100644
index 000000000..3362f7e24
--- /dev/null
+++ b/include/drivers/st/regulator_gpio.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef REGULATOR_GPIO_H
+#define REGULATOR_GPIO_H
+
+int gpio_regulator_register(void);
+
+#endif /* REGULATOR_GPIO_H */
diff --git a/include/drivers/st/stm32_gpio.h b/include/drivers/st/stm32_gpio.h
index e241f584f..4ed1e3947 100644
--- a/include/drivers/st/stm32_gpio.h
+++ b/include/drivers/st/stm32_gpio.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2019, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2015-2021, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -13,6 +13,8 @@
 #define GPIO_TYPE_OFFSET	U(0x04)
 #define GPIO_SPEED_OFFSET	U(0x08)
 #define GPIO_PUPD_OFFSET	U(0x0C)
+#define GPIO_IDR_OFFSET		U(0x10)
+#define GPIO_OD_OFFSET		U(0x14)
 #define GPIO_BSRR_OFFSET	U(0x18)
 #define GPIO_AFRL_OFFSET	U(0x20)
 #define GPIO_AFRH_OFFSET	U(0x24)
@@ -32,7 +34,9 @@
 #define GPIO_MODE_ANALOG	0x03
 #define GPIO_MODE_MASK		U(0x03)
 
-#define GPIO_OPEN_DRAIN		U(0x10)
+#define GPIO_TYPE_PUSH_PULL	0x00
+#define GPIO_TYPE_OPEN_DRAIN	0x01
+#define GPIO_TYPE_MASK		U(0x01)
 
 #define GPIO_SPEED_LOW		0x00
 #define GPIO_SPEED_MEDIUM	0x01
@@ -45,13 +49,23 @@
 #define GPIO_PULL_DOWN		0x02
 #define GPIO_PULL_MASK		U(0x03)
 
+#define GPIO_OD_MASK		U(0x01)
+
 #ifndef __ASSEMBLER__
 #include <stdint.h>
-
 int dt_set_pinctrl_config(int node);
-void set_gpio(uint32_t bank, uint32_t pin, uint32_t mode, uint32_t speed,
-	      uint32_t pull, uint32_t alternate, uint8_t status);
 void set_gpio_secure_cfg(uint32_t bank, uint32_t pin, bool secure);
+void set_gpio_reset_cfg(uint32_t bank, uint32_t pin);
+
+enum gpio_level {
+	GPIO_LEVEL_LOW,
+	GPIO_LEVEL_HIGH
+};
+
+void set_gpio_level(uint32_t bank, uint32_t pin, enum gpio_level level);
+enum gpio_level get_gpio_level(uint32_t bank, uint32_t pin);
+
+void set_gpio_config(uint32_t bank, uint32_t pin, uint32_t config, uint8_t status);
 #endif /*__ASSEMBLER__*/
 
 #endif /* STM32_GPIO_H */
diff --git a/include/drivers/st/stm32_hash.h b/include/drivers/st/stm32_hash.h
index df04730d6..4614b87a6 100644
--- a/include/drivers/st/stm32_hash.h
+++ b/include/drivers/st/stm32_hash.h
@@ -8,10 +8,16 @@
 #define STM32_HASH_H
 
 enum stm32_hash_algo_mode {
+#if STM32MP15
 	HASH_MD5SUM,
+#endif
 	HASH_SHA1,
 	HASH_SHA224,
-	HASH_SHA256
+	HASH_SHA256,
+#if STM32MP13
+	HASH_SHA384,
+	HASH_SHA512,
+#endif
 };
 
 int stm32_hash_update(const uint8_t *buffer, size_t length);
diff --git a/include/drivers/st/stm32_i2c.h b/include/drivers/st/stm32_i2c.h
index 170d4cf81..4844a8f44 100644
--- a/include/drivers/st/stm32_i2c.h
+++ b/include/drivers/st/stm32_i2c.h
@@ -1,7 +1,7 @@
 /*
  * Copyright (c) 2016-2019, STMicroelectronics - All Rights Reserved
  *
- * SPDX-License-Identifier: BSD-3-Clause
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
  */
 
 #ifndef STM32_I2C_H
@@ -73,6 +73,21 @@
 #define I2C_TIMINGR_SDADEL		GENMASK(19, 16)
 #define I2C_TIMINGR_SCLDEL		GENMASK(23, 20)
 #define I2C_TIMINGR_PRESC		GENMASK(31, 28)
+#define I2C_TIMINGR_SCLL_MAX		(I2C_TIMINGR_SCLL + 1)
+#define I2C_TIMINGR_SCLH_MAX		((I2C_TIMINGR_SCLH >> 8) + 1)
+#define I2C_TIMINGR_SDADEL_MAX		((I2C_TIMINGR_SDADEL >> 16) + 1)
+#define I2C_TIMINGR_SCLDEL_MAX		((I2C_TIMINGR_SCLDEL >> 20) + 1)
+#define I2C_TIMINGR_PRESC_MAX		((I2C_TIMINGR_PRESC >> 28) + 1)
+#define I2C_SET_TIMINGR_SCLL(n)		((n) & \
+					 (I2C_TIMINGR_SCLL_MAX - 1))
+#define I2C_SET_TIMINGR_SCLH(n)		(((n) & \
+					  (I2C_TIMINGR_SCLH_MAX - 1)) << 8)
+#define I2C_SET_TIMINGR_SDADEL(n)	(((n) & \
+					  (I2C_TIMINGR_SDADEL_MAX - 1)) << 16)
+#define I2C_SET_TIMINGR_SCLDEL(n)	(((n) & \
+					  (I2C_TIMINGR_SCLDEL_MAX - 1)) << 20)
+#define I2C_SET_TIMINGR_PRESC(n)	(((n) & \
+					  (I2C_TIMINGR_PRESC_MAX - 1)) << 28)
 
 /* Bit definition for I2C_TIMEOUTR register */
 #define I2C_TIMEOUTR_TIMEOUTA		GENMASK(11, 0)
@@ -111,15 +126,9 @@
 #define I2C_ICR_TIMOUTCF		BIT(12)
 #define I2C_ICR_ALERTCF			BIT(13)
 
-enum i2c_speed_e {
-	I2C_SPEED_STANDARD,	/* 100 kHz */
-	I2C_SPEED_FAST,		/* 400 kHz */
-	I2C_SPEED_FAST_PLUS,	/* 1 MHz   */
-};
-
-#define STANDARD_RATE				100000
-#define FAST_RATE				400000
-#define FAST_PLUS_RATE				1000000
+#define STANDARD_RATE			100000
+#define FAST_RATE			400000
+#define FAST_PLUS_RATE			1000000
 
 struct stm32_i2c_init_s {
 	uint32_t own_address1;		/*
@@ -181,12 +190,7 @@ struct stm32_i2c_init_s {
 					 * time in nanoseconds.
 					 */
 
-	enum i2c_speed_e speed_mode;	/*
-					 * Specifies the I2C clock source
-					 * frequency mode.
-					 * This parameter can be a value of @ref
-					 * i2c_speed_mode_e.
-					 */
+	uint32_t bus_rate;		/* Specifies the I2C clock frequency */
 
 	int analog_filter;		/*
 					 * Specifies if the I2C analog noise
@@ -238,6 +242,8 @@ struct i2c_handle_s {
 	enum i2c_state_e i2c_state;		/* Communication state    */
 	enum i2c_mode_e i2c_mode;		/* Communication mode     */
 	uint32_t i2c_err;			/* Error code             */
+	uint32_t saved_timing;			/* Saved timing value     */
+	uint32_t saved_frequency;		/* Saved frequency value  */
 };
 
 #define I2C_ADDRESSINGMODE_7BIT		0x00000001U
diff --git a/include/drivers/st/stm32_iwdg.h b/include/drivers/st/stm32_iwdg.h
index bad25244a..c0c009779 100644
--- a/include/drivers/st/stm32_iwdg.h
+++ b/include/drivers/st/stm32_iwdg.h
@@ -15,5 +15,6 @@
 
 int stm32_iwdg_init(void);
 void stm32_iwdg_refresh(void);
+void __dead2 stm32_iwdg_it_handler(int id);
 
 #endif /* STM32_IWDG_H */
diff --git a/include/drivers/st/stm32_mce.h b/include/drivers/st/stm32_mce.h
new file mode 100644
index 000000000..81c4d20d7
--- /dev/null
+++ b/include/drivers/st/stm32_mce.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2020-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32_MCE_H
+#define STM32_MCE_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include <dt-bindings/soc/stm32mp13-mce.h>
+
+/* MCE encryption modes */
+#define MCE_BYPASS_MODE			MCE_PLAINTEXT
+#define MCE_ENCRYPT_MODE		MCE_ENCRYPT
+#define MCE_ENCRYPTION_MODE_MAX		MCE_ENCRYPT_MODE
+
+/* IP configuration */
+#define MCE_IP_MAX_REGION_NB		1U
+
+struct stm32_mce_region_s {
+	uint32_t encrypt_mode;	/*
+				 * Specifies the region encryption mode.
+				 * This parameter can be a value of
+				 * @ref MCE_*_MODE (in driver header file).
+				 */
+	uint32_t start_address;	/* Specifies the region start address */
+	uint32_t end_address;	/* Specifies the region end address */
+};
+
+void stm32_mce_init(void);
+
+int stm32_mce_write_master_key(uint8_t *mkey);
+void stm32_mce_lock_master_key(void);
+bool stm32_mce_is_master_key_locked(void);
+
+void stm32_mce_lock_global(void);
+bool stm32_mce_is_globally_locked(void);
+bool stm32_mce_is_hw_encryption_functional(void);
+
+int stm32_mce_get_address_encryption_state(uint32_t address, uint32_t *state);
+
+void stm32_mce_reload_configuration(void);
+#endif /* STM32_MCE_H */
diff --git a/include/drivers/st/stm32_ospi.h b/include/drivers/st/stm32_ospi.h
new file mode 100644
index 000000000..932ebd46f
--- /dev/null
+++ b/include/drivers/st/stm32_ospi.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ */
+
+#ifndef STM32_OSPI_H
+#define STM32_OSPI_H
+
+int stm32_ospi_init(void);
+
+#endif /* STM32_OSPI_H */
diff --git a/include/drivers/st/stm32_pka.h b/include/drivers/st/stm32_pka.h
new file mode 100644
index 000000000..8958d1f7d
--- /dev/null
+++ b/include/drivers/st/stm32_pka.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32_PKA_H
+#define STM32_PKA_H
+
+#include <stdint.h>
+
+#if !PKA_USE_NIST_P256 && !PKA_USE_BRAINPOOL_P256R1 && !PKA_USE_BRAINPOOL_P256T1 && \
+	!PKA_USE_NIST_P521
+#error "At least one ECDSA curve needs to be selected"
+#endif
+
+enum stm32_pka_ecdsa_curve_id {
+#if PKA_USE_NIST_P256
+	PKA_NIST_P256,
+#endif
+#if PKA_USE_BRAINPOOL_P256R1
+	PKA_BRAINPOOL_P256R1,
+#endif
+#if PKA_USE_BRAINPOOL_P256T1
+	PKA_BRAINPOOL_P256T1,
+#endif
+#if PKA_USE_NIST_P521
+	PKA_NIST_P521,
+#endif
+};
+
+struct stm32_pka_platdata {
+	uintptr_t base;
+	unsigned long clock_id;
+	unsigned int reset_id;
+};
+
+int stm32_pka_init(void);
+int stm32_pka_ecdsa_verif(void *hash, unsigned int hash_size,
+			  void *sig_r_ptr, unsigned int sig_r_size,
+			  void *sig_s_ptr, unsigned int sig_s_size,
+			  void *pk_x_ptr, unsigned int pk_x_size,
+			  void *pk_y_ptr, unsigned int pk_y_size,
+			  enum stm32_pka_ecdsa_curve_id cid);
+
+#endif /* STM32_PKA_H */
diff --git a/include/drivers/st/stm32_rng.h b/include/drivers/st/stm32_rng.h
new file mode 100644
index 000000000..ea228433f
--- /dev/null
+++ b/include/drivers/st/stm32_rng.h
@@ -0,0 +1,13 @@
+/*
+ * Copyright (c) 2018-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32_RNG_H
+#define STM32_RNG_H
+
+int stm32_rng_read(uint8_t *out, uint32_t size);
+int stm32_rng_init(void);
+
+#endif /* STM32_RNG_H */
diff --git a/include/drivers/st/stm32_rtc.h b/include/drivers/st/stm32_rtc.h
new file mode 100644
index 000000000..128dd2d14
--- /dev/null
+++ b/include/drivers/st/stm32_rtc.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2017-2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32_RTC_H
+#define STM32_RTC_H
+
+#include <stdbool.h>
+
+#define RTC_TR		0x00U
+#define RTC_DR		0x04U
+#define RTC_SSR		0x08U
+#define RTC_ICSR	0x0CU
+#define RTC_PRER	0x10U
+#define RTC_WUTR	0x14U
+#define RTC_CR		0x18U
+#define RTC_SMCR	0x20U
+#define RTC_WPR		0x24U
+#define RTC_CALR	0x28U
+#define RTC_SHIFTR	0x2CU
+#define RTC_TSTR	0x30U
+#define RTC_TSDR	0x34U
+#define RTC_TSSSR	0x38U
+#define RTC_ALRMAR	0x40U
+#define RTC_ALRMASSR	0x44U
+#define RTC_ALRMBR	0x48U
+#define RTC_ALRMBSSR	0x4CU
+#define RTC_SR		0x50U
+#define RTC_SCR		0x5CU
+#define RTC_OR		0x60U
+
+struct stm32_rtc_calendar {
+	uint32_t ssr;
+	uint32_t tr;
+	uint32_t dr;
+};
+
+enum months {
+	JANUARY = 1,
+	FEBRUARY,
+	MARCH,
+	APRIL,
+	MAY,
+	JUNE,
+	JULY,
+	AUGUST,
+	SEPTEMBER,
+	OCTOBER,
+	NOVEMBER,
+	DECEMBER,
+	NB_MONTHS = 12
+};
+
+struct stm32_rtc_time {
+	uint32_t hour;
+	uint32_t min;
+	uint32_t sec;
+	uint32_t wday;
+	uint32_t day;
+	enum months month;
+	uint32_t year;
+};
+
+void stm32_rtc_get_calendar(struct stm32_rtc_calendar *calendar);
+unsigned long long stm32_rtc_diff_calendar(struct stm32_rtc_calendar *current,
+					   struct stm32_rtc_calendar *ref);
+void stm32_rtc_set_tamper_timestamp(void);
+bool stm32_rtc_is_timestamp_enable(void);
+void stm32_rtc_get_timestamp(struct stm32_rtc_time *tamp_ts);
+int stm32_rtc_init(void);
+
+/* SMP protection on RTC registers access */
+void stm32_rtc_regs_lock(void);
+void stm32_rtc_regs_unlock(void);
+
+#endif /* STM32_RTC_H */
diff --git a/include/drivers/st/stm32_saes.h b/include/drivers/st/stm32_saes.h
new file mode 100644
index 000000000..17d24e6c2
--- /dev/null
+++ b/include/drivers/st/stm32_saes.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32_SAES_H
+#define STM32_SAES_H
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+
+#define DT_SAES_COMPAT		"st,stm32-saes"
+
+struct stm32_saes_platdata {
+	uintptr_t base;
+	unsigned long clock_id;
+	unsigned int reset_id;
+};
+
+enum stm32_saes_chaining_mode {
+	STM32_SAES_MODE_ECB,
+	STM32_SAES_MODE_CBC,
+	STM32_SAES_MODE_CTR,
+	STM32_SAES_MODE_GCM,
+	STM32_SAES_MODE_CCM, /* Not use in TF-A */
+};
+
+enum stm32_saes_key_selection {
+	STM32_SAES_KEY_SOFT,
+	STM32_SAES_KEY_DHU,           /* Derived HW unique key */
+	STM32_SAES_KEY_BH,            /* Boot HW key */
+	STM32_SAES_KEY_BHU_XOR_BH,    /* XOR of DHUK and BHK */
+	STM32_SAES_KEY_WRAPPED
+};
+
+struct stm32_saes_context {
+	uintptr_t base;
+	uint32_t cr;
+	uint32_t assoc_len;
+	uint32_t load_len;
+	uint32_t key[8]; /* In HW byte order */
+	uint32_t iv[4];  /* In HW byte order */
+};
+
+int stm32_saes_driver_init(void);
+
+int stm32_saes_init(struct stm32_saes_context *ctx, bool is_decrypt,
+		    enum stm32_saes_chaining_mode ch_mode, enum stm32_saes_key_selection key_select,
+		    const void *key, size_t key_len, const void *iv, size_t iv_len);
+int stm32_saes_update(struct stm32_saes_context *ctx, bool last_block,
+		      uint8_t *data_in, uint8_t *data_out, size_t data_len);
+int stm32_saes_update_assodata(struct stm32_saes_context *ctx, bool last_block,
+			       uint8_t *data, size_t data_len);
+int stm32_saes_update_load(struct stm32_saes_context *ctx, bool last_block,
+			   uint8_t *data_in, uint8_t *data_out, size_t data_len);
+int stm32_saes_final(struct stm32_saes_context *ctx, uint8_t *tag, size_t tag_len);
+
+int stm32_saes_wrap_key(enum stm32_saes_chaining_mode ch_mode,
+			enum stm32_saes_key_selection key_select, const void *key, size_t key_size,
+			const void *iv, size_t iv_size, const void *in_key, const void *out_data);
+int stm32_saes_unwrap_key(enum stm32_saes_chaining_mode ch_mode,
+			  enum stm32_saes_key_selection key_select, const void *key,
+			  size_t key_size, const void *iv, size_t iv_size, const void *in_data);
+#endif
diff --git a/include/drivers/st/stm32_sdmmc2.h b/include/drivers/st/stm32_sdmmc2.h
index 4853208c2..af02b91ea 100644
--- a/include/drivers/st/stm32_sdmmc2.h
+++ b/include/drivers/st/stm32_sdmmc2.h
@@ -10,6 +10,7 @@
 #include <stdbool.h>
 
 #include <drivers/mmc.h>
+#include <drivers/regulator.h>
 
 struct stm32_sdmmc2_params {
 	uintptr_t		reg_base;
@@ -24,6 +25,7 @@ struct stm32_sdmmc2_params {
 	unsigned int		reset_id;
 	unsigned int		max_freq;
 	bool			use_dma;
+	struct rdev		*vmmc_regu;
 };
 
 unsigned long long stm32_sdmmc2_mmc_get_device_size(void);
diff --git a/include/drivers/st/stm32_tamp.h b/include/drivers/st/stm32_tamp.h
new file mode 100644
index 000000000..11dc96df6
--- /dev/null
+++ b/include/drivers/st/stm32_tamp.h
@@ -0,0 +1,252 @@
+/*
+ * Copyright (c) 2014-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32_TAMP_H
+#define STM32_TAMP_H
+
+/* Internal Tamper */
+enum stm32_tamp_int_id {
+	INT_TAMP1 = 0,
+	INT_TAMP2,
+	INT_TAMP3,
+	INT_TAMP4,
+	INT_TAMP5,
+	INT_TAMP6,
+	INT_TAMP7,
+	INT_TAMP8,
+	INT_TAMP9,
+	INT_TAMP10,
+	INT_TAMP11,
+	INT_TAMP12,
+	INT_TAMP13,
+	INT_TAMP14,
+	INT_TAMP15,
+	INT_TAMP16
+};
+
+/* External Tamper */
+enum stm32_tamp_ext_id {
+	EXT_TAMP1 = 0,
+	EXT_TAMP2,
+	EXT_TAMP3,
+	EXT_TAMP4,
+	EXT_TAMP5,
+	EXT_TAMP6,
+	EXT_TAMP7,
+	EXT_TAMP8
+};
+
+/* Out pin to compare for external Tamper */
+enum stm32_tamp_ext_out_id {
+	TAMPOUTSEL_SAME_AS_INPUT = 0,
+	TAMPOUTSEL1 = 1,
+	TAMPOUTSEL2,
+	TAMPOUTSEL3,
+	TAMPOUTSEL4,
+	TAMPOUTSEL5,
+	TAMPOUTSEL6,
+	TAMPOUTSEL7,
+	TAMPOUTSEL8,
+};
+
+/* Define number of backup registers in zone 1 and zone 2 (remaining are in
+ * zone 3)
+ *
+ * backup registers in zone 1 : read/write only in secure mode
+ *                     zone 2 : write only in secure mode, read in secure
+ *                              and non-secure mode
+ *                     zone 3 : read/write in secure and non-secure mode
+ *
+ * Protection zone 1 if nb_zone1_regs == 0 no backup register are in zone 1
+ *                   else backup registers from TAMP_BKP0R to TAMP_BKPxR
+ *                   with x = nb_zone1_regs - 1 are in zone 1.
+ * Protection zone 2 if nb_zone2_regs == 0 no backup register are in zone 2
+ *                   else backup registers from TAMP_BKPyR with y = nb_zone1_regs
+ *                   to TAMP_BKPzR with z = (nb_zone1_regs1 + nb_zone2_regs - 1)
+ *                   are in zone 2.
+ * Protection zone 3 backup registers from TAMP_BKPtR
+ *                   with t = nb_zone1_regs1 + nb_zone2_regs to last backup
+ *                   register are in zone 3.
+ */
+struct bkpregs_conf {
+	uint32_t nb_zone1_regs;
+	uint32_t nb_zone2_regs;
+};
+
+/* Define TAMPER modes */
+#define TAMP_DISABLE		0x0U
+#define TAMP_ENABLE		0x1U
+#define TAMP_TRIG_OFF		0x0U
+#define TAMP_TRIG_ON		0x2U
+#define TAMP_ACTIVE		0x4U
+#define TAMP_ERASE		0x0U
+#define TAMP_NOERASE		0x8U
+#define TAMP_NO_EVT_MASK	0x0U
+#define TAMP_EVT_MASK		0x10U
+
+/* Define Passive FILTER mode */
+#define TAMP_FILTER_TAMPPUDIS_OFFSET	7U
+#define TAMP_FILTER_PRECHARGE		(0x0U << TAMP_FILTER_TAMPPUDIS_OFFSET)
+#define TAMP_FILTER_PULL_UP_DISABLE	(0x1U << TAMP_FILTER_TAMPPUDIS_OFFSET)
+#define TAMP_FILTER_TAMPPRCH_OFFSET	5U
+#define TAMP_FILTER_DURATION_1_CYCLE	(0x0U << TAMP_FILTER_TAMPPRCH_OFFSET)
+#define TAMP_FILTER_DURATION_2_CYCLES	(0x1U << TAMP_FILTER_TAMPPRCH_OFFSET)
+#define TAMP_FILTER_DURATION_4_CYCLES	(0x2U << TAMP_FILTER_TAMPPRCH_OFFSET)
+#define TAMP_FILTER_DURATION_8_CYCLES	(0x3U << TAMP_FILTER_TAMPPRCH_OFFSET)
+#define TAMP_FILTER_TAMPFLT_OFFSET	3U
+#define TAMP_FILTER_COUNT_1		(0x0U << TAMP_FILTER_TAMPFLT_OFFSET)
+#define TAMP_FILTER_COUNT_2		(0x1U << TAMP_FILTER_TAMPFLT_OFFSET)
+#define TAMP_FILTER_COUNT_4		(0x2U << TAMP_FILTER_TAMPFLT_OFFSET)
+#define TAMP_FILTER_COUNT_8		(0x3U << TAMP_FILTER_TAMPFLT_OFFSET)
+#define TAMP_FILTER_TAMPFREQ_OFFSET	0U
+#define TAMP_FILTER_SAMPLING_32768	(0x0U << TAMP_FILTER_TAMPFREQ_OFFSET)
+#define TAMP_FILTER_SAMPLING_16384	(0x1U << TAMP_FILTER_TAMPFREQ_OFFSET)
+#define TAMP_FILTER_SAMPLING_8192	(0x2U << TAMP_FILTER_TAMPFREQ_OFFSET)
+#define TAMP_FILTER_SAMPLING_4096	(0x3U << TAMP_FILTER_TAMPFREQ_OFFSET)
+#define TAMP_FILTER_SAMPLING_2048	(0x4U << TAMP_FILTER_TAMPFREQ_OFFSET)
+#define TAMP_FILTER_SAMPLING_1024	(0x5U << TAMP_FILTER_TAMPFREQ_OFFSET)
+#define TAMP_FILTER_SAMPLING_512	(0x6U << TAMP_FILTER_TAMPFREQ_OFFSET)
+#define TAMP_FILTER_SAMPLING_256	(0x7U << TAMP_FILTER_TAMPFREQ_OFFSET)
+
+/*  Define active filter */
+#define TAMP_ACTIVE_FLTEN_OFFSET	31U
+#define TAMP_ACTIVE_FILTER_OFF		(0x0U << TAMP_ACTIVE_FLTEN_OFFSET)
+#define TAMP_ACTIVE_FILTER_ON		(0x1U << TAMP_ACTIVE_FLTEN_OFFSET)
+#define TAMP_FILTER_ATOSHARE_OFFSET	30U
+#define TAMP_FILTER_USE_DEDICATED_OUT	(0x0U << TAMP_FILTER_ATOSHARE_OFFSET)
+#define TAMP_FILTER_SELECT_OUT		(0x1U << TAMP_FILTER_ATOSHARE_OFFSET)
+#define TAMP_ACTIVE_ATPER_OFFSET	24U
+#define TAMP_ACTIVE_ATPER_1_OUTPUT	(0x0U << TAMP_ACTIVE_ATPER_OFFSET)
+#define TAMP_ACTIVE_ATPER_2_OUTPUTS	(0x1U << TAMP_ACTIVE_ATPER_OFFSET)
+#define TAMP_ACTIVE_ATPER_3_4_OUTPUTS	(0x2U << TAMP_ACTIVE_ATPER_OFFSET)
+#define TAMP_ACTIVE_ATPER_5_OUTPUTS	(0x3U << TAMP_ACTIVE_ATPER_OFFSET)
+#define TAMP_ACTIVE_ATCKSEL_OFFSET	16U
+#define TAMP_ACTIVE_CKSEL_DIV_0		(0x0U << TAMP_ACTIVE_ATCKSEL_OFFSET)
+#define TAMP_ACTIVE_CKSEL_DIV_2		(0x1U << TAMP_ACTIVE_ATCKSEL_OFFSET)
+#define TAMP_ACTIVE_CKSEL_DIV_4		(0x2U << TAMP_ACTIVE_ATCKSEL_OFFSET)
+#define TAMP_ACTIVE_CKSEL_DIV_8		(0x3U << TAMP_ACTIVE_ATCKSEL_OFFSET)
+#define TAMP_ACTIVE_CKSEL_DIV_16	(0x4U << TAMP_ACTIVE_ATCKSEL_OFFSET)
+#define TAMP_ACTIVE_CKSEL_DIV_32	(0x5U << TAMP_ACTIVE_ATCKSEL_OFFSET)
+#define TAMP_ACTIVE_CKSEL_DIV_64	(0x6U << TAMP_ACTIVE_ATCKSEL_OFFSET)
+#define TAMP_ACTIVE_CKSEL_DIV_128	(0x7U << TAMP_ACTIVE_ATCKSEL_OFFSET)
+
+/* Define secure mode acces */
+/* Tamper configuration and interrupt can be written when the APB access is secure or nonsecure.*/
+#define TAMP_REGS_IT_UNSECURE		0U
+/* Tamper configuration and interrupt can be written only when the APB access is secure.*/
+#define TAMP_REGS_IT_SECURE		BIT(31)
+
+/*
+ * stm32_tamp_write_mcounter : Increase monotonic counter[counter_idx]
+ */
+int stm32_tamp_write_mcounter(int counter_idx);
+uint32_t stm32_tamp_read_mcounter(int counter_idx);
+
+/*
+ * stm32_tamp_it_handler : Interrupt handler
+ */
+void stm32_tamp_it_handler(void);
+
+/*
+ * stm32_tamp_configure_secure_access: Configure which registers can be
+ * read/write from unsecure world
+ * secure_conf is a bit field from TAMP_.*_{UN,}SECURE define
+ */
+void stm32_tamp_configure_secure_access(uint32_t secure_conf);
+
+/*
+ * stm32_tamp_configure_privilege_access: Configure which registers can be
+ * read/write from unpriviliged world
+ * privilege_conf is a bit field from TAMP_.*_{UN,}PRIVILEGE define
+ */
+void stm32_tamp_configure_privilege_access(uint32_t privilege_conf);
+
+/*
+ * stm32_tamp_configure_passive: Configure passive mode
+ * passive_conf is a bit field from TAMP_FILTER_* define
+ */
+void stm32_tamp_configure_passive(uint32_t passive_conf);
+
+/*
+ * stm32_tamp_configure_ctive: Configure active mode
+ * passive_conf is a bit field from TAMP_ACTIVE_* define
+ */
+void stm32_tamp_configure_active(uint32_t active_conf);
+
+/*
+ * stm32_tamp_configure_internal: Configure one internal tamper
+ * id: internal tamper id
+ * mode: bitmask from TAMPER modes define
+ * callback: function to call when tamper is raised (can be NULL),
+ *           called in interrupt context,
+ *           if callback returns negative value, blocked secrets stay blocked
+ *           (driver doesn't release this specific tamper).
+ *           if callback returns 0 this specific tamp is ack (in case of no-erase
+ *           tamper, blocked secret are unblocked)
+ *           if callback returns positive value, this specific tamp is ack (in
+ *           case of no-erase tamper, blocked secret are unblocked) and system is
+ *           rebooted).
+ *
+ * return: -EINVAL if 'id' is not a valid internal tamp id, else 0
+ */
+int stm32_tamp_configure_internal(enum stm32_tamp_int_id id, uint32_t mode,
+				  int (*callback)(int id));
+
+/*
+ * stm32_tamp_configure_external: Configure one external tamper
+ * id: external tamper id
+ * mode: bitmask from TAMPER modes define
+ * pin_out; output pin connected to input pin (linekd with selected ext tamp id)
+ * callback: function to call when tamper is raised (can be NULL),
+ *           called in interrupt context,
+ *           if callback returns negative value, blocked secrets stay blocked
+ *           (driver doesn't release this specific tamper).
+ *           if callback returns 0 this specific tamp is ack (in case of no-erase
+ *           tamper, blocked secret are unblocked)
+ *           if callback returns positive value, this specific tamp is ack (in
+ *           case of no-erase tamper, blocked secret are unblocked) and system is
+ *           rebooted).
+ *
+ * return: -EINVAL if 'id' is not a valid external tamp id, else 0
+ */
+int stm32_tamp_configure_external(enum stm32_tamp_ext_id id, uint32_t mode,
+				  enum stm32_tamp_ext_out_id out_pin, int (*callback)(int id));
+
+/*
+ * stm32_tamp_init: Initialize tamper from DT
+ * return 0 if disabled, 1 if enabled, else < 0
+ */
+int stm32_tamp_init(void);
+
+/*
+ * stm32_tamp_set_secure_bkprwregs : Configure backup registers zone.
+ * registers in zone 1 : read/write only in secure mode
+ *              zone 2 : write only in secure mode, read in secure and non-secure mode
+ *              zone 3 : read/write in secure and non-secure mode
+ *
+ * bkpregs_conf : a pointer to struct bkpregs_conf that define the number of registers in zone 1
+ * and zone 2 (remaining backup registers will be in zone 3).
+ *
+ * return 0 if OK, -ENODEV if zone 1 and/or zone 2 definition are out of range.
+ */
+int stm32_tamp_set_secure_bkpregs(struct bkpregs_conf *bkpregs_conf);
+
+/*
+ * stm32_tamp_set_config: apply configuration
+ * default one if no previous call to any of :
+ * stm32_tamp_configure_passive()
+ * stm32_tamp_configure_active()
+ * stm32_tamp_configure_internal()
+ * stm32_tamp_configure_external()
+ * stm32_tamp_configure_secret_list()
+ * stm32_tamp_configure_secure_access()
+ * stm32_tamp_configure_privilige_access()
+ *
+ * return: < 0 if unable to apply configuration, else 0
+ */
+int stm32_tamp_set_config(void);
+
+#endif /* STM32_TAMP_H */
diff --git a/include/drivers/st/stm32_timer.h b/include/drivers/st/stm32_timer.h
new file mode 100644
index 000000000..0e2eb91fe
--- /dev/null
+++ b/include/drivers/st/stm32_timer.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2018-2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32_TIMER_H
+#define STM32_TIMER_H
+
+enum timer_cal {
+	HSI_CAL = 0,
+	CSI_CAL
+};
+
+unsigned long stm32_timer_hsi_freq(void);
+unsigned long stm32_timer_csi_freq(void);
+void stm32_timer_freq_func(unsigned long (**timer_freq_cb)(void),
+			   enum timer_cal type);
+int stm32_timer_init(void);
+
+#endif /* STM32_TIMER_H */
diff --git a/include/drivers/st/stm32_uart.h b/include/drivers/st/stm32_uart.h
new file mode 100644
index 000000000..f906cf8ad
--- /dev/null
+++ b/include/drivers/st/stm32_uart.h
@@ -0,0 +1,159 @@
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32_UART_H
+#define STM32_UART_H
+
+/* UART word length */
+#define STM32_UART_WORDLENGTH_7B		USART_CR1_M1
+#define STM32_UART_WORDLENGTH_8B		0x00000000U
+#define STM32_UART_WORDLENGTH_9B		USART_CR1_M0
+
+/* UART number of stop bits */
+#define STM32_UART_STOPBITS_0_5			USART_CR2_STOP_0
+#define STM32_UART_STOPBITS_1			0x00000000U
+#define STM32_UART_STOPBITS_1_5			(USART_CR2_STOP_0 | USART_CR2_STOP_1)
+#define STM32_UART_STOPBITS_2			USART_CR2_STOP_1
+
+/* UART parity */
+#define STM32_UART_PARITY_NONE			0x00000000U
+#define STM32_UART_PARITY_EVEN			USART_CR1_PCE
+#define STM32_UART_PARITY_ODD			(USART_CR1_PCE | USART_CR1_PS)
+
+/* UART transfer mode */
+#define STM32_UART_MODE_RX			USART_CR1_RE
+#define STM32_UART_MODE_TX			USART_CR1_TE
+#define STM32_UART_MODE_TX_RX			(USART_CR1_TE | USART_CR1_RE)
+
+/* UART hardware flow control */
+#define STM32_UART_HWCONTROL_NONE		0x00000000U
+#define STM32_UART_HWCONTROL_RTS		USART_CR3_RTSE
+#define STM32_UART_HWCONTROL_CTS		USART_CR3_CTSE
+#define STM32_UART_HWCONTROL_RTS_CTS		(USART_CR3_RTSE | USART_CR3_CTSE)
+
+/* UART prescaler */
+#define STM32_UART_PRESCALER_DIV1		0x00000000U
+#define STM32_UART_PRESCALER_DIV2		0x00000001U
+#define STM32_UART_PRESCALER_DIV4		0x00000002U
+#define STM32_UART_PRESCALER_DIV6		0x00000003U
+#define STM32_UART_PRESCALER_DIV8		0x00000004U
+#define STM32_UART_PRESCALER_DIV10		0x00000005U
+#define STM32_UART_PRESCALER_DIV12		0x00000006U
+#define STM32_UART_PRESCALER_DIV16		0x00000007U
+#define STM32_UART_PRESCALER_DIV32		0x00000008U
+#define STM32_UART_PRESCALER_DIV64		0x00000009U
+#define STM32_UART_PRESCALER_DIV128		0x0000000AU
+#define STM32_UART_PRESCALER_DIV256		0x0000000BU
+#define STM32_UART_PRESCALER_NB			0x0000000CU
+
+/* UART fifo mode */
+#define STM32_UART_FIFOMODE_EN			USART_CR1_FIFOEN
+#define STM32_UART_FIFOMODE_DIS			0x00000000U
+
+/* UART TXFIFO threshold level */
+#define STM32_UART_TXFIFO_THRESHOLD_1EIGHTHFULL		0x00000000U
+#define STM32_UART_TXFIFO_THRESHOLD_1QUARTERFUL		USART_CR3_TXFTCFG_0
+#define STM32_UART_TXFIFO_THRESHOLD_HALFFULL		USART_CR3_TXFTCFG_1
+#define STM32_UART_TXFIFO_THRESHOLD_3QUARTERSFULL	(USART_CR3_TXFTCFG_0 | USART_CR3_TXFTCFG_1)
+#define STM32_UART_TXFIFO_THRESHOLD_7EIGHTHFULL		USART_CR3_TXFTCFG_2
+#define STM32_UART_TXFIFO_THRESHOLD_EMPTY		(USART_CR3_TXFTCFG_2 | USART_CR3_TXFTCFG_0)
+
+/* UART RXFIFO threshold level */
+#define STM32_UART_RXFIFO_THRESHOLD_1EIGHTHFULL		0x00000000U
+#define STM32_UART_RXFIFO_THRESHOLD_1QUARTERFULL	USART_CR3_RXFTCFG_0
+#define STM32_UART_RXFIFO_THRESHOLD_HALFFULL		USART_CR3_RXFTCFG_1
+#define STM32_UART_RXFIFO_THRESHOLD_3QUARTERSFULL	(USART_CR3_RXFTCFG_0 | USART_CR3_RXFTCFG_1)
+#define STM32_UART_RXFIFO_THRESHOLD_7EIGHTHFULL		USART_CR3_RXFTCFG_2
+#define STM32_UART_RXFIFO_THRESHOLD_FULL		(USART_CR3_RXFTCFG_2 | USART_CR3_RXFTCFG_0)
+
+struct stm32_uart_init_s {
+	uint32_t baud_rate;		/*
+					 * Configures the UART communication
+					 * baud rate.
+					 */
+
+	uint32_t word_length;		/*
+					 * Specifies the number of data bits
+					 * transmitted or received in a frame.
+					 * This parameter can be a value of
+					 * @ref STM32_UART_WORDLENGTH_*.
+					 */
+
+	uint32_t stop_bits;		/*
+					 * Specifies the number of stop bits
+					 * transmitted. This parameter can be
+					 * a value of @ref STM32_UART_STOPBITS_*.
+					 */
+
+	uint32_t parity;		/*
+					 * Specifies the parity mode.
+					 * This parameter can be a value of
+					 * @ref STM32_UART_PARITY_*.
+					 */
+
+	uint32_t mode;			/*
+					 * Specifies whether the receive or
+					 * transmit mode is enabled or
+					 * disabled. This parameter can be a
+					 * value of @ref @ref STM32_UART_MODE_*.
+					 */
+
+	uint32_t hw_flow_control;	/*
+					 * Specifies whether the hardware flow
+					 * control mode is enabled or
+					 * disabled. This parameter can be a
+					 * value of @ref STM32_UARTHWCONTROL_*.
+					 */
+
+	uint32_t one_bit_sampling;	/*
+					 * Specifies whether a single sample
+					 * or three samples' majority vote is
+					 * selected. This parameter can be 0
+					 * or USART_CR3_ONEBIT.
+					 */
+
+	uint32_t prescaler;		/*
+					 * Specifies the prescaler value used
+					 * to divide the UART clock source.
+					 * This parameter can be a value of
+					 * @ref STM32_UART_PRESCALER_*.
+					 */
+
+	uint32_t fifo_mode;		/*
+					 * Specifies if the FIFO mode will be
+					 * used. This parameter can be a value
+					 * of @ref STM32_UART_FIFOMODE_*.
+					 */
+
+	uint32_t tx_fifo_threshold;	/*
+					 * Specifies the TXFIFO threshold
+					 * level. This parameter can be a
+					 * value of @ref
+					 * STM32_UART_TXFIFO_THRESHOLD_*.
+					 */
+
+	uint32_t rx_fifo_threshold;	/*
+					 * Specifies the RXFIFO threshold
+					 * level. This parameter can be a
+					 * value of @ref
+					 * STM32_UART_RXFIFO_THRESHOLD_*.
+					 */
+};
+
+struct stm32_uart_handle_s {
+	uint32_t base;
+	uint32_t rdr_mask;
+};
+
+int stm32_uart_init(struct stm32_uart_handle_s *huart,
+		    uintptr_t base_addr,
+		    const struct stm32_uart_init_s *init);
+void stm32_uart_stop(uintptr_t base_addr);
+int stm32_uart_putc(struct stm32_uart_handle_s *huart, int c);
+int stm32_uart_flush(struct stm32_uart_handle_s *huart);
+int stm32_uart_getc(struct stm32_uart_handle_s *huart);
+
+#endif /* STM32_UART_H */
diff --git a/include/drivers/st/stm32mp13_rcc.h b/include/drivers/st/stm32mp13_rcc.h
new file mode 100644
index 000000000..9f992e771
--- /dev/null
+++ b/include/drivers/st/stm32mp13_rcc.h
@@ -0,0 +1,1878 @@
+/*
+ * Copyright (c) 2015-2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP13_RCC_H
+#define STM32MP13_RCC_H
+
+#include <lib/utils_def.h>
+
+#define RCC_SECCFGR				U(0X0)
+#define RCC_MP_SREQSETR				U(0X100)
+#define RCC_MP_SREQCLRR				U(0X104)
+#define RCC_MP_APRSTCR				U(0X108)
+#define RCC_MP_APRSTSR				U(0X10C)
+#define RCC_PWRLPDLYCR				U(0X110)
+#define RCC_MP_GRSTCSETR			U(0X114)
+#define RCC_BR_RSTSCLRR				U(0X118)
+#define RCC_MP_RSTSSETR				U(0X11C)
+#define RCC_MP_RSTSCLRR				U(0X120)
+#define RCC_MP_IWDGFZSETR			U(0X124)
+#define RCC_MP_IWDGFZCLRR			U(0X128)
+#define RCC_MP_CIER				U(0X200)
+#define RCC_MP_CIFR				U(0X204)
+#define RCC_BDCR				U(0X400)
+#define RCC_RDLSICR				U(0X404)
+#define RCC_OCENSETR				U(0X420)
+#define RCC_OCENCLRR				U(0X424)
+#define RCC_OCRDYR				U(0X428)
+#define RCC_HSICFGR				U(0X440)
+#define RCC_CSICFGR				U(0X444)
+#define RCC_MCO1CFGR				U(0X460)
+#define RCC_MCO2CFGR				U(0X464)
+#define RCC_DBGCFGR				U(0X468)
+#define RCC_RCK12SELR				U(0X480)
+#define RCC_RCK3SELR				U(0X484)
+#define RCC_RCK4SELR				U(0X488)
+#define RCC_PLL1CR				U(0X4A0)
+#define RCC_PLL1CFGR1				U(0X4A4)
+#define RCC_PLL1CFGR2				U(0X4A8)
+#define RCC_PLL1FRACR				U(0X4AC)
+#define RCC_PLL1CSGR				U(0X4B0)
+#define RCC_PLL2CR				U(0X4D0)
+#define RCC_PLL2CFGR1				U(0X4D4)
+#define RCC_PLL2CFGR2				U(0X4D8)
+#define RCC_PLL2FRACR				U(0X4DC)
+#define RCC_PLL2CSGR				U(0X4E0)
+#define RCC_PLL3CR				U(0X500)
+#define RCC_PLL3CFGR1				U(0X504)
+#define RCC_PLL3CFGR2				U(0X508)
+#define RCC_PLL3FRACR				U(0X50C)
+#define RCC_PLL3CSGR				U(0X510)
+#define RCC_PLL4CR				U(0X520)
+#define RCC_PLL4CFGR1				U(0X524)
+#define RCC_PLL4CFGR2				U(0X528)
+#define RCC_PLL4FRACR				U(0X52C)
+#define RCC_PLL4CSGR				U(0X530)
+#define RCC_MPCKSELR				U(0X540)
+#define RCC_ASSCKSELR				U(0X544)
+#define RCC_MSSCKSELR				U(0X548)
+#define RCC_CPERCKSELR				U(0X54C)
+#define RCC_RTCDIVR				U(0X560)
+#define RCC_MPCKDIVR				U(0X564)
+#define RCC_AXIDIVR				U(0X568)
+#define RCC_MLAHBDIVR				U(0X56C)
+#define RCC_APB1DIVR				U(0X570)
+#define RCC_APB2DIVR				U(0X574)
+#define RCC_APB3DIVR				U(0X578)
+#define RCC_APB4DIVR				U(0X57C)
+#define RCC_APB5DIVR				U(0X580)
+#define RCC_APB6DIVR				U(0X584)
+#define RCC_TIMG1PRER				U(0X5A0)
+#define RCC_TIMG2PRER				U(0X5A4)
+#define RCC_TIMG3PRER				U(0X5A8)
+#define RCC_DDRITFCR				U(0X5C0)
+#define RCC_I2C12CKSELR				U(0X600)
+#define RCC_I2C345CKSELR			U(0X604)
+#define RCC_SPI2S1CKSELR			U(0X608)
+#define RCC_SPI2S23CKSELR			U(0X60C)
+#define RCC_SPI45CKSELR				U(0X610)
+#define RCC_UART12CKSELR			U(0X614)
+#define RCC_UART35CKSELR			U(0X618)
+#define RCC_UART4CKSELR				U(0X61C)
+#define RCC_UART6CKSELR				U(0X620)
+#define RCC_UART78CKSELR			U(0X624)
+#define RCC_LPTIM1CKSELR			U(0X628)
+#define RCC_LPTIM23CKSELR			U(0X62C)
+#define RCC_LPTIM45CKSELR			U(0X630)
+#define RCC_SAI1CKSELR				U(0X634)
+#define RCC_SAI2CKSELR				U(0X638)
+#define RCC_FDCANCKSELR				U(0X63C)
+#define RCC_SPDIFCKSELR				U(0X640)
+#define RCC_ADC12CKSELR				U(0X644)
+#define RCC_SDMMC12CKSELR			U(0X648)
+#define RCC_ETH12CKSELR				U(0X64C)
+#define RCC_USBCKSELR				U(0X650)
+#define RCC_QSPICKSELR				U(0X654)
+#define RCC_FMCCKSELR				U(0X658)
+#define RCC_RNG1CKSELR				U(0X65C)
+#define RCC_STGENCKSELR				U(0X660)
+#define RCC_DCMIPPCKSELR			U(0X664)
+#define RCC_SAESCKSELR				U(0X668)
+#define RCC_APB1RSTSETR				U(0X6A0)
+#define RCC_APB1RSTCLRR				U(0X6A4)
+#define RCC_APB2RSTSETR				U(0X6A8)
+#define RCC_APB2RSTCLRR				U(0X6AC)
+#define RCC_APB3RSTSETR				U(0X6B0)
+#define RCC_APB3RSTCLRR				U(0X6B4)
+#define RCC_APB4RSTSETR				U(0X6B8)
+#define RCC_APB4RSTCLRR				U(0X6BC)
+#define RCC_APB5RSTSETR				U(0X6C0)
+#define RCC_APB5RSTCLRR				U(0X6C4)
+#define RCC_APB6RSTSETR				U(0X6C8)
+#define RCC_APB6RSTCLRR				U(0X6CC)
+#define RCC_AHB2RSTSETR				U(0X6D0)
+#define RCC_AHB2RSTCLRR				U(0X6D4)
+#define RCC_AHB4RSTSETR				U(0X6E0)
+#define RCC_AHB4RSTCLRR				U(0X6E4)
+#define RCC_AHB5RSTSETR				U(0X6E8)
+#define RCC_AHB5RSTCLRR				U(0X6EC)
+#define RCC_AHB6RSTSETR				U(0X6F0)
+#define RCC_AHB6RSTCLRR				U(0X6F4)
+#define RCC_MP_APB1ENSETR			U(0X700)
+#define RCC_MP_APB1ENCLRR			U(0X704)
+#define RCC_MP_APB2ENSETR			U(0X708)
+#define RCC_MP_APB2ENCLRR			U(0X70C)
+#define RCC_MP_APB3ENSETR			U(0X710)
+#define RCC_MP_APB3ENCLRR			U(0X714)
+#define RCC_MP_S_APB3ENSETR			U(0X718)
+#define RCC_MP_S_APB3ENCLRR			U(0X71C)
+#define RCC_MP_NS_APB3ENSETR			U(0X720)
+#define RCC_MP_NS_APB3ENCLRR			U(0X724)
+#define RCC_MP_APB4ENSETR			U(0X728)
+#define RCC_MP_APB4ENCLRR			U(0X72C)
+#define RCC_MP_S_APB4ENSETR			U(0X730)
+#define RCC_MP_S_APB4ENCLRR			U(0X734)
+#define RCC_MP_NS_APB4ENSETR			U(0X738)
+#define RCC_MP_NS_APB4ENCLRR			U(0X73C)
+#define RCC_MP_APB5ENSETR			U(0X740)
+#define RCC_MP_APB5ENCLRR			U(0X744)
+#define RCC_MP_APB6ENSETR			U(0X748)
+#define RCC_MP_APB6ENCLRR			U(0X74C)
+#define RCC_MP_AHB2ENSETR			U(0X750)
+#define RCC_MP_AHB2ENCLRR			U(0X754)
+#define RCC_MP_AHB4ENSETR			U(0X760)
+#define RCC_MP_AHB4ENCLRR			U(0X764)
+#define RCC_MP_S_AHB4ENSETR			U(0X768)
+#define RCC_MP_S_AHB4ENCLRR			U(0X76C)
+#define RCC_MP_NS_AHB4ENSETR			U(0X770)
+#define RCC_MP_NS_AHB4ENCLRR			U(0X774)
+#define RCC_MP_AHB5ENSETR			U(0X778)
+#define RCC_MP_AHB5ENCLRR			U(0X77C)
+#define RCC_MP_AHB6ENSETR			U(0X780)
+#define RCC_MP_AHB6ENCLRR			U(0X784)
+#define RCC_MP_S_AHB6ENSETR			U(0X788)
+#define RCC_MP_S_AHB6ENCLRR			U(0X78C)
+#define RCC_MP_NS_AHB6ENSETR			U(0X790)
+#define RCC_MP_NS_AHB6ENCLRR			U(0X794)
+#define RCC_MP_APB1LPENSETR			U(0X800)
+#define RCC_MP_APB1LPENCLRR			U(0X804)
+#define RCC_MP_APB2LPENSETR			U(0X808)
+#define RCC_MP_APB2LPENCLRR			U(0X80C)
+#define RCC_MP_APB3LPENSETR			U(0X810)
+#define RCC_MP_APB3LPENCLRR			U(0X814)
+#define RCC_MP_S_APB3LPENSETR			U(0X818)
+#define RCC_MP_S_APB3LPENCLRR			U(0X81C)
+#define RCC_MP_NS_APB3LPENSETR			U(0X820)
+#define RCC_MP_NS_APB3LPENCLRR			U(0X824)
+#define RCC_MP_APB4LPENSETR			U(0X828)
+#define RCC_MP_APB4LPENCLRR			U(0X82C)
+#define RCC_MP_S_APB4LPENSETR			U(0X830)
+#define RCC_MP_S_APB4LPENCLRR			U(0X834)
+#define RCC_MP_NS_APB4LPENSETR			U(0X838)
+#define RCC_MP_NS_APB4LPENCLRR			U(0X83C)
+#define RCC_MP_APB5LPENSETR			U(0X840)
+#define RCC_MP_APB5LPENCLRR			U(0X844)
+#define RCC_MP_APB6LPENSETR			U(0X848)
+#define RCC_MP_APB6LPENCLRR			U(0X84C)
+#define RCC_MP_AHB2LPENSETR			U(0X850)
+#define RCC_MP_AHB2LPENCLRR			U(0X854)
+#define RCC_MP_AHB4LPENSETR			U(0X858)
+#define RCC_MP_AHB4LPENCLRR			U(0X85C)
+#define RCC_MP_S_AHB4LPENSETR			U(0X868)
+#define RCC_MP_S_AHB4LPENCLRR			U(0X86C)
+#define RCC_MP_NS_AHB4LPENSETR			U(0X870)
+#define RCC_MP_NS_AHB4LPENCLRR			U(0X874)
+#define RCC_MP_AHB5LPENSETR			U(0X878)
+#define RCC_MP_AHB5LPENCLRR			U(0X87C)
+#define RCC_MP_AHB6LPENSETR			U(0X880)
+#define RCC_MP_AHB6LPENCLRR			U(0X884)
+#define RCC_MP_S_AHB6LPENSETR			U(0X888)
+#define RCC_MP_S_AHB6LPENCLRR			U(0X88C)
+#define RCC_MP_NS_AHB6LPENSETR			U(0X890)
+#define RCC_MP_NS_AHB6LPENCLRR			U(0X894)
+#define RCC_MP_S_AXIMLPENSETR			U(0X898)
+#define RCC_MP_S_AXIMLPENCLRR			U(0X89C)
+#define RCC_MP_NS_AXIMLPENSETR			U(0X8A0)
+#define RCC_MP_NS_AXIMLPENCLRR			U(0X8A4)
+#define RCC_MP_MLAHBLPENSETR			U(0X8A8)
+#define RCC_MP_MLAHBLPENCLRR			U(0X8AC)
+#define RCC_APB3SECSR				U(0X8C0)
+#define RCC_APB4SECSR				U(0X8C4)
+#define RCC_APB5SECSR				U(0X8C8)
+#define RCC_APB6SECSR				U(0X8CC)
+#define RCC_AHB2SECSR				U(0X8D0)
+#define RCC_AHB4SECSR				U(0X8D4)
+#define RCC_AHB5SECSR				U(0X8D8)
+#define RCC_AHB6SECSR				U(0X8DC)
+#define RCC_VERR				U(0XFF4)
+#define RCC_IDR					U(0XFF8)
+#define RCC_SIDR				U(0XFFC)
+
+/* RCC_SECCFGR register fields */
+#define RCC_SECCFGR_HSISEC			BIT(0)
+#define RCC_SECCFGR_CSISEC			BIT(1)
+#define RCC_SECCFGR_HSESEC			BIT(2)
+#define RCC_SECCFGR_LSISEC			BIT(3)
+#define RCC_SECCFGR_LSESEC			BIT(4)
+#define RCC_SECCFGR_PLL12SEC			BIT(8)
+#define RCC_SECCFGR_PLL3SEC			BIT(9)
+#define RCC_SECCFGR_PLL4SEC			BIT(10)
+#define RCC_SECCFGR_MPUSEC			BIT(11)
+#define RCC_SECCFGR_AXISEC			BIT(12)
+#define RCC_SECCFGR_MLAHBSEC			BIT(13)
+#define RCC_SECCFGR_APB3DIVSEC			BIT(16)
+#define RCC_SECCFGR_APB4DIVSEC			BIT(17)
+#define RCC_SECCFGR_APB5DIVSEC			BIT(18)
+#define RCC_SECCFGR_APB6DIVSEC			BIT(19)
+#define RCC_SECCFGR_TIMG3SEC			BIT(20)
+#define RCC_SECCFGR_CPERSEC			BIT(21)
+#define RCC_SECCFGR_MCO1SEC			BIT(22)
+#define RCC_SECCFGR_MCO2SEC			BIT(23)
+#define RCC_SECCFGR_STPSEC			BIT(24)
+#define RCC_SECCFGR_RSTSEC			BIT(25)
+#define RCC_SECCFGR_PWRSEC			BIT(31)
+
+/* RCC_MP_SREQSETR register fields */
+#define RCC_MP_SREQSETR_STPREQ_P0		BIT(0)
+
+/* RCC_MP_SREQCLRR register fields */
+#define RCC_MP_SREQCLRR_STPREQ_P0		BIT(0)
+
+/* RCC_MP_APRSTCR register fields */
+#define RCC_MP_APRSTCR_RDCTLEN			BIT(0)
+#define RCC_MP_APRSTCR_RSTTO_MASK		GENMASK(14, 8)
+#define RCC_MP_APRSTCR_RSTTO_SHIFT		8
+
+/* RCC_MP_APRSTSR register fields */
+#define RCC_MP_APRSTSR_RSTTOV_MASK		GENMASK(14, 8)
+#define RCC_MP_APRSTSR_RSTTOV_SHIFT		8
+
+/* RCC_PWRLPDLYCR register fields */
+#define RCC_PWRLPDLYCR_PWRLP_DLY_MASK		GENMASK(21, 0)
+#define RCC_PWRLPDLYCR_PWRLP_DLY_SHIFT		0
+
+/* RCC_MP_GRSTCSETR register fields */
+#define RCC_MP_GRSTCSETR_MPSYSRST		BIT(0)
+#define RCC_MP_GRSTCSETR_MPUP0RST		BIT(4)
+
+/* RCC_BR_RSTSCLRR register fields */
+#define RCC_BR_RSTSCLRR_PORRSTF			BIT(0)
+#define RCC_BR_RSTSCLRR_BORRSTF			BIT(1)
+#define RCC_BR_RSTSCLRR_PADRSTF			BIT(2)
+#define RCC_BR_RSTSCLRR_HCSSRSTF		BIT(3)
+#define RCC_BR_RSTSCLRR_VCORERSTF		BIT(4)
+#define RCC_BR_RSTSCLRR_VCPURSTF		BIT(5)
+#define RCC_BR_RSTSCLRR_MPSYSRSTF		BIT(6)
+#define RCC_BR_RSTSCLRR_IWDG1RSTF		BIT(8)
+#define RCC_BR_RSTSCLRR_IWDG2RSTF		BIT(9)
+#define RCC_BR_RSTSCLRR_MPUP0RSTF		BIT(13)
+
+/* RCC_MP_RSTSSETR register fields */
+#define RCC_MP_RSTSSETR_PORRSTF			BIT(0)
+#define RCC_MP_RSTSSETR_BORRSTF			BIT(1)
+#define RCC_MP_RSTSSETR_PADRSTF			BIT(2)
+#define RCC_MP_RSTSSETR_HCSSRSTF		BIT(3)
+#define RCC_MP_RSTSSETR_VCORERSTF		BIT(4)
+#define RCC_MP_RSTSSETR_VCPURSTF		BIT(5)
+#define RCC_MP_RSTSSETR_MPSYSRSTF		BIT(6)
+#define RCC_MP_RSTSSETR_IWDG1RSTF		BIT(8)
+#define RCC_MP_RSTSSETR_IWDG2RSTF		BIT(9)
+#define RCC_MP_RSTSSETR_STP2RSTF		BIT(10)
+#define RCC_MP_RSTSSETR_STDBYRSTF		BIT(11)
+#define RCC_MP_RSTSSETR_CSTDBYRSTF		BIT(12)
+#define RCC_MP_RSTSSETR_MPUP0RSTF		BIT(13)
+#define RCC_MP_RSTSSETR_SPARE			BIT(15)
+
+/* RCC_MP_RSTSCLRR register fields */
+#define RCC_MP_RSTSCLRR_PORRSTF			BIT(0)
+#define RCC_MP_RSTSCLRR_BORRSTF			BIT(1)
+#define RCC_MP_RSTSCLRR_PADRSTF			BIT(2)
+#define RCC_MP_RSTSCLRR_HCSSRSTF		BIT(3)
+#define RCC_MP_RSTSCLRR_VCORERSTF		BIT(4)
+#define RCC_MP_RSTSCLRR_VCPURSTF		BIT(5)
+#define RCC_MP_RSTSCLRR_MPSYSRSTF		BIT(6)
+#define RCC_MP_RSTSCLRR_IWDG1RSTF		BIT(8)
+#define RCC_MP_RSTSCLRR_IWDG2RSTF		BIT(9)
+#define RCC_MP_RSTSCLRR_STP2RSTF		BIT(10)
+#define RCC_MP_RSTSCLRR_STDBYRSTF		BIT(11)
+#define RCC_MP_RSTSCLRR_CSTDBYRSTF		BIT(12)
+#define RCC_MP_RSTSCLRR_MPUP0RSTF		BIT(13)
+#define RCC_MP_RSTSCLRR_SPARE			BIT(15)
+
+/* RCC_MP_IWDGFZSETR register fields */
+#define RCC_MP_IWDGFZSETR_FZ_IWDG1		BIT(0)
+#define RCC_MP_IWDGFZSETR_FZ_IWDG2		BIT(1)
+
+/* RCC_MP_IWDGFZCLRR register fields */
+#define RCC_MP_IWDGFZCLRR_FZ_IWDG1		BIT(0)
+#define RCC_MP_IWDGFZCLRR_FZ_IWDG2		BIT(1)
+
+/* RCC_MP_CIER register fields */
+#define RCC_MP_CIER_LSIRDYIE			BIT(0)
+#define RCC_MP_CIER_LSERDYIE			BIT(1)
+#define RCC_MP_CIER_HSIRDYIE			BIT(2)
+#define RCC_MP_CIER_HSERDYIE			BIT(3)
+#define RCC_MP_CIER_CSIRDYIE			BIT(4)
+#define RCC_MP_CIER_PLL1DYIE			BIT(8)
+#define RCC_MP_CIER_PLL2DYIE			BIT(9)
+#define RCC_MP_CIER_PLL3DYIE			BIT(10)
+#define RCC_MP_CIER_PLL4DYIE			BIT(11)
+#define RCC_MP_CIER_LSECSSIE			BIT(16)
+#define RCC_MP_CIER_WKUPIE			BIT(20)
+
+/* RCC_MP_CIFR register fields */
+#define RCC_MP_CIFR_LSIRDYF			BIT(0)
+#define RCC_MP_CIFR_LSERDYF			BIT(1)
+#define RCC_MP_CIFR_HSIRDYF			BIT(2)
+#define RCC_MP_CIFR_HSERDYF			BIT(3)
+#define RCC_MP_CIFR_CSIRDYF			BIT(4)
+#define RCC_MP_CIFR_PLL1DYF			BIT(8)
+#define RCC_MP_CIFR_PLL2DYF			BIT(9)
+#define RCC_MP_CIFR_PLL3DYF			BIT(10)
+#define RCC_MP_CIFR_PLL4DYF			BIT(11)
+#define RCC_MP_CIFR_LSECSSF			BIT(16)
+#define RCC_MP_CIFR_WKUPF			BIT(20)
+
+/* RCC_BDCR register fields */
+#define RCC_BDCR_LSEON				BIT(0)
+#define RCC_BDCR_LSEBYP				BIT(1)
+#define RCC_BDCR_LSERDY				BIT(2)
+#define RCC_BDCR_DIGBYP				BIT(3)
+#define RCC_BDCR_LSEDRV_MASK			GENMASK(5, 4)
+#define RCC_BDCR_LSEDRV_SHIFT			4
+#define RCC_BDCR_LSECSSON			BIT(8)
+#define RCC_BDCR_LSECSSD			BIT(9)
+#define RCC_BDCR_RTCSRC_MASK			GENMASK(17, 16)
+#define RCC_BDCR_RTCSRC_SHIFT			16
+#define RCC_BDCR_RTCCKEN			BIT(20)
+#define RCC_BDCR_VSWRST				BIT(31)
+
+#define RCC_BDCR_LSEBYP_BIT	                1
+#define RCC_BDCR_LSERDY_BIT		        2
+#define RCC_BDCR_DIGBYP_BIT		        3
+#define RCC_BDCR_LSECSSON_BIT		        8
+
+#define RCC_BDCR_LSEDRV_WIDTH		        2
+
+/* RCC_RDLSICR register fields */
+#define RCC_RDLSICR_LSION			BIT(0)
+#define RCC_RDLSICR_LSIRDY			BIT(1)
+#define RCC_RDLSICR_MRD_MASK			GENMASK(20, 16)
+#define RCC_RDLSICR_MRD_SHIFT			16
+#define RCC_RDLSICR_EADLY_MASK			GENMASK(26, 24)
+#define RCC_RDLSICR_EADLY_SHIFT			24
+#define RCC_RDLSICR_SPARE_MASK			GENMASK(31, 27)
+#define RCC_RDLSICR_SPARE_SHIFT			27
+
+#define RCC_RDLSICR_LSIRDY_BIT		1
+
+/* RCC_OCENSETR register fields */
+#define RCC_OCENSETR_HSION			BIT(0)
+#define RCC_OCENSETR_HSIKERON			BIT(1)
+#define RCC_OCENSETR_CSION			BIT(4)
+#define RCC_OCENSETR_CSIKERON			BIT(5)
+#define RCC_OCENSETR_DIGBYP			BIT(7)
+#define RCC_OCENSETR_HSEON			BIT(8)
+#define RCC_OCENSETR_HSEKERON			BIT(9)
+#define RCC_OCENSETR_HSEBYP			BIT(10)
+#define RCC_OCENSETR_HSECSSON			BIT(11)
+
+#define RCC_OCENR_DIGBYP_BIT		        7
+#define RCC_OCENR_HSEBYP_BIT		        10
+#define RCC_OCENR_HSECSSON_BIT		        11
+
+/* RCC_OCENCLRR register fields */
+#define RCC_OCENCLRR_HSION			BIT(0)
+#define RCC_OCENCLRR_HSIKERON			BIT(1)
+#define RCC_OCENCLRR_CSION			BIT(4)
+#define RCC_OCENCLRR_CSIKERON			BIT(5)
+#define RCC_OCENCLRR_DIGBYP			BIT(7)
+#define RCC_OCENCLRR_HSEON			BIT(8)
+#define RCC_OCENCLRR_HSEKERON			BIT(9)
+#define RCC_OCENCLRR_HSEBYP			BIT(10)
+
+/* RCC_OCRDYR register fields */
+#define RCC_OCRDYR_HSIRDY			BIT(0)
+#define RCC_OCRDYR_HSIDIVRDY			BIT(2)
+#define RCC_OCRDYR_CSIRDY			BIT(4)
+#define RCC_OCRDYR_HSERDY			BIT(8)
+#define RCC_OCRDYR_MPUCKRDY			BIT(23)
+#define RCC_OCRDYR_AXICKRDY			BIT(24)
+
+#define RCC_OCRDYR_HSIRDY_BIT		        0
+#define RCC_OCRDYR_HSIDIVRDY_BIT                2
+#define RCC_OCRDYR_CSIRDY_BIT		        4
+#define RCC_OCRDYR_HSERDY_BIT                   8
+
+/* RCC_HSICFGR register fields */
+#define RCC_HSICFGR_HSIDIV_MASK			GENMASK(1, 0)
+#define RCC_HSICFGR_HSIDIV_SHIFT		0
+#define RCC_HSICFGR_HSITRIM_MASK		GENMASK(14, 8)
+#define RCC_HSICFGR_HSITRIM_SHIFT		8
+#define RCC_HSICFGR_HSICAL_MASK			GENMASK(27, 16)
+#define RCC_HSICFGR_HSICAL_SHIFT		16
+
+/* RCC_CSICFGR register fields */
+#define RCC_CSICFGR_CSITRIM_MASK		GENMASK(12, 8)
+#define RCC_CSICFGR_CSITRIM_SHIFT		8
+#define RCC_CSICFGR_CSICAL_MASK			GENMASK(23, 16)
+#define RCC_CSICFGR_CSICAL_SHIFT		16
+
+/* RCC_MCO1CFGR register fields */
+#define RCC_MCO1CFGR_MCO1SEL_MASK		GENMASK(2, 0)
+#define RCC_MCO1CFGR_MCO1SEL_SHIFT		0
+#define RCC_MCO1CFGR_MCO1DIV_MASK		GENMASK(7, 4)
+#define RCC_MCO1CFGR_MCO1DIV_SHIFT		4
+#define RCC_MCO1CFGR_MCO1ON			BIT(12)
+
+/* RCC_MCO2CFGR register fields */
+#define RCC_MCO2CFGR_MCO2SEL_MASK		GENMASK(2, 0)
+#define RCC_MCO2CFGR_MCO2SEL_SHIFT		0
+#define RCC_MCO2CFGR_MCO2DIV_MASK		GENMASK(7, 4)
+#define RCC_MCO2CFGR_MCO2DIV_SHIFT		4
+#define RCC_MCO2CFGR_MCO2ON			BIT(12)
+
+/* RCC_DBGCFGR register fields */
+#define RCC_DBGCFGR_TRACEDIV_MASK		GENMASK(2, 0)
+#define RCC_DBGCFGR_TRACEDIV_SHIFT		0
+#define RCC_DBGCFGR_DBGCKEN			BIT(8)
+#define RCC_DBGCFGR_TRACECKEN			BIT(9)
+#define RCC_DBGCFGR_DBGRST			BIT(12)
+
+/* RCC_RCK12SELR register fields */
+#define RCC_RCK12SELR_PLL12SRC_MASK		GENMASK(1, 0)
+#define RCC_RCK12SELR_PLL12SRC_SHIFT		0
+#define RCC_RCK12SELR_PLL12SRCRDY		BIT(31)
+
+/* RCC_RCK3SELR register fields */
+#define RCC_RCK3SELR_PLL3SRC_MASK		GENMASK(1, 0)
+#define RCC_RCK3SELR_PLL3SRC_SHIFT		0
+#define RCC_RCK3SELR_PLL3SRCRDY			BIT(31)
+
+/* RCC_RCK4SELR register fields */
+#define RCC_RCK4SELR_PLL4SRC_MASK		GENMASK(1, 0)
+#define RCC_RCK4SELR_PLL4SRC_SHIFT		0
+#define RCC_RCK4SELR_PLL4SRCRDY			BIT(31)
+
+/* RCC_PLL1CR register fields */
+#define RCC_PLL1CR_PLLON			BIT(0)
+#define RCC_PLL1CR_PLL1RDY			BIT(1)
+#define RCC_PLL1CR_SSCG_CTRL			BIT(2)
+#define RCC_PLL1CR_DIVPEN			BIT(4)
+#define RCC_PLL1CR_DIVQEN			BIT(5)
+#define RCC_PLL1CR_DIVREN			BIT(6)
+
+/* RCC_PLL1CFGR1 register fields */
+#define RCC_PLL1CFGR1_DIVN_MASK			GENMASK(8, 0)
+#define RCC_PLL1CFGR1_DIVN_SHIFT		0
+#define RCC_PLL1CFGR1_DIVM1_MASK		GENMASK(21, 16)
+#define RCC_PLL1CFGR1_DIVM1_SHIFT		16
+
+/* RCC_PLL1CFGR2 register fields */
+#define RCC_PLL1CFGR2_DIVP_MASK			GENMASK(6, 0)
+#define RCC_PLL1CFGR2_DIVP_SHIFT		0
+#define RCC_PLL1CFGR2_DIVQ_MASK			GENMASK(14, 8)
+#define RCC_PLL1CFGR2_DIVQ_SHIFT		8
+#define RCC_PLL1CFGR2_DIVR_MASK			GENMASK(22, 16)
+#define RCC_PLL1CFGR2_DIVR_SHIFT		16
+
+/* RCC_PLL1FRACR register fields */
+#define RCC_PLL1FRACR_FRACV_MASK		GENMASK(15, 3)
+#define RCC_PLL1FRACR_FRACV_SHIFT		3
+#define RCC_PLL1FRACR_FRACLE			BIT(16)
+
+/* RCC_PLL1CSGR register fields */
+#define RCC_PLL1CSGR_MOD_PER_MASK		GENMASK(12, 0)
+#define RCC_PLL1CSGR_MOD_PER_SHIFT		0
+#define RCC_PLL1CSGR_TPDFN_DIS			BIT(13)
+#define RCC_PLL1CSGR_RPDFN_DIS			BIT(14)
+#define RCC_PLL1CSGR_SSCG_MODE			BIT(15)
+#define RCC_PLL1CSGR_INC_STEP_MASK		GENMASK(30, 16)
+#define RCC_PLL1CSGR_INC_STEP_SHIFT		16
+
+/* RCC_PLL2CR register fields */
+#define RCC_PLL2CR_PLLON			BIT(0)
+#define RCC_PLL2CR_PLL2RDY			BIT(1)
+#define RCC_PLL2CR_SSCG_CTRL			BIT(2)
+#define RCC_PLL2CR_DIVPEN			BIT(4)
+#define RCC_PLL2CR_DIVQEN			BIT(5)
+#define RCC_PLL2CR_DIVREN			BIT(6)
+
+/* RCC_PLL2CFGR1 register fields */
+#define RCC_PLL2CFGR1_DIVN_MASK			GENMASK(8, 0)
+#define RCC_PLL2CFGR1_DIVN_SHIFT		0
+#define RCC_PLL2CFGR1_DIVM2_MASK		GENMASK(21, 16)
+#define RCC_PLL2CFGR1_DIVM2_SHIFT		16
+
+/* RCC_PLL2CFGR2 register fields */
+#define RCC_PLL2CFGR2_DIVP_MASK			GENMASK(6, 0)
+#define RCC_PLL2CFGR2_DIVP_SHIFT		0
+#define RCC_PLL2CFGR2_DIVQ_MASK			GENMASK(14, 8)
+#define RCC_PLL2CFGR2_DIVQ_SHIFT		8
+#define RCC_PLL2CFGR2_DIVR_MASK			GENMASK(22, 16)
+#define RCC_PLL2CFGR2_DIVR_SHIFT		16
+
+/* RCC_PLL2FRACR register fields */
+#define RCC_PLL2FRACR_FRACV_MASK		GENMASK(15, 3)
+#define RCC_PLL2FRACR_FRACV_SHIFT		3
+#define RCC_PLL2FRACR_FRACLE			BIT(16)
+
+/* RCC_PLL2CSGR register fields */
+#define RCC_PLL2CSGR_MOD_PER_MASK		GENMASK(12, 0)
+#define RCC_PLL2CSGR_MOD_PER_SHIFT		0
+#define RCC_PLL2CSGR_TPDFN_DIS			BIT(13)
+#define RCC_PLL2CSGR_RPDFN_DIS			BIT(14)
+#define RCC_PLL2CSGR_SSCG_MODE			BIT(15)
+#define RCC_PLL2CSGR_INC_STEP_MASK		GENMASK(30, 16)
+#define RCC_PLL2CSGR_INC_STEP_SHIFT		16
+
+/* RCC_PLL3CR register fields */
+#define RCC_PLL3CR_PLLON			BIT(0)
+#define RCC_PLL3CR_PLL3RDY			BIT(1)
+#define RCC_PLL3CR_SSCG_CTRL			BIT(2)
+#define RCC_PLL3CR_DIVPEN			BIT(4)
+#define RCC_PLL3CR_DIVQEN			BIT(5)
+#define RCC_PLL3CR_DIVREN			BIT(6)
+
+/* RCC_PLL3CFGR1 register fields */
+#define RCC_PLL3CFGR1_DIVN_MASK			GENMASK(8, 0)
+#define RCC_PLL3CFGR1_DIVN_SHIFT		0
+#define RCC_PLL3CFGR1_DIVM3_MASK		GENMASK(21, 16)
+#define RCC_PLL3CFGR1_DIVM3_SHIFT		16
+#define RCC_PLL3CFGR1_IFRGE_MASK		GENMASK(25, 24)
+#define RCC_PLL3CFGR1_IFRGE_SHIFT		24
+
+/* RCC_PLL3CFGR2 register fields */
+#define RCC_PLL3CFGR2_DIVP_MASK			GENMASK(6, 0)
+#define RCC_PLL3CFGR2_DIVP_SHIFT		0
+#define RCC_PLL3CFGR2_DIVQ_MASK			GENMASK(14, 8)
+#define RCC_PLL3CFGR2_DIVQ_SHIFT		8
+#define RCC_PLL3CFGR2_DIVR_MASK			GENMASK(22, 16)
+#define RCC_PLL3CFGR2_DIVR_SHIFT		16
+
+/* RCC_PLL3FRACR register fields */
+#define RCC_PLL3FRACR_FRACV_MASK		GENMASK(15, 3)
+#define RCC_PLL3FRACR_FRACV_SHIFT		3
+#define RCC_PLL3FRACR_FRACLE			BIT(16)
+
+/* RCC_PLL3CSGR register fields */
+#define RCC_PLL3CSGR_MOD_PER_MASK		GENMASK(12, 0)
+#define RCC_PLL3CSGR_MOD_PER_SHIFT		0
+#define RCC_PLL3CSGR_TPDFN_DIS			BIT(13)
+#define RCC_PLL3CSGR_RPDFN_DIS			BIT(14)
+#define RCC_PLL3CSGR_SSCG_MODE			BIT(15)
+#define RCC_PLL3CSGR_INC_STEP_MASK		GENMASK(30, 16)
+#define RCC_PLL3CSGR_INC_STEP_SHIFT		16
+
+/* RCC_PLL4CR register fields */
+#define RCC_PLL4CR_PLLON			BIT(0)
+#define RCC_PLL4CR_PLL4RDY			BIT(1)
+#define RCC_PLL4CR_SSCG_CTRL			BIT(2)
+#define RCC_PLL4CR_DIVPEN			BIT(4)
+#define RCC_PLL4CR_DIVQEN			BIT(5)
+#define RCC_PLL4CR_DIVREN			BIT(6)
+
+/* RCC_PLL4CFGR1 register fields */
+#define RCC_PLL4CFGR1_DIVN_MASK			GENMASK(8, 0)
+#define RCC_PLL4CFGR1_DIVN_SHIFT		0
+#define RCC_PLL4CFGR1_DIVM4_MASK		GENMASK(21, 16)
+#define RCC_PLL4CFGR1_DIVM4_SHIFT		16
+#define RCC_PLL4CFGR1_IFRGE_MASK		GENMASK(25, 24)
+#define RCC_PLL4CFGR1_IFRGE_SHIFT		24
+
+/* RCC_PLL4CFGR2 register fields */
+#define RCC_PLL4CFGR2_DIVP_MASK			GENMASK(6, 0)
+#define RCC_PLL4CFGR2_DIVP_SHIFT		0
+#define RCC_PLL4CFGR2_DIVQ_MASK			GENMASK(14, 8)
+#define RCC_PLL4CFGR2_DIVQ_SHIFT		8
+#define RCC_PLL4CFGR2_DIVR_MASK			GENMASK(22, 16)
+#define RCC_PLL4CFGR2_DIVR_SHIFT		16
+
+/* RCC_PLL4FRACR register fields */
+#define RCC_PLL4FRACR_FRACV_MASK		GENMASK(15, 3)
+#define RCC_PLL4FRACR_FRACV_SHIFT		3
+#define RCC_PLL4FRACR_FRACLE			BIT(16)
+
+/* RCC_PLL4CSGR register fields */
+#define RCC_PLL4CSGR_MOD_PER_MASK		GENMASK(12, 0)
+#define RCC_PLL4CSGR_MOD_PER_SHIFT		0
+#define RCC_PLL4CSGR_TPDFN_DIS			BIT(13)
+#define RCC_PLL4CSGR_RPDFN_DIS			BIT(14)
+#define RCC_PLL4CSGR_SSCG_MODE			BIT(15)
+#define RCC_PLL4CSGR_INC_STEP_MASK		GENMASK(30, 16)
+#define RCC_PLL4CSGR_INC_STEP_SHIFT		16
+
+/* RCC_MPCKSELR register fields */
+#define RCC_MPCKSELR_MPUSRC_MASK		GENMASK(1, 0)
+#define RCC_MPCKSELR_MPUSRC_SHIFT		0
+#define RCC_MPCKSELR_MPUSRCRDY			BIT(31)
+
+/* RCC_ASSCKSELR register fields */
+#define RCC_ASSCKSELR_AXISSRC_MASK		GENMASK(2, 0)
+#define RCC_ASSCKSELR_AXISSRC_SHIFT		0
+#define RCC_ASSCKSELR_AXISSRCRDY		BIT(31)
+
+/* RCC_MSSCKSELR register fields */
+#define RCC_MSSCKSELR_MLAHBSSRC_MASK		GENMASK(1, 0)
+#define RCC_MSSCKSELR_MLAHBSSRC_SHIFT		0
+#define RCC_MSSCKSELR_MLAHBSSRCRDY		BIT(31)
+
+/* RCC_CPERCKSELR register fields */
+#define RCC_CPERCKSELR_CKPERSRC_MASK		GENMASK(1, 0)
+#define RCC_CPERCKSELR_CKPERSRC_SHIFT		0
+
+/* RCC_RTCDIVR register fields */
+#define RCC_RTCDIVR_RTCDIV_MASK			GENMASK(5, 0)
+#define RCC_RTCDIVR_RTCDIV_SHIFT		0
+
+/* RCC_MPCKDIVR register fields */
+#define RCC_MPCKDIVR_MPUDIV_MASK		GENMASK(3, 0)
+#define RCC_MPCKDIVR_MPUDIV_SHIFT		0
+#define RCC_MPCKDIVR_MPUDIVRDY			BIT(31)
+
+/* RCC_AXIDIVR register fields */
+#define RCC_AXIDIVR_AXIDIV_MASK			GENMASK(2, 0)
+#define RCC_AXIDIVR_AXIDIV_SHIFT		0
+#define RCC_AXIDIVR_AXIDIVRDY			BIT(31)
+
+/* RCC_MLAHBDIVR register fields */
+#define RCC_MLAHBDIVR_MLAHBDIV_MASK		GENMASK(3, 0)
+#define RCC_MLAHBDIVR_MLAHBDIV_SHIFT		0
+#define RCC_MLAHBDIVR_MLAHBDIVRDY		BIT(31)
+
+/* RCC_APB1DIVR register fields */
+#define RCC_APB1DIVR_APB1DIV_MASK		GENMASK(2, 0)
+#define RCC_APB1DIVR_APB1DIV_SHIFT		0
+#define RCC_APB1DIVR_APB1DIVRDY			BIT(31)
+
+/* RCC_APB2DIVR register fields */
+#define RCC_APB2DIVR_APB2DIV_MASK		GENMASK(2, 0)
+#define RCC_APB2DIVR_APB2DIV_SHIFT		0
+#define RCC_APB2DIVR_APB2DIVRDY			BIT(31)
+
+/* RCC_APB3DIVR register fields */
+#define RCC_APB3DIVR_APB3DIV_MASK		GENMASK(2, 0)
+#define RCC_APB3DIVR_APB3DIV_SHIFT		0
+#define RCC_APB3DIVR_APB3DIVRDY			BIT(31)
+
+/* RCC_APB4DIVR register fields */
+#define RCC_APB4DIVR_APB4DIV_MASK		GENMASK(2, 0)
+#define RCC_APB4DIVR_APB4DIV_SHIFT		0
+#define RCC_APB4DIVR_APB4DIVRDY			BIT(31)
+
+/* RCC_APB5DIVR register fields */
+#define RCC_APB5DIVR_APB5DIV_MASK		GENMASK(2, 0)
+#define RCC_APB5DIVR_APB5DIV_SHIFT		0
+#define RCC_APB5DIVR_APB5DIVRDY			BIT(31)
+
+/* RCC_APB6DIVR register fields */
+#define RCC_APB6DIVR_APB6DIV_MASK		GENMASK(2, 0)
+#define RCC_APB6DIVR_APB6DIV_SHIFT		0
+#define RCC_APB6DIVR_APB6DIVRDY			BIT(31)
+
+/* RCC_TIMG1PRER register fields */
+#define RCC_TIMG1PRER_TIMG1PRE			BIT(0)
+#define RCC_TIMG1PRER_TIMG1PRERDY		BIT(31)
+
+/* RCC_TIMG2PRER register fields */
+#define RCC_TIMG2PRER_TIMG2PRE			BIT(0)
+#define RCC_TIMG2PRER_TIMG2PRERDY		BIT(31)
+
+/* RCC_TIMG3PRER register fields */
+#define RCC_TIMG3PRER_TIMG3PRE			BIT(0)
+#define RCC_TIMG3PRER_TIMG3PRERDY		BIT(31)
+
+/* RCC_DDRITFCR register fields */
+#define RCC_DDRITFCR_DDRC1EN			BIT(0)
+#define RCC_DDRITFCR_DDRC1LPEN			BIT(1)
+#define RCC_DDRITFCR_DDRPHYCEN			BIT(4)
+#define RCC_DDRITFCR_DDRPHYCLPEN		BIT(5)
+#define RCC_DDRITFCR_DDRCAPBEN			BIT(6)
+#define RCC_DDRITFCR_DDRCAPBLPEN		BIT(7)
+#define RCC_DDRITFCR_AXIDCGEN			BIT(8)
+#define RCC_DDRITFCR_DDRPHYCAPBEN		BIT(9)
+#define RCC_DDRITFCR_DDRPHYCAPBLPEN		BIT(10)
+#define RCC_DDRITFCR_KERDCG_DLY_MASK		GENMASK(13, 11)
+#define RCC_DDRITFCR_KERDCG_DLY_SHIFT		11
+#define RCC_DDRITFCR_DDRCAPBRST			BIT(14)
+#define RCC_DDRITFCR_DDRCAXIRST			BIT(15)
+#define RCC_DDRITFCR_DDRCORERST			BIT(16)
+#define RCC_DDRITFCR_DPHYAPBRST			BIT(17)
+#define RCC_DDRITFCR_DPHYRST			BIT(18)
+#define RCC_DDRITFCR_DPHYCTLRST			BIT(19)
+#define RCC_DDRITFCR_DDRCKMOD_MASK		GENMASK(22, 20)
+#define RCC_DDRITFCR_DDRCKMOD_SHIFT		20
+#define RCC_DDRITFCR_GSKPMOD			BIT(23)
+#define RCC_DDRITFCR_GSKPCTRL			BIT(24)
+#define RCC_DDRITFCR_DFILP_WIDTH_MASK		GENMASK(27, 25)
+#define RCC_DDRITFCR_DFILP_WIDTH_SHIFT		25
+#define RCC_DDRITFCR_GSKP_DUR_MASK		GENMASK(31, 28)
+#define RCC_DDRITFCR_GSKP_DUR_SHIFT		28
+
+/* RCC_I2C12CKSELR register fields */
+#define RCC_I2C12CKSELR_I2C12SRC_MASK		GENMASK(2, 0)
+#define RCC_I2C12CKSELR_I2C12SRC_SHIFT		0
+
+/* RCC_I2C345CKSELR register fields */
+#define RCC_I2C345CKSELR_I2C3SRC_MASK		GENMASK(2, 0)
+#define RCC_I2C345CKSELR_I2C3SRC_SHIFT		0
+#define RCC_I2C345CKSELR_I2C4SRC_MASK		GENMASK(5, 3)
+#define RCC_I2C345CKSELR_I2C4SRC_SHIFT		3
+#define RCC_I2C345CKSELR_I2C5SRC_MASK		GENMASK(8, 6)
+#define RCC_I2C345CKSELR_I2C5SRC_SHIFT		6
+
+/* RCC_SPI2S1CKSELR register fields */
+#define RCC_SPI2S1CKSELR_SPI1SRC_MASK		GENMASK(2, 0)
+#define RCC_SPI2S1CKSELR_SPI1SRC_SHIFT		0
+
+/* RCC_SPI2S23CKSELR register fields */
+#define RCC_SPI2S23CKSELR_SPI23SRC_MASK		GENMASK(2, 0)
+#define RCC_SPI2S23CKSELR_SPI23SRC_SHIFT	0
+
+/* RCC_SPI45CKSELR register fields */
+#define RCC_SPI45CKSELR_SPI4SRC_MASK		GENMASK(2, 0)
+#define RCC_SPI45CKSELR_SPI4SRC_SHIFT		0
+#define RCC_SPI45CKSELR_SPI5SRC_MASK		GENMASK(5, 3)
+#define RCC_SPI45CKSELR_SPI5SRC_SHIFT		3
+
+/* RCC_UART12CKSELR register fields */
+#define RCC_UART12CKSELR_UART1SRC_MASK		GENMASK(2, 0)
+#define RCC_UART12CKSELR_UART1SRC_SHIFT		0
+#define RCC_UART12CKSELR_UART2SRC_MASK		GENMASK(5, 3)
+#define RCC_UART12CKSELR_UART2SRC_SHIFT		3
+
+/* RCC_UART35CKSELR register fields */
+#define RCC_UART35CKSELR_UART35SRC_MASK		GENMASK(2, 0)
+#define RCC_UART35CKSELR_UART35SRC_SHIFT	0
+
+/* RCC_UART4CKSELR register fields */
+#define RCC_UART4CKSELR_UART4SRC_MASK		GENMASK(2, 0)
+#define RCC_UART4CKSELR_UART4SRC_SHIFT		0
+
+/* RCC_UART6CKSELR register fields */
+#define RCC_UART6CKSELR_UART6SRC_MASK		GENMASK(2, 0)
+#define RCC_UART6CKSELR_UART6SRC_SHIFT		0
+
+/* RCC_UART78CKSELR register fields */
+#define RCC_UART78CKSELR_UART78SRC_MASK		GENMASK(2, 0)
+#define RCC_UART78CKSELR_UART78SRC_SHIFT	0
+
+/* RCC_LPTIM1CKSELR register fields */
+#define RCC_LPTIM1CKSELR_LPTIM1SRC_MASK		GENMASK(2, 0)
+#define RCC_LPTIM1CKSELR_LPTIM1SRC_SHIFT	0
+
+/* RCC_LPTIM23CKSELR register fields */
+#define RCC_LPTIM23CKSELR_LPTIM2SRC_MASK	GENMASK(2, 0)
+#define RCC_LPTIM23CKSELR_LPTIM2SRC_SHIFT	0
+#define RCC_LPTIM23CKSELR_LPTIM3SRC_MASK	GENMASK(5, 3)
+#define RCC_LPTIM23CKSELR_LPTIM3SRC_SHIFT	3
+
+/* RCC_LPTIM45CKSELR register fields */
+#define RCC_LPTIM45CKSELR_LPTIM45SRC_MASK	GENMASK(2, 0)
+#define RCC_LPTIM45CKSELR_LPTIM45SRC_SHIFT	0
+
+/* RCC_SAI1CKSELR register fields */
+#define RCC_SAI1CKSELR_SAI1SRC_MASK		GENMASK(2, 0)
+#define RCC_SAI1CKSELR_SAI1SRC_SHIFT		0
+
+/* RCC_SAI2CKSELR register fields */
+#define RCC_SAI2CKSELR_SAI2SRC_MASK		GENMASK(2, 0)
+#define RCC_SAI2CKSELR_SAI2SRC_SHIFT		0
+
+/* RCC_FDCANCKSELR register fields */
+#define RCC_FDCANCKSELR_FDCANSRC_MASK		GENMASK(1, 0)
+#define RCC_FDCANCKSELR_FDCANSRC_SHIFT		0
+
+/* RCC_SPDIFCKSELR register fields */
+#define RCC_SPDIFCKSELR_SPDIFSRC_MASK		GENMASK(1, 0)
+#define RCC_SPDIFCKSELR_SPDIFSRC_SHIFT		0
+
+/* RCC_ADC12CKSELR register fields */
+#define RCC_ADC12CKSELR_ADC1SRC_MASK		GENMASK(1, 0)
+#define RCC_ADC12CKSELR_ADC1SRC_SHIFT		0
+#define RCC_ADC12CKSELR_ADC2SRC_MASK		GENMASK(3, 2)
+#define RCC_ADC12CKSELR_ADC2SRC_SHIFT		2
+
+/* RCC_SDMMC12CKSELR register fields */
+#define RCC_SDMMC12CKSELR_SDMMC1SRC_MASK	GENMASK(2, 0)
+#define RCC_SDMMC12CKSELR_SDMMC1SRC_SHIFT	0
+#define RCC_SDMMC12CKSELR_SDMMC2SRC_MASK	GENMASK(5, 3)
+#define RCC_SDMMC12CKSELR_SDMMC2SRC_SHIFT	3
+
+/* RCC_ETH12CKSELR register fields */
+#define RCC_ETH12CKSELR_ETH1SRC_MASK		GENMASK(1, 0)
+#define RCC_ETH12CKSELR_ETH1SRC_SHIFT		0
+#define RCC_ETH12CKSELR_ETH1PTPDIV_MASK		GENMASK(7, 4)
+#define RCC_ETH12CKSELR_ETH1PTPDIV_SHIFT	4
+#define RCC_ETH12CKSELR_ETH2SRC_MASK		GENMASK(9, 8)
+#define RCC_ETH12CKSELR_ETH2SRC_SHIFT		8
+#define RCC_ETH12CKSELR_ETH2PTPDIV_MASK		GENMASK(15, 12)
+#define RCC_ETH12CKSELR_ETH2PTPDIV_SHIFT	12
+
+/* RCC_USBCKSELR register fields */
+#define RCC_USBCKSELR_USBPHYSRC_MASK		GENMASK(1, 0)
+#define RCC_USBCKSELR_USBPHYSRC_SHIFT		0
+#define RCC_USBCKSELR_USBOSRC			BIT(4)
+
+/* RCC_QSPICKSELR register fields */
+#define RCC_QSPICKSELR_QSPISRC_MASK		GENMASK(1, 0)
+#define RCC_QSPICKSELR_QSPISRC_SHIFT		0
+
+/* RCC_FMCCKSELR register fields */
+#define RCC_FMCCKSELR_FMCSRC_MASK		GENMASK(1, 0)
+#define RCC_FMCCKSELR_FMCSRC_SHIFT		0
+
+/* RCC_RNG1CKSELR register fields */
+#define RCC_RNG1CKSELR_RNG1SRC_MASK		GENMASK(1, 0)
+#define RCC_RNG1CKSELR_RNG1SRC_SHIFT		0
+
+/* RCC_STGENCKSELR register fields */
+#define RCC_STGENCKSELR_STGENSRC_MASK		GENMASK(1, 0)
+#define RCC_STGENCKSELR_STGENSRC_SHIFT		0
+
+/* RCC_DCMIPPCKSELR register fields */
+#define RCC_DCMIPPCKSELR_DCMIPPSRC_MASK		GENMASK(1, 0)
+#define RCC_DCMIPPCKSELR_DCMIPPSRC_SHIFT	0
+
+/* RCC_SAESCKSELR register fields */
+#define RCC_SAESCKSELR_SAESSRC_MASK		GENMASK(1, 0)
+#define RCC_SAESCKSELR_SAESSRC_SHIFT		0
+
+/* RCC_APB1RSTSETR register fields */
+#define RCC_APB1RSTSETR_TIM2RST			BIT(0)
+#define RCC_APB1RSTSETR_TIM3RST			BIT(1)
+#define RCC_APB1RSTSETR_TIM4RST			BIT(2)
+#define RCC_APB1RSTSETR_TIM5RST			BIT(3)
+#define RCC_APB1RSTSETR_TIM6RST			BIT(4)
+#define RCC_APB1RSTSETR_TIM7RST			BIT(5)
+#define RCC_APB1RSTSETR_LPTIM1RST		BIT(9)
+#define RCC_APB1RSTSETR_SPI2RST			BIT(11)
+#define RCC_APB1RSTSETR_SPI3RST			BIT(12)
+#define RCC_APB1RSTSETR_USART3RST		BIT(15)
+#define RCC_APB1RSTSETR_UART4RST		BIT(16)
+#define RCC_APB1RSTSETR_UART5RST		BIT(17)
+#define RCC_APB1RSTSETR_UART7RST		BIT(18)
+#define RCC_APB1RSTSETR_UART8RST		BIT(19)
+#define RCC_APB1RSTSETR_I2C1RST			BIT(21)
+#define RCC_APB1RSTSETR_I2C2RST			BIT(22)
+#define RCC_APB1RSTSETR_SPDIFRST		BIT(26)
+
+/* RCC_APB1RSTCLRR register fields */
+#define RCC_APB1RSTCLRR_TIM2RST			BIT(0)
+#define RCC_APB1RSTCLRR_TIM3RST			BIT(1)
+#define RCC_APB1RSTCLRR_TIM4RST			BIT(2)
+#define RCC_APB1RSTCLRR_TIM5RST			BIT(3)
+#define RCC_APB1RSTCLRR_TIM6RST			BIT(4)
+#define RCC_APB1RSTCLRR_TIM7RST			BIT(5)
+#define RCC_APB1RSTCLRR_LPTIM1RST		BIT(9)
+#define RCC_APB1RSTCLRR_SPI2RST			BIT(11)
+#define RCC_APB1RSTCLRR_SPI3RST			BIT(12)
+#define RCC_APB1RSTCLRR_USART3RST		BIT(15)
+#define RCC_APB1RSTCLRR_UART4RST		BIT(16)
+#define RCC_APB1RSTCLRR_UART5RST		BIT(17)
+#define RCC_APB1RSTCLRR_UART7RST		BIT(18)
+#define RCC_APB1RSTCLRR_UART8RST		BIT(19)
+#define RCC_APB1RSTCLRR_I2C1RST			BIT(21)
+#define RCC_APB1RSTCLRR_I2C2RST			BIT(22)
+#define RCC_APB1RSTCLRR_SPDIFRST		BIT(26)
+
+/* RCC_APB2RSTSETR register fields */
+#define RCC_APB2RSTSETR_TIM1RST			BIT(0)
+#define RCC_APB2RSTSETR_TIM8RST			BIT(1)
+#define RCC_APB2RSTSETR_SPI1RST			BIT(8)
+#define RCC_APB2RSTSETR_USART6RST		BIT(13)
+#define RCC_APB2RSTSETR_SAI1RST			BIT(16)
+#define RCC_APB2RSTSETR_SAI2RST			BIT(17)
+#define RCC_APB2RSTSETR_DFSDMRST		BIT(20)
+#define RCC_APB2RSTSETR_FDCANRST		BIT(24)
+
+/* RCC_APB2RSTCLRR register fields */
+#define RCC_APB2RSTCLRR_TIM1RST			BIT(0)
+#define RCC_APB2RSTCLRR_TIM8RST			BIT(1)
+#define RCC_APB2RSTCLRR_SPI1RST			BIT(8)
+#define RCC_APB2RSTCLRR_USART6RST		BIT(13)
+#define RCC_APB2RSTCLRR_SAI1RST			BIT(16)
+#define RCC_APB2RSTCLRR_SAI2RST			BIT(17)
+#define RCC_APB2RSTCLRR_DFSDMRST		BIT(20)
+#define RCC_APB2RSTCLRR_FDCANRST		BIT(24)
+
+/* RCC_APB3RSTSETR register fields */
+#define RCC_APB3RSTSETR_LPTIM2RST		BIT(0)
+#define RCC_APB3RSTSETR_LPTIM3RST		BIT(1)
+#define RCC_APB3RSTSETR_LPTIM4RST		BIT(2)
+#define RCC_APB3RSTSETR_LPTIM5RST		BIT(3)
+#define RCC_APB3RSTSETR_SYSCFGRST		BIT(11)
+#define RCC_APB3RSTSETR_VREFRST			BIT(13)
+#define RCC_APB3RSTSETR_DTSRST			BIT(16)
+#define RCC_APB3RSTSETR_PMBCTRLRST		BIT(17)
+
+/* RCC_APB3RSTCLRR register fields */
+#define RCC_APB3RSTCLRR_LPTIM2RST		BIT(0)
+#define RCC_APB3RSTCLRR_LPTIM3RST		BIT(1)
+#define RCC_APB3RSTCLRR_LPTIM4RST		BIT(2)
+#define RCC_APB3RSTCLRR_LPTIM5RST		BIT(3)
+#define RCC_APB3RSTCLRR_SYSCFGRST		BIT(11)
+#define RCC_APB3RSTCLRR_VREFRST			BIT(13)
+#define RCC_APB3RSTCLRR_DTSRST			BIT(16)
+#define RCC_APB3RSTCLRR_PMBCTRLRST		BIT(17)
+
+/* RCC_APB4RSTSETR register fields */
+#define RCC_APB4RSTSETR_LTDCRST			BIT(0)
+#define RCC_APB4RSTSETR_DCMIPPRST		BIT(1)
+#define RCC_APB4RSTSETR_DDRPERFMRST		BIT(8)
+#define RCC_APB4RSTSETR_USBPHYRST		BIT(16)
+
+/* RCC_APB4RSTCLRR register fields */
+#define RCC_APB4RSTCLRR_LTDCRST			BIT(0)
+#define RCC_APB4RSTCLRR_DCMIPPRST		BIT(1)
+#define RCC_APB4RSTCLRR_DDRPERFMRST		BIT(8)
+#define RCC_APB4RSTCLRR_USBPHYRST		BIT(16)
+
+/* RCC_APB5RSTSETR register fields */
+#define RCC_APB5RSTSETR_STGENRST		BIT(20)
+
+/* RCC_APB5RSTCLRR register fields */
+#define RCC_APB5RSTCLRR_STGENRST		BIT(20)
+
+/* RCC_APB6RSTSETR register fields */
+#define RCC_APB6RSTSETR_USART1RST		BIT(0)
+#define RCC_APB6RSTSETR_USART2RST		BIT(1)
+#define RCC_APB6RSTSETR_SPI4RST			BIT(2)
+#define RCC_APB6RSTSETR_SPI5RST			BIT(3)
+#define RCC_APB6RSTSETR_I2C3RST			BIT(4)
+#define RCC_APB6RSTSETR_I2C4RST			BIT(5)
+#define RCC_APB6RSTSETR_I2C5RST			BIT(6)
+#define RCC_APB6RSTSETR_TIM12RST		BIT(7)
+#define RCC_APB6RSTSETR_TIM13RST		BIT(8)
+#define RCC_APB6RSTSETR_TIM14RST		BIT(9)
+#define RCC_APB6RSTSETR_TIM15RST		BIT(10)
+#define RCC_APB6RSTSETR_TIM16RST		BIT(11)
+#define RCC_APB6RSTSETR_TIM17RST		BIT(12)
+
+/* RCC_APB6RSTCLRR register fields */
+#define RCC_APB6RSTCLRR_USART1RST		BIT(0)
+#define RCC_APB6RSTCLRR_USART2RST		BIT(1)
+#define RCC_APB6RSTCLRR_SPI4RST			BIT(2)
+#define RCC_APB6RSTCLRR_SPI5RST			BIT(3)
+#define RCC_APB6RSTCLRR_I2C3RST			BIT(4)
+#define RCC_APB6RSTCLRR_I2C4RST			BIT(5)
+#define RCC_APB6RSTCLRR_I2C5RST			BIT(6)
+#define RCC_APB6RSTCLRR_TIM12RST		BIT(7)
+#define RCC_APB6RSTCLRR_TIM13RST		BIT(8)
+#define RCC_APB6RSTCLRR_TIM14RST		BIT(9)
+#define RCC_APB6RSTCLRR_TIM15RST		BIT(10)
+#define RCC_APB6RSTCLRR_TIM16RST		BIT(11)
+#define RCC_APB6RSTCLRR_TIM17RST		BIT(12)
+
+/* RCC_AHB2RSTSETR register fields */
+#define RCC_AHB2RSTSETR_DMA1RST			BIT(0)
+#define RCC_AHB2RSTSETR_DMA2RST			BIT(1)
+#define RCC_AHB2RSTSETR_DMAMUX1RST		BIT(2)
+#define RCC_AHB2RSTSETR_DMA3RST			BIT(3)
+#define RCC_AHB2RSTSETR_DMAMUX2RST		BIT(4)
+#define RCC_AHB2RSTSETR_ADC1RST			BIT(5)
+#define RCC_AHB2RSTSETR_ADC2RST			BIT(6)
+#define RCC_AHB2RSTSETR_USBORST			BIT(8)
+
+/* RCC_AHB2RSTCLRR register fields */
+#define RCC_AHB2RSTCLRR_DMA1RST			BIT(0)
+#define RCC_AHB2RSTCLRR_DMA2RST			BIT(1)
+#define RCC_AHB2RSTCLRR_DMAMUX1RST		BIT(2)
+#define RCC_AHB2RSTCLRR_DMA3RST			BIT(3)
+#define RCC_AHB2RSTCLRR_DMAMUX2RST		BIT(4)
+#define RCC_AHB2RSTCLRR_ADC1RST			BIT(5)
+#define RCC_AHB2RSTCLRR_ADC2RST			BIT(6)
+#define RCC_AHB2RSTCLRR_USBORST			BIT(8)
+
+/* RCC_AHB4RSTSETR register fields */
+#define RCC_AHB4RSTSETR_GPIOARST		BIT(0)
+#define RCC_AHB4RSTSETR_GPIOBRST		BIT(1)
+#define RCC_AHB4RSTSETR_GPIOCRST		BIT(2)
+#define RCC_AHB4RSTSETR_GPIODRST		BIT(3)
+#define RCC_AHB4RSTSETR_GPIOERST		BIT(4)
+#define RCC_AHB4RSTSETR_GPIOFRST		BIT(5)
+#define RCC_AHB4RSTSETR_GPIOGRST		BIT(6)
+#define RCC_AHB4RSTSETR_GPIOHRST		BIT(7)
+#define RCC_AHB4RSTSETR_GPIOIRST		BIT(8)
+#define RCC_AHB4RSTSETR_TSCRST			BIT(15)
+
+/* RCC_AHB4RSTCLRR register fields */
+#define RCC_AHB4RSTCLRR_GPIOARST		BIT(0)
+#define RCC_AHB4RSTCLRR_GPIOBRST		BIT(1)
+#define RCC_AHB4RSTCLRR_GPIOCRST		BIT(2)
+#define RCC_AHB4RSTCLRR_GPIODRST		BIT(3)
+#define RCC_AHB4RSTCLRR_GPIOERST		BIT(4)
+#define RCC_AHB4RSTCLRR_GPIOFRST		BIT(5)
+#define RCC_AHB4RSTCLRR_GPIOGRST		BIT(6)
+#define RCC_AHB4RSTCLRR_GPIOHRST		BIT(7)
+#define RCC_AHB4RSTCLRR_GPIOIRST		BIT(8)
+#define RCC_AHB4RSTCLRR_TSCRST			BIT(15)
+
+/* RCC_AHB5RSTSETR register fields */
+#define RCC_AHB5RSTSETR_PKARST			BIT(2)
+#define RCC_AHB5RSTSETR_SAESRST			BIT(3)
+#define RCC_AHB5RSTSETR_CRYP1RST		BIT(4)
+#define RCC_AHB5RSTSETR_HASH1RST		BIT(5)
+#define RCC_AHB5RSTSETR_RNG1RST			BIT(6)
+#define RCC_AHB5RSTSETR_AXIMCRST		BIT(16)
+
+/* RCC_AHB5RSTCLRR register fields */
+#define RCC_AHB5RSTCLRR_PKARST			BIT(2)
+#define RCC_AHB5RSTCLRR_SAESRST			BIT(3)
+#define RCC_AHB5RSTCLRR_CRYP1RST		BIT(4)
+#define RCC_AHB5RSTCLRR_HASH1RST		BIT(5)
+#define RCC_AHB5RSTCLRR_RNG1RST			BIT(6)
+#define RCC_AHB5RSTCLRR_AXIMCRST		BIT(16)
+
+/* RCC_AHB6RSTSETR register fields */
+#define RCC_AHB6RSTSETR_MDMARST			BIT(0)
+#define RCC_AHB6RSTSETR_MCERST			BIT(1)
+#define RCC_AHB6RSTSETR_ETH1MACRST		BIT(10)
+#define RCC_AHB6RSTSETR_FMCRST			BIT(12)
+#define RCC_AHB6RSTSETR_QSPIRST			BIT(14)
+#define RCC_AHB6RSTSETR_SDMMC1RST		BIT(16)
+#define RCC_AHB6RSTSETR_SDMMC2RST		BIT(17)
+#define RCC_AHB6RSTSETR_CRC1RST			BIT(20)
+#define RCC_AHB6RSTSETR_USBHRST			BIT(24)
+#define RCC_AHB6RSTSETR_ETH2MACRST		BIT(30)
+
+/* RCC_AHB6RSTCLRR register fields */
+#define RCC_AHB6RSTCLRR_MDMARST			BIT(0)
+#define RCC_AHB6RSTCLRR_MCERST			BIT(1)
+#define RCC_AHB6RSTCLRR_ETH1MACRST		BIT(10)
+#define RCC_AHB6RSTCLRR_FMCRST			BIT(12)
+#define RCC_AHB6RSTCLRR_QSPIRST			BIT(14)
+#define RCC_AHB6RSTCLRR_SDMMC1RST		BIT(16)
+#define RCC_AHB6RSTCLRR_SDMMC2RST		BIT(17)
+#define RCC_AHB6RSTCLRR_CRC1RST			BIT(20)
+#define RCC_AHB6RSTCLRR_USBHRST			BIT(24)
+#define RCC_AHB6RSTCLRR_ETH2MACRST		BIT(30)
+
+/* RCC_MP_APB1ENSETR register fields */
+#define RCC_MP_APB1ENSETR_TIM2EN		BIT(0)
+#define RCC_MP_APB1ENSETR_TIM3EN		BIT(1)
+#define RCC_MP_APB1ENSETR_TIM4EN		BIT(2)
+#define RCC_MP_APB1ENSETR_TIM5EN		BIT(3)
+#define RCC_MP_APB1ENSETR_TIM6EN		BIT(4)
+#define RCC_MP_APB1ENSETR_TIM7EN		BIT(5)
+#define RCC_MP_APB1ENSETR_LPTIM1EN		BIT(9)
+#define RCC_MP_APB1ENSETR_SPI2EN		BIT(11)
+#define RCC_MP_APB1ENSETR_SPI3EN		BIT(12)
+#define RCC_MP_APB1ENSETR_USART3EN		BIT(15)
+#define RCC_MP_APB1ENSETR_UART4EN		BIT(16)
+#define RCC_MP_APB1ENSETR_UART5EN		BIT(17)
+#define RCC_MP_APB1ENSETR_UART7EN		BIT(18)
+#define RCC_MP_APB1ENSETR_UART8EN		BIT(19)
+#define RCC_MP_APB1ENSETR_I2C1EN		BIT(21)
+#define RCC_MP_APB1ENSETR_I2C2EN		BIT(22)
+#define RCC_MP_APB1ENSETR_SPDIFEN		BIT(26)
+
+/* RCC_MP_APB1ENCLRR register fields */
+#define RCC_MP_APB1ENCLRR_TIM2EN		BIT(0)
+#define RCC_MP_APB1ENCLRR_TIM3EN		BIT(1)
+#define RCC_MP_APB1ENCLRR_TIM4EN		BIT(2)
+#define RCC_MP_APB1ENCLRR_TIM5EN		BIT(3)
+#define RCC_MP_APB1ENCLRR_TIM6EN		BIT(4)
+#define RCC_MP_APB1ENCLRR_TIM7EN		BIT(5)
+#define RCC_MP_APB1ENCLRR_LPTIM1EN		BIT(9)
+#define RCC_MP_APB1ENCLRR_SPI2EN		BIT(11)
+#define RCC_MP_APB1ENCLRR_SPI3EN		BIT(12)
+#define RCC_MP_APB1ENCLRR_USART3EN		BIT(15)
+#define RCC_MP_APB1ENCLRR_UART4EN		BIT(16)
+#define RCC_MP_APB1ENCLRR_UART5EN		BIT(17)
+#define RCC_MP_APB1ENCLRR_UART7EN		BIT(18)
+#define RCC_MP_APB1ENCLRR_UART8EN		BIT(19)
+#define RCC_MP_APB1ENCLRR_I2C1EN		BIT(21)
+#define RCC_MP_APB1ENCLRR_I2C2EN		BIT(22)
+#define RCC_MP_APB1ENCLRR_SPDIFEN		BIT(26)
+
+/* RCC_MP_APB2ENSETR register fields */
+#define RCC_MP_APB2ENSETR_TIM1EN		BIT(0)
+#define RCC_MP_APB2ENSETR_TIM8EN		BIT(1)
+#define RCC_MP_APB2ENSETR_SPI1EN		BIT(8)
+#define RCC_MP_APB2ENSETR_USART6EN		BIT(13)
+#define RCC_MP_APB2ENSETR_SAI1EN		BIT(16)
+#define RCC_MP_APB2ENSETR_SAI2EN		BIT(17)
+#define RCC_MP_APB2ENSETR_DFSDMEN		BIT(20)
+#define RCC_MP_APB2ENSETR_ADFSDMEN		BIT(21)
+#define RCC_MP_APB2ENSETR_FDCANEN		BIT(24)
+
+/* RCC_MP_APB2ENCLRR register fields */
+#define RCC_MP_APB2ENCLRR_TIM1EN		BIT(0)
+#define RCC_MP_APB2ENCLRR_TIM8EN		BIT(1)
+#define RCC_MP_APB2ENCLRR_SPI1EN		BIT(8)
+#define RCC_MP_APB2ENCLRR_USART6EN		BIT(13)
+#define RCC_MP_APB2ENCLRR_SAI1EN		BIT(16)
+#define RCC_MP_APB2ENCLRR_SAI2EN		BIT(17)
+#define RCC_MP_APB2ENCLRR_DFSDMEN		BIT(20)
+#define RCC_MP_APB2ENCLRR_ADFSDMEN		BIT(21)
+#define RCC_MP_APB2ENCLRR_FDCANEN		BIT(24)
+
+/* RCC_MP_APB3ENSETR register fields */
+#define RCC_MP_APB3ENSETR_LPTIM2EN		BIT(0)
+#define RCC_MP_APB3ENSETR_LPTIM3EN		BIT(1)
+#define RCC_MP_APB3ENSETR_LPTIM4EN		BIT(2)
+#define RCC_MP_APB3ENSETR_LPTIM5EN		BIT(3)
+#define RCC_MP_APB3ENSETR_VREFEN		BIT(13)
+#define RCC_MP_APB3ENSETR_DTSEN			BIT(16)
+#define RCC_MP_APB3ENSETR_PMBCTRLEN		BIT(17)
+#define RCC_MP_APB3ENSETR_HDPEN			BIT(20)
+
+/* RCC_MP_APB3ENCLRR register fields */
+#define RCC_MP_APB3ENCLRR_LPTIM2EN		BIT(0)
+#define RCC_MP_APB3ENCLRR_LPTIM3EN		BIT(1)
+#define RCC_MP_APB3ENCLRR_LPTIM4EN		BIT(2)
+#define RCC_MP_APB3ENCLRR_LPTIM5EN		BIT(3)
+#define RCC_MP_APB3ENCLRR_VREFEN		BIT(13)
+#define RCC_MP_APB3ENCLRR_DTSEN			BIT(16)
+#define RCC_MP_APB3ENCLRR_PMBCTRLEN		BIT(17)
+#define RCC_MP_APB3ENCLRR_HDPEN			BIT(20)
+
+/* RCC_MP_S_APB3ENSETR register fields */
+#define RCC_MP_S_APB3ENSETR_SYSCFGEN		BIT(0)
+
+/* RCC_MP_S_APB3ENCLRR register fields */
+#define RCC_MP_S_APB3ENCLRR_SYSCFGEN		BIT(0)
+
+/* RCC_MP_NS_APB3ENSETR register fields */
+#define RCC_MP_NS_APB3ENSETR_SYSCFGEN		BIT(0)
+
+/* RCC_MP_NS_APB3ENCLRR register fields */
+#define RCC_MP_NS_APB3ENCLRR_SYSCFGEN		BIT(0)
+
+/* RCC_MP_APB4ENSETR register fields */
+#define RCC_MP_APB4ENSETR_DCMIPPEN		BIT(1)
+#define RCC_MP_APB4ENSETR_DDRPERFMEN		BIT(8)
+#define RCC_MP_APB4ENSETR_IWDG2APBEN		BIT(15)
+#define RCC_MP_APB4ENSETR_USBPHYEN		BIT(16)
+#define RCC_MP_APB4ENSETR_STGENROEN		BIT(20)
+
+/* RCC_MP_APB4ENCLRR register fields */
+#define RCC_MP_APB4ENCLRR_DCMIPPEN		BIT(1)
+#define RCC_MP_APB4ENCLRR_DDRPERFMEN		BIT(8)
+#define RCC_MP_APB4ENCLRR_IWDG2APBEN		BIT(15)
+#define RCC_MP_APB4ENCLRR_USBPHYEN		BIT(16)
+#define RCC_MP_APB4ENCLRR_STGENROEN		BIT(20)
+
+/* RCC_MP_S_APB4ENSETR register fields */
+#define RCC_MP_S_APB4ENSETR_LTDCEN		BIT(0)
+
+/* RCC_MP_S_APB4ENCLRR register fields */
+#define RCC_MP_S_APB4ENCLRR_LTDCEN		BIT(0)
+
+/* RCC_MP_NS_APB4ENSETR register fields */
+#define RCC_MP_NS_APB4ENSETR_LTDCEN		BIT(0)
+
+/* RCC_MP_NS_APB4ENCLRR register fields */
+#define RCC_MP_NS_APB4ENCLRR_LTDCEN		BIT(0)
+
+/* RCC_MP_APB5ENSETR register fields */
+#define RCC_MP_APB5ENSETR_RTCAPBEN		BIT(8)
+#define RCC_MP_APB5ENSETR_TZCEN			BIT(11)
+#define RCC_MP_APB5ENSETR_ETZPCEN		BIT(13)
+#define RCC_MP_APB5ENSETR_IWDG1APBEN		BIT(15)
+#define RCC_MP_APB5ENSETR_BSECEN		BIT(16)
+#define RCC_MP_APB5ENSETR_STGENCEN		BIT(20)
+
+/* RCC_MP_APB5ENCLRR register fields */
+#define RCC_MP_APB5ENCLRR_RTCAPBEN		BIT(8)
+#define RCC_MP_APB5ENCLRR_TZCEN			BIT(11)
+#define RCC_MP_APB5ENCLRR_ETZPCEN		BIT(13)
+#define RCC_MP_APB5ENCLRR_IWDG1APBEN		BIT(15)
+#define RCC_MP_APB5ENCLRR_BSECEN		BIT(16)
+#define RCC_MP_APB5ENCLRR_STGENCEN		BIT(20)
+
+/* RCC_MP_APB6ENSETR register fields */
+#define RCC_MP_APB6ENSETR_USART1EN		BIT(0)
+#define RCC_MP_APB6ENSETR_USART2EN		BIT(1)
+#define RCC_MP_APB6ENSETR_SPI4EN		BIT(2)
+#define RCC_MP_APB6ENSETR_SPI5EN		BIT(3)
+#define RCC_MP_APB6ENSETR_I2C3EN		BIT(4)
+#define RCC_MP_APB6ENSETR_I2C4EN		BIT(5)
+#define RCC_MP_APB6ENSETR_I2C5EN		BIT(6)
+#define RCC_MP_APB6ENSETR_TIM12EN		BIT(7)
+#define RCC_MP_APB6ENSETR_TIM13EN		BIT(8)
+#define RCC_MP_APB6ENSETR_TIM14EN		BIT(9)
+#define RCC_MP_APB6ENSETR_TIM15EN		BIT(10)
+#define RCC_MP_APB6ENSETR_TIM16EN		BIT(11)
+#define RCC_MP_APB6ENSETR_TIM17EN		BIT(12)
+
+/* RCC_MP_APB6ENCLRR register fields */
+#define RCC_MP_APB6ENCLRR_USART1EN		BIT(0)
+#define RCC_MP_APB6ENCLRR_USART2EN		BIT(1)
+#define RCC_MP_APB6ENCLRR_SPI4EN		BIT(2)
+#define RCC_MP_APB6ENCLRR_SPI5EN		BIT(3)
+#define RCC_MP_APB6ENCLRR_I2C3EN		BIT(4)
+#define RCC_MP_APB6ENCLRR_I2C4EN		BIT(5)
+#define RCC_MP_APB6ENCLRR_I2C5EN		BIT(6)
+#define RCC_MP_APB6ENCLRR_TIM12EN		BIT(7)
+#define RCC_MP_APB6ENCLRR_TIM13EN		BIT(8)
+#define RCC_MP_APB6ENCLRR_TIM14EN		BIT(9)
+#define RCC_MP_APB6ENCLRR_TIM15EN		BIT(10)
+#define RCC_MP_APB6ENCLRR_TIM16EN		BIT(11)
+#define RCC_MP_APB6ENCLRR_TIM17EN		BIT(12)
+
+/* RCC_MP_AHB2ENSETR register fields */
+#define RCC_MP_AHB2ENSETR_DMA1EN		BIT(0)
+#define RCC_MP_AHB2ENSETR_DMA2EN		BIT(1)
+#define RCC_MP_AHB2ENSETR_DMAMUX1EN		BIT(2)
+#define RCC_MP_AHB2ENSETR_DMA3EN		BIT(3)
+#define RCC_MP_AHB2ENSETR_DMAMUX2EN		BIT(4)
+#define RCC_MP_AHB2ENSETR_ADC1EN		BIT(5)
+#define RCC_MP_AHB2ENSETR_ADC2EN		BIT(6)
+#define RCC_MP_AHB2ENSETR_USBOEN		BIT(8)
+
+/* RCC_MP_AHB2ENCLRR register fields */
+#define RCC_MP_AHB2ENCLRR_DMA1EN		BIT(0)
+#define RCC_MP_AHB2ENCLRR_DMA2EN		BIT(1)
+#define RCC_MP_AHB2ENCLRR_DMAMUX1EN		BIT(2)
+#define RCC_MP_AHB2ENCLRR_DMA3EN		BIT(3)
+#define RCC_MP_AHB2ENCLRR_DMAMUX2EN		BIT(4)
+#define RCC_MP_AHB2ENCLRR_ADC1EN		BIT(5)
+#define RCC_MP_AHB2ENCLRR_ADC2EN		BIT(6)
+#define RCC_MP_AHB2ENCLRR_USBOEN		BIT(8)
+
+/* RCC_MP_AHB4ENSETR register fields */
+#define RCC_MP_AHB4ENSETR_TSCEN			BIT(15)
+
+/* RCC_MP_AHB4ENCLRR register fields */
+#define RCC_MP_AHB4ENCLRR_TSCEN			BIT(15)
+
+/* RCC_MP_S_AHB4ENSETR register fields */
+#define RCC_MP_S_AHB4ENSETR_GPIOAEN		BIT(0)
+#define RCC_MP_S_AHB4ENSETR_GPIOBEN		BIT(1)
+#define RCC_MP_S_AHB4ENSETR_GPIOCEN		BIT(2)
+#define RCC_MP_S_AHB4ENSETR_GPIODEN		BIT(3)
+#define RCC_MP_S_AHB4ENSETR_GPIOEEN		BIT(4)
+#define RCC_MP_S_AHB4ENSETR_GPIOFEN		BIT(5)
+#define RCC_MP_S_AHB4ENSETR_GPIOGEN		BIT(6)
+#define RCC_MP_S_AHB4ENSETR_GPIOHEN		BIT(7)
+#define RCC_MP_S_AHB4ENSETR_GPIOIEN		BIT(8)
+
+/* RCC_MP_S_AHB4ENCLRR register fields */
+#define RCC_MP_S_AHB4ENCLRR_GPIOAEN		BIT(0)
+#define RCC_MP_S_AHB4ENCLRR_GPIOBEN		BIT(1)
+#define RCC_MP_S_AHB4ENCLRR_GPIOCEN		BIT(2)
+#define RCC_MP_S_AHB4ENCLRR_GPIODEN		BIT(3)
+#define RCC_MP_S_AHB4ENCLRR_GPIOEEN		BIT(4)
+#define RCC_MP_S_AHB4ENCLRR_GPIOFEN		BIT(5)
+#define RCC_MP_S_AHB4ENCLRR_GPIOGEN		BIT(6)
+#define RCC_MP_S_AHB4ENCLRR_GPIOHEN		BIT(7)
+#define RCC_MP_S_AHB4ENCLRR_GPIOIEN		BIT(8)
+
+/* RCC_MP_NS_AHB4ENSETR register fields */
+#define RCC_MP_NS_AHB4ENSETR_GPIOAEN		BIT(0)
+#define RCC_MP_NS_AHB4ENSETR_GPIOBEN		BIT(1)
+#define RCC_MP_NS_AHB4ENSETR_GPIOCEN		BIT(2)
+#define RCC_MP_NS_AHB4ENSETR_GPIODEN		BIT(3)
+#define RCC_MP_NS_AHB4ENSETR_GPIOEEN		BIT(4)
+#define RCC_MP_NS_AHB4ENSETR_GPIOFEN		BIT(5)
+#define RCC_MP_NS_AHB4ENSETR_GPIOGEN		BIT(6)
+#define RCC_MP_NS_AHB4ENSETR_GPIOHEN		BIT(7)
+#define RCC_MP_NS_AHB4ENSETR_GPIOIEN		BIT(8)
+
+/* RCC_MP_NS_AHB4ENCLRR register fields */
+#define RCC_MP_NS_AHB4ENCLRR_GPIOAEN		BIT(0)
+#define RCC_MP_NS_AHB4ENCLRR_GPIOBEN		BIT(1)
+#define RCC_MP_NS_AHB4ENCLRR_GPIOCEN		BIT(2)
+#define RCC_MP_NS_AHB4ENCLRR_GPIODEN		BIT(3)
+#define RCC_MP_NS_AHB4ENCLRR_GPIOEEN		BIT(4)
+#define RCC_MP_NS_AHB4ENCLRR_GPIOFEN		BIT(5)
+#define RCC_MP_NS_AHB4ENCLRR_GPIOGEN		BIT(6)
+#define RCC_MP_NS_AHB4ENCLRR_GPIOHEN		BIT(7)
+#define RCC_MP_NS_AHB4ENCLRR_GPIOIEN		BIT(8)
+
+/* RCC_MP_AHB5ENSETR register fields */
+#define RCC_MP_AHB5ENSETR_PKAEN			BIT(2)
+#define RCC_MP_AHB5ENSETR_SAESEN		BIT(3)
+#define RCC_MP_AHB5ENSETR_CRYP1EN		BIT(4)
+#define RCC_MP_AHB5ENSETR_HASH1EN		BIT(5)
+#define RCC_MP_AHB5ENSETR_RNG1EN		BIT(6)
+#define RCC_MP_AHB5ENSETR_BKPSRAMEN		BIT(8)
+#define RCC_MP_AHB5ENSETR_AXIMCEN		BIT(16)
+
+/* RCC_MP_AHB5ENCLRR register fields */
+#define RCC_MP_AHB5ENCLRR_PKAEN			BIT(2)
+#define RCC_MP_AHB5ENCLRR_SAESEN		BIT(3)
+#define RCC_MP_AHB5ENCLRR_CRYP1EN		BIT(4)
+#define RCC_MP_AHB5ENCLRR_HASH1EN		BIT(5)
+#define RCC_MP_AHB5ENCLRR_RNG1EN		BIT(6)
+#define RCC_MP_AHB5ENCLRR_BKPSRAMEN		BIT(8)
+#define RCC_MP_AHB5ENCLRR_AXIMCEN		BIT(16)
+
+/* RCC_MP_AHB6ENSETR register fields */
+#define RCC_MP_AHB6ENSETR_MCEEN			BIT(1)
+#define RCC_MP_AHB6ENSETR_ETH1CKEN		BIT(7)
+#define RCC_MP_AHB6ENSETR_ETH1TXEN		BIT(8)
+#define RCC_MP_AHB6ENSETR_ETH1RXEN		BIT(9)
+#define RCC_MP_AHB6ENSETR_ETH1MACEN		BIT(10)
+#define RCC_MP_AHB6ENSETR_FMCEN			BIT(12)
+#define RCC_MP_AHB6ENSETR_QSPIEN		BIT(14)
+#define RCC_MP_AHB6ENSETR_SDMMC1EN		BIT(16)
+#define RCC_MP_AHB6ENSETR_SDMMC2EN		BIT(17)
+#define RCC_MP_AHB6ENSETR_CRC1EN		BIT(20)
+#define RCC_MP_AHB6ENSETR_USBHEN		BIT(24)
+#define RCC_MP_AHB6ENSETR_ETH2CKEN		BIT(27)
+#define RCC_MP_AHB6ENSETR_ETH2TXEN		BIT(28)
+#define RCC_MP_AHB6ENSETR_ETH2RXEN		BIT(29)
+#define RCC_MP_AHB6ENSETR_ETH2MACEN		BIT(30)
+
+/* RCC_MP_AHB6ENCLRR register fields */
+#define RCC_MP_AHB6ENCLRR_MCEEN			BIT(1)
+#define RCC_MP_AHB6ENCLRR_ETH1CKEN		BIT(7)
+#define RCC_MP_AHB6ENCLRR_ETH1TXEN		BIT(8)
+#define RCC_MP_AHB6ENCLRR_ETH1RXEN		BIT(9)
+#define RCC_MP_AHB6ENCLRR_ETH1MACEN		BIT(10)
+#define RCC_MP_AHB6ENCLRR_FMCEN			BIT(12)
+#define RCC_MP_AHB6ENCLRR_QSPIEN		BIT(14)
+#define RCC_MP_AHB6ENCLRR_SDMMC1EN		BIT(16)
+#define RCC_MP_AHB6ENCLRR_SDMMC2EN		BIT(17)
+#define RCC_MP_AHB6ENCLRR_CRC1EN		BIT(20)
+#define RCC_MP_AHB6ENCLRR_USBHEN		BIT(24)
+#define RCC_MP_AHB6ENCLRR_ETH2CKEN		BIT(27)
+#define RCC_MP_AHB6ENCLRR_ETH2TXEN		BIT(28)
+#define RCC_MP_AHB6ENCLRR_ETH2RXEN		BIT(29)
+#define RCC_MP_AHB6ENCLRR_ETH2MACEN		BIT(30)
+
+/* RCC_MP_S_AHB6ENSETR register fields */
+#define RCC_MP_S_AHB6ENSETR_MDMAEN		BIT(0)
+
+/* RCC_MP_S_AHB6ENCLRR register fields */
+#define RCC_MP_S_AHB6ENCLRR_MDMAEN		BIT(0)
+
+/* RCC_MP_NS_AHB6ENSETR register fields */
+#define RCC_MP_NS_AHB6ENSETR_MDMAEN		BIT(0)
+
+/* RCC_MP_NS_AHB6ENCLRR register fields */
+#define RCC_MP_NS_AHB6ENCLRR_MDMAEN		BIT(0)
+
+/* RCC_MP_APB1LPENSETR register fields */
+#define RCC_MP_APB1LPENSETR_TIM2LPEN		BIT(0)
+#define RCC_MP_APB1LPENSETR_TIM3LPEN		BIT(1)
+#define RCC_MP_APB1LPENSETR_TIM4LPEN		BIT(2)
+#define RCC_MP_APB1LPENSETR_TIM5LPEN		BIT(3)
+#define RCC_MP_APB1LPENSETR_TIM6LPEN		BIT(4)
+#define RCC_MP_APB1LPENSETR_TIM7LPEN		BIT(5)
+#define RCC_MP_APB1LPENSETR_LPTIM1LPEN		BIT(9)
+#define RCC_MP_APB1LPENSETR_SPI2LPEN		BIT(11)
+#define RCC_MP_APB1LPENSETR_SPI3LPEN		BIT(12)
+#define RCC_MP_APB1LPENSETR_USART3LPEN		BIT(15)
+#define RCC_MP_APB1LPENSETR_UART4LPEN		BIT(16)
+#define RCC_MP_APB1LPENSETR_UART5LPEN		BIT(17)
+#define RCC_MP_APB1LPENSETR_UART7LPEN		BIT(18)
+#define RCC_MP_APB1LPENSETR_UART8LPEN		BIT(19)
+#define RCC_MP_APB1LPENSETR_I2C1LPEN		BIT(21)
+#define RCC_MP_APB1LPENSETR_I2C2LPEN		BIT(22)
+#define RCC_MP_APB1LPENSETR_SPDIFLPEN		BIT(26)
+
+/* RCC_MP_APB1LPENCLRR register fields */
+#define RCC_MP_APB1LPENCLRR_TIM2LPEN		BIT(0)
+#define RCC_MP_APB1LPENCLRR_TIM3LPEN		BIT(1)
+#define RCC_MP_APB1LPENCLRR_TIM4LPEN		BIT(2)
+#define RCC_MP_APB1LPENCLRR_TIM5LPEN		BIT(3)
+#define RCC_MP_APB1LPENCLRR_TIM6LPEN		BIT(4)
+#define RCC_MP_APB1LPENCLRR_TIM7LPEN		BIT(5)
+#define RCC_MP_APB1LPENCLRR_LPTIM1LPEN		BIT(9)
+#define RCC_MP_APB1LPENCLRR_SPI2LPEN		BIT(11)
+#define RCC_MP_APB1LPENCLRR_SPI3LPEN		BIT(12)
+#define RCC_MP_APB1LPENCLRR_USART3LPEN		BIT(15)
+#define RCC_MP_APB1LPENCLRR_UART4LPEN		BIT(16)
+#define RCC_MP_APB1LPENCLRR_UART5LPEN		BIT(17)
+#define RCC_MP_APB1LPENCLRR_UART7LPEN		BIT(18)
+#define RCC_MP_APB1LPENCLRR_UART8LPEN		BIT(19)
+#define RCC_MP_APB1LPENCLRR_I2C1LPEN		BIT(21)
+#define RCC_MP_APB1LPENCLRR_I2C2LPEN		BIT(22)
+#define RCC_MP_APB1LPENCLRR_SPDIFLPEN		BIT(26)
+
+/* RCC_MP_APB2LPENSETR register fields */
+#define RCC_MP_APB2LPENSETR_TIM1LPEN		BIT(0)
+#define RCC_MP_APB2LPENSETR_TIM8LPEN		BIT(1)
+#define RCC_MP_APB2LPENSETR_SPI1LPEN		BIT(8)
+#define RCC_MP_APB2LPENSETR_USART6LPEN		BIT(13)
+#define RCC_MP_APB2LPENSETR_SAI1LPEN		BIT(16)
+#define RCC_MP_APB2LPENSETR_SAI2LPEN		BIT(17)
+#define RCC_MP_APB2LPENSETR_DFSDMLPEN		BIT(20)
+#define RCC_MP_APB2LPENSETR_ADFSDMLPEN		BIT(21)
+#define RCC_MP_APB2LPENSETR_FDCANLPEN		BIT(24)
+
+/* RCC_MP_APB2LPENCLRR register fields */
+#define RCC_MP_APB2LPENCLRR_TIM1LPEN		BIT(0)
+#define RCC_MP_APB2LPENCLRR_TIM8LPEN		BIT(1)
+#define RCC_MP_APB2LPENCLRR_SPI1LPEN		BIT(8)
+#define RCC_MP_APB2LPENCLRR_USART6LPEN		BIT(13)
+#define RCC_MP_APB2LPENCLRR_SAI1LPEN		BIT(16)
+#define RCC_MP_APB2LPENCLRR_SAI2LPEN		BIT(17)
+#define RCC_MP_APB2LPENCLRR_DFSDMLPEN		BIT(20)
+#define RCC_MP_APB2LPENCLRR_ADFSDMLPEN		BIT(21)
+#define RCC_MP_APB2LPENCLRR_FDCANLPEN		BIT(24)
+
+/* RCC_MP_APB3LPENSETR register fields */
+#define RCC_MP_APB3LPENSETR_LPTIM2LPEN		BIT(0)
+#define RCC_MP_APB3LPENSETR_LPTIM3LPEN		BIT(1)
+#define RCC_MP_APB3LPENSETR_LPTIM4LPEN		BIT(2)
+#define RCC_MP_APB3LPENSETR_LPTIM5LPEN		BIT(3)
+#define RCC_MP_APB3LPENSETR_VREFLPEN		BIT(13)
+#define RCC_MP_APB3LPENSETR_DTSLPEN		BIT(16)
+#define RCC_MP_APB3LPENSETR_PMBCTRLLPEN		BIT(17)
+
+/* RCC_MP_APB3LPENCLRR register fields */
+#define RCC_MP_APB3LPENCLRR_LPTIM2LPEN		BIT(0)
+#define RCC_MP_APB3LPENCLRR_LPTIM3LPEN		BIT(1)
+#define RCC_MP_APB3LPENCLRR_LPTIM4LPEN		BIT(2)
+#define RCC_MP_APB3LPENCLRR_LPTIM5LPEN		BIT(3)
+#define RCC_MP_APB3LPENCLRR_VREFLPEN		BIT(13)
+#define RCC_MP_APB3LPENCLRR_DTSLPEN		BIT(16)
+#define RCC_MP_APB3LPENCLRR_PMBCTRLLPEN		BIT(17)
+
+/* RCC_MP_S_APB3LPENSETR register fields */
+#define RCC_MP_S_APB3LPENSETR_SYSCFGLPEN	BIT(0)
+
+/* RCC_MP_S_APB3LPENCLRR register fields */
+#define RCC_MP_S_APB3LPENCLRR_SYSCFGLPEN	BIT(0)
+
+/* RCC_MP_NS_APB3LPENSETR register fields */
+#define RCC_MP_NS_APB3LPENSETR_SYSCFGLPEN	BIT(0)
+
+/* RCC_MP_NS_APB3LPENCLRR register fields */
+#define RCC_MP_NS_APB3LPENCLRR_SYSCFGLPEN	BIT(0)
+
+/* RCC_MP_APB4LPENSETR register fields */
+#define RCC_MP_APB4LPENSETR_DCMIPPLPEN		BIT(1)
+#define RCC_MP_APB4LPENSETR_DDRPERFMLPEN	BIT(8)
+#define RCC_MP_APB4LPENSETR_IWDG2APBLPEN	BIT(15)
+#define RCC_MP_APB4LPENSETR_USBPHYLPEN		BIT(16)
+#define RCC_MP_APB4LPENSETR_STGENROLPEN		BIT(20)
+#define RCC_MP_APB4LPENSETR_STGENROSTPEN	BIT(21)
+
+/* RCC_MP_APB4LPENCLRR register fields */
+#define RCC_MP_APB4LPENCLRR_DCMIPPLPEN		BIT(1)
+#define RCC_MP_APB4LPENCLRR_DDRPERFMLPEN	BIT(8)
+#define RCC_MP_APB4LPENCLRR_IWDG2APBLPEN	BIT(15)
+#define RCC_MP_APB4LPENCLRR_USBPHYLPEN		BIT(16)
+#define RCC_MP_APB4LPENCLRR_STGENROLPEN		BIT(20)
+#define RCC_MP_APB4LPENCLRR_STGENROSTPEN	BIT(21)
+
+/* RCC_MP_S_APB4LPENSETR register fields */
+#define RCC_MP_S_APB4LPENSETR_LTDCLPEN		BIT(0)
+
+/* RCC_MP_S_APB4LPENCLRR register fields */
+#define RCC_MP_S_APB4LPENCLRR_LTDCLPEN		BIT(0)
+
+/* RCC_MP_NS_APB4LPENSETR register fields */
+#define RCC_MP_NS_APB4LPENSETR_LTDCLPEN		BIT(0)
+
+/* RCC_MP_NS_APB4LPENCLRR register fields */
+#define RCC_MP_NS_APB4LPENCLRR_LTDCLPEN		BIT(0)
+
+/* RCC_MP_APB5LPENSETR register fields */
+#define RCC_MP_APB5LPENSETR_RTCAPBLPEN		BIT(8)
+#define RCC_MP_APB5LPENSETR_TZCLPEN		BIT(11)
+#define RCC_MP_APB5LPENSETR_ETZPCLPEN		BIT(13)
+#define RCC_MP_APB5LPENSETR_IWDG1APBLPEN	BIT(15)
+#define RCC_MP_APB5LPENSETR_BSECLPEN		BIT(16)
+#define RCC_MP_APB5LPENSETR_STGENCLPEN		BIT(20)
+#define RCC_MP_APB5LPENSETR_STGENCSTPEN		BIT(21)
+
+/* RCC_MP_APB5LPENCLRR register fields */
+#define RCC_MP_APB5LPENCLRR_RTCAPBLPEN		BIT(8)
+#define RCC_MP_APB5LPENCLRR_TZCLPEN		BIT(11)
+#define RCC_MP_APB5LPENCLRR_ETZPCLPEN		BIT(13)
+#define RCC_MP_APB5LPENCLRR_IWDG1APBLPEN	BIT(15)
+#define RCC_MP_APB5LPENCLRR_BSECLPEN		BIT(16)
+#define RCC_MP_APB5LPENCLRR_STGENCLPEN		BIT(20)
+#define RCC_MP_APB5LPENCLRR_STGENCSTPEN		BIT(21)
+
+/* RCC_MP_APB6LPENSETR register fields */
+#define RCC_MP_APB6LPENSETR_USART1LPEN		BIT(0)
+#define RCC_MP_APB6LPENSETR_USART2LPEN		BIT(1)
+#define RCC_MP_APB6LPENSETR_SPI4LPEN		BIT(2)
+#define RCC_MP_APB6LPENSETR_SPI5LPEN		BIT(3)
+#define RCC_MP_APB6LPENSETR_I2C3LPEN		BIT(4)
+#define RCC_MP_APB6LPENSETR_I2C4LPEN		BIT(5)
+#define RCC_MP_APB6LPENSETR_I2C5LPEN		BIT(6)
+#define RCC_MP_APB6LPENSETR_TIM12LPEN		BIT(7)
+#define RCC_MP_APB6LPENSETR_TIM13LPEN		BIT(8)
+#define RCC_MP_APB6LPENSETR_TIM14LPEN		BIT(9)
+#define RCC_MP_APB6LPENSETR_TIM15LPEN		BIT(10)
+#define RCC_MP_APB6LPENSETR_TIM16LPEN		BIT(11)
+#define RCC_MP_APB6LPENSETR_TIM17LPEN		BIT(12)
+
+/* RCC_MP_APB6LPENCLRR register fields */
+#define RCC_MP_APB6LPENCLRR_USART1LPEN		BIT(0)
+#define RCC_MP_APB6LPENCLRR_USART2LPEN		BIT(1)
+#define RCC_MP_APB6LPENCLRR_SPI4LPEN		BIT(2)
+#define RCC_MP_APB6LPENCLRR_SPI5LPEN		BIT(3)
+#define RCC_MP_APB6LPENCLRR_I2C3LPEN		BIT(4)
+#define RCC_MP_APB6LPENCLRR_I2C4LPEN		BIT(5)
+#define RCC_MP_APB6LPENCLRR_I2C5LPEN		BIT(6)
+#define RCC_MP_APB6LPENCLRR_TIM12LPEN		BIT(7)
+#define RCC_MP_APB6LPENCLRR_TIM13LPEN		BIT(8)
+#define RCC_MP_APB6LPENCLRR_TIM14LPEN		BIT(9)
+#define RCC_MP_APB6LPENCLRR_TIM15LPEN		BIT(10)
+#define RCC_MP_APB6LPENCLRR_TIM16LPEN		BIT(11)
+#define RCC_MP_APB6LPENCLRR_TIM17LPEN		BIT(12)
+
+/* RCC_MP_AHB2LPENSETR register fields */
+#define RCC_MP_AHB2LPENSETR_DMA1LPEN		BIT(0)
+#define RCC_MP_AHB2LPENSETR_DMA2LPEN		BIT(1)
+#define RCC_MP_AHB2LPENSETR_DMAMUX1LPEN		BIT(2)
+#define RCC_MP_AHB2LPENSETR_DMA3LPEN		BIT(3)
+#define RCC_MP_AHB2LPENSETR_DMAMUX2LPEN		BIT(4)
+#define RCC_MP_AHB2LPENSETR_ADC1LPEN		BIT(5)
+#define RCC_MP_AHB2LPENSETR_ADC2LPEN		BIT(6)
+#define RCC_MP_AHB2LPENSETR_USBOLPEN		BIT(8)
+
+/* RCC_MP_AHB2LPENCLRR register fields */
+#define RCC_MP_AHB2LPENCLRR_DMA1LPEN		BIT(0)
+#define RCC_MP_AHB2LPENCLRR_DMA2LPEN		BIT(1)
+#define RCC_MP_AHB2LPENCLRR_DMAMUX1LPEN		BIT(2)
+#define RCC_MP_AHB2LPENCLRR_DMA3LPEN		BIT(3)
+#define RCC_MP_AHB2LPENCLRR_DMAMUX2LPEN		BIT(4)
+#define RCC_MP_AHB2LPENCLRR_ADC1LPEN		BIT(5)
+#define RCC_MP_AHB2LPENCLRR_ADC2LPEN		BIT(6)
+#define RCC_MP_AHB2LPENCLRR_USBOLPEN		BIT(8)
+
+/* RCC_MP_AHB4LPENSETR register fields */
+#define RCC_MP_AHB4LPENSETR_TSCLPEN		BIT(15)
+
+/* RCC_MP_AHB4LPENCLRR register fields */
+#define RCC_MP_AHB4LPENCLRR_TSCLPEN		BIT(15)
+
+/* RCC_MP_S_AHB4LPENSETR register fields */
+#define RCC_MP_S_AHB4LPENSETR_GPIOALPEN		BIT(0)
+#define RCC_MP_S_AHB4LPENSETR_GPIOBLPEN		BIT(1)
+#define RCC_MP_S_AHB4LPENSETR_GPIOCLPEN		BIT(2)
+#define RCC_MP_S_AHB4LPENSETR_GPIODLPEN		BIT(3)
+#define RCC_MP_S_AHB4LPENSETR_GPIOELPEN		BIT(4)
+#define RCC_MP_S_AHB4LPENSETR_GPIOFLPEN		BIT(5)
+#define RCC_MP_S_AHB4LPENSETR_GPIOGLPEN		BIT(6)
+#define RCC_MP_S_AHB4LPENSETR_GPIOHLPEN		BIT(7)
+#define RCC_MP_S_AHB4LPENSETR_GPIOILPEN		BIT(8)
+
+/* RCC_MP_S_AHB4LPENCLRR register fields */
+#define RCC_MP_S_AHB4LPENCLRR_GPIOALPEN		BIT(0)
+#define RCC_MP_S_AHB4LPENCLRR_GPIOBLPEN		BIT(1)
+#define RCC_MP_S_AHB4LPENCLRR_GPIOCLPEN		BIT(2)
+#define RCC_MP_S_AHB4LPENCLRR_GPIODLPEN		BIT(3)
+#define RCC_MP_S_AHB4LPENCLRR_GPIOELPEN		BIT(4)
+#define RCC_MP_S_AHB4LPENCLRR_GPIOFLPEN		BIT(5)
+#define RCC_MP_S_AHB4LPENCLRR_GPIOGLPEN		BIT(6)
+#define RCC_MP_S_AHB4LPENCLRR_GPIOHLPEN		BIT(7)
+#define RCC_MP_S_AHB4LPENCLRR_GPIOILPEN		BIT(8)
+
+/* RCC_MP_NS_AHB4LPENSETR register fields */
+#define RCC_MP_NS_AHB4LPENSETR_GPIOALPEN	BIT(0)
+#define RCC_MP_NS_AHB4LPENSETR_GPIOBLPEN	BIT(1)
+#define RCC_MP_NS_AHB4LPENSETR_GPIOCLPEN	BIT(2)
+#define RCC_MP_NS_AHB4LPENSETR_GPIODLPEN	BIT(3)
+#define RCC_MP_NS_AHB4LPENSETR_GPIOELPEN	BIT(4)
+#define RCC_MP_NS_AHB4LPENSETR_GPIOFLPEN	BIT(5)
+#define RCC_MP_NS_AHB4LPENSETR_GPIOGLPEN	BIT(6)
+#define RCC_MP_NS_AHB4LPENSETR_GPIOHLPEN	BIT(7)
+#define RCC_MP_NS_AHB4LPENSETR_GPIOILPEN	BIT(8)
+
+/* RCC_MP_NS_AHB4LPENCLRR register fields */
+#define RCC_MP_NS_AHB4LPENCLRR_GPIOALPEN	BIT(0)
+#define RCC_MP_NS_AHB4LPENCLRR_GPIOBLPEN	BIT(1)
+#define RCC_MP_NS_AHB4LPENCLRR_GPIOCLPEN	BIT(2)
+#define RCC_MP_NS_AHB4LPENCLRR_GPIODLPEN	BIT(3)
+#define RCC_MP_NS_AHB4LPENCLRR_GPIOELPEN	BIT(4)
+#define RCC_MP_NS_AHB4LPENCLRR_GPIOFLPEN	BIT(5)
+#define RCC_MP_NS_AHB4LPENCLRR_GPIOGLPEN	BIT(6)
+#define RCC_MP_NS_AHB4LPENCLRR_GPIOHLPEN	BIT(7)
+#define RCC_MP_NS_AHB4LPENCLRR_GPIOILPEN	BIT(8)
+
+/* RCC_MP_AHB5LPENSETR register fields */
+#define RCC_MP_AHB5LPENSETR_PKALPEN		BIT(2)
+#define RCC_MP_AHB5LPENSETR_SAESLPEN		BIT(3)
+#define RCC_MP_AHB5LPENSETR_CRYP1LPEN		BIT(4)
+#define RCC_MP_AHB5LPENSETR_HASH1LPEN		BIT(5)
+#define RCC_MP_AHB5LPENSETR_RNG1LPEN		BIT(6)
+#define RCC_MP_AHB5LPENSETR_BKPSRAMLPEN		BIT(8)
+
+/* RCC_MP_AHB5LPENCLRR register fields */
+#define RCC_MP_AHB5LPENCLRR_PKALPEN		BIT(2)
+#define RCC_MP_AHB5LPENCLRR_SAESLPEN		BIT(3)
+#define RCC_MP_AHB5LPENCLRR_CRYP1LPEN		BIT(4)
+#define RCC_MP_AHB5LPENCLRR_HASH1LPEN		BIT(5)
+#define RCC_MP_AHB5LPENCLRR_RNG1LPEN		BIT(6)
+#define RCC_MP_AHB5LPENCLRR_BKPSRAMLPEN		BIT(8)
+
+/* RCC_MP_AHB6LPENSETR register fields */
+#define RCC_MP_AHB6LPENSETR_MCELPEN		BIT(1)
+#define RCC_MP_AHB6LPENSETR_ETH1CKLPEN		BIT(7)
+#define RCC_MP_AHB6LPENSETR_ETH1TXLPEN		BIT(8)
+#define RCC_MP_AHB6LPENSETR_ETH1RXLPEN		BIT(9)
+#define RCC_MP_AHB6LPENSETR_ETH1MACLPEN		BIT(10)
+#define RCC_MP_AHB6LPENSETR_ETH1STPEN		BIT(11)
+#define RCC_MP_AHB6LPENSETR_FMCLPEN		BIT(12)
+#define RCC_MP_AHB6LPENSETR_QSPILPEN		BIT(14)
+#define RCC_MP_AHB6LPENSETR_SDMMC1LPEN		BIT(16)
+#define RCC_MP_AHB6LPENSETR_SDMMC2LPEN		BIT(17)
+#define RCC_MP_AHB6LPENSETR_CRC1LPEN		BIT(20)
+#define RCC_MP_AHB6LPENSETR_USBHLPEN		BIT(24)
+#define RCC_MP_AHB6LPENSETR_ETH2CKLPEN		BIT(27)
+#define RCC_MP_AHB6LPENSETR_ETH2TXLPEN		BIT(28)
+#define RCC_MP_AHB6LPENSETR_ETH2RXLPEN		BIT(29)
+#define RCC_MP_AHB6LPENSETR_ETH2MACLPEN		BIT(30)
+#define RCC_MP_AHB6LPENSETR_ETH2STPEN		BIT(31)
+
+/* RCC_MP_AHB6LPENCLRR register fields */
+#define RCC_MP_AHB6LPENCLRR_MCELPEN		BIT(1)
+#define RCC_MP_AHB6LPENCLRR_ETH1CKLPEN		BIT(7)
+#define RCC_MP_AHB6LPENCLRR_ETH1TXLPEN		BIT(8)
+#define RCC_MP_AHB6LPENCLRR_ETH1RXLPEN		BIT(9)
+#define RCC_MP_AHB6LPENCLRR_ETH1MACLPEN		BIT(10)
+#define RCC_MP_AHB6LPENCLRR_ETH1STPEN		BIT(11)
+#define RCC_MP_AHB6LPENCLRR_FMCLPEN		BIT(12)
+#define RCC_MP_AHB6LPENCLRR_QSPILPEN		BIT(14)
+#define RCC_MP_AHB6LPENCLRR_SDMMC1LPEN		BIT(16)
+#define RCC_MP_AHB6LPENCLRR_SDMMC2LPEN		BIT(17)
+#define RCC_MP_AHB6LPENCLRR_CRC1LPEN		BIT(20)
+#define RCC_MP_AHB6LPENCLRR_USBHLPEN		BIT(24)
+#define RCC_MP_AHB6LPENCLRR_ETH2CKLPEN		BIT(27)
+#define RCC_MP_AHB6LPENCLRR_ETH2TXLPEN		BIT(28)
+#define RCC_MP_AHB6LPENCLRR_ETH2RXLPEN		BIT(29)
+#define RCC_MP_AHB6LPENCLRR_ETH2MACLPEN		BIT(30)
+#define RCC_MP_AHB6LPENCLRR_ETH2STPEN		BIT(31)
+
+/* RCC_MP_S_AHB6LPENSETR register fields */
+#define RCC_MP_S_AHB6LPENSETR_MDMALPEN		BIT(0)
+
+/* RCC_MP_S_AHB6LPENCLRR register fields */
+#define RCC_MP_S_AHB6LPENCLRR_MDMALPEN		BIT(0)
+
+/* RCC_MP_NS_AHB6LPENSETR register fields */
+#define RCC_MP_NS_AHB6LPENSETR_MDMALPEN		BIT(0)
+
+/* RCC_MP_NS_AHB6LPENCLRR register fields */
+#define RCC_MP_NS_AHB6LPENCLRR_MDMALPEN		BIT(0)
+
+/* RCC_MP_S_AXIMLPENSETR register fields */
+#define RCC_MP_S_AXIMLPENSETR_SYSRAMLPEN	BIT(0)
+
+/* RCC_MP_S_AXIMLPENCLRR register fields */
+#define RCC_MP_S_AXIMLPENCLRR_SYSRAMLPEN	BIT(0)
+
+/* RCC_MP_NS_AXIMLPENSETR register fields */
+#define RCC_MP_NS_AXIMLPENSETR_SYSRAMLPEN	BIT(0)
+
+/* RCC_MP_NS_AXIMLPENCLRR register fields */
+#define RCC_MP_NS_AXIMLPENCLRR_SYSRAMLPEN	BIT(0)
+
+/* RCC_MP_MLAHBLPENSETR register fields */
+#define RCC_MP_MLAHBLPENSETR_SRAM1LPEN		BIT(0)
+#define RCC_MP_MLAHBLPENSETR_SRAM2LPEN		BIT(1)
+#define RCC_MP_MLAHBLPENSETR_SRAM3LPEN		BIT(2)
+
+/* RCC_MP_MLAHBLPENCLRR register fields */
+#define RCC_MP_MLAHBLPENCLRR_SRAM1LPEN		BIT(0)
+#define RCC_MP_MLAHBLPENCLRR_SRAM2LPEN		BIT(1)
+#define RCC_MP_MLAHBLPENCLRR_SRAM3LPEN		BIT(2)
+
+/* RCC_APB3SECSR register fields */
+#define RCC_APB3SECSR_LPTIM2SECF		BIT(0)
+#define RCC_APB3SECSR_LPTIM3SECF		BIT(1)
+#define RCC_APB3SECSR_VREFSECF			BIT(13)
+
+/* RCC_APB4SECSR register fields */
+#define RCC_APB4SECSR_DCMIPPSECF		BIT(1)
+#define RCC_APB4SECSR_USBPHYSECF		BIT(16)
+
+/* RCC_APB5SECSR register fields */
+#define RCC_APB5SECSR_RTCSECF			BIT(8)
+#define RCC_APB5SECSR_TZCSECF			BIT(11)
+#define RCC_APB5SECSR_ETZPCSECF			BIT(13)
+#define RCC_APB5SECSR_IWDG1SECF			BIT(15)
+#define RCC_APB5SECSR_BSECSECF			BIT(16)
+#define RCC_APB5SECSR_STGENCSECF_MASK		GENMASK(21, 20)
+#define RCC_APB5SECSR_STGENCSECF_SHIFT		20
+
+/* RCC_APB6SECSR register fields */
+#define RCC_APB6SECSR_USART1SECF		BIT(0)
+#define RCC_APB6SECSR_USART2SECF		BIT(1)
+#define RCC_APB6SECSR_SPI4SECF			BIT(2)
+#define RCC_APB6SECSR_SPI5SECF			BIT(3)
+#define RCC_APB6SECSR_I2C3SECF			BIT(4)
+#define RCC_APB6SECSR_I2C4SECF			BIT(5)
+#define RCC_APB6SECSR_I2C5SECF			BIT(6)
+#define RCC_APB6SECSR_TIM12SECF			BIT(7)
+#define RCC_APB6SECSR_TIM13SECF			BIT(8)
+#define RCC_APB6SECSR_TIM14SECF			BIT(9)
+#define RCC_APB6SECSR_TIM15SECF			BIT(10)
+#define RCC_APB6SECSR_TIM16SECF			BIT(11)
+#define RCC_APB6SECSR_TIM17SECF			BIT(12)
+
+/* RCC_AHB2SECSR register fields */
+#define RCC_AHB2SECSR_DMA3SECF			BIT(3)
+#define RCC_AHB2SECSR_DMAMUX2SECF		BIT(4)
+#define RCC_AHB2SECSR_ADC1SECF			BIT(5)
+#define RCC_AHB2SECSR_ADC2SECF			BIT(6)
+#define RCC_AHB2SECSR_USBOSECF			BIT(8)
+
+/* RCC_AHB4SECSR register fields */
+#define RCC_AHB4SECSR_TSCSECF			BIT(15)
+
+/* RCC_AHB5SECSR register fields */
+#define RCC_AHB5SECSR_PKASECF			BIT(2)
+#define RCC_AHB5SECSR_SAESSECF			BIT(3)
+#define RCC_AHB5SECSR_CRYP1SECF			BIT(4)
+#define RCC_AHB5SECSR_HASH1SECF			BIT(5)
+#define RCC_AHB5SECSR_RNG1SECF			BIT(6)
+#define RCC_AHB5SECSR_BKPSRAMSECF		BIT(8)
+
+/* RCC_AHB6SECSR register fields */
+#define RCC_AHB6SECSR_MCESECF			BIT(1)
+#define RCC_AHB6SECSR_ETH1SECF_MASK		GENMASK(11, 7)
+#define RCC_AHB6SECSR_ETH1SECF_SHIFT		7
+#define RCC_AHB6SECSR_FMCSECF			BIT(12)
+#define RCC_AHB6SECSR_QSPISECF			BIT(14)
+#define RCC_AHB6SECSR_SDMMC1SECF		BIT(16)
+#define RCC_AHB6SECSR_SDMMC2SECF		BIT(17)
+#define RCC_AHB6SECSR_ETH2SECF_MASK		GENMASK(31, 27)
+#define RCC_AHB6SECSR_ETH2SECF_SHIFT		27
+
+/* RCC_VERR register fields */
+#define RCC_VERR_MINREV_MASK			GENMASK(3, 0)
+#define RCC_VERR_MINREV_SHIFT			0
+#define RCC_VERR_MAJREV_MASK			GENMASK(7, 4)
+#define RCC_VERR_MAJREV_SHIFT			4
+
+/* RCC_IDR register fields */
+#define RCC_IDR_ID_MASK				GENMASK(31, 0)
+#define RCC_IDR_ID_SHIFT			0
+
+/* RCC_SIDR register fields */
+#define RCC_SIDR_SID_MASK			GENMASK(31, 0)
+#define RCC_SIDR_SID_SHIFT			0
+
+/* Used for all RCC_PLL<n>CR registers */
+#define RCC_PLLNCR_PLLON			BIT(0)
+#define RCC_PLLNCR_PLLRDY			BIT(1)
+#define RCC_PLLNCR_SSCG_CTRL			BIT(2)
+#define RCC_PLLNCR_DIVPEN			BIT(4)
+#define RCC_PLLNCR_DIVQEN			BIT(5)
+#define RCC_PLLNCR_DIVREN			BIT(6)
+#define RCC_PLLNCR_DIVEN_SHIFT			4
+
+/* Used for all RCC_PLL<n>CFGR1 registers */
+#define RCC_PLLNCFGR1_DIVM_SHIFT		16
+#define RCC_PLLNCFGR1_DIVM_MASK			GENMASK(21, 16)
+#define RCC_PLLNCFGR1_DIVN_SHIFT		0
+#define RCC_PLLNCFGR1_DIVN_MASK			GENMASK(8, 0)
+
+/* Only for PLL3 and PLL4 */
+#define RCC_PLLNCFGR1_IFRGE_SHIFT		24
+#define RCC_PLLNCFGR1_IFRGE_MASK		GENMASK(25, 24)
+
+/* Used for all RCC_PLL<n>CFGR2 registers */
+#define RCC_PLLNCFGR2_DIVX_MASK			GENMASK(6, 0)
+#define RCC_PLLNCFGR2_DIVP_SHIFT		0
+#define RCC_PLLNCFGR2_DIVP_MASK			GENMASK(6, 0)
+#define RCC_PLLNCFGR2_DIVQ_SHIFT		8
+#define RCC_PLLNCFGR2_DIVQ_MASK			GENMASK(14, 8)
+#define RCC_PLLNCFGR2_DIVR_SHIFT		16
+#define RCC_PLLNCFGR2_DIVR_MASK			GENMASK(22, 16)
+
+/* Used for all RCC_PLL<n>FRACR registers */
+#define RCC_PLLNFRACR_FRACV_SHIFT		3
+#define RCC_PLLNFRACR_FRACV_MASK		GENMASK(15, 3)
+#define RCC_PLLNFRACR_FRACLE			BIT(16)
+
+/* Used for all RCC_PLL<n>CSGR registers */
+#define RCC_PLLNCSGR_INC_STEP_SHIFT		16
+#define RCC_PLLNCSGR_INC_STEP_MASK		GENMASK(30, 16)
+#define RCC_PLLNCSGR_MOD_PER_SHIFT		0
+#define RCC_PLLNCSGR_MOD_PER_MASK		GENMASK(12, 0)
+#define RCC_PLLNCSGR_SSCG_MODE_SHIFT		15
+#define RCC_PLLNCSGR_SSCG_MODE_MASK		BIT(15)
+
+/* Used for most of RCC_<x>SELR registers */
+#define RCC_SELR_SRC_MASK			GENMASK(2, 0)
+#define RCC_SELR_REFCLK_SRC_MASK		GENMASK(1, 0)
+#define RCC_SELR_SRCRDY				BIT(31)
+
+/* Values of RCC_MPCKSELR register */
+#define RCC_MPCKSELR_HSI			0x00000000
+#define RCC_MPCKSELR_HSE			0x00000001
+#define RCC_MPCKSELR_PLL			0x00000002
+#define RCC_MPCKSELR_PLL_MPUDIV			0x00000003
+
+/* Values of RCC_ASSCKSELR register */
+#define RCC_ASSCKSELR_HSI			0x00000000
+#define RCC_ASSCKSELR_HSE			0x00000001
+#define RCC_ASSCKSELR_PLL			0x00000002
+
+/* Values of RCC_MSSCKSELR register */
+#define RCC_MSSCKSELR_HSI			0x00000000
+#define RCC_MSSCKSELR_HSE			0x00000001
+#define RCC_MSSCKSELR_CSI			0x00000002
+#define RCC_MSSCKSELR_PLL			0x00000003
+
+/* Values of RCC_CPERCKSELR register */
+#define RCC_CPERCKSELR_HSI			0x00000000
+#define RCC_CPERCKSELR_CSI			0x00000001
+#define RCC_CPERCKSELR_HSE			0x00000002
+
+/* Used for most of DIVR register: max div for RTC */
+#define RCC_DIVR_DIV_MASK			GENMASK(5, 0)
+#define RCC_DIVR_DIVRDY				BIT(31)
+
+/* Masks for specific DIVR registers */
+#define RCC_APBXDIV_MASK			GENMASK(2, 0)
+#define RCC_MPUDIV_MASK				GENMASK(2, 0)
+#define RCC_AXIDIV_MASK				GENMASK(2, 0)
+#define RCC_MLAHBDIV_MASK			GENMASK(3, 0)
+
+/* Used for TIMER Prescaler */
+#define RCC_TIMGXPRER_TIMGXPRE			BIT(0)
+
+/* Offset between RCC_MP_xxxENSETR and RCC_MP_xxxENCLRR registers */
+#define RCC_MP_ENCLRR_OFFSET			U(4)
+
+/* Offset between RCC_xxxRSTSETR and RCC_xxxRSTCLRR registers */
+#define RCC_RSTCLRR_OFFSET			U(4)
+
+/* RCC_OCENSETR register fields */
+#define RCC_OCENR_HSION				BIT(0)
+#define RCC_OCENR_HSIKERON			BIT(1)
+#define RCC_OCENR_CSION				BIT(4)
+#define RCC_OCENR_CSIKERON			BIT(5)
+#define RCC_OCENR_DIGBYP			BIT(7)
+#define RCC_OCENR_HSEON				BIT(8)
+#define RCC_OCENR_HSEKERON			BIT(9)
+#define RCC_OCENR_HSEBYP			BIT(10)
+#define RCC_OCENR_HSECSSON			BIT(11)
+
+#define RCC_OCENR_DIGBYP_BIT		        7
+#define RCC_OCENR_HSEBYP_BIT		        10
+#define RCC_OCENR_HSECSSON_BIT		        11
+
+/* Used for RCC_MCO related operations */
+#define RCC_MCOCFG_MCOON			BIT(12)
+#define RCC_MCOCFG_MCODIV_MASK			GENMASK(7, 4)
+#define RCC_MCOCFG_MCODIV_SHIFT			4
+#define RCC_MCOCFG_MCOSRC_MASK			GENMASK(2, 0)
+
+#define RCC_UART4CKSELR_HSI			0x00000002
+
+#define RCC_CPERCKSELR_PERSRC_MASK		GENMASK(1, 0)
+#define RCC_CPERCKSELR_PERSRC_SHIFT		0
+
+#define RCC_USBCKSELR_USBOSRC_MASK		BIT(4)
+#define RCC_USBCKSELR_USBOSRC_SHIFT		4
+
+#define RCC_DDRITFCR_DDRCKMOD_SSR		0
+#define RCC_DDRITFCR_DDRCKMOD_ASR1		BIT(20)
+#define RCC_DDRITFCR_DDRCKMOD_HSR1		BIT(21)
+
+#define RCC_DDRITFCR_DDRC2EN			BIT(0)
+#define RCC_DDRITFCR_DDRC2LPEN			BIT(1)
+
+#define RCC_MP_CIFR_MASK			U(0x110F1F)
+#define RCC_OFFSET_MASK				GENMASK(11, 0)
+
+#endif /* STM32MP1_RCC_H */
diff --git a/include/drivers/st/stm32mp15_rcc.h b/include/drivers/st/stm32mp15_rcc.h
new file mode 100644
index 000000000..7b50b2725
--- /dev/null
+++ b/include/drivers/st/stm32mp15_rcc.h
@@ -0,0 +1,2328 @@
+/*
+ * Copyright (c) 2015-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP1_RCC_H
+#define STM32MP1_RCC_H
+
+#include <lib/utils_def.h>
+
+#define RCC_TZCR				U(0x00)
+#define RCC_OCENSETR				U(0x0C)
+#define RCC_OCENCLRR				U(0x10)
+#define RCC_HSICFGR				U(0x18)
+#define RCC_CSICFGR				U(0x1C)
+#define RCC_MPCKSELR				U(0x20)
+#define RCC_ASSCKSELR				U(0x24)
+#define RCC_RCK12SELR				U(0x28)
+#define RCC_MPCKDIVR				U(0x2C)
+#define RCC_AXIDIVR				U(0x30)
+#define RCC_APB4DIVR				U(0x3C)
+#define RCC_APB5DIVR				U(0x40)
+#define RCC_RTCDIVR				U(0x44)
+#define RCC_MSSCKSELR				U(0x48)
+#define RCC_PLL1CR				U(0x80)
+#define RCC_PLL1CFGR1				U(0x84)
+#define RCC_PLL1CFGR2				U(0x88)
+#define RCC_PLL1FRACR				U(0x8C)
+#define RCC_PLL1CSGR				U(0x90)
+#define RCC_PLL2CR				U(0x94)
+#define RCC_PLL2CFGR1				U(0x98)
+#define RCC_PLL2CFGR2				U(0x9C)
+#define RCC_PLL2FRACR				U(0xA0)
+#define RCC_PLL2CSGR				U(0xA4)
+#define RCC_I2C46CKSELR				U(0xC0)
+#define RCC_SPI6CKSELR				U(0xC4)
+#define RCC_UART1CKSELR				U(0xC8)
+#define RCC_RNG1CKSELR				U(0xCC)
+#define RCC_CPERCKSELR				U(0xD0)
+#define RCC_STGENCKSELR				U(0xD4)
+#define RCC_DDRITFCR				U(0xD8)
+#define RCC_MP_BOOTCR				U(0x100)
+#define RCC_MP_SREQSETR				U(0x104)
+#define RCC_MP_SREQCLRR				U(0x108)
+#define RCC_MP_GCR				U(0x10C)
+#define RCC_MP_APRSTCR				U(0x110)
+#define RCC_MP_APRSTSR				U(0x114)
+#define RCC_BDCR				U(0x140)
+#define RCC_RDLSICR				U(0x144)
+#define RCC_APB4RSTSETR				U(0x180)
+#define RCC_APB4RSTCLRR				U(0x184)
+#define RCC_APB5RSTSETR				U(0x188)
+#define RCC_APB5RSTCLRR				U(0x18C)
+#define RCC_AHB5RSTSETR				U(0x190)
+#define RCC_AHB5RSTCLRR				U(0x194)
+#define RCC_AHB6RSTSETR				U(0x198)
+#define RCC_AHB6RSTCLRR				U(0x19C)
+#define RCC_TZAHB6RSTSETR			U(0x1A0)
+#define RCC_TZAHB6RSTCLRR			U(0x1A4)
+#define RCC_MP_APB4ENSETR			U(0x200)
+#define RCC_MP_APB4ENCLRR			U(0x204)
+#define RCC_MP_APB5ENSETR			U(0x208)
+#define RCC_MP_APB5ENCLRR			U(0x20C)
+#define RCC_MP_AHB5ENSETR			U(0x210)
+#define RCC_MP_AHB5ENCLRR			U(0x214)
+#define RCC_MP_AHB6ENSETR			U(0x218)
+#define RCC_MP_AHB6ENCLRR			U(0x21C)
+#define RCC_MP_TZAHB6ENSETR			U(0x220)
+#define RCC_MP_TZAHB6ENCLRR			U(0x224)
+#define RCC_MC_APB4ENSETR			U(0x280)
+#define RCC_MC_APB4ENCLRR			U(0x284)
+#define RCC_MC_APB5ENSETR			U(0x288)
+#define RCC_MC_APB5ENCLRR			U(0x28C)
+#define RCC_MC_AHB5ENSETR			U(0x290)
+#define RCC_MC_AHB5ENCLRR			U(0x294)
+#define RCC_MC_AHB6ENSETR			U(0x298)
+#define RCC_MC_AHB6ENCLRR			U(0x29C)
+#define RCC_MP_APB4LPENSETR			U(0x300)
+#define RCC_MP_APB4LPENCLRR			U(0x304)
+#define RCC_MP_APB5LPENSETR			U(0x308)
+#define RCC_MP_APB5LPENCLRR			U(0x30C)
+#define RCC_MP_AHB5LPENSETR			U(0x310)
+#define RCC_MP_AHB5LPENCLRR			U(0x314)
+#define RCC_MP_AHB6LPENSETR			U(0x318)
+#define RCC_MP_AHB6LPENCLRR			U(0x31C)
+#define RCC_MP_TZAHB6LPENSETR			U(0x320)
+#define RCC_MP_TZAHB6LPENCLRR			U(0x324)
+#define RCC_MC_APB4LPENSETR			U(0x380)
+#define RCC_MC_APB4LPENCLRR			U(0x384)
+#define RCC_MC_APB5LPENSETR			U(0x388)
+#define RCC_MC_APB5LPENCLRR			U(0x38C)
+#define RCC_MC_AHB5LPENSETR			U(0x390)
+#define RCC_MC_AHB5LPENCLRR			U(0x394)
+#define RCC_MC_AHB6LPENSETR			U(0x398)
+#define RCC_MC_AHB6LPENCLRR			U(0x39C)
+#define RCC_BR_RSTSCLRR				U(0x400)
+#define RCC_MP_GRSTCSETR			U(0x404)
+#define RCC_MP_RSTSCLRR				U(0x408)
+#define RCC_MP_IWDGFZSETR			U(0x40C)
+#define RCC_MP_IWDGFZCLRR			U(0x410)
+#define RCC_MP_CIER				U(0x414)
+#define RCC_MP_CIFR				U(0x418)
+#define RCC_PWRLPDLYCR				U(0x41C)
+#define RCC_MP_RSTSSETR				U(0x420)
+#define RCC_MCO1CFGR				U(0x800)
+#define RCC_MCO2CFGR				U(0x804)
+#define RCC_OCRDYR				U(0x808)
+#define RCC_DBGCFGR				U(0x80C)
+#define RCC_RCK3SELR				U(0x820)
+#define RCC_RCK4SELR				U(0x824)
+#define RCC_TIMG1PRER				U(0x828)
+#define RCC_TIMG2PRER				U(0x82C)
+#define RCC_MCUDIVR				U(0x830)
+#define RCC_APB1DIVR				U(0x834)
+#define RCC_APB2DIVR				U(0x838)
+#define RCC_APB3DIVR				U(0x83C)
+#define RCC_PLL3CR				U(0x880)
+#define RCC_PLL3CFGR1				U(0x884)
+#define RCC_PLL3CFGR2				U(0x888)
+#define RCC_PLL3FRACR				U(0x88C)
+#define RCC_PLL3CSGR				U(0x890)
+#define RCC_PLL4CR				U(0x894)
+#define RCC_PLL4CFGR1				U(0x898)
+#define RCC_PLL4CFGR2				U(0x89C)
+#define RCC_PLL4FRACR				U(0x8A0)
+#define RCC_PLL4CSGR				U(0x8A4)
+#define RCC_I2C12CKSELR				U(0x8C0)
+#define RCC_I2C35CKSELR				U(0x8C4)
+#define RCC_SAI1CKSELR				U(0x8C8)
+#define RCC_SAI2CKSELR				U(0x8CC)
+#define RCC_SAI3CKSELR				U(0x8D0)
+#define RCC_SAI4CKSELR				U(0x8D4)
+#define RCC_SPI2S1CKSELR			U(0x8D8)
+#define RCC_SPI2S23CKSELR			U(0x8DC)
+#define RCC_SPI45CKSELR				U(0x8E0)
+#define RCC_UART6CKSELR				U(0x8E4)
+#define RCC_UART24CKSELR			U(0x8E8)
+#define RCC_UART35CKSELR			U(0x8EC)
+#define RCC_UART78CKSELR			U(0x8F0)
+#define RCC_SDMMC12CKSELR			U(0x8F4)
+#define RCC_SDMMC3CKSELR			U(0x8F8)
+#define RCC_ETHCKSELR				U(0x8FC)
+#define RCC_QSPICKSELR				U(0x900)
+#define RCC_FMCCKSELR				U(0x904)
+#define RCC_FDCANCKSELR				U(0x90C)
+#define RCC_SPDIFCKSELR				U(0x914)
+#define RCC_CECCKSELR				U(0x918)
+#define RCC_USBCKSELR				U(0x91C)
+#define RCC_RNG2CKSELR				U(0x920)
+#define RCC_DSICKSELR				U(0x924)
+#define RCC_ADCCKSELR				U(0x928)
+#define RCC_LPTIM45CKSELR			U(0x92C)
+#define RCC_LPTIM23CKSELR			U(0x930)
+#define RCC_LPTIM1CKSELR			U(0x934)
+#define RCC_APB1RSTSETR				U(0x980)
+#define RCC_APB1RSTCLRR				U(0x984)
+#define RCC_APB2RSTSETR				U(0x988)
+#define RCC_APB2RSTCLRR				U(0x98C)
+#define RCC_APB3RSTSETR				U(0x990)
+#define RCC_APB3RSTCLRR				U(0x994)
+#define RCC_AHB2RSTSETR				U(0x998)
+#define RCC_AHB2RSTCLRR				U(0x99C)
+#define RCC_AHB3RSTSETR				U(0x9A0)
+#define RCC_AHB3RSTCLRR				U(0x9A4)
+#define RCC_AHB4RSTSETR				U(0x9A8)
+#define RCC_AHB4RSTCLRR				U(0x9AC)
+#define RCC_MP_APB1ENSETR			U(0xA00)
+#define RCC_MP_APB1ENCLRR			U(0xA04)
+#define RCC_MP_APB2ENSETR			U(0xA08)
+#define RCC_MP_APB2ENCLRR			U(0xA0C)
+#define RCC_MP_APB3ENSETR			U(0xA10)
+#define RCC_MP_APB3ENCLRR			U(0xA14)
+#define RCC_MP_AHB2ENSETR			U(0xA18)
+#define RCC_MP_AHB2ENCLRR			U(0xA1C)
+#define RCC_MP_AHB3ENSETR			U(0xA20)
+#define RCC_MP_AHB3ENCLRR			U(0xA24)
+#define RCC_MP_AHB4ENSETR			U(0xA28)
+#define RCC_MP_AHB4ENCLRR			U(0xA2C)
+#define RCC_MP_MLAHBENSETR			U(0xA38)
+#define RCC_MP_MLAHBENCLRR			U(0xA3C)
+#define RCC_MC_APB1ENSETR			U(0xA80)
+#define RCC_MC_APB1ENCLRR			U(0xA84)
+#define RCC_MC_APB2ENSETR			U(0xA88)
+#define RCC_MC_APB2ENCLRR			U(0xA8C)
+#define RCC_MC_APB3ENSETR			U(0xA90)
+#define RCC_MC_APB3ENCLRR			U(0xA94)
+#define RCC_MC_AHB2ENSETR			U(0xA98)
+#define RCC_MC_AHB2ENCLRR			U(0xA9C)
+#define RCC_MC_AHB3ENSETR			U(0xAA0)
+#define RCC_MC_AHB3ENCLRR			U(0xAA4)
+#define RCC_MC_AHB4ENSETR			U(0xAA8)
+#define RCC_MC_AHB4ENCLRR			U(0xAAC)
+#define RCC_MC_AXIMENSETR			U(0xAB0)
+#define RCC_MC_AXIMENCLRR			U(0xAB4)
+#define RCC_MC_MLAHBENSETR			U(0xAB8)
+#define RCC_MC_MLAHBENCLRR			U(0xABC)
+#define RCC_MP_APB1LPENSETR			U(0xB00)
+#define RCC_MP_APB1LPENCLRR			U(0xB04)
+#define RCC_MP_APB2LPENSETR			U(0xB08)
+#define RCC_MP_APB2LPENCLRR			U(0xB0C)
+#define RCC_MP_APB3LPENSETR			U(0xB10)
+#define RCC_MP_APB3LPENCLRR			U(0xB14)
+#define RCC_MP_AHB2LPENSETR			U(0xB18)
+#define RCC_MP_AHB2LPENCLRR			U(0xB1C)
+#define RCC_MP_AHB3LPENSETR			U(0xB20)
+#define RCC_MP_AHB3LPENCLRR			U(0xB24)
+#define RCC_MP_AHB4LPENSETR			U(0xB28)
+#define RCC_MP_AHB4LPENCLRR			U(0xB2C)
+#define RCC_MP_AXIMLPENSETR			U(0xB30)
+#define RCC_MP_AXIMLPENCLRR			U(0xB34)
+#define RCC_MP_MLAHBLPENSETR			U(0xB38)
+#define RCC_MP_MLAHBLPENCLRR			U(0xB3C)
+#define RCC_MC_APB1LPENSETR			U(0xB80)
+#define RCC_MC_APB1LPENCLRR			U(0xB84)
+#define RCC_MC_APB2LPENSETR			U(0xB88)
+#define RCC_MC_APB2LPENCLRR			U(0xB8C)
+#define RCC_MC_APB3LPENSETR			U(0xB90)
+#define RCC_MC_APB3LPENCLRR			U(0xB94)
+#define RCC_MC_AHB2LPENSETR			U(0xB98)
+#define RCC_MC_AHB2LPENCLRR			U(0xB9C)
+#define RCC_MC_AHB3LPENSETR			U(0xBA0)
+#define RCC_MC_AHB3LPENCLRR			U(0xBA4)
+#define RCC_MC_AHB4LPENSETR			U(0xBA8)
+#define RCC_MC_AHB4LPENCLRR			U(0xBAC)
+#define RCC_MC_AXIMLPENSETR			U(0xBB0)
+#define RCC_MC_AXIMLPENCLRR			U(0xBB4)
+#define RCC_MC_MLAHBLPENSETR			U(0xBB8)
+#define RCC_MC_MLAHBLPENCLRR			U(0xBBC)
+#define RCC_MC_RSTSCLRR				U(0xC00)
+#define RCC_MC_CIER				U(0xC14)
+#define RCC_MC_CIFR				U(0xC18)
+#define RCC_VERR				U(0xFF4)
+#define RCC_IDR					U(0xFF8)
+#define RCC_SIDR				U(0xFFC)
+
+/* RCC_TZCR register fields */
+#define RCC_TZCR_TZEN				BIT(0)
+#define RCC_TZCR_MCKPROT			BIT(1)
+
+/* RCC_OCENSETR register fields */
+#define RCC_OCENSETR_HSION			BIT(0)
+#define RCC_OCENSETR_HSIKERON			BIT(1)
+#define RCC_OCENSETR_CSION			BIT(4)
+#define RCC_OCENSETR_CSIKERON			BIT(5)
+#define RCC_OCENSETR_DIGBYP			BIT(7)
+#define RCC_OCENSETR_HSEON			BIT(8)
+#define RCC_OCENSETR_HSEKERON			BIT(9)
+#define RCC_OCENSETR_HSEBYP			BIT(10)
+#define RCC_OCENSETR_HSECSSON			BIT(11)
+
+/* RCC_OCENCLRR register fields */
+#define RCC_OCENCLRR_HSION			BIT(0)
+#define RCC_OCENCLRR_HSIKERON			BIT(1)
+#define RCC_OCENCLRR_CSION			BIT(4)
+#define RCC_OCENCLRR_CSIKERON			BIT(5)
+#define RCC_OCENCLRR_DIGBYP			BIT(7)
+#define RCC_OCENCLRR_HSEON			BIT(8)
+#define RCC_OCENCLRR_HSEKERON			BIT(9)
+#define RCC_OCENCLRR_HSEBYP			BIT(10)
+
+/* RCC_HSICFGR register fields */
+#define RCC_HSICFGR_HSIDIV_MASK			GENMASK(1, 0)
+#define RCC_HSICFGR_HSIDIV_SHIFT		0
+#define RCC_HSICFGR_HSITRIM_MASK		GENMASK(14, 8)
+#define RCC_HSICFGR_HSITRIM_SHIFT		8
+#define RCC_HSICFGR_HSICAL_MASK			GENMASK(24, 16)
+#define RCC_HSICFGR_HSICAL_SHIFT		16
+#define RCC_HSICFGR_HSICAL_TEMP_MASK		GENMASK(27, 25)
+
+/* RCC_CSICFGR register fields */
+#define RCC_CSICFGR_CSITRIM_MASK		GENMASK(12, 8)
+#define RCC_CSICFGR_CSITRIM_SHIFT		8
+#define RCC_CSICFGR_CSICAL_MASK			GENMASK(23, 16)
+#define RCC_CSICFGR_CSICAL_SHIFT		16
+
+/* RCC_MPCKSELR register fields */
+#define RCC_MPCKSELR_HSI			0x00000000
+#define RCC_MPCKSELR_HSE			0x00000001
+#define RCC_MPCKSELR_PLL			0x00000002
+#define RCC_MPCKSELR_PLL_MPUDIV			0x00000003
+#define RCC_MPCKSELR_MPUSRC_MASK		GENMASK(1, 0)
+#define RCC_MPCKSELR_MPUSRC_SHIFT		0
+#define RCC_MPCKSELR_MPUSRCRDY			BIT(31)
+
+/* RCC_ASSCKSELR register fields */
+#define RCC_ASSCKSELR_HSI			0x00000000
+#define RCC_ASSCKSELR_HSE			0x00000001
+#define RCC_ASSCKSELR_PLL			0x00000002
+#define RCC_ASSCKSELR_AXISSRC_MASK		GENMASK(2, 0)
+#define RCC_ASSCKSELR_AXISSRC_SHIFT		0
+#define RCC_ASSCKSELR_AXISSRCRDY		BIT(31)
+
+/* RCC_RCK12SELR register fields */
+#define RCC_RCK12SELR_PLL12SRC_MASK		GENMASK(1, 0)
+#define RCC_RCK12SELR_PLL12SRC_SHIFT		0
+#define RCC_RCK12SELR_PLL12SRCRDY		BIT(31)
+
+/* RCC_MPCKDIVR register fields */
+#define RCC_MPCKDIVR_MPUDIV_MASK		GENMASK(2, 0)
+#define RCC_MPCKDIVR_MPUDIV_SHIFT		0
+#define RCC_MPCKDIVR_MPUDIVRDY			BIT(31)
+
+/* RCC_AXIDIVR register fields */
+#define RCC_AXIDIVR_AXIDIV_MASK			GENMASK(2, 0)
+#define RCC_AXIDIVR_AXIDIV_SHIFT		0
+#define RCC_AXIDIVR_AXIDIVRDY			BIT(31)
+
+/* RCC_APB4DIVR register fields */
+#define RCC_APB4DIVR_APB4DIV_MASK		GENMASK(2, 0)
+#define RCC_APB4DIVR_APB4DIV_SHIFT		0
+#define RCC_APB4DIVR_APB4DIVRDY			BIT(31)
+
+/* RCC_APB5DIVR register fields */
+#define RCC_APB5DIVR_APB5DIV_MASK		GENMASK(2, 0)
+#define RCC_APB5DIVR_APB5DIV_SHIFT		0
+#define RCC_APB5DIVR_APB5DIVRDY			BIT(31)
+
+/* RCC_RTCDIVR register fields */
+#define RCC_RTCDIVR_RTCDIV_MASK			GENMASK(5, 0)
+#define RCC_RTCDIVR_RTCDIV_SHIFT		0
+
+/* RCC_MSSCKSELR register fields */
+#define RCC_MSSCKSELR_HSI			0x00000000
+#define RCC_MSSCKSELR_HSE			0x00000001
+#define RCC_MSSCKSELR_CSI			0x00000002
+#define RCC_MSSCKSELR_PLL			0x00000003
+#define RCC_MSSCKSELR_MCUSSRC_MASK		GENMASK(1, 0)
+#define RCC_MSSCKSELR_MCUSSRC_SHIFT		0
+#define RCC_MSSCKSELR_MCUSSRCRDY		BIT(31)
+
+/* RCC_PLL1CR register fields */
+#define RCC_PLL1CR_PLLON			BIT(0)
+#define RCC_PLL1CR_PLL1RDY			BIT(1)
+#define RCC_PLL1CR_SSCG_CTRL			BIT(2)
+#define RCC_PLL1CR_DIVPEN			BIT(4)
+#define RCC_PLL1CR_DIVQEN			BIT(5)
+#define RCC_PLL1CR_DIVREN			BIT(6)
+
+/* RCC_PLL1CFGR1 register fields */
+#define RCC_PLL1CFGR1_DIVN_MASK			GENMASK(8, 0)
+#define RCC_PLL1CFGR1_DIVN_SHIFT		0
+#define RCC_PLL1CFGR1_DIVM1_MASK		GENMASK(21, 16)
+#define RCC_PLL1CFGR1_DIVM1_SHIFT		16
+
+/* RCC_PLL1CFGR2 register fields */
+#define RCC_PLL1CFGR2_DIVP_MASK			GENMASK(6, 0)
+#define RCC_PLL1CFGR2_DIVP_SHIFT		0
+#define RCC_PLL1CFGR2_DIVQ_MASK			GENMASK(14, 8)
+#define RCC_PLL1CFGR2_DIVQ_SHIFT		8
+#define RCC_PLL1CFGR2_DIVR_MASK			GENMASK(22, 16)
+#define RCC_PLL1CFGR2_DIVR_SHIFT		16
+
+/* RCC_PLL1FRACR register fields */
+#define RCC_PLL1FRACR_FRACV_MASK		GENMASK(15, 3)
+#define RCC_PLL1FRACR_FRACV_SHIFT		3
+#define RCC_PLL1FRACR_FRACLE			BIT(16)
+
+/* RCC_PLL1CSGR register fields */
+#define RCC_PLL1CSGR_MOD_PER_MASK		GENMASK(12, 0)
+#define RCC_PLL1CSGR_MOD_PER_SHIFT		0
+#define RCC_PLL1CSGR_TPDFN_DIS			BIT(13)
+#define RCC_PLL1CSGR_RPDFN_DIS			BIT(14)
+#define RCC_PLL1CSGR_SSCG_MODE			BIT(15)
+#define RCC_PLL1CSGR_INC_STEP_MASK		GENMASK(30, 16)
+#define RCC_PLL1CSGR_INC_STEP_SHIFT		16
+
+/* RCC_PLL2CR register fields */
+#define RCC_PLL2CR_PLLON			BIT(0)
+#define RCC_PLL2CR_PLL2RDY			BIT(1)
+#define RCC_PLL2CR_SSCG_CTRL			BIT(2)
+#define RCC_PLL2CR_DIVPEN			BIT(4)
+#define RCC_PLL2CR_DIVQEN			BIT(5)
+#define RCC_PLL2CR_DIVREN			BIT(6)
+
+/* RCC_PLL2CFGR1 register fields */
+#define RCC_PLL2CFGR1_DIVN_MASK			GENMASK(8, 0)
+#define RCC_PLL2CFGR1_DIVN_SHIFT		0
+#define RCC_PLL2CFGR1_DIVM2_MASK		GENMASK(21, 16)
+#define RCC_PLL2CFGR1_DIVM2_SHIFT		16
+
+/* RCC_PLL2CFGR2 register fields */
+#define RCC_PLL2CFGR2_DIVP_MASK			GENMASK(6, 0)
+#define RCC_PLL2CFGR2_DIVP_SHIFT		0
+#define RCC_PLL2CFGR2_DIVQ_MASK			GENMASK(14, 8)
+#define RCC_PLL2CFGR2_DIVQ_SHIFT		8
+#define RCC_PLL2CFGR2_DIVR_MASK			GENMASK(22, 16)
+#define RCC_PLL2CFGR2_DIVR_SHIFT		16
+
+/* RCC_PLL2FRACR register fields */
+#define RCC_PLL2FRACR_FRACV_MASK		GENMASK(15, 3)
+#define RCC_PLL2FRACR_FRACV_SHIFT		3
+#define RCC_PLL2FRACR_FRACLE			BIT(16)
+
+/* RCC_PLL2CSGR register fields */
+#define RCC_PLL2CSGR_MOD_PER_MASK		GENMASK(12, 0)
+#define RCC_PLL2CSGR_MOD_PER_SHIFT		0
+#define RCC_PLL2CSGR_TPDFN_DIS			BIT(13)
+#define RCC_PLL2CSGR_RPDFN_DIS			BIT(14)
+#define RCC_PLL2CSGR_SSCG_MODE			BIT(15)
+#define RCC_PLL2CSGR_INC_STEP_MASK		GENMASK(30, 16)
+#define RCC_PLL2CSGR_INC_STEP_SHIFT		16
+
+/* RCC_I2C46CKSELR register fields */
+#define RCC_I2C46CKSELR_I2C46SRC_MASK		GENMASK(2, 0)
+#define RCC_I2C46CKSELR_I2C46SRC_SHIFT		0
+
+/* RCC_SPI6CKSELR register fields */
+#define RCC_SPI6CKSELR_SPI6SRC_MASK		GENMASK(2, 0)
+#define RCC_SPI6CKSELR_SPI6SRC_SHIFT		0
+
+/* RCC_UART1CKSELR register fields */
+#define RCC_UART1CKSELR_UART1SRC_MASK		GENMASK(2, 0)
+#define RCC_UART1CKSELR_UART1SRC_SHIFT		0
+
+/* RCC_RNG1CKSELR register fields */
+#define RCC_RNG1CKSELR_RNG1SRC_MASK		GENMASK(1, 0)
+#define RCC_RNG1CKSELR_RNG1SRC_SHIFT		0
+
+/* RCC_CPERCKSELR register fields */
+#define RCC_CPERCKSELR_HSI			0x00000000
+#define RCC_CPERCKSELR_CSI			0x00000001
+#define RCC_CPERCKSELR_HSE			0x00000002
+#define RCC_CPERCKSELR_CKPERSRC_MASK		GENMASK(1, 0)
+#define RCC_CPERCKSELR_CKPERSRC_SHIFT		0
+
+/* RCC_STGENCKSELR register fields */
+#define RCC_STGENCKSELR_STGENSRC_MASK		GENMASK(1, 0)
+#define RCC_STGENCKSELR_STGENSRC_SHIFT		0
+
+/* RCC_DDRITFCR register fields */
+#define RCC_DDRITFCR_DDRC1EN			BIT(0)
+#define RCC_DDRITFCR_DDRC1LPEN			BIT(1)
+#define RCC_DDRITFCR_DDRC2EN			BIT(2)
+#define RCC_DDRITFCR_DDRC2LPEN			BIT(3)
+#define RCC_DDRITFCR_DDRPHYCEN			BIT(4)
+#define RCC_DDRITFCR_DDRPHYCLPEN		BIT(5)
+#define RCC_DDRITFCR_DDRCAPBEN			BIT(6)
+#define RCC_DDRITFCR_DDRCAPBLPEN		BIT(7)
+#define RCC_DDRITFCR_AXIDCGEN			BIT(8)
+#define RCC_DDRITFCR_DDRPHYCAPBEN		BIT(9)
+#define RCC_DDRITFCR_DDRPHYCAPBLPEN		BIT(10)
+#define RCC_DDRITFCR_KERDCG_DLY_MASK		GENMASK(13, 11)
+#define RCC_DDRITFCR_KERDCG_DLY_SHIFT		11
+#define RCC_DDRITFCR_DDRCAPBRST			BIT(14)
+#define RCC_DDRITFCR_DDRCAXIRST			BIT(15)
+#define RCC_DDRITFCR_DDRCORERST			BIT(16)
+#define RCC_DDRITFCR_DPHYAPBRST			BIT(17)
+#define RCC_DDRITFCR_DPHYRST			BIT(18)
+#define RCC_DDRITFCR_DPHYCTLRST			BIT(19)
+#define RCC_DDRITFCR_DDRCKMOD_MASK		GENMASK(22, 20)
+#define RCC_DDRITFCR_DDRCKMOD_SHIFT		20
+#define RCC_DDRITFCR_DDRCKMOD_SSR		0
+#define RCC_DDRITFCR_DDRCKMOD_ASR1		BIT(20)
+#define RCC_DDRITFCR_DDRCKMOD_HSR1		BIT(21)
+#define RCC_DDRITFCR_GSKPMOD			BIT(23)
+#define RCC_DDRITFCR_GSKPCTRL			BIT(24)
+#define RCC_DDRITFCR_DFILP_WIDTH_MASK		GENMASK(27, 25)
+#define RCC_DDRITFCR_DFILP_WIDTH_SHIFT		25
+#define RCC_DDRITFCR_GSKP_DUR_MASK		GENMASK(31, 28)
+#define RCC_DDRITFCR_GSKP_DUR_SHIFT		28
+
+/* RCC_MP_BOOTCR register fields */
+#define RCC_MP_BOOTCR_MCU_BEN			BIT(0)
+#define RCC_MP_BOOTCR_MPU_BEN			BIT(1)
+
+/* RCC_MP_SREQSETR register fields */
+#define RCC_MP_SREQSETR_STPREQ_P0		BIT(0)
+#define RCC_MP_SREQSETR_STPREQ_P1		BIT(1)
+
+/* RCC_MP_SREQCLRR register fields */
+#define RCC_MP_SREQCLRR_STPREQ_P0		BIT(0)
+#define RCC_MP_SREQCLRR_STPREQ_P1		BIT(1)
+
+/* RCC_MP_GCR register fields */
+#define RCC_MP_GCR_BOOT_MCU			BIT(0)
+
+/* RCC_MP_APRSTCR register fields */
+#define RCC_MP_APRSTCR_RDCTLEN			BIT(0)
+#define RCC_MP_APRSTCR_RSTTO_MASK		GENMASK(14, 8)
+#define RCC_MP_APRSTCR_RSTTO_SHIFT		8
+
+/* RCC_MP_APRSTSR register fields */
+#define RCC_MP_APRSTSR_RSTTOV_MASK		GENMASK(14, 8)
+#define RCC_MP_APRSTSR_RSTTOV_SHIFT		8
+
+/* RCC_BDCR register fields */
+#define RCC_BDCR_LSEON				BIT(0)
+#define RCC_BDCR_LSEBYP				BIT(1)
+#define RCC_BDCR_LSERDY				BIT(2)
+#define RCC_BDCR_DIGBYP				BIT(3)
+#define RCC_BDCR_LSEDRV_MASK			GENMASK(5, 4)
+#define RCC_BDCR_LSEDRV_SHIFT			4
+#define RCC_BDCR_LSECSSON			BIT(8)
+#define RCC_BDCR_LSECSSD			BIT(9)
+#define RCC_BDCR_RTCSRC_MASK			GENMASK(17, 16)
+#define RCC_BDCR_RTCSRC_SHIFT			16
+#define RCC_BDCR_RTCCKEN			BIT(20)
+#define RCC_BDCR_VSWRST				BIT(31)
+
+/* RCC_RDLSICR register fields */
+#define RCC_RDLSICR_LSION			BIT(0)
+#define RCC_RDLSICR_LSIRDY			BIT(1)
+#define RCC_RDLSICR_MRD_MASK			GENMASK(20, 16)
+#define RCC_RDLSICR_MRD_SHIFT			16
+#define RCC_RDLSICR_EADLY_MASK			GENMASK(26, 24)
+#define RCC_RDLSICR_EADLY_SHIFT			24
+#define RCC_RDLSICR_SPARE_MASK			GENMASK(31, 27)
+#define RCC_RDLSICR_SPARE_SHIFT			27
+
+/* RCC_APB4RSTSETR register fields */
+#define RCC_APB4RSTSETR_LTDCRST			BIT(0)
+#define RCC_APB4RSTSETR_DSIRST			BIT(4)
+#define RCC_APB4RSTSETR_DDRPERFMRST		BIT(8)
+#define RCC_APB4RSTSETR_USBPHYRST		BIT(16)
+
+/* RCC_APB4RSTCLRR register fields */
+#define RCC_APB4RSTCLRR_LTDCRST			BIT(0)
+#define RCC_APB4RSTCLRR_DSIRST			BIT(4)
+#define RCC_APB4RSTCLRR_DDRPERFMRST		BIT(8)
+#define RCC_APB4RSTCLRR_USBPHYRST		BIT(16)
+
+/* RCC_APB5RSTSETR register fields */
+#define RCC_APB5RSTSETR_SPI6RST			BIT(0)
+#define RCC_APB5RSTSETR_I2C4RST			BIT(2)
+#define RCC_APB5RSTSETR_I2C6RST			BIT(3)
+#define RCC_APB5RSTSETR_USART1RST		BIT(4)
+#define RCC_APB5RSTSETR_STGENRST		BIT(20)
+
+/* RCC_APB5RSTCLRR register fields */
+#define RCC_APB5RSTCLRR_SPI6RST			BIT(0)
+#define RCC_APB5RSTCLRR_I2C4RST			BIT(2)
+#define RCC_APB5RSTCLRR_I2C6RST			BIT(3)
+#define RCC_APB5RSTCLRR_USART1RST		BIT(4)
+#define RCC_APB5RSTCLRR_STGENRST		BIT(20)
+
+/* RCC_AHB5RSTSETR register fields */
+#define RCC_AHB5RSTSETR_GPIOZRST		BIT(0)
+#define RCC_AHB5RSTSETR_CRYP1RST		BIT(4)
+#define RCC_AHB5RSTSETR_HASH1RST		BIT(5)
+#define RCC_AHB5RSTSETR_RNG1RST			BIT(6)
+#define RCC_AHB5RSTSETR_AXIMCRST		BIT(16)
+
+/* RCC_AHB5RSTCLRR register fields */
+#define RCC_AHB5RSTCLRR_GPIOZRST		BIT(0)
+#define RCC_AHB5RSTCLRR_CRYP1RST		BIT(4)
+#define RCC_AHB5RSTCLRR_HASH1RST		BIT(5)
+#define RCC_AHB5RSTCLRR_RNG1RST			BIT(6)
+#define RCC_AHB5RSTCLRR_AXIMCRST		BIT(16)
+
+/* RCC_AHB6RSTSETR register fields */
+#define RCC_AHB6RSTSETR_GPURST			BIT(5)
+#define RCC_AHB6RSTSETR_ETHMACRST		BIT(10)
+#define RCC_AHB6RSTSETR_FMCRST			BIT(12)
+#define RCC_AHB6RSTSETR_QSPIRST			BIT(14)
+#define RCC_AHB6RSTSETR_SDMMC1RST		BIT(16)
+#define RCC_AHB6RSTSETR_SDMMC2RST		BIT(17)
+#define RCC_AHB6RSTSETR_CRC1RST			BIT(20)
+#define RCC_AHB6RSTSETR_USBHRST			BIT(24)
+
+/* RCC_AHB6RSTCLRR register fields */
+#define RCC_AHB6RSTCLRR_ETHMACRST		BIT(10)
+#define RCC_AHB6RSTCLRR_FMCRST			BIT(12)
+#define RCC_AHB6RSTCLRR_QSPIRST			BIT(14)
+#define RCC_AHB6RSTCLRR_SDMMC1RST		BIT(16)
+#define RCC_AHB6RSTCLRR_SDMMC2RST		BIT(17)
+#define RCC_AHB6RSTCLRR_CRC1RST			BIT(20)
+#define RCC_AHB6RSTCLRR_USBHRST			BIT(24)
+
+/* RCC_TZAHB6RSTSETR register fields */
+#define RCC_TZAHB6RSTSETR_MDMARST		BIT(0)
+
+/* RCC_TZAHB6RSTCLRR register fields */
+#define RCC_TZAHB6RSTCLRR_MDMARST		BIT(0)
+
+/* RCC_MP_APB4ENSETR register fields */
+#define RCC_MP_APB4ENSETR_LTDCEN		BIT(0)
+#define RCC_MP_APB4ENSETR_DSIEN			BIT(4)
+#define RCC_MP_APB4ENSETR_DDRPERFMEN		BIT(8)
+#define RCC_MP_APB4ENSETR_IWDG2APBEN		BIT(15)
+#define RCC_MP_APB4ENSETR_USBPHYEN		BIT(16)
+#define RCC_MP_APB4ENSETR_STGENROEN		BIT(20)
+
+/* RCC_MP_APB4ENCLRR register fields */
+#define RCC_MP_APB4ENCLRR_LTDCEN		BIT(0)
+#define RCC_MP_APB4ENCLRR_DSIEN			BIT(4)
+#define RCC_MP_APB4ENCLRR_DDRPERFMEN		BIT(8)
+#define RCC_MP_APB4ENCLRR_IWDG2APBEN		BIT(15)
+#define RCC_MP_APB4ENCLRR_USBPHYEN		BIT(16)
+#define RCC_MP_APB4ENCLRR_STGENROEN		BIT(20)
+
+/* RCC_MP_APB5ENSETR register fields */
+#define RCC_MP_APB5ENSETR_SPI6EN		BIT(0)
+#define RCC_MP_APB5ENSETR_I2C4EN		BIT(2)
+#define RCC_MP_APB5ENSETR_I2C6EN		BIT(3)
+#define RCC_MP_APB5ENSETR_USART1EN		BIT(4)
+#define RCC_MP_APB5ENSETR_RTCAPBEN		BIT(8)
+#define RCC_MP_APB5ENSETR_TZC1EN		BIT(11)
+#define RCC_MP_APB5ENSETR_TZC2EN		BIT(12)
+#define RCC_MP_APB5ENSETR_TZPCEN		BIT(13)
+#define RCC_MP_APB5ENSETR_IWDG1APBEN		BIT(15)
+#define RCC_MP_APB5ENSETR_BSECEN		BIT(16)
+#define RCC_MP_APB5ENSETR_STGENEN		BIT(20)
+
+/* RCC_MP_APB5ENCLRR register fields */
+#define RCC_MP_APB5ENCLRR_SPI6EN		BIT(0)
+#define RCC_MP_APB5ENCLRR_I2C4EN		BIT(2)
+#define RCC_MP_APB5ENCLRR_I2C6EN		BIT(3)
+#define RCC_MP_APB5ENCLRR_USART1EN		BIT(4)
+#define RCC_MP_APB5ENCLRR_RTCAPBEN		BIT(8)
+#define RCC_MP_APB5ENCLRR_TZC1EN		BIT(11)
+#define RCC_MP_APB5ENCLRR_TZC2EN		BIT(12)
+#define RCC_MP_APB5ENCLRR_TZPCEN		BIT(13)
+#define RCC_MP_APB5ENCLRR_IWDG1APBEN		BIT(15)
+#define RCC_MP_APB5ENCLRR_BSECEN		BIT(16)
+#define RCC_MP_APB5ENCLRR_STGENEN		BIT(20)
+
+/* RCC_MP_AHB5ENSETR register fields */
+#define RCC_MP_AHB5ENSETR_GPIOZEN		BIT(0)
+#define RCC_MP_AHB5ENSETR_CRYP1EN		BIT(4)
+#define RCC_MP_AHB5ENSETR_HASH1EN		BIT(5)
+#define RCC_MP_AHB5ENSETR_RNG1EN		BIT(6)
+#define RCC_MP_AHB5ENSETR_BKPSRAMEN		BIT(8)
+#define RCC_MP_AHB5ENSETR_AXIMCEN		BIT(16)
+
+/* RCC_MP_AHB5ENCLRR register fields */
+#define RCC_MP_AHB5ENCLRR_GPIOZEN		BIT(0)
+#define RCC_MP_AHB5ENCLRR_CRYP1EN		BIT(4)
+#define RCC_MP_AHB5ENCLRR_HASH1EN		BIT(5)
+#define RCC_MP_AHB5ENCLRR_RNG1EN		BIT(6)
+#define RCC_MP_AHB5ENCLRR_BKPSRAMEN		BIT(8)
+#define RCC_MP_AHB5ENCLRR_AXIMCEN		BIT(16)
+
+/* RCC_MP_AHB6ENSETR register fields */
+#define RCC_MP_AHB6ENSETR_MDMAEN		BIT(0)
+#define RCC_MP_AHB6ENSETR_GPUEN			BIT(5)
+#define RCC_MP_AHB6ENSETR_ETHCKEN		BIT(7)
+#define RCC_MP_AHB6ENSETR_ETHTXEN		BIT(8)
+#define RCC_MP_AHB6ENSETR_ETHRXEN		BIT(9)
+#define RCC_MP_AHB6ENSETR_ETHMACEN		BIT(10)
+#define RCC_MP_AHB6ENSETR_FMCEN			BIT(12)
+#define RCC_MP_AHB6ENSETR_QSPIEN		BIT(14)
+#define RCC_MP_AHB6ENSETR_SDMMC1EN		BIT(16)
+#define RCC_MP_AHB6ENSETR_SDMMC2EN		BIT(17)
+#define RCC_MP_AHB6ENSETR_CRC1EN		BIT(20)
+#define RCC_MP_AHB6ENSETR_USBHEN		BIT(24)
+
+/* RCC_MP_AHB6ENCLRR register fields */
+#define RCC_MP_AHB6ENCLRR_MDMAEN		BIT(0)
+#define RCC_MP_AHB6ENCLRR_GPUEN			BIT(5)
+#define RCC_MP_AHB6ENCLRR_ETHCKEN		BIT(7)
+#define RCC_MP_AHB6ENCLRR_ETHTXEN		BIT(8)
+#define RCC_MP_AHB6ENCLRR_ETHRXEN		BIT(9)
+#define RCC_MP_AHB6ENCLRR_ETHMACEN		BIT(10)
+#define RCC_MP_AHB6ENCLRR_FMCEN			BIT(12)
+#define RCC_MP_AHB6ENCLRR_QSPIEN		BIT(14)
+#define RCC_MP_AHB6ENCLRR_SDMMC1EN		BIT(16)
+#define RCC_MP_AHB6ENCLRR_SDMMC2EN		BIT(17)
+#define RCC_MP_AHB6ENCLRR_CRC1EN		BIT(20)
+#define RCC_MP_AHB6ENCLRR_USBHEN		BIT(24)
+
+/* RCC_MP_TZAHB6ENSETR register fields */
+#define RCC_MP_TZAHB6ENSETR_MDMAEN		BIT(0)
+
+/* RCC_MP_TZAHB6ENCLRR register fields */
+#define RCC_MP_TZAHB6ENCLRR_MDMAEN		BIT(0)
+
+/* RCC_MC_APB4ENSETR register fields */
+#define RCC_MC_APB4ENSETR_LTDCEN		BIT(0)
+#define RCC_MC_APB4ENSETR_DSIEN			BIT(4)
+#define RCC_MC_APB4ENSETR_DDRPERFMEN		BIT(8)
+#define RCC_MC_APB4ENSETR_USBPHYEN		BIT(16)
+#define RCC_MC_APB4ENSETR_STGENROEN		BIT(20)
+
+/* RCC_MC_APB4ENCLRR register fields */
+#define RCC_MC_APB4ENCLRR_LTDCEN		BIT(0)
+#define RCC_MC_APB4ENCLRR_DSIEN			BIT(4)
+#define RCC_MC_APB4ENCLRR_DDRPERFMEN		BIT(8)
+#define RCC_MC_APB4ENCLRR_USBPHYEN		BIT(16)
+#define RCC_MC_APB4ENCLRR_STGENROEN		BIT(20)
+
+/* RCC_MC_APB5ENSETR register fields */
+#define RCC_MC_APB5ENSETR_SPI6EN		BIT(0)
+#define RCC_MC_APB5ENSETR_I2C4EN		BIT(2)
+#define RCC_MC_APB5ENSETR_I2C6EN		BIT(3)
+#define RCC_MC_APB5ENSETR_USART1EN		BIT(4)
+#define RCC_MC_APB5ENSETR_RTCAPBEN		BIT(8)
+#define RCC_MC_APB5ENSETR_TZC1EN		BIT(11)
+#define RCC_MC_APB5ENSETR_TZC2EN		BIT(12)
+#define RCC_MC_APB5ENSETR_TZPCEN		BIT(13)
+#define RCC_MC_APB5ENSETR_BSECEN		BIT(16)
+#define RCC_MC_APB5ENSETR_STGENEN		BIT(20)
+
+/* RCC_MC_APB5ENCLRR register fields */
+#define RCC_MC_APB5ENCLRR_SPI6EN		BIT(0)
+#define RCC_MC_APB5ENCLRR_I2C4EN		BIT(2)
+#define RCC_MC_APB5ENCLRR_I2C6EN		BIT(3)
+#define RCC_MC_APB5ENCLRR_USART1EN		BIT(4)
+#define RCC_MC_APB5ENCLRR_RTCAPBEN		BIT(8)
+#define RCC_MC_APB5ENCLRR_TZC1EN		BIT(11)
+#define RCC_MC_APB5ENCLRR_TZC2EN		BIT(12)
+#define RCC_MC_APB5ENCLRR_TZPCEN		BIT(13)
+#define RCC_MC_APB5ENCLRR_BSECEN		BIT(16)
+#define RCC_MC_APB5ENCLRR_STGENEN		BIT(20)
+
+/* RCC_MC_AHB5ENSETR register fields */
+#define RCC_MC_AHB5ENSETR_GPIOZEN		BIT(0)
+#define RCC_MC_AHB5ENSETR_CRYP1EN		BIT(4)
+#define RCC_MC_AHB5ENSETR_HASH1EN		BIT(5)
+#define RCC_MC_AHB5ENSETR_RNG1EN		BIT(6)
+#define RCC_MC_AHB5ENSETR_BKPSRAMEN		BIT(8)
+
+/* RCC_MC_AHB5ENCLRR register fields */
+#define RCC_MC_AHB5ENCLRR_GPIOZEN		BIT(0)
+#define RCC_MC_AHB5ENCLRR_CRYP1EN		BIT(4)
+#define RCC_MC_AHB5ENCLRR_HASH1EN		BIT(5)
+#define RCC_MC_AHB5ENCLRR_RNG1EN		BIT(6)
+#define RCC_MC_AHB5ENCLRR_BKPSRAMEN		BIT(8)
+
+/* RCC_MC_AHB6ENSETR register fields */
+#define RCC_MC_AHB6ENSETR_MDMAEN		BIT(0)
+#define RCC_MC_AHB6ENSETR_GPUEN			BIT(5)
+#define RCC_MC_AHB6ENSETR_ETHCKEN		BIT(7)
+#define RCC_MC_AHB6ENSETR_ETHTXEN		BIT(8)
+#define RCC_MC_AHB6ENSETR_ETHRXEN		BIT(9)
+#define RCC_MC_AHB6ENSETR_ETHMACEN		BIT(10)
+#define RCC_MC_AHB6ENSETR_FMCEN			BIT(12)
+#define RCC_MC_AHB6ENSETR_QSPIEN		BIT(14)
+#define RCC_MC_AHB6ENSETR_SDMMC1EN		BIT(16)
+#define RCC_MC_AHB6ENSETR_SDMMC2EN		BIT(17)
+#define RCC_MC_AHB6ENSETR_CRC1EN		BIT(20)
+#define RCC_MC_AHB6ENSETR_USBHEN		BIT(24)
+
+/* RCC_MC_AHB6ENCLRR register fields */
+#define RCC_MC_AHB6ENCLRR_MDMAEN		BIT(0)
+#define RCC_MC_AHB6ENCLRR_GPUEN			BIT(5)
+#define RCC_MC_AHB6ENCLRR_ETHCKEN		BIT(7)
+#define RCC_MC_AHB6ENCLRR_ETHTXEN		BIT(8)
+#define RCC_MC_AHB6ENCLRR_ETHRXEN		BIT(9)
+#define RCC_MC_AHB6ENCLRR_ETHMACEN		BIT(10)
+#define RCC_MC_AHB6ENCLRR_FMCEN			BIT(12)
+#define RCC_MC_AHB6ENCLRR_QSPIEN		BIT(14)
+#define RCC_MC_AHB6ENCLRR_SDMMC1EN		BIT(16)
+#define RCC_MC_AHB6ENCLRR_SDMMC2EN		BIT(17)
+#define RCC_MC_AHB6ENCLRR_CRC1EN		BIT(20)
+#define RCC_MC_AHB6ENCLRR_USBHEN		BIT(24)
+
+/* RCC_MP_APB4LPENSETR register fields */
+#define RCC_MP_APB4LPENSETR_LTDCLPEN		BIT(0)
+#define RCC_MP_APB4LPENSETR_DSILPEN		BIT(4)
+#define RCC_MP_APB4LPENSETR_DDRPERFMLPEN	BIT(8)
+#define RCC_MP_APB4LPENSETR_IWDG2APBLPEN	BIT(15)
+#define RCC_MP_APB4LPENSETR_USBPHYLPEN		BIT(16)
+#define RCC_MP_APB4LPENSETR_STGENROLPEN		BIT(20)
+#define RCC_MP_APB4LPENSETR_STGENROSTPEN	BIT(21)
+
+/* RCC_MP_APB4LPENCLRR register fields */
+#define RCC_MP_APB4LPENCLRR_LTDCLPEN		BIT(0)
+#define RCC_MP_APB4LPENCLRR_DSILPEN		BIT(4)
+#define RCC_MP_APB4LPENCLRR_DDRPERFMLPEN	BIT(8)
+#define RCC_MP_APB4LPENCLRR_IWDG2APBLPEN	BIT(15)
+#define RCC_MP_APB4LPENCLRR_USBPHYLPEN		BIT(16)
+#define RCC_MP_APB4LPENCLRR_STGENROLPEN		BIT(20)
+#define RCC_MP_APB4LPENCLRR_STGENROSTPEN	BIT(21)
+
+/* RCC_MP_APB5LPENSETR register fields */
+#define RCC_MP_APB5LPENSETR_SPI6LPEN		BIT(0)
+#define RCC_MP_APB5LPENSETR_I2C4LPEN		BIT(2)
+#define RCC_MP_APB5LPENSETR_I2C6LPEN		BIT(3)
+#define RCC_MP_APB5LPENSETR_USART1LPEN		BIT(4)
+#define RCC_MP_APB5LPENSETR_RTCAPBLPEN		BIT(8)
+#define RCC_MP_APB5LPENSETR_TZC1LPEN		BIT(11)
+#define RCC_MP_APB5LPENSETR_TZC2LPEN		BIT(12)
+#define RCC_MP_APB5LPENSETR_TZPCLPEN		BIT(13)
+#define RCC_MP_APB5LPENSETR_IWDG1APBLPEN	BIT(15)
+#define RCC_MP_APB5LPENSETR_BSECLPEN		BIT(16)
+#define RCC_MP_APB5LPENSETR_STGENLPEN		BIT(20)
+#define RCC_MP_APB5LPENSETR_STGENSTPEN		BIT(21)
+
+/* RCC_MP_APB5LPENCLRR register fields */
+#define RCC_MP_APB5LPENCLRR_SPI6LPEN		BIT(0)
+#define RCC_MP_APB5LPENCLRR_I2C4LPEN		BIT(2)
+#define RCC_MP_APB5LPENCLRR_I2C6LPEN		BIT(3)
+#define RCC_MP_APB5LPENCLRR_USART1LPEN		BIT(4)
+#define RCC_MP_APB5LPENCLRR_RTCAPBLPEN		BIT(8)
+#define RCC_MP_APB5LPENCLRR_TZC1LPEN		BIT(11)
+#define RCC_MP_APB5LPENCLRR_TZC2LPEN		BIT(12)
+#define RCC_MP_APB5LPENCLRR_TZPCLPEN		BIT(13)
+#define RCC_MP_APB5LPENCLRR_IWDG1APBLPEN	BIT(15)
+#define RCC_MP_APB5LPENCLRR_BSECLPEN		BIT(16)
+#define RCC_MP_APB5LPENCLRR_STGENLPEN		BIT(20)
+#define RCC_MP_APB5LPENCLRR_STGENSTPEN		BIT(21)
+
+/* RCC_MP_AHB5LPENSETR register fields */
+#define RCC_MP_AHB5LPENSETR_GPIOZLPEN		BIT(0)
+#define RCC_MP_AHB5LPENSETR_CRYP1LPEN		BIT(4)
+#define RCC_MP_AHB5LPENSETR_HASH1LPEN		BIT(5)
+#define RCC_MP_AHB5LPENSETR_RNG1LPEN		BIT(6)
+#define RCC_MP_AHB5LPENSETR_BKPSRAMLPEN		BIT(8)
+
+/* RCC_MP_AHB5LPENCLRR register fields */
+#define RCC_MP_AHB5LPENCLRR_GPIOZLPEN		BIT(0)
+#define RCC_MP_AHB5LPENCLRR_CRYP1LPEN		BIT(4)
+#define RCC_MP_AHB5LPENCLRR_HASH1LPEN		BIT(5)
+#define RCC_MP_AHB5LPENCLRR_RNG1LPEN		BIT(6)
+#define RCC_MP_AHB5LPENCLRR_BKPSRAMLPEN		BIT(8)
+
+/* RCC_MP_AHB6LPENSETR register fields */
+#define RCC_MP_AHB6LPENSETR_MDMALPEN		BIT(0)
+#define RCC_MP_AHB6LPENSETR_GPULPEN		BIT(5)
+#define RCC_MP_AHB6LPENSETR_ETHCKLPEN		BIT(7)
+#define RCC_MP_AHB6LPENSETR_ETHTXLPEN		BIT(8)
+#define RCC_MP_AHB6LPENSETR_ETHRXLPEN		BIT(9)
+#define RCC_MP_AHB6LPENSETR_ETHMACLPEN		BIT(10)
+#define RCC_MP_AHB6LPENSETR_ETHSTPEN		BIT(11)
+#define RCC_MP_AHB6LPENSETR_FMCLPEN		BIT(12)
+#define RCC_MP_AHB6LPENSETR_QSPILPEN		BIT(14)
+#define RCC_MP_AHB6LPENSETR_SDMMC1LPEN		BIT(16)
+#define RCC_MP_AHB6LPENSETR_SDMMC2LPEN		BIT(17)
+#define RCC_MP_AHB6LPENSETR_CRC1LPEN		BIT(20)
+#define RCC_MP_AHB6LPENSETR_USBHLPEN		BIT(24)
+
+/* RCC_MP_AHB6LPENCLRR register fields */
+#define RCC_MP_AHB6LPENCLRR_MDMALPEN		BIT(0)
+#define RCC_MP_AHB6LPENCLRR_GPULPEN		BIT(5)
+#define RCC_MP_AHB6LPENCLRR_ETHCKLPEN		BIT(7)
+#define RCC_MP_AHB6LPENCLRR_ETHTXLPEN		BIT(8)
+#define RCC_MP_AHB6LPENCLRR_ETHRXLPEN		BIT(9)
+#define RCC_MP_AHB6LPENCLRR_ETHMACLPEN		BIT(10)
+#define RCC_MP_AHB6LPENCLRR_ETHSTPEN		BIT(11)
+#define RCC_MP_AHB6LPENCLRR_FMCLPEN		BIT(12)
+#define RCC_MP_AHB6LPENCLRR_QSPILPEN		BIT(14)
+#define RCC_MP_AHB6LPENCLRR_SDMMC1LPEN		BIT(16)
+#define RCC_MP_AHB6LPENCLRR_SDMMC2LPEN		BIT(17)
+#define RCC_MP_AHB6LPENCLRR_CRC1LPEN		BIT(20)
+#define RCC_MP_AHB6LPENCLRR_USBHLPEN		BIT(24)
+
+/* RCC_MP_TZAHB6LPENSETR register fields */
+#define RCC_MP_TZAHB6LPENSETR_MDMALPEN		BIT(0)
+
+/* RCC_MP_TZAHB6LPENCLRR register fields */
+#define RCC_MP_TZAHB6LPENCLRR_MDMALPEN		BIT(0)
+
+/* RCC_MC_APB4LPENSETR register fields */
+#define RCC_MC_APB4LPENSETR_LTDCLPEN		BIT(0)
+#define RCC_MC_APB4LPENSETR_DSILPEN		BIT(4)
+#define RCC_MC_APB4LPENSETR_DDRPERFMLPEN	BIT(8)
+#define RCC_MC_APB4LPENSETR_USBPHYLPEN		BIT(16)
+#define RCC_MC_APB4LPENSETR_STGENROLPEN		BIT(20)
+#define RCC_MC_APB4LPENSETR_STGENROSTPEN	BIT(21)
+
+/* RCC_MC_APB4LPENCLRR register fields */
+#define RCC_MC_APB4LPENCLRR_LTDCLPEN		BIT(0)
+#define RCC_MC_APB4LPENCLRR_DSILPEN		BIT(4)
+#define RCC_MC_APB4LPENCLRR_DDRPERFMLPEN	BIT(8)
+#define RCC_MC_APB4LPENCLRR_USBPHYLPEN		BIT(16)
+#define RCC_MC_APB4LPENCLRR_STGENROLPEN		BIT(20)
+#define RCC_MC_APB4LPENCLRR_STGENROSTPEN	BIT(21)
+
+/* RCC_MC_APB5LPENSETR register fields */
+#define RCC_MC_APB5LPENSETR_SPI6LPEN		BIT(0)
+#define RCC_MC_APB5LPENSETR_I2C4LPEN		BIT(2)
+#define RCC_MC_APB5LPENSETR_I2C6LPEN		BIT(3)
+#define RCC_MC_APB5LPENSETR_USART1LPEN		BIT(4)
+#define RCC_MC_APB5LPENSETR_RTCAPBLPEN		BIT(8)
+#define RCC_MC_APB5LPENSETR_TZC1LPEN		BIT(11)
+#define RCC_MC_APB5LPENSETR_TZC2LPEN		BIT(12)
+#define RCC_MC_APB5LPENSETR_TZPCLPEN		BIT(13)
+#define RCC_MC_APB5LPENSETR_BSECLPEN		BIT(16)
+#define RCC_MC_APB5LPENSETR_STGENLPEN		BIT(20)
+#define RCC_MC_APB5LPENSETR_STGENSTPEN		BIT(21)
+
+/* RCC_MC_APB5LPENCLRR register fields */
+#define RCC_MC_APB5LPENCLRR_SPI6LPEN		BIT(0)
+#define RCC_MC_APB5LPENCLRR_I2C4LPEN		BIT(2)
+#define RCC_MC_APB5LPENCLRR_I2C6LPEN		BIT(3)
+#define RCC_MC_APB5LPENCLRR_USART1LPEN		BIT(4)
+#define RCC_MC_APB5LPENCLRR_RTCAPBLPEN		BIT(8)
+#define RCC_MC_APB5LPENCLRR_TZC1LPEN		BIT(11)
+#define RCC_MC_APB5LPENCLRR_TZC2LPEN		BIT(12)
+#define RCC_MC_APB5LPENCLRR_TZPCLPEN		BIT(13)
+#define RCC_MC_APB5LPENCLRR_BSECLPEN		BIT(16)
+#define RCC_MC_APB5LPENCLRR_STGENLPEN		BIT(20)
+#define RCC_MC_APB5LPENCLRR_STGENSTPEN		BIT(21)
+
+/* RCC_MC_AHB5LPENSETR register fields */
+#define RCC_MC_AHB5LPENSETR_GPIOZLPEN		BIT(0)
+#define RCC_MC_AHB5LPENSETR_CRYP1LPEN		BIT(4)
+#define RCC_MC_AHB5LPENSETR_HASH1LPEN		BIT(5)
+#define RCC_MC_AHB5LPENSETR_RNG1LPEN		BIT(6)
+#define RCC_MC_AHB5LPENSETR_BKPSRAMLPEN		BIT(8)
+
+/* RCC_MC_AHB5LPENCLRR register fields */
+#define RCC_MC_AHB5LPENCLRR_GPIOZLPEN		BIT(0)
+#define RCC_MC_AHB5LPENCLRR_CRYP1LPEN		BIT(4)
+#define RCC_MC_AHB5LPENCLRR_HASH1LPEN		BIT(5)
+#define RCC_MC_AHB5LPENCLRR_RNG1LPEN		BIT(6)
+#define RCC_MC_AHB5LPENCLRR_BKPSRAMLPEN		BIT(8)
+
+/* RCC_MC_AHB6LPENSETR register fields */
+#define RCC_MC_AHB6LPENSETR_MDMALPEN		BIT(0)
+#define RCC_MC_AHB6LPENSETR_GPULPEN		BIT(5)
+#define RCC_MC_AHB6LPENSETR_ETHCKLPEN		BIT(7)
+#define RCC_MC_AHB6LPENSETR_ETHTXLPEN		BIT(8)
+#define RCC_MC_AHB6LPENSETR_ETHRXLPEN		BIT(9)
+#define RCC_MC_AHB6LPENSETR_ETHMACLPEN		BIT(10)
+#define RCC_MC_AHB6LPENSETR_ETHSTPEN		BIT(11)
+#define RCC_MC_AHB6LPENSETR_FMCLPEN		BIT(12)
+#define RCC_MC_AHB6LPENSETR_QSPILPEN		BIT(14)
+#define RCC_MC_AHB6LPENSETR_SDMMC1LPEN		BIT(16)
+#define RCC_MC_AHB6LPENSETR_SDMMC2LPEN		BIT(17)
+#define RCC_MC_AHB6LPENSETR_CRC1LPEN		BIT(20)
+#define RCC_MC_AHB6LPENSETR_USBHLPEN		BIT(24)
+
+/* RCC_MC_AHB6LPENCLRR register fields */
+#define RCC_MC_AHB6LPENCLRR_MDMALPEN		BIT(0)
+#define RCC_MC_AHB6LPENCLRR_GPULPEN		BIT(5)
+#define RCC_MC_AHB6LPENCLRR_ETHCKLPEN		BIT(7)
+#define RCC_MC_AHB6LPENCLRR_ETHTXLPEN		BIT(8)
+#define RCC_MC_AHB6LPENCLRR_ETHRXLPEN		BIT(9)
+#define RCC_MC_AHB6LPENCLRR_ETHMACLPEN		BIT(10)
+#define RCC_MC_AHB6LPENCLRR_ETHSTPEN		BIT(11)
+#define RCC_MC_AHB6LPENCLRR_FMCLPEN		BIT(12)
+#define RCC_MC_AHB6LPENCLRR_QSPILPEN		BIT(14)
+#define RCC_MC_AHB6LPENCLRR_SDMMC1LPEN		BIT(16)
+#define RCC_MC_AHB6LPENCLRR_SDMMC2LPEN		BIT(17)
+#define RCC_MC_AHB6LPENCLRR_CRC1LPEN		BIT(20)
+#define RCC_MC_AHB6LPENCLRR_USBHLPEN		BIT(24)
+
+/* RCC_BR_RSTSCLRR register fields */
+#define RCC_BR_RSTSCLRR_PORRSTF			BIT(0)
+#define RCC_BR_RSTSCLRR_BORRSTF			BIT(1)
+#define RCC_BR_RSTSCLRR_PADRSTF			BIT(2)
+#define RCC_BR_RSTSCLRR_HCSSRSTF		BIT(3)
+#define RCC_BR_RSTSCLRR_VCORERSTF		BIT(4)
+#define RCC_BR_RSTSCLRR_MPSYSRSTF		BIT(6)
+#define RCC_BR_RSTSCLRR_MCSYSRSTF		BIT(7)
+#define RCC_BR_RSTSCLRR_IWDG1RSTF		BIT(8)
+#define RCC_BR_RSTSCLRR_IWDG2RSTF		BIT(9)
+#define RCC_BR_RSTSCLRR_MPUP0RSTF		BIT(13)
+#define RCC_BR_RSTSCLRR_MPUP1RSTF		BIT(14)
+
+/* RCC_MP_GRSTCSETR register fields */
+#define RCC_MP_GRSTCSETR_MPSYSRST		BIT(0)
+#define RCC_MP_GRSTCSETR_MCURST			BIT(1)
+#define RCC_MP_GRSTCSETR_MPUP0RST		BIT(4)
+#define RCC_MP_GRSTCSETR_MPUP1RST		BIT(5)
+
+/* RCC_MP_RSTSCLRR register fields */
+#define RCC_MP_RSTSCLRR_PORRSTF			BIT(0)
+#define RCC_MP_RSTSCLRR_BORRSTF			BIT(1)
+#define RCC_MP_RSTSCLRR_PADRSTF			BIT(2)
+#define RCC_MP_RSTSCLRR_HCSSRSTF		BIT(3)
+#define RCC_MP_RSTSCLRR_VCORERSTF		BIT(4)
+#define RCC_MP_RSTSCLRR_MPSYSRSTF		BIT(6)
+#define RCC_MP_RSTSCLRR_MCSYSRSTF		BIT(7)
+#define RCC_MP_RSTSCLRR_IWDG1RSTF		BIT(8)
+#define RCC_MP_RSTSCLRR_IWDG2RSTF		BIT(9)
+#define RCC_MP_RSTSCLRR_STDBYRSTF		BIT(11)
+#define RCC_MP_RSTSCLRR_CSTDBYRSTF		BIT(12)
+#define RCC_MP_RSTSCLRR_MPUP0RSTF		BIT(13)
+#define RCC_MP_RSTSCLRR_MPUP1RSTF		BIT(14)
+#define RCC_MP_RSTSCLRR_SPARE			BIT(15)
+
+/* RCC_MP_IWDGFZSETR register fields */
+#define RCC_MP_IWDGFZSETR_FZ_IWDG1		BIT(0)
+#define RCC_MP_IWDGFZSETR_FZ_IWDG2		BIT(1)
+
+/* RCC_MP_IWDGFZCLRR register fields */
+#define RCC_MP_IWDGFZCLRR_FZ_IWDG1		BIT(0)
+#define RCC_MP_IWDGFZCLRR_FZ_IWDG2		BIT(1)
+
+/* RCC_MP_CIER register fields */
+#define RCC_MP_CIER_LSIRDYIE			BIT(0)
+#define RCC_MP_CIER_LSERDYIE			BIT(1)
+#define RCC_MP_CIER_HSIRDYIE			BIT(2)
+#define RCC_MP_CIER_HSERDYIE			BIT(3)
+#define RCC_MP_CIER_CSIRDYIE			BIT(4)
+#define RCC_MP_CIER_PLL1DYIE			BIT(8)
+#define RCC_MP_CIER_PLL2DYIE			BIT(9)
+#define RCC_MP_CIER_PLL3DYIE			BIT(10)
+#define RCC_MP_CIER_PLL4DYIE			BIT(11)
+#define RCC_MP_CIER_LSECSSIE			BIT(16)
+#define RCC_MP_CIER_WKUPIE			BIT(20)
+
+/* RCC_MP_CIFR register fields */
+#define RCC_MP_CIFR_MASK			U(0x110F1F)
+#define RCC_MP_CIFR_LSIRDYF			BIT(0)
+#define RCC_MP_CIFR_LSERDYF			BIT(1)
+#define RCC_MP_CIFR_HSIRDYF			BIT(2)
+#define RCC_MP_CIFR_HSERDYF			BIT(3)
+#define RCC_MP_CIFR_CSIRDYF			BIT(4)
+#define RCC_MP_CIFR_PLL1DYF			BIT(8)
+#define RCC_MP_CIFR_PLL2DYF			BIT(9)
+#define RCC_MP_CIFR_PLL3DYF			BIT(10)
+#define RCC_MP_CIFR_PLL4DYF			BIT(11)
+#define RCC_MP_CIFR_LSECSSF			BIT(16)
+#define RCC_MP_CIFR_WKUPF			BIT(20)
+
+/* RCC_PWRLPDLYCR register fields */
+#define RCC_PWRLPDLYCR_PWRLP_DLY_MASK		GENMASK(21, 0)
+#define RCC_PWRLPDLYCR_PWRLP_DLY_SHIFT		0
+#define RCC_PWRLPDLYCR_MCTMPSKP			BIT(24)
+
+/* RCC_MP_RSTSSETR register fields */
+#define RCC_MP_RSTSSETR_PORRSTF			BIT(0)
+#define RCC_MP_RSTSSETR_BORRSTF			BIT(1)
+#define RCC_MP_RSTSSETR_PADRSTF			BIT(2)
+#define RCC_MP_RSTSSETR_HCSSRSTF		BIT(3)
+#define RCC_MP_RSTSSETR_VCORERSTF		BIT(4)
+#define RCC_MP_RSTSSETR_MPSYSRSTF		BIT(6)
+#define RCC_MP_RSTSSETR_MCSYSRSTF		BIT(7)
+#define RCC_MP_RSTSSETR_IWDG1RSTF		BIT(8)
+#define RCC_MP_RSTSSETR_IWDG2RSTF		BIT(9)
+#define RCC_MP_RSTSSETR_STDBYRSTF		BIT(11)
+#define RCC_MP_RSTSSETR_CSTDBYRSTF		BIT(12)
+#define RCC_MP_RSTSSETR_MPUP0RSTF		BIT(13)
+#define RCC_MP_RSTSSETR_MPUP1RSTF		BIT(14)
+#define RCC_MP_RSTSSETR_SPARE			BIT(15)
+
+/* RCC_MCO1CFGR register fields */
+#define RCC_MCO1CFGR_MCO1SEL_MASK		GENMASK(2, 0)
+#define RCC_MCO1CFGR_MCO1SEL_SHIFT		0
+#define RCC_MCO1CFGR_MCO1DIV_MASK		GENMASK(7, 4)
+#define RCC_MCO1CFGR_MCO1DIV_SHIFT		4
+#define RCC_MCO1CFGR_MCO1ON			BIT(12)
+
+/* RCC_MCO2CFGR register fields */
+#define RCC_MCO2CFGR_MCO2SEL_MASK		GENMASK(2, 0)
+#define RCC_MCO2CFGR_MCO2SEL_SHIFT		0
+#define RCC_MCO2CFGR_MCO2DIV_MASK		GENMASK(7, 4)
+#define RCC_MCO2CFGR_MCO2DIV_SHIFT		4
+#define RCC_MCO2CFGR_MCO2ON			BIT(12)
+
+/* RCC_OCRDYR register fields */
+#define RCC_OCRDYR_HSIRDY			BIT(0)
+#define RCC_OCRDYR_HSIDIVRDY			BIT(2)
+#define RCC_OCRDYR_CSIRDY			BIT(4)
+#define RCC_OCRDYR_HSERDY			BIT(8)
+#define RCC_OCRDYR_MPUCKRDY			BIT(23)
+#define RCC_OCRDYR_AXICKRDY			BIT(24)
+#define RCC_OCRDYR_CKREST			BIT(25)
+
+/* RCC_DBGCFGR register fields */
+#define RCC_DBGCFGR_TRACEDIV_MASK		GENMASK(2, 0)
+#define RCC_DBGCFGR_TRACEDIV_SHIFT		0
+#define RCC_DBGCFGR_DBGCKEN			BIT(8)
+#define RCC_DBGCFGR_TRACECKEN			BIT(9)
+#define RCC_DBGCFGR_DBGRST			BIT(12)
+
+/* RCC_RCK3SELR register fields */
+#define RCC_RCK3SELR_PLL3SRC_MASK		GENMASK(1, 0)
+#define RCC_RCK3SELR_PLL3SRC_SHIFT		0
+#define RCC_RCK3SELR_PLL3SRCRDY			BIT(31)
+
+/* RCC_RCK4SELR register fields */
+#define RCC_RCK4SELR_PLL4SRC_MASK		GENMASK(1, 0)
+#define RCC_RCK4SELR_PLL4SRC_SHIFT		0
+#define RCC_RCK4SELR_PLL4SRCRDY			BIT(31)
+
+/* RCC_TIMG1PRER register fields */
+#define RCC_TIMG1PRER_TIMG1PRE			BIT(0)
+#define RCC_TIMG1PRER_TIMG1PRERDY		BIT(31)
+
+/* RCC_TIMG2PRER register fields */
+#define RCC_TIMG2PRER_TIMG2PRE			BIT(0)
+#define RCC_TIMG2PRER_TIMG2PRERDY		BIT(31)
+
+/* RCC_MCUDIVR register fields */
+#define RCC_MCUDIVR_MCUDIV_MASK			GENMASK(3, 0)
+#define RCC_MCUDIVR_MCUDIV_SHIFT		0
+#define RCC_MCUDIVR_MCUDIVRDY			BIT(31)
+
+/* RCC_APB1DIVR register fields */
+#define RCC_APB1DIVR_APB1DIV_MASK		GENMASK(2, 0)
+#define RCC_APB1DIVR_APB1DIV_SHIFT		0
+#define RCC_APB1DIVR_APB1DIVRDY			BIT(31)
+
+/* RCC_APB2DIVR register fields */
+#define RCC_APB2DIVR_APB2DIV_MASK		GENMASK(2, 0)
+#define RCC_APB2DIVR_APB2DIV_SHIFT		0
+#define RCC_APB2DIVR_APB2DIVRDY			BIT(31)
+
+/* RCC_APB3DIVR register fields */
+#define RCC_APB3DIVR_APB3DIV_MASK		GENMASK(2, 0)
+#define RCC_APB3DIVR_APB3DIV_SHIFT		0
+#define RCC_APB3DIVR_APB3DIVRDY			BIT(31)
+
+/* RCC_PLL3CR register fields */
+#define RCC_PLL3CR_PLLON			BIT(0)
+#define RCC_PLL3CR_PLL3RDY			BIT(1)
+#define RCC_PLL3CR_SSCG_CTRL			BIT(2)
+#define RCC_PLL3CR_DIVPEN			BIT(4)
+#define RCC_PLL3CR_DIVQEN			BIT(5)
+#define RCC_PLL3CR_DIVREN			BIT(6)
+
+/* RCC_PLL3CFGR1 register fields */
+#define RCC_PLL3CFGR1_DIVN_MASK			GENMASK(8, 0)
+#define RCC_PLL3CFGR1_DIVN_SHIFT		0
+#define RCC_PLL3CFGR1_DIVM3_MASK		GENMASK(21, 16)
+#define RCC_PLL3CFGR1_DIVM3_SHIFT		16
+#define RCC_PLL3CFGR1_IFRGE_MASK		GENMASK(25, 24)
+#define RCC_PLL3CFGR1_IFRGE_SHIFT		24
+
+/* RCC_PLL3CFGR2 register fields */
+#define RCC_PLL3CFGR2_DIVP_MASK			GENMASK(6, 0)
+#define RCC_PLL3CFGR2_DIVP_SHIFT		0
+#define RCC_PLL3CFGR2_DIVQ_MASK			GENMASK(14, 8)
+#define RCC_PLL3CFGR2_DIVQ_SHIFT		8
+#define RCC_PLL3CFGR2_DIVR_MASK			GENMASK(22, 16)
+#define RCC_PLL3CFGR2_DIVR_SHIFT		16
+
+/* RCC_PLL3FRACR register fields */
+#define RCC_PLL3FRACR_FRACV_MASK		GENMASK(15, 3)
+#define RCC_PLL3FRACR_FRACV_SHIFT		3
+#define RCC_PLL3FRACR_FRACLE			BIT(16)
+
+/* RCC_PLL3CSGR register fields */
+#define RCC_PLL3CSGR_MOD_PER_MASK		GENMASK(12, 0)
+#define RCC_PLL3CSGR_MOD_PER_SHIFT		0
+#define RCC_PLL3CSGR_TPDFN_DIS			BIT(13)
+#define RCC_PLL3CSGR_RPDFN_DIS			BIT(14)
+#define RCC_PLL3CSGR_SSCG_MODE			BIT(15)
+#define RCC_PLL3CSGR_INC_STEP_MASK		GENMASK(30, 16)
+#define RCC_PLL3CSGR_INC_STEP_SHIFT		16
+
+/* RCC_PLL4CR register fields */
+#define RCC_PLL4CR_PLLON			BIT(0)
+#define RCC_PLL4CR_PLL4RDY			BIT(1)
+#define RCC_PLL4CR_SSCG_CTRL			BIT(2)
+#define RCC_PLL4CR_DIVPEN			BIT(4)
+#define RCC_PLL4CR_DIVQEN			BIT(5)
+#define RCC_PLL4CR_DIVREN			BIT(6)
+
+/* RCC_PLL4CFGR1 register fields */
+#define RCC_PLL4CFGR1_DIVN_MASK			GENMASK(8, 0)
+#define RCC_PLL4CFGR1_DIVN_SHIFT		0
+#define RCC_PLL4CFGR1_DIVM4_MASK		GENMASK(21, 16)
+#define RCC_PLL4CFGR1_DIVM4_SHIFT		16
+#define RCC_PLL4CFGR1_IFRGE_MASK		GENMASK(25, 24)
+#define RCC_PLL4CFGR1_IFRGE_SHIFT		24
+
+/* RCC_PLL4CFGR2 register fields */
+#define RCC_PLL4CFGR2_DIVP_MASK			GENMASK(6, 0)
+#define RCC_PLL4CFGR2_DIVP_SHIFT		0
+#define RCC_PLL4CFGR2_DIVQ_MASK			GENMASK(14, 8)
+#define RCC_PLL4CFGR2_DIVQ_SHIFT		8
+#define RCC_PLL4CFGR2_DIVR_MASK			GENMASK(22, 16)
+#define RCC_PLL4CFGR2_DIVR_SHIFT		16
+
+/* RCC_PLL4FRACR register fields */
+#define RCC_PLL4FRACR_FRACV_MASK		GENMASK(15, 3)
+#define RCC_PLL4FRACR_FRACV_SHIFT		3
+#define RCC_PLL4FRACR_FRACLE			BIT(16)
+
+/* RCC_PLL4CSGR register fields */
+#define RCC_PLL4CSGR_MOD_PER_MASK		GENMASK(12, 0)
+#define RCC_PLL4CSGR_MOD_PER_SHIFT		0
+#define RCC_PLL4CSGR_TPDFN_DIS			BIT(13)
+#define RCC_PLL4CSGR_RPDFN_DIS			BIT(14)
+#define RCC_PLL4CSGR_SSCG_MODE			BIT(15)
+#define RCC_PLL4CSGR_INC_STEP_MASK		GENMASK(30, 16)
+#define RCC_PLL4CSGR_INC_STEP_SHIFT		16
+
+/* RCC_I2C12CKSELR register fields */
+#define RCC_I2C12CKSELR_I2C12SRC_MASK		GENMASK(2, 0)
+#define RCC_I2C12CKSELR_I2C12SRC_SHIFT		0
+
+/* RCC_I2C35CKSELR register fields */
+#define RCC_I2C35CKSELR_I2C35SRC_MASK		GENMASK(2, 0)
+#define RCC_I2C35CKSELR_I2C35SRC_SHIFT		0
+
+/* RCC_SAI1CKSELR register fields */
+#define RCC_SAI1CKSELR_SAI1SRC_MASK		GENMASK(2, 0)
+#define RCC_SAI1CKSELR_SAI1SRC_SHIFT		0
+
+/* RCC_SAI2CKSELR register fields */
+#define RCC_SAI2CKSELR_SAI2SRC_MASK		GENMASK(2, 0)
+#define RCC_SAI2CKSELR_SAI2SRC_SHIFT		0
+
+/* RCC_SAI3CKSELR register fields */
+#define RCC_SAI3CKSELR_SAI3SRC_MASK		GENMASK(2, 0)
+#define RCC_SAI3CKSELR_SAI3SRC_SHIFT		0
+
+/* RCC_SAI4CKSELR register fields */
+#define RCC_SAI4CKSELR_SAI4SRC_MASK		GENMASK(2, 0)
+#define RCC_SAI4CKSELR_SAI4SRC_SHIFT		0
+
+/* RCC_SPI2S1CKSELR register fields */
+#define RCC_SPI2S1CKSELR_SPI1SRC_MASK		GENMASK(2, 0)
+#define RCC_SPI2S1CKSELR_SPI1SRC_SHIFT		0
+
+/* RCC_SPI2S23CKSELR register fields */
+#define RCC_SPI2S23CKSELR_SPI23SRC_MASK		GENMASK(2, 0)
+#define RCC_SPI2S23CKSELR_SPI23SRC_SHIFT	0
+
+/* RCC_SPI45CKSELR register fields */
+#define RCC_SPI45CKSELR_SPI45SRC_MASK		GENMASK(2, 0)
+#define RCC_SPI45CKSELR_SPI45SRC_SHIFT		0
+
+/* RCC_UART6CKSELR register fields */
+#define RCC_UART6CKSELR_UART6SRC_MASK		GENMASK(2, 0)
+#define RCC_UART6CKSELR_UART6SRC_SHIFT		0
+
+/* RCC_UART24CKSELR register fields */
+#define RCC_UART24CKSELR_HSI			0x00000002
+#define RCC_UART24CKSELR_UART24SRC_MASK		GENMASK(2, 0)
+#define RCC_UART24CKSELR_UART24SRC_SHIFT	0
+
+/* RCC_UART35CKSELR register fields */
+#define RCC_UART35CKSELR_UART35SRC_MASK		GENMASK(2, 0)
+#define RCC_UART35CKSELR_UART35SRC_SHIFT	0
+
+/* RCC_UART78CKSELR register fields */
+#define RCC_UART78CKSELR_UART78SRC_MASK		GENMASK(2, 0)
+#define RCC_UART78CKSELR_UART78SRC_SHIFT	0
+
+/* RCC_SDMMC12CKSELR register fields */
+#define RCC_SDMMC12CKSELR_SDMMC12SRC_MASK	GENMASK(2, 0)
+#define RCC_SDMMC12CKSELR_SDMMC12SRC_SHIFT	0
+
+/* RCC_SDMMC3CKSELR register fields */
+#define RCC_SDMMC3CKSELR_SDMMC3SRC_MASK		GENMASK(2, 0)
+#define RCC_SDMMC3CKSELR_SDMMC3SRC_SHIFT	0
+
+/* RCC_ETHCKSELR register fields */
+#define RCC_ETHCKSELR_ETHSRC_MASK		GENMASK(1, 0)
+#define RCC_ETHCKSELR_ETHSRC_SHIFT		0
+#define RCC_ETHCKSELR_ETHPTPDIV_MASK		GENMASK(7, 4)
+#define RCC_ETHCKSELR_ETHPTPDIV_SHIFT		4
+
+/* RCC_QSPICKSELR register fields */
+#define RCC_QSPICKSELR_QSPISRC_MASK		GENMASK(1, 0)
+#define RCC_QSPICKSELR_QSPISRC_SHIFT		0
+
+/* RCC_FMCCKSELR register fields */
+#define RCC_FMCCKSELR_FMCSRC_MASK		GENMASK(1, 0)
+#define RCC_FMCCKSELR_FMCSRC_SHIFT		0
+
+/* RCC_FDCANCKSELR register fields */
+#define RCC_FDCANCKSELR_FDCANSRC_MASK		GENMASK(1, 0)
+#define RCC_FDCANCKSELR_FDCANSRC_SHIFT		0
+
+/* RCC_SPDIFCKSELR register fields */
+#define RCC_SPDIFCKSELR_SPDIFSRC_MASK		GENMASK(1, 0)
+#define RCC_SPDIFCKSELR_SPDIFSRC_SHIFT		0
+
+/* RCC_CECCKSELR register fields */
+#define RCC_CECCKSELR_CECSRC_MASK		GENMASK(1, 0)
+#define RCC_CECCKSELR_CECSRC_SHIFT		0
+
+/* RCC_USBCKSELR register fields */
+#define RCC_USBCKSELR_USBPHYSRC_MASK		GENMASK(1, 0)
+#define RCC_USBCKSELR_USBPHYSRC_SHIFT		0
+#define RCC_USBCKSELR_USBOSRC			BIT(4)
+#define RCC_USBCKSELR_USBOSRC_MASK		BIT(4)
+#define RCC_USBCKSELR_USBOSRC_SHIFT		4
+
+/* RCC_RNG2CKSELR register fields */
+#define RCC_RNG2CKSELR_RNG2SRC_MASK		GENMASK(1, 0)
+#define RCC_RNG2CKSELR_RNG2SRC_SHIFT		0
+
+/* RCC_DSICKSELR register fields */
+#define RCC_DSICKSELR_DSISRC			BIT(0)
+
+/* RCC_ADCCKSELR register fields */
+#define RCC_ADCCKSELR_ADCSRC_MASK		GENMASK(1, 0)
+#define RCC_ADCCKSELR_ADCSRC_SHIFT		0
+
+/* RCC_LPTIM45CKSELR register fields */
+#define RCC_LPTIM45CKSELR_LPTIM45SRC_MASK	GENMASK(2, 0)
+#define RCC_LPTIM45CKSELR_LPTIM45SRC_SHIFT	0
+
+/* RCC_LPTIM23CKSELR register fields */
+#define RCC_LPTIM23CKSELR_LPTIM23SRC_MASK	GENMASK(2, 0)
+#define RCC_LPTIM23CKSELR_LPTIM23SRC_SHIFT	0
+
+/* RCC_LPTIM1CKSELR register fields */
+#define RCC_LPTIM1CKSELR_LPTIM1SRC_MASK		GENMASK(2, 0)
+#define RCC_LPTIM1CKSELR_LPTIM1SRC_SHIFT	0
+
+/* RCC_APB1RSTSETR register fields */
+#define RCC_APB1RSTSETR_TIM2RST			BIT(0)
+#define RCC_APB1RSTSETR_TIM3RST			BIT(1)
+#define RCC_APB1RSTSETR_TIM4RST			BIT(2)
+#define RCC_APB1RSTSETR_TIM5RST			BIT(3)
+#define RCC_APB1RSTSETR_TIM6RST			BIT(4)
+#define RCC_APB1RSTSETR_TIM7RST			BIT(5)
+#define RCC_APB1RSTSETR_TIM12RST		BIT(6)
+#define RCC_APB1RSTSETR_TIM13RST		BIT(7)
+#define RCC_APB1RSTSETR_TIM14RST		BIT(8)
+#define RCC_APB1RSTSETR_LPTIM1RST		BIT(9)
+#define RCC_APB1RSTSETR_SPI2RST			BIT(11)
+#define RCC_APB1RSTSETR_SPI3RST			BIT(12)
+#define RCC_APB1RSTSETR_USART2RST		BIT(14)
+#define RCC_APB1RSTSETR_USART3RST		BIT(15)
+#define RCC_APB1RSTSETR_UART4RST		BIT(16)
+#define RCC_APB1RSTSETR_UART5RST		BIT(17)
+#define RCC_APB1RSTSETR_UART7RST		BIT(18)
+#define RCC_APB1RSTSETR_UART8RST		BIT(19)
+#define RCC_APB1RSTSETR_I2C1RST			BIT(21)
+#define RCC_APB1RSTSETR_I2C2RST			BIT(22)
+#define RCC_APB1RSTSETR_I2C3RST			BIT(23)
+#define RCC_APB1RSTSETR_I2C5RST			BIT(24)
+#define RCC_APB1RSTSETR_SPDIFRST		BIT(26)
+#define RCC_APB1RSTSETR_CECRST			BIT(27)
+#define RCC_APB1RSTSETR_DAC12RST		BIT(29)
+#define RCC_APB1RSTSETR_MDIOSRST		BIT(31)
+
+/* RCC_APB1RSTCLRR register fields */
+#define RCC_APB1RSTCLRR_TIM2RST			BIT(0)
+#define RCC_APB1RSTCLRR_TIM3RST			BIT(1)
+#define RCC_APB1RSTCLRR_TIM4RST			BIT(2)
+#define RCC_APB1RSTCLRR_TIM5RST			BIT(3)
+#define RCC_APB1RSTCLRR_TIM6RST			BIT(4)
+#define RCC_APB1RSTCLRR_TIM7RST			BIT(5)
+#define RCC_APB1RSTCLRR_TIM12RST		BIT(6)
+#define RCC_APB1RSTCLRR_TIM13RST		BIT(7)
+#define RCC_APB1RSTCLRR_TIM14RST		BIT(8)
+#define RCC_APB1RSTCLRR_LPTIM1RST		BIT(9)
+#define RCC_APB1RSTCLRR_SPI2RST			BIT(11)
+#define RCC_APB1RSTCLRR_SPI3RST			BIT(12)
+#define RCC_APB1RSTCLRR_USART2RST		BIT(14)
+#define RCC_APB1RSTCLRR_USART3RST		BIT(15)
+#define RCC_APB1RSTCLRR_UART4RST		BIT(16)
+#define RCC_APB1RSTCLRR_UART5RST		BIT(17)
+#define RCC_APB1RSTCLRR_UART7RST		BIT(18)
+#define RCC_APB1RSTCLRR_UART8RST		BIT(19)
+#define RCC_APB1RSTCLRR_I2C1RST			BIT(21)
+#define RCC_APB1RSTCLRR_I2C2RST			BIT(22)
+#define RCC_APB1RSTCLRR_I2C3RST			BIT(23)
+#define RCC_APB1RSTCLRR_I2C5RST			BIT(24)
+#define RCC_APB1RSTCLRR_SPDIFRST		BIT(26)
+#define RCC_APB1RSTCLRR_CECRST			BIT(27)
+#define RCC_APB1RSTCLRR_DAC12RST		BIT(29)
+#define RCC_APB1RSTCLRR_MDIOSRST		BIT(31)
+
+/* RCC_APB2RSTSETR register fields */
+#define RCC_APB2RSTSETR_TIM1RST			BIT(0)
+#define RCC_APB2RSTSETR_TIM8RST			BIT(1)
+#define RCC_APB2RSTSETR_TIM15RST		BIT(2)
+#define RCC_APB2RSTSETR_TIM16RST		BIT(3)
+#define RCC_APB2RSTSETR_TIM17RST		BIT(4)
+#define RCC_APB2RSTSETR_SPI1RST			BIT(8)
+#define RCC_APB2RSTSETR_SPI4RST			BIT(9)
+#define RCC_APB2RSTSETR_SPI5RST			BIT(10)
+#define RCC_APB2RSTSETR_USART6RST		BIT(13)
+#define RCC_APB2RSTSETR_SAI1RST			BIT(16)
+#define RCC_APB2RSTSETR_SAI2RST			BIT(17)
+#define RCC_APB2RSTSETR_SAI3RST			BIT(18)
+#define RCC_APB2RSTSETR_DFSDMRST		BIT(20)
+#define RCC_APB2RSTSETR_FDCANRST		BIT(24)
+
+/* RCC_APB2RSTCLRR register fields */
+#define RCC_APB2RSTCLRR_TIM1RST			BIT(0)
+#define RCC_APB2RSTCLRR_TIM8RST			BIT(1)
+#define RCC_APB2RSTCLRR_TIM15RST		BIT(2)
+#define RCC_APB2RSTCLRR_TIM16RST		BIT(3)
+#define RCC_APB2RSTCLRR_TIM17RST		BIT(4)
+#define RCC_APB2RSTCLRR_SPI1RST			BIT(8)
+#define RCC_APB2RSTCLRR_SPI4RST			BIT(9)
+#define RCC_APB2RSTCLRR_SPI5RST			BIT(10)
+#define RCC_APB2RSTCLRR_USART6RST		BIT(13)
+#define RCC_APB2RSTCLRR_SAI1RST			BIT(16)
+#define RCC_APB2RSTCLRR_SAI2RST			BIT(17)
+#define RCC_APB2RSTCLRR_SAI3RST			BIT(18)
+#define RCC_APB2RSTCLRR_DFSDMRST		BIT(20)
+#define RCC_APB2RSTCLRR_FDCANRST		BIT(24)
+
+/* RCC_APB3RSTSETR register fields */
+#define RCC_APB3RSTSETR_LPTIM2RST		BIT(0)
+#define RCC_APB3RSTSETR_LPTIM3RST		BIT(1)
+#define RCC_APB3RSTSETR_LPTIM4RST		BIT(2)
+#define RCC_APB3RSTSETR_LPTIM5RST		BIT(3)
+#define RCC_APB3RSTSETR_SAI4RST			BIT(8)
+#define RCC_APB3RSTSETR_SYSCFGRST		BIT(11)
+#define RCC_APB3RSTSETR_VREFRST			BIT(13)
+#define RCC_APB3RSTSETR_TMPSENSRST		BIT(16)
+#define RCC_APB3RSTSETR_PMBCTRLRST		BIT(17)
+
+/* RCC_APB3RSTCLRR register fields */
+#define RCC_APB3RSTCLRR_LPTIM2RST		BIT(0)
+#define RCC_APB3RSTCLRR_LPTIM3RST		BIT(1)
+#define RCC_APB3RSTCLRR_LPTIM4RST		BIT(2)
+#define RCC_APB3RSTCLRR_LPTIM5RST		BIT(3)
+#define RCC_APB3RSTCLRR_SAI4RST			BIT(8)
+#define RCC_APB3RSTCLRR_SYSCFGRST		BIT(11)
+#define RCC_APB3RSTCLRR_VREFRST			BIT(13)
+#define RCC_APB3RSTCLRR_TMPSENSRST		BIT(16)
+#define RCC_APB3RSTCLRR_PMBCTRLRST		BIT(17)
+
+/* RCC_AHB2RSTSETR register fields */
+#define RCC_AHB2RSTSETR_DMA1RST			BIT(0)
+#define RCC_AHB2RSTSETR_DMA2RST			BIT(1)
+#define RCC_AHB2RSTSETR_DMAMUXRST		BIT(2)
+#define RCC_AHB2RSTSETR_ADC12RST		BIT(5)
+#define RCC_AHB2RSTSETR_USBORST			BIT(8)
+#define RCC_AHB2RSTSETR_SDMMC3RST		BIT(16)
+
+/* RCC_AHB2RSTCLRR register fields */
+#define RCC_AHB2RSTCLRR_DMA1RST			BIT(0)
+#define RCC_AHB2RSTCLRR_DMA2RST			BIT(1)
+#define RCC_AHB2RSTCLRR_DMAMUXRST		BIT(2)
+#define RCC_AHB2RSTCLRR_ADC12RST		BIT(5)
+#define RCC_AHB2RSTCLRR_USBORST			BIT(8)
+#define RCC_AHB2RSTCLRR_SDMMC3RST		BIT(16)
+
+/* RCC_AHB3RSTSETR register fields */
+#define RCC_AHB3RSTSETR_DCMIRST			BIT(0)
+#define RCC_AHB3RSTSETR_CRYP2RST		BIT(4)
+#define RCC_AHB3RSTSETR_HASH2RST		BIT(5)
+#define RCC_AHB3RSTSETR_RNG2RST			BIT(6)
+#define RCC_AHB3RSTSETR_CRC2RST			BIT(7)
+#define RCC_AHB3RSTSETR_HSEMRST			BIT(11)
+#define RCC_AHB3RSTSETR_IPCCRST			BIT(12)
+
+/* RCC_AHB3RSTCLRR register fields */
+#define RCC_AHB3RSTCLRR_DCMIRST			BIT(0)
+#define RCC_AHB3RSTCLRR_CRYP2RST		BIT(4)
+#define RCC_AHB3RSTCLRR_HASH2RST		BIT(5)
+#define RCC_AHB3RSTCLRR_RNG2RST			BIT(6)
+#define RCC_AHB3RSTCLRR_CRC2RST			BIT(7)
+#define RCC_AHB3RSTCLRR_HSEMRST			BIT(11)
+#define RCC_AHB3RSTCLRR_IPCCRST			BIT(12)
+
+/* RCC_AHB4RSTSETR register fields */
+#define RCC_AHB4RSTSETR_GPIOARST		BIT(0)
+#define RCC_AHB4RSTSETR_GPIOBRST		BIT(1)
+#define RCC_AHB4RSTSETR_GPIOCRST		BIT(2)
+#define RCC_AHB4RSTSETR_GPIODRST		BIT(3)
+#define RCC_AHB4RSTSETR_GPIOERST		BIT(4)
+#define RCC_AHB4RSTSETR_GPIOFRST		BIT(5)
+#define RCC_AHB4RSTSETR_GPIOGRST		BIT(6)
+#define RCC_AHB4RSTSETR_GPIOHRST		BIT(7)
+#define RCC_AHB4RSTSETR_GPIOIRST		BIT(8)
+#define RCC_AHB4RSTSETR_GPIOJRST		BIT(9)
+#define RCC_AHB4RSTSETR_GPIOKRST		BIT(10)
+
+/* RCC_AHB4RSTCLRR register fields */
+#define RCC_AHB4RSTCLRR_GPIOARST		BIT(0)
+#define RCC_AHB4RSTCLRR_GPIOBRST		BIT(1)
+#define RCC_AHB4RSTCLRR_GPIOCRST		BIT(2)
+#define RCC_AHB4RSTCLRR_GPIODRST		BIT(3)
+#define RCC_AHB4RSTCLRR_GPIOERST		BIT(4)
+#define RCC_AHB4RSTCLRR_GPIOFRST		BIT(5)
+#define RCC_AHB4RSTCLRR_GPIOGRST		BIT(6)
+#define RCC_AHB4RSTCLRR_GPIOHRST		BIT(7)
+#define RCC_AHB4RSTCLRR_GPIOIRST		BIT(8)
+#define RCC_AHB4RSTCLRR_GPIOJRST		BIT(9)
+#define RCC_AHB4RSTCLRR_GPIOKRST		BIT(10)
+
+/* RCC_MP_APB1ENSETR register fields */
+#define RCC_MP_APB1ENSETR_TIM2EN		BIT(0)
+#define RCC_MP_APB1ENSETR_TIM3EN		BIT(1)
+#define RCC_MP_APB1ENSETR_TIM4EN		BIT(2)
+#define RCC_MP_APB1ENSETR_TIM5EN		BIT(3)
+#define RCC_MP_APB1ENSETR_TIM6EN		BIT(4)
+#define RCC_MP_APB1ENSETR_TIM7EN		BIT(5)
+#define RCC_MP_APB1ENSETR_TIM12EN		BIT(6)
+#define RCC_MP_APB1ENSETR_TIM13EN		BIT(7)
+#define RCC_MP_APB1ENSETR_TIM14EN		BIT(8)
+#define RCC_MP_APB1ENSETR_LPTIM1EN		BIT(9)
+#define RCC_MP_APB1ENSETR_SPI2EN		BIT(11)
+#define RCC_MP_APB1ENSETR_SPI3EN		BIT(12)
+#define RCC_MP_APB1ENSETR_USART2EN		BIT(14)
+#define RCC_MP_APB1ENSETR_USART3EN		BIT(15)
+#define RCC_MP_APB1ENSETR_UART4EN		BIT(16)
+#define RCC_MP_APB1ENSETR_UART5EN		BIT(17)
+#define RCC_MP_APB1ENSETR_UART7EN		BIT(18)
+#define RCC_MP_APB1ENSETR_UART8EN		BIT(19)
+#define RCC_MP_APB1ENSETR_I2C1EN		BIT(21)
+#define RCC_MP_APB1ENSETR_I2C2EN		BIT(22)
+#define RCC_MP_APB1ENSETR_I2C3EN		BIT(23)
+#define RCC_MP_APB1ENSETR_I2C5EN		BIT(24)
+#define RCC_MP_APB1ENSETR_SPDIFEN		BIT(26)
+#define RCC_MP_APB1ENSETR_CECEN			BIT(27)
+#define RCC_MP_APB1ENSETR_DAC12EN		BIT(29)
+#define RCC_MP_APB1ENSETR_MDIOSEN		BIT(31)
+
+/* RCC_MP_APB1ENCLRR register fields */
+#define RCC_MP_APB1ENCLRR_TIM2EN		BIT(0)
+#define RCC_MP_APB1ENCLRR_TIM3EN		BIT(1)
+#define RCC_MP_APB1ENCLRR_TIM4EN		BIT(2)
+#define RCC_MP_APB1ENCLRR_TIM5EN		BIT(3)
+#define RCC_MP_APB1ENCLRR_TIM6EN		BIT(4)
+#define RCC_MP_APB1ENCLRR_TIM7EN		BIT(5)
+#define RCC_MP_APB1ENCLRR_TIM12EN		BIT(6)
+#define RCC_MP_APB1ENCLRR_TIM13EN		BIT(7)
+#define RCC_MP_APB1ENCLRR_TIM14EN		BIT(8)
+#define RCC_MP_APB1ENCLRR_LPTIM1EN		BIT(9)
+#define RCC_MP_APB1ENCLRR_SPI2EN		BIT(11)
+#define RCC_MP_APB1ENCLRR_SPI3EN		BIT(12)
+#define RCC_MP_APB1ENCLRR_USART2EN		BIT(14)
+#define RCC_MP_APB1ENCLRR_USART3EN		BIT(15)
+#define RCC_MP_APB1ENCLRR_UART4EN		BIT(16)
+#define RCC_MP_APB1ENCLRR_UART5EN		BIT(17)
+#define RCC_MP_APB1ENCLRR_UART7EN		BIT(18)
+#define RCC_MP_APB1ENCLRR_UART8EN		BIT(19)
+#define RCC_MP_APB1ENCLRR_I2C1EN		BIT(21)
+#define RCC_MP_APB1ENCLRR_I2C2EN		BIT(22)
+#define RCC_MP_APB1ENCLRR_I2C3EN		BIT(23)
+#define RCC_MP_APB1ENCLRR_I2C5EN		BIT(24)
+#define RCC_MP_APB1ENCLRR_SPDIFEN		BIT(26)
+#define RCC_MP_APB1ENCLRR_CECEN			BIT(27)
+#define RCC_MP_APB1ENCLRR_DAC12EN		BIT(29)
+#define RCC_MP_APB1ENCLRR_MDIOSEN		BIT(31)
+
+/* RCC_MP_APB2ENSETR register fields */
+#define RCC_MP_APB2ENSETR_TIM1EN		BIT(0)
+#define RCC_MP_APB2ENSETR_TIM8EN		BIT(1)
+#define RCC_MP_APB2ENSETR_TIM15EN		BIT(2)
+#define RCC_MP_APB2ENSETR_TIM16EN		BIT(3)
+#define RCC_MP_APB2ENSETR_TIM17EN		BIT(4)
+#define RCC_MP_APB2ENSETR_SPI1EN		BIT(8)
+#define RCC_MP_APB2ENSETR_SPI4EN		BIT(9)
+#define RCC_MP_APB2ENSETR_SPI5EN		BIT(10)
+#define RCC_MP_APB2ENSETR_USART6EN		BIT(13)
+#define RCC_MP_APB2ENSETR_SAI1EN		BIT(16)
+#define RCC_MP_APB2ENSETR_SAI2EN		BIT(17)
+#define RCC_MP_APB2ENSETR_SAI3EN		BIT(18)
+#define RCC_MP_APB2ENSETR_DFSDMEN		BIT(20)
+#define RCC_MP_APB2ENSETR_ADFSDMEN		BIT(21)
+#define RCC_MP_APB2ENSETR_FDCANEN		BIT(24)
+
+/* RCC_MP_APB2ENCLRR register fields */
+#define RCC_MP_APB2ENCLRR_TIM1EN		BIT(0)
+#define RCC_MP_APB2ENCLRR_TIM8EN		BIT(1)
+#define RCC_MP_APB2ENCLRR_TIM15EN		BIT(2)
+#define RCC_MP_APB2ENCLRR_TIM16EN		BIT(3)
+#define RCC_MP_APB2ENCLRR_TIM17EN		BIT(4)
+#define RCC_MP_APB2ENCLRR_SPI1EN		BIT(8)
+#define RCC_MP_APB2ENCLRR_SPI4EN		BIT(9)
+#define RCC_MP_APB2ENCLRR_SPI5EN		BIT(10)
+#define RCC_MP_APB2ENCLRR_USART6EN		BIT(13)
+#define RCC_MP_APB2ENCLRR_SAI1EN		BIT(16)
+#define RCC_MP_APB2ENCLRR_SAI2EN		BIT(17)
+#define RCC_MP_APB2ENCLRR_SAI3EN		BIT(18)
+#define RCC_MP_APB2ENCLRR_DFSDMEN		BIT(20)
+#define RCC_MP_APB2ENCLRR_ADFSDMEN		BIT(21)
+#define RCC_MP_APB2ENCLRR_FDCANEN		BIT(24)
+
+/* RCC_MP_APB3ENSETR register fields */
+#define RCC_MP_APB3ENSETR_LPTIM2EN		BIT(0)
+#define RCC_MP_APB3ENSETR_LPTIM3EN		BIT(1)
+#define RCC_MP_APB3ENSETR_LPTIM4EN		BIT(2)
+#define RCC_MP_APB3ENSETR_LPTIM5EN		BIT(3)
+#define RCC_MP_APB3ENSETR_SAI4EN		BIT(8)
+#define RCC_MP_APB3ENSETR_SYSCFGEN		BIT(11)
+#define RCC_MP_APB3ENSETR_VREFEN		BIT(13)
+#define RCC_MP_APB3ENSETR_TMPSENSEN		BIT(16)
+#define RCC_MP_APB3ENSETR_PMBCTRLEN		BIT(17)
+#define RCC_MP_APB3ENSETR_HDPEN			BIT(20)
+
+/* RCC_MP_APB3ENCLRR register fields */
+#define RCC_MP_APB3ENCLRR_LPTIM2EN		BIT(0)
+#define RCC_MP_APB3ENCLRR_LPTIM3EN		BIT(1)
+#define RCC_MP_APB3ENCLRR_LPTIM4EN		BIT(2)
+#define RCC_MP_APB3ENCLRR_LPTIM5EN		BIT(3)
+#define RCC_MP_APB3ENCLRR_SAI4EN		BIT(8)
+#define RCC_MP_APB3ENCLRR_SYSCFGEN		BIT(11)
+#define RCC_MP_APB3ENCLRR_VREFEN		BIT(13)
+#define RCC_MP_APB3ENCLRR_TMPSENSEN		BIT(16)
+#define RCC_MP_APB3ENCLRR_PMBCTRLEN		BIT(17)
+#define RCC_MP_APB3ENCLRR_HDPEN			BIT(20)
+
+/* RCC_MP_AHB2ENSETR register fields */
+#define RCC_MP_AHB2ENSETR_DMA1EN		BIT(0)
+#define RCC_MP_AHB2ENSETR_DMA2EN		BIT(1)
+#define RCC_MP_AHB2ENSETR_DMAMUXEN		BIT(2)
+#define RCC_MP_AHB2ENSETR_ADC12EN		BIT(5)
+#define RCC_MP_AHB2ENSETR_USBOEN		BIT(8)
+#define RCC_MP_AHB2ENSETR_SDMMC3EN		BIT(16)
+
+/* RCC_MP_AHB2ENCLRR register fields */
+#define RCC_MP_AHB2ENCLRR_DMA1EN		BIT(0)
+#define RCC_MP_AHB2ENCLRR_DMA2EN		BIT(1)
+#define RCC_MP_AHB2ENCLRR_DMAMUXEN		BIT(2)
+#define RCC_MP_AHB2ENCLRR_ADC12EN		BIT(5)
+#define RCC_MP_AHB2ENCLRR_USBOEN		BIT(8)
+#define RCC_MP_AHB2ENCLRR_SDMMC3EN		BIT(16)
+
+/* RCC_MP_AHB3ENSETR register fields */
+#define RCC_MP_AHB3ENSETR_DCMIEN		BIT(0)
+#define RCC_MP_AHB3ENSETR_CRYP2EN		BIT(4)
+#define RCC_MP_AHB3ENSETR_HASH2EN		BIT(5)
+#define RCC_MP_AHB3ENSETR_RNG2EN		BIT(6)
+#define RCC_MP_AHB3ENSETR_CRC2EN		BIT(7)
+#define RCC_MP_AHB3ENSETR_HSEMEN		BIT(11)
+#define RCC_MP_AHB3ENSETR_IPCCEN		BIT(12)
+
+/* RCC_MP_AHB3ENCLRR register fields */
+#define RCC_MP_AHB3ENCLRR_DCMIEN		BIT(0)
+#define RCC_MP_AHB3ENCLRR_CRYP2EN		BIT(4)
+#define RCC_MP_AHB3ENCLRR_HASH2EN		BIT(5)
+#define RCC_MP_AHB3ENCLRR_RNG2EN		BIT(6)
+#define RCC_MP_AHB3ENCLRR_CRC2EN		BIT(7)
+#define RCC_MP_AHB3ENCLRR_HSEMEN		BIT(11)
+#define RCC_MP_AHB3ENCLRR_IPCCEN		BIT(12)
+
+/* RCC_MP_AHB4ENSETR register fields */
+#define RCC_MP_AHB4ENSETR_GPIOAEN		BIT(0)
+#define RCC_MP_AHB4ENSETR_GPIOBEN		BIT(1)
+#define RCC_MP_AHB4ENSETR_GPIOCEN		BIT(2)
+#define RCC_MP_AHB4ENSETR_GPIODEN		BIT(3)
+#define RCC_MP_AHB4ENSETR_GPIOEEN		BIT(4)
+#define RCC_MP_AHB4ENSETR_GPIOFEN		BIT(5)
+#define RCC_MP_AHB4ENSETR_GPIOGEN		BIT(6)
+#define RCC_MP_AHB4ENSETR_GPIOHEN		BIT(7)
+#define RCC_MP_AHB4ENSETR_GPIOIEN		BIT(8)
+#define RCC_MP_AHB4ENSETR_GPIOJEN		BIT(9)
+#define RCC_MP_AHB4ENSETR_GPIOKEN		BIT(10)
+
+/* RCC_MP_AHB4ENCLRR register fields */
+#define RCC_MP_AHB4ENCLRR_GPIOAEN		BIT(0)
+#define RCC_MP_AHB4ENCLRR_GPIOBEN		BIT(1)
+#define RCC_MP_AHB4ENCLRR_GPIOCEN		BIT(2)
+#define RCC_MP_AHB4ENCLRR_GPIODEN		BIT(3)
+#define RCC_MP_AHB4ENCLRR_GPIOEEN		BIT(4)
+#define RCC_MP_AHB4ENCLRR_GPIOFEN		BIT(5)
+#define RCC_MP_AHB4ENCLRR_GPIOGEN		BIT(6)
+#define RCC_MP_AHB4ENCLRR_GPIOHEN		BIT(7)
+#define RCC_MP_AHB4ENCLRR_GPIOIEN		BIT(8)
+#define RCC_MP_AHB4ENCLRR_GPIOJEN		BIT(9)
+#define RCC_MP_AHB4ENCLRR_GPIOKEN		BIT(10)
+
+/* RCC_MP_MLAHBENSETR register fields */
+#define RCC_MP_MLAHBENSETR_RETRAMEN		BIT(4)
+
+/* RCC_MP_MLAHBENCLRR register fields */
+#define RCC_MP_MLAHBENCLRR_RETRAMEN		BIT(4)
+
+/* RCC_MC_APB1ENSETR register fields */
+#define RCC_MC_APB1ENSETR_TIM2EN		BIT(0)
+#define RCC_MC_APB1ENSETR_TIM3EN		BIT(1)
+#define RCC_MC_APB1ENSETR_TIM4EN		BIT(2)
+#define RCC_MC_APB1ENSETR_TIM5EN		BIT(3)
+#define RCC_MC_APB1ENSETR_TIM6EN		BIT(4)
+#define RCC_MC_APB1ENSETR_TIM7EN		BIT(5)
+#define RCC_MC_APB1ENSETR_TIM12EN		BIT(6)
+#define RCC_MC_APB1ENSETR_TIM13EN		BIT(7)
+#define RCC_MC_APB1ENSETR_TIM14EN		BIT(8)
+#define RCC_MC_APB1ENSETR_LPTIM1EN		BIT(9)
+#define RCC_MC_APB1ENSETR_SPI2EN		BIT(11)
+#define RCC_MC_APB1ENSETR_SPI3EN		BIT(12)
+#define RCC_MC_APB1ENSETR_USART2EN		BIT(14)
+#define RCC_MC_APB1ENSETR_USART3EN		BIT(15)
+#define RCC_MC_APB1ENSETR_UART4EN		BIT(16)
+#define RCC_MC_APB1ENSETR_UART5EN		BIT(17)
+#define RCC_MC_APB1ENSETR_UART7EN		BIT(18)
+#define RCC_MC_APB1ENSETR_UART8EN		BIT(19)
+#define RCC_MC_APB1ENSETR_I2C1EN		BIT(21)
+#define RCC_MC_APB1ENSETR_I2C2EN		BIT(22)
+#define RCC_MC_APB1ENSETR_I2C3EN		BIT(23)
+#define RCC_MC_APB1ENSETR_I2C5EN		BIT(24)
+#define RCC_MC_APB1ENSETR_SPDIFEN		BIT(26)
+#define RCC_MC_APB1ENSETR_CECEN			BIT(27)
+#define RCC_MC_APB1ENSETR_WWDG1EN		BIT(28)
+#define RCC_MC_APB1ENSETR_DAC12EN		BIT(29)
+#define RCC_MC_APB1ENSETR_MDIOSEN		BIT(31)
+
+/* RCC_MC_APB1ENCLRR register fields */
+#define RCC_MC_APB1ENCLRR_TIM2EN		BIT(0)
+#define RCC_MC_APB1ENCLRR_TIM3EN		BIT(1)
+#define RCC_MC_APB1ENCLRR_TIM4EN		BIT(2)
+#define RCC_MC_APB1ENCLRR_TIM5EN		BIT(3)
+#define RCC_MC_APB1ENCLRR_TIM6EN		BIT(4)
+#define RCC_MC_APB1ENCLRR_TIM7EN		BIT(5)
+#define RCC_MC_APB1ENCLRR_TIM12EN		BIT(6)
+#define RCC_MC_APB1ENCLRR_TIM13EN		BIT(7)
+#define RCC_MC_APB1ENCLRR_TIM14EN		BIT(8)
+#define RCC_MC_APB1ENCLRR_LPTIM1EN		BIT(9)
+#define RCC_MC_APB1ENCLRR_SPI2EN		BIT(11)
+#define RCC_MC_APB1ENCLRR_SPI3EN		BIT(12)
+#define RCC_MC_APB1ENCLRR_USART2EN		BIT(14)
+#define RCC_MC_APB1ENCLRR_USART3EN		BIT(15)
+#define RCC_MC_APB1ENCLRR_UART4EN		BIT(16)
+#define RCC_MC_APB1ENCLRR_UART5EN		BIT(17)
+#define RCC_MC_APB1ENCLRR_UART7EN		BIT(18)
+#define RCC_MC_APB1ENCLRR_UART8EN		BIT(19)
+#define RCC_MC_APB1ENCLRR_I2C1EN		BIT(21)
+#define RCC_MC_APB1ENCLRR_I2C2EN		BIT(22)
+#define RCC_MC_APB1ENCLRR_I2C3EN		BIT(23)
+#define RCC_MC_APB1ENCLRR_I2C5EN		BIT(24)
+#define RCC_MC_APB1ENCLRR_SPDIFEN		BIT(26)
+#define RCC_MC_APB1ENCLRR_CECEN			BIT(27)
+#define RCC_MC_APB1ENCLRR_DAC12EN		BIT(29)
+#define RCC_MC_APB1ENCLRR_MDIOSEN		BIT(31)
+
+/* RCC_MC_APB2ENSETR register fields */
+#define RCC_MC_APB2ENSETR_TIM1EN		BIT(0)
+#define RCC_MC_APB2ENSETR_TIM8EN		BIT(1)
+#define RCC_MC_APB2ENSETR_TIM15EN		BIT(2)
+#define RCC_MC_APB2ENSETR_TIM16EN		BIT(3)
+#define RCC_MC_APB2ENSETR_TIM17EN		BIT(4)
+#define RCC_MC_APB2ENSETR_SPI1EN		BIT(8)
+#define RCC_MC_APB2ENSETR_SPI4EN		BIT(9)
+#define RCC_MC_APB2ENSETR_SPI5EN		BIT(10)
+#define RCC_MC_APB2ENSETR_USART6EN		BIT(13)
+#define RCC_MC_APB2ENSETR_SAI1EN		BIT(16)
+#define RCC_MC_APB2ENSETR_SAI2EN		BIT(17)
+#define RCC_MC_APB2ENSETR_SAI3EN		BIT(18)
+#define RCC_MC_APB2ENSETR_DFSDMEN		BIT(20)
+#define RCC_MC_APB2ENSETR_ADFSDMEN		BIT(21)
+#define RCC_MC_APB2ENSETR_FDCANEN		BIT(24)
+
+/* RCC_MC_APB2ENCLRR register fields */
+#define RCC_MC_APB2ENCLRR_TIM1EN		BIT(0)
+#define RCC_MC_APB2ENCLRR_TIM8EN		BIT(1)
+#define RCC_MC_APB2ENCLRR_TIM15EN		BIT(2)
+#define RCC_MC_APB2ENCLRR_TIM16EN		BIT(3)
+#define RCC_MC_APB2ENCLRR_TIM17EN		BIT(4)
+#define RCC_MC_APB2ENCLRR_SPI1EN		BIT(8)
+#define RCC_MC_APB2ENCLRR_SPI4EN		BIT(9)
+#define RCC_MC_APB2ENCLRR_SPI5EN		BIT(10)
+#define RCC_MC_APB2ENCLRR_USART6EN		BIT(13)
+#define RCC_MC_APB2ENCLRR_SAI1EN		BIT(16)
+#define RCC_MC_APB2ENCLRR_SAI2EN		BIT(17)
+#define RCC_MC_APB2ENCLRR_SAI3EN		BIT(18)
+#define RCC_MC_APB2ENCLRR_DFSDMEN		BIT(20)
+#define RCC_MC_APB2ENCLRR_ADFSDMEN		BIT(21)
+#define RCC_MC_APB2ENCLRR_FDCANEN		BIT(24)
+
+/* RCC_MC_APB3ENSETR register fields */
+#define RCC_MC_APB3ENSETR_LPTIM2EN		BIT(0)
+#define RCC_MC_APB3ENSETR_LPTIM3EN		BIT(1)
+#define RCC_MC_APB3ENSETR_LPTIM4EN		BIT(2)
+#define RCC_MC_APB3ENSETR_LPTIM5EN		BIT(3)
+#define RCC_MC_APB3ENSETR_SAI4EN		BIT(8)
+#define RCC_MC_APB3ENSETR_SYSCFGEN		BIT(11)
+#define RCC_MC_APB3ENSETR_VREFEN		BIT(13)
+#define RCC_MC_APB3ENSETR_TMPSENSEN		BIT(16)
+#define RCC_MC_APB3ENSETR_PMBCTRLEN		BIT(17)
+#define RCC_MC_APB3ENSETR_HDPEN			BIT(20)
+
+/* RCC_MC_APB3ENCLRR register fields */
+#define RCC_MC_APB3ENCLRR_LPTIM2EN		BIT(0)
+#define RCC_MC_APB3ENCLRR_LPTIM3EN		BIT(1)
+#define RCC_MC_APB3ENCLRR_LPTIM4EN		BIT(2)
+#define RCC_MC_APB3ENCLRR_LPTIM5EN		BIT(3)
+#define RCC_MC_APB3ENCLRR_SAI4EN		BIT(8)
+#define RCC_MC_APB3ENCLRR_SYSCFGEN		BIT(11)
+#define RCC_MC_APB3ENCLRR_VREFEN		BIT(13)
+#define RCC_MC_APB3ENCLRR_TMPSENSEN		BIT(16)
+#define RCC_MC_APB3ENCLRR_PMBCTRLEN		BIT(17)
+#define RCC_MC_APB3ENCLRR_HDPEN			BIT(20)
+
+/* RCC_MC_AHB2ENSETR register fields */
+#define RCC_MC_AHB2ENSETR_DMA1EN		BIT(0)
+#define RCC_MC_AHB2ENSETR_DMA2EN		BIT(1)
+#define RCC_MC_AHB2ENSETR_DMAMUXEN		BIT(2)
+#define RCC_MC_AHB2ENSETR_ADC12EN		BIT(5)
+#define RCC_MC_AHB2ENSETR_USBOEN		BIT(8)
+#define RCC_MC_AHB2ENSETR_SDMMC3EN		BIT(16)
+
+/* RCC_MC_AHB2ENCLRR register fields */
+#define RCC_MC_AHB2ENCLRR_DMA1EN		BIT(0)
+#define RCC_MC_AHB2ENCLRR_DMA2EN		BIT(1)
+#define RCC_MC_AHB2ENCLRR_DMAMUXEN		BIT(2)
+#define RCC_MC_AHB2ENCLRR_ADC12EN		BIT(5)
+#define RCC_MC_AHB2ENCLRR_USBOEN		BIT(8)
+#define RCC_MC_AHB2ENCLRR_SDMMC3EN		BIT(16)
+
+/* RCC_MC_AHB3ENSETR register fields */
+#define RCC_MC_AHB3ENSETR_DCMIEN		BIT(0)
+#define RCC_MC_AHB3ENSETR_CRYP2EN		BIT(4)
+#define RCC_MC_AHB3ENSETR_HASH2EN		BIT(5)
+#define RCC_MC_AHB3ENSETR_RNG2EN		BIT(6)
+#define RCC_MC_AHB3ENSETR_CRC2EN		BIT(7)
+#define RCC_MC_AHB3ENSETR_HSEMEN		BIT(11)
+#define RCC_MC_AHB3ENSETR_IPCCEN		BIT(12)
+
+/* RCC_MC_AHB3ENCLRR register fields */
+#define RCC_MC_AHB3ENCLRR_DCMIEN		BIT(0)
+#define RCC_MC_AHB3ENCLRR_CRYP2EN		BIT(4)
+#define RCC_MC_AHB3ENCLRR_HASH2EN		BIT(5)
+#define RCC_MC_AHB3ENCLRR_RNG2EN		BIT(6)
+#define RCC_MC_AHB3ENCLRR_CRC2EN		BIT(7)
+#define RCC_MC_AHB3ENCLRR_HSEMEN		BIT(11)
+#define RCC_MC_AHB3ENCLRR_IPCCEN		BIT(12)
+
+/* RCC_MC_AHB4ENSETR register fields */
+#define RCC_MC_AHB4ENSETR_GPIOAEN		BIT(0)
+#define RCC_MC_AHB4ENSETR_GPIOBEN		BIT(1)
+#define RCC_MC_AHB4ENSETR_GPIOCEN		BIT(2)
+#define RCC_MC_AHB4ENSETR_GPIODEN		BIT(3)
+#define RCC_MC_AHB4ENSETR_GPIOEEN		BIT(4)
+#define RCC_MC_AHB4ENSETR_GPIOFEN		BIT(5)
+#define RCC_MC_AHB4ENSETR_GPIOGEN		BIT(6)
+#define RCC_MC_AHB4ENSETR_GPIOHEN		BIT(7)
+#define RCC_MC_AHB4ENSETR_GPIOIEN		BIT(8)
+#define RCC_MC_AHB4ENSETR_GPIOJEN		BIT(9)
+#define RCC_MC_AHB4ENSETR_GPIOKEN		BIT(10)
+
+/* RCC_MC_AHB4ENCLRR register fields */
+#define RCC_MC_AHB4ENCLRR_GPIOAEN		BIT(0)
+#define RCC_MC_AHB4ENCLRR_GPIOBEN		BIT(1)
+#define RCC_MC_AHB4ENCLRR_GPIOCEN		BIT(2)
+#define RCC_MC_AHB4ENCLRR_GPIODEN		BIT(3)
+#define RCC_MC_AHB4ENCLRR_GPIOEEN		BIT(4)
+#define RCC_MC_AHB4ENCLRR_GPIOFEN		BIT(5)
+#define RCC_MC_AHB4ENCLRR_GPIOGEN		BIT(6)
+#define RCC_MC_AHB4ENCLRR_GPIOHEN		BIT(7)
+#define RCC_MC_AHB4ENCLRR_GPIOIEN		BIT(8)
+#define RCC_MC_AHB4ENCLRR_GPIOJEN		BIT(9)
+#define RCC_MC_AHB4ENCLRR_GPIOKEN		BIT(10)
+
+/* RCC_MC_AXIMENSETR register fields */
+#define RCC_MC_AXIMENSETR_SYSRAMEN		BIT(0)
+
+/* RCC_MC_AXIMENCLRR register fields */
+#define RCC_MC_AXIMENCLRR_SYSRAMEN		BIT(0)
+
+/* RCC_MC_MLAHBENSETR register fields */
+#define RCC_MC_MLAHBENSETR_RETRAMEN		BIT(4)
+
+/* RCC_MC_MLAHBENCLRR register fields */
+#define RCC_MC_MLAHBENCLRR_RETRAMEN		BIT(4)
+
+/* RCC_MP_APB1LPENSETR register fields */
+#define RCC_MP_APB1LPENSETR_TIM2LPEN		BIT(0)
+#define RCC_MP_APB1LPENSETR_TIM3LPEN		BIT(1)
+#define RCC_MP_APB1LPENSETR_TIM4LPEN		BIT(2)
+#define RCC_MP_APB1LPENSETR_TIM5LPEN		BIT(3)
+#define RCC_MP_APB1LPENSETR_TIM6LPEN		BIT(4)
+#define RCC_MP_APB1LPENSETR_TIM7LPEN		BIT(5)
+#define RCC_MP_APB1LPENSETR_TIM12LPEN		BIT(6)
+#define RCC_MP_APB1LPENSETR_TIM13LPEN		BIT(7)
+#define RCC_MP_APB1LPENSETR_TIM14LPEN		BIT(8)
+#define RCC_MP_APB1LPENSETR_LPTIM1LPEN		BIT(9)
+#define RCC_MP_APB1LPENSETR_SPI2LPEN		BIT(11)
+#define RCC_MP_APB1LPENSETR_SPI3LPEN		BIT(12)
+#define RCC_MP_APB1LPENSETR_USART2LPEN		BIT(14)
+#define RCC_MP_APB1LPENSETR_USART3LPEN		BIT(15)
+#define RCC_MP_APB1LPENSETR_UART4LPEN		BIT(16)
+#define RCC_MP_APB1LPENSETR_UART5LPEN		BIT(17)
+#define RCC_MP_APB1LPENSETR_UART7LPEN		BIT(18)
+#define RCC_MP_APB1LPENSETR_UART8LPEN		BIT(19)
+#define RCC_MP_APB1LPENSETR_I2C1LPEN		BIT(21)
+#define RCC_MP_APB1LPENSETR_I2C2LPEN		BIT(22)
+#define RCC_MP_APB1LPENSETR_I2C3LPEN		BIT(23)
+#define RCC_MP_APB1LPENSETR_I2C5LPEN		BIT(24)
+#define RCC_MP_APB1LPENSETR_SPDIFLPEN		BIT(26)
+#define RCC_MP_APB1LPENSETR_CECLPEN		BIT(27)
+#define RCC_MP_APB1LPENSETR_DAC12LPEN		BIT(29)
+#define RCC_MP_APB1LPENSETR_MDIOSLPEN		BIT(31)
+
+/* RCC_MP_APB1LPENCLRR register fields */
+#define RCC_MP_APB1LPENCLRR_TIM2LPEN		BIT(0)
+#define RCC_MP_APB1LPENCLRR_TIM3LPEN		BIT(1)
+#define RCC_MP_APB1LPENCLRR_TIM4LPEN		BIT(2)
+#define RCC_MP_APB1LPENCLRR_TIM5LPEN		BIT(3)
+#define RCC_MP_APB1LPENCLRR_TIM6LPEN		BIT(4)
+#define RCC_MP_APB1LPENCLRR_TIM7LPEN		BIT(5)
+#define RCC_MP_APB1LPENCLRR_TIM12LPEN		BIT(6)
+#define RCC_MP_APB1LPENCLRR_TIM13LPEN		BIT(7)
+#define RCC_MP_APB1LPENCLRR_TIM14LPEN		BIT(8)
+#define RCC_MP_APB1LPENCLRR_LPTIM1LPEN		BIT(9)
+#define RCC_MP_APB1LPENCLRR_SPI2LPEN		BIT(11)
+#define RCC_MP_APB1LPENCLRR_SPI3LPEN		BIT(12)
+#define RCC_MP_APB1LPENCLRR_USART2LPEN		BIT(14)
+#define RCC_MP_APB1LPENCLRR_USART3LPEN		BIT(15)
+#define RCC_MP_APB1LPENCLRR_UART4LPEN		BIT(16)
+#define RCC_MP_APB1LPENCLRR_UART5LPEN		BIT(17)
+#define RCC_MP_APB1LPENCLRR_UART7LPEN		BIT(18)
+#define RCC_MP_APB1LPENCLRR_UART8LPEN		BIT(19)
+#define RCC_MP_APB1LPENCLRR_I2C1LPEN		BIT(21)
+#define RCC_MP_APB1LPENCLRR_I2C2LPEN		BIT(22)
+#define RCC_MP_APB1LPENCLRR_I2C3LPEN		BIT(23)
+#define RCC_MP_APB1LPENCLRR_I2C5LPEN		BIT(24)
+#define RCC_MP_APB1LPENCLRR_SPDIFLPEN		BIT(26)
+#define RCC_MP_APB1LPENCLRR_CECLPEN		BIT(27)
+#define RCC_MP_APB1LPENCLRR_DAC12LPEN		BIT(29)
+#define RCC_MP_APB1LPENCLRR_MDIOSLPEN		BIT(31)
+
+/* RCC_MP_APB2LPENSETR register fields */
+#define RCC_MP_APB2LPENSETR_TIM1LPEN		BIT(0)
+#define RCC_MP_APB2LPENSETR_TIM8LPEN		BIT(1)
+#define RCC_MP_APB2LPENSETR_TIM15LPEN		BIT(2)
+#define RCC_MP_APB2LPENSETR_TIM16LPEN		BIT(3)
+#define RCC_MP_APB2LPENSETR_TIM17LPEN		BIT(4)
+#define RCC_MP_APB2LPENSETR_SPI1LPEN		BIT(8)
+#define RCC_MP_APB2LPENSETR_SPI4LPEN		BIT(9)
+#define RCC_MP_APB2LPENSETR_SPI5LPEN		BIT(10)
+#define RCC_MP_APB2LPENSETR_USART6LPEN		BIT(13)
+#define RCC_MP_APB2LPENSETR_SAI1LPEN		BIT(16)
+#define RCC_MP_APB2LPENSETR_SAI2LPEN		BIT(17)
+#define RCC_MP_APB2LPENSETR_SAI3LPEN		BIT(18)
+#define RCC_MP_APB2LPENSETR_DFSDMLPEN		BIT(20)
+#define RCC_MP_APB2LPENSETR_ADFSDMLPEN		BIT(21)
+#define RCC_MP_APB2LPENSETR_FDCANLPEN		BIT(24)
+
+/* RCC_MP_APB2LPENCLRR register fields */
+#define RCC_MP_APB2LPENCLRR_TIM1LPEN		BIT(0)
+#define RCC_MP_APB2LPENCLRR_TIM8LPEN		BIT(1)
+#define RCC_MP_APB2LPENCLRR_TIM15LPEN		BIT(2)
+#define RCC_MP_APB2LPENCLRR_TIM16LPEN		BIT(3)
+#define RCC_MP_APB2LPENCLRR_TIM17LPEN		BIT(4)
+#define RCC_MP_APB2LPENCLRR_SPI1LPEN		BIT(8)
+#define RCC_MP_APB2LPENCLRR_SPI4LPEN		BIT(9)
+#define RCC_MP_APB2LPENCLRR_SPI5LPEN		BIT(10)
+#define RCC_MP_APB2LPENCLRR_USART6LPEN		BIT(13)
+#define RCC_MP_APB2LPENCLRR_SAI1LPEN		BIT(16)
+#define RCC_MP_APB2LPENCLRR_SAI2LPEN		BIT(17)
+#define RCC_MP_APB2LPENCLRR_SAI3LPEN		BIT(18)
+#define RCC_MP_APB2LPENCLRR_DFSDMLPEN		BIT(20)
+#define RCC_MP_APB2LPENCLRR_ADFSDMLPEN		BIT(21)
+#define RCC_MP_APB2LPENCLRR_FDCANLPEN		BIT(24)
+
+/* RCC_MP_APB3LPENSETR register fields */
+#define RCC_MP_APB3LPENSETR_LPTIM2LPEN		BIT(0)
+#define RCC_MP_APB3LPENSETR_LPTIM3LPEN		BIT(1)
+#define RCC_MP_APB3LPENSETR_LPTIM4LPEN		BIT(2)
+#define RCC_MP_APB3LPENSETR_LPTIM5LPEN		BIT(3)
+#define RCC_MP_APB3LPENSETR_SAI4LPEN		BIT(8)
+#define RCC_MP_APB3LPENSETR_SYSCFGLPEN		BIT(11)
+#define RCC_MP_APB3LPENSETR_VREFLPEN		BIT(13)
+#define RCC_MP_APB3LPENSETR_TMPSENSLPEN		BIT(16)
+#define RCC_MP_APB3LPENSETR_PMBCTRLLPEN		BIT(17)
+
+/* RCC_MP_APB3LPENCLRR register fields */
+#define RCC_MP_APB3LPENCLRR_LPTIM2LPEN		BIT(0)
+#define RCC_MP_APB3LPENCLRR_LPTIM3LPEN		BIT(1)
+#define RCC_MP_APB3LPENCLRR_LPTIM4LPEN		BIT(2)
+#define RCC_MP_APB3LPENCLRR_LPTIM5LPEN		BIT(3)
+#define RCC_MP_APB3LPENCLRR_SAI4LPEN		BIT(8)
+#define RCC_MP_APB3LPENCLRR_SYSCFGLPEN		BIT(11)
+#define RCC_MP_APB3LPENCLRR_VREFLPEN		BIT(13)
+#define RCC_MP_APB3LPENCLRR_TMPSENSLPEN		BIT(16)
+#define RCC_MP_APB3LPENCLRR_PMBCTRLLPEN		BIT(17)
+
+/* RCC_MP_AHB2LPENSETR register fields */
+#define RCC_MP_AHB2LPENSETR_DMA1LPEN		BIT(0)
+#define RCC_MP_AHB2LPENSETR_DMA2LPEN		BIT(1)
+#define RCC_MP_AHB2LPENSETR_DMAMUXLPEN		BIT(2)
+#define RCC_MP_AHB2LPENSETR_ADC12LPEN		BIT(5)
+#define RCC_MP_AHB2LPENSETR_USBOLPEN		BIT(8)
+#define RCC_MP_AHB2LPENSETR_SDMMC3LPEN		BIT(16)
+
+/* RCC_MP_AHB2LPENCLRR register fields */
+#define RCC_MP_AHB2LPENCLRR_DMA1LPEN		BIT(0)
+#define RCC_MP_AHB2LPENCLRR_DMA2LPEN		BIT(1)
+#define RCC_MP_AHB2LPENCLRR_DMAMUXLPEN		BIT(2)
+#define RCC_MP_AHB2LPENCLRR_ADC12LPEN		BIT(5)
+#define RCC_MP_AHB2LPENCLRR_USBOLPEN		BIT(8)
+#define RCC_MP_AHB2LPENCLRR_SDMMC3LPEN		BIT(16)
+
+/* RCC_MP_AHB3LPENSETR register fields */
+#define RCC_MP_AHB3LPENSETR_DCMILPEN		BIT(0)
+#define RCC_MP_AHB3LPENSETR_CRYP2LPEN		BIT(4)
+#define RCC_MP_AHB3LPENSETR_HASH2LPEN		BIT(5)
+#define RCC_MP_AHB3LPENSETR_RNG2LPEN		BIT(6)
+#define RCC_MP_AHB3LPENSETR_CRC2LPEN		BIT(7)
+#define RCC_MP_AHB3LPENSETR_HSEMLPEN		BIT(11)
+#define RCC_MP_AHB3LPENSETR_IPCCLPEN		BIT(12)
+
+/* RCC_MP_AHB3LPENCLRR register fields */
+#define RCC_MP_AHB3LPENCLRR_DCMILPEN		BIT(0)
+#define RCC_MP_AHB3LPENCLRR_CRYP2LPEN		BIT(4)
+#define RCC_MP_AHB3LPENCLRR_HASH2LPEN		BIT(5)
+#define RCC_MP_AHB3LPENCLRR_RNG2LPEN		BIT(6)
+#define RCC_MP_AHB3LPENCLRR_CRC2LPEN		BIT(7)
+#define RCC_MP_AHB3LPENCLRR_HSEMLPEN		BIT(11)
+#define RCC_MP_AHB3LPENCLRR_IPCCLPEN		BIT(12)
+
+/* RCC_MP_AHB4LPENSETR register fields */
+#define RCC_MP_AHB4LPENSETR_GPIOALPEN		BIT(0)
+#define RCC_MP_AHB4LPENSETR_GPIOBLPEN		BIT(1)
+#define RCC_MP_AHB4LPENSETR_GPIOCLPEN		BIT(2)
+#define RCC_MP_AHB4LPENSETR_GPIODLPEN		BIT(3)
+#define RCC_MP_AHB4LPENSETR_GPIOELPEN		BIT(4)
+#define RCC_MP_AHB4LPENSETR_GPIOFLPEN		BIT(5)
+#define RCC_MP_AHB4LPENSETR_GPIOGLPEN		BIT(6)
+#define RCC_MP_AHB4LPENSETR_GPIOHLPEN		BIT(7)
+#define RCC_MP_AHB4LPENSETR_GPIOILPEN		BIT(8)
+#define RCC_MP_AHB4LPENSETR_GPIOJLPEN		BIT(9)
+#define RCC_MP_AHB4LPENSETR_GPIOKLPEN		BIT(10)
+
+/* RCC_MP_AHB4LPENCLRR register fields */
+#define RCC_MP_AHB4LPENCLRR_GPIOALPEN		BIT(0)
+#define RCC_MP_AHB4LPENCLRR_GPIOBLPEN		BIT(1)
+#define RCC_MP_AHB4LPENCLRR_GPIOCLPEN		BIT(2)
+#define RCC_MP_AHB4LPENCLRR_GPIODLPEN		BIT(3)
+#define RCC_MP_AHB4LPENCLRR_GPIOELPEN		BIT(4)
+#define RCC_MP_AHB4LPENCLRR_GPIOFLPEN		BIT(5)
+#define RCC_MP_AHB4LPENCLRR_GPIOGLPEN		BIT(6)
+#define RCC_MP_AHB4LPENCLRR_GPIOHLPEN		BIT(7)
+#define RCC_MP_AHB4LPENCLRR_GPIOILPEN		BIT(8)
+#define RCC_MP_AHB4LPENCLRR_GPIOJLPEN		BIT(9)
+#define RCC_MP_AHB4LPENCLRR_GPIOKLPEN		BIT(10)
+
+/* RCC_MP_AXIMLPENSETR register fields */
+#define RCC_MP_AXIMLPENSETR_SYSRAMLPEN		BIT(0)
+
+/* RCC_MP_AXIMLPENCLRR register fields */
+#define RCC_MP_AXIMLPENCLRR_SYSRAMLPEN		BIT(0)
+
+/* RCC_MP_MLAHBLPENSETR register fields */
+#define RCC_MP_MLAHBLPENSETR_SRAM1LPEN		BIT(0)
+#define RCC_MP_MLAHBLPENSETR_SRAM2LPEN		BIT(1)
+#define RCC_MP_MLAHBLPENSETR_SRAM34LPEN		BIT(2)
+#define RCC_MP_MLAHBLPENSETR_RETRAMLPEN		BIT(4)
+
+/* RCC_MP_MLAHBLPENCLRR register fields */
+#define RCC_MP_MLAHBLPENCLRR_SRAM1LPEN		BIT(0)
+#define RCC_MP_MLAHBLPENCLRR_SRAM2LPEN		BIT(1)
+#define RCC_MP_MLAHBLPENCLRR_SRAM34LPEN		BIT(2)
+#define RCC_MP_MLAHBLPENCLRR_RETRAMLPEN		BIT(4)
+
+/* RCC_MC_APB1LPENSETR register fields */
+#define RCC_MC_APB1LPENSETR_TIM2LPEN		BIT(0)
+#define RCC_MC_APB1LPENSETR_TIM3LPEN		BIT(1)
+#define RCC_MC_APB1LPENSETR_TIM4LPEN		BIT(2)
+#define RCC_MC_APB1LPENSETR_TIM5LPEN		BIT(3)
+#define RCC_MC_APB1LPENSETR_TIM6LPEN		BIT(4)
+#define RCC_MC_APB1LPENSETR_TIM7LPEN		BIT(5)
+#define RCC_MC_APB1LPENSETR_TIM12LPEN		BIT(6)
+#define RCC_MC_APB1LPENSETR_TIM13LPEN		BIT(7)
+#define RCC_MC_APB1LPENSETR_TIM14LPEN		BIT(8)
+#define RCC_MC_APB1LPENSETR_LPTIM1LPEN		BIT(9)
+#define RCC_MC_APB1LPENSETR_SPI2LPEN		BIT(11)
+#define RCC_MC_APB1LPENSETR_SPI3LPEN		BIT(12)
+#define RCC_MC_APB1LPENSETR_USART2LPEN		BIT(14)
+#define RCC_MC_APB1LPENSETR_USART3LPEN		BIT(15)
+#define RCC_MC_APB1LPENSETR_UART4LPEN		BIT(16)
+#define RCC_MC_APB1LPENSETR_UART5LPEN		BIT(17)
+#define RCC_MC_APB1LPENSETR_UART7LPEN		BIT(18)
+#define RCC_MC_APB1LPENSETR_UART8LPEN		BIT(19)
+#define RCC_MC_APB1LPENSETR_I2C1LPEN		BIT(21)
+#define RCC_MC_APB1LPENSETR_I2C2LPEN		BIT(22)
+#define RCC_MC_APB1LPENSETR_I2C3LPEN		BIT(23)
+#define RCC_MC_APB1LPENSETR_I2C5LPEN		BIT(24)
+#define RCC_MC_APB1LPENSETR_SPDIFLPEN		BIT(26)
+#define RCC_MC_APB1LPENSETR_CECLPEN		BIT(27)
+#define RCC_MC_APB1LPENSETR_WWDG1LPEN		BIT(28)
+#define RCC_MC_APB1LPENSETR_DAC12LPEN		BIT(29)
+#define RCC_MC_APB1LPENSETR_MDIOSLPEN		BIT(31)
+
+/* RCC_MC_APB1LPENCLRR register fields */
+#define RCC_MC_APB1LPENCLRR_TIM2LPEN		BIT(0)
+#define RCC_MC_APB1LPENCLRR_TIM3LPEN		BIT(1)
+#define RCC_MC_APB1LPENCLRR_TIM4LPEN		BIT(2)
+#define RCC_MC_APB1LPENCLRR_TIM5LPEN		BIT(3)
+#define RCC_MC_APB1LPENCLRR_TIM6LPEN		BIT(4)
+#define RCC_MC_APB1LPENCLRR_TIM7LPEN		BIT(5)
+#define RCC_MC_APB1LPENCLRR_TIM12LPEN		BIT(6)
+#define RCC_MC_APB1LPENCLRR_TIM13LPEN		BIT(7)
+#define RCC_MC_APB1LPENCLRR_TIM14LPEN		BIT(8)
+#define RCC_MC_APB1LPENCLRR_LPTIM1LPEN		BIT(9)
+#define RCC_MC_APB1LPENCLRR_SPI2LPEN		BIT(11)
+#define RCC_MC_APB1LPENCLRR_SPI3LPEN		BIT(12)
+#define RCC_MC_APB1LPENCLRR_USART2LPEN		BIT(14)
+#define RCC_MC_APB1LPENCLRR_USART3LPEN		BIT(15)
+#define RCC_MC_APB1LPENCLRR_UART4LPEN		BIT(16)
+#define RCC_MC_APB1LPENCLRR_UART5LPEN		BIT(17)
+#define RCC_MC_APB1LPENCLRR_UART7LPEN		BIT(18)
+#define RCC_MC_APB1LPENCLRR_UART8LPEN		BIT(19)
+#define RCC_MC_APB1LPENCLRR_I2C1LPEN		BIT(21)
+#define RCC_MC_APB1LPENCLRR_I2C2LPEN		BIT(22)
+#define RCC_MC_APB1LPENCLRR_I2C3LPEN		BIT(23)
+#define RCC_MC_APB1LPENCLRR_I2C5LPEN		BIT(24)
+#define RCC_MC_APB1LPENCLRR_SPDIFLPEN		BIT(26)
+#define RCC_MC_APB1LPENCLRR_CECLPEN		BIT(27)
+#define RCC_MC_APB1LPENCLRR_WWDG1LPEN		BIT(28)
+#define RCC_MC_APB1LPENCLRR_DAC12LPEN		BIT(29)
+#define RCC_MC_APB1LPENCLRR_MDIOSLPEN		BIT(31)
+
+/* RCC_MC_APB2LPENSETR register fields */
+#define RCC_MC_APB2LPENSETR_TIM1LPEN		BIT(0)
+#define RCC_MC_APB2LPENSETR_TIM8LPEN		BIT(1)
+#define RCC_MC_APB2LPENSETR_TIM15LPEN		BIT(2)
+#define RCC_MC_APB2LPENSETR_TIM16LPEN		BIT(3)
+#define RCC_MC_APB2LPENSETR_TIM17LPEN		BIT(4)
+#define RCC_MC_APB2LPENSETR_SPI1LPEN		BIT(8)
+#define RCC_MC_APB2LPENSETR_SPI4LPEN		BIT(9)
+#define RCC_MC_APB2LPENSETR_SPI5LPEN		BIT(10)
+#define RCC_MC_APB2LPENSETR_USART6LPEN		BIT(13)
+#define RCC_MC_APB2LPENSETR_SAI1LPEN		BIT(16)
+#define RCC_MC_APB2LPENSETR_SAI2LPEN		BIT(17)
+#define RCC_MC_APB2LPENSETR_SAI3LPEN		BIT(18)
+#define RCC_MC_APB2LPENSETR_DFSDMLPEN		BIT(20)
+#define RCC_MC_APB2LPENSETR_ADFSDMLPEN		BIT(21)
+#define RCC_MC_APB2LPENSETR_FDCANLPEN		BIT(24)
+
+/* RCC_MC_APB2LPENCLRR register fields */
+#define RCC_MC_APB2LPENCLRR_TIM1LPEN		BIT(0)
+#define RCC_MC_APB2LPENCLRR_TIM8LPEN		BIT(1)
+#define RCC_MC_APB2LPENCLRR_TIM15LPEN		BIT(2)
+#define RCC_MC_APB2LPENCLRR_TIM16LPEN		BIT(3)
+#define RCC_MC_APB2LPENCLRR_TIM17LPEN		BIT(4)
+#define RCC_MC_APB2LPENCLRR_SPI1LPEN		BIT(8)
+#define RCC_MC_APB2LPENCLRR_SPI4LPEN		BIT(9)
+#define RCC_MC_APB2LPENCLRR_SPI5LPEN		BIT(10)
+#define RCC_MC_APB2LPENCLRR_USART6LPEN		BIT(13)
+#define RCC_MC_APB2LPENCLRR_SAI1LPEN		BIT(16)
+#define RCC_MC_APB2LPENCLRR_SAI2LPEN		BIT(17)
+#define RCC_MC_APB2LPENCLRR_SAI3LPEN		BIT(18)
+#define RCC_MC_APB2LPENCLRR_DFSDMLPEN		BIT(20)
+#define RCC_MC_APB2LPENCLRR_ADFSDMLPEN		BIT(21)
+#define RCC_MC_APB2LPENCLRR_FDCANLPEN		BIT(24)
+
+/* RCC_MC_APB3LPENSETR register fields */
+#define RCC_MC_APB3LPENSETR_LPTIM2LPEN		BIT(0)
+#define RCC_MC_APB3LPENSETR_LPTIM3LPEN		BIT(1)
+#define RCC_MC_APB3LPENSETR_LPTIM4LPEN		BIT(2)
+#define RCC_MC_APB3LPENSETR_LPTIM5LPEN		BIT(3)
+#define RCC_MC_APB3LPENSETR_SAI4LPEN		BIT(8)
+#define RCC_MC_APB3LPENSETR_SYSCFGLPEN		BIT(11)
+#define RCC_MC_APB3LPENSETR_VREFLPEN		BIT(13)
+#define RCC_MC_APB3LPENSETR_TMPSENSLPEN		BIT(16)
+#define RCC_MC_APB3LPENSETR_PMBCTRLLPEN		BIT(17)
+
+/* RCC_MC_APB3LPENCLRR register fields */
+#define RCC_MC_APB3LPENCLRR_LPTIM2LPEN		BIT(0)
+#define RCC_MC_APB3LPENCLRR_LPTIM3LPEN		BIT(1)
+#define RCC_MC_APB3LPENCLRR_LPTIM4LPEN		BIT(2)
+#define RCC_MC_APB3LPENCLRR_LPTIM5LPEN		BIT(3)
+#define RCC_MC_APB3LPENCLRR_SAI4LPEN		BIT(8)
+#define RCC_MC_APB3LPENCLRR_SYSCFGLPEN		BIT(11)
+#define RCC_MC_APB3LPENCLRR_VREFLPEN		BIT(13)
+#define RCC_MC_APB3LPENCLRR_TMPSENSLPEN		BIT(16)
+#define RCC_MC_APB3LPENCLRR_PMBCTRLLPEN		BIT(17)
+
+/* RCC_MC_AHB2LPENSETR register fields */
+#define RCC_MC_AHB2LPENSETR_DMA1LPEN		BIT(0)
+#define RCC_MC_AHB2LPENSETR_DMA2LPEN		BIT(1)
+#define RCC_MC_AHB2LPENSETR_DMAMUXLPEN		BIT(2)
+#define RCC_MC_AHB2LPENSETR_ADC12LPEN		BIT(5)
+#define RCC_MC_AHB2LPENSETR_USBOLPEN		BIT(8)
+#define RCC_MC_AHB2LPENSETR_SDMMC3LPEN		BIT(16)
+
+/* RCC_MC_AHB2LPENCLRR register fields */
+#define RCC_MC_AHB2LPENCLRR_DMA1LPEN		BIT(0)
+#define RCC_MC_AHB2LPENCLRR_DMA2LPEN		BIT(1)
+#define RCC_MC_AHB2LPENCLRR_DMAMUXLPEN		BIT(2)
+#define RCC_MC_AHB2LPENCLRR_ADC12LPEN		BIT(5)
+#define RCC_MC_AHB2LPENCLRR_USBOLPEN		BIT(8)
+#define RCC_MC_AHB2LPENCLRR_SDMMC3LPEN		BIT(16)
+
+/* RCC_MC_AHB3LPENSETR register fields */
+#define RCC_MC_AHB3LPENSETR_DCMILPEN		BIT(0)
+#define RCC_MC_AHB3LPENSETR_CRYP2LPEN		BIT(4)
+#define RCC_MC_AHB3LPENSETR_HASH2LPEN		BIT(5)
+#define RCC_MC_AHB3LPENSETR_RNG2LPEN		BIT(6)
+#define RCC_MC_AHB3LPENSETR_CRC2LPEN		BIT(7)
+#define RCC_MC_AHB3LPENSETR_HSEMLPEN		BIT(11)
+#define RCC_MC_AHB3LPENSETR_IPCCLPEN		BIT(12)
+
+/* RCC_MC_AHB3LPENCLRR register fields */
+#define RCC_MC_AHB3LPENCLRR_DCMILPEN		BIT(0)
+#define RCC_MC_AHB3LPENCLRR_CRYP2LPEN		BIT(4)
+#define RCC_MC_AHB3LPENCLRR_HASH2LPEN		BIT(5)
+#define RCC_MC_AHB3LPENCLRR_RNG2LPEN		BIT(6)
+#define RCC_MC_AHB3LPENCLRR_CRC2LPEN		BIT(7)
+#define RCC_MC_AHB3LPENCLRR_HSEMLPEN		BIT(11)
+#define RCC_MC_AHB3LPENCLRR_IPCCLPEN		BIT(12)
+
+/* RCC_MC_AHB4LPENSETR register fields */
+#define RCC_MC_AHB4LPENSETR_GPIOALPEN		BIT(0)
+#define RCC_MC_AHB4LPENSETR_GPIOBLPEN		BIT(1)
+#define RCC_MC_AHB4LPENSETR_GPIOCLPEN		BIT(2)
+#define RCC_MC_AHB4LPENSETR_GPIODLPEN		BIT(3)
+#define RCC_MC_AHB4LPENSETR_GPIOELPEN		BIT(4)
+#define RCC_MC_AHB4LPENSETR_GPIOFLPEN		BIT(5)
+#define RCC_MC_AHB4LPENSETR_GPIOGLPEN		BIT(6)
+#define RCC_MC_AHB4LPENSETR_GPIOHLPEN		BIT(7)
+#define RCC_MC_AHB4LPENSETR_GPIOILPEN		BIT(8)
+#define RCC_MC_AHB4LPENSETR_GPIOJLPEN		BIT(9)
+#define RCC_MC_AHB4LPENSETR_GPIOKLPEN		BIT(10)
+
+/* RCC_MC_AHB4LPENCLRR register fields */
+#define RCC_MC_AHB4LPENCLRR_GPIOALPEN		BIT(0)
+#define RCC_MC_AHB4LPENCLRR_GPIOBLPEN		BIT(1)
+#define RCC_MC_AHB4LPENCLRR_GPIOCLPEN		BIT(2)
+#define RCC_MC_AHB4LPENCLRR_GPIODLPEN		BIT(3)
+#define RCC_MC_AHB4LPENCLRR_GPIOELPEN		BIT(4)
+#define RCC_MC_AHB4LPENCLRR_GPIOFLPEN		BIT(5)
+#define RCC_MC_AHB4LPENCLRR_GPIOGLPEN		BIT(6)
+#define RCC_MC_AHB4LPENCLRR_GPIOHLPEN		BIT(7)
+#define RCC_MC_AHB4LPENCLRR_GPIOILPEN		BIT(8)
+#define RCC_MC_AHB4LPENCLRR_GPIOJLPEN		BIT(9)
+#define RCC_MC_AHB4LPENCLRR_GPIOKLPEN		BIT(10)
+
+/* RCC_MC_AXIMLPENSETR register fields */
+#define RCC_MC_AXIMLPENSETR_SYSRAMLPEN		BIT(0)
+
+/* RCC_MC_AXIMLPENCLRR register fields */
+#define RCC_MC_AXIMLPENCLRR_SYSRAMLPEN		BIT(0)
+
+/* RCC_MC_MLAHBLPENSETR register fields */
+#define RCC_MC_MLAHBLPENSETR_SRAM1LPEN		BIT(0)
+#define RCC_MC_MLAHBLPENSETR_SRAM2LPEN		BIT(1)
+#define RCC_MC_MLAHBLPENSETR_SRAM34LPEN		BIT(2)
+#define RCC_MC_MLAHBLPENSETR_RETRAMLPEN		BIT(4)
+
+/* RCC_MC_MLAHBLPENCLRR register fields */
+#define RCC_MC_MLAHBLPENCLRR_SRAM1LPEN		BIT(0)
+#define RCC_MC_MLAHBLPENCLRR_SRAM2LPEN		BIT(1)
+#define RCC_MC_MLAHBLPENCLRR_SRAM34LPEN		BIT(2)
+#define RCC_MC_MLAHBLPENCLRR_RETRAMLPEN		BIT(4)
+
+/* RCC_MC_RSTSCLRR register fields */
+#define RCC_MC_RSTSCLRR_PORRSTF			BIT(0)
+#define RCC_MC_RSTSCLRR_BORRSTF			BIT(1)
+#define RCC_MC_RSTSCLRR_PADRSTF			BIT(2)
+#define RCC_MC_RSTSCLRR_HCSSRSTF		BIT(3)
+#define RCC_MC_RSTSCLRR_VCORERSTF		BIT(4)
+#define RCC_MC_RSTSCLRR_MCURSTF			BIT(5)
+#define RCC_MC_RSTSCLRR_MPSYSRSTF		BIT(6)
+#define RCC_MC_RSTSCLRR_MCSYSRSTF		BIT(7)
+#define RCC_MC_RSTSCLRR_IWDG1RSTF		BIT(8)
+#define RCC_MC_RSTSCLRR_IWDG2RSTF		BIT(9)
+#define RCC_MC_RSTSCLRR_WWDG1RSTF		BIT(10)
+
+/* RCC_MC_CIER register fields */
+#define RCC_MC_CIER_LSIRDYIE			BIT(0)
+#define RCC_MC_CIER_LSERDYIE			BIT(1)
+#define RCC_MC_CIER_HSIRDYIE			BIT(2)
+#define RCC_MC_CIER_HSERDYIE			BIT(3)
+#define RCC_MC_CIER_CSIRDYIE			BIT(4)
+#define RCC_MC_CIER_PLL1DYIE			BIT(8)
+#define RCC_MC_CIER_PLL2DYIE			BIT(9)
+#define RCC_MC_CIER_PLL3DYIE			BIT(10)
+#define RCC_MC_CIER_PLL4DYIE			BIT(11)
+#define RCC_MC_CIER_LSECSSIE			BIT(16)
+#define RCC_MC_CIER_WKUPIE			BIT(20)
+
+/* RCC_MC_CIFR register fields */
+#define RCC_MC_CIFR_LSIRDYF			BIT(0)
+#define RCC_MC_CIFR_LSERDYF			BIT(1)
+#define RCC_MC_CIFR_HSIRDYF			BIT(2)
+#define RCC_MC_CIFR_HSERDYF			BIT(3)
+#define RCC_MC_CIFR_CSIRDYF			BIT(4)
+#define RCC_MC_CIFR_PLL1DYF			BIT(8)
+#define RCC_MC_CIFR_PLL2DYF			BIT(9)
+#define RCC_MC_CIFR_PLL3DYF			BIT(10)
+#define RCC_MC_CIFR_PLL4DYF			BIT(11)
+#define RCC_MC_CIFR_LSECSSF			BIT(16)
+#define RCC_MC_CIFR_WKUPF			BIT(20)
+
+/* RCC_VERR register fields */
+#define RCC_VERR_MINREV_MASK			GENMASK(3, 0)
+#define RCC_VERR_MINREV_SHIFT			0
+#define RCC_VERR_MAJREV_MASK			GENMASK(7, 4)
+#define RCC_VERR_MAJREV_SHIFT			4
+
+/* Used for RCC_OCENSETR and RCC_OCENCLRR registers */
+#define RCC_OCENR_HSION				BIT(0)
+#define RCC_OCENR_HSIKERON			BIT(1)
+#define RCC_OCENR_CSION				BIT(4)
+#define RCC_OCENR_CSIKERON			BIT(5)
+#define RCC_OCENR_DIGBYP			BIT(7)
+#define RCC_OCENR_HSEON				BIT(8)
+#define RCC_OCENR_HSEKERON			BIT(9)
+#define RCC_OCENR_HSEBYP			BIT(10)
+#define RCC_OCENR_HSECSSON			BIT(11)
+
+/* Offset between RCC_MP_xxxENSETR and RCC_MP_xxxENCLRR registers */
+#define RCC_MP_ENCLRR_OFFSET			U(4)
+
+/* Offset between RCC_xxxRSTSETR and RCC_xxxRSTCLRR registers */
+#define RCC_RSTCLRR_OFFSET			U(4)
+
+/* Used for most of DIVR register: max div for RTC */
+#define RCC_DIVR_DIV_MASK			GENMASK(5, 0)
+#define RCC_DIVR_DIVRDY				BIT(31)
+
+/* Masks for specific DIVR registers */
+#define RCC_APBXDIV_MASK			GENMASK(2, 0)
+#define RCC_MPUDIV_MASK				GENMASK(2, 0)
+#define RCC_AXIDIV_MASK				GENMASK(2, 0)
+#define RCC_MCUDIV_MASK				GENMASK(3, 0)
+
+/* Used for most of RCC_<x>SELR registers */
+#define RCC_SELR_SRC_MASK			GENMASK(2, 0)
+#define RCC_SELR_REFCLK_SRC_MASK		GENMASK(1, 0)
+#define RCC_SELR_SRCRDY				BIT(31)
+
+/* Used for all RCC_PLL<n>CR registers */
+#define RCC_PLLNCR_PLLON			BIT(0)
+#define RCC_PLLNCR_PLLRDY			BIT(1)
+#define RCC_PLLNCR_SSCG_CTRL			BIT(2)
+#define RCC_PLLNCR_DIVPEN			BIT(4)
+#define RCC_PLLNCR_DIVQEN			BIT(5)
+#define RCC_PLLNCR_DIVREN			BIT(6)
+#define RCC_PLLNCR_DIVEN_SHIFT			4
+
+/* Used for all RCC_PLL<n>CFGR1 registers */
+#define RCC_PLLNCFGR1_DIVM_MASK			GENMASK(21, 16)
+#define RCC_PLLNCFGR1_DIVM_SHIFT		16
+#define RCC_PLLNCFGR1_DIVN_MASK			GENMASK(8, 0)
+#define RCC_PLLNCFGR1_DIVN_SHIFT		0
+
+/* Only for PLL3 and PLL4 */
+#define RCC_PLLNCFGR1_IFRGE_MASK		GENMASK(25, 24)
+#define RCC_PLLNCFGR1_IFRGE_SHIFT		24
+
+/* Used for all RCC_PLL<n>CFGR2 registers */
+#define RCC_PLLNCFGR2_DIVX_MASK			GENMASK(6, 0)
+#define RCC_PLLNCFGR2_DIVP_MASK			GENMASK(6, 0)
+#define RCC_PLLNCFGR2_DIVP_SHIFT		0
+#define RCC_PLLNCFGR2_DIVQ_MASK			GENMASK(14, 8)
+#define RCC_PLLNCFGR2_DIVQ_SHIFT		8
+#define RCC_PLLNCFGR2_DIVR_MASK			GENMASK(22, 16)
+#define RCC_PLLNCFGR2_DIVR_SHIFT		16
+
+/* Used for all RCC_PLL<n>FRACR registers */
+#define RCC_PLLNFRACR_FRACV_SHIFT		3
+#define RCC_PLLNFRACR_FRACV_MASK		GENMASK(15, 3)
+#define RCC_PLLNFRACR_FRACLE			BIT(16)
+
+/* Used for all RCC_PLL<n>CSGR registers */
+#define RCC_PLLNCSGR_INC_STEP_SHIFT		16
+#define RCC_PLLNCSGR_INC_STEP_MASK		GENMASK(30, 16)
+#define RCC_PLLNCSGR_MOD_PER_SHIFT		0
+#define RCC_PLLNCSGR_MOD_PER_MASK		GENMASK(12, 0)
+#define RCC_PLLNCSGR_SSCG_MODE_SHIFT		15
+#define RCC_PLLNCSGR_SSCG_MODE_MASK		BIT(15)
+
+/* Used for TIMER Prescaler */
+#define RCC_TIMGXPRER_TIMGXPRE			BIT(0)
+
+/* Used for RCC_MCO related operations */
+#define RCC_MCOCFG_MCOON			BIT(12)
+#define RCC_MCOCFG_MCODIV_MASK			GENMASK(7, 4)
+#define RCC_MCOCFG_MCODIV_SHIFT			4
+#define RCC_MCOCFG_MCOSRC_MASK			GENMASK(2, 0)
+
+#endif /* STM32MP1_RCC_H */
diff --git a/include/drivers/st/stm32mp1_calib.h b/include/drivers/st/stm32mp1_calib.h
new file mode 100644
index 000000000..ef69cb456
--- /dev/null
+++ b/include/drivers/st/stm32mp1_calib.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) 2018-2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP1_CALIB_H
+#define STM32MP1_CALIB_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+bool stm32mp1_calib_get_wakeup(void);
+void stm32mp1_calib_set_wakeup(bool state);
+void stm32mp1_calib_it_handler(uint32_t id);
+int stm32mp1_calib_start_hsi_cal(void);
+int stm32mp1_calib_start_csi_cal(void);
+void stm32mp1_calib_init(void);
+
+#endif /* STM32MP1_CLK_H */
diff --git a/include/drivers/st/stm32mp1_clk.h b/include/drivers/st/stm32mp1_clk.h
index c46892b78..86efbd893 100644
--- a/include/drivers/st/stm32mp1_clk.h
+++ b/include/drivers/st/stm32mp1_clk.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2019, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2018-2020, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -22,42 +22,42 @@ enum stm32mp_osc_id {
 
 extern const char *stm32mp_osc_node_label[NB_OSC];
 
+#define PLL1_SETTINGS_VALID_ID	U(0x504C4C31) /* "PLL1" */
+
 int stm32mp1_clk_probe(void);
-int stm32mp1_clk_init(void);
+int stm32mp1_clk_init(uint32_t pll1_freq_mhz);
+
+int stm32mp1_clk_compute_all_pll1_settings(uint32_t buck1_voltage);
+void stm32mp1_clk_lp_save_opp_pll1_settings(uint8_t *data, size_t size);
+void stm32mp1_clk_lp_load_opp_pll1_settings(uint8_t *data, size_t size);
+
+int stm32mp1_clk_get_maxfreq_opp(uint32_t *freq_mhz, uint32_t *voltage_mv);
 
 bool stm32mp1_rcc_is_secure(void);
 bool stm32mp1_rcc_is_mckprot(void);
 
-void __stm32mp1_clk_enable(unsigned long id, bool caller_is_secure);
-void __stm32mp1_clk_disable(unsigned long id, bool caller_is_secure);
+void stm32mp1_clk_force_enable(unsigned long id);
+void stm32mp1_clk_force_disable(unsigned long id);
 
-static inline void stm32mp1_clk_enable_non_secure(unsigned long id)
-{
-	__stm32mp1_clk_enable(id, false);
-}
+bool stm32mp1_rtc_get_read_twice(void);
 
-static inline void stm32mp1_clk_enable_secure(unsigned long id)
-{
-	__stm32mp1_clk_enable(id, true);
-}
+/* SMP protection on RCC registers access */
+void stm32mp1_clk_rcc_regs_lock(void);
+void stm32mp1_clk_rcc_regs_unlock(void);
 
-static inline void stm32mp1_clk_disable_non_secure(unsigned long id)
-{
-	__stm32mp1_clk_disable(id, false);
-}
+int stm32mp1_round_opp_khz(uint32_t *freq_khz);
+int stm32mp1_set_opp_khz(uint32_t freq_khz);
 
-static inline void stm32mp1_clk_disable_secure(unsigned long id)
-{
-	__stm32mp1_clk_disable(id, true);
-}
+void stm32mp1_clock_suspend(void);
+void stm32mp1_clock_resume(void);
 
-unsigned int stm32mp1_clk_get_refcount(unsigned long id);
+void stm32mp1_clock_stopmode_save(void);
+int stm32mp1_clock_stopmode_resume(void);
 
-/* SMP protection on RCC registers access */
-void stm32mp1_clk_rcc_regs_lock(void);
-void stm32mp1_clk_rcc_regs_unlock(void);
+void restore_clock_pm_context(void);
+void save_clock_pm_context(void);
 
-void stm32mp1_stgen_increment(unsigned long long offset_in_ms);
+void stm32mp1_clk_mcuss_protect(bool enable);
 
 #ifdef STM32MP_SHARED_RESOURCES
 void stm32mp1_register_clock_parents_secure(unsigned long id);
diff --git a/include/drivers/st/stm32mp1_ddr.h b/include/drivers/st/stm32mp1_ddr.h
index 4ab37d6b4..f21a8a75c 100644
--- a/include/drivers/st/stm32mp1_ddr.h
+++ b/include/drivers/st/stm32mp1_ddr.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2018-2019, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2018-2021, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
  */
@@ -8,31 +8,8 @@
 #define STM32MP1_DDR_H
 
 #include <stdbool.h>
-#include <stdint.h>
 
-#define DT_DDR_COMPAT	"st,stm32mp1-ddr"
-
-struct stm32mp1_ddr_size {
-	uint64_t base;
-	uint64_t size;
-};
-
-/**
- * struct ddr_info
- *
- * @dev: pointer for the device
- * @info: UCLASS RAM information
- * @ctl: DDR controleur base address
- * @phy: DDR PHY base address
- * @syscfg: syscfg base address
- */
-struct ddr_info {
-	struct stm32mp1_ddr_size info;
-	struct stm32mp1_ddrctl *ctl;
-	struct stm32mp1_ddrphy *phy;
-	uintptr_t pwr;
-	uintptr_t rcc;
-};
+#include <drivers/st/stm32mp_ddr.h>
 
 struct stm32mp1_ddrctrl_reg {
 	uint32_t mstr;
@@ -101,12 +78,14 @@ struct stm32mp1_ddrctrl_perf {
 	uint32_t pcfgqos1_0;
 	uint32_t pcfgwqos0_0;
 	uint32_t pcfgwqos1_0;
+#if STM32MP_DDR_DUAL_AXI_PORT
 	uint32_t pcfgr_1;
 	uint32_t pcfgw_1;
 	uint32_t pcfgqos0_1;
 	uint32_t pcfgqos1_1;
 	uint32_t pcfgwqos0_1;
 	uint32_t pcfgwqos1_1;
+#endif
 };
 
 struct stm32mp1_ddrphy_reg {
@@ -119,8 +98,10 @@ struct stm32mp1_ddrphy_reg {
 	uint32_t zq0cr1;
 	uint32_t dx0gcr;
 	uint32_t dx1gcr;
+#if STM32MP_DDR_32BIT_INTERFACE
 	uint32_t dx2gcr;
 	uint32_t dx3gcr;
+#endif
 };
 
 struct stm32mp1_ddrphy_timing {
@@ -136,39 +117,19 @@ struct stm32mp1_ddrphy_timing {
 	uint32_t mr3;
 };
 
-struct stm32mp1_ddrphy_cal {
-	uint32_t dx0dllcr;
-	uint32_t dx0dqtr;
-	uint32_t dx0dqstr;
-	uint32_t dx1dllcr;
-	uint32_t dx1dqtr;
-	uint32_t dx1dqstr;
-	uint32_t dx2dllcr;
-	uint32_t dx2dqtr;
-	uint32_t dx2dqstr;
-	uint32_t dx3dllcr;
-	uint32_t dx3dqtr;
-	uint32_t dx3dqstr;
-};
-
-struct stm32mp1_ddr_info {
-	const char *name;
-	uint32_t speed; /* in kHZ */
-	uint32_t size;  /* Memory size in byte = col * row * width */
-};
-
-struct stm32mp1_ddr_config {
-	struct stm32mp1_ddr_info info;
+struct stm32mp_ddr_config {
+	struct stm32mp_ddr_info info;
 	struct stm32mp1_ddrctrl_reg c_reg;
 	struct stm32mp1_ddrctrl_timing c_timing;
 	struct stm32mp1_ddrctrl_map c_map;
 	struct stm32mp1_ddrctrl_perf c_perf;
 	struct stm32mp1_ddrphy_reg p_reg;
 	struct stm32mp1_ddrphy_timing p_timing;
-	struct stm32mp1_ddrphy_cal p_cal;
+	bool self_refresh;
+	uint32_t zdata;
 };
 
-int stm32mp1_ddr_clk_enable(struct ddr_info *priv, uint32_t mem_speed);
-void stm32mp1_ddr_init(struct ddr_info *priv,
-		       struct stm32mp1_ddr_config *config);
+int stm32mp1_ddr_clk_enable(struct stm32mp_ddr_priv *priv, uint32_t mem_speed);
+void stm32mp1_ddr_init(struct stm32mp_ddr_priv *priv, struct stm32mp_ddr_config *config);
+
 #endif /* STM32MP1_DDR_H */
diff --git a/include/drivers/st/stm32mp1_ddr_helpers.h b/include/drivers/st/stm32mp1_ddr_helpers.h
index 38f24152a..17366deaa 100644
--- a/include/drivers/st/stm32mp1_ddr_helpers.h
+++ b/include/drivers/st/stm32mp1_ddr_helpers.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2018, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2017-2020, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -7,6 +7,22 @@
 #ifndef STM32MP1_DDR_HELPERS_H
 #define STM32MP1_DDR_HELPERS_H
 
+#include <stdbool.h>
+#include <stdint.h>
+
+enum stm32mp1_ddr_sr_mode {
+	DDR_SR_MODE_INVALID = 0,
+	DDR_SSR_MODE,
+	DDR_HSR_MODE,
+	DDR_ASR_MODE,
+};
+
 void ddr_enable_clock(void);
+int ddr_sw_self_refresh_exit(void);
+uint32_t ddr_get_io_calibration_val(void);
+int ddr_standby_sr_entry(void);
+enum stm32mp1_ddr_sr_mode ddr_read_sr_mode(void);
+void ddr_set_sr_mode(enum stm32mp1_ddr_sr_mode mode);
+bool ddr_is_nonsecured_area(uintptr_t address, uint32_t length);
 
 #endif /* STM32MP1_DDR_HELPERS_H */
diff --git a/include/drivers/st/stm32mp1_ddr_regs.h b/include/drivers/st/stm32mp1_ddr_regs.h
index 01d663834..ae780e6ec 100644
--- a/include/drivers/st/stm32mp1_ddr_regs.h
+++ b/include/drivers/st/stm32mp1_ddr_regs.h
@@ -7,140 +7,11 @@
 #ifndef STM32MP1_DDR_REGS_H
 #define STM32MP1_DDR_REGS_H
 
+#include <drivers/st/stm32mp_ddrctrl_regs.h>
 #include <lib/utils_def.h>
 
-/* DDR3/LPDDR2/LPDDR3 Controller (DDRCTRL) registers */
-struct stm32mp1_ddrctl {
-	uint32_t mstr ;		/* 0x0 Master */
-	uint32_t stat;		/* 0x4 Operating Mode Status */
-	uint8_t reserved008[0x10 - 0x8];
-	uint32_t mrctrl0;	/* 0x10 Control 0 */
-	uint32_t mrctrl1;	/* 0x14 Control 1 */
-	uint32_t mrstat;	/* 0x18 Status */
-	uint32_t reserved01c;	/* 0x1c */
-	uint32_t derateen;	/* 0x20 Temperature Derate Enable */
-	uint32_t derateint;	/* 0x24 Temperature Derate Interval */
-	uint8_t reserved028[0x30 - 0x28];
-	uint32_t pwrctl;	/* 0x30 Low Power Control */
-	uint32_t pwrtmg;	/* 0x34 Low Power Timing */
-	uint32_t hwlpctl;	/* 0x38 Hardware Low Power Control */
-	uint8_t reserved03c[0x50 - 0x3C];
-	uint32_t rfshctl0;	/* 0x50 Refresh Control 0 */
-	uint32_t reserved054;	/* 0x54 Refresh Control 1 */
-	uint32_t reserved058;	/* 0x58 Refresh Control 2 */
-	uint32_t reserved05C;
-	uint32_t rfshctl3;	/* 0x60 Refresh Control 0 */
-	uint32_t rfshtmg;	/* 0x64 Refresh Timing */
-	uint8_t reserved068[0xc0 - 0x68];
-	uint32_t crcparctl0;		/* 0xc0 CRC Parity Control0 */
-	uint32_t reserved0c4;	/* 0xc4 CRC Parity Control1 */
-	uint32_t reserved0c8;	/* 0xc8 CRC Parity Control2 */
-	uint32_t crcparstat;		/* 0xcc CRC Parity Status */
-	uint32_t init0;		/* 0xd0 SDRAM Initialization 0 */
-	uint32_t init1;		/* 0xd4 SDRAM Initialization 1 */
-	uint32_t init2;		/* 0xd8 SDRAM Initialization 2 */
-	uint32_t init3;		/* 0xdc SDRAM Initialization 3 */
-	uint32_t init4;		/* 0xe0 SDRAM Initialization 4 */
-	uint32_t init5;		/* 0xe4 SDRAM Initialization 5 */
-	uint32_t reserved0e8;
-	uint32_t reserved0ec;
-	uint32_t dimmctl;	/* 0xf0 DIMM Control */
-	uint8_t reserved0f4[0x100 - 0xf4];
-	uint32_t dramtmg0;	/* 0x100 SDRAM Timing 0 */
-	uint32_t dramtmg1;	/* 0x104 SDRAM Timing 1 */
-	uint32_t dramtmg2;	/* 0x108 SDRAM Timing 2 */
-	uint32_t dramtmg3;	/* 0x10c SDRAM Timing 3 */
-	uint32_t dramtmg4;	/* 0x110 SDRAM Timing 4 */
-	uint32_t dramtmg5;	/* 0x114 SDRAM Timing 5 */
-	uint32_t dramtmg6;	/* 0x118 SDRAM Timing 6 */
-	uint32_t dramtmg7;	/* 0x11c SDRAM Timing 7 */
-	uint32_t dramtmg8;	/* 0x120 SDRAM Timing 8 */
-	uint8_t reserved124[0x138 - 0x124];
-	uint32_t dramtmg14;	/* 0x138 SDRAM Timing 14 */
-	uint32_t dramtmg15;	/* 0x13C SDRAM Timing 15 */
-	uint8_t reserved140[0x180 - 0x140];
-	uint32_t zqctl0;	/* 0x180 ZQ Control 0 */
-	uint32_t zqctl1;	/* 0x184 ZQ Control 1 */
-	uint32_t zqctl2;	/* 0x188 ZQ Control 2 */
-	uint32_t zqstat;	/* 0x18c ZQ Status */
-	uint32_t dfitmg0;	/* 0x190 DFI Timing 0 */
-	uint32_t dfitmg1;	/* 0x194 DFI Timing 1 */
-	uint32_t dfilpcfg0;	/* 0x198 DFI Low Power Configuration 0 */
-	uint32_t reserved19c;
-	uint32_t dfiupd0;	/* 0x1a0 DFI Update 0 */
-	uint32_t dfiupd1;	/* 0x1a4 DFI Update 1 */
-	uint32_t dfiupd2;	/* 0x1a8 DFI Update 2 */
-	uint32_t reserved1ac;
-	uint32_t dfimisc;	/* 0x1b0 DFI Miscellaneous Control */
-	uint8_t reserved1b4[0x1bc - 0x1b4];
-	uint32_t dfistat;	/* 0x1bc DFI Miscellaneous Control */
-	uint8_t reserved1c0[0x1c4 - 0x1c0];
-	uint32_t dfiphymstr;	/* 0x1c4 DFI PHY Master interface */
-	uint8_t reserved1c8[0x204 - 0x1c8];
-	uint32_t addrmap1;	/* 0x204 Address Map 1 */
-	uint32_t addrmap2;	/* 0x208 Address Map 2 */
-	uint32_t addrmap3;	/* 0x20c Address Map 3 */
-	uint32_t addrmap4;	/* 0x210 Address Map 4 */
-	uint32_t addrmap5;	/* 0x214 Address Map 5 */
-	uint32_t addrmap6;	/* 0x218 Address Map 6 */
-	uint8_t reserved21c[0x224 - 0x21c];
-	uint32_t addrmap9;	/* 0x224 Address Map 9 */
-	uint32_t addrmap10;	/* 0x228 Address Map 10 */
-	uint32_t addrmap11;	/* 0x22C Address Map 11 */
-	uint8_t reserved230[0x240 - 0x230];
-	uint32_t odtcfg;	/* 0x240 ODT Configuration */
-	uint32_t odtmap;	/* 0x244 ODT/Rank Map */
-	uint8_t reserved248[0x250 - 0x248];
-	uint32_t sched;		/* 0x250 Scheduler Control */
-	uint32_t sched1;	/* 0x254 Scheduler Control 1 */
-	uint32_t reserved258;
-	uint32_t perfhpr1;	/* 0x25c High Priority Read CAM 1 */
-	uint32_t reserved260;
-	uint32_t perflpr1;	/* 0x264 Low Priority Read CAM 1 */
-	uint32_t reserved268;
-	uint32_t perfwr1;	/* 0x26c Write CAM 1 */
-	uint8_t reserved27c[0x300 - 0x270];
-	uint32_t dbg0;		/* 0x300 Debug 0 */
-	uint32_t dbg1;		/* 0x304 Debug 1 */
-	uint32_t dbgcam;	/* 0x308 CAM Debug */
-	uint32_t dbgcmd;	/* 0x30c Command Debug */
-	uint32_t dbgstat;	/* 0x310 Status Debug */
-	uint8_t reserved314[0x320 - 0x314];
-	uint32_t swctl;		/* 0x320 Software Programming Control Enable */
-	uint32_t swstat;	/* 0x324 Software Programming Control Status */
-	uint8_t reserved328[0x36c - 0x328];
-	uint32_t poisoncfg;	/* 0x36c AXI Poison Configuration Register */
-	uint32_t poisonstat;	/* 0x370 AXI Poison Status Register */
-	uint8_t reserved374[0x3fc - 0x374];
-
-	/* Multi Port registers */
-	uint32_t pstat;		/* 0x3fc Port Status */
-	uint32_t pccfg;		/* 0x400 Port Common Configuration */
-
-	/* PORT 0 */
-	uint32_t pcfgr_0;	/* 0x404 Configuration Read */
-	uint32_t pcfgw_0;	/* 0x408 Configuration Write */
-	uint8_t reserved40c[0x490 - 0x40c];
-	uint32_t pctrl_0;	/* 0x490 Port Control Register */
-	uint32_t pcfgqos0_0;	/* 0x494 Read QoS Configuration 0 */
-	uint32_t pcfgqos1_0;	/* 0x498 Read QoS Configuration 1 */
-	uint32_t pcfgwqos0_0;	/* 0x49c Write QoS Configuration 0 */
-	uint32_t pcfgwqos1_0;	/* 0x4a0 Write QoS Configuration 1 */
-	uint8_t reserved4a4[0x4b4 - 0x4a4];
-
-	/* PORT 1 */
-	uint32_t pcfgr_1;	/* 0x4b4 Configuration Read */
-	uint32_t pcfgw_1;	/* 0x4b8 Configuration Write */
-	uint8_t reserved4bc[0x540 - 0x4bc];
-	uint32_t pctrl_1;	/* 0x540 Port 2 Control Register */
-	uint32_t pcfgqos0_1;	/* 0x544 Read QoS Configuration 0 */
-	uint32_t pcfgqos1_1;	/* 0x548 Read QoS Configuration 1 */
-	uint32_t pcfgwqos0_1;	/* 0x54c Write QoS Configuration 0 */
-	uint32_t pcfgwqos1_1;	/* 0x550 Write QoS Configuration 1 */
-} __packed;
-
 /* DDR Physical Interface Control (DDRPHYC) registers*/
-struct stm32mp1_ddrphy {
+struct stm32mp_ddrphy {
 	uint32_t ridr;		/* 0x00 R Revision Identification */
 	uint32_t pir;		/* 0x04 R/W PHY Initialization */
 	uint32_t pgcr;		/* 0x08 R/W PHY General Configuration */
@@ -214,6 +85,7 @@ struct stm32mp1_ddrphy {
 	uint32_t dx1dqtr;	/* 0x210 Byte lane 1 DQ Timing */
 	uint32_t dx1dqstr;	/* 0x214 Byte lane 1 QS Timing */
 	uint8_t res6[0x240 - 0x218];	/* 0x218 */
+#if STM32MP_DDR_32BIT_INTERFACE
 	uint32_t dx2gcr;	/* 0x240 Byte lane 2 General Configuration */
 	uint32_t dx2gsr0;	/* 0x244 Byte lane 2 General Status 0 */
 	uint32_t dx2gsr1;	/* 0x248 Byte lane 2 General Status 1 */
@@ -227,103 +99,9 @@ struct stm32mp1_ddrphy {
 	uint32_t dx3dllcr;	/* 0x28c Byte lane 3 DLL Control */
 	uint32_t dx3dqtr;	/* 0x290 Byte lane 3 DQ Timing */
 	uint32_t dx3dqstr;	/* 0x294 Byte lane 3 QS Timing */
+#endif
 } __packed;
 
-/* DDR Controller registers offsets */
-#define DDRCTRL_MSTR				0x000
-#define DDRCTRL_STAT				0x004
-#define DDRCTRL_MRCTRL0				0x010
-#define DDRCTRL_MRSTAT				0x018
-#define DDRCTRL_PWRCTL				0x030
-#define DDRCTRL_PWRTMG				0x034
-#define DDRCTRL_HWLPCTL				0x038
-#define DDRCTRL_RFSHCTL3			0x060
-#define DDRCTRL_RFSHTMG				0x064
-#define DDRCTRL_INIT0				0x0D0
-#define DDRCTRL_DFIMISC				0x1B0
-#define DDRCTRL_DBG1				0x304
-#define DDRCTRL_DBGCAM				0x308
-#define DDRCTRL_DBGCMD				0x30C
-#define DDRCTRL_DBGSTAT				0x310
-#define DDRCTRL_SWCTL				0x320
-#define DDRCTRL_SWSTAT				0x324
-#define DDRCTRL_PSTAT				0x3FC
-#define DDRCTRL_PCTRL_0				0x490
-#define DDRCTRL_PCTRL_1				0x540
-
-/* DDR Controller Register fields */
-#define DDRCTRL_MSTR_DDR3			BIT(0)
-#define DDRCTRL_MSTR_LPDDR2			BIT(2)
-#define DDRCTRL_MSTR_LPDDR3			BIT(3)
-#define DDRCTRL_MSTR_DATA_BUS_WIDTH_MASK	GENMASK(13, 12)
-#define DDRCTRL_MSTR_DATA_BUS_WIDTH_FULL	0
-#define DDRCTRL_MSTR_DATA_BUS_WIDTH_HALF	BIT(12)
-#define DDRCTRL_MSTR_DATA_BUS_WIDTH_QUARTER	BIT(13)
-#define DDRCTRL_MSTR_DLL_OFF_MODE		BIT(15)
-
-#define DDRCTRL_STAT_OPERATING_MODE_MASK	GENMASK(2, 0)
-#define DDRCTRL_STAT_OPERATING_MODE_NORMAL	BIT(0)
-#define DDRCTRL_STAT_OPERATING_MODE_SR		(BIT(0) | BIT(1))
-#define DDRCTRL_STAT_SELFREF_TYPE_MASK		GENMASK(5, 4)
-#define DDRCTRL_STAT_SELFREF_TYPE_ASR		(BIT(4) | BIT(5))
-#define DDRCTRL_STAT_SELFREF_TYPE_SR		BIT(5)
-
-#define DDRCTRL_MRCTRL0_MR_TYPE_WRITE		U(0)
-/* Only one rank supported */
-#define DDRCTRL_MRCTRL0_MR_RANK_SHIFT		4
-#define DDRCTRL_MRCTRL0_MR_RANK_ALL \
-					BIT(DDRCTRL_MRCTRL0_MR_RANK_SHIFT)
-#define DDRCTRL_MRCTRL0_MR_ADDR_SHIFT		12
-#define DDRCTRL_MRCTRL0_MR_ADDR_MASK		GENMASK(15, 12)
-#define DDRCTRL_MRCTRL0_MR_WR			BIT(31)
-
-#define DDRCTRL_MRSTAT_MR_WR_BUSY		BIT(0)
-
-#define DDRCTRL_PWRCTL_SELFREF_EN		BIT(0)
-#define DDRCTRL_PWRCTL_POWERDOWN_EN		BIT(1)
-#define DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE	BIT(3)
-#define DDRCTRL_PWRCTL_SELFREF_SW		BIT(5)
-
-#define DDRCTRL_PWRTMG_SELFREF_TO_X32_MASK	GENMASK(23, 16)
-#define DDRCTRL_PWRTMG_SELFREF_TO_X32_0		BIT(16)
-
-#define DDRCTRL_RFSHCTL3_DIS_AUTO_REFRESH	BIT(0)
-
-#define DDRCTRL_HWLPCTL_HW_LP_EN		BIT(0)
-
-#define DDRCTRL_RFSHTMG_T_RFC_NOM_X1_X32_MASK	GENMASK(27, 16)
-#define DDRCTRL_RFSHTMG_T_RFC_NOM_X1_X32_SHIFT	16
-
-#define DDRCTRL_INIT0_SKIP_DRAM_INIT_MASK	GENMASK(31, 30)
-#define DDRCTRL_INIT0_SKIP_DRAM_INIT_NORMAL	BIT(30)
-
-#define DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN	BIT(0)
-
-#define DDRCTRL_DBG1_DIS_HIF			BIT(1)
-
-#define DDRCTRL_DBGCAM_WR_DATA_PIPELINE_EMPTY	BIT(29)
-#define DDRCTRL_DBGCAM_RD_DATA_PIPELINE_EMPTY	BIT(28)
-#define DDRCTRL_DBGCAM_DBG_WR_Q_EMPTY		BIT(26)
-#define DDRCTRL_DBGCAM_DBG_LPR_Q_DEPTH		GENMASK(12, 8)
-#define DDRCTRL_DBGCAM_DBG_HPR_Q_DEPTH		GENMASK(4, 0)
-#define DDRCTRL_DBGCAM_DATA_PIPELINE_EMPTY \
-		(DDRCTRL_DBGCAM_WR_DATA_PIPELINE_EMPTY | \
-		 DDRCTRL_DBGCAM_RD_DATA_PIPELINE_EMPTY)
-#define DDRCTRL_DBGCAM_DBG_Q_DEPTH \
-		(DDRCTRL_DBGCAM_DBG_WR_Q_EMPTY | \
-		 DDRCTRL_DBGCAM_DBG_LPR_Q_DEPTH | \
-		 DDRCTRL_DBGCAM_DBG_HPR_Q_DEPTH)
-
-#define DDRCTRL_DBGCMD_RANK0_REFRESH		BIT(0)
-
-#define DDRCTRL_DBGSTAT_RANK0_REFRESH_BUSY	BIT(0)
-
-#define DDRCTRL_SWCTL_SW_DONE			BIT(0)
-
-#define DDRCTRL_SWSTAT_SW_DONE_ACK		BIT(0)
-
-#define DDRCTRL_PCTRL_N_PORT_EN			BIT(0)
-
 /* DDR PHY registers offsets */
 #define DDRPHYC_PIR				0x004
 #define DDRPHYC_PGCR				0x008
@@ -339,10 +117,12 @@ struct stm32mp1_ddrphy {
 #define DDRPHYC_DX0DLLCR			0x1CC
 #define DDRPHYC_DX1GCR				0x200
 #define DDRPHYC_DX1DLLCR			0x20C
+#if STM32MP_DDR_32BIT_INTERFACE
 #define DDRPHYC_DX2GCR				0x240
 #define DDRPHYC_DX2DLLCR			0x24C
 #define DDRPHYC_DX3GCR				0x280
 #define DDRPHYC_DX3DLLCR			0x28C
+#endif
 
 /* DDR PHY Register fields */
 #define DDRPHYC_PIR_INIT			BIT(0)
@@ -353,6 +133,7 @@ struct stm32mp1_ddrphy {
 #define DDRPHYC_PIR_DRAMRST			BIT(5)
 #define DDRPHYC_PIR_DRAMINIT			BIT(6)
 #define DDRPHYC_PIR_QSTRN			BIT(7)
+#define DDRPHYC_PIR_RVTRN			BIT(8)
 #define DDRPHYC_PIR_ICPC			BIT(16)
 #define DDRPHYC_PIR_ZCALBYP			BIT(30)
 #define DDRPHYC_PIR_INITSTEPS_MASK		GENMASK(31, 7)
@@ -380,6 +161,7 @@ struct stm32mp1_ddrphy {
 #define DDRPHYC_PTR0_TITMSRST_OFFSET		18
 #define DDRPHYC_PTR0_TITMSRST_MASK		GENMASK(21, 18)
 
+#define DDRPHYC_ACIOCR_ACOE			BIT(1)
 #define DDRPHYC_ACIOCR_ACPDD			BIT(3)
 #define DDRPHYC_ACIOCR_ACPDR			BIT(4)
 #define DDRPHYC_ACIOCR_CKPDD_MASK		GENMASK(10, 8)
@@ -399,6 +181,7 @@ struct stm32mp1_ddrphy {
 #define DDRPHYC_DSGCR_ODTPDD_MASK		GENMASK(23, 20)
 #define DDRPHYC_DSGCR_ODTPDD_0			BIT(20)
 #define DDRPHYC_DSGCR_NL2PD			BIT(24)
+#define DDRPHYC_DSGCR_CKOE			BIT(28)
 
 #define DDRPHYC_ZQ0CRN_ZDATA_MASK		GENMASK(27, 0)
 #define DDRPHYC_ZQ0CRN_ZDATA_SHIFT		0
diff --git a/include/drivers/st/stm32mp1_pwr.h b/include/drivers/st/stm32mp1_pwr.h
index e17df44fb..44a42b6b2 100644
--- a/include/drivers/st/stm32mp1_pwr.h
+++ b/include/drivers/st/stm32mp1_pwr.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2018, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2017-2019, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -13,20 +13,42 @@
 #define PWR_CR2			U(0x08)
 #define PWR_CR3			U(0x0C)
 #define PWR_MPUCR		U(0x10)
+#define PWR_MCUCR		U(0x14)
 #define PWR_WKUPCR		U(0x20)
 #define PWR_MPUWKUPENR		U(0x28)
 
+#define PWR_OFFSET_MASK		GENMASK(9, 0)
+
 #define PWR_CR1_LPDS		BIT(0)
 #define PWR_CR1_LPCFG		BIT(1)
 #define PWR_CR1_LVDS		BIT(2)
 #define PWR_CR1_DBP		BIT(8)
 
+#define PWR_CR2_BREN		BIT(0)
+#define PWR_CR2_RREN		BIT(1)
+#define PWR_CR2_BRRDY		BIT(16)
+#define PWR_CR2_RRRDY		BIT(17)
+
+#define PWR_CR3_VBE		BIT(8)
+#define PWR_CR3_VBRS		BIT(9)
 #define PWR_CR3_DDRSREN		BIT(10)
 #define PWR_CR3_DDRSRDIS	BIT(11)
 #define PWR_CR3_DDRRETEN	BIT(12)
+#define PWR_CR3_USB33DEN	BIT(24)
+#define PWR_CR3_REG18EN		BIT(28)
+#define PWR_CR3_REG11EN		BIT(30)
+
+#define PWR_CR3_POPL_SHIFT	17
+#define PWR_CR3_POPL_MASK	GENMASK_32(21, 17)
 
 #define PWR_MPUCR_PDDS		BIT(0)
 #define PWR_MPUCR_CSTDBYDIS	BIT(3)
 #define PWR_MPUCR_CSSF		BIT(9)
 
+#define PWR_MCUCR_PDDS		BIT(0)
+
+#define PWR_WKUPCR_MASK		GENMASK(27, 16) | GENMASK(13, 8) | GENMASK(5, 0)
+
+#define PWR_MPUWKUPENR_MASK	GENMASK(5, 0)
+
 #endif /* STM32MP1_PWR_H */
diff --git a/include/drivers/st/stm32mp1_ram.h b/include/drivers/st/stm32mp1_ram.h
index 38360e759..adecd409d 100644
--- a/include/drivers/st/stm32mp1_ram.h
+++ b/include/drivers/st/stm32mp1_ram.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2018, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2015-2020, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -7,6 +7,7 @@
 #ifndef STM32MP1_RAM_H
 #define STM32MP1_RAM_H
 
+bool stm32mp1_ddr_is_restored(void);
 int stm32mp1_ddr_probe(void);
 
 #endif /* STM32MP1_RAM_H */
diff --git a/include/drivers/st/stm32mp1_rcc.h b/include/drivers/st/stm32mp1_rcc.h
index 14f93fdce..39b343f49 100644
--- a/include/drivers/st/stm32mp1_rcc.h
+++ b/include/drivers/st/stm32mp1_rcc.h
@@ -4,2325 +4,9 @@
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
-#ifndef STM32MP1_RCC_H
-#define STM32MP1_RCC_H
-
-#include <lib/utils_def.h>
-
-#define RCC_TZCR				U(0x00)
-#define RCC_OCENSETR				U(0x0C)
-#define RCC_OCENCLRR				U(0x10)
-#define RCC_HSICFGR				U(0x18)
-#define RCC_CSICFGR				U(0x1C)
-#define RCC_MPCKSELR				U(0x20)
-#define RCC_ASSCKSELR				U(0x24)
-#define RCC_RCK12SELR				U(0x28)
-#define RCC_MPCKDIVR				U(0x2C)
-#define RCC_AXIDIVR				U(0x30)
-#define RCC_APB4DIVR				U(0x3C)
-#define RCC_APB5DIVR				U(0x40)
-#define RCC_RTCDIVR				U(0x44)
-#define RCC_MSSCKSELR				U(0x48)
-#define RCC_PLL1CR				U(0x80)
-#define RCC_PLL1CFGR1				U(0x84)
-#define RCC_PLL1CFGR2				U(0x88)
-#define RCC_PLL1FRACR				U(0x8C)
-#define RCC_PLL1CSGR				U(0x90)
-#define RCC_PLL2CR				U(0x94)
-#define RCC_PLL2CFGR1				U(0x98)
-#define RCC_PLL2CFGR2				U(0x9C)
-#define RCC_PLL2FRACR				U(0xA0)
-#define RCC_PLL2CSGR				U(0xA4)
-#define RCC_I2C46CKSELR				U(0xC0)
-#define RCC_SPI6CKSELR				U(0xC4)
-#define RCC_UART1CKSELR				U(0xC8)
-#define RCC_RNG1CKSELR				U(0xCC)
-#define RCC_CPERCKSELR				U(0xD0)
-#define RCC_STGENCKSELR				U(0xD4)
-#define RCC_DDRITFCR				U(0xD8)
-#define RCC_MP_BOOTCR				U(0x100)
-#define RCC_MP_SREQSETR				U(0x104)
-#define RCC_MP_SREQCLRR				U(0x108)
-#define RCC_MP_GCR				U(0x10C)
-#define RCC_MP_APRSTCR				U(0x110)
-#define RCC_MP_APRSTSR				U(0x114)
-#define RCC_BDCR				U(0x140)
-#define RCC_RDLSICR				U(0x144)
-#define RCC_APB4RSTSETR				U(0x180)
-#define RCC_APB4RSTCLRR				U(0x184)
-#define RCC_APB5RSTSETR				U(0x188)
-#define RCC_APB5RSTCLRR				U(0x18C)
-#define RCC_AHB5RSTSETR				U(0x190)
-#define RCC_AHB5RSTCLRR				U(0x194)
-#define RCC_AHB6RSTSETR				U(0x198)
-#define RCC_AHB6RSTCLRR				U(0x19C)
-#define RCC_TZAHB6RSTSETR			U(0x1A0)
-#define RCC_TZAHB6RSTCLRR			U(0x1A4)
-#define RCC_MP_APB4ENSETR			U(0x200)
-#define RCC_MP_APB4ENCLRR			U(0x204)
-#define RCC_MP_APB5ENSETR			U(0x208)
-#define RCC_MP_APB5ENCLRR			U(0x20C)
-#define RCC_MP_AHB5ENSETR			U(0x210)
-#define RCC_MP_AHB5ENCLRR			U(0x214)
-#define RCC_MP_AHB6ENSETR			U(0x218)
-#define RCC_MP_AHB6ENCLRR			U(0x21C)
-#define RCC_MP_TZAHB6ENSETR			U(0x220)
-#define RCC_MP_TZAHB6ENCLRR			U(0x224)
-#define RCC_MC_APB4ENSETR			U(0x280)
-#define RCC_MC_APB4ENCLRR			U(0x284)
-#define RCC_MC_APB5ENSETR			U(0x288)
-#define RCC_MC_APB5ENCLRR			U(0x28C)
-#define RCC_MC_AHB5ENSETR			U(0x290)
-#define RCC_MC_AHB5ENCLRR			U(0x294)
-#define RCC_MC_AHB6ENSETR			U(0x298)
-#define RCC_MC_AHB6ENCLRR			U(0x29C)
-#define RCC_MP_APB4LPENSETR			U(0x300)
-#define RCC_MP_APB4LPENCLRR			U(0x304)
-#define RCC_MP_APB5LPENSETR			U(0x308)
-#define RCC_MP_APB5LPENCLRR			U(0x30C)
-#define RCC_MP_AHB5LPENSETR			U(0x310)
-#define RCC_MP_AHB5LPENCLRR			U(0x314)
-#define RCC_MP_AHB6LPENSETR			U(0x318)
-#define RCC_MP_AHB6LPENCLRR			U(0x31C)
-#define RCC_MP_TZAHB6LPENSETR			U(0x320)
-#define RCC_MP_TZAHB6LPENCLRR			U(0x324)
-#define RCC_MC_APB4LPENSETR			U(0x380)
-#define RCC_MC_APB4LPENCLRR			U(0x384)
-#define RCC_MC_APB5LPENSETR			U(0x388)
-#define RCC_MC_APB5LPENCLRR			U(0x38C)
-#define RCC_MC_AHB5LPENSETR			U(0x390)
-#define RCC_MC_AHB5LPENCLRR			U(0x394)
-#define RCC_MC_AHB6LPENSETR			U(0x398)
-#define RCC_MC_AHB6LPENCLRR			U(0x39C)
-#define RCC_BR_RSTSCLRR				U(0x400)
-#define RCC_MP_GRSTCSETR			U(0x404)
-#define RCC_MP_RSTSCLRR				U(0x408)
-#define RCC_MP_IWDGFZSETR			U(0x40C)
-#define RCC_MP_IWDGFZCLRR			U(0x410)
-#define RCC_MP_CIER				U(0x414)
-#define RCC_MP_CIFR				U(0x418)
-#define RCC_PWRLPDLYCR				U(0x41C)
-#define RCC_MP_RSTSSETR				U(0x420)
-#define RCC_MCO1CFGR				U(0x800)
-#define RCC_MCO2CFGR				U(0x804)
-#define RCC_OCRDYR				U(0x808)
-#define RCC_DBGCFGR				U(0x80C)
-#define RCC_RCK3SELR				U(0x820)
-#define RCC_RCK4SELR				U(0x824)
-#define RCC_TIMG1PRER				U(0x828)
-#define RCC_TIMG2PRER				U(0x82C)
-#define RCC_MCUDIVR				U(0x830)
-#define RCC_APB1DIVR				U(0x834)
-#define RCC_APB2DIVR				U(0x838)
-#define RCC_APB3DIVR				U(0x83C)
-#define RCC_PLL3CR				U(0x880)
-#define RCC_PLL3CFGR1				U(0x884)
-#define RCC_PLL3CFGR2				U(0x888)
-#define RCC_PLL3FRACR				U(0x88C)
-#define RCC_PLL3CSGR				U(0x890)
-#define RCC_PLL4CR				U(0x894)
-#define RCC_PLL4CFGR1				U(0x898)
-#define RCC_PLL4CFGR2				U(0x89C)
-#define RCC_PLL4FRACR				U(0x8A0)
-#define RCC_PLL4CSGR				U(0x8A4)
-#define RCC_I2C12CKSELR				U(0x8C0)
-#define RCC_I2C35CKSELR				U(0x8C4)
-#define RCC_SAI1CKSELR				U(0x8C8)
-#define RCC_SAI2CKSELR				U(0x8CC)
-#define RCC_SAI3CKSELR				U(0x8D0)
-#define RCC_SAI4CKSELR				U(0x8D4)
-#define RCC_SPI2S1CKSELR			U(0x8D8)
-#define RCC_SPI2S23CKSELR			U(0x8DC)
-#define RCC_SPI45CKSELR				U(0x8E0)
-#define RCC_UART6CKSELR				U(0x8E4)
-#define RCC_UART24CKSELR			U(0x8E8)
-#define RCC_UART35CKSELR			U(0x8EC)
-#define RCC_UART78CKSELR			U(0x8F0)
-#define RCC_SDMMC12CKSELR			U(0x8F4)
-#define RCC_SDMMC3CKSELR			U(0x8F8)
-#define RCC_ETHCKSELR				U(0x8FC)
-#define RCC_QSPICKSELR				U(0x900)
-#define RCC_FMCCKSELR				U(0x904)
-#define RCC_FDCANCKSELR				U(0x90C)
-#define RCC_SPDIFCKSELR				U(0x914)
-#define RCC_CECCKSELR				U(0x918)
-#define RCC_USBCKSELR				U(0x91C)
-#define RCC_RNG2CKSELR				U(0x920)
-#define RCC_DSICKSELR				U(0x924)
-#define RCC_ADCCKSELR				U(0x928)
-#define RCC_LPTIM45CKSELR			U(0x92C)
-#define RCC_LPTIM23CKSELR			U(0x930)
-#define RCC_LPTIM1CKSELR			U(0x934)
-#define RCC_APB1RSTSETR				U(0x980)
-#define RCC_APB1RSTCLRR				U(0x984)
-#define RCC_APB2RSTSETR				U(0x988)
-#define RCC_APB2RSTCLRR				U(0x98C)
-#define RCC_APB3RSTSETR				U(0x990)
-#define RCC_APB3RSTCLRR				U(0x994)
-#define RCC_AHB2RSTSETR				U(0x998)
-#define RCC_AHB2RSTCLRR				U(0x99C)
-#define RCC_AHB3RSTSETR				U(0x9A0)
-#define RCC_AHB3RSTCLRR				U(0x9A4)
-#define RCC_AHB4RSTSETR				U(0x9A8)
-#define RCC_AHB4RSTCLRR				U(0x9AC)
-#define RCC_MP_APB1ENSETR			U(0xA00)
-#define RCC_MP_APB1ENCLRR			U(0xA04)
-#define RCC_MP_APB2ENSETR			U(0xA08)
-#define RCC_MP_APB2ENCLRR			U(0xA0C)
-#define RCC_MP_APB3ENSETR			U(0xA10)
-#define RCC_MP_APB3ENCLRR			U(0xA14)
-#define RCC_MP_AHB2ENSETR			U(0xA18)
-#define RCC_MP_AHB2ENCLRR			U(0xA1C)
-#define RCC_MP_AHB3ENSETR			U(0xA20)
-#define RCC_MP_AHB3ENCLRR			U(0xA24)
-#define RCC_MP_AHB4ENSETR			U(0xA28)
-#define RCC_MP_AHB4ENCLRR			U(0xA2C)
-#define RCC_MP_MLAHBENSETR			U(0xA38)
-#define RCC_MP_MLAHBENCLRR			U(0xA3C)
-#define RCC_MC_APB1ENSETR			U(0xA80)
-#define RCC_MC_APB1ENCLRR			U(0xA84)
-#define RCC_MC_APB2ENSETR			U(0xA88)
-#define RCC_MC_APB2ENCLRR			U(0xA8C)
-#define RCC_MC_APB3ENSETR			U(0xA90)
-#define RCC_MC_APB3ENCLRR			U(0xA94)
-#define RCC_MC_AHB2ENSETR			U(0xA98)
-#define RCC_MC_AHB2ENCLRR			U(0xA9C)
-#define RCC_MC_AHB3ENSETR			U(0xAA0)
-#define RCC_MC_AHB3ENCLRR			U(0xAA4)
-#define RCC_MC_AHB4ENSETR			U(0xAA8)
-#define RCC_MC_AHB4ENCLRR			U(0xAAC)
-#define RCC_MC_AXIMENSETR			U(0xAB0)
-#define RCC_MC_AXIMENCLRR			U(0xAB4)
-#define RCC_MC_MLAHBENSETR			U(0xAB8)
-#define RCC_MC_MLAHBENCLRR			U(0xABC)
-#define RCC_MP_APB1LPENSETR			U(0xB00)
-#define RCC_MP_APB1LPENCLRR			U(0xB04)
-#define RCC_MP_APB2LPENSETR			U(0xB08)
-#define RCC_MP_APB2LPENCLRR			U(0xB0C)
-#define RCC_MP_APB3LPENSETR			U(0xB10)
-#define RCC_MP_APB3LPENCLRR			U(0xB14)
-#define RCC_MP_AHB2LPENSETR			U(0xB18)
-#define RCC_MP_AHB2LPENCLRR			U(0xB1C)
-#define RCC_MP_AHB3LPENSETR			U(0xB20)
-#define RCC_MP_AHB3LPENCLRR			U(0xB24)
-#define RCC_MP_AHB4LPENSETR			U(0xB28)
-#define RCC_MP_AHB4LPENCLRR			U(0xB2C)
-#define RCC_MP_AXIMLPENSETR			U(0xB30)
-#define RCC_MP_AXIMLPENCLRR			U(0xB34)
-#define RCC_MP_MLAHBLPENSETR			U(0xB38)
-#define RCC_MP_MLAHBLPENCLRR			U(0xB3C)
-#define RCC_MC_APB1LPENSETR			U(0xB80)
-#define RCC_MC_APB1LPENCLRR			U(0xB84)
-#define RCC_MC_APB2LPENSETR			U(0xB88)
-#define RCC_MC_APB2LPENCLRR			U(0xB8C)
-#define RCC_MC_APB3LPENSETR			U(0xB90)
-#define RCC_MC_APB3LPENCLRR			U(0xB94)
-#define RCC_MC_AHB2LPENSETR			U(0xB98)
-#define RCC_MC_AHB2LPENCLRR			U(0xB9C)
-#define RCC_MC_AHB3LPENSETR			U(0xBA0)
-#define RCC_MC_AHB3LPENCLRR			U(0xBA4)
-#define RCC_MC_AHB4LPENSETR			U(0xBA8)
-#define RCC_MC_AHB4LPENCLRR			U(0xBAC)
-#define RCC_MC_AXIMLPENSETR			U(0xBB0)
-#define RCC_MC_AXIMLPENCLRR			U(0xBB4)
-#define RCC_MC_MLAHBLPENSETR			U(0xBB8)
-#define RCC_MC_MLAHBLPENCLRR			U(0xBBC)
-#define RCC_MC_RSTSCLRR				U(0xC00)
-#define RCC_MC_CIER				U(0xC14)
-#define RCC_MC_CIFR				U(0xC18)
-#define RCC_VERR				U(0xFF4)
-#define RCC_IDR					U(0xFF8)
-#define RCC_SIDR				U(0xFFC)
-
-/* RCC_TZCR register fields */
-#define RCC_TZCR_TZEN				BIT(0)
-#define RCC_TZCR_MCKPROT			BIT(1)
-
-/* RCC_OCENSETR register fields */
-#define RCC_OCENSETR_HSION			BIT(0)
-#define RCC_OCENSETR_HSIKERON			BIT(1)
-#define RCC_OCENSETR_CSION			BIT(4)
-#define RCC_OCENSETR_CSIKERON			BIT(5)
-#define RCC_OCENSETR_DIGBYP			BIT(7)
-#define RCC_OCENSETR_HSEON			BIT(8)
-#define RCC_OCENSETR_HSEKERON			BIT(9)
-#define RCC_OCENSETR_HSEBYP			BIT(10)
-#define RCC_OCENSETR_HSECSSON			BIT(11)
-
-/* RCC_OCENCLRR register fields */
-#define RCC_OCENCLRR_HSION			BIT(0)
-#define RCC_OCENCLRR_HSIKERON			BIT(1)
-#define RCC_OCENCLRR_CSION			BIT(4)
-#define RCC_OCENCLRR_CSIKERON			BIT(5)
-#define RCC_OCENCLRR_DIGBYP			BIT(7)
-#define RCC_OCENCLRR_HSEON			BIT(8)
-#define RCC_OCENCLRR_HSEKERON			BIT(9)
-#define RCC_OCENCLRR_HSEBYP			BIT(10)
-
-/* RCC_HSICFGR register fields */
-#define RCC_HSICFGR_HSIDIV_MASK			GENMASK(1, 0)
-#define RCC_HSICFGR_HSIDIV_SHIFT		0
-#define RCC_HSICFGR_HSITRIM_MASK		GENMASK(14, 8)
-#define RCC_HSICFGR_HSITRIM_SHIFT		8
-#define RCC_HSICFGR_HSICAL_MASK			GENMASK(24, 16)
-#define RCC_HSICFGR_HSICAL_SHIFT		16
-#define RCC_HSICFGR_HSICAL_TEMP_MASK		GENMASK(27, 25)
-
-/* RCC_CSICFGR register fields */
-#define RCC_CSICFGR_CSITRIM_MASK		GENMASK(12, 8)
-#define RCC_CSICFGR_CSITRIM_SHIFT		8
-#define RCC_CSICFGR_CSICAL_MASK			GENMASK(23, 16)
-#define RCC_CSICFGR_CSICAL_SHIFT		16
-
-/* RCC_MPCKSELR register fields */
-#define RCC_MPCKSELR_HSI			0x00000000
-#define RCC_MPCKSELR_HSE			0x00000001
-#define RCC_MPCKSELR_PLL			0x00000002
-#define RCC_MPCKSELR_PLL_MPUDIV			0x00000003
-#define RCC_MPCKSELR_MPUSRC_MASK		GENMASK(1, 0)
-#define RCC_MPCKSELR_MPUSRC_SHIFT		0
-#define RCC_MPCKSELR_MPUSRCRDY			BIT(31)
-
-/* RCC_ASSCKSELR register fields */
-#define RCC_ASSCKSELR_HSI			0x00000000
-#define RCC_ASSCKSELR_HSE			0x00000001
-#define RCC_ASSCKSELR_PLL			0x00000002
-#define RCC_ASSCKSELR_AXISSRC_MASK		GENMASK(2, 0)
-#define RCC_ASSCKSELR_AXISSRC_SHIFT		0
-#define RCC_ASSCKSELR_AXISSRCRDY		BIT(31)
-
-/* RCC_RCK12SELR register fields */
-#define RCC_RCK12SELR_PLL12SRC_MASK		GENMASK(1, 0)
-#define RCC_RCK12SELR_PLL12SRC_SHIFT		0
-#define RCC_RCK12SELR_PLL12SRCRDY		BIT(31)
-
-/* RCC_MPCKDIVR register fields */
-#define RCC_MPCKDIVR_MPUDIV_MASK		GENMASK(2, 0)
-#define RCC_MPCKDIVR_MPUDIV_SHIFT		0
-#define RCC_MPCKDIVR_MPUDIVRDY			BIT(31)
-
-/* RCC_AXIDIVR register fields */
-#define RCC_AXIDIVR_AXIDIV_MASK			GENMASK(2, 0)
-#define RCC_AXIDIVR_AXIDIV_SHIFT		0
-#define RCC_AXIDIVR_AXIDIVRDY			BIT(31)
-
-/* RCC_APB4DIVR register fields */
-#define RCC_APB4DIVR_APB4DIV_MASK		GENMASK(2, 0)
-#define RCC_APB4DIVR_APB4DIV_SHIFT		0
-#define RCC_APB4DIVR_APB4DIVRDY			BIT(31)
-
-/* RCC_APB5DIVR register fields */
-#define RCC_APB5DIVR_APB5DIV_MASK		GENMASK(2, 0)
-#define RCC_APB5DIVR_APB5DIV_SHIFT		0
-#define RCC_APB5DIVR_APB5DIVRDY			BIT(31)
-
-/* RCC_RTCDIVR register fields */
-#define RCC_RTCDIVR_RTCDIV_MASK			GENMASK(5, 0)
-#define RCC_RTCDIVR_RTCDIV_SHIFT		0
-
-/* RCC_MSSCKSELR register fields */
-#define RCC_MSSCKSELR_HSI			0x00000000
-#define RCC_MSSCKSELR_HSE			0x00000001
-#define RCC_MSSCKSELR_CSI			0x00000002
-#define RCC_MSSCKSELR_PLL			0x00000003
-#define RCC_MSSCKSELR_MCUSSRC_MASK		GENMASK(1, 0)
-#define RCC_MSSCKSELR_MCUSSRC_SHIFT		0
-#define RCC_MSSCKSELR_MCUSSRCRDY		BIT(31)
-
-/* RCC_PLL1CR register fields */
-#define RCC_PLL1CR_PLLON			BIT(0)
-#define RCC_PLL1CR_PLL1RDY			BIT(1)
-#define RCC_PLL1CR_SSCG_CTRL			BIT(2)
-#define RCC_PLL1CR_DIVPEN			BIT(4)
-#define RCC_PLL1CR_DIVQEN			BIT(5)
-#define RCC_PLL1CR_DIVREN			BIT(6)
-
-/* RCC_PLL1CFGR1 register fields */
-#define RCC_PLL1CFGR1_DIVN_MASK			GENMASK(8, 0)
-#define RCC_PLL1CFGR1_DIVN_SHIFT		0
-#define RCC_PLL1CFGR1_DIVM1_MASK		GENMASK(21, 16)
-#define RCC_PLL1CFGR1_DIVM1_SHIFT		16
-
-/* RCC_PLL1CFGR2 register fields */
-#define RCC_PLL1CFGR2_DIVP_MASK			GENMASK(6, 0)
-#define RCC_PLL1CFGR2_DIVP_SHIFT		0
-#define RCC_PLL1CFGR2_DIVQ_MASK			GENMASK(14, 8)
-#define RCC_PLL1CFGR2_DIVQ_SHIFT		8
-#define RCC_PLL1CFGR2_DIVR_MASK			GENMASK(22, 16)
-#define RCC_PLL1CFGR2_DIVR_SHIFT		16
-
-/* RCC_PLL1FRACR register fields */
-#define RCC_PLL1FRACR_FRACV_MASK		GENMASK(15, 3)
-#define RCC_PLL1FRACR_FRACV_SHIFT		3
-#define RCC_PLL1FRACR_FRACLE			BIT(16)
-
-/* RCC_PLL1CSGR register fields */
-#define RCC_PLL1CSGR_MOD_PER_MASK		GENMASK(12, 0)
-#define RCC_PLL1CSGR_MOD_PER_SHIFT		0
-#define RCC_PLL1CSGR_TPDFN_DIS			BIT(13)
-#define RCC_PLL1CSGR_RPDFN_DIS			BIT(14)
-#define RCC_PLL1CSGR_SSCG_MODE			BIT(15)
-#define RCC_PLL1CSGR_INC_STEP_MASK		GENMASK(30, 16)
-#define RCC_PLL1CSGR_INC_STEP_SHIFT		16
-
-/* RCC_PLL2CR register fields */
-#define RCC_PLL2CR_PLLON			BIT(0)
-#define RCC_PLL2CR_PLL2RDY			BIT(1)
-#define RCC_PLL2CR_SSCG_CTRL			BIT(2)
-#define RCC_PLL2CR_DIVPEN			BIT(4)
-#define RCC_PLL2CR_DIVQEN			BIT(5)
-#define RCC_PLL2CR_DIVREN			BIT(6)
-
-/* RCC_PLL2CFGR1 register fields */
-#define RCC_PLL2CFGR1_DIVN_MASK			GENMASK(8, 0)
-#define RCC_PLL2CFGR1_DIVN_SHIFT		0
-#define RCC_PLL2CFGR1_DIVM2_MASK		GENMASK(21, 16)
-#define RCC_PLL2CFGR1_DIVM2_SHIFT		16
-
-/* RCC_PLL2CFGR2 register fields */
-#define RCC_PLL2CFGR2_DIVP_MASK			GENMASK(6, 0)
-#define RCC_PLL2CFGR2_DIVP_SHIFT		0
-#define RCC_PLL2CFGR2_DIVQ_MASK			GENMASK(14, 8)
-#define RCC_PLL2CFGR2_DIVQ_SHIFT		8
-#define RCC_PLL2CFGR2_DIVR_MASK			GENMASK(22, 16)
-#define RCC_PLL2CFGR2_DIVR_SHIFT		16
-
-/* RCC_PLL2FRACR register fields */
-#define RCC_PLL2FRACR_FRACV_MASK		GENMASK(15, 3)
-#define RCC_PLL2FRACR_FRACV_SHIFT		3
-#define RCC_PLL2FRACR_FRACLE			BIT(16)
-
-/* RCC_PLL2CSGR register fields */
-#define RCC_PLL2CSGR_MOD_PER_MASK		GENMASK(12, 0)
-#define RCC_PLL2CSGR_MOD_PER_SHIFT		0
-#define RCC_PLL2CSGR_TPDFN_DIS			BIT(13)
-#define RCC_PLL2CSGR_RPDFN_DIS			BIT(14)
-#define RCC_PLL2CSGR_SSCG_MODE			BIT(15)
-#define RCC_PLL2CSGR_INC_STEP_MASK		GENMASK(30, 16)
-#define RCC_PLL2CSGR_INC_STEP_SHIFT		16
-
-/* RCC_I2C46CKSELR register fields */
-#define RCC_I2C46CKSELR_I2C46SRC_MASK		GENMASK(2, 0)
-#define RCC_I2C46CKSELR_I2C46SRC_SHIFT		0
-
-/* RCC_SPI6CKSELR register fields */
-#define RCC_SPI6CKSELR_SPI6SRC_MASK		GENMASK(2, 0)
-#define RCC_SPI6CKSELR_SPI6SRC_SHIFT		0
-
-/* RCC_UART1CKSELR register fields */
-#define RCC_UART1CKSELR_UART1SRC_MASK		GENMASK(2, 0)
-#define RCC_UART1CKSELR_UART1SRC_SHIFT		0
-
-/* RCC_RNG1CKSELR register fields */
-#define RCC_RNG1CKSELR_RNG1SRC_MASK		GENMASK(1, 0)
-#define RCC_RNG1CKSELR_RNG1SRC_SHIFT		0
-
-/* RCC_CPERCKSELR register fields */
-#define RCC_CPERCKSELR_HSI			0x00000000
-#define RCC_CPERCKSELR_CSI			0x00000001
-#define RCC_CPERCKSELR_HSE			0x00000002
-#define RCC_CPERCKSELR_CKPERSRC_MASK		GENMASK(1, 0)
-#define RCC_CPERCKSELR_CKPERSRC_SHIFT		0
-
-/* RCC_STGENCKSELR register fields */
-#define RCC_STGENCKSELR_STGENSRC_MASK		GENMASK(1, 0)
-#define RCC_STGENCKSELR_STGENSRC_SHIFT		0
-
-/* RCC_DDRITFCR register fields */
-#define RCC_DDRITFCR_DDRC1EN			BIT(0)
-#define RCC_DDRITFCR_DDRC1LPEN			BIT(1)
-#define RCC_DDRITFCR_DDRC2EN			BIT(2)
-#define RCC_DDRITFCR_DDRC2LPEN			BIT(3)
-#define RCC_DDRITFCR_DDRPHYCEN			BIT(4)
-#define RCC_DDRITFCR_DDRPHYCLPEN		BIT(5)
-#define RCC_DDRITFCR_DDRCAPBEN			BIT(6)
-#define RCC_DDRITFCR_DDRCAPBLPEN		BIT(7)
-#define RCC_DDRITFCR_AXIDCGEN			BIT(8)
-#define RCC_DDRITFCR_DDRPHYCAPBEN		BIT(9)
-#define RCC_DDRITFCR_DDRPHYCAPBLPEN		BIT(10)
-#define RCC_DDRITFCR_KERDCG_DLY_MASK		GENMASK(13, 11)
-#define RCC_DDRITFCR_KERDCG_DLY_SHIFT		11
-#define RCC_DDRITFCR_DDRCAPBRST			BIT(14)
-#define RCC_DDRITFCR_DDRCAXIRST			BIT(15)
-#define RCC_DDRITFCR_DDRCORERST			BIT(16)
-#define RCC_DDRITFCR_DPHYAPBRST			BIT(17)
-#define RCC_DDRITFCR_DPHYRST			BIT(18)
-#define RCC_DDRITFCR_DPHYCTLRST			BIT(19)
-#define RCC_DDRITFCR_DDRCKMOD_MASK		GENMASK(22, 20)
-#define RCC_DDRITFCR_DDRCKMOD_SHIFT		20
-#define RCC_DDRITFCR_DDRCKMOD_SSR		0
-#define RCC_DDRITFCR_DDRCKMOD_ASR1		BIT(20)
-#define RCC_DDRITFCR_DDRCKMOD_HSR1		BIT(21)
-#define RCC_DDRITFCR_GSKPMOD			BIT(23)
-#define RCC_DDRITFCR_GSKPCTRL			BIT(24)
-#define RCC_DDRITFCR_DFILP_WIDTH_MASK		GENMASK(27, 25)
-#define RCC_DDRITFCR_DFILP_WIDTH_SHIFT		25
-#define RCC_DDRITFCR_GSKP_DUR_MASK		GENMASK(31, 28)
-#define RCC_DDRITFCR_GSKP_DUR_SHIFT		28
-
-/* RCC_MP_BOOTCR register fields */
-#define RCC_MP_BOOTCR_MCU_BEN			BIT(0)
-#define RCC_MP_BOOTCR_MPU_BEN			BIT(1)
-
-/* RCC_MP_SREQSETR register fields */
-#define RCC_MP_SREQSETR_STPREQ_P0		BIT(0)
-#define RCC_MP_SREQSETR_STPREQ_P1		BIT(1)
-
-/* RCC_MP_SREQCLRR register fields */
-#define RCC_MP_SREQCLRR_STPREQ_P0		BIT(0)
-#define RCC_MP_SREQCLRR_STPREQ_P1		BIT(1)
-
-/* RCC_MP_GCR register fields */
-#define RCC_MP_GCR_BOOT_MCU			BIT(0)
-
-/* RCC_MP_APRSTCR register fields */
-#define RCC_MP_APRSTCR_RDCTLEN			BIT(0)
-#define RCC_MP_APRSTCR_RSTTO_MASK		GENMASK(14, 8)
-#define RCC_MP_APRSTCR_RSTTO_SHIFT		8
-
-/* RCC_MP_APRSTSR register fields */
-#define RCC_MP_APRSTSR_RSTTOV_MASK		GENMASK(14, 8)
-#define RCC_MP_APRSTSR_RSTTOV_SHIFT		8
-
-/* RCC_BDCR register fields */
-#define RCC_BDCR_LSEON				BIT(0)
-#define RCC_BDCR_LSEBYP				BIT(1)
-#define RCC_BDCR_LSERDY				BIT(2)
-#define RCC_BDCR_DIGBYP				BIT(3)
-#define RCC_BDCR_LSEDRV_MASK			GENMASK(5, 4)
-#define RCC_BDCR_LSEDRV_SHIFT			4
-#define RCC_BDCR_LSECSSON			BIT(8)
-#define RCC_BDCR_LSECSSD			BIT(9)
-#define RCC_BDCR_RTCSRC_MASK			GENMASK(17, 16)
-#define RCC_BDCR_RTCSRC_SHIFT			16
-#define RCC_BDCR_RTCCKEN			BIT(20)
-#define RCC_BDCR_VSWRST				BIT(31)
-
-/* RCC_RDLSICR register fields */
-#define RCC_RDLSICR_LSION			BIT(0)
-#define RCC_RDLSICR_LSIRDY			BIT(1)
-#define RCC_RDLSICR_MRD_MASK			GENMASK(20, 16)
-#define RCC_RDLSICR_MRD_SHIFT			16
-#define RCC_RDLSICR_EADLY_MASK			GENMASK(26, 24)
-#define RCC_RDLSICR_EADLY_SHIFT			24
-#define RCC_RDLSICR_SPARE_MASK			GENMASK(31, 27)
-#define RCC_RDLSICR_SPARE_SHIFT			27
-
-/* RCC_APB4RSTSETR register fields */
-#define RCC_APB4RSTSETR_LTDCRST			BIT(0)
-#define RCC_APB4RSTSETR_DSIRST			BIT(4)
-#define RCC_APB4RSTSETR_DDRPERFMRST		BIT(8)
-#define RCC_APB4RSTSETR_USBPHYRST		BIT(16)
-
-/* RCC_APB4RSTCLRR register fields */
-#define RCC_APB4RSTCLRR_LTDCRST			BIT(0)
-#define RCC_APB4RSTCLRR_DSIRST			BIT(4)
-#define RCC_APB4RSTCLRR_DDRPERFMRST		BIT(8)
-#define RCC_APB4RSTCLRR_USBPHYRST		BIT(16)
-
-/* RCC_APB5RSTSETR register fields */
-#define RCC_APB5RSTSETR_SPI6RST			BIT(0)
-#define RCC_APB5RSTSETR_I2C4RST			BIT(2)
-#define RCC_APB5RSTSETR_I2C6RST			BIT(3)
-#define RCC_APB5RSTSETR_USART1RST		BIT(4)
-#define RCC_APB5RSTSETR_STGENRST		BIT(20)
-
-/* RCC_APB5RSTCLRR register fields */
-#define RCC_APB5RSTCLRR_SPI6RST			BIT(0)
-#define RCC_APB5RSTCLRR_I2C4RST			BIT(2)
-#define RCC_APB5RSTCLRR_I2C6RST			BIT(3)
-#define RCC_APB5RSTCLRR_USART1RST		BIT(4)
-#define RCC_APB5RSTCLRR_STGENRST		BIT(20)
-
-/* RCC_AHB5RSTSETR register fields */
-#define RCC_AHB5RSTSETR_GPIOZRST		BIT(0)
-#define RCC_AHB5RSTSETR_CRYP1RST		BIT(4)
-#define RCC_AHB5RSTSETR_HASH1RST		BIT(5)
-#define RCC_AHB5RSTSETR_RNG1RST			BIT(6)
-#define RCC_AHB5RSTSETR_AXIMCRST		BIT(16)
-
-/* RCC_AHB5RSTCLRR register fields */
-#define RCC_AHB5RSTCLRR_GPIOZRST		BIT(0)
-#define RCC_AHB5RSTCLRR_CRYP1RST		BIT(4)
-#define RCC_AHB5RSTCLRR_HASH1RST		BIT(5)
-#define RCC_AHB5RSTCLRR_RNG1RST			BIT(6)
-#define RCC_AHB5RSTCLRR_AXIMCRST		BIT(16)
-
-/* RCC_AHB6RSTSETR register fields */
-#define RCC_AHB6RSTSETR_GPURST			BIT(5)
-#define RCC_AHB6RSTSETR_ETHMACRST		BIT(10)
-#define RCC_AHB6RSTSETR_FMCRST			BIT(12)
-#define RCC_AHB6RSTSETR_QSPIRST			BIT(14)
-#define RCC_AHB6RSTSETR_SDMMC1RST		BIT(16)
-#define RCC_AHB6RSTSETR_SDMMC2RST		BIT(17)
-#define RCC_AHB6RSTSETR_CRC1RST			BIT(20)
-#define RCC_AHB6RSTSETR_USBHRST			BIT(24)
-
-/* RCC_AHB6RSTCLRR register fields */
-#define RCC_AHB6RSTCLRR_ETHMACRST		BIT(10)
-#define RCC_AHB6RSTCLRR_FMCRST			BIT(12)
-#define RCC_AHB6RSTCLRR_QSPIRST			BIT(14)
-#define RCC_AHB6RSTCLRR_SDMMC1RST		BIT(16)
-#define RCC_AHB6RSTCLRR_SDMMC2RST		BIT(17)
-#define RCC_AHB6RSTCLRR_CRC1RST			BIT(20)
-#define RCC_AHB6RSTCLRR_USBHRST			BIT(24)
-
-/* RCC_TZAHB6RSTSETR register fields */
-#define RCC_TZAHB6RSTSETR_MDMARST		BIT(0)
-
-/* RCC_TZAHB6RSTCLRR register fields */
-#define RCC_TZAHB6RSTCLRR_MDMARST		BIT(0)
-
-/* RCC_MP_APB4ENSETR register fields */
-#define RCC_MP_APB4ENSETR_LTDCEN		BIT(0)
-#define RCC_MP_APB4ENSETR_DSIEN			BIT(4)
-#define RCC_MP_APB4ENSETR_DDRPERFMEN		BIT(8)
-#define RCC_MP_APB4ENSETR_IWDG2APBEN		BIT(15)
-#define RCC_MP_APB4ENSETR_USBPHYEN		BIT(16)
-#define RCC_MP_APB4ENSETR_STGENROEN		BIT(20)
-
-/* RCC_MP_APB4ENCLRR register fields */
-#define RCC_MP_APB4ENCLRR_LTDCEN		BIT(0)
-#define RCC_MP_APB4ENCLRR_DSIEN			BIT(4)
-#define RCC_MP_APB4ENCLRR_DDRPERFMEN		BIT(8)
-#define RCC_MP_APB4ENCLRR_IWDG2APBEN		BIT(15)
-#define RCC_MP_APB4ENCLRR_USBPHYEN		BIT(16)
-#define RCC_MP_APB4ENCLRR_STGENROEN		BIT(20)
-
-/* RCC_MP_APB5ENSETR register fields */
-#define RCC_MP_APB5ENSETR_SPI6EN		BIT(0)
-#define RCC_MP_APB5ENSETR_I2C4EN		BIT(2)
-#define RCC_MP_APB5ENSETR_I2C6EN		BIT(3)
-#define RCC_MP_APB5ENSETR_USART1EN		BIT(4)
-#define RCC_MP_APB5ENSETR_RTCAPBEN		BIT(8)
-#define RCC_MP_APB5ENSETR_TZC1EN		BIT(11)
-#define RCC_MP_APB5ENSETR_TZC2EN		BIT(12)
-#define RCC_MP_APB5ENSETR_TZPCEN		BIT(13)
-#define RCC_MP_APB5ENSETR_IWDG1APBEN		BIT(15)
-#define RCC_MP_APB5ENSETR_BSECEN		BIT(16)
-#define RCC_MP_APB5ENSETR_STGENEN		BIT(20)
-
-/* RCC_MP_APB5ENCLRR register fields */
-#define RCC_MP_APB5ENCLRR_SPI6EN		BIT(0)
-#define RCC_MP_APB5ENCLRR_I2C4EN		BIT(2)
-#define RCC_MP_APB5ENCLRR_I2C6EN		BIT(3)
-#define RCC_MP_APB5ENCLRR_USART1EN		BIT(4)
-#define RCC_MP_APB5ENCLRR_RTCAPBEN		BIT(8)
-#define RCC_MP_APB5ENCLRR_TZC1EN		BIT(11)
-#define RCC_MP_APB5ENCLRR_TZC2EN		BIT(12)
-#define RCC_MP_APB5ENCLRR_TZPCEN		BIT(13)
-#define RCC_MP_APB5ENCLRR_IWDG1APBEN		BIT(15)
-#define RCC_MP_APB5ENCLRR_BSECEN		BIT(16)
-#define RCC_MP_APB5ENCLRR_STGENEN		BIT(20)
-
-/* RCC_MP_AHB5ENSETR register fields */
-#define RCC_MP_AHB5ENSETR_GPIOZEN		BIT(0)
-#define RCC_MP_AHB5ENSETR_CRYP1EN		BIT(4)
-#define RCC_MP_AHB5ENSETR_HASH1EN		BIT(5)
-#define RCC_MP_AHB5ENSETR_RNG1EN		BIT(6)
-#define RCC_MP_AHB5ENSETR_BKPSRAMEN		BIT(8)
-#define RCC_MP_AHB5ENSETR_AXIMCEN		BIT(16)
-
-/* RCC_MP_AHB5ENCLRR register fields */
-#define RCC_MP_AHB5ENCLRR_GPIOZEN		BIT(0)
-#define RCC_MP_AHB5ENCLRR_CRYP1EN		BIT(4)
-#define RCC_MP_AHB5ENCLRR_HASH1EN		BIT(5)
-#define RCC_MP_AHB5ENCLRR_RNG1EN		BIT(6)
-#define RCC_MP_AHB5ENCLRR_BKPSRAMEN		BIT(8)
-#define RCC_MP_AHB5ENCLRR_AXIMCEN		BIT(16)
-
-/* RCC_MP_AHB6ENSETR register fields */
-#define RCC_MP_AHB6ENSETR_MDMAEN		BIT(0)
-#define RCC_MP_AHB6ENSETR_GPUEN			BIT(5)
-#define RCC_MP_AHB6ENSETR_ETHCKEN		BIT(7)
-#define RCC_MP_AHB6ENSETR_ETHTXEN		BIT(8)
-#define RCC_MP_AHB6ENSETR_ETHRXEN		BIT(9)
-#define RCC_MP_AHB6ENSETR_ETHMACEN		BIT(10)
-#define RCC_MP_AHB6ENSETR_FMCEN			BIT(12)
-#define RCC_MP_AHB6ENSETR_QSPIEN		BIT(14)
-#define RCC_MP_AHB6ENSETR_SDMMC1EN		BIT(16)
-#define RCC_MP_AHB6ENSETR_SDMMC2EN		BIT(17)
-#define RCC_MP_AHB6ENSETR_CRC1EN		BIT(20)
-#define RCC_MP_AHB6ENSETR_USBHEN		BIT(24)
-
-/* RCC_MP_AHB6ENCLRR register fields */
-#define RCC_MP_AHB6ENCLRR_MDMAEN		BIT(0)
-#define RCC_MP_AHB6ENCLRR_GPUEN			BIT(5)
-#define RCC_MP_AHB6ENCLRR_ETHCKEN		BIT(7)
-#define RCC_MP_AHB6ENCLRR_ETHTXEN		BIT(8)
-#define RCC_MP_AHB6ENCLRR_ETHRXEN		BIT(9)
-#define RCC_MP_AHB6ENCLRR_ETHMACEN		BIT(10)
-#define RCC_MP_AHB6ENCLRR_FMCEN			BIT(12)
-#define RCC_MP_AHB6ENCLRR_QSPIEN		BIT(14)
-#define RCC_MP_AHB6ENCLRR_SDMMC1EN		BIT(16)
-#define RCC_MP_AHB6ENCLRR_SDMMC2EN		BIT(17)
-#define RCC_MP_AHB6ENCLRR_CRC1EN		BIT(20)
-#define RCC_MP_AHB6ENCLRR_USBHEN		BIT(24)
-
-/* RCC_MP_TZAHB6ENSETR register fields */
-#define RCC_MP_TZAHB6ENSETR_MDMAEN		BIT(0)
-
-/* RCC_MP_TZAHB6ENCLRR register fields */
-#define RCC_MP_TZAHB6ENCLRR_MDMAEN		BIT(0)
-
-/* RCC_MC_APB4ENSETR register fields */
-#define RCC_MC_APB4ENSETR_LTDCEN		BIT(0)
-#define RCC_MC_APB4ENSETR_DSIEN			BIT(4)
-#define RCC_MC_APB4ENSETR_DDRPERFMEN		BIT(8)
-#define RCC_MC_APB4ENSETR_USBPHYEN		BIT(16)
-#define RCC_MC_APB4ENSETR_STGENROEN		BIT(20)
-
-/* RCC_MC_APB4ENCLRR register fields */
-#define RCC_MC_APB4ENCLRR_LTDCEN		BIT(0)
-#define RCC_MC_APB4ENCLRR_DSIEN			BIT(4)
-#define RCC_MC_APB4ENCLRR_DDRPERFMEN		BIT(8)
-#define RCC_MC_APB4ENCLRR_USBPHYEN		BIT(16)
-#define RCC_MC_APB4ENCLRR_STGENROEN		BIT(20)
-
-/* RCC_MC_APB5ENSETR register fields */
-#define RCC_MC_APB5ENSETR_SPI6EN		BIT(0)
-#define RCC_MC_APB5ENSETR_I2C4EN		BIT(2)
-#define RCC_MC_APB5ENSETR_I2C6EN		BIT(3)
-#define RCC_MC_APB5ENSETR_USART1EN		BIT(4)
-#define RCC_MC_APB5ENSETR_RTCAPBEN		BIT(8)
-#define RCC_MC_APB5ENSETR_TZC1EN		BIT(11)
-#define RCC_MC_APB5ENSETR_TZC2EN		BIT(12)
-#define RCC_MC_APB5ENSETR_TZPCEN		BIT(13)
-#define RCC_MC_APB5ENSETR_BSECEN		BIT(16)
-#define RCC_MC_APB5ENSETR_STGENEN		BIT(20)
-
-/* RCC_MC_APB5ENCLRR register fields */
-#define RCC_MC_APB5ENCLRR_SPI6EN		BIT(0)
-#define RCC_MC_APB5ENCLRR_I2C4EN		BIT(2)
-#define RCC_MC_APB5ENCLRR_I2C6EN		BIT(3)
-#define RCC_MC_APB5ENCLRR_USART1EN		BIT(4)
-#define RCC_MC_APB5ENCLRR_RTCAPBEN		BIT(8)
-#define RCC_MC_APB5ENCLRR_TZC1EN		BIT(11)
-#define RCC_MC_APB5ENCLRR_TZC2EN		BIT(12)
-#define RCC_MC_APB5ENCLRR_TZPCEN		BIT(13)
-#define RCC_MC_APB5ENCLRR_BSECEN		BIT(16)
-#define RCC_MC_APB5ENCLRR_STGENEN		BIT(20)
-
-/* RCC_MC_AHB5ENSETR register fields */
-#define RCC_MC_AHB5ENSETR_GPIOZEN		BIT(0)
-#define RCC_MC_AHB5ENSETR_CRYP1EN		BIT(4)
-#define RCC_MC_AHB5ENSETR_HASH1EN		BIT(5)
-#define RCC_MC_AHB5ENSETR_RNG1EN		BIT(6)
-#define RCC_MC_AHB5ENSETR_BKPSRAMEN		BIT(8)
-
-/* RCC_MC_AHB5ENCLRR register fields */
-#define RCC_MC_AHB5ENCLRR_GPIOZEN		BIT(0)
-#define RCC_MC_AHB5ENCLRR_CRYP1EN		BIT(4)
-#define RCC_MC_AHB5ENCLRR_HASH1EN		BIT(5)
-#define RCC_MC_AHB5ENCLRR_RNG1EN		BIT(6)
-#define RCC_MC_AHB5ENCLRR_BKPSRAMEN		BIT(8)
-
-/* RCC_MC_AHB6ENSETR register fields */
-#define RCC_MC_AHB6ENSETR_MDMAEN		BIT(0)
-#define RCC_MC_AHB6ENSETR_GPUEN			BIT(5)
-#define RCC_MC_AHB6ENSETR_ETHCKEN		BIT(7)
-#define RCC_MC_AHB6ENSETR_ETHTXEN		BIT(8)
-#define RCC_MC_AHB6ENSETR_ETHRXEN		BIT(9)
-#define RCC_MC_AHB6ENSETR_ETHMACEN		BIT(10)
-#define RCC_MC_AHB6ENSETR_FMCEN			BIT(12)
-#define RCC_MC_AHB6ENSETR_QSPIEN		BIT(14)
-#define RCC_MC_AHB6ENSETR_SDMMC1EN		BIT(16)
-#define RCC_MC_AHB6ENSETR_SDMMC2EN		BIT(17)
-#define RCC_MC_AHB6ENSETR_CRC1EN		BIT(20)
-#define RCC_MC_AHB6ENSETR_USBHEN		BIT(24)
-
-/* RCC_MC_AHB6ENCLRR register fields */
-#define RCC_MC_AHB6ENCLRR_MDMAEN		BIT(0)
-#define RCC_MC_AHB6ENCLRR_GPUEN			BIT(5)
-#define RCC_MC_AHB6ENCLRR_ETHCKEN		BIT(7)
-#define RCC_MC_AHB6ENCLRR_ETHTXEN		BIT(8)
-#define RCC_MC_AHB6ENCLRR_ETHRXEN		BIT(9)
-#define RCC_MC_AHB6ENCLRR_ETHMACEN		BIT(10)
-#define RCC_MC_AHB6ENCLRR_FMCEN			BIT(12)
-#define RCC_MC_AHB6ENCLRR_QSPIEN		BIT(14)
-#define RCC_MC_AHB6ENCLRR_SDMMC1EN		BIT(16)
-#define RCC_MC_AHB6ENCLRR_SDMMC2EN		BIT(17)
-#define RCC_MC_AHB6ENCLRR_CRC1EN		BIT(20)
-#define RCC_MC_AHB6ENCLRR_USBHEN		BIT(24)
-
-/* RCC_MP_APB4LPENSETR register fields */
-#define RCC_MP_APB4LPENSETR_LTDCLPEN		BIT(0)
-#define RCC_MP_APB4LPENSETR_DSILPEN		BIT(4)
-#define RCC_MP_APB4LPENSETR_DDRPERFMLPEN	BIT(8)
-#define RCC_MP_APB4LPENSETR_IWDG2APBLPEN	BIT(15)
-#define RCC_MP_APB4LPENSETR_USBPHYLPEN		BIT(16)
-#define RCC_MP_APB4LPENSETR_STGENROLPEN		BIT(20)
-#define RCC_MP_APB4LPENSETR_STGENROSTPEN	BIT(21)
-
-/* RCC_MP_APB4LPENCLRR register fields */
-#define RCC_MP_APB4LPENCLRR_LTDCLPEN		BIT(0)
-#define RCC_MP_APB4LPENCLRR_DSILPEN		BIT(4)
-#define RCC_MP_APB4LPENCLRR_DDRPERFMLPEN	BIT(8)
-#define RCC_MP_APB4LPENCLRR_IWDG2APBLPEN	BIT(15)
-#define RCC_MP_APB4LPENCLRR_USBPHYLPEN		BIT(16)
-#define RCC_MP_APB4LPENCLRR_STGENROLPEN		BIT(20)
-#define RCC_MP_APB4LPENCLRR_STGENROSTPEN	BIT(21)
-
-/* RCC_MP_APB5LPENSETR register fields */
-#define RCC_MP_APB5LPENSETR_SPI6LPEN		BIT(0)
-#define RCC_MP_APB5LPENSETR_I2C4LPEN		BIT(2)
-#define RCC_MP_APB5LPENSETR_I2C6LPEN		BIT(3)
-#define RCC_MP_APB5LPENSETR_USART1LPEN		BIT(4)
-#define RCC_MP_APB5LPENSETR_RTCAPBLPEN		BIT(8)
-#define RCC_MP_APB5LPENSETR_TZC1LPEN		BIT(11)
-#define RCC_MP_APB5LPENSETR_TZC2LPEN		BIT(12)
-#define RCC_MP_APB5LPENSETR_TZPCLPEN		BIT(13)
-#define RCC_MP_APB5LPENSETR_IWDG1APBLPEN	BIT(15)
-#define RCC_MP_APB5LPENSETR_BSECLPEN		BIT(16)
-#define RCC_MP_APB5LPENSETR_STGENLPEN		BIT(20)
-#define RCC_MP_APB5LPENSETR_STGENSTPEN		BIT(21)
-
-/* RCC_MP_APB5LPENCLRR register fields */
-#define RCC_MP_APB5LPENCLRR_SPI6LPEN		BIT(0)
-#define RCC_MP_APB5LPENCLRR_I2C4LPEN		BIT(2)
-#define RCC_MP_APB5LPENCLRR_I2C6LPEN		BIT(3)
-#define RCC_MP_APB5LPENCLRR_USART1LPEN		BIT(4)
-#define RCC_MP_APB5LPENCLRR_RTCAPBLPEN		BIT(8)
-#define RCC_MP_APB5LPENCLRR_TZC1LPEN		BIT(11)
-#define RCC_MP_APB5LPENCLRR_TZC2LPEN		BIT(12)
-#define RCC_MP_APB5LPENCLRR_TZPCLPEN		BIT(13)
-#define RCC_MP_APB5LPENCLRR_IWDG1APBLPEN	BIT(15)
-#define RCC_MP_APB5LPENCLRR_BSECLPEN		BIT(16)
-#define RCC_MP_APB5LPENCLRR_STGENLPEN		BIT(20)
-#define RCC_MP_APB5LPENCLRR_STGENSTPEN		BIT(21)
-
-/* RCC_MP_AHB5LPENSETR register fields */
-#define RCC_MP_AHB5LPENSETR_GPIOZLPEN		BIT(0)
-#define RCC_MP_AHB5LPENSETR_CRYP1LPEN		BIT(4)
-#define RCC_MP_AHB5LPENSETR_HASH1LPEN		BIT(5)
-#define RCC_MP_AHB5LPENSETR_RNG1LPEN		BIT(6)
-#define RCC_MP_AHB5LPENSETR_BKPSRAMLPEN		BIT(8)
-
-/* RCC_MP_AHB5LPENCLRR register fields */
-#define RCC_MP_AHB5LPENCLRR_GPIOZLPEN		BIT(0)
-#define RCC_MP_AHB5LPENCLRR_CRYP1LPEN		BIT(4)
-#define RCC_MP_AHB5LPENCLRR_HASH1LPEN		BIT(5)
-#define RCC_MP_AHB5LPENCLRR_RNG1LPEN		BIT(6)
-#define RCC_MP_AHB5LPENCLRR_BKPSRAMLPEN		BIT(8)
-
-/* RCC_MP_AHB6LPENSETR register fields */
-#define RCC_MP_AHB6LPENSETR_MDMALPEN		BIT(0)
-#define RCC_MP_AHB6LPENSETR_GPULPEN		BIT(5)
-#define RCC_MP_AHB6LPENSETR_ETHCKLPEN		BIT(7)
-#define RCC_MP_AHB6LPENSETR_ETHTXLPEN		BIT(8)
-#define RCC_MP_AHB6LPENSETR_ETHRXLPEN		BIT(9)
-#define RCC_MP_AHB6LPENSETR_ETHMACLPEN		BIT(10)
-#define RCC_MP_AHB6LPENSETR_ETHSTPEN		BIT(11)
-#define RCC_MP_AHB6LPENSETR_FMCLPEN		BIT(12)
-#define RCC_MP_AHB6LPENSETR_QSPILPEN		BIT(14)
-#define RCC_MP_AHB6LPENSETR_SDMMC1LPEN		BIT(16)
-#define RCC_MP_AHB6LPENSETR_SDMMC2LPEN		BIT(17)
-#define RCC_MP_AHB6LPENSETR_CRC1LPEN		BIT(20)
-#define RCC_MP_AHB6LPENSETR_USBHLPEN		BIT(24)
-
-/* RCC_MP_AHB6LPENCLRR register fields */
-#define RCC_MP_AHB6LPENCLRR_MDMALPEN		BIT(0)
-#define RCC_MP_AHB6LPENCLRR_GPULPEN		BIT(5)
-#define RCC_MP_AHB6LPENCLRR_ETHCKLPEN		BIT(7)
-#define RCC_MP_AHB6LPENCLRR_ETHTXLPEN		BIT(8)
-#define RCC_MP_AHB6LPENCLRR_ETHRXLPEN		BIT(9)
-#define RCC_MP_AHB6LPENCLRR_ETHMACLPEN		BIT(10)
-#define RCC_MP_AHB6LPENCLRR_ETHSTPEN		BIT(11)
-#define RCC_MP_AHB6LPENCLRR_FMCLPEN		BIT(12)
-#define RCC_MP_AHB6LPENCLRR_QSPILPEN		BIT(14)
-#define RCC_MP_AHB6LPENCLRR_SDMMC1LPEN		BIT(16)
-#define RCC_MP_AHB6LPENCLRR_SDMMC2LPEN		BIT(17)
-#define RCC_MP_AHB6LPENCLRR_CRC1LPEN		BIT(20)
-#define RCC_MP_AHB6LPENCLRR_USBHLPEN		BIT(24)
-
-/* RCC_MP_TZAHB6LPENSETR register fields */
-#define RCC_MP_TZAHB6LPENSETR_MDMALPEN		BIT(0)
-
-/* RCC_MP_TZAHB6LPENCLRR register fields */
-#define RCC_MP_TZAHB6LPENCLRR_MDMALPEN		BIT(0)
-
-/* RCC_MC_APB4LPENSETR register fields */
-#define RCC_MC_APB4LPENSETR_LTDCLPEN		BIT(0)
-#define RCC_MC_APB4LPENSETR_DSILPEN		BIT(4)
-#define RCC_MC_APB4LPENSETR_DDRPERFMLPEN	BIT(8)
-#define RCC_MC_APB4LPENSETR_USBPHYLPEN		BIT(16)
-#define RCC_MC_APB4LPENSETR_STGENROLPEN		BIT(20)
-#define RCC_MC_APB4LPENSETR_STGENROSTPEN	BIT(21)
-
-/* RCC_MC_APB4LPENCLRR register fields */
-#define RCC_MC_APB4LPENCLRR_LTDCLPEN		BIT(0)
-#define RCC_MC_APB4LPENCLRR_DSILPEN		BIT(4)
-#define RCC_MC_APB4LPENCLRR_DDRPERFMLPEN	BIT(8)
-#define RCC_MC_APB4LPENCLRR_USBPHYLPEN		BIT(16)
-#define RCC_MC_APB4LPENCLRR_STGENROLPEN		BIT(20)
-#define RCC_MC_APB4LPENCLRR_STGENROSTPEN	BIT(21)
-
-/* RCC_MC_APB5LPENSETR register fields */
-#define RCC_MC_APB5LPENSETR_SPI6LPEN		BIT(0)
-#define RCC_MC_APB5LPENSETR_I2C4LPEN		BIT(2)
-#define RCC_MC_APB5LPENSETR_I2C6LPEN		BIT(3)
-#define RCC_MC_APB5LPENSETR_USART1LPEN		BIT(4)
-#define RCC_MC_APB5LPENSETR_RTCAPBLPEN		BIT(8)
-#define RCC_MC_APB5LPENSETR_TZC1LPEN		BIT(11)
-#define RCC_MC_APB5LPENSETR_TZC2LPEN		BIT(12)
-#define RCC_MC_APB5LPENSETR_TZPCLPEN		BIT(13)
-#define RCC_MC_APB5LPENSETR_BSECLPEN		BIT(16)
-#define RCC_MC_APB5LPENSETR_STGENLPEN		BIT(20)
-#define RCC_MC_APB5LPENSETR_STGENSTPEN		BIT(21)
-
-/* RCC_MC_APB5LPENCLRR register fields */
-#define RCC_MC_APB5LPENCLRR_SPI6LPEN		BIT(0)
-#define RCC_MC_APB5LPENCLRR_I2C4LPEN		BIT(2)
-#define RCC_MC_APB5LPENCLRR_I2C6LPEN		BIT(3)
-#define RCC_MC_APB5LPENCLRR_USART1LPEN		BIT(4)
-#define RCC_MC_APB5LPENCLRR_RTCAPBLPEN		BIT(8)
-#define RCC_MC_APB5LPENCLRR_TZC1LPEN		BIT(11)
-#define RCC_MC_APB5LPENCLRR_TZC2LPEN		BIT(12)
-#define RCC_MC_APB5LPENCLRR_TZPCLPEN		BIT(13)
-#define RCC_MC_APB5LPENCLRR_BSECLPEN		BIT(16)
-#define RCC_MC_APB5LPENCLRR_STGENLPEN		BIT(20)
-#define RCC_MC_APB5LPENCLRR_STGENSTPEN		BIT(21)
-
-/* RCC_MC_AHB5LPENSETR register fields */
-#define RCC_MC_AHB5LPENSETR_GPIOZLPEN		BIT(0)
-#define RCC_MC_AHB5LPENSETR_CRYP1LPEN		BIT(4)
-#define RCC_MC_AHB5LPENSETR_HASH1LPEN		BIT(5)
-#define RCC_MC_AHB5LPENSETR_RNG1LPEN		BIT(6)
-#define RCC_MC_AHB5LPENSETR_BKPSRAMLPEN		BIT(8)
-
-/* RCC_MC_AHB5LPENCLRR register fields */
-#define RCC_MC_AHB5LPENCLRR_GPIOZLPEN		BIT(0)
-#define RCC_MC_AHB5LPENCLRR_CRYP1LPEN		BIT(4)
-#define RCC_MC_AHB5LPENCLRR_HASH1LPEN		BIT(5)
-#define RCC_MC_AHB5LPENCLRR_RNG1LPEN		BIT(6)
-#define RCC_MC_AHB5LPENCLRR_BKPSRAMLPEN		BIT(8)
-
-/* RCC_MC_AHB6LPENSETR register fields */
-#define RCC_MC_AHB6LPENSETR_MDMALPEN		BIT(0)
-#define RCC_MC_AHB6LPENSETR_GPULPEN		BIT(5)
-#define RCC_MC_AHB6LPENSETR_ETHCKLPEN		BIT(7)
-#define RCC_MC_AHB6LPENSETR_ETHTXLPEN		BIT(8)
-#define RCC_MC_AHB6LPENSETR_ETHRXLPEN		BIT(9)
-#define RCC_MC_AHB6LPENSETR_ETHMACLPEN		BIT(10)
-#define RCC_MC_AHB6LPENSETR_ETHSTPEN		BIT(11)
-#define RCC_MC_AHB6LPENSETR_FMCLPEN		BIT(12)
-#define RCC_MC_AHB6LPENSETR_QSPILPEN		BIT(14)
-#define RCC_MC_AHB6LPENSETR_SDMMC1LPEN		BIT(16)
-#define RCC_MC_AHB6LPENSETR_SDMMC2LPEN		BIT(17)
-#define RCC_MC_AHB6LPENSETR_CRC1LPEN		BIT(20)
-#define RCC_MC_AHB6LPENSETR_USBHLPEN		BIT(24)
-
-/* RCC_MC_AHB6LPENCLRR register fields */
-#define RCC_MC_AHB6LPENCLRR_MDMALPEN		BIT(0)
-#define RCC_MC_AHB6LPENCLRR_GPULPEN		BIT(5)
-#define RCC_MC_AHB6LPENCLRR_ETHCKLPEN		BIT(7)
-#define RCC_MC_AHB6LPENCLRR_ETHTXLPEN		BIT(8)
-#define RCC_MC_AHB6LPENCLRR_ETHRXLPEN		BIT(9)
-#define RCC_MC_AHB6LPENCLRR_ETHMACLPEN		BIT(10)
-#define RCC_MC_AHB6LPENCLRR_ETHSTPEN		BIT(11)
-#define RCC_MC_AHB6LPENCLRR_FMCLPEN		BIT(12)
-#define RCC_MC_AHB6LPENCLRR_QSPILPEN		BIT(14)
-#define RCC_MC_AHB6LPENCLRR_SDMMC1LPEN		BIT(16)
-#define RCC_MC_AHB6LPENCLRR_SDMMC2LPEN		BIT(17)
-#define RCC_MC_AHB6LPENCLRR_CRC1LPEN		BIT(20)
-#define RCC_MC_AHB6LPENCLRR_USBHLPEN		BIT(24)
-
-/* RCC_BR_RSTSCLRR register fields */
-#define RCC_BR_RSTSCLRR_PORRSTF			BIT(0)
-#define RCC_BR_RSTSCLRR_BORRSTF			BIT(1)
-#define RCC_BR_RSTSCLRR_PADRSTF			BIT(2)
-#define RCC_BR_RSTSCLRR_HCSSRSTF		BIT(3)
-#define RCC_BR_RSTSCLRR_VCORERSTF		BIT(4)
-#define RCC_BR_RSTSCLRR_MPSYSRSTF		BIT(6)
-#define RCC_BR_RSTSCLRR_MCSYSRSTF		BIT(7)
-#define RCC_BR_RSTSCLRR_IWDG1RSTF		BIT(8)
-#define RCC_BR_RSTSCLRR_IWDG2RSTF		BIT(9)
-#define RCC_BR_RSTSCLRR_MPUP0RSTF		BIT(13)
-#define RCC_BR_RSTSCLRR_MPUP1RSTF		BIT(14)
-
-/* RCC_MP_GRSTCSETR register fields */
-#define RCC_MP_GRSTCSETR_MPSYSRST		BIT(0)
-#define RCC_MP_GRSTCSETR_MCURST			BIT(1)
-#define RCC_MP_GRSTCSETR_MPUP0RST		BIT(4)
-#define RCC_MP_GRSTCSETR_MPUP1RST		BIT(5)
-
-/* RCC_MP_RSTSCLRR register fields */
-#define RCC_MP_RSTSCLRR_PORRSTF			BIT(0)
-#define RCC_MP_RSTSCLRR_BORRSTF			BIT(1)
-#define RCC_MP_RSTSCLRR_PADRSTF			BIT(2)
-#define RCC_MP_RSTSCLRR_HCSSRSTF		BIT(3)
-#define RCC_MP_RSTSCLRR_VCORERSTF		BIT(4)
-#define RCC_MP_RSTSCLRR_MPSYSRSTF		BIT(6)
-#define RCC_MP_RSTSCLRR_MCSYSRSTF		BIT(7)
-#define RCC_MP_RSTSCLRR_IWDG1RSTF		BIT(8)
-#define RCC_MP_RSTSCLRR_IWDG2RSTF		BIT(9)
-#define RCC_MP_RSTSCLRR_STDBYRSTF		BIT(11)
-#define RCC_MP_RSTSCLRR_CSTDBYRSTF		BIT(12)
-#define RCC_MP_RSTSCLRR_MPUP0RSTF		BIT(13)
-#define RCC_MP_RSTSCLRR_MPUP1RSTF		BIT(14)
-#define RCC_MP_RSTSCLRR_SPARE			BIT(15)
-
-/* RCC_MP_IWDGFZSETR register fields */
-#define RCC_MP_IWDGFZSETR_FZ_IWDG1		BIT(0)
-#define RCC_MP_IWDGFZSETR_FZ_IWDG2		BIT(1)
-
-/* RCC_MP_IWDGFZCLRR register fields */
-#define RCC_MP_IWDGFZCLRR_FZ_IWDG1		BIT(0)
-#define RCC_MP_IWDGFZCLRR_FZ_IWDG2		BIT(1)
-
-/* RCC_MP_CIER register fields */
-#define RCC_MP_CIER_LSIRDYIE			BIT(0)
-#define RCC_MP_CIER_LSERDYIE			BIT(1)
-#define RCC_MP_CIER_HSIRDYIE			BIT(2)
-#define RCC_MP_CIER_HSERDYIE			BIT(3)
-#define RCC_MP_CIER_CSIRDYIE			BIT(4)
-#define RCC_MP_CIER_PLL1DYIE			BIT(8)
-#define RCC_MP_CIER_PLL2DYIE			BIT(9)
-#define RCC_MP_CIER_PLL3DYIE			BIT(10)
-#define RCC_MP_CIER_PLL4DYIE			BIT(11)
-#define RCC_MP_CIER_LSECSSIE			BIT(16)
-#define RCC_MP_CIER_WKUPIE			BIT(20)
-
-/* RCC_MP_CIFR register fields */
-#define RCC_MP_CIFR_MASK			U(0x110F1F)
-#define RCC_MP_CIFR_LSIRDYF			BIT(0)
-#define RCC_MP_CIFR_LSERDYF			BIT(1)
-#define RCC_MP_CIFR_HSIRDYF			BIT(2)
-#define RCC_MP_CIFR_HSERDYF			BIT(3)
-#define RCC_MP_CIFR_CSIRDYF			BIT(4)
-#define RCC_MP_CIFR_PLL1DYF			BIT(8)
-#define RCC_MP_CIFR_PLL2DYF			BIT(9)
-#define RCC_MP_CIFR_PLL3DYF			BIT(10)
-#define RCC_MP_CIFR_PLL4DYF			BIT(11)
-#define RCC_MP_CIFR_LSECSSF			BIT(16)
-#define RCC_MP_CIFR_WKUPF			BIT(20)
-
-/* RCC_PWRLPDLYCR register fields */
-#define RCC_PWRLPDLYCR_PWRLP_DLY_MASK		GENMASK(21, 0)
-#define RCC_PWRLPDLYCR_PWRLP_DLY_SHIFT		0
-#define RCC_PWRLPDLYCR_MCTMPSKP			BIT(24)
-
-/* RCC_MP_RSTSSETR register fields */
-#define RCC_MP_RSTSSETR_PORRSTF			BIT(0)
-#define RCC_MP_RSTSSETR_BORRSTF			BIT(1)
-#define RCC_MP_RSTSSETR_PADRSTF			BIT(2)
-#define RCC_MP_RSTSSETR_HCSSRSTF		BIT(3)
-#define RCC_MP_RSTSSETR_VCORERSTF		BIT(4)
-#define RCC_MP_RSTSSETR_MPSYSRSTF		BIT(6)
-#define RCC_MP_RSTSSETR_MCSYSRSTF		BIT(7)
-#define RCC_MP_RSTSSETR_IWDG1RSTF		BIT(8)
-#define RCC_MP_RSTSSETR_IWDG2RSTF		BIT(9)
-#define RCC_MP_RSTSSETR_STDBYRSTF		BIT(11)
-#define RCC_MP_RSTSSETR_CSTDBYRSTF		BIT(12)
-#define RCC_MP_RSTSSETR_MPUP0RSTF		BIT(13)
-#define RCC_MP_RSTSSETR_MPUP1RSTF		BIT(14)
-#define RCC_MP_RSTSSETR_SPARE			BIT(15)
-
-/* RCC_MCO1CFGR register fields */
-#define RCC_MCO1CFGR_MCO1SEL_MASK		GENMASK(2, 0)
-#define RCC_MCO1CFGR_MCO1SEL_SHIFT		0
-#define RCC_MCO1CFGR_MCO1DIV_MASK		GENMASK(7, 4)
-#define RCC_MCO1CFGR_MCO1DIV_SHIFT		4
-#define RCC_MCO1CFGR_MCO1ON			BIT(12)
-
-/* RCC_MCO2CFGR register fields */
-#define RCC_MCO2CFGR_MCO2SEL_MASK		GENMASK(2, 0)
-#define RCC_MCO2CFGR_MCO2SEL_SHIFT		0
-#define RCC_MCO2CFGR_MCO2DIV_MASK		GENMASK(7, 4)
-#define RCC_MCO2CFGR_MCO2DIV_SHIFT		4
-#define RCC_MCO2CFGR_MCO2ON			BIT(12)
-
-/* RCC_OCRDYR register fields */
-#define RCC_OCRDYR_HSIRDY			BIT(0)
-#define RCC_OCRDYR_HSIDIVRDY			BIT(2)
-#define RCC_OCRDYR_CSIRDY			BIT(4)
-#define RCC_OCRDYR_HSERDY			BIT(8)
-#define RCC_OCRDYR_MPUCKRDY			BIT(23)
-#define RCC_OCRDYR_AXICKRDY			BIT(24)
-#define RCC_OCRDYR_CKREST			BIT(25)
-
-/* RCC_DBGCFGR register fields */
-#define RCC_DBGCFGR_TRACEDIV_MASK		GENMASK(2, 0)
-#define RCC_DBGCFGR_TRACEDIV_SHIFT		0
-#define RCC_DBGCFGR_DBGCKEN			BIT(8)
-#define RCC_DBGCFGR_TRACECKEN			BIT(9)
-#define RCC_DBGCFGR_DBGRST			BIT(12)
-
-/* RCC_RCK3SELR register fields */
-#define RCC_RCK3SELR_PLL3SRC_MASK		GENMASK(1, 0)
-#define RCC_RCK3SELR_PLL3SRC_SHIFT		0
-#define RCC_RCK3SELR_PLL3SRCRDY			BIT(31)
-
-/* RCC_RCK4SELR register fields */
-#define RCC_RCK4SELR_PLL4SRC_MASK		GENMASK(1, 0)
-#define RCC_RCK4SELR_PLL4SRC_SHIFT		0
-#define RCC_RCK4SELR_PLL4SRCRDY			BIT(31)
-
-/* RCC_TIMG1PRER register fields */
-#define RCC_TIMG1PRER_TIMG1PRE			BIT(0)
-#define RCC_TIMG1PRER_TIMG1PRERDY		BIT(31)
-
-/* RCC_TIMG2PRER register fields */
-#define RCC_TIMG2PRER_TIMG2PRE			BIT(0)
-#define RCC_TIMG2PRER_TIMG2PRERDY		BIT(31)
-
-/* RCC_MCUDIVR register fields */
-#define RCC_MCUDIVR_MCUDIV_MASK			GENMASK(3, 0)
-#define RCC_MCUDIVR_MCUDIV_SHIFT		0
-#define RCC_MCUDIVR_MCUDIVRDY			BIT(31)
-
-/* RCC_APB1DIVR register fields */
-#define RCC_APB1DIVR_APB1DIV_MASK		GENMASK(2, 0)
-#define RCC_APB1DIVR_APB1DIV_SHIFT		0
-#define RCC_APB1DIVR_APB1DIVRDY			BIT(31)
-
-/* RCC_APB2DIVR register fields */
-#define RCC_APB2DIVR_APB2DIV_MASK		GENMASK(2, 0)
-#define RCC_APB2DIVR_APB2DIV_SHIFT		0
-#define RCC_APB2DIVR_APB2DIVRDY			BIT(31)
-
-/* RCC_APB3DIVR register fields */
-#define RCC_APB3DIVR_APB3DIV_MASK		GENMASK(2, 0)
-#define RCC_APB3DIVR_APB3DIV_SHIFT		0
-#define RCC_APB3DIVR_APB3DIVRDY			BIT(31)
-
-/* RCC_PLL3CR register fields */
-#define RCC_PLL3CR_PLLON			BIT(0)
-#define RCC_PLL3CR_PLL3RDY			BIT(1)
-#define RCC_PLL3CR_SSCG_CTRL			BIT(2)
-#define RCC_PLL3CR_DIVPEN			BIT(4)
-#define RCC_PLL3CR_DIVQEN			BIT(5)
-#define RCC_PLL3CR_DIVREN			BIT(6)
-
-/* RCC_PLL3CFGR1 register fields */
-#define RCC_PLL3CFGR1_DIVN_MASK			GENMASK(8, 0)
-#define RCC_PLL3CFGR1_DIVN_SHIFT		0
-#define RCC_PLL3CFGR1_DIVM3_MASK		GENMASK(21, 16)
-#define RCC_PLL3CFGR1_DIVM3_SHIFT		16
-#define RCC_PLL3CFGR1_IFRGE_MASK		GENMASK(25, 24)
-#define RCC_PLL3CFGR1_IFRGE_SHIFT		24
-
-/* RCC_PLL3CFGR2 register fields */
-#define RCC_PLL3CFGR2_DIVP_MASK			GENMASK(6, 0)
-#define RCC_PLL3CFGR2_DIVP_SHIFT		0
-#define RCC_PLL3CFGR2_DIVQ_MASK			GENMASK(14, 8)
-#define RCC_PLL3CFGR2_DIVQ_SHIFT		8
-#define RCC_PLL3CFGR2_DIVR_MASK			GENMASK(22, 16)
-#define RCC_PLL3CFGR2_DIVR_SHIFT		16
-
-/* RCC_PLL3FRACR register fields */
-#define RCC_PLL3FRACR_FRACV_MASK		GENMASK(15, 3)
-#define RCC_PLL3FRACR_FRACV_SHIFT		3
-#define RCC_PLL3FRACR_FRACLE			BIT(16)
-
-/* RCC_PLL3CSGR register fields */
-#define RCC_PLL3CSGR_MOD_PER_MASK		GENMASK(12, 0)
-#define RCC_PLL3CSGR_MOD_PER_SHIFT		0
-#define RCC_PLL3CSGR_TPDFN_DIS			BIT(13)
-#define RCC_PLL3CSGR_RPDFN_DIS			BIT(14)
-#define RCC_PLL3CSGR_SSCG_MODE			BIT(15)
-#define RCC_PLL3CSGR_INC_STEP_MASK		GENMASK(30, 16)
-#define RCC_PLL3CSGR_INC_STEP_SHIFT		16
-
-/* RCC_PLL4CR register fields */
-#define RCC_PLL4CR_PLLON			BIT(0)
-#define RCC_PLL4CR_PLL4RDY			BIT(1)
-#define RCC_PLL4CR_SSCG_CTRL			BIT(2)
-#define RCC_PLL4CR_DIVPEN			BIT(4)
-#define RCC_PLL4CR_DIVQEN			BIT(5)
-#define RCC_PLL4CR_DIVREN			BIT(6)
-
-/* RCC_PLL4CFGR1 register fields */
-#define RCC_PLL4CFGR1_DIVN_MASK			GENMASK(8, 0)
-#define RCC_PLL4CFGR1_DIVN_SHIFT		0
-#define RCC_PLL4CFGR1_DIVM4_MASK		GENMASK(21, 16)
-#define RCC_PLL4CFGR1_DIVM4_SHIFT		16
-#define RCC_PLL4CFGR1_IFRGE_MASK		GENMASK(25, 24)
-#define RCC_PLL4CFGR1_IFRGE_SHIFT		24
-
-/* RCC_PLL4CFGR2 register fields */
-#define RCC_PLL4CFGR2_DIVP_MASK			GENMASK(6, 0)
-#define RCC_PLL4CFGR2_DIVP_SHIFT		0
-#define RCC_PLL4CFGR2_DIVQ_MASK			GENMASK(14, 8)
-#define RCC_PLL4CFGR2_DIVQ_SHIFT		8
-#define RCC_PLL4CFGR2_DIVR_MASK			GENMASK(22, 16)
-#define RCC_PLL4CFGR2_DIVR_SHIFT		16
-
-/* RCC_PLL4FRACR register fields */
-#define RCC_PLL4FRACR_FRACV_MASK		GENMASK(15, 3)
-#define RCC_PLL4FRACR_FRACV_SHIFT		3
-#define RCC_PLL4FRACR_FRACLE			BIT(16)
-
-/* RCC_PLL4CSGR register fields */
-#define RCC_PLL4CSGR_MOD_PER_MASK		GENMASK(12, 0)
-#define RCC_PLL4CSGR_MOD_PER_SHIFT		0
-#define RCC_PLL4CSGR_TPDFN_DIS			BIT(13)
-#define RCC_PLL4CSGR_RPDFN_DIS			BIT(14)
-#define RCC_PLL4CSGR_SSCG_MODE			BIT(15)
-#define RCC_PLL4CSGR_INC_STEP_MASK		GENMASK(30, 16)
-#define RCC_PLL4CSGR_INC_STEP_SHIFT		16
-
-/* RCC_I2C12CKSELR register fields */
-#define RCC_I2C12CKSELR_I2C12SRC_MASK		GENMASK(2, 0)
-#define RCC_I2C12CKSELR_I2C12SRC_SHIFT		0
-
-/* RCC_I2C35CKSELR register fields */
-#define RCC_I2C35CKSELR_I2C35SRC_MASK		GENMASK(2, 0)
-#define RCC_I2C35CKSELR_I2C35SRC_SHIFT		0
-
-/* RCC_SAI1CKSELR register fields */
-#define RCC_SAI1CKSELR_SAI1SRC_MASK		GENMASK(2, 0)
-#define RCC_SAI1CKSELR_SAI1SRC_SHIFT		0
-
-/* RCC_SAI2CKSELR register fields */
-#define RCC_SAI2CKSELR_SAI2SRC_MASK		GENMASK(2, 0)
-#define RCC_SAI2CKSELR_SAI2SRC_SHIFT		0
-
-/* RCC_SAI3CKSELR register fields */
-#define RCC_SAI3CKSELR_SAI3SRC_MASK		GENMASK(2, 0)
-#define RCC_SAI3CKSELR_SAI3SRC_SHIFT		0
-
-/* RCC_SAI4CKSELR register fields */
-#define RCC_SAI4CKSELR_SAI4SRC_MASK		GENMASK(2, 0)
-#define RCC_SAI4CKSELR_SAI4SRC_SHIFT		0
-
-/* RCC_SPI2S1CKSELR register fields */
-#define RCC_SPI2S1CKSELR_SPI1SRC_MASK		GENMASK(2, 0)
-#define RCC_SPI2S1CKSELR_SPI1SRC_SHIFT		0
-
-/* RCC_SPI2S23CKSELR register fields */
-#define RCC_SPI2S23CKSELR_SPI23SRC_MASK		GENMASK(2, 0)
-#define RCC_SPI2S23CKSELR_SPI23SRC_SHIFT	0
-
-/* RCC_SPI45CKSELR register fields */
-#define RCC_SPI45CKSELR_SPI45SRC_MASK		GENMASK(2, 0)
-#define RCC_SPI45CKSELR_SPI45SRC_SHIFT		0
-
-/* RCC_UART6CKSELR register fields */
-#define RCC_UART6CKSELR_UART6SRC_MASK		GENMASK(2, 0)
-#define RCC_UART6CKSELR_UART6SRC_SHIFT		0
-
-/* RCC_UART24CKSELR register fields */
-#define RCC_UART24CKSELR_HSI			0x00000002
-#define RCC_UART24CKSELR_UART24SRC_MASK		GENMASK(2, 0)
-#define RCC_UART24CKSELR_UART24SRC_SHIFT	0
-
-/* RCC_UART35CKSELR register fields */
-#define RCC_UART35CKSELR_UART35SRC_MASK		GENMASK(2, 0)
-#define RCC_UART35CKSELR_UART35SRC_SHIFT	0
-
-/* RCC_UART78CKSELR register fields */
-#define RCC_UART78CKSELR_UART78SRC_MASK		GENMASK(2, 0)
-#define RCC_UART78CKSELR_UART78SRC_SHIFT	0
-
-/* RCC_SDMMC12CKSELR register fields */
-#define RCC_SDMMC12CKSELR_SDMMC12SRC_MASK	GENMASK(2, 0)
-#define RCC_SDMMC12CKSELR_SDMMC12SRC_SHIFT	0
-
-/* RCC_SDMMC3CKSELR register fields */
-#define RCC_SDMMC3CKSELR_SDMMC3SRC_MASK		GENMASK(2, 0)
-#define RCC_SDMMC3CKSELR_SDMMC3SRC_SHIFT	0
-
-/* RCC_ETHCKSELR register fields */
-#define RCC_ETHCKSELR_ETHSRC_MASK		GENMASK(1, 0)
-#define RCC_ETHCKSELR_ETHSRC_SHIFT		0
-#define RCC_ETHCKSELR_ETHPTPDIV_MASK		GENMASK(7, 4)
-#define RCC_ETHCKSELR_ETHPTPDIV_SHIFT		4
-
-/* RCC_QSPICKSELR register fields */
-#define RCC_QSPICKSELR_QSPISRC_MASK		GENMASK(1, 0)
-#define RCC_QSPICKSELR_QSPISRC_SHIFT		0
-
-/* RCC_FMCCKSELR register fields */
-#define RCC_FMCCKSELR_FMCSRC_MASK		GENMASK(1, 0)
-#define RCC_FMCCKSELR_FMCSRC_SHIFT		0
-
-/* RCC_FDCANCKSELR register fields */
-#define RCC_FDCANCKSELR_FDCANSRC_MASK		GENMASK(1, 0)
-#define RCC_FDCANCKSELR_FDCANSRC_SHIFT		0
-
-/* RCC_SPDIFCKSELR register fields */
-#define RCC_SPDIFCKSELR_SPDIFSRC_MASK		GENMASK(1, 0)
-#define RCC_SPDIFCKSELR_SPDIFSRC_SHIFT		0
-
-/* RCC_CECCKSELR register fields */
-#define RCC_CECCKSELR_CECSRC_MASK		GENMASK(1, 0)
-#define RCC_CECCKSELR_CECSRC_SHIFT		0
-
-/* RCC_USBCKSELR register fields */
-#define RCC_USBCKSELR_USBPHYSRC_MASK		GENMASK(1, 0)
-#define RCC_USBCKSELR_USBPHYSRC_SHIFT		0
-#define RCC_USBCKSELR_USBOSRC			BIT(4)
-#define RCC_USBCKSELR_USBOSRC_MASK		BIT(4)
-#define RCC_USBCKSELR_USBOSRC_SHIFT		4
-
-/* RCC_RNG2CKSELR register fields */
-#define RCC_RNG2CKSELR_RNG2SRC_MASK		GENMASK(1, 0)
-#define RCC_RNG2CKSELR_RNG2SRC_SHIFT		0
-
-/* RCC_DSICKSELR register fields */
-#define RCC_DSICKSELR_DSISRC			BIT(0)
-
-/* RCC_ADCCKSELR register fields */
-#define RCC_ADCCKSELR_ADCSRC_MASK		GENMASK(1, 0)
-#define RCC_ADCCKSELR_ADCSRC_SHIFT		0
-
-/* RCC_LPTIM45CKSELR register fields */
-#define RCC_LPTIM45CKSELR_LPTIM45SRC_MASK	GENMASK(2, 0)
-#define RCC_LPTIM45CKSELR_LPTIM45SRC_SHIFT	0
-
-/* RCC_LPTIM23CKSELR register fields */
-#define RCC_LPTIM23CKSELR_LPTIM23SRC_MASK	GENMASK(2, 0)
-#define RCC_LPTIM23CKSELR_LPTIM23SRC_SHIFT	0
-
-/* RCC_LPTIM1CKSELR register fields */
-#define RCC_LPTIM1CKSELR_LPTIM1SRC_MASK		GENMASK(2, 0)
-#define RCC_LPTIM1CKSELR_LPTIM1SRC_SHIFT	0
-
-/* RCC_APB1RSTSETR register fields */
-#define RCC_APB1RSTSETR_TIM2RST			BIT(0)
-#define RCC_APB1RSTSETR_TIM3RST			BIT(1)
-#define RCC_APB1RSTSETR_TIM4RST			BIT(2)
-#define RCC_APB1RSTSETR_TIM5RST			BIT(3)
-#define RCC_APB1RSTSETR_TIM6RST			BIT(4)
-#define RCC_APB1RSTSETR_TIM7RST			BIT(5)
-#define RCC_APB1RSTSETR_TIM12RST		BIT(6)
-#define RCC_APB1RSTSETR_TIM13RST		BIT(7)
-#define RCC_APB1RSTSETR_TIM14RST		BIT(8)
-#define RCC_APB1RSTSETR_LPTIM1RST		BIT(9)
-#define RCC_APB1RSTSETR_SPI2RST			BIT(11)
-#define RCC_APB1RSTSETR_SPI3RST			BIT(12)
-#define RCC_APB1RSTSETR_USART2RST		BIT(14)
-#define RCC_APB1RSTSETR_USART3RST		BIT(15)
-#define RCC_APB1RSTSETR_UART4RST		BIT(16)
-#define RCC_APB1RSTSETR_UART5RST		BIT(17)
-#define RCC_APB1RSTSETR_UART7RST		BIT(18)
-#define RCC_APB1RSTSETR_UART8RST		BIT(19)
-#define RCC_APB1RSTSETR_I2C1RST			BIT(21)
-#define RCC_APB1RSTSETR_I2C2RST			BIT(22)
-#define RCC_APB1RSTSETR_I2C3RST			BIT(23)
-#define RCC_APB1RSTSETR_I2C5RST			BIT(24)
-#define RCC_APB1RSTSETR_SPDIFRST		BIT(26)
-#define RCC_APB1RSTSETR_CECRST			BIT(27)
-#define RCC_APB1RSTSETR_DAC12RST		BIT(29)
-#define RCC_APB1RSTSETR_MDIOSRST		BIT(31)
-
-/* RCC_APB1RSTCLRR register fields */
-#define RCC_APB1RSTCLRR_TIM2RST			BIT(0)
-#define RCC_APB1RSTCLRR_TIM3RST			BIT(1)
-#define RCC_APB1RSTCLRR_TIM4RST			BIT(2)
-#define RCC_APB1RSTCLRR_TIM5RST			BIT(3)
-#define RCC_APB1RSTCLRR_TIM6RST			BIT(4)
-#define RCC_APB1RSTCLRR_TIM7RST			BIT(5)
-#define RCC_APB1RSTCLRR_TIM12RST		BIT(6)
-#define RCC_APB1RSTCLRR_TIM13RST		BIT(7)
-#define RCC_APB1RSTCLRR_TIM14RST		BIT(8)
-#define RCC_APB1RSTCLRR_LPTIM1RST		BIT(9)
-#define RCC_APB1RSTCLRR_SPI2RST			BIT(11)
-#define RCC_APB1RSTCLRR_SPI3RST			BIT(12)
-#define RCC_APB1RSTCLRR_USART2RST		BIT(14)
-#define RCC_APB1RSTCLRR_USART3RST		BIT(15)
-#define RCC_APB1RSTCLRR_UART4RST		BIT(16)
-#define RCC_APB1RSTCLRR_UART5RST		BIT(17)
-#define RCC_APB1RSTCLRR_UART7RST		BIT(18)
-#define RCC_APB1RSTCLRR_UART8RST		BIT(19)
-#define RCC_APB1RSTCLRR_I2C1RST			BIT(21)
-#define RCC_APB1RSTCLRR_I2C2RST			BIT(22)
-#define RCC_APB1RSTCLRR_I2C3RST			BIT(23)
-#define RCC_APB1RSTCLRR_I2C5RST			BIT(24)
-#define RCC_APB1RSTCLRR_SPDIFRST		BIT(26)
-#define RCC_APB1RSTCLRR_CECRST			BIT(27)
-#define RCC_APB1RSTCLRR_DAC12RST		BIT(29)
-#define RCC_APB1RSTCLRR_MDIOSRST		BIT(31)
-
-/* RCC_APB2RSTSETR register fields */
-#define RCC_APB2RSTSETR_TIM1RST			BIT(0)
-#define RCC_APB2RSTSETR_TIM8RST			BIT(1)
-#define RCC_APB2RSTSETR_TIM15RST		BIT(2)
-#define RCC_APB2RSTSETR_TIM16RST		BIT(3)
-#define RCC_APB2RSTSETR_TIM17RST		BIT(4)
-#define RCC_APB2RSTSETR_SPI1RST			BIT(8)
-#define RCC_APB2RSTSETR_SPI4RST			BIT(9)
-#define RCC_APB2RSTSETR_SPI5RST			BIT(10)
-#define RCC_APB2RSTSETR_USART6RST		BIT(13)
-#define RCC_APB2RSTSETR_SAI1RST			BIT(16)
-#define RCC_APB2RSTSETR_SAI2RST			BIT(17)
-#define RCC_APB2RSTSETR_SAI3RST			BIT(18)
-#define RCC_APB2RSTSETR_DFSDMRST		BIT(20)
-#define RCC_APB2RSTSETR_FDCANRST		BIT(24)
-
-/* RCC_APB2RSTCLRR register fields */
-#define RCC_APB2RSTCLRR_TIM1RST			BIT(0)
-#define RCC_APB2RSTCLRR_TIM8RST			BIT(1)
-#define RCC_APB2RSTCLRR_TIM15RST		BIT(2)
-#define RCC_APB2RSTCLRR_TIM16RST		BIT(3)
-#define RCC_APB2RSTCLRR_TIM17RST		BIT(4)
-#define RCC_APB2RSTCLRR_SPI1RST			BIT(8)
-#define RCC_APB2RSTCLRR_SPI4RST			BIT(9)
-#define RCC_APB2RSTCLRR_SPI5RST			BIT(10)
-#define RCC_APB2RSTCLRR_USART6RST		BIT(13)
-#define RCC_APB2RSTCLRR_SAI1RST			BIT(16)
-#define RCC_APB2RSTCLRR_SAI2RST			BIT(17)
-#define RCC_APB2RSTCLRR_SAI3RST			BIT(18)
-#define RCC_APB2RSTCLRR_DFSDMRST		BIT(20)
-#define RCC_APB2RSTCLRR_FDCANRST		BIT(24)
-
-/* RCC_APB3RSTSETR register fields */
-#define RCC_APB3RSTSETR_LPTIM2RST		BIT(0)
-#define RCC_APB3RSTSETR_LPTIM3RST		BIT(1)
-#define RCC_APB3RSTSETR_LPTIM4RST		BIT(2)
-#define RCC_APB3RSTSETR_LPTIM5RST		BIT(3)
-#define RCC_APB3RSTSETR_SAI4RST			BIT(8)
-#define RCC_APB3RSTSETR_SYSCFGRST		BIT(11)
-#define RCC_APB3RSTSETR_VREFRST			BIT(13)
-#define RCC_APB3RSTSETR_TMPSENSRST		BIT(16)
-#define RCC_APB3RSTSETR_PMBCTRLRST		BIT(17)
-
-/* RCC_APB3RSTCLRR register fields */
-#define RCC_APB3RSTCLRR_LPTIM2RST		BIT(0)
-#define RCC_APB3RSTCLRR_LPTIM3RST		BIT(1)
-#define RCC_APB3RSTCLRR_LPTIM4RST		BIT(2)
-#define RCC_APB3RSTCLRR_LPTIM5RST		BIT(3)
-#define RCC_APB3RSTCLRR_SAI4RST			BIT(8)
-#define RCC_APB3RSTCLRR_SYSCFGRST		BIT(11)
-#define RCC_APB3RSTCLRR_VREFRST			BIT(13)
-#define RCC_APB3RSTCLRR_TMPSENSRST		BIT(16)
-#define RCC_APB3RSTCLRR_PMBCTRLRST		BIT(17)
-
-/* RCC_AHB2RSTSETR register fields */
-#define RCC_AHB2RSTSETR_DMA1RST			BIT(0)
-#define RCC_AHB2RSTSETR_DMA2RST			BIT(1)
-#define RCC_AHB2RSTSETR_DMAMUXRST		BIT(2)
-#define RCC_AHB2RSTSETR_ADC12RST		BIT(5)
-#define RCC_AHB2RSTSETR_USBORST			BIT(8)
-#define RCC_AHB2RSTSETR_SDMMC3RST		BIT(16)
-
-/* RCC_AHB2RSTCLRR register fields */
-#define RCC_AHB2RSTCLRR_DMA1RST			BIT(0)
-#define RCC_AHB2RSTCLRR_DMA2RST			BIT(1)
-#define RCC_AHB2RSTCLRR_DMAMUXRST		BIT(2)
-#define RCC_AHB2RSTCLRR_ADC12RST		BIT(5)
-#define RCC_AHB2RSTCLRR_USBORST			BIT(8)
-#define RCC_AHB2RSTCLRR_SDMMC3RST		BIT(16)
-
-/* RCC_AHB3RSTSETR register fields */
-#define RCC_AHB3RSTSETR_DCMIRST			BIT(0)
-#define RCC_AHB3RSTSETR_CRYP2RST		BIT(4)
-#define RCC_AHB3RSTSETR_HASH2RST		BIT(5)
-#define RCC_AHB3RSTSETR_RNG2RST			BIT(6)
-#define RCC_AHB3RSTSETR_CRC2RST			BIT(7)
-#define RCC_AHB3RSTSETR_HSEMRST			BIT(11)
-#define RCC_AHB3RSTSETR_IPCCRST			BIT(12)
-
-/* RCC_AHB3RSTCLRR register fields */
-#define RCC_AHB3RSTCLRR_DCMIRST			BIT(0)
-#define RCC_AHB3RSTCLRR_CRYP2RST		BIT(4)
-#define RCC_AHB3RSTCLRR_HASH2RST		BIT(5)
-#define RCC_AHB3RSTCLRR_RNG2RST			BIT(6)
-#define RCC_AHB3RSTCLRR_CRC2RST			BIT(7)
-#define RCC_AHB3RSTCLRR_HSEMRST			BIT(11)
-#define RCC_AHB3RSTCLRR_IPCCRST			BIT(12)
-
-/* RCC_AHB4RSTSETR register fields */
-#define RCC_AHB4RSTSETR_GPIOARST		BIT(0)
-#define RCC_AHB4RSTSETR_GPIOBRST		BIT(1)
-#define RCC_AHB4RSTSETR_GPIOCRST		BIT(2)
-#define RCC_AHB4RSTSETR_GPIODRST		BIT(3)
-#define RCC_AHB4RSTSETR_GPIOERST		BIT(4)
-#define RCC_AHB4RSTSETR_GPIOFRST		BIT(5)
-#define RCC_AHB4RSTSETR_GPIOGRST		BIT(6)
-#define RCC_AHB4RSTSETR_GPIOHRST		BIT(7)
-#define RCC_AHB4RSTSETR_GPIOIRST		BIT(8)
-#define RCC_AHB4RSTSETR_GPIOJRST		BIT(9)
-#define RCC_AHB4RSTSETR_GPIOKRST		BIT(10)
-
-/* RCC_AHB4RSTCLRR register fields */
-#define RCC_AHB4RSTCLRR_GPIOARST		BIT(0)
-#define RCC_AHB4RSTCLRR_GPIOBRST		BIT(1)
-#define RCC_AHB4RSTCLRR_GPIOCRST		BIT(2)
-#define RCC_AHB4RSTCLRR_GPIODRST		BIT(3)
-#define RCC_AHB4RSTCLRR_GPIOERST		BIT(4)
-#define RCC_AHB4RSTCLRR_GPIOFRST		BIT(5)
-#define RCC_AHB4RSTCLRR_GPIOGRST		BIT(6)
-#define RCC_AHB4RSTCLRR_GPIOHRST		BIT(7)
-#define RCC_AHB4RSTCLRR_GPIOIRST		BIT(8)
-#define RCC_AHB4RSTCLRR_GPIOJRST		BIT(9)
-#define RCC_AHB4RSTCLRR_GPIOKRST		BIT(10)
-
-/* RCC_MP_APB1ENSETR register fields */
-#define RCC_MP_APB1ENSETR_TIM2EN		BIT(0)
-#define RCC_MP_APB1ENSETR_TIM3EN		BIT(1)
-#define RCC_MP_APB1ENSETR_TIM4EN		BIT(2)
-#define RCC_MP_APB1ENSETR_TIM5EN		BIT(3)
-#define RCC_MP_APB1ENSETR_TIM6EN		BIT(4)
-#define RCC_MP_APB1ENSETR_TIM7EN		BIT(5)
-#define RCC_MP_APB1ENSETR_TIM12EN		BIT(6)
-#define RCC_MP_APB1ENSETR_TIM13EN		BIT(7)
-#define RCC_MP_APB1ENSETR_TIM14EN		BIT(8)
-#define RCC_MP_APB1ENSETR_LPTIM1EN		BIT(9)
-#define RCC_MP_APB1ENSETR_SPI2EN		BIT(11)
-#define RCC_MP_APB1ENSETR_SPI3EN		BIT(12)
-#define RCC_MP_APB1ENSETR_USART2EN		BIT(14)
-#define RCC_MP_APB1ENSETR_USART3EN		BIT(15)
-#define RCC_MP_APB1ENSETR_UART4EN		BIT(16)
-#define RCC_MP_APB1ENSETR_UART5EN		BIT(17)
-#define RCC_MP_APB1ENSETR_UART7EN		BIT(18)
-#define RCC_MP_APB1ENSETR_UART8EN		BIT(19)
-#define RCC_MP_APB1ENSETR_I2C1EN		BIT(21)
-#define RCC_MP_APB1ENSETR_I2C2EN		BIT(22)
-#define RCC_MP_APB1ENSETR_I2C3EN		BIT(23)
-#define RCC_MP_APB1ENSETR_I2C5EN		BIT(24)
-#define RCC_MP_APB1ENSETR_SPDIFEN		BIT(26)
-#define RCC_MP_APB1ENSETR_CECEN			BIT(27)
-#define RCC_MP_APB1ENSETR_DAC12EN		BIT(29)
-#define RCC_MP_APB1ENSETR_MDIOSEN		BIT(31)
-
-/* RCC_MP_APB1ENCLRR register fields */
-#define RCC_MP_APB1ENCLRR_TIM2EN		BIT(0)
-#define RCC_MP_APB1ENCLRR_TIM3EN		BIT(1)
-#define RCC_MP_APB1ENCLRR_TIM4EN		BIT(2)
-#define RCC_MP_APB1ENCLRR_TIM5EN		BIT(3)
-#define RCC_MP_APB1ENCLRR_TIM6EN		BIT(4)
-#define RCC_MP_APB1ENCLRR_TIM7EN		BIT(5)
-#define RCC_MP_APB1ENCLRR_TIM12EN		BIT(6)
-#define RCC_MP_APB1ENCLRR_TIM13EN		BIT(7)
-#define RCC_MP_APB1ENCLRR_TIM14EN		BIT(8)
-#define RCC_MP_APB1ENCLRR_LPTIM1EN		BIT(9)
-#define RCC_MP_APB1ENCLRR_SPI2EN		BIT(11)
-#define RCC_MP_APB1ENCLRR_SPI3EN		BIT(12)
-#define RCC_MP_APB1ENCLRR_USART2EN		BIT(14)
-#define RCC_MP_APB1ENCLRR_USART3EN		BIT(15)
-#define RCC_MP_APB1ENCLRR_UART4EN		BIT(16)
-#define RCC_MP_APB1ENCLRR_UART5EN		BIT(17)
-#define RCC_MP_APB1ENCLRR_UART7EN		BIT(18)
-#define RCC_MP_APB1ENCLRR_UART8EN		BIT(19)
-#define RCC_MP_APB1ENCLRR_I2C1EN		BIT(21)
-#define RCC_MP_APB1ENCLRR_I2C2EN		BIT(22)
-#define RCC_MP_APB1ENCLRR_I2C3EN		BIT(23)
-#define RCC_MP_APB1ENCLRR_I2C5EN		BIT(24)
-#define RCC_MP_APB1ENCLRR_SPDIFEN		BIT(26)
-#define RCC_MP_APB1ENCLRR_CECEN			BIT(27)
-#define RCC_MP_APB1ENCLRR_DAC12EN		BIT(29)
-#define RCC_MP_APB1ENCLRR_MDIOSEN		BIT(31)
-
-/* RCC_MP_APB2ENSETR register fields */
-#define RCC_MP_APB2ENSETR_TIM1EN		BIT(0)
-#define RCC_MP_APB2ENSETR_TIM8EN		BIT(1)
-#define RCC_MP_APB2ENSETR_TIM15EN		BIT(2)
-#define RCC_MP_APB2ENSETR_TIM16EN		BIT(3)
-#define RCC_MP_APB2ENSETR_TIM17EN		BIT(4)
-#define RCC_MP_APB2ENSETR_SPI1EN		BIT(8)
-#define RCC_MP_APB2ENSETR_SPI4EN		BIT(9)
-#define RCC_MP_APB2ENSETR_SPI5EN		BIT(10)
-#define RCC_MP_APB2ENSETR_USART6EN		BIT(13)
-#define RCC_MP_APB2ENSETR_SAI1EN		BIT(16)
-#define RCC_MP_APB2ENSETR_SAI2EN		BIT(17)
-#define RCC_MP_APB2ENSETR_SAI3EN		BIT(18)
-#define RCC_MP_APB2ENSETR_DFSDMEN		BIT(20)
-#define RCC_MP_APB2ENSETR_ADFSDMEN		BIT(21)
-#define RCC_MP_APB2ENSETR_FDCANEN		BIT(24)
-
-/* RCC_MP_APB2ENCLRR register fields */
-#define RCC_MP_APB2ENCLRR_TIM1EN		BIT(0)
-#define RCC_MP_APB2ENCLRR_TIM8EN		BIT(1)
-#define RCC_MP_APB2ENCLRR_TIM15EN		BIT(2)
-#define RCC_MP_APB2ENCLRR_TIM16EN		BIT(3)
-#define RCC_MP_APB2ENCLRR_TIM17EN		BIT(4)
-#define RCC_MP_APB2ENCLRR_SPI1EN		BIT(8)
-#define RCC_MP_APB2ENCLRR_SPI4EN		BIT(9)
-#define RCC_MP_APB2ENCLRR_SPI5EN		BIT(10)
-#define RCC_MP_APB2ENCLRR_USART6EN		BIT(13)
-#define RCC_MP_APB2ENCLRR_SAI1EN		BIT(16)
-#define RCC_MP_APB2ENCLRR_SAI2EN		BIT(17)
-#define RCC_MP_APB2ENCLRR_SAI3EN		BIT(18)
-#define RCC_MP_APB2ENCLRR_DFSDMEN		BIT(20)
-#define RCC_MP_APB2ENCLRR_ADFSDMEN		BIT(21)
-#define RCC_MP_APB2ENCLRR_FDCANEN		BIT(24)
-
-/* RCC_MP_APB3ENSETR register fields */
-#define RCC_MP_APB3ENSETR_LPTIM2EN		BIT(0)
-#define RCC_MP_APB3ENSETR_LPTIM3EN		BIT(1)
-#define RCC_MP_APB3ENSETR_LPTIM4EN		BIT(2)
-#define RCC_MP_APB3ENSETR_LPTIM5EN		BIT(3)
-#define RCC_MP_APB3ENSETR_SAI4EN		BIT(8)
-#define RCC_MP_APB3ENSETR_SYSCFGEN		BIT(11)
-#define RCC_MP_APB3ENSETR_VREFEN		BIT(13)
-#define RCC_MP_APB3ENSETR_TMPSENSEN		BIT(16)
-#define RCC_MP_APB3ENSETR_PMBCTRLEN		BIT(17)
-#define RCC_MP_APB3ENSETR_HDPEN			BIT(20)
-
-/* RCC_MP_APB3ENCLRR register fields */
-#define RCC_MP_APB3ENCLRR_LPTIM2EN		BIT(0)
-#define RCC_MP_APB3ENCLRR_LPTIM3EN		BIT(1)
-#define RCC_MP_APB3ENCLRR_LPTIM4EN		BIT(2)
-#define RCC_MP_APB3ENCLRR_LPTIM5EN		BIT(3)
-#define RCC_MP_APB3ENCLRR_SAI4EN		BIT(8)
-#define RCC_MP_APB3ENCLRR_SYSCFGEN		BIT(11)
-#define RCC_MP_APB3ENCLRR_VREFEN		BIT(13)
-#define RCC_MP_APB3ENCLRR_TMPSENSEN		BIT(16)
-#define RCC_MP_APB3ENCLRR_PMBCTRLEN		BIT(17)
-#define RCC_MP_APB3ENCLRR_HDPEN			BIT(20)
-
-/* RCC_MP_AHB2ENSETR register fields */
-#define RCC_MP_AHB2ENSETR_DMA1EN		BIT(0)
-#define RCC_MP_AHB2ENSETR_DMA2EN		BIT(1)
-#define RCC_MP_AHB2ENSETR_DMAMUXEN		BIT(2)
-#define RCC_MP_AHB2ENSETR_ADC12EN		BIT(5)
-#define RCC_MP_AHB2ENSETR_USBOEN		BIT(8)
-#define RCC_MP_AHB2ENSETR_SDMMC3EN		BIT(16)
-
-/* RCC_MP_AHB2ENCLRR register fields */
-#define RCC_MP_AHB2ENCLRR_DMA1EN		BIT(0)
-#define RCC_MP_AHB2ENCLRR_DMA2EN		BIT(1)
-#define RCC_MP_AHB2ENCLRR_DMAMUXEN		BIT(2)
-#define RCC_MP_AHB2ENCLRR_ADC12EN		BIT(5)
-#define RCC_MP_AHB2ENCLRR_USBOEN		BIT(8)
-#define RCC_MP_AHB2ENCLRR_SDMMC3EN		BIT(16)
-
-/* RCC_MP_AHB3ENSETR register fields */
-#define RCC_MP_AHB3ENSETR_DCMIEN		BIT(0)
-#define RCC_MP_AHB3ENSETR_CRYP2EN		BIT(4)
-#define RCC_MP_AHB3ENSETR_HASH2EN		BIT(5)
-#define RCC_MP_AHB3ENSETR_RNG2EN		BIT(6)
-#define RCC_MP_AHB3ENSETR_CRC2EN		BIT(7)
-#define RCC_MP_AHB3ENSETR_HSEMEN		BIT(11)
-#define RCC_MP_AHB3ENSETR_IPCCEN		BIT(12)
-
-/* RCC_MP_AHB3ENCLRR register fields */
-#define RCC_MP_AHB3ENCLRR_DCMIEN		BIT(0)
-#define RCC_MP_AHB3ENCLRR_CRYP2EN		BIT(4)
-#define RCC_MP_AHB3ENCLRR_HASH2EN		BIT(5)
-#define RCC_MP_AHB3ENCLRR_RNG2EN		BIT(6)
-#define RCC_MP_AHB3ENCLRR_CRC2EN		BIT(7)
-#define RCC_MP_AHB3ENCLRR_HSEMEN		BIT(11)
-#define RCC_MP_AHB3ENCLRR_IPCCEN		BIT(12)
-
-/* RCC_MP_AHB4ENSETR register fields */
-#define RCC_MP_AHB4ENSETR_GPIOAEN		BIT(0)
-#define RCC_MP_AHB4ENSETR_GPIOBEN		BIT(1)
-#define RCC_MP_AHB4ENSETR_GPIOCEN		BIT(2)
-#define RCC_MP_AHB4ENSETR_GPIODEN		BIT(3)
-#define RCC_MP_AHB4ENSETR_GPIOEEN		BIT(4)
-#define RCC_MP_AHB4ENSETR_GPIOFEN		BIT(5)
-#define RCC_MP_AHB4ENSETR_GPIOGEN		BIT(6)
-#define RCC_MP_AHB4ENSETR_GPIOHEN		BIT(7)
-#define RCC_MP_AHB4ENSETR_GPIOIEN		BIT(8)
-#define RCC_MP_AHB4ENSETR_GPIOJEN		BIT(9)
-#define RCC_MP_AHB4ENSETR_GPIOKEN		BIT(10)
-
-/* RCC_MP_AHB4ENCLRR register fields */
-#define RCC_MP_AHB4ENCLRR_GPIOAEN		BIT(0)
-#define RCC_MP_AHB4ENCLRR_GPIOBEN		BIT(1)
-#define RCC_MP_AHB4ENCLRR_GPIOCEN		BIT(2)
-#define RCC_MP_AHB4ENCLRR_GPIODEN		BIT(3)
-#define RCC_MP_AHB4ENCLRR_GPIOEEN		BIT(4)
-#define RCC_MP_AHB4ENCLRR_GPIOFEN		BIT(5)
-#define RCC_MP_AHB4ENCLRR_GPIOGEN		BIT(6)
-#define RCC_MP_AHB4ENCLRR_GPIOHEN		BIT(7)
-#define RCC_MP_AHB4ENCLRR_GPIOIEN		BIT(8)
-#define RCC_MP_AHB4ENCLRR_GPIOJEN		BIT(9)
-#define RCC_MP_AHB4ENCLRR_GPIOKEN		BIT(10)
-
-/* RCC_MP_MLAHBENSETR register fields */
-#define RCC_MP_MLAHBENSETR_RETRAMEN		BIT(4)
-
-/* RCC_MP_MLAHBENCLRR register fields */
-#define RCC_MP_MLAHBENCLRR_RETRAMEN		BIT(4)
-
-/* RCC_MC_APB1ENSETR register fields */
-#define RCC_MC_APB1ENSETR_TIM2EN		BIT(0)
-#define RCC_MC_APB1ENSETR_TIM3EN		BIT(1)
-#define RCC_MC_APB1ENSETR_TIM4EN		BIT(2)
-#define RCC_MC_APB1ENSETR_TIM5EN		BIT(3)
-#define RCC_MC_APB1ENSETR_TIM6EN		BIT(4)
-#define RCC_MC_APB1ENSETR_TIM7EN		BIT(5)
-#define RCC_MC_APB1ENSETR_TIM12EN		BIT(6)
-#define RCC_MC_APB1ENSETR_TIM13EN		BIT(7)
-#define RCC_MC_APB1ENSETR_TIM14EN		BIT(8)
-#define RCC_MC_APB1ENSETR_LPTIM1EN		BIT(9)
-#define RCC_MC_APB1ENSETR_SPI2EN		BIT(11)
-#define RCC_MC_APB1ENSETR_SPI3EN		BIT(12)
-#define RCC_MC_APB1ENSETR_USART2EN		BIT(14)
-#define RCC_MC_APB1ENSETR_USART3EN		BIT(15)
-#define RCC_MC_APB1ENSETR_UART4EN		BIT(16)
-#define RCC_MC_APB1ENSETR_UART5EN		BIT(17)
-#define RCC_MC_APB1ENSETR_UART7EN		BIT(18)
-#define RCC_MC_APB1ENSETR_UART8EN		BIT(19)
-#define RCC_MC_APB1ENSETR_I2C1EN		BIT(21)
-#define RCC_MC_APB1ENSETR_I2C2EN		BIT(22)
-#define RCC_MC_APB1ENSETR_I2C3EN		BIT(23)
-#define RCC_MC_APB1ENSETR_I2C5EN		BIT(24)
-#define RCC_MC_APB1ENSETR_SPDIFEN		BIT(26)
-#define RCC_MC_APB1ENSETR_CECEN			BIT(27)
-#define RCC_MC_APB1ENSETR_WWDG1EN		BIT(28)
-#define RCC_MC_APB1ENSETR_DAC12EN		BIT(29)
-#define RCC_MC_APB1ENSETR_MDIOSEN		BIT(31)
-
-/* RCC_MC_APB1ENCLRR register fields */
-#define RCC_MC_APB1ENCLRR_TIM2EN		BIT(0)
-#define RCC_MC_APB1ENCLRR_TIM3EN		BIT(1)
-#define RCC_MC_APB1ENCLRR_TIM4EN		BIT(2)
-#define RCC_MC_APB1ENCLRR_TIM5EN		BIT(3)
-#define RCC_MC_APB1ENCLRR_TIM6EN		BIT(4)
-#define RCC_MC_APB1ENCLRR_TIM7EN		BIT(5)
-#define RCC_MC_APB1ENCLRR_TIM12EN		BIT(6)
-#define RCC_MC_APB1ENCLRR_TIM13EN		BIT(7)
-#define RCC_MC_APB1ENCLRR_TIM14EN		BIT(8)
-#define RCC_MC_APB1ENCLRR_LPTIM1EN		BIT(9)
-#define RCC_MC_APB1ENCLRR_SPI2EN		BIT(11)
-#define RCC_MC_APB1ENCLRR_SPI3EN		BIT(12)
-#define RCC_MC_APB1ENCLRR_USART2EN		BIT(14)
-#define RCC_MC_APB1ENCLRR_USART3EN		BIT(15)
-#define RCC_MC_APB1ENCLRR_UART4EN		BIT(16)
-#define RCC_MC_APB1ENCLRR_UART5EN		BIT(17)
-#define RCC_MC_APB1ENCLRR_UART7EN		BIT(18)
-#define RCC_MC_APB1ENCLRR_UART8EN		BIT(19)
-#define RCC_MC_APB1ENCLRR_I2C1EN		BIT(21)
-#define RCC_MC_APB1ENCLRR_I2C2EN		BIT(22)
-#define RCC_MC_APB1ENCLRR_I2C3EN		BIT(23)
-#define RCC_MC_APB1ENCLRR_I2C5EN		BIT(24)
-#define RCC_MC_APB1ENCLRR_SPDIFEN		BIT(26)
-#define RCC_MC_APB1ENCLRR_CECEN			BIT(27)
-#define RCC_MC_APB1ENCLRR_DAC12EN		BIT(29)
-#define RCC_MC_APB1ENCLRR_MDIOSEN		BIT(31)
-
-/* RCC_MC_APB2ENSETR register fields */
-#define RCC_MC_APB2ENSETR_TIM1EN		BIT(0)
-#define RCC_MC_APB2ENSETR_TIM8EN		BIT(1)
-#define RCC_MC_APB2ENSETR_TIM15EN		BIT(2)
-#define RCC_MC_APB2ENSETR_TIM16EN		BIT(3)
-#define RCC_MC_APB2ENSETR_TIM17EN		BIT(4)
-#define RCC_MC_APB2ENSETR_SPI1EN		BIT(8)
-#define RCC_MC_APB2ENSETR_SPI4EN		BIT(9)
-#define RCC_MC_APB2ENSETR_SPI5EN		BIT(10)
-#define RCC_MC_APB2ENSETR_USART6EN		BIT(13)
-#define RCC_MC_APB2ENSETR_SAI1EN		BIT(16)
-#define RCC_MC_APB2ENSETR_SAI2EN		BIT(17)
-#define RCC_MC_APB2ENSETR_SAI3EN		BIT(18)
-#define RCC_MC_APB2ENSETR_DFSDMEN		BIT(20)
-#define RCC_MC_APB2ENSETR_ADFSDMEN		BIT(21)
-#define RCC_MC_APB2ENSETR_FDCANEN		BIT(24)
-
-/* RCC_MC_APB2ENCLRR register fields */
-#define RCC_MC_APB2ENCLRR_TIM1EN		BIT(0)
-#define RCC_MC_APB2ENCLRR_TIM8EN		BIT(1)
-#define RCC_MC_APB2ENCLRR_TIM15EN		BIT(2)
-#define RCC_MC_APB2ENCLRR_TIM16EN		BIT(3)
-#define RCC_MC_APB2ENCLRR_TIM17EN		BIT(4)
-#define RCC_MC_APB2ENCLRR_SPI1EN		BIT(8)
-#define RCC_MC_APB2ENCLRR_SPI4EN		BIT(9)
-#define RCC_MC_APB2ENCLRR_SPI5EN		BIT(10)
-#define RCC_MC_APB2ENCLRR_USART6EN		BIT(13)
-#define RCC_MC_APB2ENCLRR_SAI1EN		BIT(16)
-#define RCC_MC_APB2ENCLRR_SAI2EN		BIT(17)
-#define RCC_MC_APB2ENCLRR_SAI3EN		BIT(18)
-#define RCC_MC_APB2ENCLRR_DFSDMEN		BIT(20)
-#define RCC_MC_APB2ENCLRR_ADFSDMEN		BIT(21)
-#define RCC_MC_APB2ENCLRR_FDCANEN		BIT(24)
-
-/* RCC_MC_APB3ENSETR register fields */
-#define RCC_MC_APB3ENSETR_LPTIM2EN		BIT(0)
-#define RCC_MC_APB3ENSETR_LPTIM3EN		BIT(1)
-#define RCC_MC_APB3ENSETR_LPTIM4EN		BIT(2)
-#define RCC_MC_APB3ENSETR_LPTIM5EN		BIT(3)
-#define RCC_MC_APB3ENSETR_SAI4EN		BIT(8)
-#define RCC_MC_APB3ENSETR_SYSCFGEN		BIT(11)
-#define RCC_MC_APB3ENSETR_VREFEN		BIT(13)
-#define RCC_MC_APB3ENSETR_TMPSENSEN		BIT(16)
-#define RCC_MC_APB3ENSETR_PMBCTRLEN		BIT(17)
-#define RCC_MC_APB3ENSETR_HDPEN			BIT(20)
-
-/* RCC_MC_APB3ENCLRR register fields */
-#define RCC_MC_APB3ENCLRR_LPTIM2EN		BIT(0)
-#define RCC_MC_APB3ENCLRR_LPTIM3EN		BIT(1)
-#define RCC_MC_APB3ENCLRR_LPTIM4EN		BIT(2)
-#define RCC_MC_APB3ENCLRR_LPTIM5EN		BIT(3)
-#define RCC_MC_APB3ENCLRR_SAI4EN		BIT(8)
-#define RCC_MC_APB3ENCLRR_SYSCFGEN		BIT(11)
-#define RCC_MC_APB3ENCLRR_VREFEN		BIT(13)
-#define RCC_MC_APB3ENCLRR_TMPSENSEN		BIT(16)
-#define RCC_MC_APB3ENCLRR_PMBCTRLEN		BIT(17)
-#define RCC_MC_APB3ENCLRR_HDPEN			BIT(20)
-
-/* RCC_MC_AHB2ENSETR register fields */
-#define RCC_MC_AHB2ENSETR_DMA1EN		BIT(0)
-#define RCC_MC_AHB2ENSETR_DMA2EN		BIT(1)
-#define RCC_MC_AHB2ENSETR_DMAMUXEN		BIT(2)
-#define RCC_MC_AHB2ENSETR_ADC12EN		BIT(5)
-#define RCC_MC_AHB2ENSETR_USBOEN		BIT(8)
-#define RCC_MC_AHB2ENSETR_SDMMC3EN		BIT(16)
-
-/* RCC_MC_AHB2ENCLRR register fields */
-#define RCC_MC_AHB2ENCLRR_DMA1EN		BIT(0)
-#define RCC_MC_AHB2ENCLRR_DMA2EN		BIT(1)
-#define RCC_MC_AHB2ENCLRR_DMAMUXEN		BIT(2)
-#define RCC_MC_AHB2ENCLRR_ADC12EN		BIT(5)
-#define RCC_MC_AHB2ENCLRR_USBOEN		BIT(8)
-#define RCC_MC_AHB2ENCLRR_SDMMC3EN		BIT(16)
-
-/* RCC_MC_AHB3ENSETR register fields */
-#define RCC_MC_AHB3ENSETR_DCMIEN		BIT(0)
-#define RCC_MC_AHB3ENSETR_CRYP2EN		BIT(4)
-#define RCC_MC_AHB3ENSETR_HASH2EN		BIT(5)
-#define RCC_MC_AHB3ENSETR_RNG2EN		BIT(6)
-#define RCC_MC_AHB3ENSETR_CRC2EN		BIT(7)
-#define RCC_MC_AHB3ENSETR_HSEMEN		BIT(11)
-#define RCC_MC_AHB3ENSETR_IPCCEN		BIT(12)
-
-/* RCC_MC_AHB3ENCLRR register fields */
-#define RCC_MC_AHB3ENCLRR_DCMIEN		BIT(0)
-#define RCC_MC_AHB3ENCLRR_CRYP2EN		BIT(4)
-#define RCC_MC_AHB3ENCLRR_HASH2EN		BIT(5)
-#define RCC_MC_AHB3ENCLRR_RNG2EN		BIT(6)
-#define RCC_MC_AHB3ENCLRR_CRC2EN		BIT(7)
-#define RCC_MC_AHB3ENCLRR_HSEMEN		BIT(11)
-#define RCC_MC_AHB3ENCLRR_IPCCEN		BIT(12)
-
-/* RCC_MC_AHB4ENSETR register fields */
-#define RCC_MC_AHB4ENSETR_GPIOAEN		BIT(0)
-#define RCC_MC_AHB4ENSETR_GPIOBEN		BIT(1)
-#define RCC_MC_AHB4ENSETR_GPIOCEN		BIT(2)
-#define RCC_MC_AHB4ENSETR_GPIODEN		BIT(3)
-#define RCC_MC_AHB4ENSETR_GPIOEEN		BIT(4)
-#define RCC_MC_AHB4ENSETR_GPIOFEN		BIT(5)
-#define RCC_MC_AHB4ENSETR_GPIOGEN		BIT(6)
-#define RCC_MC_AHB4ENSETR_GPIOHEN		BIT(7)
-#define RCC_MC_AHB4ENSETR_GPIOIEN		BIT(8)
-#define RCC_MC_AHB4ENSETR_GPIOJEN		BIT(9)
-#define RCC_MC_AHB4ENSETR_GPIOKEN		BIT(10)
-
-/* RCC_MC_AHB4ENCLRR register fields */
-#define RCC_MC_AHB4ENCLRR_GPIOAEN		BIT(0)
-#define RCC_MC_AHB4ENCLRR_GPIOBEN		BIT(1)
-#define RCC_MC_AHB4ENCLRR_GPIOCEN		BIT(2)
-#define RCC_MC_AHB4ENCLRR_GPIODEN		BIT(3)
-#define RCC_MC_AHB4ENCLRR_GPIOEEN		BIT(4)
-#define RCC_MC_AHB4ENCLRR_GPIOFEN		BIT(5)
-#define RCC_MC_AHB4ENCLRR_GPIOGEN		BIT(6)
-#define RCC_MC_AHB4ENCLRR_GPIOHEN		BIT(7)
-#define RCC_MC_AHB4ENCLRR_GPIOIEN		BIT(8)
-#define RCC_MC_AHB4ENCLRR_GPIOJEN		BIT(9)
-#define RCC_MC_AHB4ENCLRR_GPIOKEN		BIT(10)
-
-/* RCC_MC_AXIMENSETR register fields */
-#define RCC_MC_AXIMENSETR_SYSRAMEN		BIT(0)
-
-/* RCC_MC_AXIMENCLRR register fields */
-#define RCC_MC_AXIMENCLRR_SYSRAMEN		BIT(0)
-
-/* RCC_MC_MLAHBENSETR register fields */
-#define RCC_MC_MLAHBENSETR_RETRAMEN		BIT(4)
-
-/* RCC_MC_MLAHBENCLRR register fields */
-#define RCC_MC_MLAHBENCLRR_RETRAMEN		BIT(4)
-
-/* RCC_MP_APB1LPENSETR register fields */
-#define RCC_MP_APB1LPENSETR_TIM2LPEN		BIT(0)
-#define RCC_MP_APB1LPENSETR_TIM3LPEN		BIT(1)
-#define RCC_MP_APB1LPENSETR_TIM4LPEN		BIT(2)
-#define RCC_MP_APB1LPENSETR_TIM5LPEN		BIT(3)
-#define RCC_MP_APB1LPENSETR_TIM6LPEN		BIT(4)
-#define RCC_MP_APB1LPENSETR_TIM7LPEN		BIT(5)
-#define RCC_MP_APB1LPENSETR_TIM12LPEN		BIT(6)
-#define RCC_MP_APB1LPENSETR_TIM13LPEN		BIT(7)
-#define RCC_MP_APB1LPENSETR_TIM14LPEN		BIT(8)
-#define RCC_MP_APB1LPENSETR_LPTIM1LPEN		BIT(9)
-#define RCC_MP_APB1LPENSETR_SPI2LPEN		BIT(11)
-#define RCC_MP_APB1LPENSETR_SPI3LPEN		BIT(12)
-#define RCC_MP_APB1LPENSETR_USART2LPEN		BIT(14)
-#define RCC_MP_APB1LPENSETR_USART3LPEN		BIT(15)
-#define RCC_MP_APB1LPENSETR_UART4LPEN		BIT(16)
-#define RCC_MP_APB1LPENSETR_UART5LPEN		BIT(17)
-#define RCC_MP_APB1LPENSETR_UART7LPEN		BIT(18)
-#define RCC_MP_APB1LPENSETR_UART8LPEN		BIT(19)
-#define RCC_MP_APB1LPENSETR_I2C1LPEN		BIT(21)
-#define RCC_MP_APB1LPENSETR_I2C2LPEN		BIT(22)
-#define RCC_MP_APB1LPENSETR_I2C3LPEN		BIT(23)
-#define RCC_MP_APB1LPENSETR_I2C5LPEN		BIT(24)
-#define RCC_MP_APB1LPENSETR_SPDIFLPEN		BIT(26)
-#define RCC_MP_APB1LPENSETR_CECLPEN		BIT(27)
-#define RCC_MP_APB1LPENSETR_DAC12LPEN		BIT(29)
-#define RCC_MP_APB1LPENSETR_MDIOSLPEN		BIT(31)
-
-/* RCC_MP_APB1LPENCLRR register fields */
-#define RCC_MP_APB1LPENCLRR_TIM2LPEN		BIT(0)
-#define RCC_MP_APB1LPENCLRR_TIM3LPEN		BIT(1)
-#define RCC_MP_APB1LPENCLRR_TIM4LPEN		BIT(2)
-#define RCC_MP_APB1LPENCLRR_TIM5LPEN		BIT(3)
-#define RCC_MP_APB1LPENCLRR_TIM6LPEN		BIT(4)
-#define RCC_MP_APB1LPENCLRR_TIM7LPEN		BIT(5)
-#define RCC_MP_APB1LPENCLRR_TIM12LPEN		BIT(6)
-#define RCC_MP_APB1LPENCLRR_TIM13LPEN		BIT(7)
-#define RCC_MP_APB1LPENCLRR_TIM14LPEN		BIT(8)
-#define RCC_MP_APB1LPENCLRR_LPTIM1LPEN		BIT(9)
-#define RCC_MP_APB1LPENCLRR_SPI2LPEN		BIT(11)
-#define RCC_MP_APB1LPENCLRR_SPI3LPEN		BIT(12)
-#define RCC_MP_APB1LPENCLRR_USART2LPEN		BIT(14)
-#define RCC_MP_APB1LPENCLRR_USART3LPEN		BIT(15)
-#define RCC_MP_APB1LPENCLRR_UART4LPEN		BIT(16)
-#define RCC_MP_APB1LPENCLRR_UART5LPEN		BIT(17)
-#define RCC_MP_APB1LPENCLRR_UART7LPEN		BIT(18)
-#define RCC_MP_APB1LPENCLRR_UART8LPEN		BIT(19)
-#define RCC_MP_APB1LPENCLRR_I2C1LPEN		BIT(21)
-#define RCC_MP_APB1LPENCLRR_I2C2LPEN		BIT(22)
-#define RCC_MP_APB1LPENCLRR_I2C3LPEN		BIT(23)
-#define RCC_MP_APB1LPENCLRR_I2C5LPEN		BIT(24)
-#define RCC_MP_APB1LPENCLRR_SPDIFLPEN		BIT(26)
-#define RCC_MP_APB1LPENCLRR_CECLPEN		BIT(27)
-#define RCC_MP_APB1LPENCLRR_DAC12LPEN		BIT(29)
-#define RCC_MP_APB1LPENCLRR_MDIOSLPEN		BIT(31)
-
-/* RCC_MP_APB2LPENSETR register fields */
-#define RCC_MP_APB2LPENSETR_TIM1LPEN		BIT(0)
-#define RCC_MP_APB2LPENSETR_TIM8LPEN		BIT(1)
-#define RCC_MP_APB2LPENSETR_TIM15LPEN		BIT(2)
-#define RCC_MP_APB2LPENSETR_TIM16LPEN		BIT(3)
-#define RCC_MP_APB2LPENSETR_TIM17LPEN		BIT(4)
-#define RCC_MP_APB2LPENSETR_SPI1LPEN		BIT(8)
-#define RCC_MP_APB2LPENSETR_SPI4LPEN		BIT(9)
-#define RCC_MP_APB2LPENSETR_SPI5LPEN		BIT(10)
-#define RCC_MP_APB2LPENSETR_USART6LPEN		BIT(13)
-#define RCC_MP_APB2LPENSETR_SAI1LPEN		BIT(16)
-#define RCC_MP_APB2LPENSETR_SAI2LPEN		BIT(17)
-#define RCC_MP_APB2LPENSETR_SAI3LPEN		BIT(18)
-#define RCC_MP_APB2LPENSETR_DFSDMLPEN		BIT(20)
-#define RCC_MP_APB2LPENSETR_ADFSDMLPEN		BIT(21)
-#define RCC_MP_APB2LPENSETR_FDCANLPEN		BIT(24)
-
-/* RCC_MP_APB2LPENCLRR register fields */
-#define RCC_MP_APB2LPENCLRR_TIM1LPEN		BIT(0)
-#define RCC_MP_APB2LPENCLRR_TIM8LPEN		BIT(1)
-#define RCC_MP_APB2LPENCLRR_TIM15LPEN		BIT(2)
-#define RCC_MP_APB2LPENCLRR_TIM16LPEN		BIT(3)
-#define RCC_MP_APB2LPENCLRR_TIM17LPEN		BIT(4)
-#define RCC_MP_APB2LPENCLRR_SPI1LPEN		BIT(8)
-#define RCC_MP_APB2LPENCLRR_SPI4LPEN		BIT(9)
-#define RCC_MP_APB2LPENCLRR_SPI5LPEN		BIT(10)
-#define RCC_MP_APB2LPENCLRR_USART6LPEN		BIT(13)
-#define RCC_MP_APB2LPENCLRR_SAI1LPEN		BIT(16)
-#define RCC_MP_APB2LPENCLRR_SAI2LPEN		BIT(17)
-#define RCC_MP_APB2LPENCLRR_SAI3LPEN		BIT(18)
-#define RCC_MP_APB2LPENCLRR_DFSDMLPEN		BIT(20)
-#define RCC_MP_APB2LPENCLRR_ADFSDMLPEN		BIT(21)
-#define RCC_MP_APB2LPENCLRR_FDCANLPEN		BIT(24)
-
-/* RCC_MP_APB3LPENSETR register fields */
-#define RCC_MP_APB3LPENSETR_LPTIM2LPEN		BIT(0)
-#define RCC_MP_APB3LPENSETR_LPTIM3LPEN		BIT(1)
-#define RCC_MP_APB3LPENSETR_LPTIM4LPEN		BIT(2)
-#define RCC_MP_APB3LPENSETR_LPTIM5LPEN		BIT(3)
-#define RCC_MP_APB3LPENSETR_SAI4LPEN		BIT(8)
-#define RCC_MP_APB3LPENSETR_SYSCFGLPEN		BIT(11)
-#define RCC_MP_APB3LPENSETR_VREFLPEN		BIT(13)
-#define RCC_MP_APB3LPENSETR_TMPSENSLPEN		BIT(16)
-#define RCC_MP_APB3LPENSETR_PMBCTRLLPEN		BIT(17)
-
-/* RCC_MP_APB3LPENCLRR register fields */
-#define RCC_MP_APB3LPENCLRR_LPTIM2LPEN		BIT(0)
-#define RCC_MP_APB3LPENCLRR_LPTIM3LPEN		BIT(1)
-#define RCC_MP_APB3LPENCLRR_LPTIM4LPEN		BIT(2)
-#define RCC_MP_APB3LPENCLRR_LPTIM5LPEN		BIT(3)
-#define RCC_MP_APB3LPENCLRR_SAI4LPEN		BIT(8)
-#define RCC_MP_APB3LPENCLRR_SYSCFGLPEN		BIT(11)
-#define RCC_MP_APB3LPENCLRR_VREFLPEN		BIT(13)
-#define RCC_MP_APB3LPENCLRR_TMPSENSLPEN		BIT(16)
-#define RCC_MP_APB3LPENCLRR_PMBCTRLLPEN		BIT(17)
-
-/* RCC_MP_AHB2LPENSETR register fields */
-#define RCC_MP_AHB2LPENSETR_DMA1LPEN		BIT(0)
-#define RCC_MP_AHB2LPENSETR_DMA2LPEN		BIT(1)
-#define RCC_MP_AHB2LPENSETR_DMAMUXLPEN		BIT(2)
-#define RCC_MP_AHB2LPENSETR_ADC12LPEN		BIT(5)
-#define RCC_MP_AHB2LPENSETR_USBOLPEN		BIT(8)
-#define RCC_MP_AHB2LPENSETR_SDMMC3LPEN		BIT(16)
-
-/* RCC_MP_AHB2LPENCLRR register fields */
-#define RCC_MP_AHB2LPENCLRR_DMA1LPEN		BIT(0)
-#define RCC_MP_AHB2LPENCLRR_DMA2LPEN		BIT(1)
-#define RCC_MP_AHB2LPENCLRR_DMAMUXLPEN		BIT(2)
-#define RCC_MP_AHB2LPENCLRR_ADC12LPEN		BIT(5)
-#define RCC_MP_AHB2LPENCLRR_USBOLPEN		BIT(8)
-#define RCC_MP_AHB2LPENCLRR_SDMMC3LPEN		BIT(16)
-
-/* RCC_MP_AHB3LPENSETR register fields */
-#define RCC_MP_AHB3LPENSETR_DCMILPEN		BIT(0)
-#define RCC_MP_AHB3LPENSETR_CRYP2LPEN		BIT(4)
-#define RCC_MP_AHB3LPENSETR_HASH2LPEN		BIT(5)
-#define RCC_MP_AHB3LPENSETR_RNG2LPEN		BIT(6)
-#define RCC_MP_AHB3LPENSETR_CRC2LPEN		BIT(7)
-#define RCC_MP_AHB3LPENSETR_HSEMLPEN		BIT(11)
-#define RCC_MP_AHB3LPENSETR_IPCCLPEN		BIT(12)
-
-/* RCC_MP_AHB3LPENCLRR register fields */
-#define RCC_MP_AHB3LPENCLRR_DCMILPEN		BIT(0)
-#define RCC_MP_AHB3LPENCLRR_CRYP2LPEN		BIT(4)
-#define RCC_MP_AHB3LPENCLRR_HASH2LPEN		BIT(5)
-#define RCC_MP_AHB3LPENCLRR_RNG2LPEN		BIT(6)
-#define RCC_MP_AHB3LPENCLRR_CRC2LPEN		BIT(7)
-#define RCC_MP_AHB3LPENCLRR_HSEMLPEN		BIT(11)
-#define RCC_MP_AHB3LPENCLRR_IPCCLPEN		BIT(12)
-
-/* RCC_MP_AHB4LPENSETR register fields */
-#define RCC_MP_AHB4LPENSETR_GPIOALPEN		BIT(0)
-#define RCC_MP_AHB4LPENSETR_GPIOBLPEN		BIT(1)
-#define RCC_MP_AHB4LPENSETR_GPIOCLPEN		BIT(2)
-#define RCC_MP_AHB4LPENSETR_GPIODLPEN		BIT(3)
-#define RCC_MP_AHB4LPENSETR_GPIOELPEN		BIT(4)
-#define RCC_MP_AHB4LPENSETR_GPIOFLPEN		BIT(5)
-#define RCC_MP_AHB4LPENSETR_GPIOGLPEN		BIT(6)
-#define RCC_MP_AHB4LPENSETR_GPIOHLPEN		BIT(7)
-#define RCC_MP_AHB4LPENSETR_GPIOILPEN		BIT(8)
-#define RCC_MP_AHB4LPENSETR_GPIOJLPEN		BIT(9)
-#define RCC_MP_AHB4LPENSETR_GPIOKLPEN		BIT(10)
-
-/* RCC_MP_AHB4LPENCLRR register fields */
-#define RCC_MP_AHB4LPENCLRR_GPIOALPEN		BIT(0)
-#define RCC_MP_AHB4LPENCLRR_GPIOBLPEN		BIT(1)
-#define RCC_MP_AHB4LPENCLRR_GPIOCLPEN		BIT(2)
-#define RCC_MP_AHB4LPENCLRR_GPIODLPEN		BIT(3)
-#define RCC_MP_AHB4LPENCLRR_GPIOELPEN		BIT(4)
-#define RCC_MP_AHB4LPENCLRR_GPIOFLPEN		BIT(5)
-#define RCC_MP_AHB4LPENCLRR_GPIOGLPEN		BIT(6)
-#define RCC_MP_AHB4LPENCLRR_GPIOHLPEN		BIT(7)
-#define RCC_MP_AHB4LPENCLRR_GPIOILPEN		BIT(8)
-#define RCC_MP_AHB4LPENCLRR_GPIOJLPEN		BIT(9)
-#define RCC_MP_AHB4LPENCLRR_GPIOKLPEN		BIT(10)
-
-/* RCC_MP_AXIMLPENSETR register fields */
-#define RCC_MP_AXIMLPENSETR_SYSRAMLPEN		BIT(0)
-
-/* RCC_MP_AXIMLPENCLRR register fields */
-#define RCC_MP_AXIMLPENCLRR_SYSRAMLPEN		BIT(0)
-
-/* RCC_MP_MLAHBLPENSETR register fields */
-#define RCC_MP_MLAHBLPENSETR_SRAM1LPEN		BIT(0)
-#define RCC_MP_MLAHBLPENSETR_SRAM2LPEN		BIT(1)
-#define RCC_MP_MLAHBLPENSETR_SRAM34LPEN		BIT(2)
-#define RCC_MP_MLAHBLPENSETR_RETRAMLPEN		BIT(4)
-
-/* RCC_MP_MLAHBLPENCLRR register fields */
-#define RCC_MP_MLAHBLPENCLRR_SRAM1LPEN		BIT(0)
-#define RCC_MP_MLAHBLPENCLRR_SRAM2LPEN		BIT(1)
-#define RCC_MP_MLAHBLPENCLRR_SRAM34LPEN		BIT(2)
-#define RCC_MP_MLAHBLPENCLRR_RETRAMLPEN		BIT(4)
-
-/* RCC_MC_APB1LPENSETR register fields */
-#define RCC_MC_APB1LPENSETR_TIM2LPEN		BIT(0)
-#define RCC_MC_APB1LPENSETR_TIM3LPEN		BIT(1)
-#define RCC_MC_APB1LPENSETR_TIM4LPEN		BIT(2)
-#define RCC_MC_APB1LPENSETR_TIM5LPEN		BIT(3)
-#define RCC_MC_APB1LPENSETR_TIM6LPEN		BIT(4)
-#define RCC_MC_APB1LPENSETR_TIM7LPEN		BIT(5)
-#define RCC_MC_APB1LPENSETR_TIM12LPEN		BIT(6)
-#define RCC_MC_APB1LPENSETR_TIM13LPEN		BIT(7)
-#define RCC_MC_APB1LPENSETR_TIM14LPEN		BIT(8)
-#define RCC_MC_APB1LPENSETR_LPTIM1LPEN		BIT(9)
-#define RCC_MC_APB1LPENSETR_SPI2LPEN		BIT(11)
-#define RCC_MC_APB1LPENSETR_SPI3LPEN		BIT(12)
-#define RCC_MC_APB1LPENSETR_USART2LPEN		BIT(14)
-#define RCC_MC_APB1LPENSETR_USART3LPEN		BIT(15)
-#define RCC_MC_APB1LPENSETR_UART4LPEN		BIT(16)
-#define RCC_MC_APB1LPENSETR_UART5LPEN		BIT(17)
-#define RCC_MC_APB1LPENSETR_UART7LPEN		BIT(18)
-#define RCC_MC_APB1LPENSETR_UART8LPEN		BIT(19)
-#define RCC_MC_APB1LPENSETR_I2C1LPEN		BIT(21)
-#define RCC_MC_APB1LPENSETR_I2C2LPEN		BIT(22)
-#define RCC_MC_APB1LPENSETR_I2C3LPEN		BIT(23)
-#define RCC_MC_APB1LPENSETR_I2C5LPEN		BIT(24)
-#define RCC_MC_APB1LPENSETR_SPDIFLPEN		BIT(26)
-#define RCC_MC_APB1LPENSETR_CECLPEN		BIT(27)
-#define RCC_MC_APB1LPENSETR_WWDG1LPEN		BIT(28)
-#define RCC_MC_APB1LPENSETR_DAC12LPEN		BIT(29)
-#define RCC_MC_APB1LPENSETR_MDIOSLPEN		BIT(31)
-
-/* RCC_MC_APB1LPENCLRR register fields */
-#define RCC_MC_APB1LPENCLRR_TIM2LPEN		BIT(0)
-#define RCC_MC_APB1LPENCLRR_TIM3LPEN		BIT(1)
-#define RCC_MC_APB1LPENCLRR_TIM4LPEN		BIT(2)
-#define RCC_MC_APB1LPENCLRR_TIM5LPEN		BIT(3)
-#define RCC_MC_APB1LPENCLRR_TIM6LPEN		BIT(4)
-#define RCC_MC_APB1LPENCLRR_TIM7LPEN		BIT(5)
-#define RCC_MC_APB1LPENCLRR_TIM12LPEN		BIT(6)
-#define RCC_MC_APB1LPENCLRR_TIM13LPEN		BIT(7)
-#define RCC_MC_APB1LPENCLRR_TIM14LPEN		BIT(8)
-#define RCC_MC_APB1LPENCLRR_LPTIM1LPEN		BIT(9)
-#define RCC_MC_APB1LPENCLRR_SPI2LPEN		BIT(11)
-#define RCC_MC_APB1LPENCLRR_SPI3LPEN		BIT(12)
-#define RCC_MC_APB1LPENCLRR_USART2LPEN		BIT(14)
-#define RCC_MC_APB1LPENCLRR_USART3LPEN		BIT(15)
-#define RCC_MC_APB1LPENCLRR_UART4LPEN		BIT(16)
-#define RCC_MC_APB1LPENCLRR_UART5LPEN		BIT(17)
-#define RCC_MC_APB1LPENCLRR_UART7LPEN		BIT(18)
-#define RCC_MC_APB1LPENCLRR_UART8LPEN		BIT(19)
-#define RCC_MC_APB1LPENCLRR_I2C1LPEN		BIT(21)
-#define RCC_MC_APB1LPENCLRR_I2C2LPEN		BIT(22)
-#define RCC_MC_APB1LPENCLRR_I2C3LPEN		BIT(23)
-#define RCC_MC_APB1LPENCLRR_I2C5LPEN		BIT(24)
-#define RCC_MC_APB1LPENCLRR_SPDIFLPEN		BIT(26)
-#define RCC_MC_APB1LPENCLRR_CECLPEN		BIT(27)
-#define RCC_MC_APB1LPENCLRR_WWDG1LPEN		BIT(28)
-#define RCC_MC_APB1LPENCLRR_DAC12LPEN		BIT(29)
-#define RCC_MC_APB1LPENCLRR_MDIOSLPEN		BIT(31)
-
-/* RCC_MC_APB2LPENSETR register fields */
-#define RCC_MC_APB2LPENSETR_TIM1LPEN		BIT(0)
-#define RCC_MC_APB2LPENSETR_TIM8LPEN		BIT(1)
-#define RCC_MC_APB2LPENSETR_TIM15LPEN		BIT(2)
-#define RCC_MC_APB2LPENSETR_TIM16LPEN		BIT(3)
-#define RCC_MC_APB2LPENSETR_TIM17LPEN		BIT(4)
-#define RCC_MC_APB2LPENSETR_SPI1LPEN		BIT(8)
-#define RCC_MC_APB2LPENSETR_SPI4LPEN		BIT(9)
-#define RCC_MC_APB2LPENSETR_SPI5LPEN		BIT(10)
-#define RCC_MC_APB2LPENSETR_USART6LPEN		BIT(13)
-#define RCC_MC_APB2LPENSETR_SAI1LPEN		BIT(16)
-#define RCC_MC_APB2LPENSETR_SAI2LPEN		BIT(17)
-#define RCC_MC_APB2LPENSETR_SAI3LPEN		BIT(18)
-#define RCC_MC_APB2LPENSETR_DFSDMLPEN		BIT(20)
-#define RCC_MC_APB2LPENSETR_ADFSDMLPEN		BIT(21)
-#define RCC_MC_APB2LPENSETR_FDCANLPEN		BIT(24)
-
-/* RCC_MC_APB2LPENCLRR register fields */
-#define RCC_MC_APB2LPENCLRR_TIM1LPEN		BIT(0)
-#define RCC_MC_APB2LPENCLRR_TIM8LPEN		BIT(1)
-#define RCC_MC_APB2LPENCLRR_TIM15LPEN		BIT(2)
-#define RCC_MC_APB2LPENCLRR_TIM16LPEN		BIT(3)
-#define RCC_MC_APB2LPENCLRR_TIM17LPEN		BIT(4)
-#define RCC_MC_APB2LPENCLRR_SPI1LPEN		BIT(8)
-#define RCC_MC_APB2LPENCLRR_SPI4LPEN		BIT(9)
-#define RCC_MC_APB2LPENCLRR_SPI5LPEN		BIT(10)
-#define RCC_MC_APB2LPENCLRR_USART6LPEN		BIT(13)
-#define RCC_MC_APB2LPENCLRR_SAI1LPEN		BIT(16)
-#define RCC_MC_APB2LPENCLRR_SAI2LPEN		BIT(17)
-#define RCC_MC_APB2LPENCLRR_SAI3LPEN		BIT(18)
-#define RCC_MC_APB2LPENCLRR_DFSDMLPEN		BIT(20)
-#define RCC_MC_APB2LPENCLRR_ADFSDMLPEN		BIT(21)
-#define RCC_MC_APB2LPENCLRR_FDCANLPEN		BIT(24)
-
-/* RCC_MC_APB3LPENSETR register fields */
-#define RCC_MC_APB3LPENSETR_LPTIM2LPEN		BIT(0)
-#define RCC_MC_APB3LPENSETR_LPTIM3LPEN		BIT(1)
-#define RCC_MC_APB3LPENSETR_LPTIM4LPEN		BIT(2)
-#define RCC_MC_APB3LPENSETR_LPTIM5LPEN		BIT(3)
-#define RCC_MC_APB3LPENSETR_SAI4LPEN		BIT(8)
-#define RCC_MC_APB3LPENSETR_SYSCFGLPEN		BIT(11)
-#define RCC_MC_APB3LPENSETR_VREFLPEN		BIT(13)
-#define RCC_MC_APB3LPENSETR_TMPSENSLPEN		BIT(16)
-#define RCC_MC_APB3LPENSETR_PMBCTRLLPEN		BIT(17)
-
-/* RCC_MC_APB3LPENCLRR register fields */
-#define RCC_MC_APB3LPENCLRR_LPTIM2LPEN		BIT(0)
-#define RCC_MC_APB3LPENCLRR_LPTIM3LPEN		BIT(1)
-#define RCC_MC_APB3LPENCLRR_LPTIM4LPEN		BIT(2)
-#define RCC_MC_APB3LPENCLRR_LPTIM5LPEN		BIT(3)
-#define RCC_MC_APB3LPENCLRR_SAI4LPEN		BIT(8)
-#define RCC_MC_APB3LPENCLRR_SYSCFGLPEN		BIT(11)
-#define RCC_MC_APB3LPENCLRR_VREFLPEN		BIT(13)
-#define RCC_MC_APB3LPENCLRR_TMPSENSLPEN		BIT(16)
-#define RCC_MC_APB3LPENCLRR_PMBCTRLLPEN		BIT(17)
-
-/* RCC_MC_AHB2LPENSETR register fields */
-#define RCC_MC_AHB2LPENSETR_DMA1LPEN		BIT(0)
-#define RCC_MC_AHB2LPENSETR_DMA2LPEN		BIT(1)
-#define RCC_MC_AHB2LPENSETR_DMAMUXLPEN		BIT(2)
-#define RCC_MC_AHB2LPENSETR_ADC12LPEN		BIT(5)
-#define RCC_MC_AHB2LPENSETR_USBOLPEN		BIT(8)
-#define RCC_MC_AHB2LPENSETR_SDMMC3LPEN		BIT(16)
-
-/* RCC_MC_AHB2LPENCLRR register fields */
-#define RCC_MC_AHB2LPENCLRR_DMA1LPEN		BIT(0)
-#define RCC_MC_AHB2LPENCLRR_DMA2LPEN		BIT(1)
-#define RCC_MC_AHB2LPENCLRR_DMAMUXLPEN		BIT(2)
-#define RCC_MC_AHB2LPENCLRR_ADC12LPEN		BIT(5)
-#define RCC_MC_AHB2LPENCLRR_USBOLPEN		BIT(8)
-#define RCC_MC_AHB2LPENCLRR_SDMMC3LPEN		BIT(16)
-
-/* RCC_MC_AHB3LPENSETR register fields */
-#define RCC_MC_AHB3LPENSETR_DCMILPEN		BIT(0)
-#define RCC_MC_AHB3LPENSETR_CRYP2LPEN		BIT(4)
-#define RCC_MC_AHB3LPENSETR_HASH2LPEN		BIT(5)
-#define RCC_MC_AHB3LPENSETR_RNG2LPEN		BIT(6)
-#define RCC_MC_AHB3LPENSETR_CRC2LPEN		BIT(7)
-#define RCC_MC_AHB3LPENSETR_HSEMLPEN		BIT(11)
-#define RCC_MC_AHB3LPENSETR_IPCCLPEN		BIT(12)
-
-/* RCC_MC_AHB3LPENCLRR register fields */
-#define RCC_MC_AHB3LPENCLRR_DCMILPEN		BIT(0)
-#define RCC_MC_AHB3LPENCLRR_CRYP2LPEN		BIT(4)
-#define RCC_MC_AHB3LPENCLRR_HASH2LPEN		BIT(5)
-#define RCC_MC_AHB3LPENCLRR_RNG2LPEN		BIT(6)
-#define RCC_MC_AHB3LPENCLRR_CRC2LPEN		BIT(7)
-#define RCC_MC_AHB3LPENCLRR_HSEMLPEN		BIT(11)
-#define RCC_MC_AHB3LPENCLRR_IPCCLPEN		BIT(12)
-
-/* RCC_MC_AHB4LPENSETR register fields */
-#define RCC_MC_AHB4LPENSETR_GPIOALPEN		BIT(0)
-#define RCC_MC_AHB4LPENSETR_GPIOBLPEN		BIT(1)
-#define RCC_MC_AHB4LPENSETR_GPIOCLPEN		BIT(2)
-#define RCC_MC_AHB4LPENSETR_GPIODLPEN		BIT(3)
-#define RCC_MC_AHB4LPENSETR_GPIOELPEN		BIT(4)
-#define RCC_MC_AHB4LPENSETR_GPIOFLPEN		BIT(5)
-#define RCC_MC_AHB4LPENSETR_GPIOGLPEN		BIT(6)
-#define RCC_MC_AHB4LPENSETR_GPIOHLPEN		BIT(7)
-#define RCC_MC_AHB4LPENSETR_GPIOILPEN		BIT(8)
-#define RCC_MC_AHB4LPENSETR_GPIOJLPEN		BIT(9)
-#define RCC_MC_AHB4LPENSETR_GPIOKLPEN		BIT(10)
-
-/* RCC_MC_AHB4LPENCLRR register fields */
-#define RCC_MC_AHB4LPENCLRR_GPIOALPEN		BIT(0)
-#define RCC_MC_AHB4LPENCLRR_GPIOBLPEN		BIT(1)
-#define RCC_MC_AHB4LPENCLRR_GPIOCLPEN		BIT(2)
-#define RCC_MC_AHB4LPENCLRR_GPIODLPEN		BIT(3)
-#define RCC_MC_AHB4LPENCLRR_GPIOELPEN		BIT(4)
-#define RCC_MC_AHB4LPENCLRR_GPIOFLPEN		BIT(5)
-#define RCC_MC_AHB4LPENCLRR_GPIOGLPEN		BIT(6)
-#define RCC_MC_AHB4LPENCLRR_GPIOHLPEN		BIT(7)
-#define RCC_MC_AHB4LPENCLRR_GPIOILPEN		BIT(8)
-#define RCC_MC_AHB4LPENCLRR_GPIOJLPEN		BIT(9)
-#define RCC_MC_AHB4LPENCLRR_GPIOKLPEN		BIT(10)
-
-/* RCC_MC_AXIMLPENSETR register fields */
-#define RCC_MC_AXIMLPENSETR_SYSRAMLPEN		BIT(0)
-
-/* RCC_MC_AXIMLPENCLRR register fields */
-#define RCC_MC_AXIMLPENCLRR_SYSRAMLPEN		BIT(0)
-
-/* RCC_MC_MLAHBLPENSETR register fields */
-#define RCC_MC_MLAHBLPENSETR_SRAM1LPEN		BIT(0)
-#define RCC_MC_MLAHBLPENSETR_SRAM2LPEN		BIT(1)
-#define RCC_MC_MLAHBLPENSETR_SRAM34LPEN		BIT(2)
-#define RCC_MC_MLAHBLPENSETR_RETRAMLPEN		BIT(4)
-
-/* RCC_MC_MLAHBLPENCLRR register fields */
-#define RCC_MC_MLAHBLPENCLRR_SRAM1LPEN		BIT(0)
-#define RCC_MC_MLAHBLPENCLRR_SRAM2LPEN		BIT(1)
-#define RCC_MC_MLAHBLPENCLRR_SRAM34LPEN		BIT(2)
-#define RCC_MC_MLAHBLPENCLRR_RETRAMLPEN		BIT(4)
-
-/* RCC_MC_RSTSCLRR register fields */
-#define RCC_MC_RSTSCLRR_PORRSTF			BIT(0)
-#define RCC_MC_RSTSCLRR_BORRSTF			BIT(1)
-#define RCC_MC_RSTSCLRR_PADRSTF			BIT(2)
-#define RCC_MC_RSTSCLRR_HCSSRSTF		BIT(3)
-#define RCC_MC_RSTSCLRR_VCORERSTF		BIT(4)
-#define RCC_MC_RSTSCLRR_MCURSTF			BIT(5)
-#define RCC_MC_RSTSCLRR_MPSYSRSTF		BIT(6)
-#define RCC_MC_RSTSCLRR_MCSYSRSTF		BIT(7)
-#define RCC_MC_RSTSCLRR_IWDG1RSTF		BIT(8)
-#define RCC_MC_RSTSCLRR_IWDG2RSTF		BIT(9)
-#define RCC_MC_RSTSCLRR_WWDG1RSTF		BIT(10)
-
-/* RCC_MC_CIER register fields */
-#define RCC_MC_CIER_LSIRDYIE			BIT(0)
-#define RCC_MC_CIER_LSERDYIE			BIT(1)
-#define RCC_MC_CIER_HSIRDYIE			BIT(2)
-#define RCC_MC_CIER_HSERDYIE			BIT(3)
-#define RCC_MC_CIER_CSIRDYIE			BIT(4)
-#define RCC_MC_CIER_PLL1DYIE			BIT(8)
-#define RCC_MC_CIER_PLL2DYIE			BIT(9)
-#define RCC_MC_CIER_PLL3DYIE			BIT(10)
-#define RCC_MC_CIER_PLL4DYIE			BIT(11)
-#define RCC_MC_CIER_LSECSSIE			BIT(16)
-#define RCC_MC_CIER_WKUPIE			BIT(20)
-
-/* RCC_MC_CIFR register fields */
-#define RCC_MC_CIFR_LSIRDYF			BIT(0)
-#define RCC_MC_CIFR_LSERDYF			BIT(1)
-#define RCC_MC_CIFR_HSIRDYF			BIT(2)
-#define RCC_MC_CIFR_HSERDYF			BIT(3)
-#define RCC_MC_CIFR_CSIRDYF			BIT(4)
-#define RCC_MC_CIFR_PLL1DYF			BIT(8)
-#define RCC_MC_CIFR_PLL2DYF			BIT(9)
-#define RCC_MC_CIFR_PLL3DYF			BIT(10)
-#define RCC_MC_CIFR_PLL4DYF			BIT(11)
-#define RCC_MC_CIFR_LSECSSF			BIT(16)
-#define RCC_MC_CIFR_WKUPF			BIT(20)
-
-/* RCC_VERR register fields */
-#define RCC_VERR_MINREV_MASK			GENMASK(3, 0)
-#define RCC_VERR_MINREV_SHIFT			0
-#define RCC_VERR_MAJREV_MASK			GENMASK(7, 4)
-#define RCC_VERR_MAJREV_SHIFT			4
-
-/* Used for RCC_OCENSETR and RCC_OCENCLRR registers */
-#define RCC_OCENR_HSION				BIT(0)
-#define RCC_OCENR_HSIKERON			BIT(1)
-#define RCC_OCENR_CSION				BIT(4)
-#define RCC_OCENR_CSIKERON			BIT(5)
-#define RCC_OCENR_DIGBYP			BIT(7)
-#define RCC_OCENR_HSEON				BIT(8)
-#define RCC_OCENR_HSEKERON			BIT(9)
-#define RCC_OCENR_HSEBYP			BIT(10)
-#define RCC_OCENR_HSECSSON			BIT(11)
-
-/* Offset between RCC_MP_xxxENSETR and RCC_MP_xxxENCLRR registers */
-#define RCC_MP_ENCLRR_OFFSET			U(4)
-
-/* Offset between RCC_xxxRSTSETR and RCC_xxxRSTCLRR registers */
-#define RCC_RSTCLRR_OFFSET			U(4)
-
-/* Used for most of DIVR register: max div for RTC */
-#define RCC_DIVR_DIV_MASK			GENMASK(5, 0)
-#define RCC_DIVR_DIVRDY				BIT(31)
-
-/* Masks for specific DIVR registers */
-#define RCC_APBXDIV_MASK			GENMASK(2, 0)
-#define RCC_MPUDIV_MASK				GENMASK(2, 0)
-#define RCC_AXIDIV_MASK				GENMASK(2, 0)
-#define RCC_MCUDIV_MASK				GENMASK(3, 0)
-
-/* Used for most of RCC_<x>SELR registers */
-#define RCC_SELR_SRC_MASK			GENMASK(2, 0)
-#define RCC_SELR_REFCLK_SRC_MASK		GENMASK(1, 0)
-#define RCC_SELR_SRCRDY				BIT(31)
-
-/* Used for all RCC_PLL<n>CR registers */
-#define RCC_PLLNCR_PLLON			BIT(0)
-#define RCC_PLLNCR_PLLRDY			BIT(1)
-#define RCC_PLLNCR_SSCG_CTRL			BIT(2)
-#define RCC_PLLNCR_DIVPEN			BIT(4)
-#define RCC_PLLNCR_DIVQEN			BIT(5)
-#define RCC_PLLNCR_DIVREN			BIT(6)
-#define RCC_PLLNCR_DIVEN_SHIFT			4
-
-/* Used for all RCC_PLL<n>CFGR1 registers */
-#define RCC_PLLNCFGR1_DIVM_MASK			GENMASK(21, 16)
-#define RCC_PLLNCFGR1_DIVM_SHIFT		16
-#define RCC_PLLNCFGR1_DIVN_MASK			GENMASK(8, 0)
-#define RCC_PLLNCFGR1_DIVN_SHIFT		0
-
-/* Only for PLL3 and PLL4 */
-#define RCC_PLLNCFGR1_IFRGE_MASK		GENMASK(25, 24)
-#define RCC_PLLNCFGR1_IFRGE_SHIFT		24
-
-/* Used for all RCC_PLL<n>CFGR2 registers */
-#define RCC_PLLNCFGR2_DIVX_MASK			GENMASK(6, 0)
-#define RCC_PLLNCFGR2_DIVP_MASK			GENMASK(6, 0)
-#define RCC_PLLNCFGR2_DIVP_SHIFT		0
-#define RCC_PLLNCFGR2_DIVQ_MASK			GENMASK(14, 8)
-#define RCC_PLLNCFGR2_DIVQ_SHIFT		8
-#define RCC_PLLNCFGR2_DIVR_MASK			GENMASK(22, 16)
-#define RCC_PLLNCFGR2_DIVR_SHIFT		16
-
-/* Used for all RCC_PLL<n>FRACR registers */
-#define RCC_PLLNFRACR_FRACV_SHIFT		3
-#define RCC_PLLNFRACR_FRACV_MASK		GENMASK(15, 3)
-#define RCC_PLLNFRACR_FRACLE			BIT(16)
-
-/* Used for all RCC_PLL<n>CSGR registers */
-#define RCC_PLLNCSGR_INC_STEP_SHIFT		16
-#define RCC_PLLNCSGR_INC_STEP_MASK		GENMASK(30, 16)
-#define RCC_PLLNCSGR_MOD_PER_SHIFT		0
-#define RCC_PLLNCSGR_MOD_PER_MASK		GENMASK(12, 0)
-#define RCC_PLLNCSGR_SSCG_MODE_SHIFT		15
-#define RCC_PLLNCSGR_SSCG_MODE_MASK		BIT(15)
-
-/* Used for TIMER Prescaler */
-#define RCC_TIMGXPRER_TIMGXPRE			BIT(0)
-
-/* Used for RCC_MCO related operations */
-#define RCC_MCOCFG_MCOON			BIT(12)
-#define RCC_MCOCFG_MCODIV_MASK			GENMASK(7, 4)
-#define RCC_MCOCFG_MCODIV_SHIFT			4
-#define RCC_MCOCFG_MCOSRC_MASK			GENMASK(2, 0)
-
-#endif /* STM32MP1_RCC_H */
+#if STM32MP13
+#include "stm32mp13_rcc.h"
+#endif
+#if STM32MP15
+#include "stm32mp15_rcc.h"
+#endif
diff --git a/include/drivers/st/stm32mp2_clk.h b/include/drivers/st/stm32mp2_clk.h
new file mode 100644
index 000000000..f8fc67d0e
--- /dev/null
+++ b/include/drivers/st/stm32mp2_clk.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2018-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_CLK_H
+#define STM32MP2_CLK_H
+
+#include <platform_def.h>
+
+enum stm32mp_osc_id {
+	_HSI,
+	_HSE,
+	_CSI,
+	_LSI,
+	_LSE,
+	_I2S_CKIN,
+	_SPDIF_SYMB,
+	NB_OSC,
+	_UNKNOWN_OSC_ID = 0xFF
+};
+
+extern const char *stm32mp_osc_node_label[NB_OSC];
+
+enum pll_cfg {
+	FBDIV,
+	REFDIV,
+	POSTDIV1,
+	POSTDIV2,
+	PLLCFG_NB
+};
+
+enum pll_csg {
+	DIVVAL,
+	SPREAD,
+	DOWNSPREAD,
+	PLLCSG_NB
+};
+
+int stm32mp2_clk_init(void);
+
+#endif /* STM32MP2_CLK_H */
diff --git a/include/drivers/st/stm32mp2_ddr.h b/include/drivers/st/stm32mp2_ddr.h
new file mode 100644
index 000000000..76b809b69
--- /dev/null
+++ b/include/drivers/st/stm32mp2_ddr.h
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ */
+
+#ifndef STM32MP2_DDR_H
+#define STM32MP2_DDR_H
+
+#include <stdbool.h>
+
+#include <drivers/st/stm32mp_ddr.h>
+
+struct stm32mp2_ddrctrl_reg {
+	uint32_t mstr;
+	uint32_t mrctrl0;
+	uint32_t mrctrl1;
+	uint32_t mrctrl2;
+	uint32_t derateen;
+	uint32_t derateint;
+	uint32_t deratectl;
+	uint32_t pwrctl;
+	uint32_t pwrtmg;
+	uint32_t hwlpctl;
+	uint32_t rfshctl0;
+	uint32_t rfshctl1;
+	uint32_t rfshctl3;
+	uint32_t crcparctl0;
+	uint32_t crcparctl1;
+	uint32_t init0;
+	uint32_t init1;
+	uint32_t init2;
+	uint32_t init3;
+	uint32_t init4;
+	uint32_t init5;
+	uint32_t init6;
+	uint32_t init7;
+	uint32_t dimmctl;
+	uint32_t rankctl;
+	uint32_t zqctl0;
+	uint32_t zqctl1;
+	uint32_t zqctl2;
+	uint32_t dfitmg0;
+	uint32_t dfitmg1;
+	uint32_t dfilpcfg0;
+	uint32_t dfilpcfg1;
+	uint32_t dfiupd0;
+	uint32_t dfiupd1;
+	uint32_t dfiupd2;
+	uint32_t dfimisc;
+	uint32_t dfitmg2;
+	uint32_t dfitmg3;
+	uint32_t dbictl;
+	uint32_t dfiphymstr;
+	uint32_t dbg0;
+	uint32_t dbg1;
+	uint32_t dbgcmd;
+	uint32_t swctl;
+	uint32_t poisoncfg;
+	uint32_t pccfg;
+};
+
+struct stm32mp2_ddrctrl_timing {
+	uint32_t rfshtmg;
+	uint32_t rfshtmg1;
+	uint32_t dramtmg0;
+	uint32_t dramtmg1;
+	uint32_t dramtmg2;
+	uint32_t dramtmg3;
+	uint32_t dramtmg4;
+	uint32_t dramtmg5;
+	uint32_t dramtmg6;
+	uint32_t dramtmg7;
+	uint32_t dramtmg8;
+	uint32_t dramtmg9;
+	uint32_t dramtmg10;
+	uint32_t dramtmg11;
+	uint32_t dramtmg12;
+	uint32_t dramtmg13;
+	uint32_t dramtmg14;
+	uint32_t dramtmg15;
+	uint32_t odtcfg;
+	uint32_t odtmap;
+};
+
+struct stm32mp2_ddrctrl_map {
+	uint32_t addrmap0;
+	uint32_t addrmap1;
+	uint32_t addrmap2;
+	uint32_t addrmap3;
+	uint32_t addrmap4;
+	uint32_t addrmap5;
+	uint32_t addrmap6;
+	uint32_t addrmap7;
+	uint32_t addrmap8;
+	uint32_t addrmap9;
+	uint32_t addrmap10;
+	uint32_t addrmap11;
+};
+
+struct stm32mp2_ddrctrl_perf {
+	uint32_t sched;
+	uint32_t sched1;
+	uint32_t perfhpr1;
+	uint32_t perflpr1;
+	uint32_t perfwr1;
+	uint32_t pcfgr_0;
+	uint32_t pcfgw_0;
+	uint32_t pctrl_0;
+	uint32_t pcfgqos0_0;
+	uint32_t pcfgqos1_0;
+	uint32_t pcfgwqos0_0;
+	uint32_t pcfgwqos1_0;
+#if STM32MP_DDR_DUAL_AXI_PORT
+	uint32_t pcfgr_1;
+	uint32_t pcfgw_1;
+	uint32_t pctrl_1;
+	uint32_t pcfgqos0_1;
+	uint32_t pcfgqos1_1;
+	uint32_t pcfgwqos0_1;
+	uint32_t pcfgwqos1_1;
+#endif
+};
+
+struct stm32mp_ddr_config {
+	struct stm32mp_ddr_info info;
+	struct stm32mp2_ddrctrl_reg c_reg;
+	struct stm32mp2_ddrctrl_timing c_timing;
+	struct stm32mp2_ddrctrl_map c_map;
+	struct stm32mp2_ddrctrl_perf c_perf;
+	bool self_refresh;
+	uint32_t zdata;
+};
+
+void stm32mp2_ddr_init(struct stm32mp_ddr_priv *priv, struct stm32mp_ddr_config *config);
+
+#endif /* STM32MP2_DDR_H */
diff --git a/include/drivers/st/stm32mp2_ddr_helpers.h b/include/drivers/st/stm32mp2_ddr_helpers.h
new file mode 100644
index 000000000..063cc8aa4
--- /dev/null
+++ b/include/drivers/st/stm32mp2_ddr_helpers.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_DDR_HELPERS_H
+#define STM32MP2_DDR_HELPERS_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+enum stm32mp2_ddr_sr_mode {
+	DDR_SR_MODE_INVALID = 0,
+	DDR_SSR_MODE,
+	DDR_HSR_MODE,
+	DDR_ASR_MODE,
+};
+
+int ddr_sw_self_refresh_exit(void);
+uint32_t ddr_get_io_calibration_val(void);
+int ddr_standby_sr_entry(void);
+enum stm32mp2_ddr_sr_mode ddr_read_sr_mode(void);
+void ddr_set_sr_mode(enum stm32mp2_ddr_sr_mode mode);
+void ddr_save_sr_mode(void);
+void ddr_restore_sr_mode(void);
+
+#endif /* STM32MP2_DDR_HELPERS_H */
diff --git a/include/drivers/st/stm32mp2_ddr_regs.h b/include/drivers/st/stm32mp2_ddr_regs.h
new file mode 100644
index 000000000..adc07c971
--- /dev/null
+++ b/include/drivers/st/stm32mp2_ddr_regs.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ */
+
+#ifndef STM32MP2_DDR_REGS_H
+#define STM32MP2_DDR_REGS_H
+
+#include <drivers/st/stm32mp_ddrctrl_regs.h>
+#include <lib/utils_def.h>
+
+/* DDR Physical Interface Control (DDRPHYC) registers*/
+struct stm32mp_ddrphy {
+	uint32_t dummy;
+} __packed;
+
+/* DDRPHY registers offsets */
+#define DDRPHY_APBONLY0_MICROCONTMUXSEL		U(0x340000)
+
+/* DDRDBG registers offsets */
+#define DDRDBG_LP_DISABLE			U(0x0)
+#define DDRDBG_BYPASS_PCLKEN			U(0x4)
+
+/* DDRDBG registers fields */
+#define DDRDBG_LP_DISABLE_LPI_XPI_DISABLE	BIT(0)
+#define DDRDBG_LP_DISABLE_LPI_DDRC_DISABLE	BIT(8)
+
+#endif /* STM32MP2_DDR_REGS_H */
diff --git a/include/drivers/st/stm32mp2_pwr.h b/include/drivers/st/stm32mp2_pwr.h
new file mode 100644
index 000000000..8eed577f3
--- /dev/null
+++ b/include/drivers/st/stm32mp2_pwr.h
@@ -0,0 +1,478 @@
+/*
+ * Copyright (c) 2018-2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_PWR_H
+#define STM32MP2_PWR_H
+
+#include <lib/utils_def.h>
+
+#define PWR_CR1					U(0x00)
+#define PWR_CR2					U(0x04)
+#define PWR_CR3					U(0x08)
+#define PWR_CR4					U(0x0C)
+#define PWR_CR5					U(0x10)
+#define PWR_CR6					U(0x14)
+#define PWR_CR7					U(0x18)
+#define PWR_CR8					U(0x1C)
+#define PWR_CR9					U(0x20)
+#define PWR_CR10				U(0x24)
+#define PWR_CR11				U(0x28)
+#define PWR_CR12				U(0x2C)
+#define PWR_UCPDR				U(0x30)
+#define PWR_BDCR1				U(0x38)
+#define PWR_BDCR2				U(0x3C)
+#define PWR_CPU1CR				U(0x40)
+#define PWR_CPU2CR				U(0x44)
+#define PWR_CPU3CR				U(0x48)
+#define PWR_D1CR				U(0x4C)
+#define PWR_D2CR				U(0x50)
+#define PWR_D3CR				U(0x54)
+#define PWR_WKUPCR1				U(0x60)
+#define PWR_WKUPCR2				U(0x64)
+#define PWR_WKUPCR3				U(0x68)
+#define PWR_WKUPCR4				U(0x6C)
+#define PWR_WKUPCR5				U(0x70)
+#define PWR_WKUPCR6				U(0x74)
+#define PWR_D3WKUPENR				U(0x98)
+#define PWR_RSECCFGR				U(0x100)
+#define PWR_RPRIVCFGR				U(0x104)
+#define PWR_R0CIDCFGR				U(0x108)
+#define PWR_R1CIDCFGR				U(0x10C)
+#define PWR_R2CIDCFGR				U(0x110)
+#define PWR_R3CIDCFGR				U(0x114)
+#define PWR_R4CIDCFGR				U(0x118)
+#define PWR_R5CIDCFGR				U(0x11C)
+#define PWR_R6CIDCFGR				U(0x120)
+#define PWR_WIOSECCFGR				U(0x180)
+#define PWR_WIOPRIVCFGR				U(0x184)
+#define PWR_WIO1CIDCFGR				U(0x188)
+#define PWR_WIO1SEMCR				U(0x18C)
+#define PWR_WIO2CIDCFGR				U(0x190)
+#define PWR_WIO2SEMCR				U(0x194)
+#define PWR_WIO3CIDCFGR				U(0x198)
+#define PWR_WIO3SEMCR				U(0x19C)
+#define PWR_WIO4CIDCFGR				U(0x1A0)
+#define PWR_WIO4SEMCR				U(0x1A4)
+#define PWR_WIO5CIDCFGR				U(0x1A8)
+#define PWR_WIO5SEMCR				U(0x1AC)
+#define PWR_WIO6CIDCFGR				U(0x1B0)
+#define PWR_WIO6SEMCR				U(0x1B4)
+#define PWR_CPU1D1SR				U(0x200)
+#define PWR_CPU2D2SR				U(0x204)
+#define PWR_CPU3D3SR				U(0x208)
+#define PWR_DBGR				U(0x308)
+#define PWR_VERR				U(0x3F4)
+#define PWR_IPIDR				U(0x3F8)
+#define PWR_SIDR				U(0x3FC)
+
+/* PWR_CR1 register fields */
+#define PWR_CR1_VDDIO3VMEN			BIT(0)
+#define PWR_CR1_VDDIO4VMEN			BIT(1)
+#define PWR_CR1_USB33VMEN			BIT(2)
+#define PWR_CR1_UCPDVMEN			BIT(3)
+#define PWR_CR1_AVMEN				BIT(4)
+#define PWR_CR1_VDDIO3SV			BIT(8)
+#define PWR_CR1_VDDIO4SV			BIT(9)
+#define PWR_CR1_USB33SV				BIT(10)
+#define PWR_CR1_UCPDSV				BIT(11)
+#define PWR_CR1_ASV				BIT(12)
+#define PWR_CR1_VDDIO3RDY			BIT(16)
+#define PWR_CR1_VDDIO4RDY			BIT(17)
+#define PWR_CR1_USB33RDY			BIT(18)
+#define PWR_CR1_UCPDRDY				BIT(19)
+#define PWR_CR1_ARDY				BIT(20)
+#define PWR_CR1_VDDIOVRSEL			BIT(24)
+#define PWR_CR1_VDDIO3VRSEL			BIT(25)
+#define PWR_CR1_VDDIO4VRSEL			BIT(26)
+#define PWR_CR1_GPVMO				BIT(31)
+
+/* PWR_CR2 register fields */
+#define PWR_CR2_MONEN				BIT(0)
+#define PWR_CR2_VBATL				BIT(8)
+#define PWR_CR2_VBATH				BIT(9)
+#define PWR_CR2_TEMPL				BIT(10)
+#define PWR_CR2_TEMPH				BIT(11)
+
+/* PWR_CR3 register fields */
+#define PWR_CR3_PVDEN				BIT(0)
+#define PWR_CR3_PVDO				BIT(8)
+
+/* PWR_CR5 register fields */
+#define PWR_CR5_VCOREMONEN			BIT(0)
+#define PWR_CR5_VCOREL				BIT(8)
+#define PWR_CR5_VCOREH				BIT(9)
+
+/* PWR_CR6 register fields */
+#define PWR_CR6_VCPUMONEN			BIT(0)
+#define PWR_CR6_VCPULLS				BIT(4)
+#define PWR_CR6_VCPUL				BIT(8)
+#define PWR_CR6_VCPUH				BIT(9)
+
+/* PWR_CR7 register fields */
+#define PWR_CR7_VDDIO2VMEN			BIT(0)
+#define PWR_CR7_VDDIO2SV			BIT(8)
+#define PWR_CR7_VDDIO2RDY			BIT(16)
+#define PWR_CR7_VDDIO2VRSEL			BIT(24)
+#define PWR_CR7_VDDIO2VRSTBY			BIT(25)
+
+/* PWR_CR8 register fields */
+#define PWR_CR8_VDDIO1VMEN			BIT(0)
+#define PWR_CR8_VDDIO1SV			BIT(8)
+#define PWR_CR8_VDDIO1RDY			BIT(16)
+#define PWR_CR8_VDDIO1VRSEL			BIT(24)
+#define PWR_CR8_VDDIO1VRSTBY			BIT(25)
+
+/* PWR_CR9 register fields */
+#define PWR_CR9_BKPRBSEN			BIT(0)
+#define PWR_CR9_LPR1BSEN			BIT(4)
+
+/* PWR_CR10 register fields */
+#define PWR_CR10_RETRBSEN_MASK			GENMASK(1, 0)
+#define PWR_CR10_RETRBSEN_SHIFT			0
+
+/* PWR_CR11 register fields */
+#define PWR_CR11_DDRRETDIS			BIT(0)
+
+/* PWR_CR12 register fields */
+#define PWR_CR12_GPUVMEN			BIT(0)
+#define PWR_CR12_GPULVTEN			BIT(1)
+#define PWR_CR12_GPUSV				BIT(8)
+#define PWR_CR12_VDDGPURDY			BIT(16)
+
+/* PWR_UCPDR register fields */
+#define PWR_UCPDR_UCPD_DBDIS			BIT(0)
+#define PWR_UCPDR_UCPD_STBY			BIT(1)
+
+/* PWR_BDCR1 register fields */
+#define PWR_BDCR1_DBD3P				BIT(0)
+
+/* PWR_BDCR2 register fields */
+#define PWR_BDCR2_DBP				BIT(0)
+
+/* PWR_CPU1CR register fields */
+#define PWR_CPU1CR_PDDS_D2			BIT(0)
+#define PWR_CPU1CR_PDDS_D1			BIT(1)
+#define PWR_CPU1CR_VBF				BIT(4)
+#define PWR_CPU1CR_STOPF			BIT(5)
+#define PWR_CPU1CR_SBF				BIT(6)
+#define PWR_CPU1CR_SBF_D1			BIT(7)
+#define PWR_CPU1CR_SBF_D3			BIT(8)
+#define PWR_CPU1CR_CSSF				BIT(9)
+#define PWR_CPU1CR_STANDBYWFIL2			BIT(15)
+#define PWR_CPU1CR_LPDS_D1			BIT(16)
+#define PWR_CPU1CR_LVDS_D1			BIT(17)
+
+/* PWR_CPU2CR register fields */
+#define PWR_CPU2CR_PDDS_D2			BIT(0)
+#define PWR_CPU2CR_VBF				BIT(4)
+#define PWR_CPU2CR_STOPF			BIT(5)
+#define PWR_CPU2CR_SBF				BIT(6)
+#define PWR_CPU2CR_SBF_D2			BIT(7)
+#define PWR_CPU2CR_SBF_D3			BIT(8)
+#define PWR_CPU2CR_CSSF				BIT(9)
+#define PWR_CPU2CR_DEEPSLEEP			BIT(15)
+#define PWR_CPU2CR_LPDS_D2			BIT(16)
+#define PWR_CPU2CR_LVDS_D2			BIT(17)
+
+/* PWR_CPU3CR register fields */
+#define PWR_CPU3CR_VBF				BIT(4)
+#define PWR_CPU3CR_SBF_D3			BIT(8)
+#define PWR_CPU3CR_CSSF				BIT(9)
+#define PWR_CPU3CR_DEEPSLEEP			BIT(15)
+
+/* PWR_D1CR register fields */
+#define PWR_D1CR_LPCFG_D1			BIT(0)
+#define PWR_D1CR_POPL_D1_MASK			GENMASK(12, 8)
+#define PWR_D1CR_POPL_D1_SHIFT			8
+
+/* PWR_D2CR register fields */
+#define PWR_D2CR_LPCFG_D2			BIT(0)
+#define PWR_D2CR_POPL_D2_MASK			GENMASK(12, 8)
+#define PWR_D2CR_POPL_D2_SHIFT			8
+#define PWR_D2CR_LPLVDLY_D2_MASK		GENMASK(18, 16)
+#define PWR_D2CR_LPLVDLY_D2_SHIFT		16
+#define PWR_D2CR_PODH_D2_MASK			GENMASK(27, 24)
+#define PWR_D2CR_PODH_D2_SHIFT			24
+
+/* PWR_D3CR register fields */
+#define PWR_D3CR_PDDS_D3			BIT(0)
+#define PWR_D3CR_D3RDY				BIT(31)
+
+/* PWR_WKUPCR1 register fields */
+#define PWR_WKUPCR1_WKUPC			BIT(0)
+#define PWR_WKUPCR1_WKUPP			BIT(8)
+#define PWR_WKUPCR1_WKUPPUPD_MASK		GENMASK(13, 12)
+#define PWR_WKUPCR1_WKUPPUPD_SHIFT		12
+#define PWR_WKUPCR1_WKUPENCPU1			BIT(16)
+#define PWR_WKUPCR1_WKUPENCPU2			BIT(17)
+#define PWR_WKUPCR1_WKUPF			BIT(31)
+
+/* PWR_WKUPCR2 register fields */
+#define PWR_WKUPCR2_WKUPC			BIT(0)
+#define PWR_WKUPCR2_WKUPP			BIT(8)
+#define PWR_WKUPCR2_WKUPPUPD_MASK		GENMASK(13, 12)
+#define PWR_WKUPCR2_WKUPPUPD_SHIFT		12
+#define PWR_WKUPCR2_WKUPENCPU1			BIT(16)
+#define PWR_WKUPCR2_WKUPENCPU2			BIT(17)
+#define PWR_WKUPCR2_WKUPF			BIT(31)
+
+/* PWR_WKUPCR3 register fields */
+#define PWR_WKUPCR3_WKUPC			BIT(0)
+#define PWR_WKUPCR3_WKUPP			BIT(8)
+#define PWR_WKUPCR3_WKUPPUPD_MASK		GENMASK(13, 12)
+#define PWR_WKUPCR3_WKUPPUPD_SHIFT		12
+#define PWR_WKUPCR3_WKUPENCPU1			BIT(16)
+#define PWR_WKUPCR3_WKUPENCPU2			BIT(17)
+#define PWR_WKUPCR3_WKUPF			BIT(31)
+
+/* PWR_WKUPCR4 register fields */
+#define PWR_WKUPCR4_WKUPC			BIT(0)
+#define PWR_WKUPCR4_WKUPP			BIT(8)
+#define PWR_WKUPCR4_WKUPPUPD_MASK		GENMASK(13, 12)
+#define PWR_WKUPCR4_WKUPPUPD_SHIFT		12
+#define PWR_WKUPCR4_WKUPENCPU1			BIT(16)
+#define PWR_WKUPCR4_WKUPENCPU2			BIT(17)
+#define PWR_WKUPCR4_WKUPF			BIT(31)
+
+/* PWR_WKUPCR5 register fields */
+#define PWR_WKUPCR5_WKUPC			BIT(0)
+#define PWR_WKUPCR5_WKUPP			BIT(8)
+#define PWR_WKUPCR5_WKUPPUPD_MASK		GENMASK(13, 12)
+#define PWR_WKUPCR5_WKUPPUPD_SHIFT		12
+#define PWR_WKUPCR5_WKUPENCPU1			BIT(16)
+#define PWR_WKUPCR5_WKUPENCPU2			BIT(17)
+#define PWR_WKUPCR5_WKUPF			BIT(31)
+
+/* PWR_WKUPCR6 register fields */
+#define PWR_WKUPCR6_WKUPC			BIT(0)
+#define PWR_WKUPCR6_WKUPP			BIT(8)
+#define PWR_WKUPCR6_WKUPPUPD_MASK		GENMASK(13, 12)
+#define PWR_WKUPCR6_WKUPPUPD_SHIFT		12
+#define PWR_WKUPCR6_WKUPENCPU1			BIT(16)
+#define PWR_WKUPCR6_WKUPENCPU2			BIT(17)
+#define PWR_WKUPCR6_WKUPF			BIT(31)
+
+/* PWR_D3WKUPENR register fields */
+#define PWR_D3WKUPENR_TAMP_WKUPEN_D3		BIT(0)
+
+/* PWR_RSECCFGR register fields */
+#define PWR_RSECCFGR_RSEC0			BIT(0)
+#define PWR_RSECCFGR_RSEC1			BIT(1)
+#define PWR_RSECCFGR_RSEC2			BIT(2)
+#define PWR_RSECCFGR_RSEC3			BIT(3)
+#define PWR_RSECCFGR_RSEC4			BIT(4)
+#define PWR_RSECCFGR_RSEC5			BIT(5)
+#define PWR_RSECCFGR_RSEC6			BIT(6)
+
+/* PWR_RPRIVCFGR register fields */
+#define PWR_RPRIVCFGR_RPRIV0			BIT(0)
+#define PWR_RPRIVCFGR_RPRIV1			BIT(1)
+#define PWR_RPRIVCFGR_RPRIV2			BIT(2)
+#define PWR_RPRIVCFGR_RPRIV3			BIT(3)
+#define PWR_RPRIVCFGR_RPRIV4			BIT(4)
+#define PWR_RPRIVCFGR_RPRIV5			BIT(5)
+#define PWR_RPRIVCFGR_RPRIV6			BIT(6)
+
+/* PWR_R0CIDCFGR register fields */
+#define PWR_R0CIDCFGR_CFEN			BIT(0)
+#define PWR_R0CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define PWR_R0CIDCFGR_SCID_SHIFT		4
+
+/* PWR_R1CIDCFGR register fields */
+#define PWR_R1CIDCFGR_CFEN			BIT(0)
+#define PWR_R1CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define PWR_R1CIDCFGR_SCID_SHIFT		4
+
+/* PWR_R2CIDCFGR register fields */
+#define PWR_R2CIDCFGR_CFEN			BIT(0)
+#define PWR_R2CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define PWR_R2CIDCFGR_SCID_SHIFT		4
+
+/* PWR_R3CIDCFGR register fields */
+#define PWR_R3CIDCFGR_CFEN			BIT(0)
+#define PWR_R3CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define PWR_R3CIDCFGR_SCID_SHIFT		4
+
+/* PWR_R4CIDCFGR register fields */
+#define PWR_R4CIDCFGR_CFEN			BIT(0)
+#define PWR_R4CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define PWR_R4CIDCFGR_SCID_SHIFT		4
+
+/* PWR_R5CIDCFGR register fields */
+#define PWR_R5CIDCFGR_CFEN			BIT(0)
+#define PWR_R5CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define PWR_R5CIDCFGR_SCID_SHIFT		4
+
+/* PWR_R6CIDCFGR register fields */
+#define PWR_R6CIDCFGR_CFEN			BIT(0)
+#define PWR_R6CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define PWR_R6CIDCFGR_SCID_SHIFT		4
+
+/* PWR_WIOSECCFGR register fields */
+#define PWR_WIOSECCFGR_WIOSEC1			BIT(0)
+#define PWR_WIOSECCFGR_WIOSEC2			BIT(1)
+#define PWR_WIOSECCFGR_WIOSEC3			BIT(2)
+#define PWR_WIOSECCFGR_WIOSEC4			BIT(3)
+#define PWR_WIOSECCFGR_WIOSEC5			BIT(4)
+#define PWR_WIOSECCFGR_WIOSEC6			BIT(5)
+
+/* PWR_WIOPRIVCFGR register fields */
+#define PWR_WIOPRIVCFGR_WIOPRIV1		BIT(0)
+#define PWR_WIOPRIVCFGR_WIOPRIV2		BIT(1)
+#define PWR_WIOPRIVCFGR_WIOPRIV3		BIT(2)
+#define PWR_WIOPRIVCFGR_WIOPRIV4		BIT(3)
+#define PWR_WIOPRIVCFGR_WIOPRIV5		BIT(4)
+#define PWR_WIOPRIVCFGR_WIOPRIV6		BIT(5)
+
+/* PWR_WIO1CIDCFGR register fields */
+#define PWR_WIO1CIDCFGR_CFEN			BIT(0)
+#define PWR_WIO1CIDCFGR_SEM_EN			BIT(1)
+#define PWR_WIO1CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define PWR_WIO1CIDCFGR_SCID_SHIFT		4
+#define PWR_WIO1CIDCFGR_SEMWLC0			BIT(16)
+#define PWR_WIO1CIDCFGR_SEMWLC1			BIT(17)
+#define PWR_WIO1CIDCFGR_SEMWLC2			BIT(18)
+#define PWR_WIO1CIDCFGR_SEMWLC3			BIT(19)
+#define PWR_WIO1CIDCFGR_SEMWLC4			BIT(20)
+#define PWR_WIO1CIDCFGR_SEMWLC5			BIT(21)
+#define PWR_WIO1CIDCFGR_SEMWLC6			BIT(22)
+#define PWR_WIO1CIDCFGR_SEMWLC7			BIT(23)
+
+/* PWR_WIO1SEMCR register fields */
+#define PWR_WIO1SEMCR_SEM_MUTEX			BIT(0)
+#define PWR_WIO1SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define PWR_WIO1SEMCR_SEMCID_SHIFT		4
+
+/* PWR_WIO2CIDCFGR register fields */
+#define PWR_WIO2CIDCFGR_CFEN			BIT(0)
+#define PWR_WIO2CIDCFGR_SEM_EN			BIT(1)
+#define PWR_WIO2CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define PWR_WIO2CIDCFGR_SCID_SHIFT		4
+#define PWR_WIO2CIDCFGR_SEMWLC0			BIT(16)
+#define PWR_WIO2CIDCFGR_SEMWLC1			BIT(17)
+#define PWR_WIO2CIDCFGR_SEMWLC2			BIT(18)
+#define PWR_WIO2CIDCFGR_SEMWLC3			BIT(19)
+#define PWR_WIO2CIDCFGR_SEMWLC4			BIT(20)
+#define PWR_WIO2CIDCFGR_SEMWLC5			BIT(21)
+#define PWR_WIO2CIDCFGR_SEMWLC6			BIT(22)
+#define PWR_WIO2CIDCFGR_SEMWLC7			BIT(23)
+
+/* PWR_WIO2SEMCR register fields */
+#define PWR_WIO2SEMCR_SEM_MUTEX			BIT(0)
+#define PWR_WIO2SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define PWR_WIO2SEMCR_SEMCID_SHIFT		4
+
+/* PWR_WIO3CIDCFGR register fields */
+#define PWR_WIO3CIDCFGR_CFEN			BIT(0)
+#define PWR_WIO3CIDCFGR_SEM_EN			BIT(1)
+#define PWR_WIO3CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define PWR_WIO3CIDCFGR_SCID_SHIFT		4
+#define PWR_WIO3CIDCFGR_SEMWLC0			BIT(16)
+#define PWR_WIO3CIDCFGR_SEMWLC1			BIT(17)
+#define PWR_WIO3CIDCFGR_SEMWLC2			BIT(18)
+#define PWR_WIO3CIDCFGR_SEMWLC3			BIT(19)
+#define PWR_WIO3CIDCFGR_SEMWLC4			BIT(20)
+#define PWR_WIO3CIDCFGR_SEMWLC5			BIT(21)
+#define PWR_WIO3CIDCFGR_SEMWLC6			BIT(22)
+#define PWR_WIO3CIDCFGR_SEMWLC7			BIT(23)
+
+/* PWR_WIO3SEMCR register fields */
+#define PWR_WIO3SEMCR_SEM_MUTEX			BIT(0)
+#define PWR_WIO3SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define PWR_WIO3SEMCR_SEMCID_SHIFT		4
+
+/* PWR_WIO4CIDCFGR register fields */
+#define PWR_WIO4CIDCFGR_CFEN			BIT(0)
+#define PWR_WIO4CIDCFGR_SEM_EN			BIT(1)
+#define PWR_WIO4CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define PWR_WIO4CIDCFGR_SCID_SHIFT		4
+#define PWR_WIO4CIDCFGR_SEMWLC0			BIT(16)
+#define PWR_WIO4CIDCFGR_SEMWLC1			BIT(17)
+#define PWR_WIO4CIDCFGR_SEMWLC2			BIT(18)
+#define PWR_WIO4CIDCFGR_SEMWLC3			BIT(19)
+#define PWR_WIO4CIDCFGR_SEMWLC4			BIT(20)
+#define PWR_WIO4CIDCFGR_SEMWLC5			BIT(21)
+#define PWR_WIO4CIDCFGR_SEMWLC6			BIT(22)
+#define PWR_WIO4CIDCFGR_SEMWLC7			BIT(23)
+
+/* PWR_WIO4SEMCR register fields */
+#define PWR_WIO4SEMCR_SEM_MUTEX			BIT(0)
+#define PWR_WIO4SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define PWR_WIO4SEMCR_SEMCID_SHIFT		4
+
+/* PWR_WIO5CIDCFGR register fields */
+#define PWR_WIO5CIDCFGR_CFEN			BIT(0)
+#define PWR_WIO5CIDCFGR_SEM_EN			BIT(1)
+#define PWR_WIO5CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define PWR_WIO5CIDCFGR_SCID_SHIFT		4
+#define PWR_WIO5CIDCFGR_SEMWLC0			BIT(16)
+#define PWR_WIO5CIDCFGR_SEMWLC1			BIT(17)
+#define PWR_WIO5CIDCFGR_SEMWLC2			BIT(18)
+#define PWR_WIO5CIDCFGR_SEMWLC3			BIT(19)
+#define PWR_WIO5CIDCFGR_SEMWLC4			BIT(20)
+#define PWR_WIO5CIDCFGR_SEMWLC5			BIT(21)
+#define PWR_WIO5CIDCFGR_SEMWLC6			BIT(22)
+#define PWR_WIO5CIDCFGR_SEMWLC7			BIT(23)
+
+/* PWR_WIO5SEMCR register fields */
+#define PWR_WIO5SEMCR_SEM_MUTEX			BIT(0)
+#define PWR_WIO5SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define PWR_WIO5SEMCR_SEMCID_SHIFT		4
+
+/* PWR_WIO6CIDCFGR register fields */
+#define PWR_WIO6CIDCFGR_CFEN			BIT(0)
+#define PWR_WIO6CIDCFGR_SEM_EN			BIT(1)
+#define PWR_WIO6CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define PWR_WIO6CIDCFGR_SCID_SHIFT		4
+#define PWR_WIO6CIDCFGR_SEMWLC0			BIT(16)
+#define PWR_WIO6CIDCFGR_SEMWLC1			BIT(17)
+#define PWR_WIO6CIDCFGR_SEMWLC2			BIT(18)
+#define PWR_WIO6CIDCFGR_SEMWLC3			BIT(19)
+#define PWR_WIO6CIDCFGR_SEMWLC4			BIT(20)
+#define PWR_WIO6CIDCFGR_SEMWLC5			BIT(21)
+#define PWR_WIO6CIDCFGR_SEMWLC6			BIT(22)
+#define PWR_WIO6CIDCFGR_SEMWLC7			BIT(23)
+
+/* PWR_WIO6SEMCR register fields */
+#define PWR_WIO6SEMCR_SEM_MUTEX			BIT(0)
+#define PWR_WIO6SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define PWR_WIO6SEMCR_SEMCID_SHIFT		4
+
+/* PWR_CPU1D1SR register fields */
+#define PWR_CPU1D1SR_HOLD_BOOT			BIT(0)
+#define PWR_CPU1D1SR_CSTATE_MASK		GENMASK(3, 2)
+#define PWR_CPU1D1SR_CSTATE_SHIFT		2
+#define PWR_CPU1D1SR_DSTATE_MASK		GENMASK(10, 8)
+#define PWR_CPU1D1SR_DSTATE_SHIFT		8
+
+/* PWR_CPU2D2SR register fields */
+#define PWR_CPU2D2SR_HOLD_BOOT			BIT(0)
+#define PWR_CPU2D2SR_WFBEN			BIT(1)
+#define PWR_CPU2D2SR_CSTATE_MASK		GENMASK(3, 2)
+#define PWR_CPU2D2SR_CSTATE_SHIFT		2
+#define PWR_CPU2D2SR_DSTATE_MASK		GENMASK(10, 8)
+#define PWR_CPU2D2SR_DSTATE_SHIFT		8
+
+/* PWR_CPU3D3SR register fields */
+#define PWR_CPU3D3SR_CSTATE_MASK		GENMASK(3, 2)
+#define PWR_CPU3D3SR_CSTATE_SHIFT		2
+#define PWR_CPU3D3SR_DSTATE_MASK		GENMASK(10, 8)
+#define PWR_CPU3D3SR_DSTATE_SHIFT		8
+
+/* PWR_DBGR register fields */
+#define PWR_DBGR_FD3S				BIT(0)
+#define PWR_DBGR_VDDIOKRETRAM			BIT(16)
+#define PWR_DBGR_VDDIOKBKPRAM			BIT(17)
+#define PWR_DBGR_VDDIOKD3			BIT(18)
+#define PWR_DBGR_VDDIOKLPSRAM1			BIT(19)
+
+/* PWR_VERR register fields */
+#define PWR_VERR_MINREV_MASK			GENMASK(3, 0)
+#define PWR_VERR_MINREV_SHIFT			0
+#define PWR_VERR_MAJREV_MASK			GENMASK(7, 4)
+#define PWR_VERR_MAJREV_SHIFT			4
+
+#endif /* STM32MP2_PWR_H */
diff --git a/include/drivers/st/stm32mp2_ram.h b/include/drivers/st/stm32mp2_ram.h
new file mode 100644
index 000000000..7bda83060
--- /dev/null
+++ b/include/drivers/st/stm32mp2_ram.h
@@ -0,0 +1,13 @@
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_RAM_H
+#define STM32MP2_RAM_H
+
+bool stm32mp2_ddr_is_restored(void);
+int stm32mp2_ddr_probe(void);
+
+#endif /* STM32MP2_RAM_H */
diff --git a/include/drivers/st/stm32mp2_rcc.h b/include/drivers/st/stm32mp2_rcc.h
new file mode 100644
index 000000000..fd097145f
--- /dev/null
+++ b/include/drivers/st/stm32mp2_rcc.h
@@ -0,0 +1,4986 @@
+/*
+ * Copyright (c) 2018-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_RCC_H
+#define STM32MP2_RCC_H
+
+#include <lib/utils_def.h>
+
+#define RCC_SECCFGR0				U(0x0)
+#define RCC_SECCFGR1				U(0x4)
+#define RCC_SECCFGR2				U(0x8)
+#define RCC_SECCFGR3				U(0xC)
+#define RCC_PRIVCFGR0				U(0x10)
+#define RCC_PRIVCFGR1				U(0x14)
+#define RCC_PRIVCFGR2				U(0x18)
+#define RCC_PRIVCFGR3				U(0x1C)
+#define RCC_RCFGLOCKR0				U(0x20)
+#define RCC_RCFGLOCKR1				U(0x24)
+#define RCC_RCFGLOCKR2				U(0x28)
+#define RCC_RCFGLOCKR3				U(0x2C)
+#define RCC_R0CIDCFGR				U(0x30)
+#define RCC_R0SEMCR				U(0x34)
+#define RCC_R1CIDCFGR				U(0x38)
+#define RCC_R1SEMCR				U(0x3C)
+#define RCC_R2CIDCFGR				U(0x40)
+#define RCC_R2SEMCR				U(0x44)
+#define RCC_R3CIDCFGR				U(0x48)
+#define RCC_R3SEMCR				U(0x4C)
+#define RCC_R4CIDCFGR				U(0x50)
+#define RCC_R4SEMCR				U(0x54)
+#define RCC_R5CIDCFGR				U(0x58)
+#define RCC_R5SEMCR				U(0x5C)
+#define RCC_R6CIDCFGR				U(0x60)
+#define RCC_R6SEMCR				U(0x64)
+#define RCC_R7CIDCFGR				U(0x68)
+#define RCC_R7SEMCR				U(0x6C)
+#define RCC_R8CIDCFGR				U(0x70)
+#define RCC_R8SEMCR				U(0x74)
+#define RCC_R9CIDCFGR				U(0x78)
+#define RCC_R9SEMCR				U(0x7C)
+#define RCC_R10CIDCFGR				U(0x80)
+#define RCC_R10SEMCR				U(0x84)
+#define RCC_R11CIDCFGR				U(0x88)
+#define RCC_R11SEMCR				U(0x8C)
+#define RCC_R12CIDCFGR				U(0x90)
+#define RCC_R12SEMCR				U(0x94)
+#define RCC_R13CIDCFGR				U(0x98)
+#define RCC_R13SEMCR				U(0x9C)
+#define RCC_R14CIDCFGR				U(0xA0)
+#define RCC_R14SEMCR				U(0xA4)
+#define RCC_R15CIDCFGR				U(0xA8)
+#define RCC_R15SEMCR				U(0xAC)
+#define RCC_R16CIDCFGR				U(0xB0)
+#define RCC_R16SEMCR				U(0xB4)
+#define RCC_R17CIDCFGR				U(0xB8)
+#define RCC_R17SEMCR				U(0xBC)
+#define RCC_R18CIDCFGR				U(0xC0)
+#define RCC_R18SEMCR				U(0xC4)
+#define RCC_R19CIDCFGR				U(0xC8)
+#define RCC_R19SEMCR				U(0xCC)
+#define RCC_R20CIDCFGR				U(0xD0)
+#define RCC_R20SEMCR				U(0xD4)
+#define RCC_R21CIDCFGR				U(0xD8)
+#define RCC_R21SEMCR				U(0xDC)
+#define RCC_R22CIDCFGR				U(0xE0)
+#define RCC_R22SEMCR				U(0xE4)
+#define RCC_R23CIDCFGR				U(0xE8)
+#define RCC_R23SEMCR				U(0xEC)
+#define RCC_R24CIDCFGR				U(0xF0)
+#define RCC_R24SEMCR				U(0xF4)
+#define RCC_R25CIDCFGR				U(0xF8)
+#define RCC_R25SEMCR				U(0xFC)
+#define RCC_R26CIDCFGR				U(0x100)
+#define RCC_R26SEMCR				U(0x104)
+#define RCC_R27CIDCFGR				U(0x108)
+#define RCC_R27SEMCR				U(0x10C)
+#define RCC_R28CIDCFGR				U(0x110)
+#define RCC_R28SEMCR				U(0x114)
+#define RCC_R29CIDCFGR				U(0x118)
+#define RCC_R29SEMCR				U(0x11C)
+#define RCC_R30CIDCFGR				U(0x120)
+#define RCC_R30SEMCR				U(0x124)
+#define RCC_R31CIDCFGR				U(0x128)
+#define RCC_R31SEMCR				U(0x12C)
+#define RCC_R32CIDCFGR				U(0x130)
+#define RCC_R32SEMCR				U(0x134)
+#define RCC_R33CIDCFGR				U(0x138)
+#define RCC_R33SEMCR				U(0x13C)
+#define RCC_R34CIDCFGR				U(0x140)
+#define RCC_R34SEMCR				U(0x144)
+#define RCC_R35CIDCFGR				U(0x148)
+#define RCC_R35SEMCR				U(0x14C)
+#define RCC_R36CIDCFGR				U(0x150)
+#define RCC_R36SEMCR				U(0x154)
+#define RCC_R37CIDCFGR				U(0x158)
+#define RCC_R37SEMCR				U(0x15C)
+#define RCC_R38CIDCFGR				U(0x160)
+#define RCC_R38SEMCR				U(0x164)
+#define RCC_R39CIDCFGR				U(0x168)
+#define RCC_R39SEMCR				U(0x16C)
+#define RCC_R40CIDCFGR				U(0x170)
+#define RCC_R40SEMCR				U(0x174)
+#define RCC_R41CIDCFGR				U(0x178)
+#define RCC_R41SEMCR				U(0x17C)
+#define RCC_R42CIDCFGR				U(0x180)
+#define RCC_R42SEMCR				U(0x184)
+#define RCC_R43CIDCFGR				U(0x188)
+#define RCC_R43SEMCR				U(0x18C)
+#define RCC_R44CIDCFGR				U(0x190)
+#define RCC_R44SEMCR				U(0x194)
+#define RCC_R45CIDCFGR				U(0x198)
+#define RCC_R45SEMCR				U(0x19C)
+#define RCC_R46CIDCFGR				U(0x1A0)
+#define RCC_R46SEMCR				U(0x1A4)
+#define RCC_R47CIDCFGR				U(0x1A8)
+#define RCC_R47SEMCR				U(0x1AC)
+#define RCC_R48CIDCFGR				U(0x1B0)
+#define RCC_R48SEMCR				U(0x1B4)
+#define RCC_R49CIDCFGR				U(0x1B8)
+#define RCC_R49SEMCR				U(0x1BC)
+#define RCC_R50CIDCFGR				U(0x1C0)
+#define RCC_R50SEMCR				U(0x1C4)
+#define RCC_R51CIDCFGR				U(0x1C8)
+#define RCC_R51SEMCR				U(0x1CC)
+#define RCC_R52CIDCFGR				U(0x1D0)
+#define RCC_R52SEMCR				U(0x1D4)
+#define RCC_R53CIDCFGR				U(0x1D8)
+#define RCC_R53SEMCR				U(0x1DC)
+#define RCC_R54CIDCFGR				U(0x1E0)
+#define RCC_R54SEMCR				U(0x1E4)
+#define RCC_R55CIDCFGR				U(0x1E8)
+#define RCC_R55SEMCR				U(0x1EC)
+#define RCC_R56CIDCFGR				U(0x1F0)
+#define RCC_R56SEMCR				U(0x1F4)
+#define RCC_R57CIDCFGR				U(0x1F8)
+#define RCC_R57SEMCR				U(0x1FC)
+#define RCC_R58CIDCFGR				U(0x200)
+#define RCC_R58SEMCR				U(0x204)
+#define RCC_R59CIDCFGR				U(0x208)
+#define RCC_R59SEMCR				U(0x20C)
+#define RCC_R60CIDCFGR				U(0x210)
+#define RCC_R60SEMCR				U(0x214)
+#define RCC_R61CIDCFGR				U(0x218)
+#define RCC_R61SEMCR				U(0x21C)
+#define RCC_R62CIDCFGR				U(0x220)
+#define RCC_R62SEMCR				U(0x224)
+#define RCC_R63CIDCFGR				U(0x228)
+#define RCC_R63SEMCR				U(0x22C)
+#define RCC_R64CIDCFGR				U(0x230)
+#define RCC_R64SEMCR				U(0x234)
+#define RCC_R65CIDCFGR				U(0x238)
+#define RCC_R65SEMCR				U(0x23C)
+#define RCC_R66CIDCFGR				U(0x240)
+#define RCC_R66SEMCR				U(0x244)
+#define RCC_R67CIDCFGR				U(0x248)
+#define RCC_R67SEMCR				U(0x24C)
+#define RCC_R68CIDCFGR				U(0x250)
+#define RCC_R68SEMCR				U(0x254)
+#define RCC_R69CIDCFGR				U(0x258)
+#define RCC_R69SEMCR				U(0x25C)
+#define RCC_R70CIDCFGR				U(0x260)
+#define RCC_R70SEMCR				U(0x264)
+#define RCC_R71CIDCFGR				U(0x268)
+#define RCC_R71SEMCR				U(0x26C)
+#define RCC_R72CIDCFGR				U(0x270)
+#define RCC_R72SEMCR				U(0x274)
+#define RCC_R73CIDCFGR				U(0x278)
+#define RCC_R73SEMCR				U(0x27C)
+#define RCC_R74CIDCFGR				U(0x280)
+#define RCC_R74SEMCR				U(0x284)
+#define RCC_R75CIDCFGR				U(0x288)
+#define RCC_R75SEMCR				U(0x28C)
+#define RCC_R76CIDCFGR				U(0x290)
+#define RCC_R76SEMCR				U(0x294)
+#define RCC_R77CIDCFGR				U(0x298)
+#define RCC_R77SEMCR				U(0x29C)
+#define RCC_R78CIDCFGR				U(0x2A0)
+#define RCC_R78SEMCR				U(0x2A4)
+#define RCC_R79CIDCFGR				U(0x2A8)
+#define RCC_R79SEMCR				U(0x2AC)
+#define RCC_R80CIDCFGR				U(0x2B0)
+#define RCC_R80SEMCR				U(0x2B4)
+#define RCC_R81CIDCFGR				U(0x2B8)
+#define RCC_R81SEMCR				U(0x2BC)
+#define RCC_R82CIDCFGR				U(0x2C0)
+#define RCC_R82SEMCR				U(0x2C4)
+#define RCC_R83CIDCFGR				U(0x2C8)
+#define RCC_R83SEMCR				U(0x2CC)
+#define RCC_R84CIDCFGR				U(0x2D0)
+#define RCC_R84SEMCR				U(0x2D4)
+#define RCC_R85CIDCFGR				U(0x2D8)
+#define RCC_R85SEMCR				U(0x2DC)
+#define RCC_R86CIDCFGR				U(0x2E0)
+#define RCC_R86SEMCR				U(0x2E4)
+#define RCC_R87CIDCFGR				U(0x2E8)
+#define RCC_R87SEMCR				U(0x2EC)
+#define RCC_R88CIDCFGR				U(0x2F0)
+#define RCC_R88SEMCR				U(0x2F4)
+#define RCC_R89CIDCFGR				U(0x2F8)
+#define RCC_R89SEMCR				U(0x2FC)
+#define RCC_R90CIDCFGR				U(0x300)
+#define RCC_R90SEMCR				U(0x304)
+#define RCC_R91CIDCFGR				U(0x308)
+#define RCC_R91SEMCR				U(0x30C)
+#define RCC_R92CIDCFGR				U(0x310)
+#define RCC_R92SEMCR				U(0x314)
+#define RCC_R93CIDCFGR				U(0x318)
+#define RCC_R93SEMCR				U(0x31C)
+#define RCC_R94CIDCFGR				U(0x320)
+#define RCC_R94SEMCR				U(0x324)
+#define RCC_R95CIDCFGR				U(0x328)
+#define RCC_R95SEMCR				U(0x32C)
+#define RCC_R96CIDCFGR				U(0x330)
+#define RCC_R96SEMCR				U(0x334)
+#define RCC_R97CIDCFGR				U(0x338)
+#define RCC_R97SEMCR				U(0x33C)
+#define RCC_R98CIDCFGR				U(0x340)
+#define RCC_R98SEMCR				U(0x344)
+#define RCC_R99CIDCFGR				U(0x348)
+#define RCC_R99SEMCR				U(0x34C)
+#define RCC_R100CIDCFGR				U(0x350)
+#define RCC_R100SEMCR				U(0x354)
+#define RCC_R101CIDCFGR				U(0x358)
+#define RCC_R101SEMCR				U(0x35C)
+#define RCC_R102CIDCFGR				U(0x360)
+#define RCC_R102SEMCR				U(0x364)
+#define RCC_R103CIDCFGR				U(0x368)
+#define RCC_R103SEMCR				U(0x36C)
+#define RCC_R104CIDCFGR				U(0x370)
+#define RCC_R104SEMCR				U(0x374)
+#define RCC_R105CIDCFGR				U(0x378)
+#define RCC_R105SEMCR				U(0x37C)
+#define RCC_R106CIDCFGR				U(0x380)
+#define RCC_R106SEMCR				U(0x384)
+#define RCC_R107CIDCFGR				U(0x388)
+#define RCC_R107SEMCR				U(0x38C)
+#define RCC_R108CIDCFGR				U(0x390)
+#define RCC_R108SEMCR				U(0x394)
+#define RCC_R109CIDCFGR				U(0x398)
+#define RCC_R109SEMCR				U(0x39C)
+#define RCC_R110CIDCFGR				U(0x3A0)
+#define RCC_R110SEMCR				U(0x3A4)
+#define RCC_R111CIDCFGR				U(0x3A8)
+#define RCC_R111SEMCR				U(0x3AC)
+#define RCC_R112CIDCFGR				U(0x3B0)
+#define RCC_R112SEMCR				U(0x3B4)
+#define RCC_R113CIDCFGR				U(0x3B8)
+#define RCC_R113SEMCR				U(0x3BC)
+#define RCC_GRSTCSETR				U(0x400)
+#define RCC_C1RSTCSETR				U(0x404)
+#define RCC_C1P1RSTCSETR			U(0x408)
+#define RCC_C2RSTCSETR				U(0x40C)
+#define RCC_HWRSTSCLRR				U(0x410)
+#define RCC_C1HWRSTSCLRR			U(0x414)
+#define RCC_C2HWRSTSCLRR			U(0x418)
+#define RCC_C1BOOTRSTSSETR			U(0x41C)
+#define RCC_C1BOOTRSTSCLRR			U(0x420)
+#define RCC_C2BOOTRSTSSETR			U(0x424)
+#define RCC_C2BOOTRSTSCLRR			U(0x428)
+#define RCC_C1SREQSETR				U(0x42C)
+#define RCC_C1SREQCLRR				U(0x430)
+#define RCC_CPUBOOTCR				U(0x434)
+#define RCC_STBYBOOTCR				U(0x438)
+#define RCC_LEGBOOTCR				U(0x43C)
+#define RCC_BDCR				U(0x440)
+#define RCC_D3DCR				U(0x444)
+#define RCC_D3DSR				U(0x448)
+#define RCC_RDCR				U(0x44C)
+#define RCC_C1MSRDCR				U(0x450)
+#define RCC_PWRLPDLYCR				U(0x454)
+#define RCC_C1CIESETR				U(0x458)
+#define RCC_C1CIFCLRR				U(0x45C)
+#define RCC_C2CIESETR				U(0x460)
+#define RCC_C2CIFCLRR				U(0x464)
+#define RCC_IWDGC1FZSETR			U(0x468)
+#define RCC_IWDGC1FZCLRR			U(0x46C)
+#define RCC_IWDGC1CFGSETR			U(0x470)
+#define RCC_IWDGC1CFGCLRR			U(0x474)
+#define RCC_IWDGC2FZSETR			U(0x478)
+#define RCC_IWDGC2FZCLRR			U(0x47C)
+#define RCC_IWDGC2CFGSETR			U(0x480)
+#define RCC_IWDGC2CFGCLRR			U(0x484)
+#define RCC_IWDGC3CFGSETR			U(0x488)
+#define RCC_IWDGC3CFGCLRR			U(0x48C)
+#define RCC_C3CFGR				U(0x490)
+#define RCC_MCO1CFGR				U(0x494)
+#define RCC_MCO2CFGR				U(0x498)
+#define RCC_OCENSETR				U(0x49C)
+#define RCC_OCENCLRR				U(0x4A0)
+#define RCC_OCRDYR				U(0x4A4)
+#define RCC_HSICFGR				U(0x4A8)
+#define RCC_CSICFGR				U(0x4AC)
+#define RCC_RTCDIVR				U(0x4B0)
+#define RCC_APB1DIVR				U(0x4B4)
+#define RCC_APB2DIVR				U(0x4B8)
+#define RCC_APB3DIVR				U(0x4BC)
+#define RCC_APB4DIVR				U(0x4C0)
+#define RCC_APBDBGDIVR				U(0x4C4)
+#define RCC_TIMG1PRER				U(0x4C8)
+#define RCC_TIMG2PRER				U(0x4CC)
+#define RCC_LSMCUDIVR				U(0x4D0)
+#define RCC_DDRCPCFGR				U(0x4D4)
+#define RCC_DDRCAPBCFGR				U(0x4D8)
+#define RCC_DDRPHYCAPBCFGR			U(0x4DC)
+#define RCC_DDRPHYCCFGR				U(0x4E0)
+#define RCC_DDRCFGR				U(0x4E4)
+#define RCC_DDRITFCFGR				U(0x4E8)
+#define RCC_SYSRAMCFGR				U(0x4F0)
+#define RCC_VDERAMCFGR				U(0x4F4)
+#define RCC_SRAM1CFGR				U(0x4F8)
+#define RCC_SRAM2CFGR				U(0x4FC)
+#define RCC_RETRAMCFGR				U(0x500)
+#define RCC_BKPSRAMCFGR				U(0x504)
+#define RCC_LPSRAM1CFGR				U(0x508)
+#define RCC_LPSRAM2CFGR				U(0x50C)
+#define RCC_LPSRAM3CFGR				U(0x510)
+#define RCC_OSPI1CFGR				U(0x514)
+#define RCC_OSPI2CFGR				U(0x518)
+#define RCC_FMCCFGR				U(0x51C)
+#define RCC_DBGCFGR				U(0x520)
+#define RCC_STM500CFGR				U(0x524)
+#define RCC_ETRCFGR				U(0x528)
+#define RCC_GPIOACFGR				U(0x52C)
+#define RCC_GPIOBCFGR				U(0x530)
+#define RCC_GPIOCCFGR				U(0x534)
+#define RCC_GPIODCFGR				U(0x538)
+#define RCC_GPIOECFGR				U(0x53C)
+#define RCC_GPIOFCFGR				U(0x540)
+#define RCC_GPIOGCFGR				U(0x544)
+#define RCC_GPIOHCFGR				U(0x548)
+#define RCC_GPIOICFGR				U(0x54C)
+#define RCC_GPIOJCFGR				U(0x550)
+#define RCC_GPIOKCFGR				U(0x554)
+#define RCC_GPIOZCFGR				U(0x558)
+#define RCC_HPDMA1CFGR				U(0x55C)
+#define RCC_HPDMA2CFGR				U(0x560)
+#define RCC_HPDMA3CFGR				U(0x564)
+#define RCC_LPDMACFGR				U(0x568)
+#define RCC_HSEMCFGR				U(0x56C)
+#define RCC_IPCC1CFGR				U(0x570)
+#define RCC_IPCC2CFGR				U(0x574)
+#define RCC_RTCCFGR				U(0x578)
+#define RCC_SYSCPU1CFGR				U(0x580)
+#define RCC_BSECCFGR				U(0x584)
+#define RCC_IS2MCFGR				U(0x58C)
+#define RCC_PLL2CFGR1				U(0x590)
+#define RCC_PLL2CFGR2				U(0x594)
+#define RCC_PLL2CFGR3				U(0x598)
+#define RCC_PLL2CFGR4				U(0x59C)
+#define RCC_PLL2CFGR5				U(0x5A0)
+#define RCC_PLL2CFGR6				U(0x5A8)
+#define RCC_PLL2CFGR7				U(0x5AC)
+#define RCC_PLL3CFGR1				U(0x5B8)
+#define RCC_PLL3CFGR2				U(0x5BC)
+#define RCC_PLL3CFGR3				U(0x5C0)
+#define RCC_PLL3CFGR4				U(0x5C4)
+#define RCC_PLL3CFGR5				U(0x5C8)
+#define RCC_PLL3CFGR6				U(0x5D0)
+#define RCC_PLL3CFGR7				U(0x5D4)
+#define RCC_HSIFMONCR				U(0x5E0)
+#define RCC_HSIFVALR				U(0x5E4)
+#define RCC_TIM1CFGR				U(0x700)
+#define RCC_TIM2CFGR				U(0x704)
+#define RCC_TIM3CFGR				U(0x708)
+#define RCC_TIM4CFGR				U(0x70C)
+#define RCC_TIM5CFGR				U(0x710)
+#define RCC_TIM6CFGR				U(0x714)
+#define RCC_TIM7CFGR				U(0x718)
+#define RCC_TIM8CFGR				U(0x71C)
+#define RCC_TIM10CFGR				U(0x720)
+#define RCC_TIM11CFGR				U(0x724)
+#define RCC_TIM12CFGR				U(0x728)
+#define RCC_TIM13CFGR				U(0x72C)
+#define RCC_TIM14CFGR				U(0x730)
+#define RCC_TIM15CFGR				U(0x734)
+#define RCC_TIM16CFGR				U(0x738)
+#define RCC_TIM17CFGR				U(0x73C)
+#define RCC_TIM20CFGR				U(0x740)
+#define RCC_LPTIM1CFGR				U(0x744)
+#define RCC_LPTIM2CFGR				U(0x748)
+#define RCC_LPTIM3CFGR				U(0x74C)
+#define RCC_LPTIM4CFGR				U(0x750)
+#define RCC_LPTIM5CFGR				U(0x754)
+#define RCC_SPI1CFGR				U(0x758)
+#define RCC_SPI2CFGR				U(0x75C)
+#define RCC_SPI3CFGR				U(0x760)
+#define RCC_SPI4CFGR				U(0x764)
+#define RCC_SPI5CFGR				U(0x768)
+#define RCC_SPI6CFGR				U(0x76C)
+#define RCC_SPI7CFGR				U(0x770)
+#define RCC_SPI8CFGR				U(0x774)
+#define RCC_SPDIFRXCFGR				U(0x778)
+#define RCC_USART1CFGR				U(0x77C)
+#define RCC_USART2CFGR				U(0x780)
+#define RCC_USART3CFGR				U(0x784)
+#define RCC_UART4CFGR				U(0x788)
+#define RCC_UART5CFGR				U(0x78C)
+#define RCC_USART6CFGR				U(0x790)
+#define RCC_UART7CFGR				U(0x794)
+#define RCC_UART8CFGR				U(0x798)
+#define RCC_UART9CFGR				U(0x79C)
+#define RCC_LPUART1CFGR				U(0x7A0)
+#define RCC_I2C1CFGR				U(0x7A4)
+#define RCC_I2C2CFGR				U(0x7A8)
+#define RCC_I2C3CFGR				U(0x7AC)
+#define RCC_I2C4CFGR				U(0x7B0)
+#define RCC_I2C5CFGR				U(0x7B4)
+#define RCC_I2C6CFGR				U(0x7B8)
+#define RCC_I2C7CFGR				U(0x7BC)
+#define RCC_I2C8CFGR				U(0x7C0)
+#define RCC_SAI1CFGR				U(0x7C4)
+#define RCC_SAI2CFGR				U(0x7C8)
+#define RCC_SAI3CFGR				U(0x7CC)
+#define RCC_SAI4CFGR				U(0x7D0)
+#define RCC_MDF1CFGR				U(0x7D8)
+#define RCC_ADF1CFGR				U(0x7DC)
+#define RCC_FDCANCFGR				U(0x7E0)
+#define RCC_HDPCFGR				U(0x7E4)
+#define RCC_ADC12CFGR				U(0x7E8)
+#define RCC_ADC3CFGR				U(0x7EC)
+#define RCC_ETH1CFGR				U(0x7F0)
+#define RCC_ETH2CFGR				U(0x7F4)
+#define RCC_USB2CFGR				U(0x7FC)
+#define RCC_USB2PHY1CFGR			U(0x800)
+#define RCC_USB2PHY2CFGR			U(0x804)
+#define RCC_USB3DRDCFGR				U(0x808)
+#define RCC_USB3PCIEPHYCFGR			U(0x80C)
+#define RCC_PCIECFGR				U(0x810)
+#define RCC_USBTCCFGR				U(0x814)
+#define RCC_ETHSWCFGR				U(0x818)
+#define RCC_ETHSWACMCFGR			U(0x81C)
+#define RCC_ETHSWACMMSGCFGR			U(0x820)
+#define RCC_STGENCFGR				U(0x824)
+#define RCC_SDMMC1CFGR				U(0x830)
+#define RCC_SDMMC2CFGR				U(0x834)
+#define RCC_SDMMC3CFGR				U(0x838)
+#define RCC_GPUCFGR				U(0x83C)
+#define RCC_LTDCCFGR				U(0x840)
+#define RCC_DSICFGR				U(0x844)
+#define RCC_LVDSCFGR				U(0x850)
+#define RCC_CSI2CFGR				U(0x858)
+#define RCC_DCMIPPCFGR				U(0x85C)
+#define RCC_CCICFGR				U(0x860)
+#define RCC_VDECCFGR				U(0x864)
+#define RCC_VENCCFGR				U(0x868)
+#define RCC_RNGCFGR				U(0x870)
+#define RCC_PKACFGR				U(0x874)
+#define RCC_SAESCFGR				U(0x878)
+#define RCC_HASHCFGR				U(0x87C)
+#define RCC_CRYP1CFGR				U(0x880)
+#define RCC_CRYP2CFGR				U(0x884)
+#define RCC_IWDG1CFGR				U(0x888)
+#define RCC_IWDG2CFGR				U(0x88C)
+#define RCC_IWDG3CFGR				U(0x890)
+#define RCC_IWDG4CFGR				U(0x894)
+#define RCC_IWDG5CFGR				U(0x898)
+#define RCC_WWDG1CFGR				U(0x89C)
+#define RCC_WWDG2CFGR				U(0x8A0)
+#define RCC_BUSPERFMCFGR			U(0x8A4)
+#define RCC_VREFCFGR				U(0x8A8)
+#define RCC_TMPSENSCFGR				U(0x8AC)
+#define RCC_CRCCFGR				U(0x8B4)
+#define RCC_SERCCFGR				U(0x8B8)
+#define RCC_OSPIIOMCFGR				U(0x8BC)
+#define RCC_GICV2MCFGR				U(0x8C0)
+#define RCC_I3C1CFGR				U(0x8C8)
+#define RCC_I3C2CFGR				U(0x8CC)
+#define RCC_I3C3CFGR				U(0x8D0)
+#define RCC_I3C4CFGR				U(0x8D4)
+#define RCC_MUXSELCFGR				U(0x1000)
+#define RCC_XBAR0CFGR				U(0x1018)
+#define RCC_XBAR1CFGR				U(0x101C)
+#define RCC_XBAR2CFGR				U(0x1020)
+#define RCC_XBAR3CFGR				U(0x1024)
+#define RCC_XBAR4CFGR				U(0x1028)
+#define RCC_XBAR5CFGR				U(0x102C)
+#define RCC_XBAR6CFGR				U(0x1030)
+#define RCC_XBAR7CFGR				U(0x1034)
+#define RCC_XBAR8CFGR				U(0x1038)
+#define RCC_XBAR9CFGR				U(0x103C)
+#define RCC_XBAR10CFGR				U(0x1040)
+#define RCC_XBAR11CFGR				U(0x1044)
+#define RCC_XBAR12CFGR				U(0x1048)
+#define RCC_XBAR13CFGR				U(0x104C)
+#define RCC_XBAR14CFGR				U(0x1050)
+#define RCC_XBAR15CFGR				U(0x1054)
+#define RCC_XBAR16CFGR				U(0x1058)
+#define RCC_XBAR17CFGR				U(0x105C)
+#define RCC_XBAR18CFGR				U(0x1060)
+#define RCC_XBAR19CFGR				U(0x1064)
+#define RCC_XBAR20CFGR				U(0x1068)
+#define RCC_XBAR21CFGR				U(0x106C)
+#define RCC_XBAR22CFGR				U(0x1070)
+#define RCC_XBAR23CFGR				U(0x1074)
+#define RCC_XBAR24CFGR				U(0x1078)
+#define RCC_XBAR25CFGR				U(0x107C)
+#define RCC_XBAR26CFGR				U(0x1080)
+#define RCC_XBAR27CFGR				U(0x1084)
+#define RCC_XBAR28CFGR				U(0x1088)
+#define RCC_XBAR29CFGR				U(0x108C)
+#define RCC_XBAR30CFGR				U(0x1090)
+#define RCC_XBAR31CFGR				U(0x1094)
+#define RCC_XBAR32CFGR				U(0x1098)
+#define RCC_XBAR33CFGR				U(0x109C)
+#define RCC_XBAR34CFGR				U(0x10A0)
+#define RCC_XBAR35CFGR				U(0x10A4)
+#define RCC_XBAR36CFGR				U(0x10A8)
+#define RCC_XBAR37CFGR				U(0x10AC)
+#define RCC_XBAR38CFGR				U(0x10B0)
+#define RCC_XBAR39CFGR				U(0x10B4)
+#define RCC_XBAR40CFGR				U(0x10B8)
+#define RCC_XBAR41CFGR				U(0x10BC)
+#define RCC_XBAR42CFGR				U(0x10C0)
+#define RCC_XBAR43CFGR				U(0x10C4)
+#define RCC_XBAR44CFGR				U(0x10C8)
+#define RCC_XBAR45CFGR				U(0x10CC)
+#define RCC_XBAR46CFGR				U(0x10D0)
+#define RCC_XBAR47CFGR				U(0x10D4)
+#define RCC_XBAR48CFGR				U(0x10D8)
+#define RCC_XBAR49CFGR				U(0x10DC)
+#define RCC_XBAR50CFGR				U(0x10E0)
+#define RCC_XBAR51CFGR				U(0x10E4)
+#define RCC_XBAR52CFGR				U(0x10E8)
+#define RCC_XBAR53CFGR				U(0x10EC)
+#define RCC_XBAR54CFGR				U(0x10F0)
+#define RCC_XBAR55CFGR				U(0x10F4)
+#define RCC_XBAR56CFGR				U(0x10F8)
+#define RCC_XBAR57CFGR				U(0x10FC)
+#define RCC_XBAR58CFGR				U(0x1100)
+#define RCC_XBAR59CFGR				U(0x1104)
+#define RCC_XBAR60CFGR				U(0x1108)
+#define RCC_XBAR61CFGR				U(0x110C)
+#define RCC_XBAR62CFGR				U(0x1110)
+#define RCC_XBAR63CFGR				U(0x1114)
+#define RCC_PREDIV0CFGR				U(0x1118)
+#define RCC_PREDIV1CFGR				U(0x111C)
+#define RCC_PREDIV2CFGR				U(0x1120)
+#define RCC_PREDIV3CFGR				U(0x1124)
+#define RCC_PREDIV4CFGR				U(0x1128)
+#define RCC_PREDIV5CFGR				U(0x112C)
+#define RCC_PREDIV6CFGR				U(0x1130)
+#define RCC_PREDIV7CFGR				U(0x1134)
+#define RCC_PREDIV8CFGR				U(0x1138)
+#define RCC_PREDIV9CFGR				U(0x113C)
+#define RCC_PREDIV10CFGR			U(0x1140)
+#define RCC_PREDIV11CFGR			U(0x1144)
+#define RCC_PREDIV12CFGR			U(0x1148)
+#define RCC_PREDIV13CFGR			U(0x114C)
+#define RCC_PREDIV14CFGR			U(0x1150)
+#define RCC_PREDIV15CFGR			U(0x1154)
+#define RCC_PREDIV16CFGR			U(0x1158)
+#define RCC_PREDIV17CFGR			U(0x115C)
+#define RCC_PREDIV18CFGR			U(0x1160)
+#define RCC_PREDIV19CFGR			U(0x1164)
+#define RCC_PREDIV20CFGR			U(0x1168)
+#define RCC_PREDIV21CFGR			U(0x116C)
+#define RCC_PREDIV22CFGR			U(0x1170)
+#define RCC_PREDIV23CFGR			U(0x1174)
+#define RCC_PREDIV24CFGR			U(0x1178)
+#define RCC_PREDIV25CFGR			U(0x117C)
+#define RCC_PREDIV26CFGR			U(0x1180)
+#define RCC_PREDIV27CFGR			U(0x1184)
+#define RCC_PREDIV28CFGR			U(0x1188)
+#define RCC_PREDIV29CFGR			U(0x118C)
+#define RCC_PREDIV30CFGR			U(0x1190)
+#define RCC_PREDIV31CFGR			U(0x1194)
+#define RCC_PREDIV32CFGR			U(0x1198)
+#define RCC_PREDIV33CFGR			U(0x119C)
+#define RCC_PREDIV34CFGR			U(0x11A0)
+#define RCC_PREDIV35CFGR			U(0x11A4)
+#define RCC_PREDIV36CFGR			U(0x11A8)
+#define RCC_PREDIV37CFGR			U(0x11AC)
+#define RCC_PREDIV38CFGR			U(0x11B0)
+#define RCC_PREDIV39CFGR			U(0x11B4)
+#define RCC_PREDIV40CFGR			U(0x11B8)
+#define RCC_PREDIV41CFGR			U(0x11BC)
+#define RCC_PREDIV42CFGR			U(0x11C0)
+#define RCC_PREDIV43CFGR			U(0x11C4)
+#define RCC_PREDIV44CFGR			U(0x11C8)
+#define RCC_PREDIV45CFGR			U(0x11CC)
+#define RCC_PREDIV46CFGR			U(0x11D0)
+#define RCC_PREDIV47CFGR			U(0x11D4)
+#define RCC_PREDIV48CFGR			U(0x11D8)
+#define RCC_PREDIV49CFGR			U(0x11DC)
+#define RCC_PREDIV50CFGR			U(0x11E0)
+#define RCC_PREDIV51CFGR			U(0x11E4)
+#define RCC_PREDIV52CFGR			U(0x11E8)
+#define RCC_PREDIV53CFGR			U(0x11EC)
+#define RCC_PREDIV54CFGR			U(0x11F0)
+#define RCC_PREDIV55CFGR			U(0x11F4)
+#define RCC_PREDIV56CFGR			U(0x11F8)
+#define RCC_PREDIV57CFGR			U(0x11FC)
+#define RCC_PREDIV58CFGR			U(0x1200)
+#define RCC_PREDIV59CFGR			U(0x1204)
+#define RCC_PREDIV60CFGR			U(0x1208)
+#define RCC_PREDIV61CFGR			U(0x120C)
+#define RCC_PREDIV62CFGR			U(0x1210)
+#define RCC_PREDIV63CFGR			U(0x1214)
+#define RCC_PREDIVSR1				U(0x1218)
+#define RCC_PREDIVSR2				U(0x121C)
+#define RCC_FINDIV0CFGR				U(0x1224)
+#define RCC_FINDIV1CFGR				U(0x1228)
+#define RCC_FINDIV2CFGR				U(0x122C)
+#define RCC_FINDIV3CFGR				U(0x1230)
+#define RCC_FINDIV4CFGR				U(0x1234)
+#define RCC_FINDIV5CFGR				U(0x1238)
+#define RCC_FINDIV6CFGR				U(0x123C)
+#define RCC_FINDIV7CFGR				U(0x1240)
+#define RCC_FINDIV8CFGR				U(0x1244)
+#define RCC_FINDIV9CFGR				U(0x1248)
+#define RCC_FINDIV10CFGR			U(0x124C)
+#define RCC_FINDIV11CFGR			U(0x1250)
+#define RCC_FINDIV12CFGR			U(0x1254)
+#define RCC_FINDIV13CFGR			U(0x1258)
+#define RCC_FINDIV14CFGR			U(0x125C)
+#define RCC_FINDIV15CFGR			U(0x1260)
+#define RCC_FINDIV16CFGR			U(0x1264)
+#define RCC_FINDIV17CFGR			U(0x1268)
+#define RCC_FINDIV18CFGR			U(0x126C)
+#define RCC_FINDIV19CFGR			U(0x1270)
+#define RCC_FINDIV20CFGR			U(0x1274)
+#define RCC_FINDIV21CFGR			U(0x1278)
+#define RCC_FINDIV22CFGR			U(0x127C)
+#define RCC_FINDIV23CFGR			U(0x1280)
+#define RCC_FINDIV24CFGR			U(0x1284)
+#define RCC_FINDIV25CFGR			U(0x1288)
+#define RCC_FINDIV26CFGR			U(0x128C)
+#define RCC_FINDIV27CFGR			U(0x1290)
+#define RCC_FINDIV28CFGR			U(0x1294)
+#define RCC_FINDIV29CFGR			U(0x1298)
+#define RCC_FINDIV30CFGR			U(0x129C)
+#define RCC_FINDIV31CFGR			U(0x12A0)
+#define RCC_FINDIV32CFGR			U(0x12A4)
+#define RCC_FINDIV33CFGR			U(0x12A8)
+#define RCC_FINDIV34CFGR			U(0x12AC)
+#define RCC_FINDIV35CFGR			U(0x12B0)
+#define RCC_FINDIV36CFGR			U(0x12B4)
+#define RCC_FINDIV37CFGR			U(0x12B8)
+#define RCC_FINDIV38CFGR			U(0x12BC)
+#define RCC_FINDIV39CFGR			U(0x12C0)
+#define RCC_FINDIV40CFGR			U(0x12C4)
+#define RCC_FINDIV41CFGR			U(0x12C8)
+#define RCC_FINDIV42CFGR			U(0x12CC)
+#define RCC_FINDIV43CFGR			U(0x12D0)
+#define RCC_FINDIV44CFGR			U(0x12D4)
+#define RCC_FINDIV45CFGR			U(0x12D8)
+#define RCC_FINDIV46CFGR			U(0x12DC)
+#define RCC_FINDIV47CFGR			U(0x12E0)
+#define RCC_FINDIV48CFGR			U(0x12E4)
+#define RCC_FINDIV49CFGR			U(0x12E8)
+#define RCC_FINDIV50CFGR			U(0x12EC)
+#define RCC_FINDIV51CFGR			U(0x12F0)
+#define RCC_FINDIV52CFGR			U(0x12F4)
+#define RCC_FINDIV53CFGR			U(0x12F8)
+#define RCC_FINDIV54CFGR			U(0x12FC)
+#define RCC_FINDIV55CFGR			U(0x1300)
+#define RCC_FINDIV56CFGR			U(0x1304)
+#define RCC_FINDIV57CFGR			U(0x1308)
+#define RCC_FINDIV58CFGR			U(0x130C)
+#define RCC_FINDIV59CFGR			U(0x1310)
+#define RCC_FINDIV60CFGR			U(0x1314)
+#define RCC_FINDIV61CFGR			U(0x1318)
+#define RCC_FINDIV62CFGR			U(0x131C)
+#define RCC_FINDIV63CFGR			U(0x1320)
+#define RCC_FINDIVSR1				U(0x1324)
+#define RCC_FINDIVSR2				U(0x1328)
+#define RCC_FCALCOBS0CFGR			U(0x1340)
+#define RCC_FCALCOBS1CFGR			U(0x1344)
+#define RCC_FCALCREFCFGR			U(0x1348)
+#define RCC_FCALCCR1				U(0x134C)
+#define RCC_FCALCCR2				U(0x1354)
+#define RCC_FCALCSR				U(0x1358)
+#define RCC_PLL4CFGR1				U(0x1360)
+#define RCC_PLL4CFGR2				U(0x1364)
+#define RCC_PLL4CFGR3				U(0x1368)
+#define RCC_PLL4CFGR4				U(0x136C)
+#define RCC_PLL4CFGR5				U(0x1370)
+#define RCC_PLL4CFGR6				U(0x1378)
+#define RCC_PLL4CFGR7				U(0x137C)
+#define RCC_PLL5CFGR1				U(0x1388)
+#define RCC_PLL5CFGR2				U(0x138C)
+#define RCC_PLL5CFGR3				U(0x1390)
+#define RCC_PLL5CFGR4				U(0x1394)
+#define RCC_PLL5CFGR5				U(0x1398)
+#define RCC_PLL5CFGR6				U(0x13A0)
+#define RCC_PLL5CFGR7				U(0x13A4)
+#define RCC_PLL6CFGR1				U(0x13B0)
+#define RCC_PLL6CFGR2				U(0x13B4)
+#define RCC_PLL6CFGR3				U(0x13B8)
+#define RCC_PLL6CFGR4				U(0x13BC)
+#define RCC_PLL6CFGR5				U(0x13C0)
+#define RCC_PLL6CFGR6				U(0x13C8)
+#define RCC_PLL6CFGR7				U(0x13CC)
+#define RCC_PLL7CFGR1				U(0x13D8)
+#define RCC_PLL7CFGR2				U(0x13DC)
+#define RCC_PLL7CFGR3				U(0x13E0)
+#define RCC_PLL7CFGR4				U(0x13E4)
+#define RCC_PLL7CFGR5				U(0x13E8)
+#define RCC_PLL7CFGR6				U(0x13F0)
+#define RCC_PLL7CFGR7				U(0x13F4)
+#define RCC_PLL8CFGR1				U(0x1400)
+#define RCC_PLL8CFGR2				U(0x1404)
+#define RCC_PLL8CFGR3				U(0x1408)
+#define RCC_PLL8CFGR4				U(0x140C)
+#define RCC_PLL8CFGR5				U(0x1410)
+#define RCC_PLL8CFGR6				U(0x1418)
+#define RCC_PLL8CFGR7				U(0x141C)
+#define RCC_VERR				U(0xFFF4)
+#define RCC_IDR					U(0xFFF8)
+#define RCC_SIDR				U(0xFFFC)
+
+/* Offset between RCC_MP_xxxENSETR and RCC_MP_xxxENCLRR registers */
+#define RCC_MP_ENCLRR_OFFSET			U(4)
+
+/* RCC_SECCFGR3 register fields */
+#define RCC_SECCFGR3_SEC_MASK			GENMASK(17, 0)
+#define RCC_SECCFGR3_SEC_SHIFT			0
+
+/* RCC_PRIVCFGR3 register fields */
+#define RCC_PRIVCFGR3_PRIV_MASK			GENMASK(17, 0)
+#define RCC_PRIVCFGR3_PRIV_SHIFT		0
+
+/* RCC_RCFGLOCKR3 register fields */
+#define RCC_RCFGLOCKR3_RLOCK_MASK		GENMASK(17, 0)
+#define RCC_RCFGLOCKR3_RLOCK_SHIFT		0
+
+/* RCC_R0CIDCFGR register fields */
+#define RCC_R0CIDCFGR_CFEN			BIT(0)
+#define RCC_R0CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R0CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R0CIDCFGR_SCID_SHIFT		4
+#define RCC_R0CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R0CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R0SEMCR register fields */
+#define RCC_R0SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R0SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R0SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R1CIDCFGR register fields */
+#define RCC_R1CIDCFGR_CFEN			BIT(0)
+#define RCC_R1CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R1CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R1CIDCFGR_SCID_SHIFT		4
+#define RCC_R1CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R1CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R1SEMCR register fields */
+#define RCC_R1SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R1SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R1SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R2CIDCFGR register fields */
+#define RCC_R2CIDCFGR_CFEN			BIT(0)
+#define RCC_R2CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R2CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R2CIDCFGR_SCID_SHIFT		4
+#define RCC_R2CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R2CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R2SEMCR register fields */
+#define RCC_R2SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R2SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R2SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R3CIDCFGR register fields */
+#define RCC_R3CIDCFGR_CFEN			BIT(0)
+#define RCC_R3CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R3CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R3CIDCFGR_SCID_SHIFT		4
+#define RCC_R3CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R3CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R3SEMCR register fields */
+#define RCC_R3SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R3SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R3SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R4CIDCFGR register fields */
+#define RCC_R4CIDCFGR_CFEN			BIT(0)
+#define RCC_R4CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R4CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R4CIDCFGR_SCID_SHIFT		4
+#define RCC_R4CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R4CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R4SEMCR register fields */
+#define RCC_R4SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R4SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R4SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R5CIDCFGR register fields */
+#define RCC_R5CIDCFGR_CFEN			BIT(0)
+#define RCC_R5CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R5CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R5CIDCFGR_SCID_SHIFT		4
+#define RCC_R5CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R5CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R5SEMCR register fields */
+#define RCC_R5SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R5SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R5SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R6CIDCFGR register fields */
+#define RCC_R6CIDCFGR_CFEN			BIT(0)
+#define RCC_R6CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R6CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R6CIDCFGR_SCID_SHIFT		4
+#define RCC_R6CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R6CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R6SEMCR register fields */
+#define RCC_R6SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R6SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R6SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R7CIDCFGR register fields */
+#define RCC_R7CIDCFGR_CFEN			BIT(0)
+#define RCC_R7CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R7CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R7CIDCFGR_SCID_SHIFT		4
+#define RCC_R7CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R7CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R7SEMCR register fields */
+#define RCC_R7SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R7SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R7SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R8CIDCFGR register fields */
+#define RCC_R8CIDCFGR_CFEN			BIT(0)
+#define RCC_R8CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R8CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R8CIDCFGR_SCID_SHIFT		4
+#define RCC_R8CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R8CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R8SEMCR register fields */
+#define RCC_R8SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R8SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R8SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R9CIDCFGR register fields */
+#define RCC_R9CIDCFGR_CFEN			BIT(0)
+#define RCC_R9CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R9CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R9CIDCFGR_SCID_SHIFT		4
+#define RCC_R9CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R9CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R9SEMCR register fields */
+#define RCC_R9SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R9SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R9SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R10CIDCFGR register fields */
+#define RCC_R10CIDCFGR_CFEN			BIT(0)
+#define RCC_R10CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R10CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R10CIDCFGR_SCID_SHIFT		4
+#define RCC_R10CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R10CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R10SEMCR register fields */
+#define RCC_R10SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R10SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R10SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R11CIDCFGR register fields */
+#define RCC_R11CIDCFGR_CFEN			BIT(0)
+#define RCC_R11CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R11CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R11CIDCFGR_SCID_SHIFT		4
+#define RCC_R11CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R11CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R11SEMCR register fields */
+#define RCC_R11SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R11SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R11SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R12CIDCFGR register fields */
+#define RCC_R12CIDCFGR_CFEN			BIT(0)
+#define RCC_R12CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R12CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R12CIDCFGR_SCID_SHIFT		4
+#define RCC_R12CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R12CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R12SEMCR register fields */
+#define RCC_R12SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R12SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R12SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R13CIDCFGR register fields */
+#define RCC_R13CIDCFGR_CFEN			BIT(0)
+#define RCC_R13CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R13CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R13CIDCFGR_SCID_SHIFT		4
+#define RCC_R13CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R13CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R13SEMCR register fields */
+#define RCC_R13SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R13SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R13SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R14CIDCFGR register fields */
+#define RCC_R14CIDCFGR_CFEN			BIT(0)
+#define RCC_R14CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R14CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R14CIDCFGR_SCID_SHIFT		4
+#define RCC_R14CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R14CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R14SEMCR register fields */
+#define RCC_R14SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R14SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R14SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R15CIDCFGR register fields */
+#define RCC_R15CIDCFGR_CFEN			BIT(0)
+#define RCC_R15CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R15CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R15CIDCFGR_SCID_SHIFT		4
+#define RCC_R15CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R15CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R15SEMCR register fields */
+#define RCC_R15SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R15SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R15SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R16CIDCFGR register fields */
+#define RCC_R16CIDCFGR_CFEN			BIT(0)
+#define RCC_R16CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R16CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R16CIDCFGR_SCID_SHIFT		4
+#define RCC_R16CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R16CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R16SEMCR register fields */
+#define RCC_R16SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R16SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R16SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R17CIDCFGR register fields */
+#define RCC_R17CIDCFGR_CFEN			BIT(0)
+#define RCC_R17CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R17CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R17CIDCFGR_SCID_SHIFT		4
+#define RCC_R17CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R17CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R17SEMCR register fields */
+#define RCC_R17SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R17SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R17SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R18CIDCFGR register fields */
+#define RCC_R18CIDCFGR_CFEN			BIT(0)
+#define RCC_R18CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R18CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R18CIDCFGR_SCID_SHIFT		4
+#define RCC_R18CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R18CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R18SEMCR register fields */
+#define RCC_R18SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R18SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R18SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R19CIDCFGR register fields */
+#define RCC_R19CIDCFGR_CFEN			BIT(0)
+#define RCC_R19CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R19CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R19CIDCFGR_SCID_SHIFT		4
+#define RCC_R19CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R19CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R19SEMCR register fields */
+#define RCC_R19SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R19SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R19SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R20CIDCFGR register fields */
+#define RCC_R20CIDCFGR_CFEN			BIT(0)
+#define RCC_R20CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R20CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R20CIDCFGR_SCID_SHIFT		4
+#define RCC_R20CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R20CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R20SEMCR register fields */
+#define RCC_R20SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R20SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R20SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R21CIDCFGR register fields */
+#define RCC_R21CIDCFGR_CFEN			BIT(0)
+#define RCC_R21CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R21CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R21CIDCFGR_SCID_SHIFT		4
+#define RCC_R21CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R21CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R21SEMCR register fields */
+#define RCC_R21SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R21SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R21SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R22CIDCFGR register fields */
+#define RCC_R22CIDCFGR_CFEN			BIT(0)
+#define RCC_R22CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R22CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R22CIDCFGR_SCID_SHIFT		4
+#define RCC_R22CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R22CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R22SEMCR register fields */
+#define RCC_R22SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R22SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R22SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R23CIDCFGR register fields */
+#define RCC_R23CIDCFGR_CFEN			BIT(0)
+#define RCC_R23CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R23CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R23CIDCFGR_SCID_SHIFT		4
+#define RCC_R23CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R23CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R23SEMCR register fields */
+#define RCC_R23SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R23SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R23SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R24CIDCFGR register fields */
+#define RCC_R24CIDCFGR_CFEN			BIT(0)
+#define RCC_R24CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R24CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R24CIDCFGR_SCID_SHIFT		4
+#define RCC_R24CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R24CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R24SEMCR register fields */
+#define RCC_R24SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R24SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R24SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R25CIDCFGR register fields */
+#define RCC_R25CIDCFGR_CFEN			BIT(0)
+#define RCC_R25CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R25CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R25CIDCFGR_SCID_SHIFT		4
+#define RCC_R25CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R25CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R25SEMCR register fields */
+#define RCC_R25SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R25SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R25SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R26CIDCFGR register fields */
+#define RCC_R26CIDCFGR_CFEN			BIT(0)
+#define RCC_R26CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R26CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R26CIDCFGR_SCID_SHIFT		4
+#define RCC_R26CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R26CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R26SEMCR register fields */
+#define RCC_R26SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R26SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R26SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R27CIDCFGR register fields */
+#define RCC_R27CIDCFGR_CFEN			BIT(0)
+#define RCC_R27CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R27CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R27CIDCFGR_SCID_SHIFT		4
+#define RCC_R27CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R27CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R27SEMCR register fields */
+#define RCC_R27SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R27SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R27SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R28CIDCFGR register fields */
+#define RCC_R28CIDCFGR_CFEN			BIT(0)
+#define RCC_R28CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R28CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R28CIDCFGR_SCID_SHIFT		4
+#define RCC_R28CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R28CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R28SEMCR register fields */
+#define RCC_R28SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R28SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R28SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R29CIDCFGR register fields */
+#define RCC_R29CIDCFGR_CFEN			BIT(0)
+#define RCC_R29CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R29CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R29CIDCFGR_SCID_SHIFT		4
+#define RCC_R29CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R29CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R29SEMCR register fields */
+#define RCC_R29SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R29SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R29SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R30CIDCFGR register fields */
+#define RCC_R30CIDCFGR_CFEN			BIT(0)
+#define RCC_R30CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R30CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R30CIDCFGR_SCID_SHIFT		4
+#define RCC_R30CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R30CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R30SEMCR register fields */
+#define RCC_R30SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R30SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R30SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R31CIDCFGR register fields */
+#define RCC_R31CIDCFGR_CFEN			BIT(0)
+#define RCC_R31CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R31CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R31CIDCFGR_SCID_SHIFT		4
+#define RCC_R31CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R31CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R31SEMCR register fields */
+#define RCC_R31SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R31SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R31SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R32CIDCFGR register fields */
+#define RCC_R32CIDCFGR_CFEN			BIT(0)
+#define RCC_R32CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R32CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R32CIDCFGR_SCID_SHIFT		4
+#define RCC_R32CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R32CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R32SEMCR register fields */
+#define RCC_R32SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R32SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R32SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R33CIDCFGR register fields */
+#define RCC_R33CIDCFGR_CFEN			BIT(0)
+#define RCC_R33CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R33CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R33CIDCFGR_SCID_SHIFT		4
+#define RCC_R33CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R33CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R33SEMCR register fields */
+#define RCC_R33SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R33SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R33SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R34CIDCFGR register fields */
+#define RCC_R34CIDCFGR_CFEN			BIT(0)
+#define RCC_R34CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R34CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R34CIDCFGR_SCID_SHIFT		4
+#define RCC_R34CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R34CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R34SEMCR register fields */
+#define RCC_R34SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R34SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R34SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R35CIDCFGR register fields */
+#define RCC_R35CIDCFGR_CFEN			BIT(0)
+#define RCC_R35CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R35CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R35CIDCFGR_SCID_SHIFT		4
+#define RCC_R35CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R35CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R35SEMCR register fields */
+#define RCC_R35SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R35SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R35SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R36CIDCFGR register fields */
+#define RCC_R36CIDCFGR_CFEN			BIT(0)
+#define RCC_R36CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R36CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R36CIDCFGR_SCID_SHIFT		4
+#define RCC_R36CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R36CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R36SEMCR register fields */
+#define RCC_R36SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R36SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R36SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R37CIDCFGR register fields */
+#define RCC_R37CIDCFGR_CFEN			BIT(0)
+#define RCC_R37CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R37CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R37CIDCFGR_SCID_SHIFT		4
+#define RCC_R37CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R37CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R37SEMCR register fields */
+#define RCC_R37SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R37SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R37SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R38CIDCFGR register fields */
+#define RCC_R38CIDCFGR_CFEN			BIT(0)
+#define RCC_R38CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R38CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R38CIDCFGR_SCID_SHIFT		4
+#define RCC_R38CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R38CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R38SEMCR register fields */
+#define RCC_R38SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R38SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R38SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R39CIDCFGR register fields */
+#define RCC_R39CIDCFGR_CFEN			BIT(0)
+#define RCC_R39CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R39CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R39CIDCFGR_SCID_SHIFT		4
+#define RCC_R39CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R39CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R39SEMCR register fields */
+#define RCC_R39SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R39SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R39SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R40CIDCFGR register fields */
+#define RCC_R40CIDCFGR_CFEN			BIT(0)
+#define RCC_R40CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R40CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R40CIDCFGR_SCID_SHIFT		4
+#define RCC_R40CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R40CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R40SEMCR register fields */
+#define RCC_R40SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R40SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R40SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R41CIDCFGR register fields */
+#define RCC_R41CIDCFGR_CFEN			BIT(0)
+#define RCC_R41CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R41CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R41CIDCFGR_SCID_SHIFT		4
+#define RCC_R41CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R41CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R41SEMCR register fields */
+#define RCC_R41SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R41SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R41SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R42CIDCFGR register fields */
+#define RCC_R42CIDCFGR_CFEN			BIT(0)
+#define RCC_R42CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R42CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R42CIDCFGR_SCID_SHIFT		4
+#define RCC_R42CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R42CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R42SEMCR register fields */
+#define RCC_R42SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R42SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R42SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R43CIDCFGR register fields */
+#define RCC_R43CIDCFGR_CFEN			BIT(0)
+#define RCC_R43CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R43CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R43CIDCFGR_SCID_SHIFT		4
+#define RCC_R43CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R43CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R43SEMCR register fields */
+#define RCC_R43SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R43SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R43SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R44CIDCFGR register fields */
+#define RCC_R44CIDCFGR_CFEN			BIT(0)
+#define RCC_R44CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R44CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R44CIDCFGR_SCID_SHIFT		4
+#define RCC_R44CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R44CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R44SEMCR register fields */
+#define RCC_R44SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R44SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R44SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R45CIDCFGR register fields */
+#define RCC_R45CIDCFGR_CFEN			BIT(0)
+#define RCC_R45CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R45CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R45CIDCFGR_SCID_SHIFT		4
+#define RCC_R45CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R45CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R45SEMCR register fields */
+#define RCC_R45SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R45SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R45SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R46CIDCFGR register fields */
+#define RCC_R46CIDCFGR_CFEN			BIT(0)
+#define RCC_R46CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R46CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R46CIDCFGR_SCID_SHIFT		4
+#define RCC_R46CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R46CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R46SEMCR register fields */
+#define RCC_R46SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R46SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R46SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R47CIDCFGR register fields */
+#define RCC_R47CIDCFGR_CFEN			BIT(0)
+#define RCC_R47CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R47CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R47CIDCFGR_SCID_SHIFT		4
+#define RCC_R47CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R47CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R47SEMCR register fields */
+#define RCC_R47SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R47SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R47SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R48CIDCFGR register fields */
+#define RCC_R48CIDCFGR_CFEN			BIT(0)
+#define RCC_R48CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R48CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R48CIDCFGR_SCID_SHIFT		4
+#define RCC_R48CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R48CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R48SEMCR register fields */
+#define RCC_R48SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R48SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R48SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R49CIDCFGR register fields */
+#define RCC_R49CIDCFGR_CFEN			BIT(0)
+#define RCC_R49CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R49CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R49CIDCFGR_SCID_SHIFT		4
+#define RCC_R49CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R49CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R49SEMCR register fields */
+#define RCC_R49SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R49SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R49SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R50CIDCFGR register fields */
+#define RCC_R50CIDCFGR_CFEN			BIT(0)
+#define RCC_R50CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R50CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R50CIDCFGR_SCID_SHIFT		4
+#define RCC_R50CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R50CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R50SEMCR register fields */
+#define RCC_R50SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R50SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R50SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R51CIDCFGR register fields */
+#define RCC_R51CIDCFGR_CFEN			BIT(0)
+#define RCC_R51CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R51CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R51CIDCFGR_SCID_SHIFT		4
+#define RCC_R51CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R51CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R51SEMCR register fields */
+#define RCC_R51SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R51SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R51SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R52CIDCFGR register fields */
+#define RCC_R52CIDCFGR_CFEN			BIT(0)
+#define RCC_R52CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R52CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R52CIDCFGR_SCID_SHIFT		4
+#define RCC_R52CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R52CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R52SEMCR register fields */
+#define RCC_R52SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R52SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R52SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R53CIDCFGR register fields */
+#define RCC_R53CIDCFGR_CFEN			BIT(0)
+#define RCC_R53CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R53CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R53CIDCFGR_SCID_SHIFT		4
+#define RCC_R53CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R53CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R53SEMCR register fields */
+#define RCC_R53SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R53SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R53SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R54CIDCFGR register fields */
+#define RCC_R54CIDCFGR_CFEN			BIT(0)
+#define RCC_R54CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R54CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R54CIDCFGR_SCID_SHIFT		4
+#define RCC_R54CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R54CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R54SEMCR register fields */
+#define RCC_R54SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R54SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R54SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R55CIDCFGR register fields */
+#define RCC_R55CIDCFGR_CFEN			BIT(0)
+#define RCC_R55CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R55CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R55CIDCFGR_SCID_SHIFT		4
+#define RCC_R55CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R55CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R55SEMCR register fields */
+#define RCC_R55SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R55SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R55SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R56CIDCFGR register fields */
+#define RCC_R56CIDCFGR_CFEN			BIT(0)
+#define RCC_R56CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R56CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R56CIDCFGR_SCID_SHIFT		4
+#define RCC_R56CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R56CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R56SEMCR register fields */
+#define RCC_R56SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R56SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R56SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R57CIDCFGR register fields */
+#define RCC_R57CIDCFGR_CFEN			BIT(0)
+#define RCC_R57CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R57CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R57CIDCFGR_SCID_SHIFT		4
+#define RCC_R57CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R57CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R57SEMCR register fields */
+#define RCC_R57SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R57SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R57SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R58CIDCFGR register fields */
+#define RCC_R58CIDCFGR_CFEN			BIT(0)
+#define RCC_R58CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R58CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R58CIDCFGR_SCID_SHIFT		4
+#define RCC_R58CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R58CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R58SEMCR register fields */
+#define RCC_R58SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R58SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R58SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R59CIDCFGR register fields */
+#define RCC_R59CIDCFGR_CFEN			BIT(0)
+#define RCC_R59CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R59CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R59CIDCFGR_SCID_SHIFT		4
+#define RCC_R59CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R59CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R59SEMCR register fields */
+#define RCC_R59SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R59SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R59SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R60CIDCFGR register fields */
+#define RCC_R60CIDCFGR_CFEN			BIT(0)
+#define RCC_R60CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R60CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R60CIDCFGR_SCID_SHIFT		4
+#define RCC_R60CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R60CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R60SEMCR register fields */
+#define RCC_R60SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R60SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R60SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R61CIDCFGR register fields */
+#define RCC_R61CIDCFGR_CFEN			BIT(0)
+#define RCC_R61CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R61CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R61CIDCFGR_SCID_SHIFT		4
+#define RCC_R61CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R61CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R61SEMCR register fields */
+#define RCC_R61SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R61SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R61SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R62CIDCFGR register fields */
+#define RCC_R62CIDCFGR_CFEN			BIT(0)
+#define RCC_R62CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R62CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R62CIDCFGR_SCID_SHIFT		4
+#define RCC_R62CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R62CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R62SEMCR register fields */
+#define RCC_R62SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R62SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R62SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R63CIDCFGR register fields */
+#define RCC_R63CIDCFGR_CFEN			BIT(0)
+#define RCC_R63CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R63CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R63CIDCFGR_SCID_SHIFT		4
+#define RCC_R63CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R63CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R63SEMCR register fields */
+#define RCC_R63SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R63SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R63SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R64CIDCFGR register fields */
+#define RCC_R64CIDCFGR_CFEN			BIT(0)
+#define RCC_R64CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R64CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R64CIDCFGR_SCID_SHIFT		4
+#define RCC_R64CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R64CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R64SEMCR register fields */
+#define RCC_R64SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R64SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R64SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R65CIDCFGR register fields */
+#define RCC_R65CIDCFGR_CFEN			BIT(0)
+#define RCC_R65CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R65CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R65CIDCFGR_SCID_SHIFT		4
+#define RCC_R65CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R65CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R65SEMCR register fields */
+#define RCC_R65SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R65SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R65SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R66CIDCFGR register fields */
+#define RCC_R66CIDCFGR_CFEN			BIT(0)
+#define RCC_R66CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R66CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R66CIDCFGR_SCID_SHIFT		4
+#define RCC_R66CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R66CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R66SEMCR register fields */
+#define RCC_R66SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R66SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R66SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R67CIDCFGR register fields */
+#define RCC_R67CIDCFGR_CFEN			BIT(0)
+#define RCC_R67CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R67CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R67CIDCFGR_SCID_SHIFT		4
+#define RCC_R67CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R67CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R67SEMCR register fields */
+#define RCC_R67SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R67SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R67SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R68CIDCFGR register fields */
+#define RCC_R68CIDCFGR_CFEN			BIT(0)
+#define RCC_R68CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R68CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R68CIDCFGR_SCID_SHIFT		4
+#define RCC_R68CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R68CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R68SEMCR register fields */
+#define RCC_R68SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R68SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R68SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R69CIDCFGR register fields */
+#define RCC_R69CIDCFGR_CFEN			BIT(0)
+#define RCC_R69CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R69CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R69CIDCFGR_SCID_SHIFT		4
+#define RCC_R69CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R69CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R69SEMCR register fields */
+#define RCC_R69SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R69SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R69SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R70CIDCFGR register fields */
+#define RCC_R70CIDCFGR_CFEN			BIT(0)
+#define RCC_R70CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R70CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R70CIDCFGR_SCID_SHIFT		4
+#define RCC_R70CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R70CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R70SEMCR register fields */
+#define RCC_R70SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R70SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R70SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R71CIDCFGR register fields */
+#define RCC_R71CIDCFGR_CFEN			BIT(0)
+#define RCC_R71CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R71CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R71CIDCFGR_SCID_SHIFT		4
+#define RCC_R71CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R71CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R71SEMCR register fields */
+#define RCC_R71SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R71SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R71SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R72CIDCFGR register fields */
+#define RCC_R72CIDCFGR_CFEN			BIT(0)
+#define RCC_R72CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R72CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R72CIDCFGR_SCID_SHIFT		4
+#define RCC_R72CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R72CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R72SEMCR register fields */
+#define RCC_R72SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R72SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R72SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R73CIDCFGR register fields */
+#define RCC_R73CIDCFGR_CFEN			BIT(0)
+#define RCC_R73CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R73CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R73CIDCFGR_SCID_SHIFT		4
+#define RCC_R73CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R73CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R73SEMCR register fields */
+#define RCC_R73SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R73SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R73SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R74CIDCFGR register fields */
+#define RCC_R74CIDCFGR_CFEN			BIT(0)
+#define RCC_R74CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R74CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R74CIDCFGR_SCID_SHIFT		4
+#define RCC_R74CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R74CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R74SEMCR register fields */
+#define RCC_R74SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R74SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R74SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R75CIDCFGR register fields */
+#define RCC_R75CIDCFGR_CFEN			BIT(0)
+#define RCC_R75CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R75CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R75CIDCFGR_SCID_SHIFT		4
+#define RCC_R75CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R75CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R75SEMCR register fields */
+#define RCC_R75SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R75SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R75SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R76CIDCFGR register fields */
+#define RCC_R76CIDCFGR_CFEN			BIT(0)
+#define RCC_R76CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R76CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R76CIDCFGR_SCID_SHIFT		4
+#define RCC_R76CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R76CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R76SEMCR register fields */
+#define RCC_R76SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R76SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R76SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R77CIDCFGR register fields */
+#define RCC_R77CIDCFGR_CFEN			BIT(0)
+#define RCC_R77CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R77CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R77CIDCFGR_SCID_SHIFT		4
+#define RCC_R77CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R77CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R77SEMCR register fields */
+#define RCC_R77SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R77SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R77SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R78CIDCFGR register fields */
+#define RCC_R78CIDCFGR_CFEN			BIT(0)
+#define RCC_R78CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R78CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R78CIDCFGR_SCID_SHIFT		4
+#define RCC_R78CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R78CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R78SEMCR register fields */
+#define RCC_R78SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R78SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R78SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R79CIDCFGR register fields */
+#define RCC_R79CIDCFGR_CFEN			BIT(0)
+#define RCC_R79CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R79CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R79CIDCFGR_SCID_SHIFT		4
+#define RCC_R79CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R79CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R79SEMCR register fields */
+#define RCC_R79SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R79SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R79SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R80CIDCFGR register fields */
+#define RCC_R80CIDCFGR_CFEN			BIT(0)
+#define RCC_R80CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R80CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R80CIDCFGR_SCID_SHIFT		4
+#define RCC_R80CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R80CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R80SEMCR register fields */
+#define RCC_R80SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R80SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R80SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R81CIDCFGR register fields */
+#define RCC_R81CIDCFGR_CFEN			BIT(0)
+#define RCC_R81CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R81CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R81CIDCFGR_SCID_SHIFT		4
+#define RCC_R81CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R81CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R81SEMCR register fields */
+#define RCC_R81SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R81SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R81SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R82CIDCFGR register fields */
+#define RCC_R82CIDCFGR_CFEN			BIT(0)
+#define RCC_R82CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R82CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R82CIDCFGR_SCID_SHIFT		4
+#define RCC_R82CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R82CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R82SEMCR register fields */
+#define RCC_R82SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R82SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R82SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R83CIDCFGR register fields */
+#define RCC_R83CIDCFGR_CFEN			BIT(0)
+#define RCC_R83CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R83CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R83CIDCFGR_SCID_SHIFT		4
+#define RCC_R83CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R83CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R83SEMCR register fields */
+#define RCC_R83SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R83SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R83SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R84CIDCFGR register fields */
+#define RCC_R84CIDCFGR_CFEN			BIT(0)
+#define RCC_R84CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R84CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R84CIDCFGR_SCID_SHIFT		4
+#define RCC_R84CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R84CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R84SEMCR register fields */
+#define RCC_R84SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R84SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R84SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R85CIDCFGR register fields */
+#define RCC_R85CIDCFGR_CFEN			BIT(0)
+#define RCC_R85CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R85CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R85CIDCFGR_SCID_SHIFT		4
+#define RCC_R85CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R85CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R85SEMCR register fields */
+#define RCC_R85SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R85SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R85SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R86CIDCFGR register fields */
+#define RCC_R86CIDCFGR_CFEN			BIT(0)
+#define RCC_R86CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R86CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R86CIDCFGR_SCID_SHIFT		4
+#define RCC_R86CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R86CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R86SEMCR register fields */
+#define RCC_R86SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R86SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R86SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R87CIDCFGR register fields */
+#define RCC_R87CIDCFGR_CFEN			BIT(0)
+#define RCC_R87CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R87CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R87CIDCFGR_SCID_SHIFT		4
+#define RCC_R87CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R87CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R87SEMCR register fields */
+#define RCC_R87SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R87SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R87SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R88CIDCFGR register fields */
+#define RCC_R88CIDCFGR_CFEN			BIT(0)
+#define RCC_R88CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R88CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R88CIDCFGR_SCID_SHIFT		4
+#define RCC_R88CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R88CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R88SEMCR register fields */
+#define RCC_R88SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R88SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R88SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R89CIDCFGR register fields */
+#define RCC_R89CIDCFGR_CFEN			BIT(0)
+#define RCC_R89CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R89CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R89CIDCFGR_SCID_SHIFT		4
+#define RCC_R89CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R89CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R89SEMCR register fields */
+#define RCC_R89SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R89SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R89SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R90CIDCFGR register fields */
+#define RCC_R90CIDCFGR_CFEN			BIT(0)
+#define RCC_R90CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R90CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R90CIDCFGR_SCID_SHIFT		4
+#define RCC_R90CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R90CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R90SEMCR register fields */
+#define RCC_R90SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R90SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R90SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R91CIDCFGR register fields */
+#define RCC_R91CIDCFGR_CFEN			BIT(0)
+#define RCC_R91CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R91CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R91CIDCFGR_SCID_SHIFT		4
+#define RCC_R91CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R91CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R91SEMCR register fields */
+#define RCC_R91SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R91SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R91SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R92CIDCFGR register fields */
+#define RCC_R92CIDCFGR_CFEN			BIT(0)
+#define RCC_R92CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R92CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R92CIDCFGR_SCID_SHIFT		4
+#define RCC_R92CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R92CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R92SEMCR register fields */
+#define RCC_R92SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R92SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R92SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R93CIDCFGR register fields */
+#define RCC_R93CIDCFGR_CFEN			BIT(0)
+#define RCC_R93CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R93CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R93CIDCFGR_SCID_SHIFT		4
+#define RCC_R93CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R93CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R93SEMCR register fields */
+#define RCC_R93SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R93SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R93SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R94CIDCFGR register fields */
+#define RCC_R94CIDCFGR_CFEN			BIT(0)
+#define RCC_R94CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R94CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R94CIDCFGR_SCID_SHIFT		4
+#define RCC_R94CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R94CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R94SEMCR register fields */
+#define RCC_R94SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R94SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R94SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R95CIDCFGR register fields */
+#define RCC_R95CIDCFGR_CFEN			BIT(0)
+#define RCC_R95CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R95CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R95CIDCFGR_SCID_SHIFT		4
+#define RCC_R95CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R95CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R95SEMCR register fields */
+#define RCC_R95SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R95SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R95SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R96CIDCFGR register fields */
+#define RCC_R96CIDCFGR_CFEN			BIT(0)
+#define RCC_R96CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R96CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R96CIDCFGR_SCID_SHIFT		4
+#define RCC_R96CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R96CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R96SEMCR register fields */
+#define RCC_R96SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R96SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R96SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R97CIDCFGR register fields */
+#define RCC_R97CIDCFGR_CFEN			BIT(0)
+#define RCC_R97CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R97CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R97CIDCFGR_SCID_SHIFT		4
+#define RCC_R97CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R97CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R97SEMCR register fields */
+#define RCC_R97SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R97SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R97SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R98CIDCFGR register fields */
+#define RCC_R98CIDCFGR_CFEN			BIT(0)
+#define RCC_R98CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R98CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R98CIDCFGR_SCID_SHIFT		4
+#define RCC_R98CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R98CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R98SEMCR register fields */
+#define RCC_R98SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R98SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R98SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R99CIDCFGR register fields */
+#define RCC_R99CIDCFGR_CFEN			BIT(0)
+#define RCC_R99CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R99CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R99CIDCFGR_SCID_SHIFT		4
+#define RCC_R99CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R99CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R99SEMCR register fields */
+#define RCC_R99SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R99SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R99SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R100CIDCFGR register fields */
+#define RCC_R100CIDCFGR_CFEN			BIT(0)
+#define RCC_R100CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R100CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R100CIDCFGR_SCID_SHIFT		4
+#define RCC_R100CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R100CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R100SEMCR register fields */
+#define RCC_R100SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R100SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R100SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R101CIDCFGR register fields */
+#define RCC_R101CIDCFGR_CFEN			BIT(0)
+#define RCC_R101CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R101CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R101CIDCFGR_SCID_SHIFT		4
+#define RCC_R101CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R101CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R101SEMCR register fields */
+#define RCC_R101SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R101SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R101SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R102CIDCFGR register fields */
+#define RCC_R102CIDCFGR_CFEN			BIT(0)
+#define RCC_R102CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R102CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R102CIDCFGR_SCID_SHIFT		4
+#define RCC_R102CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R102CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R102SEMCR register fields */
+#define RCC_R102SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R102SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R102SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R103CIDCFGR register fields */
+#define RCC_R103CIDCFGR_CFEN			BIT(0)
+#define RCC_R103CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R103CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R103CIDCFGR_SCID_SHIFT		4
+#define RCC_R103CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R103CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R103SEMCR register fields */
+#define RCC_R103SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R103SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R103SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R104CIDCFGR register fields */
+#define RCC_R104CIDCFGR_CFEN			BIT(0)
+#define RCC_R104CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R104CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R104CIDCFGR_SCID_SHIFT		4
+#define RCC_R104CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R104CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R104SEMCR register fields */
+#define RCC_R104SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R104SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R104SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R105CIDCFGR register fields */
+#define RCC_R105CIDCFGR_CFEN			BIT(0)
+#define RCC_R105CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R105CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R105CIDCFGR_SCID_SHIFT		4
+#define RCC_R105CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R105CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R105SEMCR register fields */
+#define RCC_R105SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R105SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R105SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R106CIDCFGR register fields */
+#define RCC_R106CIDCFGR_CFEN			BIT(0)
+#define RCC_R106CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R106CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R106CIDCFGR_SCID_SHIFT		4
+#define RCC_R106CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R106CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R106SEMCR register fields */
+#define RCC_R106SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R106SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R106SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R107CIDCFGR register fields */
+#define RCC_R107CIDCFGR_CFEN			BIT(0)
+#define RCC_R107CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R107CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R107CIDCFGR_SCID_SHIFT		4
+#define RCC_R107CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R107CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R107SEMCR register fields */
+#define RCC_R107SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R107SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R107SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R108CIDCFGR register fields */
+#define RCC_R108CIDCFGR_CFEN			BIT(0)
+#define RCC_R108CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R108CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R108CIDCFGR_SCID_SHIFT		4
+#define RCC_R108CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R108CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R108SEMCR register fields */
+#define RCC_R108SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R108SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R108SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R109CIDCFGR register fields */
+#define RCC_R109CIDCFGR_CFEN			BIT(0)
+#define RCC_R109CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R109CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R109CIDCFGR_SCID_SHIFT		4
+#define RCC_R109CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R109CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R109SEMCR register fields */
+#define RCC_R109SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R109SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R109SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R110CIDCFGR register fields */
+#define RCC_R110CIDCFGR_CFEN			BIT(0)
+#define RCC_R110CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R110CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R110CIDCFGR_SCID_SHIFT		4
+#define RCC_R110CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R110CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R110SEMCR register fields */
+#define RCC_R110SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R110SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R110SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R111CIDCFGR register fields */
+#define RCC_R111CIDCFGR_CFEN			BIT(0)
+#define RCC_R111CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R111CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R111CIDCFGR_SCID_SHIFT		4
+#define RCC_R111CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R111CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R111SEMCR register fields */
+#define RCC_R111SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R111SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R111SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R112CIDCFGR register fields */
+#define RCC_R112CIDCFGR_CFEN			BIT(0)
+#define RCC_R112CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R112CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R112CIDCFGR_SCID_SHIFT		4
+#define RCC_R112CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R112CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R112SEMCR register fields */
+#define RCC_R112SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R112SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R112SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R113CIDCFGR register fields */
+#define RCC_R113CIDCFGR_CFEN			BIT(0)
+#define RCC_R113CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R113CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R113CIDCFGR_SCID_SHIFT		4
+#define RCC_R113CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R113CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R113SEMCR register fields */
+#define RCC_R113SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R113SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R113SEMCR_SEMCID_SHIFT		4
+
+/* RCC_RxCIDCFGR register fields */
+#define RCC_RxCIDCFGR_CFEN			BIT(0)
+#define RCC_RxCIDCFGR_SEM_EN			BIT(1)
+#define RCC_RxCIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_RxCIDCFGR_SCID_SHIFT		4
+#define RCC_RxCIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_RxCIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_RxSEMCR register fields */
+#define RCC_RxSEMCR_SEM_MUTEX			BIT(0)
+#define RCC_RxSEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_RxSEMCR_SEMCID_SHIFT		4
+
+/* RCC_GRSTCSETR register fields */
+#define RCC_GRSTCSETR_SYSRST			BIT(0)
+
+/* RCC_C1RSTCSETR register fields */
+#define RCC_C1RSTCSETR_C1RST			BIT(0)
+
+/* RCC_C1P1RSTCSETR register fields */
+#define RCC_C1P1RSTCSETR_C1P1PORRST		BIT(0)
+#define RCC_C1P1RSTCSETR_C1P1RST		BIT(1)
+
+/* RCC_C2RSTCSETR register fields */
+#define RCC_C2RSTCSETR_C2RST			BIT(0)
+
+/* RCC_CxRSTCSETR register fields */
+#define RCC_CxRSTCSETR_CxRST			BIT(0)
+
+/* RCC_HWRSTSCLRR register fields */
+#define RCC_HWRSTSCLRR_PORRSTF			BIT(0)
+#define RCC_HWRSTSCLRR_BORRSTF			BIT(1)
+#define RCC_HWRSTSCLRR_PADRSTF			BIT(2)
+#define RCC_HWRSTSCLRR_HCSSRSTF			BIT(3)
+#define RCC_HWRSTSCLRR_VCORERSTF		BIT(4)
+#define RCC_HWRSTSCLRR_SYSC1RSTF		BIT(5)
+#define RCC_HWRSTSCLRR_SYSC2RSTF		BIT(6)
+#define RCC_HWRSTSCLRR_IWDG1SYSRSTF		BIT(7)
+#define RCC_HWRSTSCLRR_IWDG2SYSRSTF		BIT(8)
+#define RCC_HWRSTSCLRR_IWDG3SYSRSTF		BIT(9)
+#define RCC_HWRSTSCLRR_IWDG4SYSRSTF		BIT(10)
+#define RCC_HWRSTSCLRR_IWDG5SYSRSTF		BIT(11)
+#define RCC_HWRSTSCLRR_RETCRCERRRSTF		BIT(12)
+#define RCC_HWRSTSCLRR_RETECCFAILCRCRSTF	BIT(13)
+#define RCC_HWRSTSCLRR_RETECCFAILRESTRSTF	BIT(14)
+
+/* RCC_C1HWRSTSCLRR register fields */
+#define RCC_C1HWRSTSCLRR_VCPURSTF		BIT(0)
+#define RCC_C1HWRSTSCLRR_C1RSTF			BIT(1)
+#define RCC_C1HWRSTSCLRR_C1P1RSTF		BIT(2)
+
+/* RCC_C2HWRSTSCLRR register fields */
+#define RCC_C2HWRSTSCLRR_C2RSTF			BIT(0)
+
+/* RCC_C1BOOTRSTSSETR register fields */
+#define RCC_C1BOOTRSTSSETR_PORRSTF		BIT(0)
+#define RCC_C1BOOTRSTSSETR_BORRSTF		BIT(1)
+#define RCC_C1BOOTRSTSSETR_PADRSTF		BIT(2)
+#define RCC_C1BOOTRSTSSETR_HCSSRSTF		BIT(3)
+#define RCC_C1BOOTRSTSSETR_VCORERSTF		BIT(4)
+#define RCC_C1BOOTRSTSSETR_VCPURSTF		BIT(5)
+#define RCC_C1BOOTRSTSSETR_SYSC1RSTF		BIT(6)
+#define RCC_C1BOOTRSTSSETR_SYSC2RSTF		BIT(7)
+#define RCC_C1BOOTRSTSSETR_IWDG1SYSRSTF		BIT(8)
+#define RCC_C1BOOTRSTSSETR_IWDG2SYSRSTF		BIT(9)
+#define RCC_C1BOOTRSTSSETR_IWDG3SYSRSTF		BIT(10)
+#define RCC_C1BOOTRSTSSETR_IWDG4SYSRSTF		BIT(11)
+#define RCC_C1BOOTRSTSSETR_IWDG5SYSRSTF		BIT(12)
+#define RCC_C1BOOTRSTSSETR_C1RSTF		BIT(13)
+#define RCC_C1BOOTRSTSSETR_C1P1RSTF		BIT(16)
+#define RCC_C1BOOTRSTSSETR_RETCRCERRRSTF	BIT(17)
+#define RCC_C1BOOTRSTSSETR_RETECCFAILCRCRSTF	BIT(18)
+#define RCC_C1BOOTRSTSSETR_RETECCFAILRESTRSTF	BIT(19)
+#define RCC_C1BOOTRSTSSETR_STBYC1RSTF		BIT(20)
+#define RCC_C1BOOTRSTSSETR_D1STBYRSTF		BIT(22)
+#define RCC_C1BOOTRSTSSETR_D2STBYRSTF		BIT(23)
+
+/* RCC_C1BOOTRSTSCLRR register fields */
+#define RCC_C1BOOTRSTSCLRR_PORRSTF		BIT(0)
+#define RCC_C1BOOTRSTSCLRR_BORRSTF		BIT(1)
+#define RCC_C1BOOTRSTSCLRR_PADRSTF		BIT(2)
+#define RCC_C1BOOTRSTSCLRR_HCSSRSTF		BIT(3)
+#define RCC_C1BOOTRSTSCLRR_VCORERSTF		BIT(4)
+#define RCC_C1BOOTRSTSCLRR_VCPURSTF		BIT(5)
+#define RCC_C1BOOTRSTSCLRR_SYSC1RSTF		BIT(6)
+#define RCC_C1BOOTRSTSCLRR_SYSC2RSTF		BIT(7)
+#define RCC_C1BOOTRSTSCLRR_IWDG1SYSRSTF		BIT(8)
+#define RCC_C1BOOTRSTSCLRR_IWDG2SYSRSTF		BIT(9)
+#define RCC_C1BOOTRSTSCLRR_IWDG3SYSRSTF		BIT(10)
+#define RCC_C1BOOTRSTSCLRR_IWDG4SYSRSTF		BIT(11)
+#define RCC_C1BOOTRSTSCLRR_IWDG5SYSRSTF		BIT(12)
+#define RCC_C1BOOTRSTSCLRR_C1RSTF		BIT(13)
+#define RCC_C1BOOTRSTSCLRR_C1P1RSTF		BIT(16)
+#define RCC_C1BOOTRSTSCLRR_RETCRCERRRSTF	BIT(17)
+#define RCC_C1BOOTRSTSCLRR_RETECCFAILCRCRSTF	BIT(18)
+#define RCC_C1BOOTRSTSCLRR_RETECCFAILRESTRSTF	BIT(19)
+#define RCC_C1BOOTRSTSCLRR_STBYC1RSTF		BIT(20)
+#define RCC_C1BOOTRSTSCLRR_D1STBYRSTF		BIT(22)
+#define RCC_C1BOOTRSTSCLRR_D2STBYRSTF		BIT(23)
+
+/* RCC_C2BOOTRSTSSETR register fields */
+#define RCC_C2BOOTRSTSSETR_PORRSTF		BIT(0)
+#define RCC_C2BOOTRSTSSETR_BORRSTF		BIT(1)
+#define RCC_C2BOOTRSTSSETR_PADRSTF		BIT(2)
+#define RCC_C2BOOTRSTSSETR_HCSSRSTF		BIT(3)
+#define RCC_C2BOOTRSTSSETR_VCORERSTF		BIT(4)
+#define RCC_C2BOOTRSTSSETR_SYSC1RSTF		BIT(6)
+#define RCC_C2BOOTRSTSSETR_SYSC2RSTF		BIT(7)
+#define RCC_C2BOOTRSTSSETR_IWDG1SYSRSTF		BIT(8)
+#define RCC_C2BOOTRSTSSETR_IWDG2SYSRSTF		BIT(9)
+#define RCC_C2BOOTRSTSSETR_IWDG3SYSRSTF		BIT(10)
+#define RCC_C2BOOTRSTSSETR_IWDG4SYSRSTF		BIT(11)
+#define RCC_C2BOOTRSTSSETR_IWDG5SYSRSTF		BIT(12)
+#define RCC_C2BOOTRSTSSETR_C2RSTF		BIT(14)
+#define RCC_C2BOOTRSTSSETR_RETCRCERRRSTF	BIT(17)
+#define RCC_C2BOOTRSTSSETR_RETECCFAILCRCRSTF	BIT(18)
+#define RCC_C2BOOTRSTSSETR_RETECCFAILRESTRSTF	BIT(19)
+#define RCC_C2BOOTRSTSSETR_STBYC2RSTF		BIT(21)
+#define RCC_C2BOOTRSTSSETR_D2STBYRSTF		BIT(23)
+
+/* RCC_C2BOOTRSTSCLRR register fields */
+#define RCC_C2BOOTRSTSCLRR_PORRSTF		BIT(0)
+#define RCC_C2BOOTRSTSCLRR_BORRSTF		BIT(1)
+#define RCC_C2BOOTRSTSCLRR_PADRSTF		BIT(2)
+#define RCC_C2BOOTRSTSCLRR_HCSSRSTF		BIT(3)
+#define RCC_C2BOOTRSTSCLRR_VCORERSTF		BIT(4)
+#define RCC_C2BOOTRSTSCLRR_SYSC1RSTF		BIT(6)
+#define RCC_C2BOOTRSTSCLRR_SYSC2RSTF		BIT(7)
+#define RCC_C2BOOTRSTSCLRR_IWDG1SYSRSTF		BIT(8)
+#define RCC_C2BOOTRSTSCLRR_IWDG2SYSRSTF		BIT(9)
+#define RCC_C2BOOTRSTSCLRR_IWDG3SYSRSTF		BIT(10)
+#define RCC_C2BOOTRSTSCLRR_IWDG4SYSRSTF		BIT(11)
+#define RCC_C2BOOTRSTSCLRR_IWDG5SYSRSTF		BIT(12)
+#define RCC_C2BOOTRSTSCLRR_C2RSTF		BIT(14)
+#define RCC_C2BOOTRSTSCLRR_RETCRCERRRSTF	BIT(17)
+#define RCC_C2BOOTRSTSCLRR_RETECCFAILCRCRSTF	BIT(18)
+#define RCC_C2BOOTRSTSCLRR_RETECCFAILRESTRSTF	BIT(19)
+#define RCC_C2BOOTRSTSCLRR_STBYC2RSTF		BIT(21)
+#define RCC_C2BOOTRSTSCLRR_D2STBYRSTF		BIT(23)
+
+/* RCC_C1SREQSETR register fields */
+#define RCC_C1SREQSETR_STPREQ_P0		BIT(0)
+#define RCC_C1SREQSETR_STPREQ_P1		BIT(1)
+#define RCC_C1SREQSETR_ESLPREQ			BIT(16)
+
+/* RCC_C1SREQCLRR register fields */
+#define RCC_C1SREQCLRR_STPREQ_P0		BIT(0)
+#define RCC_C1SREQCLRR_STPREQ_P1		BIT(1)
+#define RCC_C1SREQCLRR_ESLPREQ			BIT(16)
+
+/* RCC_CPUBOOTCR register fields */
+#define RCC_CPUBOOTCR_BOOT_CPU2			BIT(0)
+#define RCC_CPUBOOTCR_BOOT_CPU1			BIT(1)
+
+/* RCC_STBYBOOTCR register fields */
+#define RCC_STBYBOOTCR_CPU_BEN_SEL		BIT(1)
+#define RCC_STBYBOOTCR_COLD_CPU2		BIT(2)
+#define RCC_STBYBOOTCR_CPU2_HW_BEN		BIT(4)
+#define RCC_STBYBOOTCR_CPU1_HW_BEN		BIT(5)
+#define RCC_STBYBOOTCR_RET_CRCERR_RSTEN		BIT(8)
+
+/* RCC_LEGBOOTCR register fields */
+#define RCC_LEGBOOTCR_LEGACY_BEN		BIT(0)
+
+/* RCC_BDCR register fields */
+#define RCC_BDCR_LSEON				BIT(0)
+#define RCC_BDCR_LSEBYP				BIT(1)
+#define RCC_BDCR_LSERDY				BIT(2)
+#define RCC_BDCR_LSEDIGBYP			BIT(3)
+#define RCC_BDCR_LSEDRV_MASK			GENMASK(5, 4)
+#define RCC_BDCR_LSEDRV_SHIFT			4
+#define RCC_BDCR_LSECSSON			BIT(6)
+#define RCC_BDCR_LSEGFON			BIT(7)
+#define RCC_BDCR_LSECSSD			BIT(8)
+#define RCC_BDCR_LSION				BIT(9)
+#define RCC_BDCR_LSIRDY				BIT(10)
+#define RCC_BDCR_RTCSRC_MASK			GENMASK(17, 16)
+#define RCC_BDCR_RTCSRC_SHIFT			16
+#define RCC_BDCR_RTCCKEN			BIT(20)
+#define RCC_BDCR_MSIFREQSEL			BIT(24)
+#define RCC_BDCR_C3SYSTICKSEL			BIT(25)
+#define RCC_BDCR_VSWRST				BIT(31)
+#define RCC_BDCR_LSEBYP_BIT			1
+#define RCC_BDCR_LSEDIGBYP_BIT			3
+#define RCC_BDCR_LSECSSON_BIT			6
+#define RCC_BDCR_LSERDY_BIT			2
+#define RCC_BDCR_LSIRDY_BIT			10
+
+#define RCC_BDCR_LSEDRV_SHIFT			4
+#define RCC_BDCR_LSEDRV_WIDTH			2
+
+/* RCC_D3DCR register fields */
+#define RCC_D3DCR_CSION				BIT(0)
+#define RCC_D3DCR_CSIKERON			BIT(1)
+#define RCC_D3DCR_CSIRDY			BIT(2)
+#define RCC_D3DCR_D3PERCKSEL_MASK		GENMASK(17, 16)
+#define RCC_D3DCR_D3PERCKSEL_SHIFT		16
+#define RCC_D3DCR_CSIRDY_BIT			2
+
+/* RCC_D3DSR register fields */
+#define RCC_D3DSR_D3STATE_MASK			GENMASK(1, 0)
+#define RCC_D3DSR_D3STATE_SHIFT			0
+
+/* RCC_RDCR register fields */
+#define RCC_RDCR_MRD_MASK			GENMASK(20, 16)
+#define RCC_RDCR_MRD_SHIFT			16
+#define RCC_RDCR_EADLY_MASK			GENMASK(27, 24)
+#define RCC_RDCR_EADLY_SHIFT			24
+
+/* RCC_C1MSRDCR register fields */
+#define RCC_C1MSRDCR_C1MSRD_MASK		GENMASK(4, 0)
+#define RCC_C1MSRDCR_C1MSRD_SHIFT		0
+#define RCC_C1MSRDCR_C1MSRST			BIT(8)
+
+/* RCC_PWRLPDLYCR register fields */
+#define RCC_PWRLPDLYCR_PWRLP_DLY_MASK		GENMASK(21, 0)
+#define RCC_PWRLPDLYCR_PWRLP_DLY_SHIFT		0
+#define RCC_PWRLPDLYCR_CPU2TMPSKP		BIT(24)
+
+/* RCC_C1CIESETR register fields */
+#define RCC_C1CIESETR_LSIRDYIE			BIT(0)
+#define RCC_C1CIESETR_LSERDYIE			BIT(1)
+#define RCC_C1CIESETR_HSIRDYIE			BIT(2)
+#define RCC_C1CIESETR_HSERDYIE			BIT(3)
+#define RCC_C1CIESETR_CSIRDYIE			BIT(4)
+#define RCC_C1CIESETR_PLL1RDYIE			BIT(5)
+#define RCC_C1CIESETR_PLL2RDYIE			BIT(6)
+#define RCC_C1CIESETR_PLL3RDYIE			BIT(7)
+#define RCC_C1CIESETR_PLL4RDYIE			BIT(8)
+#define RCC_C1CIESETR_PLL5RDYIE			BIT(9)
+#define RCC_C1CIESETR_PLL6RDYIE			BIT(10)
+#define RCC_C1CIESETR_PLL7RDYIE			BIT(11)
+#define RCC_C1CIESETR_PLL8RDYIE			BIT(12)
+#define RCC_C1CIESETR_LSECSSIE			BIT(16)
+#define RCC_C1CIESETR_WKUPIE			BIT(20)
+
+/* RCC_C1CIFCLRR register fields */
+#define RCC_C1CIFCLRR_LSIRDYF			BIT(0)
+#define RCC_C1CIFCLRR_LSERDYF			BIT(1)
+#define RCC_C1CIFCLRR_HSIRDYF			BIT(2)
+#define RCC_C1CIFCLRR_HSERDYF			BIT(3)
+#define RCC_C1CIFCLRR_CSIRDYF			BIT(4)
+#define RCC_C1CIFCLRR_PLL1RDYF			BIT(5)
+#define RCC_C1CIFCLRR_PLL2RDYF			BIT(6)
+#define RCC_C1CIFCLRR_PLL3RDYF			BIT(7)
+#define RCC_C1CIFCLRR_PLL4RDYF			BIT(8)
+#define RCC_C1CIFCLRR_PLL5RDYF			BIT(9)
+#define RCC_C1CIFCLRR_PLL6RDYF			BIT(10)
+#define RCC_C1CIFCLRR_PLL7RDYF			BIT(11)
+#define RCC_C1CIFCLRR_PLL8RDYF			BIT(12)
+#define RCC_C1CIFCLRR_LSECSSF			BIT(16)
+#define RCC_C1CIFCLRR_WKUPF			BIT(20)
+
+/* RCC_C2CIESETR register fields */
+#define RCC_C2CIESETR_LSIRDYIE			BIT(0)
+#define RCC_C2CIESETR_LSERDYIE			BIT(1)
+#define RCC_C2CIESETR_HSIRDYIE			BIT(2)
+#define RCC_C2CIESETR_HSERDYIE			BIT(3)
+#define RCC_C2CIESETR_CSIRDYIE			BIT(4)
+#define RCC_C2CIESETR_PLL1RDYIE			BIT(5)
+#define RCC_C2CIESETR_PLL2RDYIE			BIT(6)
+#define RCC_C2CIESETR_PLL3RDYIE			BIT(7)
+#define RCC_C2CIESETR_PLL4RDYIE			BIT(8)
+#define RCC_C2CIESETR_PLL5RDYIE			BIT(9)
+#define RCC_C2CIESETR_PLL6RDYIE			BIT(10)
+#define RCC_C2CIESETR_PLL7RDYIE			BIT(11)
+#define RCC_C2CIESETR_PLL8RDYIE			BIT(12)
+#define RCC_C2CIESETR_LSECSSIE			BIT(16)
+#define RCC_C2CIESETR_WKUPIE			BIT(20)
+
+/* RCC_C2CIFCLRR register fields */
+#define RCC_C2CIFCLRR_LSIRDYF			BIT(0)
+#define RCC_C2CIFCLRR_LSERDYF			BIT(1)
+#define RCC_C2CIFCLRR_HSIRDYF			BIT(2)
+#define RCC_C2CIFCLRR_HSERDYF			BIT(3)
+#define RCC_C2CIFCLRR_CSIRDYF			BIT(4)
+#define RCC_C2CIFCLRR_PLL1RDYF			BIT(5)
+#define RCC_C2CIFCLRR_PLL2RDYF			BIT(6)
+#define RCC_C2CIFCLRR_PLL3RDYF			BIT(7)
+#define RCC_C2CIFCLRR_PLL4RDYF			BIT(8)
+#define RCC_C2CIFCLRR_PLL5RDYF			BIT(9)
+#define RCC_C2CIFCLRR_PLL6RDYF			BIT(10)
+#define RCC_C2CIFCLRR_PLL7RDYF			BIT(11)
+#define RCC_C2CIFCLRR_PLL8RDYF			BIT(12)
+#define RCC_C2CIFCLRR_LSECSSF			BIT(16)
+#define RCC_C2CIFCLRR_WKUPF			BIT(20)
+
+/* RCC_CxCIESETR register fields */
+#define RCC_CxCIESETR_LSIRDYIE			BIT(0)
+#define RCC_CxCIESETR_LSERDYIE			BIT(1)
+#define RCC_CxCIESETR_HSIRDYIE			BIT(2)
+#define RCC_CxCIESETR_HSERDYIE			BIT(3)
+#define RCC_CxCIESETR_CSIRDYIE			BIT(4)
+#define RCC_CxCIESETR_SHSIRDYIE			BIT(5)
+#define RCC_CxCIESETR_PLL1RDYIE			BIT(6)
+#define RCC_CxCIESETR_PLL2RDYIE			BIT(7)
+#define RCC_CxCIESETR_PLL3RDYIE			BIT(8)
+#define RCC_CxCIESETR_PLL4RDYIE			BIT(9)
+#define RCC_CxCIESETR_PLL5RDYIE			BIT(10)
+#define RCC_CxCIESETR_PLL6RDYIE			BIT(11)
+#define RCC_CxCIESETR_PLL7RDYIE			BIT(12)
+#define RCC_CxCIESETR_PLL8RDYIE			BIT(13)
+#define RCC_CxCIESETR_LSECSSIE			BIT(16)
+#define RCC_CxCIESETR_WKUPIE			BIT(20)
+
+/* RCC_CxCIFCLRR register fields */
+#define RCC_CxCIFCLRR_LSIRDYF			BIT(0)
+#define RCC_CxCIFCLRR_LSERDYF			BIT(1)
+#define RCC_CxCIFCLRR_HSIRDYF			BIT(2)
+#define RCC_CxCIFCLRR_HSERDYF			BIT(3)
+#define RCC_CxCIFCLRR_CSIRDYF			BIT(4)
+#define RCC_CxCIFCLRR_SHSIRDYF			BIT(5)
+#define RCC_CxCIFCLRR_PLL1RDYF			BIT(6)
+#define RCC_CxCIFCLRR_PLL2RDYF			BIT(7)
+#define RCC_CxCIFCLRR_PLL3RDYF			BIT(8)
+#define RCC_CxCIFCLRR_PLL4RDYF			BIT(9)
+#define RCC_CxCIFCLRR_PLL5RDYF			BIT(10)
+#define RCC_CxCIFCLRR_PLL6RDYF			BIT(11)
+#define RCC_CxCIFCLRR_PLL7RDYF			BIT(12)
+#define RCC_CxCIFCLRR_PLL8RDYF			BIT(13)
+#define RCC_CxCIFCLRR_LSECSSF			BIT(16)
+#define RCC_CxCIFCLRR_WKUPF			BIT(20)
+
+/* RCC_IWDGC1FZSETR register fields */
+#define RCC_IWDGC1FZSETR_FZ_IWDG1		BIT(0)
+#define RCC_IWDGC1FZSETR_FZ_IWDG2		BIT(1)
+
+/* RCC_IWDGC1FZCLRR register fields */
+#define RCC_IWDGC1FZCLRR_FZ_IWDG1		BIT(0)
+#define RCC_IWDGC1FZCLRR_FZ_IWDG2		BIT(1)
+
+/* RCC_IWDGC1CFGSETR register fields */
+#define RCC_IWDGC1CFGSETR_IWDG1_SYSRSTEN	BIT(0)
+#define RCC_IWDGC1CFGSETR_IWDG2_SYSRSTEN	BIT(2)
+#define RCC_IWDGC1CFGSETR_IWDG2_KERRST		BIT(18)
+
+/* RCC_IWDGC1CFGCLRR register fields */
+#define RCC_IWDGC1CFGCLRR_IWDG1_SYSRSTEN	BIT(0)
+#define RCC_IWDGC1CFGCLRR_IWDG2_SYSRSTEN	BIT(2)
+#define RCC_IWDGC1CFGCLRR_IWDG2_KERRST		BIT(18)
+
+/* RCC_IWDGC2FZSETR register fields */
+#define RCC_IWDGC2FZSETR_FZ_IWDG3		BIT(0)
+#define RCC_IWDGC2FZSETR_FZ_IWDG4		BIT(1)
+
+/* RCC_IWDGC2FZCLRR register fields */
+#define RCC_IWDGC2FZCLRR_FZ_IWDG3		BIT(0)
+#define RCC_IWDGC2FZCLRR_FZ_IWDG4		BIT(1)
+
+/* RCC_IWDGC2CFGSETR register fields */
+#define RCC_IWDGC2CFGSETR_IWDG3_SYSRSTEN	BIT(0)
+#define RCC_IWDGC2CFGSETR_IWDG4_SYSRSTEN	BIT(2)
+#define RCC_IWDGC2CFGSETR_IWDG4_KERRST		BIT(18)
+
+/* RCC_IWDGC2CFGCLRR register fields */
+#define RCC_IWDGC2CFGCLRR_IWDG3_SYSRSTEN	BIT(0)
+#define RCC_IWDGC2CFGCLRR_IWDG4_SYSRSTEN	BIT(2)
+#define RCC_IWDGC2CFGCLRR_IWDG4_KERRST		BIT(18)
+
+/* RCC_IWDGC3CFGSETR register fields */
+#define RCC_IWDGC3CFGSETR_IWDG5_SYSRSTEN	BIT(0)
+
+/* RCC_IWDGC3CFGCLRR register fields */
+#define RCC_IWDGC3CFGCLRR_IWDG5_SYSRSTEN	BIT(0)
+
+/* RCC_C3CFGR register fields */
+#define RCC_C3CFGR_C3RST			BIT(0)
+#define RCC_C3CFGR_C3EN				BIT(1)
+#define RCC_C3CFGR_C3LPEN			BIT(2)
+#define RCC_C3CFGR_C3AMEN			BIT(3)
+#define RCC_C3CFGR_LPTIM3C3EN			BIT(16)
+#define RCC_C3CFGR_LPTIM4C3EN			BIT(17)
+#define RCC_C3CFGR_LPTIM5C3EN			BIT(18)
+#define RCC_C3CFGR_SPI8C3EN			BIT(19)
+#define RCC_C3CFGR_LPUART1C3EN			BIT(20)
+#define RCC_C3CFGR_I2C8C3EN			BIT(21)
+#define RCC_C3CFGR_ADF1C3EN			BIT(23)
+#define RCC_C3CFGR_GPIOZC3EN			BIT(24)
+#define RCC_C3CFGR_LPDMAC3EN			BIT(25)
+#define RCC_C3CFGR_RTCC3EN			BIT(26)
+#define RCC_C3CFGR_I3C4C3EN			BIT(27)
+
+/* RCC_MCO1CFGR register fields */
+#define RCC_MCO1CFGR_MCO1SEL			BIT(0)
+#define RCC_MCO1CFGR_MCO1ON			BIT(8)
+
+/* RCC_MCO2CFGR register fields */
+#define RCC_MCO2CFGR_MCO2SEL			BIT(0)
+#define RCC_MCO2CFGR_MCO2ON			BIT(8)
+
+/* RCC_MCOxCFGR register fields */
+#define RCC_MCOxCFGR_MCOxSEL			BIT(0)
+#define RCC_MCOxCFGR_MCOxON			BIT(8)
+
+/* RCC_OCENSETR register fields */
+#define RCC_OCENSETR_HSION			BIT(0)
+#define RCC_OCENSETR_HSIKERON			BIT(1)
+#define RCC_OCENSETR_HSEDIV2ON			BIT(5)
+#define RCC_OCENSETR_HSEDIV2BYP			BIT(6)
+#define RCC_OCENSETR_HSEDIGBYP			BIT(7)
+#define RCC_OCENSETR_HSEON			BIT(8)
+#define RCC_OCENSETR_HSEKERON			BIT(9)
+#define RCC_OCENSETR_HSEBYP			BIT(10)
+#define RCC_OCENSETR_HSECSSON			BIT(11)
+
+/* RCC_OCENCLRR register fields */
+#define RCC_OCENCLRR_HSION			BIT(0)
+#define RCC_OCENCLRR_HSIKERON			BIT(1)
+#define RCC_OCENCLRR_HSEDIV2ON			BIT(5)
+#define RCC_OCENCLRR_HSEDIV2BYP			BIT(6)
+#define RCC_OCENCLRR_HSEDIGBYP			BIT(7)
+#define RCC_OCENCLRR_HSEON			BIT(8)
+#define RCC_OCENCLRR_HSEKERON			BIT(9)
+#define RCC_OCENCLRR_HSEBYP			BIT(10)
+
+/* RCC_OCRDYR register fields */
+#define RCC_OCRDYR_HSIRDY			BIT(0)
+#define RCC_OCRDYR_HSERDY			BIT(8)
+#define RCC_OCRDYR_CKREST			BIT(25)
+
+#define RCC_OCRDYR_HSIRDY_BIT			0
+#define RCC_OCRDYR_HSERDY_BIT			8
+
+/* RCC_HSICFGR register fields */
+#define RCC_HSICFGR_HSITRIM_MASK		GENMASK(14, 8)
+#define RCC_HSICFGR_HSITRIM_SHIFT		8
+#define RCC_HSICFGR_HSICAL_MASK			GENMASK(24, 16)
+#define RCC_HSICFGR_HSICAL_SHIFT		16
+
+/* RCC_CSICFGR register fields */
+#define RCC_CSICFGR_CSITRIM_MASK		GENMASK(12, 8)
+#define RCC_CSICFGR_CSITRIM_SHIFT		8
+#define RCC_CSICFGR_CSICAL_MASK			GENMASK(23, 16)
+#define RCC_CSICFGR_CSICAL_SHIFT		16
+
+/* RCC_RTCDIVR register fields */
+#define RCC_RTCDIVR_RTCDIV_MASK			GENMASK(5, 0)
+#define RCC_RTCDIVR_RTCDIV_SHIFT		0
+
+/* RCC_APB1DIVR register fields */
+#define RCC_APB1DIVR_APB1DIV_MASK		GENMASK(2, 0)
+#define RCC_APB1DIVR_APB1DIV_SHIFT		0
+#define RCC_APB1DIVR_APB1DIVRDY			BIT(31)
+
+/* RCC_APB2DIVR register fields */
+#define RCC_APB2DIVR_APB2DIV_MASK		GENMASK(2, 0)
+#define RCC_APB2DIVR_APB2DIV_SHIFT		0
+#define RCC_APB2DIVR_APB2DIVRDY			BIT(31)
+
+/* RCC_APB3DIVR register fields */
+#define RCC_APB3DIVR_APB3DIV_MASK		GENMASK(2, 0)
+#define RCC_APB3DIVR_APB3DIV_SHIFT		0
+#define RCC_APB3DIVR_APB3DIVRDY			BIT(31)
+
+/* RCC_APB4DIVR register fields */
+#define RCC_APB4DIVR_APB4DIV_MASK		GENMASK(2, 0)
+#define RCC_APB4DIVR_APB4DIV_SHIFT		0
+#define RCC_APB4DIVR_APB4DIVRDY			BIT(31)
+
+/* RCC_APBDBGDIVR register fields */
+#define RCC_APBDBGDIVR_APBDBGDIV_MASK		GENMASK(2, 0)
+#define RCC_APBDBGDIVR_APBDBGDIV_SHIFT		0
+#define RCC_APBDBGDIVR_APBDBGDIVRDY		BIT(31)
+
+/* RCC_APBxDIVR register fields */
+#define RCC_APBxDIVR_APBxDIV_MASK		GENMASK(2, 0)
+#define RCC_APBxDIVR_APBxDIV_SHIFT		0
+#define RCC_APBxDIVR_APBxDIVRDY			BIT(31)
+
+/* RCC_TIMG1PRER register fields */
+#define RCC_TIMG1PRER_TIMG1PRE			BIT(0)
+#define RCC_TIMG1PRER_TIMG1PRERDY		BIT(31)
+
+/* RCC_TIMG2PRER register fields */
+#define RCC_TIMG2PRER_TIMG2PRE			BIT(0)
+#define RCC_TIMG2PRER_TIMG2PRERDY		BIT(31)
+
+/* RCC_TIMGxPRER register fields */
+#define RCC_TIMGxPRER_TIMGxPRE			BIT(0)
+#define RCC_TIMGxPRER_TIMGxPRERDY		BIT(31)
+
+/* RCC_LSMCUDIVR register fields */
+#define RCC_LSMCUDIVR_LSMCUDIV			BIT(0)
+#define RCC_LSMCUDIVR_LSMCUDIVRDY		BIT(31)
+
+/* RCC_DDRCPCFGR register fields */
+#define RCC_DDRCPCFGR_DDRCPRST			BIT(0)
+#define RCC_DDRCPCFGR_DDRCPEN			BIT(1)
+#define RCC_DDRCPCFGR_DDRCPLPEN			BIT(2)
+
+/* RCC_DDRCAPBCFGR register fields */
+#define RCC_DDRCAPBCFGR_DDRCAPBRST		BIT(0)
+#define RCC_DDRCAPBCFGR_DDRCAPBEN		BIT(1)
+#define RCC_DDRCAPBCFGR_DDRCAPBLPEN		BIT(2)
+
+/* RCC_DDRPHYCAPBCFGR register fields */
+#define RCC_DDRPHYCAPBCFGR_DDRPHYCAPBRST	BIT(0)
+#define RCC_DDRPHYCAPBCFGR_DDRPHYCAPBEN		BIT(1)
+#define RCC_DDRPHYCAPBCFGR_DDRPHYCAPBLPEN	BIT(2)
+
+/* RCC_DDRPHYCCFGR register fields */
+#define RCC_DDRPHYCCFGR_DDRPHYCEN		BIT(1)
+
+/* RCC_DDRCFGR register fields */
+#define RCC_DDRCFGR_DDRCFGRST			BIT(0)
+#define RCC_DDRCFGR_DDRCFGEN			BIT(1)
+#define RCC_DDRCFGR_DDRCFGLPEN			BIT(2)
+
+/* RCC_DDRITFCFGR register fields */
+#define RCC_DDRITFCFGR_DDRRST			BIT(0)
+#define RCC_DDRITFCFGR_DDRCKMOD_MASK		GENMASK(5, 4)
+#define RCC_DDRITFCFGR_DDRCKMOD_SHIFT		4
+#define RCC_DDRITFCFGR_DDRCKMOD_HSR		BIT(5)
+#define RCC_DDRITFCFGR_DDRSHR			BIT(8)
+#define RCC_DDRITFCFGR_DDRPHYDLP		BIT(16)
+
+/* RCC_SYSRAMCFGR register fields */
+#define RCC_SYSRAMCFGR_SYSRAMEN			BIT(1)
+#define RCC_SYSRAMCFGR_SYSRAMLPEN		BIT(2)
+
+/* RCC_VDERAMCFGR register fields */
+#define RCC_VDERAMCFGR_VDERAMEN			BIT(1)
+#define RCC_VDERAMCFGR_VDERAMLPEN		BIT(2)
+
+/* RCC_SRAM1CFGR register fields */
+#define RCC_SRAM1CFGR_SRAM1EN			BIT(1)
+#define RCC_SRAM1CFGR_SRAM1LPEN			BIT(2)
+
+/* RCC_SRAM2CFGR register fields */
+#define RCC_SRAM2CFGR_SRAM2EN			BIT(1)
+#define RCC_SRAM2CFGR_SRAM2LPEN			BIT(2)
+
+/* RCC_RETRAMCFGR register fields */
+#define RCC_RETRAMCFGR_RETRAMEN			BIT(1)
+#define RCC_RETRAMCFGR_RETRAMLPEN		BIT(2)
+
+/* RCC_BKPSRAMCFGR register fields */
+#define RCC_BKPSRAMCFGR_BKPSRAMEN		BIT(1)
+#define RCC_BKPSRAMCFGR_BKPSRAMLPEN		BIT(2)
+
+/* RCC_LPSRAM1CFGR register fields */
+#define RCC_LPSRAM1CFGR_LPSRAM1EN		BIT(1)
+#define RCC_LPSRAM1CFGR_LPSRAM1LPEN		BIT(2)
+#define RCC_LPSRAM1CFGR_LPSRAM1AMEN		BIT(3)
+
+/* RCC_LPSRAM2CFGR register fields */
+#define RCC_LPSRAM2CFGR_LPSRAM2EN		BIT(1)
+#define RCC_LPSRAM2CFGR_LPSRAM2LPEN		BIT(2)
+#define RCC_LPSRAM2CFGR_LPSRAM2AMEN		BIT(3)
+
+/* RCC_LPSRAM3CFGR register fields */
+#define RCC_LPSRAM3CFGR_LPSRAM3EN		BIT(1)
+#define RCC_LPSRAM3CFGR_LPSRAM3LPEN		BIT(2)
+#define RCC_LPSRAM3CFGR_LPSRAM3AMEN		BIT(3)
+
+/* RCC_OSPI1CFGR register fields */
+#define RCC_OSPI1CFGR_OSPI1RST			BIT(0)
+#define RCC_OSPI1CFGR_OSPI1EN			BIT(1)
+#define RCC_OSPI1CFGR_OSPI1LPEN			BIT(2)
+#define RCC_OSPI1CFGR_OTFDEC1RST		BIT(8)
+#define RCC_OSPI1CFGR_OSPI1DLLRST		BIT(16)
+
+/* RCC_OSPI2CFGR register fields */
+#define RCC_OSPI2CFGR_OSPI2RST			BIT(0)
+#define RCC_OSPI2CFGR_OSPI2EN			BIT(1)
+#define RCC_OSPI2CFGR_OSPI2LPEN			BIT(2)
+#define RCC_OSPI2CFGR_OTFDEC2RST		BIT(8)
+#define RCC_OSPI2CFGR_OSPI2DLLRST		BIT(16)
+
+/* RCC_OSPIxCFGR register fields */
+#define RCC_OSPIxCFGR_OSPIxRST			BIT(0)
+#define RCC_OSPIxCFGR_OSPIxEN			BIT(1)
+#define RCC_OSPIxCFGR_OSPIxLPEN			BIT(2)
+#define RCC_OSPIxCFGR_OTFDECxRST		BIT(8)
+#define RCC_OSPIxCFGR_OSPIxDLLRST		BIT(16)
+
+/* RCC_FMCCFGR register fields */
+#define RCC_FMCCFGR_FMCRST			BIT(0)
+#define RCC_FMCCFGR_FMCEN			BIT(1)
+#define RCC_FMCCFGR_FMCLPEN			BIT(2)
+
+/* RCC_DBGCFGR register fields */
+#define RCC_DBGCFGR_DBGEN			BIT(8)
+#define RCC_DBGCFGR_TRACEEN			BIT(9)
+#define RCC_DBGCFGR_DBGRST			BIT(12)
+
+/* RCC_STM500CFGR register fields */
+#define RCC_STM500CFGR_STM500EN			BIT(1)
+#define RCC_STM500CFGR_STM500LPEN		BIT(2)
+
+/* RCC_ETRCFGR register fields */
+#define RCC_ETRCFGR_ETREN			BIT(1)
+#define RCC_ETRCFGR_ETRLPEN			BIT(2)
+
+/* RCC_GPIOACFGR register fields */
+#define RCC_GPIOACFGR_GPIOARST			BIT(0)
+#define RCC_GPIOACFGR_GPIOAEN			BIT(1)
+#define RCC_GPIOACFGR_GPIOALPEN			BIT(2)
+
+/* RCC_GPIOBCFGR register fields */
+#define RCC_GPIOBCFGR_GPIOBRST			BIT(0)
+#define RCC_GPIOBCFGR_GPIOBEN			BIT(1)
+#define RCC_GPIOBCFGR_GPIOBLPEN			BIT(2)
+
+/* RCC_GPIOCCFGR register fields */
+#define RCC_GPIOCCFGR_GPIOCRST			BIT(0)
+#define RCC_GPIOCCFGR_GPIOCEN			BIT(1)
+#define RCC_GPIOCCFGR_GPIOCLPEN			BIT(2)
+
+/* RCC_GPIODCFGR register fields */
+#define RCC_GPIODCFGR_GPIODRST			BIT(0)
+#define RCC_GPIODCFGR_GPIODEN			BIT(1)
+#define RCC_GPIODCFGR_GPIODLPEN			BIT(2)
+
+/* RCC_GPIOECFGR register fields */
+#define RCC_GPIOECFGR_GPIOERST			BIT(0)
+#define RCC_GPIOECFGR_GPIOEEN			BIT(1)
+#define RCC_GPIOECFGR_GPIOELPEN			BIT(2)
+
+/* RCC_GPIOFCFGR register fields */
+#define RCC_GPIOFCFGR_GPIOFRST			BIT(0)
+#define RCC_GPIOFCFGR_GPIOFEN			BIT(1)
+#define RCC_GPIOFCFGR_GPIOFLPEN			BIT(2)
+
+/* RCC_GPIOGCFGR register fields */
+#define RCC_GPIOGCFGR_GPIOGRST			BIT(0)
+#define RCC_GPIOGCFGR_GPIOGEN			BIT(1)
+#define RCC_GPIOGCFGR_GPIOGLPEN			BIT(2)
+
+/* RCC_GPIOHCFGR register fields */
+#define RCC_GPIOHCFGR_GPIOHRST			BIT(0)
+#define RCC_GPIOHCFGR_GPIOHEN			BIT(1)
+#define RCC_GPIOHCFGR_GPIOHLPEN			BIT(2)
+
+/* RCC_GPIOICFGR register fields */
+#define RCC_GPIOICFGR_GPIOIRST			BIT(0)
+#define RCC_GPIOICFGR_GPIOIEN			BIT(1)
+#define RCC_GPIOICFGR_GPIOILPEN			BIT(2)
+
+/* RCC_GPIOJCFGR register fields */
+#define RCC_GPIOJCFGR_GPIOJRST			BIT(0)
+#define RCC_GPIOJCFGR_GPIOJEN			BIT(1)
+#define RCC_GPIOJCFGR_GPIOJLPEN			BIT(2)
+
+/* RCC_GPIOKCFGR register fields */
+#define RCC_GPIOKCFGR_GPIOKRST			BIT(0)
+#define RCC_GPIOKCFGR_GPIOKEN			BIT(1)
+#define RCC_GPIOKCFGR_GPIOKLPEN			BIT(2)
+
+/* RCC_GPIOZCFGR register fields */
+#define RCC_GPIOZCFGR_GPIOZRST			BIT(0)
+#define RCC_GPIOZCFGR_GPIOZEN			BIT(1)
+#define RCC_GPIOZCFGR_GPIOZLPEN			BIT(2)
+#define RCC_GPIOZCFGR_GPIOZAMEN			BIT(3)
+
+/* RCC_GPIOxCFGR register fields */
+#define RCC_GPIOxCFGR_GPIOxRST			BIT(0)
+#define RCC_GPIOxCFGR_GPIOxEN			BIT(1)
+#define RCC_GPIOxCFGR_GPIOxLPEN			BIT(2)
+#define RCC_GPIOxCFGR_GPIOxAMEN			BIT(3)
+
+/* RCC_HPDMA1CFGR register fields */
+#define RCC_HPDMA1CFGR_HPDMA1RST		BIT(0)
+#define RCC_HPDMA1CFGR_HPDMA1EN			BIT(1)
+#define RCC_HPDMA1CFGR_HPDMA1LPEN		BIT(2)
+
+/* RCC_HPDMA2CFGR register fields */
+#define RCC_HPDMA2CFGR_HPDMA2RST		BIT(0)
+#define RCC_HPDMA2CFGR_HPDMA2EN			BIT(1)
+#define RCC_HPDMA2CFGR_HPDMA2LPEN		BIT(2)
+
+/* RCC_HPDMA3CFGR register fields */
+#define RCC_HPDMA3CFGR_HPDMA3RST		BIT(0)
+#define RCC_HPDMA3CFGR_HPDMA3EN			BIT(1)
+#define RCC_HPDMA3CFGR_HPDMA3LPEN		BIT(2)
+
+/* RCC_HPDMAxCFGR register fields */
+#define RCC_HPDMAxCFGR_HPDMAxRST		BIT(0)
+#define RCC_HPDMAxCFGR_HPDMAxEN			BIT(1)
+#define RCC_HPDMAxCFGR_HPDMAxLPEN		BIT(2)
+
+/* RCC_LPDMACFGR register fields */
+#define RCC_LPDMACFGR_LPDMARST			BIT(0)
+#define RCC_LPDMACFGR_LPDMAEN			BIT(1)
+#define RCC_LPDMACFGR_LPDMALPEN			BIT(2)
+#define RCC_LPDMACFGR_LPDMAAMEN			BIT(3)
+
+/* RCC_HSEMCFGR register fields */
+#define RCC_HSEMCFGR_HSEMRST			BIT(0)
+#define RCC_HSEMCFGR_HSEMEN			BIT(1)
+#define RCC_HSEMCFGR_HSEMLPEN			BIT(2)
+#define RCC_HSEMCFGR_HSEMAMEN			BIT(3)
+
+/* RCC_IPCC1CFGR register fields */
+#define RCC_IPCC1CFGR_IPCC1RST			BIT(0)
+#define RCC_IPCC1CFGR_IPCC1EN			BIT(1)
+#define RCC_IPCC1CFGR_IPCC1LPEN			BIT(2)
+
+/* RCC_IPCC2CFGR register fields */
+#define RCC_IPCC2CFGR_IPCC2RST			BIT(0)
+#define RCC_IPCC2CFGR_IPCC2EN			BIT(1)
+#define RCC_IPCC2CFGR_IPCC2LPEN			BIT(2)
+#define RCC_IPCC2CFGR_IPCC2AMEN			BIT(3)
+
+/* RCC_RTCCFGR register fields */
+#define RCC_RTCCFGR_RTCEN			BIT(1)
+#define RCC_RTCCFGR_RTCLPEN			BIT(2)
+#define RCC_RTCCFGR_RTCAMEN			BIT(3)
+
+/* RCC_SYSCPU1CFGR register fields */
+#define RCC_SYSCPU1CFGR_SYSCPU1EN		BIT(1)
+#define RCC_SYSCPU1CFGR_SYSCPU1LPEN		BIT(2)
+
+/* RCC_BSECCFGR register fields */
+#define RCC_BSECCFGR_BSECEN			BIT(1)
+#define RCC_BSECCFGR_BSECLPEN			BIT(2)
+
+/* RCC_IS2MCFGR register fields */
+#define RCC_IS2MCFGR_IS2MRST			BIT(0)
+#define RCC_IS2MCFGR_IS2MEN			BIT(1)
+#define RCC_IS2MCFGR_IS2MLPEN			BIT(2)
+
+/* RCC_PLL2CFGR1 register fields */
+#define RCC_PLL2CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL2CFGR1_PLLEN			BIT(8)
+#define RCC_PLL2CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL2CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL2CFGR2 register fields */
+#define RCC_PLL2CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL2CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL2CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL2CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL2CFGR3 register fields */
+#define RCC_PLL2CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL2CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL2CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL2CFGR3_DACEN			BIT(25)
+#define RCC_PLL2CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL2CFGR4 register fields */
+#define RCC_PLL2CFGR4_DSMEN			BIT(8)
+#define RCC_PLL2CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL2CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL2CFGR5 register fields */
+#define RCC_PLL2CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL2CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL2CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL2CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL2CFGR6 register fields */
+#define RCC_PLL2CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL2CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL2CFGR7 register fields */
+#define RCC_PLL2CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL2CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL3CFGR1 register fields */
+#define RCC_PLL3CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL3CFGR1_PLLEN			BIT(8)
+#define RCC_PLL3CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL3CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL3CFGR2 register fields */
+#define RCC_PLL3CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL3CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL3CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL3CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL3CFGR3 register fields */
+#define RCC_PLL3CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL3CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL3CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL3CFGR3_DACEN			BIT(25)
+#define RCC_PLL3CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL3CFGR4 register fields */
+#define RCC_PLL3CFGR4_DSMEN			BIT(8)
+#define RCC_PLL3CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL3CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL3CFGR5 register fields */
+#define RCC_PLL3CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL3CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL3CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL3CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL3CFGR6 register fields */
+#define RCC_PLL3CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL3CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL3CFGR7 register fields */
+#define RCC_PLL3CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL3CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLLxCFGR1 register fields */
+#define RCC_PLLxCFGR1_SSMODRST			BIT(0)
+#define RCC_PLLxCFGR1_PLLEN			BIT(8)
+#define RCC_PLLxCFGR1_PLLRDY			BIT(24)
+#define RCC_PLLxCFGR1_CKREFST			BIT(28)
+
+/* RCC_PLLxCFGR2 register fields */
+#define RCC_PLLxCFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLLxCFGR2_FREFDIV_SHIFT		0
+#define RCC_PLLxCFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLLxCFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLLxCFGR3 register fields */
+#define RCC_PLLxCFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLLxCFGR3_FRACIN_SHIFT		0
+#define RCC_PLLxCFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLLxCFGR3_DACEN			BIT(25)
+#define RCC_PLLxCFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLLxCFGR4 register fields */
+#define RCC_PLLxCFGR4_DSMEN			BIT(8)
+#define RCC_PLLxCFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLLxCFGR4_BYPASS			BIT(10)
+
+/* RCC_PLLxCFGR5 register fields */
+#define RCC_PLLxCFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLLxCFGR5_DIVVAL_SHIFT		0
+#define RCC_PLLxCFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLLxCFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLLxCFGR6 register fields */
+#define RCC_PLLxCFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLLxCFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLLxCFGR7 register fields */
+#define RCC_PLLxCFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLLxCFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_HSIFMONCR register fields */
+#define RCC_HSIFMONCR_HSIREF_MASK		GENMASK(10, 0)
+#define RCC_HSIFMONCR_HSIREF_SHIFT		0
+#define RCC_HSIFMONCR_HSIMONEN			BIT(15)
+#define RCC_HSIFMONCR_HSIDEV_MASK		GENMASK(21, 16)
+#define RCC_HSIFMONCR_HSIDEV_SHIFT		16
+#define RCC_HSIFMONCR_HSIMONIE			BIT(30)
+#define RCC_HSIFMONCR_HSIMONF			BIT(31)
+
+/* RCC_HSIFVALR register fields */
+#define RCC_HSIFVALR_HSIVAL_MASK		GENMASK(10, 0)
+#define RCC_HSIFVALR_HSIVAL_SHIFT		0
+
+/* RCC_TIM1CFGR register fields */
+#define RCC_TIM1CFGR_TIM1RST			BIT(0)
+#define RCC_TIM1CFGR_TIM1EN			BIT(1)
+#define RCC_TIM1CFGR_TIM1LPEN			BIT(2)
+
+/* RCC_TIM2CFGR register fields */
+#define RCC_TIM2CFGR_TIM2RST			BIT(0)
+#define RCC_TIM2CFGR_TIM2EN			BIT(1)
+#define RCC_TIM2CFGR_TIM2LPEN			BIT(2)
+
+/* RCC_TIM3CFGR register fields */
+#define RCC_TIM3CFGR_TIM3RST			BIT(0)
+#define RCC_TIM3CFGR_TIM3EN			BIT(1)
+#define RCC_TIM3CFGR_TIM3LPEN			BIT(2)
+
+/* RCC_TIM4CFGR register fields */
+#define RCC_TIM4CFGR_TIM4RST			BIT(0)
+#define RCC_TIM4CFGR_TIM4EN			BIT(1)
+#define RCC_TIM4CFGR_TIM4LPEN			BIT(2)
+
+/* RCC_TIM5CFGR register fields */
+#define RCC_TIM5CFGR_TIM5RST			BIT(0)
+#define RCC_TIM5CFGR_TIM5EN			BIT(1)
+#define RCC_TIM5CFGR_TIM5LPEN			BIT(2)
+
+/* RCC_TIM6CFGR register fields */
+#define RCC_TIM6CFGR_TIM6RST			BIT(0)
+#define RCC_TIM6CFGR_TIM6EN			BIT(1)
+#define RCC_TIM6CFGR_TIM6LPEN			BIT(2)
+
+/* RCC_TIM7CFGR register fields */
+#define RCC_TIM7CFGR_TIM7RST			BIT(0)
+#define RCC_TIM7CFGR_TIM7EN			BIT(1)
+#define RCC_TIM7CFGR_TIM7LPEN			BIT(2)
+
+/* RCC_TIM8CFGR register fields */
+#define RCC_TIM8CFGR_TIM8RST			BIT(0)
+#define RCC_TIM8CFGR_TIM8EN			BIT(1)
+#define RCC_TIM8CFGR_TIM8LPEN			BIT(2)
+
+/* RCC_TIM10CFGR register fields */
+#define RCC_TIM10CFGR_TIM10RST			BIT(0)
+#define RCC_TIM10CFGR_TIM10EN			BIT(1)
+#define RCC_TIM10CFGR_TIM10LPEN			BIT(2)
+
+/* RCC_TIM11CFGR register fields */
+#define RCC_TIM11CFGR_TIM11RST			BIT(0)
+#define RCC_TIM11CFGR_TIM11EN			BIT(1)
+#define RCC_TIM11CFGR_TIM11LPEN			BIT(2)
+
+/* RCC_TIM12CFGR register fields */
+#define RCC_TIM12CFGR_TIM12RST			BIT(0)
+#define RCC_TIM12CFGR_TIM12EN			BIT(1)
+#define RCC_TIM12CFGR_TIM12LPEN			BIT(2)
+
+/* RCC_TIM13CFGR register fields */
+#define RCC_TIM13CFGR_TIM13RST			BIT(0)
+#define RCC_TIM13CFGR_TIM13EN			BIT(1)
+#define RCC_TIM13CFGR_TIM13LPEN			BIT(2)
+
+/* RCC_TIM14CFGR register fields */
+#define RCC_TIM14CFGR_TIM14RST			BIT(0)
+#define RCC_TIM14CFGR_TIM14EN			BIT(1)
+#define RCC_TIM14CFGR_TIM14LPEN			BIT(2)
+
+/* RCC_TIM15CFGR register fields */
+#define RCC_TIM15CFGR_TIM15RST			BIT(0)
+#define RCC_TIM15CFGR_TIM15EN			BIT(1)
+#define RCC_TIM15CFGR_TIM15LPEN			BIT(2)
+
+/* RCC_TIM16CFGR register fields */
+#define RCC_TIM16CFGR_TIM16RST			BIT(0)
+#define RCC_TIM16CFGR_TIM16EN			BIT(1)
+#define RCC_TIM16CFGR_TIM16LPEN			BIT(2)
+
+/* RCC_TIM17CFGR register fields */
+#define RCC_TIM17CFGR_TIM17RST			BIT(0)
+#define RCC_TIM17CFGR_TIM17EN			BIT(1)
+#define RCC_TIM17CFGR_TIM17LPEN			BIT(2)
+
+/* RCC_TIM20CFGR register fields */
+#define RCC_TIM20CFGR_TIM20RST			BIT(0)
+#define RCC_TIM20CFGR_TIM20EN			BIT(1)
+#define RCC_TIM20CFGR_TIM20LPEN			BIT(2)
+
+/* RCC_LPTIM1CFGR register fields */
+#define RCC_LPTIM1CFGR_LPTIM1RST		BIT(0)
+#define RCC_LPTIM1CFGR_LPTIM1EN			BIT(1)
+#define RCC_LPTIM1CFGR_LPTIM1LPEN		BIT(2)
+
+/* RCC_LPTIM2CFGR register fields */
+#define RCC_LPTIM2CFGR_LPTIM2RST		BIT(0)
+#define RCC_LPTIM2CFGR_LPTIM2EN			BIT(1)
+#define RCC_LPTIM2CFGR_LPTIM2LPEN		BIT(2)
+
+/* RCC_LPTIM3CFGR register fields */
+#define RCC_LPTIM3CFGR_LPTIM3RST		BIT(0)
+#define RCC_LPTIM3CFGR_LPTIM3EN			BIT(1)
+#define RCC_LPTIM3CFGR_LPTIM3LPEN		BIT(2)
+#define RCC_LPTIM3CFGR_LPTIM3AMEN		BIT(3)
+
+/* RCC_LPTIM4CFGR register fields */
+#define RCC_LPTIM4CFGR_LPTIM4RST		BIT(0)
+#define RCC_LPTIM4CFGR_LPTIM4EN			BIT(1)
+#define RCC_LPTIM4CFGR_LPTIM4LPEN		BIT(2)
+#define RCC_LPTIM4CFGR_LPTIM4AMEN		BIT(3)
+
+/* RCC_LPTIM5CFGR register fields */
+#define RCC_LPTIM5CFGR_LPTIM5RST		BIT(0)
+#define RCC_LPTIM5CFGR_LPTIM5EN			BIT(1)
+#define RCC_LPTIM5CFGR_LPTIM5LPEN		BIT(2)
+#define RCC_LPTIM5CFGR_LPTIM5AMEN		BIT(3)
+
+/* RCC_LPTIMxCFGR register fields */
+#define RCC_LPTIMxCFGR_LPTIMxRST		BIT(0)
+#define RCC_LPTIMxCFGR_LPTIMxEN			BIT(1)
+#define RCC_LPTIMxCFGR_LPTIMxLPEN		BIT(2)
+#define RCC_LPTIMxCFGR_LPTIMxAMEN		BIT(3)
+
+/* RCC_SPI1CFGR register fields */
+#define RCC_SPI1CFGR_SPI1RST			BIT(0)
+#define RCC_SPI1CFGR_SPI1EN			BIT(1)
+#define RCC_SPI1CFGR_SPI1LPEN			BIT(2)
+
+/* RCC_SPI2CFGR register fields */
+#define RCC_SPI2CFGR_SPI2RST			BIT(0)
+#define RCC_SPI2CFGR_SPI2EN			BIT(1)
+#define RCC_SPI2CFGR_SPI2LPEN			BIT(2)
+
+/* RCC_SPI3CFGR register fields */
+#define RCC_SPI3CFGR_SPI3RST			BIT(0)
+#define RCC_SPI3CFGR_SPI3EN			BIT(1)
+#define RCC_SPI3CFGR_SPI3LPEN			BIT(2)
+
+/* RCC_SPI4CFGR register fields */
+#define RCC_SPI4CFGR_SPI4RST			BIT(0)
+#define RCC_SPI4CFGR_SPI4EN			BIT(1)
+#define RCC_SPI4CFGR_SPI4LPEN			BIT(2)
+
+/* RCC_SPI5CFGR register fields */
+#define RCC_SPI5CFGR_SPI5RST			BIT(0)
+#define RCC_SPI5CFGR_SPI5EN			BIT(1)
+#define RCC_SPI5CFGR_SPI5LPEN			BIT(2)
+
+/* RCC_SPI6CFGR register fields */
+#define RCC_SPI6CFGR_SPI6RST			BIT(0)
+#define RCC_SPI6CFGR_SPI6EN			BIT(1)
+#define RCC_SPI6CFGR_SPI6LPEN			BIT(2)
+
+/* RCC_SPI7CFGR register fields */
+#define RCC_SPI7CFGR_SPI7RST			BIT(0)
+#define RCC_SPI7CFGR_SPI7EN			BIT(1)
+#define RCC_SPI7CFGR_SPI7LPEN			BIT(2)
+
+/* RCC_SPI8CFGR register fields */
+#define RCC_SPI8CFGR_SPI8RST			BIT(0)
+#define RCC_SPI8CFGR_SPI8EN			BIT(1)
+#define RCC_SPI8CFGR_SPI8LPEN			BIT(2)
+#define RCC_SPI8CFGR_SPI8AMEN			BIT(3)
+
+/* RCC_SPIxCFGR register fields */
+#define RCC_SPIxCFGR_SPIxRST			BIT(0)
+#define RCC_SPIxCFGR_SPIxEN			BIT(1)
+#define RCC_SPIxCFGR_SPIxLPEN			BIT(2)
+#define RCC_SPIxCFGR_SPIxAMEN			BIT(3)
+
+/* RCC_SPDIFRXCFGR register fields */
+#define RCC_SPDIFRXCFGR_SPDIFRXRST		BIT(0)
+#define RCC_SPDIFRXCFGR_SPDIFRXEN		BIT(1)
+#define RCC_SPDIFRXCFGR_SPDIFRXLPEN		BIT(2)
+
+/* RCC_USART1CFGR register fields */
+#define RCC_USART1CFGR_USART1RST		BIT(0)
+#define RCC_USART1CFGR_USART1EN			BIT(1)
+#define RCC_USART1CFGR_USART1LPEN		BIT(2)
+
+/* RCC_USART2CFGR register fields */
+#define RCC_USART2CFGR_USART2RST		BIT(0)
+#define RCC_USART2CFGR_USART2EN			BIT(1)
+#define RCC_USART2CFGR_USART2LPEN		BIT(2)
+
+/* RCC_USART3CFGR register fields */
+#define RCC_USART3CFGR_USART3RST		BIT(0)
+#define RCC_USART3CFGR_USART3EN			BIT(1)
+#define RCC_USART3CFGR_USART3LPEN		BIT(2)
+
+/* RCC_UART4CFGR register fields */
+#define RCC_UART4CFGR_UART4RST			BIT(0)
+#define RCC_UART4CFGR_UART4EN			BIT(1)
+#define RCC_UART4CFGR_UART4LPEN			BIT(2)
+
+/* RCC_UART5CFGR register fields */
+#define RCC_UART5CFGR_UART5RST			BIT(0)
+#define RCC_UART5CFGR_UART5EN			BIT(1)
+#define RCC_UART5CFGR_UART5LPEN			BIT(2)
+
+/* RCC_USART6CFGR register fields */
+#define RCC_USART6CFGR_USART6RST		BIT(0)
+#define RCC_USART6CFGR_USART6EN			BIT(1)
+#define RCC_USART6CFGR_USART6LPEN		BIT(2)
+
+/* RCC_UART7CFGR register fields */
+#define RCC_UART7CFGR_UART7RST			BIT(0)
+#define RCC_UART7CFGR_UART7EN			BIT(1)
+#define RCC_UART7CFGR_UART7LPEN			BIT(2)
+
+/* RCC_UART8CFGR register fields */
+#define RCC_UART8CFGR_UART8RST			BIT(0)
+#define RCC_UART8CFGR_UART8EN			BIT(1)
+#define RCC_UART8CFGR_UART8LPEN			BIT(2)
+
+/* RCC_UART9CFGR register fields */
+#define RCC_UART9CFGR_UART9RST			BIT(0)
+#define RCC_UART9CFGR_UART9EN			BIT(1)
+#define RCC_UART9CFGR_UART9LPEN			BIT(2)
+
+/* RCC_USARTxCFGR register fields */
+#define RCC_USARTxCFGR_USARTxRST		BIT(0)
+#define RCC_USARTxCFGR_USARTxEN			BIT(1)
+#define RCC_USARTxCFGR_USARTxLPEN		BIT(2)
+
+/* RCC_UARTxCFGR register fields */
+#define RCC_UARTxCFGR_UARTxRST			BIT(0)
+#define RCC_UARTxCFGR_UARTxEN			BIT(1)
+#define RCC_UARTxCFGR_UARTxLPEN			BIT(2)
+
+/* RCC_LPUART1CFGR register fields */
+#define RCC_LPUART1CFGR_LPUART1RST		BIT(0)
+#define RCC_LPUART1CFGR_LPUART1EN		BIT(1)
+#define RCC_LPUART1CFGR_LPUART1LPEN		BIT(2)
+#define RCC_LPUART1CFGR_LPUART1AMEN		BIT(3)
+
+/* RCC_I2C1CFGR register fields */
+#define RCC_I2C1CFGR_I2C1RST			BIT(0)
+#define RCC_I2C1CFGR_I2C1EN			BIT(1)
+#define RCC_I2C1CFGR_I2C1LPEN			BIT(2)
+
+/* RCC_I2C2CFGR register fields */
+#define RCC_I2C2CFGR_I2C2RST			BIT(0)
+#define RCC_I2C2CFGR_I2C2EN			BIT(1)
+#define RCC_I2C2CFGR_I2C2LPEN			BIT(2)
+
+/* RCC_I2C3CFGR register fields */
+#define RCC_I2C3CFGR_I2C3RST			BIT(0)
+#define RCC_I2C3CFGR_I2C3EN			BIT(1)
+#define RCC_I2C3CFGR_I2C3LPEN			BIT(2)
+
+/* RCC_I2C4CFGR register fields */
+#define RCC_I2C4CFGR_I2C4RST			BIT(0)
+#define RCC_I2C4CFGR_I2C4EN			BIT(1)
+#define RCC_I2C4CFGR_I2C4LPEN			BIT(2)
+
+/* RCC_I2C5CFGR register fields */
+#define RCC_I2C5CFGR_I2C5RST			BIT(0)
+#define RCC_I2C5CFGR_I2C5EN			BIT(1)
+#define RCC_I2C5CFGR_I2C5LPEN			BIT(2)
+
+/* RCC_I2C6CFGR register fields */
+#define RCC_I2C6CFGR_I2C6RST			BIT(0)
+#define RCC_I2C6CFGR_I2C6EN			BIT(1)
+#define RCC_I2C6CFGR_I2C6LPEN			BIT(2)
+
+/* RCC_I2C7CFGR register fields */
+#define RCC_I2C7CFGR_I2C7RST			BIT(0)
+#define RCC_I2C7CFGR_I2C7EN			BIT(1)
+#define RCC_I2C7CFGR_I2C7LPEN			BIT(2)
+
+/* RCC_I2C8CFGR register fields */
+#define RCC_I2C8CFGR_I2C8RST			BIT(0)
+#define RCC_I2C8CFGR_I2C8EN			BIT(1)
+#define RCC_I2C8CFGR_I2C8LPEN			BIT(2)
+#define RCC_I2C8CFGR_I2C8AMEN			BIT(3)
+
+/* RCC_I2CxCFGR register fields */
+#define RCC_I2CxCFGR_I2CxRST			BIT(0)
+#define RCC_I2CxCFGR_I2CxEN			BIT(1)
+#define RCC_I2CxCFGR_I2CxLPEN			BIT(2)
+#define RCC_I2CxCFGR_I2CxAMEN			BIT(3)
+
+/* RCC_SAI1CFGR register fields */
+#define RCC_SAI1CFGR_SAI1RST			BIT(0)
+#define RCC_SAI1CFGR_SAI1EN			BIT(1)
+#define RCC_SAI1CFGR_SAI1LPEN			BIT(2)
+
+/* RCC_SAI2CFGR register fields */
+#define RCC_SAI2CFGR_SAI2RST			BIT(0)
+#define RCC_SAI2CFGR_SAI2EN			BIT(1)
+#define RCC_SAI2CFGR_SAI2LPEN			BIT(2)
+
+/* RCC_SAI3CFGR register fields */
+#define RCC_SAI3CFGR_SAI3RST			BIT(0)
+#define RCC_SAI3CFGR_SAI3EN			BIT(1)
+#define RCC_SAI3CFGR_SAI3LPEN			BIT(2)
+
+/* RCC_SAI4CFGR register fields */
+#define RCC_SAI4CFGR_SAI4RST			BIT(0)
+#define RCC_SAI4CFGR_SAI4EN			BIT(1)
+#define RCC_SAI4CFGR_SAI4LPEN			BIT(2)
+
+/* RCC_SAIxCFGR register fields */
+#define RCC_SAIxCFGR_SAIxRST			BIT(0)
+#define RCC_SAIxCFGR_SAIxEN			BIT(1)
+#define RCC_SAIxCFGR_SAIxLPEN			BIT(2)
+
+/* RCC_MDF1CFGR register fields */
+#define RCC_MDF1CFGR_MDF1RST			BIT(0)
+#define RCC_MDF1CFGR_MDF1EN			BIT(1)
+#define RCC_MDF1CFGR_MDF1LPEN			BIT(2)
+
+/* RCC_ADF1CFGR register fields */
+#define RCC_ADF1CFGR_ADF1RST			BIT(0)
+#define RCC_ADF1CFGR_ADF1EN			BIT(1)
+#define RCC_ADF1CFGR_ADF1LPEN			BIT(2)
+#define RCC_ADF1CFGR_ADF1AMEN			BIT(3)
+
+/* RCC_FDCANCFGR register fields */
+#define RCC_FDCANCFGR_FDCANRST			BIT(0)
+#define RCC_FDCANCFGR_FDCANEN			BIT(1)
+#define RCC_FDCANCFGR_FDCANLPEN			BIT(2)
+
+/* RCC_HDPCFGR register fields */
+#define RCC_HDPCFGR_HDPRST			BIT(0)
+#define RCC_HDPCFGR_HDPEN			BIT(1)
+
+/* RCC_ADC12CFGR register fields */
+#define RCC_ADC12CFGR_ADC12RST			BIT(0)
+#define RCC_ADC12CFGR_ADC12EN			BIT(1)
+#define RCC_ADC12CFGR_ADC12LPEN			BIT(2)
+#define RCC_ADC12CFGR_ADC12KERSEL		BIT(12)
+
+/* RCC_ADC3CFGR register fields */
+#define RCC_ADC3CFGR_ADC3RST			BIT(0)
+#define RCC_ADC3CFGR_ADC3EN			BIT(1)
+#define RCC_ADC3CFGR_ADC3LPEN			BIT(2)
+#define RCC_ADC3CFGR_ADC3KERSEL_MASK		GENMASK(13, 12)
+#define RCC_ADC3CFGR_ADC3KERSEL_SHIFT		12
+
+/* RCC_ETH1CFGR register fields */
+#define RCC_ETH1CFGR_ETH1RST			BIT(0)
+#define RCC_ETH1CFGR_ETH1MACEN			BIT(1)
+#define RCC_ETH1CFGR_ETH1MACLPEN		BIT(2)
+#define RCC_ETH1CFGR_ETH1STPEN			BIT(4)
+#define RCC_ETH1CFGR_ETH1EN			BIT(5)
+#define RCC_ETH1CFGR_ETH1LPEN			BIT(6)
+#define RCC_ETH1CFGR_ETH1TXEN			BIT(8)
+#define RCC_ETH1CFGR_ETH1TXLPEN			BIT(9)
+#define RCC_ETH1CFGR_ETH1RXEN			BIT(10)
+#define RCC_ETH1CFGR_ETH1RXLPEN			BIT(11)
+
+/* RCC_ETH2CFGR register fields */
+#define RCC_ETH2CFGR_ETH2RST			BIT(0)
+#define RCC_ETH2CFGR_ETH2MACEN			BIT(1)
+#define RCC_ETH2CFGR_ETH2MACLPEN		BIT(2)
+#define RCC_ETH2CFGR_ETH2STPEN			BIT(4)
+#define RCC_ETH2CFGR_ETH2EN			BIT(5)
+#define RCC_ETH2CFGR_ETH2LPEN			BIT(6)
+#define RCC_ETH2CFGR_ETH2TXEN			BIT(8)
+#define RCC_ETH2CFGR_ETH2TXLPEN			BIT(9)
+#define RCC_ETH2CFGR_ETH2RXEN			BIT(10)
+#define RCC_ETH2CFGR_ETH2RXLPEN			BIT(11)
+
+/* RCC_ETHxCFGR register fields */
+#define RCC_ETHxCFGR_ETHxRST			BIT(0)
+#define RCC_ETHxCFGR_ETHxMACEN			BIT(1)
+#define RCC_ETHxCFGR_ETHxMACLPEN		BIT(2)
+#define RCC_ETHxCFGR_ETHxSTPEN			BIT(4)
+#define RCC_ETHxCFGR_ETHxEN			BIT(5)
+#define RCC_ETHxCFGR_ETHxLPEN			BIT(6)
+#define RCC_ETHxCFGR_ETHxTXEN			BIT(8)
+#define RCC_ETHxCFGR_ETHxTXLPEN			BIT(9)
+#define RCC_ETHxCFGR_ETHxRXEN			BIT(10)
+#define RCC_ETHxCFGR_ETHxRXLPEN			BIT(11)
+
+/* RCC_USB2CFGR register fields */
+#define RCC_USB2CFGR_USB2RST			BIT(0)
+#define RCC_USB2CFGR_USB2EN			BIT(1)
+#define RCC_USB2CFGR_USB2LPEN			BIT(2)
+#define RCC_USB2CFGR_USB2STPEN			BIT(4)
+
+/* RCC_USB2PHY1CFGR register fields */
+#define RCC_USB2PHY1CFGR_USB2PHY1RST		BIT(0)
+#define RCC_USB2PHY1CFGR_USB2PHY1EN		BIT(1)
+#define RCC_USB2PHY1CFGR_USB2PHY1LPEN		BIT(2)
+#define RCC_USB2PHY1CFGR_USB2PHY1STPEN		BIT(4)
+#define RCC_USB2PHY1CFGR_USB2PHY1CKREFSEL	BIT(15)
+
+/* RCC_USB2PHY2CFGR register fields */
+#define RCC_USB2PHY2CFGR_USB2PHY2RST		BIT(0)
+#define RCC_USB2PHY2CFGR_USB2PHY2EN		BIT(1)
+#define RCC_USB2PHY2CFGR_USB2PHY2LPEN		BIT(2)
+#define RCC_USB2PHY2CFGR_USB2PHY2STPEN		BIT(4)
+#define RCC_USB2PHY2CFGR_USB2PHY2CKREFSEL	BIT(15)
+
+/* RCC_USB2PHYxCFGR register fields */
+#define RCC_USB2PHYxCFGR_USB2PHY1RST		BIT(0)
+#define RCC_USB2PHYxCFGR_USB2PHY1EN		BIT(1)
+#define RCC_USB2PHYxCFGR_USB2PHY1LPEN		BIT(2)
+#define RCC_USB2PHYxCFGR_USB2PHY1STPEN		BIT(4)
+#define RCC_USB2PHYxCFGR_USB2PHY1CKREFSEL	BIT(15)
+
+/* RCC_USB3DRDCFGR register fields */
+#define RCC_USB3DRDCFGR_USB3DRDRST		BIT(0)
+#define RCC_USB3DRDCFGR_USB3DRDEN		BIT(1)
+#define RCC_USB3DRDCFGR_USB3DRDLPEN		BIT(2)
+#define RCC_USB3DRDCFGR_USB3DRDSTPEN		BIT(4)
+
+/* RCC_USB3PCIEPHYCFGR register fields */
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYRST	BIT(0)
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYEN	BIT(1)
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYLPEN	BIT(2)
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYSTPEN	BIT(4)
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYCKREFSEL	BIT(15)
+
+/* RCC_PCIECFGR register fields */
+#define RCC_PCIECFGR_PCIERST			BIT(0)
+#define RCC_PCIECFGR_PCIEEN			BIT(1)
+#define RCC_PCIECFGR_PCIELPEN			BIT(2)
+#define RCC_PCIECFGR_PCIESTPEN			BIT(4)
+
+/* RCC_USBTCCFGR register fields */
+#define RCC_USBTCCFGR_USBTCRST			BIT(0)
+#define RCC_USBTCCFGR_USBTCEN			BIT(1)
+#define RCC_USBTCCFGR_USBTCLPEN			BIT(2)
+
+/* RCC_ETHSWCFGR register fields */
+#define RCC_ETHSWCFGR_ETHSWRST			BIT(0)
+#define RCC_ETHSWCFGR_ETHSWMACEN		BIT(1)
+#define RCC_ETHSWCFGR_ETHSWMACLPEN		BIT(2)
+#define RCC_ETHSWCFGR_ETHSWEN			BIT(5)
+#define RCC_ETHSWCFGR_ETHSWLPEN			BIT(6)
+#define RCC_ETHSWCFGR_ETHSWREFEN		BIT(21)
+#define RCC_ETHSWCFGR_ETHSWREFLPEN		BIT(22)
+
+/* RCC_ETHSWACMCFGR register fields */
+#define RCC_ETHSWACMCFGR_ETHSWACMEN		BIT(1)
+#define RCC_ETHSWACMCFGR_ETHSWACMLPEN		BIT(2)
+
+/* RCC_ETHSWACMMSGCFGR register fields */
+#define RCC_ETHSWACMMSGCFGR_ETHSWACMMSGEN	BIT(1)
+#define RCC_ETHSWACMMSGCFGR_ETHSWACMMSGLPEN	BIT(2)
+
+/* RCC_STGENCFGR register fields */
+#define RCC_STGENCFGR_STGENEN			BIT(1)
+#define RCC_STGENCFGR_STGENLPEN			BIT(2)
+#define RCC_STGENCFGR_STGENSTPEN		BIT(4)
+
+/* RCC_SDMMC1CFGR register fields */
+#define RCC_SDMMC1CFGR_SDMMC1RST		BIT(0)
+#define RCC_SDMMC1CFGR_SDMMC1EN			BIT(1)
+#define RCC_SDMMC1CFGR_SDMMC1LPEN		BIT(2)
+#define RCC_SDMMC1CFGR_SDMMC1DLLRST		BIT(16)
+
+/* RCC_SDMMC2CFGR register fields */
+#define RCC_SDMMC2CFGR_SDMMC2RST		BIT(0)
+#define RCC_SDMMC2CFGR_SDMMC2EN			BIT(1)
+#define RCC_SDMMC2CFGR_SDMMC2LPEN		BIT(2)
+#define RCC_SDMMC2CFGR_SDMMC2DLLRST		BIT(16)
+
+/* RCC_SDMMC3CFGR register fields */
+#define RCC_SDMMC3CFGR_SDMMC3RST		BIT(0)
+#define RCC_SDMMC3CFGR_SDMMC3EN			BIT(1)
+#define RCC_SDMMC3CFGR_SDMMC3LPEN		BIT(2)
+#define RCC_SDMMC3CFGR_SDMMC3DLLRST		BIT(16)
+
+/* RCC_SDMMCxCFGR register fields */
+#define RCC_SDMMCxCFGR_SDMMC1RST		BIT(0)
+#define RCC_SDMMCxCFGR_SDMMC1EN			BIT(1)
+#define RCC_SDMMCxCFGR_SDMMC1LPEN		BIT(2)
+#define RCC_SDMMCxCFGR_SDMMC1DLLRST		BIT(16)
+
+/* RCC_GPUCFGR register fields */
+#define RCC_GPUCFGR_GPURST			BIT(0)
+#define RCC_GPUCFGR_GPUEN			BIT(1)
+#define RCC_GPUCFGR_GPULPEN			BIT(2)
+
+/* RCC_LTDCCFGR register fields */
+#define RCC_LTDCCFGR_LTDCRST			BIT(0)
+#define RCC_LTDCCFGR_LTDCEN			BIT(1)
+#define RCC_LTDCCFGR_LTDCLPEN			BIT(2)
+
+/* RCC_DSICFGR register fields */
+#define RCC_DSICFGR_DSIRST			BIT(0)
+#define RCC_DSICFGR_DSIEN			BIT(1)
+#define RCC_DSICFGR_DSILPEN			BIT(2)
+#define RCC_DSICFGR_DSIBLSEL			BIT(12)
+#define RCC_DSICFGR_DSIPHYCKREFSEL		BIT(15)
+
+/* RCC_LVDSCFGR register fields */
+#define RCC_LVDSCFGR_LVDSRST			BIT(0)
+#define RCC_LVDSCFGR_LVDSEN			BIT(1)
+#define RCC_LVDSCFGR_LVDSLPEN			BIT(2)
+#define RCC_LVDSCFGR_LVDSPHYCKREFSEL		BIT(15)
+
+/* RCC_CSI2CFGR register fields */
+#define RCC_CSI2CFGR_CSI2RST			BIT(0)
+#define RCC_CSI2CFGR_CSI2EN			BIT(1)
+#define RCC_CSI2CFGR_CSI2LPEN			BIT(2)
+
+/* RCC_DCMIPPCFGR register fields */
+#define RCC_DCMIPPCFGR_DCMIPPRST		BIT(0)
+#define RCC_DCMIPPCFGR_DCMIPPEN			BIT(1)
+#define RCC_DCMIPPCFGR_DCMIPPLPEN		BIT(2)
+
+/* RCC_CCICFGR register fields */
+#define RCC_CCICFGR_CCIRST			BIT(0)
+#define RCC_CCICFGR_CCIEN			BIT(1)
+#define RCC_CCICFGR_CCILPEN			BIT(2)
+
+/* RCC_VDECCFGR register fields */
+#define RCC_VDECCFGR_VDECRST			BIT(0)
+#define RCC_VDECCFGR_VDECEN			BIT(1)
+#define RCC_VDECCFGR_VDECLPEN			BIT(2)
+
+/* RCC_VENCCFGR register fields */
+#define RCC_VENCCFGR_VENCRST			BIT(0)
+#define RCC_VENCCFGR_VENCEN			BIT(1)
+#define RCC_VENCCFGR_VENCLPEN			BIT(2)
+
+/* RCC_RNGCFGR register fields */
+#define RCC_RNGCFGR_RNGRST			BIT(0)
+#define RCC_RNGCFGR_RNGEN			BIT(1)
+#define RCC_RNGCFGR_RNGLPEN			BIT(2)
+
+/* RCC_PKACFGR register fields */
+#define RCC_PKACFGR_PKARST			BIT(0)
+#define RCC_PKACFGR_PKAEN			BIT(1)
+#define RCC_PKACFGR_PKALPEN			BIT(2)
+
+/* RCC_SAESCFGR register fields */
+#define RCC_SAESCFGR_SAESRST			BIT(0)
+#define RCC_SAESCFGR_SAESEN			BIT(1)
+#define RCC_SAESCFGR_SAESLPEN			BIT(2)
+
+/* RCC_HASHCFGR register fields */
+#define RCC_HASHCFGR_HASHRST			BIT(0)
+#define RCC_HASHCFGR_HASHEN			BIT(1)
+#define RCC_HASHCFGR_HASHLPEN			BIT(2)
+
+/* RCC_CRYP1CFGR register fields */
+#define RCC_CRYP1CFGR_CRYP1RST			BIT(0)
+#define RCC_CRYP1CFGR_CRYP1EN			BIT(1)
+#define RCC_CRYP1CFGR_CRYP1LPEN			BIT(2)
+
+/* RCC_CRYP2CFGR register fields */
+#define RCC_CRYP2CFGR_CRYP2RST			BIT(0)
+#define RCC_CRYP2CFGR_CRYP2EN			BIT(1)
+#define RCC_CRYP2CFGR_CRYP2LPEN			BIT(2)
+
+/* RCC_CRYPxCFGR register fields */
+#define RCC_CRYPxCFGR_CRYPxRST			BIT(0)
+#define RCC_CRYPxCFGR_CRYPxEN			BIT(1)
+#define RCC_CRYPxCFGR_CRYPxLPEN			BIT(2)
+
+/* RCC_IWDG1CFGR register fields */
+#define RCC_IWDG1CFGR_IWDG1EN			BIT(1)
+#define RCC_IWDG1CFGR_IWDG1LPEN			BIT(2)
+
+/* RCC_IWDG2CFGR register fields */
+#define RCC_IWDG2CFGR_IWDG2EN			BIT(1)
+#define RCC_IWDG2CFGR_IWDG2LPEN			BIT(2)
+
+/* RCC_IWDG3CFGR register fields */
+#define RCC_IWDG3CFGR_IWDG3EN			BIT(1)
+#define RCC_IWDG3CFGR_IWDG3LPEN			BIT(2)
+
+/* RCC_IWDG4CFGR register fields */
+#define RCC_IWDG4CFGR_IWDG4EN			BIT(1)
+#define RCC_IWDG4CFGR_IWDG4LPEN			BIT(2)
+
+/* RCC_IWDGxCFGR register fields */
+#define RCC_IWDGxCFGR_IWDGxEN			BIT(1)
+#define RCC_IWDGxCFGR_IWDGxLPEN			BIT(2)
+
+/* RCC_IWDG5CFGR register fields */
+#define RCC_IWDG5CFGR_IWDG5EN			BIT(1)
+#define RCC_IWDG5CFGR_IWDG5LPEN			BIT(2)
+#define RCC_IWDG5CFGR_IWDG5AMEN			BIT(3)
+
+/* RCC_WWDG1CFGR register fields */
+#define RCC_WWDG1CFGR_WWDG1RST			BIT(0)
+#define RCC_WWDG1CFGR_WWDG1EN			BIT(1)
+#define RCC_WWDG1CFGR_WWDG1LPEN			BIT(2)
+
+/* RCC_WWDG2CFGR register fields */
+#define RCC_WWDG2CFGR_WWDG2RST			BIT(0)
+#define RCC_WWDG2CFGR_WWDG2EN			BIT(1)
+#define RCC_WWDG2CFGR_WWDG2LPEN			BIT(2)
+#define RCC_WWDG2CFGR_WWDG2AMEN			BIT(3)
+
+/* RCC_BUSPERFMCFGR register fields */
+#define RCC_BUSPERFMCFGR_BUSPERFMRST		BIT(0)
+#define RCC_BUSPERFMCFGR_BUSPERFMEN		BIT(1)
+#define RCC_BUSPERFMCFGR_BUSPERFMLPEN		BIT(2)
+
+/* RCC_VREFCFGR register fields */
+#define RCC_VREFCFGR_VREFRST			BIT(0)
+#define RCC_VREFCFGR_VREFEN			BIT(1)
+#define RCC_VREFCFGR_VREFLPEN			BIT(2)
+
+/* RCC_TMPSENSCFGR register fields */
+#define RCC_TMPSENSCFGR_TMPSENSRST		BIT(0)
+#define RCC_TMPSENSCFGR_TMPSENSEN		BIT(1)
+#define RCC_TMPSENSCFGR_TMPSENSLPEN		BIT(2)
+#define RCC_TMPSENSCFGR_TMPSENSKERSEL_MASK	GENMASK(13, 12)
+#define RCC_TMPSENSCFGR_TMPSENSKERSEL_SHIFT	12
+
+/* RCC_CRCCFGR register fields */
+#define RCC_CRCCFGR_CRCRST			BIT(0)
+#define RCC_CRCCFGR_CRCEN			BIT(1)
+#define RCC_CRCCFGR_CRCLPEN			BIT(2)
+
+/* RCC_SERCCFGR register fields */
+#define RCC_SERCCFGR_SERCRST			BIT(0)
+#define RCC_SERCCFGR_SERCEN			BIT(1)
+#define RCC_SERCCFGR_SERCLPEN			BIT(2)
+
+/* RCC_OSPIIOMCFGR register fields */
+#define RCC_OSPIIOMCFGR_OSPIIOMRST		BIT(0)
+#define RCC_OSPIIOMCFGR_OSPIIOMEN		BIT(1)
+#define RCC_OSPIIOMCFGR_OSPIIOMLPEN		BIT(2)
+
+/* RCC_GICV2MCFGR register fields */
+#define RCC_GICV2MCFGR_GICV2MEN			BIT(1)
+#define RCC_GICV2MCFGR_GICV2MLPEN		BIT(2)
+
+/* RCC_I3C1CFGR register fields */
+#define RCC_I3C1CFGR_I3C1RST			BIT(0)
+#define RCC_I3C1CFGR_I3C1EN			BIT(1)
+#define RCC_I3C1CFGR_I3C1LPEN			BIT(2)
+
+/* RCC_I3C2CFGR register fields */
+#define RCC_I3C2CFGR_I3C2RST			BIT(0)
+#define RCC_I3C2CFGR_I3C2EN			BIT(1)
+#define RCC_I3C2CFGR_I3C2LPEN			BIT(2)
+
+/* RCC_I3C3CFGR register fields */
+#define RCC_I3C3CFGR_I3C3RST			BIT(0)
+#define RCC_I3C3CFGR_I3C3EN			BIT(1)
+#define RCC_I3C3CFGR_I3C3LPEN			BIT(2)
+
+/* RCC_I3C4CFGR register fields */
+#define RCC_I3C4CFGR_I3C4RST			BIT(0)
+#define RCC_I3C4CFGR_I3C4EN			BIT(1)
+#define RCC_I3C4CFGR_I3C4LPEN			BIT(2)
+#define RCC_I3C4CFGR_I3C4AMEN			BIT(3)
+
+/* RCC_I3CxCFGR register fields */
+#define RCC_I3CxCFGR_I3CxRST			BIT(0)
+#define RCC_I3CxCFGR_I3CxEN			BIT(1)
+#define RCC_I3CxCFGR_I3CxLPEN			BIT(2)
+#define RCC_I3CxCFGR_I3CxAMEN			BIT(3)
+
+/* RCC_MUXSELCFGR register fields */
+#define RCC_MUXSELCFGR_MUXSEL0_MASK		GENMASK(1, 0)
+#define RCC_MUXSELCFGR_MUXSEL0_SHIFT		0
+#define RCC_MUXSELCFGR_MUXSEL1_MASK		GENMASK(5, 4)
+#define RCC_MUXSELCFGR_MUXSEL1_SHIFT		4
+#define RCC_MUXSELCFGR_MUXSEL2_MASK		GENMASK(9, 8)
+#define RCC_MUXSELCFGR_MUXSEL2_SHIFT		8
+#define RCC_MUXSELCFGR_MUXSEL3_MASK		GENMASK(13, 12)
+#define RCC_MUXSELCFGR_MUXSEL3_SHIFT		12
+#define RCC_MUXSELCFGR_MUXSEL4_MASK		GENMASK(17, 16)
+#define RCC_MUXSELCFGR_MUXSEL4_SHIFT		16
+#define RCC_MUXSELCFGR_MUXSEL5_MASK		GENMASK(21, 20)
+#define RCC_MUXSELCFGR_MUXSEL5_SHIFT		20
+#define RCC_MUXSELCFGR_MUXSEL6_MASK		GENMASK(25, 24)
+#define RCC_MUXSELCFGR_MUXSEL6_SHIFT		24
+#define RCC_MUXSELCFGR_MUXSEL7_MASK		GENMASK(29, 28)
+#define RCC_MUXSELCFGR_MUXSEL7_SHIFT		28
+
+/* RCC_XBAR0CFGR register fields */
+#define RCC_XBAR0CFGR_XBAR0SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR0CFGR_XBAR0SEL_SHIFT		0
+#define RCC_XBAR0CFGR_XBAR0EN			BIT(6)
+#define RCC_XBAR0CFGR_XBAR0STS			BIT(7)
+
+/* RCC_XBAR1CFGR register fields */
+#define RCC_XBAR1CFGR_XBAR1SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR1CFGR_XBAR1SEL_SHIFT		0
+#define RCC_XBAR1CFGR_XBAR1EN			BIT(6)
+#define RCC_XBAR1CFGR_XBAR1STS			BIT(7)
+
+/* RCC_XBAR2CFGR register fields */
+#define RCC_XBAR2CFGR_XBAR2SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR2CFGR_XBAR2SEL_SHIFT		0
+#define RCC_XBAR2CFGR_XBAR2EN			BIT(6)
+#define RCC_XBAR2CFGR_XBAR2STS			BIT(7)
+
+/* RCC_XBAR3CFGR register fields */
+#define RCC_XBAR3CFGR_XBAR3SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR3CFGR_XBAR3SEL_SHIFT		0
+#define RCC_XBAR3CFGR_XBAR3EN			BIT(6)
+#define RCC_XBAR3CFGR_XBAR3STS			BIT(7)
+
+/* RCC_XBAR4CFGR register fields */
+#define RCC_XBAR4CFGR_XBAR4SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR4CFGR_XBAR4SEL_SHIFT		0
+#define RCC_XBAR4CFGR_XBAR4EN			BIT(6)
+#define RCC_XBAR4CFGR_XBAR4STS			BIT(7)
+
+/* RCC_XBAR5CFGR register fields */
+#define RCC_XBAR5CFGR_XBAR5SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR5CFGR_XBAR5SEL_SHIFT		0
+#define RCC_XBAR5CFGR_XBAR5EN			BIT(6)
+#define RCC_XBAR5CFGR_XBAR5STS			BIT(7)
+
+/* RCC_XBAR6CFGR register fields */
+#define RCC_XBAR6CFGR_XBAR6SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR6CFGR_XBAR6SEL_SHIFT		0
+#define RCC_XBAR6CFGR_XBAR6EN			BIT(6)
+#define RCC_XBAR6CFGR_XBAR6STS			BIT(7)
+
+/* RCC_XBAR7CFGR register fields */
+#define RCC_XBAR7CFGR_XBAR7SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR7CFGR_XBAR7SEL_SHIFT		0
+#define RCC_XBAR7CFGR_XBAR7EN			BIT(6)
+#define RCC_XBAR7CFGR_XBAR7STS			BIT(7)
+
+/* RCC_XBAR8CFGR register fields */
+#define RCC_XBAR8CFGR_XBAR8SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR8CFGR_XBAR8SEL_SHIFT		0
+#define RCC_XBAR8CFGR_XBAR8EN			BIT(6)
+#define RCC_XBAR8CFGR_XBAR8STS			BIT(7)
+
+/* RCC_XBAR9CFGR register fields */
+#define RCC_XBAR9CFGR_XBAR9SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR9CFGR_XBAR9SEL_SHIFT		0
+#define RCC_XBAR9CFGR_XBAR9EN			BIT(6)
+#define RCC_XBAR9CFGR_XBAR9STS			BIT(7)
+
+/* RCC_XBAR10CFGR register fields */
+#define RCC_XBAR10CFGR_XBAR10SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR10CFGR_XBAR10SEL_SHIFT		0
+#define RCC_XBAR10CFGR_XBAR10EN			BIT(6)
+#define RCC_XBAR10CFGR_XBAR10STS		BIT(7)
+
+/* RCC_XBAR11CFGR register fields */
+#define RCC_XBAR11CFGR_XBAR11SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR11CFGR_XBAR11SEL_SHIFT		0
+#define RCC_XBAR11CFGR_XBAR11EN			BIT(6)
+#define RCC_XBAR11CFGR_XBAR11STS		BIT(7)
+
+/* RCC_XBAR12CFGR register fields */
+#define RCC_XBAR12CFGR_XBAR12SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR12CFGR_XBAR12SEL_SHIFT		0
+#define RCC_XBAR12CFGR_XBAR12EN			BIT(6)
+#define RCC_XBAR12CFGR_XBAR12STS		BIT(7)
+
+/* RCC_XBAR13CFGR register fields */
+#define RCC_XBAR13CFGR_XBAR13SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR13CFGR_XBAR13SEL_SHIFT		0
+#define RCC_XBAR13CFGR_XBAR13EN			BIT(6)
+#define RCC_XBAR13CFGR_XBAR13STS		BIT(7)
+
+/* RCC_XBAR14CFGR register fields */
+#define RCC_XBAR14CFGR_XBAR14SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR14CFGR_XBAR14SEL_SHIFT		0
+#define RCC_XBAR14CFGR_XBAR14EN			BIT(6)
+#define RCC_XBAR14CFGR_XBAR14STS		BIT(7)
+
+/* RCC_XBAR15CFGR register fields */
+#define RCC_XBAR15CFGR_XBAR15SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR15CFGR_XBAR15SEL_SHIFT		0
+#define RCC_XBAR15CFGR_XBAR15EN			BIT(6)
+#define RCC_XBAR15CFGR_XBAR15STS		BIT(7)
+
+/* RCC_XBAR16CFGR register fields */
+#define RCC_XBAR16CFGR_XBAR16SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR16CFGR_XBAR16SEL_SHIFT		0
+#define RCC_XBAR16CFGR_XBAR16EN			BIT(6)
+#define RCC_XBAR16CFGR_XBAR16STS		BIT(7)
+
+/* RCC_XBAR17CFGR register fields */
+#define RCC_XBAR17CFGR_XBAR17SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR17CFGR_XBAR17SEL_SHIFT		0
+#define RCC_XBAR17CFGR_XBAR17EN			BIT(6)
+#define RCC_XBAR17CFGR_XBAR17STS		BIT(7)
+
+/* RCC_XBAR18CFGR register fields */
+#define RCC_XBAR18CFGR_XBAR18SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR18CFGR_XBAR18SEL_SHIFT		0
+#define RCC_XBAR18CFGR_XBAR18EN			BIT(6)
+#define RCC_XBAR18CFGR_XBAR18STS		BIT(7)
+
+/* RCC_XBAR19CFGR register fields */
+#define RCC_XBAR19CFGR_XBAR19SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR19CFGR_XBAR19SEL_SHIFT		0
+#define RCC_XBAR19CFGR_XBAR19EN			BIT(6)
+#define RCC_XBAR19CFGR_XBAR19STS		BIT(7)
+
+/* RCC_XBAR20CFGR register fields */
+#define RCC_XBAR20CFGR_XBAR20SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR20CFGR_XBAR20SEL_SHIFT		0
+#define RCC_XBAR20CFGR_XBAR20EN			BIT(6)
+#define RCC_XBAR20CFGR_XBAR20STS		BIT(7)
+
+/* RCC_XBAR21CFGR register fields */
+#define RCC_XBAR21CFGR_XBAR21SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR21CFGR_XBAR21SEL_SHIFT		0
+#define RCC_XBAR21CFGR_XBAR21EN			BIT(6)
+#define RCC_XBAR21CFGR_XBAR21STS		BIT(7)
+
+/* RCC_XBAR22CFGR register fields */
+#define RCC_XBAR22CFGR_XBAR22SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR22CFGR_XBAR22SEL_SHIFT		0
+#define RCC_XBAR22CFGR_XBAR22EN			BIT(6)
+#define RCC_XBAR22CFGR_XBAR22STS		BIT(7)
+
+/* RCC_XBAR23CFGR register fields */
+#define RCC_XBAR23CFGR_XBAR23SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR23CFGR_XBAR23SEL_SHIFT		0
+#define RCC_XBAR23CFGR_XBAR23EN			BIT(6)
+#define RCC_XBAR23CFGR_XBAR23STS		BIT(7)
+
+/* RCC_XBAR24CFGR register fields */
+#define RCC_XBAR24CFGR_XBAR24SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR24CFGR_XBAR24SEL_SHIFT		0
+#define RCC_XBAR24CFGR_XBAR24EN			BIT(6)
+#define RCC_XBAR24CFGR_XBAR24STS		BIT(7)
+
+/* RCC_XBAR25CFGR register fields */
+#define RCC_XBAR25CFGR_XBAR25SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR25CFGR_XBAR25SEL_SHIFT		0
+#define RCC_XBAR25CFGR_XBAR25EN			BIT(6)
+#define RCC_XBAR25CFGR_XBAR25STS		BIT(7)
+
+/* RCC_XBAR26CFGR register fields */
+#define RCC_XBAR26CFGR_XBAR26SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR26CFGR_XBAR26SEL_SHIFT		0
+#define RCC_XBAR26CFGR_XBAR26EN			BIT(6)
+#define RCC_XBAR26CFGR_XBAR26STS		BIT(7)
+
+/* RCC_XBAR27CFGR register fields */
+#define RCC_XBAR27CFGR_XBAR27SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR27CFGR_XBAR27SEL_SHIFT		0
+#define RCC_XBAR27CFGR_XBAR27EN			BIT(6)
+#define RCC_XBAR27CFGR_XBAR27STS		BIT(7)
+
+/* RCC_XBAR28CFGR register fields */
+#define RCC_XBAR28CFGR_XBAR28SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR28CFGR_XBAR28SEL_SHIFT		0
+#define RCC_XBAR28CFGR_XBAR28EN			BIT(6)
+#define RCC_XBAR28CFGR_XBAR28STS		BIT(7)
+
+/* RCC_XBAR29CFGR register fields */
+#define RCC_XBAR29CFGR_XBAR29SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR29CFGR_XBAR29SEL_SHIFT		0
+#define RCC_XBAR29CFGR_XBAR29EN			BIT(6)
+#define RCC_XBAR29CFGR_XBAR29STS		BIT(7)
+
+/* RCC_XBAR30CFGR register fields */
+#define RCC_XBAR30CFGR_XBAR30SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR30CFGR_XBAR30SEL_SHIFT		0
+#define RCC_XBAR30CFGR_XBAR30EN			BIT(6)
+#define RCC_XBAR30CFGR_XBAR30STS		BIT(7)
+
+/* RCC_XBAR31CFGR register fields */
+#define RCC_XBAR31CFGR_XBAR31SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR31CFGR_XBAR31SEL_SHIFT		0
+#define RCC_XBAR31CFGR_XBAR31EN			BIT(6)
+#define RCC_XBAR31CFGR_XBAR31STS		BIT(7)
+
+/* RCC_XBAR32CFGR register fields */
+#define RCC_XBAR32CFGR_XBAR32SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR32CFGR_XBAR32SEL_SHIFT		0
+#define RCC_XBAR32CFGR_XBAR32EN			BIT(6)
+#define RCC_XBAR32CFGR_XBAR32STS		BIT(7)
+
+/* RCC_XBAR33CFGR register fields */
+#define RCC_XBAR33CFGR_XBAR33SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR33CFGR_XBAR33SEL_SHIFT		0
+#define RCC_XBAR33CFGR_XBAR33EN			BIT(6)
+#define RCC_XBAR33CFGR_XBAR33STS		BIT(7)
+
+/* RCC_XBAR34CFGR register fields */
+#define RCC_XBAR34CFGR_XBAR34SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR34CFGR_XBAR34SEL_SHIFT		0
+#define RCC_XBAR34CFGR_XBAR34EN			BIT(6)
+#define RCC_XBAR34CFGR_XBAR34STS		BIT(7)
+
+/* RCC_XBAR35CFGR register fields */
+#define RCC_XBAR35CFGR_XBAR35SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR35CFGR_XBAR35SEL_SHIFT		0
+#define RCC_XBAR35CFGR_XBAR35EN			BIT(6)
+#define RCC_XBAR35CFGR_XBAR35STS		BIT(7)
+
+/* RCC_XBAR36CFGR register fields */
+#define RCC_XBAR36CFGR_XBAR36SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR36CFGR_XBAR36SEL_SHIFT		0
+#define RCC_XBAR36CFGR_XBAR36EN			BIT(6)
+#define RCC_XBAR36CFGR_XBAR36STS		BIT(7)
+
+/* RCC_XBAR37CFGR register fields */
+#define RCC_XBAR37CFGR_XBAR37SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR37CFGR_XBAR37SEL_SHIFT		0
+#define RCC_XBAR37CFGR_XBAR37EN			BIT(6)
+#define RCC_XBAR37CFGR_XBAR37STS		BIT(7)
+
+/* RCC_XBAR38CFGR register fields */
+#define RCC_XBAR38CFGR_XBAR38SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR38CFGR_XBAR38SEL_SHIFT		0
+#define RCC_XBAR38CFGR_XBAR38EN			BIT(6)
+#define RCC_XBAR38CFGR_XBAR38STS		BIT(7)
+
+/* RCC_XBAR39CFGR register fields */
+#define RCC_XBAR39CFGR_XBAR39SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR39CFGR_XBAR39SEL_SHIFT		0
+#define RCC_XBAR39CFGR_XBAR39EN			BIT(6)
+#define RCC_XBAR39CFGR_XBAR39STS		BIT(7)
+
+/* RCC_XBAR40CFGR register fields */
+#define RCC_XBAR40CFGR_XBAR40SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR40CFGR_XBAR40SEL_SHIFT		0
+#define RCC_XBAR40CFGR_XBAR40EN			BIT(6)
+#define RCC_XBAR40CFGR_XBAR40STS		BIT(7)
+
+/* RCC_XBAR41CFGR register fields */
+#define RCC_XBAR41CFGR_XBAR41SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR41CFGR_XBAR41SEL_SHIFT		0
+#define RCC_XBAR41CFGR_XBAR41EN			BIT(6)
+#define RCC_XBAR41CFGR_XBAR41STS		BIT(7)
+
+/* RCC_XBAR42CFGR register fields */
+#define RCC_XBAR42CFGR_XBAR42SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR42CFGR_XBAR42SEL_SHIFT		0
+#define RCC_XBAR42CFGR_XBAR42EN			BIT(6)
+#define RCC_XBAR42CFGR_XBAR42STS		BIT(7)
+
+/* RCC_XBAR43CFGR register fields */
+#define RCC_XBAR43CFGR_XBAR43SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR43CFGR_XBAR43SEL_SHIFT		0
+#define RCC_XBAR43CFGR_XBAR43EN			BIT(6)
+#define RCC_XBAR43CFGR_XBAR43STS		BIT(7)
+
+/* RCC_XBAR44CFGR register fields */
+#define RCC_XBAR44CFGR_XBAR44SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR44CFGR_XBAR44SEL_SHIFT		0
+#define RCC_XBAR44CFGR_XBAR44EN			BIT(6)
+#define RCC_XBAR44CFGR_XBAR44STS		BIT(7)
+
+/* RCC_XBAR45CFGR register fields */
+#define RCC_XBAR45CFGR_XBAR45SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR45CFGR_XBAR45SEL_SHIFT		0
+#define RCC_XBAR45CFGR_XBAR45EN			BIT(6)
+#define RCC_XBAR45CFGR_XBAR45STS		BIT(7)
+
+/* RCC_XBAR46CFGR register fields */
+#define RCC_XBAR46CFGR_XBAR46SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR46CFGR_XBAR46SEL_SHIFT		0
+#define RCC_XBAR46CFGR_XBAR46EN			BIT(6)
+#define RCC_XBAR46CFGR_XBAR46STS		BIT(7)
+
+/* RCC_XBAR47CFGR register fields */
+#define RCC_XBAR47CFGR_XBAR47SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR47CFGR_XBAR47SEL_SHIFT		0
+#define RCC_XBAR47CFGR_XBAR47EN			BIT(6)
+#define RCC_XBAR47CFGR_XBAR47STS		BIT(7)
+
+/* RCC_XBAR48CFGR register fields */
+#define RCC_XBAR48CFGR_XBAR48SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR48CFGR_XBAR48SEL_SHIFT		0
+#define RCC_XBAR48CFGR_XBAR48EN			BIT(6)
+#define RCC_XBAR48CFGR_XBAR48STS		BIT(7)
+
+/* RCC_XBAR49CFGR register fields */
+#define RCC_XBAR49CFGR_XBAR49SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR49CFGR_XBAR49SEL_SHIFT		0
+#define RCC_XBAR49CFGR_XBAR49EN			BIT(6)
+#define RCC_XBAR49CFGR_XBAR49STS		BIT(7)
+
+/* RCC_XBAR50CFGR register fields */
+#define RCC_XBAR50CFGR_XBAR50SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR50CFGR_XBAR50SEL_SHIFT		0
+#define RCC_XBAR50CFGR_XBAR50EN			BIT(6)
+#define RCC_XBAR50CFGR_XBAR50STS		BIT(7)
+
+/* RCC_XBAR51CFGR register fields */
+#define RCC_XBAR51CFGR_XBAR51SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR51CFGR_XBAR51SEL_SHIFT		0
+#define RCC_XBAR51CFGR_XBAR51EN			BIT(6)
+#define RCC_XBAR51CFGR_XBAR51STS		BIT(7)
+
+/* RCC_XBAR52CFGR register fields */
+#define RCC_XBAR52CFGR_XBAR52SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR52CFGR_XBAR52SEL_SHIFT		0
+#define RCC_XBAR52CFGR_XBAR52EN			BIT(6)
+#define RCC_XBAR52CFGR_XBAR52STS		BIT(7)
+
+/* RCC_XBAR53CFGR register fields */
+#define RCC_XBAR53CFGR_XBAR53SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR53CFGR_XBAR53SEL_SHIFT		0
+#define RCC_XBAR53CFGR_XBAR53EN			BIT(6)
+#define RCC_XBAR53CFGR_XBAR53STS		BIT(7)
+
+/* RCC_XBAR54CFGR register fields */
+#define RCC_XBAR54CFGR_XBAR54SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR54CFGR_XBAR54SEL_SHIFT		0
+#define RCC_XBAR54CFGR_XBAR54EN			BIT(6)
+#define RCC_XBAR54CFGR_XBAR54STS		BIT(7)
+
+/* RCC_XBAR55CFGR register fields */
+#define RCC_XBAR55CFGR_XBAR55SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR55CFGR_XBAR55SEL_SHIFT		0
+#define RCC_XBAR55CFGR_XBAR55EN			BIT(6)
+#define RCC_XBAR55CFGR_XBAR55STS		BIT(7)
+
+/* RCC_XBAR56CFGR register fields */
+#define RCC_XBAR56CFGR_XBAR56SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR56CFGR_XBAR56SEL_SHIFT		0
+#define RCC_XBAR56CFGR_XBAR56EN			BIT(6)
+#define RCC_XBAR56CFGR_XBAR56STS		BIT(7)
+
+/* RCC_XBAR57CFGR register fields */
+#define RCC_XBAR57CFGR_XBAR57SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR57CFGR_XBAR57SEL_SHIFT		0
+#define RCC_XBAR57CFGR_XBAR57EN			BIT(6)
+#define RCC_XBAR57CFGR_XBAR57STS		BIT(7)
+
+/* RCC_XBAR58CFGR register fields */
+#define RCC_XBAR58CFGR_XBAR58SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR58CFGR_XBAR58SEL_SHIFT		0
+#define RCC_XBAR58CFGR_XBAR58EN			BIT(6)
+#define RCC_XBAR58CFGR_XBAR58STS		BIT(7)
+
+/* RCC_XBAR59CFGR register fields */
+#define RCC_XBAR59CFGR_XBAR59SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR59CFGR_XBAR59SEL_SHIFT		0
+#define RCC_XBAR59CFGR_XBAR59EN			BIT(6)
+#define RCC_XBAR59CFGR_XBAR59STS		BIT(7)
+
+/* RCC_XBAR60CFGR register fields */
+#define RCC_XBAR60CFGR_XBAR60SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR60CFGR_XBAR60SEL_SHIFT		0
+#define RCC_XBAR60CFGR_XBAR60EN			BIT(6)
+#define RCC_XBAR60CFGR_XBAR60STS		BIT(7)
+
+/* RCC_XBAR61CFGR register fields */
+#define RCC_XBAR61CFGR_XBAR61SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR61CFGR_XBAR61SEL_SHIFT		0
+#define RCC_XBAR61CFGR_XBAR61EN			BIT(6)
+#define RCC_XBAR61CFGR_XBAR61STS		BIT(7)
+
+/* RCC_XBAR62CFGR register fields */
+#define RCC_XBAR62CFGR_XBAR62SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR62CFGR_XBAR62SEL_SHIFT		0
+#define RCC_XBAR62CFGR_XBAR62EN			BIT(6)
+#define RCC_XBAR62CFGR_XBAR62STS		BIT(7)
+
+/* RCC_XBAR63CFGR register fields */
+#define RCC_XBAR63CFGR_XBAR63SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR63CFGR_XBAR63SEL_SHIFT		0
+#define RCC_XBAR63CFGR_XBAR63EN			BIT(6)
+#define RCC_XBAR63CFGR_XBAR63STS		BIT(7)
+
+/* RCC_XBARxCFGR register fields */
+#define RCC_XBARxCFGR_XBARxSEL_MASK		GENMASK(3, 0)
+#define RCC_XBARxCFGR_XBARxSEL_SHIFT		0
+#define RCC_XBARxCFGR_XBARxEN			BIT(6)
+#define RCC_XBARxCFGR_XBARxSTS			BIT(7)
+
+/* RCC_PREDIV0CFGR register fields */
+#define RCC_PREDIV0CFGR_PREDIV0_MASK		GENMASK(9, 0)
+#define RCC_PREDIV0CFGR_PREDIV0_SHIFT		0
+
+/* RCC_PREDIV1CFGR register fields */
+#define RCC_PREDIV1CFGR_PREDIV1_MASK		GENMASK(9, 0)
+#define RCC_PREDIV1CFGR_PREDIV1_SHIFT		0
+
+/* RCC_PREDIV2CFGR register fields */
+#define RCC_PREDIV2CFGR_PREDIV2_MASK		GENMASK(9, 0)
+#define RCC_PREDIV2CFGR_PREDIV2_SHIFT		0
+
+/* RCC_PREDIV3CFGR register fields */
+#define RCC_PREDIV3CFGR_PREDIV3_MASK		GENMASK(9, 0)
+#define RCC_PREDIV3CFGR_PREDIV3_SHIFT		0
+
+/* RCC_PREDIV4CFGR register fields */
+#define RCC_PREDIV4CFGR_PREDIV4_MASK		GENMASK(9, 0)
+#define RCC_PREDIV4CFGR_PREDIV4_SHIFT		0
+
+/* RCC_PREDIV5CFGR register fields */
+#define RCC_PREDIV5CFGR_PREDIV5_MASK		GENMASK(9, 0)
+#define RCC_PREDIV5CFGR_PREDIV5_SHIFT		0
+
+/* RCC_PREDIV6CFGR register fields */
+#define RCC_PREDIV6CFGR_PREDIV6_MASK		GENMASK(9, 0)
+#define RCC_PREDIV6CFGR_PREDIV6_SHIFT		0
+
+/* RCC_PREDIV7CFGR register fields */
+#define RCC_PREDIV7CFGR_PREDIV7_MASK		GENMASK(9, 0)
+#define RCC_PREDIV7CFGR_PREDIV7_SHIFT		0
+
+/* RCC_PREDIV8CFGR register fields */
+#define RCC_PREDIV8CFGR_PREDIV8_MASK		GENMASK(9, 0)
+#define RCC_PREDIV8CFGR_PREDIV8_SHIFT		0
+
+/* RCC_PREDIV9CFGR register fields */
+#define RCC_PREDIV9CFGR_PREDIV9_MASK		GENMASK(9, 0)
+#define RCC_PREDIV9CFGR_PREDIV9_SHIFT		0
+
+/* RCC_PREDIV10CFGR register fields */
+#define RCC_PREDIV10CFGR_PREDIV10_MASK		GENMASK(9, 0)
+#define RCC_PREDIV10CFGR_PREDIV10_SHIFT		0
+
+/* RCC_PREDIV11CFGR register fields */
+#define RCC_PREDIV11CFGR_PREDIV11_MASK		GENMASK(9, 0)
+#define RCC_PREDIV11CFGR_PREDIV11_SHIFT		0
+
+/* RCC_PREDIV12CFGR register fields */
+#define RCC_PREDIV12CFGR_PREDIV12_MASK		GENMASK(9, 0)
+#define RCC_PREDIV12CFGR_PREDIV12_SHIFT		0
+
+/* RCC_PREDIV13CFGR register fields */
+#define RCC_PREDIV13CFGR_PREDIV13_MASK		GENMASK(9, 0)
+#define RCC_PREDIV13CFGR_PREDIV13_SHIFT		0
+
+/* RCC_PREDIV14CFGR register fields */
+#define RCC_PREDIV14CFGR_PREDIV14_MASK		GENMASK(9, 0)
+#define RCC_PREDIV14CFGR_PREDIV14_SHIFT		0
+
+/* RCC_PREDIV15CFGR register fields */
+#define RCC_PREDIV15CFGR_PREDIV15_MASK		GENMASK(9, 0)
+#define RCC_PREDIV15CFGR_PREDIV15_SHIFT		0
+
+/* RCC_PREDIV16CFGR register fields */
+#define RCC_PREDIV16CFGR_PREDIV16_MASK		GENMASK(9, 0)
+#define RCC_PREDIV16CFGR_PREDIV16_SHIFT		0
+
+/* RCC_PREDIV17CFGR register fields */
+#define RCC_PREDIV17CFGR_PREDIV17_MASK		GENMASK(9, 0)
+#define RCC_PREDIV17CFGR_PREDIV17_SHIFT		0
+
+/* RCC_PREDIV18CFGR register fields */
+#define RCC_PREDIV18CFGR_PREDIV18_MASK		GENMASK(9, 0)
+#define RCC_PREDIV18CFGR_PREDIV18_SHIFT		0
+
+/* RCC_PREDIV19CFGR register fields */
+#define RCC_PREDIV19CFGR_PREDIV19_MASK		GENMASK(9, 0)
+#define RCC_PREDIV19CFGR_PREDIV19_SHIFT		0
+
+/* RCC_PREDIV20CFGR register fields */
+#define RCC_PREDIV20CFGR_PREDIV20_MASK		GENMASK(9, 0)
+#define RCC_PREDIV20CFGR_PREDIV20_SHIFT		0
+
+/* RCC_PREDIV21CFGR register fields */
+#define RCC_PREDIV21CFGR_PREDIV21_MASK		GENMASK(9, 0)
+#define RCC_PREDIV21CFGR_PREDIV21_SHIFT		0
+
+/* RCC_PREDIV22CFGR register fields */
+#define RCC_PREDIV22CFGR_PREDIV22_MASK		GENMASK(9, 0)
+#define RCC_PREDIV22CFGR_PREDIV22_SHIFT		0
+
+/* RCC_PREDIV23CFGR register fields */
+#define RCC_PREDIV23CFGR_PREDIV23_MASK		GENMASK(9, 0)
+#define RCC_PREDIV23CFGR_PREDIV23_SHIFT		0
+
+/* RCC_PREDIV24CFGR register fields */
+#define RCC_PREDIV24CFGR_PREDIV24_MASK		GENMASK(9, 0)
+#define RCC_PREDIV24CFGR_PREDIV24_SHIFT		0
+
+/* RCC_PREDIV25CFGR register fields */
+#define RCC_PREDIV25CFGR_PREDIV25_MASK		GENMASK(9, 0)
+#define RCC_PREDIV25CFGR_PREDIV25_SHIFT		0
+
+/* RCC_PREDIV26CFGR register fields */
+#define RCC_PREDIV26CFGR_PREDIV26_MASK		GENMASK(9, 0)
+#define RCC_PREDIV26CFGR_PREDIV26_SHIFT		0
+
+/* RCC_PREDIV27CFGR register fields */
+#define RCC_PREDIV27CFGR_PREDIV27_MASK		GENMASK(9, 0)
+#define RCC_PREDIV27CFGR_PREDIV27_SHIFT		0
+
+/* RCC_PREDIV28CFGR register fields */
+#define RCC_PREDIV28CFGR_PREDIV28_MASK		GENMASK(9, 0)
+#define RCC_PREDIV28CFGR_PREDIV28_SHIFT		0
+
+/* RCC_PREDIV29CFGR register fields */
+#define RCC_PREDIV29CFGR_PREDIV29_MASK		GENMASK(9, 0)
+#define RCC_PREDIV29CFGR_PREDIV29_SHIFT		0
+
+/* RCC_PREDIV30CFGR register fields */
+#define RCC_PREDIV30CFGR_PREDIV30_MASK		GENMASK(9, 0)
+#define RCC_PREDIV30CFGR_PREDIV30_SHIFT		0
+
+/* RCC_PREDIV31CFGR register fields */
+#define RCC_PREDIV31CFGR_PREDIV31_MASK		GENMASK(9, 0)
+#define RCC_PREDIV31CFGR_PREDIV31_SHIFT		0
+
+/* RCC_PREDIV32CFGR register fields */
+#define RCC_PREDIV32CFGR_PREDIV32_MASK		GENMASK(9, 0)
+#define RCC_PREDIV32CFGR_PREDIV32_SHIFT		0
+
+/* RCC_PREDIV33CFGR register fields */
+#define RCC_PREDIV33CFGR_PREDIV33_MASK		GENMASK(9, 0)
+#define RCC_PREDIV33CFGR_PREDIV33_SHIFT		0
+
+/* RCC_PREDIV34CFGR register fields */
+#define RCC_PREDIV34CFGR_PREDIV34_MASK		GENMASK(9, 0)
+#define RCC_PREDIV34CFGR_PREDIV34_SHIFT		0
+
+/* RCC_PREDIV35CFGR register fields */
+#define RCC_PREDIV35CFGR_PREDIV35_MASK		GENMASK(9, 0)
+#define RCC_PREDIV35CFGR_PREDIV35_SHIFT		0
+
+/* RCC_PREDIV36CFGR register fields */
+#define RCC_PREDIV36CFGR_PREDIV36_MASK		GENMASK(9, 0)
+#define RCC_PREDIV36CFGR_PREDIV36_SHIFT		0
+
+/* RCC_PREDIV37CFGR register fields */
+#define RCC_PREDIV37CFGR_PREDIV37_MASK		GENMASK(9, 0)
+#define RCC_PREDIV37CFGR_PREDIV37_SHIFT		0
+
+/* RCC_PREDIV38CFGR register fields */
+#define RCC_PREDIV38CFGR_PREDIV38_MASK		GENMASK(9, 0)
+#define RCC_PREDIV38CFGR_PREDIV38_SHIFT		0
+
+/* RCC_PREDIV39CFGR register fields */
+#define RCC_PREDIV39CFGR_PREDIV39_MASK		GENMASK(9, 0)
+#define RCC_PREDIV39CFGR_PREDIV39_SHIFT		0
+
+/* RCC_PREDIV40CFGR register fields */
+#define RCC_PREDIV40CFGR_PREDIV40_MASK		GENMASK(9, 0)
+#define RCC_PREDIV40CFGR_PREDIV40_SHIFT		0
+
+/* RCC_PREDIV41CFGR register fields */
+#define RCC_PREDIV41CFGR_PREDIV41_MASK		GENMASK(9, 0)
+#define RCC_PREDIV41CFGR_PREDIV41_SHIFT		0
+
+/* RCC_PREDIV42CFGR register fields */
+#define RCC_PREDIV42CFGR_PREDIV42_MASK		GENMASK(9, 0)
+#define RCC_PREDIV42CFGR_PREDIV42_SHIFT		0
+
+/* RCC_PREDIV43CFGR register fields */
+#define RCC_PREDIV43CFGR_PREDIV43_MASK		GENMASK(9, 0)
+#define RCC_PREDIV43CFGR_PREDIV43_SHIFT		0
+
+/* RCC_PREDIV44CFGR register fields */
+#define RCC_PREDIV44CFGR_PREDIV44_MASK		GENMASK(9, 0)
+#define RCC_PREDIV44CFGR_PREDIV44_SHIFT		0
+
+/* RCC_PREDIV45CFGR register fields */
+#define RCC_PREDIV45CFGR_PREDIV45_MASK		GENMASK(9, 0)
+#define RCC_PREDIV45CFGR_PREDIV45_SHIFT		0
+
+/* RCC_PREDIV46CFGR register fields */
+#define RCC_PREDIV46CFGR_PREDIV46_MASK		GENMASK(9, 0)
+#define RCC_PREDIV46CFGR_PREDIV46_SHIFT		0
+
+/* RCC_PREDIV47CFGR register fields */
+#define RCC_PREDIV47CFGR_PREDIV47_MASK		GENMASK(9, 0)
+#define RCC_PREDIV47CFGR_PREDIV47_SHIFT		0
+
+/* RCC_PREDIV48CFGR register fields */
+#define RCC_PREDIV48CFGR_PREDIV48_MASK		GENMASK(9, 0)
+#define RCC_PREDIV48CFGR_PREDIV48_SHIFT		0
+
+/* RCC_PREDIV49CFGR register fields */
+#define RCC_PREDIV49CFGR_PREDIV49_MASK		GENMASK(9, 0)
+#define RCC_PREDIV49CFGR_PREDIV49_SHIFT		0
+
+/* RCC_PREDIV50CFGR register fields */
+#define RCC_PREDIV50CFGR_PREDIV50_MASK		GENMASK(9, 0)
+#define RCC_PREDIV50CFGR_PREDIV50_SHIFT		0
+
+/* RCC_PREDIV51CFGR register fields */
+#define RCC_PREDIV51CFGR_PREDIV51_MASK		GENMASK(9, 0)
+#define RCC_PREDIV51CFGR_PREDIV51_SHIFT		0
+
+/* RCC_PREDIV52CFGR register fields */
+#define RCC_PREDIV52CFGR_PREDIV52_MASK		GENMASK(9, 0)
+#define RCC_PREDIV52CFGR_PREDIV52_SHIFT		0
+
+/* RCC_PREDIV53CFGR register fields */
+#define RCC_PREDIV53CFGR_PREDIV53_MASK		GENMASK(9, 0)
+#define RCC_PREDIV53CFGR_PREDIV53_SHIFT		0
+
+/* RCC_PREDIV54CFGR register fields */
+#define RCC_PREDIV54CFGR_PREDIV54_MASK		GENMASK(9, 0)
+#define RCC_PREDIV54CFGR_PREDIV54_SHIFT		0
+
+/* RCC_PREDIV55CFGR register fields */
+#define RCC_PREDIV55CFGR_PREDIV55_MASK		GENMASK(9, 0)
+#define RCC_PREDIV55CFGR_PREDIV55_SHIFT		0
+
+/* RCC_PREDIV56CFGR register fields */
+#define RCC_PREDIV56CFGR_PREDIV56_MASK		GENMASK(9, 0)
+#define RCC_PREDIV56CFGR_PREDIV56_SHIFT		0
+
+/* RCC_PREDIV57CFGR register fields */
+#define RCC_PREDIV57CFGR_PREDIV57_MASK		GENMASK(9, 0)
+#define RCC_PREDIV57CFGR_PREDIV57_SHIFT		0
+
+/* RCC_PREDIV58CFGR register fields */
+#define RCC_PREDIV58CFGR_PREDIV58_MASK		GENMASK(9, 0)
+#define RCC_PREDIV58CFGR_PREDIV58_SHIFT		0
+
+/* RCC_PREDIV59CFGR register fields */
+#define RCC_PREDIV59CFGR_PREDIV59_MASK		GENMASK(9, 0)
+#define RCC_PREDIV59CFGR_PREDIV59_SHIFT		0
+
+/* RCC_PREDIV60CFGR register fields */
+#define RCC_PREDIV60CFGR_PREDIV60_MASK		GENMASK(9, 0)
+#define RCC_PREDIV60CFGR_PREDIV60_SHIFT		0
+
+/* RCC_PREDIV61CFGR register fields */
+#define RCC_PREDIV61CFGR_PREDIV61_MASK		GENMASK(9, 0)
+#define RCC_PREDIV61CFGR_PREDIV61_SHIFT		0
+
+/* RCC_PREDIV62CFGR register fields */
+#define RCC_PREDIV62CFGR_PREDIV62_MASK		GENMASK(9, 0)
+#define RCC_PREDIV62CFGR_PREDIV62_SHIFT		0
+
+/* RCC_PREDIV63CFGR register fields */
+#define RCC_PREDIV63CFGR_PREDIV63_MASK		GENMASK(9, 0)
+#define RCC_PREDIV63CFGR_PREDIV63_SHIFT		0
+
+/* RCC_PREDIVxCFGR register fields */
+#define RCC_PREDIVxCFGR_PREDIVx_MASK		GENMASK(9, 0)
+#define RCC_PREDIVxCFGR_PREDIVx_SHIFT		0
+
+/* RCC_FINDIV0CFGR register fields */
+#define RCC_FINDIV0CFGR_FINDIV0_MASK		GENMASK(5, 0)
+#define RCC_FINDIV0CFGR_FINDIV0_SHIFT		0
+#define RCC_FINDIV0CFGR_FINDIV0EN		BIT(6)
+
+/* RCC_FINDIV1CFGR register fields */
+#define RCC_FINDIV1CFGR_FINDIV1_MASK		GENMASK(5, 0)
+#define RCC_FINDIV1CFGR_FINDIV1_SHIFT		0
+#define RCC_FINDIV1CFGR_FINDIV1EN		BIT(6)
+
+/* RCC_FINDIV2CFGR register fields */
+#define RCC_FINDIV2CFGR_FINDIV2_MASK		GENMASK(5, 0)
+#define RCC_FINDIV2CFGR_FINDIV2_SHIFT		0
+#define RCC_FINDIV2CFGR_FINDIV2EN		BIT(6)
+
+/* RCC_FINDIV3CFGR register fields */
+#define RCC_FINDIV3CFGR_FINDIV3_MASK		GENMASK(5, 0)
+#define RCC_FINDIV3CFGR_FINDIV3_SHIFT		0
+#define RCC_FINDIV3CFGR_FINDIV3EN		BIT(6)
+
+/* RCC_FINDIV4CFGR register fields */
+#define RCC_FINDIV4CFGR_FINDIV4_MASK		GENMASK(5, 0)
+#define RCC_FINDIV4CFGR_FINDIV4_SHIFT		0
+#define RCC_FINDIV4CFGR_FINDIV4EN		BIT(6)
+
+/* RCC_FINDIV5CFGR register fields */
+#define RCC_FINDIV5CFGR_FINDIV5_MASK		GENMASK(5, 0)
+#define RCC_FINDIV5CFGR_FINDIV5_SHIFT		0
+#define RCC_FINDIV5CFGR_FINDIV5EN		BIT(6)
+
+/* RCC_FINDIV6CFGR register fields */
+#define RCC_FINDIV6CFGR_FINDIV6_MASK		GENMASK(5, 0)
+#define RCC_FINDIV6CFGR_FINDIV6_SHIFT		0
+#define RCC_FINDIV6CFGR_FINDIV6EN		BIT(6)
+
+/* RCC_FINDIV7CFGR register fields */
+#define RCC_FINDIV7CFGR_FINDIV7_MASK		GENMASK(5, 0)
+#define RCC_FINDIV7CFGR_FINDIV7_SHIFT		0
+#define RCC_FINDIV7CFGR_FINDIV7EN		BIT(6)
+
+/* RCC_FINDIV8CFGR register fields */
+#define RCC_FINDIV8CFGR_FINDIV8_MASK		GENMASK(5, 0)
+#define RCC_FINDIV8CFGR_FINDIV8_SHIFT		0
+#define RCC_FINDIV8CFGR_FINDIV8EN		BIT(6)
+
+/* RCC_FINDIV9CFGR register fields */
+#define RCC_FINDIV9CFGR_FINDIV9_MASK		GENMASK(5, 0)
+#define RCC_FINDIV9CFGR_FINDIV9_SHIFT		0
+#define RCC_FINDIV9CFGR_FINDIV9EN		BIT(6)
+
+/* RCC_FINDIV10CFGR register fields */
+#define RCC_FINDIV10CFGR_FINDIV10_MASK		GENMASK(5, 0)
+#define RCC_FINDIV10CFGR_FINDIV10_SHIFT		0
+#define RCC_FINDIV10CFGR_FINDIV10EN		BIT(6)
+
+/* RCC_FINDIV11CFGR register fields */
+#define RCC_FINDIV11CFGR_FINDIV11_MASK		GENMASK(5, 0)
+#define RCC_FINDIV11CFGR_FINDIV11_SHIFT		0
+#define RCC_FINDIV11CFGR_FINDIV11EN		BIT(6)
+
+/* RCC_FINDIV12CFGR register fields */
+#define RCC_FINDIV12CFGR_FINDIV12_MASK		GENMASK(5, 0)
+#define RCC_FINDIV12CFGR_FINDIV12_SHIFT		0
+#define RCC_FINDIV12CFGR_FINDIV12EN		BIT(6)
+
+/* RCC_FINDIV13CFGR register fields */
+#define RCC_FINDIV13CFGR_FINDIV13_MASK		GENMASK(5, 0)
+#define RCC_FINDIV13CFGR_FINDIV13_SHIFT		0
+#define RCC_FINDIV13CFGR_FINDIV13EN		BIT(6)
+
+/* RCC_FINDIV14CFGR register fields */
+#define RCC_FINDIV14CFGR_FINDIV14_MASK		GENMASK(5, 0)
+#define RCC_FINDIV14CFGR_FINDIV14_SHIFT		0
+#define RCC_FINDIV14CFGR_FINDIV14EN		BIT(6)
+
+/* RCC_FINDIV15CFGR register fields */
+#define RCC_FINDIV15CFGR_FINDIV15_MASK		GENMASK(5, 0)
+#define RCC_FINDIV15CFGR_FINDIV15_SHIFT		0
+#define RCC_FINDIV15CFGR_FINDIV15EN		BIT(6)
+
+/* RCC_FINDIV16CFGR register fields */
+#define RCC_FINDIV16CFGR_FINDIV16_MASK		GENMASK(5, 0)
+#define RCC_FINDIV16CFGR_FINDIV16_SHIFT		0
+#define RCC_FINDIV16CFGR_FINDIV16EN		BIT(6)
+
+/* RCC_FINDIV17CFGR register fields */
+#define RCC_FINDIV17CFGR_FINDIV17_MASK		GENMASK(5, 0)
+#define RCC_FINDIV17CFGR_FINDIV17_SHIFT		0
+#define RCC_FINDIV17CFGR_FINDIV17EN		BIT(6)
+
+/* RCC_FINDIV18CFGR register fields */
+#define RCC_FINDIV18CFGR_FINDIV18_MASK		GENMASK(5, 0)
+#define RCC_FINDIV18CFGR_FINDIV18_SHIFT		0
+#define RCC_FINDIV18CFGR_FINDIV18EN		BIT(6)
+
+/* RCC_FINDIV19CFGR register fields */
+#define RCC_FINDIV19CFGR_FINDIV19_MASK		GENMASK(5, 0)
+#define RCC_FINDIV19CFGR_FINDIV19_SHIFT		0
+#define RCC_FINDIV19CFGR_FINDIV19EN		BIT(6)
+
+/* RCC_FINDIV20CFGR register fields */
+#define RCC_FINDIV20CFGR_FINDIV20_MASK		GENMASK(5, 0)
+#define RCC_FINDIV20CFGR_FINDIV20_SHIFT		0
+#define RCC_FINDIV20CFGR_FINDIV20EN		BIT(6)
+
+/* RCC_FINDIV21CFGR register fields */
+#define RCC_FINDIV21CFGR_FINDIV21_MASK		GENMASK(5, 0)
+#define RCC_FINDIV21CFGR_FINDIV21_SHIFT		0
+#define RCC_FINDIV21CFGR_FINDIV21EN		BIT(6)
+
+/* RCC_FINDIV22CFGR register fields */
+#define RCC_FINDIV22CFGR_FINDIV22_MASK		GENMASK(5, 0)
+#define RCC_FINDIV22CFGR_FINDIV22_SHIFT		0
+#define RCC_FINDIV22CFGR_FINDIV22EN		BIT(6)
+
+/* RCC_FINDIV23CFGR register fields */
+#define RCC_FINDIV23CFGR_FINDIV23_MASK		GENMASK(5, 0)
+#define RCC_FINDIV23CFGR_FINDIV23_SHIFT		0
+#define RCC_FINDIV23CFGR_FINDIV23EN		BIT(6)
+
+/* RCC_FINDIV24CFGR register fields */
+#define RCC_FINDIV24CFGR_FINDIV24_MASK		GENMASK(5, 0)
+#define RCC_FINDIV24CFGR_FINDIV24_SHIFT		0
+#define RCC_FINDIV24CFGR_FINDIV24EN		BIT(6)
+
+/* RCC_FINDIV25CFGR register fields */
+#define RCC_FINDIV25CFGR_FINDIV25_MASK		GENMASK(5, 0)
+#define RCC_FINDIV25CFGR_FINDIV25_SHIFT		0
+#define RCC_FINDIV25CFGR_FINDIV25EN		BIT(6)
+
+/* RCC_FINDIV26CFGR register fields */
+#define RCC_FINDIV26CFGR_FINDIV26_MASK		GENMASK(5, 0)
+#define RCC_FINDIV26CFGR_FINDIV26_SHIFT		0
+#define RCC_FINDIV26CFGR_FINDIV26EN		BIT(6)
+
+/* RCC_FINDIV27CFGR register fields */
+#define RCC_FINDIV27CFGR_FINDIV27_MASK		GENMASK(5, 0)
+#define RCC_FINDIV27CFGR_FINDIV27_SHIFT		0
+#define RCC_FINDIV27CFGR_FINDIV27EN		BIT(6)
+
+/* RCC_FINDIV28CFGR register fields */
+#define RCC_FINDIV28CFGR_FINDIV28_MASK		GENMASK(5, 0)
+#define RCC_FINDIV28CFGR_FINDIV28_SHIFT		0
+#define RCC_FINDIV28CFGR_FINDIV28EN		BIT(6)
+
+/* RCC_FINDIV29CFGR register fields */
+#define RCC_FINDIV29CFGR_FINDIV29_MASK		GENMASK(5, 0)
+#define RCC_FINDIV29CFGR_FINDIV29_SHIFT		0
+#define RCC_FINDIV29CFGR_FINDIV29EN		BIT(6)
+
+/* RCC_FINDIV30CFGR register fields */
+#define RCC_FINDIV30CFGR_FINDIV30_MASK		GENMASK(5, 0)
+#define RCC_FINDIV30CFGR_FINDIV30_SHIFT		0
+#define RCC_FINDIV30CFGR_FINDIV30EN		BIT(6)
+
+/* RCC_FINDIV31CFGR register fields */
+#define RCC_FINDIV31CFGR_FINDIV31_MASK		GENMASK(5, 0)
+#define RCC_FINDIV31CFGR_FINDIV31_SHIFT		0
+#define RCC_FINDIV31CFGR_FINDIV31EN		BIT(6)
+
+/* RCC_FINDIV32CFGR register fields */
+#define RCC_FINDIV32CFGR_FINDIV32_MASK		GENMASK(5, 0)
+#define RCC_FINDIV32CFGR_FINDIV32_SHIFT		0
+#define RCC_FINDIV32CFGR_FINDIV32EN		BIT(6)
+
+/* RCC_FINDIV33CFGR register fields */
+#define RCC_FINDIV33CFGR_FINDIV33_MASK		GENMASK(5, 0)
+#define RCC_FINDIV33CFGR_FINDIV33_SHIFT		0
+#define RCC_FINDIV33CFGR_FINDIV33EN		BIT(6)
+
+/* RCC_FINDIV34CFGR register fields */
+#define RCC_FINDIV34CFGR_FINDIV34_MASK		GENMASK(5, 0)
+#define RCC_FINDIV34CFGR_FINDIV34_SHIFT		0
+#define RCC_FINDIV34CFGR_FINDIV34EN		BIT(6)
+
+/* RCC_FINDIV35CFGR register fields */
+#define RCC_FINDIV35CFGR_FINDIV35_MASK		GENMASK(5, 0)
+#define RCC_FINDIV35CFGR_FINDIV35_SHIFT		0
+#define RCC_FINDIV35CFGR_FINDIV35EN		BIT(6)
+
+/* RCC_FINDIV36CFGR register fields */
+#define RCC_FINDIV36CFGR_FINDIV36_MASK		GENMASK(5, 0)
+#define RCC_FINDIV36CFGR_FINDIV36_SHIFT		0
+#define RCC_FINDIV36CFGR_FINDIV36EN		BIT(6)
+
+/* RCC_FINDIV37CFGR register fields */
+#define RCC_FINDIV37CFGR_FINDIV37_MASK		GENMASK(5, 0)
+#define RCC_FINDIV37CFGR_FINDIV37_SHIFT		0
+#define RCC_FINDIV37CFGR_FINDIV37EN		BIT(6)
+
+/* RCC_FINDIV38CFGR register fields */
+#define RCC_FINDIV38CFGR_FINDIV38_MASK		GENMASK(5, 0)
+#define RCC_FINDIV38CFGR_FINDIV38_SHIFT		0
+#define RCC_FINDIV38CFGR_FINDIV38EN		BIT(6)
+
+/* RCC_FINDIV39CFGR register fields */
+#define RCC_FINDIV39CFGR_FINDIV39_MASK		GENMASK(5, 0)
+#define RCC_FINDIV39CFGR_FINDIV39_SHIFT		0
+#define RCC_FINDIV39CFGR_FINDIV39EN		BIT(6)
+
+/* RCC_FINDIV40CFGR register fields */
+#define RCC_FINDIV40CFGR_FINDIV40_MASK		GENMASK(5, 0)
+#define RCC_FINDIV40CFGR_FINDIV40_SHIFT		0
+#define RCC_FINDIV40CFGR_FINDIV40EN		BIT(6)
+
+/* RCC_FINDIV41CFGR register fields */
+#define RCC_FINDIV41CFGR_FINDIV41_MASK		GENMASK(5, 0)
+#define RCC_FINDIV41CFGR_FINDIV41_SHIFT		0
+#define RCC_FINDIV41CFGR_FINDIV41EN		BIT(6)
+
+/* RCC_FINDIV42CFGR register fields */
+#define RCC_FINDIV42CFGR_FINDIV42_MASK		GENMASK(5, 0)
+#define RCC_FINDIV42CFGR_FINDIV42_SHIFT		0
+#define RCC_FINDIV42CFGR_FINDIV42EN		BIT(6)
+
+/* RCC_FINDIV43CFGR register fields */
+#define RCC_FINDIV43CFGR_FINDIV43_MASK		GENMASK(5, 0)
+#define RCC_FINDIV43CFGR_FINDIV43_SHIFT		0
+#define RCC_FINDIV43CFGR_FINDIV43EN		BIT(6)
+
+/* RCC_FINDIV44CFGR register fields */
+#define RCC_FINDIV44CFGR_FINDIV44_MASK		GENMASK(5, 0)
+#define RCC_FINDIV44CFGR_FINDIV44_SHIFT		0
+#define RCC_FINDIV44CFGR_FINDIV44EN		BIT(6)
+
+/* RCC_FINDIV45CFGR register fields */
+#define RCC_FINDIV45CFGR_FINDIV45_MASK		GENMASK(5, 0)
+#define RCC_FINDIV45CFGR_FINDIV45_SHIFT		0
+#define RCC_FINDIV45CFGR_FINDIV45EN		BIT(6)
+
+/* RCC_FINDIV46CFGR register fields */
+#define RCC_FINDIV46CFGR_FINDIV46_MASK		GENMASK(5, 0)
+#define RCC_FINDIV46CFGR_FINDIV46_SHIFT		0
+#define RCC_FINDIV46CFGR_FINDIV46EN		BIT(6)
+
+/* RCC_FINDIV47CFGR register fields */
+#define RCC_FINDIV47CFGR_FINDIV47_MASK		GENMASK(5, 0)
+#define RCC_FINDIV47CFGR_FINDIV47_SHIFT		0
+#define RCC_FINDIV47CFGR_FINDIV47EN		BIT(6)
+
+/* RCC_FINDIV48CFGR register fields */
+#define RCC_FINDIV48CFGR_FINDIV48_MASK		GENMASK(5, 0)
+#define RCC_FINDIV48CFGR_FINDIV48_SHIFT		0
+#define RCC_FINDIV48CFGR_FINDIV48EN		BIT(6)
+
+/* RCC_FINDIV49CFGR register fields */
+#define RCC_FINDIV49CFGR_FINDIV49_MASK		GENMASK(5, 0)
+#define RCC_FINDIV49CFGR_FINDIV49_SHIFT		0
+#define RCC_FINDIV49CFGR_FINDIV49EN		BIT(6)
+
+/* RCC_FINDIV50CFGR register fields */
+#define RCC_FINDIV50CFGR_FINDIV50_MASK		GENMASK(5, 0)
+#define RCC_FINDIV50CFGR_FINDIV50_SHIFT		0
+#define RCC_FINDIV50CFGR_FINDIV50EN		BIT(6)
+
+/* RCC_FINDIV51CFGR register fields */
+#define RCC_FINDIV51CFGR_FINDIV51_MASK		GENMASK(5, 0)
+#define RCC_FINDIV51CFGR_FINDIV51_SHIFT		0
+#define RCC_FINDIV51CFGR_FINDIV51EN		BIT(6)
+
+/* RCC_FINDIV52CFGR register fields */
+#define RCC_FINDIV52CFGR_FINDIV52_MASK		GENMASK(5, 0)
+#define RCC_FINDIV52CFGR_FINDIV52_SHIFT		0
+#define RCC_FINDIV52CFGR_FINDIV52EN		BIT(6)
+
+/* RCC_FINDIV53CFGR register fields */
+#define RCC_FINDIV53CFGR_FINDIV53_MASK		GENMASK(5, 0)
+#define RCC_FINDIV53CFGR_FINDIV53_SHIFT		0
+#define RCC_FINDIV53CFGR_FINDIV53EN		BIT(6)
+
+/* RCC_FINDIV54CFGR register fields */
+#define RCC_FINDIV54CFGR_FINDIV54_MASK		GENMASK(5, 0)
+#define RCC_FINDIV54CFGR_FINDIV54_SHIFT		0
+#define RCC_FINDIV54CFGR_FINDIV54EN		BIT(6)
+
+/* RCC_FINDIV55CFGR register fields */
+#define RCC_FINDIV55CFGR_FINDIV55_MASK		GENMASK(5, 0)
+#define RCC_FINDIV55CFGR_FINDIV55_SHIFT		0
+#define RCC_FINDIV55CFGR_FINDIV55EN		BIT(6)
+
+/* RCC_FINDIV56CFGR register fields */
+#define RCC_FINDIV56CFGR_FINDIV56_MASK		GENMASK(5, 0)
+#define RCC_FINDIV56CFGR_FINDIV56_SHIFT		0
+#define RCC_FINDIV56CFGR_FINDIV56EN		BIT(6)
+
+/* RCC_FINDIV57CFGR register fields */
+#define RCC_FINDIV57CFGR_FINDIV57_MASK		GENMASK(5, 0)
+#define RCC_FINDIV57CFGR_FINDIV57_SHIFT		0
+#define RCC_FINDIV57CFGR_FINDIV57EN		BIT(6)
+
+/* RCC_FINDIV58CFGR register fields */
+#define RCC_FINDIV58CFGR_FINDIV58_MASK		GENMASK(5, 0)
+#define RCC_FINDIV58CFGR_FINDIV58_SHIFT		0
+#define RCC_FINDIV58CFGR_FINDIV58EN		BIT(6)
+
+/* RCC_FINDIV59CFGR register fields */
+#define RCC_FINDIV59CFGR_FINDIV59_MASK		GENMASK(5, 0)
+#define RCC_FINDIV59CFGR_FINDIV59_SHIFT		0
+#define RCC_FINDIV59CFGR_FINDIV59EN		BIT(6)
+
+/* RCC_FINDIV60CFGR register fields */
+#define RCC_FINDIV60CFGR_FINDIV60_MASK		GENMASK(5, 0)
+#define RCC_FINDIV60CFGR_FINDIV60_SHIFT		0
+#define RCC_FINDIV60CFGR_FINDIV60EN		BIT(6)
+
+/* RCC_FINDIV61CFGR register fields */
+#define RCC_FINDIV61CFGR_FINDIV61_MASK		GENMASK(5, 0)
+#define RCC_FINDIV61CFGR_FINDIV61_SHIFT		0
+#define RCC_FINDIV61CFGR_FINDIV61EN		BIT(6)
+
+/* RCC_FINDIV62CFGR register fields */
+#define RCC_FINDIV62CFGR_FINDIV62_MASK		GENMASK(5, 0)
+#define RCC_FINDIV62CFGR_FINDIV62_SHIFT		0
+#define RCC_FINDIV62CFGR_FINDIV62EN		BIT(6)
+
+/* RCC_FINDIV63CFGR register fields */
+#define RCC_FINDIV63CFGR_FINDIV63_MASK		GENMASK(5, 0)
+#define RCC_FINDIV63CFGR_FINDIV63_SHIFT		0
+#define RCC_FINDIV63CFGR_FINDIV63EN		BIT(6)
+
+/* RCC_FINDIVxCFGR register fields */
+#define RCC_FINDIVxCFGR_FINDIVx_MASK		GENMASK(5, 0)
+#define RCC_FINDIVxCFGR_FINDIVx_SHIFT		0
+#define RCC_FINDIVxCFGR_FINDIVxEN		BIT(6)
+
+/* RCC_FCALCOBS0CFGR register fields */
+#define RCC_FCALCOBS0CFGR_CKINTSEL_MASK		GENMASK(7, 0)
+#define RCC_FCALCOBS0CFGR_CKINTSEL_SHIFT	0
+#define RCC_FCALCOBS0CFGR_CKEXTSEL_MASK		GENMASK(10, 8)
+#define RCC_FCALCOBS0CFGR_CKEXTSEL_SHIFT	8
+#define RCC_FCALCOBS0CFGR_FCALCCKEXTSEL		BIT(15)
+#define RCC_FCALCOBS0CFGR_CKOBSEXTSEL		BIT(16)
+#define RCC_FCALCOBS0CFGR_FCALCCKINV		BIT(17)
+#define RCC_FCALCOBS0CFGR_CKOBSINV		BIT(18)
+#define RCC_FCALCOBS0CFGR_CKOBSDIV_MASK		GENMASK(24, 22)
+#define RCC_FCALCOBS0CFGR_CKOBSDIV_SHIFT	22
+#define RCC_FCALCOBS0CFGR_FCALCCKEN		BIT(25)
+#define RCC_FCALCOBS0CFGR_CKOBSEN		BIT(26)
+
+/* RCC_FCALCOBS1CFGR register fields */
+#define RCC_FCALCOBS1CFGR_CKINTSEL_MASK		GENMASK(7, 0)
+#define RCC_FCALCOBS1CFGR_CKINTSEL_SHIFT	0
+#define RCC_FCALCOBS1CFGR_CKEXTSEL_MASK		GENMASK(10, 8)
+#define RCC_FCALCOBS1CFGR_CKEXTSEL_SHIFT	8
+#define RCC_FCALCOBS1CFGR_CKOBSEXTSEL		BIT(16)
+#define RCC_FCALCOBS1CFGR_CKOBSINV		BIT(18)
+#define RCC_FCALCOBS1CFGR_CKOBSDIV_MASK		GENMASK(24, 22)
+#define RCC_FCALCOBS1CFGR_CKOBSDIV_SHIFT	22
+#define RCC_FCALCOBS1CFGR_CKOBSEN		BIT(26)
+#define RCC_FCALCOBS1CFGR_FCALCRSTN		BIT(27)
+
+/* RCC_FCALCREFCFGR register fields */
+#define RCC_FCALCREFCFGR_FCALCREFCKSEL_MASK	GENMASK(2, 0)
+#define RCC_FCALCREFCFGR_FCALCREFCKSEL_SHIFT	0
+
+/* RCC_FCALCCR1 register fields */
+#define RCC_FCALCCR1_FCALCRUN			BIT(0)
+
+/* RCC_FCALCCR2 register fields */
+#define RCC_FCALCCR2_FCALCMD_MASK		GENMASK(4, 3)
+#define RCC_FCALCCR2_FCALCMD_SHIFT		3
+#define RCC_FCALCCR2_FCALCTWC_MASK		GENMASK(14, 11)
+#define RCC_FCALCCR2_FCALCTWC_SHIFT		11
+#define RCC_FCALCCR2_FCALCTYP_MASK		GENMASK(21, 17)
+#define RCC_FCALCCR2_FCALCTYP_SHIFT		17
+
+/* RCC_FCALCSR register fields */
+#define RCC_FCALCSR_FVAL_MASK			GENMASK(16, 0)
+#define RCC_FCALCSR_FVAL_SHIFT			0
+#define RCC_FCALCSR_FCALCSTS			BIT(19)
+
+/* RCC_PLL4CFGR1 register fields */
+#define RCC_PLL4CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL4CFGR1_PLLEN			BIT(8)
+#define RCC_PLL4CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL4CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL4CFGR2 register fields */
+#define RCC_PLL4CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL4CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL4CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL4CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL4CFGR3 register fields */
+#define RCC_PLL4CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL4CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL4CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL4CFGR3_DACEN			BIT(25)
+#define RCC_PLL4CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL4CFGR4 register fields */
+#define RCC_PLL4CFGR4_DSMEN			BIT(8)
+#define RCC_PLL4CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL4CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL4CFGR5 register fields */
+#define RCC_PLL4CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL4CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL4CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL4CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL4CFGR6 register fields */
+#define RCC_PLL4CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL4CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL4CFGR7 register fields */
+#define RCC_PLL4CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL4CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL5CFGR1 register fields */
+#define RCC_PLL5CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL5CFGR1_PLLEN			BIT(8)
+#define RCC_PLL5CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL5CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL5CFGR2 register fields */
+#define RCC_PLL5CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL5CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL5CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL5CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL5CFGR3 register fields */
+#define RCC_PLL5CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL5CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL5CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL5CFGR3_DACEN			BIT(25)
+#define RCC_PLL5CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL5CFGR4 register fields */
+#define RCC_PLL5CFGR4_DSMEN			BIT(8)
+#define RCC_PLL5CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL5CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL5CFGR5 register fields */
+#define RCC_PLL5CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL5CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL5CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL5CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL5CFGR6 register fields */
+#define RCC_PLL5CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL5CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL5CFGR7 register fields */
+#define RCC_PLL5CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL5CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL6CFGR1 register fields */
+#define RCC_PLL6CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL6CFGR1_PLLEN			BIT(8)
+#define RCC_PLL6CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL6CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL6CFGR2 register fields */
+#define RCC_PLL6CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL6CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL6CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL6CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL6CFGR3 register fields */
+#define RCC_PLL6CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL6CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL6CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL6CFGR3_DACEN			BIT(25)
+#define RCC_PLL6CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL6CFGR4 register fields */
+#define RCC_PLL6CFGR4_DSMEN			BIT(8)
+#define RCC_PLL6CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL6CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL6CFGR5 register fields */
+#define RCC_PLL6CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL6CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL6CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL6CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL6CFGR6 register fields */
+#define RCC_PLL6CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL6CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL6CFGR7 register fields */
+#define RCC_PLL6CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL6CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL7CFGR1 register fields */
+#define RCC_PLL7CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL7CFGR1_PLLEN			BIT(8)
+#define RCC_PLL7CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL7CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL7CFGR2 register fields */
+#define RCC_PLL7CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL7CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL7CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL7CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL7CFGR3 register fields */
+#define RCC_PLL7CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL7CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL7CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL7CFGR3_DACEN			BIT(25)
+#define RCC_PLL7CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL7CFGR4 register fields */
+#define RCC_PLL7CFGR4_DSMEN			BIT(8)
+#define RCC_PLL7CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL7CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL7CFGR5 register fields */
+#define RCC_PLL7CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL7CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL7CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL7CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL7CFGR6 register fields */
+#define RCC_PLL7CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL7CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL7CFGR7 register fields */
+#define RCC_PLL7CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL7CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL8CFGR1 register fields */
+#define RCC_PLL8CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL8CFGR1_PLLEN			BIT(8)
+#define RCC_PLL8CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL8CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL8CFGR2 register fields */
+#define RCC_PLL8CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL8CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL8CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL8CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL8CFGR3 register fields */
+#define RCC_PLL8CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL8CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL8CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL8CFGR3_DACEN			BIT(25)
+#define RCC_PLL8CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL8CFGR4 register fields */
+#define RCC_PLL8CFGR4_DSMEN			BIT(8)
+#define RCC_PLL8CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL8CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL8CFGR5 register fields */
+#define RCC_PLL8CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL8CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL8CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL8CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL8CFGR6 register fields */
+#define RCC_PLL8CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL8CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL8CFGR7 register fields */
+#define RCC_PLL8CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL8CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLLxCFGR1 register fields */
+#define RCC_PLLxCFGR1_SSMODRST			BIT(0)
+#define RCC_PLLxCFGR1_PLLEN			BIT(8)
+#define RCC_PLLxCFGR1_PLLRDY			BIT(24)
+#define RCC_PLLxCFGR1_CKREFST			BIT(28)
+
+/* RCC_PLLxCFGR2 register fields */
+#define RCC_PLLxCFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLLxCFGR2_FREFDIV_SHIFT		0
+#define RCC_PLLxCFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLLxCFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLLxCFGR3 register fields */
+#define RCC_PLLxCFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLLxCFGR3_FRACIN_SHIFT		0
+#define RCC_PLLxCFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLLxCFGR3_DACEN			BIT(25)
+#define RCC_PLLxCFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLLxCFGR4 register fields */
+#define RCC_PLLxCFGR4_DSMEN			BIT(8)
+#define RCC_PLLxCFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLLxCFGR4_BYPASS			BIT(10)
+
+/* RCC_PLLxCFGR5 register fields */
+#define RCC_PLLxCFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLLxCFGR5_DIVVAL_SHIFT		0
+#define RCC_PLLxCFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLLxCFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLLxCFGR6 register fields */
+#define RCC_PLLxCFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLLxCFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLLxCFGR7 register fields */
+#define RCC_PLLxCFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLLxCFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_VERR register fields */
+#define RCC_VERR_MINREV_MASK			GENMASK(3, 0)
+#define RCC_VERR_MINREV_SHIFT			0
+#define RCC_VERR_MAJREV_MASK			GENMASK(7, 4)
+#define RCC_VERR_MAJREV_SHIFT			4
+
+#endif /* STM32MP2_RCC_H */
diff --git a/include/drivers/st/stm32mp2_risaf.h b/include/drivers/st/stm32mp2_risaf.h
new file mode 100644
index 000000000..ee8d88f88
--- /dev/null
+++ b/include/drivers/st/stm32mp2_risaf.h
@@ -0,0 +1,15 @@
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_RISAF_H
+#define STM32MP2_RISAF_H
+
+int stm32mp2_risaf_write_master_key(int instance, uint8_t *mkey);
+int stm32mp2_risaf_lock(int instance);
+int stm32mp2_risaf_is_locked(int instance, bool *state);
+int stm32mp2_risaf_init(void);
+
+#endif /* STM32MP2_RISAF_H */
diff --git a/include/drivers/st/stm32mp_clkfunc.h b/include/drivers/st/stm32mp_clkfunc.h
index c3329cc71..1af673706 100644
--- a/include/drivers/st/stm32mp_clkfunc.h
+++ b/include/drivers/st/stm32mp_clkfunc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2020, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2017-2021, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -14,17 +14,28 @@
 #include <platform_def.h>
 
 int fdt_osc_read_freq(const char *name, uint32_t *freq);
-bool fdt_osc_read_bool(enum stm32mp_osc_id osc_id, const char *prop_name);
-uint32_t fdt_osc_read_uint32_default(enum stm32mp_osc_id osc_id,
+bool fdt_clk_read_bool(const char *node_label, const char *prop_name);
+uint32_t fdt_clk_read_uint32_default(const char *node_label,
 				     const char *prop_name,
 				     uint32_t dflt_value);
 
 int fdt_rcc_read_uint32_array(const char *prop_name, uint32_t count,
 			      uint32_t *array);
+uint32_t fdt_rcc_read_uint32_default(const char *prop_name,
+				     uint32_t dflt_value);
 int fdt_rcc_subnode_offset(const char *name);
 const fdt32_t *fdt_rcc_read_prop(const char *prop_name, int *lenp);
-bool fdt_get_rcc_secure_status(void);
+bool fdt_get_rcc_secure_state(void);
+int fdt_rcc_enable_it(const char *name);
 
 int fdt_get_clock_id(int node);
+int fdt_get_clock_id_by_name(int node, const char *name);
+unsigned long fdt_get_uart_clock_freq(uintptr_t instance);
+
+void stm32mp_stgen_config(unsigned long rate);
+void stm32mp_stgen_restore_rate(void);
+void stm32mp_stgen_restore_counter(unsigned long long value,
+				   unsigned long long offset_in_ms);
+unsigned long long stm32mp_stgen_get_counter(void);
 
 #endif /* STM32MP_CLKFUNC_H */
diff --git a/include/drivers/st/stm32mp_ddr.h b/include/drivers/st/stm32mp_ddr.h
new file mode 100644
index 000000000..23ef80c89
--- /dev/null
+++ b/include/drivers/st/stm32mp_ddr.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ */
+
+#ifndef STM32MP_DDR_H
+#define STM32MP_DDR_H
+
+#include <platform_def.h>
+
+enum stm32mp_ddr_base_type {
+	DDR_BASE,
+	DDRPHY_BASE,
+	NONE_BASE
+};
+
+enum stm32mp_ddr_reg_type {
+	REG_REG,
+	REG_TIMING,
+	REG_PERF,
+	REG_MAP,
+	REGPHY_REG,
+	REGPHY_TIMING,
+	REG_TYPE_NB
+};
+
+struct stm32mp_ddr_reg_desc {
+	const char *name;
+	uint16_t offset;	/* Offset for base address */
+	uint8_t par_offset;	/* Offset for parameter array */
+};
+
+struct stm32mp_ddr_reg_info {
+	const char *name;
+	const struct stm32mp_ddr_reg_desc *desc;
+	uint8_t size;
+	enum stm32mp_ddr_base_type base;
+};
+
+struct stm32mp_ddr_size {
+	uint64_t base;
+	uint64_t size;
+};
+
+struct stm32mp_ddr_priv {
+	struct stm32mp_ddr_size info;
+	struct stm32mp_ddrctl *ctl;
+	struct stm32mp_ddrphy *phy;
+	uintptr_t pwr;
+	uintptr_t rcc;
+};
+
+struct stm32mp_ddr_info {
+	const char *name;
+	uint32_t speed; /* in kHZ */
+	uint32_t size;  /* Memory size in byte = col * row * width */
+};
+
+#define DDR_DELAY_1US		1U
+#define DDR_DELAY_2US		2U
+#define DDR_DELAY_10US		10U
+#define DDR_DELAY_50US		50U
+#define DDR_TIMEOUT_500US	500U
+#define DDR_TIMEOUT_US_1S	1000000U
+
+void stm32mp_ddr_set_reg(const struct stm32mp_ddr_priv *priv, enum stm32mp_ddr_reg_type type,
+			 const void *param, const struct stm32mp_ddr_reg_info *ddr_registers);
+void stm32mp_ddr_start_sw_done(struct stm32mp_ddrctl *ctl);
+void stm32mp_ddr_wait_sw_done_ack(struct stm32mp_ddrctl *ctl);
+void stm32mp_ddr_enable_axi_port(struct stm32mp_ddrctl *ctl);
+int stm32mp_ddr_disable_axi_port(struct stm32mp_ddrctl *ctl);
+void stm32mp_ddr_enable_host_interface(struct stm32mp_ddrctl *ctl);
+void stm32mp_ddr_disable_host_interface(struct stm32mp_ddrctl *ctl);
+int stm32mp_ddr_sw_selfref_entry(struct stm32mp_ddrctl *ctl);
+void stm32mp_ddr_sw_selfref_exit(struct stm32mp_ddrctl *ctl);
+void stm32mp_ddr_set_qd3_update_conditions(struct stm32mp_ddrctl *ctl);
+void stm32mp_ddr_unset_qd3_update_conditions(struct stm32mp_ddrctl *ctl);
+void stm32mp_ddr_wait_refresh_update_done_ack(struct stm32mp_ddrctl *ctl);
+int stm32mp_board_ddr_power_init(enum ddr_type ddr_type);
+
+#endif /* STM32MP_DDR_H */
diff --git a/include/drivers/st/stm32mp_ddr_test.h b/include/drivers/st/stm32mp_ddr_test.h
new file mode 100644
index 000000000..fe4c8c08e
--- /dev/null
+++ b/include/drivers/st/stm32mp_ddr_test.h
@@ -0,0 +1,15 @@
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP_DDR_TEST_H
+#define STM32MP_DDR_TEST_H
+
+uint32_t stm32mp_ddr_test_rw_access(void);
+uint32_t stm32mp_ddr_test_data_bus(void);
+uint32_t stm32mp_ddr_test_addr_bus(uint64_t size);
+uint32_t stm32mp_ddr_check_size(void);
+
+#endif /* STM32MP_DDR_TEST_H */
diff --git a/include/drivers/st/stm32mp_ddrctrl_regs.h b/include/drivers/st/stm32mp_ddrctrl_regs.h
new file mode 100644
index 000000000..053a68bf9
--- /dev/null
+++ b/include/drivers/st/stm32mp_ddrctrl_regs.h
@@ -0,0 +1,273 @@
+/*
+ * Copyright (c) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ */
+
+#ifndef STM32MP_DDRCTRL_REGS_H
+#define STM32MP_DDRCTRL_REGS_H
+
+#include <cdefs.h>
+#include <stdint.h>
+
+#include <lib/utils_def.h>
+
+/* DDR Controller (DDRCTRL) registers */
+struct stm32mp_ddrctl {
+	uint32_t mstr ;		/* 0x0 Master */
+	uint32_t stat;		/* 0x4 Operating Mode Status */
+	uint8_t reserved008[0x10 - 0x8];
+	uint32_t mrctrl0;	/* 0x10 Control 0 */
+	uint32_t mrctrl1;	/* 0x14 Control 1 */
+	uint32_t mrstat;	/* 0x18 Status */
+	uint32_t mrctrl2;	/* 0x1c Control 2 */
+	uint32_t derateen;	/* 0x20 Temperature Derate Enable */
+	uint32_t derateint;	/* 0x24 Temperature Derate Interval */
+	uint32_t reserved028;
+	uint32_t deratectl;	/* 0x2c Temperature Derate Control */
+	uint32_t pwrctl;	/* 0x30 Low Power Control */
+	uint32_t pwrtmg;	/* 0x34 Low Power Timing */
+	uint32_t hwlpctl;	/* 0x38 Hardware Low Power Control */
+	uint8_t reserved03c[0x50 - 0x3c];
+	uint32_t rfshctl0;	/* 0x50 Refresh Control 0 */
+	uint32_t rfshctl1;	/* 0x54 Refresh Control 1 */
+	uint32_t reserved058;	/* 0x58 Refresh Control 2 */
+	uint32_t reserved05C;
+	uint32_t rfshctl3;	/* 0x60 Refresh Control 0 */
+	uint32_t rfshtmg;	/* 0x64 Refresh Timing */
+	uint32_t rfshtmg1;	/* 0x68 Refresh Timing 1 */
+	uint8_t reserved06c[0xc0 - 0x6c];
+	uint32_t crcparctl0;	/* 0xc0 CRC Parity Control0 */
+	uint32_t crcparctl1;	/* 0xc4 CRC Parity Control1 */
+	uint32_t reserved0c8;	/* 0xc8 CRC Parity Control2 */
+	uint32_t crcparstat;	/* 0xcc CRC Parity Status */
+	uint32_t init0;		/* 0xd0 SDRAM Initialization 0 */
+	uint32_t init1;		/* 0xd4 SDRAM Initialization 1 */
+	uint32_t init2;		/* 0xd8 SDRAM Initialization 2 */
+	uint32_t init3;		/* 0xdc SDRAM Initialization 3 */
+	uint32_t init4;		/* 0xe0 SDRAM Initialization 4 */
+	uint32_t init5;		/* 0xe4 SDRAM Initialization 5 */
+	uint32_t init6;		/* 0xe8 SDRAM Initialization 6 */
+	uint32_t init7;		/* 0xec SDRAM Initialization 7 */
+	uint32_t dimmctl;	/* 0xf0 DIMM Control */
+	uint32_t rankctl;	/* 0xf4 Rank Control */
+	uint8_t reserved0f4[0x100 - 0xf8];
+	uint32_t dramtmg0;	/* 0x100 SDRAM Timing 0 */
+	uint32_t dramtmg1;	/* 0x104 SDRAM Timing 1 */
+	uint32_t dramtmg2;	/* 0x108 SDRAM Timing 2 */
+	uint32_t dramtmg3;	/* 0x10c SDRAM Timing 3 */
+	uint32_t dramtmg4;	/* 0x110 SDRAM Timing 4 */
+	uint32_t dramtmg5;	/* 0x114 SDRAM Timing 5 */
+	uint32_t dramtmg6;	/* 0x118 SDRAM Timing 6 */
+	uint32_t dramtmg7;	/* 0x11c SDRAM Timing 7 */
+	uint32_t dramtmg8;	/* 0x120 SDRAM Timing 8 */
+	uint32_t dramtmg9;	/* 0x124 SDRAM Timing 9 */
+	uint32_t dramtmg10;	/* 0x128 SDRAM Timing 10 */
+	uint32_t dramtmg11;	/* 0x12c SDRAM Timing 11 */
+	uint32_t dramtmg12;	/* 0x130 SDRAM Timing 12 */
+	uint32_t dramtmg13;	/* 0x134 SDRAM Timing 13 */
+	uint32_t dramtmg14;	/* 0x138 SDRAM Timing 14 */
+	uint32_t dramtmg15;	/* 0x13c SDRAM Timing 15 */
+	uint8_t reserved140[0x180 - 0x140];
+	uint32_t zqctl0;	/* 0x180 ZQ Control 0 */
+	uint32_t zqctl1;	/* 0x184 ZQ Control 1 */
+	uint32_t zqctl2;	/* 0x188 ZQ Control 2 */
+	uint32_t zqstat;	/* 0x18c ZQ Status */
+	uint32_t dfitmg0;	/* 0x190 DFI Timing 0 */
+	uint32_t dfitmg1;	/* 0x194 DFI Timing 1 */
+	uint32_t dfilpcfg0;	/* 0x198 DFI Low Power Configuration 0 */
+	uint32_t dfilpcfg1;	/* 0x19c DFI Low Power Configuration 1 */
+	uint32_t dfiupd0;	/* 0x1a0 DFI Update 0 */
+	uint32_t dfiupd1;	/* 0x1a4 DFI Update 1 */
+	uint32_t dfiupd2;	/* 0x1a8 DFI Update 2 */
+	uint32_t reserved1ac;
+	uint32_t dfimisc;	/* 0x1b0 DFI Miscellaneous Control */
+	uint32_t dfitmg2;	/* 0x1b4 DFI Timing 2 */
+	uint32_t dfitmg3;	/* 0x1b8 DFI Timing 3 */
+	uint32_t dfistat;	/* 0x1bc DFI Status */
+	uint32_t dbictl;	/* 0x1c0 DM/DBI Control */
+	uint32_t dfiphymstr;	/* 0x1c4 DFI PHY Master interface */
+	uint8_t reserved1c8[0x200 - 0x1c8];
+	uint32_t addrmap0;	/* 0x200 Address Map 0 */
+	uint32_t addrmap1;	/* 0x204 Address Map 1 */
+	uint32_t addrmap2;	/* 0x208 Address Map 2 */
+	uint32_t addrmap3;	/* 0x20c Address Map 3 */
+	uint32_t addrmap4;	/* 0x210 Address Map 4 */
+	uint32_t addrmap5;	/* 0x214 Address Map 5 */
+	uint32_t addrmap6;	/* 0x218 Address Map 6 */
+	uint32_t addrmap7;	/* 0x21c Address Map 7 */
+	uint32_t addrmap8;	/* 0x220 Address Map 8 */
+	uint32_t addrmap9;	/* 0x224 Address Map 9 */
+	uint32_t addrmap10;	/* 0x228 Address Map 10 */
+	uint32_t addrmap11;	/* 0x22C Address Map 11 */
+	uint8_t reserved230[0x240 - 0x230];
+	uint32_t odtcfg;	/* 0x240 ODT Configuration */
+	uint32_t odtmap;	/* 0x244 ODT/Rank Map */
+	uint8_t reserved248[0x250 - 0x248];
+	uint32_t sched;		/* 0x250 Scheduler Control */
+	uint32_t sched1;	/* 0x254 Scheduler Control 1 */
+	uint32_t reserved258;
+	uint32_t perfhpr1;	/* 0x25c High Priority Read CAM 1 */
+	uint32_t reserved260;
+	uint32_t perflpr1;	/* 0x264 Low Priority Read CAM 1 */
+	uint32_t reserved268;
+	uint32_t perfwr1;	/* 0x26c Write CAM 1 */
+	uint8_t reserved27c[0x300 - 0x270];
+	uint32_t dbg0;		/* 0x300 Debug 0 */
+	uint32_t dbg1;		/* 0x304 Debug 1 */
+	uint32_t dbgcam;	/* 0x308 CAM Debug */
+	uint32_t dbgcmd;	/* 0x30c Command Debug */
+	uint32_t dbgstat;	/* 0x310 Status Debug */
+	uint8_t reserved314[0x320 - 0x314];
+	uint32_t swctl;		/* 0x320 Software Programming Control Enable */
+	uint32_t swstat;	/* 0x324 Software Programming Control Status */
+	uint8_t reserved328[0x36c - 0x328];
+	uint32_t poisoncfg;	/* 0x36c AXI Poison Configuration Register */
+	uint32_t poisonstat;	/* 0x370 AXI Poison Status Register */
+	uint8_t reserved374[0x3f0 - 0x374];
+	uint32_t deratestat;	/* 0x3f0 Temperature Derate Status */
+	uint8_t reserved3f4[0x3fc - 0x3f4];
+
+	/* Multi Port registers */
+	uint32_t pstat;		/* 0x3fc Port Status */
+	uint32_t pccfg;		/* 0x400 Port Common Configuration */
+
+	/* PORT 0 */
+	uint32_t pcfgr_0;	/* 0x404 Configuration Read */
+	uint32_t pcfgw_0;	/* 0x408 Configuration Write */
+	uint8_t reserved40c[0x490 - 0x40c];
+	uint32_t pctrl_0;	/* 0x490 Port Control Register */
+	uint32_t pcfgqos0_0;	/* 0x494 Read QoS Configuration 0 */
+	uint32_t pcfgqos1_0;	/* 0x498 Read QoS Configuration 1 */
+	uint32_t pcfgwqos0_0;	/* 0x49c Write QoS Configuration 0 */
+	uint32_t pcfgwqos1_0;	/* 0x4a0 Write QoS Configuration 1 */
+	uint8_t reserved4a4[0x4b4 - 0x4a4];
+
+#if STM32MP_DDR_DUAL_AXI_PORT
+	/* PORT 1 */
+	uint32_t pcfgr_1;	/* 0x4b4 Configuration Read */
+	uint32_t pcfgw_1;	/* 0x4b8 Configuration Write */
+	uint8_t reserved4bc[0x540 - 0x4bc];
+	uint32_t pctrl_1;	/* 0x540 Port 2 Control Register */
+	uint32_t pcfgqos0_1;	/* 0x544 Read QoS Configuration 0 */
+	uint32_t pcfgqos1_1;	/* 0x548 Read QoS Configuration 1 */
+	uint32_t pcfgwqos0_1;	/* 0x54c Write QoS Configuration 0 */
+	uint32_t pcfgwqos1_1;	/* 0x550 Write QoS Configuration 1 */
+#endif
+
+	uint8_t reserved554[0xff0 - 0x554];
+	uint32_t umctl2_ver_number;	/* 0xff0 UMCTL2 Version Number */
+} __packed;
+
+/* DDR Controller registers offsets */
+#define DDRCTRL_MSTR				0x000
+#define DDRCTRL_STAT				0x004
+#define DDRCTRL_MRCTRL0				0x010
+#define DDRCTRL_MRSTAT				0x018
+#define DDRCTRL_PWRCTL				0x030
+#define DDRCTRL_PWRTMG				0x034
+#define DDRCTRL_HWLPCTL				0x038
+#define DDRCTRL_RFSHCTL3			0x060
+#define DDRCTRL_RFSHTMG				0x064
+#define DDRCTRL_INIT0				0x0D0
+#define DDRCTRL_DFIMISC				0x1B0
+#define DDRCTRL_DBG1				0x304
+#define DDRCTRL_DBGCAM				0x308
+#define DDRCTRL_DBGCMD				0x30C
+#define DDRCTRL_DBGSTAT				0x310
+#define DDRCTRL_SWCTL				0x320
+#define DDRCTRL_SWSTAT				0x324
+#define DDRCTRL_PSTAT				0x3FC
+#define DDRCTRL_PCTRL_0				0x490
+#if STM32MP_DDR_DUAL_AXI_PORT
+#define DDRCTRL_PCTRL_1				0x540
+#endif
+
+/* DDR Controller Register fields */
+#define DDRCTRL_MSTR_DDR3			BIT(0)
+#define DDRCTRL_MSTR_LPDDR2			BIT(2)
+#define DDRCTRL_MSTR_LPDDR3			BIT(3)
+#define DDRCTRL_MSTR_DDR4			BIT(4)
+#define DDRCTRL_MSTR_LPDDR4			BIT(5)
+#define DDRCTRL_MSTR_DATA_BUS_WIDTH_MASK	GENMASK(13, 12)
+#define DDRCTRL_MSTR_DATA_BUS_WIDTH_FULL	0
+#define DDRCTRL_MSTR_DATA_BUS_WIDTH_HALF	BIT(12)
+#define DDRCTRL_MSTR_DATA_BUS_WIDTH_QUARTER	BIT(13)
+#define DDRCTRL_MSTR_DLL_OFF_MODE		BIT(15)
+
+#define DDRCTRL_STAT_OPERATING_MODE_MASK	GENMASK(2, 0)
+#define DDRCTRL_STAT_OPERATING_MODE_NORMAL	BIT(0)
+#define DDRCTRL_STAT_OPERATING_MODE_SR		(BIT(0) | BIT(1))
+#define DDRCTRL_STAT_SELFREF_TYPE_MASK		GENMASK(5, 4)
+#define DDRCTRL_STAT_SELFREF_TYPE_ASR		(BIT(4) | BIT(5))
+#define DDRCTRL_STAT_SELFREF_TYPE_SR		BIT(5)
+
+#define DDRCTRL_MRCTRL0_MR_TYPE_WRITE		U(0)
+/* Only one rank supported */
+#define DDRCTRL_MRCTRL0_MR_RANK_SHIFT		4
+#define DDRCTRL_MRCTRL0_MR_RANK_ALL \
+					BIT(DDRCTRL_MRCTRL0_MR_RANK_SHIFT)
+#define DDRCTRL_MRCTRL0_MR_ADDR_SHIFT		12
+#define DDRCTRL_MRCTRL0_MR_ADDR_MASK		GENMASK(15, 12)
+#define DDRCTRL_MRCTRL0_MR_WR			BIT(31)
+
+#define DDRCTRL_MRSTAT_MR_WR_BUSY		BIT(0)
+
+#define DDRCTRL_PWRCTL_SELFREF_EN		BIT(0)
+#define DDRCTRL_PWRCTL_POWERDOWN_EN		BIT(1)
+#define DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE	BIT(3)
+#define DDRCTRL_PWRCTL_SELFREF_SW		BIT(5)
+
+#define DDRCTRL_PWRTMG_SELFREF_TO_X32_MASK	GENMASK(23, 16)
+#define DDRCTRL_PWRTMG_SELFREF_TO_X32_0		BIT(16)
+
+#define DDRCTRL_RFSHCTL3_DIS_AUTO_REFRESH	BIT(0)
+#define DDRCTRL_RFSHCTL3_REFRESH_UPDATE_LEVEL	BIT(1)
+
+#define DDRCTRL_HWLPCTL_HW_LP_EN		BIT(0)
+#define DDRCTRL_HWLPCTL_HW_LP_EXIT_IDLE_EN	BIT(1)
+#define DDRCTRL_HWLPCTL_HW_LP_IDLE_X32_MASK	GENMASK(27, 16)
+#define DDRCTRL_HWLPCTL_HW_LP_IDLE_X32_SHIFT	16
+
+#define DDRCTRL_RFSHTMG_T_RFC_NOM_X1_X32_MASK	GENMASK(27, 16)
+#define DDRCTRL_RFSHTMG_T_RFC_NOM_X1_X32_SHIFT	16
+
+#define DDRCTRL_INIT0_SKIP_DRAM_INIT_MASK	GENMASK(31, 30)
+#define DDRCTRL_INIT0_SKIP_DRAM_INIT_NORMAL	BIT(30)
+
+#define DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN	BIT(0)
+#define DDRCTRL_DFIMISC_DFI_INIT_START		BIT(5)
+
+#define DDRCTRL_DFISTAT_DFI_INIT_COMPLETE	BIT(0)
+
+#define DDRCTRL_DBG1_DIS_HIF			BIT(1)
+
+#define DDRCTRL_DBGCAM_WR_DATA_PIPELINE_EMPTY	BIT(29)
+#define DDRCTRL_DBGCAM_RD_DATA_PIPELINE_EMPTY	BIT(28)
+#define DDRCTRL_DBGCAM_DBG_WR_Q_EMPTY		BIT(26)
+#define DDRCTRL_DBGCAM_DBG_RD_Q_EMPTY		BIT(25)
+#define DDRCTRL_DBGCAM_DBG_LPR_Q_DEPTH		GENMASK(12, 8)
+#define DDRCTRL_DBGCAM_DBG_HPR_Q_DEPTH		GENMASK(4, 0)
+#define DDRCTRL_DBGCAM_DATA_PIPELINE_EMPTY \
+		(DDRCTRL_DBGCAM_WR_DATA_PIPELINE_EMPTY | \
+		 DDRCTRL_DBGCAM_RD_DATA_PIPELINE_EMPTY)
+#define DDRCTRL_DBG_Q_AND_DATA_PIPELINE_EMPTY \
+		(DDRCTRL_DBGCAM_DBG_WR_Q_EMPTY | \
+		 DDRCTRL_DBGCAM_DBG_RD_Q_EMPTY | \
+		 DDRCTRL_DBGCAM_DATA_PIPELINE_EMPTY)
+#define DDRCTRL_DBGCAM_DBG_Q_DEPTH \
+		(DDRCTRL_DBGCAM_DBG_WR_Q_EMPTY | \
+		 DDRCTRL_DBGCAM_DBG_LPR_Q_DEPTH | \
+		 DDRCTRL_DBGCAM_DBG_HPR_Q_DEPTH)
+
+#define DDRCTRL_DBGCMD_RANK0_REFRESH		BIT(0)
+
+#define DDRCTRL_DBGSTAT_RANK0_REFRESH_BUSY	BIT(0)
+
+#define DDRCTRL_SWCTL_SW_DONE			BIT(0)
+
+#define DDRCTRL_SWSTAT_SW_DONE_ACK		BIT(0)
+
+#define DDRCTRL_PCTRL_N_PORT_EN			BIT(0)
+
+#endif /* STM32MP_DDRCTRL_REGS_H */
diff --git a/include/drivers/st/stm32mp_pmic.h b/include/drivers/st/stm32mp_pmic.h
index 984cd6014..5059cb424 100644
--- a/include/drivers/st/stm32mp_pmic.h
+++ b/include/drivers/st/stm32mp_pmic.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2019, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2017-2022, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -19,14 +19,6 @@
  */
 int dt_pmic_status(void);
 
-/*
- * dt_pmic_configure_boot_on_regulators - Configure boot-on and always-on
- * regulators from device tree configuration
- *
- * Returns 0 on success, and negative values on errors
- */
-int dt_pmic_configure_boot_on_regulators(void);
-
 /*
  * initialize_pmic_i2c - Initialize I2C for the PMIC control
  *
@@ -41,6 +33,14 @@ bool initialize_pmic_i2c(void);
  */
 void initialize_pmic(void);
 
+#if DEBUG
+void print_pmic_info_and_debug(void);
+#else
+static inline void print_pmic_info_and_debug(void)
+{
+}
+#endif
+
 /*
  * pmic_ddr_power_init - Initialize regulators required for DDR
  *
@@ -48,4 +48,18 @@ void initialize_pmic(void);
  */
 int pmic_ddr_power_init(enum ddr_type ddr_type);
 
+/*
+ * pmic_voltages_init - Update voltages for platform init
+ *
+ * Returns 0 on success, and negative values on errors
+ */
+int pmic_voltages_init(void);
+
+/*
+ * pmic_switch_off - switch off the platform with PMIC
+ *
+ * Panics on errors
+ */
+void pmic_switch_off(void);
+
 #endif /* STM32MP_PMIC_H */
diff --git a/include/drivers/st/stm32mp_ram.h b/include/drivers/st/stm32mp_ram.h
new file mode 100644
index 000000000..43f0c2020
--- /dev/null
+++ b/include/drivers/st/stm32mp_ram.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#ifndef STM32MP_RAM_H
+#define STM32MP_RAM_H
+
+#include <stdbool.h>
+
+#include <drivers/st/stm32mp_ddr.h>
+
+#define PARAM(x, y)							\
+	{								\
+		.name = x,						\
+		.offset = offsetof(struct stm32mp_ddr_config, y),	\
+		.size = sizeof(config.y) / sizeof(uint32_t),		\
+	}
+
+#define CTL_PARAM(x) PARAM("st,ctl-"#x, c_##x)
+#define PHY_PARAM(x) PARAM("st,phy-"#x, p_##x)
+
+struct stm32mp_ddr_param {
+	const char *name;      /* Name in DT */
+	const uint32_t offset; /* Offset in config struct */
+	const uint32_t size;   /* Size of parameters */
+};
+
+int stm32mp_ddr_dt_get_info(void *fdt, int node, struct stm32mp_ddr_info *info);
+int stm32mp_ddr_dt_get_param(void *fdt, int node, const struct stm32mp_ddr_param *param,
+			     uint32_t param_size, uintptr_t config);
+
+#endif /* STM32MP_RAM_H */
diff --git a/include/drivers/st/stm32mp_reset.h b/include/drivers/st/stm32mp_reset.h
index 84448050d..8c43c0b5b 100644
--- a/include/drivers/st/stm32mp_reset.h
+++ b/include/drivers/st/stm32mp_reset.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2019, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2018-2020, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -47,4 +47,16 @@ static inline void stm32mp_reset_release(uint32_t reset_id)
 	(void)stm32mp_reset_deassert(reset_id, 0U);
 }
 
+/*
+ * Manage reset control for the MCU reset
+ *
+ * @assert_not_deassert: reset requested state
+ */
+void stm32mp_reset_assert_deassert_to_mcu(bool assert_not_deassert);
+
+/*
+ * Manage system reset control
+ */
+void __dead2 stm32mp_system_reset(void);
+
 #endif /* STM32MP_RESET_H */
diff --git a/include/drivers/st/stm32mp_rifsc_regs.h b/include/drivers/st/stm32mp_rifsc_regs.h
new file mode 100644
index 000000000..d8abfd1af
--- /dev/null
+++ b/include/drivers/st/stm32mp_rifsc_regs.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP_RIFSC_REGS_H
+#define STM32MP_RIFSC_REGS_H
+
+/* RIFSC offset register */
+#define _RIFSC_RISC_CR			U(0x0)
+#define _RIFSC_RISC_SECCFGR(id)		(U(0x10) + U(0x4) * ((id) / 32))
+#define _RIFSC_RISC_PRIVCFGR(id)	(U(0x30) + U(0x4) * ((id) / 32))
+#define _RIFSC_RISC_RCFGLOCKR(id)	(U(0x50) + U(0x4) * ((id) / 32))
+#define _RIFSC_RISC_PERy_CIDCFGR(id)	(U(0x100) + U(0x8) * (id))
+#define _RIFSC_RISC_PERy_SEMCR(id)	(U(0x104) + U(0x8) * (id))
+#define _RIFSC_RIMC_CR			U(0xC00)
+#define _RIFSC_RIMC_SR			U(0xC04)
+#define _RIFSC_RIMC_ATTR(x)		(U(0xC10) + U(0x4) * (x))
+#define _RIFSC_PPSR(x)			(U(0xFB0) + U(0x4) * (x))
+#define _RIFSC_HWCFGR3			U(0xFE8)
+#define _RIFSC_HWCFGR2			U(0xFEC)
+#define _RIFSC_HWCFGR1			U(0xFF0)
+#define _RIFSC_VERR			U(0xFF4)
+#define _RFISC_IPIDR			U(0xFF8)
+#define _RFISC_SIDR			U(0xFFC)
+
+/* RIFSC_RIMC_ATTRx register fields */
+#define RIFSC_RIMC_ATTRx_CIDSEL			BIT(2)
+#define RIFSC_RIMC_ATTRx_MCID_MASK		GENMASK(6, 4)
+#define RIFSC_RIMC_ATTRx_MCID_SHIFT		4
+#define RIFSC_RIMC_ATTRx_MSEC			BIT(8)
+#define RIFSC_RIMC_ATTRx_MPRIV			BIT(9)
+
+#endif /* STM32MP_RIFSC_REGS_H */
diff --git a/include/drivers/st/stm32mp_risab_regs.h b/include/drivers/st/stm32mp_risab_regs.h
new file mode 100644
index 000000000..c765c04e0
--- /dev/null
+++ b/include/drivers/st/stm32mp_risab_regs.h
@@ -0,0 +1,271 @@
+/*
+ * Copyright (C) 2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP_RISAB_REGS_H
+#define STM32MP_RISAB_REGS_H
+
+#define RISAB_CR				U(0x00)
+#define RISAB_IASR				U(0x08)
+#define RISAB_IACR				U(0x0C)
+#define RISAB_RIFLOCKR				U(0x10)
+#define RISAB_IAESR				U(0x20)
+#define RISAB_IADDR				U(0x24)
+#define RISAB_PG0_SECCFGR			U(0x100)
+#define RISAB_PG1_SECCFGR			U(0x104)
+#define RISAB_PG2_SECCFGR			U(0x108)
+#define RISAB_PG3_SECCFGR			U(0x10C)
+#define RISAB_PG4_SECCFGR			U(0x110)
+#define RISAB_PG5_SECCFGR			U(0x114)
+#define RISAB_PG6_SECCFGR			U(0x118)
+#define RISAB_PG7_SECCFGR			U(0x11C)
+#define RISAB_PG8_SECCFGR			U(0x120)
+#define RISAB_PG9_SECCFGR			U(0x124)
+#define RISAB_PG10_SECCFGR			U(0x128)
+#define RISAB_PG11_SECCFGR			U(0x12C)
+#define RISAB_PG12_SECCFGR			U(0x130)
+#define RISAB_PG13_SECCFGR			U(0x134)
+#define RISAB_PG14_SECCFGR			U(0x138)
+#define RISAB_PG15_SECCFGR			U(0x13C)
+#define RISAB_PG16_SECCFGR			U(0x140)
+#define RISAB_PG17_SECCFGR			U(0x144)
+#define RISAB_PG18_SECCFGR			U(0x148)
+#define RISAB_PG19_SECCFGR			U(0x14C)
+#define RISAB_PG20_SECCFGR			U(0x150)
+#define RISAB_PG21_SECCFGR			U(0x154)
+#define RISAB_PG22_SECCFGR			U(0x158)
+#define RISAB_PG23_SECCFGR			U(0x15C)
+#define RISAB_PG24_SECCFGR			U(0x160)
+#define RISAB_PG25_SECCFGR			U(0x164)
+#define RISAB_PG26_SECCFGR			U(0x168)
+#define RISAB_PG27_SECCFGR			U(0x16C)
+#define RISAB_PG28_SECCFGR			U(0x170)
+#define RISAB_PG29_SECCFGR			U(0x174)
+#define RISAB_PG30_SECCFGR			U(0x178)
+#define RISAB_PG31_SECCFGR			U(0x17C)
+#define RISAB_PG0_PRIVCFGR			U(0x200)
+#define RISAB_PG1_PRIVCFGR			U(0x204)
+#define RISAB_PG2_PRIVCFGR			U(0x208)
+#define RISAB_PG3_PRIVCFGR			U(0x20C)
+#define RISAB_PG4_PRIVCFGR			U(0x210)
+#define RISAB_PG5_PRIVCFGR			U(0x214)
+#define RISAB_PG6_PRIVCFGR			U(0x218)
+#define RISAB_PG7_PRIVCFGR			U(0x21C)
+#define RISAB_PG8_PRIVCFGR			U(0x220)
+#define RISAB_PG9_PRIVCFGR			U(0x224)
+#define RISAB_PG10_PRIVCFGR			U(0x228)
+#define RISAB_PG11_PRIVCFGR			U(0x22C)
+#define RISAB_PG12_PRIVCFGR			U(0x230)
+#define RISAB_PG13_PRIVCFGR			U(0x234)
+#define RISAB_PG14_PRIVCFGR			U(0x238)
+#define RISAB_PG15_PRIVCFGR			U(0x23C)
+#define RISAB_PG16_PRIVCFGR			U(0x240)
+#define RISAB_PG17_PRIVCFGR			U(0x244)
+#define RISAB_PG18_PRIVCFGR			U(0x248)
+#define RISAB_PG19_PRIVCFGR			U(0x24C)
+#define RISAB_PG20_PRIVCFGR			U(0x250)
+#define RISAB_PG21_PRIVCFGR			U(0x254)
+#define RISAB_PG22_PRIVCFGR			U(0x258)
+#define RISAB_PG23_PRIVCFGR			U(0x25C)
+#define RISAB_PG24_PRIVCFGR			U(0x260)
+#define RISAB_PG25_PRIVCFGR			U(0x264)
+#define RISAB_PG26_PRIVCFGR			U(0x268)
+#define RISAB_PG27_PRIVCFGR			U(0x26C)
+#define RISAB_PG28_PRIVCFGR			U(0x270)
+#define RISAB_PG29_PRIVCFGR			U(0x274)
+#define RISAB_PG30_PRIVCFGR			U(0x278)
+#define RISAB_PG31_PRIVCFGR			U(0x27C)
+#define RISAB_PG0_C2PRIVCFGR			U(0x600)
+#define RISAB_PG1_C2PRIVCFGR			U(0x604)
+#define RISAB_PG2_C2PRIVCFGR			U(0x608)
+#define RISAB_PG3_C2PRIVCFGR			U(0x60C)
+#define RISAB_PG4_C2PRIVCFGR			U(0x610)
+#define RISAB_PG5_C2PRIVCFGR			U(0x614)
+#define RISAB_PG6_C2PRIVCFGR			U(0x618)
+#define RISAB_PG7_C2PRIVCFGR			U(0x61C)
+#define RISAB_PG8_C2PRIVCFGR			U(0x620)
+#define RISAB_PG9_C2PRIVCFGR			U(0x624)
+#define RISAB_PG10_C2PRIVCFGR			U(0x628)
+#define RISAB_PG11_C2PRIVCFGR			U(0x62C)
+#define RISAB_PG12_C2PRIVCFGR			U(0x630)
+#define RISAB_PG13_C2PRIVCFGR			U(0x634)
+#define RISAB_PG14_C2PRIVCFGR			U(0x638)
+#define RISAB_PG15_C2PRIVCFGR			U(0x63C)
+#define RISAB_PG16_C2PRIVCFGR			U(0x640)
+#define RISAB_PG17_C2PRIVCFGR			U(0x644)
+#define RISAB_PG18_C2PRIVCFGR			U(0x648)
+#define RISAB_PG19_C2PRIVCFGR			U(0x64C)
+#define RISAB_PG20_C2PRIVCFGR			U(0x650)
+#define RISAB_PG21_C2PRIVCFGR			U(0x654)
+#define RISAB_PG22_C2PRIVCFGR			U(0x658)
+#define RISAB_PG23_C2PRIVCFGR			U(0x65C)
+#define RISAB_PG24_C2PRIVCFGR			U(0x660)
+#define RISAB_PG25_C2PRIVCFGR			U(0x664)
+#define RISAB_PG26_C2PRIVCFGR			U(0x668)
+#define RISAB_PG27_C2PRIVCFGR			U(0x66C)
+#define RISAB_PG28_C2PRIVCFGR			U(0x670)
+#define RISAB_PG29_C2PRIVCFGR			U(0x674)
+#define RISAB_PG30_C2PRIVCFGR			U(0x678)
+#define RISAB_PG31_C2PRIVCFGR			U(0x67C)
+#define RISAB_CID0PRIVCFGR			U(0x800)
+#define RISAB_CID0RDCFGR			U(0x808)
+#define RISAB_CID0WRCFGR			U(0x810)
+#define RISAB_CID1PRIVCFGR			U(0x820)
+#define RISAB_CID1RDCFGR			U(0x828)
+#define RISAB_CID1WRCFGR			U(0x830)
+#define RISAB_CID2PRIVCFGR			U(0x840)
+#define RISAB_CID2RDCFGR			U(0x848)
+#define RISAB_CID2WRCFGR			U(0x850)
+#define RISAB_CID3PRIVCFGR			U(0x860)
+#define RISAB_CID3RDCFGR			U(0x868)
+#define RISAB_CID3WRCFGR			U(0x870)
+#define RISAB_CID4PRIVCFGR			U(0x880)
+#define RISAB_CID4RDCFGR			U(0x888)
+#define RISAB_CID4WRCFGR			U(0x890)
+#define RISAB_CID5PRIVCFGR			U(0x8A0)
+#define RISAB_CID5RDCFGR			U(0x8A8)
+#define RISAB_CID5WRCFGR			U(0x8B0)
+#define RISAB_CID6PRIVCFGR			U(0x8C0)
+#define RISAB_CID6RDCFGR			U(0x8C8)
+#define RISAB_CID6WRCFGR			U(0x8D0)
+#define RISAB_PG0_CIDCFGR			U(0xA00)
+#define RISAB_PG1_CIDCFGR			U(0xA04)
+#define RISAB_PG2_CIDCFGR			U(0xA08)
+#define RISAB_PG3_CIDCFGR			U(0xA0C)
+#define RISAB_PG4_CIDCFGR			U(0xA10)
+#define RISAB_PG5_CIDCFGR			U(0xA14)
+#define RISAB_PG6_CIDCFGR			U(0xA18)
+#define RISAB_PG7_CIDCFGR			U(0xA1C)
+#define RISAB_PG8_CIDCFGR			U(0xA20)
+#define RISAB_PG9_CIDCFGR			U(0xA24)
+#define RISAB_PG10_CIDCFGR			U(0xA28)
+#define RISAB_PG11_CIDCFGR			U(0xA2C)
+#define RISAB_PG12_CIDCFGR			U(0xA30)
+#define RISAB_PG13_CIDCFGR			U(0xA34)
+#define RISAB_PG14_CIDCFGR			U(0xA38)
+#define RISAB_PG15_CIDCFGR			U(0xA3C)
+#define RISAB_PG16_CIDCFGR			U(0xA40)
+#define RISAB_PG17_CIDCFGR			U(0xA44)
+#define RISAB_PG18_CIDCFGR			U(0xA48)
+#define RISAB_PG19_CIDCFGR			U(0xA4C)
+#define RISAB_PG20_CIDCFGR			U(0xA50)
+#define RISAB_PG21_CIDCFGR			U(0xA54)
+#define RISAB_PG22_CIDCFGR			U(0xA58)
+#define RISAB_PG23_CIDCFGR			U(0xA5C)
+#define RISAB_PG24_CIDCFGR			U(0xA60)
+#define RISAB_PG25_CIDCFGR			U(0xA64)
+#define RISAB_PG26_CIDCFGR			U(0xA68)
+#define RISAB_PG27_CIDCFGR			U(0xA6C)
+#define RISAB_PG28_CIDCFGR			U(0xA70)
+#define RISAB_PG29_CIDCFGR			U(0xA74)
+#define RISAB_PG30_CIDCFGR			U(0xA78)
+#define RISAB_PG31_CIDCFGR			U(0xA7C)
+#define RISAB_HWCFGR3				U(0xFE8)
+#define RISAB_HWCFGR2				U(0xFEC)
+#define RISAB_HWCFGR1				U(0xFF0)
+#define RISAB_VERR				U(0xFF4)
+#define RISAB_IPIDR				U(0xFF8)
+#define RISAB_SIDR				U(0xFFC)
+
+/* RISAB_CR register fields */
+#define RISAB_CR_GLOCK				BIT(0)
+#define RISAB_CR_SRWIAD				BIT(31)
+
+/* RISAB_IASR register fields */
+#define RISAB_IASR_CAEF				BIT(0)
+#define RISAB_IASR_IAEF				BIT(1)
+
+/* RISAB_IACR register fields */
+#define RISAB_IACR_CAEF				BIT(0)
+#define RISAB_IACR_IAEF				BIT(1)
+
+/* RISAB_RIFLOCKR register fields */
+#define RISAB_RIFLOCKR_RLOCK0			BIT(0)
+#define RISAB_RIFLOCKR_RLOCK1			BIT(1)
+#define RISAB_RIFLOCKR_RLOCK2			BIT(2)
+#define RISAB_RIFLOCKR_RLOCK3			BIT(3)
+#define RISAB_RIFLOCKR_RLOCK4			BIT(4)
+#define RISAB_RIFLOCKR_RLOCK5			BIT(5)
+#define RISAB_RIFLOCKR_RLOCK6			BIT(6)
+#define RISAB_RIFLOCKR_RLOCK7			BIT(7)
+#define RISAB_RIFLOCKR_RLOCK8			BIT(8)
+#define RISAB_RIFLOCKR_RLOCK9			BIT(9)
+#define RISAB_RIFLOCKR_RLOCK10			BIT(10)
+#define RISAB_RIFLOCKR_RLOCK11			BIT(11)
+#define RISAB_RIFLOCKR_RLOCK12			BIT(12)
+#define RISAB_RIFLOCKR_RLOCK13			BIT(13)
+#define RISAB_RIFLOCKR_RLOCK14			BIT(14)
+#define RISAB_RIFLOCKR_RLOCK15			BIT(15)
+#define RISAB_RIFLOCKR_RLOCK16			BIT(16)
+#define RISAB_RIFLOCKR_RLOCK17			BIT(17)
+#define RISAB_RIFLOCKR_RLOCK18			BIT(18)
+#define RISAB_RIFLOCKR_RLOCK19			BIT(19)
+#define RISAB_RIFLOCKR_RLOCK20			BIT(20)
+#define RISAB_RIFLOCKR_RLOCK21			BIT(21)
+#define RISAB_RIFLOCKR_RLOCK22			BIT(22)
+#define RISAB_RIFLOCKR_RLOCK23			BIT(23)
+#define RISAB_RIFLOCKR_RLOCK24			BIT(24)
+#define RISAB_RIFLOCKR_RLOCK25			BIT(25)
+#define RISAB_RIFLOCKR_RLOCK26			BIT(26)
+#define RISAB_RIFLOCKR_RLOCK27			BIT(27)
+#define RISAB_RIFLOCKR_RLOCK28			BIT(28)
+#define RISAB_RIFLOCKR_RLOCK29			BIT(29)
+#define RISAB_RIFLOCKR_RLOCK30			BIT(30)
+#define RISAB_RIFLOCKR_RLOCK31			BIT(31)
+
+/* RISAB_IAESR register fields */
+#define RISAB_IAESR_IACID_MASK			GENMASK(2, 0)
+#define RISAB_IAESR_IACID_SHIFT			0
+#define RISAB_IAESR_IAPRIV			BIT(4)
+#define RISAB_IAESR_IASEC			BIT(5)
+#define RISAB_IAESR_IANRW			BIT(7)
+
+/* RISAB_PGx_SECCFGR register fields */
+#define RISAB_PGx_SECCFGR_SEC(_y)		BIT(_y)
+
+/* RISAB_PGx_PRIVCFGR register fields */
+#define RISAB_PGx_PRIVCFGR_PRIV(_y)		BIT(_y)
+
+/* RISAB_PGx_CmPRIVCFGR register fields */
+#define RISAB_PGx_CmPRIVCFGR_PRIV(_y)		BIT(_y)
+
+/* RISAB_CIDxPRIVCFGR register fields */
+#define RISAB_CIDxPRIVCFGR_PPRIV(_y)		BIT(_y)
+
+/* RISAB_CIDxRDCFGR register fields */
+#define RISAB_CIDxRDCFGR_PRDEN(_y)		BIT(_y)
+
+/* RISAB_CIDxWRCFGR register fields */
+#define RISAB_CIDxWRCFGR_PWREN(_y)		BIT(_y)
+
+/* RISAB_PGx_CIDCFGR register fields */
+#define RISAB_PGx_CIDCFGR_CFEN			BIT(0)
+#define RISAB_PGx_CIDCFGR_DCEN			BIT(2)
+#define RISAB_PGx_CIDCFGR_DCCID_MASK		GENMASK(6, 4)
+#define RISAB_PGx_CIDCFGR_DCCID_SHIFT		4
+
+/* RISAB_HWCFGR1 register fields */
+#define RISAB_HWCFGR1_CFG1_MASK			GENMASK(3, 0)
+#define RISAB_HWCFGR1_CFG1_SHIFT		0
+#define RISAB_HWCFGR1_CFG2_MASK			GENMASK(7, 4)
+#define RISAB_HWCFGR1_CFG2_SHIFT		4
+#define RISAB_HWCFGR1_CFG3_MASK			GENMASK(11, 8)
+#define RISAB_HWCFGR1_CFG3_SHIFT		8
+#define RISAB_HWCFGR1_CFG4_MASK			GENMASK(15, 12)
+#define RISAB_HWCFGR1_CFG4_SHIFT		12
+#define RISAB_HWCFGR1_CFG5_MASK			GENMASK(19, 16)
+#define RISAB_HWCFGR1_CFG5_SHIFT		16
+#define RISAB_HWCFGR1_CFG6_MASK			GENMASK(23, 20)
+#define RISAB_HWCFGR1_CFG6_SHIFT		20
+#define RISAB_HWCFGR1_CFG7_MASK			GENMASK(27, 24)
+#define RISAB_HWCFGR1_CFG7_SHIFT		24
+
+/* RISAB_VERR register fields */
+#define RISAB_VERR_MINREV_MASK			GENMASK(3, 0)
+#define RISAB_VERR_MINREV_SHIFT			0
+#define RISAB_VERR_MAJREV_MASK			GENMASK(7, 4)
+#define RISAB_VERR_MAJREV_SHIFT			4
+
+#endif /* STM32MP_RISAB_REGS_H */
diff --git a/include/drivers/st/stpmic1.h b/include/drivers/st/stpmic1.h
index dc096cd1a..193e673c7 100644
--- a/include/drivers/st/stpmic1.h
+++ b/include/drivers/st/stpmic1.h
@@ -103,6 +103,22 @@
 #define BUCK4_PULL_DOWN_SHIFT		6
 #define VREF_DDR_PULL_DOWN_SHIFT	4
 
+/* ICC register */
+#define BUCK1_ICC_SHIFT			0
+#define BUCK2_ICC_SHIFT			1
+#define BUCK3_ICC_SHIFT			2
+#define BUCK4_ICC_SHIFT			3
+#define PWR_SW1_ICC_SHIFT		4
+#define PWR_SW2_ICC_SHIFT		5
+#define BOOST_ICC_SHIFT			6
+
+#define LDO1_ICC_SHIFT			0
+#define LDO2_ICC_SHIFT			1
+#define LDO3_ICC_SHIFT			2
+#define LDO4_ICC_SHIFT			3
+#define LDO5_ICC_SHIFT			4
+#define LDO6_ICC_SHIFT			5
+
 /* Buck Mask reset register */
 #define BUCK1_MASK_RESET		0
 #define BUCK2_MASK_RESET		1
@@ -118,6 +134,10 @@
 #define LDO6_MASK_RESET			5
 #define VREF_DDR_MASK_RESET		6
 
+/* LDO3 Special modes */
+#define LDO3_BYPASS                     BIT(7)
+#define LDO3_DDR_SEL                    31U
+
 /* Main PMIC Control Register (MAIN_CONTROL_REG) */
 #define ICC_EVENT_ENABLED		BIT(4)
 #define PWRCTRL_POLARITY_HIGH		BIT(3)
@@ -145,9 +165,12 @@
 /* USB Control Register */
 #define BOOST_OVP_DISABLED		BIT(7)
 #define VBUS_OTG_DETECTION_DISABLED	BIT(6)
+#define SW_OUT_DISCHARGE		BIT(5)
+#define VBUS_OTG_DISCHARGE		BIT(4)
 #define OCP_LIMIT_HIGH			BIT(3)
 #define SWIN_SWOUT_ENABLED		BIT(2)
 #define USBSW_OTG_SWITCH_ENABLED	BIT(1)
+#define BOOST_ENABLED			BIT(0)
 
 int stpmic1_powerctrl_on(void);
 int stpmic1_switch_off(void);
@@ -156,11 +179,21 @@ int stpmic1_register_write(uint8_t register_id, uint8_t value);
 int stpmic1_register_update(uint8_t register_id, uint8_t value, uint8_t mask);
 int stpmic1_regulator_enable(const char *name);
 int stpmic1_regulator_disable(const char *name);
-uint8_t stpmic1_is_regulator_enabled(const char *name);
+bool stpmic1_is_regulator_enabled(const char *name);
 int stpmic1_regulator_voltage_set(const char *name, uint16_t millivolts);
+int stpmic1_regulator_levels_mv(const char *name, const uint16_t **levels,
+				size_t *levels_count);
 int stpmic1_regulator_voltage_get(const char *name);
 int stpmic1_regulator_pull_down_set(const char *name);
 int stpmic1_regulator_mask_reset_set(const char *name);
+int stpmic1_regulator_icc_set(const char *name);
+int stpmic1_regulator_sink_mode_set(const char *name);
+int stpmic1_regulator_bypass_mode_set(const char *name);
+int stpmic1_active_discharge_mode_set(const char *name);
+int stpmic1_lp_copy_reg(const char *name);
+int stpmic1_lp_reg_on_off(const char *name, uint8_t enable);
+int stpmic1_lp_set_mode(const char *name, uint8_t hplp);
+int stpmic1_lp_set_voltage(const char *name, uint16_t millivolts);
 void stpmic1_bind_i2c(struct i2c_handle_s *i2c_handle, uint16_t i2c_addr);
 
 int stpmic1_get_version(unsigned long *version);
diff --git a/include/drivers/st/usb_dwc3.h b/include/drivers/st/usb_dwc3.h
new file mode 100644
index 000000000..824c497fb
--- /dev/null
+++ b/include/drivers/st/usb_dwc3.h
@@ -0,0 +1,244 @@
+/*
+ * Copyright (c) 2015-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __USB_DWC3_H
+#define __USB_DWC3_H
+
+#include <drivers/usb_device.h>
+#include <platform_def.h>
+
+/* define value use in register */
+
+#define USB3_HS_MAX_PACKET_SIZE     512U
+#define USB3_FS_MAX_PACKET_SIZE     64U
+#ifdef USE_USB_FS
+#define USB3_MAX_PACKET_SIZE        USB3_FS_MAX_PACKET_SIZE
+#else
+#define USB3_MAX_PACKET_SIZE        USB3_HS_MAX_PACKET_SIZE
+#endif
+#define USB_SETUP_PACKET_SIZE       12U
+
+/* USB_DWC3_EPTypeDef->trb_flag */
+#define USB_DWC3_TRBCTL_NORMAL            1
+#define USB_DWC3_TRBCTL_CONTROL_SETUP     2
+#define USB_DWC3_TRBCTL_CONTROL_STATUS2   3
+#define USB_DWC3_TRBCTL_CONTROL_STATUS3   4
+#define USB_DWC3_TRBCTL_CONTROL_DATA      5
+#define USB_DWC3_TRBCTL_ISOCHRONOUS_FIRST 6
+#define USB_DWC3_TRBCTL_ISOCHRONOUS       7
+#define USB_DWC3_TRBCTL_LINK_TRB          8
+#define USB_DWC3_TRBCTL_MASK              0x3fUL
+
+/* USB_DWC3_EPTypeDef->flags */
+#define USB_DWC3_EP_REQ_QUEUED          BIT(0)
+#define USB_DWC3_EP_ISOC_START_PENDING  BIT(1)
+#define USB_DWC3_EP_ISOC_STARTED        BIT(2)
+
+/*
+ * DWC3 Specific Configurable macros
+ */
+#define USB_DWC3_INT_INUSE          1U
+#define USB_DWC3_EVENT_BUFFER_SIZE  2048U
+#define USB_DWC3_NUM_IN_EP          USBD_EP_NB
+#define USB_DWC3_NUM_OUT_EP         USBD_EP_NB
+
+typedef struct {
+	uint32_t dcfg;             /* @ offset 0x0 */
+	uint32_t dctl;             /* @ offset 0x4 */
+	uint32_t devten;           /* @ offset 0x8 */
+	uint32_t dsts;             /* @ offset 0xc */
+	uint32_t dgcmdpar;         /* @ offset 0x10 */
+	uint32_t dgcmd;            /* @ offset 0x14 */
+	uint32_t reserved_18[2];   /* Reserved @ offset 0x18 */
+	uint32_t dalepena;         /* @ offset 0x20 */
+	uint32_t reserved_24;      /* @ offset 0x24 */
+	uint32_t reserved_28[54];  /* Reserved @ offset 0x28 */
+	uint32_t depcmdpar2;       /* @ offset 0x100 */
+	uint32_t depcmdpar1;       /* @ offset 0x104 */
+	uint32_t depcmdpar0;       /* @ offset 0x108 */
+	uint32_t depcmd;           /* @ offset 0x10c */
+	uint32_t reserved_110[124];/* Reserved @ offset 0x110 */
+	uint32_t dev_imod;         /* @ offset 0x300 */
+	uint32_t reserved_304[0xfc / 4]; /* Reserved @ offset 0x304 */
+} usb_dwc3_device_t;
+
+typedef struct {
+	uint32_t gsbuscfg0;         /* @ offset 0x0 */
+	uint32_t gsbuscfg1;         /* @ offset 0x4 */
+	uint32_t gtxthrcfg;         /* @ offset 0x8 */
+	uint32_t grxthrcfg;         /* @ offset 0xc */
+	uint32_t gctl;              /* @ offset 0x10 */
+	uint32_t gpmsts;            /* @ offset 0x14 */
+	uint32_t gsts;              /* @ offset 0x18 */
+	uint32_t guctl1;            /* @ offset 0x1c */
+	uint32_t gsnpsid;           /* @ offset 0x20 */
+	uint32_t ggpio;             /* @ offset 0x24 */
+	uint32_t guid;              /* @ offset 0x28 */
+	uint32_t guctl;             /* @ offset 0x2c */
+	uint32_t gbuserraddrlo;     /* @ offset 0x30 */
+	uint32_t gbuserraddrhi;     /* @ offset 0x34 */
+	uint32_t gprtbimaplo;       /* @ offset 0x38 */
+	uint32_t gprtbimaphi;       /* @ offset 0x3c */
+	uint32_t ghwparams0;        /* @ offset 0x40 */
+	uint32_t ghwparams1;        /* @ offset 0x44 */
+	uint32_t ghwparams2;        /* @ offset 0x48 */
+	uint32_t ghwparams3;        /* @ offset 0x4c */
+	uint32_t ghwparams4;        /* @ offset 0x50 */
+	uint32_t ghwparams5;        /* @ offset 0x54 */
+	uint32_t ghwparams6;        /* @ offset 0x58 */
+	uint32_t ghwparams7;        /* @ offset 0x5c */
+	uint32_t gdbgfifospace;     /* @ offset 0x60 */
+	uint32_t gdbgltssm;         /* @ offset 0x64 */
+	uint32_t gdbglnmcc;         /* @ offset 0x68 */
+	uint32_t gdbgbmu;           /* @ offset 0x6c */
+	uint32_t gdbglspmux_hst;    /* @ offset 0x70 */
+	uint32_t gdbglsp;           /* @ offset 0x74 */
+	uint32_t gdbgepinfo0;       /* @ offset 0x78 */
+	uint32_t gdbgepinfo1;       /* @ offset 0x7c */
+	uint32_t gprtbimap_hslo;    /* @ offset 0x80 */
+	uint32_t gprtbimap_hshi;    /* @ offset 0x84 */
+	uint32_t gprtbimap_fslo;    /* @ offset 0x88 */
+	uint32_t gprtbimap_fshi;    /* @ offset 0x8c */
+	uint32_t reserved_90;       /* Reserved @ offset 0x90 */
+	uint32_t reserved_94;       /* @ offset 0x94 */
+	uint32_t reserved_98;       /* @ offset 0x98 */
+	uint32_t guctl2;            /* @ offset 0x9c */
+	uint32_t reserved_A0[24];   /* Reserved @ offset 0xa0 */
+	uint32_t gusb2phycfg;       /* @ offset 0x100 */
+	uint32_t reserved_104[15];  /* Reserved @ offset 0x104 */
+	uint32_t gusb2i2cctl;       /* @ offset 0x140 */
+	uint32_t reserved_144[15];  /* Reserved @ offset 0x144 */
+	uint32_t gusb2phyacc_ulpi;  /* @ offset 0x180 */
+	uint32_t reserved_184[15];  /* Reserved @ offset 0x184 */
+	uint32_t gusb3pipectl;      /* @ offset 0x1c0 */
+	uint32_t reserved_1c4[15];  /* Reserved @ offset 0x1c4 */
+	uint32_t gtxfifosiz0;       /* @ offset 0x200 */
+	uint32_t gtxfifosiz1;       /* @ offset 0x204 */
+	uint32_t gtxfifosiz2;       /* @ offset 0x208 */
+	uint32_t gtxfifosiz3;       /* @ offset 0x20c */
+	uint32_t gtxfifosiz4;       /* @ offset 0x210 */
+	uint32_t gtxfifosiz5;       /* @ offset 0x214 */
+	uint32_t gtxfifosiz6;       /* @ offset 0x218 */
+	uint32_t gtxfifosiz7;       /* @ offset 0x21c */
+	uint32_t gtxfifosiz8;       /* @ offset 0x220 */
+	uint32_t gtxfifosiz9;       /* @ offset 0x224 */
+	uint32_t gtxfifosiz10;      /* @ offset 0x228 */
+	uint32_t gtxfifosiz11;      /* @ offset 0x22c */
+	uint32_t reserved_230[20];  /* Reserved @ offset 0x230 */
+	uint32_t grxfifosiz0;       /* @ offset 0x280 */
+	uint32_t grxfifosiz1;       /* @ offset 0x284 */
+	uint32_t grxfifosiz2;       /* @ offset 0x288 */
+	uint32_t reserved_28c[29];  /* Reserved @ offset 0x28c */
+	uint32_t gevntadrlo;        /* @ offset 0x300 */
+	uint32_t gevntadrhi;        /* @ offset 0x304 */
+	uint32_t gevntsiz;          /* @ offset 0x308 */
+	uint32_t gevntcount;        /* @ offset 0x30c */
+	uint32_t reserved_310[124]; /* Reserved @ offset 0x310 */
+	uint32_t ghwparams8;        /* @ offset 0x500 */
+	uint32_t reserved_504[3];   /* Reserved @ offset 0x504 */
+	uint32_t gtxfifopridev;     /* @ offset 0x510 */
+	uint32_t reserved_514;      /* Reserved @ offset 0x514 */
+	uint32_t gtxfifoprihst;     /* @ offset 0x518 */
+	uint32_t grxfifoprihst;     /* @ offset 0x51c */
+	uint32_t reserved_520;      /* Reserved @ offset 0x520 */
+	uint32_t gdmahlratio;       /* @ offset 0x524 */
+	uint32_t reserved_528[2];   /* Reserved @ offset 0x528 */
+	uint32_t gfladj;            /* @ offset 0x530 */
+	uint32_t reserved_534[0xcc / 4];  /* Reserved @ offset 0x534 */
+} usb_dwc3_global_t;
+
+typedef struct {
+	uint32_t bpl;      /* Buffer Pointer Low Address */
+	uint32_t bph;      /* Buffer Pointer High Address */
+	uint32_t size;     /* Buffer Size */
+	uint32_t ctrl;     /* Control and Status field */
+} __packed usb_dwc3_trb_t __aligned(16);
+
+#define CACHED_MEMORY
+#define CACHE_LINE_SIZE CACHE_WRITEBACK_GRANULE
+
+typedef struct {
+	bool is_stall;				/* Endpoint stall condition */
+
+	volatile usb_dwc3_trb_t *trb_addr; /* Trb descriptor coherent address */
+	uintptr_t trb_dma_addr;   /* 32 bits aligned trb bus address */
+	uint8_t trb_flag;         /* TRB Control Flag */
+	uint8_t flags;            /* Endpoint state flags condition */
+	uint8_t phy_epnum;        /* physical EP number 0 - 31 */
+	uint8_t intr_num;         /* Interrupt number to get events for this EP */
+#ifdef CACHED_MEMORY // Needed only for cached (__KERNEL__) environment
+    /* Added to shield the cache line (8 words) intersection with other members of structure */
+	uint32_t dummy3[CACHE_LINE_SIZE];
+#endif
+	/* to be used for receiving packet < EP-Max-Packet-Size */
+	uint8_t bounce_buf[USB3_MAX_PACKET_SIZE];
+#ifdef CACHED_MEMORY // Needed only for cached (__KERNEL__) environment
+	/* Added to shield the cache line (8 words) intersection with other members of structure */
+	uint32_t dummy4[CACHE_LINE_SIZE];
+#endif
+	/* Transmission FIFO number. Number between Min_Data = 1 and Max_Data = 15 */
+	uint8_t tx_fifo_num;
+	uint8_t resc_idx;       /* Resource index */
+	uintptr_t dma_addr;     /* 32 bits aligned transfer buffer address */
+	/* Pointer to destination buffer, used for receive case, where bounce_buf is used */
+	uint8_t *xfer_dest_buff;
+	/* length of destination buffer, used for receive case, where bounce_buf is used */
+	uint32_t xfer_dest_len;
+} usb_dwc3_endpoint_t;
+
+/* Aligned to make EvtBuffer start address evtbuffer-size aligned */
+typedef struct {
+	uint8_t EvtBufferArea[USB_DWC3_EVENT_BUFFER_SIZE];  /* Event Buffer area */
+} PCD_intbufferareadef __aligned(USB_DWC3_EVENT_BUFFER_SIZE);
+
+typedef struct {
+	/* shield needed for the cache line (8 words) intersection with other members of structure,
+	 * only when USB_DWC3_EVENT_BUFFER_SIZE is non-cache_line aligned
+	 */
+
+	uint8_t *evtbuffer_addr[USB_DWC3_INT_INUSE]; /* Event Buffer coherent addr */
+	uintptr_t evtbuffer_dma_addr[USB_DWC3_INT_INUSE]; /* Event Buffer dma addr */
+	uint32_t evtbufferpos[USB_DWC3_INT_INUSE];   /*!< Read Position inside the Event Buffer */
+} PCD_intbuffersdef;
+
+typedef enum {
+	HAL_PCD_STATE_RESET   = 0x00U,
+	HAL_PCD_STATE_READY   = 0x01U,
+	HAL_PCD_STATE_ERROR   = 0x02U,
+	HAL_PCD_STATE_BUSY    = 0x03U,
+	HAL_PCD_STATE_TIMEOUT = 0x04U
+} usb_dwc3_state_t;
+
+typedef enum {
+	HAL_PCD_EP0_SETUP_COMPLETED = 0x00U,
+	HAL_PCD_EP0_SETUP_QUEUED  = 0x01U
+} usb_dwc3_ep0state_t;
+
+typedef struct {
+	/*
+	 * Kept at top to avoid struct size wastage since EvtBufferArea
+	 * needs to be USB_DWC3_EVENT_BUFFER_SIZE aligned
+	 */
+	PCD_intbuffersdef intbuffers;
+	usb_dwc3_global_t *usb_global;
+	usb_dwc3_device_t *usb_device;
+	usb_dwc3_endpoint_t IN_ep[USB_DWC3_NUM_IN_EP];
+	usb_dwc3_endpoint_t OUT_ep[USB_DWC3_NUM_OUT_EP];
+
+	usb_dwc3_state_t State;      /*!< PCD communication state            */
+	usb_dwc3_ep0state_t EP0_State;  /*!< EP0 State */
+
+	uint8_t *setup_addr;  /*!< Setup packet coherent address    */
+	uintptr_t setup_dma_addr;  /*!< Setup packet buffer DMA Bus address */
+
+	struct pcd_handle *pcd_handle;
+} dwc3_handle_t;
+
+void usb_dwc3_init_driver(struct usb_handle *usb_core_handle,
+			  struct pcd_handle *pcd_handle, dwc3_handle_t *dwc3_handle,
+			  void *base_addr);
+
+#endif /* __USB_DWC3_H */
diff --git a/include/drivers/usb_device.h b/include/drivers/usb_device.h
index 8fdb6ae13..2f9403318 100644
--- a/include/drivers/usb_device.h
+++ b/include/drivers/usb_device.h
@@ -11,6 +11,17 @@
 
 #include <lib/utils_def.h>
 
+/* Define for EP address */
+#define EP_DIR_MASK	BIT(7)
+#define EP_DIR_IN	BIT(7)
+#define EP_NUM_MASK	GENMASK(3, 0)
+
+#define EP0_IN	(0U | EP_DIR_IN)
+#define EP0_OUT	0U
+
+/* USB address between 1 through 127 = 0x7F mask */
+#define ADDRESS_MASK	GENMASK(6, 0)
+
 #define USBD_MAX_NUM_INTERFACES			1U
 #define USBD_MAX_NUM_CONFIGURATION		1U
 
diff --git a/include/dt-bindings/clock/stm32mp1-clks.h b/include/dt-bindings/clock/stm32mp1-clks.h
index 67e66b23f..b2fa90f1b 100644
--- a/include/dt-bindings/clock/stm32mp1-clks.h
+++ b/include/dt-bindings/clock/stm32mp1-clks.h
@@ -4,275 +4,9 @@
  * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
  */
 
-#ifndef _DT_BINDINGS_STM32MP1_CLKS_H_
-#define _DT_BINDINGS_STM32MP1_CLKS_H_
-
-/* OSCILLATOR clocks */
-#define CK_HSE		0
-#define CK_CSI		1
-#define CK_LSI		2
-#define CK_LSE		3
-#define CK_HSI		4
-#define CK_HSE_DIV2	5
-
-/* Bus clocks */
-#define TIM2		6
-#define TIM3		7
-#define TIM4		8
-#define TIM5		9
-#define TIM6		10
-#define TIM7		11
-#define TIM12		12
-#define TIM13		13
-#define TIM14		14
-#define LPTIM1		15
-#define SPI2		16
-#define SPI3		17
-#define USART2		18
-#define USART3		19
-#define UART4		20
-#define UART5		21
-#define UART7		22
-#define UART8		23
-#define I2C1		24
-#define I2C2		25
-#define I2C3		26
-#define I2C5		27
-#define SPDIF		28
-#define CEC		29
-#define DAC12		30
-#define MDIO		31
-#define TIM1		32
-#define TIM8		33
-#define TIM15		34
-#define TIM16		35
-#define TIM17		36
-#define SPI1		37
-#define SPI4		38
-#define SPI5		39
-#define USART6		40
-#define SAI1		41
-#define SAI2		42
-#define SAI3		43
-#define DFSDM		44
-#define FDCAN		45
-#define LPTIM2		46
-#define LPTIM3		47
-#define LPTIM4		48
-#define LPTIM5		49
-#define SAI4		50
-#define SYSCFG		51
-#define VREF		52
-#define TMPSENS		53
-#define PMBCTRL		54
-#define HDP		55
-#define LTDC		56
-#define DSI		57
-#define IWDG2		58
-#define USBPHY		59
-#define STGENRO		60
-#define SPI6		61
-#define I2C4		62
-#define I2C6		63
-#define USART1		64
-#define RTCAPB		65
-#define TZC1		66
-#define TZPC		67
-#define IWDG1		68
-#define BSEC		69
-#define STGEN		70
-#define DMA1		71
-#define DMA2		72
-#define DMAMUX		73
-#define ADC12		74
-#define USBO		75
-#define SDMMC3		76
-#define DCMI		77
-#define CRYP2		78
-#define HASH2		79
-#define RNG2		80
-#define CRC2		81
-#define HSEM		82
-#define IPCC		83
-#define GPIOA		84
-#define GPIOB		85
-#define GPIOC		86
-#define GPIOD		87
-#define GPIOE		88
-#define GPIOF		89
-#define GPIOG		90
-#define GPIOH		91
-#define GPIOI		92
-#define GPIOJ		93
-#define GPIOK		94
-#define GPIOZ		95
-#define CRYP1		96
-#define HASH1		97
-#define RNG1		98
-#define BKPSRAM		99
-#define MDMA		100
-#define GPU		101
-#define ETHCK		102
-#define ETHTX		103
-#define ETHRX		104
-#define ETHMAC		105
-#define FMC		106
-#define QSPI		107
-#define SDMMC1		108
-#define SDMMC2		109
-#define CRC1		110
-#define USBH		111
-#define ETHSTP		112
-#define TZC2		113
-
-/* Kernel clocks */
-#define SDMMC1_K	118
-#define SDMMC2_K	119
-#define SDMMC3_K	120
-#define FMC_K		121
-#define QSPI_K		122
-#define ETHCK_K		123
-#define RNG1_K		124
-#define RNG2_K		125
-#define GPU_K		126
-#define USBPHY_K	127
-#define STGEN_K		128
-#define SPDIF_K		129
-#define SPI1_K		130
-#define SPI2_K		131
-#define SPI3_K		132
-#define SPI4_K		133
-#define SPI5_K		134
-#define SPI6_K		135
-#define CEC_K		136
-#define I2C1_K		137
-#define I2C2_K		138
-#define I2C3_K		139
-#define I2C4_K		140
-#define I2C5_K		141
-#define I2C6_K		142
-#define LPTIM1_K	143
-#define LPTIM2_K	144
-#define LPTIM3_K	145
-#define LPTIM4_K	146
-#define LPTIM5_K	147
-#define USART1_K	148
-#define USART2_K	149
-#define USART3_K	150
-#define UART4_K		151
-#define UART5_K		152
-#define USART6_K	153
-#define UART7_K		154
-#define UART8_K		155
-#define DFSDM_K		156
-#define FDCAN_K		157
-#define SAI1_K		158
-#define SAI2_K		159
-#define SAI3_K		160
-#define SAI4_K		161
-#define ADC12_K		162
-#define DSI_K		163
-#define DSI_PX		164
-#define ADFSDM_K	165
-#define USBO_K		166
-#define LTDC_PX		167
-#define DAC12_K		168
-#define ETHPTP_K	169
-
-/* PLL */
-#define PLL1		176
-#define PLL2		177
-#define PLL3		178
-#define PLL4		179
-
-/* ODF */
-#define PLL1_P		180
-#define PLL1_Q		181
-#define PLL1_R		182
-#define PLL2_P		183
-#define PLL2_Q		184
-#define PLL2_R		185
-#define PLL3_P		186
-#define PLL3_Q		187
-#define PLL3_R		188
-#define PLL4_P		189
-#define PLL4_Q		190
-#define PLL4_R		191
-
-/* AUX */
-#define RTC		192
-
-/* MCLK */
-#define CK_PER		193
-#define CK_MPU		194
-#define CK_AXI		195
-#define CK_MCU		196
-
-/* Time base */
-#define TIM2_K		197
-#define TIM3_K		198
-#define TIM4_K		199
-#define TIM5_K		200
-#define TIM6_K		201
-#define TIM7_K		202
-#define TIM12_K		203
-#define TIM13_K		204
-#define TIM14_K		205
-#define TIM1_K		206
-#define TIM8_K		207
-#define TIM15_K		208
-#define TIM16_K		209
-#define TIM17_K		210
-
-/* MCO clocks */
-#define CK_MCO1		211
-#define CK_MCO2		212
-
-/* TRACE & DEBUG clocks */
-#define CK_DBG		214
-#define CK_TRACE	215
-
-/* DDR */
-#define DDRC1		220
-#define DDRC1LP		221
-#define DDRC2		222
-#define DDRC2LP		223
-#define DDRPHYC		224
-#define DDRPHYCLP	225
-#define DDRCAPB		226
-#define DDRCAPBLP	227
-#define AXIDCG		228
-#define DDRPHYCAPB	229
-#define DDRPHYCAPBLP	230
-#define DDRPERFM	231
-
-#define STM32MP1_LAST_CLK 232
-
-/* SCMI clock identifiers */
-#define CK_SCMI0_HSE		0
-#define CK_SCMI0_HSI		1
-#define CK_SCMI0_CSI		2
-#define CK_SCMI0_LSE		3
-#define CK_SCMI0_LSI		4
-#define CK_SCMI0_PLL2_Q		5
-#define CK_SCMI0_PLL2_R		6
-#define CK_SCMI0_MPU		7
-#define CK_SCMI0_AXI		8
-#define CK_SCMI0_BSEC		9
-#define CK_SCMI0_CRYP1		10
-#define CK_SCMI0_GPIOZ		11
-#define CK_SCMI0_HASH1		12
-#define CK_SCMI0_I2C4		13
-#define CK_SCMI0_I2C6		14
-#define CK_SCMI0_IWDG1		15
-#define CK_SCMI0_RNG1		16
-#define CK_SCMI0_RTC		17
-#define CK_SCMI0_RTCAPB		18
-#define CK_SCMI0_SPI6		19
-#define CK_SCMI0_USART1		20
-
-#define CK_SCMI1_PLL3_Q		0
-#define CK_SCMI1_PLL3_R		1
-#define CK_SCMI1_MCU		2
-
-#endif /* _DT_BINDINGS_STM32MP1_CLKS_H_ */
+#if STM32MP13
+#include "stm32mp13-clks.h"
+#endif
+#if STM32MP15
+#include "stm32mp15-clks.h"
+#endif
diff --git a/include/dt-bindings/clock/stm32mp1-clksrc.h b/include/dt-bindings/clock/stm32mp1-clksrc.h
index 818f4b768..70ecf1063 100644
--- a/include/dt-bindings/clock/stm32mp1-clksrc.h
+++ b/include/dt-bindings/clock/stm32mp1-clksrc.h
@@ -1,283 +1,11 @@
 /* SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause */
 /*
- * Copyright (C) 2017, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2017-2020, STMicroelectronics - All Rights Reserved
  */
 
-#ifndef _DT_BINDINGS_CLOCK_STM32MP1_CLKSRC_H_
-#define _DT_BINDINGS_CLOCK_STM32MP1_CLKSRC_H_
-
-/* PLL output is enable when x=1, with x=p,q or r */
-#define PQR(p, q, r)	(((p) & 1) | (((q) & 1) << 1) | (((r) & 1) << 2))
-
-/* st,clksrc: mandatory clock source */
-
-#define CLK_MPU_HSI		0x00000200
-#define CLK_MPU_HSE		0x00000201
-#define CLK_MPU_PLL1P		0x00000202
-#define CLK_MPU_PLL1P_DIV	0x00000203
-
-#define CLK_AXI_HSI		0x00000240
-#define CLK_AXI_HSE		0x00000241
-#define CLK_AXI_PLL2P		0x00000242
-
-#define CLK_MCU_HSI		0x00000480
-#define CLK_MCU_HSE		0x00000481
-#define CLK_MCU_CSI		0x00000482
-#define CLK_MCU_PLL3P		0x00000483
-
-#define CLK_PLL12_HSI		0x00000280
-#define CLK_PLL12_HSE		0x00000281
-
-#define CLK_PLL3_HSI		0x00008200
-#define CLK_PLL3_HSE		0x00008201
-#define CLK_PLL3_CSI		0x00008202
-
-#define CLK_PLL4_HSI		0x00008240
-#define CLK_PLL4_HSE		0x00008241
-#define CLK_PLL4_CSI		0x00008242
-#define CLK_PLL4_I2SCKIN	0x00008243
-
-#define CLK_RTC_DISABLED	0x00001400
-#define CLK_RTC_LSE		0x00001401
-#define CLK_RTC_LSI		0x00001402
-#define CLK_RTC_HSE		0x00001403
-
-#define CLK_MCO1_HSI		0x00008000
-#define CLK_MCO1_HSE		0x00008001
-#define CLK_MCO1_CSI		0x00008002
-#define CLK_MCO1_LSI		0x00008003
-#define CLK_MCO1_LSE		0x00008004
-#define CLK_MCO1_DISABLED	0x0000800F
-
-#define CLK_MCO2_MPU		0x00008040
-#define CLK_MCO2_AXI		0x00008041
-#define CLK_MCO2_MCU		0x00008042
-#define CLK_MCO2_PLL4P		0x00008043
-#define CLK_MCO2_HSE		0x00008044
-#define CLK_MCO2_HSI		0x00008045
-#define CLK_MCO2_DISABLED	0x0000804F
-
-/* st,pkcs: peripheral kernel clock source */
-
-#define CLK_I2C12_PCLK1		0x00008C00
-#define CLK_I2C12_PLL4R		0x00008C01
-#define CLK_I2C12_HSI		0x00008C02
-#define CLK_I2C12_CSI		0x00008C03
-#define CLK_I2C12_DISABLED	0x00008C07
-
-#define CLK_I2C35_PCLK1		0x00008C40
-#define CLK_I2C35_PLL4R		0x00008C41
-#define CLK_I2C35_HSI		0x00008C42
-#define CLK_I2C35_CSI		0x00008C43
-#define CLK_I2C35_DISABLED	0x00008C47
-
-#define CLK_I2C46_PCLK5		0x00000C00
-#define CLK_I2C46_PLL3Q		0x00000C01
-#define CLK_I2C46_HSI		0x00000C02
-#define CLK_I2C46_CSI		0x00000C03
-#define CLK_I2C46_DISABLED	0x00000C07
-
-#define CLK_SAI1_PLL4Q		0x00008C80
-#define CLK_SAI1_PLL3Q		0x00008C81
-#define CLK_SAI1_I2SCKIN	0x00008C82
-#define CLK_SAI1_CKPER		0x00008C83
-#define CLK_SAI1_PLL3R		0x00008C84
-#define CLK_SAI1_DISABLED	0x00008C87
-
-#define CLK_SAI2_PLL4Q		0x00008CC0
-#define CLK_SAI2_PLL3Q		0x00008CC1
-#define CLK_SAI2_I2SCKIN	0x00008CC2
-#define CLK_SAI2_CKPER		0x00008CC3
-#define CLK_SAI2_SPDIF		0x00008CC4
-#define CLK_SAI2_PLL3R		0x00008CC5
-#define CLK_SAI2_DISABLED	0x00008CC7
-
-#define CLK_SAI3_PLL4Q		0x00008D00
-#define CLK_SAI3_PLL3Q		0x00008D01
-#define CLK_SAI3_I2SCKIN	0x00008D02
-#define CLK_SAI3_CKPER		0x00008D03
-#define CLK_SAI3_PLL3R		0x00008D04
-#define CLK_SAI3_DISABLED	0x00008D07
-
-#define CLK_SAI4_PLL4Q		0x00008D40
-#define CLK_SAI4_PLL3Q		0x00008D41
-#define CLK_SAI4_I2SCKIN	0x00008D42
-#define CLK_SAI4_CKPER		0x00008D43
-#define CLK_SAI4_PLL3R		0x00008D44
-#define CLK_SAI4_DISABLED	0x00008D47
-
-#define CLK_SPI2S1_PLL4P	0x00008D80
-#define CLK_SPI2S1_PLL3Q	0x00008D81
-#define CLK_SPI2S1_I2SCKIN	0x00008D82
-#define CLK_SPI2S1_CKPER	0x00008D83
-#define CLK_SPI2S1_PLL3R	0x00008D84
-#define CLK_SPI2S1_DISABLED	0x00008D87
-
-#define CLK_SPI2S23_PLL4P	0x00008DC0
-#define CLK_SPI2S23_PLL3Q	0x00008DC1
-#define CLK_SPI2S23_I2SCKIN	0x00008DC2
-#define CLK_SPI2S23_CKPER	0x00008DC3
-#define CLK_SPI2S23_PLL3R	0x00008DC4
-#define CLK_SPI2S23_DISABLED	0x00008DC7
-
-#define CLK_SPI45_PCLK2		0x00008E00
-#define CLK_SPI45_PLL4Q		0x00008E01
-#define CLK_SPI45_HSI		0x00008E02
-#define CLK_SPI45_CSI		0x00008E03
-#define CLK_SPI45_HSE		0x00008E04
-#define CLK_SPI45_DISABLED	0x00008E07
-
-#define CLK_SPI6_PCLK5		0x00000C40
-#define CLK_SPI6_PLL4Q		0x00000C41
-#define CLK_SPI6_HSI		0x00000C42
-#define CLK_SPI6_CSI		0x00000C43
-#define CLK_SPI6_HSE		0x00000C44
-#define CLK_SPI6_PLL3Q		0x00000C45
-#define CLK_SPI6_DISABLED	0x00000C47
-
-#define CLK_UART6_PCLK2		0x00008E40
-#define CLK_UART6_PLL4Q		0x00008E41
-#define CLK_UART6_HSI		0x00008E42
-#define CLK_UART6_CSI		0x00008E43
-#define CLK_UART6_HSE		0x00008E44
-#define CLK_UART6_DISABLED	0x00008E47
-
-#define CLK_UART24_PCLK1	0x00008E80
-#define CLK_UART24_PLL4Q	0x00008E81
-#define CLK_UART24_HSI		0x00008E82
-#define CLK_UART24_CSI		0x00008E83
-#define CLK_UART24_HSE		0x00008E84
-#define CLK_UART24_DISABLED	0x00008E87
-
-#define CLK_UART35_PCLK1	0x00008EC0
-#define CLK_UART35_PLL4Q	0x00008EC1
-#define CLK_UART35_HSI		0x00008EC2
-#define CLK_UART35_CSI		0x00008EC3
-#define CLK_UART35_HSE		0x00008EC4
-#define CLK_UART35_DISABLED	0x00008EC7
-
-#define CLK_UART78_PCLK1	0x00008F00
-#define CLK_UART78_PLL4Q	0x00008F01
-#define CLK_UART78_HSI		0x00008F02
-#define CLK_UART78_CSI		0x00008F03
-#define CLK_UART78_HSE		0x00008F04
-#define CLK_UART78_DISABLED	0x00008F07
-
-#define CLK_UART1_PCLK5		0x00000C80
-#define CLK_UART1_PLL3Q		0x00000C81
-#define CLK_UART1_HSI		0x00000C82
-#define CLK_UART1_CSI		0x00000C83
-#define CLK_UART1_PLL4Q		0x00000C84
-#define CLK_UART1_HSE		0x00000C85
-#define CLK_UART1_DISABLED	0x00000C87
-
-#define CLK_SDMMC12_HCLK6	0x00008F40
-#define CLK_SDMMC12_PLL3R	0x00008F41
-#define CLK_SDMMC12_PLL4P	0x00008F42
-#define CLK_SDMMC12_HSI		0x00008F43
-#define CLK_SDMMC12_DISABLED	0x00008F47
-
-#define CLK_SDMMC3_HCLK2	0x00008F80
-#define CLK_SDMMC3_PLL3R	0x00008F81
-#define CLK_SDMMC3_PLL4P	0x00008F82
-#define CLK_SDMMC3_HSI		0x00008F83
-#define CLK_SDMMC3_DISABLED	0x00008F87
-
-#define CLK_ETH_PLL4P		0x00008FC0
-#define CLK_ETH_PLL3Q		0x00008FC1
-#define CLK_ETH_DISABLED	0x00008FC3
-
-#define CLK_QSPI_ACLK		0x00009000
-#define CLK_QSPI_PLL3R		0x00009001
-#define CLK_QSPI_PLL4P		0x00009002
-#define CLK_QSPI_CKPER		0x00009003
-
-#define CLK_FMC_ACLK		0x00009040
-#define CLK_FMC_PLL3R		0x00009041
-#define CLK_FMC_PLL4P		0x00009042
-#define CLK_FMC_CKPER		0x00009043
-
-#define CLK_FDCAN_HSE		0x000090C0
-#define CLK_FDCAN_PLL3Q		0x000090C1
-#define CLK_FDCAN_PLL4Q		0x000090C2
-#define CLK_FDCAN_PLL4R		0x000090C3
-
-#define CLK_SPDIF_PLL4P		0x00009140
-#define CLK_SPDIF_PLL3Q		0x00009141
-#define CLK_SPDIF_HSI		0x00009142
-#define CLK_SPDIF_DISABLED	0x00009143
-
-#define CLK_CEC_LSE		0x00009180
-#define CLK_CEC_LSI		0x00009181
-#define CLK_CEC_CSI_DIV122	0x00009182
-#define CLK_CEC_DISABLED	0x00009183
-
-#define CLK_USBPHY_HSE		0x000091C0
-#define CLK_USBPHY_PLL4R	0x000091C1
-#define CLK_USBPHY_HSE_DIV2	0x000091C2
-#define CLK_USBPHY_DISABLED	0x000091C3
-
-#define CLK_USBO_PLL4R		0x800091C0
-#define CLK_USBO_USBPHY		0x800091C1
-
-#define CLK_RNG1_CSI		0x00000CC0
-#define CLK_RNG1_PLL4R		0x00000CC1
-#define CLK_RNG1_LSE		0x00000CC2
-#define CLK_RNG1_LSI		0x00000CC3
-
-#define CLK_RNG2_CSI		0x00009200
-#define CLK_RNG2_PLL4R		0x00009201
-#define CLK_RNG2_LSE		0x00009202
-#define CLK_RNG2_LSI		0x00009203
-
-#define CLK_CKPER_HSI		0x00000D00
-#define CLK_CKPER_CSI		0x00000D01
-#define CLK_CKPER_HSE		0x00000D02
-#define CLK_CKPER_DISABLED	0x00000D03
-
-#define CLK_STGEN_HSI		0x00000D40
-#define CLK_STGEN_HSE		0x00000D41
-#define CLK_STGEN_DISABLED	0x00000D43
-
-#define CLK_DSI_DSIPLL		0x00009240
-#define CLK_DSI_PLL4P		0x00009241
-
-#define CLK_ADC_PLL4R		0x00009280
-#define CLK_ADC_CKPER		0x00009281
-#define CLK_ADC_PLL3Q		0x00009282
-#define CLK_ADC_DISABLED	0x00009283
-
-#define CLK_LPTIM45_PCLK3	0x000092C0
-#define CLK_LPTIM45_PLL4P	0x000092C1
-#define CLK_LPTIM45_PLL3Q	0x000092C2
-#define CLK_LPTIM45_LSE		0x000092C3
-#define CLK_LPTIM45_LSI		0x000092C4
-#define CLK_LPTIM45_CKPER	0x000092C5
-#define CLK_LPTIM45_DISABLED	0x000092C7
-
-#define CLK_LPTIM23_PCLK3	0x00009300
-#define CLK_LPTIM23_PLL4Q	0x00009301
-#define CLK_LPTIM23_CKPER	0x00009302
-#define CLK_LPTIM23_LSE		0x00009303
-#define CLK_LPTIM23_LSI		0x00009304
-#define CLK_LPTIM23_DISABLED	0x00009307
-
-#define CLK_LPTIM1_PCLK1	0x00009340
-#define CLK_LPTIM1_PLL4P	0x00009341
-#define CLK_LPTIM1_PLL3Q	0x00009342
-#define CLK_LPTIM1_LSE		0x00009343
-#define CLK_LPTIM1_LSI		0x00009344
-#define CLK_LPTIM1_CKPER	0x00009345
-#define CLK_LPTIM1_DISABLED	0x00009347
-
-/* define for st,pll /csg */
-#define SSCG_MODE_CENTER_SPREAD	0
-#define SSCG_MODE_DOWN_SPREAD	1
-
-/* define for st,drive */
-#define LSEDRV_LOWEST		0
-#define LSEDRV_MEDIUM_LOW	1
-#define LSEDRV_MEDIUM_HIGH	2
-#define LSEDRV_HIGHEST		3
-
+#if STM32MP13
+#include "stm32mp13-clksrc.h"
+#endif
+#if STM32MP15
+#include "stm32mp15-clksrc.h"
 #endif
diff --git a/include/dt-bindings/clock/stm32mp13-clks.h b/include/dt-bindings/clock/stm32mp13-clks.h
new file mode 100644
index 000000000..446cbd109
--- /dev/null
+++ b/include/dt-bindings/clock/stm32mp13-clks.h
@@ -0,0 +1,230 @@
+/* SPDX-License-Identifier: GPL-2.0+ or BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2020 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32MP13_CLKS_H_
+#define _DT_BINDINGS_STM32MP13_CLKS_H_
+
+/* OSCILLATOR clocks */
+#define CK_HSE		0
+#define CK_CSI		1
+#define CK_LSI		2
+#define CK_LSE		3
+#define CK_HSI		4
+#define CK_HSE_DIV2	5
+
+/* PLL */
+#define PLL1		6
+#define PLL2		7
+#define PLL3		8
+#define PLL4		9
+
+/* ODF */
+#define PLL1_P		10
+#define PLL1_Q		11
+#define PLL1_R		12
+#define PLL2_P		13
+#define PLL2_Q		14
+#define PLL2_R		15
+#define PLL3_P		16
+#define PLL3_Q		17
+#define PLL3_R		18
+#define PLL4_P		19
+#define PLL4_Q		20
+#define PLL4_R		21
+
+#define PCLK1		22
+#define PCLK2		23
+#define PCLK3		24
+#define PCLK4		25
+#define PCLK5		26
+#define PCLK6		27
+
+/* SYSTEM CLOCK */
+#define CK_PER		28
+#define CK_MPU		29
+#define CK_AXI		30
+#define CK_MLAHB	31
+
+/* BASE TIMER */
+#define CK_TIMG1	32
+#define CK_TIMG2	33
+#define CK_TIMG3	34
+
+/* AUX */
+#define RTC		35
+
+/* TRACE & DEBUG clocks */
+#define CK_DBG		36
+#define CK_TRACE	37
+
+/* MCO clocks */
+#define CK_MCO1		38
+#define CK_MCO2		39
+
+/*  IP clocks */
+#define SYSCFG		40
+#define VREF		41
+#define TMPSENS		42
+#define PMBCTRL		43
+#define HDP		44
+#define IWDG2		45
+#define STGENRO		46
+#define USART1		47
+#define RTCAPB		48
+#define TZC		49
+#define TZPC		50
+#define IWDG1		51
+#define BSEC		52
+#define DMA1		53
+#define DMA2		54
+#define DMAMUX1		55
+#define DMAMUX2		56
+#define GPIOA		57
+#define GPIOB		58
+#define GPIOC		59
+#define GPIOD		60
+#define GPIOE		61
+#define GPIOF		62
+#define GPIOG		63
+#define GPIOH		64
+#define GPIOI		65
+#define CRYP1		66
+#define HASH1		67
+#define BKPSRAM		68
+#define MDMA		69
+#define CRC1		70
+#define USBH		71
+#define DMA3		72
+#define TSC		73
+#define PKA		74
+#define AXIMC		75
+#define MCE		76
+#define ETH1TX		77
+#define ETH2TX		78
+#define ETH1RX		79
+#define ETH2RX		80
+#define ETH1MAC		81
+#define ETH2MAC		82
+#define ETH1STP		83
+#define ETH2STP		84
+
+/* IP clocks with parents */
+#define SDMMC1_K	85
+#define SDMMC2_K	86
+#define ADC1_K		87
+#define ADC2_K		88
+#define FMC_K		89
+#define QSPI_K		90
+#define RNG1_K		91
+#define USBPHY_K	92
+#define STGEN_K		93
+#define SPDIF_K		94
+#define SPI1_K		95
+#define SPI2_K		96
+#define SPI3_K		97
+#define SPI4_K		98
+#define SPI5_K		99
+#define I2C1_K		100
+#define I2C2_K		101
+#define I2C3_K		102
+#define I2C4_K		103
+#define I2C5_K		104
+#define TIM2_K		105
+#define TIM3_K		106
+#define TIM4_K		107
+#define TIM5_K		108
+#define TIM6_K		109
+#define TIM7_K		110
+#define TIM12_K		111
+#define TIM13_K		112
+#define TIM14_K		113
+#define TIM1_K		114
+#define TIM8_K		115
+#define TIM15_K		116
+#define TIM16_K		117
+#define TIM17_K		118
+#define LPTIM1_K	119
+#define LPTIM2_K	120
+#define LPTIM3_K	121
+#define LPTIM4_K	122
+#define LPTIM5_K	123
+#define USART1_K	124
+#define USART2_K	125
+#define USART3_K	126
+#define UART4_K		127
+#define UART5_K		128
+#define USART6_K	129
+#define UART7_K		130
+#define UART8_K		131
+#define DFSDM_K		132
+#define FDCAN_K		133
+#define SAI1_K		134
+#define SAI2_K		135
+#define ADFSDM_K	136
+#define USBO_K		137
+#define LTDC_PX		138
+#define ETH1CK_K	139
+#define ETH1PTP_K	140
+#define ETH2CK_K	141
+#define ETH2PTP_K	142
+#define DCMIPP_K	143
+#define SAES_K		144
+#define DTS_K		145
+
+/* DDR */
+#define DDRC1		146
+#define DDRC1LP		147
+#define DDRC2		148
+#define DDRC2LP		149
+#define DDRPHYC		150
+#define DDRPHYCLP	151
+#define DDRCAPB		152
+#define DDRCAPBLP	153
+#define AXIDCG		154
+#define DDRPHYCAPB	155
+#define DDRPHYCAPBLP	156
+#define DDRPERFM	157
+
+#define ADC1		158
+#define ADC2		159
+#define SAI1		160
+#define SAI2		161
+
+#define STM32MP1_LAST_CLK 162
+
+/* SCMI clock identifiers */
+#define CK_SCMI0_HSE		0
+#define CK_SCMI0_HSI		1
+#define CK_SCMI0_CSI		2
+#define CK_SCMI0_LSE		3
+#define CK_SCMI0_LSI		4
+#define CK_SCMI0_HSE_DIV2	5
+#define CK_SCMI0_PLL2_Q		6
+#define CK_SCMI0_PLL2_R		7
+#define CK_SCMI0_PLL3_P		8
+#define CK_SCMI0_PLL3_Q		9
+#define CK_SCMI0_PLL3_R		10
+#define CK_SCMI0_PLL4_P		11
+#define CK_SCMI0_PLL4_Q		12
+#define CK_SCMI0_PLL4_R		13
+#define CK_SCMI0_MPU		14
+#define CK_SCMI0_AXI		15
+#define CK_SCMI0_MLAHB		16
+#define CK_SCMI0_CKPER		17
+#define CK_SCMI0_PCLK1		18
+#define CK_SCMI0_PCLK2		19
+#define CK_SCMI0_PCLK3		20
+#define CK_SCMI0_PCLK4		21
+#define CK_SCMI0_PCLK5		22
+#define CK_SCMI0_PCLK6		23
+#define CK_SCMI0_CKTIMG1	24
+#define CK_SCMI0_CKTIMG2	25
+#define CK_SCMI0_CKTIMG3	26
+#define CK_SCMI0_RTC		27
+#define CK_SCMI0_RTCAPB		28
+#define CK_SCMI0_BSEC		29
+
+#endif /* _DT_BINDINGS_STM32MP13_CLKS_H_ */
diff --git a/include/dt-bindings/clock/stm32mp13-clksrc.h b/include/dt-bindings/clock/stm32mp13-clksrc.h
new file mode 100644
index 000000000..20ec78863
--- /dev/null
+++ b/include/dt-bindings/clock/stm32mp13-clksrc.h
@@ -0,0 +1,394 @@
+/*
+ * Copyright (C) 2018-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ */
+
+#ifndef _DT_BINDINGS_CLOCK_STM32MP13_CLKSRC_H_
+#define _DT_BINDINGS_CLOCK_STM32MP13_CLKSRC_H_
+
+#define CMD_DIV		0
+#define CMD_MUX		1
+#define CMD_CLK		2
+#define CMD_RESERVED1	3
+
+#define CMD_SHIFT	26
+#define CMD_MASK	0xFC000000
+#define CMD_DATA_MASK	0x03FFFFFF
+
+#define DIV_ID_SHIFT	8
+#define DIV_ID_MASK	0x0000FF00
+
+#define DIV_DIVN_SHIFT	0
+#define DIV_DIVN_MASK	0x000000FF
+
+#define MUX_ID_SHIFT	4
+#define MUX_ID_MASK	0x00000FF0
+
+#define MUX_SEL_SHIFT	0
+#define MUX_SEL_MASK	0x0000000F
+
+#define CLK_ID_MASK	GENMASK_32(19, 11)
+#define CLK_ID_SHIFT	11
+#define CLK_ON_MASK	0x00000400
+#define CLK_ON_SHIFT	10
+#define CLK_DIV_MASK	GENMASK_32(9, 4)
+#define CLK_DIV_SHIFT	4
+#define CLK_SEL_MASK	GENMASK_32(3, 0)
+#define CLK_SEL_SHIFT	0
+
+#define DIV_PLL1DIVP	0
+#define DIV_PLL2DIVP	1
+#define DIV_PLL2DIVQ	2
+#define DIV_PLL2DIVR	3
+#define DIV_PLL3DIVP	4
+#define DIV_PLL3DIVQ	5
+#define DIV_PLL3DIVR	6
+#define DIV_PLL4DIVP	7
+#define DIV_PLL4DIVQ	8
+#define DIV_PLL4DIVR	9
+#define DIV_MPU		10
+#define DIV_AXI		11
+#define DIV_MLAHB	12
+#define DIV_APB1	13
+#define DIV_APB2	14
+#define DIV_APB3	15
+#define DIV_APB4	16
+#define DIV_APB5	17
+#define DIV_APB6	18
+#define DIV_RTC		19
+#define DIV_MCO1	20
+#define DIV_MCO2	21
+#define DIV_HSI		22
+#define DIV_TRACE	23
+#define DIV_ETH1PTP	24
+#define DIV_ETH2PTP	25
+#define DIV_MAX		26
+
+#define DIV(div_id, div)	((CMD_DIV << CMD_SHIFT) |\
+				 ((div_id) << DIV_ID_SHIFT |\
+				 (div)))
+
+#define CLKSRC(mux_id, sel)	((CMD_MUX << CMD_SHIFT) |\
+				 ((mux_id) << MUX_ID_SHIFT |\
+				 (sel)))
+
+/* MCO output is enable */
+#define MCO_SRC(mco_id, sel)	((CMD_CLK << CMD_SHIFT) |\
+				 (((mco_id) << CLK_ID_SHIFT) |\
+				 (sel)) | CLK_ON_MASK)
+
+#define MCO_DISABLED(mco_id)	((CMD_CLK << CMD_SHIFT) |\
+				 ((mco_id) << CLK_ID_SHIFT))
+
+/* CLK output is enable */
+#define CLK_SRC(clk_id, sel)	((CMD_CLK << CMD_SHIFT) |\
+				 (((clk_id) << CLK_ID_SHIFT) |\
+				 (sel)) | CLK_ON_MASK)
+
+#define CLK_DISABLED(clk_id)	((CMD_CLK << CMD_SHIFT) |\
+				 ((clk_id) << CLK_ID_SHIFT))
+
+#define MUX_MPU			0
+#define MUX_AXI			1
+#define MUX_MLAHB		2
+#define MUX_PLL12		3
+#define MUX_PLL3		4
+#define MUX_PLL4		5
+#define MUX_RTC			6
+#define MUX_MCO1		7
+#define MUX_MCO2		8
+#define MUX_CKPER		9
+#define MUX_KERNEL_BEGIN	10
+#define MUX_ADC1		10
+#define MUX_ADC2		11
+#define MUX_DCMIPP		12
+#define MUX_ETH1		13
+#define MUX_ETH2		14
+#define MUX_FDCAN		15
+#define MUX_FMC			16
+#define MUX_I2C12		17
+#define MUX_I2C3		18
+#define MUX_I2C4		19
+#define MUX_I2C5		20
+#define MUX_LPTIM1		21
+#define MUX_LPTIM2		22
+#define MUX_LPTIM3		23
+#define MUX_LPTIM45		24
+#define MUX_QSPI		25
+#define MUX_RNG1		26
+#define MUX_SAES		27
+#define MUX_SAI1		28
+#define MUX_SAI2		29
+#define MUX_SDMMC1		30
+#define MUX_SDMMC2		31
+#define MUX_SPDIF		32
+#define MUX_SPI1		33
+#define MUX_SPI23		34
+#define MUX_SPI4		35
+#define MUX_SPI5		36
+#define MUX_STGEN		37
+#define MUX_UART1		38
+#define MUX_UART2		39
+#define MUX_UART35		40
+#define MUX_UART4		41
+#define MUX_UART6		42
+#define MUX_UART78		43
+#define MUX_USBO		44
+#define MUX_USBPHY		45
+#define MUX_MAX			46
+
+#define CLK_MPU_HSI		CLKSRC(MUX_MPU, 0)
+#define CLK_MPU_HSE		CLKSRC(MUX_MPU, 1)
+#define CLK_MPU_PLL1P		CLKSRC(MUX_MPU, 2)
+#define CLK_MPU_PLL1P_DIV	CLKSRC(MUX_MPU, 3)
+
+#define CLK_AXI_HSI		CLKSRC(MUX_AXI, 0)
+#define CLK_AXI_HSE		CLKSRC(MUX_AXI, 1)
+#define CLK_AXI_PLL2P		CLKSRC(MUX_AXI, 2)
+
+#define CLK_MLAHBS_HSI		CLKSRC(MUX_MLAHB, 0)
+#define CLK_MLAHBS_HSE		CLKSRC(MUX_MLAHB, 1)
+#define CLK_MLAHBS_CSI		CLKSRC(MUX_MLAHB, 2)
+#define CLK_MLAHBS_PLL3		CLKSRC(MUX_MLAHB, 3)
+
+#define CLK_PLL12_HSI		CLKSRC(MUX_PLL12, 0)
+#define CLK_PLL12_HSE		CLKSRC(MUX_PLL12, 1)
+
+#define CLK_PLL3_HSI		CLKSRC(MUX_PLL3, 0)
+#define CLK_PLL3_HSE		CLKSRC(MUX_PLL3, 1)
+#define CLK_PLL3_CSI		CLKSRC(MUX_PLL3, 2)
+
+#define CLK_PLL4_HSI		CLKSRC(MUX_PLL4, 0)
+#define CLK_PLL4_HSE		CLKSRC(MUX_PLL4, 1)
+#define CLK_PLL4_CSI		CLKSRC(MUX_PLL4, 2)
+
+#define CLK_RTC_DISABLED	CLK_DISABLED(RTC)
+#define CLK_RTC_LSE		CLK_SRC(RTC, 1)
+#define CLK_RTC_LSI		CLK_SRC(RTC, 2)
+#define CLK_RTC_HSE		CLK_SRC(RTC, 3)
+
+#define CLK_MCO1_HSI		CLK_SRC(CK_MCO1, 0)
+#define CLK_MCO1_HSE		CLK_SRC(CK_MCO1, 1)
+#define CLK_MCO1_CSI		CLK_SRC(CK_MCO1, 2)
+#define CLK_MCO1_LSI		CLK_SRC(CK_MCO1, 3)
+#define CLK_MCO1_LSE		CLK_SRC(CK_MCO1, 4)
+#define CLK_MCO1_DISABLED	CLK_DISABLED(CK_MCO1)
+
+#define CLK_MCO2_MPU		CLK_SRC(CK_MCO2, 0)
+#define CLK_MCO2_AXI		CLK_SRC(CK_MCO2, 1)
+#define CLK_MCO2_MLAHB		CLK_SRC(CK_MCO2, 2)
+#define CLK_MCO2_PLL4		CLK_SRC(CK_MCO2, 3)
+#define CLK_MCO2_HSE		CLK_SRC(CK_MCO2, 4)
+#define CLK_MCO2_HSI		CLK_SRC(CK_MCO2, 5)
+#define CLK_MCO2_DISABLED	CLK_DISABLED(CK_MCO2)
+
+#define CLK_CKPER_HSI		CLKSRC(MUX_CKPER, 0)
+#define CLK_CKPER_CSI		CLKSRC(MUX_CKPER, 1)
+#define CLK_CKPER_HSE		CLKSRC(MUX_CKPER, 2)
+#define CLK_CKPER_DISABLED	CLKSRC(MUX_CKPER, 3)
+
+#define CLK_I2C12_PCLK1		CLKSRC(MUX_I2C12, 0)
+#define CLK_I2C12_PLL4R		CLKSRC(MUX_I2C12, 1)
+#define CLK_I2C12_HSI		CLKSRC(MUX_I2C12, 2)
+#define CLK_I2C12_CSI		CLKSRC(MUX_I2C12, 3)
+
+#define CLK_I2C3_PCLK6		CLKSRC(MUX_I2C3, 0)
+#define CLK_I2C3_PLL4R		CLKSRC(MUX_I2C3, 1)
+#define CLK_I2C3_HSI		CLKSRC(MUX_I2C3, 2)
+#define CLK_I2C3_CSI		CLKSRC(MUX_I2C3, 3)
+
+#define CLK_I2C4_PCLK6		CLKSRC(MUX_I2C4, 0)
+#define CLK_I2C4_PLL4R		CLKSRC(MUX_I2C4, 1)
+#define CLK_I2C4_HSI		CLKSRC(MUX_I2C4, 2)
+#define CLK_I2C4_CSI		CLKSRC(MUX_I2C4, 3)
+
+#define CLK_I2C5_PCLK6		CLKSRC(MUX_I2C5, 0)
+#define CLK_I2C5_PLL4R		CLKSRC(MUX_I2C5, 1)
+#define CLK_I2C5_HSI		CLKSRC(MUX_I2C5, 2)
+#define CLK_I2C5_CSI		CLKSRC(MUX_I2C5, 3)
+
+#define CLK_SPI1_PLL4P		CLKSRC(MUX_SPI1, 0)
+#define CLK_SPI1_PLL3Q		CLKSRC(MUX_SPI1, 1)
+#define CLK_SPI1_I2SCKIN	CLKSRC(MUX_SPI1, 2)
+#define CLK_SPI1_CKPER		CLKSRC(MUX_SPI1, 3)
+#define CLK_SPI1_PLL3R		CLKSRC(MUX_SPI1, 4)
+
+#define CLK_SPI23_PLL4P		CLKSRC(MUX_SPI23, 0)
+#define CLK_SPI23_PLL3Q		CLKSRC(MUX_SPI23, 1)
+#define CLK_SPI23_I2SCKIN	CLKSRC(MUX_SPI23, 2)
+#define CLK_SPI23_CKPER		CLKSRC(MUX_SPI23, 3)
+#define CLK_SPI23_PLL3R		CLKSRC(MUX_SPI23, 4)
+
+#define CLK_SPI4_PCLK6		CLKSRC(MUX_SPI4, 0)
+#define CLK_SPI4_PLL4Q		CLKSRC(MUX_SPI4, 1)
+#define CLK_SPI4_HSI		CLKSRC(MUX_SPI4, 2)
+#define CLK_SPI4_CSI		CLKSRC(MUX_SPI4, 3)
+#define CLK_SPI4_HSE		CLKSRC(MUX_SPI4, 4)
+#define CLK_SPI4_I2SCKIN	CLKSRC(MUX_SPI4, 5)
+
+#define CLK_SPI5_PCLK6		CLKSRC(MUX_SPI5, 0)
+#define CLK_SPI5_PLL4Q		CLKSRC(MUX_SPI5, 1)
+#define CLK_SPI5_HSI		CLKSRC(MUX_SPI5, 2)
+#define CLK_SPI5_CSI		CLKSRC(MUX_SPI5, 3)
+#define CLK_SPI5_HSE		CLKSRC(MUX_SPI5, 4)
+
+#define CLK_UART1_PCLK6		CLKSRC(MUX_UART1, 0)
+#define CLK_UART1_PLL3Q		CLKSRC(MUX_UART1, 1)
+#define CLK_UART1_HSI		CLKSRC(MUX_UART1, 2)
+#define CLK_UART1_CSI		CLKSRC(MUX_UART1, 3)
+#define CLK_UART1_PLL4Q		CLKSRC(MUX_UART1, 4)
+#define CLK_UART1_HSE		CLKSRC(MUX_UART1, 5)
+
+#define CLK_UART2_PCLK6		CLKSRC(MUX_UART2, 0)
+#define CLK_UART2_PLL3Q		CLKSRC(MUX_UART2, 1)
+#define CLK_UART2_HSI		CLKSRC(MUX_UART2, 2)
+#define CLK_UART2_CSI		CLKSRC(MUX_UART2, 3)
+#define CLK_UART2_PLL4Q		CLKSRC(MUX_UART2, 4)
+#define CLK_UART2_HSE		CLKSRC(MUX_UART2, 5)
+
+#define CLK_UART35_PCLK1	CLKSRC(MUX_UART35, 0)
+#define CLK_UART35_PLL4Q	CLKSRC(MUX_UART35, 1)
+#define CLK_UART35_HSI		CLKSRC(MUX_UART35, 2)
+#define CLK_UART35_CSI		CLKSRC(MUX_UART35, 3)
+#define CLK_UART35_HSE		CLKSRC(MUX_UART35, 4)
+
+#define CLK_UART4_PCLK1		CLKSRC(MUX_UART4, 0)
+#define CLK_UART4_PLL4Q		CLKSRC(MUX_UART4, 1)
+#define CLK_UART4_HSI		CLKSRC(MUX_UART4, 2)
+#define CLK_UART4_CSI		CLKSRC(MUX_UART4, 3)
+#define CLK_UART4_HSE		CLKSRC(MUX_UART4, 4)
+
+#define CLK_UART6_PCLK2		CLKSRC(MUX_UART6, 0)
+#define CLK_UART6_PLL4Q		CLKSRC(MUX_UART6, 1)
+#define CLK_UART6_HSI		CLKSRC(MUX_UART6, 2)
+#define CLK_UART6_CSI		CLKSRC(MUX_UART6, 3)
+#define CLK_UART6_HSE		CLKSRC(MUX_UART6, 4)
+
+#define CLK_UART78_PCLK1	CLKSRC(MUX_UART78, 0)
+#define CLK_UART78_PLL4Q	CLKSRC(MUX_UART78, 1)
+#define CLK_UART78_HSI		CLKSRC(MUX_UART78, 2)
+#define CLK_UART78_CSI		CLKSRC(MUX_UART78, 3)
+#define CLK_UART78_HSE		CLKSRC(MUX_UART78, 4)
+
+#define CLK_LPTIM1_PCLK1	CLKSRC(MUX_LPTIM1, 0)
+#define CLK_LPTIM1_PLL4P	CLKSRC(MUX_LPTIM1, 1)
+#define CLK_LPTIM1_PLL3Q	CLKSRC(MUX_LPTIM1, 2)
+#define CLK_LPTIM1_LSE		CLKSRC(MUX_LPTIM1, 3)
+#define CLK_LPTIM1_LSI		CLKSRC(MUX_LPTIM1, 4)
+#define CLK_LPTIM1_CKPER	CLKSRC(MUX_LPTIM1, 5)
+
+#define CLK_LPTIM2_PCLK3	CLKSRC(MUX_LPTIM2, 0)
+#define CLK_LPTIM2_PLL4Q	CLKSRC(MUX_LPTIM2, 1)
+#define CLK_LPTIM2_CKPER	CLKSRC(MUX_LPTIM2, 2)
+#define CLK_LPTIM2_LSE		CLKSRC(MUX_LPTIM2, 3)
+#define CLK_LPTIM2_LSI		CLKSRC(MUX_LPTIM2, 4)
+
+#define CLK_LPTIM3_PCLK3	CLKSRC(MUX_LPTIM3, 0)
+#define CLK_LPTIM3_PLL4Q	CLKSRC(MUX_LPTIM3, 1)
+#define CLK_LPTIM3_CKPER	CLKSRC(MUX_LPTIM3, 2)
+#define CLK_LPTIM3_LSE		CLKSRC(MUX_LPTIM3, 3)
+#define CLK_LPTIM3_LSI		CLKSRC(MUX_LPTIM3, 4)
+
+#define CLK_LPTIM45_PCLK3	CLKSRC(MUX_LPTIM45, 0)
+#define CLK_LPTIM45_PLL4P	CLKSRC(MUX_LPTIM45, 1)
+#define CLK_LPTIM45_PLL3Q	CLKSRC(MUX_LPTIM45, 2)
+#define CLK_LPTIM45_LSE		CLKSRC(MUX_LPTIM45, 3)
+#define CLK_LPTIM45_LSI		CLKSRC(MUX_LPTIM45, 4)
+#define CLK_LPTIM45_CKPER	CLKSRC(MUX_LPTIM45, 5)
+
+#define CLK_SAI1_PLL4Q		CLKSRC(MUX_SAI1, 0)
+#define CLK_SAI1_PLL3Q		CLKSRC(MUX_SAI1, 1)
+#define CLK_SAI1_I2SCKIN	CLKSRC(MUX_SAI1, 2)
+#define CLK_SAI1_CKPER		CLKSRC(MUX_SAI1, 3)
+#define CLK_SAI1_PLL3R		CLKSRC(MUX_SAI1, 4)
+
+#define CLK_SAI2_PLL4Q		CLKSRC(MUX_SAI2, 0)
+#define CLK_SAI2_PLL3Q		CLKSRC(MUX_SAI2, 1)
+#define CLK_SAI2_I2SCKIN	CLKSRC(MUX_SAI2, 2)
+#define CLK_SAI2_CKPER		CLKSRC(MUX_SAI2, 3)
+#define CLK_SAI2_SPDIF		CLKSRC(MUX_SAI2, 4)
+#define CLK_SAI2_PLL3R		CLKSRC(MUX_SAI2, 5)
+
+#define CLK_FDCAN_HSE		CLKSRC(MUX_FDCAN, 0)
+#define CLK_FDCAN_PLL3Q		CLKSRC(MUX_FDCAN, 1)
+#define CLK_FDCAN_PLL4Q		CLKSRC(MUX_FDCAN, 2)
+#define CLK_FDCAN_PLL4R		CLKSRC(MUX_FDCAN, 3)
+
+#define CLK_SPDIF_PLL4P		CLKSRC(MUX_SPDIF, 0)
+#define CLK_SPDIF_PLL3Q		CLKSRC(MUX_SPDIF, 1)
+#define CLK_SPDIF_HSI		CLKSRC(MUX_SPDIF, 2)
+
+#define CLK_ADC1_PLL4R		CLKSRC(MUX_ADC1, 0)
+#define CLK_ADC1_CKPER		CLKSRC(MUX_ADC1, 1)
+#define CLK_ADC1_PLL3Q		CLKSRC(MUX_ADC1, 2)
+
+#define CLK_ADC2_PLL4R		CLKSRC(MUX_ADC2, 0)
+#define CLK_ADC2_CKPER		CLKSRC(MUX_ADC2, 1)
+#define CLK_ADC2_PLL3Q		CLKSRC(MUX_ADC2, 2)
+
+#define CLK_SDMMC1_HCLK6	CLKSRC(MUX_SDMMC1, 0)
+#define CLK_SDMMC1_PLL3R	CLKSRC(MUX_SDMMC1, 1)
+#define CLK_SDMMC1_PLL4P	CLKSRC(MUX_SDMMC1, 2)
+#define CLK_SDMMC1_HSI		CLKSRC(MUX_SDMMC1, 3)
+
+#define CLK_SDMMC2_HCLK6	CLKSRC(MUX_SDMMC2, 0)
+#define CLK_SDMMC2_PLL3R	CLKSRC(MUX_SDMMC2, 1)
+#define CLK_SDMMC2_PLL4P	CLKSRC(MUX_SDMMC2, 2)
+#define CLK_SDMMC2_HSI		CLKSRC(MUX_SDMMC2, 3)
+
+#define CLK_ETH1_PLL4P		CLKSRC(MUX_ETH1, 0)
+#define CLK_ETH1_PLL3Q		CLKSRC(MUX_ETH1, 1)
+
+#define CLK_ETH2_PLL4P		CLKSRC(MUX_ETH2, 0)
+#define CLK_ETH2_PLL3Q		CLKSRC(MUX_ETH2, 1)
+
+#define CLK_USBPHY_HSE		CLKSRC(MUX_USBPHY, 0)
+#define CLK_USBPHY_PLL4R	CLKSRC(MUX_USBPHY, 1)
+#define CLK_USBPHY_HSE_DIV2	CLKSRC(MUX_USBPHY, 2)
+
+#define CLK_USBO_PLL4R		CLKSRC(MUX_USBO, 0)
+#define CLK_USBO_USBPHY		CLKSRC(MUX_USBO, 1)
+
+#define CLK_QSPI_ACLK		CLKSRC(MUX_QSPI, 0)
+#define CLK_QSPI_PLL3R		CLKSRC(MUX_QSPI, 1)
+#define CLK_QSPI_PLL4P		CLKSRC(MUX_QSPI, 2)
+#define CLK_QSPI_CKPER		CLKSRC(MUX_QSPI, 3)
+
+#define CLK_FMC_ACLK		CLKSRC(MUX_FMC, 0)
+#define CLK_FMC_PLL3R		CLKSRC(MUX_FMC, 1)
+#define CLK_FMC_PLL4P		CLKSRC(MUX_FMC, 2)
+#define CLK_FMC_CKPER		CLKSRC(MUX_FMC, 3)
+
+#define CLK_RNG1_CSI		CLKSRC(MUX_RNG1, 0)
+#define CLK_RNG1_PLL4R		CLKSRC(MUX_RNG1, 1)
+/* WARNING: POSITION 2 OF RNG1 MUX IS RESERVED */
+#define CLK_RNG1_LSI		CLKSRC(MUX_RNG1, 3)
+
+#define CLK_STGEN_HSI		CLKSRC(MUX_STGEN, 0)
+#define CLK_STGEN_HSE		CLKSRC(MUX_STGEN, 1)
+
+#define CLK_DCMIPP_ACLK		CLKSRC(MUX_DCMIPP, 0)
+#define CLK_DCMIPP_PLL2Q	CLKSRC(MUX_DCMIPP, 1)
+#define CLK_DCMIPP_PLL4P	CLKSRC(MUX_DCMIPP, 2)
+#define CLK_DCMIPP_CKPER	CLKSRC(MUX_DCMIPP, 3)
+
+#define CLK_SAES_AXI		CLKSRC(MUX_SAES, 0)
+#define CLK_SAES_CKPER		CLKSRC(MUX_SAES, 1)
+#define CLK_SAES_PLL4R		CLKSRC(MUX_SAES, 2)
+#define CLK_SAES_LSI		CLKSRC(MUX_SAES, 3)
+
+/* PLL output is enable when x=1, with x=p,q or r */
+#define PQR(p, q, r)	(((p) & 1) | (((q) & 1) << 1) | (((r) & 1) << 2))
+
+/* define for st,pll /csg */
+#define SSCG_MODE_CENTER_SPREAD	0
+#define SSCG_MODE_DOWN_SPREAD	1
+
+/* define for st,drive */
+#define LSEDRV_LOWEST		0
+#define LSEDRV_MEDIUM_LOW	1
+#define LSEDRV_MEDIUM_HIGH	2
+#define LSEDRV_HIGHEST		3
+
+#endif /* _DT_BINDINGS_CLOCK_STM32MP13_CLKSRC_H_ */
diff --git a/include/dt-bindings/clock/stm32mp15-clks.h b/include/dt-bindings/clock/stm32mp15-clks.h
new file mode 100644
index 000000000..7fa8cbad6
--- /dev/null
+++ b/include/dt-bindings/clock/stm32mp15-clks.h
@@ -0,0 +1,278 @@
+/* SPDX-License-Identifier: GPL-2.0+ or BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32MP1_CLKS_H_
+#define _DT_BINDINGS_STM32MP1_CLKS_H_
+
+/* OSCILLATOR clocks */
+#define CK_HSE		0
+#define CK_CSI		1
+#define CK_LSI		2
+#define CK_LSE		3
+#define CK_HSI		4
+#define CK_HSE_DIV2	5
+
+/* Bus clocks */
+#define TIM2		6
+#define TIM3		7
+#define TIM4		8
+#define TIM5		9
+#define TIM6		10
+#define TIM7		11
+#define TIM12		12
+#define TIM13		13
+#define TIM14		14
+#define LPTIM1		15
+#define SPI2		16
+#define SPI3		17
+#define USART2		18
+#define USART3		19
+#define UART4		20
+#define UART5		21
+#define UART7		22
+#define UART8		23
+#define I2C1		24
+#define I2C2		25
+#define I2C3		26
+#define I2C5		27
+#define SPDIF		28
+#define CEC		29
+#define DAC12		30
+#define MDIO		31
+#define TIM1		32
+#define TIM8		33
+#define TIM15		34
+#define TIM16		35
+#define TIM17		36
+#define SPI1		37
+#define SPI4		38
+#define SPI5		39
+#define USART6		40
+#define SAI1		41
+#define SAI2		42
+#define SAI3		43
+#define DFSDM		44
+#define FDCAN		45
+#define LPTIM2		46
+#define LPTIM3		47
+#define LPTIM4		48
+#define LPTIM5		49
+#define SAI4		50
+#define SYSCFG		51
+#define VREF		52
+#define TMPSENS		53
+#define PMBCTRL		54
+#define HDP		55
+#define LTDC		56
+#define DSI		57
+#define IWDG2		58
+#define USBPHY		59
+#define STGENRO		60
+#define SPI6		61
+#define I2C4		62
+#define I2C6		63
+#define USART1		64
+#define RTCAPB		65
+#define TZC1		66
+#define TZPC		67
+#define IWDG1		68
+#define BSEC		69
+#define STGEN		70
+#define DMA1		71
+#define DMA2		72
+#define DMAMUX		73
+#define ADC12		74
+#define USBO		75
+#define SDMMC3		76
+#define DCMI		77
+#define CRYP2		78
+#define HASH2		79
+#define RNG2		80
+#define CRC2		81
+#define HSEM		82
+#define IPCC		83
+#define GPIOA		84
+#define GPIOB		85
+#define GPIOC		86
+#define GPIOD		87
+#define GPIOE		88
+#define GPIOF		89
+#define GPIOG		90
+#define GPIOH		91
+#define GPIOI		92
+#define GPIOJ		93
+#define GPIOK		94
+#define GPIOZ		95
+#define CRYP1		96
+#define HASH1		97
+#define RNG1		98
+#define BKPSRAM		99
+#define MDMA		100
+#define GPU		101
+#define ETHCK		102
+#define ETHTX		103
+#define ETHRX		104
+#define ETHMAC		105
+#define FMC		106
+#define QSPI		107
+#define SDMMC1		108
+#define SDMMC2		109
+#define CRC1		110
+#define USBH		111
+#define ETHSTP		112
+#define TZC2		113
+
+/* Kernel clocks */
+#define SDMMC1_K	118
+#define SDMMC2_K	119
+#define SDMMC3_K	120
+#define FMC_K		121
+#define QSPI_K		122
+#define ETHCK_K		123
+#define RNG1_K		124
+#define RNG2_K		125
+#define GPU_K		126
+#define USBPHY_K	127
+#define STGEN_K		128
+#define SPDIF_K		129
+#define SPI1_K		130
+#define SPI2_K		131
+#define SPI3_K		132
+#define SPI4_K		133
+#define SPI5_K		134
+#define SPI6_K		135
+#define CEC_K		136
+#define I2C1_K		137
+#define I2C2_K		138
+#define I2C3_K		139
+#define I2C4_K		140
+#define I2C5_K		141
+#define I2C6_K		142
+#define LPTIM1_K	143
+#define LPTIM2_K	144
+#define LPTIM3_K	145
+#define LPTIM4_K	146
+#define LPTIM5_K	147
+#define USART1_K	148
+#define USART2_K	149
+#define USART3_K	150
+#define UART4_K		151
+#define UART5_K		152
+#define USART6_K	153
+#define UART7_K		154
+#define UART8_K		155
+#define DFSDM_K		156
+#define FDCAN_K		157
+#define SAI1_K		158
+#define SAI2_K		159
+#define SAI3_K		160
+#define SAI4_K		161
+#define ADC12_K		162
+#define DSI_K		163
+#define DSI_PX		164
+#define ADFSDM_K	165
+#define USBO_K		166
+#define LTDC_PX		167
+#define DAC12_K		168
+#define ETHPTP_K	169
+
+/* PLL */
+#define PLL1		176
+#define PLL2		177
+#define PLL3		178
+#define PLL4		179
+
+/* ODF */
+#define PLL1_P		180
+#define PLL1_Q		181
+#define PLL1_R		182
+#define PLL2_P		183
+#define PLL2_Q		184
+#define PLL2_R		185
+#define PLL3_P		186
+#define PLL3_Q		187
+#define PLL3_R		188
+#define PLL4_P		189
+#define PLL4_Q		190
+#define PLL4_R		191
+
+/* AUX */
+#define RTC		192
+
+/* MCLK */
+#define CK_PER		193
+#define CK_MPU		194
+#define CK_AXI		195
+#define CK_MCU		196
+
+/* Time base */
+#define TIM2_K		197
+#define TIM3_K		198
+#define TIM4_K		199
+#define TIM5_K		200
+#define TIM6_K		201
+#define TIM7_K		202
+#define TIM12_K		203
+#define TIM13_K		204
+#define TIM14_K		205
+#define TIM1_K		206
+#define TIM8_K		207
+#define TIM15_K		208
+#define TIM16_K		209
+#define TIM17_K		210
+
+/* MCO clocks */
+#define CK_MCO1		211
+#define CK_MCO2		212
+
+/* TRACE & DEBUG clocks */
+#define CK_DBG		214
+#define CK_TRACE	215
+
+/* DDR */
+#define DDRC1		220
+#define DDRC1LP		221
+#define DDRC2		222
+#define DDRC2LP		223
+#define DDRPHYC		224
+#define DDRPHYCLP	225
+#define DDRCAPB		226
+#define DDRCAPBLP	227
+#define AXIDCG		228
+#define DDRPHYCAPB	229
+#define DDRPHYCAPBLP	230
+#define DDRPERFM	231
+
+#define STM32MP1_LAST_CLK 232
+
+/* SCMI clock identifiers */
+#define CK_SCMI0_HSE		0
+#define CK_SCMI0_HSI		1
+#define CK_SCMI0_CSI		2
+#define CK_SCMI0_LSE		3
+#define CK_SCMI0_LSI		4
+#define CK_SCMI0_PLL2_Q		5
+#define CK_SCMI0_PLL2_R		6
+#define CK_SCMI0_MPU		7
+#define CK_SCMI0_AXI		8
+#define CK_SCMI0_BSEC		9
+#define CK_SCMI0_CRYP1		10
+#define CK_SCMI0_GPIOZ		11
+#define CK_SCMI0_HASH1		12
+#define CK_SCMI0_I2C4		13
+#define CK_SCMI0_I2C6		14
+#define CK_SCMI0_IWDG1		15
+#define CK_SCMI0_RNG1		16
+#define CK_SCMI0_RTC		17
+#define CK_SCMI0_RTCAPB		18
+#define CK_SCMI0_SPI6		19
+#define CK_SCMI0_USART1		20
+
+#define CK_SCMI1_PLL3_Q		0
+#define CK_SCMI1_PLL3_R		1
+#define CK_SCMI1_MCU		2
+
+#endif /* _DT_BINDINGS_STM32MP1_CLKS_H_ */
diff --git a/include/dt-bindings/clock/stm32mp15-clksrc.h b/include/dt-bindings/clock/stm32mp15-clksrc.h
new file mode 100644
index 000000000..1f7a50751
--- /dev/null
+++ b/include/dt-bindings/clock/stm32mp15-clksrc.h
@@ -0,0 +1,282 @@
+/* SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause */
+/*
+ * Copyright (C) 2017, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef _DT_BINDINGS_CLOCK_STM32MP15_CLKSRC_H_
+#define _DT_BINDINGS_CLOCK_STM32MP15_CLKSRC_H_
+
+/* PLL output is enable when x=1, with x=p,q or r */
+#define PQR(p, q, r)	(((p) & 1) | (((q) & 1) << 1) | (((r) & 1) << 2))
+
+/* st,clksrc: mandatory clock source */
+#define CLK_MPU_HSI		0x00000200
+#define CLK_MPU_HSE		0x00000201
+#define CLK_MPU_PLL1P		0x00000202
+#define CLK_MPU_PLL1P_DIV	0x00000203
+
+#define CLK_AXI_HSI		0x00000240
+#define CLK_AXI_HSE		0x00000241
+#define CLK_AXI_PLL2P		0x00000242
+
+#define CLK_MCU_HSI		0x00000480
+#define CLK_MCU_HSE		0x00000481
+#define CLK_MCU_CSI		0x00000482
+#define CLK_MCU_PLL3P		0x00000483
+
+#define CLK_PLL12_HSI		0x00000280
+#define CLK_PLL12_HSE		0x00000281
+
+#define CLK_PLL3_HSI		0x00008200
+#define CLK_PLL3_HSE		0x00008201
+#define CLK_PLL3_CSI		0x00008202
+
+#define CLK_PLL4_HSI		0x00008240
+#define CLK_PLL4_HSE		0x00008241
+#define CLK_PLL4_CSI		0x00008242
+#define CLK_PLL4_I2SCKIN	0x00008243
+
+#define CLK_RTC_DISABLED	0x00001400
+#define CLK_RTC_LSE		0x00001401
+#define CLK_RTC_LSI		0x00001402
+#define CLK_RTC_HSE		0x00001403
+
+#define CLK_MCO1_HSI		0x00008000
+#define CLK_MCO1_HSE		0x00008001
+#define CLK_MCO1_CSI		0x00008002
+#define CLK_MCO1_LSI		0x00008003
+#define CLK_MCO1_LSE		0x00008004
+#define CLK_MCO1_DISABLED	0x0000800F
+
+#define CLK_MCO2_MPU		0x00008040
+#define CLK_MCO2_AXI		0x00008041
+#define CLK_MCO2_MCU		0x00008042
+#define CLK_MCO2_PLL4P		0x00008043
+#define CLK_MCO2_HSE		0x00008044
+#define CLK_MCO2_HSI		0x00008045
+#define CLK_MCO2_DISABLED	0x0000804F
+
+/* st,pkcs: peripheral kernel clock source */
+
+#define CLK_I2C12_PCLK1		0x00008C00
+#define CLK_I2C12_PLL4R		0x00008C01
+#define CLK_I2C12_HSI		0x00008C02
+#define CLK_I2C12_CSI		0x00008C03
+#define CLK_I2C12_DISABLED	0x00008C07
+
+#define CLK_I2C35_PCLK1		0x00008C40
+#define CLK_I2C35_PLL4R		0x00008C41
+#define CLK_I2C35_HSI		0x00008C42
+#define CLK_I2C35_CSI		0x00008C43
+#define CLK_I2C35_DISABLED	0x00008C47
+
+#define CLK_I2C46_PCLK5		0x00000C00
+#define CLK_I2C46_PLL3Q		0x00000C01
+#define CLK_I2C46_HSI		0x00000C02
+#define CLK_I2C46_CSI		0x00000C03
+#define CLK_I2C46_DISABLED	0x00000C07
+
+#define CLK_SAI1_PLL4Q		0x00008C80
+#define CLK_SAI1_PLL3Q		0x00008C81
+#define CLK_SAI1_I2SCKIN	0x00008C82
+#define CLK_SAI1_CKPER		0x00008C83
+#define CLK_SAI1_PLL3R		0x00008C84
+#define CLK_SAI1_DISABLED	0x00008C87
+
+#define CLK_SAI2_PLL4Q		0x00008CC0
+#define CLK_SAI2_PLL3Q		0x00008CC1
+#define CLK_SAI2_I2SCKIN	0x00008CC2
+#define CLK_SAI2_CKPER		0x00008CC3
+#define CLK_SAI2_SPDIF		0x00008CC4
+#define CLK_SAI2_PLL3R		0x00008CC5
+#define CLK_SAI2_DISABLED	0x00008CC7
+
+#define CLK_SAI3_PLL4Q		0x00008D00
+#define CLK_SAI3_PLL3Q		0x00008D01
+#define CLK_SAI3_I2SCKIN	0x00008D02
+#define CLK_SAI3_CKPER		0x00008D03
+#define CLK_SAI3_PLL3R		0x00008D04
+#define CLK_SAI3_DISABLED	0x00008D07
+
+#define CLK_SAI4_PLL4Q		0x00008D40
+#define CLK_SAI4_PLL3Q		0x00008D41
+#define CLK_SAI4_I2SCKIN	0x00008D42
+#define CLK_SAI4_CKPER		0x00008D43
+#define CLK_SAI4_PLL3R		0x00008D44
+#define CLK_SAI4_DISABLED	0x00008D47
+
+#define CLK_SPI2S1_PLL4P	0x00008D80
+#define CLK_SPI2S1_PLL3Q	0x00008D81
+#define CLK_SPI2S1_I2SCKIN	0x00008D82
+#define CLK_SPI2S1_CKPER	0x00008D83
+#define CLK_SPI2S1_PLL3R	0x00008D84
+#define CLK_SPI2S1_DISABLED	0x00008D87
+
+#define CLK_SPI2S23_PLL4P	0x00008DC0
+#define CLK_SPI2S23_PLL3Q	0x00008DC1
+#define CLK_SPI2S23_I2SCKIN	0x00008DC2
+#define CLK_SPI2S23_CKPER	0x00008DC3
+#define CLK_SPI2S23_PLL3R	0x00008DC4
+#define CLK_SPI2S23_DISABLED	0x00008DC7
+
+#define CLK_SPI45_PCLK2		0x00008E00
+#define CLK_SPI45_PLL4Q		0x00008E01
+#define CLK_SPI45_HSI		0x00008E02
+#define CLK_SPI45_CSI		0x00008E03
+#define CLK_SPI45_HSE		0x00008E04
+#define CLK_SPI45_DISABLED	0x00008E07
+
+#define CLK_SPI6_PCLK5		0x00000C40
+#define CLK_SPI6_PLL4Q		0x00000C41
+#define CLK_SPI6_HSI		0x00000C42
+#define CLK_SPI6_CSI		0x00000C43
+#define CLK_SPI6_HSE		0x00000C44
+#define CLK_SPI6_PLL3Q		0x00000C45
+#define CLK_SPI6_DISABLED	0x00000C47
+
+#define CLK_UART6_PCLK2		0x00008E40
+#define CLK_UART6_PLL4Q		0x00008E41
+#define CLK_UART6_HSI		0x00008E42
+#define CLK_UART6_CSI		0x00008E43
+#define CLK_UART6_HSE		0x00008E44
+#define CLK_UART6_DISABLED	0x00008E47
+
+#define CLK_UART24_PCLK1	0x00008E80
+#define CLK_UART24_PLL4Q	0x00008E81
+#define CLK_UART24_HSI		0x00008E82
+#define CLK_UART24_CSI		0x00008E83
+#define CLK_UART24_HSE		0x00008E84
+#define CLK_UART24_DISABLED	0x00008E87
+
+#define CLK_UART35_PCLK1	0x00008EC0
+#define CLK_UART35_PLL4Q	0x00008EC1
+#define CLK_UART35_HSI		0x00008EC2
+#define CLK_UART35_CSI		0x00008EC3
+#define CLK_UART35_HSE		0x00008EC4
+#define CLK_UART35_DISABLED	0x00008EC7
+
+#define CLK_UART78_PCLK1	0x00008F00
+#define CLK_UART78_PLL4Q	0x00008F01
+#define CLK_UART78_HSI		0x00008F02
+#define CLK_UART78_CSI		0x00008F03
+#define CLK_UART78_HSE		0x00008F04
+#define CLK_UART78_DISABLED	0x00008F07
+
+#define CLK_UART1_PCLK5		0x00000C80
+#define CLK_UART1_PLL3Q		0x00000C81
+#define CLK_UART1_HSI		0x00000C82
+#define CLK_UART1_CSI		0x00000C83
+#define CLK_UART1_PLL4Q		0x00000C84
+#define CLK_UART1_HSE		0x00000C85
+#define CLK_UART1_DISABLED	0x00000C87
+
+#define CLK_SDMMC12_HCLK6	0x00008F40
+#define CLK_SDMMC12_PLL3R	0x00008F41
+#define CLK_SDMMC12_PLL4P	0x00008F42
+#define CLK_SDMMC12_HSI		0x00008F43
+#define CLK_SDMMC12_DISABLED	0x00008F47
+
+#define CLK_SDMMC3_HCLK2	0x00008F80
+#define CLK_SDMMC3_PLL3R	0x00008F81
+#define CLK_SDMMC3_PLL4P	0x00008F82
+#define CLK_SDMMC3_HSI		0x00008F83
+#define CLK_SDMMC3_DISABLED	0x00008F87
+
+#define CLK_ETH_PLL4P		0x00008FC0
+#define CLK_ETH_PLL3Q		0x00008FC1
+#define CLK_ETH_DISABLED	0x00008FC3
+
+#define CLK_QSPI_ACLK		0x00009000
+#define CLK_QSPI_PLL3R		0x00009001
+#define CLK_QSPI_PLL4P		0x00009002
+#define CLK_QSPI_CKPER		0x00009003
+
+#define CLK_FMC_ACLK		0x00009040
+#define CLK_FMC_PLL3R		0x00009041
+#define CLK_FMC_PLL4P		0x00009042
+#define CLK_FMC_CKPER		0x00009043
+
+#define CLK_FDCAN_HSE		0x000090C0
+#define CLK_FDCAN_PLL3Q		0x000090C1
+#define CLK_FDCAN_PLL4Q		0x000090C2
+#define CLK_FDCAN_PLL4R		0x000090C3
+
+#define CLK_SPDIF_PLL4P		0x00009140
+#define CLK_SPDIF_PLL3Q		0x00009141
+#define CLK_SPDIF_HSI		0x00009142
+#define CLK_SPDIF_DISABLED	0x00009143
+
+#define CLK_CEC_LSE		0x00009180
+#define CLK_CEC_LSI		0x00009181
+#define CLK_CEC_CSI_DIV122	0x00009182
+#define CLK_CEC_DISABLED	0x00009183
+
+#define CLK_USBPHY_HSE		0x000091C0
+#define CLK_USBPHY_PLL4R	0x000091C1
+#define CLK_USBPHY_HSE_DIV2	0x000091C2
+#define CLK_USBPHY_DISABLED	0x000091C3
+
+#define CLK_USBO_PLL4R		0x800091C0
+#define CLK_USBO_USBPHY		0x800091C1
+
+#define CLK_RNG1_CSI		0x00000CC0
+#define CLK_RNG1_PLL4R		0x00000CC1
+#define CLK_RNG1_LSE		0x00000CC2
+#define CLK_RNG1_LSI		0x00000CC3
+
+#define CLK_RNG2_CSI		0x00009200
+#define CLK_RNG2_PLL4R		0x00009201
+#define CLK_RNG2_LSE		0x00009202
+#define CLK_RNG2_LSI		0x00009203
+
+#define CLK_CKPER_HSI		0x00000D00
+#define CLK_CKPER_CSI		0x00000D01
+#define CLK_CKPER_HSE		0x00000D02
+#define CLK_CKPER_DISABLED	0x00000D03
+
+#define CLK_STGEN_HSI		0x00000D40
+#define CLK_STGEN_HSE		0x00000D41
+#define CLK_STGEN_DISABLED	0x00000D43
+
+#define CLK_DSI_DSIPLL		0x00009240
+#define CLK_DSI_PLL4P		0x00009241
+
+#define CLK_ADC_PLL4R		0x00009280
+#define CLK_ADC_CKPER		0x00009281
+#define CLK_ADC_PLL3Q		0x00009282
+#define CLK_ADC_DISABLED	0x00009283
+
+#define CLK_LPTIM45_PCLK3	0x000092C0
+#define CLK_LPTIM45_PLL4P	0x000092C1
+#define CLK_LPTIM45_PLL3Q	0x000092C2
+#define CLK_LPTIM45_LSE		0x000092C3
+#define CLK_LPTIM45_LSI		0x000092C4
+#define CLK_LPTIM45_CKPER	0x000092C5
+#define CLK_LPTIM45_DISABLED	0x000092C7
+
+#define CLK_LPTIM23_PCLK3	0x00009300
+#define CLK_LPTIM23_PLL4Q	0x00009301
+#define CLK_LPTIM23_CKPER	0x00009302
+#define CLK_LPTIM23_LSE		0x00009303
+#define CLK_LPTIM23_LSI		0x00009304
+#define CLK_LPTIM23_DISABLED	0x00009307
+
+#define CLK_LPTIM1_PCLK1	0x00009340
+#define CLK_LPTIM1_PLL4P	0x00009341
+#define CLK_LPTIM1_PLL3Q	0x00009342
+#define CLK_LPTIM1_LSE		0x00009343
+#define CLK_LPTIM1_LSI		0x00009344
+#define CLK_LPTIM1_CKPER	0x00009345
+#define CLK_LPTIM1_DISABLED	0x00009347
+
+/* define for st,pll /csg */
+#define SSCG_MODE_CENTER_SPREAD	0
+#define SSCG_MODE_DOWN_SPREAD	1
+
+/* define for st,drive */
+#define LSEDRV_LOWEST		0
+#define LSEDRV_MEDIUM_LOW	1
+#define LSEDRV_MEDIUM_HIGH	2
+#define LSEDRV_HIGHEST		3
+
+#endif
diff --git a/include/dt-bindings/clock/stm32mp2-clks.h b/include/dt-bindings/clock/stm32mp2-clks.h
new file mode 100644
index 000000000..1d34f6aa4
--- /dev/null
+++ b/include/dt-bindings/clock/stm32mp2-clks.h
@@ -0,0 +1,462 @@
+/* SPDX-License-Identifier: GPL-2.0 or BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
+ */
+
+#ifndef DT_BINDINGS_STM32MP2_CLKS_H
+#define DT_BINDINGS_STM32MP2_CLKS_H
+
+/* INTERNAL/EXTERNAL OSCILLATORS */
+#define HSI_CK			0
+#define HSE_CK			1
+#define MSI_CK			2
+#define LSI_CK			3
+#define LSE_CK			4
+#define I2S_CK			5
+#define RTC_CK			6
+#define SPDIF_CK_SYMB		7
+
+/* PLL CLOCKS */
+#define PLL1_CK			8
+#define PLL2_CK			9
+#define PLL3_CK			10
+#define PLL4_CK			11
+#define PLL5_CK			12
+#define PLL6_CK			13
+#define PLL7_CK			14
+#define PLL8_CK			15
+
+/* LOW SPEEP MCU CLOCK */
+#define CK_ICN_LS_MCU		20
+
+/* APB DIV CLOCKS */
+#define CK_ICN_APB1		21
+#define CK_ICN_APB2		22
+#define CK_ICN_APB3		23
+#define CK_ICN_APB4		24
+#define CK_ICN_APBDBG		25
+
+/* GLOBAL TIMER */
+#define TIMG1_CK		26
+#define TIMG2_CK		27
+
+/* FLEXGEN CLOCKS */
+#define CK_ICN_HS_MCU		28
+#define CK_ICN_SDMMC		29
+#define CK_ICN_DDR		30
+#define CK_ICN_DISPLAY		31
+#define CK_ICN_HSL		32
+#define CK_ICN_NIC		33
+#define CK_ICN_VID		34
+
+#define CK_FLEXGEN_07		35
+#define CK_FLEXGEN_08		36
+#define CK_FLEXGEN_09		37
+#define CK_FLEXGEN_10		38
+#define CK_FLEXGEN_11		39
+#define CK_FLEXGEN_12		40
+#define CK_FLEXGEN_13		41
+#define CK_FLEXGEN_14		42
+#define CK_FLEXGEN_15		43
+#define CK_FLEXGEN_16		44
+#define CK_FLEXGEN_17		45
+#define CK_FLEXGEN_18		46
+#define CK_FLEXGEN_19		47
+#define CK_FLEXGEN_20		48
+#define CK_FLEXGEN_21		49
+#define CK_FLEXGEN_22		50
+#define CK_FLEXGEN_23		51
+#define CK_FLEXGEN_24		52
+#define CK_FLEXGEN_25		53
+#define CK_FLEXGEN_26		54
+#define CK_FLEXGEN_27		55
+#define CK_FLEXGEN_28		56
+#define CK_FLEXGEN_29		57
+#define CK_FLEXGEN_30		58
+#define CK_FLEXGEN_31		59
+#define CK_FLEXGEN_32		60
+#define CK_FLEXGEN_33		61
+#define CK_FLEXGEN_34		62
+#define CK_FLEXGEN_35		63
+#define CK_FLEXGEN_36		64
+#define CK_FLEXGEN_37		65
+#define CK_FLEXGEN_38		66
+#define CK_FLEXGEN_39		67
+#define CK_FLEXGEN_40		68
+#define CK_FLEXGEN_41		69
+#define CK_FLEXGEN_42		70
+#define CK_FLEXGEN_43		71
+#define CK_FLEXGEN_44		72
+#define CK_FLEXGEN_45		73
+#define CK_FLEXGEN_46		74
+#define CK_FLEXGEN_47		75
+#define CK_FLEXGEN_48		76
+#define CK_FLEXGEN_49		77
+#define CK_FLEXGEN_50		78
+#define CK_FLEXGEN_51		79
+#define CK_FLEXGEN_52		80
+#define CK_FLEXGEN_53		81
+#define CK_FLEXGEN_54		82
+#define CK_FLEXGEN_55		83
+#define CK_FLEXGEN_56		84
+#define CK_FLEXGEN_57		85
+#define CK_FLEXGEN_58		86
+#define CK_FLEXGEN_59		87
+#define CK_FLEXGEN_60		88
+#define CK_FLEXGEN_61		89
+#define CK_FLEXGEN_62		90
+#define CK_FLEXGEN_63		91
+
+#define CK_BUS_STM500		92
+#define CK_BUS_FMC		93
+#define CK_BUS_GPU		94
+#define CK_BUS_ETH1		95
+#define CK_BUS_ETH2		96
+#define CK_BUS_PCIE		97
+#define CK_BUS_DDRPHYC		98
+#define CK_BUS_SYSCPU1		99
+#define CK_BUS_ETHSW		100
+#define CK_BUS_HPDMA1		101
+#define CK_BUS_HPDMA2		102
+#define CK_BUS_HPDMA3		103
+#define CK_BUS_ADC12		104
+#define CK_BUS_ADC3		105
+#define CK_BUS_IPCC1		106
+#define CK_BUS_CCI		107
+#define CK_BUS_CRC		108
+#define CK_BUS_MDF1		109
+#define CK_BUS_OSPIIOM		110
+#define CK_BUS_BKPSRAM		111
+#define CK_BUS_HASH		112
+#define CK_BUS_RNG		113
+#define CK_BUS_CRYP1		114
+#define CK_BUS_CRYP2		115
+#define CK_BUS_SAES		116
+#define CK_BUS_PKA		117
+#define CK_BUS_RISAF1		118
+#define CK_BUS_RISAF5		119
+#define CK_BUS_RISAB1		120
+#define CK_BUS_RISAB2		121
+#define CK_BUS_RISAB6		122
+#define CK_BUS_GPIOA		123
+#define CK_BUS_GPIOB		124
+#define CK_BUS_GPIOC		125
+#define CK_BUS_GPIOD		126
+#define CK_BUS_GPIOE		127
+#define CK_BUS_GPIOF		128
+#define CK_BUS_GPIOG		129
+#define CK_BUS_GPIOH		130
+#define CK_BUS_GPIOI		131
+#define CK_BUS_GPIOJ		132
+#define CK_BUS_GPIOK		133
+#define CK_BUS_LPSRAM1		134
+#define CK_BUS_LPSRAM2		135
+#define CK_BUS_LPSRAM3		136
+#define CK_BUS_GPIOZ		137
+#define CK_BUS_LPDMA		138
+#define CK_BUS_ADF1		139
+#define CK_BUS_HSEM		140
+#define CK_BUS_IPCC2		141
+#define CK_BUS_C3H		142
+#define CK_BUS_C3S		143
+#define CK_BUS_C3D		144
+#define CK_BUS_RTC		145
+#define CK_BUS_SPI8		146
+#define CK_BUS_LPUART1		147
+#define CK_BUS_I2C8		148
+#define CK_BUS_LPTIM3		149
+#define CK_BUS_LPTIM4		150
+#define CK_BUS_LPTIM5		151
+#define CK_BUS_IWDG5		152
+#define CK_BUS_WWDG2		153
+#define CK_BUS_I3C4		154
+#define CK_BUS_TIM2		155
+#define CK_BUS_TIM3		156
+#define CK_BUS_TIM4		157
+#define CK_BUS_TIM5		158
+#define CK_BUS_TIM6		159
+#define CK_BUS_TIM7		160
+#define CK_BUS_TIM10		161
+#define CK_BUS_TIM11		162
+#define CK_BUS_TIM12		163
+#define CK_BUS_TIM13		164
+#define CK_BUS_TIM14		165
+#define CK_BUS_LPTIM1		166
+#define CK_BUS_LPTIM2		167
+#define CK_BUS_SPI2		168
+#define CK_BUS_SPI3		169
+#define CK_BUS_SPDIFRX		170
+#define CK_BUS_USART2		171
+#define CK_BUS_USART3		172
+#define CK_BUS_UART4		173
+#define CK_BUS_UART5		174
+#define CK_BUS_I2C1		175
+#define CK_BUS_I2C2		176
+#define CK_BUS_I2C3		177
+#define CK_BUS_I2C4		178
+#define CK_BUS_I2C5		179
+#define CK_BUS_I2C6		180
+#define CK_BUS_I2C7		181
+#define CK_BUS_I3C1		182
+#define CK_BUS_I3C2		183
+#define CK_BUS_I3C3		184
+#define CK_BUS_TIM1		185
+#define CK_BUS_TIM8		186
+#define CK_BUS_TIM15		187
+#define CK_BUS_TIM16		188
+#define CK_BUS_TIM17		189
+#define CK_BUS_TIM20		190
+#define CK_BUS_SAI1		191
+#define CK_BUS_SAI2		192
+#define CK_BUS_SAI3		193
+#define CK_BUS_SAI4		194
+#define CK_BUS_USART1		195
+#define CK_BUS_USART6		196
+#define CK_BUS_UART7		197
+#define CK_BUS_UART8		198
+#define CK_BUS_UART9		199
+#define CK_BUS_FDCAN		200
+#define CK_BUS_SPI1		201
+#define CK_BUS_SPI4		202
+#define CK_BUS_SPI5		203
+#define CK_BUS_SPI6		204
+#define CK_BUS_SPI7		205
+#define CK_BUS_BSEC		206
+#define CK_BUS_IWDG1		207
+#define CK_BUS_IWDG2		208
+#define CK_BUS_IWDG3		209
+#define CK_BUS_IWDG4		210
+#define CK_BUS_WWDG1		211
+#define CK_BUS_VREF		212
+#define CK_BUS_TMPSENS		213
+#define CK_BUS_SERC		214
+#define CK_BUS_HDP		215
+#define CK_BUS_IS2M		216
+#define CK_BUS_DSI		217
+#define CK_BUS_LTDC		218
+#define CK_BUS_CSI2		219
+#define CK_BUS_DCMIPP		220
+#define CK_BUS_DDRC		221
+#define CK_BUS_DDRCFG		222
+#define CK_BUS_LDIT		223
+#define CK_BUS_GICV2M		224
+#define CK_BUS_USBTC		225
+#define CK_BUS_BUSPERFM		226
+#define CK_BUS_USB3PCIEPHY	227
+#define CK_BUS_STGEN		228
+#define CK_BUS_VDEC		229
+#define CK_BUS_VENC		230
+#define CK_BUS_DBG		231
+#define CK_KER_TIM2		232
+#define CK_KER_TIM3		233
+#define CK_KER_TIM4		234
+#define CK_KER_TIM5		235
+#define CK_KER_TIM6		236
+#define CK_KER_TIM7		237
+#define CK_KER_TIM10		238
+#define CK_KER_TIM11		239
+#define CK_KER_TIM12		240
+#define CK_KER_TIM13		241
+#define CK_KER_TIM14		242
+#define CK_KER_TIM1		243
+#define CK_KER_TIM8		244
+#define CK_KER_TIM15		245
+#define CK_KER_TIM16		246
+#define CK_KER_TIM17		247
+#define CK_KER_TIM20		248
+#define CK_BUS_SYSRAM		249
+#define CK_BUS_VDERAM		250
+#define CK_BUS_RETRAM		251
+#define CK_BUS_OSPI1		252
+#define CK_BUS_OSPI2		253
+#define CK_BUS_OTFD1		254
+#define CK_BUS_OTFD2		255
+#define CK_BUS_SRAM1		256
+#define CK_BUS_SRAM2		257
+#define CK_BUS_RISAB3		258
+#define CK_BUS_RISAB4		259
+#define CK_BUS_RISAB5		260
+#define CK_BUS_SDMMC1		261
+#define CK_BUS_SDMMC2		262
+#define CK_BUS_SDMMC3		263
+#define CK_BUS_DDR		264
+#define CK_BUS_RISAF4		265
+#define CK_BUS_USB2OHCI		268
+#define CK_BUS_USB2EHCI		269
+#define CK_BUS_USB3DRD		270
+#define CK_KER_LPTIM1		273
+#define CK_KER_LPTIM2		274
+#define CK_KER_USART2		275
+#define CK_KER_UART4		276
+#define CK_KER_USART3		277
+#define CK_KER_UART5		278
+#define CK_KER_SPI2		279
+#define CK_KER_SPI3		280
+#define CK_KER_SPDIFRX		281
+#define CK_KER_I2C1		282
+#define CK_KER_I2C2		283
+#define CK_KER_I3C1		284
+#define CK_KER_I3C2		285
+#define CK_KER_I2C3		286
+#define CK_KER_I2C5		287
+#define CK_KER_I3C3		288
+#define CK_KER_I2C4		289
+#define CK_KER_I2C6		290
+#define CK_KER_I2C7		291
+#define CK_KER_SPI1		292
+#define CK_KER_SPI4		293
+#define CK_KER_SPI5		294
+#define CK_KER_SPI6		295
+#define CK_KER_SPI7		296
+#define CK_KER_USART1		297
+#define CK_KER_USART6		298
+#define CK_KER_UART7		299
+#define CK_KER_UART8		300
+#define CK_KER_UART9		301
+#define CK_KER_MDF1		302
+#define CK_KER_SAI1		303
+#define CK_KER_SAI2		304
+#define CK_KER_SAI3		305
+#define CK_KER_SAI4		306
+#define CK_KER_FDCAN		307
+#define CK_KER_DSIBLANE		308
+#define CK_KER_DSIPHY		309
+#define CK_KER_CSI2		310
+#define CK_KER_CSI2TXESC	311
+#define CK_KER_CSI2PHY		312
+#define CK_KER_LVDSPHY		313
+#define CK_KER_STGEN		314
+#define CK_KER_USB3PCIEPHY	315
+#define CK_KER_USB3TC		316
+#define CK_KER_I3C4		317
+#define CK_KER_SPI8		318
+#define CK_KER_I2C8		319
+#define CK_KER_LPUART1		320
+#define CK_KER_LPTIM3		321
+#define CK_KER_LPTIM4		322
+#define CK_KER_LPTIM5		323
+#define CK_KER_ADF1		324
+#define CK_KER_TSDBG		325
+#define CK_KER_TPIU		326
+#define CK_BUS_ETR		327
+#define CK_BUS_ATB		328
+#define CK_KER_ADC12		329
+#define CK_KER_ADC3		330
+#define CK_KER_OSPI1		331
+#define CK_KER_OSPI2		332
+#define CK_KER_FMC		333
+#define CK_KER_SDMMC1		334
+#define CK_KER_SDMMC2		335
+#define CK_KER_SDMMC3		336
+#define CK_KER_ETH1		337
+#define CK_KER_ETH2		338
+#define CK_KER_ETH1PTP		339
+#define CK_KER_ETH2PTP		340
+#define CK_KER_USB2PHY1		341
+#define CK_KER_USB2PHY2		342
+#define CK_KER_ETHSW		343
+#define CK_KER_ETHSWREF		344
+#define CK_MCO1			345
+#define CK_MCO2			346
+#define CK_KER_TMPSENS		347
+
+#define CK_ETH1_RX		348
+#define CK_ETH1_TX		349
+#define CK_ETH1_MAC		350
+
+#define CK_ETH2_RX		351
+#define CK_ETH2_TX		352
+#define CK_ETH2_MAC		353
+
+#define CK_ETH1_STP		354
+#define CK_ETH2_STP		355
+
+#define STM32MP2_LAST_CLK	356
+
+#define CK_SCMI0_ICN_HS_MCU	0
+#define CK_SCMI0_ICN_SDMMC	1
+#define CK_SCMI0_ICN_DDR	2
+#define CK_SCMI0_ICN_DISPLAY	3
+#define CK_SCMI0_ICN_HSL	4
+#define CK_SCMI0_ICN_NIC	5
+#define CK_SCMI0_ICN_VID	6
+#define CK_SCMI0_FLEXGEN_07	7
+#define CK_SCMI0_FLEXGEN_08	8
+#define CK_SCMI0_FLEXGEN_09	9
+#define CK_SCMI0_FLEXGEN_10	10
+#define CK_SCMI0_FLEXGEN_11	11
+#define CK_SCMI0_FLEXGEN_12	12
+#define CK_SCMI0_FLEXGEN_13	13
+#define CK_SCMI0_FLEXGEN_14	14
+#define CK_SCMI0_FLEXGEN_15	15
+#define CK_SCMI0_FLEXGEN_16	16
+#define CK_SCMI0_FLEXGEN_17	17
+#define CK_SCMI0_FLEXGEN_18	18
+#define CK_SCMI0_FLEXGEN_19	19
+#define CK_SCMI0_FLEXGEN_20	20
+#define CK_SCMI0_FLEXGEN_21	21
+#define CK_SCMI0_FLEXGEN_22	22
+#define CK_SCMI0_FLEXGEN_23	23
+#define CK_SCMI0_FLEXGEN_24	24
+#define CK_SCMI0_FLEXGEN_25	25
+#define CK_SCMI0_FLEXGEN_26	26
+#define CK_SCMI0_FLEXGEN_27	27
+#define CK_SCMI0_FLEXGEN_28	28
+#define CK_SCMI0_FLEXGEN_29	29
+#define CK_SCMI0_FLEXGEN_30	30
+#define CK_SCMI0_FLEXGEN_31	31
+#define CK_SCMI0_FLEXGEN_32	32
+#define CK_SCMI0_FLEXGEN_33	33
+#define CK_SCMI0_FLEXGEN_34	34
+#define CK_SCMI0_FLEXGEN_35	35
+#define CK_SCMI0_FLEXGEN_36	36
+#define CK_SCMI0_FLEXGEN_37	37
+#define CK_SCMI0_FLEXGEN_38	38
+#define CK_SCMI0_FLEXGEN_39	39
+#define CK_SCMI0_FLEXGEN_40	40
+#define CK_SCMI0_FLEXGEN_41	41
+#define CK_SCMI0_FLEXGEN_42	42
+#define CK_SCMI0_FLEXGEN_43	43
+#define CK_SCMI0_FLEXGEN_44	44
+#define CK_SCMI0_FLEXGEN_45	45
+#define CK_SCMI0_FLEXGEN_46	46
+#define CK_SCMI0_FLEXGEN_47	47
+#define CK_SCMI0_FLEXGEN_48	48
+#define CK_SCMI0_FLEXGEN_49	49
+#define CK_SCMI0_FLEXGEN_50	50
+#define CK_SCMI0_FLEXGEN_51	51
+#define CK_SCMI0_FLEXGEN_52	52
+#define CK_SCMI0_FLEXGEN_53	53
+#define CK_SCMI0_FLEXGEN_54	54
+#define CK_SCMI0_FLEXGEN_55	55
+#define CK_SCMI0_FLEXGEN_56	56
+#define CK_SCMI0_FLEXGEN_57	57
+#define CK_SCMI0_FLEXGEN_58	58
+#define CK_SCMI0_FLEXGEN_59	59
+#define CK_SCMI0_FLEXGEN_60	60
+#define CK_SCMI0_FLEXGEN_61	61
+#define CK_SCMI0_FLEXGEN_62	62
+#define CK_SCMI0_FLEXGEN_63	63
+
+#define CK_SCMI0_ICN_LS_MCU	64
+
+#define CK_SCMI0_HSE		65
+#define CK_SCMI0_LSE		66
+#define CK_SCMI0_HSI		67
+#define CK_SCMI0_LSI		68
+#define CK_SCMI0_MSI		69
+
+#define CK_SCMI0_RTC		70
+
+#define CK_SCMI0_ICN_APB1	71
+#define CK_SCMI0_ICN_APB2	72
+#define CK_SCMI0_ICN_APB3	73
+#define CK_SCMI0_ICN_APB4	74
+
+#define CK_SCMI0_ICN_APBDBG	75
+
+#define CK_SCMI0_TIMG1		76
+#define CK_SCMI0_TIMG2		77
+
+#endif /* DT_BINDINGS_STM32MP2_CLKS_H */
diff --git a/include/dt-bindings/clock/stm32mp2-clksrc.h b/include/dt-bindings/clock/stm32mp2-clksrc.h
new file mode 100644
index 000000000..c17650c71
--- /dev/null
+++ b/include/dt-bindings/clock/stm32mp2-clksrc.h
@@ -0,0 +1,226 @@
+/* SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause */
+/*
+ * Copyright (C) 2017-2020, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef _DT_BINDINGS_CLOCK_STM32MP2_CLKSRC_H_
+#define _DT_BINDINGS_CLOCK_STM32MP2_CLKSRC_H_
+
+#define CMD_DIV		0
+#define CMD_MUX		1
+#define CMD_CLK		2
+#define CMD_FLEXGEN	3
+
+#define CMD_ADDR_BIT	0x80000000
+
+#define CMD_SHIFT	26
+#define CMD_MASK	0xFC000000
+#define CMD_DATA_MASK	0x03FFFFFF
+
+#define DIV_ID_SHIFT	8
+#define DIV_ID_MASK	0x0000FF00
+
+#define DIV_DIVN_SHIFT	0
+#define DIV_DIVN_MASK	0x000000FF
+
+#define MUX_ID_SHIFT	4
+#define MUX_ID_MASK	0x00000FF0
+
+#define MUX_SEL_SHIFT	0
+#define MUX_SEL_MASK	0x0000000F
+
+/* CLK define */
+#define CLK_ON_MASK	BIT(21)
+#define CLK_ON_SHIFT	21
+
+#define CLK_ID_MASK	GENMASK_32(20, 12)
+#define CLK_ID_SHIFT	12
+
+#define CLK_NO_DIV_MASK	0x0000080
+#define CLK_DIV_MASK	GENMASK_32(10, 5)
+#define CLK_DIV_SHIFT	5
+
+#define CLK_NO_SEL_MASK	0x00000010
+#define CLK_SEL_MASK	GENMASK_32(3, 0)
+#define CLK_SEL_SHIFT	0
+
+#define CLK_CFG(clk_id, sel, div, state)	((CMD_CLK << CMD_SHIFT) |\
+						 ((state) << CLK_ON_SHIFT) |\
+						 ((clk_id) << CLK_ID_SHIFT) |\
+						 ((div) << CLK_DIV_SHIFT) |\
+						 ((sel) << CLK_SEL_SHIFT))
+
+#define CLK_OFF		0
+#define CLK_ON		1
+#define CLK_NODIV	0x00000040
+#define CLK_NOMUX	0x00000010
+
+/* Flexgen define */
+#define FLEX_ID_SHIFT	13
+#define FLEX_SEL_SHIFT	9
+#define FLEX_PDIV_SHIFT	6
+#define FLEX_FDIV_SHIFT	0
+
+#define FLEX_ID_MASK	GENMASK_32(18, 13)
+#define FLEX_SEL_MASK	GENMASK_32(12, 9)
+#define FLEX_PDIV_MASK	GENMASK_32(8, 6)
+#define FLEX_FDIV_MASK	GENMASK_32(5, 0)
+
+#define DIV_CFG(div_id, div)	((CMD_DIV << CMD_SHIFT) |\
+				 ((div_id) << DIV_ID_SHIFT |\
+				 (div)))
+
+#define MUX_CFG(mux_id, sel)	((CMD_MUX << CMD_SHIFT) |\
+				 ((mux_id) << MUX_ID_SHIFT |\
+				 (sel)))
+
+#define CLK_ADDR_SHIFT		16
+#define CLK_ADDR_MASK		0x7FFF0000
+#define CLK_ADDR_VAL_MASK	0xFFFF
+
+#define DIV_LSMCU	0
+#define DIV_APB1	1
+#define DIV_APB2	2
+#define DIV_APB3	3
+#define DIV_APB4	4
+#define DIV_APBDBG	5
+#define DIV_RTC		6
+#define DIV_NB		7
+
+#define MUX_MUXSEL0	0
+#define MUX_MUXSEL1	1
+#define MUX_MUXSEL2	2
+#define MUX_MUXSEL3	3
+#define MUX_MUXSEL4	4
+#define MUX_MUXSEL5	5
+#define MUX_MUXSEL6	6
+#define MUX_MUXSEL7	7
+#define MUX_XBARSEL	8
+#define MUX_RTC		9
+#define MUX_MCO1	10
+#define MUX_MCO2	11
+#define MUX_ADC12	12
+#define MUX_ADC3	13
+#define MUX_USB2PHY1	14
+#define MUX_USB2PHY2	15
+#define MUX_USB3PCIEPHY	16
+#define MUX_DSIBLANE	17
+#define MUX_DSIPHY	18
+#define MUX_LVDSPHY	19
+#define MUX_DTS		20
+#define MUX_CPU1	21
+#define MUX_D3PER	22
+#define MUX_NB		23
+
+#define MUXSEL_HSI		0
+#define MUXSEL_HSE		1
+#define MUXSEL_MSI		2
+
+/* KERNEL source clocks */
+#define MUX_RTC_DISABLED	0x0
+#define MUX_RTC_LSE		0x1
+#define MUX_RTC_LSI		0x2
+#define MUX_RTC_HSE		0x3
+
+#define MUX_MCO1_FLEX61		0x0
+#define MUX_MCO1_OBSER0		0x1
+
+#define MUX_MCO2_FLEX62		0x0
+#define MUX_MCO2_OBSER1		0x1
+
+#define MUX_ADC12_FLEX46	0x0
+#define MUX_ADC12_LSMCU		0x1
+
+#define MUX_ADC3_FLEX47		0x0
+#define MUX_ADC3_LSMCU		0x1
+#define MUX_ADC3_FLEX46		0x2
+
+#define MUX_USB2PHY1_FLEX57	0x0
+#define MUX_USB2PHY1_HSE	0x1
+
+#define MUX_USB2PHY2_FLEX58	0x0
+#define MUX_USB2PHY2_HSE	0x1
+
+#define MUX_USB3PCIEPHY_FLEX34	0x0
+#define MUX_USB3PCIEPHY_HSE	0x1
+
+#define MUX_DSIBLANE_FLEX28	0x0
+#define MUX_DSIBLANE_FLEX27	0x1
+
+#define MUX_DSIPHY_FLEX28	0x0
+#define MUX_DSIPHY_HSE		0x1
+
+#define MUX_LVDSPHY_FLEX32	0x0
+#define MUX_LVDSPHY_HSE		0x1
+
+#define MUX_DTS_HSI		0x0
+#define MUX_DTS_HSE		0x1
+#define MUX_DTS_MSI		0x2
+
+#define MUX_D3PER_MSI		0x0
+#define MUX_D3PER_LSI		0x1
+#define MUX_D3PER_LSE		0x2
+
+/* PLLs source clocks */
+#define PLL_SRC_HSI		0x0
+#define PLL_SRC_HSE		0x1
+#define PLL_SRC_MSI		0x2
+#define PLL_SRC_DISABLED	0x3
+
+/* XBAR source clocks */
+#define XBAR_SRC_PLL4		0x0
+#define XBAR_SRC_PLL5		0x1
+#define XBAR_SRC_PLL6		0x2
+#define XBAR_SRC_PLL7		0x3
+#define XBAR_SRC_PLL8		0x4
+#define XBAR_SRC_HSI		0x5
+#define XBAR_SRC_HSE		0x6
+#define XBAR_SRC_MSI		0x7
+#define XBAR_SRC_HSI_KER	0x8
+#define XBAR_SRC_HSE_KER	0x9
+#define XBAR_SRC_MSI_KER	0xA
+#define XBAR_SRC_SPDIF_SYMB	0xB
+#define XBAR_SRC_I2S		0xC
+#define XBAR_SRC_LSI		0xD
+#define XBAR_SRC_LSE		0xE
+
+/*
+ * Configure a XBAR channel with its clock source
+ * channel_nb: XBAR channel number from 0 to 63
+ * channel_src: one of the 15 previous XBAR source clocks defines
+ * channel_prediv: value of the PREDIV in channel RCC_PREDIVxCFGR register
+ *		   can be either 1, 2, 4 or 1024
+ * channel_findiv: value of the FINDIV in channel RCC_FINDIVxCFGR register
+ *		   from 1 to 64
+ */
+
+#define FLEXGEN_CFG(ch, sel, pdiv, fdiv)	((CMD_FLEXGEN << CMD_SHIFT) |\
+						((ch) << FLEX_ID_SHIFT) |\
+						((sel) << FLEX_SEL_SHIFT) |\
+						((pdiv) << FLEX_PDIV_SHIFT) |\
+						((fdiv) << FLEX_FDIV_SHIFT))
+
+/* Register addresses of MCO1 & MCO2 */
+#define MCO1			0x494
+#define MCO2			0x498
+
+#define MCO_OFF			0
+#define MCO_ON			1
+#define MCO_STATUS_SHIFT	8
+
+#define MCO_CFG(addr, sel, status)	(CMD_ADDR_BIT |\
+					((addr) << CLK_ADDR_SHIFT) |\
+					((status) << MCO_STATUS_SHIFT) |\
+					(sel))
+
+/* define for st,pll /csg */
+#define SSCG_MODE_CENTER_SPREAD	0
+#define SSCG_MODE_DOWN_SPREAD	1
+
+/* define for st,drive */
+#define LSEDRV_LOWEST		0
+#define LSEDRV_MEDIUM_LOW	1
+#define LSEDRV_MEDIUM_HIGH	2
+#define LSEDRV_HIGHEST		3
+
+#endif /* _DT_BINDINGS_CLOCK_STM32MP2_CLKSRC_H_ */
diff --git a/include/dt-bindings/gpio/stm32-gpio.h b/include/dt-bindings/gpio/stm32-gpio.h
new file mode 100644
index 000000000..3820bd1fb
--- /dev/null
+++ b/include/dt-bindings/gpio/stm32-gpio.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Paillet Pascal <p.paillet@foss.st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32_GPIO_H
+#define _DT_BINDINGS_STM32_GPIO_H
+
+/* Bank IDs used in GPIO driver API */
+#define GPIO_BANK_A			0U
+#define GPIO_BANK_B			1U
+#define GPIO_BANK_C			2U
+#define GPIO_BANK_D			3U
+#define GPIO_BANK_E			4U
+#define GPIO_BANK_F			5U
+#define GPIO_BANK_G			6U
+#define GPIO_BANK_H			7U
+#define GPIO_BANK_I			8U
+#define GPIO_BANK_J			9U
+#define GPIO_BANK_K			10U
+#define GPIO_BANK_Z			25U
+
+/* Bit 0 is used to set GPIO in input mode */
+#define GPIOF_DIR_OUT			0x0
+#define GPIOF_DIR_IN			0x1
+
+/* Bit 1 is used to set GPIO high level during init */
+#define GPIOF_INIT_LOW			0x0
+#define GPIOF_INIT_HIGH			0x2
+
+#define GPIOF_IN			(GPIOF_DIR_IN)
+#define GPIOF_OUT_INIT_LOW		(GPIOF_DIR_OUT | GPIOF_INIT_LOW)
+#define GPIOF_OUT_INIT_HIGH		(GPIOF_DIR_OUT | GPIOF_INIT_HIGH)
+
+/* Bit 2 is used to set GPIO pull up */
+#define GPIOF_PULL_UP			0x4
+/* Bit 3 is used to set GPIO pull down */
+#define GPIOF_PULL_DOWN			0x8
+
+#endif /* _DT_BINDINGS_STM32_GPIO_H */
diff --git a/include/dt-bindings/power/stm32mp1-power.h b/include/dt-bindings/power/stm32mp1-power.h
new file mode 100644
index 000000000..3202e0b44
--- /dev/null
+++ b/include/dt-bindings/power/stm32mp1-power.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0 or BSD-3-Clause */
+/*
+ * Copyright (C) 2018-2019, STMicroelectronics - All Rights Reserved
+ * Author: Yann Gautier <yann.gautier@st.com> for STMicroelectronics.
+ */
+
+#ifndef DT_BINDINGS_STM32MP1_POWER_H
+#define DT_BINDINGS_STM32MP1_POWER_H
+
+#define STM32_PM_CSLEEP_RUN			0
+#define STM32_PM_CSTOP_ALLOW_STOP		1
+#define STM32_PM_CSTOP_ALLOW_LP_STOP		2
+#define STM32_PM_CSTOP_ALLOW_LPLV_STOP		3
+#define STM32_PM_CSTOP_ALLOW_LPLV_STOP2		4
+#define STM32_PM_CSTOP_ALLOW_STANDBY_DDR_SR	5
+#define STM32_PM_CSTOP_ALLOW_STANDBY_DDR_OFF	6
+#define STM32_PM_SHUTDOWN			7
+#define STM32_PM_MAX_SOC_MODE			8
+
+#endif /* DT_BINDINGS_STM32MP1_POWER_H */
diff --git a/include/dt-bindings/reset/stm32mp1-resets.h b/include/dt-bindings/reset/stm32mp1-resets.h
index bc71924fa..f24f99b12 100644
--- a/include/dt-bindings/reset/stm32mp1-resets.h
+++ b/include/dt-bindings/reset/stm32mp1-resets.h
@@ -1,121 +1,11 @@
-/* SPDX-License-Identifier: GPL-2.0 or BSD-3-Clause */
+/* SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause */
 /*
- * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
- * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
+ * Copyright (C) 2020, STMicroelectronics - All Rights Reserved
  */
 
-#ifndef _DT_BINDINGS_STM32MP1_RESET_H_
-#define _DT_BINDINGS_STM32MP1_RESET_H_
-
-#define LTDC_R		3072
-#define DSI_R		3076
-#define DDRPERFM_R	3080
-#define USBPHY_R	3088
-#define SPI6_R		3136
-#define I2C4_R		3138
-#define I2C6_R		3139
-#define USART1_R	3140
-#define STGEN_R		3156
-#define GPIOZ_R		3200
-#define CRYP1_R		3204
-#define HASH1_R		3205
-#define RNG1_R		3206
-#define AXIM_R		3216
-#define GPU_R		3269
-#define ETHMAC_R	3274
-#define FMC_R		3276
-#define QSPI_R		3278
-#define SDMMC1_R	3280
-#define SDMMC2_R	3281
-#define CRC1_R		3284
-#define USBH_R		3288
-#define MDMA_R		3328
-#define MCU_R		8225
-#define TIM2_R		19456
-#define TIM3_R		19457
-#define TIM4_R		19458
-#define TIM5_R		19459
-#define TIM6_R		19460
-#define TIM7_R		19461
-#define TIM12_R		16462
-#define TIM13_R		16463
-#define TIM14_R		16464
-#define LPTIM1_R	19465
-#define SPI2_R		19467
-#define SPI3_R		19468
-#define USART2_R	19470
-#define USART3_R	19471
-#define UART4_R		19472
-#define UART5_R		19473
-#define UART7_R		19474
-#define UART8_R		19475
-#define I2C1_R		19477
-#define I2C2_R		19478
-#define I2C3_R		19479
-#define I2C5_R		19480
-#define SPDIF_R		19482
-#define CEC_R		19483
-#define DAC12_R		19485
-#define MDIO_R		19847
-#define TIM1_R		19520
-#define TIM8_R		19521
-#define TIM15_R		19522
-#define TIM16_R		19523
-#define TIM17_R		19524
-#define SPI1_R		19528
-#define SPI4_R		19529
-#define SPI5_R		19530
-#define USART6_R	19533
-#define SAI1_R		19536
-#define SAI2_R		19537
-#define SAI3_R		19538
-#define DFSDM_R		19540
-#define FDCAN_R		19544
-#define LPTIM2_R	19584
-#define LPTIM3_R	19585
-#define LPTIM4_R	19586
-#define LPTIM5_R	19587
-#define SAI4_R		19592
-#define SYSCFG_R	19595
-#define VREF_R		19597
-#define TMPSENS_R	19600
-#define PMBCTRL_R	19601
-#define DMA1_R		19648
-#define DMA2_R		19649
-#define DMAMUX_R	19650
-#define ADC12_R		19653
-#define USBO_R		19656
-#define SDMMC3_R	19664
-#define CAMITF_R	19712
-#define CRYP2_R		19716
-#define HASH2_R		19717
-#define RNG2_R		19718
-#define CRC2_R		19719
-#define HSEM_R		19723
-#define MBOX_R		19724
-#define GPIOA_R		19776
-#define GPIOB_R		19777
-#define GPIOC_R		19778
-#define GPIOD_R		19779
-#define GPIOE_R		19780
-#define GPIOF_R		19781
-#define GPIOG_R		19782
-#define GPIOH_R		19783
-#define GPIOI_R		19784
-#define GPIOJ_R		19785
-#define GPIOK_R		19786
-
-/* SCMI reset domain identifiers */
-#define RST_SCMI0_SPI6		0
-#define RST_SCMI0_I2C4		1
-#define RST_SCMI0_I2C6		2
-#define RST_SCMI0_USART1	3
-#define RST_SCMI0_STGEN		4
-#define RST_SCMI0_GPIOZ		5
-#define RST_SCMI0_CRYP1		6
-#define RST_SCMI0_HASH1		7
-#define RST_SCMI0_RNG1		8
-#define RST_SCMI0_MDMA		9
-#define RST_SCMI0_MCU		10
-
-#endif /* _DT_BINDINGS_STM32MP1_RESET_H_ */
+#if STM32MP13
+#include "stm32mp13-resets.h"
+#endif
+#if STM32MP15
+#include "stm32mp15-resets.h"
+#endif
diff --git a/include/dt-bindings/reset/stm32mp13-resets.h b/include/dt-bindings/reset/stm32mp13-resets.h
new file mode 100644
index 000000000..09fad7f98
--- /dev/null
+++ b/include/dt-bindings/reset/stm32mp13-resets.h
@@ -0,0 +1,96 @@
+/* SPDX-License-Identifier: GPL-2.0 or BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32MP13_RESET_H_
+#define _DT_BINDINGS_STM32MP13_RESET_H_
+
+#define TIM2_R		13568
+#define TIM3_R		13569
+#define TIM4_R		13570
+#define TIM5_R		13571
+#define TIM6_R		13572
+#define TIM7_R		13573
+#define LPTIM1_R	13577
+#define SPI2_R		13579
+#define SPI3_R		13580
+#define USART3_R	13583
+#define UART4_R		13584
+#define UART5_R		13585
+#define UART7_R		13586
+#define UART8_R		13587
+#define I2C1_R		13589
+#define I2C2_R		13590
+#define SPDIF_R		13594
+#define TIM1_R		13632
+#define TIM8_R		13633
+#define SPI1_R		13640
+#define USART6_R	13645
+#define SAI1_R		13648
+#define SAI2_R		13649
+#define DFSDM_R		13652
+#define FDCAN_R		13656
+#define LPTIM2_R	13696
+#define LPTIM3_R	13697
+#define LPTIM4_R	13698
+#define LPTIM5_R	13699
+#define SYSCFG_R	13707
+#define VREF_R		13709
+#define DTS_R		13712
+#define PMBCTRL_R	13713
+#define LTDC_R		13760
+#define DCMIPP_R	13761
+#define DDRPERFM_R	13768
+#define USBPHY_R	13776
+#define STGEN_R		13844
+#define USART1_R	13888
+#define USART2_R	13889
+#define SPI4_R		13890
+#define SPI5_R		13891
+#define I2C3_R		13892
+#define I2C4_R		13893
+#define I2C5_R		13894
+#define TIM12_R		13895
+#define TIM13_R		13896
+#define TIM14_R		13897
+#define TIM15_R		13898
+#define TIM16_R		13899
+#define TIM17_R		13900
+#define DMA1_R		13952
+#define DMA2_R		13953
+#define DMAMUX1_R	13954
+#define DMA3_R		13955
+#define DMAMUX2_R	13956
+#define ADC1_R		13957
+#define ADC2_R		13958
+#define USBO_R		13960
+#define GPIOA_R		14080
+#define GPIOB_R		14081
+#define GPIOC_R		14082
+#define GPIOD_R		14083
+#define GPIOE_R		14084
+#define GPIOF_R		14085
+#define GPIOG_R		14086
+#define GPIOH_R		14087
+#define GPIOI_R		14088
+#define TSC_R		14095
+#define PKA_R		14146
+#define SAES_R		14147
+#define CRYP1_R		14148
+#define HASH1_R		14149
+#define RNG1_R		14150
+#define AXIMC_R		14160
+#define MDMA_R		14208
+#define MCE_R		14209
+#define ETH1MAC_R	14218
+#define FMC_R		14220
+#define QSPI_R		14222
+#define SDMMC1_R	14224
+#define SDMMC2_R	14225
+#define CRC1_R		14228
+#define USBH_R		14232
+#define ETH2MAC_R	14238
+
+#endif /* _DT_BINDINGS_STM32MP13_RESET_H_ */
diff --git a/include/dt-bindings/reset/stm32mp15-resets.h b/include/dt-bindings/reset/stm32mp15-resets.h
new file mode 100644
index 000000000..2846d7b84
--- /dev/null
+++ b/include/dt-bindings/reset/stm32mp15-resets.h
@@ -0,0 +1,123 @@
+/* SPDX-License-Identifier: GPL-2.0 or BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32MP15_RESET_H_
+#define _DT_BINDINGS_STM32MP15_RESET_H_
+
+#define MCU_HOLD_BOOT_R	2144
+#define LTDC_R		3072
+#define DSI_R		3076
+#define DDRPERFM_R	3080
+#define USBPHY_R	3088
+#define SPI6_R		3136
+#define I2C4_R		3138
+#define I2C6_R		3139
+#define USART1_R	3140
+#define STGEN_R		3156
+#define GPIOZ_R		3200
+#define CRYP1_R		3204
+#define HASH1_R		3205
+#define RNG1_R		3206
+#define AXIM_R		3216
+#define GPU_R		3269
+#define ETHMAC_R	3274
+#define FMC_R		3276
+#define QSPI_R		3278
+#define SDMMC1_R	3280
+#define SDMMC2_R	3281
+#define CRC1_R		3284
+#define USBH_R		3288
+#define MDMA_R		3328
+#define MCU_R		8225
+#define TIM2_R		19456
+#define TIM3_R		19457
+#define TIM4_R		19458
+#define TIM5_R		19459
+#define TIM6_R		19460
+#define TIM7_R		19461
+#define TIM12_R		16462
+#define TIM13_R		16463
+#define TIM14_R		16464
+#define LPTIM1_R	19465
+#define SPI2_R		19467
+#define SPI3_R		19468
+#define USART2_R	19470
+#define USART3_R	19471
+#define UART4_R		19472
+#define UART5_R		19473
+#define UART7_R		19474
+#define UART8_R		19475
+#define I2C1_R		19477
+#define I2C2_R		19478
+#define I2C3_R		19479
+#define I2C5_R		19480
+#define SPDIF_R		19482
+#define CEC_R		19483
+#define DAC12_R		19485
+#define MDIO_R		19847
+#define TIM1_R		19520
+#define TIM8_R		19521
+#define TIM15_R		19522
+#define TIM16_R		19523
+#define TIM17_R		19524
+#define SPI1_R		19528
+#define SPI4_R		19529
+#define SPI5_R		19530
+#define USART6_R	19533
+#define SAI1_R		19536
+#define SAI2_R		19537
+#define SAI3_R		19538
+#define DFSDM_R		19540
+#define FDCAN_R		19544
+#define LPTIM2_R	19584
+#define LPTIM3_R	19585
+#define LPTIM4_R	19586
+#define LPTIM5_R	19587
+#define SAI4_R		19592
+#define SYSCFG_R	19595
+#define VREF_R		19597
+#define TMPSENS_R	19600
+#define PMBCTRL_R	19601
+#define DMA1_R		19648
+#define DMA2_R		19649
+#define DMAMUX_R	19650
+#define ADC12_R		19653
+#define USBO_R		19656
+#define SDMMC3_R	19664
+#define CAMITF_R	19712
+#define CRYP2_R		19716
+#define HASH2_R		19717
+#define RNG2_R		19718
+#define CRC2_R		19719
+#define HSEM_R		19723
+#define MBOX_R		19724
+#define GPIOA_R		19776
+#define GPIOB_R		19777
+#define GPIOC_R		19778
+#define GPIOD_R		19779
+#define GPIOE_R		19780
+#define GPIOF_R		19781
+#define GPIOG_R		19782
+#define GPIOH_R		19783
+#define GPIOI_R		19784
+#define GPIOJ_R		19785
+#define GPIOK_R		19786
+
+/* SCMI reset domain identifiers */
+#define RST_SCMI0_SPI6		0
+#define RST_SCMI0_I2C4		1
+#define RST_SCMI0_I2C6		2
+#define RST_SCMI0_USART1	3
+#define RST_SCMI0_STGEN		4
+#define RST_SCMI0_GPIOZ		5
+#define RST_SCMI0_CRYP1		6
+#define RST_SCMI0_HASH1		7
+#define RST_SCMI0_RNG1		8
+#define RST_SCMI0_MDMA		9
+#define RST_SCMI0_MCU		10
+#define RST_SCMI0_MCU_HOLD_BOOT	11
+
+#endif /* _DT_BINDINGS_STM32MP15_RESET_H_ */
diff --git a/include/dt-bindings/reset/stm32mp2-resets.h b/include/dt-bindings/reset/stm32mp2-resets.h
new file mode 100644
index 000000000..bee3d10bc
--- /dev/null
+++ b/include/dt-bindings/reset/stm32mp2-resets.h
@@ -0,0 +1,165 @@
+/* SPDX-License-Identifier: GPL-2.0 or BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author(s): Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
+ *	      Yann Gautier <yann.gautier@st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32MP25_RESET_H_
+#define _DT_BINDINGS_STM32MP25_RESET_H_
+
+#define SYS_R		8192
+#define C1_R		8224
+#define C1P1POR_R	8256
+#define C1P1_R		8257
+#define C2_R		8288
+#define C2_HOLDBOOT_R	8608
+#define VSW_R		8703
+#define C1MS_R		8808
+#define IWDG2_KER_R	9074
+// #define IWDG2_KER_R	9106
+#define IWDG4_KER_R	9202
+// #define IWDG4_KER_R	9234
+#define C3_R		9312
+#define DDRCP_R		9856
+#define DDRCAPB_R	9888
+#define DDRPHYCAPB_R	9920
+#define DDRCFG_R	9984
+#define DDR_R		10016
+#define OSPI1_R		10400
+#define OSPI1DLL_R	10416
+#define OSPI2_R		10432
+#define OSPI2DLL_R	10448
+#define FMC_R		10464
+#define DBG_R		10508
+#define GPIOA_R		10592
+#define GPIOB_R		10624
+#define GPIOC_R		10656
+#define GPIOD_R		10688
+#define GPIOE_R		10720
+#define GPIOF_R		10752
+#define GPIOG_R		10784
+#define GPIOH_R		10816
+#define GPIOI_R		10848
+#define GPIOJ_R		10880
+#define GPIOK_R		10912
+#define GPIOZ_R		10944
+#define HPDMA1_R	10976
+#define HPDMA2_R	11008
+#define HPDMA3_R	11040
+#define LPDMA_R		11072
+#define HSEM_R		11104
+#define IPCC1_R		11136
+#define IPCC2_R		11168
+#define IS2M_R		11360
+#define SSMOD_R		11392
+// #define SSMOD_R		11712
+#define TIM1_R		14336
+#define TIM2_R		14368
+#define TIM3_R		14400
+#define TIM4_R		14432
+#define TIM5_R		14464
+#define TIM6_R		14496
+#define TIM7_R		14528
+#define TIM8_R		14560
+#define TIM10_R		14592
+#define TIM11_R		14624
+#define TIM12_R		14656
+#define TIM13_R		14688
+#define TIM14_R		14720
+#define TIM15_R		14752
+#define TIM16_R		14784
+#define TIM17_R		14816
+#define TIM20_R		14848
+#define LPTIM1_R	14880
+#define LPTIM2_R	14912
+#define LPTIM3_R	14944
+#define LPTIM4_R	14976
+#define LPTIM5_R	15008
+#define SPI1_R		15040
+#define SPI2_R		15072
+#define SPI3_R		15104
+#define SPI4_R		15136
+#define SPI5_R		15168
+#define SPI6_R		15200
+#define SPI7_R		15232
+#define SPI8_R		15264
+#define SPDIFRX_R	15296
+#define USART1_R	15328
+#define USART2_R	15360
+#define USART3_R	15392
+#define UART4_R		15424
+#define UART5_R		15456
+#define USART6_R	15488
+#define UART7_R		15520
+#define UART8_R		15552
+#define UART9_R		15584
+#define LPUART1_R	15616
+#define I2C1_R		15648
+#define I2C2_R		15680
+#define I2C3_R		15712
+#define I2C4_R		15744
+#define I2C5_R		15776
+#define I2C6_R		15808
+#define I2C7_R		15840
+#define I2C8_R		15872
+#define SAI1_R		15904
+#define SAI2_R		15936
+#define SAI3_R		15968
+#define SAI4_R		16000
+#define MDF1_R		16064
+#define ADF1_R		16096
+#define FDCAN_R		16128
+#define HDP_R		16160
+#define ADC12_R		16192
+#define ADC3_R		16224
+#define ETH1_R		16256
+#define ETH2_R		16288
+#define USB2_R		16352
+#define USB2PHY1_R	16384
+#define USB2PHY2_R	16416
+#define USB3DRD_R	16448
+#define USB3PCIEPHY_R	16480
+#define PCIE_R		16512
+#define USBTC_R		16544
+#define ETHSW_R		16576
+#define SDMMC1_R	16768
+#define SDMMC1DLL_R	16784
+#define SDMMC2_R	16800
+#define SDMMC2DLL_R	16816
+#define SDMMC3_R	16832
+#define SDMMC3DLL_R	16848
+#define GPU_R		16864
+#define LTDC_R		16896
+#define DSI_R		16928
+#define LVDS_R		17024
+#define CSI2_R		17088
+#define DCMIPP_R	17120
+#define CCI_R		17152
+#define VDEC_R		17184
+#define VENC_R		17216
+#define RNG_R		17280
+#define PKA_R		17312
+#define SAES_R		17344
+#define HASH_R		17376
+#define CRYP1_R		17408
+#define CRYP2_R		17440
+#define WWDG1_R		17632
+#define WWDG2_R		17664
+#define BUSPERFM_R	17696
+#define VREF_R		17728
+#define TMPSENS_R	17760
+#define CRC_R		17824
+#define SERC_R		17856
+#define OSPIIOM_R	17888
+#define I3C1_R		17984
+#define I3C2_R		18016
+#define I3C3_R		18048
+#define I3C4_R		18080
+// #define SSMOD_R		39680
+// #define SSMOD_R		40000
+// #define SSMOD_R		40320
+// #define SSMOD_R		40640
+// #define SSMOD_R		40960
+
+#endif /* _DT_BINDINGS_STM32MP25_RESET_H_ */
diff --git a/include/dt-bindings/soc/rif.h b/include/dt-bindings/soc/rif.h
new file mode 100644
index 000000000..239f5866b
--- /dev/null
+++ b/include/dt-bindings/soc/rif.h
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier:	GPL-2.0+	BSD-3-Clause
+ */
+
+#ifndef _DT_BINDINGS_RIF_H
+#define _DT_BINDINGS_RIF_H
+
+/* RIFSC CIDs */
+#define RIF_CID0		0x0
+#define RIF_CID1		0x1
+#define RIF_CID2		0x2
+#define RIF_CID3		0x3
+#define RIF_CID4		0x4
+#define RIF_CID5		0x5
+#define RIF_CID6		0x6
+#define RIF_CID7		0x7
+#define RIF_CID_MAX		0x8
+
+/* RIFSC semaphore list */
+#define EMPTY_SEMWL		0x0
+#define RIF_CID0_BF		(1 << RIF_CID0)
+#define RIF_CID1_BF		(1 << RIF_CID1)
+#define RIF_CID2_BF		(1 << RIF_CID2)
+#define RIF_CID3_BF		(1 << RIF_CID3)
+#define RIF_CID4_BF		(1 << RIF_CID4)
+#define RIF_CID5_BF		(1 << RIF_CID5)
+#define RIF_CID6_BF		(1 << RIF_CID6)
+#define RIF_CID7_BF		(1 << RIF_CID7)
+
+/* RIFSC secure levels */
+#define RIF_NSEC		0x0
+#define RIF_SEC			0x1
+
+/* RIFSC privilege levels */
+#define RIF_NPRIV		0x0
+#define RIF_PRIV		0x1
+
+/* RIFSC semaphore modes */
+#define RIF_SEM_DIS		0x0
+#define RIF_SEM_EN		0x1
+
+/* RIFSC CID filtering modes */
+#define RIF_CFDIS		0x0
+#define RIF_CFEN		0x1
+
+/* RIFSC lock states */
+#define RIF_UNLOCK		0x0
+#define RIF_LOCK		0x1
+
+#define RIFPROT(rifid, sem_list, sec, priv, scid, sem_en, cfen) \
+	(((rifid) << 24) | ((sem_list) << 16) | ((priv) << 9) | ((sec) << 8) | ((scid) << 4) | \
+	 ((sem_en) << 1) | (cfen))
+
+/* Masters IDs */
+#define RIMU_ID(idx)		(idx)
+
+/* Master configuration modes */
+#define RIF_CIDSEL_P		0x0 /* Config from RISUP */
+#define RIF_CIDSEL_M		0x1 /* Config from RIMU */
+
+#define RIMUPROT(rimuid, scid, sec, priv, mode) \
+	(((rimuid) << 16) | ((priv) << 9) | ((sec) << 8) | ((scid) << 4) | ((mode) << 2))
+
+/* RISAF region IDs */
+#define RISAF_REG_ID(idx)	(idx)
+
+/* RISAF base region enable modes */
+#define RIF_BREN_DIS		0x0
+#define RIF_BREN_EN		0x1
+
+/* RISAF encryption modes */
+#define RIF_ENC_DIS		0x0
+#define RIF_ENC_EN		0x1
+
+#define RISAFPROT(risaf_region, cid_read_list, cid_write_list, cid_priv_list, sec, enc, enabled) \
+	(((cid_write_list) << 24) | ((cid_read_list) << 16) | ((cid_priv_list) << 8) | \
+	 ((enc) << 7) | ((sec) << 6) | ((enabled) << 5) | (risaf_region))
+
+/* RISAB page IDs */
+#define RISAB_PAGE_ID(idx)	(idx)
+
+/* RISAB control modes */
+#define RIF_DDCID_DIS		0x0
+#define RIF_DDCID_EN		0x1
+
+#define RISABPROT(risab_page, delegate_en, delegate_cid, sec, default_priv, cid_read_list, \
+		  cid_write_list, cid_priv_list, enabled) \
+	(((risab_page) << 24) | ((default_priv) << 9) | ((sec) << 8) | ((delegate_cid) << 4) | \
+	 ((delegate_en) << 2) | (enabled)) \
+	((cid_write_list) << 16 | (cid_read_list) << 8 | (cid_priv_list))
+
+#endif /* _DT_BINDINGS_RIF_H */
+
diff --git a/include/dt-bindings/soc/st,stm32-etzpc.h b/include/dt-bindings/soc/st,stm32-etzpc.h
index 3f9fb3b12..199c83154 100644
--- a/include/dt-bindings/soc/st,stm32-etzpc.h
+++ b/include/dt-bindings/soc/st,stm32-etzpc.h
@@ -17,4 +17,90 @@
 #define DECPROT_UNLOCK		0x0
 #define DECPROT_LOCK		0x1
 
+/* ETZPC ID */
+#define STM32MP1_ETZPC_STGENC_ID	0
+#define STM32MP1_ETZPC_BKPSRAM_ID	1
+#define STM32MP1_ETZPC_IWDG1_ID		2
+#define STM32MP1_ETZPC_USART1_ID	3
+#define STM32MP1_ETZPC_SPI6_ID		4
+#define STM32MP1_ETZPC_I2C4_ID		5
+#define STM32MP1_ETZPC_RNG1_ID		7
+#define STM32MP1_ETZPC_HASH1_ID		8
+#define STM32MP1_ETZPC_CRYP1_ID		9
+#define STM32MP1_ETZPC_DDRCTRL_ID	10
+#define STM32MP1_ETZPC_DDRPHYC_ID	11
+#define STM32MP1_ETZPC_I2C6_ID		12
+#define STM32MP1_ETZPC_TIM2_ID		16
+#define STM32MP1_ETZPC_TIM3_ID		17
+#define STM32MP1_ETZPC_TIM4_ID		18
+#define STM32MP1_ETZPC_TIM5_ID		19
+#define STM32MP1_ETZPC_TIM6_ID		20
+#define STM32MP1_ETZPC_TIM7_ID		21
+#define STM32MP1_ETZPC_TIM12_ID		22
+#define STM32MP1_ETZPC_TIM13_ID		23
+#define STM32MP1_ETZPC_TIM14_ID		24
+#define STM32MP1_ETZPC_LPTIM1_ID	25
+#define STM32MP1_ETZPC_WWDG1_ID		26
+#define STM32MP1_ETZPC_SPI2_ID		27
+#define STM32MP1_ETZPC_SPI3_ID		28
+#define STM32MP1_ETZPC_SPDIFRX_ID	29
+#define STM32MP1_ETZPC_USART2_ID	30
+#define STM32MP1_ETZPC_USART3_ID	31
+#define STM32MP1_ETZPC_UART4_ID		32
+#define STM32MP1_ETZPC_UART5_ID		33
+#define STM32MP1_ETZPC_I2C1_ID		34
+#define STM32MP1_ETZPC_I2C2_ID		35
+#define STM32MP1_ETZPC_I2C3_ID		36
+#define STM32MP1_ETZPC_I2C5_ID		37
+#define STM32MP1_ETZPC_CEC_ID		38
+#define STM32MP1_ETZPC_DAC_ID		39
+#define STM32MP1_ETZPC_UART7_ID		40
+#define STM32MP1_ETZPC_UART8_ID		41
+#define STM32MP1_ETZPC_MDIOS_ID		44
+#define STM32MP1_ETZPC_TIM1_ID		48
+#define STM32MP1_ETZPC_TIM8_ID		49
+#define STM32MP1_ETZPC_USART6_ID	51
+#define STM32MP1_ETZPC_SPI1_ID		52
+#define STM32MP1_ETZPC_SPI4_ID		53
+#define STM32MP1_ETZPC_TIM15_ID		54
+#define STM32MP1_ETZPC_TIM16_ID		55
+#define STM32MP1_ETZPC_TIM17_ID		56
+#define STM32MP1_ETZPC_SPI5_ID		57
+#define STM32MP1_ETZPC_SAI1_ID		58
+#define STM32MP1_ETZPC_SAI2_ID		59
+#define STM32MP1_ETZPC_SAI3_ID		60
+#define STM32MP1_ETZPC_DFSDM_ID		61
+#define STM32MP1_ETZPC_TT_FDCAN_ID	62
+#define STM32MP1_ETZPC_LPTIM2_ID	64
+#define STM32MP1_ETZPC_LPTIM3_ID	65
+#define STM32MP1_ETZPC_LPTIM4_ID	66
+#define STM32MP1_ETZPC_LPTIM5_ID	67
+#define STM32MP1_ETZPC_SAI4_ID		68
+#define STM32MP1_ETZPC_VREFBUF_ID	69
+#define STM32MP1_ETZPC_DCMI_ID		70
+#define STM32MP1_ETZPC_CRC2_ID		71
+#define STM32MP1_ETZPC_ADC_ID		72
+#define STM32MP1_ETZPC_HASH2_ID		73
+#define STM32MP1_ETZPC_RNG2_ID		74
+#define STM32MP1_ETZPC_CRYP2_ID		75
+#define STM32MP1_ETZPC_SRAM1_ID		80
+#define STM32MP1_ETZPC_SRAM2_ID		81
+#define STM32MP1_ETZPC_SRAM3_ID		82
+#define STM32MP1_ETZPC_SRAM4_ID		83
+#define STM32MP1_ETZPC_RETRAM_ID	84
+#define STM32MP1_ETZPC_OTG_ID		85
+#define STM32MP1_ETZPC_SDMMC3_ID	86
+#define STM32MP1_ETZPC_DLYBSD3_ID	87
+#define STM32MP1_ETZPC_DMA1_ID		88
+#define STM32MP1_ETZPC_DMA2_ID		89
+#define STM32MP1_ETZPC_DMAMUX_ID	90
+#define STM32MP1_ETZPC_FMC_ID		91
+#define STM32MP1_ETZPC_QSPI_ID		92
+#define STM32MP1_ETZPC_DLYBQ_ID		93
+#define STM32MP1_ETZPC_ETH_ID		94
+
+#define STM32MP1_ETZPC_MAX_ID		96
+
+#define DECPROT(id, mode, lock)		(((id) << 16) | ((mode) << 8) | (lock))
+
 #endif /* _DT_BINDINGS_STM32_ETZPC_H */
diff --git a/include/dt-bindings/soc/stm32mp13-mce.h b/include/dt-bindings/soc/stm32mp13-mce.h
new file mode 100644
index 000000000..15006fc61
--- /dev/null
+++ b/include/dt-bindings/soc/stm32mp13-mce.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause */
+/*
+ * Copyright (C) 2020, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef _DT_BINDINGS_STM32MP13_MCE_H
+#define _DT_BINDINGS_STM32MP13_MCE_H
+
+#define MCE_PLAINTEXT  U(0)
+#define MCE_ENCRYPT    U(1)
+
+#endif /* _DT_BINDINGS_STM32MP13_MCE_H */
diff --git a/include/dt-bindings/soc/stm32mp13-tzc400.h b/include/dt-bindings/soc/stm32mp13-tzc400.h
new file mode 100644
index 000000000..47c1761f7
--- /dev/null
+++ b/include/dt-bindings/soc/stm32mp13-tzc400.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause */
+/*
+ * Copyright (C) 2020-2021, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef _DT_BINDINGS_STM32MP13_TZC400_H
+#define _DT_BINDINGS_STM32MP13_TZC400_H
+
+#include <drivers/arm/tzc_common.h>
+
+#define STM32MP1_TZC_A7_ID		U(0)
+#define STM32MP1_TZC_LCD_ID		U(3)
+#define STM32MP1_TZC_MDMA_ID		U(5)
+#define STM32MP1_TZC_DMA_ID		U(6)
+#define STM32MP1_TZC_USB_HOST_ID	U(7)
+#define STM32MP1_TZC_USB_OTG_ID		U(8)
+#define STM32MP1_TZC_SDMMC_ID		U(9)
+#define STM32MP1_TZC_ETH_ID		U(10)
+#define STM32MP1_TZC_DCMIPP_ID		U(11)
+#define STM32MP1_TZC_DAP_ID		U(15)
+
+#define TZC_REGION_NSEC_ALL_ACCESS_RDWR \
+	(TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_A7_ID) | \
+	 TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_LCD_ID) | \
+	 TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_MDMA_ID) | \
+	 TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_DMA_ID) | \
+	 TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_USB_HOST_ID) | \
+	 TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_USB_OTG_ID) | \
+	 TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_SDMMC_ID) | \
+	 TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_ETH_ID) | \
+	 TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_DCMIPP_ID) | \
+	 TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_DAP_ID))
+
+#endif /* _DT_BINDINGS_STM32MP13_TZC400_H */
diff --git a/include/dt-bindings/soc/stm32mp25-rif.h b/include/dt-bindings/soc/stm32mp25-rif.h
new file mode 100644
index 000000000..61bc8d042
--- /dev/null
+++ b/include/dt-bindings/soc/stm32mp25-rif.h
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier:	GPL-2.0+	BSD-3-Clause
+ */
+
+#ifndef _DT_BINDINGS_STM32MP25_RIF_H
+#define _DT_BINDINGS_STM32MP25_RIF_H
+
+/* define RIFSC ID */
+#define STM32MP25_RIFSC_TIM1_ID			0
+#define STM32MP25_RIFSC_TIM2_ID			1
+#define STM32MP25_RIFSC_TIM3_ID			2
+#define STM32MP25_RIFSC_TIM4_ID			3
+#define STM32MP25_RIFSC_TIM5_ID			4
+#define STM32MP25_RIFSC_TIM6_ID			5
+#define STM32MP25_RIFSC_TIM7_ID			6
+#define STM32MP25_RIFSC_TIM8_ID			7
+#define STM32MP25_RIFSC_TIM10_ID		8
+#define STM32MP25_RIFSC_TIM11_ID		9
+#define STM32MP25_RIFSC_TIM12_ID		10
+#define STM32MP25_RIFSC_TIM13_ID		11
+#define STM32MP25_RIFSC_TIM14_ID		12
+#define STM32MP25_RIFSC_TIM15_ID		13
+#define STM32MP25_RIFSC_TIM16_ID		14
+#define STM32MP25_RIFSC_TIM17_ID		15
+#define STM32MP25_RIFSC_TIM20_ID		16
+#define STM32MP25_RIFSC_LPTIM1_ID		17
+#define STM32MP25_RIFSC_LPTIM2_ID		18
+#define STM32MP25_RIFSC_LPTIM3_ID		19
+#define STM32MP25_RIFSC_LPTIM4_ID		20
+#define STM32MP25_RIFSC_LPTIM5_ID		21
+#define STM32MP25_RIFSC_SPI1_ID			22
+#define STM32MP25_RIFSC_SPI2_ID			23
+#define STM32MP25_RIFSC_SPI3_ID			24
+#define STM32MP25_RIFSC_SPI4_ID			25
+#define STM32MP25_RIFSC_SPI5_ID			26
+#define STM32MP25_RIFSC_SPI6_ID			27
+#define STM32MP25_RIFSC_SPI7_ID			28
+#define STM32MP25_RIFSC_SPI8_ID			29
+#define STM32MP25_RIFSC_SPDIFRX_ID		30
+#define STM32MP25_RIFSC_USART1_ID		31
+#define STM32MP25_RIFSC_USART2_ID		32
+#define STM32MP25_RIFSC_USART3_ID		33
+#define STM32MP25_RIFSC_UART4_ID		34
+#define STM32MP25_RIFSC_UART5_ID		35
+#define STM32MP25_RIFSC_USART6_ID		36
+#define STM32MP25_RIFSC_UART7_ID		37
+#define STM32MP25_RIFSC_UART8_ID		38
+#define STM32MP25_RIFSC_UART9_ID		39
+#define STM32MP25_RIFSC_LPUART1_ID		40
+#define STM32MP25_RIFSC_I2C1_ID			41
+#define STM32MP25_RIFSC_I2C2_ID			42
+#define STM32MP25_RIFSC_I2C3_ID			43
+#define STM32MP25_RIFSC_I2C4_ID			44
+#define STM32MP25_RIFSC_I2C5_ID			45
+#define STM32MP25_RIFSC_I2C6_ID			46
+#define STM32MP25_RIFSC_I2C7_ID			47
+#define STM32MP25_RIFSC_I2C8_ID			48
+#define STM32MP25_RIFSC_SAI1_ID			49
+#define STM32MP25_RIFSC_SAI2_ID			50
+#define STM32MP25_RIFSC_SAI3_ID			51
+#define STM32MP25_RIFSC_SAI4_ID			52
+#define STM32MP25_RIFSC_MDF1_ID			54
+#define STM32MP25_RIFSC_ADF1_ID			55
+#define STM32MP25_RIFSC_FDCAN_ID		56
+#define STM32MP25_RIFSC_HDP_ID			57
+#define STM32MP25_RIFSC_ADC12_ID		58
+#define STM32MP25_RIFSC_ADC3_ID			59
+#define STM32MP25_RIFSC_ETH1_ID			60
+#define STM32MP25_RIFSC_ETH2_ID			61
+#define STM32MP25_RIFSC_USBH_ID			63
+#define STM32MP25_RIFSC_USB3DR_ID		66
+#define STM32MP25_RIFSC_COMBOPHY_ID		67
+#define STM32MP25_RIFSC_PCIE_ID			68
+#define STM32MP25_RIFSC_UCPD1_ID		69
+#define STM32MP25_RIFSC_ETHSW_CFG_ID		70
+#define STM32MP25_RIFSC_ACM_CFG_ID		71
+#define STM32MP25_RIFSC_ACM_MSGBUF_ID		72
+#define STM32MP25_RIFSC_STGEN_ID		73
+#define STM32MP25_RIFSC_OCTOSPI1_ID		74
+#define STM32MP25_RIFSC_OCTOSPI2_ID		75
+#define STM32MP25_RIFSC_SDMMC1_ID		76
+#define STM32MP25_RIFSC_SDMMC2_ID		77
+#define STM32MP25_RIFSC_SDMMC3_ID		78
+#define STM32MP25_RIFSC_GPU_ID			79
+#define STM32MP25_RIFSC_LTDC_CMN_ID		80
+#define STM32MP25_RIFSC_DSI_CMN_ID		81
+#define STM32MP25_RIFSC_LDITX_ID		84
+#define STM32MP25_RIFSC_CSI2HOST_ID		86
+#define STM32MP25_RIFSC_DCMIPP_ID		87
+#define STM32MP25_RIFSC_CCI_ID			88
+#define STM32MP25_RIFSC_VDEC_ID			89
+#define STM32MP25_RIFSC_VENC_ID			90
+#define STM32MP25_RIFSC_RNG_ID			92
+#define STM32MP25_RIFSC_PKA_ID			93
+#define STM32MP25_RIFSC_SAES_ID			94
+#define STM32MP25_RIFSC_HASH_ID			95
+#define STM32MP25_RIFSC_CRYP1_ID		96
+#define STM32MP25_RIFSC_CRYP2_ID		97
+#define STM32MP25_RIFSC_IWDG1_ID		98
+#define STM32MP25_RIFSC_IWDG2_ID		99
+#define STM32MP25_RIFSC_IWDG3_ID		100
+#define STM32MP25_RIFSC_IWDG4_ID		101
+#define STM32MP25_RIFSC_IWDG5_ID		102
+#define STM32MP25_RIFSC_WWDG1_ID		103
+#define STM32MP25_RIFSC_WWDG2_ID		104
+#define STM32MP25_RIFSC_VREFBUF_ID		106
+#define STM32MP25_RIFSC_DTS_ID			107
+#define STM32MP25_RIFSC_CRC_ID			109
+#define STM32MP25_RIFSC_SERC_ID			110
+#define STM32MP25_RIFSC_OCTOSPIM_ID		111
+#define STM32MP25_RIFSC_GICV2M_ID		112
+#define STM32MP25_RIFSC_I3C1_ID			114
+#define STM32MP25_RIFSC_I3C2_ID			115
+#define STM32MP25_RIFSC_I3C3_ID			116
+#define STM32MP25_RIFSC_I3C4_ID			117
+#define STM32MP25_RIFSC_ICACHE_DCACHE_ID	118
+#define STM32MP25_RIFSC_LTDC_L0L1_ID		119
+#define STM32MP25_RIFSC_LTDC_L2_ID		120
+#define STM32MP25_RIFSC_LTDC_ROT_ID		121
+#define STM32MP25_RIFSC_DSI_TRIG_ID		122
+#define STM32MP25_RIFSC_DSI_RDFIFO_ID		123
+#define STM32MP25_RIFSC_OTFDEC1_ID		125
+#define STM32MP25_RIFSC_OTFDEC2_ID		126
+#define STM32MP25_RIFSC_IAC_ID			127
+#define STM32MP25_RIFSC_BSEC_ID			177
+
+#define STM32MP25_RIFSC_MAX_ID			178
+
+#endif /* _DT_BINDINGS_STM32MP25_RIF_H */
+
diff --git a/include/lib/fconf/fconf_dyn_cfg_getter.h b/include/lib/fconf/fconf_dyn_cfg_getter.h
index 6f8da0d78..ff51c6c4d 100644
--- a/include/lib/fconf/fconf_dyn_cfg_getter.h
+++ b/include/lib/fconf/fconf_dyn_cfg_getter.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -9,6 +9,8 @@
 
 #include <lib/fconf/fconf.h>
 
+#define FCONF_INVALID_IDX	0xFFFFFFFFU
+
 /* Dynamic configuration related getter */
 #define dyn_cfg__dtb_getter(id)	dyn_cfg_dtb_info_getter(id)
 
@@ -18,6 +20,7 @@ struct dyn_cfg_dtb_info_t {
 	unsigned int config_id;
 };
 
+unsigned int dyn_cfg_dtb_info_get_index(unsigned int config_id);
 struct dyn_cfg_dtb_info_t *dyn_cfg_dtb_info_getter(unsigned int config_id);
 int fconf_populate_dtb_registry(uintptr_t config);
 
diff --git a/include/lib/psci/psci.h b/include/lib/psci/psci.h
index b56e98b5f..9f2a80ebe 100644
--- a/include/lib/psci/psci.h
+++ b/include/lib/psci/psci.h
@@ -349,6 +349,7 @@ int psci_node_hw_state(u_register_t target_cpu,
 int psci_features(unsigned int psci_fid);
 void __dead2 psci_power_down_wfi(void);
 void psci_arch_setup(void);
+unsigned int psci_is_last_on_cpu(void);
 
 #endif /*__ASSEMBLER__*/
 
diff --git a/include/lib/utils_def.h b/include/lib/utils_def.h
index 7a7012d3d..c005d6e3d 100644
--- a/include/lib/utils_def.h
+++ b/include/lib/utils_def.h
@@ -64,6 +64,16 @@
 	((val) + _div - (__typeof__(div)) 1) / _div;		\
 })
 
+/*
+ * Macro for unsigned integer division with nearest rounding variant.
+ * Default integer division rounds down.
+ */
+#define udiv_round_nearest(x, y) __extension__ ({	\
+	__typeof__(x) _x = (x);				\
+	__typeof__(y) _y = (y);				\
+	(_x + (_y / 2)) / _y;				\
+})
+
 #define MIN(x, y) __extension__ ({	\
 	__typeof__(x) _x = (x);		\
 	__typeof__(y) _y = (y);		\
diff --git a/include/plat/common/common_def.h b/include/plat/common/common_def.h
index 14ae603b9..7137bca8b 100644
--- a/include/plat/common/common_def.h
+++ b/include/plat/common/common_def.h
@@ -1,17 +1,48 @@
 /*
- * Copyright (c) 2015-2018, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
 #ifndef COMMON_DEF_H
 #define COMMON_DEF_H
 
-#include <platform_def.h>
-
 #include <common/bl_common.h>
 #include <lib/utils_def.h>
 #include <lib/xlat_tables/xlat_tables_defs.h>
 
+#include <platform_def.h>
+
+#define SZ_32				U(0x00000020)
+#define SZ_64				U(0x00000040)
+#define SZ_128				U(0x00000080)
+#define SZ_256				U(0x00000100)
+#define SZ_512				U(0x00000200)
+
+#define SZ_1K				U(0x00000400)
+#define SZ_2K				U(0x00000800)
+#define SZ_4K				U(0x00001000)
+#define SZ_8K				U(0x00002000)
+#define SZ_16K				U(0x00004000)
+#define SZ_32K				U(0x00008000)
+#define SZ_64K				U(0x00010000)
+#define SZ_128K				U(0x00020000)
+#define SZ_256K				U(0x00040000)
+#define SZ_512K				U(0x00080000)
+
+#define SZ_1M				U(0x00100000)
+#define SZ_2M				U(0x00200000)
+#define SZ_4M				U(0x00400000)
+#define SZ_8M				U(0x00800000)
+#define SZ_16M				U(0x01000000)
+#define SZ_32M				U(0x02000000)
+#define SZ_64M				U(0x04000000)
+#define SZ_128M				U(0x08000000)
+#define SZ_256M				U(0x10000000)
+#define SZ_512M				U(0x20000000)
+
+#define SZ_1G				U(0x40000000)
+#define SZ_2G				U(0x80000000)
+
 /******************************************************************************
  * Required platform porting definitions that are expected to be common to
  * all platforms
diff --git a/include/plat/common/platform.h b/include/plat/common/platform.h
index 3fa63f555..60d43d702 100644
--- a/include/plat/common/platform.h
+++ b/include/plat/common/platform.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013-2021, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2013-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -113,6 +113,11 @@ unsigned int plat_ic_get_interrupt_id(unsigned int raw);
  ******************************************************************************/
 uintptr_t plat_get_my_stack(void);
 void plat_report_exception(unsigned int exception_type);
+#if AARCH32_EXCEPTION_DEBUG
+void plat_report_undef_inst(unsigned int fault_address);
+void plat_report_prefetch_abort(unsigned int fault_address);
+void plat_report_data_abort(unsigned int fault_address);
+#endif
 int plat_crash_console_init(void);
 int plat_crash_console_putc(int c);
 void plat_crash_console_flush(void);
@@ -121,6 +126,7 @@ void plat_panic_handler(void) __dead2;
 const char *plat_log_get_prefix(unsigned int log_level);
 void bl2_plat_preload_setup(void);
 int plat_try_next_boot_source(void);
+int plat_try_backup_partitions(unsigned int image_id);
 
 #if MEASURED_BOOT
 int plat_mboot_measure_image(unsigned int image_id, image_info_t *image_data);
@@ -311,6 +317,8 @@ int plat_get_nv_ctr(void *cookie, unsigned int *nv_ctr);
 int plat_set_nv_ctr(void *cookie, unsigned int nv_ctr);
 int plat_set_nv_ctr2(void *cookie, const struct auth_img_desc_s *img_desc,
 		unsigned int nv_ctr);
+int plat_get_hashed_pk(void *full_pk_ptr, unsigned int full_pk_len,
+		       void **hashed_pk_ptr, unsigned int *hash_pk_len);
 int get_mbedtls_heap_helper(void **heap_addr, size_t *heap_size);
 int plat_get_enc_key_info(enum fw_enc_status_t fw_enc_status, uint8_t *key,
 			  size_t *key_len, unsigned int *flags,
@@ -379,6 +387,8 @@ int32_t plat_is_smccc_feature_available(u_register_t fid);
 int plat_fwu_set_metadata_image_source(unsigned int image_id,
 				       uintptr_t *dev_handle,
 				       uintptr_t *image_spec);
-void plat_fwu_set_images_source(struct fwu_metadata *metadata);
+void plat_fwu_set_images_source(const struct fwu_metadata *metadata);
+uint32_t plat_fwu_get_boot_idx(void);
+bool plat_fwu_is_enabled(void);
 
 #endif /* PLATFORM_H */
diff --git a/lib/aarch32/misc_helpers.S b/lib/aarch32/misc_helpers.S
index 8b16f93cc..59e15bd1c 100644
--- a/lib/aarch32/misc_helpers.S
+++ b/lib/aarch32/misc_helpers.S
@@ -301,9 +301,9 @@ func fixup_gdt_reloc
 	cmp	r4, r6
 	blo	2f
 
-	/* Skip adding offset if address is >= upper limit */
+	/* Skip adding offset if address is > upper limit */
 	cmp	r4, r7
-	bhs	2f
+	bhi	2f
 
 	add 	r4, r0, r4
 	str	r4, [r3]
diff --git a/lib/aarch64/misc_helpers.S b/lib/aarch64/misc_helpers.S
index 6e4d1fc30..01531ca22 100644
--- a/lib/aarch64/misc_helpers.S
+++ b/lib/aarch64/misc_helpers.S
@@ -532,9 +532,9 @@ func fixup_gdt_reloc
 	cmp	x3, x6
 	b.lo	2f
 
-	/* Skip adding offset if address is >= upper limit */
+	/* Skip adding offset if address is > upper limit */
 	cmp	x3, x7
-	b.hs	2f
+	b.hi	2f
 	add	x3, x3, x0
 	str	x3, [x1]
 
@@ -582,9 +582,9 @@ func fixup_gdt_reloc
 	cmp	x4, x6
 	b.lo	2f
 
-	/* Skip adding offset if r_addend entry is >= upper limit */
+	/* Skip adding offset if r_addend entry is > upper limit */
 	cmp	x4, x7
-	b.hs	2f
+	b.hi	2f
 
 	add	x4, x0, x4	/* Diff(S) + r_addend */
 	str	x4, [x3]
diff --git a/lib/fconf/fconf_dyn_cfg_getter.c b/lib/fconf/fconf_dyn_cfg_getter.c
index 25dd7f9ed..34623fbd4 100644
--- a/lib/fconf/fconf_dyn_cfg_getter.c
+++ b/lib/fconf/fconf_dyn_cfg_getter.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -40,17 +40,30 @@ void set_config_info(uintptr_t config_addr, uint32_t config_max_size,
 	dtb_info->config_id = config_id;
 }
 
-struct dyn_cfg_dtb_info_t *dyn_cfg_dtb_info_getter(unsigned int config_id)
+/* Get index of the config_id image */
+unsigned int dyn_cfg_dtb_info_get_index(unsigned int config_id)
 {
 	unsigned int index;
 
 	/* Positions index to the proper config-id */
 	for (index = 0U; index < MAX_DTB_INFO; index++) {
 		if (dtb_infos[index].config_id == config_id) {
-			return &dtb_infos[index];
+			return index;
 		}
 	}
 
+	return FCONF_INVALID_IDX;
+}
+
+struct dyn_cfg_dtb_info_t *dyn_cfg_dtb_info_getter(unsigned int config_id)
+{
+	/* Positions index to the proper config-id */
+	unsigned int index = dyn_cfg_dtb_info_get_index(config_id);
+
+	if (index < MAX_DTB_INFO) {
+		return &dtb_infos[index];
+	}
+
 	WARN("FCONF: Invalid config id %u\n", config_id);
 
 	return NULL;
diff --git a/lib/optee/optee_utils.c b/lib/optee/optee_utils.c
index 72979cd9d..d30248fa2 100644
--- a/lib/optee/optee_utils.c
+++ b/lib/optee/optee_utils.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2017-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -192,8 +192,17 @@ int parse_optee_header(entry_point_info_t *header_ep,
 				&header->optee_image_list[num]);
 		} else if (header->optee_image_list[num].image_id ==
 				OPTEE_PAGED_IMAGE_ID) {
-			ret = parse_optee_image(paged_image_info,
-				&header->optee_image_list[num]);
+			if (paged_image_info == NULL) {
+				if (header->optee_image_list[num].size != 0U) {
+					ERROR("Paged image is not supported\n");
+					return -1;
+				}
+
+				continue;
+			} else {
+				ret = parse_optee_image(paged_image_info,
+							&header->optee_image_list[num]);
+			}
 		} else {
 			ERROR("Parse optee image failed.\n");
 			return -1;
@@ -215,8 +224,10 @@ int parse_optee_header(entry_point_info_t *header_ep,
 	 * header image arguments so that can be read by the
 	 * BL32 SPD.
 	 */
-	header_ep->args.arg1 = paged_image_info->image_base;
-	header_ep->args.arg2 = paged_image_info->image_size;
+	if (paged_image_info != NULL) {
+		header_ep->args.arg1 = paged_image_info->image_base;
+		header_ep->args.arg2 = paged_image_info->image_size;
+	}
 
 	/* Set OPTEE runtime arch - aarch32/aarch64 */
 	if (header->arch == 0) {
diff --git a/lib/psci/psci_private.h b/lib/psci/psci_private.h
index 72bd6bd11..0f55e8504 100644
--- a/lib/psci/psci_private.h
+++ b/lib/psci/psci_private.h
@@ -291,7 +291,6 @@ unsigned int psci_find_max_off_lvl(const psci_power_state_t *state_info);
 unsigned int psci_find_target_suspend_lvl(const psci_power_state_t *state_info);
 void psci_set_pwr_domains_to_run(unsigned int end_pwrlvl);
 void psci_print_power_domain_map(void);
-unsigned int psci_is_last_on_cpu(void);
 int psci_spd_migrate_info(u_register_t *mpidr);
 void psci_do_pwrdown_sequence(unsigned int power_level);
 
diff --git a/make_helpers/build_macros.mk b/make_helpers/build_macros.mk
index 12aaee684..2108570b9 100644
--- a/make_helpers/build_macros.mk
+++ b/make_helpers/build_macros.mk
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2015-2021, ARM Limited and Contributors. All rights reserved.
+# Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
 #
 # SPDX-License-Identifier: BSD-3-Clause
 #
@@ -144,6 +144,13 @@ $(2): $(1) enctool
 	$$(Q)$$(ENCTOOL) $$(ENC_ARGS) -i $$< -o $$@
 endef
 
+# GEN_METADATA
+define GEN_METADATA
+$(2): $(1) | $(dir $(2))
+	$$(ECHO) "  GEN_METADATA     $$<"
+	$$(Q)$$(FWUMDTOOL) $$(FWUMD_ARGS) jsonparse $$< -b $$@
+endef
+
 # TOOL_ADD_PAYLOAD appends the command line arguments required by fiptool to
 # package a new payload and/or by cert_create to generate certificate.
 # Optionally, it adds the dependency on this payload
diff --git a/make_helpers/defaults.mk b/make_helpers/defaults.mk
index e88148f4e..01bbb40f7 100644
--- a/make_helpers/defaults.mk
+++ b/make_helpers/defaults.mk
@@ -148,6 +148,9 @@ ENC_KEY	:= 1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef
 # Default dummy nonce for firmware encryption
 ENC_NONCE			:= 1234567890abcdef12345678
 
+# Flag to enable exception debug for AARCH32
+AARCH32_EXCEPTION_DEBUG		:= 0
+
 # Build flag to treat usage of deprecated platform and framework APIs as error.
 ERROR_DEPRECATED		:= 0
 
@@ -318,6 +321,10 @@ AMU_RESTRICT_COUNTERS		:= 0
 
 # Enable SVE for non-secure world by default
 ENABLE_SVE_FOR_NS		:= 1
+# SVE is only supported on AArch64 so disable it on AArch32.
+ifeq (${ARCH},aarch32)
+	override ENABLE_SVE_FOR_NS	:= 0
+endif
 ENABLE_SVE_FOR_SWD		:= 0
 
 # SME defaults to disabled
@@ -359,9 +366,6 @@ RAS_TRAP_LOWER_EL_ERR_ACCESS	:= 0
 # Build option to create cot descriptors using fconf
 COT_DESC_IN_DTB			:= 0
 
-# Build option to provide openssl directory path
-OPENSSL_DIR			:= /usr
-
 # Build option to use the SP804 timer instead of the generic one
 USE_SP804_TIMER			:= 0
 
diff --git a/plat/arm/common/arm_io_storage.c b/plat/arm/common/arm_io_storage.c
index 387086a29..aa44903ff 100644
--- a/plat/arm/common/arm_io_storage.c
+++ b/plat/arm/common/arm_io_storage.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2021, ARM Limited. All rights reserved.
+ * Copyright (c) 2015-2022, ARM Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -217,7 +217,7 @@ void arm_set_fip_addr(uint32_t active_fw_bank_idx)
  * bank to get its offset and length, and update these details in the I/O policy
  * of the FIP image.
  ******************************************************************************/
-void plat_fwu_set_images_source(struct fwu_metadata *metadata)
+void plat_fwu_set_images_source(const struct fwu_metadata *metadata)
 {
 	arm_set_fip_addr(metadata->active_index);
 }
@@ -247,4 +247,9 @@ int plat_fwu_set_metadata_image_source(unsigned int image_id,
 
 	return result;
 }
+
+bool plat_fwu_is_enabled(void)
+{
+	return true;
+}
 #endif /* PSA_FWU_SUPPORT */
diff --git a/plat/common/aarch32/platform_helpers.S b/plat/common/aarch32/platform_helpers.S
index 5b9cb5914..d2c20b4a7 100644
--- a/plat/common/aarch32/platform_helpers.S
+++ b/plat/common/aarch32/platform_helpers.S
@@ -8,6 +8,11 @@
 #include <asm_macros.S>
 
 	.weak	plat_report_exception
+#if AARCH32_EXCEPTION_DEBUG
+	.weak	plat_report_undef_inst
+	.weak	plat_report_prefetch_abort
+	.weak	plat_report_data_abort
+#endif
 	.weak	plat_reset_handler
 	.weak	plat_disable_acp
 	.weak	bl1_plat_prepare_exit
@@ -23,6 +28,35 @@ func plat_report_exception
 	bx	lr
 endfunc plat_report_exception
 
+#if AARCH32_EXCEPTION_DEBUG
+	/* -----------------------------------------------------
+	 * Placeholder function which should be redefined by
+	 * each platform.
+	 * -----------------------------------------------------
+	 */
+func plat_report_undef_inst
+	bx	lr
+endfunc plat_report_undef_inst
+
+	/* -----------------------------------------------------
+	 * Placeholder function which should be redefined by
+	 * each platform.
+	 * -----------------------------------------------------
+	 */
+func plat_report_prefetch_abort
+	bx	lr
+endfunc plat_report_prefetch_abort
+
+	/* -----------------------------------------------------
+	 * Placeholder function which should be redefined by
+	 * each platform.
+	 * -----------------------------------------------------
+	 */
+func plat_report_data_abort
+	bx	lr
+endfunc plat_report_data_abort
+#endif
+
 	/* -----------------------------------------------------
 	 * Placeholder function which should be redefined by
 	 * each platform.
diff --git a/plat/common/plat_bl_common.c b/plat/common/plat_bl_common.c
index 89b77ba6c..cdf5a26d0 100644
--- a/plat/common/plat_bl_common.c
+++ b/plat/common/plat_bl_common.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2020, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2018-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -25,6 +25,7 @@
 #pragma weak bl2_plat_handle_pre_image_load
 #pragma weak bl2_plat_handle_post_image_load
 #pragma weak plat_try_next_boot_source
+#pragma weak plat_try_backup_partitions
 #pragma weak plat_get_enc_key_info
 #pragma weak plat_is_smccc_feature_available
 #pragma weak plat_get_soc_version
@@ -74,6 +75,11 @@ int plat_try_next_boot_source(void)
 	return 0;
 }
 
+int plat_try_backup_partitions(unsigned int image_id)
+{
+	return 0;
+}
+
 /*
  * Weak implementation to provide dummy decryption key only for test purposes,
  * platforms must override this API for any real world firmware encryption
diff --git a/plat/st/common/bl2_io_storage.c b/plat/st/common/bl2_io_storage.c
index b0314d2ab..93f824bf9 100644
--- a/plat/st/common/bl2_io_storage.c
+++ b/plat/st/common/bl2_io_storage.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2021, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -10,20 +10,29 @@
 #include <arch_helpers.h>
 #include <common/debug.h>
 #include <common/desc_image_load.h>
+#include <drivers/fwu/fwu.h>
+#include <drivers/fwu/fwu_metadata.h>
 #include <drivers/io/io_block.h>
 #include <drivers/io/io_driver.h>
+#include <drivers/io/io_encrypted.h>
 #include <drivers/io/io_fip.h>
 #include <drivers/io/io_memmap.h>
 #include <drivers/io/io_mtd.h>
 #include <drivers/io/io_storage.h>
 #include <drivers/mmc.h>
+#include <drivers/partition/efi.h>
 #include <drivers/partition/partition.h>
 #include <drivers/raw_nand.h>
 #include <drivers/spi_nand.h>
 #include <drivers/spi_nor.h>
 #include <drivers/st/io_mmc.h>
 #include <drivers/st/stm32_fmc2_nand.h>
+#if STM32MP13 || STM32MP15
 #include <drivers/st/stm32_qspi.h>
+#endif
+#if STM32MP25
+#include <drivers/st/stm32_ospi.h>
+#endif
 #include <drivers/st/stm32_sdmmc2.h>
 #include <drivers/usb_device.h>
 #include <lib/fconf/fconf.h>
@@ -34,7 +43,9 @@
 
 #include <platform_def.h>
 #include <stm32cubeprogrammer.h>
+#include <stm32mp_efi.h>
 #include <stm32mp_fconf_getter.h>
+#include <stm32mp_io_storage.h>
 #include <usb_dfu.h>
 
 /* IO devices */
@@ -42,6 +53,12 @@ uintptr_t fip_dev_handle;
 uintptr_t storage_dev_handle;
 
 static const io_dev_connector_t *fip_dev_con;
+static uint32_t nand_block_sz;
+
+#ifndef DECRYPTION_SUPPORT_none
+static const io_dev_connector_t *enc_dev_con;
+uintptr_t enc_dev_handle;
+#endif
 
 #if STM32MP_SDMMC || STM32MP_EMMC
 static struct mmc_device_info mmc_info;
@@ -99,7 +116,7 @@ static io_mtd_dev_spec_t spi_nand_dev_spec = {
 static const io_dev_connector_t *spi_dev_con;
 #endif
 
-#if STM32MP_USB_PROGRAMMER
+#if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
 static const io_dev_connector_t *memmap_dev_con;
 #endif
 
@@ -113,6 +130,29 @@ int open_fip(const uintptr_t spec)
 	return io_dev_init(fip_dev_handle, (uintptr_t)FIP_IMAGE_ID);
 }
 
+#ifndef DECRYPTION_SUPPORT_none
+int open_enc_fip(const uintptr_t spec)
+{
+	int result;
+	uintptr_t local_image_handle;
+
+	result = io_dev_init(enc_dev_handle, (uintptr_t)ENC_IMAGE_ID);
+	if (result != 0) {
+		return result;
+	}
+
+	result = io_open(enc_dev_handle, spec, &local_image_handle);
+	if (result != 0) {
+		return result;
+	}
+
+	VERBOSE("Using encrypted FIP\n");
+	io_close(local_image_handle);
+
+	return 0;
+}
+#endif
+
 int open_storage(const uintptr_t spec)
 {
 	return io_dev_init(storage_dev_handle, 0);
@@ -127,15 +167,18 @@ static void print_boot_device(boot_api_context_t *boot_context)
 	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_EMMC:
 		INFO("Using EMMC\n");
 		break;
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_QSPI:
-		INFO("Using QSPI NOR\n");
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_SPI:
+		INFO("Using SPI NOR\n");
 		break;
 	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_FMC:
 		INFO("Using FMC NAND\n");
 		break;
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_QSPI:
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_SPI:
 		INFO("Using SPI NAND\n");
 		break;
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART:
+		INFO("Using UART\n");
+		break;
 	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB:
 		INFO("Using USB\n");
 		break;
@@ -182,6 +225,10 @@ static void boot_mmc(enum mmc_device_type mmc_dev_type,
 		break;
 	}
 
+	if (mmc_dev_type == MMC_IS_SD) {
+		params.flags = MMC_FLAG_SD_CMD6;
+	}
+
 	params.device_info = &mmc_info;
 	if (stm32_sdmmc2_mmc_init(&params) != 0) {
 		ERROR("SDMMC%u init failed\n", boot_interface_instance);
@@ -203,9 +250,15 @@ static void boot_mmc(enum mmc_device_type mmc_dev_type,
 #if STM32MP_SPI_NOR
 static void boot_spi_nor(boot_api_context_t *boot_context)
 {
-	int io_result __unused;
+	int io_result __unused = 0;
 
+#if STM32MP13 || STM32MP15
 	io_result = stm32_qspi_init();
+#endif
+#if STM32MP25
+	io_result = stm32_ospi_init();
+#endif
+
 	assert(io_result == 0);
 
 	io_result = register_io_dev_mtd(&spi_dev_con);
@@ -235,15 +288,22 @@ static void boot_fmc2_nand(boot_api_context_t *boot_context)
 	io_result = io_dev_open(nand_dev_con, (uintptr_t)&nand_dev_spec,
 				&storage_dev_handle);
 	assert(io_result == 0);
+
+	nand_block_sz = nand_dev_spec.erase_size;
 }
 #endif /* STM32MP_RAW_NAND */
 
 #if STM32MP_SPI_NAND
 static void boot_spi_nand(boot_api_context_t *boot_context)
 {
-	int io_result __unused;
+	int io_result __unused = 0;
 
+#if STM32MP13 || STM32MP15
 	io_result = stm32_qspi_init();
+#endif
+#if STM32MP25
+	io_result = stm32_ospi_init();
+#endif
 	assert(io_result == 0);
 
 	io_result = register_io_dev_mtd(&spi_dev_con);
@@ -254,10 +314,12 @@ static void boot_spi_nand(boot_api_context_t *boot_context)
 				(uintptr_t)&spi_nand_dev_spec,
 				&storage_dev_handle);
 	assert(io_result == 0);
+
+	nand_block_sz = spi_nand_dev_spec.erase_size;
 }
 #endif /* STM32MP_SPI_NAND */
 
-#if STM32MP_USB_PROGRAMMER
+#if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
 static void mmap_io_setup(void)
 {
 	int io_result __unused;
@@ -270,18 +332,37 @@ static void mmap_io_setup(void)
 	assert(io_result == 0);
 }
 
-static void stm32cubeprogrammer_usb(void)
+#if STM32MP_UART_PROGRAMMER
+static void stm32cubeprogrammer_uart(uint8_t phase, uintptr_t base, size_t len)
+{
+	int ret __unused;
+	boot_api_context_t *boot_context =
+		(boot_api_context_t *)stm32mp_get_boot_ctx_address();
+	uintptr_t uart_base;
+
+	uart_base = get_uart_address(boot_context->boot_interface_instance);
+	ret = stm32cubeprog_uart_load(uart_base, phase, base, len);
+	assert(ret == 0);
+}
+#endif
+
+#if STM32MP_USB_PROGRAMMER
+static void stm32cubeprogrammer_usb(uint8_t phase, uintptr_t base, size_t len)
 {
 	int ret __unused;
-	struct usb_handle *pdev;
+	static struct usb_handle *pdev;
 
 	/* Init USB on platform */
-	pdev = usb_dfu_plat_init();
+	if (pdev == NULL) {
+		pdev = usb_dfu_plat_init();
+	}
 
-	ret = stm32cubeprog_usb_load(pdev, DWL_BUFFER_BASE, DWL_BUFFER_SIZE);
+	ret = stm32cubeprog_usb_load(pdev, phase, base, len);
 	assert(ret == 0);
 }
 #endif
+#endif /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
+
 
 void stm32mp_io_setup(void)
 {
@@ -303,6 +384,15 @@ void stm32mp_io_setup(void)
 	io_result = io_dev_open(fip_dev_con, (uintptr_t)NULL,
 				&fip_dev_handle);
 
+#ifndef DECRYPTION_SUPPORT_none
+	io_result = register_io_dev_enc(&enc_dev_con);
+	assert(io_result == 0);
+
+	io_result = io_dev_open(enc_dev_con, (uintptr_t)NULL,
+				&enc_dev_handle);
+	assert(io_result == 0);
+#endif
+
 	switch (boot_context->boot_interface_selected) {
 #if STM32MP_SDMMC
 	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_SD:
@@ -317,7 +407,7 @@ void stm32mp_io_setup(void)
 		break;
 #endif
 #if STM32MP_SPI_NOR
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_QSPI:
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_SPI:
 		dmbsy();
 		boot_spi_nor(boot_context);
 		break;
@@ -329,13 +419,18 @@ void stm32mp_io_setup(void)
 		break;
 #endif
 #if STM32MP_SPI_NAND
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_QSPI:
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_SPI:
 		dmbsy();
 		boot_spi_nand(boot_context);
 		break;
 #endif
+#if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
+#if STM32MP_UART_PROGRAMMER
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART:
+#endif
 #if STM32MP_USB_PROGRAMMER
 	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB:
+#endif
 		dmbsy();
 		mmap_io_setup();
 		break;
@@ -354,24 +449,41 @@ int bl2_plat_handle_pre_image_load(unsigned int image_id)
 	static bool gpt_init_done __unused;
 	uint16_t boot_itf = stm32mp_get_boot_itf_selected();
 
+	if (stm32mp_skip_boot_device_after_standby()) {
+		return 0;
+	}
+
 	switch (boot_itf) {
 #if STM32MP_SDMMC || STM32MP_EMMC
 	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_SD:
 	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_EMMC:
 		if (!gpt_init_done) {
+/*
+ * With FWU Multi Bank feature enabled, the selection of
+ * the image to boot will be done by fwu_init calling the
+ * platform hook, plat_fwu_set_images_source.
+ */
+#if !PSA_FWU_SUPPORT
 			const partition_entry_t *entry;
+			const struct efi_guid img_type_guid = STM32MP_FIP_GUID;
+			uuid_t img_type_uuid;
 
+			guidcpy(&img_type_uuid, &img_type_guid);
 			partition_init(GPT_IMAGE_ID);
-			entry = get_partition_entry(FIP_IMAGE_NAME);
+			entry = get_partition_entry_by_type(&img_type_uuid);
 			if (entry == NULL) {
-				ERROR("Could NOT find the %s partition!\n",
-				      FIP_IMAGE_NAME);
-				return -ENOENT;
+				entry = get_partition_entry(FIP_IMAGE_NAME);
+				if (entry == NULL) {
+					ERROR("Could NOT find the %s partition!\n",
+					      FIP_IMAGE_NAME);
+
+					return -ENOENT;
+				}
 			}
 
 			image_block_spec.offset = entry->start;
 			image_block_spec.length = entry->length;
-
+#endif
 			gpt_init_done = true;
 		} else {
 			bl_mem_params_node_t *bl_mem_params = get_bl_mem_params_node(image_id);
@@ -388,22 +500,70 @@ int bl2_plat_handle_pre_image_load(unsigned int image_id)
 	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_FMC:
 #endif
 #if STM32MP_SPI_NAND
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_QSPI:
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_SPI:
 #endif
+/*
+ * With FWU Multi Bank feature enabled, the selection of
+ * the image to boot will be done by fwu_init calling the
+ * platform hook, plat_fwu_set_images_source.
+ */
+#if !PSA_FWU_SUPPORT
 		image_block_spec.offset = STM32MP_NAND_FIP_OFFSET;
+#endif
 		break;
 #endif
 
 #if STM32MP_SPI_NOR
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_QSPI:
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_SPI:
+/*
+ * With FWU Multi Bank feature enabled, the selection of
+ * the image to boot will be done by fwu_init calling the
+ * platform hook, plat_fwu_set_images_source.
+ */
+#if !PSA_FWU_SUPPORT
 		image_block_spec.offset = STM32MP_NOR_FIP_OFFSET;
+#endif
 		break;
 #endif
 
+#if STM32MP_UART_PROGRAMMER
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART:
+#if STM32MP_DDR_FIP_IO_STORAGE
+		if (image_id == DDR_FW_ID) {
+			stm32cubeprogrammer_uart(PHASE_DDR_FW,
+						 DWL_DDR_BUFFER_BASE,
+						 DWL_DDR_BUFFER_SIZE);
+			/* FIP loaded at DWL address */
+			image_block_spec.offset = DWL_DDR_BUFFER_BASE;
+			image_block_spec.length = DWL_DDR_BUFFER_SIZE;
+		}
+#endif
+		if (image_id == FW_CONFIG_ID) {
+			stm32cubeprogrammer_uart(PHASE_SSBL,
+						 DWL_BUFFER_BASE,
+						 DWL_BUFFER_SIZE);
+			/* FIP loaded at DWL address */
+			image_block_spec.offset = DWL_BUFFER_BASE;
+			image_block_spec.length = DWL_BUFFER_SIZE;
+		}
+		break;
+#endif
 #if STM32MP_USB_PROGRAMMER
 	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB:
+#if STM32MP_DDR_FIP_IO_STORAGE
+		if (image_id == DDR_FW_ID) {
+			stm32cubeprogrammer_usb(PHASE_DDR_FW,
+						DWL_DDR_BUFFER_BASE,
+						DWL_DDR_BUFFER_SIZE);
+			/* FIP loaded at DWL address */
+			image_block_spec.offset = DWL_DDR_BUFFER_BASE;
+			image_block_spec.length = DWL_DDR_BUFFER_SIZE;
+		}
+#endif
 		if (image_id == FW_CONFIG_ID) {
-			stm32cubeprogrammer_usb();
+			stm32cubeprogrammer_usb(PHASE_SSBL,
+						DWL_BUFFER_BASE,
+						DWL_BUFFER_SIZE);
 			/* FIP loaded at DWL address */
 			image_block_spec.offset = DWL_BUFFER_BASE;
 			image_block_spec.length = DWL_BUFFER_SIZE;
@@ -438,3 +598,221 @@ int plat_get_image_source(unsigned int image_id, uintptr_t *dev_handle,
 
 	return rc;
 }
+
+/*
+ * This function shall return 0 if it cannot find an alternate
+ * image to be loaded or it returns 1 otherwise.
+ */
+int plat_try_backup_partitions(unsigned int image_id)
+{
+	static unsigned int backup_id;
+	static unsigned int backup_block_nb;
+
+	/* Check if NAND storage used */
+	if (nand_block_sz == 0U) {
+		return 0;
+	}
+
+	if (backup_id != image_id) {
+		backup_block_nb = PLATFORM_MTD_MAX_PART_SIZE / nand_block_sz;
+		backup_id = image_id;
+	}
+
+	if (backup_block_nb-- == 0U) {
+		return 0;
+	}
+
+#if PSA_FWU_SUPPORT
+	if (((image_block_spec.offset < STM32MP_NAND_FIP_B_OFFSET) &&
+	     ((image_block_spec.offset + nand_block_sz) >= STM32MP_NAND_FIP_B_OFFSET)) ||
+	    (image_block_spec.offset + nand_block_sz >= STM32MP_NAND_FIP_B_MAX_OFFSET)) {
+		return 0;
+	}
+#endif
+
+	image_block_spec.offset += nand_block_sz;
+
+	return 1;
+}
+
+#if PSA_FWU_SUPPORT
+/*
+ * In each boot in non-trial mode, we set the BKP register to
+ * FWU_MAX_TRIAL_REBOOT, and return the active_index from metadata.
+ *
+ * As long as the update agent didn't update the "accepted" field in metadata
+ * (ie we are in trial mode), we select the new active_index.
+ * To avoid infinite boot loop at trial boot we decrement a BKP register.
+ * If this counter is 0:
+ *     - an unexpected TAMPER event raised (that resets the BKP registers to 0)
+ *     - a power-off occurs before the update agent was able to update the
+ *       "accepted' field
+ *     - we already boot FWU_MAX_TRIAL_REBOOT times in trial mode.
+ * we select the previous_active_index.
+ */
+#define INVALID_BOOT_IDX		0xFFFFFFFF
+
+uint32_t plat_fwu_get_boot_idx(void)
+{
+	/*
+	 * Need to memoize the boot_idx, as this function is call twice,
+	 * and double call has an effect on returned value.
+	 */
+	static uint32_t memoize_boot_idx = INVALID_BOOT_IDX;
+	const struct fwu_metadata *data;
+
+	data = fwu_get_metadata();
+
+	if (memoize_boot_idx == INVALID_BOOT_IDX) {
+		memoize_boot_idx = data->active_index;
+		if (fwu_is_trial_run_state()) {
+			if (stm32_get_and_dec_fwu_trial_boot_cnt() == 0U) {
+				WARN("Trial FWU fails to many times");
+				memoize_boot_idx = data->previous_active_index;
+			}
+		} else {
+			stm32_set_max_fwu_trial_boot_cnt();
+		}
+	}
+
+	return memoize_boot_idx;
+}
+
+static void *stm32_get_image_spec(const uuid_t *img_type_uuid)
+{
+	unsigned int i;
+
+	for (i = 0U; i < MAX_NUMBER_IDS; i++) {
+		if ((guidcmp(&policies[i].img_type_guid, img_type_uuid)) == 0) {
+			return (void *)policies[i].image_spec;
+		}
+	}
+
+	return NULL;
+}
+
+void plat_fwu_set_images_source(const struct fwu_metadata *metadata)
+{
+	unsigned int i;
+	uint32_t boot_idx;
+	const partition_entry_t *entry __unused;
+	const uuid_t *img_type_uuid, *img_uuid;
+	io_block_spec_t *image_spec;
+
+	boot_idx = plat_fwu_get_boot_idx();
+	assert(boot_idx < NR_OF_FW_BANKS);
+
+	for (i = 0U; i < NR_OF_IMAGES_IN_FW_BANK; i++) {
+		img_type_uuid = &metadata->img_entry[i].img_type_uuid;
+
+		img_uuid = &metadata->img_entry[i].img_props[boot_idx].img_uuid;
+
+		image_spec = stm32_get_image_spec(img_type_uuid);
+		if (image_spec == NULL) {
+			ERROR("Unable to get image spec for the image in the metadata\n");
+			panic();
+		}
+
+#if (STM32MP_SDMMC || STM32MP_EMMC)
+		entry = get_partition_entry_by_uuid(img_uuid);
+		if (entry == NULL) {
+			ERROR("Unable to find the partition with the uuid mentioned in metadata\n");
+			panic();
+		}
+
+		image_spec->offset = entry->start;
+		image_spec->length = entry->length;
+#endif
+#if STM32MP_SPI_NOR
+		if (guidcmp(img_uuid, &STM32MP_NOR_FIP_A_GUID) == 0) {
+			image_spec->offset = STM32MP_NOR_FIP_A_OFFSET;
+		} else if (guidcmp(img_uuid, &STM32MP_NOR_FIP_B_GUID) == 0) {
+			image_spec->offset = STM32MP_NOR_FIP_B_OFFSET;
+		} else {
+			ERROR("Invalid uuid mentioned in metadata\n");
+			panic();
+		}
+#endif
+#if (STM32MP_SPI_NAND || STM32MP_RAW_NAND)
+		if (guidcmp(img_uuid, &STM32MP_NAND_FIP_A_GUID) == 0) {
+			image_spec->offset = STM32MP_NAND_FIP_A_OFFSET;
+		} else if (guidcmp(img_uuid, &STM32MP_NAND_FIP_B_GUID) == 0) {
+			image_spec->offset = STM32MP_NAND_FIP_B_OFFSET;
+		} else {
+			ERROR("Invalid uuid mentioned in metadata\n");
+			panic();
+		}
+#endif
+	}
+}
+
+static int plat_set_image_source(unsigned int image_id,
+				 uintptr_t *handle,
+				 uintptr_t *image_spec)
+{
+	struct plat_io_policy *policy;
+	io_block_spec_t *spec;
+	const partition_entry_t *entry __unused;
+
+	policy = &policies[image_id];
+	spec = (io_block_spec_t *)policy->image_spec;
+
+#if (STM32MP_SDMMC || STM32MP_EMMC)
+	partition_init(GPT_IMAGE_ID);
+
+	if (image_id == FWU_METADATA_IMAGE_ID) {
+		entry = get_partition_entry(METADATA_PART_1);
+	} else {
+		entry = get_partition_entry(METADATA_PART_2);
+	}
+
+	if (entry == NULL) {
+		ERROR("Unable to find a metadata partition\n");
+		return -ENOENT;
+	}
+
+	spec->offset = entry->start;
+	spec->length = entry->length;
+#endif
+
+#if STM32MP_SPI_NOR
+	if (image_id == FWU_METADATA_IMAGE_ID) {
+		spec->offset = STM32MP_NOR_METADATA1_OFFSET;
+	} else {
+		spec->offset = STM32MP_NOR_METADATA2_OFFSET;
+	}
+
+	spec->length = sizeof(struct fwu_metadata);
+#endif
+
+#if (STM32MP_SPI_NAND || STM32MP_RAW_NAND)
+	if (image_id == FWU_METADATA_IMAGE_ID) {
+		spec->offset = STM32MP_NAND_METADATA1_OFFSET;
+	} else {
+		spec->offset = STM32MP_NAND_METADATA2_OFFSET;
+	}
+
+	spec->length = sizeof(struct fwu_metadata);
+#endif
+
+	*image_spec = policy->image_spec;
+	*handle = *policy->dev_handle;
+
+	return 0;
+}
+
+int plat_fwu_set_metadata_image_source(unsigned int image_id,
+				       uintptr_t *handle,
+				       uintptr_t *image_spec)
+{
+	assert((image_id == FWU_METADATA_IMAGE_ID) ||
+	       (image_id == BKUP_FWU_METADATA_IMAGE_ID));
+
+	return plat_set_image_source(image_id, handle, image_spec);
+}
+
+bool plat_fwu_is_enabled(void)
+{
+	return !stm32mp_skip_boot_device_after_standby();
+}
+#endif /* PSA_FWU_SUPPORT */
diff --git a/plat/st/common/bl2_stm32_io_storage.c b/plat/st/common/bl2_stm32_io_storage.c
deleted file mode 100644
index 2d68a5028..000000000
--- a/plat/st/common/bl2_stm32_io_storage.c
+++ /dev/null
@@ -1,665 +0,0 @@
-/*
- * Copyright (c) 2015-2021, ARM Limited and Contributors. All rights reserved.
- *
- * SPDX-License-Identifier: BSD-3-Clause
- */
-
-#include <assert.h>
-#include <string.h>
-
-#include <arch_helpers.h>
-#include <common/debug.h>
-#include <drivers/io/io_block.h>
-#include <drivers/io/io_driver.h>
-#include <drivers/io/io_dummy.h>
-#include <drivers/io/io_mtd.h>
-#include <drivers/io/io_storage.h>
-#include <drivers/mmc.h>
-#include <drivers/partition/partition.h>
-#include <drivers/raw_nand.h>
-#include <drivers/spi_nand.h>
-#include <drivers/spi_nor.h>
-#include <drivers/st/io_mmc.h>
-#include <drivers/st/io_stm32image.h>
-#include <drivers/st/stm32_fmc2_nand.h>
-#include <drivers/st/stm32_qspi.h>
-#include <drivers/st/stm32_sdmmc2.h>
-#include <lib/mmio.h>
-#include <lib/utils.h>
-#include <plat/common/platform.h>
-
-#include <platform_def.h>
-
-/* IO devices */
-#ifndef AARCH32_SP_OPTEE
-static const io_dev_connector_t *dummy_dev_con;
-static uintptr_t dummy_dev_handle;
-static uintptr_t dummy_dev_spec;
-#endif
-
-static uintptr_t image_dev_handle;
-static uintptr_t storage_dev_handle;
-
-#if STM32MP_SDMMC || STM32MP_EMMC
-static struct mmc_device_info mmc_info;
-static io_block_spec_t gpt_block_spec = {
-	.offset = 0U,
-	.length = 34U * MMC_BLOCK_SIZE, /* Size of GPT table */
-};
-
-static uint32_t block_buffer[MMC_BLOCK_SIZE] __aligned(MMC_BLOCK_SIZE);
-
-static const io_block_dev_spec_t mmc_block_dev_spec = {
-	/* It's used as temp buffer in block driver */
-	.buffer = {
-		.offset = (size_t)&block_buffer,
-		.length = MMC_BLOCK_SIZE,
-	},
-	.ops = {
-		.read = mmc_read_blocks,
-		.write = NULL,
-	},
-	.block_size = MMC_BLOCK_SIZE,
-};
-
-#if STM32MP_EMMC_BOOT
-static io_block_spec_t emmc_boot_ssbl_block_spec = {
-	.offset = PLAT_EMMC_BOOT_SSBL_OFFSET,
-	.length = MMC_BLOCK_SIZE, /* We are interested only in first 4 bytes */
-};
-
-static const io_block_dev_spec_t mmc_block_dev_boot_part_spec = {
-	/* It's used as temp buffer in block driver */
-	.buffer = {
-		.offset = (size_t)&block_buffer,
-		.length = MMC_BLOCK_SIZE,
-	},
-	.ops = {
-		.read = mmc_boot_part_read_blocks,
-		.write = NULL,
-	},
-	.block_size = MMC_BLOCK_SIZE,
-};
-#endif
-
-static struct io_mmc_dev_spec mmc_device_spec = {
-	.use_boot_part = false,
-};
-
-static const io_dev_connector_t *mmc_dev_con;
-#endif /* STM32MP_SDMMC || STM32MP_EMMC */
-
-#if STM32MP_SPI_NOR
-static io_mtd_dev_spec_t spi_nor_dev_spec = {
-	.ops = {
-		.init = spi_nor_init,
-		.read = spi_nor_read,
-	},
-};
-#endif
-
-#if STM32MP_RAW_NAND
-static io_mtd_dev_spec_t nand_dev_spec = {
-	.ops = {
-		.init = nand_raw_init,
-		.read = nand_read,
-	},
-};
-
-static const io_dev_connector_t *nand_dev_con;
-#endif
-
-#if STM32MP_SPI_NAND
-static io_mtd_dev_spec_t spi_nand_dev_spec = {
-	.ops = {
-		.init = spi_nand_init,
-		.read = nand_read,
-	},
-};
-#endif
-
-#if STM32MP_SPI_NAND || STM32MP_SPI_NOR
-static const io_dev_connector_t *spi_dev_con;
-#endif
-
-#ifdef AARCH32_SP_OPTEE
-static const struct stm32image_part_info optee_header_partition_spec = {
-	.name = OPTEE_HEADER_IMAGE_NAME,
-	.binary_type = OPTEE_HEADER_BINARY_TYPE,
-};
-
-static const struct stm32image_part_info optee_core_partition_spec = {
-	.name = OPTEE_CORE_IMAGE_NAME,
-	.binary_type = OPTEE_CORE_BINARY_TYPE,
-};
-
-static const struct stm32image_part_info optee_paged_partition_spec = {
-	.name = OPTEE_PAGED_IMAGE_NAME,
-	.binary_type = OPTEE_PAGED_BINARY_TYPE,
-};
-#else
-static const io_block_spec_t bl32_block_spec = {
-	.offset = BL32_BASE,
-	.length = STM32MP_BL32_SIZE
-};
-#endif
-
-static const struct stm32image_part_info bl33_partition_spec = {
-	.name = BL33_IMAGE_NAME,
-	.binary_type = BL33_BINARY_TYPE,
-};
-
-enum {
-	IMG_IDX_BL33,
-#ifdef AARCH32_SP_OPTEE
-	IMG_IDX_OPTEE_HEADER,
-	IMG_IDX_OPTEE_CORE,
-	IMG_IDX_OPTEE_PAGED,
-#endif
-	IMG_IDX_NUM
-};
-
-static struct stm32image_device_info stm32image_dev_info_spec __unused = {
-	.lba_size = MMC_BLOCK_SIZE,
-	.part_info[IMG_IDX_BL33] = {
-		.name = BL33_IMAGE_NAME,
-		.binary_type = BL33_BINARY_TYPE,
-	},
-#ifdef AARCH32_SP_OPTEE
-	.part_info[IMG_IDX_OPTEE_HEADER] = {
-		.name = OPTEE_HEADER_IMAGE_NAME,
-		.binary_type = OPTEE_HEADER_BINARY_TYPE,
-	},
-	.part_info[IMG_IDX_OPTEE_CORE] = {
-		.name = OPTEE_CORE_IMAGE_NAME,
-		.binary_type = OPTEE_CORE_BINARY_TYPE,
-	},
-	.part_info[IMG_IDX_OPTEE_PAGED] = {
-		.name = OPTEE_PAGED_IMAGE_NAME,
-		.binary_type = OPTEE_PAGED_BINARY_TYPE,
-	},
-#endif
-};
-
-static io_block_spec_t stm32image_block_spec = {
-	.offset = 0U,
-	.length = 0U,
-};
-
-static const io_dev_connector_t *stm32image_dev_con __unused;
-
-#ifndef AARCH32_SP_OPTEE
-static int open_dummy(const uintptr_t spec);
-#endif
-static int open_image(const uintptr_t spec);
-static int open_storage(const uintptr_t spec);
-
-struct plat_io_policy {
-	uintptr_t *dev_handle;
-	uintptr_t image_spec;
-	int (*check)(const uintptr_t spec);
-};
-
-static const struct plat_io_policy policies[] = {
-#ifdef AARCH32_SP_OPTEE
-	[BL32_IMAGE_ID] = {
-		.dev_handle = &image_dev_handle,
-		.image_spec = (uintptr_t)&optee_header_partition_spec,
-		.check = open_image
-	},
-	[BL32_EXTRA1_IMAGE_ID] = {
-		.dev_handle = &image_dev_handle,
-		.image_spec = (uintptr_t)&optee_core_partition_spec,
-		.check = open_image
-	},
-	[BL32_EXTRA2_IMAGE_ID] = {
-		.dev_handle = &image_dev_handle,
-		.image_spec = (uintptr_t)&optee_paged_partition_spec,
-		.check = open_image
-	},
-#else
-	[BL32_IMAGE_ID] = {
-		.dev_handle = &dummy_dev_handle,
-		.image_spec = (uintptr_t)&bl32_block_spec,
-		.check = open_dummy
-	},
-#endif
-	[BL33_IMAGE_ID] = {
-		.dev_handle = &image_dev_handle,
-		.image_spec = (uintptr_t)&bl33_partition_spec,
-		.check = open_image
-	},
-#if STM32MP_SDMMC || STM32MP_EMMC
-	[GPT_IMAGE_ID] = {
-		.dev_handle = &storage_dev_handle,
-		.image_spec = (uintptr_t)&gpt_block_spec,
-		.check = open_storage
-	},
-#endif
-	[STM32_IMAGE_ID] = {
-		.dev_handle = &storage_dev_handle,
-		.image_spec = (uintptr_t)&stm32image_block_spec,
-		.check = open_storage
-	}
-};
-
-#ifndef AARCH32_SP_OPTEE
-static int open_dummy(const uintptr_t spec)
-{
-	return io_dev_init(dummy_dev_handle, 0);
-}
-#endif
-
-static int open_image(const uintptr_t spec)
-{
-	return io_dev_init(image_dev_handle, 0);
-}
-
-static int open_storage(const uintptr_t spec)
-{
-	return io_dev_init(storage_dev_handle, 0);
-}
-
-#if STM32MP_EMMC_BOOT
-static uint32_t get_boot_part_ssbl_header(void)
-{
-	uint32_t magic = 0U;
-	int io_result;
-	size_t bytes_read;
-
-	io_result = register_io_dev_block(&mmc_dev_con);
-	if (io_result != 0) {
-		panic();
-	}
-
-	io_result = io_dev_open(mmc_dev_con, (uintptr_t)&mmc_block_dev_boot_part_spec,
-				&storage_dev_handle);
-	assert(io_result == 0);
-
-	io_result = io_open(storage_dev_handle, (uintptr_t)&emmc_boot_ssbl_block_spec,
-			    &image_dev_handle);
-	assert(io_result == 0);
-
-	io_result = io_read(image_dev_handle, (uintptr_t)&magic, sizeof(magic),
-			    &bytes_read);
-	assert(io_result == 0);
-	assert(bytes_read == sizeof(magic));
-
-	io_result = io_dev_close(storage_dev_handle);
-	assert(io_result == 0);
-
-	return magic;
-}
-#endif
-
-static void print_boot_device(boot_api_context_t *boot_context)
-{
-	switch (boot_context->boot_interface_selected) {
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_SD:
-		INFO("Using SDMMC\n");
-		break;
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_EMMC:
-		INFO("Using EMMC\n");
-		break;
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_QSPI:
-		INFO("Using QSPI NOR\n");
-		break;
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_FMC:
-		INFO("Using FMC NAND\n");
-		break;
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_QSPI:
-		INFO("Using SPI NAND\n");
-		break;
-	default:
-		ERROR("Boot interface not found\n");
-		panic();
-		break;
-	}
-
-	if (boot_context->boot_interface_instance != 0U) {
-		INFO("  Instance %d\n", boot_context->boot_interface_instance);
-	}
-}
-
-static void stm32image_io_setup(void)
-{
-	int io_result __unused;
-
-	io_result = register_io_dev_stm32image(&stm32image_dev_con);
-	assert(io_result == 0);
-
-	io_result = io_dev_open(stm32image_dev_con,
-				(uintptr_t)&stm32image_dev_info_spec,
-				&image_dev_handle);
-	assert(io_result == 0);
-}
-
-#if STM32MP_SDMMC || STM32MP_EMMC
-static void boot_mmc(enum mmc_device_type mmc_dev_type,
-		     uint16_t boot_interface_instance)
-{
-	int io_result __unused;
-	uint8_t idx;
-	struct stm32image_part_info *part;
-	struct stm32_sdmmc2_params params;
-	const partition_entry_t *entry __unused;
-	uint32_t magic __unused;
-
-	zeromem(&params, sizeof(struct stm32_sdmmc2_params));
-
-	mmc_info.mmc_dev_type = mmc_dev_type;
-
-	switch (boot_interface_instance) {
-	case 1:
-		params.reg_base = STM32MP_SDMMC1_BASE;
-		break;
-	case 2:
-		params.reg_base = STM32MP_SDMMC2_BASE;
-		break;
-	case 3:
-		params.reg_base = STM32MP_SDMMC3_BASE;
-		break;
-	default:
-		WARN("SDMMC instance not found, using default\n");
-		if (mmc_dev_type == MMC_IS_SD) {
-			params.reg_base = STM32MP_SDMMC1_BASE;
-		} else {
-			params.reg_base = STM32MP_SDMMC2_BASE;
-		}
-		break;
-	}
-
-	params.device_info = &mmc_info;
-	if (stm32_sdmmc2_mmc_init(&params) != 0) {
-		ERROR("SDMMC%u init failed\n", boot_interface_instance);
-		panic();
-	}
-
-	stm32image_dev_info_spec.device_size =
-		stm32_sdmmc2_mmc_get_device_size();
-
-#if STM32MP_EMMC_BOOT
-	magic = get_boot_part_ssbl_header();
-
-	if (magic == BOOT_API_IMAGE_HEADER_MAGIC_NB) {
-		VERBOSE("%s, header found, jump to emmc load\n", __func__);
-		idx = IMG_IDX_BL33;
-		part = &stm32image_dev_info_spec.part_info[idx];
-		part->part_offset = PLAT_EMMC_BOOT_SSBL_OFFSET;
-		part->bkp_offset = 0U;
-		mmc_device_spec.use_boot_part = true;
-
-		goto emmc_boot;
-	} else {
-		WARN("%s: Can't find STM32 header on a boot partition\n", __func__);
-	}
-#endif
-
-	/* Open MMC as a block device to read GPT table */
-	io_result = register_io_dev_block(&mmc_dev_con);
-	if (io_result != 0) {
-		panic();
-	}
-
-	io_result = io_dev_open(mmc_dev_con, (uintptr_t)&mmc_block_dev_spec,
-				&storage_dev_handle);
-	assert(io_result == 0);
-
-	partition_init(GPT_IMAGE_ID);
-
-	io_result = io_dev_close(storage_dev_handle);
-	assert(io_result == 0);
-
-	for (idx = 0U; idx < IMG_IDX_NUM; idx++) {
-		part = &stm32image_dev_info_spec.part_info[idx];
-		entry = get_partition_entry(part->name);
-		if (entry == NULL) {
-			ERROR("Partition %s not found\n", part->name);
-			panic();
-		}
-
-		part->part_offset = entry->start;
-		part->bkp_offset = 0U;
-	}
-
-#if STM32MP_EMMC_BOOT
-emmc_boot:
-#endif
-	/*
-	 * Re-open MMC with io_mmc, for better perfs compared to
-	 * io_block.
-	 */
-	io_result = register_io_dev_mmc(&mmc_dev_con);
-	assert(io_result == 0);
-
-	io_result = io_dev_open(mmc_dev_con, (uintptr_t)&mmc_device_spec,
-				&storage_dev_handle);
-	assert(io_result == 0);
-}
-#endif /* STM32MP_SDMMC || STM32MP_EMMC */
-
-#if STM32MP_SPI_NOR
-static void boot_spi_nor(boot_api_context_t *boot_context)
-{
-	int io_result __unused;
-	uint8_t idx;
-	struct stm32image_part_info *part;
-
-	io_result = stm32_qspi_init();
-	assert(io_result == 0);
-
-	io_result = register_io_dev_mtd(&spi_dev_con);
-	assert(io_result == 0);
-
-	/* Open connections to device */
-	io_result = io_dev_open(spi_dev_con,
-				(uintptr_t)&spi_nor_dev_spec,
-				&storage_dev_handle);
-	assert(io_result == 0);
-
-	stm32image_dev_info_spec.device_size = spi_nor_dev_spec.device_size;
-
-	idx = IMG_IDX_BL33;
-	part = &stm32image_dev_info_spec.part_info[idx];
-	part->part_offset = STM32MP_NOR_BL33_OFFSET;
-	part->bkp_offset = 0U;
-
-#ifdef AARCH32_SP_OPTEE
-	idx = IMG_IDX_OPTEE_HEADER;
-	part = &stm32image_dev_info_spec.part_info[idx];
-	part->part_offset = STM32MP_NOR_TEEH_OFFSET;
-	part->bkp_offset = 0U;
-
-	idx = IMG_IDX_OPTEE_PAGED;
-	part = &stm32image_dev_info_spec.part_info[idx];
-	part->part_offset = STM32MP_NOR_TEED_OFFSET;
-	part->bkp_offset = 0U;
-
-	idx = IMG_IDX_OPTEE_CORE;
-	part = &stm32image_dev_info_spec.part_info[idx];
-	part->part_offset = STM32MP_NOR_TEEX_OFFSET;
-	part->bkp_offset = 0U;
-#endif
-}
-#endif /* STM32MP_SPI_NOR */
-
-#if STM32MP_RAW_NAND
-static void boot_fmc2_nand(boot_api_context_t *boot_context)
-{
-	int io_result __unused;
-	uint8_t idx;
-	struct stm32image_part_info *part;
-
-	io_result = stm32_fmc2_init();
-	assert(io_result == 0);
-
-	/* Register the IO device on this platform */
-	io_result = register_io_dev_mtd(&nand_dev_con);
-	assert(io_result == 0);
-
-	/* Open connections to device */
-	io_result = io_dev_open(nand_dev_con, (uintptr_t)&nand_dev_spec,
-				&storage_dev_handle);
-	assert(io_result == 0);
-
-	stm32image_dev_info_spec.device_size = nand_dev_spec.device_size;
-
-	idx = IMG_IDX_BL33;
-	part = &stm32image_dev_info_spec.part_info[idx];
-	part->part_offset = STM32MP_NAND_BL33_OFFSET;
-	part->bkp_offset = nand_dev_spec.erase_size;
-
-#ifdef AARCH32_SP_OPTEE
-	idx = IMG_IDX_OPTEE_HEADER;
-	part = &stm32image_dev_info_spec.part_info[idx];
-	part->part_offset = STM32MP_NAND_TEEH_OFFSET;
-	part->bkp_offset = nand_dev_spec.erase_size;
-
-	idx = IMG_IDX_OPTEE_PAGED;
-	part = &stm32image_dev_info_spec.part_info[idx];
-	part->part_offset = STM32MP_NAND_TEED_OFFSET;
-	part->bkp_offset = nand_dev_spec.erase_size;
-
-	idx = IMG_IDX_OPTEE_CORE;
-	part = &stm32image_dev_info_spec.part_info[idx];
-	part->part_offset = STM32MP_NAND_TEEX_OFFSET;
-	part->bkp_offset = nand_dev_spec.erase_size;
-#endif
-}
-#endif /* STM32MP_RAW_NAND */
-
-#if STM32MP_SPI_NAND
-static void boot_spi_nand(boot_api_context_t *boot_context)
-{
-	int io_result __unused;
-	uint8_t idx;
-	struct stm32image_part_info *part;
-
-	io_result = stm32_qspi_init();
-	assert(io_result == 0);
-
-	io_result = register_io_dev_mtd(&spi_dev_con);
-	assert(io_result == 0);
-
-	/* Open connections to device */
-	io_result = io_dev_open(spi_dev_con,
-				(uintptr_t)&spi_nand_dev_spec,
-				&storage_dev_handle);
-	assert(io_result == 0);
-
-	stm32image_dev_info_spec.device_size =
-		spi_nand_dev_spec.device_size;
-
-	idx = IMG_IDX_BL33;
-	part = &stm32image_dev_info_spec.part_info[idx];
-	part->part_offset = STM32MP_NAND_BL33_OFFSET;
-	part->bkp_offset = spi_nand_dev_spec.erase_size;
-
-#ifdef AARCH32_SP_OPTEE
-	idx = IMG_IDX_OPTEE_HEADER;
-	part = &stm32image_dev_info_spec.part_info[idx];
-	part->part_offset = STM32MP_NAND_TEEH_OFFSET;
-	part->bkp_offset = spi_nand_dev_spec.erase_size;
-
-	idx = IMG_IDX_OPTEE_PAGED;
-	part = &stm32image_dev_info_spec.part_info[idx];
-	part->part_offset = STM32MP_NAND_TEED_OFFSET;
-	part->bkp_offset = spi_nand_dev_spec.erase_size;
-
-	idx = IMG_IDX_OPTEE_CORE;
-	part = &stm32image_dev_info_spec.part_info[idx];
-	part->part_offset = STM32MP_NAND_TEEX_OFFSET;
-	part->bkp_offset = spi_nand_dev_spec.erase_size;
-#endif
-}
-#endif /* STM32MP_SPI_NAND */
-
-void stm32mp_io_setup(void)
-{
-	int io_result __unused;
-	boot_api_context_t *boot_context =
-		(boot_api_context_t *)stm32mp_get_boot_ctx_address();
-
-	print_boot_device(boot_context);
-
-	if ((boot_context->boot_partition_used_toboot == 1U) ||
-	    (boot_context->boot_partition_used_toboot == 2U)) {
-		INFO("Boot used partition fsbl%u\n",
-		     boot_context->boot_partition_used_toboot);
-	}
-
-#ifndef AARCH32_SP_OPTEE
-	io_result = register_io_dev_dummy(&dummy_dev_con);
-	assert(io_result == 0);
-
-	io_result = io_dev_open(dummy_dev_con, dummy_dev_spec,
-				&dummy_dev_handle);
-	assert(io_result == 0);
-#endif
-
-	switch (boot_context->boot_interface_selected) {
-#if STM32MP_SDMMC
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_SD:
-		dmbsy();
-		boot_mmc(MMC_IS_SD, boot_context->boot_interface_instance);
-		stm32image_io_setup();
-		break;
-#endif
-#if STM32MP_EMMC
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_EMMC:
-		dmbsy();
-		boot_mmc(MMC_IS_EMMC, boot_context->boot_interface_instance);
-		stm32image_io_setup();
-		break;
-#endif
-#if STM32MP_SPI_NOR
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_QSPI:
-		dmbsy();
-		boot_spi_nor(boot_context);
-		stm32image_io_setup();
-		break;
-#endif
-#if STM32MP_RAW_NAND
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_FMC:
-		dmbsy();
-		boot_fmc2_nand(boot_context);
-		stm32image_io_setup();
-		break;
-#endif
-#if STM32MP_SPI_NAND
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_QSPI:
-		dmbsy();
-		boot_spi_nand(boot_context);
-		stm32image_io_setup();
-		break;
-#endif
-
-	default:
-		ERROR("Boot interface %d not supported\n",
-		      boot_context->boot_interface_selected);
-		panic();
-		break;
-	}
-}
-
-/*
- * Return an IO device handle and specification which can be used to access
- * an image. Use this to enforce platform load policy.
- */
-int plat_get_image_source(unsigned int image_id, uintptr_t *dev_handle,
-			  uintptr_t *image_spec)
-{
-	int rc;
-	const struct plat_io_policy *policy;
-
-	assert(image_id < ARRAY_SIZE(policies));
-
-	policy = &policies[image_id];
-	rc = policy->check(policy->image_spec);
-	if (rc == 0) {
-		*image_spec = policy->image_spec;
-		*dev_handle = *(policy->dev_handle);
-	}
-
-	return rc;
-}
diff --git a/plat/st/common/common.mk b/plat/st/common/common.mk
new file mode 100644
index 000000000..9e31f96db
--- /dev/null
+++ b/plat/st/common/common.mk
@@ -0,0 +1,215 @@
+#
+# Copyright (c) 2022, ARM Limited and Contributors. All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+BL2_AT_EL3		:=	1
+
+STM32MP_EARLY_CONSOLE	?=	0
+STM32MP_RECONFIGURE_CONSOLE ?=	0
+STM32MP_UART_BAUDRATE	?=	115200
+
+# Add specific ST version
+ST_VERSION 		:=	r2.0
+ST_GIT_SHA1		:=	$(shell git rev-parse --short=8 HEAD 2>/dev/null)
+VERSION_STRING		:=	v${VERSION_MAJOR}.${VERSION_MINOR}-${PLAT}-${ST_VERSION}(${BUILD_TYPE}):${BUILD_STRING}(${ST_GIT_SHA1})
+
+TRUSTED_BOARD_BOOT	?=	0
+
+# Please don't increment this value without good understanding of
+# the monotonic counter
+STM32_TF_VERSION	?=	0
+
+# Enable dynamic memory mapping
+PLAT_XLAT_TABLES_DYNAMIC :=	1
+
+# STM32 image header binary type for BL2
+STM32_HEADER_BL2_BINARY_TYPE:=	0x10
+
+TF_CFLAGS		+=	-Wsign-compare
+
+# Boot devices
+STM32MP_EMMC		?=	0
+STM32MP_SDMMC		?=	0
+STM32MP_RAW_NAND	?=	0
+STM32MP_SPI_NAND	?=	0
+STM32MP_SPI_NOR		?=	0
+STM32MP_EMMC_BOOT	?=	0
+
+# Serial boot devices
+STM32MP_UART_PROGRAMMER	?=	0
+STM32MP_USB_PROGRAMMER	?=	0
+
+$(eval DTC_V = $(shell $(DTC) -v | awk '{print $$NF}'))
+$(eval DTC_VERSION = $(shell printf "%d" $(shell echo ${DTC_V} | cut -d- -f1 | sed "s/\./0/g" | grep -o "[0-9]*")))
+DTC_CPPFLAGS		+=	${INCLUDES}
+DTC_FLAGS		+=	-Wno-unit_address_vs_reg
+ifeq ($(shell test $(DTC_VERSION) -ge 10601; echo $$?),0)
+DTC_FLAGS		+=	-Wno-interrupt_provider
+endif
+
+# Macros and rules to build TF binary
+STM32_TF_ELF_LDFLAGS	:=	--hash-style=gnu --as-needed
+STM32_TF_LINKERFILE	:=	${BUILD_PLAT}/${PLAT}.ld
+
+ASFLAGS			+= -DBL2_BIN_PATH=\"${BUILD_PLAT}/bl2.bin\"
+
+# Variables for use with stm32image
+STM32IMAGEPATH		?= tools/stm32image
+STM32IMAGE		?= ${STM32IMAGEPATH}/stm32image${BIN_EXT}
+STM32IMAGE_SRC		:= ${STM32IMAGEPATH}/stm32image.c
+STM32_DEPS		+= ${STM32IMAGE}
+
+FIP_DEPS		+=	dtbs
+STM32MP_HW_CONFIG	:=	${BL33_CFG}
+
+# Add the HW_CONFIG to FIP and specify the same to certtool
+$(eval $(call TOOL_ADD_PAYLOAD,${STM32MP_HW_CONFIG},--hw-config))
+
+ifeq (${GENERATE_COT},1)
+$(eval $(call TOOL_ADD_PAYLOAD,${BUILD_PLAT}/tb_fw.crt,--tb-fw-cert))
+endif
+
+$(eval $(call CERT_ADD_CMD_OPT,${BUILD_PLAT}/bl2.bin,--tb-fw))
+CRT_DEPS+=${BUILD_PLAT}/bl2.bin
+
+# Add the build options to pack Trusted OS Extra1 and Trusted OS Extra2 images
+# in the FIP if the platform requires.
+ifneq ($(BL32_EXTRA1),)
+$(eval $(call TOOL_ADD_IMG,BL32_EXTRA1,--tos-fw-extra1,,$(ENCRYPT_BL32)))
+endif
+ifneq ($(BL32_EXTRA2),)
+$(eval $(call TOOL_ADD_IMG,BL32_EXTRA2,--tos-fw-extra2,,$(ENCRYPT_BL32)))
+endif
+
+# Enable flags for C files
+$(eval $(call assert_booleans,\
+	$(sort \
+		PLAT_XLAT_TABLES_DYNAMIC \
+		STM32MP_EARLY_CONSOLE \
+		STM32MP_EMMC \
+		STM32MP_EMMC_BOOT \
+		STM32MP_RAW_NAND \
+		STM32MP_RECONFIGURE_CONSOLE \
+		STM32MP_SDMMC \
+		STM32MP_SPI_NAND \
+		STM32MP_SPI_NOR \
+		STM32MP_UART_PROGRAMMER \
+		STM32MP_USB_PROGRAMMER \
+)))
+
+$(eval $(call assert_numerics,\
+	$(sort \
+		STM32_TF_VERSION \
+		STM32MP_UART_BAUDRATE \
+)))
+
+$(eval $(call add_defines,\
+	$(sort \
+		PLAT_XLAT_TABLES_DYNAMIC \
+		STM32_TF_VERSION \
+		STM32MP_EARLY_CONSOLE \
+		STM32MP_EMMC \
+		STM32MP_EMMC_BOOT \
+		STM32MP_RAW_NAND \
+		STM32MP_RECONFIGURE_CONSOLE \
+		STM32MP_SDMMC \
+		STM32MP_SPI_NAND \
+		STM32MP_SPI_NOR \
+		STM32MP_UART_BAUDRATE \
+		STM32MP_UART_PROGRAMMER \
+		STM32MP_USB_PROGRAMMER \
+)))
+
+# Include paths and source files
+PLAT_INCLUDES		+=	-Iplat/st/common/include/
+
+include lib/fconf/fconf.mk
+include lib/libfdt/libfdt.mk
+
+PLAT_BL_COMMON_SOURCES	+=	common/uuid.c						\
+				plat/st/common/stm32mp_common.c
+
+
+include lib/xlat_tables_v2/xlat_tables.mk
+PLAT_BL_COMMON_SOURCES	+=	${XLAT_TABLES_LIB_SRCS}
+
+PLAT_BL_COMMON_SOURCES	+=	drivers/clk/clk.c					\
+				drivers/delay_timer/delay_timer.c			\
+				drivers/delay_timer/generic_delay_timer.c		\
+				drivers/regulator/regulator_core.c			\
+				drivers/st/clk/stm32mp_clkfunc.c			\
+				drivers/st/ddr/stm32mp_ddr.c				\
+				drivers/st/gpio/stm32_gpio.c				\
+				drivers/st/pmic/stm32mp_pmic.c				\
+				drivers/st/regulator/regulator_fixed.c			\
+				drivers/st/regulator/regulator_gpio.c			\
+				plat/st/common/stm32mp_dt.c				\
+				plat/st/common/stm32mp_fconf_fuse.c			\
+				plat/st/common/stm32mp_shres_helpers.c
+
+BL2_SOURCES		+=	${FCONF_SOURCES} ${FCONF_DYN_SOURCES}
+
+BL2_SOURCES		+=	drivers/io/io_fip.c					\
+				plat/st/common/bl2_io_storage.c				\
+				plat/st/common/stm32mp_fconf_io.c
+
+BL2_SOURCES		+=	drivers/io/io_block.c					\
+				drivers/io/io_mtd.c					\
+				drivers/io/io_storage.c
+
+ifneq ($(filter 1,${STM32MP_EMMC} ${STM32MP_SDMMC}),)
+BL2_SOURCES		+=	drivers/mmc/mmc.c					\
+				drivers/partition/gpt.c					\
+				drivers/partition/partition.c				\
+				drivers/st/io/io_mmc.c
+endif
+
+ifneq ($(filter 1,${STM32MP_SPI_NAND} ${STM32MP_SPI_NOR}),)
+BL2_SOURCES		+=	drivers/mtd/spi-mem/spi_mem.c
+endif
+
+ifeq (${STM32MP_RAW_NAND},1)
+$(eval $(call add_define_val,NAND_ONFI_DETECT,1))
+BL2_SOURCES		+=	drivers/mtd/nand/raw_nand.c
+endif
+
+ifeq (${STM32MP_SPI_NAND},1)
+BL2_SOURCES		+=	drivers/mtd/nand/spi_nand.c
+endif
+
+ifeq (${STM32MP_SPI_NOR},1)
+ifneq (${STM32MP_FORCE_MTD_START_OFFSET},)
+$(eval $(call add_define_val,STM32MP_NOR_FIP_OFFSET,${STM32MP_FORCE_MTD_START_OFFSET}))
+endif
+BL2_SOURCES		+=	drivers/mtd/nor/spi_nor.c
+endif
+
+ifneq ($(filter 1,${STM32MP_RAW_NAND} ${STM32MP_SPI_NAND}),)
+ifneq (${STM32MP_FORCE_MTD_START_OFFSET},)
+$(eval $(call add_define_val,STM32MP_NAND_FIP_OFFSET,${STM32MP_FORCE_MTD_START_OFFSET}))
+endif
+BL2_SOURCES		+=	drivers/mtd/nand/core.c
+endif
+
+ifneq ($(filter 1,${STM32MP_UART_PROGRAMMER} ${STM32MP_USB_PROGRAMMER}),)
+BL2_SOURCES		+=	drivers/io/io_memmap.c
+endif
+
+ifeq (${STM32MP_UART_PROGRAMMER},1)
+BL2_SOURCES		+=	plat/st/common/stm32cubeprogrammer_uart.c
+endif
+
+ifeq (${STM32MP_USB_PROGRAMMER},1)
+BL2_SOURCES		+=	drivers/usb/usb_device.c				\
+				plat/st/common/stm32cubeprogrammer_usb.c		\
+				plat/st/common/usb_dfu.c
+endif
+
+BL2_SOURCES		+=	drivers/st/ddr/stm32mp_ddr_test.c			\
+				drivers/st/ddr/stm32mp_ram.c
+
+BL2_SOURCES		+=	common/desc_image_load.c
+
+BL2_SOURCES		+=	lib/optee/optee_utils.c
diff --git a/plat/st/common/common_rules.mk b/plat/st/common/common_rules.mk
new file mode 100644
index 000000000..8d4d0f3df
--- /dev/null
+++ b/plat/st/common/common_rules.mk
@@ -0,0 +1,79 @@
+#
+# Copyright (c) 2022, ARM Limited and Contributors. All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+# Compilation rules
+.PHONY: check_dtc_version stm32image clean_stm32image check_boot_device
+.SUFFIXES:
+
+all: check_dtc_version stm32image ${STM32_TF_STM32}
+
+distclean realclean clean: clean_stm32image
+
+bl2: check_boot_device
+
+check_boot_device:
+	@if [ ${STM32MP_EMMC} != 1 ] && \
+	    [ ${STM32MP_SDMMC} != 1 ] && \
+	    [ ${STM32MP_RAW_NAND} != 1 ] && \
+	    [ ${STM32MP_SPI_NAND} != 1 ] && \
+	    [ ${STM32MP_SPI_NOR} != 1 ] && \
+	    [ ${STM32MP_UART_PROGRAMMER} != 1 ] && \
+	    [ ${STM32MP_USB_PROGRAMMER} != 1 ]; then \
+		echo "No boot device driver is enabled"; \
+		false; \
+	fi
+
+stm32image: ${STM32IMAGE}
+
+${STM32IMAGE}: ${STM32IMAGE_SRC}
+	${Q}${MAKE} CPPFLAGS="" --no-print-directory -C ${STM32IMAGEPATH}
+
+clean_stm32image:
+	${Q}${MAKE} --no-print-directory -C ${STM32IMAGEPATH} clean
+
+check_dtc_version:
+	@if [ ${DTC_VERSION} -lt 10404 ]; then \
+		echo "dtc version too old (${DTC_V}), you need at least version 1.4.4"; \
+		false; \
+	fi
+
+# Create DTB file for BL2
+${BUILD_PLAT}/fdts/%-bl2.dts: fdts/%.dts fdts/${BL2_DTSI} | ${BUILD_PLAT} fdt_dirs
+	@echo '#include "$(patsubst fdts/%,%,$<)"' > $@
+	@echo '#include "${BL2_DTSI}"' >> $@
+
+${BUILD_PLAT}/fdts/%-bl2.dtb: ${BUILD_PLAT}/fdts/%-bl2.dts
+
+${BUILD_PLAT}/$(PLAT)-%.o: ${BUILD_PLAT}/fdts/%-bl2.dtb $(STM32_BINARY_MAPPING) bl2
+	@echo "  AS      $${PLAT}.S"
+	${Q}${AS} ${ASFLAGS} ${TF_CFLAGS} \
+		-DDTB_BIN_PATH=\"$<\" \
+		-c $(word 2,$^) -o $@
+
+$(eval $(call MAKE_LD,${STM32_TF_LINKERFILE},$(STM32_LD_FILE),bl2))
+
+tf-a-%.elf: $(PLAT)-%.o ${STM32_TF_LINKERFILE}
+	@echo "  LDS     $<"
+	${Q}${LD} -o $@ ${STM32_TF_ELF_LDFLAGS} -Map=$(@:.elf=.map) --script ${STM32_TF_LINKERFILE} $<
+
+tf-a-%.bin: tf-a-%.elf
+	${Q}${OC} -O binary $< $@
+	@echo
+	@echo "Built $@ successfully"
+	@echo
+
+tf-a-%.stm32: tf-a-%.bin ${STM32_DEPS}
+	@echo
+	@echo "Generate $@"
+	$(eval LOADADDR = $(shell cat $(@:.stm32=.map) | grep RAM | awk '{print $$2}'))
+	$(eval ENTRY = $(shell cat $(@:.stm32=.map) | grep "__BL2_IMAGE_START" | awk '{print $$1}'))
+	${Q}${STM32IMAGE} -s $< -d $@ \
+		-l $(LOADADDR) -e ${ENTRY} \
+		-v ${STM32_TF_VERSION} \
+		-m ${STM32_HEADER_VERSION_MAJOR} \
+		-n ${STM32_HEADER_VERSION_MINOR} \
+		-b ${STM32_HEADER_BL2_BINARY_TYPE}
+	@echo
diff --git a/plat/st/common/include/stm32cubeprogrammer.h b/plat/st/common/include/stm32cubeprogrammer.h
index 503d91945..9a171ab35 100644
--- a/plat/st/common/include/stm32cubeprogrammer.h
+++ b/plat/st/common/include/stm32cubeprogrammer.h
@@ -13,15 +13,33 @@
 
 /* Phase definition */
 #define PHASE_FLASHLAYOUT	0U
+#define PHASE_DDR_FW		2U
 #define PHASE_SSBL		3U
 #define PHASE_CMD		0xF1U
+#define PHASE_SSP		0xF3U
 #define PHASE_RESET		0xFFU
 
 /* Functions provided by plat */
 uint8_t usb_dfu_get_phase(uint8_t alt);
 
 int stm32cubeprog_usb_load(struct usb_handle *usb_core_handle,
+			   uint8_t phase,
 			   uintptr_t ssbl_base,
 			   size_t ssbl_len);
 
+int stm32cubeprog_uart_load(uintptr_t instance, uint8_t phase,
+			   uintptr_t base, size_t len);
+
+int stm32cubeprog_usb_ssp(struct usb_handle *usb_core_handle,
+			  uintptr_t cert_base,
+			  size_t cert_len,
+			  uintptr_t ssp_base,
+			  size_t ssp_len);
+
+int stm32cubeprog_uart_ssp(uintptr_t instance,
+			   uintptr_t cert_base,
+			   size_t cert_len,
+			   uintptr_t ssp_base,
+			   size_t ssp_len);
+
 #endif /* STM32CUBEPROGRAMMER_H */
diff --git a/plat/st/common/include/stm32mp_auth.h b/plat/st/common/include/stm32mp_auth.h
deleted file mode 100644
index 3075d18ac..000000000
--- a/plat/st/common/include/stm32mp_auth.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
- * Copyright (c) 2019, ARM Limited and Contributors. All rights reserved.
- *
- * SPDX-License-Identifier: BSD-3-Clause
- */
-
-#ifndef STM32MP_AUTH_H
-#define STM32MP_AUTH_H
-
-struct stm32mp_auth_ops {
-	uint32_t (*check_key)(uint8_t *pubkey_in, uint8_t *pubkey_out);
-	uint32_t (*verify_signature)(uint8_t *hash_in, uint8_t *pubkey_in,
-				     uint8_t *signature, uint32_t ecc_algo);
-};
-
-void stm32mp_init_auth(struct stm32mp_auth_ops *init_ptr);
-int stm32mp_auth_image(boot_api_image_header_t *header, uintptr_t buffer);
-
-#endif /* STM32MP_AUTH_H */
diff --git a/plat/st/common/include/stm32mp_common.h b/plat/st/common/include/stm32mp_common.h
index 8a5fe48ad..4a741d60b 100644
--- a/plat/st/common/include/stm32mp_common.h
+++ b/plat/st/common/include/stm32mp_common.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2018-2021, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2018-2022, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -18,9 +18,13 @@
 void stm32mp_save_boot_ctx_address(uintptr_t address);
 uintptr_t stm32mp_get_boot_ctx_address(void);
 uint16_t stm32mp_get_boot_itf_selected(void);
+#if STM32MP13 || STM32MP15
+uint32_t stm32mp_get_boot_action(void);
+#endif
 
 bool stm32mp_is_single_core(void);
 bool stm32mp_is_closed_device(void);
+bool stm32mp_is_auth_supported(void);
 
 /* Return the base address of the DDR controller */
 uintptr_t stm32mp_ddrctrl_base(void);
@@ -34,9 +38,24 @@ uintptr_t stm32mp_pwr_base(void);
 /* Return the base address of the RCC peripheral */
 uintptr_t stm32mp_rcc_base(void);
 
+void stm32mp_gic_pcpu_init(void);
+void stm32mp_gic_init(void);
+int stm32mp_gic_enable_spi(int node, const char *name);
+
 /* Check MMU status to allow spinlock use */
 bool stm32mp_lock_available(void);
 
+/* SMP protection on PWR registers access */
+void stm32mp_pwr_regs_lock(void);
+void stm32mp_pwr_regs_unlock(void);
+
+int stm32_get_otp_index(const char *otp_name, uint32_t *otp_idx,
+			uint32_t *otp_len);
+int stm32_get_otp_value(const char *otp_name, uint32_t *otp_val);
+int stm32_get_otp_value_from_idx(const uint32_t otp_idx, uint32_t *otp_val);
+/* update UID_WORD_NB array */
+int stm32_get_uid_otp(uint32_t uid[]);
+
 /* Get IWDG platform instance ID from peripheral IO memory base address */
 uint32_t stm32_iwdg_get_instance(uintptr_t base);
 
@@ -48,6 +67,26 @@ uint32_t stm32_iwdg_get_otp_config(uint32_t iwdg_inst);
 uint32_t stm32_iwdg_shadow_update(uint32_t iwdg_inst, uint32_t flags);
 #endif
 
+#if STM32MP_UART_PROGRAMMER || !defined(IMAGE_BL2)
+/* Get the UART address from its instance number */
+uintptr_t get_uart_address(uint32_t instance_nb);
+#endif
+
+/* Setup the UART console */
+int stm32mp_uart_console_setup(void);
+
+#if STM32MP_EARLY_CONSOLE
+void stm32mp_setup_early_console(void);
+#else
+static inline void stm32mp_setup_early_console(void)
+{
+}
+#endif
+
+void stm32mp_set_console_after_standby(void);
+
+bool stm32mp_skip_boot_device_after_standby(void);
+
 /*
  * Platform util functions for the GPIO driver
  * @bank: Target GPIO bank ID as per DT bindings
@@ -64,6 +103,7 @@ uint32_t stm32_iwdg_shadow_update(uint32_t iwdg_inst, uint32_t flags);
 uintptr_t stm32_get_gpio_bank_base(unsigned int bank);
 unsigned long stm32_get_gpio_bank_clock(unsigned int bank);
 uint32_t stm32_get_gpio_bank_offset(unsigned int bank);
+bool stm32_gpio_is_secure_at_reset(unsigned int bank);
 
 /* Return node offset for target GPIO bank ID @bank or a FDT error code */
 int stm32_get_gpio_bank_pinctrl_node(void *fdt, unsigned int bank);
@@ -83,30 +123,32 @@ void stm32mp_print_cpuinfo(void);
 /* Print board information */
 void stm32mp_print_boardinfo(void);
 
-/*
- * Util for clock gating and to get clock rate for stm32 and platform drivers
- * @id: Target clock ID, ID used in clock DT bindings
- */
-bool stm32mp_clk_is_enabled(unsigned long id);
-void stm32mp_clk_enable(unsigned long id);
-void stm32mp_clk_disable(unsigned long id);
-unsigned long stm32mp_clk_get_rate(unsigned long id);
+/* Check HW CPU OPP support */
+bool stm32mp_supports_cpu_opp(uint32_t opp_id);
 
 /* Initialise the IO layer and register platform IO devices */
 void stm32mp_io_setup(void);
 
-#if STM32MP_USE_STM32IMAGE
-/*
- * Check that the STM32 header of a .stm32 binary image is valid
- * @param header: pointer to the stm32 image header
- * @param buffer: address of the binary image (payload)
- * @return: 0 on success, negative value in case of error
- */
-int stm32mp_check_header(boot_api_image_header_t *header, uintptr_t buffer);
-#endif /* STM32MP_USE_STM32IMAGE */
-
 /* Functions to map DDR in MMU with non-cacheable attribute, and unmap it */
 int stm32mp_map_ddr_non_cacheable(void);
 int stm32mp_unmap_ddr(void);
 
+/* Functions to save and get boot peripheral info */
+void stm32_save_boot_interface(uint32_t interface, uint32_t instance);
+void stm32_save_boot_itf(uint32_t interface, uint32_t instance,
+			 unsigned long clk_id, uintptr_t bkpr);
+void stm32_get_boot_interface(uint32_t *interface, uint32_t *instance);
+void stm32_get_boot_itf(uint32_t *interface, uint32_t *instance,
+			unsigned long clk_id, uintptr_t bkpr);
+bool stm32_boot_is_serial(void);
+
+/* Display board information from the value found in OTP fuse */
+void stm32_display_board_info(uint32_t board_id);
+
+#if PSA_FWU_SUPPORT
+void stm32mp1_fwu_set_boot_idx(void);
+uint32_t stm32_get_and_dec_fwu_trial_boot_cnt(void);
+void stm32_set_max_fwu_trial_boot_cnt(void);
+#endif /* PSA_FWU_SUPPORT */
+
 #endif /* STM32MP_COMMON_H */
diff --git a/plat/st/common/include/stm32mp_dt.h b/plat/st/common/include/stm32mp_dt.h
index f7201c0d9..0170f3a73 100644
--- a/plat/st/common/include/stm32mp_dt.h
+++ b/plat/st/common/include/stm32mp_dt.h
@@ -11,6 +11,8 @@
 #include <stdbool.h>
 #include <stdint.h>
 
+#include <libfdt.h>
+
 #define DT_DISABLED		U(0)
 #define DT_NON_SECURE		U(1)
 #define DT_SECURE		U(2)
@@ -30,14 +32,23 @@ int dt_open_and_check(uintptr_t dt_addr);
 int fdt_get_address(void **fdt_addr);
 bool fdt_check_node(int node);
 uint8_t fdt_get_status(int node);
+int fdt_get_interrupt(int node, const fdt32_t **array, int *len,
+		      bool *extended);
 int dt_set_stdout_pinctrl(void);
 void dt_fill_device_info(struct dt_node_info *info, int node);
 int dt_get_node(struct dt_node_info *info, int offset, const char *compat);
 int dt_get_stdout_uart_info(struct dt_node_info *info);
 int dt_match_instance_by_compatible(const char *compatible, uintptr_t address);
 uint32_t dt_get_ddr_size(void);
+int dt_get_max_opp_freqvolt(uint32_t *freq_khz, uint32_t *voltage_mv);
+int dt_get_all_opp_freqvolt(uint32_t *count, uint32_t *freq_khz_array,
+			    uint32_t *voltage_mv_array);
 uint32_t dt_get_pwr_vdd_voltage(void);
+struct rdev *dt_get_vdd_regulator(void);
+struct rdev *dt_get_cpu_regulator(void);
+struct rdev *dt_get_usb_phy_regulator(void);
 const char *dt_get_board_model(void);
+int dt_find_otp_name(const char *name, uint32_t *otp, uint32_t *otp_len);
 int fdt_get_gpio_bank_pin_count(unsigned int bank);
 
 #endif /* STM32MP_DT_H */
diff --git a/plat/st/common/include/stm32mp_efi.h b/plat/st/common/include/stm32mp_efi.h
new file mode 100644
index 000000000..490560ff3
--- /dev/null
+++ b/plat/st/common/include/stm32mp_efi.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+/*
+ * Copyright (c) 2021, Linaro Limited
+ */
+
+#ifndef STM32MP_EFI_H
+#define STM32MP_EFI_H
+
+#include <drivers/partition/efi.h>
+
+#define STM32MP_FIP_GUID \
+	EFI_GUID(0x19d5df83, 0x11b0, 0x457b, \
+		 0xbe, 0x2c, 0x75, 0x59, 0xc1, 0x31, 0x42, 0xa5)
+
+#endif /* STM32MP_EFI_H */
diff --git a/plat/st/common/include/stm32mp_fconf_getter.h b/plat/st/common/include/stm32mp_fconf_getter.h
index 3a8bb11a4..18884ae06 100644
--- a/plat/st/common/include/stm32mp_fconf_getter.h
+++ b/plat/st/common/include/stm32mp_fconf_getter.h
@@ -10,6 +10,7 @@
 #include <assert.h>
 
 #include <lib/fconf/fconf.h>
+#include <tools_share/uuid.h>
 
 /* IO policies */
 #define stm32mp__io_policies_getter(id) __extension__ ({	\
@@ -20,6 +21,7 @@
 struct plat_io_policy {
 	uintptr_t *dev_handle;
 	uintptr_t image_spec;
+	struct efi_guid img_type_guid;
 	int (*check)(const uintptr_t spec);
 };
 
diff --git a/plat/st/common/include/stm32mp_io_storage.h b/plat/st/common/include/stm32mp_io_storage.h
index 989c890d4..677a2ebb5 100644
--- a/plat/st/common/include/stm32mp_io_storage.h
+++ b/plat/st/common/include/stm32mp_io_storage.h
@@ -13,11 +13,15 @@
 /* IO devices handle */
 extern uintptr_t storage_dev_handle;
 extern uintptr_t fip_dev_handle;
+extern uintptr_t enc_dev_handle;
 
 extern io_block_spec_t image_block_spec;
 
 /* Function declarations */
 int open_fip(const uintptr_t spec);
+#ifndef DECRYPTION_SUPPORT_none
+int open_enc_fip(const uintptr_t spec);
+#endif
 int open_storage(const uintptr_t spec);
 
 #endif /* STM32MP_IO_STORAGE_H */
diff --git a/plat/st/common/include/stm32mp_shres_helpers.h b/plat/st/common/include/stm32mp_shres_helpers.h
index 8b786cc04..8b048284c 100644
--- a/plat/st/common/include/stm32mp_shres_helpers.h
+++ b/plat/st/common/include/stm32mp_shres_helpers.h
@@ -12,63 +12,16 @@
 #include <common/debug.h>
 
 /*
- * Shared reference counter: increments by 2 on secure increment
- * request, decrements by 2 on secure decrement request. Bit #0
- * is set to 1 on non-secure increment request and reset to 0 on
- * non-secure decrement request. The counter initializes to
- * either 0, 1 or 2 upon their expect default state.
- * Counters saturates once above UINT_MAX / 2.
+ * Lock/unlock access to shared registers
+ *
+ * @lock - NULL or pointer to spin lock
  */
-#define SHREFCNT_NONSECURE_FLAG		0x1UL
-#define SHREFCNT_SECURE_STEP		0x2UL
-#define SHREFCNT_MAX			(UINT32_MAX / 2)
-
-/* Return 1 if refcnt increments from 0, else return 0 */
-static inline int stm32mp_incr_shrefcnt(unsigned int *refcnt, bool secure)
-{
-	int rc = !*refcnt;
-
-	if (secure) {
-		*refcnt += SHREFCNT_SECURE_STEP;
-		if (*refcnt >= SHREFCNT_MAX) {
-			panic();
-		}
-	} else {
-		*refcnt |= SHREFCNT_NONSECURE_FLAG;
-	}
-
-	return rc;
-}
-
-/* Return 1 if refcnt decrements to 0, else return 0 */
-static inline int stm32mp_decr_shrefcnt(unsigned int *refcnt, bool secure)
-{
-	int  rc = 0;
-
-	if (secure) {
-		if (*refcnt < SHREFCNT_MAX) {
-			if (*refcnt < SHREFCNT_SECURE_STEP) {
-				panic();
-			}
-			*refcnt -= SHREFCNT_SECURE_STEP;
-			rc = !*refcnt;
-		}
-	} else {
-		rc = (*refcnt == SHREFCNT_NONSECURE_FLAG) ? 1 : 0;
-		*refcnt &= ~SHREFCNT_NONSECURE_FLAG;
-	}
-
-	return rc;
-}
-
-static inline int stm32mp_incr_refcnt(unsigned int *refcnt)
-{
-	return stm32mp_incr_shrefcnt(refcnt, true);
-}
 
-static inline int stm32mp_decr_refcnt(unsigned int *refcnt)
-{
-	return stm32mp_decr_shrefcnt(refcnt, true);
-}
+void stm32mp_lock_shregs(void);
+void stm32mp_unlock_shregs(void);
+void stm32mp_mmio_clrsetbits_32_shregs(uintptr_t addr, uint32_t clear,
+				       uint32_t set);
+void stm32mp_mmio_clrbits_32_shregs(uintptr_t addr, uint32_t clear);
+void stm32mp_mmio_setbits_32_shregs(uintptr_t addr, uint32_t set);
 
 #endif /* STM32MP_SHRES_HELPERS_H */
diff --git a/plat/st/common/include/stm32mp_svc_setup.h b/plat/st/common/include/stm32mp_svc_setup.h
new file mode 100644
index 000000000..55b233619
--- /dev/null
+++ b/plat/st/common/include/stm32mp_svc_setup.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP_SVC_SETUP_H
+#define STM32MP_SVC_SETUP_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+/* Common SMC function IDs for STM32 Service queries across STM32MP paltforms */
+#define STM32_SIP_SVC_CALL_COUNT	0x8200ff00
+#define STM32_SIP_SVC_UID		0x8200ff01
+/*					0x8200ff02 is reserved */
+#define STM32_SIP_SVC_VERSION		0x8200ff03
+
+/* STM32 SiP Service Calls version numbers */
+#define STM32_SIP_SVC_VERSION_MAJOR	0x0
+#define STM32_SIP_SVC_VERSION_MINOR	0x1
+
+/* SMC error codes */
+#define STM32_SMC_OK			0x00000000U
+#define STM32_SMC_NOT_SUPPORTED		0xFFFFFFFFU
+#define STM32_SMC_FAILED		0xFFFFFFFEU
+#define STM32_SMC_INVALID_PARAMS	0xFFFFFFFDU
+
+void plat_svc_smc_handler(uint32_t smc_fid, u_register_t x1,
+			  u_register_t x2, u_register_t x3,
+			  u_register_t x4, uint32_t *ret1,
+			  uint32_t *ret2, bool *ret2_enabled,
+			  u_register_t flags);
+
+#endif /* STM32MP_SVC_SETUP_H */
diff --git a/plat/st/common/stm32cubeprogrammer_uart.c b/plat/st/common/stm32cubeprogrammer_uart.c
new file mode 100644
index 000000000..e2f801e00
--- /dev/null
+++ b/plat/st/common/stm32cubeprogrammer_uart.c
@@ -0,0 +1,662 @@
+/*
+ * Copyright (c) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <endian.h>
+#include <errno.h>
+#include <string.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32_iwdg.h>
+#include <drivers/st/stm32_uart.h>
+#include <drivers/st/stm32_uart_regs.h>
+#include <lib/mmio.h>
+#include <tools_share/firmware_image_package.h>
+
+#include <platform_def.h>
+#include <stm32cubeprogrammer.h>
+
+/* USART bootloader protocol version V4.0 */
+#define USART_BL_VERSION	0x40U
+
+/* Command definition */
+#define GET_CMD_COMMAND		0x00U
+#define GET_VER_COMMAND		0x01U
+#define GET_ID_COMMAND		0x02U
+#define PHASE_COMMAND		0x03U
+#define READ_PART_COMMAND	0x12U
+#define START_COMMAND		0x21U
+#define DOWNLOAD_COMMAND	0x31U
+
+/* Answer defines */
+#define INIT_BYTE		0x7FU
+#define ACK_BYTE		0x79U
+#define NACK_BYTE		0x1FU
+#define ABORT			0x5FU
+
+#define UNDEFINED_DOWN_ADDR	U(0xFFFFFFFF)
+#define PROGRAMMER_TIMEOUT_US	20000U
+
+static const uint8_t command_tab[] = {
+	GET_CMD_COMMAND,
+	GET_VER_COMMAND,
+	GET_ID_COMMAND,
+	PHASE_COMMAND,
+#if STM32MP_SSP
+	READ_PART_COMMAND,
+#endif
+	START_COMMAND,
+	DOWNLOAD_COMMAND
+};
+
+/* STM32CubeProgrammer over UART handle */
+struct stm32prog_uart_handle_s {
+	struct stm32_uart_handle_s uart;
+	uint32_t packet;
+	uint8_t *addr;
+	uint32_t len;
+	uint8_t phase;
+#if STM32MP_SSP
+	uintptr_t cert_base;
+	size_t cert_len;
+#endif
+	/* Error msg buffer: max 255 in UART protocol, reduced in TF-A */
+	uint8_t error[64];
+} handle;
+
+/* Trace and handle unrecoverable UART protocol error */
+#define STM32PROG_ERROR(...) \
+	{ \
+		ERROR(__VA_ARGS__); \
+		if (handle.phase != PHASE_RESET) { \
+			snprintf((char *)&handle.error, sizeof(handle.error), __VA_ARGS__); \
+			handle.phase = PHASE_RESET; \
+			handle.addr = (uint8_t *)UNDEFINED_DOWN_ADDR; \
+			handle.len = 0U; \
+			handle.packet = 0U; \
+		} \
+	}
+
+static int uart_write(const uint8_t *addr, uint16_t size)
+{
+	while (size != 0U) {
+		if (stm32_uart_putc(&handle.uart, *addr) != 0) {
+			return -EIO;
+		}
+		size--;
+		addr++;
+	}
+
+	return 0;
+}
+
+static int uart_write_8(uint8_t byte)
+{
+	return stm32_uart_putc(&handle.uart, byte);
+}
+
+static int uart_write_32(uint32_t value)
+{
+	return uart_write((uint8_t *)&value, 4U);
+}
+
+static int uart_read_8(uint8_t *byte)
+{
+	int ret;
+	uint64_t timeout_ref = timeout_init_us(PROGRAMMER_TIMEOUT_US);
+
+	do {
+		ret = stm32_uart_getc(&handle.uart);
+		if (ret == -EAGAIN) {
+			if (timeout_elapsed(timeout_ref)) {
+				return -ETIMEDOUT;
+			}
+		} else if (ret < 0) {
+			return ret;
+		}
+	} while (ret == -EAGAIN);
+
+	*byte = (uint8_t)ret;
+
+	return 0;
+}
+
+static int uart_send_result(uint8_t byte)
+{
+	int ret;
+
+	/* Always flush fifo before to send result = read all pending data */
+	do {
+		ret = stm32_uart_getc(&handle.uart);
+	} while (ret >= 0);
+
+	return uart_write_8(byte);
+}
+
+static bool is_valid_header(fip_toc_header_t *header)
+{
+	return (header->name == TOC_HEADER_NAME) &&
+	       (header->serial_number != 0U);
+}
+
+static int uart_receive_command(uint8_t *command)
+{
+	uint8_t byte = 0U;
+	uint8_t xor = 0U;
+	unsigned int count;
+	bool found = false;
+	int ret;
+
+	/* Repeat read until something is received */
+	do {
+		stm32_iwdg_refresh();
+		ret = uart_read_8(&byte);
+	} while (ret == -ETIMEDOUT);
+
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Handle reconnection request */
+	if (byte == INIT_BYTE) {
+		*command = byte;
+		return 0;
+	}
+
+	for (count = 0U; count < ARRAY_SIZE(command_tab); count++) {
+		if (command_tab[count] == byte) {
+			found = true;
+			break;
+		}
+	}
+	if (!found) {
+		VERBOSE("UART: Command unknown (byte=0x%x)\n", byte);
+		return -EPROTO;
+	}
+
+	ret = uart_read_8(&xor);
+	if (ret != 0) {
+		return ret;
+	}
+	if ((byte ^ xor) != 0xFF) {
+		VERBOSE("UART: Command XOR check fail (byte=0x%x, xor=0x%x)\n",
+			byte, xor);
+		return -EPROTO;
+	}
+
+	*command = byte;
+
+	return 0;
+}
+
+static int get_cmd_command(void)
+{
+	const uint8_t msg[2] = {
+		sizeof(command_tab), /* Length of data - 1 */
+		USART_BL_VERSION
+	};
+	int ret;
+
+	ret = uart_write(msg, sizeof(msg));
+	if (ret != 0) {
+		return ret;
+	}
+
+	return uart_write(command_tab, sizeof(command_tab));
+}
+
+static int get_version_command(void)
+{
+	return uart_write_8(STM32_TF_VERSION);
+}
+
+static int get_id_command(void)
+{
+	uint8_t msg[3] = {
+		sizeof(msg) - 1 /* Length of data - 1 */
+	};
+	uint32_t chip_id = stm32mp_get_chip_dev_id();
+
+	be16enc(&msg[1], chip_id);
+
+	return uart_write(msg, sizeof(msg));
+}
+
+static int uart_send_phase(uint32_t address)
+{
+	int ret;
+	uint8_t msg_size = 5U; /* Length of data - 1 */
+	uint8_t error_size = 0U;
+
+	/* Additional information only for RESET phase */
+	if (handle.phase == PHASE_RESET) {
+		error_size = strnlen((char *)&handle.error, sizeof(handle.error));
+	}
+	ret = uart_write_8(msg_size + error_size);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Send the ID of next partition */
+	ret = uart_write_8(handle.phase);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Destination address */
+	ret = uart_write_32(address);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = uart_write_8(error_size);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Additional information: message error */
+	if (error_size > 0U) {
+		ret = uart_write(handle.error, error_size);
+	}
+
+	return ret;
+}
+
+static int uart_download_part(void)
+{
+	uint8_t operation = 0U;
+	uint8_t xor;
+	uint8_t byte = 0U;
+	uint32_t packet_number = 0U;
+	uint32_t packet_size = 0U;
+	uint32_t i = 0U;
+	int ret;
+
+	/* Get operation number */
+	ret = uart_read_8(&operation);
+	if (ret != 0) {
+		return ret;
+	}
+
+	xor = operation;
+
+	/* Get packet number */
+	for (i = 3U; i != 0U; i--) {
+		ret = uart_read_8(&byte);
+		if (ret != 0) {
+			return ret;
+		}
+
+		xor ^= byte;
+		packet_number = (packet_number << 8) | byte;
+	}
+
+	if (packet_number != handle.packet) {
+		WARN("UART: Bad packet number receive: %u, expected %u\n",
+		     packet_number, handle.packet);
+		return -EPROTO;
+	}
+
+	/* Checksum */
+	ret = uart_read_8(&byte);
+	if (ret != 0) {
+		return ret;
+	}
+	if (xor != byte) {
+		VERBOSE("UART: Download Command checksum xor: %x, received %x\n",
+			xor, byte);
+		return -EPROTO;
+	}
+
+	ret = uart_send_result(ACK_BYTE);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = uart_read_8(&byte);
+	if (ret != 0) {
+		return ret;
+	}
+	xor = byte;
+	packet_size = byte + 1U;
+	if (handle.len < packet_size) {
+		STM32PROG_ERROR("Download overflow at %p\n", handle.addr + packet_size);
+		return 0;
+	}
+
+	for (i = 0U; i < packet_size; i++) {
+		ret = uart_read_8(&byte);
+		if (ret != 0) {
+			return ret;
+		}
+
+		*(handle.addr + i) = byte;
+		xor ^= byte;
+	}
+
+	/* Checksum */
+	ret = uart_read_8(&byte) != 0;
+	if (ret != 0) {
+		return ret;
+	}
+	if (xor != byte) {
+		VERBOSE("UART: Download Data checksum xor: %x, received %x\n",
+			xor, byte);
+		return -EPROTO;
+	}
+
+	/* Packet treated */
+	handle.packet++;
+	handle.addr += packet_size;
+	handle.len -= packet_size;
+
+	return 0;
+}
+
+static int uart_start_cmd(uintptr_t buffer)
+{
+	uint8_t byte = 0U;
+	uint8_t xor = 0U;
+	uint32_t i;
+	uint32_t start_address = 0U;
+	int ret;
+
+	/* Get address */
+	for (i = 4U; i != 0U; i--) {
+		ret = uart_read_8(&byte);
+		if (ret != 0U) {
+			return ret;
+		}
+
+		xor ^= byte;
+		start_address = (start_address << 8) | byte;
+	}
+
+	/* Checksum */
+	ret = uart_read_8(&byte);
+	if (ret != 0) {
+		return ret;
+	}
+
+	if (xor != byte) {
+		VERBOSE("UART: Start Command checksum xor: %x, received %x\n",
+			xor, byte);
+		return -EPROTO;
+	}
+
+	if (start_address != UNDEFINED_DOWN_ADDR) {
+		STM32PROG_ERROR("Invalid start at %x, for phase %u\n",
+				start_address, handle.phase);
+		return 0;
+	}
+
+	if (!is_valid_header((fip_toc_header_t *)buffer)) {
+		STM32PROG_ERROR("FIP Header check failed %lx, for phase %u\n",
+				buffer, handle.phase);
+		return -EIO;
+	}
+	VERBOSE("FIP header looks OK.\n");
+
+	return 0;
+}
+
+#if STM32MP_SSP
+static int uart_read_part(void)
+{
+	uint8_t byte = 0U;
+	uint8_t xor = 0U;
+	uint8_t partid = 0U;
+	uint16_t size = 0U;
+	uint32_t start_address = 0U;
+	uint32_t i;
+	size_t length;
+	uint8_t *buffer;
+
+	/* Get partition id */
+	if (uart_read_8(&partid) != 0) {
+		return -EIO;
+	}
+
+	if ((partid != PHASE_FLASHLAYOUT) && (partid != PHASE_SSP)) {
+		return -EPERM;
+	}
+
+	xor = partid;
+
+	/* Get address */
+	for (i = 4U; i > 0U; i--) {
+		if (uart_read_8(&byte) != 0) {
+			return -EIO;
+		}
+
+		xor ^= byte;
+		start_address = (start_address << 8) | byte;
+	}
+
+	/* Checksum */
+	if (uart_read_8(&byte) != 0) {
+		return -EIO;
+	}
+
+	if (xor != byte) {
+		WARN("UART: Start cmd: address checksum: %x != %x\n",
+		     xor, byte);
+		return -EPROTO;
+	}
+	/* OFFSET != 0 not supported */
+	if (start_address != 0U) {
+		return -EIO;
+	}
+
+	uart_write_8(ACK_BYTE);
+
+	/* Get number of bytes to send */
+	if (uart_read_8(&byte) != 0) {
+		return -EIO;
+	}
+
+	xor = byte;
+
+	/* Send Size + 1 */
+	size = byte++;
+
+	/* Checksum */
+	if (uart_read_8(&byte) != 0) {
+		return -EIO;
+	}
+
+	if ((xor ^ byte) != 0xFF) {
+		WARN("UART: Start cmd: length checksum: %x != %x\n", xor, byte);
+		return -EPROTO;
+	}
+
+	uart_write_8(ACK_BYTE);
+
+	if (partid != PHASE_SSP) {
+		WARN("Not supported\n");
+		return -EPROTO;
+	}
+
+	length = handle.cert_len;
+	buffer = (uint8_t *)handle.cert_base;
+
+	for (i = 0U; i < length; i++, buffer++) {
+		uart_write_8(*buffer);
+	}
+	for (; i < size; i++) {
+		uart_write_8(0x0);
+	}
+
+	return 0;
+}
+#endif /* STM32MP_SSP */
+
+static int uart_read(uint8_t id, uintptr_t buffer, size_t length)
+{
+	bool start_done = false;
+	int ret;
+	uint8_t command = 0U;
+
+	handle.phase = id;
+	handle.packet = 0U;
+	handle.addr = (uint8_t *)buffer;
+	handle.len = length;
+
+	INFO("UART: read phase %u at 0x%lx size 0x%zx\n",
+	     id, buffer, length);
+	while (!start_done) {
+		ret = uart_receive_command(&command);
+		if (ret != 0) {
+			/* Delay to wait STM32CubeProgrammer end of transmission */
+			mdelay(3);
+
+			ret = uart_send_result(NACK_BYTE);
+			if (ret != 0U) {
+				return ret;
+			}
+
+			continue;
+		}
+
+		uart_send_result(ACK_BYTE);
+
+		switch (command) {
+		case INIT_BYTE:
+			INFO("UART: Connected\n");
+			/* Nothing to do */
+			continue;
+
+		case GET_CMD_COMMAND:
+			ret = get_cmd_command();
+			break;
+
+		case GET_VER_COMMAND:
+			ret = get_version_command();
+			break;
+
+		case GET_ID_COMMAND:
+			ret = get_id_command();
+			break;
+
+		case PHASE_COMMAND:
+			ret = uart_send_phase((uint32_t)buffer);
+			if ((ret == 0) && (handle.phase == PHASE_RESET)) {
+				start_done = true;
+				INFO("UART: Reset\n");
+			}
+			break;
+
+		case DOWNLOAD_COMMAND:
+			ret = uart_download_part();
+			break;
+#if STM32MP_SSP
+		case READ_PART_COMMAND:
+			ret = uart_read_part();
+			break;
+#endif
+		case START_COMMAND:
+			ret = uart_start_cmd(buffer);
+			if ((ret == 0) && (handle.phase == id)) {
+				INFO("UART: Start phase %u\n", handle.phase);
+#if STM32MP_SSP
+				if (handle.phase == PHASE_SSP) {
+					handle.phase = PHASE_RESET;
+					break;
+				}
+#endif
+				start_done = true;
+			}
+			break;
+
+		default:
+			WARN("UART: Unknown command\n");
+			ret = -EINVAL;
+			break;
+		}
+
+		if (ret == 0) {
+			ret = uart_send_result(ACK_BYTE);
+		} else {
+			ret = uart_send_result(NACK_BYTE);
+		}
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+/* Init UART: 115200, 8bit 1stop parity even and enable FIFO mode */
+const struct stm32_uart_init_s init = {
+	.baud_rate = STM32MP_UART_BAUDRATE,
+	.word_length = STM32_UART_WORDLENGTH_9B,
+	.stop_bits = STM32_UART_STOPBITS_1,
+	.parity = STM32_UART_PARITY_EVEN,
+	.hw_flow_control = STM32_UART_HWCONTROL_NONE,
+	.mode = STM32_UART_MODE_TX_RX,
+	.fifo_mode = STM32_UART_FIFOMODE_EN,
+};
+
+#if STM32MP_SSP
+int stm32cubeprog_uart_ssp(uintptr_t instance,
+			   uintptr_t cert_base,
+			   size_t cert_len,
+			   uintptr_t ssp_base,
+			   size_t ssp_len)
+{
+	int ret;
+
+	if (stm32_uart_init(&handle.uart, instance, &init) != 0U) {
+		return -EIO;
+	}
+
+	/* NACK to synchronize STM32CubeProgrammer */
+	ret = uart_send_result(NACK_BYTE);
+	if (ret != 0) {
+		return ret;
+	}
+
+	if (cert_base == UNDEFINED_DOWN_ADDR) {
+		/* Send Provisioning message to programmer for reboot */
+		STM32PROG_ERROR("Provisioning\n");
+	} else {
+		handle.cert_base = cert_base;
+		handle.cert_len  = cert_len;
+		handle.phase = PHASE_SSP;
+	}
+
+	return uart_read(handle.phase, ssp_base, ssp_len);
+
+}
+#endif
+
+int stm32cubeprog_uart_load(uintptr_t instance, uint8_t phase,
+			    uintptr_t base, size_t len)
+{
+	int ret;
+
+	if (stm32_uart_init(&handle.uart, instance, &init) != 0) {
+		return -EIO;
+	}
+
+	/*
+	 * The following NACK_BYTE is written because STM32CubeProgrammer has
+	 * already sent its command before TF-A has reached this point, and
+	 * because FIFO was not configured by BootROM.
+	 * The byte in the UART_RX register is then the checksum and not the
+	 * command. NACK_BYTE has to be written, so that the programmer will
+	 * re-send the good command.
+	 */
+	ret = uart_send_result(NACK_BYTE);
+	if (ret != 0) {
+		return ret;
+	}
+
+	return uart_read(phase, base, len);
+}
diff --git a/plat/st/common/stm32cubeprogrammer_usb.c b/plat/st/common/stm32cubeprogrammer_usb.c
index 19a6bbae8..a1d4b6eb1 100644
--- a/plat/st/common/stm32cubeprogrammer_usb.c
+++ b/plat/st/common/stm32cubeprogrammer_usb.c
@@ -1,11 +1,12 @@
 /*
- * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2021-2022, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
 #include <assert.h>
 #include <errno.h>
+#include <string.h>
 
 #include <tools_share/firmware_image_package.h>
 
@@ -20,6 +21,10 @@ struct dfu_state {
 	uintptr_t base;
 	size_t len;
 	uintptr_t address;
+#if STM32MP_SSP
+	uintptr_t cert_base;
+	size_t cert_len;
+#endif
 	/* working buffer */
 	uint8_t buffer[UCHAR_MAX];
 };
@@ -42,6 +47,7 @@ static struct dfu_state dfu_state;
 		} \
 	}
 
+#if !STM32MP_SSP
 static bool is_valid_header(fip_toc_header_t *header)
 {
 	if ((header->name == TOC_HEADER_NAME) && (header->serial_number != 0U)) {
@@ -50,6 +56,7 @@ static bool is_valid_header(fip_toc_header_t *header)
 
 	return false;
 }
+#endif
 
 static int dfu_callback_upload(uint8_t alt, uintptr_t *buffer, uint32_t *len,
 			       void *user_data)
@@ -61,7 +68,15 @@ static int dfu_callback_upload(uint8_t alt, uintptr_t *buffer, uint32_t *len,
 	switch (usb_dfu_get_phase(alt)) {
 	case PHASE_CMD:
 		/* Get Pḧase */
+#if STM32MP_SSP && STM32MP15
+		if (dfu->phase == PHASE_SSP) {
+			dfu->buffer[0] = PHASE_FLASHLAYOUT;
+		} else {
+			dfu->buffer[0] = dfu->phase;
+		}
+#else
 		dfu->buffer[0] = dfu->phase;
+#endif
 		dfu->buffer[1] = (uint8_t)(dfu->address);
 		dfu->buffer[2] = (uint8_t)(dfu->address >> 8);
 		dfu->buffer[3] = (uint8_t)(dfu->address >> 16);
@@ -84,6 +99,33 @@ static int dfu_callback_upload(uint8_t alt, uintptr_t *buffer, uint32_t *len,
 		}
 		break;
 
+#if STM32MP_SSP
+	case PHASE_SSP:
+#if STM32MP13
+		dfu->buffer[0] = dfu->phase;
+#endif
+#if STM32MP15
+		/* Fix phase to flashlayout phase */
+		dfu->buffer[0] = PHASE_FLASHLAYOUT;
+#endif
+		dfu->buffer[1] = (uint8_t)(dfu_state.cert_base);
+		dfu->buffer[2] = (uint8_t)(dfu_state.cert_base >> 8);
+		dfu->buffer[3] = (uint8_t)(dfu_state.cert_base >> 16);
+		dfu->buffer[4] = (uint8_t)(dfu_state.cert_base >> 24);
+		dfu->buffer[5] = 0x00;
+		dfu->buffer[6] = 0x00;
+		dfu->buffer[7] = 0x00;
+		dfu->buffer[8] = 0x00;
+		length = 9U;
+
+		if ((length + dfu_state.cert_len) <= sizeof(dfu->buffer)) {
+			memcpy(&dfu->buffer[9], (uint8_t *)dfu_state.cert_base,
+			       dfu_state.cert_len);
+			length += dfu_state.cert_len;
+		}
+
+		break;
+#endif
 	default:
 		DFU_ERROR("phase ID :%i, alternate %i for phase %i\n",
 			  dfu->phase, alt, usb_dfu_get_phase(alt));
@@ -136,6 +178,15 @@ static int dfu_callback_manifestation(uint8_t alt, void *user_data)
 	     dfu->phase, alt, dfu->address);
 
 	switch (dfu->phase) {
+#if STM32MP_SSP
+	case PHASE_SSP:
+		/* Configure End with request detach */
+		dfu->phase = PHASE_FLASHLAYOUT;
+		dfu->address = UNDEFINED_DOWN_ADDR;
+		dfu->len = 0;
+		break;
+#else
+	case PHASE_DDR_FW:
 	case PHASE_SSBL:
 		if (!is_valid_header((fip_toc_header_t *)dfu->base)) {
 			DFU_ERROR("FIP Header check failed for phase %d\n", alt);
@@ -148,6 +199,7 @@ static int dfu_callback_manifestation(uint8_t alt, void *user_data)
 		dfu->address = UNDEFINED_DOWN_ADDR;
 		dfu->len = 0;
 		break;
+#endif /* STM32MP_SSP */
 	default:
 		DFU_ERROR("Unknown phase\n");
 	}
@@ -162,7 +214,54 @@ static const struct usb_dfu_media usb_dfu_fops = {
 	.manifestation = dfu_callback_manifestation,
 };
 
+#if STM32MP_SSP
+int stm32cubeprog_usb_ssp(struct usb_handle *usb_core_handle,
+			  uintptr_t cert_base,
+			  size_t cert_len,
+			  uintptr_t ssp_base,
+			  size_t ssp_len)
+{
+	int ret;
+
+	usb_core_handle->user_data = (void *)&dfu_state;
+
+	INFO("DFU USB START...\n");
+	ret = usb_core_start(usb_core_handle);
+	if (ret != USBD_OK) {
+		return -EIO;
+	}
+
+	if (cert_base == UNDEFINED_DOWN_ADDR) {
+		struct dfu_state *dfu = (struct dfu_state *)usb_core_handle->user_data;
+
+		/* Send Provisioning message to programmer for reboot */
+		DFU_ERROR("Provisioning\n");
+	} else {
+		dfu_state.phase = PHASE_SSP;
+		dfu_state.address = ssp_base;
+		dfu_state.base = ssp_base;
+		dfu_state.len = ssp_len;
+		dfu_state.cert_base = cert_base;
+		dfu_state.cert_len = cert_len;
+	}
+
+	ret = usb_dfu_loop(usb_core_handle, &usb_dfu_fops);
+	if (ret != USBD_OK) {
+		return -EIO;
+	}
+
+	INFO("DFU USB STOP...\n");
+	ret = usb_core_stop(usb_core_handle);
+	if (ret != USBD_OK) {
+		return -EIO;
+	}
+
+	return 0;
+}
+#endif
+
 int stm32cubeprog_usb_load(struct usb_handle *usb_core_handle,
+			   uint8_t phase,
 			   uintptr_t base,
 			   size_t len)
 {
@@ -176,7 +275,7 @@ int stm32cubeprog_usb_load(struct usb_handle *usb_core_handle,
 		return -EIO;
 	}
 
-	dfu_state.phase = PHASE_SSBL;
+	dfu_state.phase = phase;
 	dfu_state.address = base;
 	dfu_state.base = base;
 	dfu_state.len = len;
diff --git a/plat/st/common/stm32mp_auth.c b/plat/st/common/stm32mp_auth.c
deleted file mode 100644
index 0ef6d5454..000000000
--- a/plat/st/common/stm32mp_auth.c
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright (c) 2019, STMicroelectronics - All Rights Reserved
- *
- * SPDX-License-Identifier: BSD-3-Clause
- */
-
-#include <errno.h>
-
-#include <platform_def.h>
-
-#include <common/debug.h>
-#include <drivers/io/io_storage.h>
-#include <drivers/st/bsec.h>
-#include <drivers/st/stm32_hash.h>
-#include <lib/xlat_tables/xlat_tables_v2.h>
-#include <plat/common/platform.h>
-
-static const struct stm32mp_auth_ops *auth_ops;
-
-void stm32mp_init_auth(struct stm32mp_auth_ops *init_ptr)
-{
-	if ((init_ptr == NULL) ||
-	    (init_ptr->check_key == NULL) ||
-	    (init_ptr->verify_signature == NULL) ||
-	    (stm32_hash_register() != 0)) {
-		panic();
-	}
-
-	auth_ops = init_ptr;
-}
-
-int stm32mp_auth_image(boot_api_image_header_t *header, uintptr_t buffer)
-{
-	int ret;
-	uint8_t image_hash[BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES];
-	uint32_t header_skip_cksum = sizeof(header->magic) +
-				     sizeof(header->image_signature) +
-				     sizeof(header->payload_checksum);
-
-	/* Check Security Status */
-	if (!stm32mp_is_closed_device()) {
-		if (header->option_flags != 0U) {
-			WARN("Skip signature check (header option)\n");
-			return 0;
-		}
-		INFO("Check signature on Open device\n");
-	}
-
-	ret = mmap_add_dynamic_region(STM32MP_ROM_BASE, STM32MP_ROM_BASE,
-				      STM32MP_ROM_SIZE, MT_CODE | MT_SECURE);
-	if (ret != 0) {
-		return ret;
-	}
-
-	/* Check Public Key */
-	if (auth_ops->check_key(header->ecc_pubk, NULL) != BOOT_API_RETURN_OK) {
-		ret = -EINVAL;
-		goto err;
-	}
-
-	/* Compute end of header hash and payload hash */
-	stm32_hash_init(HASH_SHA256);
-
-	ret = stm32_hash_update((uint8_t *)&header->header_version,
-				sizeof(boot_api_image_header_t) -
-				header_skip_cksum);
-	if (ret != 0) {
-		ERROR("Hash of header failed, %i\n", ret);
-		goto err;
-	}
-
-	ret = stm32_hash_final_update((uint8_t *)buffer,
-			       header->image_length, image_hash);
-	if (ret != 0) {
-		ERROR("Hash of payload failed\n");
-		goto err;
-	}
-
-	/* Verify signature */
-	if (auth_ops->verify_signature(image_hash, header->ecc_pubk,
-				       header->image_signature,
-				       header->ecc_algo_type) !=
-	    BOOT_API_RETURN_OK) {
-		ret = -EINVAL;
-	}
-
-err:
-	mmap_remove_dynamic_region(STM32MP_ROM_BASE, STM32MP_ROM_SIZE);
-	return ret;
-}
diff --git a/plat/st/common/stm32mp_common.c b/plat/st/common/stm32mp_common.c
index 91204089b..8f35fe250 100644
--- a/plat/st/common/stm32mp_common.c
+++ b/plat/st/common/stm32mp_common.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2021, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -7,17 +7,54 @@
 #include <assert.h>
 #include <errno.h>
 
-#include <platform_def.h>
-
 #include <arch_helpers.h>
 #include <common/debug.h>
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32_console.h>
 #include <drivers/st/stm32mp_clkfunc.h>
+#include <drivers/st/stm32mp_reset.h>
+#include <lib/mmio.h>
 #include <lib/smccc.h>
+#include <lib/spinlock.h>
 #include <lib/xlat_tables/xlat_tables_v2.h>
 #include <plat/common/platform.h>
 #include <services/arm_arch_svc.h>
 
+#include <platform_def.h>
+
 #define HEADER_VERSION_MAJOR_MASK	GENMASK(23, 16)
+#define RESET_TIMEOUT_US_1MS		1000U
+
+#define BOOT_ITF_MASK			GENMASK_32(15, 12)
+#define BOOT_ITF_SHIFT			12
+#define BOOT_INST_MASK			GENMASK_32(11, 8)
+#define BOOT_INST_SHIFT			8
+
+/* Internal layout of the 32bit OTP word board_id */
+#define BOARD_ID_BOARD_NB_MASK		GENMASK_32(31, 16)
+#define BOARD_ID_BOARD_NB_SHIFT		16
+#define BOARD_ID_VARCPN_MASK		GENMASK_32(15, 12)
+#define BOARD_ID_VARCPN_SHIFT		12
+#define BOARD_ID_REVISION_MASK		GENMASK_32(11, 8)
+#define BOARD_ID_REVISION_SHIFT		8
+#define BOARD_ID_VARFG_MASK		GENMASK_32(7, 4)
+#define BOARD_ID_VARFG_SHIFT		4
+#define BOARD_ID_BOM_MASK		GENMASK_32(3, 0)
+
+#define BOARD_ID2NB(_id)		(((_id) & BOARD_ID_BOARD_NB_MASK) >> \
+					 BOARD_ID_BOARD_NB_SHIFT)
+#define BOARD_ID2VARCPN(_id)		(((_id) & BOARD_ID_VARCPN_MASK) >> \
+					 BOARD_ID_VARCPN_SHIFT)
+#define BOARD_ID2REV(_id)		(((_id) & BOARD_ID_REVISION_MASK) >> \
+					 BOARD_ID_REVISION_SHIFT)
+#define BOARD_ID2VARFG(_id)		(((_id) & BOARD_ID_VARFG_MASK) >> \
+					 BOARD_ID_VARFG_SHIFT)
+#define BOARD_ID2BOM(_id)		((_id) & BOARD_ID_BOM_MASK)
+
+static console_t console;
+static struct dt_node_info dt_uart_info;
+static struct spinlock lock;
 
 uintptr_t plat_get_ns_image_entrypoint(void)
 {
@@ -31,6 +68,9 @@ unsigned int plat_get_syscnt_freq2(void)
 
 static uintptr_t boot_ctx_address;
 static uint16_t boot_itf_selected;
+#if STM32MP13 || STM32MP15
+static uint32_t boot_action_saved;
+#endif
 
 void stm32mp_save_boot_ctx_address(uintptr_t address)
 {
@@ -38,6 +78,9 @@ void stm32mp_save_boot_ctx_address(uintptr_t address)
 
 	boot_ctx_address = address;
 	boot_itf_selected = boot_context->boot_interface_selected;
+#if STM32MP13 || STM32MP15
+	boot_action_saved = boot_context->boot_action;
+#endif
 }
 
 uintptr_t stm32mp_get_boot_ctx_address(void)
@@ -50,6 +93,13 @@ uint16_t stm32mp_get_boot_itf_selected(void)
 	return boot_itf_selected;
 }
 
+#if STM32MP13 || STM32MP15
+uint32_t stm32mp_get_boot_action(void)
+{
+	return boot_action_saved;
+}
+#endif
+
 uintptr_t stm32mp_ddrctrl_base(void)
 {
 	return DDRCTRL_BASE;
@@ -75,45 +125,26 @@ bool stm32mp_lock_available(void)
 	const uint32_t c_m_bits = SCTLR_M_BIT | SCTLR_C_BIT;
 
 	/* The spinlocks are used only when MMU and data cache are enabled */
+#ifdef __aarch64__
+	return (read_sctlr_el3() & c_m_bits) == c_m_bits;
+#else
 	return (read_sctlr() & c_m_bits) == c_m_bits;
+#endif
 }
 
-#if STM32MP_USE_STM32IMAGE
-int stm32mp_check_header(boot_api_image_header_t *header, uintptr_t buffer)
+void stm32mp_pwr_regs_lock(void)
 {
-	uint32_t i;
-	uint32_t img_checksum = 0U;
-
-	/*
-	 * Check header/payload validity:
-	 *	- Header magic
-	 *	- Header version
-	 *	- Payload checksum
-	 */
-	if (header->magic != BOOT_API_IMAGE_HEADER_MAGIC_NB) {
-		ERROR("Header magic\n");
-		return -EINVAL;
-	}
-
-	if ((header->header_version & HEADER_VERSION_MAJOR_MASK) !=
-	    (BOOT_API_HEADER_VERSION & HEADER_VERSION_MAJOR_MASK)) {
-		ERROR("Header version\n");
-		return -EINVAL;
-	}
-
-	for (i = 0U; i < header->image_length; i++) {
-		img_checksum += *(uint8_t *)(buffer + i);
+	if (stm32mp_lock_available()) {
+		spin_lock(&lock);
 	}
+}
 
-	if (header->payload_checksum != img_checksum) {
-		ERROR("Checksum: 0x%x (awaited: 0x%x)\n", img_checksum,
-		      header->payload_checksum);
-		return -EINVAL;
+void stm32mp_pwr_regs_unlock(void)
+{
+	if (stm32mp_lock_available()) {
+		spin_unlock(&lock);
 	}
-
-	return 0;
 }
-#endif /* STM32MP_USE_STM32IMAGE */
 
 int stm32mp_map_ddr_non_cacheable(void)
 {
@@ -128,6 +159,193 @@ int stm32mp_unmap_ddr(void)
 					   STM32MP_DDR_MAX_SIZE);
 }
 
+int stm32_get_otp_index(const char *otp_name, uint32_t *otp_idx,
+			uint32_t *otp_len)
+{
+	assert(otp_name != NULL);
+	assert(otp_idx != NULL);
+
+	return dt_find_otp_name(otp_name, otp_idx, otp_len);
+}
+
+int stm32_get_otp_value(const char *otp_name, uint32_t *otp_val)
+{
+	uint32_t otp_idx;
+
+	assert(otp_name != NULL);
+	assert(otp_val != NULL);
+
+	if (stm32_get_otp_index(otp_name, &otp_idx, NULL) != 0) {
+		return -1;
+	}
+
+	if (stm32_get_otp_value_from_idx(otp_idx, otp_val) != 0) {
+		ERROR("BSEC: %s Read Error\n", otp_name);
+		return -1;
+	}
+
+	return 0;
+}
+
+int stm32_get_otp_value_from_idx(const uint32_t otp_idx, uint32_t *otp_val)
+{
+	int ret = BSEC_NOT_SUPPORTED;
+
+	assert(otp_val != NULL);
+
+#if defined(IMAGE_BL2)
+	ret = bsec_shadow_read_otp(otp_val, otp_idx);
+#elif defined(IMAGE_BL31) || defined(IMAGE_BL32)
+	ret = bsec_read_otp(otp_val, otp_idx);
+#else
+#error "Not supported"
+#endif
+	if (ret != BSEC_OK) {
+		ERROR("BSEC: idx=%d Read Error\n", otp_idx);
+		return -1;
+	}
+
+	return 0;
+}
+
+int stm32_get_uid_otp(uint32_t uid[])
+{
+	uint8_t i;
+	uint32_t otp;
+	uint32_t len;
+
+	if (stm32_get_otp_index(UID_OTP, &otp, &len) != 0) {
+		ERROR("BSEC: Get UID_OTP number Error\n");
+		return -1;
+	}
+
+	if ((len / __WORD_BIT) != UID_WORD_NB) {
+		ERROR("BSEC: Get UID_OTP length Error\n");
+		return -1;
+	}
+
+	for (i = 0U; i < UID_WORD_NB; i++) {
+		if (bsec_shadow_read_otp(&uid[i], i + otp) != BSEC_OK) {
+			ERROR("BSEC: UID%u Error\n", i);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+#if  defined(IMAGE_BL2)
+static void reset_uart(uint32_t reset)
+{
+	int ret;
+
+	ret = stm32mp_reset_assert(reset, RESET_TIMEOUT_US_1MS);
+	if (ret != 0) {
+		panic();
+	}
+
+	udelay(2);
+
+	ret = stm32mp_reset_deassert(reset, RESET_TIMEOUT_US_1MS);
+	if (ret != 0) {
+		panic();
+	}
+
+	mdelay(1);
+}
+#endif
+
+static void set_console(uintptr_t base, uint32_t clk_rate)
+{
+	unsigned int console_flags;
+
+	if (console_stm32_register(base, clk_rate,
+				   (uint32_t)STM32MP_UART_BAUDRATE, &console) == 0) {
+		panic();
+	}
+
+	console_flags = CONSOLE_FLAG_BOOT | CONSOLE_FLAG_CRASH |
+			CONSOLE_FLAG_TRANSLATE_CRLF;
+#if !defined(IMAGE_BL2) && defined(DEBUG)
+	console_flags |= CONSOLE_FLAG_RUNTIME;
+#endif
+
+	console_set_scope(&console, console_flags);
+}
+
+int stm32mp_uart_console_setup(void)
+{
+	uint32_t clk_rate = 0U;
+	int result;
+	uint32_t boot_itf __unused;
+	uint32_t boot_instance __unused;
+
+	result = dt_get_stdout_uart_info(&dt_uart_info);
+
+	if ((result <= 0) ||
+	    (dt_uart_info.status == DT_DISABLED)) {
+		return -ENODEV;
+	}
+
+#if defined(IMAGE_BL2)
+	if ((dt_uart_info.clock < 0) ||
+	    (dt_uart_info.reset < 0)) {
+		return -ENODEV;
+	}
+#endif
+
+#if STM32MP_UART_PROGRAMMER || !defined(IMAGE_BL2)
+	stm32_get_boot_interface(&boot_itf, &boot_instance);
+
+	if ((boot_itf == BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART) &&
+	    (get_uart_address(boot_instance) == dt_uart_info.base)) {
+		return -EACCES;
+	}
+#endif
+
+#if defined(IMAGE_BL2)
+	if (dt_set_stdout_pinctrl() != 0) {
+		return -ENODEV;
+	}
+
+	clk_enable((unsigned long)dt_uart_info.clock);
+
+	reset_uart((uint32_t)dt_uart_info.reset);
+
+	clk_rate = clk_get_rate((unsigned long)dt_uart_info.clock);
+#endif
+
+	set_console(dt_uart_info.base, clk_rate);
+
+	return 0;
+}
+
+#if STM32MP_EARLY_CONSOLE
+void stm32mp_setup_early_console(void)
+{
+#if defined(IMAGE_BL2) || STM32MP_RECONFIGURE_CONSOLE
+	plat_crash_console_init();
+#endif
+	set_console(STM32MP_DEBUG_USART_BASE, STM32MP_DEBUG_USART_CLK_FRQ);
+	NOTICE("Early console setup\n");
+}
+#endif /* STM32MP_EARLY_CONSOLE */
+
+void stm32mp_set_console_after_standby(void)
+{
+	unsigned int console_flags;
+
+	console_flags = CONSOLE_FLAG_CRASH | CONSOLE_FLAG_TRANSLATE_CRLF;
+	if ((clk_is_enabled(dt_uart_info.clock)) &&
+	    (clk_get_rate(dt_uart_info.clock) != 0U)) {
+		console_flags |= CONSOLE_FLAG_BOOT;
+#ifdef DEBUG
+		console_flags |= CONSOLE_FLAG_RUNTIME;
+#endif
+	}
+	console_set_scope(&console, console_flags);
+}
+
 /*****************************************************************************
  * plat_is_smccc_feature_available() - This function checks whether SMCCC
  *                                     feature is availabile for platform.
@@ -160,3 +378,47 @@ int32_t plat_get_soc_revision(void)
 {
 	return (int32_t)(stm32mp_get_chip_version() & SOC_ID_REV_MASK);
 }
+
+void stm32_save_boot_itf(uint32_t interface, uint32_t instance,
+			 unsigned long clk_id, uintptr_t bkpr)
+{
+	clk_enable(clk_id);
+
+	mmio_clrsetbits_32(bkpr,
+			   BOOT_ITF_MASK | BOOT_INST_MASK,
+			   ((interface << BOOT_ITF_SHIFT) & BOOT_ITF_MASK) |
+			   ((instance << BOOT_INST_SHIFT) & BOOT_INST_MASK));
+
+	clk_disable(clk_id);
+}
+
+void stm32_get_boot_itf(uint32_t *interface, uint32_t *instance,
+			unsigned long clk_id, uintptr_t bkpr)
+{
+	static uint32_t itf;
+
+	if (itf == 0U) {
+		clk_enable(clk_id);
+
+		itf = mmio_read_32(bkpr) & (BOOT_ITF_MASK | BOOT_INST_MASK);
+
+		clk_disable(clk_id);
+	}
+
+	*interface = (itf & BOOT_ITF_MASK) >> BOOT_ITF_SHIFT;
+	*instance = (itf & BOOT_INST_MASK) >> BOOT_INST_SHIFT;
+}
+
+void stm32_display_board_info(uint32_t board_id)
+{
+	char rev[2];
+
+	rev[0] = BOARD_ID2REV(board_id) - 1 + 'A';
+	rev[1] = '\0';
+	NOTICE("Board: MB%04x Var%u.%u Rev.%s-%02u\n",
+	       BOARD_ID2NB(board_id),
+	       BOARD_ID2VARCPN(board_id),
+	       BOARD_ID2VARFG(board_id),
+	       rev,
+	       BOARD_ID2BOM(board_id));
+}
diff --git a/plat/st/common/stm32mp_crypto_lib.c b/plat/st/common/stm32mp_crypto_lib.c
new file mode 100644
index 000000000..606e01144
--- /dev/null
+++ b/plat/st/common/stm32mp_crypto_lib.c
@@ -0,0 +1,658 @@
+/*
+ * Copyright (c) 2020-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <endian.h>
+#include <errno.h>
+
+#include <mbedtls/asn1.h>
+#include <mbedtls/md.h>
+#include <mbedtls/oid.h>
+#include <mbedtls/platform.h>
+#include <mbedtls/x509.h>
+
+#include <common/debug.h>
+#include <drivers/auth/crypto_mod.h>
+#include <drivers/io/io_storage.h>
+#include <drivers/st/bsec.h>
+#include <drivers/st/stm32_hash.h>
+#if STM32MP13
+#include <drivers/st/stm32_pka.h>
+#include <drivers/st/stm32_rng.h>
+#include <drivers/st/stm32_saes.h>
+#endif
+#include <lib/xlat_tables/xlat_tables_v2.h>
+#include <plat/common/platform.h>
+#include <tools_share/firmware_encrypted.h>
+
+#include <platform_def.h>
+
+#define CRYPTO_HASH_MAX_SIZE	32U
+#define CRYPTO_SIGN_MAX_SIZE	64U
+#define CRYPTO_PUBKEY_MAX_SIZE	64U
+#define CRYPTO_MAX_TAG_SIZE	16U
+
+#if STM32MP15
+struct stm32mp_auth_ops {
+	uint32_t (*verify_signature)(uint8_t *hash_in, uint8_t *pubkey_in,
+				     uint8_t *signature, uint32_t ecc_algo);
+};
+
+static struct stm32mp_auth_ops auth_ops;
+
+#endif
+
+static void crypto_lib_init(void)
+{
+#if STM32MP15
+	boot_api_context_t *boot_context =
+		(boot_api_context_t *)stm32mp_get_boot_ctx_address();
+#endif
+
+	int ret;
+
+	NOTICE("TRUSTED_BOARD_BOOT support enabled\n");
+
+	ret = stm32_hash_register();
+	if (ret != 0) {
+		ERROR("HASH init (%d)\n", ret);
+		panic();
+	}
+
+	if (!stm32mp_is_closed_device() && !stm32mp_is_auth_supported()) {
+		return;
+	}
+
+#if STM32MP13
+	if (stm32_rng_init() != 0) {
+		panic();
+	}
+
+	if (stm32_saes_driver_init() != 0) {
+		panic();
+	}
+
+	if (stm32_pka_init() != 0) {
+		panic();
+	}
+#endif
+
+#if STM32MP15
+	auth_ops.verify_signature =
+		boot_context->bootrom_ecdsa_verify_signature;
+#endif
+}
+
+int get_plain_pk_from_asn1(void *pk_ptr, unsigned int pk_len, void **plain_pk,
+			   unsigned int *len, int *pk_alg)
+{
+	int ret;
+	mbedtls_pk_context mbedtls_pk = {0};
+	unsigned char *p, *end;
+	mbedtls_asn1_buf alg_params = {0};
+	mbedtls_asn1_buf alg_oid = {0};
+
+	*plain_pk = NULL;
+	*len = 0U;
+
+	/* Parse the public key */
+	mbedtls_pk_init(&mbedtls_pk);
+	p = (unsigned char *)pk_ptr;
+	end = (unsigned char *)(p + pk_len);
+
+	ret =  mbedtls_asn1_get_tag(&p, end, len,
+				    MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE);
+	if (ret != 0) {
+		return -EINVAL;
+	}
+
+	end = p + *len;
+	ret = mbedtls_asn1_get_alg(&p, end, &alg_oid, &alg_params);
+	if (ret != 0) {
+		VERBOSE("%s: mbedtls_asn1_get_alg (%d)\n", __func__, ret);
+		return -EINVAL;
+	}
+
+	if (pk_alg != NULL) {
+		if ((strlen(MBEDTLS_OID_EC_GRP_SECP256R1) == alg_params.len) &&
+		    (memcmp(MBEDTLS_OID_EC_GRP_SECP256R1, alg_params.p, alg_params.len) == 0)) {
+			*pk_alg = BOOT_API_ECDSA_ALGO_TYPE_P256NIST;
+		} else {
+			*pk_alg = BOOT_API_ECDSA_ALGO_TYPE_BRAINPOOL256;
+		}
+	}
+
+	ret = mbedtls_asn1_get_bitstring_null(&p, end, len);
+	if (ret != 0) {
+		VERBOSE("%s: mbedtls_asn1_get_bitstring_null (%d)\n", __func__, ret);
+		return -EINVAL;
+	}
+
+	/* we remove the ident (0x04) first byte.  */
+	if ((*len < 1U) || (p[0] !=  MBEDTLS_ASN1_OCTET_STRING)) {
+		VERBOSE("%s: not expected len or tag\n", __func__);
+		return -EINVAL;
+	}
+
+	*len = *len - 1U;
+	*plain_pk = p + 1U;
+
+	return 0;
+}
+
+#if STM32MP13
+static uint32_t verify_signature(uint8_t *hash_in, uint8_t *pubkey_in,
+				 uint8_t *signature, uint32_t ecc_algo)
+{
+	int ret;
+	enum stm32_pka_ecdsa_curve_id cid;
+
+	switch (ecc_algo) {
+	case BOOT_API_ECDSA_ALGO_TYPE_P256NIST:
+#if PKA_USE_NIST_P256
+		cid = PKA_NIST_P256;
+		break;
+#else
+		WARN("%s nist_p256 requested but not included\n", __func__);
+		return CRYPTO_ERR_SIGNATURE;
+#endif
+	case BOOT_API_ECDSA_ALGO_TYPE_BRAINPOOL256:
+#if PKA_USE_BRAINPOOL_P256T1
+		cid = PKA_BRAINPOOL_P256T1;
+		break;
+#else
+		WARN("%s brainpool_p256t1 requested but not included\n", __func__);
+		return CRYPTO_ERR_SIGNATURE;
+#endif
+	default:
+		WARN("%s unexpected ecc_algo(%d)\n", __func__, ecc_algo);
+		return CRYPTO_ERR_SIGNATURE;
+	}
+
+	ret = stm32_pka_ecdsa_verif(hash_in,
+				    BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES,
+				    signature, BOOT_API_ECDSA_SIGNATURE_LEN_IN_BYTES / 2U,
+				    signature + BOOT_API_ECDSA_SIGNATURE_LEN_IN_BYTES / 2U,
+				    BOOT_API_ECDSA_SIGNATURE_LEN_IN_BYTES / 2U,
+				    pubkey_in, BOOT_API_ECDSA_PUB_KEY_LEN_IN_BYTES / 2U,
+				    pubkey_in + BOOT_API_ECDSA_PUB_KEY_LEN_IN_BYTES / 2U,
+				    BOOT_API_ECDSA_PUB_KEY_LEN_IN_BYTES / 2U, cid);
+	if (ret < 0) {
+		return CRYPTO_ERR_SIGNATURE;
+	}
+
+	return 0;
+}
+
+int plat_get_hashed_pk(void *full_pk_ptr, unsigned int full_pk_len,
+		       void **hashed_pk_ptr, unsigned int *hashed_pk_len)
+{
+	static uint8_t st_pk[CRYPTO_PUBKEY_MAX_SIZE + sizeof(uint32_t)];
+	int ret;
+	void *plain_pk;
+	unsigned int len;
+	int curve_id;
+	uint32_t cid;
+
+	ret = get_plain_pk_from_asn1(full_pk_ptr, full_pk_len, &plain_pk, &len, &curve_id);
+	if ((ret != 0) || (len > CRYPTO_PUBKEY_MAX_SIZE))  {
+		return -EINVAL;
+	}
+
+	cid = curve_id; /* we want value of curve_id (1 or 2) in a uint32_t */
+
+	memcpy(st_pk, &cid, sizeof(cid));
+	memcpy(st_pk + sizeof(cid), plain_pk, len);
+
+	*hashed_pk_ptr = st_pk;
+	*hashed_pk_len = len + sizeof(cid);
+
+	return 0;
+}
+#endif
+
+#if STM32MP15
+uint32_t verify_signature(uint8_t *hash_in, uint8_t *pubkey_in,
+			  uint8_t *signature, uint32_t ecc_algo)
+{
+	int ret;
+
+	ret = mmap_add_dynamic_region(STM32MP_ROM_BASE, STM32MP_ROM_BASE,
+				      STM32MP_ROM_SIZE_2MB_ALIGNED, MT_CODE | MT_SECURE);
+	if (ret != 0) {
+		VERBOSE("%s: mmap_add_dynamic_region (%d)\n", __func__, ret);
+		return CRYPTO_ERR_SIGNATURE;
+	}
+
+	ret = auth_ops.verify_signature(hash_in, pubkey_in, signature, ecc_algo);
+
+	if (ret != BOOT_API_RETURN_OK) {
+		VERBOSE("%s: auth_ops.verify_sign (%d)\n", __func__, ret);
+		ret = CRYPTO_ERR_SIGNATURE;
+	} else {
+		ret = 0;
+	}
+
+	mmap_remove_dynamic_region(STM32MP_ROM_BASE, STM32MP_ROM_SIZE_2MB_ALIGNED);
+
+	return ret;
+}
+
+int plat_get_hashed_pk(void *full_pk_ptr, unsigned int full_pk_len,
+		       void **hashed_pk_ptr, unsigned int *hashed_pk_len)
+{
+	return get_plain_pk_from_asn1(full_pk_ptr, full_pk_len, hashed_pk_ptr, hashed_pk_len, NULL);
+}
+#endif
+
+static int get_plain_digest_from_asn1(void *digest_ptr, unsigned int digest_len,
+				      uint8_t **out, size_t *out_len, mbedtls_md_type_t *md_alg)
+{
+	int ret;
+	mbedtls_asn1_buf hash_oid, params;
+	size_t len;
+	unsigned char *p, *end;
+
+	*out = NULL;
+	*out_len = 0U;
+
+	/* Digest info should be an MBEDTLS_ASN1_SEQUENCE */
+	p = (unsigned char *)digest_ptr;
+	end = p + digest_len;
+	ret = mbedtls_asn1_get_tag(&p, end, &len, MBEDTLS_ASN1_CONSTRUCTED |
+				   MBEDTLS_ASN1_SEQUENCE);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Get the hash algorithm */
+	ret = mbedtls_asn1_get_alg(&p, end, &hash_oid, &params);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = mbedtls_oid_get_md_alg(&hash_oid, md_alg);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = mbedtls_asn1_get_tag(&p, end, &len, MBEDTLS_ASN1_OCTET_STRING);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Length of hash must match the algorithm's size */
+	if (len != BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES) {
+		return -1;
+	}
+
+	*out = p;
+	*out_len = len;
+
+	return 0;
+}
+
+static int crypto_verify_signature(void *data_ptr, unsigned int data_len,
+				   void *sig_ptr, unsigned int sig_len,
+				   void *sig_alg, unsigned int sig_alg_len,
+				   void *pk_ptr, unsigned int pk_len)
+{
+	uint8_t image_hash[CRYPTO_HASH_MAX_SIZE] = {0};
+	uint8_t sig[CRYPTO_SIGN_MAX_SIZE];
+	uint8_t my_pk[CRYPTO_PUBKEY_MAX_SIZE];
+	int ret;
+	size_t len;
+	mbedtls_asn1_sequence seq;
+	mbedtls_asn1_sequence *cur;
+	unsigned char *p, *end;
+	int curve_id;
+	mbedtls_asn1_buf sig_oid, sig_params;
+	mbedtls_md_type_t md_alg;
+	mbedtls_pk_type_t pk_alg;
+	size_t bignum_len = sizeof(sig) / 2U;
+	unsigned int seq_num = 0U;
+
+	if (!stm32mp_is_closed_device() && !stm32mp_is_auth_supported()) {
+		return CRYPTO_SUCCESS;
+	}
+
+	/* Get pointers to signature OID and parameters */
+	p = (unsigned char *)sig_alg;
+	end = (unsigned char *)(p + sig_alg_len);
+	ret = mbedtls_asn1_get_alg(&p, end, &sig_oid, &sig_params);
+	if (ret != 0) {
+		VERBOSE("%s: mbedtls_asn1_get_alg (%d)\n", __func__, ret);
+		return CRYPTO_ERR_SIGNATURE;
+	}
+
+	/* Get the actual signature algorithm (MD + PK) */
+	ret = mbedtls_oid_get_sig_alg(&sig_oid, &md_alg, &pk_alg);
+	if (ret != 0) {
+		VERBOSE("%s: mbedtls_oid_get_sig_alg (%d)\n", __func__, ret);
+		return CRYPTO_ERR_SIGNATURE;
+	}
+
+	if ((md_alg != MBEDTLS_MD_SHA256) || (pk_alg != MBEDTLS_PK_ECDSA)) {
+		VERBOSE("%s: md_alg=%d pk_alg=%d\n", __func__, md_alg, pk_alg);
+		return CRYPTO_ERR_SIGNATURE;
+	}
+
+	ret = get_plain_pk_from_asn1(pk_ptr, pk_len, &pk_ptr, &pk_len, &curve_id);
+	if (ret != 0) {
+		VERBOSE("%s: get_plain_pk_from_asn1 (%d)\n", __func__, ret);
+		return CRYPTO_ERR_SIGNATURE;
+	}
+
+	/* We expect a known pk_len */
+	if (pk_len != sizeof(my_pk)) {
+		VERBOSE("%s: pk_len=%d sizeof(my_pk)=%d)\n", __func__, pk_len, sizeof(my_pk));
+		return CRYPTO_ERR_SIGNATURE;
+	}
+
+	/* Need to copy as auth_ops.verify_signature
+	 * expects aligned public key.
+	 */
+	memcpy(my_pk, pk_ptr, sizeof(my_pk));
+
+	/* Get the signature (bitstring) */
+	p = (unsigned char *)sig_ptr;
+	end = (unsigned char *)(p + sig_len);
+	ret = mbedtls_asn1_get_bitstring_null(&p, end, &len);
+	if (ret != 0) {
+		VERBOSE("%s: mbedtls_asn1_get_bitstring_null (%d)\n", __func__, ret);
+		return CRYPTO_ERR_SIGNATURE;
+	}
+
+	/* Get r and s from sequence */
+	ret = mbedtls_asn1_get_sequence_of(&p, end, &seq, MBEDTLS_ASN1_INTEGER);
+	if (ret != 0) {
+		VERBOSE("%s: mbedtls_asn1_get_sequence_of (%d)\n", __func__, ret);
+		return CRYPTO_ERR_SIGNATURE;
+	}
+
+	/* We expect only 2 integers (r and s) from the sequence */
+	if (seq.next->next != NULL) {
+		cur = seq.next;
+		mbedtls_asn1_sequence *next;
+
+		VERBOSE("%s: nb seq != 2\n", __func__);
+		/* Free all the sequences */
+		while (cur != NULL) {
+			next = cur->next;
+			mbedtls_free(cur);
+			cur = next;
+		}
+
+		return CRYPTO_ERR_SIGNATURE;
+	}
+
+	/*
+	 * ECDSA signatures are composed of a tuple (R,S) where R and S are between 0 and n.
+	 * This means that the R and S can have a maximum of 32 each, but can also be smaller.
+	 * Also seen the integer sequence may (sometime) start with 0x00 as MSB, but we can only
+	 * manage exactly 2*32 bytes, we remove this higher byte if there are not 00,
+	 * we will fail either.
+	 */
+	cur = &seq;
+	memset(sig, 0U, sizeof(sig));
+
+	while (cur != NULL) {
+		size_t skip = 0U;
+		size_t seek = seq_num * bignum_len;
+
+		if (cur->buf.len > bignum_len) {
+			/* Remove extra 0x00 bytes */
+			skip = cur->buf.len - bignum_len;
+		} else if (cur->buf.len < bignum_len) {
+			/* Add padding to match HW required size */
+			seek += (bignum_len % cur->buf.len);
+		}
+
+		if (seek + cur->buf.len > sizeof(sig) + skip) {
+			panic();
+		}
+
+		memcpy(sig + seek, cur->buf.p + skip, cur->buf.len - skip);
+		cur = cur->next;
+		seq_num++;
+	}
+
+	/* Need to free allocated 'next' in mbedtls_asn1_get_sequence_of */
+	mbedtls_free(seq.next);
+
+	/* Compute hash for the data covered by the signature */
+	stm32_hash_init(HASH_SHA256);
+
+	ret = stm32_hash_final_update((uint8_t *)data_ptr, data_len, image_hash);
+	if (ret != 0) {
+		VERBOSE("%s: stm32_hash_final_update (%d)\n", __func__, ret);
+		return CRYPTO_ERR_SIGNATURE;
+	}
+
+	return verify_signature(image_hash, my_pk, sig, curve_id);
+}
+
+static int crypto_verify_hash(void *data_ptr, unsigned int data_len,
+			      void *digest_info_ptr,
+			      unsigned int digest_info_len)
+{
+	int ret;
+	uint8_t calc_hash[BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES];
+	unsigned char *p;
+	mbedtls_md_type_t md_alg;
+	size_t len;
+
+	/* we receive an asn1 encapsulated digest, we flatten it */
+	ret = get_plain_digest_from_asn1(digest_info_ptr,
+					 digest_info_len, &p, &len,
+					 &md_alg);
+	if ((ret != 0) || (md_alg != MBEDTLS_MD_SHA256) || (len != sizeof(calc_hash))) {
+		return CRYPTO_ERR_HASH;
+	}
+
+	digest_info_ptr = p;
+	digest_info_len = len;
+
+	stm32_hash_init(HASH_SHA256);
+
+	ret = stm32_hash_final_update(data_ptr, data_len, calc_hash);
+	if (ret != 0) {
+		VERBOSE("%s: hash failed\n", __func__);
+		return CRYPTO_ERR_HASH;
+	}
+
+	ret = memcmp(calc_hash, digest_info_ptr, digest_info_len);
+	if (ret != 0) {
+		VERBOSE("%s: not expected digest\n", __func__);
+		ret = CRYPTO_ERR_HASH;
+	}
+
+	return ret;
+}
+
+#if STM32MP13 && !defined(DECRYPTION_SUPPORT_none)
+int derive_key(uint8_t *key, size_t *key_len, size_t len,
+	       unsigned int *flags, const uint8_t *img_id, size_t img_id_len)
+{
+	size_t i, j;
+
+	assert(*key_len >= 32U);
+
+	/*
+	 * Not a real derivation yet
+	 *
+	 * But we expect a 32 bytes key, and otp is only 16 bytes
+	 *   => duplicate.
+	 */
+	for (i = 0U, j = len; j < 32U;
+	     i += sizeof(uint32_t), j += sizeof(uint32_t)) {
+		memcpy(key + j, key + i, sizeof(uint32_t));
+	}
+
+	*key_len = 32U;
+	/* Variable 'key' store a real key */
+	*flags = 0U;
+
+	return 0;
+}
+
+int plat_get_enc_key_info(enum fw_enc_status_t fw_enc_status, uint8_t *key,
+			  size_t *key_len, unsigned int *flags,
+			  const uint8_t *img_id, size_t img_id_len)
+{
+	uint32_t otp_idx;
+	uint32_t otp_len;
+	size_t read_len;
+	size_t i;
+
+	if (fw_enc_status == FW_ENC_WITH_BSSK) {
+		return -EINVAL;
+	}
+
+	if (stm32_get_otp_index(ENCKEY_OTP, &otp_idx, &otp_len) != 0) {
+		VERBOSE("%s: get %s index error\n", __func__, ENCKEY_OTP);
+		return -EINVAL;
+	}
+
+	if (otp_len > (*key_len * CHAR_BIT)) {
+		VERBOSE("%s: length Error otp_len=%d key_len=%u\n", __func__,
+			otp_len, *key_len * CHAR_BIT);
+		return -EINVAL;
+	}
+
+	read_len = otp_len / CHAR_BIT;
+	assert(read_len % sizeof(uint32_t) == 0);
+
+	for (i = 0U; i < read_len / sizeof(uint32_t); i++) {
+		uint32_t tmp;
+		uint32_t otp_val;
+
+		if (stm32_get_otp_value_from_idx(otp_idx + i, &otp_val) != 0) {
+			VERBOSE("%s: unable to read from otp\n", __func__);
+			return -EINVAL;
+		}
+
+		tmp = bswap32(otp_val);
+		memcpy(key + i * sizeof(uint32_t), &tmp, sizeof(tmp));
+	}
+
+	/* Now we have the OTP values in key till read_len */
+
+	if (derive_key(key, key_len, read_len, flags, img_id,
+		       img_id_len) != 0) {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static enum stm32_saes_key_selection select_key(unsigned int key_flags)
+{
+	if ((key_flags & ENC_KEY_IS_IDENTIFIER) != 0U) {
+		panic();
+	}
+
+	/* Use the provided key buffer */
+	return STM32_SAES_KEY_SOFT;
+}
+
+static int stm32_decrypt_aes_gcm(void *data, size_t data_len,
+				 const void *key, unsigned int key_len,
+				 unsigned int key_flags,
+				 const void *iv, unsigned int iv_len,
+				 const void *tag, unsigned int tag_len)
+{
+	int ret;
+	struct stm32_saes_context ctx;
+	unsigned char tag_buf[CRYPTO_MAX_TAG_SIZE];
+	enum stm32_saes_key_selection key_mode;
+	unsigned int diff, i;
+
+	key_mode = select_key(key_flags);
+
+	ret = stm32_saes_init(&ctx, true, STM32_SAES_MODE_GCM, key_mode, key,
+			      key_len, iv, iv_len);
+	if (ret != 0) {
+		return CRYPTO_ERR_INIT;
+	}
+
+	ret = stm32_saes_update_assodata(&ctx, true, NULL, 0U);
+	if (ret != 0) {
+		return CRYPTO_ERR_DECRYPTION;
+	}
+
+	ret = stm32_saes_update_load(&ctx, true, data, data, data_len);
+	if (ret != 0) {
+		return CRYPTO_ERR_DECRYPTION;
+	}
+
+	ret = stm32_saes_final(&ctx, tag_buf, sizeof(tag_buf));
+	if (ret != 0) {
+		return CRYPTO_ERR_DECRYPTION;
+	}
+
+	/* Check tag in "constant-time" */
+	for (diff = 0U, i = 0U; i < tag_len; i++) {
+		diff |= ((const unsigned char *)tag)[i] ^ tag_buf[i];
+	}
+
+	if (diff != 0U) {
+		return CRYPTO_ERR_DECRYPTION;
+	}
+
+	return CRYPTO_SUCCESS;
+}
+
+/*
+ * Authenticated decryption of an image
+ *
+ */
+static int crypto_auth_decrypt(enum crypto_dec_algo dec_algo, void *data_ptr, size_t len,
+			       const void *key, unsigned int key_len, unsigned int key_flags,
+			       const void *iv, unsigned int iv_len, const void *tag,
+			       unsigned int tag_len)
+{
+	int rc;
+	uint32_t real_iv[4];
+
+	switch (dec_algo) {
+	case CRYPTO_GCM_DECRYPT:
+		/*
+		 * GCM expect a Nonce
+		 * The AES IV is the nonce (a uint32_t[3])
+		 * then a counter (a uint32_t big endian)
+		 * The counter starts at 2.
+		 */
+		memcpy(real_iv, iv, iv_len);
+		real_iv[3] = htobe32(0x2U);
+
+		rc = stm32_decrypt_aes_gcm(data_ptr, len, key, key_len, key_flags,
+					   real_iv, sizeof(real_iv), tag, tag_len);
+		if (rc != 0) {
+			return rc;
+		}
+		break;
+	default:
+		return CRYPTO_ERR_DECRYPTION;
+	}
+
+	return CRYPTO_SUCCESS;
+}
+
+REGISTER_CRYPTO_LIB("stm32_crypto_lib",
+		    crypto_lib_init,
+		    crypto_verify_signature,
+		    crypto_verify_hash,
+		    crypto_auth_decrypt);
+
+#else /* No decryption support */
+REGISTER_CRYPTO_LIB("stm32_crypto_lib",
+		    crypto_lib_init,
+		    crypto_verify_signature,
+		    crypto_verify_hash,
+		    NULL);
+
+#endif
diff --git a/plat/st/common/stm32mp_dt.c b/plat/st/common/stm32mp_dt.c
index 4dc990896..a0daf9514 100644
--- a/plat/st/common/stm32mp_dt.c
+++ b/plat/st/common/stm32mp_dt.c
@@ -1,11 +1,12 @@
 /*
- * Copyright (c) 2017-2021, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2017-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
 #include <assert.h>
 #include <errno.h>
+#include <inttypes.h>
 
 #include <libfdt.h>
 
@@ -13,9 +14,8 @@
 
 #include <common/debug.h>
 #include <common/fdt_wrappers.h>
+#include <drivers/regulator.h>
 #include <drivers/st/stm32_gpio.h>
-#include <drivers/st/stm32mp1_ddr.h>
-#include <drivers/st/stm32mp1_ram.h>
 
 #include <stm32mp_dt.h>
 
@@ -115,6 +115,30 @@ static int fdt_get_node_parent_address_cells(int node)
 }
 #endif
 
+/*******************************************************************************
+ * This function return interrupts from node.
+ ******************************************************************************/
+int fdt_get_interrupt(int node, const fdt32_t **array, int *len, bool *extended)
+{
+	*extended = false;
+
+	*array = fdt_getprop(fdt, node, "secure-interrupts", len);
+	if (*array == NULL) {
+		*array = fdt_getprop(fdt, node, "interrupts-extended", len);
+		if (*array == NULL) {
+			*array = fdt_getprop(fdt, node, "interrupts", len);
+		} else {
+			*extended = true;
+		}
+	}
+
+	if (*array == NULL) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	return 0;
+}
+
 /*******************************************************************************
  * This function gets the stdout pin configuration information from the DT.
  * And then calls the sub-function to treat it and set GPIO registers.
@@ -256,44 +280,244 @@ uint32_t dt_get_ddr_size(void)
 	return size;
 }
 
+/*******************************************************************************
+ * This function gets OPP table node from the DT.
+ * Returns node offset on success and a negative FDT error code on failure.
+ ******************************************************************************/
+static int dt_get_opp_table_node(void)
+{
+	return fdt_node_offset_by_compatible(fdt, -1, DT_OPP_COMPAT);
+}
+
+/*******************************************************************************
+ * This function gets OPP parameters (frequency in KHz and voltage in mV) from
+ * an OPP table subnode. Platform HW support capabilities are also checked.
+ * Returns 0 on success and a negative FDT error code on failure.
+ ******************************************************************************/
+static int dt_get_opp_freqvolt_from_subnode(int subnode, uint32_t *freq_khz,
+					    uint32_t *voltage_mv)
+{
+	const fdt64_t *cuint64;
+	const fdt32_t *cuint32;
+	uint64_t read_freq_64;
+	uint32_t read_voltage_32;
+
+	assert(freq_khz != NULL);
+	assert(voltage_mv != NULL);
+
+	cuint32 = fdt_getprop(fdt, subnode, "opp-supported-hw", NULL);
+	if (cuint32 != NULL) {
+		if (!stm32mp_supports_cpu_opp(fdt32_to_cpu(*cuint32))) {
+			VERBOSE("Invalid opp-supported-hw 0x%x\n",
+				fdt32_to_cpu(*cuint32));
+			return -FDT_ERR_BADVALUE;
+		}
+	}
+
+	cuint64 = fdt_getprop(fdt, subnode, "opp-hz", NULL);
+	if (cuint64 == NULL) {
+		VERBOSE("Missing opp-hz\n");
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	/* Frequency value expressed in KHz must fit on 32 bits */
+	read_freq_64 = fdt64_to_cpu(*cuint64) / 1000ULL;
+	if (read_freq_64 > (uint64_t)UINT32_MAX) {
+		VERBOSE("Invalid opp-hz %" PRIu64 "\n", read_freq_64);
+		return -FDT_ERR_BADVALUE;
+	}
+
+	cuint32 = fdt_getprop(fdt, subnode, "opp-microvolt", NULL);
+	if (cuint32 == NULL) {
+		VERBOSE("Missing opp-microvolt\n");
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	/* Millivolt value must fit on 16 bits */
+	read_voltage_32 = fdt32_to_cpu(*cuint32) / 1000U;
+	if (read_voltage_32 > (uint32_t)UINT16_MAX) {
+		VERBOSE("Invalid opp-microvolt %u\n", read_voltage_32);
+		return -FDT_ERR_BADVALUE;
+	}
+
+	*freq_khz = (uint32_t)read_freq_64;
+
+	*voltage_mv = read_voltage_32;
+
+	return 0;
+}
+
+/*******************************************************************************
+ * This function parses OPP table in DT and finds the parameters for the
+ * highest frequency supported by the HW platform.
+ * If found, the new frequency and voltage values override the original ones.
+ * Returns 0 on success and a negative FDT error code on failure.
+ ******************************************************************************/
+int dt_get_max_opp_freqvolt(uint32_t *freq_khz, uint32_t *voltage_mv)
+{
+	int node;
+	int subnode;
+	uint32_t freq = 0U;
+	uint32_t voltage = 0U;
+
+	assert(freq_khz != NULL);
+	assert(voltage_mv != NULL);
+
+	node = dt_get_opp_table_node();
+	if (node < 0) {
+		return node;
+	}
+
+	fdt_for_each_subnode(subnode, fdt, node) {
+		uint32_t read_freq;
+		uint32_t read_voltage;
+
+		if (dt_get_opp_freqvolt_from_subnode(subnode, &read_freq,
+						     &read_voltage) != 0) {
+			continue;
+		}
+
+		if (read_freq > freq) {
+			freq = read_freq;
+			voltage = read_voltage;
+		}
+	}
+
+	if ((freq == 0U) || (voltage == 0U)) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	*freq_khz = freq;
+	*voltage_mv = voltage;
+
+	return 0;
+}
+
+/*******************************************************************************
+ * This function parses OPP table in DT and finds all parameters supported by
+ * the HW platform.
+ * If found, the corresponding frequency and voltage values are respectively
+ * stored in @*freq_khz_array and @*voltage_mv_array.
+ * Note that @*count has to be set by caller to the effective size allocated
+ * for both tables. Its value is then replaced by the number of filled elements.
+ * Returns 0 on success and a negative FDT error code on failure.
+ ******************************************************************************/
+int dt_get_all_opp_freqvolt(uint32_t *count, uint32_t *freq_khz_array,
+			    uint32_t *voltage_mv_array)
+{
+	int node;
+	int subnode;
+	uint32_t idx = 0U;
+
+	assert(count != NULL);
+	assert(freq_khz_array != NULL);
+	assert(voltage_mv_array != NULL);
+
+	node = dt_get_opp_table_node();
+	if (node < 0) {
+		return node;
+	}
+
+	fdt_for_each_subnode(subnode, fdt, node) {
+		uint32_t read_freq;
+		uint32_t read_voltage;
+
+		if (dt_get_opp_freqvolt_from_subnode(subnode, &read_freq,
+						     &read_voltage) != 0) {
+			continue;
+		}
+
+		if (idx >= *count) {
+			return -FDT_ERR_NOSPACE;
+		}
+
+		freq_khz_array[idx] = read_freq;
+		voltage_mv_array[idx] = read_voltage;
+		idx++;
+	}
+
+	if (idx == 0U) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	*count = idx;
+
+	return 0;
+}
+
 /*******************************************************************************
  * This function gets PWR VDD regulator voltage information from the DT.
  * Returns value in microvolts on success, and 0 on failure.
  ******************************************************************************/
 uint32_t dt_get_pwr_vdd_voltage(void)
 {
-	int node, pwr_regulators_node;
-	const fdt32_t *cuint;
+	struct rdev *regul = dt_get_vdd_regulator();
+	uint16_t min;
 
-	node = fdt_node_offset_by_compatible(fdt, -1, DT_PWR_COMPAT);
-	if (node < 0) {
-		INFO("%s: Cannot read PWR node in DT\n", __func__);
+	if (regul == NULL) {
 		return 0;
 	}
 
-	pwr_regulators_node = fdt_subnode_offset(fdt, node, "pwr-regulators");
-	if (pwr_regulators_node < 0) {
-		INFO("%s: Cannot read pwr-regulators node in DT\n", __func__);
-		return 0;
+	regulator_get_range(regul, &min, NULL);
+
+	return (uint32_t)min * 1000U;
+}
+
+/*******************************************************************************
+ * This function retrieves VDD supply regulator from DT.
+ * Returns an rdev taken from supply node, NULL otherwise.
+ ******************************************************************************/
+struct rdev *dt_get_vdd_regulator(void)
+{
+	int node = fdt_node_offset_by_compatible(fdt, -1, DT_PWR_COMPAT);
+
+	if (node < 0) {
+		return NULL;
 	}
 
-	cuint = fdt_getprop(fdt, pwr_regulators_node, "vdd-supply", NULL);
-	if (cuint == NULL) {
-		return 0;
+	return regulator_get_by_supply_name(fdt, node, "vdd");
+}
+
+/*******************************************************************************
+ * This function retrieves CPU supply regulator from DT.
+ * Returns an rdev taken from supply node, NULL otherwise.
+ ******************************************************************************/
+struct rdev *dt_get_cpu_regulator(void)
+{
+	int node = fdt_path_offset(fdt, "/cpus/cpu@0");
+
+	if (node < 0) {
+		return NULL;
 	}
 
-	node = fdt_node_offset_by_phandle(fdt, fdt32_to_cpu(*cuint));
+	return regulator_get_by_supply_name(fdt, node, "cpu");
+}
+
+#if IMAGE_BL32
+/*******************************************************************************
+ * This function retrieves USB phy regulator name from DT.
+ * Returns string taken from supply node, NULL otherwise.
+ ******************************************************************************/
+struct rdev *dt_get_usb_phy_regulator(void)
+{
+	int node = fdt_node_offset_by_compatible(fdt, -1, DT_USBPHYC_COMPAT);
+	int subnode;
+
 	if (node < 0) {
-		return 0;
+		return NULL;
 	}
 
-	cuint = fdt_getprop(fdt, node, "regulator-min-microvolt", NULL);
-	if (cuint == NULL) {
-		return 0;
+	fdt_for_each_subnode(subnode, fdt, node) {
+		struct rdev *supply = regulator_get_by_supply_name(fdt, node, "phy");
+
+		if (supply != NULL) {
+			return supply;
+		}
 	}
 
-	return fdt32_to_cpu(*cuint);
+	return NULL;
 }
+#endif
 
 /*******************************************************************************
  * This function retrieves board model from DT
@@ -310,6 +534,57 @@ const char *dt_get_board_model(void)
 	return (const char *)fdt_getprop(fdt, node, "model", NULL);
 }
 
+/*******************************************************************************
+ * dt_find_otp_name: get OTP ID and length in DT.
+ * name: sub-node name to look up.
+ * otp: pointer to read OTP number or NULL.
+ * otp_len: pointer to read OTP length in bits or NULL.
+ * return value: 0 if no error, an FDT error value otherwise.
+ ******************************************************************************/
+int dt_find_otp_name(const char *name, uint32_t *otp, uint32_t *otp_len)
+{
+	int node;
+	int len;
+	const fdt32_t *cuint;
+
+	if ((name == NULL) || (otp == NULL)) {
+		return -FDT_ERR_BADVALUE;
+	}
+
+	node = fdt_node_offset_by_compatible(fdt, -1, DT_BSEC_COMPAT);
+	if (node < 0) {
+		return node;
+	}
+
+	node = fdt_subnode_offset(fdt, node, name);
+	if (node < 0) {
+		ERROR("nvmem node %s not found\n", name);
+		return node;
+	}
+
+	cuint = fdt_getprop(fdt, node, "reg", &len);
+	if ((cuint == NULL) || (len != (2 * (int)sizeof(uint32_t)))) {
+		ERROR("Malformed nvmem node %s: ignored\n", name);
+		return -FDT_ERR_BADVALUE;
+	}
+
+	if (fdt32_to_cpu(*cuint) % sizeof(uint32_t)) {
+		ERROR("Misaligned nvmem %s element: ignored\n", name);
+		return -FDT_ERR_BADVALUE;
+	}
+
+	if (otp != NULL) {
+		*otp = fdt32_to_cpu(*cuint) / sizeof(uint32_t);
+	}
+
+	if (otp_len != NULL) {
+		cuint++;
+		*otp_len = fdt32_to_cpu(*cuint) * CHAR_BIT;
+	}
+
+	return 0;
+}
+
 /*******************************************************************************
  * This function gets the pin count for a GPIO bank based from the FDT.
  * It also checks node consistency.
@@ -318,6 +593,9 @@ int fdt_get_gpio_bank_pin_count(unsigned int bank)
 {
 	int pinctrl_node;
 	int node;
+	int len;
+	int i;
+	int pin_count;
 	uint32_t bank_offset;
 
 	pinctrl_node = stm32_get_gpio_bank_pinctrl_node(fdt, bank);
@@ -347,12 +625,22 @@ int fdt_get_gpio_bank_pin_count(unsigned int bank)
 			return 0;
 		}
 
-		cuint = fdt_getprop(fdt, node, "ngpios", NULL);
-		if (cuint == NULL) {
-			return -FDT_ERR_NOTFOUND;
+		/* Parse gpio-ranges with its 4 parameters */
+		cuint = fdt_getprop(fdt, node, "gpio-ranges", &len);
+		len /= sizeof(*cuint);
+		if ((len % 4) != 0) {
+			return -FDT_ERR_BADVALUE;
+		}
+
+		/* Get the last defined gpio line (offset + nb of pins) */
+		pin_count = fdt32_to_cpu(*(cuint + 1)) + fdt32_to_cpu(*(cuint + 3));
+		for (i = 0; i < len / 4; i++) {
+			pin_count = MAX(pin_count, (int)(fdt32_to_cpu(*(cuint + 1)) +
+							 fdt32_to_cpu(*(cuint + 3))));
+			cuint += 4;
 		}
 
-		return (int)fdt32_to_cpu(*cuint);
+		return pin_count;
 	}
 
 	return 0;
diff --git a/plat/st/common/stm32mp_fconf_fuse.c b/plat/st/common/stm32mp_fconf_fuse.c
new file mode 100644
index 000000000..75ea161da
--- /dev/null
+++ b/plat/st/common/stm32mp_fconf_fuse.c
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+
+#include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <lib/fconf/fconf.h>
+#include <libfdt.h>
+
+#include <platform_def.h>
+#include <stm32mp_fconf_getter.h>
+
+int fconf_populate_stm32mp_fuse_provisioning(uintptr_t config)
+{
+	int node, child;
+
+	/* As libfdt uses void *, we can't avoid this cast */
+	const void *fdt = (void *)config;
+
+	/* Assert the node offset point to "st,provisioning" compatible property */
+	const char *compatible_str = "st,provisioning";
+
+	node = fdt_node_offset_by_compatible(fdt, -1, compatible_str);
+	if (node < 0) {
+		/* The node is not mandatory, just return */
+		return 0;
+	}
+
+	fdt_for_each_subnode(child, fdt, node) {
+		int rc;
+		const int *cuint;
+		int shadow_len;
+		uint32_t phandle;
+		uint32_t otp_id;
+		uint32_t otp_len;
+		uint32_t otp_len_word;
+		unsigned int i;
+
+		cuint = fdt_getprop(fdt, child, "nvmem-cells", NULL);
+		if (cuint == NULL) {
+			panic();
+		}
+
+		phandle = fdt32_to_cpu(*cuint);
+		rc = bsec_get_otp_by_phandle(fdt, phandle, &otp_id, &otp_len);
+		if (rc != 0) {
+			WARN("Phandle not found\n");
+			panic();
+		}
+
+		cuint = fdt_getprop(fdt, child, "st,shadow-value", &shadow_len);
+		if (cuint == NULL || shadow_len < 0 || (shadow_len % sizeof(uint32_t) != 0U)) {
+			panic();
+		}
+
+		otp_len_word = otp_len / sizeof(uint32_t);
+		if (otp_len % sizeof(uint32_t) != 0U) {
+			otp_len_word++;
+		}
+
+		if (otp_len_word != (shadow_len / sizeof(uint32_t))) {
+			WARN("Invalid OTP size\n");
+			panic();
+		}
+
+		for (i = 0U; i < otp_len_word; i++) {
+			uint32_t shadow_val;
+			uint32_t otp_val;
+			bool check_state;
+
+			if (bsec_read_sw_lock(otp_id + i, &check_state) != BSEC_OK) {
+				panic();
+			}
+
+			if (check_state) {
+				WARN("Shadow write lock\n");
+				panic();
+			}
+
+			shadow_val = fdt32_to_cpu(*cuint++);
+
+			if (bsec_shadow_read_otp(&otp_val, otp_id + i) != BSEC_OK) {
+				panic();
+			}
+
+			if (otp_val != 0U) {
+				INFO("Override the OTP %u initial value\n", otp_id);
+			}
+
+			if (bsec_write_otp(otp_val | shadow_val, otp_id + i) != BSEC_OK) {
+				panic();
+			}
+		}
+	}
+
+	return 0;
+}
+
+FCONF_REGISTER_POPULATOR(TB_FW, stm32mp_fuse, fconf_populate_stm32mp_fuse_provisioning);
diff --git a/plat/st/common/stm32mp_fconf_io.c b/plat/st/common/stm32mp_fconf_io.c
index aa8cd5441..907effd70 100644
--- a/plat/st/common/stm32mp_fconf_io.c
+++ b/plat/st/common/stm32mp_fconf_io.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2021-2022, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -16,6 +16,7 @@
 #include <tools_share/firmware_image_package.h>
 
 #include <platform_def.h>
+#include <stm32mp_efi.h>
 #include <stm32mp_fconf_getter.h>
 #include <stm32mp_io_storage.h>
 
@@ -26,23 +27,77 @@ static io_block_spec_t gpt_block_spec = {
 };
 #endif
 
+#if PSA_FWU_SUPPORT
+io_block_spec_t metadata_block_spec = {
+	.offset = 0,    /* To be filled at runtime */
+	.length = 0,    /* To be filled at runtime */
+};
+#endif
+
 /* By default, STM32 platforms load images from the FIP */
 struct plat_io_policy policies[MAX_NUMBER_IDS] = {
 	[FIP_IMAGE_ID] = {
-		&storage_dev_handle,
-		(uintptr_t)&image_block_spec,
-		open_storage
+		.dev_handle = &storage_dev_handle,
+		.image_spec = (uintptr_t)&image_block_spec,
+		.img_type_guid = STM32MP_FIP_GUID,
+		.check = open_storage
 	},
+#ifndef DECRYPTION_SUPPORT_none
+	[ENC_IMAGE_ID] = {
+		.dev_handle = &fip_dev_handle,
+		.image_spec = (uintptr_t)NULL,
+		.img_type_guid = NULL_GUID,
+		.check = open_fip
+	},
+#endif
 #if STM32MP_SDMMC || STM32MP_EMMC
 	[GPT_IMAGE_ID] = {
-		&storage_dev_handle,
-		(uintptr_t)&gpt_block_spec,
-		open_storage
+		.dev_handle = &storage_dev_handle,
+		.image_spec = (uintptr_t)&gpt_block_spec,
+		.img_type_guid = NULL_GUID,
+		.check = open_storage
 	},
 #endif
+#if PSA_FWU_SUPPORT
+	[FWU_METADATA_IMAGE_ID] = {
+		.dev_handle = &storage_dev_handle,
+		.image_spec = (uintptr_t)&metadata_block_spec,
+		.img_type_guid = NULL_GUID,
+		.check = open_storage
+	},
+	[BKUP_FWU_METADATA_IMAGE_ID] = {
+		.dev_handle = &storage_dev_handle,
+		.image_spec = (uintptr_t)&metadata_block_spec,
+		.img_type_guid = NULL_GUID,
+		.check = open_storage
+	},
+#endif /* PSA_FWU_SUPPORT */
 };
 
-#define FCONF_ST_IO_UUID_NUMBER	U(8)
+#define DEFAULT_UUID_NUMBER	U(7)
+
+#ifdef __aarch64__
+#define BL31_UUID_NUMBER	U(1)
+#else
+#define BL31_UUID_NUMBER	U(0)
+#endif
+
+#if TRUSTED_BOARD_BOOT
+#define TBBR_UUID_NUMBER	U(6)
+#else
+#define TBBR_UUID_NUMBER	U(0)
+#endif
+
+#if STM32MP_DDR_FIP_IO_STORAGE
+#define DDR_FW_UUID_NUMBER	U(1)
+#else
+#define DDR_FW_UUID_NUMBER	U(0)
+#endif
+
+#define FCONF_ST_IO_UUID_NUMBER	(DEFAULT_UUID_NUMBER + \
+				 BL31_UUID_NUMBER + \
+				 TBBR_UUID_NUMBER + \
+				 DDR_FW_UUID_NUMBER)
 
 static io_uuid_spec_t fconf_stm32mp_uuids[FCONF_ST_IO_UUID_NUMBER];
 static OBJECT_POOL_ARRAY(fconf_stm32mp_uuids_pool, fconf_stm32mp_uuids);
@@ -54,14 +109,27 @@ struct policies_load_info {
 
 /* image id to property name table */
 static const struct policies_load_info load_info[FCONF_ST_IO_UUID_NUMBER] = {
+#if STM32MP_DDR_FIP_IO_STORAGE
+	{DDR_FW_ID, "ddr_fw_uuid"},
+#endif
 	{FW_CONFIG_ID, "fw_cfg_uuid"},
+#ifdef __aarch64__
+	{BL31_IMAGE_ID, "bl31_uuid"},
+#endif
 	{BL32_IMAGE_ID, "bl32_uuid"},
 	{BL32_EXTRA1_IMAGE_ID, "bl32_extra1_uuid"},
 	{BL32_EXTRA2_IMAGE_ID, "bl32_extra2_uuid"},
 	{BL33_IMAGE_ID, "bl33_uuid"},
 	{HW_CONFIG_ID, "hw_cfg_uuid"},
 	{TOS_FW_CONFIG_ID, "tos_fw_cfg_uuid"},
-	{NT_FW_CONFIG_ID, "nt_fw_cfg_uuid"},
+#if TRUSTED_BOARD_BOOT
+	{STM32MP_CONFIG_CERT_ID, "stm32mp_cfg_cert_uuid"},
+	{TRUSTED_KEY_CERT_ID, "t_key_cert_uuid"},
+	{TRUSTED_OS_FW_KEY_CERT_ID, "tos_fw_key_cert_uuid"},
+	{NON_TRUSTED_FW_KEY_CERT_ID, "nt_fw_key_cert_uuid"},
+	{TRUSTED_OS_FW_CONTENT_CERT_ID, "tos_fw_content_cert_uuid"},
+	{NON_TRUSTED_FW_CONTENT_CERT_ID, "nt_fw_content_cert_uuid"},
+#endif /* TRUSTED_BOARD_BOOT */
 };
 
 int fconf_populate_stm32mp_io_policies(uintptr_t config)
@@ -111,8 +179,20 @@ int fconf_populate_stm32mp_io_policies(uintptr_t config)
 
 		uuid_ptr->uuid = uuid_helper.uuid_struct;
 		policies[load_info[i].image_id].image_spec = (uintptr_t)uuid_ptr;
-		policies[load_info[i].image_id].dev_handle = &fip_dev_handle;
-		policies[load_info[i].image_id].check = open_fip;
+		switch (load_info[i].image_id) {
+#if ENCRYPT_BL32 && !defined(DECRYPTION_SUPPORT_none)
+		case BL32_IMAGE_ID:
+		case BL32_EXTRA1_IMAGE_ID:
+		case BL32_EXTRA2_IMAGE_ID:
+			policies[load_info[i].image_id].dev_handle = &enc_dev_handle;
+			policies[load_info[i].image_id].check = open_enc_fip;
+			break;
+#endif
+		default:
+			policies[load_info[i].image_id].dev_handle = &fip_dev_handle;
+			policies[load_info[i].image_id].check = open_fip;
+			break;
+		}
 	}
 
 	return 0;
diff --git a/plat/st/common/stm32mp_gic.c b/plat/st/common/stm32mp_gic.c
new file mode 100644
index 000000000..e496483e4
--- /dev/null
+++ b/plat/st/common/stm32mp_gic.c
@@ -0,0 +1,219 @@
+/*
+ * Copyright (c) 2016-2022, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+
+#include <libfdt.h>
+
+#include <platform_def.h>
+
+#include <common/bl_common.h>
+#include <common/debug.h>
+#include <drivers/arm/gicv2.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <lib/utils.h>
+#include <plat/common/platform.h>
+
+struct stm32mp_gic_instance {
+	uint32_t cells;
+	uint32_t phandle_node;
+};
+
+/******************************************************************************
+ * On a GICv2 system, the Group 1 secure interrupts are treated as Group 0
+ * interrupts.
+ *****************************************************************************/
+static const interrupt_prop_t stm32mp_interrupt_props[] = {
+	PLATFORM_G1S_PROPS(GICV2_INTR_GROUP0),
+	PLATFORM_G0_PROPS(GICV2_INTR_GROUP0)
+};
+
+/* Fix target_mask_array as secondary core is not able to initialize it */
+static unsigned int target_mask_array[PLATFORM_CORE_COUNT] = {1, 2};
+
+static gicv2_driver_data_t platform_gic_data = {
+	.interrupt_props = stm32mp_interrupt_props,
+	.interrupt_props_num = ARRAY_SIZE(stm32mp_interrupt_props),
+	.target_masks = target_mask_array,
+	.target_masks_num = ARRAY_SIZE(target_mask_array),
+};
+
+static struct stm32mp_gic_instance stm32mp_gic;
+
+static uint32_t enable_gic_interrupt(const fdt32_t *array)
+{
+	unsigned int id, cfg;
+
+	switch (fdt32_to_cpu(*array)) {
+	case GIC_SPI:
+		id = MIN_SPI_ID;
+		break;
+
+	case GIC_PPI:
+		id = MIN_PPI_ID;
+		break;
+
+	default:
+		id = MIN_SGI_ID;
+		break;
+	}
+
+	id += fdt32_to_cpu(*(array + 1));
+	cfg = (fdt32_to_cpu(*(array + 2)) < IRQ_TYPE_LEVEL_HIGH) ?
+		GIC_INTR_CFG_EDGE : GIC_INTR_CFG_LEVEL;
+
+	if ((id >= MIN_SPI_ID) && (id <= MAX_SPI_ID)) {
+		VERBOSE("Enable IT %i\n", id);
+		gicv2_set_interrupt_type(id, GICV2_INTR_GROUP0);
+		gicv2_set_interrupt_priority(id, STM32MP_IRQ_SEC_SPI_PRIO);
+		gicv2_set_spi_routing(id, STM32MP_PRIMARY_CPU);
+		gicv2_interrupt_set_cfg(id, cfg);
+		gicv2_enable_interrupt(id);
+	}
+
+	return id;
+}
+
+static void find_next_interrupt(const fdt32_t **array)
+{
+	int node;
+	const fdt32_t *cuint;
+	void *fdt;
+
+	assert(fdt32_to_cpu(**array) != stm32mp_gic.phandle_node);
+
+	if (fdt_get_address(&fdt) == 0) {
+		panic();
+	}
+
+	node = fdt_node_offset_by_phandle(fdt, fdt32_to_cpu(**array));
+	if (node < 0) {
+		panic();
+	}
+
+	cuint = fdt_getprop(fdt, node, "#interrupt-cells", NULL);
+	if (cuint == NULL) {
+		panic();
+	}
+
+	*array += fdt32_to_cpu(*cuint) + 1;
+}
+
+void stm32mp_gic_init(void)
+{
+	int node;
+	void *fdt;
+	const fdt32_t *cuint;
+	struct dt_node_info dt_gic;
+
+	if (fdt_get_address(&fdt) == 0) {
+		panic();
+	}
+
+	node = dt_get_node(&dt_gic, -1, "arm,cortex-a7-gic");
+	if (node < 0) {
+		panic();
+	}
+
+	platform_gic_data.gicd_base = dt_gic.base;
+
+	cuint = fdt_getprop(fdt, node, "reg", NULL);
+	if (cuint == NULL) {
+		panic();
+	}
+
+	platform_gic_data.gicc_base = fdt32_to_cpu(*(cuint + 2));
+
+	cuint = fdt_getprop(fdt, node, "#interrupt-cells", NULL);
+	if (cuint == NULL) {
+		panic();
+	}
+
+	stm32mp_gic.cells = fdt32_to_cpu(*cuint);
+
+	stm32mp_gic.phandle_node = fdt_get_phandle(fdt, node);
+	if (stm32mp_gic.phandle_node == 0U) {
+		panic();
+	}
+
+	gicv2_driver_init(&platform_gic_data);
+	gicv2_distif_init();
+
+	stm32mp_gic_pcpu_init();
+}
+
+void stm32mp_gic_pcpu_init(void)
+{
+	gicv2_pcpu_distif_init();
+	gicv2_set_pe_target_mask(plat_my_core_pos());
+	gicv2_cpuif_enable();
+}
+
+int stm32mp_gic_enable_spi(int node, const char *name)
+{
+	const fdt32_t *cuint;
+	void *fdt;
+	int res, len;
+	int index = -1;
+	int i = 0;
+	int id = -1;
+	bool extended;
+	const fdt32_t *t_array, *max;
+
+	if (fdt_get_address(&fdt) == 0) {
+		panic();
+	}
+
+	cuint = fdt_getprop(fdt, node, "interrupt-parent", NULL);
+	if (cuint != NULL) {
+		if (stm32mp_gic.phandle_node != fdt32_to_cpu(*cuint)) {
+			return -FDT_ERR_NOTFOUND;
+		}
+	}
+
+	if (name != NULL) {
+		index = fdt_stringlist_search(fdt, node,
+					      "secure-interrupt-names",
+					      name);
+		if (index < 0) {
+			index = fdt_stringlist_search(fdt, node,
+						      "interrupt-names", name);
+		}
+
+		if (index < 0) {
+			return index;
+		}
+	}
+
+	res = fdt_get_interrupt(node, &t_array, &len, &extended);
+	if (res < 0) {
+		return res;
+	}
+
+	max = t_array + (len / sizeof(uint32_t));
+
+	while ((t_array < max) && ((i <= index) || (index == -1))) {
+		if (!extended) {
+			if ((index == -1) || (i == index)) {
+				id = enable_gic_interrupt(t_array);
+			}
+			t_array += stm32mp_gic.cells;
+		} else {
+			if (fdt32_to_cpu(*t_array) == stm32mp_gic.phandle_node) {
+				t_array++;
+				if ((index == -1) || (i == index)) {
+					id = enable_gic_interrupt(t_array);
+				}
+				t_array += stm32mp_gic.cells;
+			} else {
+				find_next_interrupt(&t_array);
+			}
+		}
+		i++;
+	}
+
+	return id;
+}
diff --git a/plat/st/common/stm32mp_shres_helpers.c b/plat/st/common/stm32mp_shres_helpers.c
new file mode 100644
index 000000000..12633e47d
--- /dev/null
+++ b/plat/st/common/stm32mp_shres_helpers.c
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2018-2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <platform_def.h>
+
+#include <arch_helpers.h>
+#include <lib/mmio.h>
+#include <lib/spinlock.h>
+
+#include <stm32mp_shres_helpers.h>
+
+static struct spinlock shregs_lock;
+
+void stm32mp_lock_shregs(void)
+{
+	if (stm32mp_lock_available() == 0U) {
+		return;
+	}
+
+	/* Assume interrupts are masked */
+	spin_lock(&shregs_lock);
+}
+
+void stm32mp_unlock_shregs(void)
+{
+	if (stm32mp_lock_available() == 0U) {
+		return;
+	}
+
+	spin_unlock(&shregs_lock);
+}
+
+/* Shared register access: upon shared resource lock */
+void stm32mp_mmio_clrsetbits_32_shregs(uintptr_t addr, uint32_t clear,
+				       uint32_t set)
+{
+	stm32mp_lock_shregs();
+
+	mmio_clrsetbits_32(addr, clear, set);
+
+	stm32mp_unlock_shregs();
+}
+
+void stm32mp_mmio_clrbits_32_shregs(uintptr_t addr, uint32_t clear)
+{
+	stm32mp_lock_shregs();
+
+	mmio_clrbits_32(addr, clear);
+
+	stm32mp_unlock_shregs();
+}
+
+void stm32mp_mmio_setbits_32_shregs(uintptr_t addr, uint32_t set)
+{
+	stm32mp_lock_shregs();
+
+	mmio_setbits_32(addr, set);
+
+	stm32mp_unlock_shregs();
+}
diff --git a/plat/st/common/stm32mp_svc_setup.c b/plat/st/common/stm32mp_svc_setup.c
new file mode 100644
index 000000000..bb33dc81c
--- /dev/null
+++ b/plat/st/common/stm32mp_svc_setup.c
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2014-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include <common/debug.h>
+#include <common/runtime_svc.h>
+#include <drivers/scmi-msg.h>
+#include <lib/psci/psci.h>
+#include <platform_def.h>
+#include <tools_share/uuid.h>
+
+#include <stm32mp_svc_setup.h>
+
+/* STM32 SiP Service UUID */
+DEFINE_SVC_UUID2(stm32_sip_svc_uid,
+		 0xa778aa50, 0xf49b, 0x144a, 0x8a, 0x5e,
+		 0x26, 0x4d, 0x59, 0x94, 0xc2, 0x14);
+
+/* Setup STM32MP Standard Services */
+static int32_t stm32mp_svc_setup(void)
+{
+	/*
+	 * PSCI is the only specification implemented as a Standard Service.
+	 * Invoke PSCI setup from here.
+	 */
+	return 0;
+}
+
+/*
+ * Top-level Standard Service SMC handler. This handler will dispatch the SMC
+ * to the correct feature handler or default call a platform handler
+ */
+static uintptr_t stm32mp_svc_smc_handler(uint32_t smc_fid, u_register_t x1,
+					 u_register_t x2, u_register_t x3,
+					 u_register_t x4, void *cookie,
+					 void *handle, u_register_t flags)
+{
+	uint32_t ret1 = 0U, ret2 = 0U;
+	bool ret_uid = false, ret2_enabled = false;
+
+	switch (smc_fid) {
+	case STM32_SIP_SVC_UID:
+		/* Return UUID to the caller */
+		ret_uid = true;
+		break;
+
+	case STM32_SIP_SVC_VERSION:
+		/* Return the version of current implementation */
+		ret1 = STM32_SIP_SVC_VERSION_MAJOR;
+		ret2 = STM32_SIP_SVC_VERSION_MINOR;
+		ret2_enabled = true;
+		break;
+	default:
+		plat_svc_smc_handler(smc_fid, x1, x2, x3, x4, &ret1, &ret2, &ret2_enabled, flags);
+		break;
+	}
+
+	if (ret_uid) {
+		SMC_UUID_RET(handle, stm32_sip_svc_uid);
+	}
+
+	if (ret2_enabled) {
+		SMC_RET2(handle, ret1, ret2);
+	}
+
+	SMC_RET1(handle, ret1);
+}
+
+/* Register Standard Service Calls as runtime service */
+DECLARE_RT_SVC(stm32mp_sip_svc,
+	       OEN_SIP_START,
+	       OEN_SIP_END,
+	       SMC_TYPE_FAST,
+	       stm32mp_svc_setup,
+	       stm32mp_svc_smc_handler
+);
diff --git a/plat/st/common/stm32mp_trusted_boot.c b/plat/st/common/stm32mp_trusted_boot.c
new file mode 100644
index 000000000..fda53c0e3
--- /dev/null
+++ b/plat/st/common/stm32mp_trusted_boot.c
@@ -0,0 +1,206 @@
+/*
+ * Copyright (c) 2020-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <endian.h>
+#include <errno.h>
+#include <limits.h>
+
+#include <common/debug.h>
+#include <common/tbbr/cot_def.h>
+#include <drivers/st/stm32_hash.h>
+#include <lib/fconf/fconf.h>
+#include <lib/fconf/fconf_dyn_cfg_getter.h>
+#include <lib/fconf/fconf_tbbr_getter.h>
+#include <lib/mmio.h>
+#include <lib/xlat_tables/xlat_tables_v2.h>
+#include <plat/common/platform.h>
+
+#include <boot_api.h>
+#include <platform_def.h>
+
+#define HEADER_AND_EXT_TOTAL_SIZE 512
+
+static uint8_t der_sha256_header[] = {0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60,
+	0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20};
+static uint8_t root_pk_hash[HASH_DER_LEN];
+
+static int copy_hash_from_otp(const char *otp_name, uint8_t *hash, size_t len)
+{
+	uint32_t otp_idx;
+	uint32_t otp_len;
+	size_t i;
+	bool valid = false;
+
+	assert(len % sizeof(uint32_t) == 0);
+
+	if (stm32_get_otp_index(otp_name, &otp_idx, &otp_len) != 0) {
+		VERBOSE("%s: get %s index error\n", __func__, otp_name);
+		return -EINVAL;
+	}
+	if (otp_len != (len * CHAR_BIT)) {
+		VERBOSE("%s: length Error\n", __func__);
+		return -EINVAL;
+	}
+
+	for (i = 0U; i < len / sizeof(uint32_t); i++) {
+		uint32_t tmp;
+		uint32_t otp_val;
+		uint32_t first;
+
+		if (stm32_get_otp_value_from_idx(otp_idx + i, &otp_val) != 0) {
+			VERBOSE("%s: unable to read from otp\n", __func__);
+			return -EINVAL;
+		}
+
+		tmp = bswap32(otp_val);
+		memcpy(hash + i * sizeof(uint32_t), &tmp, sizeof(tmp));
+
+		if (i == 0U) {
+			first = tmp;
+		}
+
+		/*
+		 * Check if key hash values in OTP are 0 or 0xFFFFFFFFF
+		 * programmed : Invalid Key
+		 */
+		if (!stm32mp_is_closed_device() && !valid) {
+			if ((tmp != 0U) && (tmp != 0xFFFFFFFFU) && (tmp != first)) {
+				valid = true;
+			}
+		}
+	}
+
+	if (!stm32mp_is_closed_device() && !valid) {
+		return 0;
+	}
+
+	return len;
+}
+
+#if STM32MP13
+static int get_rotpk_hash(void *cookie, uint8_t *hash, size_t len)
+{
+	int ret;
+	uint32_t pk_idx = 0U;
+	uint8_t calc_hash[BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES];
+	uint8_t otp_hash[BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES];
+	boot_api_image_header_t *hdr = (boot_api_image_header_t *)(SRAM3_BASE + SRAM3_SIZE -
+								   HEADER_AND_EXT_TOTAL_SIZE);
+	boot_extension_header_t *ext_header = (boot_extension_header_t *)hdr->ext_header;
+	boot_ext_header_params_authentication_t *param;
+
+	if (cookie != NULL) {
+		return -EINVAL;
+	}
+
+	if (hdr->header_version != BOOT_API_HEADER_VERSION) {
+		VERBOSE("%s: unexpected header_version\n", __func__);
+		return -EINVAL;
+	}
+
+	param = (boot_ext_header_params_authentication_t *)ext_header->params;
+
+	pk_idx = param->pk_idx;
+
+	stm32_hash_init(HASH_SHA256);
+	ret = stm32_hash_final_update((uint8_t *)param->pk_hashes,
+				      param->nb_pk * sizeof(boot_api_sha256_t), calc_hash);
+	if (ret != 0) {
+		VERBOSE("%s: hash failed\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = copy_hash_from_otp(PKH_OTP, otp_hash, len);
+	if (ret < 0) {
+		return -EINVAL;
+	}
+
+	if (ret != 0) {
+		ret = memcmp(calc_hash, otp_hash, sizeof(calc_hash));
+		if (ret != 0) {
+			VERBOSE("%s: not expected digest\n", __func__);
+			return -EINVAL;
+		}
+
+		ret = sizeof(otp_hash);
+	}
+
+	memcpy(hash, param->pk_hashes[pk_idx], sizeof(otp_hash));
+
+	return ret;
+}
+#endif
+
+#if STM32MP15
+static int get_rotpk_hash(void *cookie, uint8_t *hash, size_t len)
+{
+	if (cookie != NULL) {
+		return -EINVAL;
+	}
+
+	return copy_hash_from_otp(PKH_OTP, hash, len);
+}
+#endif
+
+int plat_get_rotpk_info(void *cookie, void **key_ptr, unsigned int *key_len,
+			unsigned int *flags)
+{
+	size_t start_copy_idx = 0U;
+	int res;
+
+	memcpy(root_pk_hash, der_sha256_header, sizeof(der_sha256_header));
+	start_copy_idx = sizeof(der_sha256_header);
+
+	res = get_rotpk_hash(cookie, root_pk_hash + start_copy_idx,
+			     BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES);
+	if (res < 0) {
+		return -EINVAL;
+	}
+
+	*key_len = HASH_DER_LEN;
+	*key_ptr = &root_pk_hash;
+	*flags = ROTPK_IS_HASH;
+
+	if ((res == 0) && !stm32mp_is_closed_device()) {
+		*flags |= ROTPK_NOT_DEPLOYED;
+	}
+
+	return 0;
+}
+
+int plat_get_nv_ctr(void *cookie, unsigned int *nv_ctr)
+{
+	*nv_ctr = mmio_read_32(TAMP_BASE + TAMP_COUNTR);
+
+	return 0;
+}
+
+int plat_set_nv_ctr(void *cookie, unsigned int nv_ctr)
+{
+	while (mmio_read_32(TAMP_BASE + TAMP_COUNTR) != nv_ctr) {
+		mmio_write_32(TAMP_BASE + TAMP_COUNTR, 1U);
+	}
+
+	return 0;
+}
+
+int plat_get_mbedtls_heap(void **heap_addr, size_t *heap_size)
+{
+	assert(heap_addr != NULL);
+	assert(heap_size != NULL);
+
+#if STM32MP_USE_EXTERNAL_HEAP
+	/* Retrieve the already allocated heap's info from DTB */
+	*heap_addr = FCONF_GET_PROPERTY(tbbr, dyn_config, mbedtls_heap_addr);
+	*heap_size = FCONF_GET_PROPERTY(tbbr, dyn_config, mbedtls_heap_size);
+
+	/* We expect heap already statically mapped */
+
+	return 0;
+#else
+	return get_mbedtls_heap_helper(heap_addr, heap_size);
+#endif
+}
diff --git a/plat/st/stm32mp1/bl2_plat_setup.c b/plat/st/stm32mp1/bl2_plat_setup.c
index 7eaf0ed98..61e9eff32 100644
--- a/plat/st/stm32mp1/bl2_plat_setup.c
+++ b/plat/st/stm32mp1/bl2_plat_setup.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2021, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -14,14 +14,19 @@
 #include <common/bl_common.h>
 #include <common/debug.h>
 #include <common/desc_image_load.h>
-#include <drivers/delay_timer.h>
+#include <drivers/clk.h>
 #include <drivers/generic_delay_timer.h>
 #include <drivers/mmc.h>
 #include <drivers/st/bsec.h>
-#include <drivers/st/stm32_console.h>
+#include <drivers/st/regulator_fixed.h>
+#include <drivers/st/regulator_gpio.h>
 #include <drivers/st/stm32_iwdg.h>
+#if STM32MP13
+#include <drivers/st/stm32_mce.h>
+#include <drivers/st/stm32_rng.h>
+#endif
+#include <drivers/st/stm32_uart.h>
 #include <drivers/st/stm32mp_pmic.h>
-#include <drivers/st/stm32mp_reset.h>
 #include <drivers/st/stm32mp1_clk.h>
 #include <drivers/st/stm32mp1_pwr.h>
 #include <drivers/st/stm32mp1_ram.h>
@@ -34,11 +39,24 @@
 
 #include <stm32mp1_context.h>
 #include <stm32mp1_dbgmcu.h>
-
-#define RESET_TIMEOUT_US_1MS		1000U
-
-static console_t console;
-static struct stm32mp_auth_ops stm32mp1_auth_ops;
+#include <stm32mp_common.h>
+
+#define PLL1_NOMINAL_FREQ_IN_KHZ	650000U /* 650MHz */
+
+static const char debug_msg[626] = {
+	"***************************************************\n"
+	"** NOTICE   NOTICE   NOTICE   NOTICE   NOTICE    **\n"
+	"**                                               **\n"
+	"** DEBUG ACCESS PORT IS OPEN!                    **\n"
+	"** This boot image is only for debugging purpose **\n"
+	"** and is unsafe for production use.             **\n"
+	"**                                               **\n"
+	"** If you see this message and you are not       **\n"
+	"** debugging report this immediately to your     **\n"
+	"** vendor!                                       **\n"
+	"**                                               **\n"
+	"***************************************************\n"
+};
 
 static void print_reset_reason(void)
 {
@@ -73,6 +91,7 @@ static void print_reset_reason(void)
 		return;
 	}
 
+#if STM32MP15
 	if ((rstsr & RCC_MP_RSTSCLRR_MCSYSRSTF) != 0U) {
 		if ((rstsr & RCC_MP_RSTSCLRR_PADRSTF) != 0U) {
 			INFO("  System reset generated by MCU (MCSYSRST)\n");
@@ -81,6 +100,7 @@ static void print_reset_reason(void)
 		}
 		return;
 	}
+#endif
 
 	if ((rstsr & RCC_MP_RSTSCLRR_MPSYSRSTF) != 0U) {
 		INFO("  System reset generated by MPU (MPSYSRST)\n");
@@ -107,10 +127,12 @@ static void print_reset_reason(void)
 		return;
 	}
 
+#if STM32MP15
 	if ((rstsr & RCC_MP_RSTSCLRR_MPUP1RSTF) != 0U) {
 		INFO("  MPU Processor 1 Reset\n");
 		return;
 	}
+#endif
 
 	if ((rstsr & RCC_MP_RSTSCLRR_PADRSTF) != 0U) {
 		INFO("  Pad Reset from NRST\n");
@@ -130,6 +152,8 @@ void bl2_el3_early_platform_setup(u_register_t arg0,
 				  u_register_t arg2 __unused,
 				  u_register_t arg3 __unused)
 {
+	stm32mp_setup_early_console();
+
 	stm32mp_save_boot_ctx_address(arg0);
 }
 
@@ -137,16 +161,29 @@ void bl2_platform_setup(void)
 {
 	int ret;
 
-	if (dt_pmic_status() > 0) {
-		initialize_pmic();
-	}
-
 	ret = stm32mp1_ddr_probe();
 	if (ret < 0) {
 		ERROR("Invalid DDR init: error %d\n", ret);
 		panic();
 	}
 
+	if (!stm32mp1_ddr_is_restored()) {
+#if STM32MP15
+		uintptr_t bkpr_core1_magic =
+			tamp_bkpr(BOOT_API_CORE1_MAGIC_NUMBER_TAMP_BCK_REG_IDX);
+		uintptr_t bkpr_core1_addr =
+			tamp_bkpr(BOOT_API_CORE1_BRANCH_ADDRESS_TAMP_BCK_REG_IDX);
+
+		/* Clear backup register */
+		mmio_write_32(bkpr_core1_addr, 0);
+		/* Clear backup register magic */
+		mmio_write_32(bkpr_core1_magic, 0);
+#endif
+
+		/* Clear the context in BKPSRAM */
+		stm32_clean_context();
+	}
+
 	/* Map DDR for binary load, now with cacheable attribute */
 	ret = mmap_add_dynamic_region(STM32MP_DDR_BASE, STM32MP_DDR_BASE,
 				      STM32MP_DDR_MAX_SIZE, MT_MEMORY | MT_RW | MT_SECURE);
@@ -154,44 +191,64 @@ void bl2_platform_setup(void)
 		ERROR("DDR mapping: error %d\n", ret);
 		panic();
 	}
+}
 
-#if STM32MP_USE_STM32IMAGE
-#ifdef AARCH32_SP_OPTEE
-	INFO("BL2 runs OP-TEE setup\n");
-#else
-	INFO("BL2 runs SP_MIN setup\n");
-#endif
-#endif /* STM32MP_USE_STM32IMAGE */
+#if STM32MP15
+static void update_monotonic_counter(void)
+{
+	uint32_t version;
+	uint32_t otp;
+
+	CASSERT(STM32_TF_VERSION <= MAX_MONOTONIC_VALUE,
+		assert_stm32mp1_monotonic_counter_reach_max);
+
+	/* Check if monotonic counter needs to be incremented */
+	if (stm32_get_otp_index(MONOTONIC_OTP, &otp, NULL) != 0) {
+		panic();
+	}
+
+	if (stm32_get_otp_value(MONOTONIC_OTP, &version) != 0) {
+		panic();
+	}
+
+	if ((version + 1U) < BIT(STM32_TF_VERSION)) {
+		uint32_t result;
+
+		/* Need to increment the monotonic counter. */
+		version = BIT(STM32_TF_VERSION) - 1U;
+
+		result = bsec_program_otp(version, otp);
+		if (result != BSEC_OK) {
+			ERROR("BSEC: MONOTONIC_OTP program Error %i\n",
+			      result);
+			panic();
+		}
+		INFO("Monotonic counter has been incremented (value 0x%x)\n",
+		     version);
+	}
 }
+#endif
 
 void bl2_el3_plat_arch_setup(void)
 {
-	int32_t result;
-	struct dt_node_info dt_uart_info;
 	const char *board_model;
 	boot_api_context_t *boot_context =
 		(boot_api_context_t *)stm32mp_get_boot_ctx_address();
-	uint32_t clk_rate;
 	uintptr_t pwr_base;
 	uintptr_t rcc_base;
+	bool serial_uart_interface __unused =
+				(boot_context->boot_interface_selected ==
+				 BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART);
+	uintptr_t uart_prog_addr __unused;
+
+	if (bsec_probe() != 0) {
+		panic();
+	}
 
 	mmap_add_region(BL_CODE_BASE, BL_CODE_BASE,
 			BL_CODE_END - BL_CODE_BASE,
 			MT_CODE | MT_SECURE);
 
-#if STM32MP_USE_STM32IMAGE
-#ifdef AARCH32_SP_OPTEE
-	mmap_add_region(STM32MP_OPTEE_BASE, STM32MP_OPTEE_BASE,
-			STM32MP_OPTEE_SIZE,
-			MT_MEMORY | MT_RW | MT_SECURE);
-#else
-	/* Prevent corruption of preloaded BL32 */
-	mmap_add_region(BL32_BASE, BL32_BASE,
-			BL32_LIMIT - BL32_BASE,
-			MT_RO_DATA | MT_SECURE);
-#endif
-#endif /* STM32MP_USE_STM32IMAGE */
-
 	/* Prevent corruption of preloaded Device Tree */
 	mmap_add_region(DTB_BASE, DTB_BASE,
 			DTB_LIMIT - DTB_BASE,
@@ -217,10 +274,6 @@ void bl2_el3_plat_arch_setup(void)
 		;
 	}
 
-	if (bsec_probe() != 0) {
-		panic();
-	}
-
 	/* Reset backup domain on cold boot cases */
 	if ((mmio_read_32(rcc_base + RCC_BDCR) & RCC_BDCR_RTCSRC_MASK) == 0U) {
 		mmio_setbits_32(rcc_base + RCC_BDCR, RCC_BDCR_VSWRST);
@@ -233,59 +286,44 @@ void bl2_el3_plat_arch_setup(void)
 		mmio_clrbits_32(rcc_base + RCC_BDCR, RCC_BDCR_VSWRST);
 	}
 
-	/* Disable MCKPROT */
-	mmio_clrbits_32(rcc_base + RCC_TZCR, RCC_TZCR_MCKPROT);
-
-	generic_delay_timer_init();
-
-	if (stm32mp1_clk_probe() < 0) {
-		panic();
-	}
-
-	if (stm32mp1_clk_init() < 0) {
-		panic();
+	/* Set minimum reset pulse duration to 31ms for discrete power supplied boards */
+	if (dt_pmic_status() <= 0) {
+		mmio_clrsetbits_32(rcc_base + RCC_RDLSICR, RCC_RDLSICR_MRD_MASK,
+				   31U << RCC_RDLSICR_MRD_SHIFT);
 	}
 
-	stm32mp1_syscfg_init();
-
-	result = dt_get_stdout_uart_info(&dt_uart_info);
+	generic_delay_timer_init();
 
-	if ((result <= 0) ||
-	    (dt_uart_info.status == 0U) ||
-	    (dt_uart_info.clock < 0) ||
-	    (dt_uart_info.reset < 0)) {
-		goto skip_console_init;
-	}
+#if STM32MP_UART_PROGRAMMER
+	uart_prog_addr = get_uart_address(boot_context->boot_interface_instance);
 
-	if (dt_set_stdout_pinctrl() != 0) {
-		goto skip_console_init;
+	/* Disable programmer UART before changing clock tree */
+	if (serial_uart_interface) {
+		stm32_uart_stop(uart_prog_addr);
 	}
-
-	stm32mp_clk_enable((unsigned long)dt_uart_info.clock);
-
-	if (stm32mp_reset_assert((uint32_t)dt_uart_info.reset,
-				 RESET_TIMEOUT_US_1MS) != 0) {
+#endif
+	if (stm32mp1_clk_probe() < 0) {
 		panic();
 	}
 
-	udelay(2);
-
-	if (stm32mp_reset_deassert((uint32_t)dt_uart_info.reset,
-				   RESET_TIMEOUT_US_1MS) != 0) {
+	if (stm32mp1_clk_init(PLL1_NOMINAL_FREQ_IN_KHZ) < 0) {
 		panic();
 	}
 
-	mdelay(1);
+	stm32_save_boot_interface(boot_context->boot_interface_selected,
+				  boot_context->boot_interface_instance);
 
-	clk_rate = stm32mp_clk_get_rate((unsigned long)dt_uart_info.clock);
+#if STM32MP_USB_PROGRAMMER && STM32MP15
+	/* Deconfigure all UART RX pins configured by ROM code */
+	stm32mp1_deconfigure_uart_pins();
+#endif
 
-	if (console_stm32_register(dt_uart_info.base, clk_rate,
-				   STM32MP_UART_BAUDRATE, &console) == 0) {
-		panic();
+	if (stm32mp_uart_console_setup() != 0) {
+		goto skip_console_init;
 	}
 
-	console_set_scope(&console, CONSOLE_FLAG_BOOT |
-			  CONSOLE_FLAG_CRASH | CONSOLE_FLAG_TRANSLATE_CRLF);
+	/* Enter in boot mode */
+	stm32mp1_syscfg_boot_mode_enable();
 
 	stm32mp_print_cpuinfo();
 
@@ -303,39 +341,103 @@ void bl2_el3_plat_arch_setup(void)
 	}
 
 skip_console_init:
-	if (stm32_iwdg_init() < 0) {
+#if !TRUSTED_BOARD_BOOT
+	if (stm32mp_is_closed_device()) {
+		/* Closed chip required authentication */
+		ERROR("Secured chip must enabled TRUSTED_BOARD_BOOT\n");
+		panic();
+	}
+#endif
+
+	if (fixed_regulator_register() != 0) {
 		panic();
 	}
 
-	stm32_iwdg_refresh();
+#if (PLAT_NB_GPIO_REGUS > 0)
+	if (gpio_regulator_register() != 0) {
+		panic();
+	}
+#endif
 
-	result = stm32mp1_dbgmcu_freeze_iwdg2();
-	if (result != 0) {
-		INFO("IWDG2 freeze error : %i\n", result);
+	if (dt_pmic_status() > 0) {
+		initialize_pmic();
+		if (!stm32mp1_is_wakeup_from_standby() &&
+		    pmic_voltages_init() != 0) {
+			ERROR("PMIC voltages init failed\n");
+			panic();
+		}
+		print_pmic_info_and_debug();
 	}
 
-	if (stm32_save_boot_interface(boot_context->boot_interface_selected,
-				      boot_context->boot_interface_instance) !=
-	    0) {
-		ERROR("Cannot save boot interface\n");
+	stm32mp1_syscfg_init();
+
+	if (stm32_iwdg_init() < 0) {
+		panic();
 	}
 
-	stm32mp1_auth_ops.check_key = boot_context->bootrom_ecdsa_check_key;
-	stm32mp1_auth_ops.verify_signature =
-		boot_context->bootrom_ecdsa_verify_signature;
+	stm32_iwdg_refresh();
 
-	stm32mp_init_auth(&stm32mp1_auth_ops);
+	if (bsec_read_debug_conf() != 0U) {
+		if (stm32mp_is_closed_device()) {
+			NOTICE("\n%s", debug_msg);
+		}
+	}
+
+#if STM32MP13
+	if (stm32_rng_init() != 0) {
+		panic();
+	}
+#endif
 
 	stm32mp1_arch_security_setup();
 
 	print_reset_reason();
 
-#if !STM32MP_USE_STM32IMAGE
+#if STM32MP15
+	update_monotonic_counter();
+#endif
+
+	stm32mp1_syscfg_enable_io_compensation_finish();
+
 	fconf_populate("TB_FW", STM32MP_DTB_BASE);
-#endif /* !STM32MP_USE_STM32IMAGE */
 
-	stm32mp_io_setup();
+	if (stm32mp_skip_boot_device_after_standby()) {
+		bl_mem_params_node_t *bl_mem_params = get_bl_mem_params_node(FW_CONFIG_ID);
+
+		assert(bl_mem_params != NULL);
+
+		bl_mem_params->image_info.h.attr |= IMAGE_ATTRIB_SKIP_LOADING;
+	} else {
+		stm32mp_io_setup();
+	}
+}
+
+#if STM32MP13
+static void prepare_encryption(void)
+{
+	uint8_t mkey[MCE_KEY_SIZE_IN_BYTES];
+
+	stm32_mce_init();
+
+	if (stm32mp1_is_wakeup_from_standby()) {
+		stm32mp1_pm_get_mce_mkey_from_context(mkey);
+		stm32_mce_reload_configuration();
+	} else {
+		/* Generate MCE master key from RNG */
+		if (stm32_rng_read(mkey, MCE_KEY_SIZE_IN_BYTES) != 0) {
+			panic();
+		}
+
+		stm32mp1_pm_save_mce_mkey_in_context(mkey);
+	}
+
+	if (stm32_mce_write_master_key(mkey) != 0) {
+		panic();
+	}
+
+	stm32_mce_lock_master_key();
 }
+#endif
 
 /*******************************************************************************
  * This function can be used by the platforms to update/use image
@@ -348,30 +450,44 @@ int bl2_plat_handle_post_image_load(unsigned int image_id)
 	bl_mem_params_node_t *bl32_mem_params;
 	bl_mem_params_node_t *pager_mem_params __unused;
 	bl_mem_params_node_t *paged_mem_params __unused;
-#if !STM32MP_USE_STM32IMAGE
 	const struct dyn_cfg_dtb_info_t *config_info;
 	bl_mem_params_node_t *tos_fw_mem_params;
 	unsigned int i;
+	unsigned int idx;
 	unsigned long long ddr_top __unused;
+	bool wakeup_ddr_sr = stm32mp1_ddr_is_restored();
 	const unsigned int image_ids[] = {
 		BL32_IMAGE_ID,
 		BL33_IMAGE_ID,
 		HW_CONFIG_ID,
 		TOS_FW_CONFIG_ID,
 	};
-#endif /* !STM32MP_USE_STM32IMAGE */
 
 	assert(bl_mem_params != NULL);
 
 	switch (image_id) {
-#if !STM32MP_USE_STM32IMAGE
 	case FW_CONFIG_ID:
+#if STM32MP13
+		if (stm32mp_is_closed_device() || stm32mp_is_auth_supported()) {
+			prepare_encryption();
+		}
+#endif
+		if (stm32mp_skip_boot_device_after_standby()) {
+			return 0;
+		}
+
 		/* Set global DTB info for fixed fw_config information */
 		set_config_info(STM32MP_FW_CONFIG_BASE, STM32MP_FW_CONFIG_MAX_SIZE, FW_CONFIG_ID);
 		fconf_populate("FW_CONFIG", STM32MP_FW_CONFIG_BASE);
 
+		idx = dyn_cfg_dtb_info_get_index(TOS_FW_CONFIG_ID);
+
 		/* Iterate through all the fw config IDs */
 		for (i = 0U; i < ARRAY_SIZE(image_ids); i++) {
+			if ((image_ids[i] == TOS_FW_CONFIG_ID) && (idx == FCONF_INVALID_IDX)) {
+				continue;
+			}
+
 			bl_mem_params = get_bl_mem_params_node(image_ids[i]);
 			assert(bl_mem_params != NULL);
 
@@ -383,7 +499,13 @@ int bl2_plat_handle_post_image_load(unsigned int image_id)
 			bl_mem_params->image_info.image_base = config_info->config_addr;
 			bl_mem_params->image_info.image_max_size = config_info->config_max_size;
 
-			bl_mem_params->image_info.h.attr &= ~IMAGE_ATTRIB_SKIP_LOADING;
+			/*
+			 * If going back from CSTANDBY / STANDBY and DDR was in Self-Refresh,
+			 * DDR partitions must not be reloaded.
+			 */
+			if (!(wakeup_ddr_sr && (config_info->config_addr >= STM32MP_DDR_BASE))) {
+				bl_mem_params->image_info.h.attr &= ~IMAGE_ATTRIB_SKIP_LOADING;
+			}
 
 			switch (image_ids[i]) {
 			case BL32_IMAGE_ID:
@@ -397,14 +519,24 @@ int bl2_plat_handle_post_image_load(unsigned int image_id)
 
 				/* Init base and size for pager if exist */
 				paged_mem_params = get_bl_mem_params_node(BL32_EXTRA2_IMAGE_ID);
-				paged_mem_params->image_info.image_base = STM32MP_DDR_BASE +
-					(dt_get_ddr_size() - STM32MP_DDR_S_SIZE -
-					 STM32MP_DDR_SHMEM_SIZE);
-				paged_mem_params->image_info.image_max_size = STM32MP_DDR_S_SIZE;
+				if (paged_mem_params != NULL) {
+					paged_mem_params->image_info.image_base = STM32MP_DDR_BASE +
+						(dt_get_ddr_size() - STM32MP_DDR_S_SIZE);
+					paged_mem_params->image_info.image_max_size =
+						STM32MP_DDR_S_SIZE;
+				}
 				break;
 
 			case BL33_IMAGE_ID:
-				bl_mem_params->ep_info.pc = config_info->config_addr;
+				if (wakeup_ddr_sr) {
+					/*
+					 * Set ep_info PC to 0, to inform BL32 it is a reset
+					 * after STANDBY
+					 */
+					bl_mem_params->ep_info.pc = 0U;
+				} else {
+					bl_mem_params->ep_info.pc = config_info->config_addr;
+				}
 				break;
 
 			case HW_CONFIG_ID:
@@ -416,55 +548,70 @@ int bl2_plat_handle_post_image_load(unsigned int image_id)
 			}
 		}
 		break;
-#endif /* !STM32MP_USE_STM32IMAGE */
 
 	case BL32_IMAGE_ID:
+		if (wakeup_ddr_sr && stm32mp_skip_boot_device_after_standby()) {
+			bl_mem_params->ep_info.pc = stm32_pm_get_optee_ep();
+			if (stm32mp1_addr_inside_backupsram(bl_mem_params->ep_info.pc)) {
+				clk_enable(BKPSRAM);
+			}
+			break;
+		}
+
 		if (optee_header_is_valid(bl_mem_params->image_info.image_base)) {
+			image_info_t *paged_image_info = NULL;
+
 			/* BL32 is OP-TEE header */
 			bl_mem_params->ep_info.pc = bl_mem_params->image_info.image_base;
-			pager_mem_params = get_bl_mem_params_node(BL32_EXTRA1_IMAGE_ID);
-			paged_mem_params = get_bl_mem_params_node(BL32_EXTRA2_IMAGE_ID);
-			assert((pager_mem_params != NULL) && (paged_mem_params != NULL));
 
-#if STM32MP_USE_STM32IMAGE && defined(AARCH32_SP_OPTEE)
-			/* Set OP-TEE extra image load areas at run-time */
-			pager_mem_params->image_info.image_base = STM32MP_OPTEE_BASE;
-			pager_mem_params->image_info.image_max_size = STM32MP_OPTEE_SIZE;
+			pager_mem_params = get_bl_mem_params_node(BL32_EXTRA1_IMAGE_ID);
+			assert(pager_mem_params != NULL);
 
-			paged_mem_params->image_info.image_base = STM32MP_DDR_BASE +
-								  dt_get_ddr_size() -
-								  STM32MP_DDR_S_SIZE -
-								  STM32MP_DDR_SHMEM_SIZE;
-			paged_mem_params->image_info.image_max_size = STM32MP_DDR_S_SIZE;
-#endif /* STM32MP_USE_STM32IMAGE && defined(AARCH32_SP_OPTEE) */
+			paged_mem_params = get_bl_mem_params_node(BL32_EXTRA2_IMAGE_ID);
+			if (paged_mem_params != NULL) {
+				paged_image_info = &paged_mem_params->image_info;
+			}
 
 			err = parse_optee_header(&bl_mem_params->ep_info,
 						 &pager_mem_params->image_info,
-						 &paged_mem_params->image_info);
-			if (err) {
+						 paged_image_info);
+			if (err != 0) {
 				ERROR("OPTEE header parse error.\n");
 				panic();
 			}
 
 			/* Set optee boot info from parsed header data */
-			bl_mem_params->ep_info.args.arg0 = paged_mem_params->image_info.image_base;
-			bl_mem_params->ep_info.args.arg1 = 0; /* Unused */
-			bl_mem_params->ep_info.args.arg2 = 0; /* No DT supported */
+			if (paged_mem_params != NULL) {
+				bl_mem_params->ep_info.args.arg0 =
+					paged_mem_params->image_info.image_base;
+			} else {
+				bl_mem_params->ep_info.args.arg0 = 0U;
+			}
+
+			bl_mem_params->ep_info.args.arg1 = 0U; /* Unused */
+			bl_mem_params->ep_info.args.arg2 = 0U; /* No DT supported */
 		} else {
-#if !STM32MP_USE_STM32IMAGE
 			bl_mem_params->ep_info.pc = bl_mem_params->image_info.image_base;
 			tos_fw_mem_params = get_bl_mem_params_node(TOS_FW_CONFIG_ID);
 			bl_mem_params->image_info.image_max_size +=
 				tos_fw_mem_params->image_info.image_max_size;
-#endif /* !STM32MP_USE_STM32IMAGE */
 			bl_mem_params->ep_info.args.arg0 = 0;
 		}
+
+		if (bl_mem_params->ep_info.pc >= STM32MP_DDR_BASE) {
+			stm32_context_save_bl2_param();
+		}
 		break;
 
 	case BL33_IMAGE_ID:
 		bl32_mem_params = get_bl_mem_params_node(BL32_IMAGE_ID);
 		assert(bl32_mem_params != NULL);
 		bl32_mem_params->ep_info.lr_svc = bl_mem_params->ep_info.pc;
+#if PSA_FWU_SUPPORT
+		if (plat_fwu_is_enabled()) {
+			stm32mp1_fwu_set_boot_idx();
+		}
+#endif /* PSA_FWU_SUPPORT */
 		break;
 
 	default:
@@ -493,16 +640,20 @@ void bl2_el3_plat_prepare_exit(void)
 	uint16_t boot_itf = stm32mp_get_boot_itf_selected();
 
 	switch (boot_itf) {
-#if STM32MP_USB_PROGRAMMER
+#if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART:
 	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB:
 		/* Invalidate the downloaded buffer used with io_memmap */
 		inv_dcache_range(DWL_BUFFER_BASE, DWL_BUFFER_SIZE);
 		break;
-#endif
+#endif /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
 	default:
 		/* Do nothing in default case */
 		break;
 	}
 
 	stm32mp1_security_setup();
+
+	/* end of boot mode */
+	stm32mp1_syscfg_boot_mode_disable();
 }
diff --git a/plat/st/stm32mp1/cert_create_tbbr.mk b/plat/st/stm32mp1/cert_create_tbbr.mk
new file mode 100644
index 000000000..d5a9c8461
--- /dev/null
+++ b/plat/st/stm32mp1/cert_create_tbbr.mk
@@ -0,0 +1,19 @@
+#
+# Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+# Override TBBR Cert to update generic certificate
+
+$(eval $(call add_define,PDEF_CERTS))
+
+PLAT_INCLUDE	+= -I${PLAT_DIR}include \
+
+src/stm32mp1_tbb_cert.o: ${PLAT_DIR}stm32mp1_tbb_cert.c
+	${Q}${HOSTCC} -c ${HOSTCCFLAGS} ${INC_DIR} $< -o $@
+
+PLAT_OBJECTS	= src/stm32mp1_tbb_cert.o
+
+OBJECTS		+= $(PLAT_OBJECTS)
+
diff --git a/plat/st/stm32mp1/default_metadata.json b/plat/st/stm32mp1/default_metadata.json
new file mode 100644
index 000000000..bd40f04d2
--- /dev/null
+++ b/plat/st/stm32mp1/default_metadata.json
@@ -0,0 +1,37 @@
+{
+    "copyright": "Copyright (c) 2022, STMicroelectronics - All Rights Reserved",
+    "license": "SPDX-License-Identifier: BSD-3-Clause",
+
+    "metadata": {
+        "version": 0,
+        "active_index": 0,
+        "previous_active_index": 1,
+        "img_entry": {
+            "img_0": {
+                "location": "device0",
+                "img_bank_info": {
+                    "img_0_bank_0": {
+                        "accepted": true
+                    },
+                    "img_0_bank_1": {
+                        "accepted": false
+                    }
+                }
+            }
+        }
+    },
+    "uuids": {
+        "locations": {
+            "device0": "00000000-0000-0000-0000-000000000000"
+        },
+        "entries": {
+            "img_0_bank_0": "4fd84c93-54ef-463f-a7ef-ae25ff887087",
+            "img_0_bank_1": "09c54952-d5bf-45af-acee-335303766fb3",
+            "img_0":        "19d5df83-11b0-457b-be2c-7559c13142a5"
+        }
+    },
+    "configs": {
+        "nb_fw_img": 1,
+        "nb_fw_banks": 2
+    }
+}
diff --git a/plat/st/stm32mp1/include/boot_api.h b/plat/st/stm32mp1/include/boot_api.h
index 52b1d1aa0..dbea373b7 100644
--- a/plat/st/stm32mp1/include/boot_api.h
+++ b/plat/st/stm32mp1/include/boot_api.h
@@ -10,15 +10,121 @@
 #include <stdint.h>
 #include <stdio.h>
 
+/*
+ * Exported constants
+ */
+
+/*
+ * Boot Context related definitions
+ */
+
+/*
+ * Possible value of boot context field 'boot_action'
+ */
+#if STM32MP13
+/* Boot action is Process Secure Boot */
+#define BOOT_API_CTX_BOOT_ACTION_SECURE_BOOT_PROCESS		0x7879598EUL
+/* Boot action is Process Wakeup from STANDBY  */
+#define BOOT_API_CTX_BOOT_ACTION_WAKEUP_STANDBY			0x21276323UL
+/* Boot action is Process Engineering Boot */
+#define BOOT_API_CTX_BOOT_ACTION_ENGI_BOOT			0x4A05FE3AUL
+/* Boot Action is MPU P0 Local reset */
+#define BOOT_API_CTX_BOOT_ACTION_MPU_CORE0_RESET_PROCESS	0x0F6C12ABUL
+#endif
+#if STM32MP15
+/* Boot action is Process Cold Boot */
+#define BOOT_API_CTX_BOOT_ACTION_COLD_BOOT_PROCESS		0x09U
+/* Boot action is Process Wakeup from CSTANDBY */
+#define BOOT_API_CTX_BOOT_ACTION_WAKEUP_CSTANDBY		0x0AU
+/* Boot action is Process Wakeup from STANDBY  */
+#define BOOT_API_CTX_BOOT_ACTION_WAKEUP_STANDBY			0x0BU
+/* Boot action is Process Engineering Boot */
+#define BOOT_API_CTX_BOOT_ACTION_ENGI_BOOT			0x0CU
+/* Boot Action is MPU P0 Local reset */
+#define BOOT_API_CTX_BOOT_ACTION_MPU_CORE0_RESET_PROCESS	0x0F
+#endif
+
+/*
+ * Possible value of boot context field 'stby_exit_status'
+ */
+
+/* The boot reason is not a STANDBY Exit reason */
+#define BOOT_API_CTX_STBY_EXIT_STATUS_NO_STANDBY                0x00
+
+/* STANDBY Exit with MPU_BEN=1, MCU_BEN=0 */
+#define BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_MPU_ONLY             0x01
+
+/*
+ * STANDBY Exit with MPU_BEN=1, MCU_BEN=1, MPU will go for cold boot
+ * MCU restarted by bootROM
+ */
+#define BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_ALL_CORES            0x02
+
+/*
+ * STANDBY Exit with MPU_BEN=1, MCU_BEN=1, MPU will go for cold boot
+ * but MCU restart aborted (code integrity check) : have not been restarted
+ * by bootROM
+ */
+#define BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_ALL_CORES_MCU_ABT    0x03
+
+/*
+ * STANDBY Exit with MPU_BEN=0, MCU_BEN=1, MPU gone to CSTANDBY,
+ * MCU restarted correctly by bootROM
+ * This value should never be read by FSBL, because not executed in that case
+ */
+#define BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_MCU_ONLY             0x04
+
+/*
+ * STANDBY Exit with MPU_BEN=0, MCU_BEN=1, MCU restart aborted
+ * due code integrity check, then MPU will go for cold boot despite
+ * was not planned initially
+ */
+#define BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_MCU_ONLY_MCU_ABT     0x05
+
+/*
+ * STANDBY Exit with MPU_BEN=1, MCU_BEN=1, MCU restart aborted
+ * due to MCU security perimeter issue
+ */
+#define \
+BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_ALL_CORES_MCU_ABT_SEC_PERIMETER_ISSUE 0x06
+
+/*
+ * STANDBY Exit with MPU_BEN=0, MCU_BEN=1, MCU restart aborted
+ * due to MCU security perimeter issue, then MPU will go for cold boot
+ * despite was not planned initially
+ */
+#define \
+BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_MCU_ONLY_MCU_ABT_SEC_PERIMETER_ISSUE	0x07
+
+/*
+ * Possible value of boot context field 'cstby_exit_status'
+ */
+/* The boot reason is not a CSTANDBY Exit reason */
+#define BOOT_API_CTX_CSTBY_EXIT_STATUS_NO_CSTBY			0x00
+/* CSTANDBY Exit with MCU detected as Not running */
+#define BOOT_API_CTX_CSTBY_EXIT_STATUS_MCU_NOT_RUNNING		0x01
+/* CSTANDBY Exit with MCU detected as Running  */
+#define BOOT_API_CTX_CSTBY_EXIT_STATUS_MCU_RUNNING		0x02
+
 /*
  * Possible value of boot context field 'auth_status'
  */
+#if STM32MP13
+ /* No authentication done */
+#define BOOT_API_CTX_AUTH_NO					0x7CFDD351U
+ /* Authentication done and failed */
+#define BOOT_API_CTX_AUTH_FAILED				0x51330884U
+ /* Authentication done and success */
+#define BOOT_API_CTX_AUTH_SUCCESS				0x67E8CAE1U
+#endif
+#if STM32MP15
 /* No authentication done */
 #define BOOT_API_CTX_AUTH_NO					0x0U
 /* Authentication done and failed */
 #define BOOT_API_CTX_AUTH_FAILED				0x1U
 /* Authentication done and succeeded */
 #define BOOT_API_CTX_AUTH_SUCCESS				0x2U
+#endif
 
 /*
  * Possible value of boot context field 'boot_interface_sel'
@@ -37,13 +143,16 @@
 #define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_FMC		0x3U
 
 /* Boot occurred on QSPI NOR */
-#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_QSPI		0x4U
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_SPI		0x4U
+
+/* Boot occurred on UART */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART		0x5U
 
 /* Boot occurred on USB */
 #define BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB		0x6U
 
 /* Boot occurred on QSPI NAND */
-#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_QSPI		0x7U
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_SPI		0x7U
 
 /**
  * @brief  Possible value of boot context field 'EmmcXferStatus'
@@ -67,11 +176,21 @@
 #define BOOT_API_CTX_EMMC_ERROR_STATUS_HEADER_NOT_FOUND         0x5U
 #define BOOT_API_CTX_EMMC_ERROR_STATUS_HEADER_SIZE_ZERO         0x6U
 #define BOOT_API_CTX_EMMC_ERROR_STATUS_IMAGE_NOT_COMPLETE       0x7U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_ACK_ERROR                0x8U
+
+/* Definitions relative to 'p_rom_version_info->platform_type_ver' field */
+#define BOOT_API_CTX_ROM_VERSION_PLAT_VER_IC_EMU_FPGA           0xAA
+#define BOOT_API_CTX_ROM_VERSION_PLAT_VER_FPGA_ONLY             0xBB
 
 /* Image Header related definitions */
 
 /* Definition of header version */
+#if STM32MP13
+#define BOOT_API_HEADER_VERSION					0x00020000U
+#endif
+#if STM32MP15
 #define BOOT_API_HEADER_VERSION					0x00010000U
+#endif
 
 /*
  * Magic number used to detect header in memory
@@ -90,6 +209,49 @@
 #define BOOT_API_ECDSA_ALGO_TYPE_P256NIST			1
 #define BOOT_API_ECDSA_ALGO_TYPE_BRAINPOOL256			2
 
+/*
+ * Extension headers related definitions
+ */
+/* 'bootapi_image_header_t.extension_flag' used for authentication feature */
+#define BOOT_API_AUTHENTICATION_EXTENSION_BIT			BIT(0)
+/* 'bootapi_image_header_t.extension_flag' used for FSBL decryption feature */
+#define BOOT_API_FSBL_DECRYPTION_EXTENSION_BIT			BIT(1)
+/* 'bootapi_image_header_t.extension_flag' used for padding header feature */
+#define BOOT_API_PADDING_EXTENSION_BIT				BIT(31)
+/*
+ * mask of bits of field 'bootapi_image_header_t.extension_flag'
+ * used for extension headers
+ */
+#define BOOT_API_ALL_EXTENSIONS_MASK \
+	(BOOT_API_AUTHENTICATION_EXTENSION_BIT | \
+	 BOOT_API_FSBL_DECRYPTION_EXTENSION_BIT | \
+	 BOOT_API_PADDING_EXTENSION_BIT)
+/*
+ * Magic number of FSBL decryption extension header
+ * The value shall gives the four bytes 'S','T',0x00,0x01 in memory
+ */
+#define BOOT_API_FSBL_DECRYPTION_HEADER_MAGIC_NB		0x01005453U
+
+/*
+ * Magic number of PKH revocation extension header
+ * The value shall gives the four bytes 'S','T',0x00,0x02 in memory
+ */
+#define BOOT_API_AUTHENTICATION_HEADER_MAGIC_NB			0x02005453U
+
+/* Max number of ECDSA public key hash in table */
+#define BOOT_API_AUTHENTICATION_NB_PKH_MAX			8U
+
+/* ECDSA public key hash table size in bytes */
+#define BOOT_API_AUTHENTICATION_TABLE_SIZE_BYTES \
+	(BOOT_API_AUTHENTICATION_NB_PKH_MAX * \
+	 BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES)
+
+/*
+ * Magic number of padding extension header
+ * The value shall gives the four bytes 'S','T',0xFF,0xFF in memory
+ */
+#define BOOT_API_PADDING_HEADER_MAGIC_NB			0xFFFF5453U
+
 /*
  * Cores secure magic numbers
  * Constant to be stored in bakcup register
@@ -98,6 +260,64 @@
 #define BOOT_API_A7_CORE0_MAGIC_NUMBER				0xCA7FACE0U
 #define BOOT_API_A7_CORE1_MAGIC_NUMBER				0xCA7FACE1U
 
+/*
+ * MCU Code Integrity Check related definitions
+ */
+
+/*
+ * Defines to identify RTC backup registers to be used for MCU code integrity
+ * check
+ */
+
+/*
+ * TAMP_BCK0R contains two bits
+ * bit 0 : wanted value of 'RCC_TZCR.TZEN'
+ * bit 1 : wanted value of 'RCC_TZCR.MCKPROT'
+ */
+
+/*
+ * TAMP_BCK0R bit position coding wanted value of 'RCC_TZCR.TZEN'
+ * trustZone aware domain enabling/disabling
+ */
+#define BOOT_API_MCIC_MCU_SECURITY_PERIMETER_TZEN_BIT			0
+
+/*
+ * TAMP_BCK0R bit position coding wanted value of 'RCC_TZCR.MCKPROT'
+ * ability of MCU to modify some clock settings in RCC
+ */
+#define BOOT_API_MCIC_MCU_SECURITY_PERIMETER_MCKPROT_BIT		1
+
+/* TAMP_BCK0R register index */
+#define \
+BOOT_API_MCIC_MCU_SECURITY_PERIMETER_TZEN_MCKPROT_TAMP_BCK_REG_IDX	0
+
+/*
+ * TAMP_BCK1R register index
+ * This register is coding the wanted value of register 'EXTI_TZENR1'
+ * to be programmed by bootROM on wakeup from STANDBY when MCUBEN=1
+ * that is MCU quick restart requested
+ */
+#define \
+BOOT_API_MCIC_MCU_SECURITY_PERIMETER_EXTI_TZENR1_TAMP_BCK_REG_IDX	1
+
+/*
+ * TAMP_BCK2R register index
+ * This register is coding the wanted value of register 'EXTI_TZENR2'
+ * to be programmed by bootROM on wakeup from STANDBY when MCUBEN=1
+ * that is MCU quick restart requested
+ */
+#define \
+BOOT_API_MCIC_MCU_SECURITY_PERIMETER_EXTI_TZENR2_TAMP_BCK_REG_IDX	2
+
+/*
+ * TAMP_BCK3R register index
+ * This register is coding the wanted value of register 'EXTI_TZENR3'
+ * to be programmed by bootROM on wakeup from STANDBY when MCUBEN=1
+ * that is MCU quick restart requested
+ */
+#define \
+BOOT_API_MCIC_MCU_SECURITY_PERIMETER_EXTI_TZENR3_TAMP_BCK_REG_IDX	3
+
 /*
  * TAMP_BCK4R register index
  * This register is used to write a Magic Number in order to restart
@@ -112,6 +332,39 @@
  */
 #define BOOT_API_CORE1_BRANCH_ADDRESS_TAMP_BCK_REG_IDX		5U
 
+/*
+ * TAMP_BCK22R register index
+ * This register contains offset in bytes of code to Hash in RETRAM region
+ * Note : offset is intended as relative value from start of RETRAM
+ */
+#define \
+BOOT_API_MCIC_OFFSET_IN_BYTES_CODE_TO_HASH_RETRAM_TAMP_BCK_REG_IDX	22
+
+/*
+ * TAMP_BCK23R register index
+ * This register contains the size in bytes of the single consecutive region
+ * of MCU Firmware in RETRAM (Retention RAM) to hash (by SHA-256)
+ * Note : This is required as a MCU firmware Code Integrity Check (aka : MCIC)
+ * to avoid bootROM restarting MCU on a corrupted firmware
+ */
+#define \
+BOOT_API_MCIC_RETRAM_REGION_TO_HASH_IN_BYTES_TAMP_BCK_REG_IDX		23
+
+/*
+ * TAMP_BCK24R to TAMP_BCK31R register indexes
+ * Those registers contains SHA-256 digest of RETRAM MCU Firmware code between
+ * [(RETRAM_start + offset) -- (RETRAM_start + offset + size_to_hash)]
+ * in this order
+ * This is the MCU Code Integrity Check MCU Firmware signature
+ * value on 256 bits
+ */
+
+/* First TAMP_BKP index of MCU Firmware signature : ie TAMP_BCK24R */
+#define BOOT_API_MCIC_SHA_DIGEST_FIRST_TAMP_BCK_REG_IDX			24
+
+/* Last TAMP_BKP index of MCU Firmware signature : ie TAMP_BCK31R */
+#define BOOT_API_MCIC_SHA_DIGEST_LAST_TAMP_BCK_REG_IDX			31
+
 /*
  * Possible value of boot context field 'hse_clock_value_in_hz'
  */
@@ -138,6 +391,343 @@
 
 #define BOOT_API_RETURN_OK					0x77U
 
+/* Mapping of OTP Word and OTP bits managing SSP and useful to FSBL-SSP */
+#if STM32MP13
+/* OTP_CFG9 */
+#define BOOT_API_OTP_SSP_WORD_NB				9U
+/* SSP_REQ = OTP_CFG9[5] */
+#define BOOT_API_OTP_SSP_REQ_BIT_POS				5
+/* SSP_SUCCESS = OTP_CFG9[6] */
+#define BOOT_API_OTP_SSP_SUCCESS_BIT_POS			6
+#endif
+#if STM32MP15
+/* OTP_CFG8 */
+#define BOOT_API_OTP_SSP_WORD_NB				8U
+/* SSP_REQ = OTP_CFG8[8] */
+#define BOOT_API_OTP_SSP_REQ_BIT_POS				8
+/* SSP_SUCCESS = OTP_CFG8[9] */
+#define BOOT_API_OTP_SSP_SUCCESS_BIT_POS			9
+#endif
+
+/*
+ * Possible values of boot context field
+ * 'ssp_config_ptr_in->ssp_cmd'
+ */
+/* 'K' 'B' 'U' 'P' -.> 'PUBK' */
+#define BOOT_API_CTX_SSP_CMD_CALC_CHIP_PUBK             0x4B425550
+
+#if STM32MP_SSP
+/* 'V' 'O' 'R' 'P' -.> 'PROV' */
+#define BOOT_API_CTX_SSP_CMD_PROV_SECRET		0x564F5250
+/*
+ * Possible values of boot context field
+ * 'ssp_config_ptr_in->ssp_cmd' written by bootROM as Acknowledge
+ * of a request of SSP by FSBL.
+ */
+
+/* Written by bootROM on SSP error */
+#define BOOT_API_CTX_SSP_CMD_INVALID			0x00000000
+/*
+ * 'A' 'B' 'U' 'P' -.> 'PUBA' : ACK of ECIES_CHIP_PUBK calculation
+ * request by bootROM.
+ */
+#define BOOT_API_CTX_SSP_CMD_CALC_CHIP_PUBK_ACK		0x41425550
+/*
+ * 'A' 'O' 'R' 'P' -.> 'PROA' : ACK of OEM Secret Provisioning request
+ * by bootROM.
+ */
+#define BOOT_API_CTX_SSP_CMD_PROV_SECRET_ACK		0x414F5250
+
+/*
+ * Constants required for SSP
+ */
+/* '.' 'P' 'S' 'S' -.> 'SSP.' */
+#define BOOT_API_SSP_BLOB_LICENSE_TYPE_SSP_NORMAL	0x2E505353
+/* 'L' 'P' 'S' 'S' -.> 'SSPL' */
+#define BOOT_API_SSP_BLOB_LICENSE_TYPE_SSP_LIVE		0x4C505353
+/* version 1 */
+#define BOOT_API_SSP_LICENSE_LAYOUT_VERSION_TO_MATCH	0x00000001
+/* 'P' 'P' 'S' 'S' -.> 'SSPP' */
+#define BOOT_API_SSP_BLOB_PAYLOAD_MAGIC_SSP		0x50505353
+/* IV AES on 128 bits = 16 bytes and KEY AES on 128 bits = 16 bytes */
+#define BOOT_API_SSP_ENCRYPTED_IV_AND_KEY_SIZE_BYTES	32
+/* version 1 */
+#define BOOT_API_SSP_PAYLOAD_PROTOCOL_VERSION_TO_MATCH	0x00000001
+/*
+ * Scalar in Elliptic curve cryptography is an integer (often a Prime)
+ * the number of bytes of this scalar is defined below.
+ */
+#define BOOT_API_SSP_SCALAR_SIZE_BYTES				32
+
+/*
+ * In Elliptic curve cryptography coordinates of points are 2D P
+ * (Px, Py) as concatenation of two scalars.
+ */
+#define BOOT_API_SSP_EC_COORDINATE_SIZE_BYTES \
+	(2 * BOOT_API_SSP_SCALAR_SIZE_BYTES)
+
+/* In Elliptic curve cryptography Private Keys are scalars */
+#define BOOT_API_SSP_PRIVK_KEY_SIZE_BYTES \
+	BOOT_API_SSP_SCALAR_SIZE_BYTES
+
+/*
+ * In ECIES algorithm the Shared Secret (SS) is
+ * the x coordinate (Px) of a point P(Px,Py) obtained on reference
+ * chosen NIST-P256 Elliptic curve.
+ */
+#define BOOT_API_SSP_ECDH_SHARED_SECRET_SIZE_BYTES \
+	BOOT_API_SSP_SCALAR_SIZE_BYTES
+
+/*
+ * In Elliptic curve cryptography Public Keys are Points on chosen
+ * Elliptic curve P(x,y).
+ * Public Key is the x, y coordinates concatenated
+ * Ecies_eph_pubk and OEM_ECDSA_PUBK are each 64 bytes = 512 bits key
+ * sizes.
+ */
+#define BOOT_API_SSP_PUBK_KEY_SIZE_BYTES \
+	BOOT_API_SSP_EC_COORDINATE_SIZE_BYTES
+
+/*
+ * Size in bytes of ECIES_Chip_pubk obtained from bootROM at end of SSP
+ * phase 1 : Chip public key calculation.
+ */
+#define BOOT_API_SSP_ECIES_CHIP_PUBK_SIZE_BYTES \
+	BOOT_API_SSP_PUBK_KEY_SIZE_BYTES
+
+/* AES-GCM authentication tag size is 16 bytes = 128 bits */
+#define BOOT_API_SSP_AES_GCM_AUTH_TAG_SIZE_BYTES		16
+
+/* AES-GCM Symmetric Key size is 16 bytes = 128 bits */
+#define BOOT_API_SSP_AES_GCM_KEY_SIZE_BYTES			16
+
+/* AES-GCM Initialization Vector (IV) size is of 16 bytes = 128 bits */
+#define BOOT_API_SSP_AES_GCM_IV_SIZE_BYTES			16
+
+/*
+ * 88 bytes (license_type, live_session_id, license_version,
+ * fsbl_min_version, rfu[8], eph_ecies_pubk[])
+ */
+#define BOOT_API_SSP_AES_GCM_LICENSE_AAD_NB_BYTES_FROM_LICENSE	88
+
+/*
+ * 32 bytes AAD License Secret from 2nd round KDF-SHA-256
+ * from ECDH Shared Secret hence KDF[32..63] aka "Authorization Token"
+ */
+#define BOOT_API_SSP_AES_GCM_LICENSE_AAD_NB_BYTES_FROM_KDF	32
+
+/*
+ * Total License AAD size = 88 + 32 = 120 bytes
+ */
+#define BOOT_API_SSP_AES_GCM_LICENSE_AAD_SIZE_BYTES \
+	(BOOT_API_SSP_AES_GCM_LICENSE_AAD_NB_BYTES_FROM_LICENSE + \
+	 BOOT_API_SSP_AES_GCM_LICENSE_AAD_NB_BYTES_FROM_KDF)
+
+/*
+ * AAD for Payload size : composed of :
+ * payload_magic, payload_protocol_version, oem_ecdsa_pubk[], oem_secret_size
+ * = 4 + 4 + 64 + 4 = 76 bytes AAD for Payload
+ */
+#define BOOT_API_SSP_AES_GCM_PAYLOAD_AAD_SIZE_BYTES		76
+
+/*
+ * OEM Secrets max size in bytes :
+ * [OTP[95:59] + OTP_CFG56 (RMA Unlock and Relock passwords)] x 4 bytes
+ * by OTP word = 152 bytes
+ */
+#define BOOT_API_SSP_OEM_SECRETS_MAX_SIZE_BYTES			152
+
+/*
+ * Possible values of boot context field 'ssp_status'
+ * as can be read by FSBL-SSP
+ */
+#define BOOT_API_CTX_SSP_STATUS_NO_SSP				0
+#define BOOT_API_CTX_SSP_STATUS_CHIP_PUBK_CALC_FINISHED		1
+#define BOOT_API_CTX_SSP_STATUS_OEM_SEC_PROV_FINISHED		2
+#define BOOT_API_CTX_SSP_STATUS_OEM_SEC_PROV_FORBIDDEN		3
+
+/*
+ * Reserved size for future use
+ */
+#define BOOT_API_SSP_HSM_OEM_RFU_SIZE				8
+
+/*
+ * Exported types
+ */
+
+/*
+ * SSP related definitions
+ */
+/*
+ * SSP BLOB License structure : Binary Large OBject License structure
+ * Should be written by FSBL-SSP to provide bootROM with SSP OEM Secret
+ * provisioning.
+ * License information data, the structure is read by bootROM.
+ */
+typedef struct {
+	/*
+	 * License Type provided by HSM-OEM tool
+	 * should match Normal SSP License of Live SSP License.
+	 */
+	uint32_t license_type;
+
+	/* Live Session ID provided by HSM-OEM tool */
+	uint32_t live_session_id;
+
+	/*
+	 * Version of the License Protocol (Structure)
+	 * should be incremented each time a new.
+	 */
+	uint32_t license_version;
+
+	/*
+	 * Minimum FSBL version to be compared
+	 * with FSBL Header field 'imageVersion'.
+	 */
+	uint32_t fsbl_min_version;
+
+	/* RFU provided by HSM-OEM tool */
+	uint8_t  rfu[BOOT_API_SSP_HSM_OEM_RFU_SIZE];
+
+	/*
+	 * Ephemeral ECIES Public Key from HSM-OEM
+	 * 64 bytes = 512 bits.
+	 */
+	uint8_t  eph_ecies_pubk[BOOT_API_SSP_PUBK_KEY_SIZE_BYTES];
+
+	/*
+	 * Encrypted (IV,Key) : with Shared Secret based on
+	 * 'Ephemeral ECIES Key pair' and 'ECIES Chip Key pair'.
+	 */
+	uint8_t encrypted_iv_and_key
+		[BOOT_API_SSP_ENCRYPTED_IV_AND_KEY_SIZE_BYTES];
+
+	/*
+	 * AUTH_TAG AES-GCM from encryption of (IV, Key)
+	 * in HSM-OEM with License AAD scheme
+	 * License Tag is 16 bytes = 128 bits.
+	 */
+	uint8_t  license_tag[BOOT_API_SSP_AES_GCM_AUTH_TAG_SIZE_BYTES];
+
+} boot_api_ssp_blob_license_t;
+
+/*
+ * SSP BLOB Payload structure : Binary Large OBject Payload Structure
+ * Should be written by FSBL-SSP to provide bootROM with SSP OEM Secret
+ * provisioning input data, the structure is read by bootROM
+ * The BLOB Payload size is fixed to a max size of 244 bytes based
+ * on a max number of bytes of OEM secret derived from OTP upper free
+ * area in STM32MP15xx cut 2.0.In this table oem_encrypted_secrets[]
+ * of max size only the first 'p_blob_payload->oem_secret_size_bytes'
+ * bytes will be considered and used by bootROM.
+ */
+typedef struct {
+	/*
+	 * BLOB Payload Magic : for memory validity check of BLOB Payload
+	 * to match against BOOT_API_SSP_BLOB_PAYLOAD_MAGIC_SSP by bootROM.
+	 */
+	uint32_t payload_magic;
+
+	/*
+	 * SSP Payload protocol version : on 32 bits
+	 * to be checked by bootROM for equality with
+	 * BOOT_API_SSP_PAYLOAD_PROTOCOL_VERSION_TO_MATCH
+	 * ie : 0x00000001 : version 1 of SSP Payload
+	 */
+	uint32_t payload_protocol_version;
+
+#if STM32MP13
+	/* OEM_RPKTH OEM Root Public Key table hash is the
+	 * hash[ hash(algo + pubK i) for i=0..N-1] where N
+	 * is the number of OEM public keys in product for
+	 * key revocation feature
+	 *
+	 * N = 8 for STM32MP13xx
+	 * size of field = 32 bytes = 256 bits
+	 */
+	uint8_t  oem_rpkth[BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES];
+#endif
+#if STM32MP15
+	/*
+	 * OEM_ECDSA_PUBK Public Key defined by OEM
+	 * 64 bytes = 512 bits
+	 */
+	uint8_t  oem_ecdsa_pubk[BOOT_API_SSP_PUBK_KEY_SIZE_BYTES];
+#endif
+
+	/*
+	 * Size of Table of OEM Secrets encrypted with AES-GCM (Key,IV) from
+	 * License field 'encrypted_iv_and_key[]'
+	 * should be <= BOOT_API_SSP_OEM_SECRETS_MAX_SIZE_BYTES:
+	 * is verified by bootROM.
+	 */
+	uint32_t oem_secret_size_bytes;
+
+	/*
+	 * AUTH_TAG AES-GCM computed by HSM-OEM when encrypting OEM Secrets with
+	 * (Key,IV) using special AAD scheme for Payload.
+	 * 16 bytes = 128 bits
+	 */
+	uint8_t  payload_tag[BOOT_API_SSP_AES_GCM_AUTH_TAG_SIZE_BYTES];
+
+	/*
+	 * OEM Secrets encrypted with AES-GCM (IV, Key) from
+	 * License field 'encrypted_iv_and_key[]'.
+	 * The payload size is 'oem_secret_size_bytes'
+	 * should be <= BOOT_API_SSP_OEM_SECRETS_MAX_SIZE_BYTES =
+	 *  152 bytes : OEM Secrets max size in bytes :
+	 * [OTP_CFG56, OTP_CFG59, OTP_CFG60..95] x 4 bytes by OTP word.
+	 */
+	uint8_t oem_encrypted_secrets[BOOT_API_SSP_OEM_SECRETS_MAX_SIZE_BYTES];
+
+} boot_api_ssp_blob_payload_t;
+#endif
+
+/* SSP Configuration structure */
+typedef struct {
+	/* SSP Command*/
+	uint32_t ssp_cmd;
+#if STM32MP_SSP
+	/* ECIES chip public key */
+	uint8_t *p_chip_pubk;
+	/* Blob License Address */
+	boot_api_ssp_blob_license_t *p_blob_license;
+	/* Blob Payload Address */
+	boot_api_ssp_blob_payload_t *p_blob_payload;
+	/* Secrets Decrypted Address */
+	uint8_t *p_ssp_oem_secrets_decrypted;
+	/* Reserved for Future Use (RFU) */
+	uint32_t padding_rfu;
+#else
+	uint8_t	reserved[20];
+#endif
+} boot_api_ssp_config_t;
+
+/*
+ * bootROM version information structure definition
+ * Total size = 24 bytes = 6 uint32_t
+ */
+typedef struct {
+	/* Chip Version */
+	uint32_t chip_ver;
+
+	/* Cut version within a fixed chip version */
+	uint32_t cut_ver;
+
+	/* Version of ROM Mask within a fixed cut version */
+	uint32_t rom_mask_ver;
+
+	/* Internal Version of bootROM code */
+	uint32_t bootrom_ver;
+
+	/* Version of bootROM adapted */
+	uint32_t for_chip_design_rtl_ver;
+
+	/* Restriction on compiled platform when it applies */
+	uint32_t platform_type_ver;
+
+} boot_api_rom_version_info_t;
+
 /*
  * Boot Context related definitions
  */
@@ -154,29 +744,49 @@ typedef struct {
 	 */
 	uint16_t boot_interface_selected;
 	uint16_t boot_interface_instance;
+#if STM32MP15
 	uint32_t reserved1[13];
+#endif
+#if STM32MP13
+	uint32_t reserved1[12];
+#endif
 	uint32_t otp_afmux_values[3];
-	uint32_t reserved[5];
+	uint32_t reserved[2];
+	/*
+	 * Log to boot context, what was the kind of boot action
+	 * takes values from defines BOOT_API_BOOT_ACTION_XXX above
+	 */
+	uint32_t boot_action;
+#if STM32MP15
+	/*
+	 * STANDBY Exit status to be checked by FSBL in case
+	 * field 'boot_action' == BOOT_API_CTX_BOOT_ACTION_WAKEUP_STANDBY
+	 * take values from defines above 'BOOT_API_CTX_STBY_EXIT_STATUS_XXX'
+	 * depending on encountered situation
+	 */
+	uint32_t stby_exit_status;
+	/*
+	 * CSTANDBY Exit status to be checked by FSBL in case
+	 * boot_action == BOOT_API_CTX_BOOT_ACTION_WAKEUP_CSTANDBY
+	 * take values from defines above 'BOOT_API_CTX_CSTBY_EXIT_STATUS_XXX'
+	 * depending on encountered situation
+	 */
+	uint32_t cstby_exit_status;
+#endif
 	uint32_t auth_status;
 
+#if STM32MP15
 	/*
 	 * Pointers to bootROM External Secure Services
-	 * - ECDSA check key
 	 * - ECDSA verify signature
-	 * - ECDSA verify signature and go
 	 */
-	uint32_t (*bootrom_ecdsa_check_key)(uint8_t *pubkey_in,
-					    uint8_t *pubkey_out);
+	uint32_t reserved3;
 	uint32_t (*bootrom_ecdsa_verify_signature)(uint8_t *hash_in,
 						   uint8_t *pubkey_in,
 						   uint8_t *signature,
 						   uint32_t ecc_algo);
-	uint32_t (*bootrom_ecdsa_verify_and_go)(uint8_t *hash_in,
-						uint8_t *pub_key_in,
-						uint8_t *signature,
-						uint32_t ecc_algo,
-						uint32_t *entry_in);
-
+	uint32_t reserved4;
+#endif
 	/*
 	 * Information specific to an SD boot
 	 * Updated each time an SD boot is at least attempted,
@@ -206,6 +816,21 @@ typedef struct {
 	 * ie FSBL partition on which the boot was successful
 	 */
 	uint32_t boot_partition_used_toboot;
+	/*
+	 * Address of SSP configuration structure :
+	 * given and defined by bootROM
+	 * and used by FSBL. The structure is of type
+	 * 'boot_api_ssp_config_t'
+	 */
+	boot_api_ssp_config_t *p_ssp_config;
+	/*
+	 * boot context field containing bootROM updated SSP Status
+	 * Values can be of type BOOT_API_CTX_SSP_STATUS_XXX
+	 */
+	uint32_t	ssp_status;
+
+	/* Pointer on ROM constant containing ROM information */
+	const boot_api_rom_version_info_t *p_rom_version_info;
 
 } __packed boot_api_context_t;
 
@@ -224,10 +849,10 @@ typedef struct {
 	uint8_t image_signature[BOOT_API_ECDSA_SIGNATURE_LEN_IN_BYTES];
 	/*
 	 * Checksum of payload
-	 * 32-bit sum all all payload bytes considered as 8 bit unigned numbers,
-	 * discarding any overflow bits.
+	 * 32-bit sum all payload bytes considered as 8 bit unsigned
+	 * numbers, discarding any overflow bits.
 	 * Use to check UART/USB downloaded image integrity when signature
-	 * is not used (i.e bit 0 : 'No_sig_check' = 1 in option flags)
+	 * is not used
 	 */
 	uint32_t payload_checksum;
 	/* Image header version : should have value BOOT_API_HEADER_VERSION */
@@ -252,6 +877,27 @@ typedef struct {
 	 * counter value in OTP_CFG4 prior executing the downloaded image
 	 */
 	uint32_t image_version;
+
+#if STM32MP13
+	/*
+	 * Extension flags :
+	 *
+	 * Bit 0 : Authentication extension header
+	 *      value 0 : No signature check request
+	 * Bit 1 : Encryption extension header
+	 * Bit 2 : Padding extension header
+	 */
+	uint32_t extension_flags;
+	/* Length in bytes of all extension headers */
+	uint32_t extension_headers_length;
+	/* Add binary type information */
+	uint32_t binary_type;
+	/* Pad up to 128 byte total size */
+	uint8_t pad[16];
+	/* Followed by extension header */
+	uint8_t ext_header[];
+#endif
+#if STM32MP15
 	/*
 	 * Option flags:
 	 * Bit 0 : No signature check request : 'No_sig_check'
@@ -277,6 +923,48 @@ typedef struct {
 	uint8_t pad[83];
 	/* Add binary type information */
 	uint8_t binary_type;
+#endif
 } __packed boot_api_image_header_t;
 
+typedef uint8_t boot_api_sha256_t[BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES];
+
+typedef struct {
+	/* Extension header type:
+	 * BOOT_API_FSBL_DECRYPTION_HEADER_MAGIC_NB or
+	 * BOOT_API_AUTHENTICATION_HEADER_MAGIC_NB
+	 * BOOT_API_PADDING_HEADER_MAGIC_NB
+	 */
+	uint32_t type;
+	/* Extension header len in byte */
+	uint32_t len;
+	/* parameters of this extension */
+	uint8_t  params[];
+} __packed boot_extension_header_t;
+
+typedef struct {
+	/* Idx of ECDSA public key to be used in table */
+	uint32_t pk_idx;
+	/* Number of ECDSA public key in table */
+	uint32_t nb_pk;
+	/*
+	 * Type of ECC algorithm to use  :
+	 * value 1 : for P-256 NIST algorithm
+	 * value 2 : for Brainpool 256 algorithm
+	 * See definitions 'BOOT_API_ECDSA_ALGO_TYPE_XXX' above.
+	 */
+	uint32_t ecc_algo_type;
+	/* ECDSA public key to be used to check signature. */
+	uint8_t ecc_pubk[BOOT_API_ECDSA_PUB_KEY_LEN_IN_BYTES];
+	/* table of Hash of Algo+ECDSA public key */
+	boot_api_sha256_t pk_hashes[];
+} __packed boot_ext_header_params_authentication_t;
+
+typedef struct {
+	/* Size of encryption key (128 or 256) */
+	uint32_t key_size;
+	uint32_t derivation_cont;
+	/* 128 msb bits of plain payload SHA256 */
+	uint32_t hash[4];
+} __packed boot_ext_header_params_encrypted_fsbl_t;
+
 #endif /* BOOT_API_H */
diff --git a/plat/st/stm32mp1/include/plat_def_fip_uuid.h b/plat/st/stm32mp1/include/plat_def_fip_uuid.h
new file mode 100644
index 000000000..e5fbc2dfc
--- /dev/null
+++ b/plat/st/stm32mp1/include/plat_def_fip_uuid.h
@@ -0,0 +1,14 @@
+/*
+ * Copyright (c) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef PLAT_DEF_FIP_UUID_H
+#define PLAT_DEF_FIP_UUID_H
+
+#define UUID_STM32MP_CONFIG_CERT \
+	{{0x50, 0x1d, 0x8d, 0xd2}, {0x8b, 0xce}, {0x49, 0xa5}, 0x84, 0xeb, \
+	 {0x55, 0x9a, 0x9f, 0x2e, 0xae, 0xaf} }
+#endif /* PLAT_DEF_FIP_UUID_H */
+
diff --git a/plat/st/stm32mp1/include/plat_tbbr_img_def.h b/plat/st/stm32mp1/include/plat_tbbr_img_def.h
new file mode 100644
index 000000000..984aae85b
--- /dev/null
+++ b/plat/st/stm32mp1/include/plat_tbbr_img_def.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+#ifndef STM32MP1_IMG_DEF_H
+#define STM32MP1_IMG_DEF_H
+
+#include <export/common/tbbr/tbbr_img_def_exp.h>
+
+/* Undef the existing values */
+#undef BL32_EXTRA1_IMAGE_ID
+#undef BL32_EXTRA2_IMAGE_ID
+#undef TOS_FW_CONFIG_ID
+#undef TRUSTED_BOOT_FW_CERT_ID
+#undef FWU_METADATA_IMAGE_ID
+#undef BKUP_FWU_METADATA_IMAGE_ID
+#undef FW_CONFIG_ID
+#undef HW_CONFIG_ID
+#undef GPT_IMAGE_ID
+#undef ENC_IMAGE_ID
+
+/* Define the STM32MP1 used ID */
+#define FW_CONFIG_ID			U(1)
+#define HW_CONFIG_ID			U(2)
+#define GPT_IMAGE_ID			U(3)
+#define ENC_IMAGE_ID			U(6)
+#define BL32_EXTRA1_IMAGE_ID		U(8)
+#define BL32_EXTRA2_IMAGE_ID		U(9)
+#define FWU_METADATA_IMAGE_ID		U(12)
+#define BKUP_FWU_METADATA_IMAGE_ID	U(13)
+#define TOS_FW_CONFIG_ID		U(16)
+#define STM32MP_CONFIG_CERT_ID		U(17)
+
+/* Increase the MAX_NUMBER_IDS to match the authentication pool required */
+#define MAX_NUMBER_IDS			U(19)
+
+#endif	/* STM32MP1_IMG_DEF_H */
diff --git a/plat/st/stm32mp1/include/platform_def.h b/plat/st/stm32mp1/include/platform_def.h
index 1e9443ece..baeecd385 100644
--- a/plat/st/stm32mp1/include/platform_def.h
+++ b/plat/st/stm32mp1/include/platform_def.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2021, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -25,22 +25,9 @@
 #define PLATFORM_STACK_SIZE		0xC00
 #endif
 
-#if STM32MP_USE_STM32IMAGE
-#ifdef AARCH32_SP_OPTEE
-#define OPTEE_HEADER_IMAGE_NAME		"teeh"
-#define OPTEE_CORE_IMAGE_NAME		"teex"
-#define OPTEE_PAGED_IMAGE_NAME		"teed"
-#define OPTEE_HEADER_BINARY_TYPE	U(0x20)
-#define OPTEE_CORE_BINARY_TYPE		U(0x21)
-#define OPTEE_PAGED_BINARY_TYPE		U(0x22)
-#endif
-
-/* SSBL = second stage boot loader */
-#define BL33_IMAGE_NAME			"ssbl"
-#define BL33_BINARY_TYPE		U(0x0)
-#else /* STM32MP_USE_STM32IMAGE */
 #define FIP_IMAGE_NAME			"fip"
-#endif /* STM32MP_USE_STM32IMAGE */
+#define METADATA_PART_1			"metadata1"
+#define METADATA_PART_2			"metadata2"
 
 #define STM32MP_PRIMARY_CPU		U(0x0)
 #define STM32MP_SECONDARY_CPU		U(0x1)
@@ -68,10 +55,17 @@
 #define BL2_LIMIT			(STM32MP_BL2_BASE + \
 					 STM32MP_BL2_SIZE)
 
+#define BL2_RO_BASE			STM32MP_BL2_RO_BASE
+#define BL2_RO_LIMIT			(STM32MP_BL2_RO_BASE + \
+					 STM32MP_BL2_RO_SIZE)
+
+#define BL2_RW_BASE			STM32MP_BL2_RW_BASE
+#define BL2_RW_LIMIT			(STM32MP_BL2_RW_BASE + \
+					 STM32MP_BL2_RW_SIZE)
 /*******************************************************************************
  * BL32 specific defines.
  ******************************************************************************/
-#if STM32MP_USE_STM32IMAGE || defined(IMAGE_BL32)
+#if defined(IMAGE_BL32)
 #if ENABLE_PIE
 #define BL32_BASE			0
 #define BL32_LIMIT			STM32MP_BL32_SIZE
@@ -80,7 +74,7 @@
 #define BL32_LIMIT			(STM32MP_BL32_BASE + \
 					 STM32MP_BL32_SIZE)
 #endif
-#endif /* STM32MP_USE_STM32IMAGE || defined(IMAGE_BL32) */
+#endif /* defined(IMAGE_BL32) */
 
 /*******************************************************************************
  * BL33 specific defines.
@@ -93,8 +87,7 @@
 #define PLAT_STM32MP_NS_IMAGE_OFFSET	BL33_BASE
 
 /* Needed by STM32CubeProgrammer support */
-#define DWL_BUFFER_BASE			(STM32MP_DDR_BASE + U(0x08000000))
-#define DWL_BUFFER_SIZE			U(0x08000000)
+#define DWL_BUFFER_SIZE			U(0x01000000)
 
 /*
  * SSBL offset in case it's stored in eMMC boot partition.
@@ -132,6 +125,8 @@
  */
 #define ARM_IRQ_SEC_PHY_TIMER		U(29)
 
+#define ARM_IRQ_NON_SEC_SGI_0		U(0)
+
 #define ARM_IRQ_SEC_SGI_0		U(8)
 #define ARM_IRQ_SEC_SGI_1		U(9)
 #define ARM_IRQ_SEC_SGI_2		U(10)
@@ -141,7 +136,15 @@
 #define ARM_IRQ_SEC_SGI_6		U(14)
 #define ARM_IRQ_SEC_SGI_7		U(15)
 
+/* Platform IRQ Priority */
+#define STM32MP1_IRQ_RCC_SEC_PRIO	U(0x6)
+#define STM32MP_IRQ_SEC_SPI_PRIO	U(0x10)
+
 #define STM32MP1_IRQ_TZC400		U(36)
+#define STM32MP1_IRQ_MCU_SEV		U(176)
+#define STM32MP1_IRQ_RCC_WAKEUP		U(177)
+#define STM32MP1_IRQ_IWDG1		U(182)
+#define STM32MP1_IRQ_IWDG2		U(183)
 #define STM32MP1_IRQ_TAMPSERRS		U(229)
 #define STM32MP1_IRQ_AXIERRIRQ		U(244)
 
diff --git a/plat/st/stm32mp1/include/stm32mp15_mbedtls_config.h b/plat/st/stm32mp1/include/stm32mp15_mbedtls_config.h
new file mode 100644
index 000000000..0023fecd9
--- /dev/null
+++ b/plat/st/stm32mp1/include/stm32mp15_mbedtls_config.h
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2015-2020, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#ifndef MBEDTLS_CONFIG_H
+#define MBEDTLS_CONFIG_H
+
+/*
+ * Key algorithms currently supported on mbed TLS libraries
+ */
+#define TF_MBEDTLS_USE_RSA	0
+#define TF_MBEDTLS_USE_ECDSA	1
+
+/*
+ * Hash algorithms currently supported on mbed TLS libraries
+ */
+#define TF_MBEDTLS_SHA256		1
+#define TF_MBEDTLS_SHA384		2
+#define TF_MBEDTLS_SHA512		3
+
+/*
+ * Configuration file to build mbed TLS with the required features for
+ * Trusted Boot
+ */
+
+#define MBEDTLS_PLATFORM_MEMORY
+#define MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
+/* Prevent mbed TLS from using snprintf so that it can use tf_snprintf. */
+#define MBEDTLS_PLATFORM_SNPRINTF_ALT
+
+#define MBEDTLS_PKCS1_V21
+
+#define MBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION
+#define MBEDTLS_X509_CHECK_KEY_USAGE
+#define MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE
+
+#define MBEDTLS_ASN1_PARSE_C
+#define MBEDTLS_ASN1_WRITE_C
+
+#define MBEDTLS_BASE64_C
+#define MBEDTLS_BIGNUM_C
+
+#define MBEDTLS_ERROR_C
+#define MBEDTLS_MD_C
+
+#define MBEDTLS_MEMORY_BUFFER_ALLOC_C
+#define MBEDTLS_OID_C
+
+#define MBEDTLS_PK_C
+#define MBEDTLS_PK_PARSE_C
+#define MBEDTLS_PK_WRITE_C
+
+#define MBEDTLS_PLATFORM_C
+
+#if TF_MBEDTLS_USE_ECDSA
+#define MBEDTLS_ECDSA_C
+#define MBEDTLS_ECP_C
+#define MBEDTLS_ECP_DP_SECP256R1_ENABLED
+#define MBEDTLS_ECP_NO_INTERNAL_RNG
+#endif
+#if TF_MBEDTLS_USE_RSA
+#define MBEDTLS_RSA_C
+#define MBEDTLS_X509_RSASSA_PSS_SUPPORT
+#endif
+
+#define MBEDTLS_SHA256_C
+#if (TF_MBEDTLS_HASH_ALG_ID != TF_MBEDTLS_SHA256)
+#define MBEDTLS_SHA512_C
+#endif
+
+#define MBEDTLS_VERSION_C
+
+#define MBEDTLS_X509_USE_C
+#define MBEDTLS_X509_CRT_PARSE_C
+
+#if TF_MBEDTLS_USE_AES_GCM
+#define MBEDTLS_AES_C
+#define MBEDTLS_CIPHER_C
+#define MBEDTLS_GCM_C
+#endif
+
+/* MPI / BIGNUM options */
+#define MBEDTLS_MPI_WINDOW_SIZE			2
+
+#if TF_MBEDTLS_USE_RSA
+#if TF_MBEDTLS_KEY_SIZE <= 2048
+#define MBEDTLS_MPI_MAX_SIZE			256
+#else
+#define MBEDTLS_MPI_MAX_SIZE			512
+#endif
+#else
+#define MBEDTLS_MPI_MAX_SIZE			256
+#endif
+
+/* Memory buffer allocator options */
+#define MBEDTLS_MEMORY_ALIGN_MULTIPLE		8
+
+/*
+ * Prevent the use of 128-bit division which
+ * creates dependency on external libraries.
+ */
+#define MBEDTLS_NO_UDBL_DIVISION
+
+#ifndef __ASSEMBLER__
+/* System headers required to build mbed TLS with the current configuration */
+#include <stdlib.h>
+#include <mbedtls/check_config.h>
+#endif
+
+/*
+ * Mbed TLS heap size is smal as we only use the asn1
+ * parsing functions
+ * digest, signature and crypto algorithm are done by
+ * other library.
+ */
+
+#define TF_MBEDTLS_HEAP_SIZE           U(5120)
+#endif /* MBEDTLS_CONFIG_H */
diff --git a/plat/st/stm32mp1/include/stm32mp1_context.h b/plat/st/stm32mp1/include/stm32mp1_context.h
index 698415af2..c89c213b3 100644
--- a/plat/st/stm32mp1/include/stm32mp1_context.h
+++ b/plat/st/stm32mp1/include/stm32mp1_context.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2018, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2017-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -7,8 +7,37 @@
 #ifndef STM32MP1_CONTEXT_H
 #define STM32MP1_CONTEXT_H
 
+#include <stdbool.h>
 #include <stdint.h>
 
-int stm32_save_boot_interface(uint32_t interface, uint32_t instance);
+#include <drivers/st/stm32_mce.h>
+#include <drivers/st/stm32_rtc.h>
+
+void stm32_clean_context(void);
+int stm32_save_context(uint32_t zq0cr0_zdata,
+		       struct stm32_rtc_calendar *rtc_time,
+		       unsigned long long stgen_cnt);
+int stm32_restore_context(void);
+unsigned long long stm32_get_stgen_from_context(void);
+void stm32_context_get_bl2_low_power_params(uintptr_t *bl2_code_base,
+					    uintptr_t *bl2_code_end,
+					    uintptr_t *bl2_end);
+void stm32_context_save_bl2_param(void);
+uint32_t stm32_get_zdata_from_context(void);
+int stm32_get_pll1_settings_from_context(void);
+bool stm32_are_pll1_settings_valid_in_context(void);
+bool stm32_pm_context_is_valid(void);
+void stm32_save_ddr_training_area(void);
+void stm32_restore_ddr_training_area(void);
+uint32_t stm32_pm_get_optee_ep(void);
+#if STM32MP13
+void stm32mp1_pm_save_mce_mkey_in_context(uint8_t *data);
+void stm32mp1_pm_get_mce_mkey_from_context(uint8_t *data);
+void stm32mp1_pm_save_mce_region(uint32_t index, struct stm32_mce_region_s *config);
+void stm32mp1_pm_get_mce_region(uint32_t index, struct stm32_mce_region_s *config);
+#endif
+
+void stm32mp1_pm_save_clock_cfg(size_t offset, uint8_t *data, size_t size);
+void stm32mp1_pm_restore_clock_cfg(size_t offset, uint8_t *data, size_t size);
 
 #endif /* STM32MP1_CONTEXT_H */
diff --git a/plat/st/stm32mp1/include/stm32mp1_critic_power.h b/plat/st/stm32mp1/include/stm32mp1_critic_power.h
new file mode 100644
index 000000000..619d8c61a
--- /dev/null
+++ b/plat/st/stm32mp1/include/stm32mp1_critic_power.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2019-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP1_CRITIC_POWER_H
+#define STM32MP1_CRITIC_POWER_H
+
+ /* Only BL32 compilation unit need stm32_pwr_down_wfi
+  * function/variable symbol
+  */
+#if defined(IMAGE_BL32)
+extern void stm32_pwr_down_wfi(bool is_cstop, uint32_t mode);
+#endif
+extern void stm32_pwr_down_wfi_wrapper(bool is_cstop, uint32_t mode);
+extern void stm32_pwr_back_from_stop2(void);
+void stm32_pwr_down_wfi_load(bool is_cstop, uint32_t mode);
+void stm32_pwr_call_optee_ep(void);
+void stm32_pwr_cstop_critic_exit(void);
+
+#endif /* STM32MP1_CRITIC_POWER_H */
diff --git a/plat/st/stm32mp1/include/stm32mp1_dbgmcu.h b/plat/st/stm32mp1/include/stm32mp1_dbgmcu.h
index 498a4f210..3663bce67 100644
--- a/plat/st/stm32mp1/include/stm32mp1_dbgmcu.h
+++ b/plat/st/stm32mp1/include/stm32mp1_dbgmcu.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2019, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2015-2021, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -13,11 +13,4 @@
 int stm32mp1_dbgmcu_get_chip_version(uint32_t *chip_version);
 int stm32mp1_dbgmcu_get_chip_dev_id(uint32_t *chip_dev_id);
 
-/*
- * Freeze watchdog when a debugger is attached, if the security configuration
- * allows it.
- * Return 0 on success, a negative error value otherwise.
- */
-int stm32mp1_dbgmcu_freeze_iwdg2(void);
-
 #endif /* STM32MP1_DBGMCU_H */
diff --git a/plat/st/stm32mp1/include/stm32mp1_low_power.h b/plat/st/stm32mp1/include/stm32mp1_low_power.h
new file mode 100644
index 000000000..79ae3bfc9
--- /dev/null
+++ b/plat/st/stm32mp1/include/stm32mp1_low_power.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2017-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP1_LOW_POWER_H
+#define STM32MP1_LOW_POWER_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include <stm32mp1_critic_power.h>
+
+void stm32_rcc_wakeup_update(bool state);
+void stm32_apply_pmic_suspend_config(uint32_t mode);
+bool stm32_is_cstop_done(void);
+void stm32_exit_cstop(void);
+void stm32_enter_low_power(uint32_t mode, uint32_t nsec_addr);
+void stm32_auto_stop(void);
+void stm32_init_low_power(void);
+
+#endif /* STM32MP1_LOW_POWER_H */
diff --git a/plat/st/stm32mp1/include/stm32mp1_power_config.h b/plat/st/stm32mp1/include/stm32mp1_power_config.h
new file mode 100644
index 000000000..37312c8de
--- /dev/null
+++ b/plat/st/stm32mp1/include/stm32mp1_power_config.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2017-2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP1_POWER_CONFIG_H
+#define STM32MP1_POWER_CONFIG_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#define PSCI_MODE_SYSTEM_SUSPEND	0
+#define PSCI_MODE_SYSTEM_OFF		1
+
+enum stm32mp1_pm_domain {
+	STM32MP1_PD_VSW,
+	STM32MP1_PD_CORE_RET,
+	STM32MP1_PD_CORE,
+	STM32MP1_PD_MAX_PM_DOMAIN
+};
+
+void stm32mp1_init_lp_states(void);
+int stm32mp1_set_pm_domain_state(enum stm32mp1_pm_domain domain, bool status);
+uint32_t stm32mp1_get_lp_soc_mode(uint32_t psci_mode);
+int stm32mp1_set_lp_deepest_soc_mode(uint32_t psci_mode, uint32_t soc_mode);
+bool stm32mp1_get_retram_enabled(void);
+
+#endif /* STM32MP1_POWER_CONFIG_H */
diff --git a/plat/st/stm32mp1/include/stm32mp1_private.h b/plat/st/stm32mp1/include/stm32mp1_private.h
index 729d2336b..73222815c 100644
--- a/plat/st/stm32mp1/include/stm32mp1_private.h
+++ b/plat/st/stm32mp1/include/stm32mp1_private.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2021, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -9,21 +9,45 @@
 
 #include <stdint.h>
 
+#include <drivers/st/etzpc.h>
+
 void configure_mmu(void);
 
+void stm32mp_mask_timer(void);
+void __dead2 stm32mp_wait_cpu_reset(void);
+
 void stm32mp1_arch_security_setup(void);
 void stm32mp1_security_setup(void);
 
-void stm32mp1_gic_pcpu_init(void);
-void stm32mp1_gic_init(void);
+bool stm32mp1_addr_inside_backupsram(uintptr_t addr);
+bool stm32mp1_is_wakeup_from_standby(void);
+
+#if defined(IMAGE_BL32)
+enum etzpc_decprot_attributes stm32mp_etzpc_binding2decprot(uint32_t mode);
+#endif
 
 void stm32mp1_syscfg_init(void);
-void stm32mp1_syscfg_enable_io_compensation(void);
+void stm32mp1_syscfg_enable_io_compensation_start(void);
+void stm32mp1_syscfg_enable_io_compensation_finish(void);
 void stm32mp1_syscfg_disable_io_compensation(void);
-
-#if STM32MP_USE_STM32IMAGE
-uint32_t stm32mp_get_ddr_ns_size(void);
-#endif /* STM32MP_USE_STM32IMAGE */
+uint32_t stm32mp1_syscfg_get_chip_version(void);
+uint32_t stm32mp1_syscfg_get_chip_dev_id(void);
+#if STM32MP13
+void stm32mp1_syscfg_boot_mode_enable(void);
+void stm32mp1_syscfg_boot_mode_disable(void);
+#endif
+#if STM32MP15
+static inline void stm32mp1_syscfg_boot_mode_enable(void){}
+static inline void stm32mp1_syscfg_boot_mode_disable(void){}
+#endif
+
+void stm32mp1_deconfigure_uart_pins(void);
 
 void stm32mp1_init_scmi_server(void);
+void stm32mp1_pm_save_scmi_state(uint8_t *state, size_t size);
+void stm32mp1_pm_restore_scmi_state(uint8_t *state, size_t size);
+
+#if defined(IMAGE_BL32) && DEBUG
+void stm32mp_dump_core_registers(bool fcore);
+#endif
 #endif /* STM32MP1_PRIVATE_H */
diff --git a/plat/st/stm32mp1/include/stm32mp1_shared_resources.h b/plat/st/stm32mp1/include/stm32mp1_shared_resources.h
index 3f6367ebe..519a67bad 100644
--- a/plat/st/stm32mp1/include/stm32mp1_shared_resources.h
+++ b/plat/st/stm32mp1/include/stm32mp1_shared_resources.h
@@ -7,6 +7,8 @@
 #ifndef STM32MP1_SHARED_RESOURCES_H
 #define STM32MP1_SHARED_RESOURCES_H
 
+#include <drivers/st/etzpc.h>
+
 #include <stm32mp_shared_resources.h>
 
 #define STM32MP1_SHRES_GPIOZ(i)		(STM32MP1_SHRES_GPIOZ_0 + (i))
@@ -35,4 +37,19 @@ enum stm32mp_shres {
 
 	STM32MP1_SHRES_COUNT
 };
+
+#ifdef STM32MP_SHARED_RESOURCES
+/*
+ * Register a (non-)secure peripheral based on the ETZPC DECPROT configuration
+ */
+void stm32mp1_register_etzpc_decprot(unsigned int id,
+				     enum etzpc_decprot_attributes attr);
+#else
+static inline
+void stm32mp1_register_etzpc_decprot(unsigned int id,
+				     enum etzpc_decprot_attributes attr)
+{
+}
+#endif
+
 #endif /* STM32MP1_SHARED_RESOURCES_H */
diff --git a/plat/st/stm32mp1/include/stm32mp1_smc.h b/plat/st/stm32mp1/include/stm32mp1_smc.h
index 52088de28..d75b75c6f 100644
--- a/plat/st/stm32mp1/include/stm32mp1_smc.h
+++ b/plat/st/stm32mp1/include/stm32mp1_smc.h
@@ -17,6 +17,39 @@
 
 /* Secure Service access from Non-secure */
 
+/*
+ * SMC function STM32_SMC_RCC.
+ *
+ * Argument a0: (input) SMCC ID.
+ *		(output) Status return code.
+ * Argument a1: (input) Service ID (STM32_SMC_REG_xxx).
+ * Argument a2: (input) Register offset or physical address.
+ *		(output) Register read value, if applicable.
+ * Argument a3: (input) Register target value if applicable.
+ */
+#define STM32_SMC_RCC			0x82001000
+
+/*
+ * SMC function STM32_SMC_PWR.
+ *
+ * Argument a0: (input) SMCC ID.
+ *		(output) Status return code.
+ * Argument a1: (input) Service ID (STM32_SMC_REG_xxx).
+ * Argument a2: (input) Register offset or physical address.
+ *		(output) Register read value, if applicable.
+ * Argument a3: (input) Register target value if applicable.
+ */
+#define STM32_SMC_PWR			0x82001001
+
+/*
+ * SMC functions STM32_SMC_RCC_CAL.
+ *
+ * Argument a0: (input) SMCC ID.
+ *		(output) Status return code.
+ * Argument a1: (input) Clock ID (from DT clock bindings).
+ */
+#define STM32_SMC_RCC_CAL		0x82001002
+
 /*
  * STM32_SMC_BSEC call API
  *
@@ -29,6 +62,26 @@
  */
 #define STM32_SMC_BSEC			0x82001003
 
+/* Low Power services */
+
+/*
+ * SIP function STM32_SMC_PD_DOMAIN.
+ *
+ * Argument a0: (input) SMCC ID.
+ *		(output) Status return code.
+ * Argument a2: (index) ID of target power domain to be enabled/disabled.
+ * Argument a3: (input) 0 to disable, 1 to enable target domain.
+ */
+#define STM32_SMC_PD_DOMAIN		0x82001008
+
+/*
+ * SIP function STM32_SMC_AUTO_STOP - CPU auto stop for OS driver suspend
+ *
+ * Argument a0: (input) This SMCC ID: STM32_SMC_AUTO_STOP
+ *		(output) Status return code.
+ */
+#define STM32_SMC_AUTO_STOP		0x8200100a
+
 /*
  * STM32_SIP_SMC_SCMI_AGENT0
  * STM32_SIP_SMC_SCMI_AGENT1
@@ -39,29 +92,22 @@
 #define STM32_SIP_SMC_SCMI_AGENT0	0x82002000
 #define STM32_SIP_SMC_SCMI_AGENT1	0x82002001
 
-/* SMC function IDs for SiP Service queries */
-#define STM32_SIP_SVC_CALL_COUNT	0x8200ff00
-#define STM32_SIP_SVC_UID		0x8200ff01
-/*					0x8200ff02 is reserved */
-#define STM32_SIP_SVC_VERSION		0x8200ff03
-
-/* STM32 SiP Service Calls version numbers */
-#define STM32_SIP_SVC_VERSION_MAJOR	0x0
-#define STM32_SIP_SVC_VERSION_MINOR	0x1
-
 /* Number of STM32 SiP Calls implemented */
-#define STM32_COMMON_SIP_NUM_CALLS	3
+#define STM32_COMMON_SIP_NUM_CALLS	8
+
+/* Service ID for STM32_SMC_RCC/_PWR */
+#define STM32_SMC_REG_READ		0x0
+#define STM32_SMC_REG_WRITE		0x1
+#define STM32_SMC_REG_SET		0x2
+#define STM32_SMC_REG_CLEAR		0x3
 
 /* Service for BSEC */
 #define STM32_SMC_READ_SHADOW		0x01
 #define STM32_SMC_PROG_OTP		0x02
 #define STM32_SMC_WRITE_SHADOW		0x03
 #define STM32_SMC_READ_OTP		0x04
-
-/* SMC error codes */
-#define STM32_SMC_OK			0x00000000U
-#define STM32_SMC_NOT_SUPPORTED		0xFFFFFFFFU
-#define STM32_SMC_FAILED		0xFFFFFFFEU
-#define STM32_SMC_INVALID_PARAMS	0xFFFFFFFDU
+#define STM32_SMC_READ_ALL		0x05
+#define STM32_SMC_WRITE_ALL		0x06
+#define STM32_SMC_WRLOCK_OTP		0x07
 
 #endif /* STM32MP1_SMC_H */
diff --git a/plat/st/stm32mp1/include/tbbr/stm32mp1_tbb_cert.h b/plat/st/stm32mp1/include/tbbr/stm32mp1_tbb_cert.h
new file mode 100644
index 000000000..2cc1e19e4
--- /dev/null
+++ b/plat/st/stm32mp1/include/tbbr/stm32mp1_tbb_cert.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP1_TBB_CERT_H
+#define STM32MP1_TBB_CERT_H
+
+#include <tbbr/tbb_cert.h>
+
+/*
+ * Enumerate the certificates that are used to establish the chain of trust
+ */
+enum {
+	STM32MP_CONFIG_CERT = FWU_CERT + 1
+};
+
+#endif /* STM32MP1_TBB_CERT_H */
diff --git a/plat/st/stm32mp1/plat_bl2_mem_params_desc.c b/plat/st/stm32mp1/plat_bl2_mem_params_desc.c
index 7963c4a97..9f1a3e588 100644
--- a/plat/st/stm32mp1/plat_bl2_mem_params_desc.c
+++ b/plat/st/stm32mp1/plat_bl2_mem_params_desc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2016-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -68,6 +68,7 @@ static bl_mem_params_node_t bl2_mem_params_descs[] = {
 
 		.next_handoff_image_id = INVALID_IMAGE_ID,
 	},
+#if STM32MP15
 	/* Fill BL32 external 2 image related information */
 	{
 		.image_id = BL32_EXTRA2_IMAGE_ID,
@@ -82,6 +83,7 @@ static bl_mem_params_node_t bl2_mem_params_descs[] = {
 
 		.next_handoff_image_id = INVALID_IMAGE_ID,
 	},
+#endif
 
 	/* Fill HW_CONFIG related information if it exists */
 	{
@@ -117,7 +119,11 @@ static bl_mem_params_node_t bl2_mem_params_descs[] = {
 				      VERSION_2, entry_point_info_t,
 				      NON_SECURE | EXECUTABLE),
 
+#if BL33_HYP
+		.ep_info.spsr = SPSR_MODE32(MODE32_hyp, SPSR_T_ARM,
+#else
 		.ep_info.spsr = SPSR_MODE32(MODE32_svc, SPSR_T_ARM,
+#endif
 					    SPSR_E_LITTLE,
 					    DISABLE_ALL_EXCEPTIONS),
 
diff --git a/plat/st/stm32mp1/plat_def_uuid_config.c b/plat/st/stm32mp1/plat_def_uuid_config.c
new file mode 100644
index 000000000..efaf56701
--- /dev/null
+++ b/plat/st/stm32mp1/plat_def_uuid_config.c
@@ -0,0 +1,18 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <firmware_image_package.h>
+
+#include "tbbr_config.h"
+
+toc_entry_t plat_def_toc_entries[] = {
+	{
+		.name = "STM32MP CONFIG CERT",
+		.uuid = UUID_STM32MP_CONFIG_CERT,
+		.cmdline_name = "stm32mp-cfg-cert"
+	}
+};
+
diff --git a/plat/st/stm32mp1/plat_fiptool.mk b/plat/st/stm32mp1/plat_fiptool.mk
new file mode 100644
index 000000000..00570c2b3
--- /dev/null
+++ b/plat/st/stm32mp1/plat_fiptool.mk
@@ -0,0 +1,25 @@
+#
+# Copyright (c) 2021-2022, STMicroelectronics - All Rights Reserved
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+# Name of the platform defined source file name,
+# which contains platform defined UUID entries populated
+# in the plat_def_toc_entries[].
+PLAT_DEF_UUID_FILE_NAME	:= plat_def_uuid_config
+
+INCLUDE_PATHS		+= -I${PLAT_DIR}/include -I./
+
+PLAT_DEF_UUID		:= yes
+
+ifeq (${PLAT_DEF_UUID},yes)
+HOSTCCFLAGS += -DPLAT_DEF_FIP_UUID
+
+${PLAT_DEF_UUID_FILE_NAME}.o: ${PLAT_DIR}${PLAT_DEF_UUID_FILE_NAME}.c
+	${HOSTCC} -c ${CPPFLAGS} ${HOSTCCFLAGS} ${INCLUDE_PATHS} $< -o $@
+
+PLAT_OBJECTS += ${PLAT_DEF_UUID_FILE_NAME}.o
+endif
+
+OBJECTS += ${PLAT_OBJECTS}
diff --git a/plat/st/stm32mp1/plat_image_load.c b/plat/st/stm32mp1/plat_image_load.c
index 36a3a1c39..26564e49a 100644
--- a/plat/st/stm32mp1/plat_image_load.c
+++ b/plat/st/stm32mp1/plat_image_load.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2016-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -23,15 +23,6 @@ void plat_flush_next_bl_params(void)
  ******************************************************************************/
 bl_load_info_t *plat_get_bl_image_load_info(void)
 {
-#if STM32MP_USE_STM32IMAGE
-	bl_mem_params_node_t *bl33 = get_bl_mem_params_node(BL33_IMAGE_ID);
-	uint32_t ddr_ns_size = stm32mp_get_ddr_ns_size();
-
-	/* Max size is non-secure DDR end address minus image_base */
-	bl33->image_info.image_max_size = STM32MP_DDR_BASE + ddr_ns_size -
-					  bl33->image_info.image_base;
-#endif /* STM32MP_USE_STM32IMAGE */
-
 	return get_bl_load_info_from_mem_params_desc();
 }
 
diff --git a/plat/st/stm32mp1/platform.mk b/plat/st/stm32mp1/platform.mk
index badc926c0..39984ffe0 100644
--- a/plat/st/stm32mp1/platform.mk
+++ b/plat/st/stm32mp1/platform.mk
@@ -1,27 +1,71 @@
 #
-# Copyright (c) 2015-2021, ARM Limited and Contributors. All rights reserved.
+# Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
 #
 # SPDX-License-Identifier: BSD-3-Clause
 #
 
+include plat/st/common/common.mk
+
 ARM_CORTEX_A7		:=	yes
 ARM_WITH_NEON		:=	yes
-BL2_AT_EL3		:=	1
 USE_COHERENT_MEM	:=	0
 
-# Allow TF-A to concatenate BL2 & BL32 binaries in a single file,
-# share DTB file between BL2 and BL32
-# If it is set to 0, then FIP is used
-STM32MP_USE_STM32IMAGE	?=	0
+STM32MP_USE_EXTERNAL_HEAP ?=	0
+
+# Default Device tree
+DTB_FILE_NAME		?=	stm32mp157c-ev1.dtb
+
+STM32MP13		?=	0
+STM32MP15		?=	0
+
+ifeq ($(STM32MP13),1)
+ifeq ($(STM32MP15),1)
+$(error Cannot enable both flags STM32MP13 and STM32MP15)
+endif
+STM32MP13		:=	1
+STM32MP15		:=	0
+else ifeq ($(STM32MP15),1)
+STM32MP13		:=	0
+STM32MP15		:=	1
+else ifneq ($(findstring stm32mp13,$(DTB_FILE_NAME)),)
+STM32MP13		:=	1
+STM32MP15		:=	0
+else ifneq ($(findstring stm32mp15,$(DTB_FILE_NAME)),)
+STM32MP13		:=	0
+STM32MP15		:=	1
+endif
+
+ifeq ($(STM32MP13),1)
+# Will use SRAM2 as mbedtls heap
+STM32MP_USE_EXTERNAL_HEAP :=	1
 
-ifneq ($(STM32MP_USE_STM32IMAGE),1)
-ENABLE_PIE		:=	1
+# DDR controller with single AXI port and 16-bit interface
+STM32MP_DDR_DUAL_AXI_PORT:=	0
+STM32MP_DDR_32BIT_INTERFACE:=	0
+
+ifeq (${TRUSTED_BOARD_BOOT},1)
+# PKA algo to include
+PKA_USE_NIST_P256	:=	1
+PKA_USE_BRAINPOOL_P256T1:=	1
 endif
 
-STM32_TF_VERSION	?=	0
+# STM32 image header version v2.0
+STM32_HEADER_VERSION_MAJOR:=	2
+STM32_HEADER_VERSION_MINOR:=	0
+endif
 
-# Enable dynamic memory mapping
-PLAT_XLAT_TABLES_DYNAMIC :=	1
+ifeq ($(STM32MP15),1)
+# DDR controller with dual AXI port and 32-bit interface
+STM32MP_DDR_DUAL_AXI_PORT:=	1
+STM32MP_DDR_32BIT_INTERFACE:=	1
+
+# STM32 image header version v1.0
+STM32_HEADER_VERSION_MAJOR:=	1
+STM32_HEADER_VERSION_MINOR:=	0
+endif
+
+# STM32 Secure Secret Provisioning mode (SSP)
+STM32MP_SSP		?=	0
 
 ifeq ($(AARCH32_SP),sp_min)
 # Disable Neon support: sp_min runtime may conflict with non-secure world
@@ -31,41 +75,42 @@ endif
 # Not needed for Cortex-A7
 WORKAROUND_CVE_2017_5715:=	0
 
+AARCH32_EXCEPTION_DEBUG	:=	1
+
 # Number of TF-A copies in the device
 STM32_TF_A_COPIES		:=	2
-STM32_BL33_PARTS_NUM		:=	1
-ifeq ($(AARCH32_SP),optee)
-STM32_RUNTIME_PARTS_NUM		:=	3
-else ifeq ($(STM32MP_USE_STM32IMAGE),1)
-STM32_RUNTIME_PARTS_NUM		:=	0
-else
-STM32_RUNTIME_PARTS_NUM		:=	1
+
+# PLAT_PARTITION_MAX_ENTRIES must take care of STM32_TF-A_COPIES and other partitions
+# such as metadata (2) to find all the FIP partitions (default is 2).
+PLAT_PARTITION_MAX_ENTRIES	:=	$(shell echo $$(($(STM32_TF_A_COPIES) + 4)))
+
+ifeq (${PSA_FWU_SUPPORT},1)
+# Number of banks of updatable firmware
+NR_OF_FW_BANKS			:=	2
+NR_OF_IMAGES_IN_FW_BANK		:=	1
+JSON_METADATA			?=	plat/st/stm32mp1/default_metadata.json
+STM32_DEPS			+=	${BUILD_PLAT}/metadata.bin
+
+$(eval $(call GEN_METADATA,${JSON_METADATA},${BUILD_PLAT}/metadata.bin))
+
+FWU_MAX_PART = $(shell echo $$(($(STM32_TF_A_COPIES) + 2 + $(NR_OF_FW_BANKS))))
+ifeq ($(shell test $(FWU_MAX_PART) -gt $(PLAT_PARTITION_MAX_ENTRIES); echo $$?),0)
+$(error "Required partition number is $(FWU_MAX_PART) where PLAT_PARTITION_MAX_ENTRIES is only \
+$(PLAT_PARTITION_MAX_ENTRIES)")
+endif
 endif
-PLAT_PARTITION_MAX_ENTRIES	:=	$(shell echo $$(($(STM32_TF_A_COPIES) + \
-							 $(STM32_BL33_PARTS_NUM) + \
-							 $(STM32_RUNTIME_PARTS_NUM))))
 
-# Boot devices
-STM32MP_EMMC		?=	0
-STM32MP_SDMMC		?=	0
-STM32MP_RAW_NAND	?=	0
-STM32MP_SPI_NAND	?=	0
-STM32MP_SPI_NOR		?=	0
-STM32MP_EMMC_BOOT	?=	0
+# Download load address for serial boot devices
+DWL_BUFFER_BASE 	?=	0xC7000000
 
-# Serial boot devices
-STM32MP_USB_PROGRAMMER	?=	0
+# Hypervisor mode
+BL33_HYP			?= 0
 
 # Device tree
-DTB_FILE_NAME		?=	stm32mp157c-ev1.dtb
-ifeq ($(STM32MP_USE_STM32IMAGE),1)
-ifeq ($(AARCH32_SP),optee)
-BL2_DTSI		:=	stm32mp15-bl2.dtsi
+ifeq ($(STM32MP13),1)
+BL2_DTSI		:=	stm32mp13-bl2.dtsi
 FDT_SOURCES		:=	$(addprefix ${BUILD_PLAT}/fdts/, $(patsubst %.dtb,%-bl2.dts,$(DTB_FILE_NAME)))
 else
-FDT_SOURCES		:=	$(addprefix fdts/, $(patsubst %.dtb,%.dts,$(DTB_FILE_NAME)))
-endif
-else
 BL2_DTSI		:=	stm32mp15-bl2.dtsi
 FDT_SOURCES		:=	$(addprefix ${BUILD_PLAT}/fdts/, $(patsubst %.dtb,%-bl2.dts,$(DTB_FILE_NAME)))
 ifeq ($(AARCH32_SP),sp_min)
@@ -73,29 +118,18 @@ BL32_DTSI		:=	stm32mp15-bl32.dtsi
 FDT_SOURCES		+=	$(addprefix ${BUILD_PLAT}/fdts/, $(patsubst %.dtb,%-bl32.dts,$(DTB_FILE_NAME)))
 endif
 endif
-DTC_CPPFLAGS		+=	${INCLUDES}
-DTC_FLAGS		+=	-Wno-unit_address_vs_reg
 
 # Macros and rules to build TF binary
-STM32_TF_ELF_LDFLAGS	:=	--hash-style=gnu --as-needed
 STM32_TF_STM32		:=	$(addprefix ${BUILD_PLAT}/tf-a-, $(patsubst %.dtb,%.stm32,$(DTB_FILE_NAME)))
-STM32_TF_LINKERFILE	:=	${BUILD_PLAT}/stm32mp1.ld
+STM32_LD_FILE		:=	plat/st/stm32mp1/stm32mp1.ld.S
+STM32_BINARY_MAPPING	:=	plat/st/stm32mp1/stm32mp1.S
 
-ASFLAGS			+= -DBL2_BIN_PATH=\"${BUILD_PLAT}/bl2.bin\"
 ifeq ($(AARCH32_SP),sp_min)
 # BL32 is built only if using SP_MIN
 BL32_DEP		:= bl32
 ASFLAGS			+= -DBL32_BIN_PATH=\"${BUILD_PLAT}/bl32.bin\"
 endif
 
-# Variables for use with stm32image
-STM32IMAGEPATH		?= tools/stm32image
-STM32IMAGE		?= ${STM32IMAGEPATH}/stm32image${BIN_EXT}
-STM32IMAGE_SRC		:= ${STM32IMAGEPATH}/stm32image.c
-
-ifneq (${STM32MP_USE_STM32IMAGE},1)
-FIP_DEPS		+=	dtbs
-STM32MP_HW_CONFIG	:=	${BL33_CFG}
 STM32MP_FW_CONFIG_NAME	:=	$(patsubst %.dtb,%-fw-config.dtb,$(DTB_FILE_NAME))
 STM32MP_FW_CONFIG	:=	${BUILD_PLAT}/fdts/$(STM32MP_FW_CONFIG_NAME)
 ifneq (${AARCH32_SP},none)
@@ -103,72 +137,56 @@ FDT_SOURCES		+=	$(addprefix fdts/, $(patsubst %.dtb,%.dts,$(STM32MP_FW_CONFIG_NA
 endif
 # Add the FW_CONFIG to FIP and specify the same to certtool
 $(eval $(call TOOL_ADD_PAYLOAD,${STM32MP_FW_CONFIG},--fw-config))
-# Add the HW_CONFIG to FIP and specify the same to certtool
-$(eval $(call TOOL_ADD_PAYLOAD,${STM32MP_HW_CONFIG},--hw-config))
+ifeq ($(GENERATE_COT),1)
+STM32MP_CFG_CERT	:=	$(BUILD_PLAT)/stm32mp_cfg_cert.crt
+# Add the STM32MP_CFG_CERT to FIP and specify the same to certtool
+$(eval $(call TOOL_ADD_PAYLOAD,${STM32MP_CFG_CERT},--stm32mp-cfg-cert))
+endif
 ifeq ($(AARCH32_SP),sp_min)
 STM32MP_TOS_FW_CONFIG	:= $(addprefix ${BUILD_PLAT}/fdts/, $(patsubst %.dtb,%-bl32.dtb,$(DTB_FILE_NAME)))
 $(eval $(call TOOL_ADD_PAYLOAD,${STM32MP_TOS_FW_CONFIG},--tos-fw-config))
-else
-# Add the build options to pack Trusted OS Extra1 and Trusted OS Extra2 images
-# in the FIP if the platform requires.
-ifneq ($(BL32_EXTRA1),)
-$(eval $(call TOOL_ADD_IMG,BL32_EXTRA1,--tos-fw-extra1))
-endif
-ifneq ($(BL32_EXTRA2),)
-$(eval $(call TOOL_ADD_IMG,BL32_EXTRA2,--tos-fw-extra2))
-endif
-endif
 endif
 
 # Enable flags for C files
 $(eval $(call assert_booleans,\
 	$(sort \
-		STM32MP_EMMC \
-		STM32MP_SDMMC \
-		STM32MP_RAW_NAND \
-		STM32MP_SPI_NAND \
-		STM32MP_SPI_NOR \
-		STM32MP_EMMC_BOOT \
-		PLAT_XLAT_TABLES_DYNAMIC \
-		STM32MP_USB_PROGRAMMER \
-		STM32MP_USE_STM32IMAGE \
+		BL33_HYP \
+		PKA_USE_BRAINPOOL_P256T1 \
+		PKA_USE_NIST_P256 \
+		STM32MP_DDR_32BIT_INTERFACE \
+		STM32MP_DDR_DUAL_AXI_PORT \
+		STM32MP_SSP \
+		STM32MP_USE_EXTERNAL_HEAP \
+		STM32MP13 \
+		STM32MP15 \
 )))
 
 $(eval $(call assert_numerics,\
 	$(sort \
-		STM32_TF_A_COPIES \
 		PLAT_PARTITION_MAX_ENTRIES \
+		STM32_TF_A_COPIES \
 )))
 
 $(eval $(call add_defines,\
 	$(sort \
-		STM32MP_EMMC \
-		STM32MP_SDMMC \
-		STM32MP_RAW_NAND \
-		STM32MP_SPI_NAND \
-		STM32MP_SPI_NOR \
-		STM32MP_EMMC_BOOT \
-		PLAT_XLAT_TABLES_DYNAMIC \
-		STM32_TF_A_COPIES \
+		BL33_HYP \
+		DWL_BUFFER_BASE \
+		PKA_USE_BRAINPOOL_P256T1 \
+		PKA_USE_NIST_P256 \
 		PLAT_PARTITION_MAX_ENTRIES \
-		STM32MP_USB_PROGRAMMER \
-		STM32MP_USE_STM32IMAGE \
+		STM32_TF_A_COPIES \
+		STM32MP_DDR_32BIT_INTERFACE \
+		STM32MP_DDR_DUAL_AXI_PORT \
+		STM32MP_SSP \
+		STM32MP_USE_EXTERNAL_HEAP \
+		STM32MP13 \
+		STM32MP15 \
 )))
 
 # Include paths and source files
-PLAT_INCLUDES		:=	-Iplat/st/common/include/
 PLAT_INCLUDES		+=	-Iplat/st/stm32mp1/include/
 
-ifeq (${STM32MP_USE_STM32IMAGE},1)
-include common/fdt_wrappers.mk
-else
-include lib/fconf/fconf.mk
-endif
-include lib/libfdt/libfdt.mk
-
-PLAT_BL_COMMON_SOURCES	:=	common/uuid.c						\
-				plat/st/common/stm32mp_common.c				\
-				plat/st/stm32mp1/stm32mp1_private.c
+PLAT_BL_COMMON_SOURCES	+=	plat/st/stm32mp1/stm32mp1_private.c
 
 PLAT_BL_COMMON_SOURCES	+=	drivers/st/uart/aarch32/stm32_console.S
 
@@ -176,159 +194,126 @@ ifneq (${ENABLE_STACK_PROTECTOR},0)
 PLAT_BL_COMMON_SOURCES	+=	plat/st/stm32mp1/stm32mp1_stack_protector.c
 endif
 
-include lib/xlat_tables_v2/xlat_tables.mk
-PLAT_BL_COMMON_SOURCES	+=	${XLAT_TABLES_LIB_SRCS}
-
 PLAT_BL_COMMON_SOURCES	+=	lib/cpus/aarch32/cortex_a7.S
 
 PLAT_BL_COMMON_SOURCES	+=	drivers/arm/tzc/tzc400.c				\
-				drivers/delay_timer/delay_timer.c			\
-				drivers/delay_timer/generic_delay_timer.c		\
-				drivers/st/bsec/bsec.c					\
-				drivers/st/clk/stm32mp_clkfunc.c			\
-				drivers/st/clk/stm32mp1_clk.c				\
+				drivers/st/bsec/bsec2.c					\
 				drivers/st/ddr/stm32mp1_ddr_helpers.c			\
-				drivers/st/gpio/stm32_gpio.c				\
 				drivers/st/i2c/stm32_i2c.c				\
 				drivers/st/iwdg/stm32_iwdg.c				\
-				drivers/st/pmic/stm32mp_pmic.c				\
 				drivers/st/pmic/stpmic1.c				\
 				drivers/st/reset/stm32mp1_reset.c			\
-				plat/st/common/stm32mp_dt.c				\
 				plat/st/stm32mp1/stm32mp1_context.c			\
 				plat/st/stm32mp1/stm32mp1_dbgmcu.c			\
 				plat/st/stm32mp1/stm32mp1_helper.S			\
 				plat/st/stm32mp1/stm32mp1_syscfg.c
 
-ifneq (${STM32MP_USE_STM32IMAGE},1)
-BL2_SOURCES		+=	${FCONF_SOURCES} ${FCONF_DYN_SOURCES}
+ifeq ($(STM32MP13),1)
+PLAT_BL_COMMON_SOURCES	+=	drivers/st/clk/clk-stm32-core.c				\
+				drivers/st/clk/clk-stm32mp13.c				\
+				drivers/st/rng/stm32_rng.c
+else
+PLAT_BL_COMMON_SOURCES	+=	drivers/st/clk/stm32mp1_clk.c
+endif
 
-BL2_SOURCES		+=	drivers/io/io_fip.c					\
-				plat/st/common/bl2_io_storage.c				\
-				plat/st/common/stm32mp_fconf_io.c			\
-				plat/st/stm32mp1/plat_bl2_mem_params_desc.c		\
+BL2_SOURCES		+=	plat/st/stm32mp1/plat_bl2_mem_params_desc.c		\
 				plat/st/stm32mp1/stm32mp1_fconf_firewall.c
-else
-BL2_SOURCES		+=	${FDT_WRAPPERS_SOURCES}
 
-BL2_SOURCES		+=	drivers/io/io_dummy.c					\
-				drivers/st/io/io_stm32image.c				\
-				plat/st/common/bl2_stm32_io_storage.c			\
-				plat/st/stm32mp1/plat_bl2_stm32_mem_params_desc.c	\
-				plat/st/stm32mp1/stm32mp1_security.c
+ifeq (${PSA_FWU_SUPPORT},1)
+include lib/zlib/zlib.mk
+include drivers/fwu/fwu.mk
+
+BL2_SOURCES		+=	$(ZLIB_SOURCES)
 endif
 
-BL2_SOURCES		+=	drivers/io/io_block.c					\
-				drivers/io/io_mtd.c					\
-				drivers/io/io_storage.c					\
-				drivers/st/crypto/stm32_hash.c				\
-				plat/st/common/stm32mp_auth.c				\
+BL2_SOURCES		+=	drivers/st/crypto/stm32_hash.c				\
 				plat/st/stm32mp1/bl2_plat_setup.c
 
-ifneq ($(filter 1,${STM32MP_EMMC} ${STM32MP_SDMMC}),)
-BL2_SOURCES		+=	drivers/mmc/mmc.c					\
-				drivers/partition/gpt.c					\
-				drivers/partition/partition.c				\
-				drivers/st/io/io_mmc.c					\
-				drivers/st/mmc/stm32_sdmmc2.c
+ifneq (${DECRYPTION_SUPPORT},none)
+BL2_SOURCES		+=	drivers/io/io_encrypted.c
 endif
 
-ifeq (${STM32MP_RAW_NAND},1)
-$(eval $(call add_define_val,NAND_ONFI_DETECT,1))
-BL2_SOURCES		+=	drivers/mtd/nand/raw_nand.c				\
-				drivers/st/fmc/stm32_fmc2_nand.c
+ifeq ($(STM32MP13),1)
+BL2_SOURCES		+=	drivers/st/mce/stm32_mce.c
 endif
 
-ifeq (${STM32MP_SPI_NAND},1)
-BL2_SOURCES		+=	drivers/mtd/nand/spi_nand.c
+ifeq (${TRUSTED_BOARD_BOOT},1)
+AUTH_SOURCES		:=	drivers/auth/auth_mod.c					\
+				drivers/auth/crypto_mod.c				\
+				drivers/auth/img_parser_mod.c
+
+ifeq (${GENERATE_COT},1)
+TFW_NVCTR_VAL		:=	0
+NTFW_NVCTR_VAL		:=	0
+KEY_SIZE		:=
+KEY_ALG			:=	ecdsa
+HASH_ALG		:=	sha256
+
+ifeq (${SAVE_KEYS},1)
+TRUSTED_WORLD_KEY	?=	${BUILD_PLAT}/trusted.pem
+NON_TRUSTED_WORLD_KEY	?=	${BUILD_PLAT}/non-trusted.pem
+BL32_KEY		?=	${BUILD_PLAT}/trusted_os.pem
+BL33_KEY		?=	${BUILD_PLAT}/non-trusted_os.pem
 endif
 
-ifeq (${STM32MP_SPI_NOR},1)
-BL2_SOURCES		+=	drivers/mtd/nor/spi_nor.c
 endif
+TF_MBEDTLS_KEY_ALG 	:=	ecdsa
+MBEDTLS_CONFIG_FILE	?=	"<stm32mp15_mbedtls_config.h>"
 
-ifneq ($(filter 1,${STM32MP_SPI_NAND} ${STM32MP_SPI_NOR}),)
-BL2_SOURCES		+=	drivers/mtd/spi-mem/spi_mem.c				\
-				drivers/st/spi/stm32_qspi.c
+include drivers/auth/mbedtls/mbedtls_x509.mk
+
+COT_DESC_IN_DTB		:=	1
+AUTH_SOURCES		+=	lib/fconf/fconf_cot_getter.c				\
+				lib/fconf/fconf_tbbr_getter.c				\
+				plat/st/common/stm32mp_crypto_lib.c
+
+ifeq ($(STM32MP13),1)
+AUTH_SOURCES		+=	drivers/st/crypto/stm32_pka.c
+AUTH_SOURCES		+=	drivers/st/crypto/stm32_saes.c
+endif
+
+BL2_SOURCES		+=	$(AUTH_SOURCES)						\
+				plat/st/common/stm32mp_trusted_boot.c
+endif
+
+ifneq ($(filter 1,${STM32MP_EMMC} ${STM32MP_SDMMC}),)
+BL2_SOURCES		+=	drivers/st/mmc/stm32_sdmmc2.c
+endif
+
+ifeq (${STM32MP_RAW_NAND},1)
+BL2_SOURCES		+=	drivers/st/fmc/stm32_fmc2_nand.c
 endif
 
-ifneq ($(filter 1,${STM32MP_RAW_NAND} ${STM32MP_SPI_NAND}),)
-BL2_SOURCES		+=	drivers/mtd/nand/core.c
+ifneq ($(filter 1,${STM32MP_SPI_NAND} ${STM32MP_SPI_NOR}),)
+BL2_SOURCES		+=	drivers/st/spi/stm32_qspi.c
 endif
 
 ifneq ($(filter 1,${STM32MP_RAW_NAND} ${STM32MP_SPI_NAND} ${STM32MP_SPI_NOR}),)
 BL2_SOURCES		+=	plat/st/stm32mp1/stm32mp1_boot_device.c
 endif
 
+ifeq (${STM32MP_UART_PROGRAMMER},1)
+BL2_SOURCES		+=	drivers/st/uart/stm32_uart.c
+endif
+
 ifeq (${STM32MP_USB_PROGRAMMER},1)
 #The DFU stack uses only one end point, reduce the USB stack footprint
 $(eval $(call add_define_val,CONFIG_USBD_EP_NB,1U))
-BL2_SOURCES		+=	drivers/io/io_memmap.c					\
-				drivers/st/usb/stm32mp1_usb.c				\
-				drivers/usb/usb_device.c				\
-				plat/st/common/stm32cubeprogrammer_usb.c		\
-				plat/st/common/usb_dfu.c					\
+BL2_SOURCES		+=	drivers/st/usb/stm32mp1_usb.c				\
 				plat/st/stm32mp1/stm32mp1_usb_dfu.c
 endif
 
 BL2_SOURCES		+=	drivers/st/ddr/stm32mp1_ddr.c				\
 				drivers/st/ddr/stm32mp1_ram.c
 
-BL2_SOURCES		+=	common/desc_image_load.c				\
-				plat/st/stm32mp1/plat_image_load.c
-
-BL2_SOURCES		+=	lib/optee/optee_utils.c
-
-# Compilation rules
-.PHONY: check_dtc_version stm32image clean_stm32image check_boot_device
-.SUFFIXES:
-
-all: check_dtc_version stm32image ${STM32_TF_STM32}
-
-distclean realclean clean: clean_stm32image
-
-bl2: check_boot_device
-
-check_boot_device:
-	@if [ ${STM32MP_EMMC} != 1 ] && \
-	    [ ${STM32MP_SDMMC} != 1 ] && \
-	    [ ${STM32MP_RAW_NAND} != 1 ] && \
-	    [ ${STM32MP_SPI_NAND} != 1 ] && \
-	    [ ${STM32MP_SPI_NOR} != 1 ] && \
-	    [ ${STM32MP_USB_PROGRAMMER} != 1 ]; then \
-		echo "No boot device driver is enabled"; \
-		false; \
-	fi
+BL2_SOURCES		+=	plat/st/stm32mp1/plat_image_load.c
 
-stm32image: ${STM32IMAGE}
+BL2_SOURCES		+=	plat/st/stm32mp1/stm32mp1_critic_power.c
+BL2_SOURCES		+=	plat/st/stm32mp1/stm32mp1_critic_power_wrapper.S
 
-${STM32IMAGE}: ${STM32IMAGE_SRC}
-	${Q}${MAKE} CPPFLAGS="" --no-print-directory -C ${STM32IMAGEPATH}
-
-clean_stm32image:
-	${Q}${MAKE} --no-print-directory -C ${STM32IMAGEPATH} clean
-
-check_dtc_version:
-	$(eval DTC_V = $(shell $(DTC) -v | awk '{print $$NF}'))
-	$(eval DTC_VERSION = $(shell printf "%d" $(shell echo ${DTC_V} | cut -d- -f1 | sed "s/\./0/g")))
-	@if [ ${DTC_VERSION} -lt 10404 ]; then \
-		echo "dtc version too old (${DTC_V}), you need at least version 1.4.4"; \
-		false; \
-	fi
-
-ifeq ($(STM32MP_USE_STM32IMAGE)-$(AARCH32_SP),1-sp_min)
-${BUILD_PLAT}/stm32mp1-%.o: ${BUILD_PLAT}/fdts/%.dtb plat/st/stm32mp1/stm32mp1.S bl2 ${BL32_DEP}
-	@echo "  AS      stm32mp1.S"
-	${Q}${AS} ${ASFLAGS} ${TF_CFLAGS} \
-		-DDTB_BIN_PATH=\"$<\" \
-		-c $(word 2,$^) -o $@
-else
-# Create DTB file for BL2
-${BUILD_PLAT}/fdts/%-bl2.dts: fdts/%.dts fdts/${BL2_DTSI} | ${BUILD_PLAT} fdt_dirs
-	@echo '#include "$(patsubst fdts/%,%,$<)"' > $@
-	@echo '#include "${BL2_DTSI}"' >> $@
-
-${BUILD_PLAT}/fdts/%-bl2.dtb: ${BUILD_PLAT}/fdts/%-bl2.dts
+ifeq ($(STM32MP_SSP),1)
+include plat/st/stm32mp1/stm32mp1_ssp.mk
+endif
 
 ifeq ($(AARCH32_SP),sp_min)
 # Create DTB file for BL32
@@ -339,31 +324,4 @@ ${BUILD_PLAT}/fdts/%-bl32.dts: fdts/%.dts fdts/${BL32_DTSI} | ${BUILD_PLAT} fdt_
 ${BUILD_PLAT}/fdts/%-bl32.dtb: ${BUILD_PLAT}/fdts/%-bl32.dts
 endif
 
-${BUILD_PLAT}/stm32mp1-%.o: ${BUILD_PLAT}/fdts/%-bl2.dtb plat/st/stm32mp1/stm32mp1.S bl2
-	@echo "  AS      stm32mp1.S"
-	${Q}${AS} ${ASFLAGS} ${TF_CFLAGS} \
-		-DDTB_BIN_PATH=\"$<\" \
-		-c plat/st/stm32mp1/stm32mp1.S -o $@
-endif
-
-$(eval $(call MAKE_LD,${STM32_TF_LINKERFILE},plat/st/stm32mp1/stm32mp1.ld.S,bl2))
-
-tf-a-%.elf: stm32mp1-%.o ${STM32_TF_LINKERFILE}
-	@echo "  LDS     $<"
-	${Q}${LD} -o $@ ${STM32_TF_ELF_LDFLAGS} -Map=$(@:.elf=.map) --script ${STM32_TF_LINKERFILE} $<
-
-tf-a-%.bin: tf-a-%.elf
-	${Q}${OC} -O binary $< $@
-	@echo
-	@echo "Built $@ successfully"
-	@echo
-
-tf-a-%.stm32: ${STM32IMAGE} tf-a-%.bin
-	@echo
-	@echo "Generate $@"
-	$(eval LOADADDR = $(shell cat $(@:.stm32=.map) | grep RAM | awk '{print $$2}'))
-	$(eval ENTRY = $(shell cat $(@:.stm32=.map) | grep "__BL2_IMAGE_START" | awk '{print $$1}'))
-	${Q}${STM32IMAGE} -s $(word 2,$^) -d $@ \
-		-l $(LOADADDR) -e ${ENTRY} \
-		-v ${STM32_TF_VERSION}
-	@echo
+include plat/st/common/common_rules.mk
diff --git a/plat/st/stm32mp1/services/bsec_svc.c b/plat/st/stm32mp1/services/bsec_svc.c
index a1d7fc64e..59f392693 100644
--- a/plat/st/stm32mp1/services/bsec_svc.c
+++ b/plat/st/stm32mp1/services/bsec_svc.c
@@ -1,23 +1,228 @@
 /*
- * Copyright (c) 2016-2021, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2016-2022, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
+#include <assert.h>
+
 #include <platform_def.h>
 
+#include <arch.h>
+#include <arch_helpers.h>
 #include <common/debug.h>
+#include <common/runtime_svc.h>
+#include <drivers/regulator.h>
 #include <drivers/st/bsec.h>
+#include <drivers/st/bsec2_reg.h>
+#include <drivers/st/stm32mp_pmic.h>
+#include <drivers/st/stm32mp1_ddr_helpers.h>
+#include <drivers/st/stpmic1.h>
+#include <lib/mmio.h>
+#include <lib/xlat_tables/xlat_tables_v2.h>
+#include <services/std_svc.h>
 
+#include <boot_api.h>
+#include <stm32mp_svc_setup.h>
+#include <stm32mp1_dbgmcu.h>
 #include <stm32mp1_smc.h>
 
 #include "bsec_svc.h"
 
+/*
+ * version of STM32_SMC_READ_ALL / STM32_SMC_WRITE_ALL service
+ * This must be increased at each structure otp_exchange modification
+ */
+#define BSEC_SERVICE_VERSION		0x02U
+
+/* Bitfield definition status */
+#define OTP_UPDATE_REQ			BIT(31)
+#define OTP_ERROR_DETECTED		BIT(0)
+
+/* Bitfield definition for LOCK status */
+#define LOCK_PERM			BIT(30)
+#define LOCK_SHADOW_R			BIT(29)
+#define LOCK_SHADOW_W			BIT(28)
+#define LOCK_SHADOW_P			BIT(27)
+#define LOCK_ERROR			BIT(26)
+
+struct otp_state {
+	uint32_t value;
+	uint32_t state;
+};
+
+struct otp_exchange {
+	uint32_t version;
+	uint32_t status;
+	struct otp_state otp[STM32MP1_OTP_MAX_ID];
+};
+
+static uint32_t bsec_read_all_bsec(struct otp_exchange *exchange)
+{
+	uint32_t i;
+	uint32_t result;
+	uint32_t shadow_prog_lock[3];
+	uint32_t shadow_read_lock[3];
+	uint32_t shadow_write_lock[3];
+	uint32_t permanent_lock[3];
+
+	if (exchange == NULL) {
+		return BSEC_ERROR;
+	}
+
+	exchange->version = BSEC_SERVICE_VERSION;
+	exchange->status = bsec_get_secure_state();
+
+	for (i = 0U; i < 3U; i++) {
+		permanent_lock[i] = mmio_read_32(BSEC_BASE + BSEC_WRLOCK(i));
+		shadow_prog_lock[i] = mmio_read_32(BSEC_BASE + BSEC_SPLOCK(i));
+		shadow_read_lock[i] = mmio_read_32(BSEC_BASE + BSEC_SRLOCK(i));
+		shadow_write_lock[i] = mmio_read_32(BSEC_BASE + BSEC_SWLOCK(i));
+	}
+
+	for (i = 0U; i <= STM32MP1_OTP_MAX_ID; i++) {
+		uint32_t offset = i / __WORD_BIT;
+		uint32_t bits = BIT(i % __WORD_BIT);
+
+		exchange->otp[i].value = 0U;
+		exchange->otp[i].state = 0U;
+
+		result = bsec_shadow_read_otp(&exchange->otp[i].value, i);
+		if (result != BSEC_OK) {
+			exchange->otp[i].value = 0;
+			exchange->otp[i].state |= OTP_ERROR_DETECTED;
+		}
+		if (permanent_lock[offset] & bits) {
+			exchange->otp[i].state |= LOCK_PERM;
+		}
+		if (shadow_read_lock[offset] & bits) {
+			exchange->otp[i].state |= LOCK_SHADOW_R;
+		}
+		if (shadow_write_lock[offset] & bits) {
+			exchange->otp[i].state |= LOCK_SHADOW_W;
+		}
+		if (shadow_prog_lock[offset] & bits) {
+			exchange->otp[i].state |= LOCK_SHADOW_P;
+		}
+	}
+
+	return BSEC_OK;
+}
+
+static uint32_t bsec_write_all_bsec(struct otp_exchange *exchange,
+				    uint32_t *ret_otp_value)
+{
+	uint32_t i;
+	uint32_t ret;
+
+	*ret_otp_value = 0U;
+
+	if (exchange == NULL) {
+		return BSEC_ERROR;
+	}
+
+	if (exchange->version != BSEC_SERVICE_VERSION) {
+		return BSEC_ERROR;
+	}
+
+	for (i = 0U; i <= STM32MP1_OTP_MAX_ID; i++) {
+		if ((exchange->otp[i].state & OTP_UPDATE_REQ) == 0U) {
+			continue;
+		}
+		if (exchange->otp[i].value != 0U) {
+			ret = bsec_program_otp(exchange->otp[i].value, i);
+			if (ret == BSEC_OK) {
+				ret = bsec_write_otp(exchange->otp[i].value, i);
+			}
+			if (ret != BSEC_OK) {
+				ERROR("BSEC write failed on OTP%u\n", i);
+				return ret;
+			}
+		}
+		if ((exchange->otp[i].state & LOCK_PERM) != 0U) {
+			ret = bsec_permanent_lock_otp(i);
+			if (ret != BSEC_OK) {
+				ERROR("BSEC permanent lock failed on OTP%u\n", i);
+				return ret;
+			}
+		}
+		if ((exchange->otp[i].state & LOCK_SHADOW_R) != 0U) {
+			ret = bsec_set_sr_lock(i);
+			if (ret != BSEC_OK) {
+				ERROR("BSEC sr lock failed on OTP%u\n", i);
+				return ret;
+			}
+		}
+		if ((exchange->otp[i].state & LOCK_SHADOW_W) != 0U) {
+			ret = bsec_set_sw_lock(i);
+			if (ret != BSEC_OK) {
+				ERROR("BSEC sw lock failed on OTP%u\n", i);
+				return ret;
+			}
+		}
+		if ((exchange->otp[i].state & LOCK_SHADOW_P) != 0U) {
+			ret = bsec_set_sp_lock(i);
+			if (ret != BSEC_OK) {
+				ERROR("BSEC sp lock failed on OTP%u\n", i);
+				return ret;
+			}
+		}
+	}
+
+	INFO("write all otp succeed\n");
+
+	return BSEC_OK;
+}
+
 uint32_t bsec_main(uint32_t x1, uint32_t x2, uint32_t x3,
 		   uint32_t *ret_otp_value)
 {
 	uint32_t result;
 	uint32_t tmp_data = 0U;
+	struct otp_exchange *otp_exch __unused;
+	uintptr_t map_begin __unused;
+	size_t map_size __unused = PAGE_SIZE;
+	int ret __unused;
+
+	if ((x1 != STM32_SMC_READ_ALL) && (x1 != STM32_SMC_WRITE_ALL) &&
+	    (bsec_check_nsec_access_rights(x2) != BSEC_OK)) {
+		return STM32_SMC_INVALID_PARAMS;
+	}
+
+	otp_exch = NULL;
+	map_begin = 0U;
+
+	if ((x1 == STM32_SMC_READ_ALL) || (x1 == STM32_SMC_WRITE_ALL)) {
+		if (!stm32_boot_is_serial()) {
+			return STM32_SMC_FAILED;
+		}
+
+		map_begin = round_down(x2, PAGE_SIZE);
+
+		if (round_down(x2 + sizeof(struct otp_exchange), PAGE_SIZE) !=
+		    map_begin) {
+			/*
+			 * Buffer end is in the next page, 2 pages need to be
+			 * mapped.
+			 */
+			map_size += PAGE_SIZE;
+		}
+
+		ret = mmap_add_dynamic_region(map_begin,
+					      map_begin,
+					      map_size,
+					      MT_MEMORY | MT_RW | MT_NS);
+		assert(ret == 0);
+
+		if (!ddr_is_nonsecured_area(map_begin, map_size)) {
+			ret = mmap_remove_dynamic_region(map_begin, map_size);
+			assert(ret == 0);
+
+			return STM32_SMC_INVALID_PARAMS;
+		}
+
+		otp_exch = (struct otp_exchange *)(uintptr_t)x2;
+	}
 
 	switch (x1) {
 	case STM32_SMC_READ_SHADOW:
@@ -38,22 +243,30 @@ uint32_t bsec_main(uint32_t x1, uint32_t x2, uint32_t x3,
 			break;
 		}
 
-		result = bsec_shadow_register(x2);
-		if (result != BSEC_OK) {
-			break;
-		}
-
-		result = bsec_read_otp(ret_otp_value, x2);
+		result = bsec_shadow_read_otp(ret_otp_value, x2);
 		if (result != BSEC_OK) {
 			break;
 		}
 
 		result = bsec_write_otp(tmp_data, x2);
 		break;
-
+	case STM32_SMC_READ_ALL:
+		result = bsec_read_all_bsec(otp_exch);
+		break;
+	case STM32_SMC_WRITE_ALL:
+		result = bsec_write_all_bsec(otp_exch, ret_otp_value);
+		break;
+	case STM32_SMC_WRLOCK_OTP:
+		result = bsec_permanent_lock_otp(x2);
+		break;
 	default:
 		return STM32_SMC_INVALID_PARAMS;
 	}
 
+	if ((x1 == STM32_SMC_READ_ALL) || (x1 == STM32_SMC_WRITE_ALL)) {
+		ret = mmap_remove_dynamic_region(map_begin, map_size);
+		assert(ret == 0);
+	}
+
 	return (result == BSEC_OK) ? STM32_SMC_OK : STM32_SMC_FAILED;
 }
diff --git a/plat/st/stm32mp1/services/bsec_svc.h b/plat/st/stm32mp1/services/bsec_svc.h
index 06752ef4d..ba42cf823 100644
--- a/plat/st/stm32mp1/services/bsec_svc.h
+++ b/plat/st/stm32mp1/services/bsec_svc.h
@@ -9,10 +9,6 @@
 
 #include <stdint.h>
 
-/* version of this service */
-/* must be increase at each structure modification */
-#define BSEC_SERVICE_VERSION		0x01U
-
 uint32_t bsec_main(uint32_t x1, uint32_t x2, uint32_t x3,
 		   uint32_t *ret_otp_value);
 
diff --git a/plat/st/stm32mp1/services/low_power_svc.c b/plat/st/stm32mp1/services/low_power_svc.c
new file mode 100644
index 000000000..ae260a73b
--- /dev/null
+++ b/plat/st/stm32mp1/services/low_power_svc.c
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2017-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <smccc_helpers.h>
+
+#include <stm32mp_svc_setup.h>
+#include <stm32mp1_power_config.h>
+#include <stm32mp1_smc.h>
+
+#include "low_power_svc.h"
+
+uint32_t pm_domain_scv_handler(uint32_t x1, uint32_t x2)
+{
+	if (stm32mp1_set_pm_domain_state((enum stm32mp1_pm_domain)x1,
+					 (bool)x2) < 0) {
+		return STM32_SMC_FAILED;
+	}
+
+	return STM32_SMC_OK;
+}
diff --git a/plat/st/stm32mp1/services/low_power_svc.h b/plat/st/stm32mp1/services/low_power_svc.h
new file mode 100644
index 000000000..eb98e9225
--- /dev/null
+++ b/plat/st/stm32mp1/services/low_power_svc.h
@@ -0,0 +1,14 @@
+/*
+ * Copyright (c) 2017-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef LOW_POWER_SVC_H
+#define LOW_POWER_SVC_H
+
+#include <stdint.h>
+
+uint32_t pm_domain_scv_handler(uint32_t x1, uint32_t x2);
+
+#endif /* LOW_POWER_SVC_H */
diff --git a/plat/st/stm32mp1/services/pwr_svc.c b/plat/st/stm32mp1/services/pwr_svc.c
new file mode 100644
index 000000000..a0614af4c
--- /dev/null
+++ b/plat/st/stm32mp1/services/pwr_svc.c
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2017-2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <platform_def.h>
+
+#include <common/debug.h>
+#include <drivers/st/stm32mp1_pwr.h>
+#include <lib/mmio.h>
+
+#include <stm32mp_common.h>
+#include <stm32mp_svc_setup.h>
+#include <stm32mp1_smc.h>
+
+#include "pwr_svc.h"
+
+static void access_allowed_mask(uint32_t request, uint32_t offset,
+				uint32_t value, uint32_t allowed_mask)
+{
+	uint32_t addr = stm32mp_pwr_base() + offset;
+	uint32_t masked_value = value & allowed_mask;
+
+	stm32mp_pwr_regs_lock();
+
+	switch (request) {
+	case STM32_SMC_REG_WRITE:
+		mmio_clrsetbits_32(addr, allowed_mask, masked_value);
+		VERBOSE("wrt 0x%x = 0x%x => 0x%x\n", offset, value,
+			mmio_read_32(addr));
+		break;
+
+	case STM32_SMC_REG_SET:
+		mmio_setbits_32(addr, masked_value);
+		VERBOSE("set 0x%x = 0x%x => 0x%x\n", offset, value,
+			mmio_read_32(addr));
+		break;
+
+	case STM32_SMC_REG_CLEAR:
+		mmio_clrbits_32(addr, masked_value);
+		VERBOSE("clear 0x%x = 0x%x => 0x%x\n", offset, value,
+			mmio_read_32(addr));
+		break;
+
+	default:
+		break;
+	}
+
+	stm32mp_pwr_regs_unlock();
+}
+
+static void raw_allowed_access_request(uint32_t request,
+				       uint32_t offset, uint32_t value)
+{
+	uint32_t allowed_mask = 0;
+
+	switch (offset) {
+	case PWR_CR3:
+		allowed_mask |= PWR_CR3_VBE | PWR_CR3_VBRS | PWR_CR3_USB33DEN |
+				PWR_CR3_REG18EN | PWR_CR3_REG11EN;
+		break;
+
+	case PWR_WKUPCR:
+		allowed_mask |= PWR_WKUPCR_MASK;
+		break;
+
+	case PWR_MPUWKUPENR:
+		allowed_mask |= PWR_MPUWKUPENR_MASK;
+		break;
+
+	default:
+		return;
+	}
+
+	if (allowed_mask != 0U) {
+		access_allowed_mask(request, offset, value, allowed_mask);
+	}
+}
+
+uint32_t pwr_scv_handler(uint32_t x1, uint32_t x2, uint32_t x3)
+{
+	uint32_t request = x1;
+	uint32_t offset = x2;
+	uint32_t value = x3;
+
+	/*
+	 * x2 may be either the PWR register offset or the register
+	 * full physical address.
+	 */
+	if ((offset & ~PWR_OFFSET_MASK) != 0) {
+		if ((offset & ~PWR_OFFSET_MASK) != stm32mp_pwr_base()) {
+			return STM32_SMC_INVALID_PARAMS;
+		}
+
+		offset &= PWR_OFFSET_MASK;
+	}
+
+	/* PWR controls for non secure resource may be accessed straight */
+	raw_allowed_access_request(request, offset, value);
+
+	return STM32_SMC_OK;
+}
diff --git a/plat/st/stm32mp1/services/pwr_svc.h b/plat/st/stm32mp1/services/pwr_svc.h
new file mode 100644
index 000000000..6dacdf80d
--- /dev/null
+++ b/plat/st/stm32mp1/services/pwr_svc.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright (c) 2017-2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef PWR_SVC_H
+#define PWR_SVC_H
+
+uint32_t pwr_scv_handler(uint32_t x1, uint32_t x2, uint32_t x3);
+
+#endif /* PWR_SVC_H */
diff --git a/plat/st/stm32mp1/services/rcc_svc.c b/plat/st/stm32mp1/services/rcc_svc.c
new file mode 100644
index 000000000..d8d54e511
--- /dev/null
+++ b/plat/st/stm32mp1/services/rcc_svc.c
@@ -0,0 +1,141 @@
+/*
+ * Copyright (c) 2017-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <limits.h>
+
+#include <platform_def.h>
+
+#include <common/debug.h>
+#include <drivers/st/stm32_gpio.h>
+#include <drivers/st/stm32mp1_clk.h>
+#include <drivers/st/stm32mp1_rcc.h>
+#include <lib/mmio.h>
+
+#include <stm32mp_common.h>
+#include <stm32mp_shres_helpers.h>
+#include <stm32mp_svc_setup.h>
+#include <stm32mp1_shared_resources.h>
+#include <stm32mp1_smc.h>
+
+#include "rcc_svc.h"
+
+#define RCC_OFFSET_MASK			GENMASK(11, 0)
+
+static bool offset_is_clear_register(uint32_t __unused offset)
+{
+	/* All currently allowed registers are non set/clear registers */
+	return false;
+}
+
+static void access_allowed_mask(uint32_t request, uint32_t offset,
+				uint32_t value, uint32_t allowed_mask)
+{
+	uint32_t addr = stm32mp_rcc_base() + offset;
+	uint32_t masked_value = value & allowed_mask;
+
+	switch (request) {
+	case STM32_SMC_REG_WRITE:
+		if (offset_is_clear_register(offset)) {
+			mmio_write_32(addr, masked_value);
+		} else {
+			stm32mp_mmio_clrsetbits_32_shregs(addr, allowed_mask,
+							  masked_value);
+		}
+		VERBOSE("wrt 0x%x = 0x%x => 0x%x\n", offset, value,
+			mmio_read_32(addr));
+		break;
+
+	case STM32_SMC_REG_SET:
+		if (offset_is_clear_register(offset)) {
+			mmio_write_32(addr, masked_value);
+		} else {
+			stm32mp_mmio_setbits_32_shregs(addr, masked_value);
+		}
+		VERBOSE("set 0x%x = 0x%x => 0x%x\n", offset, value,
+			mmio_read_32(addr));
+		break;
+
+	case STM32_SMC_REG_CLEAR:
+		if (offset_is_clear_register(offset)) {
+			/* Nothing to do on CLR registers */
+		} else {
+			stm32mp_mmio_clrbits_32_shregs(addr, masked_value);
+		}
+		VERBOSE("clear 0x%x = 0x%x => 0x%x\n", offset, value,
+			mmio_read_32(addr));
+		break;
+
+	default:
+		break;
+	}
+}
+
+static uint32_t raw_allowed_access_request(uint32_t request,
+					   uint32_t offset, uint32_t value)
+{
+	uint32_t allowed_mask = 0;
+
+	switch (offset) {
+	case RCC_MP_CIER:
+	case RCC_MP_CIFR:
+		allowed_mask = RCC_MP_CIFR_WKUPF;
+		break;
+	default:
+		return STM32_SMC_INVALID_PARAMS;
+	}
+
+	if (allowed_mask != 0U) {
+		access_allowed_mask(request, offset, value, allowed_mask);
+	}
+
+	return STM32_SMC_OK;
+}
+
+uint32_t rcc_scv_handler(uint32_t x1, uint32_t x2, uint32_t x3)
+{
+	uint32_t request = x1;
+	uint32_t offset = x2;
+	uint32_t value = x3;
+
+	/*
+	 * x2 may be either the RCC register offset or the register
+	 * full physical address.
+	 */
+	if ((offset & ~RCC_OFFSET_MASK) != 0) {
+		if ((offset & ~RCC_OFFSET_MASK) != stm32mp_rcc_base()) {
+			return STM32_SMC_INVALID_PARAMS;
+		}
+
+		offset &= RCC_OFFSET_MASK;
+	}
+
+	return raw_allowed_access_request(request, offset, value);
+}
+
+uint32_t rcc_cal_scv_handler(uint32_t x1)
+{
+	uint32_t ret = STM32_SMC_FAILED;
+
+	switch (x1) {
+	case CK_CSI:
+		if (stm32mp1_calib_start_csi_cal() ==  0) {
+			ret = STM32_SMC_OK;
+		}
+		break;
+
+	case CK_HSI:
+		if (stm32mp1_calib_start_hsi_cal() == 0) {
+			ret = STM32_SMC_OK;
+		}
+		break;
+
+	default:
+		ret = STM32_SMC_INVALID_PARAMS;
+		break;
+	}
+
+	return ret;
+}
diff --git a/plat/st/stm32mp1/services/rcc_svc.h b/plat/st/stm32mp1/services/rcc_svc.h
new file mode 100644
index 000000000..8cf128a36
--- /dev/null
+++ b/plat/st/stm32mp1/services/rcc_svc.h
@@ -0,0 +1,13 @@
+/*
+ * Copyright (c) 2017-2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef RCC_SVC_H
+#define RCC_SVC_H
+
+uint32_t rcc_scv_handler(uint32_t x1, uint32_t x2, uint32_t x3);
+uint32_t rcc_cal_scv_handler(uint32_t x1);
+
+#endif /* RCC_SVC_H */
diff --git a/plat/st/stm32mp1/services/stm32mp1_svc_setup.c b/plat/st/stm32mp1/services/stm32mp1_svc_setup.c
index ed8a448b3..8ba2ace67 100644
--- a/plat/st/stm32mp1/services/stm32mp1_svc_setup.c
+++ b/plat/st/stm32mp1/services/stm32mp1_svc_setup.c
@@ -13,57 +13,53 @@
 #include <lib/psci/psci.h>
 #include <tools_share/uuid.h>
 
+#include <stm32mp_svc_setup.h>
+#include <stm32mp1_low_power.h>
 #include <stm32mp1_smc.h>
 
 #include "bsec_svc.h"
-
-/* STM32 SiP Service UUID */
-DEFINE_SVC_UUID2(stm32_sip_svc_uid,
-		 0xa778aa50, 0xf49b, 0x144a, 0x8a, 0x5e,
-		 0x26, 0x4d, 0x59, 0x94, 0xc2, 0x14);
-
-/* Setup STM32MP1 Standard Services */
-static int32_t stm32mp1_svc_setup(void)
-{
-	/*
-	 * PSCI is the only specification implemented as a Standard Service.
-	 * Invoke PSCI setup from here.
-	 */
-	return 0;
-}
+#include "low_power_svc.h"
+#include "pwr_svc.h"
+#include "rcc_svc.h"
 
 /*
- * Top-level Standard Service SMC handler. This handler will in turn dispatch
- * calls to PSCI SMC handler.
+ * Platform Standard Service SMC handler. This handler will dispatch
+ * calls to features handlers.
  */
-static uintptr_t stm32mp1_svc_smc_handler(uint32_t smc_fid, u_register_t x1,
-					  u_register_t x2, u_register_t x3,
-					  u_register_t x4, void *cookie,
-					  void *handle, u_register_t flags)
+void plat_svc_smc_handler(uint32_t smc_fid, u_register_t x1,
+			  u_register_t x2, u_register_t x3,
+			  u_register_t x4, uint32_t *ret1,
+			  uint32_t *ret2, bool *ret2_enabled,
+			  u_register_t flags)
 {
-	uint32_t ret1 = 0U, ret2 = 0U;
-	bool ret_uid = false, ret2_enabled = false;
-
 	switch (smc_fid) {
 	case STM32_SIP_SVC_CALL_COUNT:
-		ret1 = STM32_COMMON_SIP_NUM_CALLS;
+		*ret1 = STM32_COMMON_SIP_NUM_CALLS;
+		break;
+	case STM32_SMC_BSEC:
+		*ret1 = bsec_main(x1, x2, x3, ret2);
+		*ret2_enabled = true;
 		break;
 
-	case STM32_SIP_SVC_UID:
-		/* Return UUID to the caller */
-		ret_uid = true;
+	case STM32_SMC_RCC:
+		*ret1 = rcc_scv_handler(x1, x2, x3);
 		break;
 
-	case STM32_SIP_SVC_VERSION:
-		/* Return the version of current implementation */
-		ret1 = STM32_SIP_SVC_VERSION_MAJOR;
-		ret2 = STM32_SIP_SVC_VERSION_MINOR;
-		ret2_enabled = true;
+	case STM32_SMC_RCC_CAL:
+		*ret1 = rcc_cal_scv_handler(x1);
 		break;
 
-	case STM32_SMC_BSEC:
-		ret1 = bsec_main(x1, x2, x3, &ret2);
-		ret2_enabled = true;
+	case STM32_SMC_PWR:
+		*ret1 = pwr_scv_handler(x1, x2, x3);
+		break;
+
+	case STM32_SMC_PD_DOMAIN:
+		*ret1 = pm_domain_scv_handler(x1, x2);
+		break;
+
+	case STM32_SMC_AUTO_STOP:
+		stm32_auto_stop();
+		*ret1 = STM32_SMC_OK;
 		break;
 
 	case STM32_SIP_SMC_SCMI_AGENT0:
@@ -75,26 +71,7 @@ static uintptr_t stm32mp1_svc_smc_handler(uint32_t smc_fid, u_register_t x1,
 
 	default:
 		WARN("Unimplemented STM32MP1 Service Call: 0x%x\n", smc_fid);
-		ret1 = STM32_SMC_NOT_SUPPORTED;
+		*ret1 = STM32_SMC_NOT_SUPPORTED;
 		break;
 	}
-
-	if (ret_uid) {
-		SMC_UUID_RET(handle, stm32_sip_svc_uid);
-	}
-
-	if (ret2_enabled) {
-		SMC_RET2(handle, ret1, ret2);
-	}
-
-	SMC_RET1(handle, ret1);
 }
-
-/* Register Standard Service Calls as runtime service */
-DECLARE_RT_SVC(stm32mp1_sip_svc,
-	       OEN_SIP_START,
-	       OEN_SIP_END,
-	       SMC_TYPE_FAST,
-	       stm32mp1_svc_setup,
-	       stm32mp1_svc_smc_handler
-);
diff --git a/plat/st/stm32mp1/sp_min/sp_min-stm32mp1.mk b/plat/st/stm32mp1/sp_min/sp_min-stm32mp1.mk
index 239b60af4..9bd91cc0d 100644
--- a/plat/st/stm32mp1/sp_min/sp_min-stm32mp1.mk
+++ b/plat/st/stm32mp1/sp_min/sp_min-stm32mp1.mk
@@ -1,17 +1,32 @@
 #
-# Copyright (c) 2017-2019, ARM Limited and Contributors. All rights reserved.
+# Copyright (c) 2017-2022, ARM Limited and Contributors. All rights reserved.
 #
 # SPDX-License-Identifier: BSD-3-Clause
 #
 
+ifeq ($(STM32MP13),1)
+$(error "SP_min is not supported on STM32MP13 platform")
+endif
+
 SP_MIN_WITH_SECURE_FIQ	:=	1
 
+override ENABLE_PIE	:=	1
+BL32_CFLAGS		+=	-fpie -DENABLE_PIE
+BL32_LDFLAGS		+=	$(PIE_LDFLAGS)
+
 BL32_CFLAGS		+=	-DSTM32MP_SHARED_RESOURCES
 
-BL32_SOURCES		+=	drivers/st/etzpc/etzpc.c			\
+BL32_SOURCES		+=	drivers/st/clk/stm32mp1_calib.c			\
+				drivers/st/etzpc/etzpc.c			\
+				drivers/st/rng/stm32_rng.c			\
+				drivers/st/rtc/stm32_rtc.c			\
+				drivers/st/tamper/stm32_tamp.c			\
+				drivers/st/timer/stm32_timer.c 			\
 				plat/common/aarch32/platform_mp_stack.S		\
 				plat/st/stm32mp1/sp_min/sp_min_setup.c		\
+				plat/st/stm32mp1/stm32mp1_low_power.c		\
 				plat/st/stm32mp1/stm32mp1_pm.c			\
+				plat/st/stm32mp1/stm32mp1_power_config.c	\
 				plat/st/stm32mp1/stm32mp1_shared_resources.c	\
 				plat/st/stm32mp1/stm32mp1_topology.c
 
@@ -24,7 +39,7 @@ include drivers/arm/gic/v2/gicv2.mk
 
 BL32_SOURCES		+=	${GICV2_SOURCES}			\
 				plat/common/plat_gicv2.c		\
-				plat/st/stm32mp1/stm32mp1_gic.c
+				plat/st/common/stm32mp_gic.c
 
 # Generic PSCI
 BL32_SOURCES		+=	plat/common/plat_psci_common.c
@@ -38,8 +53,14 @@ BL32_SOURCES		+=	drivers/scmi-msg/base.c		\
 
 # stm32mp1 specific services
 BL32_SOURCES		+=	plat/st/stm32mp1/services/bsec_svc.c		\
+				plat/st/stm32mp1/services/low_power_svc.c	\
+				plat/st/stm32mp1/services/pwr_svc.c		\
+				plat/st/stm32mp1/services/rcc_svc.c		\
+				plat/st/common/stm32mp_svc_setup.c		\
 				plat/st/stm32mp1/services/stm32mp1_svc_setup.c	\
 				plat/st/stm32mp1/stm32mp1_scmi.c
 
 # Arm Archtecture services
 BL32_SOURCES		+=	services/arm_arch_svc/arm_arch_svc_setup.c
+
+BL32_SOURCES		+=	plat/st/stm32mp1/stm32mp1_critic_power.c
diff --git a/plat/st/stm32mp1/sp_min/sp_min_setup.c b/plat/st/stm32mp1/sp_min/sp_min_setup.c
index 1495e027c..d30608ed5 100644
--- a/plat/st/stm32mp1/sp_min/sp_min_setup.c
+++ b/plat/st/stm32mp1/sp_min/sp_min_setup.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2021, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -12,16 +12,28 @@
 #include <arch_helpers.h>
 #include <common/bl_common.h>
 #include <common/debug.h>
+#include <common/fdt_fixup.h>
 #include <context.h>
 #include <drivers/arm/gicv2.h>
 #include <drivers/arm/tzc400.h>
+#include <drivers/clk.h>
 #include <drivers/generic_delay_timer.h>
+#include <drivers/regulator.h>
 #include <drivers/st/bsec.h>
 #include <drivers/st/etzpc.h>
-#include <drivers/st/stm32_console.h>
+#include <drivers/st/regulator_fixed.h>
 #include <drivers/st/stm32_gpio.h>
 #include <drivers/st/stm32_iwdg.h>
+#include <drivers/st/stm32_rng.h>
+#include <drivers/st/stm32_rtc.h>
+#include <drivers/st/stm32_tamp.h>
+#include <drivers/st/stm32_timer.h>
+#include <drivers/st/stm32mp_clkfunc.h>
+#include <drivers/st/stm32mp_pmic.h>
+#include <drivers/st/stm32mp_reset.h>
 #include <drivers/st/stm32mp1_clk.h>
+#include <drivers/st/stm32mp1_ddr_helpers.h>
+#include <drivers/st/stpmic1.h>
 #include <dt-bindings/clock/stm32mp1-clks.h>
 #include <lib/el3_runtime/context_mgmt.h>
 #include <lib/mmio.h>
@@ -29,6 +41,10 @@
 #include <plat/common/platform.h>
 
 #include <platform_sp_min.h>
+#include <stm32mp1_context.h>
+#include <stm32mp1_low_power.h>
+#include <stm32mp1_power_config.h>
+#include <stm32mp1_smc.h>
 
 /******************************************************************************
  * Placeholder variables for copying the arguments that have been passed to
@@ -36,14 +52,178 @@
  ******************************************************************************/
 static entry_point_info_t bl33_image_ep_info;
 
-static console_t console;
+static const char * const tamper_name[] = {
+	[INT_TAMP1] = "RTC power domain",
+	[INT_TAMP2] = "Temperature monitoring",
+	[INT_TAMP3] = "LSE monitoring",
+	[INT_TAMP4] = "HSE monitoring",
+};
+
+static int stm32mp1_tamper_action(int id)
+{
+	const char *tamp_name = NULL;
+
+	if ((id >= 0) && ((size_t)id < ARRAY_SIZE(tamper_name))) {
+		tamp_name = tamper_name[id];
+	}
+	ERROR("Tamper %u (%s) occurs\n", id, tamp_name);
+
+	return 1; /* ack TAMPER and reset system */
+}
+
+static void stm32_sgi1_it_handler(void)
+{
+	uint32_t id;
+
+	stm32mp_mask_timer();
+
+#if DEBUG
+	stm32mp_dump_core_registers(false);
+#endif
+
+	gicv2_end_of_interrupt(ARM_IRQ_SEC_SGI_1);
+
+	do {
+		id = plat_ic_get_pending_interrupt_id();
+
+		if (id <= MAX_SPI_ID) {
+			gicv2_end_of_interrupt(id);
+
+			plat_ic_disable_interrupt(id);
+		}
+	} while (id <= MAX_SPI_ID);
+
+	stm32mp_wait_cpu_reset();
+}
+
+static void configure_wakeup_interrupt(void)
+{
+	int irq_num = fdt_rcc_enable_it("wakeup");
+
+	if (irq_num < 0) {
+		ERROR("irq_num = %d\n", irq_num);
+		panic();
+	}
+
+	plat_ic_set_interrupt_priority(irq_num, STM32MP1_IRQ_RCC_SEC_PRIO);
+}
+
+static void initialize_pll1_settings(void)
+{
+	uint32_t cpu_voltage = 0U;
+
+	if (stm32_are_pll1_settings_valid_in_context()) {
+		return;
+	}
+
+	if (dt_pmic_status() > 0) {
+		uint32_t voltage_mv = 0U;
+		uint32_t freq_khz = 0U;
+		struct rdev *regul;
+		int ret;
+
+		regul = dt_get_cpu_regulator();
+		if (regul == NULL) {
+			panic();
+		}
+
+		ret = regulator_get_voltage(regul);
+		if (ret < 0) {
+			panic();
+		}
+
+		cpu_voltage = (uint32_t)ret;
+
+		if (stm32mp1_clk_compute_all_pll1_settings(cpu_voltage) != 0) {
+			panic();
+		}
+
+		ret = dt_get_max_opp_freqvolt(&freq_khz, &voltage_mv);
+		if (ret != 0) {
+			panic();
+		}
+
+		if (voltage_mv != cpu_voltage) {
+			if (regulator_set_voltage(regul, (uint16_t)voltage_mv) != 0) {
+				panic();
+			}
+
+			ret = stm32mp1_set_opp_khz(freq_khz);
+			if (ret != 0) {
+				ERROR("Cannot set OPP freq %ukHz (%d)\n", freq_khz, ret);
+				panic();
+			}
+
+			cpu_voltage = voltage_mv;
+		}
+	}
+
+	if (stm32mp1_clk_compute_all_pll1_settings(cpu_voltage) != 0) {
+		panic();
+	}
+}
+
+static void disable_usb_phy_regulator(void)
+{
+	if (dt_pmic_status() > 0) {
+		struct rdev *regul = dt_get_usb_phy_regulator();
+		int ret;
+
+		if (regul == NULL) {
+			return;
+		}
+
+		if (regulator_is_enabled(regul) == 1) {
+			ret = regulator_disable(regul);
+			if (ret < 0) {
+				WARN("USBPHYC phy-supply (%s) disable failed\n", regul->reg_name);
+			}
+		}
+	}
+}
 
 /*******************************************************************************
  * Interrupt handler for FIQ (secure IRQ)
  ******************************************************************************/
 void sp_min_plat_fiq_handler(uint32_t id)
 {
+	bool unrecoverable_err = false;
+
 	switch (id & INT_ID_MASK) {
+	case ARM_IRQ_SEC_PHY_TIMER:
+	case STM32MP1_IRQ_MCU_SEV:
+	case STM32MP1_IRQ_RCC_WAKEUP:
+		stm32mp1_calib_it_handler(id);
+		break;
+	case STM32MP1_IRQ_TAMPSERRS:
+		stm32_tamp_it_handler();
+		break;
+	case ARM_IRQ_SEC_SGI_1:
+		stm32_sgi1_it_handler();
+		break;
+	case ARM_IRQ_SEC_SGI_6:
+		/* tell the primary cpu to exit from stm32_pwr_down_wfi() */
+		if (plat_my_core_pos() == STM32MP_PRIMARY_CPU) {
+			stm32mp1_calib_set_wakeup(true);
+		}
+		gicv2_end_of_interrupt(ARM_IRQ_SEC_SGI_6);
+		break;
+	default:
+		unrecoverable_err = true;
+		break;
+	}
+
+	if (!unrecoverable_err) {
+		return;
+	}
+
+	(void)plat_crash_console_init();
+
+	switch (id & INT_ID_MASK) {
+	case STM32MP1_IRQ_IWDG1:
+	case STM32MP1_IRQ_IWDG2:
+		stm32_iwdg_it_handler(id);
+		break;
 	case STM32MP1_IRQ_TZC400:
 		tzc400_init(STM32MP1_TZC_BASE);
 		(void)tzc400_it_handler();
@@ -54,11 +234,43 @@ void sp_min_plat_fiq_handler(uint32_t id)
 		panic();
 		break;
 	default:
-		ERROR("SECURE IT handler not define for it : %u", id);
+		ERROR("SECURE IT handler not define for it : %u\n", id);
 		break;
 	}
 }
 
+/*******************************************************************************
+ * Return the value of the saved PC from the backup register if present
+ ******************************************************************************/
+static uintptr_t get_saved_pc(void)
+{
+	uintptr_t bkpr_core1_addr =
+		tamp_bkpr(BOOT_API_CORE1_BRANCH_ADDRESS_TAMP_BCK_REG_IDX);
+	uint32_t saved_pc;
+	uintptr_t bkpr_core1_magic =
+		tamp_bkpr(BOOT_API_CORE1_MAGIC_NUMBER_TAMP_BCK_REG_IDX);
+	uint32_t magic_nb;
+
+	clk_enable(RTCAPB);
+
+	magic_nb = mmio_read_32(bkpr_core1_magic);
+	saved_pc = mmio_read_32(bkpr_core1_addr);
+
+	clk_disable(RTCAPB);
+
+	if (magic_nb != BOOT_API_A7_CORE0_MAGIC_NUMBER) {
+		return 0U;
+	}
+
+	/* BL33 return address should be in DDR */
+	if ((saved_pc < STM32MP_DDR_BASE) ||
+	    (saved_pc > (STM32MP_DDR_BASE + (dt_get_ddr_size() - 1U)))) {
+		panic();
+	}
+
+	return saved_pc;
+}
+
 /*******************************************************************************
  * Return a pointer to the 'entry_point_info' structure of the next image for
  * the security state specified. BL33 corresponds to the non-secure image type
@@ -67,12 +279,40 @@ void sp_min_plat_fiq_handler(uint32_t id)
  ******************************************************************************/
 entry_point_info_t *sp_min_plat_get_bl33_ep_info(void)
 {
-	entry_point_info_t *next_image_info;
-
-	next_image_info = &bl33_image_ep_info;
+	entry_point_info_t *next_image_info = &bl33_image_ep_info;
 
+	/*
+	 * PC is set to 0 when resetting after STANDBY
+	 * The context should be restored, and the image information
+	 * should be filled with what was saved
+	 */
 	if (next_image_info->pc == 0U) {
-		return NULL;
+		void *cpu_context;
+		uintptr_t saved_pc;
+
+		if (stm32_restore_context() != 0) {
+			panic();
+		}
+
+		stm32mp_set_console_after_standby();
+
+		cpu_context = cm_get_context(NON_SECURE);
+
+		next_image_info->spsr = read_ctx_reg(get_regs_ctx(cpu_context),
+						     CTX_SPSR);
+
+		/* PC should be retrieved in backup register if OK, else it can
+		 * be retrieved from non-secure context
+		 */
+		saved_pc = get_saved_pc();
+		if (saved_pc != 0U) {
+			next_image_info->pc = saved_pc;
+		} else {
+			next_image_info->pc =
+				read_ctx_reg(get_regs_ctx(cpu_context), CTX_LR);
+		}
+
+		regulator_core_resume();
 	}
 
 	return next_image_info;
@@ -109,20 +349,91 @@ static void stm32mp1_etzpc_early_setup(void)
 	etzpc_configure_tzma(STM32MP1_ETZPC_TZMA_SYSRAM, TZMA1_SECURE_RANGE);
 }
 
+static void update_fdt_scmi_node(void *external_fdt)
+{
+	int nodeoff;
+	const fdt32_t *cuint;
+	int val;
+	int len;
+
+	nodeoff = fdt_path_offset(external_fdt, "/firmware/scmi");
+	if (nodeoff < 0) {
+		return;
+	}
+	if (fdt_node_check_compatible(external_fdt, nodeoff, "linaro,scmi-optee") != 0) {
+		return;
+	}
+
+	cuint = fdt_getprop(external_fdt, nodeoff, "linaro,optee-channel-id", &len);
+	if (cuint == NULL) {
+		WARN("linaro,optee-channel-id is missing\n");
+		return;
+	}
+
+	val = fdt32_to_cpu(*cuint);
+
+	fdt_setprop_string(external_fdt, nodeoff, "compatible", "arm,scmi-smc");
+	fdt_delprop(external_fdt, nodeoff, "linaro,optee-channel-id");
+	fdt_setprop_u32(external_fdt, nodeoff, "arm,smc-id",
+			STM32_SIP_SMC_SCMI_AGENT0 + val);
+}
+
+static void update_fdt_optee_node(void *external_fdt)
+{
+	int nodeoff;
+
+	nodeoff = fdt_path_offset(external_fdt, "/firmware/optee");
+	if (nodeoff >= 0) {
+		fdt_del_node(external_fdt, nodeoff);
+	}
+	/* the reserved memory nodes are kept */
+}
+
+static void populate_ns_dt(u_register_t ns_dt_addr)
+{
+	void *external_fdt = (void *)ns_dt_addr;
+	int ret;
+
+	/* Map beginning of DDR as non-secure for non-secure DT update */
+	ret = mmap_add_dynamic_region(ns_dt_addr, ns_dt_addr, STM32MP_HW_CONFIG_MAX_SIZE,
+				      MT_NON_CACHEABLE | MT_EXECUTE_NEVER | MT_RW | MT_NS);
+	assert(ret == 0);
+
+	if (fdt_check_header(external_fdt) != 0) {
+		INFO("Non-secure device tree not found\n");
+		goto out;
+	}
+
+	ret = fdt_open_into(external_fdt, external_fdt, STM32MP_HW_CONFIG_MAX_SIZE);
+	if (ret < 0) {
+		WARN("Error opening DT %i\n", ret);
+		goto out;
+	}
+
+	update_fdt_scmi_node(external_fdt);
+
+	update_fdt_optee_node(external_fdt);
+
+	ret = fdt_pack(external_fdt);
+	if (ret < 0) {
+		WARN("Error packing DT %i\n", ret);
+	}
+
+out:
+	ret = mmap_remove_dynamic_region(ns_dt_addr, STM32MP_HW_CONFIG_MAX_SIZE);
+	assert(ret == 0);
+}
+
 /*******************************************************************************
  * Perform any BL32 specific platform actions.
  ******************************************************************************/
 void sp_min_early_platform_setup2(u_register_t arg0, u_register_t arg1,
 				  u_register_t arg2, u_register_t arg3)
 {
-	struct dt_node_info dt_uart_info;
-	int result;
 	bl_params_t *params_from_bl2 = (bl_params_t *)arg0;
-#if STM32MP_USE_STM32IMAGE
-	uintptr_t dt_addr = STM32MP_DTB_BASE;
-#else
 	uintptr_t dt_addr = arg1;
-#endif
+
+	stm32mp_setup_early_console();
 
 	/* Imprecise aborts can be masked in NonSecure */
 	write_scr(read_scr() | SCR_AW_BIT);
@@ -166,6 +477,10 @@ void sp_min_early_platform_setup2(u_register_t arg0, u_register_t arg1,
 		panic();
 	}
 
+	if ((bl33_image_ep_info.pc != 0U) && (bl33_image_ep_info.args.arg2 != 0U)) {
+		populate_ns_dt(bl33_image_ep_info.args.arg2);
+	}
+
 	if (bsec_probe() != 0) {
 		panic();
 	}
@@ -174,26 +489,81 @@ void sp_min_early_platform_setup2(u_register_t arg0, u_register_t arg1,
 		panic();
 	}
 
-	result = dt_get_stdout_uart_info(&dt_uart_info);
+	(void)stm32mp_uart_console_setup();
+
+	stm32mp1_etzpc_early_setup();
+
+	generic_delay_timer_init();
+
+	if (dt_pmic_status() > 0) {
+		initialize_pmic();
+	}
+
+	fixed_regulator_register();
+
+	if (regulator_core_config() != 0) {
+		ERROR("Regulator core config error\n");
+		panic();
+	}
+
+	disable_usb_phy_regulator();
+
+	initialize_pll1_settings();
+
+	stm32mp1_init_lp_states();
+}
+
+static void init_sec_peripherals(void)
+{
+	int ret;
+
+	/* Disable MCU subsystem protection */
+	stm32mp1_clk_mcuss_protect(false);
+
+	/* Init rtc driver */
+	ret = stm32_rtc_init();
+	if (ret < 0) {
+		WARN("RTC driver init error %i\n", ret);
+	}
+
+	/*  Init rng driver */
+	ret = stm32_rng_init();
+	if (ret < 0) {
+		WARN("RNG driver init error %i\n", ret);
+	}
 
-	if ((result > 0) && (dt_uart_info.status != 0U)) {
-		unsigned int console_flags;
+	/* Init tamper */
+	if (stm32_tamp_init() > 0) {
+		struct bkpregs_conf bkpregs_conf = {
+			.nb_zone1_regs = TAMP_BKP_SEC_NUMBER,
+			.nb_zone2_regs = TAMP_BKP_S_W_NS_R_NUMBER
+			/* zone3 all remaining */
+		};
 
-		if (console_stm32_register(dt_uart_info.base, 0,
-					   STM32MP_UART_BAUDRATE, &console) ==
-		    0) {
+		/* Enable BKP Register protection */
+		if (stm32_tamp_set_secure_bkpregs(&bkpregs_conf) < 0) {
 			panic();
 		}
 
-		console_flags = CONSOLE_FLAG_BOOT | CONSOLE_FLAG_CRASH |
-			CONSOLE_FLAG_TRANSLATE_CRLF;
-#ifdef DEBUG
-		console_flags |= CONSOLE_FLAG_RUNTIME;
-#endif
-		console_set_scope(&console, console_flags);
+		stm32_tamp_configure_secure_access(TAMP_REGS_IT_SECURE);
+
+		stm32_tamp_configure_internal(INT_TAMP1, TAMP_ENABLE, stm32mp1_tamper_action);
+		stm32_tamp_configure_internal(INT_TAMP2, TAMP_ENABLE, stm32mp1_tamper_action);
+		stm32_tamp_configure_internal(INT_TAMP3, TAMP_ENABLE, stm32mp1_tamper_action);
+		stm32_tamp_configure_internal(INT_TAMP4, TAMP_ENABLE, stm32mp1_tamper_action);
+
+		ret = stm32_tamp_set_config();
+		if (ret < 0) {
+			panic();
+		}
+
+		/* Enable timestamp for tamper */
+		stm32_rtc_set_tamper_timestamp();
 	}
 
-	stm32mp1_etzpc_early_setup();
+	if (stm32_timer_init() == 0) {
+		stm32mp1_calib_init();
+	}
 }
 
 /*******************************************************************************
@@ -201,17 +571,26 @@ void sp_min_early_platform_setup2(u_register_t arg0, u_register_t arg1,
  ******************************************************************************/
 void sp_min_platform_setup(void)
 {
-	generic_delay_timer_init();
+	stm32_init_low_power();
+
+	stm32mp_gic_init();
 
-	stm32mp1_gic_init();
+	init_sec_peripherals();
 
 	if (stm32_iwdg_init() < 0) {
 		panic();
 	}
 
+	configure_wakeup_interrupt();
+
 	stm32mp_lock_periph_registering();
 
 	stm32mp1_init_scmi_server();
+
+	/* Cold boot: clean-up regulators state */
+	if (get_saved_pc() == 0U) {
+		regulator_core_cleanup();
+	}
 }
 
 void sp_min_plat_arch_setup(void)
diff --git a/plat/st/stm32mp1/stm32mp1.S b/plat/st/stm32mp1/stm32mp1.S
index 85caa0a80..aee4f0ec2 100644
--- a/plat/st/stm32mp1/stm32mp1.S
+++ b/plat/st/stm32mp1/stm32mp1.S
@@ -1,16 +1,9 @@
 /*
- * Copyright (c) 2016-2021, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2016-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
-#if STM32MP_USE_STM32IMAGE
-#ifdef BL32_BIN_PATH
-.section .bl32_image
-.incbin BL32_BIN_PATH
-#endif
-#endif /* STM32MP_USE_STM32IMAGE */
-
 .section .bl2_image
 .incbin BL2_BIN_PATH
 
diff --git a/plat/st/stm32mp1/stm32mp1.ld.S b/plat/st/stm32mp1/stm32mp1.ld.S
index 945de99e5..1be82193b 100644
--- a/plat/st/stm32mp1/stm32mp1.ld.S
+++ b/plat/st/stm32mp1/stm32mp1.ld.S
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2021, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -16,7 +16,7 @@ OUTPUT_ARCH(PLATFORM_LINKER_ARCH)
 ENTRY(__BL2_IMAGE_START__)
 
 MEMORY {
-	HEADER (rw) : ORIGIN = 0x00000000, LENGTH = 0x3000
+	HEADER (rw) : ORIGIN = 0x00000000, LENGTH = STM32MP_HEADER_RESERVED_SIZE
 	RAM (rwx) : ORIGIN = STM32MP_BINARY_BASE, LENGTH = STM32MP_BINARY_SIZE
 }
 
@@ -43,11 +43,7 @@ SECTIONS
          * The strongest and only alignment contraint is MMU 4K page.
          * Indeed as images below will be removed, 4K pages will be re-used.
          */
-#if STM32MP_USE_STM32IMAGE
-        . = ( STM32MP_DTB_BASE - STM32MP_BINARY_BASE );
-#else
         . = ( STM32MP_BL2_DTB_BASE - STM32MP_BINARY_BASE );
-#endif /* STM32MP_USE_STM32IMAGE */
         __DTB_IMAGE_START__ = .;
         *(.dtb_image*)
         __DTB_IMAGE_END__ = .;
@@ -57,23 +53,15 @@ SECTIONS
          * The strongest and only alignment contraint is MMU 4K page.
          * Indeed as images below will be removed, 4K pages will be re-used.
          */
+#if SEPARATE_CODE_AND_RODATA
+        . = ( STM32MP_BL2_RO_BASE - STM32MP_BINARY_BASE );
+#else
         . = ( STM32MP_BL2_BASE - STM32MP_BINARY_BASE );
+#endif
         __BL2_IMAGE_START__ = .;
         *(.bl2_image*)
         __BL2_IMAGE_END__ = .;
 
-#if STM32MP_USE_STM32IMAGE && !defined(AARCH32_SP_OPTEE)
-        /*
-         * bl32 will be settled by bl2.
-         * The strongest and only alignment constraint is 8 words to simplify
-         * memraise8 assembly code.
-         */
-        . = ( STM32MP_BL32_BASE - STM32MP_BINARY_BASE );
-        __BL32_IMAGE_START__ = .;
-        *(.bl32_image*)
-        __BL32_IMAGE_END__ = .;
-#endif /* STM32MP_USE_STM32IMAGE && !defined(AARCH32_SP_OPTEE) */
-
         __DATA_END__ = .;
     } >RAM
 
diff --git a/plat/st/stm32mp1/stm32mp1_boot_device.c b/plat/st/stm32mp1/stm32mp1_boot_device.c
index 997335d0d..f4bac510a 100644
--- a/plat/st/stm32mp1/stm32mp1_boot_device.c
+++ b/plat/st/stm32mp1/stm32mp1_boot_device.c
@@ -1,9 +1,10 @@
 /*
- * Copyright (c) 2019, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2019-2021, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
+#include <assert.h>
 #include <errno.h>
 
 #include <drivers/nand.h>
@@ -13,30 +14,64 @@
 #include <lib/utils.h>
 #include <plat/common/platform.h>
 
-#define SZ_512		0x200U
-#define SZ_64M		0x4000000U
-
 #if STM32MP_RAW_NAND || STM32MP_SPI_NAND
+#if STM32MP13
+void plat_get_scratch_buffer(void **buffer_addr, size_t *buf_size)
+{
+	assert(buffer_addr != NULL);
+	assert(buf_size != NULL);
+
+	*buffer_addr = (void *)STM32MP_MTD_BUFFER;
+	*buf_size = PLATFORM_MTD_MAX_PAGE_SIZE;
+}
+#endif
+
 static int get_data_from_otp(struct nand_device *nand_dev, bool is_slc)
 {
-	int result;
 	uint32_t nand_param;
+	uint32_t nand2_param __unused;
 
 	/* Check if NAND parameters are stored in OTP */
-	result = bsec_shadow_read_otp(&nand_param, NAND_OTP);
-	if (result != BSEC_OK) {
-		ERROR("BSEC: NAND_OTP Error %i\n", result);
+	if (stm32_get_otp_value(NAND_OTP, &nand_param) != 0) {
+		ERROR("BSEC: NAND_OTP Error\n");
 		return -EACCES;
 	}
 
 	if (nand_param == 0U) {
+#if STM32MP13
+		if (is_slc) {
+			return 0;
+		}
+#endif
+#if STM32MP15
 		return 0;
+#endif
 	}
 
 	if ((nand_param & NAND_PARAM_STORED_IN_OTP) == 0U) {
+#if STM32MP13
+		if (is_slc) {
+			goto ecc;
+		}
+#endif
+#if STM32MP15
 		goto ecc;
+#endif
 	}
 
+#if STM32MP13
+	if (stm32_get_otp_value(NAND2_OTP, &nand2_param) != 0) {
+		ERROR("BSEC: NAND_OTP Error\n");
+		return -EACCES;
+	}
+
+	/* Check OTP configuration for this device */
+	if ((((nand2_param & NAND2_CONFIG_DISTRIB) == NAND2_PNAND_NAND1_SNAND_NAND2) && !is_slc) ||
+	    (((nand2_param & NAND2_CONFIG_DISTRIB) == NAND2_PNAND_NAND2_SNAND_NAND1) && is_slc)) {
+		nand_param = nand2_param << (NAND_PAGE_SIZE_SHIFT - NAND2_PAGE_SIZE_SHIFT);
+	}
+#endif
+
 	/* NAND parameter shall be read from OTP */
 	if ((nand_param & NAND_WIDTH_MASK) != 0U) {
 		nand_dev->buswidth = NAND_BUS_WIDTH_16;
@@ -157,6 +192,7 @@ int plat_get_spi_nand_data(struct spinand_device *device)
 int plat_get_nor_data(struct nor_device *device)
 {
 	device->size = SZ_64M;
+	device->flags |= SPI_NOR_USE_BANK;
 
 	zeromem(&device->read_op, sizeof(struct spi_mem_op));
 	device->read_op.cmd.opcode = SPI_NOR_OP_READ_1_1_4;
diff --git a/plat/st/stm32mp1/stm32mp1_context.c b/plat/st/stm32mp1/stm32mp1_context.c
index cf8a91eb4..4ed88e6c4 100644
--- a/plat/st/stm32mp1/stm32mp1_context.c
+++ b/plat/st/stm32mp1/stm32mp1_context.c
@@ -1,35 +1,634 @@
 /*
- * Copyright (c) 2017-2019, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2017-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
 #include <errno.h>
+#include <string.h>
 
-#include <platform_def.h>
-
-#include <drivers/st/stm32mp1_clk.h>
+#include <arch_helpers.h>
+#include <context.h>
+#include <drivers/arm/tzc400.h>
+#include <drivers/clk.h>
+#include <drivers/regulator.h>
+#include <drivers/st/stm32_rtc.h>
+#include <drivers/st/stm32mp_clkfunc.h>
+#include <drivers/st/stm32mp1_ddr_helpers.h>
+#include <drivers/st/stm32mp1_ddr_regs.h>
 #include <dt-bindings/clock/stm32mp1-clks.h>
+#include <lib/el3_runtime/context_mgmt.h>
 #include <lib/mmio.h>
+#include <lib/utils.h>
+#include <lib/xlat_tables/xlat_tables_v2.h>
+#include <smccc_helpers.h>
 
+#include <boot_api.h>
+#include <platform_def.h>
 #include <stm32mp1_context.h>
+#include <stm32mp1_critic_power.h>
+
+#define TRAINING_AREA_SIZE		64
+
+#define BL32_CANARY_ID			U(0x424c3332)
+
+/*
+ * MAILBOX_MAGIC relates to struct backup_data_s as defined
+ *
+ * MAILBOX_MAGIC_V1:
+ * Context provides magic, resume entry, zq0cr0 zdata and DDR training buffer.
+ *
+ * MAILBOX_MAGIC_V2:
+ * Context provides V1 content and PLL1 dual OPP settings structure (86 bytes).
+ *
+ * MAILBOX_MAGIC_V3:
+ * Context provides V2 content, low power entry point, BL2 code start, end and
+ * BL2_END (102 bytes). And, only for STM32MP13, adds MCE master key (16 bytes).
+ */
+#define MAILBOX_MAGIC_V1		(0x0001 << 16)
+#define MAILBOX_MAGIC_V2		(0x0002 << 16)
+#define MAILBOX_MAGIC_V3		(0x0003 << 16)
+#define MAILBOX_MAGIC			(MAILBOX_MAGIC_V3 | \
+					 TRAINING_AREA_SIZE)
+
+#define MAGIC_ID(magic)			((magic) & GENMASK_32(31, 16))
+#define MAGIC_AREA_SIZE(magic)		((magic) & GENMASK_32(15, 0))
+
+#if (PLAT_MAX_OPP_NB != 2) || (PLAT_MAX_PLLCFG_NB != 6)
+#error MAILBOX_MAGIC_V2/_V3 does not support expected PLL1 settings
+#endif
+
+/* pll_settings structure size definitions (reference to clock driver) */
+#define PLL1_SETTINGS_SIZE		(((PLAT_MAX_OPP_NB * \
+					  (PLAT_MAX_PLLCFG_NB + 3)) + 1) * \
+					 sizeof(uint32_t))
 
-#define TAMP_BOOT_ITF_BACKUP_REG_ID	U(20)
-#define TAMP_BOOT_ITF_MASK		U(0x0000FF00)
-#define TAMP_BOOT_ITF_SHIFT		8
+/* Set to 600 bytes to be a bit flexible but could be optimized if needed */
+#define CLOCK_CONTEXT_SIZE		600
 
-int stm32_save_boot_interface(uint32_t interface, uint32_t instance)
+/* SCMI needs only 24 bits to save the state of the 24 exposed clocks */
+#define SCMI_CONTEXT_SIZE		(sizeof(uint8_t) * 4)
+
+struct backup_data_s {
+	uint32_t magic;
+	uint32_t core0_resume_hint;
+	uint32_t zq0cr0_zdata;
+	uint8_t ddr_training_backup[TRAINING_AREA_SIZE];
+	uint8_t pll1_settings[PLL1_SETTINGS_SIZE];
+	uint32_t low_power_ep;
+	uint32_t bl2_code_base;
+	uint32_t bl2_code_end;
+	uint32_t bl2_end;
+#if STM32MP13
+	uint8_t mce_mkey[MCE_KEY_SIZE_IN_BYTES];
+	struct stm32_mce_region_s mce_regions[MCE_IP_MAX_REGION_NB];
+#endif
+};
+
+#if defined(IMAGE_BL32)
+#define STM32MP1_TZC_REGION_OFFSET(num_region)		(U(0x20) * ((num_region) - U(1)))
+#define STM32MP1_TZC_REGION_LOW(num_region)		(U(0x120) + \
+							 STM32MP1_TZC_REGION_OFFSET(num_region))
+#define STM32MP1_TZC_REGION_TOP(num_region)		(U(0x128) + \
+							 STM32MP1_TZC_REGION_OFFSET(num_region))
+#define STM32MP1_TZC_REGION_ATTRIBUTE(num_region)	(U(0x130) + \
+							 STM32MP1_TZC_REGION_OFFSET(num_region))
+#define STM32MP1_TZC_REGION_ACCESS(num_region)		(U(0x134) + \
+							 STM32MP1_TZC_REGION_OFFSET(num_region))
+
+struct tzc_regions {
+	uint32_t low;
+	uint32_t top;
+	uint32_t attribute;
+	uint32_t access;
+};
+
+struct backup_bl32_data_s {
+	uint32_t canary_id;
+	smc_ctx_t saved_smc_context[PLATFORM_CORE_COUNT];
+	cpu_context_t saved_cpu_context[PLATFORM_CORE_COUNT];
+	struct stm32_rtc_calendar rtc;
+	unsigned long long stgen;
+	uint8_t clock_cfg[CLOCK_CONTEXT_SIZE];
+	uint8_t scmi_context[SCMI_CONTEXT_SIZE];
+	uint8_t regul_context[PLAT_BACKUP_REGULATOR_SIZE];
+	struct tzc_regions tzc_backup_context[STM32MP1_TZC_MAX_REGIONS];
+};
+
+static struct backup_bl32_data_s *get_bl32_backup_data(void)
 {
-	uint32_t bkpr_itf_idx = tamp_bkpr(TAMP_BOOT_ITF_BACKUP_REG_ID);
+	return (struct backup_bl32_data_s *)(STM32MP_BACKUP_RAM_BASE +
+					     sizeof(struct backup_data_s));
+}
+#endif
 
-	stm32mp_clk_enable(RTCAPB);
+uint32_t stm32_pm_get_optee_ep(void)
+{
+	struct backup_data_s *backup_data;
+	uint32_t ep;
 
-	mmio_clrsetbits_32(bkpr_itf_idx,
-			   TAMP_BOOT_ITF_MASK,
-			   ((interface << 4) | (instance & 0xFU)) <<
-			   TAMP_BOOT_ITF_SHIFT);
+#if STM32MP15
+	clk_enable(BKPSRAM);
+#endif
+
+	/* Context & Data to be saved at the beginning of Backup SRAM */
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	switch (MAGIC_ID(backup_data->magic)) {
+	case MAILBOX_MAGIC_V1:
+	case MAILBOX_MAGIC_V2:
+	case MAILBOX_MAGIC_V3:
+		if (MAGIC_AREA_SIZE(backup_data->magic) != TRAINING_AREA_SIZE) {
+			panic();
+		}
+		break;
+	default:
+		ERROR("PM context: bad magic\n");
+		panic();
+	}
+
+	ep = backup_data->core0_resume_hint;
+
+#if STM32MP15
+	clk_disable(BKPSRAM);
+#endif
+
+	return ep;
+}
 
-	stm32mp_clk_disable(RTCAPB);
+void stm32_clean_context(void)
+{
+	clk_enable(BKPSRAM);
+
+#if defined(IMAGE_BL2)
+	zeromem((void *)STM32MP_BACKUP_RAM_BASE, sizeof(struct backup_data_s));
+#elif defined(IMAGE_BL32)
+	zeromem((void *)get_bl32_backup_data(), sizeof(struct backup_bl32_data_s));
+#endif
+
+	clk_disable(BKPSRAM);
+}
+
+#if defined(IMAGE_BL32)
+void stm32mp1_pm_save_clock_cfg(size_t offset, uint8_t *data, size_t size)
+{
+	struct backup_bl32_data_s *backup_data = get_bl32_backup_data();
+
+	if (offset + size > sizeof(backup_data->clock_cfg)) {
+		panic();
+	}
+
+	clk_enable(BKPSRAM);
+
+	memcpy(backup_data->clock_cfg + offset, data, size);
+
+	clk_disable(BKPSRAM);
+}
+
+void stm32mp1_pm_restore_clock_cfg(size_t offset, uint8_t *data, size_t size)
+{
+	struct backup_bl32_data_s *backup_data = get_bl32_backup_data();
+
+	if (offset + size > sizeof(backup_data->clock_cfg))
+		panic();
+
+	clk_enable(BKPSRAM);
+
+	memcpy(data, backup_data->clock_cfg + offset, size);
+
+	clk_disable(BKPSRAM);
+}
+
+static void tzc_backup_context_save(struct tzc_regions *regions)
+{
+	unsigned int i;
+
+	assert(regions != NULL);
+
+	zeromem(regions, sizeof(struct tzc_regions) * STM32MP1_TZC_MAX_REGIONS);
+
+	tzc400_init(STM32MP1_TZC_BASE);
+
+	for (i = 0U; i < STM32MP1_TZC_MAX_REGIONS; i++) {
+		unsigned int reg_num = i + 1U;
+
+		regions[i].low = mmio_read_32(STM32MP1_TZC_BASE +
+					      STM32MP1_TZC_REGION_LOW(reg_num));
+		regions[i].top = mmio_read_32(STM32MP1_TZC_BASE +
+					      STM32MP1_TZC_REGION_TOP(reg_num));
+		regions[i].attribute = mmio_read_32(STM32MP1_TZC_BASE +
+						    STM32MP1_TZC_REGION_ATTRIBUTE(reg_num));
+		regions[i].access = mmio_read_32(STM32MP1_TZC_BASE +
+						 STM32MP1_TZC_REGION_ACCESS(reg_num));
+	}
+}
+
+static void tzc_backup_context_restore(struct tzc_regions *regions)
+{
+	unsigned int i;
+
+	assert(regions != NULL);
+
+	tzc400_init(STM32MP1_TZC_BASE);
+
+	for (i = 0U; i < STM32MP1_TZC_MAX_REGIONS; i++) {
+		unsigned int reg_num = i + 1U;
+
+		mmio_write_32(STM32MP1_TZC_BASE + STM32MP1_TZC_REGION_LOW(reg_num),
+			      regions[i].low);
+		mmio_write_32(STM32MP1_TZC_BASE + STM32MP1_TZC_REGION_TOP(reg_num),
+			      regions[i].top);
+		mmio_write_32(STM32MP1_TZC_BASE + STM32MP1_TZC_REGION_ATTRIBUTE(reg_num),
+			      regions[i].attribute);
+		mmio_write_32(STM32MP1_TZC_BASE + STM32MP1_TZC_REGION_ACCESS(reg_num),
+			      regions[i].access);
+	}
+
+	/* Disable Region 0 access */
+	tzc400_configure_region0(TZC_REGION_S_NONE, 0);
+}
+
+int stm32_save_context(uint32_t zq0cr0_zdata,
+		       struct stm32_rtc_calendar *rtc_time,
+		       unsigned long long stgen_cnt)
+{
+	void *smc_context;
+	void *cpu_context;
+	struct backup_data_s *backup_data;
+	struct backup_bl32_data_s *backup_bl32_data;
+
+	stm32mp1_clock_suspend();
+
+	clk_enable(BKPSRAM);
+
+	/* Context & Data to be saved at the beginning of Backup SRAM */
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	/* Save BL32 context data provided to BL2 */
+	backup_data->magic = MAILBOX_MAGIC;
+
+	backup_data->zq0cr0_zdata = zq0cr0_zdata;
+
+	stm32mp1_clk_lp_save_opp_pll1_settings(backup_data->pll1_settings,
+					       sizeof(backup_data->pll1_settings));
+
+	/* Save the BL32 specific data */
+	backup_bl32_data = get_bl32_backup_data();
+
+	backup_bl32_data->canary_id = BL32_CANARY_ID;
+
+	/* Retrieve smc context struct address */
+	smc_context = smc_get_ctx(NON_SECURE);
+
+	/* Retrieve smc context struct address */
+	cpu_context = cm_get_context(NON_SECURE);
+
+	/* Save context in Backup SRAM */
+	memcpy(&backup_bl32_data->saved_smc_context[0], smc_context,
+	       sizeof(smc_ctx_t) * PLATFORM_CORE_COUNT);
+	memcpy(&backup_bl32_data->saved_cpu_context[0], cpu_context,
+	       sizeof(cpu_context_t) * PLATFORM_CORE_COUNT);
+
+	memcpy(&backup_bl32_data->rtc, rtc_time, sizeof(struct stm32_rtc_calendar));
+	backup_bl32_data->stgen = stgen_cnt;
+
+	stm32mp1_pm_save_scmi_state(backup_bl32_data->scmi_context,
+				    sizeof(backup_bl32_data->scmi_context));
+
+	save_clock_pm_context();
+
+	regulator_core_backup_context(backup_bl32_data->regul_context,
+				      sizeof(backup_bl32_data->regul_context));
+
+	tzc_backup_context_save(backup_bl32_data->tzc_backup_context);
+
+	clk_disable(BKPSRAM);
+
+	return 0;
+}
+
+int stm32_restore_context(void)
+{
+	void *smc_context;
+	void *cpu_context;
+	struct backup_data_s *backup_data;
+	struct backup_bl32_data_s *backup_bl32_data;
+	struct stm32_rtc_calendar current_calendar;
+	unsigned long long stdby_time_in_ms;
+
+	/* Context & Data to be saved at the beginning of Backup SRAM */
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	clk_enable(BKPSRAM);
+
+	stm32mp1_clk_lp_load_opp_pll1_settings(backup_data->pll1_settings,
+					       sizeof(backup_data->pll1_settings));
+
+	backup_bl32_data = get_bl32_backup_data();
+
+	if (backup_bl32_data->canary_id != BL32_CANARY_ID) {
+		ERROR("Incorrect BL32 backup data\n");
+		return -EINVAL;
+	}
+
+	/* Retrieve smc context struct address */
+	smc_context = smc_get_ctx(NON_SECURE);
+
+	/* Retrieve smc context struct address */
+	cpu_context = cm_get_context(NON_SECURE);
+
+	restore_clock_pm_context();
+
+	tzc_backup_context_restore(backup_bl32_data->tzc_backup_context);
+
+	stm32mp1_pm_restore_scmi_state(backup_bl32_data->scmi_context,
+				       sizeof(backup_bl32_data->scmi_context));
+
+	/* Restore data from Backup SRAM */
+	memcpy(smc_context, backup_bl32_data->saved_smc_context,
+	       sizeof(smc_ctx_t) * PLATFORM_CORE_COUNT);
+	memcpy(cpu_context, backup_bl32_data->saved_cpu_context,
+	       sizeof(cpu_context_t) * PLATFORM_CORE_COUNT);
+
+	/* Restore STGEN counter with standby mode length */
+	stm32_rtc_get_calendar(&current_calendar);
+	stdby_time_in_ms = stm32_rtc_diff_calendar(&current_calendar,
+						   &backup_bl32_data->rtc);
+	stm32mp_stgen_restore_counter(backup_bl32_data->stgen, stdby_time_in_ms);
+
+	regulator_core_restore_context(backup_bl32_data->regul_context,
+				       sizeof(backup_bl32_data->regul_context));
+
+	clk_disable(BKPSRAM);
+
+	stm32mp1_clock_resume();
 
 	return 0;
 }
+
+unsigned long long stm32_get_stgen_from_context(void)
+{
+	struct backup_bl32_data_s *backup_data;
+	unsigned long long stgen_cnt;
+
+	clk_enable(BKPSRAM);
+
+	backup_data = get_bl32_backup_data();
+
+	stgen_cnt = backup_data->stgen;
+
+	clk_disable(BKPSRAM);
+
+	return stgen_cnt;
+}
+
+void stm32_context_get_bl2_low_power_params(uintptr_t *bl2_code_base,
+					    uintptr_t *bl2_code_end,
+					    uintptr_t *bl2_end)
+{
+	struct backup_data_s *backup_data;
+
+	clk_enable(BKPSRAM);
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	if (MAGIC_ID(backup_data->magic) != MAILBOX_MAGIC_V3) {
+		panic();
+	}
+
+	*bl2_code_base = (uintptr_t)backup_data->bl2_code_base;
+	*bl2_code_end = (uintptr_t)backup_data->bl2_code_end;
+	*bl2_end = (uintptr_t)backup_data->bl2_end;
+
+	clk_disable(BKPSRAM);
+}
+
+#endif /* IMAGE_BL32 */
+
+#if defined(IMAGE_BL2)
+void stm32_context_save_bl2_param(void)
+{
+	struct backup_data_s *backup_data;
+
+	clk_enable(BKPSRAM);
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	backup_data->low_power_ep = (uint32_t)&stm32_pwr_down_wfi_wrapper;
+	backup_data->bl2_code_base = BL_CODE_BASE;
+	backup_data->bl2_code_end = BL_CODE_END;
+	backup_data->bl2_end = BL2_END;
+	backup_data->magic = MAILBOX_MAGIC_V3;
+	backup_data->zq0cr0_zdata = ddr_get_io_calibration_val();
+
+	clk_disable(BKPSRAM);
+}
+#endif
+
+uint32_t stm32_get_zdata_from_context(void)
+{
+	struct backup_data_s *backup_data;
+	uint32_t zdata;
+
+	clk_enable(BKPSRAM);
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	zdata = (backup_data->zq0cr0_zdata >> DDRPHYC_ZQ0CRN_ZDATA_SHIFT) &
+		DDRPHYC_ZQ0CRN_ZDATA_MASK;
+
+	clk_disable(BKPSRAM);
+
+	return zdata;
+}
+
+static int pll1_settings_in_context(struct backup_data_s *backup_data)
+{
+	switch (MAGIC_ID(backup_data->magic)) {
+	case MAILBOX_MAGIC_V1:
+		return -ENOENT;
+	case MAILBOX_MAGIC_V2:
+	case MAILBOX_MAGIC_V3:
+		assert(MAGIC_AREA_SIZE(backup_data->magic) ==
+		       TRAINING_AREA_SIZE);
+		return 0;
+	default:
+		panic();
+	}
+}
+
+int stm32_get_pll1_settings_from_context(void)
+{
+	struct backup_data_s *backup_data;
+	int ret;
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	clk_enable(BKPSRAM);
+
+	ret = pll1_settings_in_context(backup_data);
+	if (ret == 0) {
+		uint8_t *data = (uint8_t *)backup_data->pll1_settings;
+		size_t size = sizeof(backup_data->pll1_settings);
+
+		stm32mp1_clk_lp_load_opp_pll1_settings(data, size);
+	}
+
+	clk_disable(BKPSRAM);
+
+	return ret;
+}
+
+bool stm32_are_pll1_settings_valid_in_context(void)
+{
+	struct backup_data_s *backup_data;
+	uint32_t *data;
+	bool is_valid;
+
+	clk_enable(BKPSRAM);
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+	data = (uint32_t *)backup_data->pll1_settings;
+
+	is_valid = (data[0] == PLL1_SETTINGS_VALID_ID);
+
+	clk_disable(BKPSRAM);
+
+	return is_valid;
+}
+
+bool stm32_pm_context_is_valid(void)
+{
+	struct backup_data_s *backup_data;
+	bool ret;
+
+	clk_enable(BKPSRAM);
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	switch (MAGIC_ID(backup_data->magic)) {
+	case MAILBOX_MAGIC_V1:
+	case MAILBOX_MAGIC_V2:
+	case MAILBOX_MAGIC_V3:
+		ret = true;
+		break;
+	default:
+		ret = false;
+		break;
+	}
+
+	clk_disable(BKPSRAM);
+
+	return ret;
+}
+
+#if defined(IMAGE_BL32)
+/*
+ * When returning from STANDBY, the 64 first bytes of DDR will be overwritten
+ * during DDR DQS training. This area must then be saved before going to
+ * standby, and will be restored after
+ */
+void stm32_save_ddr_training_area(void)
+{
+	struct backup_data_s *backup_data;
+	int ret __unused;
+
+	clk_enable(BKPSRAM);
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	ret = mmap_add_dynamic_region(STM32MP_DDR_BASE, STM32MP_DDR_BASE,
+				      PAGE_SIZE, MT_MEMORY | MT_RW | MT_NS);
+	assert(ret == 0);
+
+	flush_dcache_range(STM32MP_DDR_BASE, TRAINING_AREA_SIZE);
+
+	memcpy(&backup_data->ddr_training_backup,
+	       (const uint32_t *)STM32MP_DDR_BASE,
+	       TRAINING_AREA_SIZE);
+	dsb();
+
+	ret = mmap_remove_dynamic_region(STM32MP_DDR_BASE, PAGE_SIZE);
+	assert(ret == 0);
+
+	clk_disable(BKPSRAM);
+}
+#endif
+
+void stm32_restore_ddr_training_area(void)
+{
+	struct backup_data_s *backup_data;
+
+	clk_enable(BKPSRAM);
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	memcpy((uint32_t *)STM32MP_DDR_BASE,
+	       &backup_data->ddr_training_backup,
+	       TRAINING_AREA_SIZE);
+	dsb();
+
+	clk_disable(BKPSRAM);
+}
+
+#if STM32MP13
+void stm32mp1_pm_save_mce_mkey_in_context(uint8_t *data)
+{
+	struct backup_data_s *backup_data;
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	clk_enable(BKPSRAM);
+
+	memcpy(backup_data->mce_mkey, data, MCE_KEY_SIZE_IN_BYTES);
+
+	clk_disable(BKPSRAM);
+}
+
+void stm32mp1_pm_get_mce_mkey_from_context(uint8_t *data)
+{
+	struct backup_data_s *backup_data;
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	clk_enable(BKPSRAM);
+
+	memcpy(data, backup_data->mce_mkey, MCE_KEY_SIZE_IN_BYTES);
+
+	clk_disable(BKPSRAM);
+}
+
+void stm32mp1_pm_save_mce_region(uint32_t index, struct stm32_mce_region_s *config)
+{
+	struct backup_data_s *backup_data;
+
+	if (index >= MCE_IP_MAX_REGION_NB) {
+		panic();
+	}
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	clk_enable(BKPSRAM);
+
+	memcpy(&backup_data->mce_regions[index], config, sizeof(struct stm32_mce_region_s));
+
+	clk_disable(BKPSRAM);
+}
+
+void stm32mp1_pm_get_mce_region(uint32_t index, struct stm32_mce_region_s *config)
+{
+	struct backup_data_s *backup_data;
+
+	if (index >= MCE_IP_MAX_REGION_NB) {
+		panic();
+	}
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	clk_enable(BKPSRAM);
+
+	memcpy(config, &backup_data->mce_regions[index], sizeof(struct stm32_mce_region_s));
+
+	clk_disable(BKPSRAM);
+}
+#endif
diff --git a/plat/st/stm32mp1/stm32mp1_critic_power.c b/plat/st/stm32mp1/stm32mp1_critic_power.c
new file mode 100644
index 000000000..a84f38b29
--- /dev/null
+++ b/plat/st/stm32mp1/stm32mp1_critic_power.c
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2019-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/arm/gicv2.h>
+#include <drivers/generic_delay_timer.h>
+#include <drivers/st/stm32_iwdg.h>
+#include <drivers/st/stm32mp_clkfunc.h>
+#include <drivers/st/stm32mp_pmic.h>
+#include <drivers/st/stm32mp1_ddr_helpers.h>
+#include <dt-bindings/power/stm32mp1-power.h>
+
+#include <platform_def.h>
+#include <stm32mp1_context.h>
+#include <stm32mp1_critic_power.h>
+
+static void cstop_critic_enter(uint32_t mode)
+{
+	/* Init generic timer that is needed for udelay used in ddr driver */
+	generic_delay_timer_init();
+
+	/* Switch to Software Self-Refresh mode */
+	ddr_set_sr_mode(DDR_SSR_MODE);
+
+	/*
+	 * Set DDR in Self-refresh,.
+	 * This is also the procedure awaited when switching off power supply.
+	 */
+	if (ddr_standby_sr_entry() != 0) {
+		ERROR("Unable to put DDR in SR\n");
+		if (mode != STM32_PM_SHUTDOWN) {
+			panic();
+		}
+	}
+}
+
+static void shutdown_critic_enter(void)
+{
+	if (dt_pmic_status() > 0) {
+		if (!initialize_pmic_i2c()) {
+			panic();
+		}
+
+		pmic_switch_off();
+	}
+}
+
+/*
+ * stm32_exit_cstop_critic - Exit from CSTOP mode reenable DDR
+ */
+void stm32_pwr_cstop_critic_exit(void)
+{
+#if STM32MP13
+	bsec_write_scratch((uint32_t)0U);
+#endif
+
+#if defined(IMAGE_BL2)
+	/* Init generic timer that is needed for udelay used in ddr driver */
+	stm32mp_stgen_restore_rate();
+
+	generic_delay_timer_init();
+#endif
+
+	if (ddr_sw_self_refresh_exit() != 0) {
+		panic();
+	}
+}
+
+void stm32_pwr_down_wfi_load(bool is_cstop, uint32_t mode)
+{
+	if (mode == STM32_PM_CSTOP_ALLOW_LPLV_STOP2) {
+#if STM32MP15
+		ERROR("LPLV-Stop2 mode not supported\n");
+		panic();
+#endif
+
+#if STM32MP13
+		/* If mode is STOP 2, set the entry point */
+		bsec_write_scratch((uint32_t)stm32_pwr_back_from_stop2);
+#endif
+	}
+
+	if (mode != STM32_PM_CSLEEP_RUN) {
+		dcsw_op_all(DC_OP_CISW);
+	}
+
+	if (is_cstop) {
+		cstop_critic_enter(mode);
+	}
+
+	if (mode == STM32_PM_SHUTDOWN) {
+		shutdown_critic_enter();
+	}
+
+	/*
+	 * Synchronize on memory accesses and instruction flow before the WFI
+	 * instruction.
+	 */
+	dsb();
+	isb();
+	wfi();
+
+	stm32_iwdg_refresh();
+
+	if (is_cstop) {
+		stm32_pwr_cstop_critic_exit();
+	}
+}
+
+#if STM32MP13
+void stm32_pwr_call_optee_ep(void)
+{
+	void (*optee_ep)(void);
+
+	optee_ep = (void (*)(void))stm32_pm_get_optee_ep();
+
+	optee_ep();
+
+	/* This shouldn't be reached */
+	panic();
+}
+#endif
+
+#if defined(IMAGE_BL32)
+extern void wfi_svc_int_enable(uintptr_t stack_addr);
+static uint32_t int_stack[STM32MP_INT_STACK_SIZE];
+
+void stm32_pwr_down_wfi(bool is_cstop, uint32_t mode)
+{
+	uint32_t interrupt = GIC_SPURIOUS_INTERRUPT;
+
+	if (mode != STM32_PM_CSLEEP_RUN) {
+		dcsw_op_all(DC_OP_CISW);
+	}
+
+	if (is_cstop) {
+		cstop_critic_enter(mode);
+	}
+
+	if (mode == STM32_PM_SHUTDOWN) {
+		shutdown_critic_enter();
+	}
+
+	stm32mp1_calib_set_wakeup(false);
+
+	while (interrupt == GIC_SPURIOUS_INTERRUPT &&
+	       !stm32mp1_calib_get_wakeup()) {
+		wfi_svc_int_enable((uintptr_t)&int_stack[0]);
+
+		interrupt = gicv2_acknowledge_interrupt();
+
+		if (interrupt != GIC_SPURIOUS_INTERRUPT) {
+			gicv2_end_of_interrupt(interrupt);
+		}
+
+		stm32_iwdg_refresh();
+	}
+
+	if (is_cstop) {
+		stm32_pwr_cstop_critic_exit();
+	}
+}
+#endif
diff --git a/plat/st/stm32mp1/stm32mp1_critic_power_wrapper.S b/plat/st/stm32mp1/stm32mp1_critic_power_wrapper.S
new file mode 100644
index 000000000..d7981d61c
--- /dev/null
+++ b/plat/st/stm32mp1/stm32mp1_critic_power_wrapper.S
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2019-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <platform_def.h>
+
+#include <arch.h>
+#include <asm_macros.S>
+#include <common/bl_common.h>
+#include <drivers/st/stm32_gpio.h>
+#include <smccc_helpers.h>
+
+	.global	stm32_pwr_down_wfi_load
+	.global	stm32_pwr_cstop_critic_exit
+	.global	stm32_pwr_down_wfi_wrapper
+#if STM32MP13
+	.global	stm32_pwr_back_from_stop2
+	.global	stm32_pwr_call_optee_ep
+#endif
+	.global	bl2_vector_table
+	.global	disable_mmu_secure
+	.global	__STACKS_END__
+
+.section .data
+	.balign 4
+saved_sp:		.word	0x00000000
+saved_vbar:		.word	0x00000000
+saved_mvbar:		.word	0x00000000
+
+.section .text
+	.align	5
+
+func stm32_pwr_down_wfi_wrapper
+	push	{r4,r5,r6,lr}
+
+	# Save r0 and r1 in  r2 and r3, as they are used in disable_mmu_secure
+	mov	r2, r0
+	mov	r3, r1
+
+	# Save current sp in sp1
+	ldr	r1, =saved_sp
+	str	sp, [r1]
+
+	# Save current VBAR in vbar1
+	ldr	r1, =saved_vbar
+	ldcopr	r0, VBAR
+	str	r0, [r1]
+
+	# Save current MVBAR in mvbar1
+	ldr	r1, =saved_mvbar
+	ldcopr	r0, MVBAR
+	str	r0, [r1]
+
+	# Reuse BL2 vector table for VBAR and MVBAR
+	ldr	r1, =bl2_vector_table
+	stcopr	r1, VBAR
+	stcopr	r1, MVBAR
+
+	# Set sp to BL2 STACK (as BL2 is not using it anymore)
+	ldr	sp, =__STACKS_END__
+
+	# Disable MMU as TLB are still stored in DDR,
+	# and in few instructions DDR won't be readable
+	bl	disable_mmu_secure
+
+	# dsb is done in disable mmu
+	# isb is done in disable mmu
+
+	mov	r0, r2
+	mov	r1, r3
+
+	bl	stm32_pwr_down_wfi_load
+
+	# Restore stack
+	ldr	r1, =saved_sp
+	ldr	sp, [r1]
+
+	# Restore VBAR
+	ldr	r1, =saved_vbar
+	ldr	r0, [r1]
+	stcopr	r0, VBAR
+
+	# Restore MVBAR
+	ldr	r1, =saved_mvbar
+	ldr	r0, [r1]
+	stcopr	r0, MVBAR
+
+	# Synchronize on memory access and instruction
+	# after resetting stack/IT handler
+	dsb
+	isb
+
+	pop	{r4,r5,r6,pc}
+endfunc stm32_pwr_down_wfi_wrapper
+
+#if STM32MP13
+func stm32_pwr_back_from_stop2
+	# switch to monitor mode.
+	cps	#MODE32_mon
+
+	ldr	sp, =__STACKS_END__
+
+	ldr	r1, =bl2_vector_table
+	stcopr	r1, VBAR
+	stcopr	r1, MVBAR
+
+	# exit ddr from self refresh
+	bl	stm32_pwr_cstop_critic_exit
+
+	# Restore stack
+	ldr	r1, =saved_sp
+	ldr	sp, [r1]
+
+	# Restore VBAR
+	ldr	r1, =saved_vbar
+	ldr	r0, [r1]
+	stcopr	r0, VBAR
+
+	# Restore MVBAR
+	ldr	r1, =saved_mvbar
+	ldr	r0, [r1]
+	stcopr	r0, MVBAR
+
+	# Synchronize on memory access and instruction
+	# after resetting stack/IT handler
+	dsb
+	isb
+
+	bl stm32_pwr_call_optee_ep
+
+endfunc stm32_pwr_back_from_stop2
+#endif
diff --git a/plat/st/stm32mp1/stm32mp1_dbgmcu.c b/plat/st/stm32mp1/stm32mp1_dbgmcu.c
index d0264968c..b70402111 100644
--- a/plat/st/stm32mp1/stm32mp1_dbgmcu.c
+++ b/plat/st/stm32mp1/stm32mp1_dbgmcu.c
@@ -1,15 +1,17 @@
 /*
- * Copyright (c) 2016-2019, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2016-2021, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
+#include <assert.h>
 #include <errno.h>
 
 #include <platform_def.h>
 
 #include <common/debug.h>
 #include <drivers/st/bsec.h>
+#include <drivers/st/bsec2_reg.h>
 #include <drivers/st/stm32mp1_rcc.h>
 #include <lib/mmio.h>
 #include <lib/utils_def.h>
@@ -17,44 +19,32 @@
 #include <stm32mp1_dbgmcu.h>
 
 #define DBGMCU_IDC		U(0x00)
-#define DBGMCU_APB4FZ1		U(0x2C)
 
 #define DBGMCU_IDC_DEV_ID_MASK	GENMASK(11, 0)
 #define DBGMCU_IDC_REV_ID_MASK	GENMASK(31, 16)
 #define DBGMCU_IDC_REV_ID_SHIFT	16
 
-#define DBGMCU_APB4FZ1_IWDG2	BIT(2)
-
-static uintptr_t get_rcc_base(void)
-{
-	/* This is called before stm32mp_rcc_base() is available */
-	return RCC_BASE;
-}
-
 static int stm32mp1_dbgmcu_init(void)
 {
-	uint32_t dbg_conf;
-	uintptr_t rcc_base = get_rcc_base();
-
-	dbg_conf = bsec_read_debug_conf();
-
-	if ((dbg_conf & BSEC_DBGSWGEN) == 0U) {
-		uint32_t result = bsec_write_debug_conf(dbg_conf |
-							BSEC_DBGSWGEN);
-
-		if (result != BSEC_OK) {
-			ERROR("Error enabling DBGSWGEN\n");
-			return -1;
-		}
+	if ((bsec_read_debug_conf() & BSEC_DBGSWGEN) == 0U) {
+		INFO("Software access to all debug components is disabled\n");
+		return -1;
 	}
 
-	mmio_setbits_32(rcc_base + RCC_DBGCFGR, RCC_DBGCFGR_DBGCKEN);
+	mmio_setbits_32(RCC_BASE + RCC_DBGCFGR, RCC_DBGCFGR_DBGCKEN);
 
 	return 0;
 }
 
+/*
+ * @brief  Get silicon revision from DBGMCU registers.
+ * @param  chip_version: pointer to the read value.
+ * @retval 0 on success, negative value on failure.
+ */
 int stm32mp1_dbgmcu_get_chip_version(uint32_t *chip_version)
 {
+	assert(chip_version != NULL);
+
 	if (stm32mp1_dbgmcu_init() != 0) {
 		return -EPERM;
 	}
@@ -65,32 +55,21 @@ int stm32mp1_dbgmcu_get_chip_version(uint32_t *chip_version)
 	return 0;
 }
 
+/*
+ * @brief  Get device ID from DBGMCU registers.
+ * @param  chip_dev_id: pointer to the read value.
+ * @retval 0 on success, negative value on failure.
+ */
 int stm32mp1_dbgmcu_get_chip_dev_id(uint32_t *chip_dev_id)
 {
-	if (stm32mp1_dbgmcu_init() != 0) {
-		return -EPERM;
-	}
-
-	*chip_dev_id = mmio_read_32(DBGMCU_BASE + DBGMCU_IDC) &
-		DBGMCU_IDC_DEV_ID_MASK;
-
-	return 0;
-}
-
-int stm32mp1_dbgmcu_freeze_iwdg2(void)
-{
-	uint32_t dbg_conf;
+	assert(chip_dev_id != NULL);
 
 	if (stm32mp1_dbgmcu_init() != 0) {
 		return -EPERM;
 	}
 
-	dbg_conf = bsec_read_debug_conf();
-
-	if ((dbg_conf & (BSEC_SPIDEN | BSEC_SPINDEN)) != 0U) {
-		mmio_setbits_32(DBGMCU_BASE + DBGMCU_APB4FZ1,
-				DBGMCU_APB4FZ1_IWDG2);
-	}
+	*chip_dev_id = mmio_read_32(DBGMCU_BASE + DBGMCU_IDC) &
+		       DBGMCU_IDC_DEV_ID_MASK;
 
 	return 0;
 }
diff --git a/plat/st/stm32mp1/stm32mp1_def.h b/plat/st/stm32mp1/stm32mp1_def.h
index f5d4b2f38..ba92bd321 100644
--- a/plat/st/stm32mp1/stm32mp1_def.h
+++ b/plat/st/stm32mp1/stm32mp1_def.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2021, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -10,33 +10,51 @@
 #include <common/tbbr/tbbr_img_def.h>
 #include <drivers/st/stm32mp1_rcc.h>
 #include <dt-bindings/clock/stm32mp1-clks.h>
+#include <dt-bindings/gpio/stm32-gpio.h>
 #include <dt-bindings/reset/stm32mp1-resets.h>
+#include <dt-bindings/soc/st,stm32-etzpc.h>
 #include <lib/utils_def.h>
 #include <lib/xlat_tables/xlat_tables_defs.h>
 
 #ifndef __ASSEMBLER__
 #include <drivers/st/bsec.h>
+#include <drivers/st/stm32mp1_calib.h>
 #include <drivers/st/stm32mp1_clk.h>
+#include <drivers/st/stm32mp1_ddr_regs.h>
+#include <drivers/st/stm32mp1_pwr.h>
 
 #include <boot_api.h>
-#include <stm32mp_auth.h>
 #include <stm32mp_common.h>
 #include <stm32mp_dt.h>
 #include <stm32mp_shres_helpers.h>
+#include <stm32mp1_context.h>
 #include <stm32mp1_dbgmcu.h>
 #include <stm32mp1_private.h>
 #include <stm32mp1_shared_resources.h>
 #endif
 
-#if !STM32MP_USE_STM32IMAGE
 #include "stm32mp1_fip_def.h"
-#else /* STM32MP_USE_STM32IMAGE */
-#include "stm32mp1_stm32image_def.h"
-#endif /* STM32MP_USE_STM32IMAGE */
 
 /*******************************************************************************
  * CHIP ID
  ******************************************************************************/
+#if STM32MP13
+#define STM32MP1_CHIP_ID	U(0x501)
+
+#define STM32MP135C_PART_NB	U(0x05010000)
+#define STM32MP135A_PART_NB	U(0x05010001)
+#define STM32MP133C_PART_NB	U(0x050100C0)
+#define STM32MP133A_PART_NB	U(0x050100C1)
+#define STM32MP131C_PART_NB	U(0x050106C8)
+#define STM32MP131A_PART_NB	U(0x050106C9)
+#define STM32MP135F_PART_NB	U(0x05010800)
+#define STM32MP135D_PART_NB	U(0x05010801)
+#define STM32MP133F_PART_NB	U(0x050108C0)
+#define STM32MP133D_PART_NB	U(0x050108C1)
+#define STM32MP131F_PART_NB	U(0x05010EC8)
+#define STM32MP131D_PART_NB	U(0x05010EC9)
+#endif
+#if STM32MP15
 #define STM32MP1_CHIP_ID	U(0x500)
 
 #define STM32MP157C_PART_NB	U(0x05000000)
@@ -51,26 +69,58 @@
 #define STM32MP153D_PART_NB	U(0x050000A5)
 #define STM32MP151F_PART_NB	U(0x050000AE)
 #define STM32MP151D_PART_NB	U(0x050000AF)
+#endif
 
 #define STM32MP1_REV_B		U(0x2000)
+#if STM32MP13
+#define STM32MP1_REV_Y		U(0x1003)
+#define STM32MP1_REV_Z		U(0x1001)
+#endif
+#if STM32MP15
 #define STM32MP1_REV_Z		U(0x2001)
+#endif
 
 /*******************************************************************************
  * PACKAGE ID
  ******************************************************************************/
+#if STM32MP15
 #define PKG_AA_LFBGA448		U(4)
 #define PKG_AB_LFBGA354		U(3)
 #define PKG_AC_TFBGA361		U(2)
 #define PKG_AD_TFBGA257		U(1)
+#endif
 
 /*******************************************************************************
  * STM32MP1 memory map related constants
  ******************************************************************************/
 #define STM32MP_ROM_BASE		U(0x00000000)
 #define STM32MP_ROM_SIZE		U(0x00020000)
-
+#define STM32MP_ROM_SIZE_2MB_ALIGNED	U(0x00200000)
+
+#if STM32MP13
+#define STM32MP_SYSRAM_BASE		U(0x2FFE0000)
+#define STM32MP_SYSRAM_SIZE		U(0x00020000)
+#define SRAM1_BASE			U(0x30000000)
+#define SRAM1_SIZE			U(0x00004000)
+#define SRAM2_BASE			U(0x30004000)
+#define SRAM2_SIZE			U(0x00002000)
+#define SRAM3_BASE			U(0x30006000)
+#define SRAM3_SIZE			U(0x00002000)
+#define SRAMS_BASE			SRAM1_BASE
+#define SRAMS_SIZE_2MB_ALIGNED		U(0x00200000)
+#endif /* STM32MP13 */
+#if STM32MP15
 #define STM32MP_SYSRAM_BASE		U(0x2FFC0000)
 #define STM32MP_SYSRAM_SIZE		U(0x00040000)
+#endif /* STM32MP15 */
+
+#define STM32MP_BACKUP_RAM_BASE		U(0x54000000)
+#if STM32MP13
+#define STM32MP_BACKUP_RAM_SIZE		U(0x00002000)	/* 8KB */
+#endif /* STM32MP13 */
+#if STM32MP15
+#define STM32MP_BACKUP_RAM_SIZE		U(0x00001000)	/* 4KB */
+#endif /* STM32MP15 */
 
 #define STM32MP_NS_SYSRAM_SIZE		PAGE_SIZE
 #define STM32MP_NS_SYSRAM_BASE		(STM32MP_SYSRAM_BASE + \
@@ -98,9 +148,20 @@ enum ddr_type {
 #endif
 
 /* Section used inside TF binaries */
+#if STM32MP13
+/* 512 Octets reserved for header */
+#define STM32MP_HEADER_RESERVED_SIZE	U(0x200)
+
+#define STM32MP_BINARY_BASE		STM32MP_SEC_SYSRAM_BASE
+
+#define STM32MP_BINARY_SIZE		STM32MP_SEC_SYSRAM_SIZE
+#endif
+#if STM32MP15
 #define STM32MP_PARAM_LOAD_SIZE		U(0x00002400)	/* 9 KB for param */
 /* 256 Octets reserved for header */
 #define STM32MP_HEADER_SIZE		U(0x00000100)
+/* round_up(STM32MP_PARAM_LOAD_SIZE + STM32MP_HEADER_SIZE, PAGE_SIZE) */
+#define STM32MP_HEADER_RESERVED_SIZE	U(0x3000)
 
 #define STM32MP_BINARY_BASE		(STM32MP_SEC_SYSRAM_BASE +	\
 					 STM32MP_PARAM_LOAD_SIZE +	\
@@ -109,24 +170,55 @@ enum ddr_type {
 #define STM32MP_BINARY_SIZE		(STM32MP_SEC_SYSRAM_SIZE -	\
 					 (STM32MP_PARAM_LOAD_SIZE +	\
 					  STM32MP_HEADER_SIZE))
+#endif
 
-/* BL2 and BL32/sp_min require 4 tables */
-#define MAX_XLAT_TABLES			U(4)		/* 16 KB for mapping */
+/* BL2 and BL32/sp_min require finer granularity tables */
+#if defined(IMAGE_BL2)
+#define MAX_XLAT_TABLES			U(2) /* 8 KB for mapping */
+#endif
+
+#if defined(IMAGE_BL32)
+#define MAX_XLAT_TABLES			U(4) /* 16 KB for mapping */
+#endif
 
 /*
  * MAX_MMAP_REGIONS is usually:
  * BL stm32mp1_mmap size + mmap regions in *_plat_arch_setup
  */
 #if defined(IMAGE_BL2)
-  #define MAX_MMAP_REGIONS		11
+ #if STM32MP_USB_PROGRAMMER
+  #define MAX_MMAP_REGIONS		8
+ #else
+  #define MAX_MMAP_REGIONS		7
+ #endif
 #endif
 
+#if STM32MP13
+#define STM32MP_BL33_BASE		STM32MP_DDR_BASE
+#endif
+#if STM32MP15
 #define STM32MP_BL33_BASE		(STM32MP_DDR_BASE + U(0x100000))
+#endif
 #define STM32MP_BL33_MAX_SIZE		U(0x400000)
 
+/* Define Temporary Stack size use during low power mode */
+#define STM32MP_INT_STACK_SIZE		0x200
+
 /* Define maximum page size for NAND devices */
 #define PLATFORM_MTD_MAX_PAGE_SIZE	U(0x1000)
 
+/* Define location for the MTD scratch buffer */
+#if STM32MP13
+#define STM32MP_MTD_BUFFER		(SRAM1_BASE + \
+					 SRAM1_SIZE - \
+					 PLATFORM_MTD_MAX_PAGE_SIZE)
+#endif
+/*
+ * Only used for MTD devices that need some backup blocks.
+ * Must define a maximum size for a partition.
+ */
+#define PLATFORM_MTD_MAX_PART_SIZE	U(0x00400000)
+
 /*******************************************************************************
  * STM32MP1 device/io map related constants (used for MMU)
  ******************************************************************************/
@@ -146,6 +238,22 @@ enum ddr_type {
  ******************************************************************************/
 #define PWR_BASE			U(0x50001000)
 
+/*******************************************************************************
+ * STM32MP1 EXTI
+ ******************************************************************************/
+#define EXTI_BASE			U(0x5000D000)
+#define EXTI_TZENR1			U(0x14)
+#define EXTI_RPR3			U(0x4C)
+#define EXTI_FPR3			U(0x50)
+#define EXTI_C1IMR1			U(0x80)
+#define EXTI_C2IMR1			U(0xC0)
+#define EXTI_C2IMR2			U(0xD0)
+#define EXTI_C2IMR3			U(0xE0)
+#define EXTI_TZENR1_TZEN18		BIT(18)
+#define EXTI_IMR1_IM18			BIT(18)
+#define EXTI_RPR3_RPIF65		BIT(1)
+#define EXTI_FPR3_FPIF65		BIT(1)
+
 /*******************************************************************************
  * STM32MP1 GPIO
  ******************************************************************************/
@@ -158,42 +266,49 @@ enum ddr_type {
 #define GPIOG_BASE			U(0x50008000)
 #define GPIOH_BASE			U(0x50009000)
 #define GPIOI_BASE			U(0x5000A000)
+#if STM32MP15
 #define GPIOJ_BASE			U(0x5000B000)
 #define GPIOK_BASE			U(0x5000C000)
 #define GPIOZ_BASE			U(0x54004000)
+#endif
 #define GPIO_BANK_OFFSET		U(0x1000)
 
-/* Bank IDs used in GPIO driver API */
-#define GPIO_BANK_A			U(0)
-#define GPIO_BANK_B			U(1)
-#define GPIO_BANK_C			U(2)
-#define GPIO_BANK_D			U(3)
-#define GPIO_BANK_E			U(4)
-#define GPIO_BANK_F			U(5)
-#define GPIO_BANK_G			U(6)
-#define GPIO_BANK_H			U(7)
-#define GPIO_BANK_I			U(8)
-#define GPIO_BANK_J			U(9)
-#define GPIO_BANK_K			U(10)
-#define GPIO_BANK_Z			U(25)
-
+#if STM32MP15
 #define STM32MP_GPIOZ_PIN_MAX_COUNT	8
+#endif
 
 /*******************************************************************************
  * STM32MP1 UART
  ******************************************************************************/
+#if STM32MP13
+#define USART1_BASE			U(0x4C000000)
+#define USART2_BASE			U(0x4C001000)
+#endif
+#if STM32MP15
 #define USART1_BASE			U(0x5C000000)
 #define USART2_BASE			U(0x4000E000)
+#endif
 #define USART3_BASE			U(0x4000F000)
 #define UART4_BASE			U(0x40010000)
 #define UART5_BASE			U(0x40011000)
 #define USART6_BASE			U(0x44003000)
 #define UART7_BASE			U(0x40018000)
 #define UART8_BASE			U(0x40019000)
-#define STM32MP_UART_BAUDRATE		U(115200)
 
 /* For UART crash console */
 #define STM32MP_DEBUG_USART_BASE	UART4_BASE
+#if STM32MP13
+/* UART4 on HSI@64MHz, TX on GPIOF12 Alternate 8 (Disco board) */
+#define STM32MP_DEBUG_USART_CLK_FRQ	64000000
+#define DEBUG_UART_TX_GPIO_BANK_ADDRESS	GPIOD_BASE
+#define DEBUG_UART_TX_GPIO_BANK_CLK_REG	RCC_MP_S_AHB4ENSETR
+#define DEBUG_UART_TX_GPIO_BANK_CLK_EN	RCC_MP_S_AHB4ENSETR_GPIODEN
+#define DEBUG_UART_TX_GPIO_PORT		6
+#define DEBUG_UART_TX_GPIO_ALTERNATE	8
+#define DEBUG_UART_TX_CLKSRC_REG	RCC_UART4CKSELR
+#define DEBUG_UART_TX_CLKSRC		RCC_UART4CKSELR_HSI
+#endif /* STM32MP13 */
+#if STM32MP15
 /* UART4 on HSI@64MHz, TX on GPIOG11 Alternate 6 */
 #define STM32MP_DEBUG_USART_CLK_FRQ	64000000
 #define DEBUG_UART_TX_GPIO_BANK_ADDRESS	GPIOG_BASE
@@ -203,6 +318,7 @@ enum ddr_type {
 #define DEBUG_UART_TX_GPIO_ALTERNATE	6
 #define DEBUG_UART_TX_CLKSRC_REG	RCC_UART24CKSELR
 #define DEBUG_UART_TX_CLKSRC		RCC_UART24CKSELR_HSI
+#endif /* STM32MP15 */
 #define DEBUG_UART_TX_EN_REG		RCC_MP_APB1ENSETR
 #define DEBUG_UART_TX_EN		RCC_MP_APB1ENSETR_UART4EN
 #define DEBUG_UART_RST_REG		RCC_APB1RSTSETR
@@ -219,100 +335,19 @@ enum ddr_type {
 
 #define STM32MP1_ETZPC_TZMA_ALL_SECURE	GENMASK_32(9, 0)
 
-/* ETZPC DECPROT IDs */
-#define STM32MP1_ETZPC_STGENC_ID	0
-#define STM32MP1_ETZPC_BKPSRAM_ID	1
-#define STM32MP1_ETZPC_IWDG1_ID		2
-#define STM32MP1_ETZPC_USART1_ID	3
-#define STM32MP1_ETZPC_SPI6_ID		4
-#define STM32MP1_ETZPC_I2C4_ID		5
-#define STM32MP1_ETZPC_RNG1_ID		7
-#define STM32MP1_ETZPC_HASH1_ID		8
-#define STM32MP1_ETZPC_CRYP1_ID		9
-#define STM32MP1_ETZPC_DDRCTRL_ID	10
-#define STM32MP1_ETZPC_DDRPHYC_ID	11
-#define STM32MP1_ETZPC_I2C6_ID		12
-#define STM32MP1_ETZPC_SEC_ID_LIMIT	13
-
-#define STM32MP1_ETZPC_TIM2_ID		16
-#define STM32MP1_ETZPC_TIM3_ID		17
-#define STM32MP1_ETZPC_TIM4_ID		18
-#define STM32MP1_ETZPC_TIM5_ID		19
-#define STM32MP1_ETZPC_TIM6_ID		20
-#define STM32MP1_ETZPC_TIM7_ID		21
-#define STM32MP1_ETZPC_TIM12_ID		22
-#define STM32MP1_ETZPC_TIM13_ID		23
-#define STM32MP1_ETZPC_TIM14_ID		24
-#define STM32MP1_ETZPC_LPTIM1_ID	25
-#define STM32MP1_ETZPC_WWDG1_ID		26
-#define STM32MP1_ETZPC_SPI2_ID		27
-#define STM32MP1_ETZPC_SPI3_ID		28
-#define STM32MP1_ETZPC_SPDIFRX_ID	29
-#define STM32MP1_ETZPC_USART2_ID	30
-#define STM32MP1_ETZPC_USART3_ID	31
-#define STM32MP1_ETZPC_UART4_ID		32
-#define STM32MP1_ETZPC_UART5_ID		33
-#define STM32MP1_ETZPC_I2C1_ID		34
-#define STM32MP1_ETZPC_I2C2_ID		35
-#define STM32MP1_ETZPC_I2C3_ID		36
-#define STM32MP1_ETZPC_I2C5_ID		37
-#define STM32MP1_ETZPC_CEC_ID		38
-#define STM32MP1_ETZPC_DAC_ID		39
-#define STM32MP1_ETZPC_UART7_ID		40
-#define STM32MP1_ETZPC_UART8_ID		41
-#define STM32MP1_ETZPC_MDIOS_ID		44
-#define STM32MP1_ETZPC_TIM1_ID		48
-#define STM32MP1_ETZPC_TIM8_ID		49
-#define STM32MP1_ETZPC_USART6_ID	51
-#define STM32MP1_ETZPC_SPI1_ID		52
-#define STM32MP1_ETZPC_SPI4_ID		53
-#define STM32MP1_ETZPC_TIM15_ID		54
-#define STM32MP1_ETZPC_TIM16_ID		55
-#define STM32MP1_ETZPC_TIM17_ID		56
-#define STM32MP1_ETZPC_SPI5_ID		57
-#define STM32MP1_ETZPC_SAI1_ID		58
-#define STM32MP1_ETZPC_SAI2_ID		59
-#define STM32MP1_ETZPC_SAI3_ID		60
-#define STM32MP1_ETZPC_DFSDM_ID		61
-#define STM32MP1_ETZPC_TT_FDCAN_ID	62
-#define STM32MP1_ETZPC_LPTIM2_ID	64
-#define STM32MP1_ETZPC_LPTIM3_ID	65
-#define STM32MP1_ETZPC_LPTIM4_ID	66
-#define STM32MP1_ETZPC_LPTIM5_ID	67
-#define STM32MP1_ETZPC_SAI4_ID		68
-#define STM32MP1_ETZPC_VREFBUF_ID	69
-#define STM32MP1_ETZPC_DCMI_ID		70
-#define STM32MP1_ETZPC_CRC2_ID		71
-#define STM32MP1_ETZPC_ADC_ID		72
-#define STM32MP1_ETZPC_HASH2_ID		73
-#define STM32MP1_ETZPC_RNG2_ID		74
-#define STM32MP1_ETZPC_CRYP2_ID		75
-#define STM32MP1_ETZPC_SRAM1_ID		80
-#define STM32MP1_ETZPC_SRAM2_ID		81
-#define STM32MP1_ETZPC_SRAM3_ID		82
-#define STM32MP1_ETZPC_SRAM4_ID		83
-#define STM32MP1_ETZPC_RETRAM_ID	84
-#define STM32MP1_ETZPC_OTG_ID		85
-#define STM32MP1_ETZPC_SDMMC3_ID	86
-#define STM32MP1_ETZPC_DLYBSD3_ID	87
-#define STM32MP1_ETZPC_DMA1_ID		88
-#define STM32MP1_ETZPC_DMA2_ID		89
-#define STM32MP1_ETZPC_DMAMUX_ID	90
-#define STM32MP1_ETZPC_FMC_ID		91
-#define STM32MP1_ETZPC_QSPI_ID		92
-#define STM32MP1_ETZPC_DLYBQ_ID		93
-#define STM32MP1_ETZPC_ETH_ID		94
-#define STM32MP1_ETZPC_RSV_ID		95
-
-#define STM32MP_ETZPC_MAX_ID		96
-
 /*******************************************************************************
  * STM32MP1 TZC (TZ400)
  ******************************************************************************/
 #define STM32MP1_TZC_BASE		U(0x5C006000)
+#define STM32MP1_TZC_MAX_REGIONS	U(8)
 
+#if STM32MP13
+#define STM32MP1_FILTER_BIT_ALL		TZC_400_REGION_ATTR_FILTER_BIT(0)
+#endif
+#if STM32MP15
 #define STM32MP1_FILTER_BIT_ALL		(TZC_400_REGION_ATTR_FILTER_BIT(0) | \
 					 TZC_400_REGION_ATTR_FILTER_BIT(1))
+#endif
 
 /*******************************************************************************
  * STM32MP1 SDMMC
@@ -335,27 +370,83 @@ enum ddr_type {
 
 #define OTP_MAX_SIZE			(STM32MP1_OTP_MAX_ID + 1U)
 
-/* OTP offsets */
-#define DATA0_OTP			U(0)
-#define PART_NUMBER_OTP			U(1)
-#define NAND_OTP			U(9)
-#define UID0_OTP			U(13)
-#define UID1_OTP			U(14)
-#define UID2_OTP			U(15)
-#define PACKAGE_OTP			U(16)
-#define HW2_OTP				U(18)
+/* OTP labels */
+#define CFG0_OTP			"cfg0_otp"
+#define PART_NUMBER_OTP			"part_number_otp"
+#if STM32MP15
+#define PACKAGE_OTP			"package_otp"
+#endif
+#define HW2_OTP				"hw2_otp"
+#if STM32MP13
+#define NAND_OTP			"cfg9_otp"
+#define NAND2_OTP			"cfg10_otp"
+#endif
+#if STM32MP15
+#define NAND_OTP			"nand_otp"
+#endif
+#define MONOTONIC_OTP			"monotonic_otp"
+#define UID_OTP				"uid_otp"
+#define PKH_OTP				"pkh_otp"
+#define ENCKEY_OTP			"enckey_otp"
+#define BOARD_ID_OTP			"board_id"
+#define CFG2_OTP			"cfg2_otp"
+#define SSP_OTP				"ssp_otp"
+#define CHIP_CERTIFICATE_OTP		"chip_otp"
+#define RMA_OTP				"rma_otp"
 
 /* OTP mask */
-/* DATA0 */
-#define DATA0_OTP_SECURED		BIT(6)
+/* CFG0 */
+#if STM32MP13
+#define CFG0_OTP_MODE_MASK		GENMASK_32(9, 0)
+#define CFG0_OTP_MODE_SHIFT		0
+#define CFG0_OPEN_DEVICE		0x17U
+#define CFG0_CLOSED_DEVICE		0x3FU
+#define CFG0_CLOSED_DEVICE_NO_BOUNDARY_SCAN	0x17FU
+#define CFG0_CLOSED_DEVICE_NO_JTAG	0x3FFU
+#endif
+#if STM32MP15
+#define CFG0_CLOSED_DEVICE		BIT(6)
+#endif
+
+/* CFG2 */
+#define OTP_CFG2_SEC_COUNTER_MASK	GENMASK_32(27, 20)
+#define OTP_CFG2_SEC_COUNTER_SHIFT	U(20)
+#define OTP_CFG2_ST_KEY_MASK		GENMASK_32(31, 28)
+#define OTP_CFG2_ST_KEY_SHIFT		U(28)
+
+/* SSP */
+#define SSP_OTP_REQ			BIT(BOOT_API_OTP_SSP_REQ_BIT_POS)
+#define SSP_OTP_SUCCESS			BIT(BOOT_API_OTP_SSP_SUCCESS_BIT_POS)
+#define SSP_OTP_MASK			GENMASK_32(BOOT_API_OTP_SSP_SUCCESS_BIT_POS, \
+						   BOOT_API_OTP_SSP_REQ_BIT_POS)
+#define SSP_OTP_SECRET_BASE		U(59)
+#define SSP_OTP_SECRET_END		U(95)
+
+/* CHIP_CERT */
+#define CHIP_CERTIFICATE_MAX_SIZE	U(0x40)
+
+/* RMA */
+#if STM32MP13
+#define RMA_OTP_MASK			GENMASK_32(31, 0)
+#endif
+#if STM32MP15
+#define RMA_OTP_MASK			GENMASK_32(29, 0)
+#endif
 
 /* PART NUMBER */
+#if STM32MP13
+#define PART_NUMBER_OTP_PART_MASK	GENMASK_32(14, 0)
+#endif
+#if STM32MP15
 #define PART_NUMBER_OTP_PART_MASK	GENMASK_32(7, 0)
+#endif
 #define PART_NUMBER_OTP_PART_SHIFT	0
 
 /* PACKAGE */
+#if STM32MP15
 #define PACKAGE_OTP_PKG_MASK		GENMASK_32(29, 27)
 #define PACKAGE_OTP_PKG_SHIFT		27
+#endif
 
 /* IWDG OTP */
 #define HW2_OTP_IWDG_HW_POS		U(3)
@@ -383,7 +474,7 @@ enum ddr_type {
 #define NAND_BLOCK_SIZE_128_PAGES	U(1)
 #define NAND_BLOCK_SIZE_256_PAGES	U(2)
 
-/* NAND number of block (in unit of 256 blocs) */
+/* NAND number of block (in unit of 256 blocks) */
 #define NAND_BLOCK_NB_MASK		GENMASK_32(26, 19)
 #define NAND_BLOCK_NB_SHIFT		19
 #define NAND_BLOCK_NB_UNIT		U(256)
@@ -404,17 +495,36 @@ enum ddr_type {
 /* NAND number of planes */
 #define NAND_PLANE_BIT_NB_MASK		BIT(14)
 
+/* NAND2 OTP */
+#define NAND2_PAGE_SIZE_SHIFT		16
+
+/* NAND2 config distribution */
+#define NAND2_CONFIG_DISTRIB		BIT(0)
+#define NAND2_PNAND_NAND2_SNAND_NAND1	U(0)
+#define NAND2_PNAND_NAND1_SNAND_NAND2	U(1)
+
+/* MONOTONIC OTP */
+#define MAX_MONOTONIC_VALUE		32
+
 /* UID OTP */
 #define UID_WORD_NB			U(3)
 
+/* FWU configuration */
+#define FWU_MAX_TRIAL_REBOOT		U(3)
+
 /*******************************************************************************
  * STM32MP1 TAMP
  ******************************************************************************/
+#define PLAT_MAX_TAMP_INT		U(6)
+#define PLAT_MAX_TAMP_EXT		U(3)
 #define TAMP_BASE			U(0x5C00A000)
 #define TAMP_BKP_REGISTER_BASE		(TAMP_BASE + U(0x100))
+#define TAMP_BKP_SEC_NUMBER		U(10)
+#define TAMP_BKP_S_W_NS_R_NUMBER	U(5)
+#define TAMP_COUNTR			U(0x40)
 
 #if !(defined(__LINKER__) || defined(__ASSEMBLER__))
-static inline uint32_t tamp_bkpr(uint32_t idx)
+static inline uintptr_t tamp_bkpr(uint32_t idx)
 {
 	return TAMP_BKP_REGISTER_BASE + (idx << 2);
 }
@@ -435,6 +545,14 @@ static inline uint32_t tamp_bkpr(uint32_t idx)
  ******************************************************************************/
 #define DDRPHYC_BASE			U(0x5A004000)
 
+/*******************************************************************************
+ * STM32MP1 MCE
+ ******************************************************************************/
+#if STM32MP13
+#define MCE_BASE			U(0x58001000)
+#define MCE_KEY_SIZE_IN_BYTES		U(16)
+#endif
+
 /*******************************************************************************
  * STM32MP1 IWDG
  ******************************************************************************/
@@ -449,23 +567,106 @@ static inline uint32_t tamp_bkpr(uint32_t idx)
  * Miscellaneous STM32MP1 peripherals base address
  ******************************************************************************/
 #define BSEC_BASE			U(0x5C005000)
+#if STM32MP13
+#define CRYP_BASE			U(0x54002000)
+#endif
+#if STM32MP15
 #define CRYP1_BASE			U(0x54001000)
+#endif
 #define DBGMCU_BASE			U(0x50081000)
+#if STM32MP13
+#define HASH_BASE			U(0x54003000)
+#endif
+#if STM32MP15
 #define HASH1_BASE			U(0x54002000)
+#endif
+#if STM32MP13
+#define I2C3_BASE			U(0x4C004000)
+#define I2C4_BASE			U(0x4C005000)
+#define I2C5_BASE			U(0x4C006000)
+#endif
+#if STM32MP15
 #define I2C4_BASE			U(0x5C002000)
 #define I2C6_BASE			U(0x5c009000)
+#endif
+#if STM32MP13
+#define RNG_BASE			U(0x54004000)
+#endif
+#if STM32MP15
 #define RNG1_BASE			U(0x54003000)
+#endif
 #define RTC_BASE			U(0x5c004000)
+#if STM32MP13
+#define SPI4_BASE			U(0x4C002000)
+#define SPI5_BASE			U(0x4C003000)
+#endif
+#if STM32MP15
 #define SPI6_BASE			U(0x5c001000)
+#endif
 #define STGEN_BASE			U(0x5c008000)
 #define SYSCFG_BASE			U(0x50020000)
 
+/*******************************************************************************
+ * STM32MP1 TIMERS
+ ******************************************************************************/
+#define TIM12_BASE			U(0x40006000)
+#define TIM15_BASE			U(0x44006000)
+#define TIM_MAX_INSTANCE		U(2)
+
+/*******************************************************************************
+ * STM32MP13 SAES
+ ******************************************************************************/
+#define SAES_BASE			U(0x54005000)
+
+/*******************************************************************************
+ * STM32MP13 PKA
+ ******************************************************************************/
+#define PKA_BASE			U(0x54006000)
+
+/*******************************************************************************
+ * STM32MP1 OPP
+ ******************************************************************************/
+#define PLAT_OPP_ID1			U(1)
+#define PLAT_OPP_ID2			U(2)
+#define PLAT_MAX_OPP_NB			U(2)
+#define PLAT_MAX_PLLCFG_NB		U(6)
+
+/*******************************************************************************
+ * REGULATORS
+ ******************************************************************************/
+/* 3 PWR + 1 VREFBUF + 14 PMIC regulators + 1 FIXED */
+#define PLAT_NB_RDEVS			U(19)
+/* 2 FIXED */
+#define PLAT_NB_FIXED_REGUS		U(2)
+/* No GPIO regu */
+#define PLAT_NB_GPIO_REGUS		U(0)
+/* Number of low power modes defined in the device tree */
+#define PLAT_NB_SUSPEND_MODES		7
+
 /*******************************************************************************
  * Device Tree defines
  ******************************************************************************/
+#if STM32MP13
+#define DT_BSEC_COMPAT			"st,stm32mp13-bsec"
+#define DT_DDR_COMPAT			"st,stm32mp13-ddr"
+#endif
+#if STM32MP15
 #define DT_BSEC_COMPAT			"st,stm32mp15-bsec"
+#define DT_DDR_COMPAT			"st,stm32mp1-ddr"
+#endif
 #define DT_IWDG_COMPAT			"st,stm32mp1-iwdg"
+#define DT_OPP_COMPAT			"operating-points-v2"
 #define DT_PWR_COMPAT			"st,stm32mp1,pwr-reg"
+#if STM32MP13
+#define DT_RCC_CLK_COMPAT		"st,stm32mp13-rcc"
+#define DT_RCC_SEC_CLK_COMPAT		"st,stm32mp13-rcc-secure"
+#endif
+#if STM32MP15
 #define DT_RCC_CLK_COMPAT		"st,stm32mp1-rcc"
+#define DT_RCC_SEC_CLK_COMPAT		"st,stm32mp1-rcc-secure"
+#endif
+#define DT_SDMMC2_COMPAT		"st,stm32-sdmmc2"
+#define DT_UART_COMPAT			"st,stm32h7-uart"
+#define DT_USBPHYC_COMPAT		"st,stm32mp1-usbphyc"
 
 #endif /* STM32MP1_DEF_H */
diff --git a/plat/st/stm32mp1/stm32mp1_fconf_firewall.c b/plat/st/stm32mp1/stm32mp1_fconf_firewall.c
index caf9ff12b..2697e0d1f 100644
--- a/plat/st/stm32mp1/stm32mp1_fconf_firewall.c
+++ b/plat/st/stm32mp1/stm32mp1_fconf_firewall.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2021-2022, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -9,7 +9,8 @@
 #include <common/debug.h>
 #include <common/fdt_wrappers.h>
 #include <drivers/arm/tzc400.h>
-#include <drivers/st/stm32mp1_clk.h>
+#include <drivers/clk.h>
+#include <drivers/st/stm32mp1_ram.h>
 #include <dt-bindings/clock/stm32mp1-clks.h>
 #include <lib/fconf/fconf.h>
 #include <lib/object_pool.h>
@@ -31,8 +32,13 @@ struct dt_id_attr {
 
 void stm32mp1_arch_security_setup(void)
 {
-	stm32mp_clk_enable(TZC1);
-	stm32mp_clk_enable(TZC2);
+#if STM32MP13
+	clk_enable(TZC);
+#endif
+#if STM32MP15
+	clk_enable(TZC1);
+	clk_enable(TZC2);
+#endif
 
 	tzc400_init(STM32MP1_TZC_BASE);
 	tzc400_disable_filters();
@@ -51,6 +57,11 @@ void stm32mp1_security_setup(void)
 {
 	uint8_t i;
 
+	/* DDR content will be restored, do not change the firewall protection */
+	if (stm32mp1_ddr_is_restored()) {
+		return;
+	}
+
 	assert(nb_regions > 0U);
 
 	tzc400_init(STM32MP1_TZC_BASE);
@@ -80,6 +91,11 @@ static int fconf_populate_stm32mp1_firewall(uintptr_t config)
 	/* Assert the node offset point to "st,mem-firewall" compatible property */
 	const char *compatible_str = "st,mem-firewall";
 
+	/* DDR content will be restored, do not change the firewall protection */
+	if (stm32mp1_ddr_is_restored()) {
+		return 0;
+	}
+
 	node = fdt_node_offset_by_compatible(dtb, -1, compatible_str);
 	if (node < 0) {
 		ERROR("FCONF: Can't find %s compatible in dtb\n", compatible_str);
diff --git a/plat/st/stm32mp1/stm32mp1_fip_def.h b/plat/st/stm32mp1/stm32mp1_fip_def.h
index d8561dcc0..5a673a038 100644
--- a/plat/st/stm32mp1/stm32mp1_fip_def.h
+++ b/plat/st/stm32mp1/stm32mp1_fip_def.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -10,24 +10,102 @@
 #define STM32MP_DDR_S_SIZE		U(0x01E00000)	/* 30 MB */
 #define STM32MP_DDR_SHMEM_SIZE		U(0x00200000)	/* 2 MB */
 
+#if STM32MP_SSP
+#if STM32MP13
+#define STM32MP_BL2_DTB_BASE		STM32MP_SEC_SYSRAM_BASE
+#endif
+#if STM32MP15
+#define STM32MP_BL2_DTB_BASE		(STM32MP_SYSRAM_BASE + \
+					 STM32MP_HEADER_RESERVED_SIZE)
+#endif
+
+#define STM32MP_BL2_DTB_SIZE		U(0x00005000)	/* 20 KB for DTB */
+
+#define STM32MP_BL2_RO_SIZE		U(0x0000E000)	/* 56 Ko for BL2 */
+
+#define STM32MP_BL2_RO_BASE		STM32MP_BL2_DTB_BASE + \
+					STM32MP_BL2_DTB_SIZE
+
+#define STM32MP_BL2_RW_BASE		(STM32MP_BL2_RO_BASE + \
+					 STM32MP_BL2_RO_SIZE)
+
+#define STM32MP_BL2_RW_SIZE		(STM32MP_SYSRAM_BASE + \
+					 STM32MP_SYSRAM_SIZE - \
+					 STM32MP_BL2_RW_BASE)
+#else /* STM32MP_SSP */
+#if TRUSTED_BOARD_BOOT && !STM32MP_USE_EXTERNAL_HEAP
+#if STM32MP15
+#define STM32MP_BL2_RO_SIZE		U(0x00014000)	/* 80 KB */
 #define STM32MP_BL2_SIZE		U(0x0001B000)	/* 108 KB for BL2 */
-#define STM32MP_BL2_DTB_SIZE		U(0x00006000)	/* 24 KB for DTB */
-#define STM32MP_BL32_SIZE		U(0x00019000)	/* 100 KB for BL32 */
+#endif /* STM32MP15 */
+#else /* TRUSTED_BOARD_BOOT && !STM32MP_USE_EXTERNAL_HEAP */
+#if STM32MP13
+#if BL2_IN_XIP_MEM
+#define STM32MP_BL2_RO_SIZE		U(0x00015000)	/* 84 KB */
+#define STM32MP_BL2_SIZE		U(0x00017000)	/* 92 KB for BL2 */
+#else
+/* STM32MP_BL2_RO_SIZE not used if !BL2_IN_XIP_MEM */
+#define STM32MP_BL2_SIZE		U(0x0001B000)	/* 108KB for BL2 */
+					/* with 20KB for DTB, SYSRAM is full */
+#endif
+#endif /* STM32MP13 */
+#if STM32MP15
+#define STM32MP_BL2_RO_SIZE		U(0x00011000)	/* 68 KB */
+#define STM32MP_BL2_SIZE		U(0x00016000)	/* 88 KB for BL2 */
+#endif /* STM32MP15 */
+#endif /* TRUSTED_BOARD_BOOT && !STM32MP_USE_EXTERNAL_HEAP */
+
+#if STM32MP13
+#if TRUSTED_BOARD_BOOT
+#define STM32MP_BL2_DTB_SIZE		U(0x00005000)	/* 20 KB for DTB */
+#else /* TRUSTED_BOARD_BOOT */
+#define STM32MP_BL2_DTB_SIZE		U(0x00004000)	/* 16 KB for DTB */
+#endif /* TRUSTED_BOARD_BOOT */
+#endif /* STM32MP13 */
+#if STM32MP15
+#define STM32MP_BL2_DTB_SIZE		U(0x00007000)	/* 28 KB for DTB */
+#endif /* STM32MP15 */
+#define STM32MP_BL32_SIZE		U(0x0001C000)	/* 112 KB for BL32 */
 #define STM32MP_BL32_DTB_SIZE		U(0x00005000)	/* 20 KB for DTB */
 #define STM32MP_FW_CONFIG_MAX_SIZE	PAGE_SIZE	/* 4 KB for FCONF DTB */
 #define STM32MP_HW_CONFIG_MAX_SIZE	U(0x40000)	/* 256 KB for HW config DTB */
 
+#if STM32MP13
+#define STM32MP_BL2_BASE		(STM32MP_BL2_DTB_BASE + \
+					 STM32MP_BL2_DTB_SIZE)
+#endif /* STM32MP13 */
+#if STM32MP15
 #define STM32MP_BL2_BASE		(STM32MP_SEC_SYSRAM_BASE + \
 					 STM32MP_SEC_SYSRAM_SIZE - \
 					 STM32MP_BL2_SIZE)
+#endif /* STM32MP15 */
+
+#define STM32MP_BL2_RO_BASE		STM32MP_BL2_BASE
+
+#define STM32MP_BL2_RW_BASE		(STM32MP_BL2_RO_BASE + \
+					 STM32MP_BL2_RO_SIZE)
+
+#if STM32MP13
+#define STM32MP_BL2_RW_SIZE		(STM32MP_SYSRAM_BASE + \
+					 STM32MP_SYSRAM_SIZE - \
+					 STM32MP_BL2_RW_BASE)
+
+#define STM32MP_BL2_DTB_BASE		STM32MP_SEC_SYSRAM_BASE
+#endif /* STM32MP13 */
+#if STM32MP15
+#define STM32MP_BL2_RW_SIZE		(STM32MP_SEC_SYSRAM_BASE + \
+					 STM32MP_SEC_SYSRAM_SIZE - \
+					 STM32MP_BL2_RW_BASE)
 
 #define STM32MP_BL2_DTB_BASE		(STM32MP_BL2_BASE - \
 					 STM32MP_BL2_DTB_SIZE)
+#endif /* STM32MP15 */
 
 #define STM32MP_BL32_DTB_BASE		STM32MP_SYSRAM_BASE
 
 #define STM32MP_BL32_BASE		(STM32MP_BL32_DTB_BASE + \
 					 STM32MP_BL32_DTB_SIZE)
+#endif /* STM32MP_SSP */
 
 
 #if defined(IMAGE_BL2)
@@ -46,9 +124,14 @@
 					 STM32MP_OPTEE_BASE)
 #endif
 
+#if STM32MP13
+#define STM32MP_FW_CONFIG_BASE		SRAM3_BASE
+#endif /* STM32MP13 */
+#if STM32MP15
 #define STM32MP_FW_CONFIG_BASE		(STM32MP_SYSRAM_BASE + \
 					 STM32MP_SYSRAM_SIZE - \
 					 PAGE_SIZE)
+#endif /* STM32MP15 */
 #define STM32MP_HW_CONFIG_BASE		(STM32MP_BL33_BASE + \
 					STM32MP_BL33_MAX_SIZE)
 
@@ -63,7 +146,39 @@
 /*******************************************************************************
  * STM32MP1 RAW partition offset for MTD devices
  ******************************************************************************/
+#if PSA_FWU_SUPPORT
+#define STM32MP_NOR_METADATA1_OFFSET	U(0x00080000)
+#define STM32MP_NOR_METADATA2_OFFSET	U(0x000C0000)
+#define STM32MP_NOR_FIP_A_OFFSET	U(0x00100000)
+#define STM32MP_NOR_FIP_A_GUID		(const struct efi_guid)EFI_GUID(0x4fd84c93,  \
+					0x54ef, 0x463f, 0xa7, 0xef, 0xae, 0x25, 0xff,\
+					0x88, 0x70, 0x87)
+
+#define STM32MP_NOR_FIP_B_OFFSET	U(0x00500000)
+#define STM32MP_NOR_FIP_B_GUID		(const struct efi_guid)EFI_GUID(0x09c54952,  \
+					0xd5bf, 0x45af, 0xac, 0xee, 0x33, 0x53, 0x03,\
+					0x76, 0x6f, 0xb3)
+
+#define STM32MP_NAND_METADATA1_OFFSET	U(0x00100000)
+#define STM32MP_NAND_METADATA2_OFFSET	U(0x00180000)
+#define STM32MP_NAND_FIP_A_OFFSET	U(0x00200000)
+#define STM32MP_NAND_FIP_A_GUID		(const struct efi_guid)EFI_GUID(0x4fd84c93,  \
+					0x54ef, 0x463f, 0xa7, 0xef, 0xae, 0x25, 0xff,\
+					0x88, 0x70, 0x87)
+
+#define STM32MP_NAND_FIP_B_OFFSET	U(0x00A00000)
+#define STM32MP_NAND_FIP_B_GUID		(const struct efi_guid)EFI_GUID(0x09c54952,  \
+					0xd5bf, 0x45af, 0xac, 0xee, 0x33, 0x53, 0x03,\
+					0x76, 0x6f, 0xb3)
+
+#define STM32MP_NAND_FIP_B_MAX_OFFSET	U(0x01200000)
+#else /* PSA_FWU_SUPPORT */
+#ifndef STM32MP_NOR_FIP_OFFSET
 #define STM32MP_NOR_FIP_OFFSET		U(0x00080000)
+#endif
+#ifndef STM32MP_NAND_FIP_OFFSET
 #define STM32MP_NAND_FIP_OFFSET		U(0x00200000)
+#endif
+#endif /* PSA_FWU_SUPPORT */
 
 #endif /* STM32MP1_FIP_DEF_H */
diff --git a/plat/st/stm32mp1/stm32mp1_gic.c b/plat/st/stm32mp1/stm32mp1_gic.c
deleted file mode 100644
index 851a9cf0c..000000000
--- a/plat/st/stm32mp1/stm32mp1_gic.c
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (c) 2016-2019, ARM Limited and Contributors. All rights reserved.
- *
- * SPDX-License-Identifier: BSD-3-Clause
- */
-
-#include <libfdt.h>
-
-#include <platform_def.h>
-
-#include <common/bl_common.h>
-#include <common/debug.h>
-#include <drivers/arm/gicv2.h>
-#include <dt-bindings/interrupt-controller/arm-gic.h>
-#include <lib/utils.h>
-#include <plat/common/platform.h>
-
-struct stm32_gic_instance {
-	uint32_t cells;
-	uint32_t phandle_node;
-};
-
-/******************************************************************************
- * On a GICv2 system, the Group 1 secure interrupts are treated as Group 0
- * interrupts.
- *****************************************************************************/
-static const interrupt_prop_t stm32mp1_interrupt_props[] = {
-	PLATFORM_G1S_PROPS(GICV2_INTR_GROUP0),
-	PLATFORM_G0_PROPS(GICV2_INTR_GROUP0)
-};
-
-/* Fix target_mask_array as secondary core is not able to initialize it */
-static unsigned int target_mask_array[PLATFORM_CORE_COUNT] = {1, 2};
-
-static gicv2_driver_data_t platform_gic_data = {
-	.interrupt_props = stm32mp1_interrupt_props,
-	.interrupt_props_num = ARRAY_SIZE(stm32mp1_interrupt_props),
-	.target_masks = target_mask_array,
-	.target_masks_num = ARRAY_SIZE(target_mask_array),
-};
-
-static struct stm32_gic_instance stm32_gic;
-
-void stm32mp1_gic_init(void)
-{
-	int node;
-	void *fdt;
-	const fdt32_t *cuint;
-	struct dt_node_info dt_gic;
-
-	if (fdt_get_address(&fdt) == 0) {
-		panic();
-	}
-
-	node = dt_get_node(&dt_gic, -1, "arm,cortex-a7-gic");
-	if (node < 0) {
-		panic();
-	}
-
-	platform_gic_data.gicd_base = dt_gic.base;
-
-	cuint = fdt_getprop(fdt, node, "reg", NULL);
-	if (cuint == NULL) {
-		panic();
-	}
-
-	platform_gic_data.gicc_base = fdt32_to_cpu(*(cuint + 2));
-
-	cuint = fdt_getprop(fdt, node, "#interrupt-cells", NULL);
-	if (cuint == NULL) {
-		panic();
-	}
-
-	stm32_gic.cells = fdt32_to_cpu(*cuint);
-
-	stm32_gic.phandle_node = fdt_get_phandle(fdt, node);
-	if (stm32_gic.phandle_node == 0U) {
-		panic();
-	}
-
-	gicv2_driver_init(&platform_gic_data);
-	gicv2_distif_init();
-
-	stm32mp1_gic_pcpu_init();
-}
-
-void stm32mp1_gic_pcpu_init(void)
-{
-	gicv2_pcpu_distif_init();
-	gicv2_set_pe_target_mask(plat_my_core_pos());
-	gicv2_cpuif_enable();
-}
diff --git a/plat/st/stm32mp1/stm32mp1_helper.S b/plat/st/stm32mp1/stm32mp1_helper.S
index cac9752e2..2f117dbff 100644
--- a/plat/st/stm32mp1/stm32mp1_helper.S
+++ b/plat/st/stm32mp1/stm32mp1_helper.S
@@ -10,11 +10,17 @@
 #include <asm_macros.S>
 #include <common/bl_common.h>
 #include <drivers/st/stm32_gpio.h>
+#include <smccc_helpers.h>
 
 #define GPIO_TX_SHIFT		(DEBUG_UART_TX_GPIO_PORT << 1)
 
 	.globl	platform_mem_init
 	.globl	plat_report_exception
+#if AARCH32_EXCEPTION_DEBUG
+	.globl	plat_report_undef_inst
+	.globl	plat_report_prefetch_abort
+	.globl	plat_report_data_abort
+#endif
 	.globl	plat_get_my_entrypoint
 	.globl	plat_secondary_cold_boot_setup
 	.globl	plat_reset_handler
@@ -24,6 +30,7 @@
 	.globl	plat_crash_console_flush
 	.globl	plat_crash_console_putc
 	.globl	plat_panic_handler
+	.globl	wfi_svc_int_enable
 
 func platform_mem_init
 	/* Nothing to do, don't need to init SYSRAM */
@@ -75,6 +82,96 @@ print_exception_info:
 #endif
 endfunc plat_report_exception
 
+#if AARCH32_EXCEPTION_DEBUG
+func plat_report_undef_inst
+#if DEBUG
+	mov	r8, lr
+
+	mov	r9, r0
+
+	ldr	r4, =undefined_str
+	bl	asm_print_str
+
+	mov	r4, r9
+	sub	r4, r4, #4
+	bl	asm_print_hex
+
+	ldr	r4, =end_error_str
+	bl	asm_print_str
+
+	bx	r8
+#else
+	bx	lr
+#endif
+endfunc plat_report_undef_inst
+
+func plat_report_prefetch_abort
+#if DEBUG
+	mov	r8, lr
+	mov	r9, r0
+
+	ldr	r4, =prefetch_abort_str
+	bl	asm_print_str
+
+	mov	r4, r9
+	sub	r4, r4, #4
+	bl	asm_print_hex
+
+	ldr	r4, =ifsr_str
+	bl	asm_print_str
+
+	ldcopr	r4, IFSR
+	bl	asm_print_hex
+
+	ldr	r4, =ifar_str
+	bl	asm_print_str
+
+	ldcopr	r4, IFAR
+	bl	asm_print_hex
+
+	ldr	r4, =end_error_str
+	bl	asm_print_str
+
+	bx	r8
+#else
+	bx	lr
+#endif
+endfunc plat_report_prefetch_abort
+
+func plat_report_data_abort
+#if DEBUG
+	mov	r8, lr
+	mov	r9, r0
+
+	ldr	r4, =data_abort_str
+	bl	asm_print_str
+
+	mov	r4, r9
+	sub	r4, r4, #8
+	bl	asm_print_hex
+
+	ldr	r4, =dfsr_str
+	bl	asm_print_str
+
+	ldcopr	r4, DFSR
+	bl	asm_print_hex
+
+	ldr	r4, =dfar_str
+	bl	asm_print_str
+
+	ldcopr	r4, DFAR
+	bl	asm_print_hex
+
+	ldr	r4, =end_error_str
+	bl	asm_print_str
+
+	bx	r8
+#else
+	bx	lr
+#endif
+endfunc plat_report_data_abort
+#endif
+
 func plat_reset_handler
 	bx	lr
 endfunc plat_reset_handler
@@ -258,12 +355,48 @@ endfunc plat_panic_handler
 .section .rodata.rev_err_str, "aS"
 abort_str:
 	.asciz "\nAbort at: 0x"
+#if AARCH32_EXCEPTION_DEBUG
+prefetch_abort_str:
+	.asciz "\nPrefetch Abort at: 0x"
+data_abort_str:
+	.asciz "\nData Abort at: 0x"
+#endif
 undefined_str:
 	.asciz "\nUndefined instruction at: 0x"
 exception_start_str:
 	.asciz "\nException mode=0x"
 exception_end_str:
 	.asciz " at: 0x"
+#if AARCH32_EXCEPTION_DEBUG
+dfsr_str:
+	.asciz " DFSR = 0x"
+dfar_str:
+	.asciz " DFAR = 0x"
+ifsr_str:
+	.asciz " IFSR = 0x"
+ifar_str:
+	.asciz " IFAR = 0x"
+#endif
 end_error_str:
 	.asciz "\n\r"
 #endif
+
+func wfi_svc_int_enable
+	push	{r4,r8,lr}
+	ldcopr	r4, SCR
+	mov	r8, sp
+	mov	sp, r0
+	add	r0, r0, #STM32MP_INT_STACK_SIZE
+	str	r0, [sp, #SMC_CTX_SP_MON]
+	str	r4, [sp, #SMC_CTX_SCR]
+	cps	#MODE32_svc
+	cpsie	af
+	dsb
+	isb
+	wfi
+	cpsid	af
+	cps	#MODE32_mon
+	mov	sp, r8
+	pop	{r4,r8,lr}
+	bx	lr
+endfunc wfi_svc_int_enable
diff --git a/plat/st/stm32mp1/stm32mp1_low_power.c b/plat/st/stm32mp1/stm32mp1_low_power.c
new file mode 100644
index 000000000..a4b473515
--- /dev/null
+++ b/plat/st/stm32mp1/stm32mp1_low_power.c
@@ -0,0 +1,441 @@
+/*
+ * Copyright (c) 2017-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+
+#include <libfdt.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/arm/gicv2.h>
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/regulator.h>
+#include <drivers/st/stm32_iwdg.h>
+#include <drivers/st/stm32_rtc.h>
+#include <drivers/st/stm32mp_clkfunc.h>
+#include <drivers/st/stm32mp_pmic.h>
+#include <drivers/st/stm32mp1_ddr_helpers.h>
+#include <drivers/st/stm32mp1_pwr.h>
+#include <drivers/st/stm32mp1_rcc.h>
+#include <drivers/st/stpmic1.h>
+#include <dt-bindings/clock/stm32mp1-clks.h>
+#include <dt-bindings/power/stm32mp1-power.h>
+#include <lib/mmio.h>
+#include <lib/psci/psci.h>
+#include <lib/spinlock.h>
+#include <plat/common/platform.h>
+
+#include <boot_api.h>
+#include <stm32mp_common.h>
+#include <stm32mp_dt.h>
+#include <stm32mp1_context.h>
+#include <stm32mp1_low_power.h>
+#include <stm32mp1_power_config.h>
+#include <stm32mp1_private.h>
+
+static unsigned int gicc_pmr;
+static struct stm32_rtc_calendar sleep_time;
+static bool enter_cstop_done;
+static unsigned long long stgen_cnt;
+
+struct pwr_lp_config {
+	uint32_t pwr_cr1;
+	uint32_t pwr_mpucr;
+	const char *regul_suspend_node_name;
+};
+
+#define PWRLP_TEMPO_5_HSI	5
+
+#define PWR_CR1_MASK	(PWR_CR1_LPDS | PWR_CR1_LPCFG | PWR_CR1_LVDS)
+#define PWR_MPUCR_MASK	(PWR_MPUCR_CSTDBYDIS | PWR_MPUCR_CSSF | PWR_MPUCR_PDDS)
+
+static const struct pwr_lp_config config_pwr[STM32_PM_MAX_SOC_MODE] = {
+	[STM32_PM_CSLEEP_RUN] = {
+		.pwr_cr1 = 0U,
+		.pwr_mpucr = PWR_MPUCR_CSSF,
+		.regul_suspend_node_name = NULL,
+	},
+	[STM32_PM_CSTOP_ALLOW_STOP] = {
+		.pwr_cr1 = 0U,
+		.pwr_mpucr = PWR_MPUCR_CSTDBYDIS | PWR_MPUCR_CSSF,
+		.regul_suspend_node_name = NULL,
+	},
+	[STM32_PM_CSTOP_ALLOW_LP_STOP] = {
+		.pwr_cr1 = PWR_CR1_LPDS,
+		.pwr_mpucr = PWR_MPUCR_CSTDBYDIS | PWR_MPUCR_CSSF,
+		.regul_suspend_node_name = "lp-stop",
+	},
+	[STM32_PM_CSTOP_ALLOW_LPLV_STOP] = {
+		.pwr_cr1 = PWR_CR1_LVDS | PWR_CR1_LPDS | PWR_CR1_LPCFG,
+		.pwr_mpucr = PWR_MPUCR_CSTDBYDIS | PWR_MPUCR_CSSF,
+		.regul_suspend_node_name = "lplv-stop",
+	},
+	[STM32_PM_CSTOP_ALLOW_STANDBY_DDR_SR] = {
+		.pwr_cr1 = 0U,
+		.pwr_mpucr = PWR_MPUCR_CSTDBYDIS | PWR_MPUCR_CSSF |
+			PWR_MPUCR_PDDS,
+		.regul_suspend_node_name = "standby-ddr-sr",
+	},
+	[STM32_PM_CSTOP_ALLOW_STANDBY_DDR_OFF] = {
+		.pwr_cr1 = 0U,
+		.pwr_mpucr = PWR_MPUCR_CSTDBYDIS | PWR_MPUCR_CSSF |
+			PWR_MPUCR_PDDS,
+		.regul_suspend_node_name = "standby-ddr-off",
+	},
+	[STM32_PM_SHUTDOWN] = {
+		.pwr_cr1 = 0U,
+		.pwr_mpucr = 0U,
+		.regul_suspend_node_name = "standby-ddr-off",
+	},
+};
+
+#define GICC_PMR_PRIORITY_8	U(0x8)
+
+enum {
+	STATE_NONE = 0,
+	STATE_AUTOSTOP_ENTRY,
+	STATE_AUTOSTOP_EXIT,
+};
+
+static struct spinlock lp_lock;
+static volatile int cpu0_state = STATE_NONE;
+static volatile int cpu1_state = STATE_NONE;
+
+const char *plat_get_lp_mode_name(int mode)
+{
+	return config_pwr[mode].regul_suspend_node_name;
+}
+
+void stm32_apply_pmic_suspend_config(uint32_t mode)
+{
+	const char *node_name;
+
+	assert(mode < ARRAY_SIZE(config_pwr));
+
+	node_name = config_pwr[mode].regul_suspend_node_name;
+
+	if (node_name != NULL) {
+		if (!initialize_pmic_i2c()) {
+			panic();
+		}
+	}
+}
+
+/*
+ * stm32_enter_cstop - Prepare CSTOP mode
+ *
+ * @mode - Target low power mode
+ * @nsec_addr - Non secure resume entry point
+ * Return 0 if succeed to suspend, non 0 else.
+ */
+static void enter_cstop(uint32_t mode, uint32_t nsec_addr)
+{
+	uint32_t zq0cr0_zdata;
+	uintptr_t bkpr_core1_addr =
+		tamp_bkpr(BOOT_API_CORE1_BRANCH_ADDRESS_TAMP_BCK_REG_IDX);
+	uintptr_t bkpr_core1_magic =
+		tamp_bkpr(BOOT_API_CORE1_MAGIC_NUMBER_TAMP_BCK_REG_IDX);
+	uint32_t pwr_cr1 = config_pwr[mode].pwr_cr1;
+	uintptr_t pwr_base = stm32mp_pwr_base();
+	uintptr_t rcc_base = stm32mp_rcc_base();
+
+#ifdef STM32MP15
+	if (mode == STM32_PM_CSTOP_ALLOW_LPLV_STOP2) {
+		ERROR("LPLV-Stop2 mode not supported\n");
+		panic();
+	}
+#endif
+
+	stm32mp1_syscfg_disable_io_compensation();
+
+	stm32_clean_context();
+
+	if (mode == STM32_PM_CSTOP_ALLOW_STANDBY_DDR_SR) {
+		/*
+		 * The first 64 bytes of DDR need to be saved for DDR DQS
+		 * training
+		 */
+		stm32_save_ddr_training_area();
+	}
+
+	if (dt_pmic_status() > 0) {
+		stm32_apply_pmic_suspend_config(mode);
+
+		if (mode == STM32_PM_CSTOP_ALLOW_LP_STOP) {
+			pwr_cr1 |= PWR_CR1_LPCFG;
+		}
+	}
+
+	regulator_core_suspend(mode);
+
+	/* Clear RCC interrupt before enabling it */
+	mmio_setbits_32(rcc_base + RCC_MP_CIFR, RCC_MP_CIFR_WKUPF);
+
+	/* Enable RCC Wake-up */
+	mmio_setbits_32(rcc_base + RCC_MP_CIER, RCC_MP_CIFR_WKUPF);
+
+	/* Configure low power mode */
+	mmio_clrsetbits_32(pwr_base + PWR_MPUCR, PWR_MPUCR_MASK,
+			   config_pwr[mode].pwr_mpucr);
+	mmio_clrsetbits_32(pwr_base + PWR_CR1, PWR_CR1_MASK,
+			   pwr_cr1);
+
+	/* Clear RCC pending interrupt flags */
+	mmio_write_32(rcc_base + RCC_MP_CIFR, RCC_MP_CIFR_MASK);
+
+	/* Request CSTOP mode to RCC */
+	mmio_setbits_32(rcc_base + RCC_MP_SREQSETR,
+			RCC_MP_SREQSETR_STPREQ_P0 | RCC_MP_SREQSETR_STPREQ_P1);
+
+	stm32_iwdg_refresh();
+
+	gicc_pmr = plat_ic_set_priority_mask(GICC_PMR_PRIORITY_8);
+
+	zq0cr0_zdata = ddr_get_io_calibration_val();
+
+	clk_enable(RTCAPB);
+
+	mmio_write_32(bkpr_core1_addr, 0);
+	mmio_write_32(bkpr_core1_magic, 0);
+
+	stm32mp1_clock_stopmode_save();
+
+	stm32_rtc_get_calendar(&sleep_time);
+	stgen_cnt = stm32mp_stgen_get_counter();
+
+	if (mode == STM32_PM_CSTOP_ALLOW_STANDBY_DDR_SR) {
+		/*
+		 * Save non-secure world entrypoint after standby in Backup
+		 * register
+		 */
+		mmio_write_32(bkpr_core1_addr, nsec_addr);
+		mmio_write_32(bkpr_core1_magic,
+			      BOOT_API_A7_CORE0_MAGIC_NUMBER);
+
+		if (stm32_save_context(zq0cr0_zdata, &sleep_time,
+				       stgen_cnt) != 0) {
+			panic();
+		}
+
+		/* set POPL to 20ms */
+		mmio_clrsetbits_32(pwr_base + PWR_CR3, PWR_CR3_POPL_MASK,
+				   20U << PWR_CR3_POPL_SHIFT);
+
+		if (stm32mp1_get_retram_enabled()) {
+			mmio_setbits_32(pwr_base + PWR_CR2, PWR_CR2_RREN);
+			while ((mmio_read_32(pwr_base + PWR_CR2) &
+				PWR_CR2_RRRDY) == 0U) {
+				;
+			}
+		}
+
+		/* Keep backup RAM content in standby */
+		mmio_setbits_32(pwr_base + PWR_CR2, PWR_CR2_BREN);
+		while ((mmio_read_32(pwr_base + PWR_CR2) &
+			PWR_CR2_BRRDY) == 0U) {
+			;
+		}
+	}
+
+	clk_disable(RTCAPB);
+
+	enter_cstop_done = true;
+}
+
+bool stm32_is_cstop_done(void)
+{
+	return enter_cstop_done;
+}
+
+/*
+ * stm32_exit_cstop - Exit from CSTOP mode
+ */
+void stm32_exit_cstop(void)
+{
+	uintptr_t pwr_base = stm32mp_pwr_base();
+	uintptr_t rcc_base = stm32mp_rcc_base();
+	unsigned long long stdby_time_in_ms;
+	struct stm32_rtc_calendar current_calendar;
+
+	if (!enter_cstop_done) {
+		return;
+	}
+
+	enter_cstop_done = false;
+
+	stm32mp1_syscfg_enable_io_compensation_start();
+
+	plat_ic_set_priority_mask(gicc_pmr);
+
+	/* Disable RCC Wake-up */
+	mmio_clrbits_32(rcc_base + RCC_MP_CIER, RCC_MP_CIFR_WKUPF);
+
+	/* Disable STOP request */
+	mmio_setbits_32(rcc_base + RCC_MP_SREQCLRR,
+			RCC_MP_SREQSETR_STPREQ_P0 | RCC_MP_SREQSETR_STPREQ_P1);
+
+	dsb();
+	isb();
+
+	/* Disable retention and backup RAM content after stop */
+	mmio_clrbits_32(pwr_base + PWR_CR2, PWR_CR2_BREN | PWR_CR2_RREN);
+
+	/* Update STGEN counter with low power mode duration */
+	stm32_rtc_get_calendar(&current_calendar);
+
+	stdby_time_in_ms = stm32_rtc_diff_calendar(&current_calendar,
+						   &sleep_time);
+	stm32mp_stgen_restore_counter(stgen_cnt, stdby_time_in_ms);
+
+	if (stm32mp1_clock_stopmode_resume() != 0) {
+		panic();
+	}
+
+	regulator_core_resume();
+
+	stm32mp1_syscfg_enable_io_compensation_finish();
+}
+
+static int get_locked(volatile int *state)
+{
+	volatile int val;
+
+	spin_lock(&lp_lock);
+	val = *state;
+	spin_unlock(&lp_lock);
+
+	return val;
+}
+
+static void set_locked(volatile int *state, int val)
+{
+	spin_lock(&lp_lock);
+	*state = val;
+	spin_unlock(&lp_lock);
+}
+
+static void smp_synchro(int state, bool wake_up)
+{
+	/* if the other CPU is stopped, no need to synchronize */
+	if (psci_is_last_on_cpu() == 1U) {
+		return;
+	}
+
+	if (plat_my_core_pos() == STM32MP_PRIMARY_CPU) {
+		set_locked(&cpu0_state, state);
+
+		while (get_locked(&cpu1_state) != state) {
+			if (wake_up) {
+				/* wakeup secondary CPU */
+				gicv2_raise_sgi(ARM_IRQ_SEC_SGI_6,
+						STM32MP_SECONDARY_CPU);
+				udelay(10);
+			}
+		};
+	} else {
+		while (get_locked(&cpu0_state) != state) {
+			if (wake_up) {
+				/* wakeup primary CPU */
+				gicv2_raise_sgi(ARM_IRQ_SEC_SGI_6,
+						STM32MP_PRIMARY_CPU);
+				udelay(10);
+			}
+		};
+
+		set_locked(&cpu1_state, state);
+	}
+}
+
+static void stm32_auto_stop_cpu0(void)
+{
+	smp_synchro(STATE_AUTOSTOP_ENTRY, false);
+
+	enter_cstop(STM32_PM_CSTOP_ALLOW_LP_STOP, 0);
+
+	stm32_pwr_down_wfi(true, STM32_PM_CSTOP_ALLOW_LP_STOP);
+
+	stm32_exit_cstop();
+
+	smp_synchro(STATE_AUTOSTOP_EXIT, true);
+}
+
+static void stm32_auto_stop_cpu1(void)
+{
+	unsigned int gicc_pmr_cpu1;
+
+	/* clear cache before the DDR is being disabled by cpu0 */
+	dcsw_op_all(DC_OP_CISW);
+
+	smp_synchro(STATE_AUTOSTOP_ENTRY, false);
+
+	gicc_pmr_cpu1 = plat_ic_set_priority_mask(GICC_PMR_PRIORITY_8);
+	wfi();
+	plat_ic_set_priority_mask(gicc_pmr_cpu1);
+
+	smp_synchro(STATE_AUTOSTOP_EXIT, true);
+}
+
+void stm32_auto_stop(void)
+{
+	if (plat_my_core_pos() == STM32MP_PRIMARY_CPU) {
+		stm32_auto_stop_cpu0();
+	} else {
+		stm32_auto_stop_cpu1();
+	}
+}
+
+static void enter_csleep(void)
+{
+	uintptr_t pwr_base = stm32mp_pwr_base();
+
+	mmio_clrsetbits_32(pwr_base + PWR_MPUCR, PWR_MPUCR_MASK,
+			   config_pwr[STM32_PM_CSLEEP_RUN].pwr_mpucr);
+	mmio_clrsetbits_32(pwr_base + PWR_CR1, PWR_CR1_MASK,
+			   config_pwr[STM32_PM_CSLEEP_RUN].pwr_cr1);
+
+	stm32_pwr_down_wfi(false, STM32_PM_CSLEEP_RUN);
+}
+
+void stm32_enter_low_power(uint32_t mode, uint32_t nsec_addr)
+{
+	switch (mode) {
+	case STM32_PM_SHUTDOWN:
+		break;
+
+	case STM32_PM_CSLEEP_RUN:
+		enter_csleep();
+		break;
+
+	default:
+		enter_cstop(mode, nsec_addr);
+		break;
+	}
+}
+
+void stm32_init_low_power(void)
+{
+	uintptr_t pwr_base = stm32mp_pwr_base();
+	uintptr_t rcc_base = stm32mp_rcc_base();
+
+	/*
+	 * Configure Standby mode available for MCU by default
+	 * and allow to switch in standby SoC in all case
+	 */
+	mmio_setbits_32(pwr_base + PWR_MCUCR, PWR_MCUCR_PDDS);
+
+	/* Disable STOP request */
+	mmio_setbits_32(rcc_base + RCC_MP_SREQCLRR,
+			RCC_MP_SREQSETR_STPREQ_P0 | RCC_MP_SREQSETR_STPREQ_P1);
+
+	/* Disable retention and backup RAM content after standby */
+	mmio_clrbits_32(pwr_base + PWR_CR2, PWR_CR2_BREN | PWR_CR2_RREN);
+
+	/* Wait 5 HSI periods before re-enabling PLLs after STOP modes */
+	mmio_clrsetbits_32(rcc_base + RCC_PWRLPDLYCR,
+			   RCC_PWRLPDLYCR_PWRLP_DLY_MASK,
+			   PWRLP_TEMPO_5_HSI);
+}
diff --git a/plat/st/stm32mp1/stm32mp1_pm.c b/plat/st/stm32mp1/stm32mp1_pm.c
index 31a9ae7f1..1346c11b5 100644
--- a/plat/st/stm32mp1/stm32mp1_pm.c
+++ b/plat/st/stm32mp1/stm32mp1_pm.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2019, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2021, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -14,14 +14,21 @@
 #include <common/debug.h>
 #include <drivers/arm/gic_common.h>
 #include <drivers/arm/gicv2.h>
-#include <drivers/st/stm32mp1_clk.h>
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32mp_reset.h>
+#include <drivers/st/stm32mp1_rcc.h>
 #include <dt-bindings/clock/stm32mp1-clks.h>
 #include <lib/mmio.h>
 #include <lib/psci/psci.h>
 #include <plat/common/platform.h>
 
+#include <stm32mp1_low_power.h>
+#include <stm32mp1_power_config.h>
+
 static uintptr_t stm32_sec_entrypoint;
 static uint32_t cntfrq_core0;
+static uintptr_t saved_entrypoint;
 
 /*******************************************************************************
  * STM32MP1 handler called when a CPU is about to enter standby.
@@ -34,11 +41,12 @@ static void stm32_cpu_standby(plat_local_state_t cpu_state)
 	assert(cpu_state == ARM_LOCAL_STATE_RET);
 
 	/*
-	 * Enter standby state
-	 * dsb is good practice before using wfi to enter low power states
+	 * Enter standby state.
+	 * Synchronize on memory accesses and instruction flow before the WFI
+	 * instruction.
 	 */
-	isb();
 	dsb();
+	isb();
 	while (interrupt == GIC_SPURIOUS_INTERRUPT) {
 		wfi();
 
@@ -60,21 +68,34 @@ static void stm32_cpu_standby(plat_local_state_t cpu_state)
 static int stm32_pwr_domain_on(u_register_t mpidr)
 {
 	unsigned long current_cpu_mpidr = read_mpidr_el1();
-	uint32_t bkpr_core1_addr =
+	uintptr_t bkpr_core1_addr =
 		tamp_bkpr(BOOT_API_CORE1_BRANCH_ADDRESS_TAMP_BCK_REG_IDX);
-	uint32_t bkpr_core1_magic =
+	uintptr_t bkpr_core1_magic =
 		tamp_bkpr(BOOT_API_CORE1_MAGIC_NUMBER_TAMP_BCK_REG_IDX);
 
+	if (stm32mp_is_single_core()) {
+		return PSCI_E_INTERN_FAIL;
+	}
+
 	if (mpidr == current_cpu_mpidr) {
 		return PSCI_E_INVALID_PARAMS;
 	}
 
+	/* Reset backup register content */
+	mmio_write_32(bkpr_core1_magic, 0);
+
+	/* Need to send additional IT 0 after individual core 1 reset */
+	gicv2_raise_sgi(ARM_IRQ_NON_SEC_SGI_0, STM32MP_SECONDARY_CPU);
+
+	/* Wait for this IT to be acknowledged by ROM code. */
+	udelay(10);
+
 	/* Only one valid entry point */
 	if (stm32_sec_entrypoint != (uintptr_t)&sp_min_warm_entrypoint) {
 		return PSCI_E_INVALID_ADDRESS;
 	}
 
-	stm32mp_clk_enable(RTCAPB);
+	clk_enable(RTCAPB);
 
 	cntfrq_core0 = read_cntfrq_el0();
 
@@ -84,7 +105,7 @@ static int stm32_pwr_domain_on(u_register_t mpidr)
 	/* Write magic number in backup register */
 	mmio_write_32(bkpr_core1_magic, BOOT_API_A7_CORE1_MAGIC_NUMBER);
 
-	stm32mp_clk_disable(RTCAPB);
+	clk_disable(RTCAPB);
 
 	/* Generate an IT to core 1 */
 	gicv2_raise_sgi(ARM_IRQ_SEC_SGI_0, STM32MP_SECONDARY_CPU);
@@ -107,7 +128,9 @@ static void stm32_pwr_domain_off(const psci_power_state_t *target_state)
  ******************************************************************************/
 static void stm32_pwr_domain_suspend(const psci_power_state_t *target_state)
 {
-	/* Nothing to do, power domain is not disabled */
+	uint32_t soc_mode = stm32mp1_get_lp_soc_mode(PSCI_MODE_SYSTEM_SUSPEND);
+
+	stm32_enter_low_power(soc_mode, saved_entrypoint);
 }
 
 /*******************************************************************************
@@ -118,7 +141,7 @@ static void stm32_pwr_domain_suspend(const psci_power_state_t *target_state)
  ******************************************************************************/
 static void stm32_pwr_domain_on_finish(const psci_power_state_t *target_state)
 {
-	stm32mp1_gic_pcpu_init();
+	stm32mp_gic_pcpu_init();
 
 	write_cntfrq_el0(cntfrq_core0);
 }
@@ -134,28 +157,66 @@ static void stm32_pwr_domain_suspend_finish(const psci_power_state_t
 	/* Nothing to do, power domain is not disabled */
 }
 
+/*******************************************************************************
+ * STM32MP1 handler called when a core tries to power itself down. If this
+ * call is made by core 0, it is a return from stop mode. In this case, we
+ * should restore previous context and jump to secure entrypoint.
+ ******************************************************************************/
 static void __dead2 stm32_pwr_domain_pwr_down_wfi(const psci_power_state_t
 						  *target_state)
 {
-	ERROR("stm32mpu1 Power Down WFI: operation not handled.\n");
+	if (MPIDR_AFFLVL0_VAL(read_mpidr_el1()) == STM32MP_PRIMARY_CPU) {
+		void (*warm_entrypoint)(void) =
+			(void (*)(void))stm32_sec_entrypoint;
+
+		stm32_pwr_down_wfi(stm32_is_cstop_done(),
+				   stm32mp1_get_lp_soc_mode(PSCI_MODE_SYSTEM_SUSPEND));
+
+		stm32_exit_cstop();
+
+		disable_mmu_icache_secure();
+
+		warm_entrypoint();
+	}
+
+	mmio_write_32(stm32mp_rcc_base() + RCC_MP_GRSTCSETR,
+		      RCC_MP_GRSTCSETR_MPUP1RST);
+
+	/*
+	 * Synchronize on memory accesses and instruction flow before
+	 * auto-reset from the WFI instruction.
+	 */
+	dsb();
+	isb();
+	wfi();
+
+	/* This shouldn't be reached */
 	panic();
 }
 
 static void __dead2 stm32_system_off(void)
 {
-	ERROR("stm32mpu1 System Off: operation not handled.\n");
+	uint32_t soc_mode = stm32mp1_get_lp_soc_mode(PSCI_MODE_SYSTEM_OFF);
+
+	if (!stm32mp_is_single_core()) {
+		/* Prepare Core 1 reset */
+		mmio_setbits_32(stm32mp_rcc_base() + RCC_MP_GRSTCSETR,
+				RCC_MP_GRSTCSETR_MPUP1RST);
+		/* Send IT to core 1 to put itself in WFI */
+		gicv2_raise_sgi(ARM_IRQ_SEC_SGI_1, STM32MP_SECONDARY_CPU);
+	}
+
+	stm32_enter_low_power(soc_mode, 0);
+
+	stm32_pwr_down_wfi(true, soc_mode);
+
+	/* This shouldn't be reached */
 	panic();
 }
 
 static void __dead2 stm32_system_reset(void)
 {
-	mmio_setbits_32(stm32mp_rcc_base() + RCC_MP_GRSTCSETR,
-			RCC_MP_GRSTCSETR_MPSYSRST);
-
-	/* Loop in case system reset is not immediately caught */
-	for ( ; ; ) {
-		;
-	}
+	stm32mp_system_reset();
 }
 
 static int stm32_validate_power_state(unsigned int power_state,
@@ -188,6 +249,8 @@ static int stm32_validate_ns_entrypoint(uintptr_t entrypoint)
 		return PSCI_E_INVALID_ADDRESS;
 	}
 
+	saved_entrypoint = entrypoint;
+
 	return PSCI_E_SUCCESS;
 }
 
@@ -211,6 +274,12 @@ static int stm32_node_hw_state(u_register_t target_cpu,
 	return (int)HW_ON;
 }
 
+static void stm32_get_sys_suspend_power_state(psci_power_state_t *req_state)
+{
+	req_state->pwr_domain_state[0] = ARM_LOCAL_STATE_OFF;
+	req_state->pwr_domain_state[1] = ARM_LOCAL_STATE_OFF;
+}
+
 /*******************************************************************************
  * Export the platform handlers. The ARM Standard platform layer will take care
  * of registering the handlers with PSCI.
@@ -227,7 +296,8 @@ static const plat_psci_ops_t stm32_psci_ops = {
 	.system_reset = stm32_system_reset,
 	.validate_power_state = stm32_validate_power_state,
 	.validate_ns_entrypoint = stm32_validate_ns_entrypoint,
-	.get_node_hw_state = stm32_node_hw_state
+	.get_node_hw_state = stm32_node_hw_state,
+	.get_sys_suspend_power_state = stm32_get_sys_suspend_power_state,
 };
 
 /*******************************************************************************
diff --git a/plat/st/stm32mp1/stm32mp1_power_config.c b/plat/st/stm32mp1/stm32mp1_power_config.c
new file mode 100644
index 000000000..6f1e6467b
--- /dev/null
+++ b/plat/st/stm32mp1/stm32mp1_power_config.c
@@ -0,0 +1,229 @@
+/*
+ * Copyright (c) 2017-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <limits.h>
+
+#include <libfdt.h>
+
+#include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <dt-bindings/power/stm32mp1-power.h>
+
+#include <stm32mp_dt.h>
+#include <stm32mp1_power_config.h>
+
+#define SYSTEM_SUSPEND_SUPPORTED_MODES	"system_suspend_supported_soc_modes"
+#define SYSTEM_OFF_MODE			"system_off_soc_mode"
+#define RETRAM_ENABLED			"st,retram-enabled-in-standby-ddr-sr"
+
+static uint32_t deepest_system_suspend_mode;
+static uint32_t system_off_mode;
+static bool retram_enabled;
+static uint8_t stm32mp1_supported_soc_modes[STM32_PM_MAX_SOC_MODE];
+
+static int dt_get_pwr_node(void *fdt)
+{
+	return fdt_node_offset_by_compatible(fdt, -1, DT_PWR_COMPAT);
+}
+
+static void save_supported_mode(void *fdt, int pwr_node)
+{
+	int len;
+	uint32_t count;
+	unsigned int i;
+	uint32_t supported[ARRAY_SIZE(stm32mp1_supported_soc_modes)];
+	const void *prop;
+
+	prop = fdt_getprop(fdt, pwr_node, SYSTEM_SUSPEND_SUPPORTED_MODES, &len);
+	if (prop == NULL) {
+		panic();
+	}
+
+	count = (uint32_t)len / sizeof(uint32_t);
+	if (count > STM32_PM_MAX_SOC_MODE) {
+		panic();
+	}
+
+	if (fdt_read_uint32_array(fdt, pwr_node, SYSTEM_SUSPEND_SUPPORTED_MODES,
+				  count, &supported[0]) < 0) {
+		ERROR("PWR DT\n");
+		panic();
+	}
+
+	for (i = 0; i < count; i++) {
+		if (supported[i] >= STM32_PM_MAX_SOC_MODE) {
+			ERROR("Invalid mode\n");
+			panic();
+		}
+		stm32mp1_supported_soc_modes[supported[i]] = 1U;
+	}
+
+	/* Initialize to deepest possible mode */
+	for (i = STM32_PM_MAX_SOC_MODE - 1U; i != STM32_PM_CSLEEP_RUN; i--) {
+		if (stm32mp1_supported_soc_modes[i] == 1U) {
+			deepest_system_suspend_mode = i;
+			break;
+		}
+	}
+}
+
+static int dt_fill_lp_state(uint32_t *lp_state_config, const char *lp_state)
+{
+	int pwr_node;
+	void *fdt;
+	const fdt32_t *cuint;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -ENOENT;
+	}
+
+	pwr_node = dt_get_pwr_node(fdt);
+	if (pwr_node < 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	cuint = fdt_getprop(fdt, pwr_node, lp_state, NULL);
+	if (cuint == NULL) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	*lp_state_config = fdt32_to_cpu(*cuint);
+
+	save_supported_mode(fdt, pwr_node);
+
+	return 0;
+}
+
+static int dt_fill_retram_enabled(void)
+{
+	int pwr_node;
+	void *fdt;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -ENOENT;
+	}
+
+	pwr_node = dt_get_pwr_node(fdt);
+	if (pwr_node < 0) {
+		return -ENOENT;
+	}
+
+	if (fdt_getprop(fdt, pwr_node, RETRAM_ENABLED, NULL) == NULL) {
+		retram_enabled = false;
+	} else {
+		retram_enabled = true;
+	}
+
+	return 0;
+}
+
+void stm32mp1_init_lp_states(void)
+{
+	if (dt_fill_lp_state(&system_off_mode, SYSTEM_OFF_MODE) < 0) {
+		ERROR("Node %s not found\n", SYSTEM_OFF_MODE);
+		panic();
+	}
+
+	if (dt_fill_retram_enabled() < 0) {
+		ERROR("could not configure retram state\n");
+		panic();
+	}
+}
+
+/* Init with all domains ON */
+static bool pm_dom[STM32MP1_PD_MAX_PM_DOMAIN] = {
+	[STM32MP1_PD_VSW] = false,
+	[STM32MP1_PD_CORE_RET] = false,
+	[STM32MP1_PD_CORE] = false
+};
+
+static bool stm32mp1_get_pm_domain_state(uint8_t mode)
+{
+	bool res = true;
+	enum stm32mp1_pm_domain id = STM32MP1_PD_MAX_PM_DOMAIN;
+
+	while (res && (id > mode)) {
+		id--;
+		res &= pm_dom[id];
+	}
+
+	return res;
+}
+
+int stm32mp1_set_pm_domain_state(enum stm32mp1_pm_domain domain, bool status)
+{
+	if (domain >= STM32MP1_PD_MAX_PM_DOMAIN) {
+		return -EINVAL;
+	}
+
+	pm_dom[domain] = status;
+
+	return 0;
+}
+
+static bool is_allowed_mode(uint32_t soc_mode)
+{
+	assert(soc_mode < ARRAY_SIZE(stm32mp1_supported_soc_modes));
+
+	if ((soc_mode == STM32_PM_CSTOP_ALLOW_STANDBY_DDR_SR) &&
+	    !stm32mp1_get_pm_domain_state(STM32MP1_PD_CORE_RET)) {
+		return false;
+	}
+
+#ifdef STM32MP15
+	if (soc_mode == STM32_PM_CSTOP_ALLOW_LPLV_STOP2) {
+		return false;
+	}
+#endif
+
+	if ((soc_mode == STM32_PM_CSTOP_ALLOW_LPLV_STOP) &&
+	    !stm32mp1_get_pm_domain_state(STM32MP1_PD_CORE)) {
+		return false;
+	}
+
+	return stm32mp1_supported_soc_modes[soc_mode] == 1U;
+}
+
+uint32_t stm32mp1_get_lp_soc_mode(uint32_t psci_mode)
+{
+	uint32_t mode;
+
+	if (psci_mode == PSCI_MODE_SYSTEM_OFF) {
+		return system_off_mode;
+	}
+
+	mode = deepest_system_suspend_mode;
+
+	while ((mode > STM32_PM_CSLEEP_RUN) && !is_allowed_mode(mode)) {
+		mode--;
+	}
+
+	return mode;
+}
+
+int stm32mp1_set_lp_deepest_soc_mode(uint32_t psci_mode, uint32_t soc_mode)
+{
+	if (soc_mode >= STM32_PM_MAX_SOC_MODE) {
+		return -EINVAL;
+	}
+
+	if (psci_mode == PSCI_MODE_SYSTEM_SUSPEND) {
+		deepest_system_suspend_mode = soc_mode;
+	}
+
+	if (psci_mode == PSCI_MODE_SYSTEM_OFF) {
+		system_off_mode = soc_mode;
+	}
+
+	return 0;
+}
+
+bool stm32mp1_get_retram_enabled(void)
+{
+	return retram_enabled;
+}
diff --git a/plat/st/stm32mp1/stm32mp1_private.c b/plat/st/stm32mp1/stm32mp1_private.c
index e4065c1c9..e4ad19ff6 100644
--- a/plat/st/stm32mp1/stm32mp1_private.c
+++ b/plat/st/stm32mp1/stm32mp1_private.c
@@ -1,38 +1,42 @@
 /*
- * Copyright (c) 2015-2021, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
 #include <assert.h>
 
+#include <arch_helpers.h>
+#include <drivers/arm/gicv2.h>
+#include <drivers/clk.h>
+#include <drivers/st/stm32_gpio.h>
+#include <drivers/st/stm32_iwdg.h>
 #include <libfdt.h>
+#include <lib/mmio.h>
+#include <lib/xlat_tables/xlat_tables_v2.h>
+#include <plat/common/platform.h>
+#include <smccc_helpers.h>
 
+#include <plat/common/platform.h>
 #include <platform_def.h>
 
-#include <drivers/st/stm32_iwdg.h>
-#include <lib/xlat_tables/xlat_tables_v2.h>
+#if STM32MP13
+#define TAMP_BOOT_ITF_BACKUP_REG_ID	U(30)
+#endif
+#if STM32MP15
+#define TAMP_BOOT_ITF_BACKUP_REG_ID	U(20)
+#endif
 
-/* Internal layout of the 32bit OTP word board_id */
-#define BOARD_ID_BOARD_NB_MASK		GENMASK(31, 16)
-#define BOARD_ID_BOARD_NB_SHIFT		16
-#define BOARD_ID_VARCPN_MASK		GENMASK(15, 12)
-#define BOARD_ID_VARCPN_SHIFT		12
-#define BOARD_ID_REVISION_MASK		GENMASK(11, 8)
-#define BOARD_ID_REVISION_SHIFT		8
-#define BOARD_ID_VARFG_MASK		GENMASK(7, 4)
-#define BOARD_ID_VARFG_SHIFT		4
-#define BOARD_ID_BOM_MASK		GENMASK(3, 0)
-
-#define BOARD_ID2NB(_id)		(((_id) & BOARD_ID_BOARD_NB_MASK) >> \
-					 BOARD_ID_BOARD_NB_SHIFT)
-#define BOARD_ID2VARCPN(_id)		(((_id) & BOARD_ID_VARCPN_MASK) >> \
-					 BOARD_ID_VARCPN_SHIFT)
-#define BOARD_ID2REV(_id)		(((_id) & BOARD_ID_REVISION_MASK) >> \
-					 BOARD_ID_REVISION_SHIFT)
-#define BOARD_ID2VARFG(_id)		(((_id) & BOARD_ID_VARFG_MASK) >> \
-					 BOARD_ID_VARFG_SHIFT)
-#define BOARD_ID2BOM(_id)		((_id) & BOARD_ID_BOM_MASK)
+/*
+ * Backup register to store fwu update information.
+ * It should be writeable only by secure world, but also readable by non secure
+ * (so it should be in Zone 2).
+ */
+#define TAMP_BOOT_FWU_INFO_REG_ID	U(10)
+#define TAMP_BOOT_FWU_INFO_IDX_MSK	U(0xF)
+#define TAMP_BOOT_FWU_INFO_IDX_OFF	U(0)
+#define TAMP_BOOT_FWU_INFO_CNT_MSK	U(0xF0)
+#define TAMP_BOOT_FWU_INFO_CNT_OFF	U(4)
 
 #if defined(IMAGE_BL2)
 #define MAP_SEC_SYSRAM	MAP_REGION_FLAT(STM32MP_SYSRAM_BASE, \
@@ -58,6 +62,15 @@
 					MT_EXECUTE_NEVER)
 #endif
 
+#if STM32MP13
+#define MAP_SRAM_ALL	MAP_REGION_FLAT(SRAMS_BASE, \
+					SRAMS_SIZE_2MB_ALIGNED, \
+					MT_MEMORY | \
+					MT_RW | \
+					MT_SECURE | \
+					MT_EXECUTE_NEVER)
+#endif
+
 #define MAP_DEVICE1	MAP_REGION_FLAT(STM32MP1_DEVICE1_BASE, \
 					STM32MP1_DEVICE1_SIZE, \
 					MT_DEVICE | \
@@ -75,8 +88,13 @@
 #if defined(IMAGE_BL2)
 static const mmap_region_t stm32mp1_mmap[] = {
 	MAP_SEC_SYSRAM,
+#if STM32MP13
+	MAP_SRAM_ALL,
+#endif
 	MAP_DEVICE1,
+#if STM32MP_RAW_NAND
 	MAP_DEVICE2,
+#endif
 	{0}
 };
 #endif
@@ -98,41 +116,108 @@ void configure_mmu(void)
 	enable_mmu_svc_mon(0);
 }
 
+#define ARM_CNTXCTL_IMASK	BIT(1)
+
+void stm32mp_mask_timer(void)
+{
+	/* Mask timer interrupts */
+	write_cntp_ctl(read_cntp_ctl() | ARM_CNTXCTL_IMASK);
+	write_cntv_ctl(read_cntv_ctl() | ARM_CNTXCTL_IMASK);
+}
+
+void __dead2 stm32mp_wait_cpu_reset(void)
+{
+	uint32_t id;
+
+	dcsw_op_all(DC_OP_CISW);
+	write_sctlr(read_sctlr() & ~SCTLR_C_BIT);
+	dcsw_op_all(DC_OP_CISW);
+	__asm__("clrex");
+
+	dsb();
+	isb();
+
+	for ( ; ; ) {
+		do {
+			id = plat_ic_get_pending_interrupt_id();
+
+			if (id <= MAX_SPI_ID) {
+				gicv2_end_of_interrupt(id);
+
+				plat_ic_disable_interrupt(id);
+			}
+		} while (id <= MAX_SPI_ID);
+
+		wfi();
+	}
+}
+
 uintptr_t stm32_get_gpio_bank_base(unsigned int bank)
 {
+#if STM32MP13
+	assert(GPIO_BANK_A == 0 && bank <= GPIO_BANK_I);
+#endif
+#if STM32MP15
 	if (bank == GPIO_BANK_Z) {
 		return GPIOZ_BASE;
 	}
 
 	assert(GPIO_BANK_A == 0 && bank <= GPIO_BANK_K);
+#endif
 
 	return GPIOA_BASE + (bank * GPIO_BANK_OFFSET);
 }
 
 uint32_t stm32_get_gpio_bank_offset(unsigned int bank)
 {
+#if STM32MP13
+	assert(GPIO_BANK_A == 0 && bank <= GPIO_BANK_I);
+#endif
+#if STM32MP15
 	if (bank == GPIO_BANK_Z) {
 		return 0;
 	}
 
 	assert(GPIO_BANK_A == 0 && bank <= GPIO_BANK_K);
+#endif
 
 	return bank * GPIO_BANK_OFFSET;
 }
 
+bool stm32_gpio_is_secure_at_reset(unsigned int bank)
+{
+#if STM32MP13
+	return true;
+#endif
+#if STM32MP15
+	if (bank == GPIO_BANK_Z) {
+		return true;
+	}
+
+	return false;
+#endif
+}
+
 unsigned long stm32_get_gpio_bank_clock(unsigned int bank)
 {
+#if STM32MP13
+	assert(GPIO_BANK_A == 0 && bank <= GPIO_BANK_I);
+#endif
+#if STM32MP15
 	if (bank == GPIO_BANK_Z) {
 		return GPIOZ;
 	}
 
 	assert(GPIO_BANK_A == 0 && bank <= GPIO_BANK_K);
+#endif
 
 	return GPIOA + (bank - GPIO_BANK_A);
 }
 
 int stm32_get_gpio_bank_pinctrl_node(void *fdt, unsigned int bank)
 {
+	const char *node_compatible = NULL;
+
 	switch (bank) {
 	case GPIO_BANK_A:
 	case GPIO_BANK_B:
@@ -143,18 +228,105 @@ int stm32_get_gpio_bank_pinctrl_node(void *fdt, unsigned int bank)
 	case GPIO_BANK_G:
 	case GPIO_BANK_H:
 	case GPIO_BANK_I:
+#if STM32MP13
+		node_compatible = "st,stm32mp135-pinctrl";
+		break;
+#endif
+#if STM32MP15
 	case GPIO_BANK_J:
 	case GPIO_BANK_K:
-		return fdt_path_offset(fdt, "/soc/pin-controller");
+		node_compatible = "st,stm32mp157-pinctrl";
+		break;
 	case GPIO_BANK_Z:
-		return fdt_path_offset(fdt, "/soc/pin-controller-z");
+		node_compatible = "st,stm32mp157-z-pinctrl";
+		break;
+#endif
 	default:
 		panic();
 	}
+
+	return fdt_node_offset_by_compatible(fdt, -1, node_compatible);
 }
 
+#if STM32MP_UART_PROGRAMMER || !defined(IMAGE_BL2)
+/*
+ * UART Management
+ */
+static const uintptr_t stm32mp1_uart_addresses[8] = {
+	USART1_BASE,
+	USART2_BASE,
+	USART3_BASE,
+	UART4_BASE,
+	UART5_BASE,
+	USART6_BASE,
+	UART7_BASE,
+	UART8_BASE,
+};
+
+uintptr_t get_uart_address(uint32_t instance_nb)
+{
+	if ((instance_nb == 0U) ||
+	    (instance_nb > ARRAY_SIZE(stm32mp1_uart_addresses))) {
+		return 0U;
+	}
+
+	return stm32mp1_uart_addresses[instance_nb - 1U];
+}
+#endif
+
+#if STM32MP_USB_PROGRAMMER
+struct gpio_bank_pin_list {
+	uint32_t bank;
+	uint32_t pin;
+};
+
+static const struct gpio_bank_pin_list gpio_list[] = {
+	{	/* USART2_RX: GPIOA3 */
+		.bank = 0,
+		.pin = 3,
+	},
+	{	/* USART3_RX: GPIOB12 */
+		.bank = 1,
+		.pin = 12,
+	},
+	{	/* UART4_RX: GPIOB2 */
+		.bank = 1,
+		.pin = 2,
+	},
+	{	/* UART5_RX: GPIOB4 */
+		.bank = 1,
+		.pin = 5,
+	},
+	{	/* USART6_RX: GPIOC7 */
+		.bank = 2,
+		.pin = 7,
+	},
+	{	/* UART7_RX: GPIOF6 */
+		.bank = 5,
+		.pin = 6,
+	},
+	{	/* UART8_RX: GPIOE0 */
+		.bank = 4,
+		.pin = 0,
+	},
+};
+
+void stm32mp1_deconfigure_uart_pins(void)
+{
+	size_t i;
+
+	for (i = 0; i < ARRAY_SIZE(gpio_list); i++) {
+		set_gpio_reset_cfg(gpio_list[i].bank, gpio_list[i].pin);
+	}
+}
+#endif
+
 uint32_t stm32mp_get_chip_version(void)
 {
+#if STM32MP13
+	return stm32mp1_syscfg_get_chip_version();
+#endif
+#if STM32MP15
 	uint32_t version = 0U;
 
 	if (stm32mp1_dbgmcu_get_chip_version(&version) < 0) {
@@ -163,10 +335,15 @@ uint32_t stm32mp_get_chip_version(void)
 	}
 
 	return version;
+#endif
 }
 
 uint32_t stm32mp_get_chip_dev_id(void)
 {
+#if STM32MP13
+	return stm32mp1_syscfg_get_chip_dev_id();
+#endif
+#if STM32MP15
 	uint32_t dev_id;
 
 	if (stm32mp1_dbgmcu_get_chip_dev_id(&dev_id) < 0) {
@@ -175,6 +352,7 @@ uint32_t stm32mp_get_chip_dev_id(void)
 	}
 
 	return dev_id;
+#endif
 }
 
 static uint32_t get_part_number(void)
@@ -185,7 +363,7 @@ static uint32_t get_part_number(void)
 		return part_number;
 	}
 
-	if (bsec_shadow_read_otp(&part_number, PART_NUMBER_OTP) != BSEC_OK) {
+	if (stm32_get_otp_value(PART_NUMBER_OTP, &part_number) != 0) {
 		panic();
 	}
 
@@ -197,11 +375,12 @@ static uint32_t get_part_number(void)
 	return part_number;
 }
 
+#if STM32MP15
 static uint32_t get_cpu_package(void)
 {
 	uint32_t package;
 
-	if (bsec_shadow_read_otp(&package, PACKAGE_OTP) != BSEC_OK) {
+	if (stm32_get_otp_value(PACKAGE_OTP, &package) != 0) {
 		panic();
 	}
 
@@ -210,6 +389,43 @@ static uint32_t get_cpu_package(void)
 
 	return package;
 }
+#endif
+
+bool stm32mp_supports_cpu_opp(uint32_t opp_id)
+{
+	uint32_t id;
+
+	switch (opp_id) {
+	case PLAT_OPP_ID1:
+	case PLAT_OPP_ID2:
+		id = opp_id;
+		break;
+	default:
+		return false;
+	}
+
+	switch (get_part_number()) {
+#if STM32MP13
+	case STM32MP135F_PART_NB:
+	case STM32MP135D_PART_NB:
+	case STM32MP133F_PART_NB:
+	case STM32MP133D_PART_NB:
+	case STM32MP131F_PART_NB:
+	case STM32MP131D_PART_NB:
+#endif
+#if STM32MP15
+	case STM32MP157F_PART_NB:
+	case STM32MP157D_PART_NB:
+	case STM32MP153F_PART_NB:
+	case STM32MP153D_PART_NB:
+	case STM32MP151F_PART_NB:
+	case STM32MP151D_PART_NB:
+#endif
+		return true;
+	default:
+		return id == PLAT_OPP_ID1;
+	}
+}
 
 void stm32mp_get_soc_name(char name[STM32_SOC_NAME_SIZE])
 {
@@ -217,6 +433,45 @@ void stm32mp_get_soc_name(char name[STM32_SOC_NAME_SIZE])
 
 	/* MPUs Part Numbers */
 	switch (get_part_number()) {
+#if STM32MP13
+	case STM32MP135F_PART_NB:
+		cpu_s = "135F";
+		break;
+	case STM32MP135D_PART_NB:
+		cpu_s = "135D";
+		break;
+	case STM32MP135C_PART_NB:
+		cpu_s = "135C";
+		break;
+	case STM32MP135A_PART_NB:
+		cpu_s = "135A";
+		break;
+	case STM32MP133F_PART_NB:
+		cpu_s = "133F";
+		break;
+	case STM32MP133D_PART_NB:
+		cpu_s = "133D";
+		break;
+	case STM32MP133C_PART_NB:
+		cpu_s = "133C";
+		break;
+	case STM32MP133A_PART_NB:
+		cpu_s = "133A";
+		break;
+	case STM32MP131F_PART_NB:
+		cpu_s = "131F";
+		break;
+	case STM32MP131D_PART_NB:
+		cpu_s = "131D";
+		break;
+	case STM32MP131C_PART_NB:
+		cpu_s = "131C";
+		break;
+	case STM32MP131A_PART_NB:
+		cpu_s = "131A";
+		break;
+#endif
+#if STM32MP15
 	case STM32MP157C_PART_NB:
 		cpu_s = "157C";
 		break;
@@ -253,12 +508,18 @@ void stm32mp_get_soc_name(char name[STM32_SOC_NAME_SIZE])
 	case STM32MP151D_PART_NB:
 		cpu_s = "151D";
 		break;
+#endif
 	default:
 		cpu_s = "????";
 		break;
 	}
 
 	/* Package */
+#if STM32MP13
+	/* On STM32MP13, package is not present in OTP */
+	pkg = "";
+#endif
+#if STM32MP15
 	switch (get_cpu_package()) {
 	case PKG_AA_LFBGA448:
 		pkg = "AA";
@@ -276,12 +537,18 @@ void stm32mp_get_soc_name(char name[STM32_SOC_NAME_SIZE])
 		pkg = "??";
 		break;
 	}
+#endif
 
 	/* REVISION */
 	switch (stm32mp_get_chip_version()) {
 	case STM32MP1_REV_B:
 		cpu_r = "B";
 		break;
+#if STM32MP13
+	case STM32MP1_REV_Y:
+		cpu_r = "Y";
+		break;
+#endif
 	case STM32MP1_REV_Z:
 		cpu_r = "Z";
 		break;
@@ -304,64 +571,39 @@ void stm32mp_print_cpuinfo(void)
 
 void stm32mp_print_boardinfo(void)
 {
-	uint32_t board_id;
-	uint32_t board_otp;
-	int bsec_node, bsec_board_id_node;
-	void *fdt;
-	const fdt32_t *cuint;
-
-	if (fdt_get_address(&fdt) == 0) {
-		panic();
-	}
-
-	bsec_node = fdt_node_offset_by_compatible(fdt, -1, DT_BSEC_COMPAT);
-	if (bsec_node < 0) {
-		return;
-	}
+	uint32_t board_id = 0U;
 
-	bsec_board_id_node = fdt_subnode_offset(fdt, bsec_node, "board_id");
-	if (bsec_board_id_node <= 0) {
-		return;
-	}
-
-	cuint = fdt_getprop(fdt, bsec_board_id_node, "reg", NULL);
-	if (cuint == NULL) {
-		panic();
-	}
-
-	board_otp = fdt32_to_cpu(*cuint) / sizeof(uint32_t);
-
-	if (bsec_shadow_read_otp(&board_id, board_otp) != BSEC_OK) {
-		ERROR("BSEC: PART_NUMBER_OTP Error\n");
+	if (stm32_get_otp_value(BOARD_ID_OTP, &board_id) != 0) {
 		return;
 	}
 
 	if (board_id != 0U) {
-		char rev[2];
-
-		rev[0] = BOARD_ID2REV(board_id) - 1 + 'A';
-		rev[1] = '\0';
-		NOTICE("Board: MB%04x Var%u.%u Rev.%s-%02u\n",
-		       BOARD_ID2NB(board_id),
-		       BOARD_ID2VARCPN(board_id),
-		       BOARD_ID2VARFG(board_id),
-		       rev,
-		       BOARD_ID2BOM(board_id));
+		stm32_display_board_info(board_id);
 	}
 }
 
 /* Return true when SoC provides a single Cortex-A7 core, and false otherwise */
 bool stm32mp_is_single_core(void)
 {
+#if STM32MP13
+	return true;
+#endif
+#if STM32MP15
+	bool single_core = false;
+
 	switch (get_part_number()) {
 	case STM32MP151A_PART_NB:
 	case STM32MP151C_PART_NB:
 	case STM32MP151D_PART_NB:
 	case STM32MP151F_PART_NB:
-		return true;
+		single_core = true;
+		break;
 	default:
-		return false;
+		break;
 	}
+
+	return single_core;
+#endif
 }
 
 /* Return true when device is in closed state */
@@ -369,12 +611,58 @@ bool stm32mp_is_closed_device(void)
 {
 	uint32_t value;
 
-	if ((bsec_shadow_register(DATA0_OTP) != BSEC_OK) ||
-	    (bsec_read_otp(&value, DATA0_OTP) != BSEC_OK)) {
+	if (stm32_get_otp_value(CFG0_OTP, &value) != 0) {
 		return true;
 	}
 
-	return (value & DATA0_OTP_SECURED) == DATA0_OTP_SECURED;
+#if STM32MP13
+	value = (value & CFG0_OTP_MODE_MASK) >> CFG0_OTP_MODE_SHIFT;
+
+	switch (value) {
+	case CFG0_OPEN_DEVICE:
+		return false;
+	case CFG0_CLOSED_DEVICE:
+	case CFG0_CLOSED_DEVICE_NO_BOUNDARY_SCAN:
+	case CFG0_CLOSED_DEVICE_NO_JTAG:
+		return true;
+	default:
+		panic();
+	}
+#endif
+#if STM32MP15
+	return (value & CFG0_CLOSED_DEVICE) == CFG0_CLOSED_DEVICE;
+#endif
+}
+
+/* Return true when device supports secure boot */
+bool stm32mp_is_auth_supported(void)
+{
+	bool supported = false;
+
+	switch (get_part_number()) {
+#if STM32MP13
+	case STM32MP131C_PART_NB:
+	case STM32MP131F_PART_NB:
+	case STM32MP133C_PART_NB:
+	case STM32MP133F_PART_NB:
+	case STM32MP135C_PART_NB:
+	case STM32MP135F_PART_NB:
+#endif
+#if STM32MP15
+	case STM32MP151C_PART_NB:
+	case STM32MP151F_PART_NB:
+	case STM32MP153C_PART_NB:
+	case STM32MP153F_PART_NB:
+	case STM32MP157C_PART_NB:
+	case STM32MP157F_PART_NB:
+#endif
+		supported = true;
+		break;
+	default:
+		break;
+	}
+
+	return supported;
 }
 
 uint32_t stm32_iwdg_get_instance(uintptr_t base)
@@ -394,13 +682,7 @@ uint32_t stm32_iwdg_get_otp_config(uint32_t iwdg_inst)
 	uint32_t iwdg_cfg = 0U;
 	uint32_t otp_value;
 
-#if defined(IMAGE_BL2)
-	if (bsec_shadow_register(HW2_OTP) != BSEC_OK) {
-		panic();
-	}
-#endif
-
-	if (bsec_read_otp(&otp_value, HW2_OTP) != BSEC_OK) {
+	if (stm32_get_otp_value(HW2_OTP, &otp_value) != 0) {
 		panic();
 	}
 
@@ -422,29 +704,34 @@ uint32_t stm32_iwdg_get_otp_config(uint32_t iwdg_inst)
 #if defined(IMAGE_BL2)
 uint32_t stm32_iwdg_shadow_update(uint32_t iwdg_inst, uint32_t flags)
 {
+	uint32_t otp_value;
 	uint32_t otp;
 	uint32_t result;
 
-	if (bsec_shadow_read_otp(&otp, HW2_OTP) != BSEC_OK) {
+	if (stm32_get_otp_index(HW2_OTP, &otp, NULL) != 0) {
+		panic();
+	}
+
+	if (stm32_get_otp_value(HW2_OTP, &otp_value) != 0) {
 		panic();
 	}
 
-	if ((flags & IWDG_DISABLE_ON_STOP) != 0U) {
-		otp |= BIT(iwdg_inst + HW2_OTP_IWDG_FZ_STOP_POS);
+	if ((flags & IWDG_DISABLE_ON_STOP) != 0) {
+		otp_value |= BIT(iwdg_inst + HW2_OTP_IWDG_FZ_STOP_POS);
 	}
 
-	if ((flags & IWDG_DISABLE_ON_STANDBY) != 0U) {
-		otp |= BIT(iwdg_inst + HW2_OTP_IWDG_FZ_STANDBY_POS);
+	if ((flags & IWDG_DISABLE_ON_STANDBY) != 0) {
+		otp_value |= BIT(iwdg_inst + HW2_OTP_IWDG_FZ_STANDBY_POS);
 	}
 
-	result = bsec_write_otp(otp, HW2_OTP);
+	result = bsec_write_otp(otp_value, otp);
 	if (result != BSEC_OK) {
 		return result;
 	}
 
 	/* Sticky lock OTP_IWDG (read and write) */
-	if (!bsec_write_sr_lock(HW2_OTP, 1U) ||
-	    !bsec_write_sw_lock(HW2_OTP, 1U)) {
+	if ((bsec_set_sr_lock(otp) != BSEC_OK) ||
+	    (bsec_set_sw_lock(otp) != BSEC_OK)) {
 		return BSEC_LOCK_FAIL;
 	}
 
@@ -452,25 +739,202 @@ uint32_t stm32_iwdg_shadow_update(uint32_t iwdg_inst, uint32_t flags)
 }
 #endif
 
-#if STM32MP_USE_STM32IMAGE
-/* Get the non-secure DDR size */
-uint32_t stm32mp_get_ddr_ns_size(void)
+#if defined(IMAGE_BL32)
+/*
+ * This function allows to split bindings between platform and ETZPC
+ * HW mapping. If this conversion was done at driver level, the driver
+ * should include all supported platform bindings. ETZPC may be used on
+ * other platforms.
+ */
+enum etzpc_decprot_attributes stm32mp_etzpc_binding2decprot(uint32_t mode)
 {
-	static uint32_t ddr_ns_size;
-	uint32_t ddr_size;
+	switch (mode) {
+	case DECPROT_S_RW:
+		return ETZPC_DECPROT_S_RW;
+	case DECPROT_NS_R_S_W:
+		return ETZPC_DECPROT_NS_R_S_W;
+	case DECPROT_MCU_ISOLATION:
+		return ETZPC_DECPROT_MCU_ISOLATION;
+	case DECPROT_NS_RW:
+		return ETZPC_DECPROT_NS_RW;
+	default:
+		panic();
+	}
+}
+#endif
+
+bool stm32mp1_addr_inside_backupsram(uintptr_t addr)
+{
+	return (addr >= STM32MP_BACKUP_RAM_BASE) &&
+		(addr < (STM32MP_BACKUP_RAM_BASE + STM32MP_BACKUP_RAM_SIZE));
+}
 
-	if (ddr_ns_size != 0U) {
-		return ddr_ns_size;
+bool stm32mp1_is_wakeup_from_standby(void)
+{
+	uint32_t rstsr = mmio_read_32(stm32mp_rcc_base() + RCC_MP_RSTSCLRR);
+#if STM32MP15
+	uintptr_t bkpr_core1_addr = tamp_bkpr(BOOT_API_CORE1_BRANCH_ADDRESS_TAMP_BCK_REG_IDX);
+	uint32_t nsec_address;
+#endif
+
+	if ((rstsr & RCC_MP_RSTSCLRR_PADRSTF) != 0U) {
+		return false;
 	}
 
-	ddr_size = dt_get_ddr_size();
-	if ((ddr_size <= (STM32MP_DDR_S_SIZE + STM32MP_DDR_SHMEM_SIZE)) ||
-	    (ddr_size > STM32MP_DDR_MAX_SIZE)) {
-		panic();
+	if (stm32mp_get_boot_action() != BOOT_API_CTX_BOOT_ACTION_WAKEUP_STANDBY) {
+		return false;
+	}
+
+#if STM32MP15
+	clk_enable(RTCAPB);
+	nsec_address = mmio_read_32(bkpr_core1_addr);
+	clk_disable(RTCAPB);
+
+	if (nsec_address == 0U) {
+		return false;
 	}
+#endif
+
+	return stm32_pm_context_is_valid();
+}
 
-	ddr_ns_size = ddr_size - (STM32MP_DDR_S_SIZE + STM32MP_DDR_SHMEM_SIZE);
+bool stm32mp_skip_boot_device_after_standby(void)
+{
+	static int skip = -1;
+
+	if (skip == -1) {
+		if (stm32mp1_is_wakeup_from_standby()) {
+			skip = 1;
+#if STM32MP15
+			if (stm32_pm_get_optee_ep() == 0U) {
+				skip = 0;
+			}
+#endif
+		} else {
+			skip = 0;
+		}
+	}
+
+	return skip == 1;
+}
+
+void stm32_save_boot_interface(uint32_t interface, uint32_t instance)
+{
+	uintptr_t bkpr = tamp_bkpr(TAMP_BOOT_ITF_BACKUP_REG_ID);
+
+	stm32_save_boot_itf(interface, instance, RTCAPB, bkpr);
+}
+
+void stm32_get_boot_interface(uint32_t *interface, uint32_t *instance)
+{
+	uintptr_t bkpr = tamp_bkpr(TAMP_BOOT_ITF_BACKUP_REG_ID);
+
+	stm32_get_boot_itf(interface, instance, RTCAPB, bkpr);
+}
+
+bool stm32_boot_is_serial(void)
+{
+	uint32_t boot_itf;
+	uint32_t boot_instance;
+
+	stm32_get_boot_interface(&boot_itf, &boot_instance);
+
+	if ((boot_itf == BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART) ||
+	    (boot_itf == BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB)) {
+		return true;
+	}
+
+	return false;
+}
+
+#if defined(IMAGE_BL32) && DEBUG
+static const char *const dump_table[] = {
+	"sp_usr  ",
+	"lr_usr  ",
+	"spsr_irq",
+	"sp_irq  ",
+	"lr_irq  ",
+	"spsr_fiq",
+	"sp_fiq  ",
+	"lr_fiq  ",
+	"spsr_svc",
+	"sp_svc  ",
+	"lr_svc  ",
+	"spsr_abt",
+	"sp_abt  ",
+	"lr_abt  ",
+	"spsr_und",
+	"sp_und  ",
+	"lr_und  ",
+	"spsr_mon",
+	"sp_mon",
+	"lr_mon",
+	"scr",
+	"pmcr",
+};
+
+/*
+ * Dump CPU registers when entering in monitor.
+ */
+void stm32mp_dump_core_registers(bool fcore)
+{
+	static bool firstcore;
+	unsigned int i;
+	smc_ctx_t *ctx = smc_get_ctx(NON_SECURE);
+	uint32_t *reg = (uint32_t *)&ctx->sp_usr;
+
+	if (fcore) {
+		firstcore = true;
+	}
+
+	if (!firstcore) {
+		return;
+	}
+
+	INFO("CPU : %i\n", plat_my_core_pos());
+
+	for (i = 0U; i < ARRAY_SIZE(dump_table); i++) {
+		INFO("%s : 0x%x\n", dump_table[i], reg[i]);
+	}
+}
+#endif
+
+#if PSA_FWU_SUPPORT
+void stm32mp1_fwu_set_boot_idx(void)
+{
+	clk_enable(RTCAPB);
+	mmio_clrsetbits_32(tamp_bkpr(TAMP_BOOT_FWU_INFO_REG_ID),
+			   TAMP_BOOT_FWU_INFO_IDX_MSK,
+			   (plat_fwu_get_boot_idx() << TAMP_BOOT_FWU_INFO_IDX_OFF) &
+			   TAMP_BOOT_FWU_INFO_IDX_MSK);
+	clk_disable(RTCAPB);
+}
+
+uint32_t stm32_get_and_dec_fwu_trial_boot_cnt(void)
+{
+	uintptr_t bkpr_fwu_cnt = tamp_bkpr(TAMP_BOOT_FWU_INFO_REG_ID);
+	uint32_t try_cnt;
+
+	clk_enable(RTCAPB);
+	try_cnt = (mmio_read_32(bkpr_fwu_cnt) & TAMP_BOOT_FWU_INFO_CNT_MSK) >>
+		TAMP_BOOT_FWU_INFO_CNT_OFF;
+	if (try_cnt != 0U) {
+		mmio_clrsetbits_32(bkpr_fwu_cnt, TAMP_BOOT_FWU_INFO_CNT_MSK,
+				   (try_cnt - 1U) << TAMP_BOOT_FWU_INFO_CNT_OFF);
+	}
+	clk_disable(RTCAPB);
+
+	return try_cnt;
+}
+
+void stm32_set_max_fwu_trial_boot_cnt(void)
+{
+	uintptr_t bkpr_fwu_cnt = tamp_bkpr(TAMP_BOOT_FWU_INFO_REG_ID);
 
-	return ddr_ns_size;
+	clk_enable(RTCAPB);
+	mmio_clrsetbits_32(bkpr_fwu_cnt, TAMP_BOOT_FWU_INFO_CNT_MSK,
+			   (FWU_MAX_TRIAL_REBOOT << TAMP_BOOT_FWU_INFO_CNT_OFF) &
+			   TAMP_BOOT_FWU_INFO_CNT_MSK);
+	clk_disable(RTCAPB);
 }
-#endif /* STM32MP_USE_STM32IMAGE */
+#endif /* PSA_FWU_SUPPORT */
diff --git a/plat/st/stm32mp1/stm32mp1_scmi.c b/plat/st/stm32mp1/stm32mp1_scmi.c
index 6d60bd4de..b11c2dddb 100644
--- a/plat/st/stm32mp1/stm32mp1_scmi.c
+++ b/plat/st/stm32mp1/stm32mp1_scmi.c
@@ -8,12 +8,14 @@
 
 #include <platform_def.h>
 
+#include <drivers/clk.h>
 #include <drivers/scmi-msg.h>
 #include <drivers/scmi.h>
 #include <drivers/st/stm32mp1_clk.h>
 #include <drivers/st/stm32mp_reset.h>
 #include <dt-bindings/clock/stm32mp1-clks.h>
 #include <dt-bindings/reset/stm32mp1-resets.h>
+#include <lib/utils.h>
 
 #define TIMEOUT_US_1MS		1000U
 
@@ -124,6 +126,7 @@ static struct stm32_scmi_rstd stm32_scmi0_reset_domain[] = {
 	RESET_CELL(RST_SCMI0_RNG1, RNG1_R, "rng1"),
 	RESET_CELL(RST_SCMI0_MDMA, MDMA_R, "mdma"),
 	RESET_CELL(RST_SCMI0_MCU, MCU_R, "mcu"),
+	RESET_CELL(RST_SCMI0_MCU_HOLD_BOOT, MCU_HOLD_BOOT_R, "mcu_hold_boot"),
 };
 
 struct scmi_agent_resources {
@@ -260,6 +263,17 @@ const char *plat_scmi_clock_get_name(unsigned int agent_id,
 
 int32_t plat_scmi_clock_rates_array(unsigned int agent_id, unsigned int scmi_id,
 				    unsigned long *array, size_t *nb_elts)
+{
+	/*
+	 * Do not expose clock rates by array since not supported by
+	 * Linux kernel
+	 */
+	return SCMI_NOT_SUPPORTED;
+}
+
+int32_t plat_scmi_clock_rates_by_step(unsigned int agent_id,
+				      unsigned int scmi_id,
+				      unsigned long *array)
 {
 	struct stm32_scmi_clk *clock = find_clock(agent_id, scmi_id);
 
@@ -271,12 +285,50 @@ int32_t plat_scmi_clock_rates_array(unsigned int agent_id, unsigned int scmi_id,
 		return SCMI_DENIED;
 	}
 
-	if (array == NULL) {
-		*nb_elts = 1U;
-	} else if (*nb_elts == 1U) {
-		*array = stm32mp_clk_get_rate(clock->clock_id);
-	} else {
-		return SCMI_GENERIC_ERROR;
+	switch (scmi_id) {
+	case CK_SCMI0_MPU:
+		/*
+		 * Pretend we support all rates for MPU clock,
+		 * CLOCK_RATE_SET will reject unsupported rates.
+		 */
+		array[0] = 0U;
+		array[1] = UINT32_MAX;
+		array[2] = 1U;
+		break;
+	default:
+		array[0] = clk_get_rate(clock->clock_id);
+		array[1] = array[0];
+		array[2] = 0U;
+		break;
+	}
+	return SCMI_SUCCESS;
+}
+
+int32_t plat_scmi_clock_set_rate(unsigned int agent_id,
+				 unsigned int scmi_id,
+				 unsigned long rate)
+{
+	struct stm32_scmi_clk *clock = find_clock(agent_id, scmi_id);
+
+	if (clock == NULL) {
+		return SCMI_NOT_FOUND;
+	}
+
+	if (!stm32mp_nsec_can_access_clock(clock->clock_id)) {
+		return SCMI_DENIED;
+	}
+
+	switch (scmi_id) {
+	case CK_SCMI0_MPU:
+		if (stm32mp1_set_opp_khz(rate / 1000UL) != 0) {
+			return SCMI_INVALID_PARAMETERS;
+		}
+		break;
+	default:
+		if (rate != clk_get_rate(clock->clock_id)) {
+			return SCMI_INVALID_PARAMETERS;
+		}
+		break;
 	}
 
 	return SCMI_SUCCESS;
@@ -292,7 +344,7 @@ unsigned long plat_scmi_clock_get_rate(unsigned int agent_id,
 		return 0U;
 	}
 
-	return stm32mp_clk_get_rate(clock->clock_id);
+	return clk_get_rate(clock->clock_id);
 }
 
 int32_t plat_scmi_clock_get_state(unsigned int agent_id, unsigned int scmi_id)
@@ -323,13 +375,13 @@ int32_t plat_scmi_clock_set_state(unsigned int agent_id, unsigned int scmi_id,
 	if (enable_not_disable) {
 		if (!clock->enabled) {
 			VERBOSE("SCMI clock %u enable\n", scmi_id);
-			stm32mp_clk_enable(clock->clock_id);
+			clk_enable(clock->clock_id);
 			clock->enabled = true;
 		}
 	} else {
 		if (clock->enabled) {
 			VERBOSE("SCMI clock %u disable\n", scmi_id);
-			stm32mp_clk_disable(clock->clock_id);
+			clk_disable(clock->clock_id);
 			clock->enabled = false;
 		}
 	}
@@ -388,6 +440,10 @@ int32_t plat_scmi_rstd_autonomous(unsigned int agent_id, unsigned int scmi_id,
 		return SCMI_NOT_FOUND;
 	}
 
+	if (rstd->reset_id == MCU_HOLD_BOOT_R) {
+		return SCMI_NOT_SUPPORTED;
+	}
+
 	if (!stm32mp_nsec_can_access_reset(rstd->reset_id)) {
 		return SCMI_DENIED;
 	}
@@ -423,6 +479,13 @@ int32_t plat_scmi_rstd_set_state(unsigned int agent_id, unsigned int scmi_id,
 		return SCMI_DENIED;
 	}
 
+	if (rstd->reset_id == MCU_HOLD_BOOT_R) {
+		VERBOSE("SCMI MCU reset %s\n",
+			assert_not_deassert ? "set" : "release");
+		stm32mp_reset_assert_deassert_to_mcu(assert_not_deassert);
+		return SCMI_SUCCESS;
+	}
+
 	if (assert_not_deassert) {
 		VERBOSE("SCMI reset %lu set\n", rstd->reset_id);
 		stm32mp_reset_set(rstd->reset_id);
@@ -461,7 +524,7 @@ void stm32mp1_init_scmi_server(void)
 			/* Sync SCMI clocks with their targeted initial state */
 			if (clk->enabled &&
 			    stm32mp_nsec_can_access_clock(clk->clock_id)) {
-				stm32mp_clk_enable(clk->clock_id);
+				clk_enable(clk->clock_id);
 			}
 		}
 
@@ -476,3 +539,51 @@ void stm32mp1_init_scmi_server(void)
 		}
 	}
 }
+
+/*
+ * Save and restore SCMI state since lost during suspend.
+ * Only clock enabled field needs to be updated.
+ */
+void stm32mp1_pm_save_scmi_state(uint8_t *state, size_t size)
+{
+	size_t i;
+	size_t j;
+	size_t cnt = 0U;
+
+	zeromem(state, size);
+
+	for (i = 0U; i < ARRAY_SIZE(agent_resources); i++) {
+		for (j = 0U; j < agent_resources[i].clock_count; j++) {
+			if ((cnt / 8) > size) {
+				VERBOSE("state table too small\n");
+				panic();
+			}
+
+			if (agent_resources[i].clock[j].enabled) {
+				*(state + (cnt / 8)) |= (uint8_t)BIT(cnt % 8);
+			}
+
+			cnt++;
+		}
+	}
+}
+
+void stm32mp1_pm_restore_scmi_state(uint8_t *state, size_t size)
+{
+	size_t i;
+	size_t j;
+	size_t cnt = 0U;
+
+	for (i = 0U; i < ARRAY_SIZE(agent_resources); i++) {
+		for (j = 0U; j < agent_resources[i].clock_count; j++) {
+			if ((*(state + (cnt / 8)) & BIT(cnt % 8)) == 0U) {
+				agent_resources[i].clock[j].enabled = 0;
+			} else {
+				agent_resources[i].clock[j].enabled = 1;
+			}
+
+			assert((cnt / 8) <= size);
+			cnt++;
+		}
+	}
+}
diff --git a/plat/st/stm32mp1/stm32mp1_security.c b/plat/st/stm32mp1/stm32mp1_security.c
deleted file mode 100644
index 19ef4f0ae..000000000
--- a/plat/st/stm32mp1/stm32mp1_security.c
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Copyright (c) 2015-2021, ARM Limited and Contributors. All rights reserved.
- *
- * SPDX-License-Identifier: BSD-3-Clause
- */
-
-#include <stdint.h>
-
-#include <platform_def.h>
-
-#include <common/debug.h>
-#include <drivers/arm/tzc400.h>
-#include <drivers/st/stm32mp1_clk.h>
-#include <dt-bindings/clock/stm32mp1-clks.h>
-#include <dt-bindings/soc/stm32mp15-tzc400.h>
-#include <lib/mmio.h>
-
-static unsigned int region_nb;
-
-static void init_tzc400_begin(unsigned int region0_attr)
-{
-	tzc400_init(STM32MP1_TZC_BASE);
-	tzc400_disable_filters();
-
-	/* Region 0 set to cover all DRAM at 0xC000_0000 */
-	tzc400_configure_region0(region0_attr, 0);
-
-	region_nb = 1U;
-}
-
-static void init_tzc400_end(unsigned int action)
-{
-	tzc400_set_action(action);
-	tzc400_enable_filters();
-}
-
-static void tzc400_add_region(unsigned long long region_base,
-			      unsigned long long region_top, bool sec)
-{
-	unsigned int sec_attr;
-	unsigned int nsaid_permissions;
-
-	if (sec) {
-		sec_attr = TZC_REGION_S_RDWR;
-		nsaid_permissions = 0;
-	} else {
-		sec_attr = TZC_REGION_S_NONE;
-		nsaid_permissions = TZC_REGION_NSEC_ALL_ACCESS_RDWR;
-	}
-
-	tzc400_configure_region(STM32MP1_FILTER_BIT_ALL, region_nb, region_base,
-				region_top, sec_attr, nsaid_permissions);
-
-	region_nb++;
-}
-
-/*******************************************************************************
- * Initialize the TrustZone Controller. Configure Region 0 with Secure RW access
- * and allow Non-Secure masters full access.
- ******************************************************************************/
-static void init_tzc400(void)
-{
-	unsigned long long region_base, region_top;
-	unsigned long long ddr_base = STM32MP_DDR_BASE;
-	unsigned long long ddr_ns_size =
-		(unsigned long long)stm32mp_get_ddr_ns_size();
-	unsigned long long ddr_ns_top = ddr_base + (ddr_ns_size - 1U);
-	unsigned long long ddr_top __unused;
-
-	init_tzc400_begin(TZC_REGION_S_NONE);
-
-	/*
-	 * Region 1 set to cover all non-secure DRAM at 0xC000_0000. Apply the
-	 * same configuration to all filters in the TZC.
-	 */
-	region_base = ddr_base;
-	region_top = ddr_ns_top;
-	tzc400_add_region(region_base, region_top, false);
-
-#ifdef AARCH32_SP_OPTEE
-	/* Region 2 set to cover all secure DRAM. */
-	region_base = region_top + 1U;
-	region_top += STM32MP_DDR_S_SIZE;
-	tzc400_add_region(region_base, region_top, true);
-
-	ddr_top = STM32MP_DDR_BASE + dt_get_ddr_size() - 1U;
-	if (region_top < ddr_top) {
-		/* Region 3 set to cover non-secure memory DRAM after BL32. */
-		region_base = region_top + 1U;
-		region_top = ddr_top;
-		tzc400_add_region(region_base, region_top, false);
-	}
-#endif
-
-	/*
-	 * Raise an interrupt (secure FIQ) if a NS device tries to access
-	 * secure memory
-	 */
-	init_tzc400_end(TZC_ACTION_INT);
-}
-
-/*******************************************************************************
- * Initialize the TrustZone Controller.
- * Early initialization create only one region with full access to secure.
- * This setting is used before and during DDR initialization.
- ******************************************************************************/
-static void early_init_tzc400(void)
-{
-	stm32mp_clk_enable(TZC1);
-	stm32mp_clk_enable(TZC2);
-
-	/* Region 0 set to cover all DRAM secure at 0xC000_0000 */
-	init_tzc400_begin(TZC_REGION_S_RDWR);
-
-	/* Raise an exception if a NS device tries to access secure memory */
-	init_tzc400_end(TZC_ACTION_ERR);
-}
-
-/*******************************************************************************
- * Initialize the secure environment. At this moment only the TrustZone
- * Controller is initialized.
- ******************************************************************************/
-void stm32mp1_arch_security_setup(void)
-{
-	early_init_tzc400();
-}
-
-/*******************************************************************************
- * Initialize the secure environment. At this moment only the TrustZone
- * Controller is initialized.
- ******************************************************************************/
-void stm32mp1_security_setup(void)
-{
-	init_tzc400();
-}
diff --git a/plat/st/stm32mp1/stm32mp1_shared_resources.c b/plat/st/stm32mp1/stm32mp1_shared_resources.c
index 6b1bcaa13..12cfb354e 100644
--- a/plat/st/stm32mp1/stm32mp1_shared_resources.c
+++ b/plat/st/stm32mp1/stm32mp1_shared_resources.c
@@ -87,6 +87,64 @@ static const char __unused *shres2str_state(unsigned int state)
 	return shres2str_state_tbl[state];
 }
 
+struct shres2decprot {
+	unsigned int shres_id;
+	unsigned int decprot_id;
+	const char *decprot_str;
+};
+
+#define SHRES2DECPROT(shres, decprot, str) {	\
+		.shres_id = shres,		\
+		.decprot_id = decprot,		\
+		.decprot_str = str,		\
+	}
+
+#define SHRES_INVALID		~0U
+
+static const struct shres2decprot shres2decprot_tbl[] = {
+	SHRES2DECPROT(STM32MP1_SHRES_IWDG1, STM32MP1_ETZPC_IWDG1_ID, "IWDG1"),
+	SHRES2DECPROT(STM32MP1_SHRES_USART1, STM32MP1_ETZPC_USART1_ID, "UART1"),
+	SHRES2DECPROT(STM32MP1_SHRES_SPI6, STM32MP1_ETZPC_SPI6_ID, "SPI6"),
+	SHRES2DECPROT(STM32MP1_SHRES_I2C4, STM32MP1_ETZPC_I2C4_ID, "I2C4"),
+	SHRES2DECPROT(STM32MP1_SHRES_RNG1, STM32MP1_ETZPC_RNG1_ID, "RNG1"),
+	SHRES2DECPROT(STM32MP1_SHRES_HASH1, STM32MP1_ETZPC_HASH1_ID, "HASH1"),
+	SHRES2DECPROT(STM32MP1_SHRES_CRYP1, STM32MP1_ETZPC_CRYP1_ID, "CRYP1"),
+	SHRES2DECPROT(STM32MP1_SHRES_I2C6, STM32MP1_ETZPC_I2C6_ID, "I2C6"),
+	/* Below are specific IDs without a 1-to-1 mapping to SHRES IDs */
+	SHRES2DECPROT(SHRES_INVALID, STM32MP1_ETZPC_STGENC_ID, "STGEN"),
+	SHRES2DECPROT(SHRES_INVALID, STM32MP1_ETZPC_BKPSRAM_ID, "BKPSRAM"),
+	SHRES2DECPROT(SHRES_INVALID, STM32MP1_ETZPC_DDRCTRL_ID, "DDRCTRL"),
+	SHRES2DECPROT(SHRES_INVALID, STM32MP1_ETZPC_DDRPHYC_ID, "DDRPHY"),
+};
+
+static unsigned int decprot2shres(unsigned int decprot_id)
+{
+	uint32_t i;
+
+	for (i = 0; i < ARRAY_SIZE(shres2decprot_tbl); i++) {
+		if (shres2decprot_tbl[i].decprot_id == decprot_id) {
+			return shres2decprot_tbl[i].shres_id;
+		}
+	}
+
+	VERBOSE("No shared resource %u", decprot_id);
+	return SHRES_INVALID;
+}
+
+static const char *decprot2str(unsigned int decprot_id)
+{
+	size_t i;
+
+	for (i = 0; i < ARRAY_SIZE(shres2decprot_tbl); i++) {
+		if (shres2decprot_tbl[i].decprot_id == decprot_id) {
+			return shres2decprot_tbl[i].decprot_str;
+		}
+	}
+
+	ERROR("Invalid ID %u", decprot_id);
+	panic();
+}
+
 /* Get resource state: these accesses lock the registering support */
 static void lock_registering(void)
 {
@@ -334,6 +392,53 @@ void stm32mp_register_non_secure_gpio(unsigned int bank, unsigned int pin)
 	}
 }
 
+void stm32mp1_register_etzpc_decprot(unsigned int id,
+				     enum etzpc_decprot_attributes attr)
+{
+	unsigned int state = SHRES_SECURE;
+	unsigned int id_shres;
+
+	switch (attr) {
+	case ETZPC_DECPROT_S_RW:
+		break;
+	case ETZPC_DECPROT_NS_R_S_W:
+	case ETZPC_DECPROT_MCU_ISOLATION:
+	case ETZPC_DECPROT_NS_RW:
+		state = SHRES_NON_SECURE;
+		break;
+	default:
+		panic();
+	}
+
+	switch (id) {
+	case STM32MP1_ETZPC_STGENC_ID:
+	case STM32MP1_ETZPC_BKPSRAM_ID:
+		/* We assume these must always be assigned to secure world */
+		if (state != SHRES_SECURE) {
+			panic();
+		}
+		break;
+	case STM32MP1_ETZPC_DDRCTRL_ID:
+	case STM32MP1_ETZPC_DDRPHYC_ID:
+		/* allow write only for secure world */
+		if ((attr != ETZPC_DECPROT_S_RW) &&
+		    (attr != ETZPC_DECPROT_NS_R_S_W)) {
+			panic();
+		}
+		break;
+	default:
+		id_shres = decprot2shres(id);
+		if (id_shres == SHRES_INVALID) {
+			if (state == SHRES_SECURE) {
+				panic();
+			}
+		} else {
+			register_periph(id_shres, state);
+		}
+		break;
+	}
+}
+
 static bool stm32mp_gpio_bank_is_non_secure(unsigned int bank)
 {
 	unsigned int non_secure = 0U;
@@ -379,12 +484,15 @@ bool stm32mp_nsec_can_access_clock(unsigned long clock_id)
 	enum stm32mp_shres shres_id = STM32MP1_SHRES_COUNT;
 
 	switch (clock_id) {
+	case BSEC:
+	case CK_AXI:
 	case CK_CSI:
 	case CK_HSE:
 	case CK_HSE_DIV2:
 	case CK_HSI:
 	case CK_LSE:
 	case CK_LSI:
+	case CK_MPU:
 	case PLL1_P:
 	case PLL1_Q:
 	case PLL1_R:
@@ -454,6 +562,7 @@ bool stm32mp_nsec_can_access_reset(unsigned int reset_id)
 		shres_id = STM32MP1_SHRES_I2C6;
 		break;
 	case MCU_R:
+	case MCU_HOLD_BOOT_R:
 		shres_id = STM32MP1_SHRES_MCU;
 		break;
 	case MDMA_R:
@@ -499,33 +608,81 @@ static enum etzpc_decprot_attributes shres2decprot_attr(enum stm32mp_shres id)
 	return ETZPC_DECPROT_S_RW;
 }
 
-static void set_etzpc_secure_configuration(void)
+static bool check_decprot(unsigned int id, enum etzpc_decprot_attributes exp)
 {
-	/* Some system peripherals shall be secure */
-	etzpc_configure_decprot(STM32MP1_ETZPC_STGENC_ID, ETZPC_DECPROT_S_RW);
-	etzpc_configure_decprot(STM32MP1_ETZPC_BKPSRAM_ID, ETZPC_DECPROT_S_RW);
-	etzpc_configure_decprot(STM32MP1_ETZPC_DDRCTRL_ID,
-				ETZPC_DECPROT_NS_R_S_W);
-	etzpc_configure_decprot(STM32MP1_ETZPC_DDRPHYC_ID,
-				ETZPC_DECPROT_NS_R_S_W);
-
-	/* Configure ETZPC with peripheral registering */
-	etzpc_configure_decprot(STM32MP1_ETZPC_CRYP1_ID,
-				shres2decprot_attr(STM32MP1_SHRES_CRYP1));
-	etzpc_configure_decprot(STM32MP1_ETZPC_HASH1_ID,
-				shres2decprot_attr(STM32MP1_SHRES_HASH1));
-	etzpc_configure_decprot(STM32MP1_ETZPC_I2C4_ID,
-				shres2decprot_attr(STM32MP1_SHRES_I2C4));
-	etzpc_configure_decprot(STM32MP1_ETZPC_I2C6_ID,
-				shres2decprot_attr(STM32MP1_SHRES_I2C6));
-	etzpc_configure_decprot(STM32MP1_ETZPC_IWDG1_ID,
-				shres2decprot_attr(STM32MP1_SHRES_IWDG1));
-	etzpc_configure_decprot(STM32MP1_ETZPC_RNG1_ID,
-				shres2decprot_attr(STM32MP1_SHRES_RNG1));
-	etzpc_configure_decprot(STM32MP1_ETZPC_USART1_ID,
+	enum etzpc_decprot_attributes cur = etzpc_get_decprot(id);
+
+	if (cur == exp) {
+		return true;
+	}
+
+	switch (exp) {
+	case ETZPC_DECPROT_NS_RW:
+		if (cur == ETZPC_DECPROT_S_RW) {
+			INFO("ETZPC: %s (%d) could be non secure\n",
+			     decprot2str(id), id);
+		}
+		return true;
+
+	case ETZPC_DECPROT_S_RW:
+		ERROR("ETZPC: %s (%d) expected secure but DECPROT = %d\n",
+		      decprot2str(id), id, cur);
+		break;
+
+	case ETZPC_DECPROT_NS_R_S_W:
+	case ETZPC_DECPROT_MCU_ISOLATION:
+		break;
+	default:
+		panic();
+	}
+
+	return false;
+}
+
+static void check_etzpc_secure_configuration(void)
+{
+	bool error = false;
+
+	assert(registering_locked);
+
+	error |= !check_decprot(STM32MP1_ETZPC_STGENC_ID, ETZPC_DECPROT_S_RW);
+
+	error |= !check_decprot(STM32MP1_ETZPC_BKPSRAM_ID, ETZPC_DECPROT_S_RW);
+
+	error |= !check_decprot(STM32MP1_ETZPC_USART1_ID,
 				shres2decprot_attr(STM32MP1_SHRES_USART1));
-	etzpc_configure_decprot(STM32MP1_ETZPC_SPI6_ID,
+
+	error |= !check_decprot(STM32MP1_ETZPC_I2C4_ID,
+				shres2decprot_attr(STM32MP1_SHRES_I2C4));
+
+	error |= !check_decprot(STM32MP1_ETZPC_SPI6_ID,
 				shres2decprot_attr(STM32MP1_SHRES_SPI6));
+
+	error |= !check_decprot(STM32MP1_ETZPC_RNG1_ID,
+				shres2decprot_attr(STM32MP1_SHRES_RNG1));
+
+	error |= !check_decprot(STM32MP1_ETZPC_HASH1_ID,
+				shres2decprot_attr(STM32MP1_SHRES_HASH1));
+
+	error |= !check_decprot(STM32MP1_ETZPC_CRYP1_ID,
+				shres2decprot_attr(STM32MP1_SHRES_CRYP1));
+
+	error |= !((check_decprot(STM32MP1_ETZPC_DDRCTRL_ID,
+				  ETZPC_DECPROT_NS_R_S_W)) ||
+		   (check_decprot(STM32MP1_ETZPC_DDRCTRL_ID,
+				  ETZPC_DECPROT_S_RW)));
+
+	error |= !((check_decprot(STM32MP1_ETZPC_DDRPHYC_ID,
+				  ETZPC_DECPROT_NS_R_S_W)) ||
+		   (check_decprot(STM32MP1_ETZPC_DDRPHYC_ID,
+				  ETZPC_DECPROT_S_RW)));
+
+	error |= !check_decprot(STM32MP1_ETZPC_I2C6_ID,
+				shres2decprot_attr(STM32MP1_SHRES_I2C6));
+
+	if (error) {
+		panic();
+	}
 }
 
 static void check_rcc_secure_configuration(void)
@@ -592,6 +749,6 @@ void stm32mp_lock_periph_registering(void)
 	print_shared_resources_state();
 
 	check_rcc_secure_configuration();
-	set_etzpc_secure_configuration();
+	check_etzpc_secure_configuration();
 	set_gpio_secure_configuration();
 }
diff --git a/plat/st/stm32mp1/stm32mp1_ssp.c b/plat/st/stm32mp1/stm32mp1_ssp.c
new file mode 100644
index 000000000..ed1fd8ec0
--- /dev/null
+++ b/plat/st/stm32mp1/stm32mp1_ssp.c
@@ -0,0 +1,1050 @@
+/*
+ * Copyright (c) 2017-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <endian.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <platform_def.h>
+
+#include <arch_helpers.h>
+#include <drivers/clk.h>
+#include <drivers/generic_delay_timer.h>
+#include <drivers/regulator.h>
+#include <drivers/st/bsec.h>
+#include <drivers/st/stm32_hash.h>
+#include <drivers/st/stm32_iwdg.h>
+#include <drivers/st/stm32_uart.h>
+#include <drivers/st/stm32mp_pmic.h>
+#include <drivers/st/stm32mp_reset.h>
+#include <drivers/st/stpmic1.h>
+#include <drivers/usb_device.h>
+#include <lib/mmio.h>
+#include <lib/utils.h>
+#include <lib/utils_def.h>
+#include <lib/xlat_tables/xlat_tables_v2.h>
+#include <plat/common/platform.h>
+
+#include <stm32cubeprogrammer.h>
+#include <usb_dfu.h>
+
+#define CERT_CHIP_ID_LEN		U(3)
+#define CERT_SECURITY_COUNTER_LEN	U(2)
+#define CERT_SECURITY_COUNTER_SHIFT	CERT_CHIP_ID_LEN
+#define CERT_RFU_LEN			U(1)
+#define CERT_RFU_SHIFT			(CERT_SECURITY_COUNTER_LEN + \
+					 CERT_SECURITY_COUNTER_SHIFT)
+#define CERT_PRODUCT_KEY_LEN		U(2)
+#define CERT_PRODUCT_KEY_SHIFT		(CERT_RFU_LEN + CERT_RFU_SHIFT)
+#define CERT_PRODUCT_ID_SIZE		(CERT_PRODUCT_KEY_LEN + \
+					 CERT_PRODUCT_KEY_SHIFT)
+#define CERT_SIGNATURE_LEN		CHIP_CERTIFICATE_MAX_SIZE
+#define CERT_SIGNATURE_SHIFT		(CERT_PRODUCT_ID_SIZE + \
+					 BOOT_API_SSP_PUBK_KEY_SIZE_BYTES)
+#define CERTIFICATE_SIZE		(CERT_PRODUCT_ID_SIZE + \
+					 BOOT_API_SSP_PUBK_KEY_SIZE_BYTES + \
+					 CERT_SIGNATURE_LEN) /* 136 bytes */
+#define BLOB_FILE_MAX_ADDR		BL2_RW_LIMIT
+
+/* Local status for SSP processing sequences */
+typedef enum {
+	SSP_NONE,
+	SSP_GET_CERT,
+	SSP_FLASH_OEM,
+	SSP_DONE,
+	SSP_ERROR
+} ssp_result_e;
+
+struct otp_val {
+	uint32_t idx;
+	uint32_t nb;
+};
+
+static struct otp_val otp_ssp;
+static struct otp_val otp_rma;
+static struct otp_val otp_pubkey;
+
+/* Platform empty definition required */
+void bl2_platform_setup(void) {}
+struct bl_params *plat_get_next_bl_params(void) { return NULL; }
+void plat_flush_next_bl_params(void) {}
+struct bl_load_info *plat_get_bl_image_load_info(void) { return NULL; }
+int plat_get_image_source(unsigned int image_id, uintptr_t *dev_handle,
+			  uintptr_t *image_spec)
+{
+	return 0;
+}
+
+/*
+ * Initialized OTP index from device tree.
+ */
+static int initialize_otp(void)
+{
+	uint32_t len;
+
+	/* OTP SSP */
+	if (stm32_get_otp_index(SSP_OTP, &otp_ssp.idx, NULL) != 0) {
+		VERBOSE("%s: get index error\n", __func__);
+		return -EINVAL;
+	}
+
+	/* OTP public key */
+	if (stm32_get_otp_index(PKH_OTP, &otp_pubkey.idx, &len) != 0) {
+		VERBOSE("%s: get index error\n", __func__);
+		return -EINVAL;
+	}
+
+	if (len != (CHAR_BIT * BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES)) {
+		VERBOSE("%s: length Error\n", __func__);
+		return -EINVAL;
+	}
+
+	otp_pubkey.nb = len / __WORD_BIT;
+
+	/* OTP RMA */
+	if (stm32_get_otp_index(RMA_OTP, &otp_rma.idx, NULL) != 0) {
+		VERBOSE("%s: get index error\n", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * Compute HASH from public key and burn it in OTP.
+ */
+static int ssp_pub_key_prog(boot_api_context_t *boot_context)
+{
+#if STM32MP13
+	uint32_t *value = (uint32_t *)
+		boot_context->p_ssp_config->p_blob_payload->oem_rpkth;
+#endif
+#if STM32MP15
+	uint8_t key_hash[BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES] __aligned(4);
+	uint8_t *pubk = (uint8_t *)
+		boot_context->p_ssp_config->p_blob_payload->oem_ecdsa_pubk;
+	uint32_t *value = (uint32_t *)key_hash;
+#endif
+	uint32_t i;
+
+#if STM32MP15
+	if (stm32_hash_register() != 0) {
+		return -EINVAL;
+	}
+
+	stm32_hash_init(HASH_SHA256);
+
+	if (stm32_hash_final_update(pubk, BOOT_API_SSP_PUBK_KEY_SIZE_BYTES,
+				    key_hash) != 0) {
+		ERROR("Hash of payload failed\n");
+		return -EINVAL;
+	}
+#endif
+
+	for (i = otp_pubkey.idx; i < (otp_pubkey.idx + otp_pubkey.nb); i++) {
+		if (bsec_program_otp(bswap32(*value), i) != BSEC_OK) {
+			return -EINVAL;
+		}
+
+		value++;
+		if (bsec_permanent_lock_otp(i) != BSEC_OK) {
+			ERROR("Error locking OTP %i\n", i);
+			panic();
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Burn OTP to close device.
+ */
+static int ssp_close_device(void)
+{
+	uint32_t otp;
+	uint32_t value;
+
+	if (stm32_get_otp_index(CFG0_OTP, &otp, NULL) != 0) {
+		return -EINVAL;
+	}
+
+	if (bsec_read_otp(&value, otp) != BSEC_OK) {
+		return -EINVAL;
+	}
+
+#if STM32MP13
+	if ((value & ~CFG0_OPEN_DEVICE) != 0U) {
+		ERROR("Device already closed\n");
+		return -EINVAL;
+	}
+#endif
+#if STM32MP15
+	if ((value & CFG0_CLOSED_DEVICE) != 0U) {
+		ERROR("Device already closed\n");
+		return -EINVAL;
+	}
+#endif
+
+	value |= CFG0_CLOSED_DEVICE;
+	if (bsec_program_otp(value, otp) != BSEC_OK) {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * OTP initial check to detect previous values.
+ */
+static int ssp_secrets_check(boot_api_context_t *boot_ctx)
+{
+	uint32_t i;
+	uint32_t check_val;
+	uint32_t otp_bytes = boot_ctx->p_ssp_config->p_blob_payload->oem_secret_size_bytes;
+	uint32_t otp_decrypted;
+	uint32_t *val;
+
+	if (otp_bytes == 0U) {
+		return -EINVAL;
+	}
+
+	for (i = otp_pubkey.idx; i < (otp_pubkey.idx + otp_pubkey.nb); i++) {
+		if (stm32_get_otp_value_from_idx(i, &check_val) != 0) {
+			return -EINVAL;
+		}
+
+		if (check_val != 0U) {
+			ERROR("OTP %u value already programmed\n", i);
+			return -EINVAL;
+		}
+	}
+
+	otp_decrypted = round_up(otp_bytes, sizeof(uint32_t)) / sizeof(uint32_t);
+
+	/* OTP decrypted include RMA password */
+	if (otp_decrypted > (2U + SSP_OTP_SECRET_END - SSP_OTP_SECRET_BASE)) {
+		return -EINVAL;
+	}
+
+	/* Check RMA password */
+	if (stm32_get_otp_value_from_idx(otp_rma.idx, &check_val) != 0) {
+		return -EINVAL;
+	}
+
+	if (check_val != 0U) {
+		ERROR("OTP %s value already programmed\n", RMA_OTP);
+		return -EINVAL;
+	}
+
+	val = (uint32_t *)boot_ctx->p_ssp_config->p_ssp_oem_secrets_decrypted;
+
+	/* Check all OTP available */
+	for (i = SSP_OTP_SECRET_BASE; i < SSP_OTP_SECRET_BASE + otp_decrypted - 1U; i++) {
+		val++;
+
+		if (*val == 0U) {
+			continue;
+		}
+
+		if (stm32_get_otp_value_from_idx(i, &check_val) != 0) {
+			return -EINVAL;
+		}
+
+		if (check_val != 0U) {
+			ERROR("OTP %u value already programmed\n", i);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Burn OTP with the decrypted secret received.
+ */
+static int ssp_secrets_flash(boot_api_context_t *boot_ctx)
+{
+	uint32_t i;
+	uint32_t *val;
+	uint32_t otp_val;
+	uint32_t otp_bytes =
+		boot_ctx->p_ssp_config->p_blob_payload->oem_secret_size_bytes;
+	uint32_t otp_decrypted;
+	uint32_t otp_mask = 0U;
+
+	if (otp_bytes == 0U) {
+		return -EINVAL;
+	}
+
+	if (otp_bytes % sizeof(uint32_t) != 0U) {
+		otp_mask = GENMASK_32(((otp_bytes % sizeof(uint32_t)) *
+				       sizeof(uint32_t)) - 1, 0);
+	}
+
+	val = (uint32_t *)boot_ctx->p_ssp_config->p_ssp_oem_secrets_decrypted;
+
+	otp_decrypted = round_up(otp_bytes, sizeof(uint32_t)) / sizeof(uint32_t);
+
+	/* Burn RMA password */
+	if (bsec_program_otp((*val & RMA_OTP_MASK), otp_rma.idx) !=  BSEC_OK) {
+		WARN("RMA programing failed\n");
+		return -EINVAL;
+	}
+
+	if (bsec_shadow_read_otp(&otp_val, otp_rma.idx) != BSEC_OK) {
+		return -EINVAL;
+	}
+
+	if ((otp_val & RMA_OTP_MASK) != (*val & RMA_OTP_MASK)) {
+		WARN("RMA programming failed\n");
+		return -EINVAL;
+	}
+
+	if (bsec_permanent_lock_otp(otp_rma.idx) != BSEC_OK) {
+		WARN("Error locking RMA OTP\n");
+		return -EINVAL;
+	}
+
+	val++;
+	otp_decrypted--;
+	for (i = SSP_OTP_SECRET_BASE; i < (SSP_OTP_SECRET_BASE + otp_decrypted - 1U); i++) {
+		if (*val == 0U) {
+			val++;
+			continue;
+		}
+
+		if (bsec_program_otp(*val, i) != BSEC_OK) {
+			WARN("Error writing OTP %i\n", i);
+			return -EINVAL;
+		}
+
+		if (bsec_permanent_lock_otp(i) != BSEC_OK) {
+			WARN("Error locking OTP %i\n", i);
+			return -EINVAL;
+		}
+
+		val++;
+	}
+
+	if (*val == 0U) {
+		return 0;
+	}
+
+	/* Mask the last OTP value if needed */
+	if (otp_mask != 0U) {
+		*val &= otp_mask;
+	}
+
+	if (bsec_program_otp(*val, i) != BSEC_OK) {
+		WARN("Error writing OTP %i\n", i);
+		return -EINVAL;
+	}
+
+	if (bsec_permanent_lock_otp(i) != BSEC_OK) {
+		WARN("Error locking OTP %i\n", i);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * Finish SSP processing by fusing OTP SSP success.
+ */
+static int ssp_finish_process(void)
+{
+	uint32_t val;
+
+	if (stm32_get_otp_value_from_idx(otp_ssp.idx, &val) != 0) {
+		return -EINVAL;
+	}
+
+	if ((val & SSP_OTP_SUCCESS) != 0U) {
+		WARN("Error while configuring OTP\n");
+		return -EINVAL;
+	}
+
+	val |= SSP_OTP_SUCCESS;
+	if (bsec_program_otp(val, otp_ssp.idx) != BSEC_OK) {
+		return -EINVAL;
+	}
+
+	VERBOSE("Write OTP Success\n");
+
+	return 0;
+}
+
+/*
+ * Transform integer to string.
+ */
+static void itoa(uint32_t num, char *str, int nb)
+{
+	if (num == 0U) {
+		while (nb-- != 0U) {
+			str[nb] = '0';
+		}
+
+		return;
+	}
+
+	while (num != 0U) {
+		int rem = num % 16;
+
+		str[--nb] = (rem > 9) ? (rem - 10) + 'A' : rem + '0';
+		num /= 16;
+	}
+
+	while (nb != 0) {
+		str[--nb] = '0';
+	}
+}
+
+/*
+ * Return chip product ID.
+ */
+static int ssp_get_product_id(char *msg)
+{
+	uint32_t otp;
+	uint32_t otp_idx;
+	uint32_t chip_id = stm32mp_get_chip_dev_id();
+
+	if (stm32_get_otp_index(CFG2_OTP, &otp_idx, NULL) != 0) {
+		VERBOSE("Get index error\n");
+		return -EINVAL;
+	}
+
+	if (stm32_get_otp_value_from_idx(otp_idx, &otp) != 0) {
+		return -EINVAL;
+	}
+
+	itoa(chip_id, msg, CERT_CHIP_ID_LEN);
+	itoa((otp & OTP_CFG2_SEC_COUNTER_MASK) >> OTP_CFG2_SEC_COUNTER_SHIFT,
+	     msg + CERT_SECURITY_COUNTER_SHIFT,
+	     CERT_SECURITY_COUNTER_LEN);
+
+	itoa(0, msg + CERT_RFU_SHIFT, CERT_RFU_LEN);
+	itoa((otp & OTP_CFG2_ST_KEY_MASK) >> OTP_CFG2_ST_KEY_SHIFT,
+	     msg + CERT_PRODUCT_KEY_SHIFT,
+	     CERT_PRODUCT_KEY_LEN);
+
+	return 0;
+}
+
+/*
+ * Construct SSP certificate.
+ */
+static int prepare_certificate(uint8_t *cert, const uint8_t *pubkey)
+{
+	uint32_t i;
+	uint32_t j;
+	uint32_t otp;
+	uint32_t otp_idx;
+	uint32_t otp_len;
+
+	/* Prepare the ROM Security constant */
+	if (ssp_get_product_id((char *)cert) != 0) {
+		return -EINVAL;
+	}
+
+	/* Prepare public key and certificate for flashloader */
+	/* Read Public Key from boot_context */
+	memcpy(cert + CERT_PRODUCT_ID_SIZE, pubkey, BOOT_API_SSP_PUBK_KEY_SIZE_BYTES);
+
+	if (stm32_get_otp_index(CHIP_CERTIFICATE_OTP,
+				&otp_idx, &otp_len) != 0) {
+		VERBOSE("Get index error\n");
+		return -EINVAL;
+	}
+
+	if (otp_len != (CHAR_BIT * CHIP_CERTIFICATE_MAX_SIZE)) {
+		VERBOSE("Length error\n");
+		return -EINVAL;
+	}
+
+	otp_len /= __WORD_BIT;
+
+	/* Read Certificat from OTP */
+	for (i = otp_idx, j = 0U; i < (otp_idx + otp_len); i++, j++) {
+		uint32_t otp_s;
+
+		if (stm32_get_otp_value_from_idx(i, &otp) != 0) {
+			return -EINVAL;
+		}
+
+		otp_s = bswap32(otp);
+		memcpy(&cert[CERT_SIGNATURE_SHIFT + (sizeof(uint32_t) * j)],
+		       &otp_s, sizeof(uint32_t));
+	}
+
+	return 0;
+}
+
+/*
+ * Clean OTP value that might be still in shadow registers
+ */
+static void cleanup_otp_value(void)
+{
+	unsigned int i;
+
+	/* RMA clear and lock */
+	if (bsec_write_otp(0U, otp_rma.idx) != BSEC_OK) {
+		return;
+	}
+
+	if (bsec_set_sr_lock(otp_rma.idx) != BSEC_OK) {
+		return;
+	}
+
+	for (i = SSP_OTP_SECRET_BASE; i < SSP_OTP_SECRET_END + 1U; i++) {
+		if (bsec_write_otp(0U, otp_rma.idx) != BSEC_OK) {
+			return;
+		}
+	}
+}
+
+/*
+ * Clean external data and bootrom context secret values.
+ */
+static void ssp_cleanup(boot_api_context_t *boot_context)
+{
+	boot_api_ssp_config_t *ssp_config = boot_context->p_ssp_config;
+
+	/* Cleanup boot_context */
+	if (ssp_config->p_ssp_oem_secrets_decrypted != NULL) {
+		zeromem(ssp_config->p_ssp_oem_secrets_decrypted,
+			BOOT_API_SSP_OEM_SECRETS_MAX_SIZE_BYTES);
+#ifndef DCACHE_OFF
+		flush_dcache_range((uintptr_t)ssp_config->p_ssp_oem_secrets_decrypted,
+				   BOOT_API_SSP_OEM_SECRETS_MAX_SIZE_BYTES);
+#endif
+		ssp_config->p_ssp_oem_secrets_decrypted = NULL;
+	}
+
+	if (ssp_config->p_chip_pubk != NULL) {
+		zeromem(ssp_config->p_chip_pubk,
+			BOOT_API_SSP_PUBK_KEY_SIZE_BYTES);
+#ifndef DCACHE_OFF
+		flush_dcache_range((uintptr_t)ssp_config->p_chip_pubk,
+				   BOOT_API_SSP_PUBK_KEY_SIZE_BYTES);
+#endif
+		ssp_config->p_chip_pubk = NULL;
+	}
+
+	if (ssp_config->p_blob_license != NULL) {
+		zeromem(ssp_config->p_blob_license,
+			sizeof(boot_api_ssp_blob_license_t));
+#ifndef DCACHE_OFF
+		flush_dcache_range((uintptr_t)ssp_config->p_blob_license,
+				   sizeof(boot_api_ssp_blob_license_t));
+#endif
+		ssp_config->p_blob_license = NULL;
+	}
+
+	if (ssp_config->p_blob_payload != NULL) {
+		zeromem(ssp_config->p_blob_payload,
+			sizeof(boot_api_ssp_blob_payload_t));
+#ifndef DCACHE_OFF
+		flush_dcache_range((uintptr_t)ssp_config->p_blob_payload,
+			   sizeof(boot_api_ssp_blob_payload_t));
+#endif
+		ssp_config->p_blob_payload = NULL;
+	}
+
+	ssp_config->ssp_cmd = 0U;
+
+#ifndef DCACHE_OFF
+	flush_dcache_range((uintptr_t)boot_context->p_ssp_config,
+			   sizeof(boot_api_ssp_config_t));
+#endif
+}
+
+/*
+ * Send certificate to the programmer and retrieve the associated
+ * encrypted file.
+ */
+static int ssp_download_phase(boot_api_context_t *boot_ctx)
+{
+	uint8_t *blob_file;
+#if STM32MP_UART_PROGRAMMER
+	uintptr_t uart_base;
+#endif
+#if STM32MP_USB_PROGRAMMER
+	struct usb_handle *pdev;
+#endif
+	int result = 0;
+	uint8_t cert[CERTIFICATE_SIZE];
+
+#if STM32MP13
+	blob_file = (uint8_t *)boot_ctx->p_ssp_config->p_blob_license;
+#endif
+#if STM32MP15
+	blob_file = (uint8_t *)page_align(BLOB_FILE_MAX_ADDR -
+					  sizeof(boot_api_ssp_blob_license_t) -
+					  sizeof(boot_api_ssp_blob_payload_t),
+					  DOWN);
+#endif
+
+	if (prepare_certificate(cert, boot_ctx->p_ssp_config->p_chip_pubk) != 0) {
+		return -EINVAL;
+	}
+
+	switch (boot_ctx->boot_interface_selected) {
+#if STM32MP_USB_PROGRAMMER
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB:
+
+		/* init USB on platform */
+		pdev = usb_dfu_plat_init();
+
+		result = stm32cubeprog_usb_ssp(pdev, (uintptr_t)cert,
+					       sizeof(cert), (uintptr_t)blob_file,
+					       sizeof(boot_api_ssp_blob_license_t) +
+					       sizeof(boot_api_ssp_blob_payload_t));
+		if (result != 0) {
+			return -EINVAL;
+		}
+
+		break;
+#endif
+
+#if STM32MP_UART_PROGRAMMER
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART:
+		uart_base = get_uart_address(boot_ctx->boot_interface_instance);
+
+		if (uart_base == 0U) {
+			return -EINVAL;
+		}
+
+		result = stm32cubeprog_uart_ssp(uart_base, (uintptr_t)cert, sizeof(cert),
+						(uintptr_t)blob_file,
+						sizeof(boot_api_ssp_blob_license_t) +
+						sizeof(boot_api_ssp_blob_payload_t));
+		if (result != 0) {
+			return -EINVAL;
+		}
+		break;
+#endif
+	default:
+		return -EINVAL;
+	}
+
+	boot_ctx->p_ssp_config->p_blob_license =
+		(boot_api_ssp_blob_license_t *)blob_file;
+
+	/* Payload is concatened with license file */
+	boot_ctx->p_ssp_config->p_blob_payload =
+		(boot_api_ssp_blob_payload_t *)(blob_file +
+		sizeof(boot_api_ssp_blob_license_t));
+
+#ifndef DCACHE_OFF
+	flush_dcache_range((uintptr_t)blob_file,
+			   sizeof(boot_api_ssp_blob_license_t) +
+			   sizeof(boot_api_ssp_blob_payload_t));
+#endif
+
+	/* Set return address for decrypted_secrets */
+	boot_ctx->p_ssp_config->p_ssp_oem_secrets_decrypted =
+		boot_ctx->p_ssp_config->p_blob_payload->oem_encrypted_secrets;
+
+	return result;
+}
+
+/*
+ * Burn decrypted secrets into OTP, clean memory and close the device.
+ */
+static int ssp_secret_programming(boot_api_context_t *boot_context)
+{
+	int result;
+
+	result = ssp_secrets_check(boot_context);
+	if (result != 0) {
+		ERROR("SSP ERROR checking OTP\n");
+		goto clean;
+	}
+
+	result = ssp_pub_key_prog(boot_context);
+	if (result != 0) {
+		ERROR("SSP ERROR writing HASH key\n");
+		goto clean;
+	}
+
+	result = ssp_close_device();
+	if (result != 0) {
+		ERROR("SSP close device failed\n");
+		goto clean;
+	}
+
+	result = ssp_secrets_flash(boot_context);
+	if (result != 0) {
+		ERROR("SSP Secret flash failed\n");
+	}
+
+clean:
+	cleanup_otp_value();
+
+	ssp_cleanup(boot_context);
+
+	if (result != 0) {
+		return result;
+	}
+
+	return ssp_finish_process();
+}
+
+/*
+ * Enable the SSP processing.
+ */
+static int ssp_enable_processing(boot_api_context_t *boot_context)
+{
+	uint32_t val;
+	int result;
+#if STM32MP_USB_PROGRAMMER
+	struct usb_handle *pdev;
+#endif
+#if STM32MP_UART_PROGRAMMER
+	uintptr_t uart_base;
+#endif
+
+	if (stm32_get_otp_value_from_idx(otp_ssp.idx, &val) != 0) {
+		return -EINVAL;
+	}
+
+	if (((val & SSP_OTP_MASK) == SSP_OTP_MASK) ||
+	    ((val & SSP_OTP_MASK) == SSP_OTP_SUCCESS)) {
+		return -EINVAL;
+	}
+
+	if ((val & SSP_OTP_MASK) == 0U) {
+		if (bsec_program_otp(SSP_OTP_REQ, otp_ssp.idx) != BSEC_OK) {
+			return -EINVAL;
+		}
+	}
+
+	switch (boot_context->boot_interface_selected) {
+#if STM32MP_UART_PROGRAMMER
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART:
+		uart_base = get_uart_address(boot_context->boot_interface_instance);
+		if (uart_base == 0U) {
+			return -EINVAL;
+		}
+
+		result = stm32cubeprog_uart_ssp(uart_base, (uintptr_t)-1, 0,
+						(uintptr_t)NULL, 0);
+		if (result != 0) {
+			return -EINVAL;
+		}
+		break;
+#endif
+#if STM32MP_USB_PROGRAMMER
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB:
+		/* init USB on platform */
+		pdev = usb_dfu_plat_init();
+
+		result = stm32cubeprog_usb_ssp(pdev, (uintptr_t)-1, 0,
+					       (uintptr_t)NULL, 0);
+		if (result != 0) {
+			return -EINVAL;
+		}
+
+		break;
+#endif
+	default:
+		return -EINVAL;
+	}
+
+	boot_context->p_ssp_config->ssp_cmd =
+		BOOT_API_CTX_SSP_CMD_CALC_CHIP_PUBK;
+
+	return 0;
+}
+
+/*
+ * Retrieve the current status of the SSP from bootrom context and OTP value.
+ */
+static ssp_result_e ssp_check_status(boot_api_context_t *boot_context)
+{
+	uint32_t otp;
+
+	if (initialize_otp() < 0) {
+		return SSP_ERROR;
+	}
+
+	if (stm32_get_otp_value_from_idx(otp_ssp.idx, &otp) != 0) {
+		return SSP_ERROR;
+	}
+
+	if ((otp & SSP_OTP_REQ) == 0U) {
+		return SSP_NONE;
+	}
+
+	if ((otp & SSP_OTP_SUCCESS) != 0U) {
+		return SSP_DONE;
+	}
+
+	VERBOSE("Start Get ssp_cmd : %x\n",
+		boot_context->p_ssp_config->ssp_cmd);
+
+	switch (boot_context->p_ssp_config->ssp_cmd) {
+	case BOOT_API_CTX_SSP_CMD_CALC_CHIP_PUBK_ACK:
+		INFO("Detected start SSP Phase 2\n");
+		return SSP_GET_CERT;
+	case BOOT_API_CTX_SSP_CMD_PROV_SECRET_ACK:
+		INFO("Detected start SSP Phase 3\n");
+		return SSP_FLASH_OEM;
+	default:
+		return SSP_NONE;
+	}
+}
+
+/*
+ * Start the SSP processing.
+ */
+static void ssp_start(boot_api_context_t *boot_context)
+{
+	int result;
+	uint8_t ssp_phase = ssp_check_status(boot_context);
+
+	switch (ssp_phase) {
+	case SSP_GET_CERT:
+		result = ssp_download_phase(boot_context);
+		if (result != 0) {
+			/*
+			 * Download Phase failed, clean, reset
+			 */
+			ssp_cleanup(boot_context);
+
+			ERROR("SSP_Error: Resetting target\n");
+		} else {
+			/* Process completed, go to Phase 3 */
+			boot_context->p_ssp_config->ssp_cmd =
+				BOOT_API_CTX_SSP_CMD_PROV_SECRET;
+		}
+
+		break;
+
+	case SSP_FLASH_OEM:
+		result = ssp_secret_programming(boot_context);
+		if (result != 0) {
+			ERROR("Error during provisionning\n");
+		} else {
+			NOTICE("Provisioning completed\n");
+		}
+
+		break;
+
+	case SSP_ERROR:
+		/*
+		 * Error during bootrom SSP processing
+		 */
+		result = -EINVAL;
+		ERROR("SSP_Error: Resetting target\n");
+		break;
+
+	case SSP_NONE:
+	default:
+		result = ssp_enable_processing(boot_context);
+		if (result != 0) {
+			ERROR("Start SSP Failed (%i)\n", result);
+		}
+	}
+
+	if ((result != 0) || (ssp_phase == SSP_FLASH_OEM)) {
+		goto out;
+	}
+
+	/*
+	 * Keep VDDCORE && VDD enabled if pmic used to generate
+	 * the required MPSYSRST.
+	 */
+	if (dt_pmic_status() > 0) {
+		struct rdev *regul;
+
+		regul = dt_get_cpu_regulator();
+		if (regul == NULL) {
+			panic();
+		}
+
+		if (regulator_set_flag(regul, REGUL_MASK_RESET) < 0) {
+			WARN("Failed to write cpu-supply reset mask\n");
+		}
+
+		regul = dt_get_vdd_regulator();
+		if (regul == NULL) {
+			goto out;
+		}
+
+		if (regulator_set_flag(regul, REGUL_MASK_RESET) < 0) {
+			WARN("Failed to write vdd-supply reset mask\n");
+		}
+	} else {
+		static const char debug_msg[] = {
+			"SSP next step will be only guarantee if the VDD\n"
+			"domain is maintained during system reset\n"
+		};
+
+		NOTICE("%s", debug_msg);
+	}
+
+out:
+#ifndef DCACHE_OFF
+	if (boot_context->p_ssp_config != NULL) {
+		flush_dcache_range((uintptr_t)boot_context->p_ssp_config,
+				   sizeof(boot_api_ssp_config_t));
+	}
+#endif
+
+	stm32mp_system_reset();
+}
+
+void bl2_el3_early_platform_setup(u_register_t arg0,
+				  u_register_t arg1 __unused,
+				  u_register_t arg2 __unused,
+				  u_register_t arg3 __unused)
+{
+	stm32mp_save_boot_ctx_address(arg0);
+}
+
+void bl2_el3_plat_arch_setup(void)
+{
+#if DEBUG
+	const char *board_model;
+#endif
+	uintptr_t pwr_base;
+	uintptr_t rcc_base;
+
+	boot_api_context_t *boot_context =
+		(boot_api_context_t *)stm32mp_get_boot_ctx_address();
+	bool serial_uart_interface __unused =
+				(boot_context->boot_interface_selected ==
+				 BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART);
+	uintptr_t uart_prog_addr __unused;
+
+	if (bsec_probe() != 0) {
+		panic();
+	}
+
+	mmap_add_region(BL_CODE_BASE, BL_CODE_BASE,
+			BL_CODE_END - BL_CODE_BASE,
+			MT_CODE | MT_SECURE);
+
+#if SEPARATE_CODE_AND_RODATA
+	mmap_add_region(BL_RO_DATA_BASE, BL_RO_DATA_BASE,
+			BL_RO_DATA_END - BL_RO_DATA_BASE,
+			MT_RO_DATA | MT_SECURE);
+#endif
+
+	/* Prevent corruption of preloaded Device Tree */
+	mmap_add_region(DTB_BASE, DTB_BASE,
+			DTB_LIMIT - DTB_BASE,
+			MT_RO_DATA | MT_SECURE);
+
+	configure_mmu();
+
+	if (dt_open_and_check(STM32MP_DTB_BASE) < 0) {
+		panic();
+	}
+
+	pwr_base = stm32mp_pwr_base();
+	rcc_base = stm32mp_rcc_base();
+
+	/*
+	 * Disable the backup domain write protection.
+	 * The protection is enable at each reset by hardware
+	 * and must be disabled by software.
+	 */
+	mmio_setbits_32(pwr_base + PWR_CR1, PWR_CR1_DBP);
+
+	while ((mmio_read_32(pwr_base + PWR_CR1) & PWR_CR1_DBP) == 0U) {
+		;
+	}
+
+	/* Reset backup domain on cold boot cases */
+	if ((mmio_read_32(rcc_base + RCC_BDCR) & RCC_BDCR_RTCSRC_MASK) == 0U) {
+		mmio_setbits_32(rcc_base + RCC_BDCR, RCC_BDCR_VSWRST);
+
+		while ((mmio_read_32(rcc_base + RCC_BDCR) & RCC_BDCR_VSWRST) ==
+		       0U) {
+			;
+		}
+
+		mmio_clrbits_32(rcc_base + RCC_BDCR, RCC_BDCR_VSWRST);
+	}
+
+	/* Set minimum reset pulse duration to 31ms for discrete power supplied boards */
+	if (dt_pmic_status() <= 0) {
+		mmio_clrsetbits_32(rcc_base + RCC_RDLSICR, RCC_RDLSICR_MRD_MASK,
+				   31U << RCC_RDLSICR_MRD_SHIFT);
+	}
+
+	generic_delay_timer_init();
+
+#if STM32MP_UART_PROGRAMMER
+	uart_prog_addr = get_uart_address(boot_context->boot_interface_instance);
+
+	/* Disable programmer UART before changing clock tree */
+	if (serial_uart_interface) {
+		stm32_uart_stop(uart_prog_addr);
+	}
+#endif
+
+	if (stm32mp1_clk_probe() < 0) {
+		panic();
+	}
+
+	if (dt_pmic_status() > 0) {
+		initialize_pmic();
+	}
+
+#if DEBUG
+	if (stm32mp_uart_console_setup() != 0) {
+		goto skip_console_init;
+	}
+
+	stm32mp_print_cpuinfo();
+
+	board_model = dt_get_board_model();
+	if (board_model != NULL) {
+		NOTICE("Model: %s\n", board_model);
+	}
+
+	stm32mp_print_boardinfo();
+
+	if ((boot_context->p_ssp_config == NULL) ||
+	    (boot_context->p_ssp_config->ssp_cmd !=
+	     BOOT_API_CTX_SSP_CMD_PROV_SECRET_ACK)) {
+		stm32mp_print_cpuinfo();
+		if (!stm32mp_is_auth_supported()) {
+			ERROR("Chip doesn't support SSP\n");
+			panic();
+		}
+	}
+
+skip_console_init:
+#endif
+	if (stm32mp_is_closed_device()) {
+		/* Closed chip required authentication */
+		ERROR("SSP not supported on closed chip\n");
+		panic();
+	}
+
+	if (stm32_iwdg_init() < 0) {
+		panic();
+	}
+
+	stm32_iwdg_refresh();
+
+	if (dt_pmic_status() > 0) {
+		initialize_pmic_i2c();
+		print_pmic_info_and_debug();
+	}
+
+	ssp_start(boot_context);
+
+	/* This must not be reached */
+	panic();
+}
diff --git a/plat/st/stm32mp1/stm32mp1_ssp.mk b/plat/st/stm32mp1/stm32mp1_ssp.mk
new file mode 100644
index 000000000..07f9297af
--- /dev/null
+++ b/plat/st/stm32mp1/stm32mp1_ssp.mk
@@ -0,0 +1,104 @@
+#
+# Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+ST_VERSION 		:=	r1.0-ssp
+VERSION_STRING		:=	v${VERSION_MAJOR}.${VERSION_MINOR}-${PLAT}-${ST_VERSION}(${BUILD_TYPE}):${BUILD_STRING}
+
+# Required to use BL2_IN_XIP_MEM
+BL2_IN_XIP_MEM		:= 	1
+
+SEPARATE_CODE_AND_RODATA :=	1
+
+TRUSTED_BOARD_BOOT	:=	0
+
+# Macros and rules to build TF-A binary
+STM32_TF_STM32		:=	$(addprefix ${BUILD_PLAT}/tf-a-ssp-, $(patsubst %.dtb,%.stm32,$(DTB_FILE_NAME)))
+
+PLAT_BL_COMMON_SOURCES	:=	common/fdt_wrappers.c					\
+				common/uuid.c						\
+				plat/st/common/stm32mp_common.c				\
+				plat/st/stm32mp1/stm32mp1_private.c
+
+PLAT_BL_COMMON_SOURCES	+=	drivers/st/uart/aarch32/stm32_console.S
+
+PLAT_BL_COMMON_SOURCES	+=	drivers/regulator/regulator_core.c			\
+				drivers/st/regulator/regulator_fixed.c
+
+PLAT_BL_COMMON_SOURCES	+=	${XLAT_TABLES_LIB_SRCS}
+
+PLAT_BL_COMMON_SOURCES	+=	lib/cpus/aarch32/cortex_a7.S
+
+PLAT_BL_COMMON_SOURCES	+=	drivers/arm/tzc/tzc400.c				\
+				drivers/clk/clk.c					\
+				drivers/delay_timer/delay_timer.c			\
+				drivers/delay_timer/generic_delay_timer.c		\
+				drivers/st/bsec/bsec2.c					\
+				drivers/st/clk/stm32mp_clkfunc.c			\
+				drivers/st/gpio/stm32_gpio.c				\
+				drivers/st/i2c/stm32_i2c.c				\
+				drivers/st/iwdg/stm32_iwdg.c				\
+				drivers/st/pmic/stm32mp_pmic.c				\
+				drivers/st/pmic/stpmic1.c				\
+				drivers/st/reset/stm32mp1_reset.c			\
+				plat/st/common/stm32mp_dt.c				\
+				plat/st/common/stm32mp_shres_helpers.c			\
+				plat/st/common/stm32mp_svc_setup.c			\
+				plat/st/stm32mp1/stm32mp1_dbgmcu.c			\
+				plat/st/stm32mp1/stm32mp1_helper.S			\
+				plat/st/stm32mp1/stm32mp1_syscfg.c
+
+ifeq ($(STM32MP13),1)
+PLAT_BL_COMMON_SOURCES	+=	drivers/st/clk/clk-stm32-core.c				\
+				drivers/st/clk/clk-stm32mp13.c
+endif
+ifeq ($(STM32MP15),1)
+PLAT_BL_COMMON_SOURCES	+=	drivers/st/clk/stm32mp1_clk.c
+endif
+
+BL2_SOURCES		:=	drivers/io/io_storage.c					\
+				plat/st/stm32mp1/stm32mp1_ssp.c
+
+ifeq ($(STM32MP15),1)
+BL2_SOURCES		+=	drivers/st/crypto/stm32_hash.c
+endif
+
+
+ifeq (${STM32MP_UART_PROGRAMMER},1)
+BL2_SOURCES		+=	drivers/st/uart/stm32_uart.c				\
+				plat/st/common/stm32cubeprogrammer_uart.c
+endif
+
+ifeq (${STM32MP_USB_PROGRAMMER},1)
+#The DFU stack uses only one end point, reduce the USB stack footprint
+$(eval $(call add_define_val,CONFIG_USBD_EP_NB,1U))
+BL2_SOURCES		+=	drivers/st/usb/stm32mp1_usb.c				\
+				drivers/usb/usb_device.c				\
+				plat/st/common/stm32cubeprogrammer_usb.c		\
+				plat/st/common/usb_dfu.c				\
+				plat/st/stm32mp1/stm32mp1_usb_dfu.c
+endif
+
+ifeq ($(STM32MP13),1)
+BL2_DTSI		:=	stm32mp13-ssp-bl2.dtsi
+endif
+ifeq ($(STM32MP15),1)
+BL2_DTSI		:=	stm32mp15-ssp-bl2.dtsi
+endif
+
+check_boot_ssp:
+	@if ([ ${STM32MP_UART_PROGRAMMER} = 1 ] && [ ${STM32MP_USB_PROGRAMMER} = 1 ]) || \
+	([ ${STM32MP_UART_PROGRAMMER} = 0 ] && [ ${STM32MP_USB_PROGRAMMER} = 0 ]); then \
+		echo "Error selecting serial boot device"; \
+		false; \
+	fi
+
+bl2: check_boot_ssp
+
+${BUILD_PLAT}/stm32mp1-ssp-%.o: ${BUILD_PLAT}/fdts/%-bl2.dtb plat/st/stm32mp1/stm32mp1.S bl2
+	@echo "  SSP AS      stm32mp1.S"
+	${Q}${AS} ${ASFLAGS} ${TF_CFLAGS} \
+		-DDTB_BIN_PATH=\"$<\" \
+		-c plat/st/stm32mp1/stm32mp1.S -o $@
diff --git a/plat/st/stm32mp1/stm32mp1_stm32image_def.h b/plat/st/stm32mp1/stm32mp1_stm32image_def.h
deleted file mode 100644
index 8efa342c1..000000000
--- a/plat/st/stm32mp1/stm32mp1_stm32image_def.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
- *
- * SPDX-License-Identifier: BSD-3-Clause
- */
-
-#ifndef STM32MP1_STM32IMAGE_DEF_H
-#define STM32MP1_STM32IMAGE_DEF_H
-
-#ifdef AARCH32_SP_OPTEE
-#define STM32MP_DDR_S_SIZE		U(0x01E00000)	/* 30 MB */
-#define STM32MP_DDR_SHMEM_SIZE		U(0x00200000)	/* 2 MB */
-#else
-#define STM32MP_DDR_S_SIZE		U(0)
-#define STM32MP_DDR_SHMEM_SIZE		U(0)
-#endif
-
-#define STM32MP_BL2_SIZE		U(0x0001C000)	/* 112 KB for BL2 */
-#define STM32MP_DTB_SIZE		U(0x00006000)	/* 24 KB for DTB */
-
-#ifdef AARCH32_SP_OPTEE
-#define STM32MP_BL32_BASE		STM32MP_SEC_SYSRAM_BASE
-
-#define STM32MP_BL2_BASE		(STM32MP_SEC_SYSRAM_BASE + \
-					 STM32MP_SEC_SYSRAM_SIZE - \
-					 STM32MP_BL2_SIZE)
-
-/* OP-TEE loads from SYSRAM base to BL2 DTB start address */
-#define STM32MP_OPTEE_BASE		STM32MP_BL32_BASE
-#define STM32MP_OPTEE_SIZE		(STM32MP_SEC_SYSRAM_SIZE -  \
-					 STM32MP_BL2_SIZE - STM32MP_DTB_SIZE)
-#define STM32MP_BL32_SIZE		STM32MP_OPTEE_SIZE
-#else /* AARCH32_SP_OPTEE */
-#define STM32MP_BL32_SIZE		U(0x00019000)	/* 96 KB for BL32 */
-
-#define STM32MP_BL32_BASE		(STM32MP_SEC_SYSRAM_BASE + \
-					 STM32MP_SEC_SYSRAM_SIZE - \
-					 STM32MP_BL32_SIZE)
-
-#define STM32MP_BL2_BASE		(STM32MP_BL32_BASE - \
-					 STM32MP_BL2_SIZE)
-#endif /* AARCH32_SP_OPTEE */
-
-/* DTB initialization value */
-#define STM32MP_DTB_BASE		(STM32MP_BL2_BASE -	\
-					 STM32MP_DTB_SIZE)
-
-/*
- * MAX_MMAP_REGIONS is usually:
- * BL stm32mp1_mmap size + mmap regions in *_plat_arch_setup
- */
-#if defined(IMAGE_BL32)
-#define MAX_MMAP_REGIONS		6
-#endif
-
-/*******************************************************************************
- * STM32MP1 RAW partition offset for MTD devices
- ******************************************************************************/
-#define STM32MP_NOR_BL33_OFFSET		U(0x00080000)
-#ifdef AARCH32_SP_OPTEE
-#define STM32MP_NOR_TEEH_OFFSET		U(0x00280000)
-#define STM32MP_NOR_TEED_OFFSET		U(0x002C0000)
-#define STM32MP_NOR_TEEX_OFFSET		U(0x00300000)
-#endif
-
-#define STM32MP_NAND_BL33_OFFSET	U(0x00200000)
-#ifdef AARCH32_SP_OPTEE
-#define STM32MP_NAND_TEEH_OFFSET	U(0x00600000)
-#define STM32MP_NAND_TEED_OFFSET	U(0x00680000)
-#define STM32MP_NAND_TEEX_OFFSET	U(0x00700000)
-#endif
-
-#endif /* STM32MP1_STM32IMAGE_DEF_H */
diff --git a/plat/st/stm32mp1/stm32mp1_syscfg.c b/plat/st/stm32mp1/stm32mp1_syscfg.c
index 793ad714a..be122730d 100644
--- a/plat/st/stm32mp1/stm32mp1_syscfg.c
+++ b/plat/st/stm32mp1/stm32mp1_syscfg.c
@@ -4,32 +4,62 @@
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
+#include <assert.h>
+#include <errno.h>
+
 #include <platform_def.h>
 
 #include <common/debug.h>
-#include <drivers/st/bsec.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32mp1_clk.h>
 #include <drivers/st/stpmic1.h>
 #include <lib/mmio.h>
+#include <lib/utils_def.h>
 
+#include <stm32mp_common.h>
 #include <stm32mp_dt.h>
 #include <stm32mp1_private.h>
 
 /*
- * SYSCFG REGISTER OFFSET (base relative)
+ * SYSCFG register offsets (base relative)
  */
 #define SYSCFG_BOOTR				0x00U
+#define SYSCFG_BOOTCR				0x0CU
+#if STM32MP15
 #define SYSCFG_IOCTRLSETR			0x18U
 #define SYSCFG_ICNR				0x1CU
+#endif
 #define SYSCFG_CMPCR				0x20U
 #define SYSCFG_CMPENSETR			0x24U
 #define SYSCFG_CMPENCLRR			0x28U
+#if STM32MP13
+#define SYSCFG_CMPSD1CR				0x30U
+#define SYSCFG_CMPSD1ENSETR			0x34U
+#define SYSCFG_CMPSD1ENCLRR			0x38U
+#define SYSCFG_CMPSD2CR				0x40U
+#define SYSCFG_CMPSD2ENSETR			0x44U
+#define SYSCFG_CMPSD2ENCLRR			0x48U
+#define SYSCFG_HSLVEN0R				0x50U
+#endif
+#define SYSCFG_IDC				0x380U
+
+#define CMPCR_CMPENSETR_OFFSET			0x4U
+#define CMPCR_CMPENCLRR_OFFSET			0x8U
 
 /*
  * SYSCFG_BOOTR Register
  */
 #define SYSCFG_BOOTR_BOOT_MASK			GENMASK(2, 0)
+#if STM32MP15
 #define SYSCFG_BOOTR_BOOTPD_MASK		GENMASK(6, 4)
 #define SYSCFG_BOOTR_BOOTPD_SHIFT		4
+#endif
+
+/*
+ * SYSCFG_BOOTCR Register
+ */
+#define SYSCFG_BOOTCR_BMEN			BIT(0)
+
 /*
  * SYSCFG_IOCTRLSETR Register
  */
@@ -54,28 +84,185 @@
 #define SYSCFG_CMPCR_RAPSRC			GENMASK(23, 20)
 #define SYSCFG_CMPCR_ANSRC_SHIFT		24
 
+#define SYSCFG_CMPCR_READY_TIMEOUT_US		10000U
+
 /*
  * SYSCFG_CMPENSETR Register
  */
 #define SYSCFG_CMPENSETR_MPU_EN			BIT(0)
 
-void stm32mp1_syscfg_init(void)
+/*
+ * HSLV definitions
+ */
+#define HSLV_IDX_TPIU				0U
+#define HSLV_IDX_QSPI				1U
+#define HSLV_IDX_ETH1				2U
+#define HSLV_IDX_ETH2				3U
+#define HSLV_IDX_SDMMC1				4U
+#define HSLV_IDX_SDMMC2				5U
+#define HSLV_IDX_SPI1				6U
+#define HSLV_IDX_SPI2				7U
+#define HSLV_IDX_SPI3				8U
+#define HSLV_IDX_SPI4				9U
+#define HSLV_IDX_SPI5				10U
+#define HSLV_IDX_LTDC				11U
+#define HSLV_NB_IDX				12U
+
+#define HSLV_KEY				0x1018U
+
+/*
+ * SYSCFG_IDC Register
+ */
+#define SYSCFG_IDC_DEV_ID_MASK	GENMASK(11, 0)
+#define SYSCFG_IDC_REV_ID_MASK	GENMASK(31, 16)
+#define SYSCFG_IDC_REV_ID_SHIFT	16
+
+static void enable_io_comp_cell_finish(uintptr_t cmpcr_off)
 {
-	uint32_t bootr;
-	uint32_t otp = 0;
-	uint32_t vdd_voltage;
+	uint64_t start;
 
-	/*
-	 * Interconnect update : select master using the port 1.
-	 * LTDC = AXI_M9.
-	 */
-	mmio_write_32(SYSCFG_BASE + SYSCFG_ICNR, SYSCFG_ICNR_AXI_M9);
+	start = timeout_init_us(SYSCFG_CMPCR_READY_TIMEOUT_US);
 
-	/* Disable Pull-Down for boot pin connected to VDD */
-	bootr = mmio_read_32(SYSCFG_BASE + SYSCFG_BOOTR) &
-		SYSCFG_BOOTR_BOOT_MASK;
-	mmio_clrsetbits_32(SYSCFG_BASE + SYSCFG_BOOTR, SYSCFG_BOOTR_BOOTPD_MASK,
-			   bootr << SYSCFG_BOOTR_BOOTPD_SHIFT);
+	while ((mmio_read_32(SYSCFG_BASE + cmpcr_off) & SYSCFG_CMPCR_READY) == 0U) {
+		if (timeout_elapsed(start)) {
+			/* Failure on IO compensation enable is not a issue: warn only. */
+			WARN("IO compensation cell not ready\n");
+			break;
+		}
+	}
+
+	mmio_clrbits_32(SYSCFG_BASE + cmpcr_off, SYSCFG_CMPCR_SW_CTRL);
+}
+
+static void disable_io_comp_cell(uintptr_t cmpcr_off)
+{
+	uint32_t value;
+
+	if (((mmio_read_32(SYSCFG_BASE + cmpcr_off) & SYSCFG_CMPCR_READY) == 0U) ||
+	    ((mmio_read_32(SYSCFG_BASE + cmpcr_off + CMPCR_CMPENSETR_OFFSET) &
+	     SYSCFG_CMPENSETR_MPU_EN) == 0U)) {
+		return;
+	}
+
+	value = mmio_read_32(SYSCFG_BASE + cmpcr_off) >> SYSCFG_CMPCR_ANSRC_SHIFT;
+
+	mmio_clrbits_32(SYSCFG_BASE + cmpcr_off, SYSCFG_CMPCR_RANSRC | SYSCFG_CMPCR_RAPSRC);
+
+	value <<= SYSCFG_CMPCR_RANSRC_SHIFT;
+	value |= mmio_read_32(SYSCFG_BASE + cmpcr_off);
+
+	mmio_write_32(SYSCFG_BASE + cmpcr_off, value | SYSCFG_CMPCR_SW_CTRL);
+
+	mmio_setbits_32(SYSCFG_BASE + cmpcr_off + CMPCR_CMPENCLRR_OFFSET, SYSCFG_CMPENSETR_MPU_EN);
+}
+
+#if STM32MP13
+static int get_regu_max_voltage(void *fdt, int sdmmc_node, char *regu_name, uint32_t *regu_val)
+{
+	int node;
+	const fdt32_t *cuint;
+
+	cuint = fdt_getprop(fdt, sdmmc_node, regu_name, NULL);
+	if (cuint == NULL) {
+		return -ENODEV;
+	}
+
+	node = fdt_node_offset_by_phandle(fdt, fdt32_to_cpu(*cuint));
+	if (node < 0) {
+		return -ENODEV;
+	}
+
+	cuint = fdt_getprop(fdt, node, "regulator-max-microvolt", NULL);
+	if (cuint == NULL) {
+		return -ENODEV;
+	}
+
+	*regu_val = fdt32_to_cpu(*cuint);
+
+	return 0;
+}
+
+static bool sdmmc_is_low_voltage(uintptr_t sdmmc_base)
+{
+	int ret;
+	int node;
+	void *fdt = NULL;
+	uint32_t regu_max_val;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return false;
+	}
+
+	if (fdt == NULL) {
+		return false;
+	}
+
+	node = dt_match_instance_by_compatible(DT_SDMMC2_COMPAT, sdmmc_base);
+	if (node < 0) {
+		/* No SD or eMMC device on this instance, enable HSLV */
+		return true;
+	}
+
+	ret = get_regu_max_voltage(fdt, node, "vqmmc-supply", &regu_max_val);
+	if ((ret < 0) || (regu_max_val > 1800000)) {
+		/*
+		 * The vqmmc-supply property should always be present for eMMC.
+		 * For SD-card, if it is not, then the card only supports 3.3V.
+		 */
+		return false;
+	}
+
+	return true;
+}
+
+static void enable_hslv_by_index(uint32_t index)
+{
+	bool apply_hslv;
+
+	assert(index < HSLV_NB_IDX);
+
+	switch (index) {
+	case HSLV_IDX_SDMMC1:
+		apply_hslv = sdmmc_is_low_voltage(STM32MP_SDMMC1_BASE);
+		break;
+	case HSLV_IDX_SDMMC2:
+		apply_hslv = sdmmc_is_low_voltage(STM32MP_SDMMC2_BASE);
+		break;
+	default:
+		apply_hslv = true;
+		break;
+	}
+
+	if (apply_hslv) {
+		mmio_write_32(SYSCFG_BASE + SYSCFG_HSLVEN0R + index * sizeof(uint32_t), HSLV_KEY);
+	}
+}
+#endif
+
+static void enable_high_speed_mode_low_voltage(void)
+{
+#if STM32MP13
+	uint32_t idx;
+
+	for (idx = 0U; idx < HSLV_NB_IDX; idx++) {
+		enable_hslv_by_index(idx);
+	}
+#endif
+#if STM32MP15
+	mmio_write_32(SYSCFG_BASE + SYSCFG_IOCTRLSETR,
+		      SYSCFG_IOCTRLSETR_HSLVEN_TRACE |
+		      SYSCFG_IOCTRLSETR_HSLVEN_QUADSPI |
+		      SYSCFG_IOCTRLSETR_HSLVEN_ETH |
+		      SYSCFG_IOCTRLSETR_HSLVEN_SDMMC |
+		      SYSCFG_IOCTRLSETR_HSLVEN_SPI);
+#endif
+}
+
+static void stm32mp1_syscfg_set_hslv(void)
+{
+	uint32_t otp_value;
+	uint32_t vdd_voltage;
+	bool product_below_2v5;
 
 	/*
 	 * High Speed Low Voltage Pad mode Enable for SPI, SDMMC, ETH, QSPI
@@ -92,64 +279,89 @@ void stm32mp1_syscfg_init(void)
 	 *   => TF-A enables the low power mode only if VDD < 2.7V (in DT)
 	 *      but this value needs to be consistent with board design.
 	 */
-	if (bsec_read_otp(&otp, HW2_OTP) != BSEC_OK) {
+	if (stm32_get_otp_value(HW2_OTP, &otp_value) != 0) {
 		panic();
 	}
 
-	otp = otp & HW2_OTP_PRODUCT_BELOW_2V5;
+	product_below_2v5 = (otp_value & HW2_OTP_PRODUCT_BELOW_2V5) != 0U;
 
 	/* Get VDD supply */
 	vdd_voltage = dt_get_pwr_vdd_voltage();
 
 	/* Check if VDD is Low Voltage */
 	if (vdd_voltage == 0U) {
-		WARN("VDD unknown");
+		WARN("VDD unknown\n");
 	} else if (vdd_voltage < 2700000U) {
-		mmio_write_32(SYSCFG_BASE + SYSCFG_IOCTRLSETR,
-			      SYSCFG_IOCTRLSETR_HSLVEN_TRACE |
-			      SYSCFG_IOCTRLSETR_HSLVEN_QUADSPI |
-			      SYSCFG_IOCTRLSETR_HSLVEN_ETH |
-			      SYSCFG_IOCTRLSETR_HSLVEN_SDMMC |
-			      SYSCFG_IOCTRLSETR_HSLVEN_SPI);
-
-		if (otp == 0U) {
+		enable_high_speed_mode_low_voltage();
+
+		if (!product_below_2v5) {
 			INFO("Product_below_2v5=0: HSLVEN protected by HW\n");
 		}
 	} else {
-		if (otp != 0U) {
+		if (product_below_2v5) {
 			ERROR("Product_below_2v5=1:\n");
 			ERROR("\tHSLVEN update is destructive,\n");
 			ERROR("\tno update as VDD > 2.7V\n");
 			panic();
 		}
 	}
+}
 
-	stm32mp1_syscfg_enable_io_compensation();
+void stm32mp1_syscfg_init(void)
+{
+#if STM32MP15
+	uint32_t bootr;
+
+	/*
+	 * Interconnect update : select master using the port 1.
+	 * LTDC = AXI_M9.
+	 */
+	mmio_write_32(SYSCFG_BASE + SYSCFG_ICNR, SYSCFG_ICNR_AXI_M9);
+
+	/* Disable Pull-Down for boot pin connected to VDD */
+	bootr = mmio_read_32(SYSCFG_BASE + SYSCFG_BOOTR) &
+		SYSCFG_BOOTR_BOOT_MASK;
+	mmio_clrsetbits_32(SYSCFG_BASE + SYSCFG_BOOTR, SYSCFG_BOOTR_BOOTPD_MASK,
+			   bootr << SYSCFG_BOOTR_BOOTPD_SHIFT);
+#endif
+
+	stm32mp1_syscfg_set_hslv();
+
+	stm32mp1_syscfg_enable_io_compensation_start();
 }
 
-void stm32mp1_syscfg_enable_io_compensation(void)
+void stm32mp1_syscfg_enable_io_compensation_start(void)
 {
 	/*
 	 * Activate automatic I/O compensation.
 	 * Warning: need to ensure CSI enabled and ready in clock driver.
 	 * Enable non-secure clock, we assume non-secure is suspended.
 	 */
-	stm32mp1_clk_enable_non_secure(SYSCFG);
+	stm32mp1_clk_force_enable(SYSCFG);
 
-	mmio_setbits_32(SYSCFG_BASE + SYSCFG_CMPENSETR,
+	mmio_setbits_32(SYSCFG_BASE + CMPCR_CMPENSETR_OFFSET + SYSCFG_CMPCR,
+			SYSCFG_CMPENSETR_MPU_EN);
+#if STM32MP13
+	mmio_setbits_32(SYSCFG_BASE + CMPCR_CMPENSETR_OFFSET + SYSCFG_CMPSD1CR,
+			SYSCFG_CMPENSETR_MPU_EN);
+	mmio_setbits_32(SYSCFG_BASE + CMPCR_CMPENSETR_OFFSET + SYSCFG_CMPSD2CR,
 			SYSCFG_CMPENSETR_MPU_EN);
 
-	while ((mmio_read_32(SYSCFG_BASE + SYSCFG_CMPCR) &
-		SYSCFG_CMPCR_READY) == 0U) {
-		;
-	}
+#endif
+}
 
-	mmio_clrbits_32(SYSCFG_BASE + SYSCFG_CMPCR, SYSCFG_CMPCR_SW_CTRL);
+void stm32mp1_syscfg_enable_io_compensation_finish(void)
+{
+	enable_io_comp_cell_finish(SYSCFG_CMPCR);
+#if STM32MP13
+	enable_io_comp_cell_finish(SYSCFG_CMPSD1CR);
+	enable_io_comp_cell_finish(SYSCFG_CMPSD2CR);
+#endif
 }
 
 void stm32mp1_syscfg_disable_io_compensation(void)
 {
-	uint32_t value;
+	stm32mp1_clk_force_enable(SYSCFG);
 
 	/*
 	 * Deactivate automatic I/O compensation.
@@ -157,18 +369,42 @@ void stm32mp1_syscfg_disable_io_compensation(void)
 	 * requested for other usages and always OFF in STANDBY.
 	 * Disable non-secure SYSCFG clock, we assume non-secure is suspended.
 	 */
-	value = mmio_read_32(SYSCFG_BASE + SYSCFG_CMPCR) >>
-	      SYSCFG_CMPCR_ANSRC_SHIFT;
+	disable_io_comp_cell(SYSCFG_CMPCR);
+#if STM32MP13
+	disable_io_comp_cell(SYSCFG_CMPSD1CR);
+	disable_io_comp_cell(SYSCFG_CMPSD2CR);
+#endif
 
-	mmio_clrbits_32(SYSCFG_BASE + SYSCFG_CMPCR,
-			SYSCFG_CMPCR_RANSRC | SYSCFG_CMPCR_RAPSRC);
+	stm32mp1_clk_force_disable(SYSCFG);
+}
 
-	value = mmio_read_32(SYSCFG_BASE + SYSCFG_CMPCR) |
-		(value << SYSCFG_CMPCR_RANSRC_SHIFT);
+/*
+ * @brief  Get silicon revision from SYSCFG registers.
+ * @retval chip version (REV_ID).
+ */
+uint32_t stm32mp1_syscfg_get_chip_version(void)
+{
+	return (mmio_read_32(SYSCFG_BASE + SYSCFG_IDC) &
+		SYSCFG_IDC_REV_ID_MASK) >> SYSCFG_IDC_REV_ID_SHIFT;
+}
 
-	mmio_write_32(SYSCFG_BASE + SYSCFG_CMPCR, value | SYSCFG_CMPCR_SW_CTRL);
+/*
+ * @brief  Get device ID from SYSCFG registers.
+ * @retval device ID (DEV_ID).
+ */
+uint32_t stm32mp1_syscfg_get_chip_dev_id(void)
+{
+	return mmio_read_32(SYSCFG_BASE + SYSCFG_IDC) & SYSCFG_IDC_DEV_ID_MASK;
+}
 
-	mmio_setbits_32(SYSCFG_BASE + SYSCFG_CMPENCLRR, SYSCFG_CMPENSETR_MPU_EN);
+#if STM32MP13
+void stm32mp1_syscfg_boot_mode_enable(void)
+{
+	mmio_setbits_32(SYSCFG_BASE + SYSCFG_BOOTCR, SYSCFG_BOOTCR_BMEN);
+}
 
-	stm32mp1_clk_disable_non_secure(SYSCFG);
+void stm32mp1_syscfg_boot_mode_disable(void)
+{
+	mmio_clrbits_32(SYSCFG_BASE + SYSCFG_BOOTCR, SYSCFG_BOOTCR_BMEN);
 }
+#endif
diff --git a/plat/st/stm32mp1/stm32mp1_tbb_cert.c b/plat/st/stm32mp1/stm32mp1_tbb_cert.c
new file mode 100644
index 000000000..3d46b0d16
--- /dev/null
+++ b/plat/st/stm32mp1/stm32mp1_tbb_cert.c
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include "tbbr/stm32mp1_tbb_cert.h"
+#include "tbbr/tbb_ext.h"
+#include "tbbr/tbb_key.h"
+
+/*
+ * Certificates used in the chain of trust
+ *
+ * The order of the certificates must follow the enumeration specified in
+ * stm32mp1_tbb_cert.h. All certificates are self-signed, so the issuer certificate
+ * field points to itself.
+ */
+static cert_t stm32mp1_tbb_certs[] = {
+	[0] = {
+		.id = STM32MP_CONFIG_CERT,
+		.opt = "stm32mp-cfg-cert",
+		.help_msg = "STM32MP Config Certificate (output file)",
+		.fn = NULL,
+		.cn = "STM32MP config FW Certificate",
+		.key = ROT_KEY,
+		.issuer = STM32MP_CONFIG_CERT,
+		.ext = {
+			TRUSTED_FW_NVCOUNTER_EXT,
+			HW_CONFIG_HASH_EXT,
+			FW_CONFIG_HASH_EXT
+		},
+		.num_ext = 3
+	},
+};
+
+PLAT_REGISTER_COT(stm32mp1_tbb_certs);
diff --git a/plat/st/stm32mp1/stm32mp1_usb_dfu.c b/plat/st/stm32mp1/stm32mp1_usb_dfu.c
index 70fbba6db..62ceace84 100644
--- a/plat/st/stm32mp1/stm32mp1_usb_dfu.c
+++ b/plat/st/stm32mp1/stm32mp1_usb_dfu.c
@@ -28,7 +28,12 @@
 #define USBD_CONFIGURATION_STRING	"DFU Config"
 #define USBD_INTERFACE_STRING		"DFU Interface"
 
+#if STM32MP13
+#define USB_DFU_ITF_NUM			2
+#endif
+#if STM32MP15
 #define USB_DFU_ITF_NUM			6
+#endif
 
 #define USB_DFU_CONFIG_DESC_SIZ		USB_DFU_DESC_SIZ(USB_DFU_ITF_NUM)
 
@@ -98,11 +103,18 @@ static const uint8_t usb_stm32mp1_config_desc[USB_DFU_CONFIG_DESC_SIZ] = {
 	/* Descriptor of DFU interface 0 Alternate setting 0..N */
 	USBD_DFU_IF_DESC(0),
 	USBD_DFU_IF_DESC(1),
+#if USB_DFU_ITF_NUM > 2
 	USBD_DFU_IF_DESC(2),
+#endif
+#if USB_DFU_ITF_NUM > 3
 	USBD_DFU_IF_DESC(3),
+#endif
+#if USB_DFU_ITF_NUM > 4
 	USBD_DFU_IF_DESC(4),
+#endif
+#if USB_DFU_ITF_NUM > 5
 	USBD_DFU_IF_DESC(5),
-
+#endif
 	/* DFU Functional Descriptor */
 	0x09, /* blength = 9 Bytes */
 	DFU_DESCRIPTOR_TYPE, /* DFU Functional Descriptor */
@@ -115,6 +127,17 @@ static const uint8_t usb_stm32mp1_config_desc[USB_DFU_CONFIG_DESC_SIZ] = {
 };
 
 /* The user strings: one by alternate as defined in USBD_DFU_IF_DESC */
+#if STM32MP13
+const char *const if_desc_string[USB_DFU_ITF_NUM] = {
+#if STM32MP_SSP
+	"@SSP /0xF3/1*512Ba",
+#else
+	"@SSBL /0x03/1*16Me",
+#endif
+	"@virtual /0xF1/1*512Ba"
+};
+#endif
+#if STM32MP15
 const char *const if_desc_string[USB_DFU_ITF_NUM] = {
 	"@Partition0 /0x00/1*256Ke",
 	"@FSBL /0x01/1*1Me",
@@ -123,6 +146,7 @@ const char *const if_desc_string[USB_DFU_ITF_NUM] = {
 	"@Partition4 /0x04/1*16Me",
 	"@virtual /0xF1/1*512Ba"
 };
+#endif
 
 /* Buffer to build the unicode string provided to USB device stack */
 static uint8_t usb_str_dec[USBD_MAX_STR_DESC_SIZ];
@@ -156,30 +180,15 @@ static void stm32mp1_get_string(const char *desc, uint8_t *unicode, uint16_t *le
  */
 static void update_serial_num_string(void)
 {
-	uint8_t i;
-	uint32_t result;
 	char serial_string[SIZ_STRING_SERIAL + 2U];
-	uint32_t deviceserial[UID_WORD_NB];
+	/* serial number is set to 0 */
+	uint32_t deviceserial[UID_WORD_NB] = {0U, 0U, 0U};
 	uint16_t length;
 
-	for (i = 0U; i < UID_WORD_NB; i++) {
-		result = bsec_shadow_register(i + UID0_OTP);
-		if (result != BSEC_OK) {
-			ERROR("BSEC: UID%d Shadowing Error\n", i);
-			break;
-		}
-		result = bsec_read_otp(&deviceserial[i], i + UID0_OTP);
-		if (result != BSEC_OK) {
-			ERROR("BSEC: UID%d Read Error\n", i);
-			break;
-		}
-	}
-	/* On bsec error: serial number is set to 0 */
-	if (result != BSEC_OK) {
-		for (i = 0; i < UID_WORD_NB; i++) {
-			deviceserial[i] = 0U;
-		}
+	if (stm32_get_uid_otp(deviceserial) != 0) {
+		return;
 	}
+
 	/* build serial number with OTP value as in ROM code */
 	snprintf(serial_string, sizeof(serial_string), "%08X%08X%08X",
 		 deviceserial[0], deviceserial[1], deviceserial[2]);
@@ -353,9 +362,11 @@ struct usb_handle *usb_dfu_plat_init(void)
 	stm32mp1_usb_init_driver(&usb_core_handle, &pcd_handle,
 				 (uint32_t *)USB_OTG_BASE);
 
+#if STM32MP15
 	/* STM32MP15 = keep the configuration from ROM code */
 	usb_core_handle.ep0_state = USBD_EP0_DATA_IN;
 	usb_core_handle.dev_state = USBD_STATE_CONFIGURED;
+#endif
 
 	/* Update the serial number string descriptor from the unique ID */
 	update_serial_num_string();
@@ -375,12 +386,31 @@ uint8_t usb_dfu_get_phase(uint8_t alt)
 	uint8_t ret;
 
 	switch (alt) {
+#if STM32MP13
+	case 0:
+#if STM32MP_SSP
+		ret = PHASE_SSP;
+#else
+		ret = PHASE_SSBL;
+#endif
+		break;
+	case 1:
+		ret = PHASE_CMD;
+		break;
+#endif
+#if STM32MP15
+#if STM32MP_SSP
+	case 0:
+		ret =  PHASE_SSP;
+		break;
+#endif
 	case 3:
 		ret = PHASE_SSBL;
 		break;
 	case 5:
 		ret = PHASE_CMD;
 		break;
+#endif
 	default:
 		ret = PHASE_RESET;
 		break;
diff --git a/plat/st/stm32mp2/.gitignore b/plat/st/stm32mp2/.gitignore
new file mode 100644
index 000000000..f1bd961db
--- /dev/null
+++ b/plat/st/stm32mp2/.gitignore
@@ -0,0 +1 @@
+plat_fiptool.mk
diff --git a/plat/st/stm32mp2/aarch64/stm32mp2.S b/plat/st/stm32mp2/aarch64/stm32mp2.S
new file mode 100644
index 000000000..720849d72
--- /dev/null
+++ b/plat/st/stm32mp2/aarch64/stm32mp2.S
@@ -0,0 +1,11 @@
+/*
+ * Copyright (c) 2020, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+.section .bl2_image
+.incbin BL2_BIN_PATH
+
+.section .dtb_image
+.incbin DTB_BIN_PATH
diff --git a/plat/st/stm32mp2/aarch64/stm32mp2.ld.S b/plat/st/stm32mp2/aarch64/stm32mp2.ld.S
new file mode 100644
index 000000000..e1745c67b
--- /dev/null
+++ b/plat/st/stm32mp2/aarch64/stm32mp2.ld.S
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2015-2020, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_LD_S
+#define STM32MP2_LD_S
+
+#include <lib/xlat_tables/xlat_tables_defs.h>
+#include <platform_def.h>
+
+OUTPUT_FORMAT(PLATFORM_LINKER_FORMAT)
+OUTPUT_ARCH(PLATFORM_LINKER_ARCH)
+
+ENTRY(__BL2_IMAGE_START__)
+
+MEMORY {
+	HEADER (rw) : ORIGIN = 0x00000000, LENGTH = STM32MP_HEADER_RESERVED_SIZE
+	RAM (rwx) : ORIGIN = STM32MP_BINARY_BASE, LENGTH = STM32MP_BINARY_SIZE
+}
+
+SECTIONS
+{
+    /*
+     * TF mapping must conform to ROM code specification.
+     */
+    .header : {
+        __HEADER_START__ = .;
+        KEEP(*(.header))
+        . = ALIGN(4);
+        __HEADER_END__ = .;
+    } >HEADER
+
+    . = STM32MP_BINARY_BASE;
+    .data . : {
+        . = ALIGN(PAGE_SIZE);
+        __DATA_START__ = .;
+        *(.data*)
+
+        /*
+         * dtb.
+         * The strongest and only alignment contraint is MMU 4K page.
+         * Indeed as images below will be removed, 4K pages will be re-used.
+         */
+        . = ( STM32MP_BL2_DTB_BASE - STM32MP_BINARY_BASE );
+        __DTB_IMAGE_START__ = .;
+        *(.dtb_image*)
+        __DTB_IMAGE_END__ = .;
+
+        /*
+         * bl2.
+         * The strongest and only alignment contraint is MMU 4K page.
+         * Indeed as images below will be removed, 4K pages will be re-used.
+         */
+#if SEPARATE_CODE_AND_RODATA
+        . = ( STM32MP_BL2_RO_BASE - STM32MP_BINARY_BASE );
+#else
+        . = ( STM32MP_BL2_BASE - STM32MP_BINARY_BASE );
+#endif
+        __BL2_IMAGE_START__ = .;
+        *(.bl2_image*)
+        __BL2_IMAGE_END__ = .;
+
+        __DATA_END__ = .;
+    } >RAM
+
+    __TF_END__ = .;
+
+}
+#endif /* STM32MP2_LD_S */
diff --git a/plat/st/stm32mp2/aarch64/stm32mp2_helper.S b/plat/st/stm32mp2/aarch64/stm32mp2_helper.S
new file mode 100644
index 000000000..f1102daa9
--- /dev/null
+++ b/plat/st/stm32mp2/aarch64/stm32mp2_helper.S
@@ -0,0 +1,228 @@
+/*
+ * Copyright (c) 2018-2022, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <platform_def.h>
+
+#include <asm_macros.S>
+#include <drivers/st/stm32_gpio.h>
+
+#define GPIO_TX_SHIFT		(DEBUG_UART_TX_GPIO_PORT << 1)
+
+	.globl	platform_mem_init
+	.globl	plat_get_my_entrypoint
+	.globl	plat_secondary_cold_boot_setup
+	.globl	plat_reset_handler
+	.globl	plat_is_my_cpu_primary
+	.globl	plat_my_core_pos
+	.globl	plat_crash_console_init
+	.globl	plat_crash_console_flush
+	.globl	plat_crash_console_putc
+	.globl	plat_report_exception
+
+func platform_mem_init
+	/* Nothing to do, don't need to init SYSRAM */
+	ret
+endfunc platform_mem_init
+
+	/* ------------------------------------------------------------------
+	 * unsigned long plat_get_my_entrypoint (void);
+	 *
+	 * Main job of this routine is to distinguish between a cold and warm
+	 * boot.
+	 *
+	 * Currently supports only cold boot
+	 * ------------------------------------------------------------------
+	 */
+func plat_get_my_entrypoint
+	mov	x0, #0
+	ret
+endfunc plat_get_my_entrypoint
+
+	/* ---------------------------------------------
+	 * void plat_secondary_cold_boot_setup (void);
+	 *
+	 * Set secondary core in WFI waiting for core reset.
+	 * ---------------------------------------------
+	 */
+func plat_secondary_cold_boot_setup
+	dsb	sy
+	wfi
+	/* This shouldn't be reached */
+	b	.
+endfunc plat_secondary_cold_boot_setup
+
+	/* ----------------------------------------------
+	 * unsigned int plat_is_my_cpu_primary(void);
+	 * This function checks if this is the primary CPU
+	 * ----------------------------------------------
+	 */
+func plat_is_my_cpu_primary
+	mrs	x0, mpidr_el1
+	and	x0, x0, #(MPIDR_CPU_MASK)
+	cmp	x0, #STM32MP_PRIMARY_CPU
+	cset	x0, eq
+	ret
+endfunc plat_is_my_cpu_primary
+
+	/* -----------------------------------------------------------
+	 *  unsigned int plat_stm32mp_get_core_pos(u_register_t mpidr)
+	 *  Helper function to calculate the core position.
+	 *  With this function: CorePos = (ClusterId * 4) +
+	 *  				  CoreId
+	 * -----------------------------------------------------------
+	 */
+func plat_stm32mp_get_core_pos
+	and	x1, x0, #MPIDR_CPU_MASK
+	and	x0, x0, #MPIDR_CLUSTER_MASK
+	add	x0, x1, x0, LSR #6
+	ret
+endfunc plat_stm32mp_get_core_pos
+
+	/* -----------------------------------------------------
+	 *  unsigned int plat_my_core_pos(void)
+	 *  This function uses the plat_stm32mp_get_core_pos()
+	 *  definition to get the index of the calling CPU.
+	 * -----------------------------------------------------
+	 */
+func plat_my_core_pos
+	mrs	x0, mpidr_el1
+	b	plat_stm32mp_get_core_pos
+endfunc plat_my_core_pos
+
+	/* ---------------------------------------------
+	 * int plat_crash_console_init(void)
+	 *
+	 * Initialize the crash console without a C Runtime stack.
+	 * ---------------------------------------------
+	 */
+func plat_crash_console_init
+	/* Reset UART peripheral */
+	mov_imm	x1, (RCC_BASE + DEBUG_UART_RST_REG)
+	ldr	x2, =DEBUG_UART_RST_BIT
+	ldr	x0, [x1]
+	orr	x0, x0, x2
+	str	x0, [x1]
+1:
+	ldr	x0, [x1]
+	ands	x2, x0, x2
+	beq	1b
+	bic	x2, x2, #DEBUG_UART_RST_BIT
+	str	x2, [x1]
+2:
+	ldr	x0, [x1]
+	ands	x2, x0, x2
+	bne	2b
+	/* Enable GPIOs for UART TX */
+	mov_imm	x1, (RCC_BASE + DEBUG_UART_TX_GPIO_BANK_CLK_REG)
+	ldr	w2, [x1]
+	/* Configure GPIO */
+	orr	w2, w2, #DEBUG_UART_TX_GPIO_BANK_CLK_EN
+	str	w2, [x1]
+	mov_imm	x1, DEBUG_UART_TX_GPIO_BANK_ADDRESS
+	/* Set GPIO mode alternate */
+	ldr	w2, [x1, #GPIO_MODE_OFFSET]
+	bic	w2, w2, #(GPIO_MODE_MASK << GPIO_TX_SHIFT)
+	orr	w2, w2, #(GPIO_MODE_ALTERNATE << GPIO_TX_SHIFT)
+	str	w2, [x1, #GPIO_MODE_OFFSET]
+	/* Set GPIO speed low */
+	ldr	w2, [x1, #GPIO_SPEED_OFFSET]
+	bic	w2, w2, #(GPIO_SPEED_MASK << GPIO_TX_SHIFT)
+	str	w2, [x1, #GPIO_SPEED_OFFSET]
+	/* Set no-pull */
+	ldr	w2, [x1, #GPIO_PUPD_OFFSET]
+	bic	w2, w2, #(GPIO_PULL_MASK << GPIO_TX_SHIFT)
+	str	w2, [x1, #GPIO_PUPD_OFFSET]
+	/* Set alternate */
+#if DEBUG_UART_TX_GPIO_PORT >= GPIO_ALT_LOWER_LIMIT
+	ldr	w2, [x1, #GPIO_AFRH_OFFSET]
+	bic	w2, w2, #(GPIO_ALTERNATE_MASK << \
+				((DEBUG_UART_TX_GPIO_PORT - GPIO_ALT_LOWER_LIMIT) << 2))
+	orr	w2, w2, #(DEBUG_UART_TX_GPIO_ALTERNATE << \
+				((DEBUG_UART_TX_GPIO_PORT - GPIO_ALT_LOWER_LIMIT) << 2))
+	str	w2, [x1, #GPIO_AFRH_OFFSET]
+#else
+	ldr	w2, [x1, #GPIO_AFRL_OFFSET]
+	bic	w2, w2, #(GPIO_ALTERNATE_MASK << (DEBUG_UART_TX_GPIO_PORT << 2))
+	orr	w2, w2, #(DEBUG_UART_TX_GPIO_ALTERNATE << (DEBUG_UART_TX_GPIO_PORT << 2))
+	str	w2, [x1, #GPIO_AFRL_OFFSET]
+#endif
+	/* Clear UART clock flexgen divisors, keep enable bit */
+	mov_imm	x1, (RCC_BASE + DEBUG_UART_PREDIV_CFGR)
+	mov	x2, #0
+	str	w2, [x1]
+	mov_imm	x1, (RCC_BASE + DEBUG_UART_FINDIV_CFGR)
+	mov	x2, #0x40
+	str	w2, [x1]
+	/* Enable UART clock, with its source */
+	mov_imm	x1, (RCC_BASE + DEBUG_UART_TX_CLKSRC_REG)
+	mov_imm	w2, (DEBUG_UART_TX_CLKSRC | RCC_XBARxCFGR_XBARxEN)
+	str	w2, [x1]
+	mov_imm	x1, (RCC_BASE + DEBUG_UART_TX_EN_REG)
+	ldr	w2, [x1]
+	orr	w2, w2, #DEBUG_UART_TX_EN
+	str	w2, [x1]
+
+	mov_imm	x0, STM32MP_DEBUG_USART_BASE
+	mov_imm	x1, STM32MP_DEBUG_USART_CLK_FRQ
+	mov_imm	x2, STM32MP_UART_BAUDRATE
+	b	console_stm32_core_init
+endfunc plat_crash_console_init
+
+func plat_crash_console_flush
+	mov_imm	x0, STM32MP_DEBUG_USART_BASE
+	b	console_stm32_core_flush
+endfunc plat_crash_console_flush
+
+func plat_crash_console_putc
+	mov_imm	x1, STM32MP_DEBUG_USART_BASE
+	cmp	x0, #'\n'
+	b.ne	1f
+	mov	x15, x30
+	mov	x0, #'\r'
+	bl	console_stm32_core_putc
+	mov	x30, x15
+	mov	x0, #'\n'
+1:
+	b	console_stm32_core_putc
+endfunc plat_crash_console_putc
+
+#ifdef IMAGE_BL2
+	/* ---------------------------------------------
+	 * void plat_report_exception(unsigned int type)
+	 * Function to report an unhandled exception
+	 * with platform-specific means.
+	 * ---------------------------------------------
+	 */
+func plat_report_exception
+	mov	x8, x30
+
+	adr	x4, plat_err_str
+	bl	asm_print_str
+
+	adr	x4, esr_el3_str
+	bl	asm_print_str
+
+	mrs	x4, esr_el3
+	bl	asm_print_hex
+
+	adr	x4, elr_el3_str
+	bl	asm_print_str
+
+	mrs	x4, elr_el3
+	bl	asm_print_hex
+
+	mov	x30, x8
+	ret
+endfunc plat_report_exception
+
+.section .rodata.rev_err_str, "aS"
+plat_err_str:
+	.asciz "\nPlatform exception reporting:"
+esr_el3_str:
+	.asciz "\nESR_EL3: "
+elr_el3_str:
+	.asciz "\nELR_EL3: "
+#endif /* IMAGE_BL2 */
diff --git a/plat/st/stm32mp2/bl2_plat_setup.c b/plat/st/stm32mp2/bl2_plat_setup.c
new file mode 100644
index 000000000..ace949932
--- /dev/null
+++ b/plat/st/stm32mp2/bl2_plat_setup.c
@@ -0,0 +1,435 @@
+/*
+ * Copyright (c) 2018-2022, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <stdint.h>
+
+#include <platform_def.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <common/desc_image_load.h>
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/generic_delay_timer.h>
+#include <drivers/mmc.h>
+#include <drivers/regulator.h>
+#include <drivers/st/bsec.h>
+#include <drivers/st/regulator_fixed.h>
+#include <drivers/st/stm32_console.h>
+#include <drivers/st/stm32mp_reset.h>
+#include <drivers/st/stm32mp_rifsc_regs.h>
+#include <drivers/st/stm32mp_risab_regs.h>
+#include <drivers/st/stm32mp2_ram.h>
+#include <drivers/st/stm32mp2_risaf.h>
+#include <lib/fconf/fconf.h>
+#include <lib/fconf/fconf_dyn_cfg_getter.h>
+#include <lib/mmio.h>
+#include <lib/optee_utils.h>
+#include <lib/xlat_tables/xlat_tables_v2.h>
+#include <plat/common/platform.h>
+
+#include <stm32mp_common.h>
+#include <stm32mp_dt.h>
+
+#define BOOT_CTX_ADDR	0x0e000000 /* beginning of SYSRAM */
+
+static void print_reset_reason(void)
+{
+	uint32_t rstsr = mmio_read_32(stm32mp_rcc_base() + RCC_C1BOOTRSTSCLRR);
+
+	if (rstsr == 0U) {
+		WARN("Reset reason unknown\n");
+		return;
+	}
+
+	INFO("Reset reason (0x%x):\n", rstsr);
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_PADRSTF) == 0U) {
+		if ((rstsr & RCC_C1BOOTRSTSCLRR_D1STBYRSTF) != 0U) {
+			INFO("D1 domain exits from DStandby\n");
+			return;
+		}
+
+		if ((rstsr & RCC_C1BOOTRSTSCLRR_STBYC1RSTF) != 0U) {
+			INFO("System exits from A35 STANDBY\n");
+			return;
+		}
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_PORRSTF) != 0U) {
+		INFO("  Power-on Reset (rst_por)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_BORRSTF) != 0U) {
+		INFO("  Brownout Reset (rst_bor)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSSETR_SYSC2RSTF) != 0U) {
+		INFO("  System reset (SYSRST) by M33\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSSETR_SYSC1RSTF) != 0U) {
+		INFO("  System reset (SYSRST) by A35\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_HCSSRSTF) != 0U) {
+		INFO("  Clock failure on HSE\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_IWDG1SYSRSTF) != 0U) {
+		INFO("  IWDG1 system reset (rst_iwdg1)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_IWDG2SYSRSTF) != 0U) {
+		INFO("  IWDG2 system reset (rst_iwdg2)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_IWDG3SYSRSTF) != 0U) {
+		INFO("  IWDG3 system reset (rst_iwdg3)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_IWDG4SYSRSTF) != 0U) {
+		INFO("  IWDG4 system reset (rst_iwdg4)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_IWDG5SYSRSTF) != 0U) {
+		INFO("  IWDG5 system reset (rst_iwdg5)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_C1P1RSTF) != 0U) {
+		INFO("  A35 processor 1 reset\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_PADRSTF) != 0U) {
+		INFO("  Pad Reset from NRST\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_VCORERSTF) != 0U) {
+		INFO("  Reset due to a failure of VDD_CORE\n");
+		return;
+	}
+
+	ERROR("  Unidentified reset reason\n");
+}
+
+void bl2_el3_early_platform_setup(u_register_t arg0 __unused,
+				  u_register_t arg1 __unused,
+				  u_register_t arg2 __unused,
+				  u_register_t arg3 __unused)
+{
+	stm32mp_setup_early_console();
+
+	stm32mp_save_boot_ctx_address(BOOT_CTX_ADDR);
+}
+
+void bl2_platform_setup(void)
+{
+	int ret;
+
+	ret = stm32mp2_ddr_probe();
+	if (ret != 0) {
+		ERROR("DDR probe: error %d\n", ret);
+		panic();
+	}
+
+	if (stm32mp2_risaf_init() < 0) {
+		panic();
+	}
+
+	/* Map DDR for binary load, now with cacheable attribute */
+	ret = mmap_add_dynamic_region(STM32MP_DDR_BASE, STM32MP_DDR_BASE,
+				      STM32MP_DDR_MAX_SIZE, MT_MEMORY | MT_RW | MT_SECURE);
+	if (ret < 0) {
+		ERROR("DDR mapping: error %d\n", ret);
+		panic();
+	}
+
+	/* Set QOS ICN priority */
+	stm32mp2_syscfg_set_icn_qos();
+}
+
+void bl2_el3_plat_arch_setup(void)
+{
+	const char *board_model;
+	boot_api_context_t *boot_context =
+		(boot_api_context_t *)stm32mp_get_boot_ctx_address();
+	uintptr_t pwr_base;
+#ifndef CFG_WORKAROUND_VSW0V8
+	uintptr_t rcc_base;
+#endif
+
+	if (bsec_probe() != 0) {
+		panic();
+	}
+
+	mmap_add_region(BL_CODE_BASE, BL_CODE_BASE,
+			BL_CODE_END - BL_CODE_BASE,
+			MT_CODE | MT_SECURE);
+
+	/* Prevent corruption of preloaded Device Tree */
+	mmap_add_region(DTB_BASE, DTB_BASE,
+			DTB_LIMIT - DTB_BASE,
+			MT_RO_DATA | MT_SECURE);
+
+	configure_mmu();
+
+	if (dt_open_and_check(STM32MP_DTB_BASE) < 0) {
+		panic();
+	}
+
+	pwr_base = stm32mp_pwr_base();
+#ifndef CFG_WORKAROUND_VSW0V8
+	rcc_base = stm32mp_rcc_base();
+#endif
+
+	/*
+	 * Disable the backup domain write protection.
+	 * The protection is enable at each reset by hardware
+	 * and must be disabled by software.
+	 */
+	mmio_setbits_32(pwr_base + PWR_BDCR1, PWR_BDCR1_DBD3P);
+
+	while ((mmio_read_32(pwr_base + PWR_BDCR1) & PWR_BDCR1_DBD3P) == 0U) {
+		;
+	}
+
+#ifndef CFG_WORKAROUND_VSW0V8
+	/* Reset backup domain on cold boot cases */
+	if ((mmio_read_32(rcc_base + RCC_BDCR) & RCC_BDCR_RTCSRC_MASK) == 0U) {
+		mmio_setbits_32(rcc_base + RCC_BDCR, RCC_BDCR_VSWRST);
+
+		while ((mmio_read_32(rcc_base + RCC_BDCR) & RCC_BDCR_VSWRST) ==
+		       0U) {
+			;
+		}
+
+		mmio_clrbits_32(rcc_base + RCC_BDCR, RCC_BDCR_VSWRST);
+	}
+#endif
+
+	if (stm32mp2_clk_init() < 0) {
+		panic();
+	}
+
+	stm32_save_boot_interface(boot_context->boot_interface_selected,
+				  boot_context->boot_interface_instance);
+
+	if (stm32mp_uart_console_setup() != 0) {
+		goto skip_console_init;
+	}
+
+	stm32mp_print_cpuinfo();
+
+	board_model = dt_get_board_model();
+	if (board_model != NULL) {
+		NOTICE("Model: %s\n", board_model);
+	}
+
+	stm32mp_print_boardinfo();
+
+	print_reset_reason();
+
+skip_console_init:
+
+	if (fixed_regulator_register() != 0) {
+		panic();
+	}
+
+	stm32mp2_arch_security_setup();
+
+	fconf_populate("TB_FW", STM32MP_DTB_BASE);
+
+#if STM32MP_DDR_FIP_IO_STORAGE
+	/*
+	 * RISAB3 setup (dedicated for SRAM1)
+	 *
+	 * Allow secure read/writes data accesses to non-secure
+	 * blocks or pages, all RISAB registers are writable.
+	 * DDR firmwares are saved there before being loaded in DDRPHY memory.
+	 */
+	mmio_write_32(RISAB3_BASE + RISAB_CR, RISAB_CR_SRWIAD);
+#endif
+#if STM32MP_USB_PROGRAMMER
+	/* Enabling SRAM2 clock is not needed as it is a critical clock */
+	/*
+	 * RISAB4 setup (dedicated for SRAM2)
+	 *
+	 * Allow secure read/writes data accesses to non-secure
+	 * blocks or pages, all RISAB registers are writable.
+	 * Secure execution is still illegal. DDR FIP is saved here.
+	 */
+	mmio_write_32(RISAB4_BASE + RISAB_CR, RISAB_CR_SRWIAD);
+
+	/*
+	 * Set USB3DRD Peripheriphal accesses to Secure/Privilege only
+	 */
+	mmio_write_32(RIFSC_BASE + _RIFSC_RISC_SECCFGR(RISUP_USB3DRD), RIFSC_USBDRD_SEC);
+	mmio_write_32(RIFSC_BASE + _RIFSC_RISC_PRIVCFGR(RISUP_USB3DRD), RIFSC_USBDRD_PRIV);
+
+	/*
+	 * Apply USB boot specific configuration to RIF master USB3DR
+	 */
+	mmio_write_32(RIFSC_BASE + _RIFSC_RIMC_ATTR(RIMU_USB3DR), RIFSC_USB_BOOT_USBDR_RIMC_CONF);
+#endif /* STM32MP_USB_PROGRAMMER */
+
+	if (stm32mp2_pwr_init_io_domains() != 0) {
+		panic();
+	}
+
+	stm32mp_io_setup();
+}
+
+static void prepare_encryption(void)
+{
+	/* TODO use random generator to create key */
+	uint8_t mkey[RISAF_KEY_SIZE_IN_BYTES] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
+						  0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF };
+
+	if (stm32mp2_risaf_write_master_key(RISAF4_INST, mkey) != 0) {
+		panic();
+	}
+}
+
+/*******************************************************************************
+ * This function can be used by the platforms to update/use image
+ * information for given `image_id`.
+ ******************************************************************************/
+int bl2_plat_handle_post_image_load(unsigned int image_id)
+{
+	int err = 0;
+	bl_mem_params_node_t *bl_mem_params = get_bl_mem_params_node(image_id);
+	bl_mem_params_node_t *bl32_mem_params __unused;
+	bl_mem_params_node_t *pager_mem_params __unused;
+	const struct dyn_cfg_dtb_info_t *config_info;
+	unsigned int i;
+	unsigned long long ddr_top __unused;
+	const unsigned int image_ids[] = {
+		BL31_IMAGE_ID,
+		BL32_IMAGE_ID,
+		BL33_IMAGE_ID,
+		HW_CONFIG_ID,
+	};
+
+	assert(bl_mem_params != NULL);
+
+	switch (image_id) {
+	case FW_CONFIG_ID:
+		if (stm32mp_is_closed_device() || stm32mp_is_auth_supported()) {
+			prepare_encryption();
+		}
+
+		/* Set global DTB info for fixed fw_config information */
+		set_config_info(STM32MP_FW_CONFIG_BASE, STM32MP_FW_CONFIG_MAX_SIZE, FW_CONFIG_ID);
+		fconf_populate("FW_CONFIG", STM32MP_FW_CONFIG_BASE);
+
+		/* Iterate through all the fw config IDs */
+		for (i = 0U; i < ARRAY_SIZE(image_ids); i++) {
+			bl_mem_params = get_bl_mem_params_node(image_ids[i]);
+			assert(bl_mem_params != NULL);
+
+			config_info = FCONF_GET_PROPERTY(dyn_cfg, dtb, image_ids[i]);
+			if (config_info == NULL) {
+				continue;
+			}
+
+			bl_mem_params->image_info.image_base = config_info->config_addr;
+			bl_mem_params->image_info.image_max_size = config_info->config_max_size;
+
+			bl_mem_params->image_info.h.attr &= ~IMAGE_ATTRIB_SKIP_LOADING;
+
+			switch (image_ids[i]) {
+			case BL31_IMAGE_ID:
+				bl_mem_params->ep_info.pc = config_info->config_addr;
+				break;
+			case BL32_IMAGE_ID:
+				bl_mem_params->ep_info.pc = config_info->config_addr;
+
+				/* In case of OPTEE, initialize address space with tos_fw addr */
+				pager_mem_params = get_bl_mem_params_node(BL32_EXTRA1_IMAGE_ID);
+				if (pager_mem_params != NULL) {
+					pager_mem_params->image_info.image_base =
+						config_info->config_addr;
+					pager_mem_params->image_info.image_max_size =
+						config_info->config_max_size;
+				}
+				break;
+
+			case BL33_IMAGE_ID:
+				bl_mem_params->ep_info.pc = config_info->config_addr;
+				break;
+
+			case HW_CONFIG_ID:
+				break;
+
+			default:
+				return -EINVAL;
+			}
+		}
+
+		break;
+
+	case BL32_IMAGE_ID:
+		if (optee_header_is_valid(bl_mem_params->image_info.image_base)) {
+			/* BL32 is OP-TEE header */
+			bl_mem_params->ep_info.pc = bl_mem_params->image_info.image_base;
+			pager_mem_params = get_bl_mem_params_node(BL32_EXTRA1_IMAGE_ID);
+			assert(pager_mem_params != NULL);
+
+			err = parse_optee_header(&bl_mem_params->ep_info,
+						 &pager_mem_params->image_info,
+						 NULL);
+			if (err) {
+				ERROR("OPTEE header parse error.\n");
+				panic();
+			}
+
+			/* Set optee boot info from parsed header data */
+			bl_mem_params->ep_info.args.arg0 = 0U; /* Unused */
+			bl_mem_params->ep_info.args.arg1 = 0U; /* Unused */
+			bl_mem_params->ep_info.args.arg2 = 0U; /* No DT supported */
+		}
+		break;
+
+	case BL33_IMAGE_ID:
+	default:
+		/* Do nothing in default case */
+		break;
+	}
+
+#if STM32MP_SDMMC || STM32MP_EMMC
+	/*
+	 * Invalidate remaining data read from MMC but not flushed by load_image_flush().
+	 * We take the worst case which is 2 MMC blocks.
+	 */
+	if ((image_id != FW_CONFIG_ID) &&
+	    ((bl_mem_params->image_info.h.attr & IMAGE_ATTRIB_SKIP_LOADING) == 0U)) {
+		inv_dcache_range(bl_mem_params->image_info.image_base +
+				 bl_mem_params->image_info.image_size,
+				 2U * MMC_BLOCK_SIZE);
+	}
+#endif /* STM32MP_SDMMC || STM32MP_EMMC */
+
+	return err;
+}
+
+void bl2_el3_plat_prepare_exit(void)
+{
+	stm32mp2_security_setup();
+}
diff --git a/plat/st/stm32mp2/bl31_plat_setup.c b/plat/st/stm32mp2/bl31_plat_setup.c
new file mode 100644
index 000000000..9a2e9bfa1
--- /dev/null
+++ b/plat/st/stm32mp2/bl31_plat_setup.c
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2020-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <stdint.h>
+
+#include <common/bl_common.h>
+#include <drivers/st/stm32_console.h>
+#include <lib/xlat_tables/xlat_tables_v2.h>
+#include <platform_def.h>
+
+static entry_point_info_t bl32_image_ep_info;
+static entry_point_info_t bl33_image_ep_info;
+
+void bl31_early_platform_setup2(u_register_t arg0, u_register_t arg1,
+				u_register_t arg2, u_register_t arg3)
+{
+	bl_params_t *params_from_bl2 = (bl_params_t *)arg0;
+
+	stm32mp_setup_early_console();
+
+	mmap_add_region(BL_CODE_BASE, BL_CODE_BASE,
+			BL_CODE_END - BL_CODE_BASE,
+			MT_CODE | MT_SECURE);
+
+	/*
+	 * Map non-secure device tree with secure property, i.e. default region.
+	 * DDR region definitions will be finalized at BL32 level.
+	 */
+	mmap_add_region(arg2, arg2, STM32MP_HW_CONFIG_MAX_SIZE, MT_RO_DATA | MT_SECURE);
+
+#if USE_COHERENT_MEM
+	/* Map coherent memory */
+	mmap_add_region(BL_COHERENT_RAM_BASE, BL_COHERENT_RAM_BASE,
+			BL_COHERENT_RAM_END - BL_COHERENT_RAM_BASE,
+			MT_DEVICE | MT_RW | MT_SECURE);
+#endif
+
+	configure_mmu();
+
+	assert(params_from_bl2 != NULL);
+	assert(params_from_bl2->h.type == PARAM_BL_PARAMS);
+	assert(params_from_bl2->h.version >= VERSION_2);
+
+	bl_params_node_t *bl_params = params_from_bl2->head;
+
+	while (bl_params != NULL) {
+		/*
+		 * Copy BL33 entry point information.
+		 * They are stored in Secure RAM, in BL2's address space.
+		 */
+		if (bl_params->image_id == BL33_IMAGE_ID) {
+			bl33_image_ep_info = *bl_params->ep_info;
+			/*
+			 *  Check if hw_configuration is given to BL32 and
+			 *  share it to BL33
+			 */
+			if (arg2 != 0U) {
+				bl33_image_ep_info.args.arg0 = 0U;
+				bl33_image_ep_info.args.arg1 = 0U;
+				bl33_image_ep_info.args.arg2 = arg2;
+			}
+		}
+
+		if (bl_params->image_id == BL32_IMAGE_ID) {
+			bl32_image_ep_info = *bl_params->ep_info;
+
+			if (arg2 != 0U) {
+				bl32_image_ep_info.args.arg3 = arg2;
+			}
+		}
+
+		bl_params = bl_params->next_params_info;
+	}
+
+	if (dt_open_and_check(arg2) < 0) {
+		panic();
+	}
+
+	if (stm32mp2_clk_init() < 0) {
+		panic();
+	}
+
+	(void)stm32mp_uart_console_setup();
+}
+
+void bl31_plat_arch_setup(void)
+{
+}
+
+void bl31_platform_setup(void)
+{
+	stm32mp_gic_init();
+}
+
+entry_point_info_t *bl31_plat_get_next_image_ep_info(unsigned int type)
+{
+	if (type == NON_SECURE)
+		return &bl33_image_ep_info;
+	if (type == SECURE)
+		return &bl32_image_ep_info;
+
+	return NULL;
+}
diff --git a/plat/st/stm32mp2/include/boot_api.h b/plat/st/stm32mp2/include/boot_api.h
new file mode 100644
index 000000000..fb7ea20dd
--- /dev/null
+++ b/plat/st/stm32mp2/include/boot_api.h
@@ -0,0 +1,391 @@
+/*
+ * Copyright (c) 2017-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef BOOT_API_H
+#define BOOT_API_H
+
+#include <stdint.h>
+#include <stdio.h>
+
+/*
+ * Exported constants
+ */
+
+/*
+ * Boot Context related definitions
+ */
+
+/*
+ * Possible value of boot context field 'auth_status'
+ */
+/* No authentication done */
+#define BOOT_API_CTX_AUTH_NO					0x0U
+/* Authentication done and failed */
+#define BOOT_API_CTX_AUTH_FAILED				0x1U
+/* Authentication done and succeeded */
+#define BOOT_API_CTX_AUTH_SUCCESS				0x2U
+
+/*
+ * Possible value of boot context field 'boot_interface_sel'
+ */
+
+/* Value of field 'boot_interface_sel' when no boot occurred */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_NO			0x0U
+
+/* Boot occurred on SD */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_SD		0x1U
+
+/* Boot occurred on EMMC */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_EMMC		0x2U
+
+/* Boot occurred on FMC */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_FMC		0x3U
+
+/* Boot occurred on OSPI NOR */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_SPI		0x4U
+
+/* Boot occurred on UART */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART		0x5U
+
+/* Boot occurred on USB */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB		0x6U
+
+/* Boot occurred on OSPI NAND */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_SPI		0x7U
+
+/* Boot occurred on HyperFlash QSPI  */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_HYPERFLASH_OSPI		0x8U
+
+/*
+ * Possible value of boot context field 'emmc_xfer_status'
+ */
+#define BOOT_API_CTX_EMMC_XFER_STATUS_NOT_STARTED			0x0U
+#define BOOT_API_CTX_EMMC_XFER_STATUS_DATAEND_DETECTED			0x1U
+#define BOOT_API_CTX_EMMC_XFER_STATUS_XFER_DATA_TIMEOUT			0x2U
+
+/*
+ * Possible value of boot context field 'emmc_error_status'
+ */
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_NONE                     0x0U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_CMD_TIMEOUT              0x1U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_ACK_TIMEOUT              0x2U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_DATA_CRC_FAIL            0x3U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_NOT_ENOUGH_BOOT_DATA_RX  0x4U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_HEADER_NOT_FOUND         0x5U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_HEADER_SIZE_ZERO         0x6U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_IMAGE_NOT_COMPLETE       0x7U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_ACK_ERROR		0x8U
+
+/* Definitions relative to 'p_rom_version_info->platform_type_ver' field */
+#define BOOT_API_CTX_ROM_VERSION_PLAT_VER_IC_EMU_FPGA           0xAA
+#define BOOT_API_CTX_ROM_VERSION_PLAT_VER_FPGA_ONLY             0xBB
+
+/* Image Header related definitions */
+
+/* Definition of header version */
+#define BOOT_API_HEADER_VERSION					0x00020000U
+
+/*
+ * Magic number used to detect header in memory
+ * Its value must be 'S' 'T' 'M' 0x32, i.e 0x324D5453 as field
+ * 'bootapi_image_header_t.magic'
+ * This identifies the start of a boot image.
+ */
+#define BOOT_API_IMAGE_HEADER_MAGIC_NB				0x324D5453U
+
+/* Definitions related to Authentication used in image header structure */
+#define BOOT_API_ECDSA_PUB_KEY_LEN_IN_BYTES			64
+#define BOOT_API_ECDSA_SIGNATURE_LEN_IN_BYTES			64
+#define BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES			32
+
+/* Possible values of the field 'boot_api_image_header_t.ecc_algo_type' */
+#define BOOT_API_ECDSA_ALGO_TYPE_P256NIST			1
+#define BOOT_API_ECDSA_ALGO_TYPE_BRAINPOOL256			2
+
+/*
+ * Extension headers related definitions
+ */
+/* 'bootapi_image_header_t.extension_flag' used for authentication feature */
+#define BOOT_API_AUTHENTICATION_EXTENSION_BIT			BIT(0)
+/* 'bootapi_image_header_t.extension_flag' used for FSBL decryption feature */
+#define BOOT_API_FSBL_DECRYPTION_EXTENSION_BIT			BIT(1)
+/* 'bootapi_image_header_t.extension_flag' used for padding header feature */
+#define BOOT_API_PADDING_EXTENSION_BIT				BIT(31)
+/*
+ * mask of bits of field 'bootapi_image_header_t.extension_flag'
+ * used for extension headers
+ */
+#define BOOT_API_ALL_EXTENSIONS_MASK \
+	(BOOT_API_AUTHENTICATION_EXTENSION_BIT | \
+	 BOOT_API_FSBL_DECRYPTION_EXTENSION_BIT | \
+	 BOOT_API_PADDING_EXTENSION_BIT)
+/*
+ * Magic number of FSBL decryption extension header
+ * The value shall gives the four bytes 'S','T',0x00,0x01 in memory
+ */
+#define BOOT_API_FSBL_DECRYPTION_HEADER_MAGIC_NB		0x01005453U
+
+/*
+ * Magic number of PKH revocation extension header
+ * The value shall gives the four bytes 'S','T',0x00,0x02 in memory
+ */
+#define BOOT_API_AUTHENTICATION_HEADER_MAGIC_NB			0x02005453U
+
+/* Max number of ECDSA public key hash in table */
+#define BOOT_API_AUTHENTICATION_NB_PKH_MAX			8U
+
+/* ECDSA public key hash table size in bytes */
+#define BOOT_API_AUTHENTICATION_TABLE_SIZE_BYTES \
+	(BOOT_API_AUTHENTICATION_NB_PKH_MAX * \
+	 BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES)
+
+/*
+ * Magic number of padding extension header
+ * The value shall gives the four bytes 'S','T',0xFF,0xFF in memory
+ */
+#define BOOT_API_PADDING_HEADER_MAGIC_NB			0xFFFF5453U
+
+/*
+ * Related to binaryType
+ * 0x00: U-Boot
+ * 0x10-0x1F: TF-A
+ * 0x20-0X2F: OPTEE
+ * 0x30: CM33 image
+ */
+#define BOOT_API_IMAGE_TYPE_UBOOT				0x0
+#define BOOT_API_IMAGE_TYPE_M33					0x30
+
+/*
+ * Cores secure magic numbers
+ * Constant to be stored in bakcup register
+ * BOOT_API_MAGIC_NUMBER_TAMP_BCK_REG_IDX
+ */
+#define BOOT_API_A35_CORE0_MAGIC_NUMBER				0xCA7FACE0U
+#define BOOT_API_A35_CORE1_MAGIC_NUMBER				0xCA7FACE1U
+
+/*
+ * TAMP_BCK9R register index
+ * This register is used to write a Magic Number in order to restart
+ * Cortex A35 Core 1 and make it execute @ branch address from TAMP_BCK5R
+ */
+#define BOOT_API_CORE1_MAGIC_NUMBER_TAMP_BCK_REG_IDX		9U
+
+/*
+ * TAMP_BCK10R register index
+ * This register is used to contain the branch address of
+ * Cortex A35 Core 1 when restarted by a TAMP_BCK4R magic number writing
+ */
+#define BOOT_API_CORE1_BRANCH_ADDRESS_TAMP_BCK_REG_IDX		10U
+
+/*
+ * Possible value of boot context field 'hse_clock_value_in_hz'
+ */
+#define BOOT_API_CTX_HSE_CLOCK_VALUE_UNDEFINED			0U
+#define BOOT_API_CTX_HSE_CLOCK_VALUE_19_2_MHZ			19200000U
+#define BOOT_API_CTX_HSE_CLOCK_VALUE_24_MHZ			24000000U
+#define BOOT_API_CTX_HSE_CLOCK_VALUE_25_MHZ			25000000U
+#define BOOT_API_CTX_HSE_CLOCK_VALUE_26_MHZ			26000000U
+#define BOOT_API_CTX_HSE_CLOCK_VALUE_40_MHZ			40000000U
+#define BOOT_API_CTX_HSE_CLOCK_VALUE_48_MHZ			48000000U
+
+/*
+ * Possible value of boot context field 'boot_partition_used_toboot'
+ */
+#define BOOT_API_CTX_BOOT_PARTITION_UNDEFINED			0U
+
+/* Used FSBL1 to boot */
+#define BOOT_API_CTX_BOOT_PARTITION_FSBL1			1U
+
+/* Used FSBL2 to boot */
+#define BOOT_API_CTX_BOOT_PARTITION_FSBL2			2U
+
+#define BOOT_API_RETURN_OK					0x66U
+
+/*
+ * Possible values of boot context field
+ * 'ssp_config_ptr_in->ssp_cmd'
+ */
+/* 'K' 'B' 'U' 'P' -.> 'PUBK' */
+#define BOOT_API_CTX_SSP_CMD_CALC_CHIP_PUBK			0x4B425550
+
+/*
+ * Exported types
+ */
+
+/* SSP Configuration structure */
+typedef struct {
+	/* SSP Command*/
+	uint32_t ssp_cmd;
+	uint8_t	reserved[36];
+} boot_api_ssp_config_t;
+
+/*
+ * bootROM version information structure definition
+ * Total size = 24 bytes = 6 uint32_t
+ */
+typedef struct {
+	/* Chip Version */
+	uint32_t chip_ver;
+
+	/* Cut version within a fixed chip version */
+	uint32_t cut_ver;
+
+	/* Version of ROM Mask within a fixed cut version */
+	uint32_t rom_mask_ver;
+
+	/* Internal Version of bootROM code */
+	uint32_t bootrom_ver;
+
+	/* Version of bootROM adapted */
+	uint32_t for_chip_design_rtl_ver;
+
+	/* Restriction on compiled platform when it applies */
+	uint32_t platform_type_ver;
+} boot_api_rom_version_info_t;
+
+/*
+ * Boot Context related definitions
+ */
+
+/*
+ * Boot core boot configuration structure
+ * Specifies all items of the secure boot configuration
+ * Memory and peripheral part.
+ */
+typedef struct {
+	/* Boot partition: ie FSBL partition on which the boot was successful */
+	uint32_t boot_partition_used_toboot;
+
+	/*
+	 * Address of SSP configuration structure :
+	 * given and defined by bootROM
+	 * and used by FSBL. The structure is of type
+	 * 'boot_api_ssp_config_t'
+	 */
+	boot_api_ssp_config_t *p_ssp_config;
+	/*
+	 * Boot context field containing bootROM updated SSP Status
+	 * Values can be of type BOOT_API_CTX_SSP_STATUS_XXX
+	 */
+	uint32_t	ssp_status;
+
+	/*
+	 * Information specific to an SD boot
+	 * Updated each time an SD boot is at least attempted,
+	 * even if not successful
+	 * Note : This is useful to understand why an SD boot failed
+	 * in particular
+	 */
+	uint32_t sd_err_internal_timeout_cnt;
+	uint32_t sd_err_dcrc_fail_cnt;
+	uint32_t sd_err_dtimeout_cnt;
+	uint32_t sd_err_ctimeout_cnt;
+	uint32_t sd_err_ccrc_fail_cnt;
+	uint32_t sd_overall_retry_cnt;
+	/*
+	 * Information specific to an eMMC boot
+	 * Updated each time an eMMC boot is at least attempted,
+	 * even if not successful
+	 * Note : This is useful to understand why an eMMC boot failed
+	 * in particular
+	 */
+	uint32_t emmc_xfer_status;
+	uint32_t emmc_error_status;
+	uint32_t emmc_nbbytes_rxcopied_tosysram_download_area;
+
+	uint32_t reserved[4];
+	/*
+	 * Boot interface used to boot : take values from defines
+	 * BOOT_API_CTX_BOOT_INTERFACE_SEL_XXX above
+	 */
+	uint16_t boot_interface_selected;
+	uint16_t boot_interface_instance;
+
+	uint32_t hse_clock_value_in_hz;
+
+	uint32_t nand_fsbl_first_block;
+
+	/*
+	 * Returned authentication status : take values from defines
+	 * BOOT_API_CTX_AUTH_XXX above
+	 */
+	uint32_t auth_status;
+
+	/* Pointer on ROM constant containing ROM information */
+	const boot_api_rom_version_info_t *p_rom_version_info;
+} __packed boot_api_context_t;
+
+/*
+ * Image Header related definitions
+ */
+
+/*
+ * Structure used to define the common Header format used for FSBL, xloader,
+ * ... and in particular used by bootROM for FSBL header readout.
+ * FSBL header size is 256 Bytes = 0x100
+ */
+typedef struct {
+	/* BOOT_API_IMAGE_HEADER_MAGIC_NB */
+	uint32_t magic;
+	uint8_t image_signature[BOOT_API_ECDSA_SIGNATURE_LEN_IN_BYTES];
+	/*
+	 * Checksum of payload
+	 * 32-bit sum all payload bytes considered as 8 bit unsigned
+	 * numbers, discarding any overflow bits.
+	 * Use to check UART/USB downloaded image integrity when signature
+	 * is not used
+	 */
+	uint32_t payload_checksum;
+	/* Image header version : should have value BOOT_API_HEADER_VERSION */
+	uint32_t header_version;
+	/* Image length in bytes */
+	uint32_t image_length;
+	/*
+	 * Image Entry point address : should be in the SYSRAM area
+	 * and at least within the download area range
+	 */
+	uint32_t image_entry_point;
+	/* Reserved */
+	uint32_t reserved1;
+	/*
+	 * Image load address : not used by bootROM but to be consistent
+	 * with header format for other packages (xloader, ...)
+	 */
+	uint32_t load_address;
+	/* Reserved */
+	uint32_t reserved2;
+	/* Image version to be compared by bootROM with FSBL_A or FSBL_M version
+	 * counter value in OTP prior executing the downloaded image
+	 */
+	uint32_t image_version;
+	/*
+	 * Option flags:
+	 * Bit 0 : No signature check request : 'No_sig_check'
+	 *      value 1 : for No signature check request
+	 *      value 0 : No request to bypass the signature check
+	 * Note : No signature check is never allowed on a Secured chip
+	 */
+	uint32_t option_flags;
+	/*
+	 * Type of ECC algorithm to use  :
+	 * value 1 : for P-256 NIST algorithm
+	 * value 2 : for Brainpool 256 algorithm
+	 * See definitions 'BOOT_API_ECDSA_ALGO_TYPE_XXX' above.
+	 */
+	uint32_t ecc_algo_type;
+	/*
+	 * OEM ECC Public Key (aka Root pubk) provided in header on 512 bits.
+	 * The SHA-256 hash of the OEM ECC pubk must match the one stored
+	 * in OTP cells.
+	 */
+	uint8_t ecc_pubk[BOOT_API_ECDSA_PUB_KEY_LEN_IN_BYTES];
+	/* Pad up to 256 byte total size */
+	uint8_t pad[83];
+	/* Add binary type information */
+	uint8_t binary_type;
+} __packed boot_api_image_header_t;
+
+#endif /* BOOT_API_H */
diff --git a/plat/st/stm32mp2/include/plat_def_fip_uuid.h b/plat/st/stm32mp2/include/plat_def_fip_uuid.h
new file mode 100644
index 000000000..677e54c81
--- /dev/null
+++ b/plat/st/stm32mp2/include/plat_def_fip_uuid.h
@@ -0,0 +1,15 @@
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef PLAT_DEF_FIP_UUID_H
+#define PLAT_DEF_FIP_UUID_H
+
+#define UUID_DDR_FW \
+	{{0xb1, 0x12, 0x49, 0xbe}, {0x92, 0xdd}, {0x4b, 0x10}, 0x86, 0x7c, \
+	 {0x2c, 0x6a, 0x4b, 0x47, 0xa7, 0xfb} }
+
+#endif /* PLAT_DEF_FIP_UUID_H */
+
diff --git a/plat/st/stm32mp2/include/plat_macros.S b/plat/st/stm32mp2/include/plat_macros.S
new file mode 100644
index 000000000..11b8edb7e
--- /dev/null
+++ b/plat/st/stm32mp2/include/plat_macros.S
@@ -0,0 +1,13 @@
+/*
+ * Copyright (c) 2018, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef PLAT_MACROS_S
+#define PLAT_MACROS_S
+
+	.macro plat_crash_print_regs
+	.endm
+
+#endif /* PLAT_MACROS_S */
diff --git a/plat/st/stm32mp2/include/plat_tbbr_img_def.h b/plat/st/stm32mp2/include/plat_tbbr_img_def.h
new file mode 100644
index 000000000..98604861e
--- /dev/null
+++ b/plat/st/stm32mp2/include/plat_tbbr_img_def.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef PLAT_TBBR_IMG_DEF_H
+#define PLAT_TBBR_IMG_DEF_H
+
+#include <export/common/tbbr/tbbr_img_def_exp.h>
+
+#if STM32MP_DDR_FIP_IO_STORAGE
+#define DDR_FW_ID		MAX_IMG_IDS_WITH_SPMDS
+#define MAX_IMG_WITH_DDR_IDS	MAX_IMG_IDS_WITH_SPMDS + 1
+#else
+#define MAX_IMG_WITH_DDR_IDS	MAX_IMG_IDS_WITH_SPMDS
+#endif
+
+#define MAX_NUMBER_IDS		MAX_IMG_WITH_DDR_IDS
+
+#endif /* PLAT_TBBR_IMG_DEF_H */
+
diff --git a/plat/st/stm32mp2/include/platform_def.h b/plat/st/stm32mp2/include/platform_def.h
new file mode 100644
index 000000000..b8525441b
--- /dev/null
+++ b/plat/st/stm32mp2/include/platform_def.h
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) 2018-2021, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef PLATFORM_DEF_H
+#define PLATFORM_DEF_H
+
+#include <arch.h>
+#include <drivers/arm/gic_common.h>
+#include <lib/utils_def.h>
+#include <plat/common/common_def.h>
+
+#include "../stm32mp2_def.h"
+
+/*******************************************************************************
+ * Generic platform constants
+ ******************************************************************************/
+
+/* Size of cacheable stacks */
+#define PLATFORM_STACK_SIZE		0xC00
+
+#define FIP_IMAGE_NAME			"fip"
+
+#define STM32MP_PRIMARY_CPU		U(0x0)
+#define STM32MP_SECONDARY_CPU		U(0x1)
+
+#define PLATFORM_CLUSTER_COUNT		U(1)
+#define PLATFORM_CLUSTER0_CORE_COUNT	U(2)
+#define PLATFORM_CLUSTER1_CORE_COUNT	U(0)
+#define PLATFORM_CORE_COUNT		(PLATFORM_CLUSTER1_CORE_COUNT + \
+					 PLATFORM_CLUSTER0_CORE_COUNT)
+#define PLATFORM_MAX_CPUS_PER_CLUSTER	2
+
+#define MAX_IO_DEVICES			U(4)
+#define MAX_IO_HANDLES			U(4)
+#define MAX_IO_BLOCK_DEVICES		U(1)
+#define MAX_IO_MTD_DEVICES		U(1)
+
+/*******************************************************************************
+ * BL2 specific defines.
+ ******************************************************************************/
+/*
+ * Put BL2 just below BL3-1. BL2_BASE is calculated using the current BL2 debug
+ * size plus a little space for growth.
+ */
+#define BL2_BASE			STM32MP_BL2_BASE
+#define BL2_LIMIT			(STM32MP_BL2_BASE + \
+					 STM32MP_BL2_SIZE)
+
+#define BL2_RO_BASE			STM32MP_BL2_RO_BASE
+#define BL2_RO_LIMIT			(STM32MP_BL2_RO_BASE + \
+					 STM32MP_BL2_RO_SIZE)
+
+#define BL2_RW_BASE			STM32MP_BL2_RW_BASE
+#define BL2_RW_LIMIT			(STM32MP_BL2_RW_BASE + \
+					 STM32MP_BL2_RW_SIZE)
+
+/*******************************************************************************
+ * BL31 specific defines.
+ ******************************************************************************/
+#define BL31_BASE			0
+#define BL31_LIMIT			STM32MP_BL31_SIZE
+
+/*******************************************************************************
+ * BL33 specific defines.
+ ******************************************************************************/
+#define BL33_BASE			STM32MP_BL33_BASE
+
+/*
+ * Load address of BL33 for this platform port
+ */
+#define PLAT_STM32MP_NS_IMAGE_OFFSET	BL33_BASE
+
+/* Needed by STM32CubeProgrammer support */
+#define DWL_BUFFER_SIZE			U(0x01000000)
+#if STM32MP_DDR_FIP_IO_STORAGE
+#define DWL_DDR_BUFFER_BASE		SRAM2_BASE
+#define DWL_DDR_BUFFER_SIZE		SRAM2_SIZE
+#endif
+
+/*
+ * SSBL offset in case it's stored in eMMC boot partition.
+ * We can fix it to 256K because TF-A size can't be bigger than SRAM
+ */
+#define PLAT_EMMC_BOOT_SSBL_OFFSET		U(0x40000)
+
+/*******************************************************************************
+ * DTB specific defines.
+ ******************************************************************************/
+#define DTB_BASE			STM32MP_DTB_BASE
+#define DTB_LIMIT			(STM32MP_DTB_BASE + \
+					 STM32MP_DTB_SIZE)
+
+/*******************************************************************************
+ * Platform specific page table and MMU setup constants
+ ******************************************************************************/
+#define PLAT_PHY_ADDR_SPACE_SIZE	(ULL(1) << 32)
+#define PLAT_VIRT_ADDR_SPACE_SIZE	(ULL(1) << 32)
+
+/*******************************************************************************
+ * Declarations and constants to access the mailboxes safely. Each mailbox is
+ * aligned on the biggest cache line size in the platform. This is known only
+ * to the platform as it might have a combination of integrated and external
+ * caches. Such alignment ensures that two maiboxes do not sit on the same cache
+ * line at any cache level. They could belong to different cpus/clusters &
+ * get written while being protected by different locks causing corruption of
+ * a valid mailbox address.
+ ******************************************************************************/
+#define CACHE_WRITEBACK_SHIFT		6
+#define CACHE_WRITEBACK_GRANULE		(U(1) << CACHE_WRITEBACK_SHIFT)
+
+/*
+ * Secure Interrupt: based on the standard ARM mapping
+ */
+#define ARM_IRQ_SEC_PHY_TIMER		U(29)
+
+#define ARM_IRQ_NON_SEC_SGI_0		U(0)
+
+#define ARM_IRQ_SEC_SGI_0		U(8)
+#define ARM_IRQ_SEC_SGI_1		U(9)
+#define ARM_IRQ_SEC_SGI_2		U(10)
+#define ARM_IRQ_SEC_SGI_3		U(11)
+#define ARM_IRQ_SEC_SGI_4		U(12)
+#define ARM_IRQ_SEC_SGI_5		U(13)
+#define ARM_IRQ_SEC_SGI_6		U(14)
+#define ARM_IRQ_SEC_SGI_7		U(15)
+
+/* Platform IRQ Priority */
+#define STM32MP_IRQ_SEC_SPI_PRIO	U(0x10)
+
+/*
+ * Define a list of Group 1 Secure and Group 0 interrupts as per GICv3
+ * terminology. On a GICv2 system or mode, the lists will be merged and treated
+ * as Group 0 interrupts.
+ */
+#define PLATFORM_G1S_PROPS(grp) \
+	INTR_PROP_DESC(ARM_IRQ_SEC_PHY_TIMER,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       (grp), GIC_INTR_CFG_LEVEL),	\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_1,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       (grp), GIC_INTR_CFG_EDGE),	\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_2,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       (grp), GIC_INTR_CFG_EDGE),	\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_3,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       (grp), GIC_INTR_CFG_EDGE),	\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_4,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       (grp), GIC_INTR_CFG_EDGE),	\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_5,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       (grp), GIC_INTR_CFG_EDGE),	\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_7,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       (grp), GIC_INTR_CFG_EDGE)
+
+#define PLATFORM_G0_PROPS(grp) \
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_0,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       (grp), GIC_INTR_CFG_EDGE),	\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_6,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       (grp), GIC_INTR_CFG_EDGE)
+
+/*
+ * Power
+ */
+#define PLAT_MAX_PWR_LVL	U(1)
+
+/* Local power state for power domains in Run state. */
+#define ARM_LOCAL_STATE_RUN	U(0)
+/* Local power state for retention. Valid only for CPU power domains */
+#define ARM_LOCAL_STATE_RET	U(1)
+/* Local power state for power-down. Valid for CPU and cluster power domains */
+#define ARM_LOCAL_STATE_OFF	U(2)
+/*
+ * This macro defines the deepest retention state possible.
+ * A higher state id will represent an invalid or a power down state.
+ */
+#define PLAT_MAX_RET_STATE		ARM_LOCAL_STATE_RET
+/*
+ * This macro defines the deepest power down states possible. Any state ID
+ * higher than this is invalid.
+ */
+#define PLAT_MAX_OFF_STATE		ARM_LOCAL_STATE_OFF
+
+#endif /* PLATFORM_DEF_H */
diff --git a/plat/st/stm32mp2/include/stm32mp2_private.h b/plat/st/stm32mp2/include/stm32mp2_private.h
new file mode 100644
index 000000000..638e62dbf
--- /dev/null
+++ b/plat/st/stm32mp2/include/stm32mp2_private.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2018-2022, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_PRIVATE_H
+#define STM32MP2_PRIVATE_H
+
+void configure_mmu(void);
+
+void stm32mp2_arch_security_setup(void);
+void stm32mp2_security_setup(void);
+
+uint32_t stm32mp2_syscfg_get_chip_version(void);
+uint32_t stm32mp2_syscfg_get_chip_dev_id(void);
+size_t stm32mp2_syscfg_get_mm_size(uint8_t bank);
+
+/* IO compensation identifiers */
+enum syscfg_io_ids {
+	SYSFG_VDDIO1_ID,
+	SYSFG_VDDIO2_ID,
+	SYSFG_VDDIO3_ID,
+	SYSFG_VDDIO4_ID,
+	SYSFG_VDD_IO_ID,
+	SYSFG_NB_IO_ID
+};
+
+void stm32mp2_syscfg_enable_io_compensation(enum syscfg_io_ids id);
+
+void stm32mp2_syscfg_set_icn_qos(void);
+
+int stm32mp2_pwr_init_io_domains(void);
+
+/* Get RISAF platform instance ID from peripheral IO memory base address */
+int stm32_risaf_get_instance(uintptr_t base);
+
+/* Get RISAF peripheral IO memory base address from platform instance ID */
+uintptr_t stm32_risaf_get_base(int instance);
+
+/* Get RISAF maximum number of regions from platform instance ID */
+int stm32_risaf_get_max_region(int instance);
+
+/* Get RISAF memory base address from platform instance ID */
+uintptr_t stm32_risaf_get_memory_base(int instance);
+
+/* Get RISAF memory size in bytes from platform instance ID */
+uint32_t stm32_risaf_get_memory_size(int instance);
+
+/* RISAF preconf process for all instance devices */
+void stm32_risaf_preconf_process(uint32_t inst_mask);
+
+/* RISAF postconf process for all instance devices */
+void stm32_risaf_postconf_process(uint32_t inst_mask);
+
+/* Get DDRDBG peripheral IO memory base address */
+uintptr_t stm32_ddrdbg_get_base(void);
+
+#endif /* STM32MP2_PRIVATE_H */
diff --git a/plat/st/stm32mp2/include/stm32mp2_smc.h b/plat/st/stm32mp2/include/stm32mp2_smc.h
new file mode 100644
index 000000000..56f0304fa
--- /dev/null
+++ b/plat/st/stm32mp2/include/stm32mp2_smc.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_SMC_H
+#define STM32MP2_SMC_H
+
+#define STM32_COMMON_SIP_NUM_CALLS			1U
+
+/*
+ * STM32_SIP_SMC_STGEN_SET_RATE call API
+ * This service is opened to secure world only.
+ *
+ * Argument a0: (input) SMCC ID
+ *		(output) status return code
+ * Argument a1: (input) Frequency to set (given by sender)
+ */
+#define STM32_SIP_SMC_STGEN_SET_RATE                    0x82000000
+
+#endif /* STM32MP2_SMC_H */
diff --git a/plat/st/stm32mp1/plat_bl2_stm32_mem_params_desc.c b/plat/st/stm32mp2/plat_bl2_mem_params_desc.c
similarity index 55%
rename from plat/st/stm32mp1/plat_bl2_stm32_mem_params_desc.c
rename to plat/st/stm32mp2/plat_bl2_mem_params_desc.c
index 4fce55a9e..e3dcacd33 100644
--- a/plat/st/stm32mp1/plat_bl2_stm32_mem_params_desc.c
+++ b/plat/st/stm32mp2/plat_bl2_mem_params_desc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2018-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -19,33 +19,72 @@
  * the next executable image id.
  ******************************************************************************/
 static bl_mem_params_node_t bl2_mem_params_descs[] = {
-	/* Fill BL32 related information */
+#if STM32MP_DDR_FIP_IO_STORAGE
+	/* Fill FW_DDR related information if it exists */
 	{
-		.image_id = BL32_IMAGE_ID,
+		.image_id = DDR_FW_ID,
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_IMAGE_BINARY,
+				      VERSION_2, entry_point_info_t,
+				      SECURE | NON_EXECUTABLE),
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_IMAGE_BINARY,
+				      VERSION_2, image_info_t,
+				      0),
+
+		.image_info.image_base = STM32MP_DDR_FW_BASE,
+		.image_info.image_max_size = STM32MP_DDR_FW_MAX_SIZE,
+
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	},
+#endif
+
+	/* Fill FW_CONFIG related information if it exists */
+	{
+		.image_id = FW_CONFIG_ID,
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_IMAGE_BINARY,
+				      VERSION_2, entry_point_info_t,
+				      SECURE | NON_EXECUTABLE),
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_IMAGE_BINARY,
+				      VERSION_2, image_info_t,
+				      IMAGE_ATTRIB_PLAT_SETUP),
+
+		.image_info.image_base = STM32MP_FW_CONFIG_BASE,
+		.image_info.image_max_size = STM32MP_FW_CONFIG_MAX_SIZE,
+
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	},
+
+	/* Fill BL31 related information */
+	{
+		.image_id = BL31_IMAGE_ID,
 
 		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP,
 				      VERSION_2, entry_point_info_t,
 				      SECURE | EXECUTABLE | EP_FIRST_EXE),
 
-		/* Updated at runtime if OP-TEE is loaded */
-		.ep_info.pc = STM32MP_BL32_BASE,
-
-		.ep_info.spsr = SPSR_MODE32(MODE32_svc, SPSR_T_ARM,
-					    SPSR_E_LITTLE,
-					    DISABLE_ALL_EXCEPTIONS),
+		.ep_info.spsr = SPSR_64(MODE_EL3, MODE_SP_ELX, DISABLE_ALL_EXCEPTIONS),
 
 		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP,
 				      VERSION_2, image_info_t,
-				      IMAGE_ATTRIB_PLAT_SETUP),
+				      IMAGE_ATTRIB_SKIP_LOADING),
 
-		/* Updated at runtime if OP-TEE is loaded */
-		.image_info.image_base = STM32MP_BL32_BASE,
-		.image_info.image_max_size = STM32MP_BL32_SIZE,
+		.next_handoff_image_id = BL32_IMAGE_ID,
+	},
+
+	/* Fill BL32 related information */
+	{
+		.image_id = BL32_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP,
+				      VERSION_2, entry_point_info_t,
+				      SECURE | EXECUTABLE),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP,
+				      VERSION_2, image_info_t,
+				      IMAGE_ATTRIB_SKIP_LOADING),
 
 		.next_handoff_image_id = BL33_IMAGE_ID,
 	},
 
-#if defined(AARCH32_SP_OPTEE)
 	/* Fill BL32 external 1 image related information */
 	{
 		.image_id = BL32_EXTRA1_IMAGE_ID,
@@ -60,21 +99,21 @@ static bl_mem_params_node_t bl2_mem_params_descs[] = {
 
 		.next_handoff_image_id = INVALID_IMAGE_ID,
 	},
-	/* Fill BL32 external 2 image related information */
+
+	/* Fill HW_CONFIG related information if it exists */
 	{
-		.image_id = BL32_EXTRA2_IMAGE_ID,
+		.image_id = HW_CONFIG_ID,
 
-		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP,
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_IMAGE_BINARY,
 				      VERSION_2, entry_point_info_t,
-				      SECURE | NON_EXECUTABLE),
+				      NON_SECURE | NON_EXECUTABLE),
 
-		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP,
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_IMAGE_BINARY,
 				      VERSION_2, image_info_t,
 				      IMAGE_ATTRIB_SKIP_LOADING),
 
 		.next_handoff_image_id = INVALID_IMAGE_ID,
 	},
-#endif /* AARCH32_SP_OPTEE */
 
 	/* Fill BL33 related information */
 	{
@@ -84,17 +123,11 @@ static bl_mem_params_node_t bl2_mem_params_descs[] = {
 				      VERSION_2, entry_point_info_t,
 				      NON_SECURE | EXECUTABLE),
 
-		.ep_info.pc = PLAT_STM32MP_NS_IMAGE_OFFSET,
-		.ep_info.spsr = SPSR_MODE32(MODE32_svc, SPSR_T_ARM,
-					    SPSR_E_LITTLE,
-					    DISABLE_ALL_EXCEPTIONS),
+		.ep_info.spsr = SPSR_64(MODE_EL1, MODE_SP_ELX, DISABLE_ALL_EXCEPTIONS),
 
 		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP,
-				      VERSION_2, image_info_t, 0U),
-
-		.image_info.image_base = PLAT_STM32MP_NS_IMAGE_OFFSET,
-		.image_info.image_max_size = STM32MP_DDR_MAX_SIZE -
-			(PLAT_STM32MP_NS_IMAGE_OFFSET - STM32MP_DDR_BASE),
+				      VERSION_2, image_info_t,
+				      IMAGE_ATTRIB_SKIP_LOADING),
 
 		.next_handoff_image_id = INVALID_IMAGE_ID,
 	}
diff --git a/plat/st/stm32mp2/plat_image_load.c b/plat/st/stm32mp2/plat_image_load.c
new file mode 100644
index 000000000..e6eda870b
--- /dev/null
+++ b/plat/st/stm32mp2/plat_image_load.c
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2018-2020, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/bl_common.h>
+#include <common/desc_image_load.h>
+#include <plat/common/platform.h>
+
+/*******************************************************************************
+ * This function flushes the data structures so that they are visible
+ * in memory for the next BL image.
+ ******************************************************************************/
+void plat_flush_next_bl_params(void)
+{
+	flush_bl_params_desc();
+}
+
+/*******************************************************************************
+ * This function returns the list of loadable images.
+ ******************************************************************************/
+bl_load_info_t *plat_get_bl_image_load_info(void)
+{
+	return get_bl_load_info_from_mem_params_desc();
+}
+
+/*******************************************************************************
+ * This function returns the list of executable images.
+ ******************************************************************************/
+bl_params_t *plat_get_next_bl_params(void)
+{
+	bl_params_t *bl_params = get_next_bl_params_from_mem_params_desc();
+
+	populate_next_bl_params_config(bl_params);
+
+	return bl_params;
+}
diff --git a/plat/st/stm32mp2/platform.mk b/plat/st/stm32mp2/platform.mk
new file mode 100644
index 000000000..086dab363
--- /dev/null
+++ b/plat/st/stm32mp2/platform.mk
@@ -0,0 +1,288 @@
+#
+# Copyright (c) 2018-2022, ARM Limited and Contributors. All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+include plat/st/common/common.mk
+
+CRASH_REPORTING		:=	1
+ENABLE_PIE		:=	1
+
+# Default Device tree
+DTB_FILE_NAME		?=	stm32mp257f-ev.dtb
+
+STM32MP25		:=	1
+
+# STM32 image header version v2.0
+STM32_HEADER_VERSION_MAJOR:=	2
+STM32_HEADER_VERSION_MINOR:=	0
+
+# Number of TF-A copies in the device
+STM32_TF_A_COPIES		:=	2
+
+# PLAT_PARTITION_MAX_ENTRIES must take care of STM32_TF-A_COPIES and other partitions
+# such as metadata (2) and fsbl-m (2) to find all the FIP partitions (default is 2).
+PLAT_PARTITION_MAX_ENTRIES	:=	$(shell echo $$(($(STM32_TF_A_COPIES) + 6)))
+
+ifeq (${PSA_FWU_SUPPORT},1)
+# Number of banks of updatable firmware
+NR_OF_FW_BANKS			:=	2
+NR_OF_IMAGES_IN_FW_BANK		:=	1
+
+FWU_MAX_PART = $(shell echo $$(($(STM32_TF_A_COPIES) + 2 + $(NR_OF_FW_BANKS))))
+ifeq ($(shell test $(FWU_MAX_PART) -gt $(PLAT_PARTITION_MAX_ENTRIES); echo $$?),0)
+$(error "Required partition number is $(FWU_MAX_PART) where PLAT_PARTITION_MAX_ENTRIES is only \
+$(PLAT_PARTITION_MAX_ENTRIES)")
+endif
+endif
+
+# Download load address for serial boot devices
+DWL_BUFFER_BASE 	?=	0x87000000
+
+# DDR types
+STM32MP_DDR3_TYPE	?=	0
+STM32MP_DDR4_TYPE	?=	0
+STM32MP_LPDDR4_TYPE	?=	0
+ifeq (${STM32MP_DDR3_TYPE},1)
+DDR_TYPE		:=	ddr3
+endif
+ifeq (${STM32MP_DDR4_TYPE},1)
+DDR_TYPE		:=	ddr4
+endif
+ifeq (${STM32MP_LPDDR4_TYPE},1)
+DDR_TYPE		:=	lpddr4
+endif
+
+# DDR features
+STM32MP_DDR_DUAL_AXI_PORT	:=	1
+STM32MP_DDR_FIP_IO_STORAGE	:=	1
+
+# Device tree
+BL2_DTSI		:=	stm32mp25-bl2.dtsi
+FDT_SOURCES		:=	$(addprefix ${BUILD_PLAT}/fdts/, $(patsubst %.dtb,%-bl2.dts,$(DTB_FILE_NAME)))
+
+# Macros and rules to build TF binary
+STM32_TF_STM32		:=	$(addprefix ${BUILD_PLAT}/tf-a-, $(patsubst %.dtb,%.stm32,$(DTB_FILE_NAME)))
+STM32_LD_FILE		:=	plat/st/stm32mp2/${ARCH}/stm32mp2.ld.S
+STM32_BINARY_MAPPING	:=	plat/st/stm32mp2/${ARCH}/stm32mp2.S
+
+STM32MP_FW_CONFIG_NAME	:=	$(patsubst %.dtb,%-fw-config.dtb,$(DTB_FILE_NAME))
+STM32MP_FW_CONFIG	:=	${BUILD_PLAT}/fdts/$(STM32MP_FW_CONFIG_NAME)
+ifeq (${STM32MP_DDR_FIP_IO_STORAGE},1)
+STM32MP_DDR_FW_NAME	:=	${DDR_TYPE}_pmu_train.bin
+STM32MP_DDR_FW		:=	drivers/st/ddr/phy/firmware/bin/${STM32MP_DDR_FW_NAME}
+endif
+FDT_SOURCES		+=	$(addprefix fdts/, $(patsubst %.dtb,%.dts,$(STM32MP_FW_CONFIG_NAME)))
+# Add the FW_CONFIG to FIP and specify the same to certtool
+$(eval $(call TOOL_ADD_PAYLOAD,${STM32MP_FW_CONFIG},--fw-config))
+ifeq (${STM32MP_DDR_FIP_IO_STORAGE},1)
+# Add the FW_DDR to FIP and specify the same to certtool
+$(eval $(call TOOL_ADD_IMG,STM32MP_DDR_FW,--ddr-fw))
+endif
+
+# Enable flags for C files
+$(eval $(call assert_booleans,\
+	$(sort \
+		CFG_DT \
+		STM32MP_DDR_DUAL_AXI_PORT \
+		STM32MP_DDR_FIP_IO_STORAGE \
+		STM32MP_DDR3_TYPE \
+		STM32MP_DDR4_TYPE \
+		STM32MP_LPDDR4_TYPE \
+		STM32MP25 \
+)))
+
+$(eval $(call assert_numerics,\
+	$(sort \
+		PLAT_PARTITION_MAX_ENTRIES \
+		STM32_TF_A_COPIES \
+)))
+
+$(eval $(call add_defines,\
+	$(sort \
+		CFG_DT \
+		DWL_BUFFER_BASE \
+		PLAT_PARTITION_MAX_ENTRIES \
+		STM32_TF_A_COPIES \
+		STM32MP_DDR_DUAL_AXI_PORT \
+		STM32MP_DDR_FIP_IO_STORAGE \
+		STM32MP_DDR3_TYPE \
+		STM32MP_DDR4_TYPE \
+		STM32MP_LPDDR4_TYPE \
+		STM32MP25 \
+)))
+
+ifeq (${STM32MP_DDR_FIP_IO_STORAGE},1)
+$(eval $(call add_define,PLAT_TBBR_IMG_DEF))
+$(eval $(call add_define,PLAT_DEF_FIP_UUID))
+endif
+
+$(eval $(call add_define,CFG_WORKAROUND_VSW0V8))
+
+# Include paths and source files
+PLAT_INCLUDES		+=	-Iplat/st/stm32mp2/include/
+PLAT_INCLUDES		+=	-Idrivers/st/ddr/phy/phyinit/include/
+PLAT_INCLUDES		+=	-Idrivers/st/ddr/phy/firmware/include/
+
+ifeq (${STM32MP_DDR_FIP_IO_STORAGE},1)
+$(shell cp tools/st/plat_fiptool/plat_fiptool.mk ${PLAT_DIR})
+endif
+
+PLAT_BL_COMMON_SOURCES	+=	plat/st/stm32mp2/stm32mp2_private.c
+
+PLAT_BL_COMMON_SOURCES	+=	drivers/st/uart/${ARCH}/stm32_console.S
+
+PLAT_BL_COMMON_SOURCES	+=	lib/cpus/${ARCH}/cortex_a35.S
+
+PLAT_BL_COMMON_SOURCES	+=	drivers/st/bsec/bsec3.c					\
+				drivers/st/iwdg/stm32_iwdg.c				\
+				drivers/st/reset/stm32mp2_reset.c			\
+				plat/st/stm32mp2/${ARCH}/stm32mp2_helper.S		\
+				plat/st/stm32mp2/stm32mp2_syscfg.c			\
+				plat/st/stm32mp2/stm32mp2_pwr.c
+
+PLAT_BL_COMMON_SOURCES	+=	drivers/st/clk/clk-stm32-core.c				\
+				drivers/st/clk/stm32mp2_clk.c				\
+				drivers/st/rng/stm32_rng.c
+
+BL2_SOURCES		+=	plat/st/stm32mp2/plat_bl2_mem_params_desc.c		\
+				plat/st/stm32mp2/stm32mp2_fconf_firewall.c
+
+BL2_SOURCES		+=	plat/st/stm32mp2/bl2_plat_setup.c
+
+BL2_SOURCES		+=	drivers/st/rif/stm32mp2_risaf.c
+
+ifeq (${TRUSTED_BOARD_BOOT},1)
+AUTH_SOURCES		:=	drivers/auth/auth_mod.c					\
+				drivers/auth/crypto_mod.c				\
+				drivers/auth/img_parser_mod.c
+
+include drivers/auth/mbedtls/mbedtls_x509.mk
+
+AUTH_SOURCES		+=	drivers/auth/tbbr/tbbr_cot_common.c			\
+				plat/st/common/stm32mp_crypto_lib.c
+
+BL2_SOURCES		+=	$(AUTH_SOURCES)						\
+				plat/st/common/stm32mp_trusted_boot.c
+endif
+
+ifneq ($(filter 1,${STM32MP_EMMC} ${STM32MP_SDMMC}),)
+BL2_SOURCES		+=	drivers/st/mmc/stm32_sdmmc2.c
+endif
+
+ifeq (${STM32MP_RAW_NAND},1)
+BL2_SOURCES		+=	drivers/st/fmc/stm32_fmc2_nand.c
+endif
+
+ifneq ($(filter 1,${STM32MP_SPI_NAND} ${STM32MP_SPI_NOR}),)
+BL2_SOURCES		+=	drivers/st/spi/stm32_ospi.c
+endif
+
+ifneq ($(filter 1,${STM32MP_RAW_NAND} ${STM32MP_SPI_NAND} ${STM32MP_SPI_NOR}),)
+BL2_SOURCES		+=	plat/st/stm32mp2/stm32mp2_boot_device.c
+endif
+
+ifeq (${STM32MP_UART_PROGRAMMER},1)
+BL2_SOURCES		+=	drivers/st/uart/stm32_uart.c
+endif
+
+ifeq (${STM32MP_USB_PROGRAMMER},1)
+#The DFU stack uses only one end point, reduce the USB stack footprint
+$(eval $(call add_define_val,CONFIG_USBD_EP_NB,1U))
+$(eval $(call add_define,USB_CORE_AVOID_PACKET_SPLIT_MPS))
+BL2_SOURCES		+=	drivers/st/usb_dwc3/usb_dwc3.c				\
+				plat/st/stm32mp2/stm32mp2_usb_dfu.c
+endif
+
+BL2_SOURCES		+=	drivers/st/ddr/stm32mp2_ddr.c				\
+				drivers/st/ddr/stm32mp2_ddr_helpers.c			\
+				drivers/st/ddr/stm32mp2_ram.c
+
+BL2_SOURCES		+=	drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_c_initphyconfig.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_calcmb.c					\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_globals.c					\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_i_loadpieimage.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_initstruct.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_isdbytedisabled.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_loadpieprodcode.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_mapdrvstren.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_progcsrskiptrain.c			\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_reginterface.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_restore_sequence.c			\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_sequence.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_softsetmb.c				\
+				drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_customposttrain.c	\
+				drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_custompretrain.c	\
+				drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_saveretregs.c
+
+BL2_SOURCES		+=	drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_d_loadimem.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_f_loaddmem.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_g_execfw.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_h_readmsgblock.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_storemsgblk.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_writeoutmem.c				\
+				drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_h_readmsgblock.c 	\
+				drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_g_waitfwdone.c
+
+BL2_SOURCES		+=	plat/st/stm32mp2/plat_image_load.c
+
+# BL31 sources
+BL31_SOURCES		+=	${FDT_WRAPPERS_SOURCES}
+
+BL31_SOURCES		+=	plat/st/stm32mp2/bl31_plat_setup.c			\
+				plat/st/stm32mp2/stm32mp2_pm.c				\
+				plat/st/stm32mp2/stm32mp2_topology.c
+# Generic GIC v2
+include drivers/arm/gic/v2/gicv2.mk
+
+BL31_SOURCES		+=	${GICV2_SOURCES}					\
+				plat/common/plat_gicv2.c				\
+				plat/st/common/stm32mp_gic.c
+
+# Generic PSCI
+BL31_SOURCES		+=	plat/common/plat_psci_common.c
+
+BL31_SOURCES		+=	plat/st/common/stm32mp_svc_setup.c			\
+				plat/st/stm32mp2/services/stgen_svc.c			\
+				plat/st/stm32mp2/services/stm32mp2_svc_setup.c
+
+# Arm Archtecture services
+BL31_SOURCES		+=	services/arm_arch_svc/arm_arch_svc_setup.c
+
+# Compilation rules
+.PHONY: check_ddr_type
+.SUFFIXES:
+
+bl2: check_ddr_type
+
+check_ddr_type:
+	$(eval DDR_TYPE = $(shell echo $$(($(STM32MP_DDR3_TYPE) + \
+					   $(STM32MP_DDR4_TYPE) + \
+					   $(STM32MP_LPDDR4_TYPE)))))
+	@if [ ${DDR_TYPE} != 1 ]; then \
+		echo "One and only one DDR type must be defined"; \
+		false; \
+	fi
+
+# generate separate DDR FIP image
+ifeq (${STM32MP_DDR_FIP_IO_STORAGE},1)
+ifneq ($(filter 1,${STM32MP_UART_PROGRAMMER} ${STM32MP_USB_PROGRAMMER}),)
+
+DDR_FIP_NAME		?=	fip-ddr.bin
+DDR_FIP_ARGS		+=	--ddr-fw ${STM32MP_DDR_FW}
+DDR_FIP_DEPS		+=	${STM32MP_DDR_FW}
+
+${BUILD_PLAT}/${DDR_FIP_NAME}: ${DDR_FIP_DEPS} fiptool
+	${Q}${FIPTOOL} create ${DDR_FIP_ARGS} $@
+	${Q}${FIPTOOL} info $@
+	@${ECHO_BLANK_LINE}
+	@echo "Built $@ successfully"
+	@${ECHO_BLANK_LINE}
+
+fip: ${BUILD_PLAT}/${DDR_FIP_NAME}
+
+endif
+endif
+
+include plat/st/common/common_rules.mk
diff --git a/plat/st/stm32mp2/services/stgen_svc.c b/plat/st/stm32mp2/services/stgen_svc.c
new file mode 100644
index 000000000..cfb27bc05
--- /dev/null
+++ b/plat/st/stm32mp2/services/stgen_svc.c
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+#include <drivers/generic_delay_timer.h>
+#include <drivers/st/stm32mp_clkfunc.h>
+#include <lib/mmio.h>
+#include <plat/common/platform.h>
+
+#include <platform_def.h>
+#include <stm32mp_svc_setup.h>
+#include <stm32mp_common.h>
+#include <stm32mp2_smc.h>
+
+#include "stgen_svc.h"
+
+/*
+ * This function reads and applies the STGEN frequency value in the STGENC base frequency register,
+ * which is the frequency the system base counter use for our platforms.
+ */
+uint32_t stgen_svc_handler(void)
+{
+	unsigned long freq_to_set = mmio_read_32(STGEN_BASE + CNTFID_OFF);
+
+	VERBOSE("STGEN frequency set to %lu\n", freq_to_set);
+
+	/*
+	 * Update the system counter frequency according to STGEN's base
+	 * counter frequency register
+	 */
+	write_cntfrq_el0((u_register_t)freq_to_set);
+
+	/* Need to update timer with new frequency */
+	generic_delay_timer_init();
+
+	return STM32_SMC_OK;
+}
diff --git a/plat/st/stm32mp2/services/stgen_svc.h b/plat/st/stm32mp2/services/stgen_svc.h
new file mode 100644
index 000000000..36f717b2f
--- /dev/null
+++ b/plat/st/stm32mp2/services/stgen_svc.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STGEN_SVC_H
+#define STGEN_SVC_H
+
+uint32_t stgen_svc_handler(void);
+
+#endif /* STGEN_SVC_H */
diff --git a/plat/st/stm32mp2/services/stm32mp2_svc_setup.c b/plat/st/stm32mp2/services/stm32mp2_svc_setup.c
new file mode 100644
index 000000000..08fe1630c
--- /dev/null
+++ b/plat/st/stm32mp2/services/stm32mp2_svc_setup.c
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include <common/debug.h>
+#include <common/runtime_svc.h>
+#include <lib/mmio.h>
+
+#include <stm32mp_svc_setup.h>
+#include <stm32mp2_smc.h>
+
+#include "stgen_svc.h"
+
+/*
+ * Platform-level Standard Service SIP SMC handler. This handler will dispatch
+ * the SMC to the correct feature handler.
+ */
+void plat_svc_smc_handler(uint32_t smc_fid, u_register_t x1,
+			  u_register_t x2, u_register_t x3,
+			  u_register_t x4, uint32_t *ret1,
+			  uint32_t *ret2, bool *ret2_enabled,
+			  u_register_t flags)
+{
+	switch (smc_fid) {
+	case STM32_SIP_SVC_CALL_COUNT:
+		*ret1 = STM32_COMMON_SIP_NUM_CALLS;
+		break;
+	case STM32_SIP_SMC_STGEN_SET_RATE:
+		if (!is_caller_secure(flags)) {
+			*ret1 = STM32_SMC_FAILED;
+			break;
+		}
+
+		*ret1 = stgen_svc_handler();
+		break;
+	default:
+		WARN("Unimplemented STM32MP2 Service Call: 0x%x\n", smc_fid);
+		*ret1 = STM32_SMC_NOT_SUPPORTED;
+		break;
+	}
+}
diff --git a/plat/st/stm32mp2/stm32mp2_boot_device.c b/plat/st/stm32mp2/stm32mp2_boot_device.c
new file mode 100644
index 000000000..c4a8311dd
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_boot_device.c
@@ -0,0 +1,173 @@
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+
+#include <drivers/nand.h>
+#include <drivers/raw_nand.h>
+#include <drivers/spi_nand.h>
+#include <drivers/spi_nor.h>
+#include <lib/utils.h>
+#include <plat/common/platform.h>
+
+#if STM32MP_RAW_NAND || STM32MP_SPI_NAND
+static int get_data_from_otp(struct nand_device *nand_dev, bool is_slc)
+{
+	uint32_t nand_param;
+	uint32_t nand2_param;
+
+	/* Check if NAND parameters are stored in OTP */
+	if (stm32_get_otp_value(NAND_OTP, &nand_param) != 0) {
+		ERROR("BSEC: NAND_OTP Error\n");
+		return -EACCES;
+	}
+
+	if ((nand_param == 0U) && is_slc) {
+		return 0;
+	}
+
+	if (((nand_param & NAND_PARAM_STORED_IN_OTP) == 0U) && is_slc) {
+		goto ecc;
+	}
+
+	if (stm32_get_otp_value(NAND2_OTP, &nand2_param) != 0) {
+		ERROR("BSEC: NAND_OTP Error\n");
+		return -EACCES;
+	}
+
+	/* Check OTP configuration for this device */
+	if ((((nand2_param & NAND2_CONFIG_DISTRIB) == NAND2_PNAND_NAND1_SNAND_NAND2) && !is_slc) ||
+	    (((nand2_param & NAND2_CONFIG_DISTRIB) == NAND2_PNAND_NAND2_SNAND_NAND1) && is_slc)) {
+		nand_param = nand2_param << (NAND_PAGE_SIZE_SHIFT - NAND2_PAGE_SIZE_SHIFT);
+	}
+
+	/* NAND parameter shall be read from OTP */
+	if ((nand_param & NAND_WIDTH_MASK) != 0U) {
+		nand_dev->buswidth = NAND_BUS_WIDTH_16;
+	} else {
+		nand_dev->buswidth = NAND_BUS_WIDTH_8;
+	}
+
+	switch ((nand_param & NAND_PAGE_SIZE_MASK) >> NAND_PAGE_SIZE_SHIFT) {
+	case NAND_PAGE_SIZE_2K:
+		nand_dev->page_size = 0x800U;
+		break;
+
+	case NAND_PAGE_SIZE_4K:
+		nand_dev->page_size = 0x1000U;
+		break;
+
+	case NAND_PAGE_SIZE_8K:
+		nand_dev->page_size = 0x2000U;
+		break;
+
+	default:
+		ERROR("Cannot read NAND page size\n");
+		return -EINVAL;
+	}
+
+	switch ((nand_param & NAND_BLOCK_SIZE_MASK) >> NAND_BLOCK_SIZE_SHIFT) {
+	case NAND_BLOCK_SIZE_64_PAGES:
+		nand_dev->block_size = 64U * nand_dev->page_size;
+		break;
+
+	case NAND_BLOCK_SIZE_128_PAGES:
+		nand_dev->block_size = 128U * nand_dev->page_size;
+		break;
+
+	case NAND_BLOCK_SIZE_256_PAGES:
+		nand_dev->block_size = 256U * nand_dev->page_size;
+		break;
+
+	default:
+		ERROR("Cannot read NAND block size\n");
+		return -EINVAL;
+	}
+
+	nand_dev->size = ((nand_param & NAND_BLOCK_NB_MASK) >>
+			  NAND_BLOCK_NB_SHIFT) *
+		NAND_BLOCK_NB_UNIT * nand_dev->block_size;
+
+ecc:
+	if (is_slc) {
+		switch ((nand_param & NAND_ECC_BIT_NB_MASK) >>
+			NAND_ECC_BIT_NB_SHIFT) {
+		case NAND_ECC_BIT_NB_1_BITS:
+			nand_dev->ecc.max_bit_corr = 1U;
+			break;
+
+		case NAND_ECC_BIT_NB_4_BITS:
+			nand_dev->ecc.max_bit_corr = 4U;
+			break;
+
+		case NAND_ECC_BIT_NB_8_BITS:
+			nand_dev->ecc.max_bit_corr = 8U;
+			break;
+
+		case NAND_ECC_ON_DIE:
+			nand_dev->ecc.mode = NAND_ECC_ONDIE;
+			break;
+
+		default:
+			if (nand_dev->ecc.max_bit_corr == 0U) {
+				ERROR("No valid eccbit number\n");
+				return -EINVAL;
+			}
+		}
+	} else {
+		/* Selected multiple plane NAND */
+		if ((nand_param & NAND_PLANE_BIT_NB_MASK) != 0U) {
+			nand_dev->nb_planes = 2U;
+		} else {
+			nand_dev->nb_planes = 1U;
+		}
+	}
+
+	VERBOSE("OTP: Block %i Page %i Size %lli\n", nand_dev->block_size,
+		nand_dev->page_size, nand_dev->size);
+
+	return 0;
+}
+#endif /* STM32MP_RAW_NAND || STM32MP_SPI_NAND */
+
+#if STM32MP_RAW_NAND
+int plat_get_raw_nand_data(struct rawnand_device *device)
+{
+	device->nand_dev->ecc.mode = NAND_ECC_HW;
+	device->nand_dev->ecc.size = SZ_512;
+
+	return get_data_from_otp(device->nand_dev, true);
+}
+#endif
+
+#if STM32MP_SPI_NAND
+int plat_get_spi_nand_data(struct spinand_device *device)
+{
+	return get_data_from_otp(device->nand_dev, false);
+}
+#endif
+
+#if STM32MP_SPI_NOR
+int plat_get_nor_data(struct nor_device *device)
+{
+	/* Quad read command used with MX25L51245G */
+	device->size = SZ_64M;
+	device->flags |= SPI_NOR_USE_BANK;
+
+	zeromem(&device->read_op, sizeof(struct spi_mem_op));
+	device->read_op.cmd.opcode = SPI_NOR_OP_READ_1_1_4;
+	device->read_op.cmd.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
+	device->read_op.addr.nbytes = 3U;
+	device->read_op.addr.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
+	device->read_op.dummy.nbytes = 1U;
+	device->read_op.dummy.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
+	device->read_op.data.buswidth = SPI_MEM_BUSWIDTH_4_LINE;
+	device->read_op.data.dir = SPI_MEM_DATA_IN;
+
+	return 0;
+}
+#endif
diff --git a/plat/st/stm32mp2/stm32mp2_def.h b/plat/st/stm32mp2/stm32mp2_def.h
new file mode 100644
index 000000000..45a35c3f4
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_def.h
@@ -0,0 +1,545 @@
+/*
+ * Copyright (c) 2018-2022, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_DEF_H
+#define STM32MP2_DEF_H
+
+#include <common/tbbr/tbbr_img_def.h>
+#include <drivers/st/stm32mp2_pwr.h>
+#include <drivers/st/stm32mp2_rcc.h>
+#include <dt-bindings/clock/stm32mp2-clks.h>
+#include <dt-bindings/clock/stm32mp2-clksrc.h>
+#include <dt-bindings/gpio/stm32-gpio.h>
+#include <dt-bindings/reset/stm32mp2-resets.h>
+#include <dt-bindings/soc/rif.h>
+
+#ifndef __ASSEMBLER__
+#include <drivers/st/bsec.h>
+#include <drivers/st/stm32mp2_clk.h>
+
+#include <boot_api.h>
+#include <stm32mp_common.h>
+#include <stm32mp_dt.h>
+#include <stm32mp_shared_resources.h>
+#include <stm32mp_shres_helpers.h>
+#include <stm32mp2_private.h>
+#endif
+
+/*******************************************************************************
+ * CHIP ID
+ ******************************************************************************/
+#define STM32MP2_CHIP_ID	U(0x505)
+
+#define STM32MP257C_PART_NB	U(0x00000000)
+#define STM32MP257A_PART_NB	U(0x40000E00)
+#define STM32MP255C_PART_NB	U(0x00080000)
+#define STM32MP255A_PART_NB	U(0x40080E00)
+#define STM32MP253C_PART_NB	U(0x000B0004)
+#define STM32MP253A_PART_NB	U(0x400B0E04)
+#define STM32MP251C_PART_NB	U(0x000B1065)
+#define STM32MP251A_PART_NB	U(0x400B1E65)
+#define STM32MP257F_PART_NB	U(0x80000000)
+#define STM32MP257D_PART_NB	U(0xC0000E00)
+#define STM32MP255F_PART_NB	U(0x80080000)
+#define STM32MP255D_PART_NB	U(0xC0080E00)
+#define STM32MP253F_PART_NB	U(0x800B0004)
+#define STM32MP253D_PART_NB	U(0xC00B0E04)
+#define STM32MP251F_PART_NB	U(0x800B1065)
+#define STM32MP251D_PART_NB	U(0xC00B1E65)
+
+#define STM32MP2_REV_A		U(0x1000)
+
+/*******************************************************************************
+ * PACKAGE ID
+ ******************************************************************************/
+#define STM32MP25_PKG_CUSTOM		U(0)
+#define STM32MP25_PKG_AL_TBGA361	U(3)
+#define STM32MP25_PKG_AK_TBGA424	U(4)
+#define STM32MP25_PKG_AI_TBGA436	U(5)
+#define STM32MP25_PKG_UNKNOWN		U(7)
+
+/*******************************************************************************
+ * STM32MP2 memory map related constants
+ ******************************************************************************/
+#define STM32MP_SYSRAM_BASE		U(0x0E000000)
+#define STM32MP_SYSRAM_SIZE		U(0x00040000)
+#define SRAM1_BASE			U(0x0E040000)
+#define SRAM1_SIZE			U(0x00020000)
+#define SRAM2_BASE			U(0x0E060000)
+#define SRAM2_SIZE			U(0x00020000)
+#define STM32MP_BACKUP_RAM_BASE	U(0x42000000)
+
+/* the first 4KB of SRAM1 are reserved are for BSEC shadow */
+#define STM32MP_SEC_SRAM1_SIZE		U(0x1000)
+
+#if defined(IMAGE_BL2) && defined(STM32MP_USB_PROGRAMMER)
+#define STM32MP_SEC_DEVICE_SYSRAM_SIZE		STM32MP_USB_DWC3_SIZE
+#define STM32MP_SEC_DEVICE_SYSRAM_BASE		(STM32MP_SYSRAM_BASE + \
+						 STM32MP_SYSRAM_SIZE - \
+						 STM32MP_SEC_DEVICE_SYSRAM_SIZE)
+
+#define STM32MP_SEC_SYSRAM_BASE		STM32MP_SYSRAM_BASE
+#define STM32MP_SEC_SYSRAM_SIZE		(STM32MP_SYSRAM_SIZE - \
+					 STM32MP_SEC_DEVICE_SYSRAM_SIZE)
+
+#define STM32MP_USB_DWC3_BASE		STM32MP_SEC_DEVICE_SYSRAM_BASE
+#define STM32MP_USB_DWC3_SIZE		PAGE_SIZE
+#else
+#define STM32MP_NS_SYSRAM_SIZE		PAGE_SIZE
+#define STM32MP_NS_SYSRAM_BASE		(STM32MP_SYSRAM_BASE + \
+					 STM32MP_SYSRAM_SIZE - \
+					 STM32MP_NS_SYSRAM_SIZE)
+
+#define STM32MP_SCMI_NS_SHM_BASE	STM32MP_NS_SYSRAM_BASE
+#define STM32MP_SCMI_NS_SHM_SIZE	STM32MP_NS_SYSRAM_SIZE
+
+#define STM32MP_SEC_SYSRAM_BASE		STM32MP_SYSRAM_BASE
+#define STM32MP_SEC_SYSRAM_SIZE		(STM32MP_SYSRAM_SIZE - \
+					 STM32MP_NS_SYSRAM_SIZE)
+#endif
+
+/* DDR configuration */
+#define STM32MP_DDR_BASE		U(0x80000000)
+#define STM32MP_DDR_MAX_SIZE		U(0x80000000)	/* Max 2GB */
+#define STM32MP_DDR_S_SIZE		U(0)
+#define STM32MP_DDR_SHMEM_SIZE		U(0)
+
+/* DDR power initializations */
+#ifndef __ASSEMBLER__
+enum ddr_type {
+	STM32MP_DDR3,
+	STM32MP_DDR4,
+	STM32MP_LPDDR4
+};
+#endif
+
+/* Section used inside TF binaries */
+#define STM32MP_PARAM_LOAD_SIZE		U(0x00002400)	/* 9 KB for param */
+/* 512 Octets reserved for header */
+#define STM32MP_HEADER_SIZE		U(0x00000200)
+/* round_up(STM32MP_PARAM_LOAD_SIZE + STM32MP_HEADER_SIZE, PAGE_SIZE) */
+#define STM32MP_HEADER_RESERVED_SIZE	U(0x3000)
+
+#define STM32MP_BINARY_BASE		(STM32MP_SEC_SYSRAM_BASE +	\
+					 STM32MP_PARAM_LOAD_SIZE +	\
+					 STM32MP_HEADER_SIZE)
+
+#define STM32MP_BINARY_SIZE		(STM32MP_SEC_SYSRAM_SIZE -	\
+					 (STM32MP_PARAM_LOAD_SIZE +	\
+					  STM32MP_HEADER_SIZE))
+
+#define STM32MP_BL31_SIZE		U(0x0001C000)	/* 112 KB for BL31 */
+
+#define STM32MP_BL2_RO_SIZE		U(0x00013000)	/* 76 KB */
+#define STM32MP_BL2_SIZE		U(0x00027000)	/* 156 KB for BL2 */
+#define STM32MP_BL2_BASE		(STM32MP_SEC_SYSRAM_BASE + \
+					 STM32MP_SEC_SYSRAM_SIZE - \
+					 STM32MP_BL2_SIZE)
+
+#define STM32MP_BL2_RO_BASE		STM32MP_BL2_BASE
+
+#define STM32MP_BL2_RW_BASE		(STM32MP_BL2_RO_BASE + \
+					 STM32MP_BL2_RO_SIZE)
+
+#define STM32MP_BL2_RW_SIZE		STM32MP_SYSRAM_BASE + \
+					STM32MP_SYSRAM_SIZE - \
+					STM32MP_BL2_RW_BASE
+
+/* BL2 and BL32/sp_min require 4 tables */
+#define MAX_XLAT_TABLES			U(4)	/* 16 KB for mapping */
+
+/*
+ * MAX_MMAP_REGIONS is usually:
+ * BL stm32mp2_mmap size + mmap regions in *_plat_arch_setup
+ */
+#if STM32MP_USB_PROGRAMMER
+#define MAX_MMAP_REGIONS		8
+#elif defined(IMAGE_BL31)
+#define MAX_MMAP_REGIONS		7
+#else
+#define MAX_MMAP_REGIONS		6
+#endif
+
+/* DTB initialization value */
+#define STM32MP_BL2_DTB_SIZE		U(0x00004000)	/* 16 KB for DTB */
+
+#define STM32MP_BL2_DTB_BASE		(STM32MP_BL2_BASE - \
+					 STM32MP_BL2_DTB_SIZE)
+
+#if defined(IMAGE_BL2)
+#define STM32MP_DTB_SIZE		STM32MP_BL2_DTB_SIZE
+#define STM32MP_DTB_BASE		STM32MP_BL2_DTB_BASE
+#endif
+
+#if STM32MP_DDR_FIP_IO_STORAGE
+#define STM32MP_DDR_FW_BASE		(SRAM1_BASE + STM32MP_SEC_SRAM1_SIZE)
+#define STM32MP_DDR_FW_DMEM_OFFSET	U(0x400)
+#define STM32MP_DDR_FW_IMEM_OFFSET	U(0x800)
+#define STM32MP_DDR_FW_MAX_SIZE		U(0x8800)
+#endif
+
+#define STM32MP_FW_CONFIG_BASE		(STM32MP_SYSRAM_BASE + \
+					 STM32MP_SYSRAM_SIZE - \
+					 PAGE_SIZE)
+#define STM32MP_FW_CONFIG_MAX_SIZE	PAGE_SIZE
+#define STM32MP_BL33_BASE		(STM32MP_DDR_BASE + U(0x04000000))
+#define STM32MP_BL33_MAX_SIZE		U(0x400000)
+#define STM32MP_HW_CONFIG_BASE		(STM32MP_BL33_BASE + \
+					STM32MP_BL33_MAX_SIZE)
+#define STM32MP_HW_CONFIG_MAX_SIZE	U(0x20000)
+
+/* Define maximum page size for NAND devices */
+#define PLATFORM_MTD_MAX_PAGE_SIZE	U(0x1000)
+
+/*
+ * Only used for MTD devices that need some backup blocks.
+ * Must define a maximum size for a partition.
+ */
+#define PLATFORM_MTD_MAX_PART_SIZE	U(0x00400000)
+
+/*******************************************************************************
+ * STM32MP2 RAW partition offset for MTD devices
+ ******************************************************************************/
+#ifndef STM32MP_NOR_FIP_OFFSET
+#define STM32MP_NOR_FIP_OFFSET		U(0x00080000)
+#endif
+#ifndef STM32MP_NAND_FIP_OFFSET
+#define STM32MP_NAND_FIP_OFFSET		U(0x00200000)
+#endif
+
+/*******************************************************************************
+ * STM32MP2 device/io map related constants (used for MMU)
+ ******************************************************************************/
+#define STM32MP_DEVICE_BASE		U(0x40000000)
+#define STM32MP_DEVICE_SIZE		U(0x40000000)
+
+/*******************************************************************************
+ * STM32MP2 RCC
+ ******************************************************************************/
+#define RCC_BASE			U(0x44200000)
+
+/*******************************************************************************
+ * STM32MP2 PWR
+ ******************************************************************************/
+#define PWR_BASE			U(0x44210000)
+
+/*******************************************************************************
+ * STM32MP2 GPIO
+ ******************************************************************************/
+#define GPIOA_BASE			U(0x44240000)
+#define GPIOB_BASE			U(0x44250000)
+#define GPIOC_BASE			U(0x44260000)
+#define GPIOD_BASE			U(0x44270000)
+#define GPIOE_BASE			U(0x44280000)
+#define GPIOF_BASE			U(0x44290000)
+#define GPIOG_BASE			U(0x442A0000)
+#define GPIOH_BASE			U(0x442B0000)
+#define GPIOI_BASE			U(0x442C0000)
+#define GPIOJ_BASE			U(0x442D0000)
+#define GPIOK_BASE			U(0x442E0000)
+#define GPIOZ_BASE			U(0x46200000)
+#define GPIO_BANK_OFFSET		U(0x10000)
+
+#define STM32MP_GPIOS_PIN_MAX_COUNT	16
+#define STM32MP_GPIOZ_PIN_MAX_COUNT	8
+
+/*******************************************************************************
+ * STM32MP2 UART
+ ******************************************************************************/
+#define USART1_BASE			U(0x40330000)
+#define USART2_BASE			U(0x400E0000)
+#define USART3_BASE			U(0x400F0000)
+#define UART4_BASE			U(0x40100000)
+#define UART5_BASE			U(0x40110000)
+#define USART6_BASE			U(0x40220000)
+#define UART7_BASE			U(0x40370000)
+#define UART8_BASE			U(0x40380000)
+#define UART9_BASE			U(0x402C0000)
+
+/* For UART crash console */
+#define STM32MP_DEBUG_USART_CLK_FRQ	64000000
+/* USART2 on HSI@64MHz, TX on GPIOA4 Alternate 6 */
+#define STM32MP_DEBUG_USART_BASE	USART2_BASE
+#define DEBUG_UART_TX_GPIO_BANK_ADDRESS	GPIOA_BASE
+#define DEBUG_UART_TX_GPIO_BANK_CLK_REG	RCC_GPIOACFGR
+#define DEBUG_UART_TX_GPIO_BANK_CLK_EN	RCC_GPIOxCFGR_GPIOxEN
+#define DEBUG_UART_TX_GPIO_PORT		4
+#define DEBUG_UART_TX_GPIO_ALTERNATE	6
+#define DEBUG_UART_TX_CLKSRC_REG	RCC_XBAR8CFGR
+#define DEBUG_UART_TX_CLKSRC		XBAR_SRC_HSI
+#define DEBUG_UART_TX_EN_REG		RCC_USART2CFGR
+#define DEBUG_UART_TX_EN		RCC_UARTxCFGR_UARTxEN
+#define DEBUG_UART_RST_REG		RCC_USART2CFGR
+#define DEBUG_UART_RST_BIT		RCC_UARTxCFGR_UARTxRST
+#define DEBUG_UART_PREDIV_CFGR		RCC_PREDIV8CFGR
+#define DEBUG_UART_FINDIV_CFGR		RCC_FINDIV8CFGR
+
+/*******************************************************************************
+ * STM32MP2 SDMMC
+ ******************************************************************************/
+#define STM32MP_SDMMC1_BASE		U(0x48220000)
+#define STM32MP_SDMMC2_BASE		U(0x48230000)
+#define STM32MP_SDMMC3_BASE		U(0x48240000)
+
+#define STM32MP_MMC_INIT_FREQ			U(400000)	/*400 KHz*/
+#define STM32MP_SD_NORMAL_SPEED_MAX_FREQ	U(25000000)	/*25 MHz*/
+#define STM32MP_SD_HIGH_SPEED_MAX_FREQ		U(50000000)	/*50 MHz*/
+#define STM32MP_EMMC_NORMAL_SPEED_MAX_FREQ	U(26000000)	/*26 MHz*/
+#define STM32MP_EMMC_HIGH_SPEED_MAX_FREQ	U(52000000)	/*52 MHz*/
+
+/*******************************************************************************
+ * STM32MP2 OSPI
+ ******************************************************************************/
+/* OSPI 1 & 2 memory map area */
+#define STM32MP_OSPI_MM_BASE		U(0x60000000)
+#define STM32MP_OSPI_MM_SIZE		U(0x10000000)
+
+/*******************************************************************************
+ * STM32MP2 BSEC / OTP
+ ******************************************************************************/
+/*
+ * 367 available OTPs, the other are masked
+ * - ECIES key: 368 to 375 (only readable by bootrom)
+ * - HWKEY: 376 to 383 (never reloadable or readable)
+ */
+#define STM32MP2_OTP_MAX_ID		0x16FU
+#define STM32MP2_MID_OTP_START		0x80U
+#define STM32MP2_UPPER_OTP_START	0x100U
+
+/* OTP labels */
+#define DATA0_OTP			"dat0_otp"
+#define PART_NUMBER_OTP			"part_number_otp"
+#define PACKAGE_OTP			"package_otp"
+#define HW2_OTP				"hw2_otp"
+#define NAND_OTP			"otp16"
+#define NAND2_OTP			"otp20"
+#define BOARD_ID_OTP			"board_id"
+#define UID_OTP				"uid_otp"
+
+/* OTP mask */
+/* DATA0 */
+#define DATA0_OTP_SECURED		BIT(6)
+
+/* PACKAGE */
+#define PACKAGE_OTP_PKG_MASK		GENMASK_32(2, 0)
+#define PACKAGE_OTP_PKG_SHIFT		0
+
+/* IWDG OTP */
+#define HW2_OTP_IWDG_HW_POS		U(0)
+#define HW2_OTP_IWDG_FZ_STOP_POS	U(1)
+#define HW2_OTP_IWDG_FZ_STANDBY_POS	U(2)
+
+/* NAND OTP */
+/* NAND parameter storage flag */
+#define NAND_PARAM_STORED_IN_OTP	BIT(31)
+
+/* NAND page size in bytes */
+#define NAND_PAGE_SIZE_MASK		GENMASK_32(30, 29)
+#define NAND_PAGE_SIZE_SHIFT		29
+#define NAND_PAGE_SIZE_2K		U(0)
+#define NAND_PAGE_SIZE_4K		U(1)
+#define NAND_PAGE_SIZE_8K		U(2)
+
+/* NAND block size in pages */
+#define NAND_BLOCK_SIZE_MASK		GENMASK_32(28, 27)
+#define NAND_BLOCK_SIZE_SHIFT		27
+#define NAND_BLOCK_SIZE_64_PAGES	U(0)
+#define NAND_BLOCK_SIZE_128_PAGES	U(1)
+#define NAND_BLOCK_SIZE_256_PAGES	U(2)
+
+/* NAND number of block (in unit of 256 blocks) */
+#define NAND_BLOCK_NB_MASK		GENMASK_32(26, 19)
+#define NAND_BLOCK_NB_SHIFT		19
+#define NAND_BLOCK_NB_UNIT		U(256)
+
+/* NAND bus width in bits */
+#define NAND_WIDTH_MASK			BIT(18)
+#define NAND_WIDTH_SHIFT		18
+
+/* NAND number of ECC bits per 512 bytes */
+#define NAND_ECC_BIT_NB_MASK		GENMASK_32(17, 15)
+#define NAND_ECC_BIT_NB_SHIFT		15
+#define NAND_ECC_BIT_NB_UNSET		U(0)
+#define NAND_ECC_BIT_NB_1_BITS		U(1)
+#define NAND_ECC_BIT_NB_4_BITS		U(2)
+#define NAND_ECC_BIT_NB_8_BITS		U(3)
+#define NAND_ECC_ON_DIE			U(4)
+
+/* NAND number of planes */
+#define NAND_PLANE_BIT_NB_MASK		BIT(14)
+
+/* NAND2 OTP */
+#define NAND2_PAGE_SIZE_SHIFT		16
+
+/* NAND2 config distribution */
+#define NAND2_CONFIG_DISTRIB		BIT(0)
+#define NAND2_PNAND_NAND2_SNAND_NAND1	U(0)
+#define NAND2_PNAND_NAND1_SNAND_NAND2	U(1)
+
+/* MONOTONIC OTP */
+#define MAX_MONOTONIC_VALUE		32
+
+/* UID OTP */
+#define UID_WORD_NB			U(3)
+/*******************************************************************************
+ * STM32MP2 TAMP
+ ******************************************************************************/
+#define PLAT_MAX_TAMP_INT		U(5)
+#define PLAT_MAX_TAMP_EXT		U(3)
+#define TAMP_BASE			U(0x46010000)
+#define TAMP_SMCR			(TAMP_BASE + U(0x20))
+#ifndef CFG_WORKAROUND_VSW0V8
+#define TAMP_BKP_REGISTER_BASE		(TAMP_BASE + U(0x100))
+#else
+#define TAMP_BKP_REGISTER_BASE		STM32MP_BACKUP_RAM_BASE
+#endif
+#define TAMP_BKP_SEC_NUMBER		U(10)
+
+#if !(defined(__LINKER__) || defined(__ASSEMBLER__))
+static inline uintptr_t tamp_bkpr(uint32_t idx)
+{
+	return TAMP_BKP_REGISTER_BASE + (idx << 2);
+}
+#endif
+
+/*******************************************************************************
+ * STM32MP2 USB
+ ******************************************************************************/
+#define USB_DWC3_BASE			U(0x48300000)
+
+/*******************************************************************************
+ * STM32MP2 DDRCTRL
+ ******************************************************************************/
+#define DDRCTRL_BASE			U(0x48040000)
+
+/*******************************************************************************
+ * STM32MP2 DDRDBG
+ ******************************************************************************/
+#define DDRDBG_BASE			U(0x48050000)
+
+/*******************************************************************************
+ * STM32MP2 DDRPHYC
+ ******************************************************************************/
+#define DDRPHYC_BASE			U(0x48C00000)
+
+/*******************************************************************************
+ * STM32MP2 IWDG
+ ******************************************************************************/
+#define IWDG_MAX_INSTANCE		U(2)
+#define IWDG1_INST			U(0)
+#define IWDG2_INST			U(1)
+
+#define IWDG1_BASE			U(0x44010000)
+#define IWDG2_BASE			U(0x44020000)
+
+/*******************************************************************************
+ * Miscellaneous STM32MP1 peripherals base address
+ ******************************************************************************/
+#define BSEC_BASE			U(0x44000000)
+#define DBGMCU_BASE			U(0x4A010000)
+#define HASH_BASE			U(0x42010000)
+#define RTC_BASE			U(0x46000000)
+#define STGEN_BASE			U(0x48080000)
+#define SYSCFG_BASE			U(0x44230000)
+
+/*******************************************************************************
+ * STM32MP RIF
+ ******************************************************************************/
+#define RIFSC_BASE			U(0x42080000)
+#define RISAB1_BASE			U(0x420F0000)
+#define RISAB2_BASE			U(0x42100000)
+#define RISAB3_BASE			U(0x42110000)
+#define RISAB4_BASE			U(0x42120000)
+#define RISAB5_BASE			U(0x42130000)
+
+#define RISAF1_INST			0
+#define RISAF2_INST			1
+#define RISAF4_INST			3
+#define RISAF5_INST			4
+#define RISAF_MAX_INSTANCE		5
+
+#define RISAF2_BASE			U(0x420B0000)
+#define RISAF4_BASE			U(0x420D0000)
+
+#ifdef RISAF1_BASE
+#define RISAF1_MAX_REGION		4
+#else
+#define RISAF1_MAX_REGION		0
+#endif
+#ifdef RISAF2_BASE
+#define RISAF2_MAX_REGION		4
+#else
+#define RISAF2_MAX_REGION		0
+#endif
+#ifdef RISAF4_BASE
+/* Consider only encrypted region maximum number, to save memory consumption */
+#define RISAF4_MAX_REGION		4
+#else
+#define RISAF4_MAX_REGION		0
+#endif
+#ifdef RISAF5_BASE
+#define RISAF5_MAX_REGION		2
+#else
+#define RISAF5_MAX_REGION		0
+#endif
+#define RISAF_MAX_REGION		(RISAF1_MAX_REGION + RISAF2_MAX_REGION + \
+					RISAF4_MAX_REGION + RISAF5_MAX_REGION)
+
+#define RISAF_KEY_SIZE_IN_BYTES		U(16)
+
+/*******************************************************************************
+ * USB boot RIFSC specific configurations
+ ******************************************************************************/
+#define RIMU_USB3DR			U(4)
+#define RISUP_USB3DRD			U(66)
+
+/*
+ * Protection for USB3-IP Peripheriphal: accessible form Secure/Priv
+ */
+#define RIFSC_USBDRD_PRIV		BIT(RISUP_USB3DRD / U(32))
+#define RIFSC_USBDRD_SEC		BIT(RISUP_USB3DRD / U(32))
+
+/*
+ * USB3DR Secure/Priv Master (DMA) access
+ */
+#define RIFSC_USB_BOOT_USBDR_RIMC_CONF	(RIFSC_RIMC_ATTRx_MPRIV | RIFSC_RIMC_ATTRx_MSEC | \
+					 RIF_CID1 << RIFSC_RIMC_ATTRx_MCID_SHIFT | \
+					 RIFSC_RIMC_ATTRx_CIDSEL)
+
+/*******************************************************************************
+ * STM32MP CA35SSC
+ ******************************************************************************/
+#define A35SSC_BASE			U(0x48800000)
+
+/*******************************************************************************
+ * REGULATORS
+ ******************************************************************************/
+/* 3 PWR + 1 VREFBUF + 14 PMIC regulators + 1 FIXED */
+#define PLAT_NB_RDEVS			U(19)
+/* 2 FIXED */
+#define PLAT_NB_FIXED_REGUS		U(9)
+/* No GPIO regu */
+#define PLAT_NB_GPIO_REGUS		U(0)
+/* Number of low power modes defined in the device tree */
+#define PLAT_NB_SUSPEND_MODES		7
+
+/*******************************************************************************
+ * Device Tree defines
+ ******************************************************************************/
+#define DT_BSEC_COMPAT			"st,stm32mp2-bsec"
+#define DT_DDR_COMPAT			"st,stm32mp2-ddr"
+#define DT_IWDG_COMPAT			"st,stm32mp2-iwdg"
+#define DT_NVMEM_LAYOUT_COMPAT		"st,stm32-nvmem-layout"
+#define DT_OPP_COMPAT			"operating-points-v2"
+#define DT_PWR_COMPAT			"st,stm32mp25-pwr"
+#define DT_RCC_CLK_COMPAT		"st,stm32mp2-rcc"
+#define DT_RCC_SEC_CLK_COMPAT		"st,stm32mp2-rcc-secure"
+#define DT_SDMMC2_COMPAT		"st,stm32mp25-sdmmc2"
+#define DT_UART_COMPAT			"st,stm32h7-uart"
+
+#define DT_PLL1_NODE_NAME		"st,pll@0"
+
+#endif /* STM32MP2_DEF_H */
diff --git a/plat/st/stm32mp2/stm32mp2_fconf_firewall.c b/plat/st/stm32mp2/stm32mp2_fconf_firewall.c
new file mode 100644
index 000000000..3e0c67313
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_fconf_firewall.c
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2019-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <platform_def.h>
+
+#include <lib/fconf/fconf.h>
+#include <lib/object_pool.h>
+#include <tools_share/firmware_image_package.h>
+
+void stm32mp2_arch_security_setup(void)
+{
+}
+
+void stm32mp2_security_setup(void)
+{
+}
+
+static int fconf_populate_stm32mp2_firewall(uintptr_t config)
+{
+	return 0;
+}
+
+FCONF_REGISTER_POPULATOR(FW_CONFIG, stm32mp2_firewall, fconf_populate_stm32mp2_firewall);
diff --git a/plat/st/stm32mp2/stm32mp2_pm.c b/plat/st/stm32mp2/stm32mp2_pm.c
new file mode 100644
index 000000000..8970afecc
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_pm.c
@@ -0,0 +1,241 @@
+/*
+ * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/arm/gic_common.h>
+#include <drivers/arm/gicv2.h>
+#include <drivers/st/stm32mp_reset.h>
+#include <lib/mmio.h>
+#include <lib/psci/psci.h>
+#include <plat/common/platform.h>
+
+#include <platform_def.h>
+
+#define CORE_PWR_STATE(state) ((state)->pwr_domain_state[MPIDR_AFFLVL0])
+#define CLUSTER_PWR_STATE(state) ((state)->pwr_domain_state[MPIDR_AFFLVL1])
+
+#define CA35SS_SYSCFG_VBAR_CR	0x2084U
+
+static uintptr_t stm32_sec_entrypoint;
+static u_register_t cntfrq_core0;
+static uintptr_t saved_entrypoint;
+
+/*******************************************************************************
+ * STM32MP2 handler called when a CPU is about to enter standby.
+ * Called by core 1 to enter in wfi.
+ ******************************************************************************/
+static void stm32_cpu_standby(plat_local_state_t cpu_state)
+{
+	uint32_t interrupt = GIC_SPURIOUS_INTERRUPT;
+
+	assert(cpu_state == ARM_LOCAL_STATE_RET);
+
+	/*
+	 * Enter standby state.
+	 * Synchronize on memory accesses and instruction flow before the WFI
+	 * instruction.
+	 */
+	dsb();
+	isb();
+	while (interrupt == GIC_SPURIOUS_INTERRUPT) {
+		wfi();
+
+		/* Acknowledge IT */
+		interrupt = gicv2_acknowledge_interrupt();
+		/* If Interrupt == 1022 it will be acknowledged by non secure */
+		if ((interrupt != PENDING_G1_INTID) &&
+		    (interrupt != GIC_SPURIOUS_INTERRUPT)) {
+			gicv2_end_of_interrupt(interrupt);
+		}
+	}
+}
+
+/*******************************************************************************
+ * STM32MP2 handler called when a power domain is about to be turned on. The
+ * mpidr determines the CPU to be turned on.
+ * Called by core 0 to activate core 1.
+ ******************************************************************************/
+static int stm32_pwr_domain_on(u_register_t mpidr)
+{
+	unsigned long current_cpu_mpidr = read_mpidr();
+
+//	if (stm32mp_is_single_core()) {
+//		return PSCI_E_INTERN_FAIL;
+//	}
+
+	if (mpidr == current_cpu_mpidr) {
+		return PSCI_E_INVALID_PARAMS;
+	}
+
+	cntfrq_core0 = read_cntfrq_el0();
+	flush_dcache_range((uintptr_t)&cntfrq_core0, sizeof(u_register_t));
+
+	/* Set CA35SS_SYSCFG VBAR address to secure entrypoint */
+	mmio_write_32(A35SSC_BASE + CA35SS_SYSCFG_VBAR_CR, stm32_sec_entrypoint);
+
+	/* Reset CPU1 */
+	mmio_write_32(RCC_BASE + RCC_C1P1RSTCSETR, RCC_C1P1RSTCSETR_C1P1PORRST);
+
+	return PSCI_E_SUCCESS;
+}
+
+static void stm32_pwr_domain_off(const psci_power_state_t *target_state)
+{
+	/* Nothing to do */
+}
+
+static void stm32_pwr_domain_suspend(const psci_power_state_t *target_state)
+{
+	/* Nothing to do, power domain is not disabled */
+}
+
+/*******************************************************************************
+ * STM32MP2 handler called when a power domain has just been powered on after
+ * being turned off earlier. The target_state encodes the low power state that
+ * each level has woken up from.
+ * Called by core 1 just after wake up.
+ ******************************************************************************/
+static void stm32_pwr_domain_on_finish(const psci_power_state_t *target_state)
+{
+	stm32mp_gic_pcpu_init();
+
+	write_cntfrq_el0(cntfrq_core0);
+}
+
+/*******************************************************************************
+ * STM32MP2 handler called when a power domain has just been powered on after
+ * having been suspended earlier. The target_state encodes the low power state
+ * that each level has woken up from.
+ ******************************************************************************/
+static void stm32_pwr_domain_suspend_finish(const psci_power_state_t
+					    *target_state)
+{
+	/* Nothing to do, power domain is not disabled */
+}
+
+static void __dead2 stm32_pwr_domain_pwr_down_wfi(const psci_power_state_t
+						  *target_state)
+{
+	/*
+	 * Synchronize on memory accesses and instruction flow before
+	 * auto-reset from the WFI instruction.
+	 */
+	dsb();
+	isb();
+	wfi();
+
+	/* This shouldn't be reached */
+	panic();
+}
+
+static void __dead2 stm32_system_off(void)
+{
+	ERROR("stm32mp2 System Off: operation not handled.\n");
+	ERROR("calling reset instead.\n");
+	stm32mp_system_reset();
+}
+
+static void __dead2 stm32_system_reset(void)
+{
+	stm32mp_system_reset();
+}
+
+static int stm32_validate_power_state(unsigned int power_state,
+				      psci_power_state_t *req_state)
+{
+	unsigned int pstate_pwrlvl = psci_get_pstate_pwrlvl(power_state);
+	unsigned int pstate_type = psci_get_pstate_type(power_state);
+	unsigned int pstate_id = psci_get_pstate_id(power_state);
+
+	if (pstate_pwrlvl > PLAT_MAX_PWR_LVL) {
+		return PSCI_E_INVALID_PARAMS;
+	}
+
+	if (pstate_type != 0U) {
+		return PSCI_E_INVALID_PARAMS;
+	}
+
+	if (pstate_id != 0U) {
+		return PSCI_E_INVALID_PARAMS;
+	}
+
+	CORE_PWR_STATE(req_state) = ARM_LOCAL_STATE_RET;
+	CLUSTER_PWR_STATE(req_state) = ARM_LOCAL_STATE_RUN;
+
+	return PSCI_E_SUCCESS;
+}
+
+static int stm32_validate_ns_entrypoint(uintptr_t entrypoint)
+{
+	/* The non-secure entry point must be in DDR */
+	if (entrypoint < STM32MP_DDR_BASE) {
+		return PSCI_E_INVALID_ADDRESS;
+	}
+
+	saved_entrypoint = entrypoint;
+
+	return PSCI_E_SUCCESS;
+}
+
+static int stm32_node_hw_state(u_register_t target_cpu,
+			       unsigned int power_level)
+{
+	/*
+	 * The format of 'power_level' is implementation-defined, but 0 must
+	 * mean a CPU. Only allow level 0.
+	 */
+	if (power_level != MPIDR_AFFLVL0) {
+		return PSCI_E_INVALID_PARAMS;
+	}
+
+	/*
+	 * From psci view the CPU 0 is always ON,
+	 * CPU 1 can be SUSPEND or RUNNING.
+	 * Therefore do not manage POWER OFF state and always return HW_ON.
+	 */
+
+	return (int)HW_ON;
+}
+
+static void stm32_get_sys_suspend_power_state(psci_power_state_t *req_state)
+{
+}
+
+/*******************************************************************************
+ * Export the platform handlers. The ARM Standard platform layer will take care
+ * of registering the handlers with PSCI.
+ ******************************************************************************/
+static const plat_psci_ops_t stm32_psci_ops = {
+	.cpu_standby = stm32_cpu_standby,
+	.pwr_domain_on = stm32_pwr_domain_on,
+	.pwr_domain_off = stm32_pwr_domain_off,
+	.pwr_domain_suspend = stm32_pwr_domain_suspend,
+	.pwr_domain_on_finish = stm32_pwr_domain_on_finish,
+	.pwr_domain_suspend_finish = stm32_pwr_domain_suspend_finish,
+	.pwr_domain_pwr_down_wfi = stm32_pwr_domain_pwr_down_wfi,
+	.system_off = stm32_system_off,
+	.system_reset = stm32_system_reset,
+	.validate_power_state = stm32_validate_power_state,
+	.validate_ns_entrypoint = stm32_validate_ns_entrypoint,
+	.get_node_hw_state = stm32_node_hw_state,
+	.get_sys_suspend_power_state = stm32_get_sys_suspend_power_state,
+};
+
+/*******************************************************************************
+ * Export the platform specific power ops.
+ ******************************************************************************/
+int plat_setup_psci_ops(uintptr_t sec_entrypoint,
+			const plat_psci_ops_t **psci_ops)
+{
+	stm32_sec_entrypoint = sec_entrypoint;
+	*psci_ops = &stm32_psci_ops;
+
+	return 0;
+}
diff --git a/plat/st/stm32mp2/stm32mp2_private.c b/plat/st/stm32mp2/stm32mp2_private.c
new file mode 100644
index 000000000..3d67cd38f
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_private.c
@@ -0,0 +1,482 @@
+/*
+ * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+
+#include <arch_helpers.h>
+#include <drivers/arm/gicv2.h>
+#include <drivers/clk.h>
+#include <lib/mmio.h>
+#include <lib/xlat_tables/xlat_tables_v2.h>
+#include <plat/common/platform.h>
+
+#include <platform_def.h>
+
+#if STM32MP_DDR_FIP_IO_STORAGE && defined(IMAGE_BL2)
+/* Map the whole SRAM1 as secure, required to load DDR FW from FIP */
+#define SRAM1_MAP_SIZE	SRAM1_SIZE
+#else
+/* Map the beginning of SRAM1 as secure */
+#define SRAM1_MAP_SIZE	STM32MP_SEC_SRAM1_SIZE
+#endif
+
+#define MAP_SYSRAM	MAP_REGION_FLAT(STM32MP_SYSRAM_BASE, \
+					STM32MP_SYSRAM_SIZE, \
+					MT_MEMORY | \
+					MT_RW | \
+					MT_SECURE | \
+					MT_EXECUTE_NEVER)
+
+#define MAP_SEC_SYSRAM	MAP_REGION_FLAT(STM32MP_SEC_SYSRAM_BASE, \
+					STM32MP_SEC_SYSRAM_SIZE, \
+					MT_MEMORY | \
+					MT_RW | \
+					MT_SECURE | \
+					MT_EXECUTE_NEVER)
+
+#if STM32MP_USB_PROGRAMMER
+#define MAP_SEC_DEVICE_SYSRAM	MAP_REGION_FLAT(STM32MP_SEC_DEVICE_SYSRAM_BASE, \
+					STM32MP_SEC_DEVICE_SYSRAM_SIZE, \
+					MT_DEVICE | \
+					MT_RW | \
+					MT_SECURE | \
+					MT_EXECUTE_NEVER)
+
+#define MAP_SRAM2	MAP_REGION_FLAT(SRAM2_BASE, \
+					SRAM2_SIZE, \
+					MT_MEMORY | \
+					MT_RW | \
+					MT_SECURE | \
+					MT_EXECUTE_NEVER)
+#endif
+
+/* Non-secure SYSRAM is used a uncached memory for SCMI message transfer */
+#define MAP_NS_SYSRAM	MAP_REGION_FLAT(STM32MP_NS_SYSRAM_BASE, \
+					STM32MP_NS_SYSRAM_SIZE, \
+					MT_DEVICE | \
+					MT_RW | \
+					MT_NS | \
+					MT_EXECUTE_NEVER)
+
+#define MAP_SRAM1	MAP_REGION_FLAT(SRAM1_BASE, \
+					SRAM1_MAP_SIZE, \
+					MT_MEMORY | \
+					MT_RW | \
+					MT_SECURE | \
+					MT_EXECUTE_NEVER)
+
+#define MAP_DEVICE	MAP_REGION_FLAT(STM32MP_DEVICE_BASE, \
+					STM32MP_DEVICE_SIZE, \
+					MT_DEVICE | \
+					MT_RW | \
+					MT_SECURE | \
+					MT_EXECUTE_NEVER)
+
+#if defined(IMAGE_BL2)
+static const mmap_region_t stm32mp2_mmap[] = {
+#if STM32MP_USB_PROGRAMMER
+	MAP_SEC_SYSRAM,
+	MAP_SEC_DEVICE_SYSRAM,
+	MAP_SRAM2,
+#else
+	MAP_SYSRAM,
+#endif
+	MAP_SRAM1,
+	MAP_DEVICE,
+	{0}
+};
+#endif
+#if defined(IMAGE_BL31)
+static const mmap_region_t stm32mp2_mmap[] = {
+	MAP_SEC_SYSRAM,
+	MAP_NS_SYSRAM,
+	MAP_SRAM1,
+	MAP_DEVICE,
+	{0}
+};
+#endif
+
+void configure_mmu(void)
+{
+	mmap_add(stm32mp2_mmap);
+	init_xlat_tables();
+
+	enable_mmu_el3(0);
+}
+
+uintptr_t stm32_get_gpio_bank_base(unsigned int bank)
+{
+	if (bank == GPIO_BANK_Z) {
+		return GPIOZ_BASE;
+	}
+
+	assert(GPIO_BANK_A == 0 && bank <= GPIO_BANK_K);
+
+	return GPIOA_BASE + (bank * GPIO_BANK_OFFSET);
+}
+
+uint32_t stm32_get_gpio_bank_offset(unsigned int bank)
+{
+	if (bank == GPIO_BANK_Z) {
+		return 0;
+	}
+
+	assert(GPIO_BANK_A == 0 && bank <= GPIO_BANK_K);
+
+	return bank * GPIO_BANK_OFFSET;
+}
+
+unsigned long stm32_get_gpio_bank_clock(unsigned int bank)
+{
+	if (bank == GPIO_BANK_Z) {
+		return CK_BUS_GPIOZ;
+	}
+
+	assert(GPIO_BANK_A == 0 && bank <= GPIO_BANK_K);
+
+	return CK_BUS_GPIOA + (bank - GPIO_BANK_A);
+}
+
+#if STM32MP_UART_PROGRAMMER || !defined(IMAGE_BL2)
+/*
+ * UART Management
+ */
+static const uintptr_t stm32mp2_uart_addresses[9] = {
+	USART1_BASE,
+	USART2_BASE,
+	USART3_BASE,
+	UART4_BASE,
+	UART5_BASE,
+	USART6_BASE,
+	UART7_BASE,
+	UART8_BASE,
+	UART9_BASE,
+};
+
+uintptr_t get_uart_address(uint32_t instance_nb)
+{
+	if ((instance_nb == 0U) ||
+	    (instance_nb > ARRAY_SIZE(stm32mp2_uart_addresses))) {
+		return 0U;
+	}
+
+	return stm32mp2_uart_addresses[instance_nb - 1U];
+}
+#endif
+
+uint32_t stm32mp_get_chip_version(void)
+{
+	return stm32mp2_syscfg_get_chip_version();
+}
+
+uint32_t stm32mp_get_chip_dev_id(void)
+{
+	return stm32mp2_syscfg_get_chip_dev_id();
+}
+
+static uint32_t get_part_number(void)
+{
+	static uint32_t part_number;
+
+	if (part_number != 0U) {
+		return part_number;
+	}
+
+	if (stm32_get_otp_value(PART_NUMBER_OTP, &part_number) != 0) {
+		panic();
+	}
+
+	return part_number;
+}
+
+static uint32_t get_cpu_package(void)
+{
+	static uint32_t package = UINT32_MAX;
+
+	if (package == UINT32_MAX) {
+		if (stm32_get_otp_value(PACKAGE_OTP, &package) != 0) {
+			panic();
+		}
+	}
+
+	return (package & PACKAGE_OTP_PKG_MASK) >> PACKAGE_OTP_PKG_SHIFT;
+}
+
+void stm32mp_get_soc_name(char name[STM32_SOC_NAME_SIZE])
+{
+	char *cpu_s, *cpu_r, *pkg;
+
+	/* MPUs Part Numbers */
+	switch (get_part_number()) {
+	case STM32MP257C_PART_NB:
+		cpu_s = "257C";
+		break;
+	case STM32MP257A_PART_NB:
+		cpu_s = "257A";
+		break;
+	case STM32MP255C_PART_NB:
+		cpu_s = "255C";
+		break;
+	case STM32MP255A_PART_NB:
+		cpu_s = "255A";
+		break;
+	case STM32MP253C_PART_NB:
+		cpu_s = "253C";
+		break;
+	case STM32MP253A_PART_NB:
+		cpu_s = "253A";
+		break;
+	case STM32MP251C_PART_NB:
+		cpu_s = "251C";
+		break;
+	case STM32MP251A_PART_NB:
+		cpu_s = "251A";
+		break;
+	case STM32MP257F_PART_NB:
+		cpu_s = "257F";
+		break;
+	case STM32MP257D_PART_NB:
+		cpu_s = "257D";
+		break;
+	case STM32MP255F_PART_NB:
+		cpu_s = "255F";
+		break;
+	case STM32MP255D_PART_NB:
+		cpu_s = "255D";
+		break;
+	case STM32MP253F_PART_NB:
+		cpu_s = "253F";
+		break;
+	case STM32MP253D_PART_NB:
+		cpu_s = "253D";
+		break;
+	case STM32MP251F_PART_NB:
+		cpu_s = "251F";
+		break;
+	case STM32MP251D_PART_NB:
+		cpu_s = "251D";
+		break;
+	default:
+		cpu_s = "????";
+		break;
+	}
+
+	/* Package */
+	switch (get_cpu_package()) {
+	case STM32MP25_PKG_CUSTOM:
+		pkg = "XX";
+		break;
+	case STM32MP25_PKG_AL_TBGA361:
+		pkg = "AL";
+		break;
+	case STM32MP25_PKG_AK_TBGA424:
+		pkg = "AK";
+		break;
+	case STM32MP25_PKG_AI_TBGA436:
+		pkg = "AI";
+		break;
+	default:
+		pkg = "??";
+		break;
+	}
+
+	/* REVISION */
+	switch (stm32mp_get_chip_version()) {
+	case STM32MP2_REV_A:
+		cpu_r = "A";
+		break;
+	default:
+		cpu_r = "?";
+		break;
+	}
+
+	snprintf(name, STM32_SOC_NAME_SIZE,
+		 "STM32MP%s%s Rev.%s", cpu_s, pkg, cpu_r);
+}
+
+void stm32mp_print_cpuinfo(void)
+{
+	char name[STM32_SOC_NAME_SIZE];
+
+	stm32mp_get_soc_name(name);
+	NOTICE("CPU: %s\n", name);
+}
+
+void stm32mp_print_boardinfo(void)
+{
+	uint32_t board_id = 0U;
+
+	if (stm32_get_otp_value(BOARD_ID_OTP, &board_id) != 0) {
+		return;
+	}
+
+	if (board_id != 0U) {
+		stm32_display_board_info(board_id);
+	}
+}
+
+/* Return true when SoC provides a single Cortex-A35 core, and false otherwise */
+bool stm32mp_is_single_core(void)
+{
+	bool single_core = false;
+
+	switch (get_part_number()) {
+	case STM32MP251A_PART_NB:
+	case STM32MP251C_PART_NB:
+	case STM32MP251D_PART_NB:
+	case STM32MP251F_PART_NB:
+		single_core = true;
+		break;
+	default:
+		break;
+	}
+
+	return single_core;
+}
+
+/* Return true when device is in closed state */
+bool stm32mp_is_closed_device(void)
+{
+	return bsec_mode_is_closed_device();
+}
+
+/* Return true when device supports secure boot */
+bool stm32mp_is_auth_supported(void)
+{
+	bool supported = false;
+
+	switch (get_part_number()) {
+	case STM32MP251C_PART_NB:
+	case STM32MP251F_PART_NB:
+	case STM32MP253C_PART_NB:
+	case STM32MP253F_PART_NB:
+	case STM32MP255C_PART_NB:
+	case STM32MP255F_PART_NB:
+	case STM32MP257C_PART_NB:
+	case STM32MP257F_PART_NB:
+		supported = true;
+		break;
+	default:
+		break;
+	}
+
+	return supported;
+}
+
+bool stm32mp_skip_boot_device_after_standby(void)
+{
+	return false;
+}
+
+int stm32_risaf_get_instance(uintptr_t base)
+{
+	switch (base) {
+	case RISAF2_BASE:
+		return (int)RISAF2_INST;
+	case RISAF4_BASE:
+		return (int)RISAF4_INST;
+	default:
+		return -ENODEV;
+	}
+}
+
+uintptr_t stm32_risaf_get_base(int instance)
+{
+	switch (instance) {
+	case RISAF2_INST:
+		return (uintptr_t)RISAF2_BASE;
+	case RISAF4_INST:
+		return (uintptr_t)RISAF4_BASE;
+	default:
+		return 0U;
+	}
+}
+
+int stm32_risaf_get_max_region(int instance)
+{
+	switch (instance) {
+	case RISAF2_INST:
+		return (int)RISAF2_MAX_REGION;
+	case RISAF4_INST:
+		return (int)RISAF4_MAX_REGION;
+	default:
+		return 0;
+	}
+}
+
+uintptr_t stm32_risaf_get_memory_base(int instance)
+{
+	switch (instance) {
+	case RISAF2_INST:
+		return (uintptr_t)STM32MP_OSPI_MM_BASE;
+	case RISAF4_INST:
+		return (uintptr_t)STM32MP_DDR_BASE;
+	default:
+		return 0U;
+	}
+}
+
+uint32_t stm32_risaf_get_memory_size(int instance)
+{
+	switch (instance) {
+	case RISAF2_INST:
+		return STM32MP_OSPI_MM_SIZE;
+	case RISAF4_INST:
+		return dt_get_ddr_size();
+	default:
+		return 0U;
+	}
+}
+
+void stm32_risaf_preconf_process(uint32_t inst_mask)
+{
+	if ((inst_mask & BIT(RISAF2_INST)) == BIT(RISAF2_INST))	{
+		/*
+		 * At least one of the OSPI clock (OSPI1 or OSPI2) must be enabled
+		 * before configuring RISAF2.
+		 */
+		clk_enable(CK_KER_OSPI1);
+	}
+}
+
+void stm32_risaf_postconf_process(uint32_t inst_mask)
+{
+	if ((inst_mask & BIT(RISAF2_INST)) == BIT(RISAF2_INST))	{
+		clk_disable(CK_KER_OSPI1);
+	}
+}
+
+#ifdef CFG_WORKAROUND_VSW0V8
+/* the Backup register are not available = replaced by Backup RAM in stm32_get_bkpr_itf_addr () */
+#undef CK_BUS_RTC
+#define CK_BUS_RTC CK_BUS_BKPSRAM
+#endif
+
+static uintptr_t stm32_get_bkpr_itf_addr(void)
+{
+	/* TODO: check the information from DT (ticket 115998)*/
+	return tamp_bkpr(96);
+}
+
+void stm32_save_boot_interface(uint32_t interface, uint32_t instance)
+{
+	uintptr_t bkpr = stm32_get_bkpr_itf_addr();
+
+	stm32_save_boot_itf(interface, instance, CK_BUS_RTC, bkpr);
+}
+
+void stm32_get_boot_interface(uint32_t *interface, uint32_t *instance)
+{
+	uintptr_t bkpr = stm32_get_bkpr_itf_addr();
+
+	stm32_get_boot_itf(interface, instance, CK_BUS_RTC, bkpr);
+}
+
+uintptr_t stm32_ddrdbg_get_base(void)
+{
+	return DDRDBG_BASE;
+}
diff --git a/plat/st/stm32mp2/stm32mp2_pwr.c b/plat/st/stm32mp2/stm32mp2_pwr.c
new file mode 100644
index 000000000..9c3538dc0
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_pwr.c
@@ -0,0 +1,188 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+#include <drivers/regulator.h>
+#include <lib/mmio.h>
+#include <lib/utils_def.h>
+
+#include <platform_def.h>
+#include <stm32mp2_private.h>
+
+#define IO_VOLTAGE_THRESHOLD_MV 2700
+
+struct pwr_regu {
+	const char *node_name;
+	uint32_t enable_reg;
+	uint32_t enable_mask;
+	uint32_t ready_mask;
+	uint32_t valid_mask;
+	uint32_t vrsel_mask;
+	int comp_idx;
+	const char *supply_name;
+};
+
+enum pwr_regulator_id {
+	IOD_VDDIO1,
+	IOD_VDDIO2,
+	IOD_VDDIO3,
+	IOD_VDDIO4,
+	IOD_VDDIO,
+	PWR_REGU_COUNT
+};
+
+static const struct pwr_regu pwr_regulators[] = {
+	 [IOD_VDDIO1] = {
+		.node_name = "vddio1",
+		.enable_reg = PWR_CR8,
+		.enable_mask = PWR_CR8_VDDIO1VMEN,
+		.ready_mask = PWR_CR8_VDDIO1RDY,
+		.valid_mask = PWR_CR8_VDDIO1SV,
+		.vrsel_mask = PWR_CR8_VDDIO1VRSEL,
+		.comp_idx = SYSFG_VDDIO1_ID,
+		.supply_name = "vddio1",
+	 },
+	 [IOD_VDDIO2] = {
+		.node_name = "vddio2",
+		.enable_reg = PWR_CR7,
+		.enable_mask = PWR_CR7_VDDIO2VMEN,
+		.ready_mask = PWR_CR7_VDDIO2RDY,
+		.valid_mask = PWR_CR7_VDDIO2SV,
+		.vrsel_mask = PWR_CR7_VDDIO2VRSEL,
+		.comp_idx = SYSFG_VDDIO2_ID,
+		.supply_name = "vddio2",
+	 },
+	 [IOD_VDDIO3] = {
+		.node_name = "vddio3",
+		.enable_reg = PWR_CR1,
+		.enable_mask = PWR_CR1_VDDIO3VMEN,
+		.ready_mask = PWR_CR1_VDDIO3RDY,
+		.valid_mask = PWR_CR1_VDDIO3SV,
+		.vrsel_mask = PWR_CR1_VDDIO3VRSEL,
+		.comp_idx = SYSFG_VDDIO3_ID,
+		.supply_name = "vddio3",
+	 },
+	 [IOD_VDDIO4] = {
+		.node_name = "vddio4",
+		.enable_reg = PWR_CR1,
+		.enable_mask = PWR_CR1_VDDIO4VMEN,
+		.ready_mask = PWR_CR1_VDDIO4RDY,
+		.valid_mask = PWR_CR1_VDDIO4SV,
+		.vrsel_mask = PWR_CR1_VDDIO4VRSEL,
+		.comp_idx = SYSFG_VDDIO4_ID,
+		.supply_name = "vddio4",
+	 },
+	 [IOD_VDDIO] = {
+		.node_name = "vddio",
+		.enable_reg = PWR_CR1,
+		.vrsel_mask = PWR_CR1_VDDIOVRSEL,
+		.comp_idx = SYSFG_VDD_IO_ID,
+		.supply_name = "vdd",
+	 },
+};
+
+static bool stm32mp2_pwr_domain_is_enabled(const struct pwr_regu *regu)
+{
+	uint32_t val = mmio_read_32(stm32mp_pwr_base() + regu->enable_reg);
+	bool status = (val & (regu->valid_mask | regu->enable_reg)) != 0U;
+
+	VERBOSE("pwr: IO doamin status for %s is %u\n", regu->node_name, status);
+
+	return status;
+
+}
+
+static int stm32mp2_pwr_handle_vrsel(void *fdt, int node, const struct pwr_regu *regu)
+{
+	struct rdev *supply;
+	int mv;
+
+	VERBOSE("Check VRSEL for %s\n", regu->node_name);
+
+	/* Look for supply */
+	supply = regulator_get_by_supply_name(fdt, node, regu->supply_name);
+	if (supply == NULL) {
+		VERBOSE("Failed to get %s-supply\n", regu->supply_name);
+		return 0;
+	}
+
+	mv = regulator_get_voltage(supply);
+	if (mv < 0) {
+		return mv;
+	}
+
+	if (mv < IO_VOLTAGE_THRESHOLD_MV) {
+		VERBOSE("Enable VRSEL for %s\n", regu->node_name);
+
+		mmio_setbits_32(stm32mp_pwr_base() + regu->enable_reg, regu->vrsel_mask);
+
+		if ((mmio_read_32(stm32mp_pwr_base() + regu->enable_reg) &
+		    regu->vrsel_mask) == 0U) {
+			WARN("Could not enable VRSEL for %s\n", regu->node_name);
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * @brief  Enable IO compensation for the IO domains that are already ON,
+ *         and set domain to high speed depending on power supply voltage.
+ * @retval 0 or error.
+ */
+int stm32mp2_pwr_init_io_domains(void)
+{
+	void *fdt;
+	int node;
+	int subnode = 0;
+
+	VERBOSE("Init IO domains\n");
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	node = fdt_node_offset_by_compatible(fdt, -1, DT_PWR_COMPAT);
+	if (node < 0) {
+		ERROR("Pwr node not found\n");
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	fdt_for_each_subnode(subnode, fdt, node) {
+		const struct pwr_regu *regu = NULL;
+		int i;
+
+		/* Find regu from node name */
+		const char *node_name = fdt_get_name(fdt, subnode, NULL);
+
+		for (i = 0; i < PWR_REGU_COUNT; i++) {
+			regu = &pwr_regulators[i];
+
+			if (strcmp(regu->node_name, node_name) == 0) {
+				break;
+			}
+		}
+
+		if (i == PWR_REGU_COUNT) {
+			continue;
+		}
+
+		if (stm32mp2_pwr_domain_is_enabled(regu)) {
+			int ret;
+
+			VERBOSE("Init IO domain %d\n", i);
+
+			ret = stm32mp2_pwr_handle_vrsel(fdt, subnode, regu);
+			if (ret < 0) {
+				return ret;
+			}
+
+			stm32mp2_syscfg_enable_io_compensation(regu->comp_idx);
+		}
+	}
+
+	return 0;
+}
diff --git a/plat/st/stm32mp2/stm32mp2_syscfg.c b/plat/st/stm32mp2/stm32mp2_syscfg.c
new file mode 100644
index 000000000..3baacb934
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_syscfg.c
@@ -0,0 +1,166 @@
+/*
+ * Copyright (c) 2019-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <platform_def.h>
+
+#include <common/debug.h>
+#include <drivers/delay_timer.h>
+#include <lib/mmio.h>
+#include <lib/utils_def.h>
+
+#include <stm32mp2_private.h>
+
+/*
+ * SYSCFG register offsets (base relative)
+ */
+#define SYSCFG_OCTOSPIAMCR		0x2C00U
+#define SYSCFG_DEVICEID			0x6400U
+
+/*
+ * SYSCFG_OCTOSPIAMCR Register
+ */
+#define SYSCFG_OCTOSPIAMCR_OAM_MASK	GENMASK_32(2, 0)
+
+/*
+ * SYSCFG_DEVICEID Register
+ */
+#define SYSCFG_DEVICEID_DEV_ID_MASK	GENMASK_32(11, 0)
+#define SYSCFG_DEVICEID_REV_ID_MASK	GENMASK_32(31, 16)
+#define SYSCFG_DEVICEID_REV_ID_SHIFT	16
+
+/*
+ * SYSCFG IO Compensation Registers
+ */
+#define SYSCFG_VDDIO3CCCR		0x4000U
+#define SYSCFG_VDDIO4CCCR		0x4008U
+#define SYSCFG_VDDCCCR			0x4010U
+#define SYSCFG_VDDIO2CCCR		0x4018U
+#define SYSCFG_VDDIO1CCCR		0x4020U
+
+/* IO compensation CCR registers bit definition */
+#define SYSCFG_CCCR_CS			BIT(9)
+#define SYSCFG_CCCR_EN			BIT(8)
+#define SYSCFG_CCCR_RAPSRC_MASK		GENMASK(7, 4)
+#define SYSCFG_CCCR_RANSRC_MASK		GENMASK(3, 0)
+
+/* IO compensation CCSR registers bit definition */
+#define SYSCFG_CCSR_READY		BIT(8)
+#define SYSCFG_CCSR_APSRC_MASK		GENMASK(7, 4)
+#define SYSCFG_CCSR_ANSRC_MASK		GENMASK(3, 0)
+
+#define SYSCFG_CCSR_READY_TIMEOUT_US	1000U
+
+/* ICN registers */
+#define SYSCFG_ICNQPCR1			0x2000U
+#define SYSCFG_ICNQPCR2			0x2004U
+
+/*
+ * SYSCFG IO compensation register offsets (base relative)
+ */
+static uint32_t syscfg_cccr_offset[SYSFG_NB_IO_ID] = {
+	[SYSFG_VDDIO1_ID] = SYSCFG_VDDIO1CCCR,
+	[SYSFG_VDDIO2_ID] = SYSCFG_VDDIO2CCCR,
+	[SYSFG_VDDIO3_ID] = SYSCFG_VDDIO3CCCR,
+	[SYSFG_VDDIO4_ID] = SYSCFG_VDDIO4CCCR,
+	[SYSFG_VDD_IO_ID] = SYSCFG_VDDCCCR,
+};
+
+/*
+ * @brief  Get silicon revision from SYSCFG registers.
+ * @retval chip version (REV_ID).
+ */
+uint32_t stm32mp2_syscfg_get_chip_version(void)
+{
+	return (mmio_read_32(SYSCFG_BASE + SYSCFG_DEVICEID) &
+		SYSCFG_DEVICEID_REV_ID_MASK) >> SYSCFG_DEVICEID_REV_ID_SHIFT;
+}
+
+/*
+ * @brief  Get device ID from SYSCFG registers.
+ * @retval device ID (DEV_ID).
+ */
+uint32_t stm32mp2_syscfg_get_chip_dev_id(void)
+{
+	return mmio_read_32(SYSCFG_BASE + SYSCFG_DEVICEID) & SYSCFG_DEVICEID_DEV_ID_MASK;
+}
+
+size_t stm32mp2_syscfg_get_mm_size(uint8_t bank)
+{
+	uint32_t amcr = mmio_read_32(SYSCFG_BASE + SYSCFG_OCTOSPIAMCR);
+	size_t addr_mapping1 = 0U;
+	size_t addr_mapping2 = 0U;
+
+	switch (amcr & SYSCFG_OCTOSPIAMCR_OAM_MASK) {
+	case 0:
+		addr_mapping1 = SZ_256M;
+		break;
+	case 1:
+		addr_mapping1 = SZ_128M + SZ_64M;
+		addr_mapping2 = SZ_64M;
+		break;
+	case 2:
+		addr_mapping1 = SZ_128M;
+		addr_mapping2 = SZ_128M;
+		break;
+	case 3:
+		addr_mapping1 = SZ_64M;
+		addr_mapping2 = SZ_128M + SZ_64M;
+		break;
+	default:
+		addr_mapping2 = SZ_256M;
+		break;
+	}
+
+	return (bank == 0U) ? addr_mapping1 : addr_mapping2;
+}
+
+/*
+ * @brief  Enable IO compensation for an IO domain.
+ * @param  id: IO compensation ID
+ * @retval 0.
+ */
+void stm32mp2_syscfg_enable_io_compensation(enum syscfg_io_ids id)
+{
+	uintptr_t cccr_addr = SYSCFG_BASE + syscfg_cccr_offset[id];
+	uintptr_t ccsr_addr = cccr_addr + 4U;
+	uint64_t timeout_ref;
+
+	VERBOSE("Enable IO comp for id %u\n", id);
+
+	if ((mmio_read_32(ccsr_addr) & SYSCFG_CCSR_READY) != 0U) {
+		return;
+	}
+
+	mmio_setbits_32(cccr_addr, SYSCFG_CCCR_EN);
+
+	timeout_ref = timeout_init_us(SYSCFG_CCSR_READY_TIMEOUT_US);
+
+	while ((mmio_read_32(ccsr_addr) & SYSCFG_CCSR_READY) == 0U)
+		if (timeout_elapsed(timeout_ref)) {
+			WARN("IO compensation cell not ready\n");
+			/* Allow an almost silent failure here */
+			break;
+		}
+
+	mmio_clrbits_32(cccr_addr, SYSCFG_CCCR_CS);
+}
+
+/*
+ * @brief  Set ICN QOS priority per master.
+ *	   Values are fixed to be compliant with DDR timings
+ *	   Temporary fix on cut1 to limit system freeze
+ * @retval 0.
+ */
+void stm32mp2_syscfg_set_icn_qos(void)
+{
+	uintptr_t addr = SYSCFG_BASE + SYSCFG_ICNQPCR1;
+	mmio_write_32(addr, 0xBBB66637);
+
+	addr = SYSCFG_BASE + SYSCFG_ICNQPCR2;
+	mmio_write_32(addr, 0x844ED95A);
+
+	INFO("ICN QOS priorities configured\n");
+}
diff --git a/plat/st/stm32mp2/stm32mp2_topology.c b/plat/st/stm32mp2/stm32mp2_topology.c
new file mode 100644
index 000000000..705fdb407
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_topology.c
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2019, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <platform_def.h>
+
+#include <lib/psci/psci.h>
+#include <plat/common/platform.h>
+
+/* 1 cluster, all cores into */
+static const unsigned char stm32mp2_power_domain_tree_desc[] = {
+	PLATFORM_CLUSTER_COUNT,
+	PLATFORM_CORE_COUNT,
+};
+
+/* This function returns the platform topology */
+const unsigned char *plat_get_power_domain_tree_desc(void)
+{
+	return stm32mp2_power_domain_tree_desc;
+}
+
+/*******************************************************************************
+ * This function implements a part of the critical interface between the psci
+ * generic layer and the platform that allows the former to query the platform
+ * to convert an MPIDR to a unique linear index. An error code (-1) is returned
+ * in case the MPIDR is invalid.
+ ******************************************************************************/
+int plat_core_pos_by_mpidr(u_register_t mpidr)
+{
+	unsigned int cluster_id, cpu_id;
+	u_register_t mpidr_copy = mpidr;
+
+	mpidr_copy &= MPIDR_AFFINITY_MASK;
+
+	if ((mpidr_copy & ~(MPIDR_CLUSTER_MASK | MPIDR_CPU_MASK)) != 0U) {
+		return -1;
+	}
+
+	cluster_id = (mpidr_copy >> MPIDR_AFF1_SHIFT) & MPIDR_AFFLVL_MASK;
+	cpu_id = (mpidr_copy >> MPIDR_AFF0_SHIFT) & MPIDR_AFFLVL_MASK;
+
+	if (cluster_id >= PLATFORM_CLUSTER_COUNT) {
+		return -1;
+	}
+
+	/*
+	 * Validate cpu_id by checking whether it represents a CPU in one
+	 * of the two clusters present on the platform.
+	 */
+	if (cpu_id >= PLATFORM_CORE_COUNT) {
+		return -1;
+	}
+
+	return (int)cpu_id;
+}
diff --git a/plat/st/stm32mp2/stm32mp2_usb_dfu.c b/plat/st/stm32mp2/stm32mp2_usb_dfu.c
new file mode 100644
index 000000000..23b08c37e
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_usb_dfu.c
@@ -0,0 +1,375 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <limits.h>
+#include <string.h>
+
+#include <common/debug.h>
+#include <drivers/st/bsec.h>
+#include <drivers/st/usb_dwc3.h>
+#include <drivers/usb_device.h>
+
+#include <platform_def.h>
+#include <stm32cubeprogrammer.h>
+#include <stm32mp_common.h>
+#include <usb_dfu.h>
+
+/*  String size (1 byte) + type (1 byte) + 24 UTF16 characters: 2 bytes each */
+#define SIZ_STRING_SERIAL		U(24)
+#define USB_SIZ_STRING_SERIAL		(1U + 1U + (SIZ_STRING_SERIAL * 2U))
+#define USBD_MAX_STR_DESC_SIZ		U(0x100)
+#define USBD_VID			U(0x0483)
+#define USBD_PID			U(0xDF11)
+#define USBD_LANGID_STRING		U(0x409)
+#define USBD_MANUFACTURER_STRING	"STMicroelectronics"
+#define USBD_CONFIGURATION_STRING	"DFU Config"
+#define USBD_INTERFACE_STRING		"DFU Interface"
+
+#define USB_DFU_ITF_NUM			U(3)
+
+#define USB_DFU_CONFIG_DESC_SIZ		USB_DFU_DESC_SIZ(USB_DFU_ITF_NUM)
+
+/* DFU devices */
+static struct usb_dfu_handle usb_dfu_handle;
+
+/* USB Standard Device Descriptor */
+static const uint8_t usb_stm32mp2_desc[USB_LEN_DEV_DESC] = {
+	USB_LEN_DEV_DESC,           /* bLength */
+	USB_DESC_TYPE_DEVICE,       /* bDescriptorType */
+	0x00,                       /* bcdUSB */
+	0x02,                       /* version */
+	0x00,                       /* bDeviceClass */
+	0x00,                       /* bDeviceSubClass */
+	0x00,                       /* bDeviceProtocol */
+	USB_MAX_EP0_SIZE,           /* bMaxPacketSize */
+	LOBYTE(USBD_VID),           /* idVendor */
+	HIBYTE(USBD_VID),           /* idVendor */
+	LOBYTE(USBD_PID),           /* idVendor */
+	HIBYTE(USBD_PID),           /* idVendor */
+	0x00,                       /* bcdDevice rel. 2.00 */
+	0x02,
+	USBD_IDX_MFC_STR,           /* Index of manufacturer string */
+	USBD_IDX_PRODUCT_STR,       /* Index of product string */
+	USBD_IDX_SERIAL_STR,        /* Index of serial number string */
+	USBD_MAX_NUM_CONFIGURATION  /* bNumConfigurations */
+}; /* USB_DeviceDescriptor */
+
+/* USB Standard String Descriptor */
+static const uint8_t usb_stm32mp2_lang_id_desc[USB_LEN_LANGID_STR_DESC] = {
+	USB_LEN_LANGID_STR_DESC,
+	USB_DESC_TYPE_STRING,
+	LOBYTE(USBD_LANGID_STRING),
+	HIBYTE(USBD_LANGID_STRING),
+};
+
+/* USB Standard Device Descriptor */
+static const uint8_t
+usbd_stm32mp2_qualifier_desc[USB_LEN_DEV_QUALIFIER_DESC] = {
+	USB_LEN_DEV_QUALIFIER_DESC,
+	USB_DESC_TYPE_DEVICE_QUALIFIER,
+	0x00,
+	0x02,
+	0x00,
+	0x00,
+	0x00,
+	0x40,
+	0x01,
+	0x00,
+};
+
+/* USB serial number: build dynamically */
+static uint8_t usb_stm32mp2_serial[USB_SIZ_STRING_SERIAL + 1];
+
+/* USB DFU device Configuration Descriptor */
+static const uint8_t usb_stm32mp2_config_desc[USB_DFU_CONFIG_DESC_SIZ] = {
+	0x09, /* bLength: Configuration Descriptor size */
+	USB_DESC_TYPE_CONFIGURATION, /* bDescriptorType: Configuration */
+	USB_DFU_CONFIG_DESC_SIZ, /* wTotalLength: Bytes returned */
+	0x00,
+	0x01, /* bNumInterfaces: 1 interface */
+	0x01, /* bConfigurationValue: Configuration value */
+	0x02, /* iConfiguration: Index of string descriptor for configuration */
+	0xC0, /* bmAttributes: bus powered and Supprts Remote Wakeup */
+	0x32, /* MaxPower 100 mA: this current is used for detecting Vbus */
+
+	/* Descriptor of DFU interface 0 Alternate setting 0..N */
+	USBD_DFU_IF_DESC(0),
+	USBD_DFU_IF_DESC(1),
+	USBD_DFU_IF_DESC(2),
+	/* DFU Functional Descriptor */
+	0x09, /* blength = 9 Bytes */
+	DFU_DESCRIPTOR_TYPE, /* DFU Functional Descriptor */
+	DFU_BM_ATTRIBUTE, /* bmAttribute for DFU */
+	0xFF, /* DetachTimeOut = 255 ms */
+	0x00,
+	/* WARNING: In DMA mode the multiple MPS packets feature
+	 *  is still not supported ==> In this case,
+	 *  when using DMA USBD_DFU_XFER_SIZE should be set
+	 *  to 64 in usbd_conf.h
+	 */
+	TRANSFER_SIZE_BYTES(USBD_DFU_XFER_SIZE), /* TransferSize = 1024 Byte */
+	((USB_DFU_VERSION >> 0) & 0xFF), /* bcdDFUVersion */
+	((USB_DFU_VERSION >> 8) & 0xFF)
+};
+
+const char *const if_desc_string[USB_DFU_ITF_NUM] = {
+	"@DDR FIP /0x02/1*32Ke",
+	"@FIP /0x03/1*16Me",
+	"@virtual /0xF1/1*512Ba"
+};
+
+/* Buffer to build the unicode string provided to USB device stack */
+static uint8_t usb_str_dec[USBD_MAX_STR_DESC_SIZ];
+
+/*
+ * Convert Ascii string into unicode one
+ * desc : descriptor buffer
+ * unicode : Formatted string buffer (unicode)
+ * len : descriptor length
+ */
+static void stm32mp2_get_string(const char *desc, uint8_t *unicode, uint16_t *len)
+{
+	uint8_t idx = 0U;
+
+	if (desc == NULL) {
+		return;
+	}
+
+	*len =  strlen(desc) * 2U + 2U;
+	unicode[idx++] = *len;
+	unicode[idx++] =  USB_DESC_TYPE_STRING;
+
+	while (*desc != '\0') {
+		unicode[idx++] = *desc++;
+		unicode[idx++] =  0x00U;
+	}
+}
+
+/*
+ * Create the serial number string descriptor
+ */
+static void update_serial_num_string(void)
+{
+	char serial_string[SIZ_STRING_SERIAL + 2U];
+	/* serial number is set to 0 */
+	uint32_t deviceserial[UID_WORD_NB] = {0U, 0U, 0U};
+	uint16_t length;
+
+	if (stm32_get_uid_otp(deviceserial) != 0) {
+		return;
+	}
+
+	/* build serial number with OTP value as in ROM code */
+	snprintf(serial_string, sizeof(serial_string), "%08X%08X%08X",
+		 deviceserial[0], deviceserial[1], deviceserial[2]);
+
+	length = USB_SIZ_STRING_SERIAL;
+	stm32mp2_get_string(serial_string, usb_stm32mp2_serial, &length);
+}
+
+/*
+ * Return Device Qualifier descriptor
+ * length : pointer data length
+ * return : pointer to descriptor buffer
+ */
+static uint8_t *stm32mp2_get_qualifier_desc(uint16_t *length)
+{
+	*length = sizeof(usbd_stm32mp2_qualifier_desc);
+
+	return (uint8_t *)usbd_stm32mp2_qualifier_desc;
+}
+
+/*
+ * Return configuration descriptor
+ * length : pointer data length
+ * return : pointer to descriptor buffer
+ */
+static uint8_t *stm32mp2_get_config_desc(uint16_t *length)
+{
+	*length = sizeof(usb_stm32mp2_config_desc);
+
+	return (uint8_t *)usb_stm32mp2_config_desc;
+}
+
+/*
+ * Returns the device descriptor.
+ * length: Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp2_device_desc(uint16_t *length)
+{
+	*length = sizeof(usb_stm32mp2_desc);
+
+	return (uint8_t *)usb_stm32mp2_desc;
+}
+
+/*
+ * Returns the LangID string descriptor.
+ * length: Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp2_lang_id_desc(uint16_t *length)
+{
+	*length = sizeof(usb_stm32mp2_lang_id_desc);
+
+	return (uint8_t *)usb_stm32mp2_lang_id_desc;
+}
+
+/*
+ *  Returns the product string descriptor.
+ * length: Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp2_product_desc(uint16_t *length)
+{
+	char name[STM32_SOC_NAME_SIZE];
+	char product[128];
+	uint32_t chip_id;
+	uint32_t chip_version;
+
+	stm32mp_get_soc_name(name);
+	chip_id = stm32mp_get_chip_dev_id();
+	chip_version = stm32mp_get_chip_version();
+
+	snprintf(product, sizeof(product),
+		 "DFU @Device ID /0x%03X, @Revision ID /0x%04X, @Name /%s,",
+		 chip_id, chip_version, name);
+
+	stm32mp2_get_string(product, usb_str_dec, length);
+
+	return usb_str_dec;
+}
+
+/*
+ * Returns the manufacturer string descriptor.
+ * length: Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp2_manufacturer_desc(uint16_t *length)
+{
+	stm32mp2_get_string(USBD_MANUFACTURER_STRING, usb_str_dec, length);
+
+	return usb_str_dec;
+}
+
+/*
+ * Returns the serial number string descriptor.
+ * length: Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp2_serial_desc(uint16_t *length)
+{
+	*length = USB_SIZ_STRING_SERIAL;
+
+	return (uint8_t *)usb_stm32mp2_serial;
+}
+
+/*
+ * Returns the configuration string descriptor.
+ * length: Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp2_config_desc(uint16_t *length)
+{
+	stm32mp2_get_string(USBD_CONFIGURATION_STRING, usb_str_dec, length);
+
+	return usb_str_dec;
+}
+
+/*
+ * Returns the interface string descriptor.
+ * length : Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp2_interface_desc(uint16_t *length)
+{
+	stm32mp2_get_string(USBD_INTERFACE_STRING, usb_str_dec, length);
+
+	return usb_str_dec;
+}
+
+/*
+ * Manages the transfer of memory interfaces string descriptors.
+ * index: descriptor index
+ * length : pointer data length
+ * return : pointer to the descriptor table or NULL if the descriptor
+ *          is not supported.
+ */
+static uint8_t *stm32mp2_get_usr_desc(uint8_t index, uint16_t *length)
+{
+	if (index >= ARRAY_SIZE(if_desc_string)) {
+		return NULL;
+	}
+
+	stm32mp2_get_string(if_desc_string[index], usb_str_dec, length);
+
+	return usb_str_dec;
+}
+
+static const struct usb_desc dfu_desc = {
+	.get_device_desc = stm32mp2_device_desc,
+	.get_lang_id_desc = stm32mp2_lang_id_desc,
+	.get_manufacturer_desc = stm32mp2_manufacturer_desc,
+	.get_product_desc = stm32mp2_product_desc,
+	.get_configuration_desc = stm32mp2_config_desc,
+	.get_serial_desc = stm32mp2_serial_desc,
+	.get_interface_desc = stm32mp2_interface_desc,
+	.get_usr_desc = stm32mp2_get_usr_desc,
+	.get_config_desc = stm32mp2_get_config_desc,
+	.get_device_qualifier_desc = stm32mp2_get_qualifier_desc,
+	/* only HS is supported, as ROM code */
+	.get_other_speed_config_desc = NULL,
+};
+
+static struct usb_handle usb_core_handle;
+static struct pcd_handle pcd_handle;
+static dwc3_handle_t dwc3_handle;
+
+struct usb_handle *usb_dfu_plat_init(void)
+{
+	/* prepare USB Driver */
+	pcd_handle.in_ep[0].maxpacket = USB_MAX_EP0_SIZE;
+	pcd_handle.out_ep[0].maxpacket = USB_MAX_EP0_SIZE;
+	usb_dwc3_init_driver(&usb_core_handle, &pcd_handle, &dwc3_handle, (void *)USB_DWC3_BASE);
+
+	/* keep the configuration from ROM code */
+	usb_core_handle.ep0_state = USBD_EP0_DATA_IN;
+	usb_core_handle.dev_state = USBD_STATE_CONFIGURED;
+
+	/* Update the serial number string descriptor from the unique ID */
+	update_serial_num_string();
+
+	/* Prepare USB DFU stack */
+	usb_dfu_register(&usb_core_handle, &usb_dfu_handle);
+
+	/* Register DFU descriptor in USB stack */
+	register_platform(&usb_core_handle, &dfu_desc);
+
+	return &usb_core_handle;
+}
+
+/* Link between USB alternate and STM32CubeProgramer phase */
+uint8_t usb_dfu_get_phase(uint8_t alt)
+{
+	uint8_t ret;
+
+	switch (alt) {
+	case 0:
+		ret = PHASE_DDR_FW;
+		break;
+	case 1:
+		ret = PHASE_SSBL;
+		break;
+	case 2:
+		ret = PHASE_CMD;
+		break;
+	default:
+		ret = PHASE_RESET;
+		break;
+	}
+
+	return ret;
+}
diff --git a/tools/cert_create/Makefile b/tools/cert_create/Makefile
index 77d2007d5..410e0638a 100644
--- a/tools/cert_create/Makefile
+++ b/tools/cert_create/Makefile
@@ -9,7 +9,7 @@ V		?= 0
 DEBUG		:= 0
 CRTTOOL		?= cert_create${BIN_EXT}
 BINARY		:= $(notdir ${CRTTOOL})
-OPENSSL_DIR	:= /usr
+OPENSSL_DIR	?= /usr
 COT		:= tbbr
 
 MAKE_HELPERS_DIRECTORY := ../../make_helpers/
@@ -63,7 +63,7 @@ HOSTCCFLAGS += ${DEFINES}
 # could get pulled in from firmware tree.
 INC_DIR += -I ./include -I ${PLAT_INCLUDE} -I ${OPENSSL_DIR}/include
 LIB_DIR := -L ${OPENSSL_DIR}/lib
-LIB := -lssl -lcrypto
+LIB := -lssl -lcrypto -lpthread
 
 HOSTCC ?= gcc
 
diff --git a/tools/cert_create/include/key.h b/tools/cert_create/include/key.h
index 128e7f7b4..2a227dd01 100644
--- a/tools/cert_create/include/key.h
+++ b/tools/cert_create/include/key.h
@@ -22,7 +22,8 @@ enum {
 enum {
 	KEY_ALG_RSA,		/* RSA PSS as defined by PKCS#1 v2.1 (default) */
 #ifndef OPENSSL_NO_EC
-	KEY_ALG_ECDSA,
+	KEY_ALG_ECDSA_NIST,
+	KEY_ALG_ECDSA_BRAINPOOL,
 #endif /* OPENSSL_NO_EC */
 	KEY_ALG_MAX_NUM
 };
@@ -42,7 +43,8 @@ enum{
 static const unsigned int KEY_SIZES[KEY_ALG_MAX_NUM][KEY_SIZE_MAX_NUM] = {
 	{ 2048, 1024, 3072, 4096 },	/* KEY_ALG_RSA */
 #ifndef OPENSSL_NO_EC
-	{}				/* KEY_ALG_ECDSA */
+	{},				/* KEY_ALG_ECDSA_NIST */
+	{}				/* KEY_ALG_ECDSA_BRAINPOOL */
 #endif /* OPENSSL_NO_EC */
 };
 
diff --git a/tools/cert_create/src/key.c b/tools/cert_create/src/key.c
index 64359756f..e33441448 100644
--- a/tools/cert_create/src/key.c
+++ b/tools/cert_create/src/key.c
@@ -79,11 +79,11 @@ err:
 }
 
 #ifndef OPENSSL_NO_EC
-static int key_create_ecdsa(key_t *key, int key_bits)
+static int key_create_ecdsa(key_t *key, int key_bits, int curve_id)
 {
 	EC_KEY *ec;
 
-	ec = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
+	ec = EC_KEY_new_by_curve_name(curve_id);
 	if (ec == NULL) {
 		printf("Cannot create EC key\n");
 		goto err;
@@ -104,13 +104,25 @@ err:
 	EC_KEY_free(ec);
 	return 0;
 }
+
+static int key_create_ecdsa_nist(key_t *key, int key_bits)
+{
+	return key_create_ecdsa(key, key_bits, NID_X9_62_prime256v1);
+}
+
+static int key_create_ecdsa_brainpool(key_t *key, int key_bits)
+{
+	return key_create_ecdsa(key, key_bits, NID_brainpoolP256t1);
+}
+
 #endif /* OPENSSL_NO_EC */
 
 typedef int (*key_create_fn_t)(key_t *key, int key_bits);
 static const key_create_fn_t key_create_fn[KEY_ALG_MAX_NUM] = {
-	key_create_rsa, 	/* KEY_ALG_RSA */
+	[KEY_ALG_RSA] = key_create_rsa,
 #ifndef OPENSSL_NO_EC
-	key_create_ecdsa, 	/* KEY_ALG_ECDSA */
+	[KEY_ALG_ECDSA_NIST] = key_create_ecdsa_nist,
+	[KEY_ALG_ECDSA_BRAINPOOL] = key_create_ecdsa_brainpool,
 #endif /* OPENSSL_NO_EC */
 };
 
diff --git a/tools/cert_create/src/main.c b/tools/cert_create/src/main.c
index b39378ca9..a91ca82dd 100644
--- a/tools/cert_create/src/main.c
+++ b/tools/cert_create/src/main.c
@@ -84,7 +84,8 @@ static char *strdup(const char *str)
 static const char *key_algs_str[] = {
 	[KEY_ALG_RSA] = "rsa",
 #ifndef OPENSSL_NO_EC
-	[KEY_ALG_ECDSA] = "ecdsa"
+	[KEY_ALG_ECDSA_NIST] = "ecdsa",
+	[KEY_ALG_ECDSA_BRAINPOOL] = "ecdsa-brainpool"
 #endif /* OPENSSL_NO_EC */
 };
 
diff --git a/tools/encrypt_fw/Makefile b/tools/encrypt_fw/Makefile
index 96dff2324..7f959abeb 100644
--- a/tools/encrypt_fw/Makefile
+++ b/tools/encrypt_fw/Makefile
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2019-2020, Linaro Limited. All rights reserved.
+# Copyright (c) 2019-2021, Linaro Limited. All rights reserved.
 #
 # SPDX-License-Identifier: BSD-3-Clause
 #
@@ -9,7 +9,7 @@ BUILD_INFO	?= 1
 DEBUG		:= 0
 ENCTOOL		?= encrypt_fw${BIN_EXT}
 BINARY		:= $(notdir ${ENCTOOL})
-OPENSSL_DIR	:= /usr
+OPENSSL_DIR	?= /usr
 
 OBJECTS := src/encrypt.o \
            src/cmd_opt.o \
@@ -40,7 +40,7 @@ endif
 # could get pulled in from firmware tree.
 INC_DIR := -I ./include -I ../../include/tools_share -I ${OPENSSL_DIR}/include
 LIB_DIR := -L ${OPENSSL_DIR}/lib
-LIB := -lssl -lcrypto
+LIB := -lssl -lcrypto -lpthread
 
 HOSTCC ?= gcc
 
diff --git a/tools/fiptool/Makefile b/tools/fiptool/Makefile
index 11d2e7b0b..7fc5670ee 100644
--- a/tools/fiptool/Makefile
+++ b/tools/fiptool/Makefile
@@ -8,6 +8,7 @@ MAKE_HELPERS_DIRECTORY := ../../make_helpers/
 include ${MAKE_HELPERS_DIRECTORY}build_macros.mk
 include ${MAKE_HELPERS_DIRECTORY}build_env.mk
 
+OPENSSL_DIR ?= /usr
 FIPTOOL ?= fiptool${BIN_EXT}
 PROJECT := $(notdir ${FIPTOOL})
 OBJECTS := fiptool.o tbbr_config.o
@@ -20,7 +21,8 @@ ifeq (${DEBUG},1)
 else
   HOSTCCFLAGS += -O2
 endif
-LDLIBS := -lcrypto
+LIB_DIR := -L ${OPENSSL_DIR}/lib
+LDLIBS := -lcrypto -lpthread
 
 ifeq (${V},0)
   Q := @
@@ -48,7 +50,7 @@ all: ${PROJECT}
 
 ${PROJECT}: ${OBJECTS} Makefile
 	@echo "  HOSTLD  $@"
-	${Q}${HOSTCC} ${OBJECTS} -o $@ ${LDLIBS}
+	${Q}${HOSTCC} ${OBJECTS} -o $@ ${LIB_DIR} ${LDLIBS}
 	@${ECHO_BLANK_LINE}
 	@echo "Built $@ successfully"
 	@${ECHO_BLANK_LINE}
diff --git a/tools/fwu_gen_metadata/README.md b/tools/fwu_gen_metadata/README.md
new file mode 100644
index 000000000..3469bda52
--- /dev/null
+++ b/tools/fwu_gen_metadata/README.md
@@ -0,0 +1,87 @@
+# fwumd\_tool
+Tool to create FWU Metadata struct in Python
+
+## Getting started
+As metadata struct composition and length changes depending on how many images and how many banks you want to put in them,
+the options `--nb-img-in-banks` (or `-ni` for short) and `--nb-banks` (or `-nb` for short) may be required to format the binary data properly.
+The default values are **1 image** and **2 banks**
+
+### From Json to binary
+`fwumd_tool.py dummy` will generate a file `dummy.json` and `dummy.bin`, containing
+dummy metadata for testing purpose.
+
+Modify the json file with the correct metadata you want to set, then call
+`fwumd_tool.py jsonparse <json file>` to generate the binary metadata from the given json file
+In both of these commands, passing option `-v` will dump the content of the metadata for visual
+inspection.
+
+**The name format `<image>_bank_<nb>` needs to be respected for images in banks**
+
+### From binary to json
+You can dump a binary metadata file using the command `fwumd_tool.py dump <binary file>` to
+visualize the metadata in human-readable format from the binary.
+
+You can also generate a json config file from binary data using the command `fwumd_tool.py binparse <binary file>`.
+It will generate json data in which names are automatically generated.
+
+Passing the option `--template <jsonfile>` to binparse allows the tool to get the config from the given json file,
+and will mimic the number of images, the number of banks, and the names given to images, banks, location.
+
+### Test reproducible binary metadata
+Passing these commands should end up with matching checksum.
+```bash
+./fwumd_tool.py dummy
+./fwumd_tool.py binparse dummy.bin -j dummy2.json
+./fwumd_tool.py jsonparse dummy2.json -b dummy2.bin
+shasum dummy.bin dummy2.bin
+```
+
+## Propositions, precepts, thoughts
+- Endianness of the data contained in the struct has to either be fixed, or defined in the "configs" section of the metadata and embedded into the binary metadata
+- Discussions has been made to embed configs into the binary metadata directly, allowing for much easier validation of the data and less prone to errors
+- A list of wanted features to ease scripting with the tool should be made.
+- PEP8 rules have been applied as much as possible on the code, as well as comments & docstrings.
+
+## TODO
+- Verify CRC32 of binary metadata file
+
+## Json examples
+### Dummy JSON metadata
+```json
+{
+    "metadata": {
+        "version": 0,
+        "active_index": 1,
+        "previous_active_index": 0,
+        "img_entry": {
+            "img_0": {
+                "location": "sda",
+                "img_bank_info": {
+                    "img_0_bank_0": {
+                        "accepted": true,
+                        "reserved": 101
+                    },
+                    "img_0_bank_1": {
+                        "accepted": false,
+                        "reserved": 102
+                    }
+                }
+            }
+        }
+    },
+    "uuids": {
+        "locations": {
+            "sda": "7e93078a-2dc2-4657-b496-eaf638247c5b"
+        },
+        "entries": {
+            "img_0_bank_0": "c31fe18a-9408-49b5-a647-03113b85dc58",
+            "img_0_bank_1": "d4ccc9b2-58a0-46ed-beeb-1f37059db676",
+            "img_0": "50833315-fe46-4eb1-8c4a-b38d03684f7f"
+        }
+    },
+    "configs": {
+        "nb_fw_img": 1,
+        "nb_fw_banks": 2
+    }
+}
+```
diff --git a/tools/fwu_gen_metadata/fwumd_tool.py b/tools/fwu_gen_metadata/fwumd_tool.py
new file mode 100755
index 000000000..6a79223f8
--- /dev/null
+++ b/tools/fwu_gen_metadata/fwumd_tool.py
@@ -0,0 +1,181 @@
+#!/usr/bin/env python3
+# Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+#
+# SPDX-License-Identifier: BSD-3-Clause
+
+"""
+    CLI tool to interact with the 'fwu_metadata' data structure
+    Contains files for:
+        - fwumd_tool.py:    CLI management
+        - src/metadata.py:  Python dict fwu_metadata
+        - src/structs.py:   C-style struct fwu_metadata
+        - src/utils.py:     Useful functions for all project
+        - src/uuid_t.py:    Class & functions to deal with UUID
+"""
+
+import json
+import argparse
+
+from src.uuid_t import test_uuids
+from src.utils import test_utils
+from src.metadata import create_dummy_metadata, validate_metadata
+from src.structs import fwupd_from_dict, fwupd_to_dict
+
+# COMMAND LINE
+
+def cli_dummy(dummy_args):
+    """
+        Routine for the command "dummy" passed in CLI
+    """
+    try:
+        dummy_metadata = create_dummy_metadata(dummy_args.nb_fw_imgs, dummy_args.nb_banks)
+        assert validate_metadata(dummy_metadata)
+        fwupd = fwupd_from_dict(dummy_metadata)
+        if dummy_args.display:
+            fwupd.display()
+        json.dump(dummy_metadata, dummy_args.jsonfile, indent=4)
+        dummy_args.binfile.write(fwupd)
+    finally:
+        dummy_args.jsonfile.close()
+        dummy_args.binfile.close()
+
+def cli_jsonparse(jsonparse_args):
+    """
+        Routine for the command "jsonparse" passed in CLI
+    """
+    try:
+        data = json.load(jsonparse_args.jsonfile)
+        if not validate_metadata(data):
+            raise Exception("Metadata contained in file are not correct")
+        fwupd = fwupd_from_dict(data)
+        if jsonparse_args.display:
+            fwupd.display()
+        jsonparse_args.binfile.write(fwupd)
+    finally:
+        jsonparse_args.jsonfile.close()
+        jsonparse_args.binfile.close()
+
+def cli_binparse(binparse_args):
+    """
+        Routine for the command "binparse" passed in CLI
+    """
+    template_data = {"uuids": {"locations": {}, "entries": {}}}
+    dummy_metadata = create_dummy_metadata(binparse_args.nb_fw_imgs, binparse_args.nb_banks)
+    assert validate_metadata(dummy_metadata)
+    fwupd = fwupd_from_dict(dummy_metadata)
+    binparse_args.binfile.readinto(fwupd)
+    if binparse_args.display:
+        fwupd.display()
+    data = fwupd_to_dict(fwupd, binparse_args.nb_fw_imgs,
+                         binparse_args.nb_banks,
+                         list(template_data["uuids"]["entries"].keys()),
+                         template_data["uuids"]["locations"])
+    json.dump(data, binparse_args.jsonfile, indent=4)
+
+    binparse_args.binfile.close()
+    binparse_args.jsonfile.close()
+
+def cli_dump(dump_args):
+    """
+        Routine for the "Dump" command passed in CLI
+    """
+    try:
+        dummy_metadata = create_dummy_metadata(dump_args.nb_fw_imgs, dump_args.nb_banks)
+        fwupd = fwupd_from_dict(dummy_metadata)
+        dump_args.binfile.readinto(fwupd)
+        fwupd.display()
+    finally:
+        dump_args.binfile.close()
+
+def cli_test(test_args):
+    """ Routine for the "Test" command passed in CLI """
+    all_tests = [("Utils", test_utils), ("UUIDs", test_uuids)]
+    if test_args.number == -1:
+        for (key, test) in all_tests:
+            print("Test " + key)
+            test(test_args)
+            print("")
+    elif test_args.number < len(all_tests):
+        print("Test " + all_tests[test_args.number][0])
+        all_tests[test_args.number][1](test_args)
+    else:
+        print("Tests available:")
+        for nbtest, (test, _) in enumerate(all_tests):
+            print("\t{} - Test {}".format(nbtest, test))
+
+def cli():
+    """ Function parsing args, dispatching commands """
+    parser = argparse.ArgumentParser()
+    subp = parser.add_subparsers(dest="cmd")
+
+    # GENERAL ARGS
+    parser.add_argument("--nb-fw-imgs", "-ni", default=1, type=int,
+                        help="Number of firmware images in entries")
+    parser.add_argument("--nb-banks", "-nb", default=2, type=int,
+                        help="Number of firmware banks for each image")
+
+    # DUMMY
+    dummy = subp.add_parser("dummy",
+                            help="Create a JSON metadata and a binary metadata dummy files")
+    dummy.add_argument("--display", "-v", action="store_true",
+                       help="Display the content of the binary metadata after creation")
+    dummy.add_argument("--jsonfile", "-j", type=argparse.FileType("w"),
+                       default="dummy.json",
+                       help="The JSON file where to write the dummy metadata")
+    dummy.add_argument("--binfile", "-b", type=argparse.FileType("wb"),
+                       default="dummy.bin",
+                       help="The binary file where to write the dummy metadata")
+
+    # JSON PARSE
+    jsparse = subp.add_parser("jsonparse",
+                              help="Parse json and creates a binary metadata file")
+    jsparse.add_argument("jsonfile", type=argparse.FileType("r"),
+                         help="The JSON file where to read the metadata from")
+    jsparse.add_argument("--display", "-v", action="store_true",
+                         help="Display the content of the binary metadata after creation")
+    jsparse.add_argument("--binfile", "-b", type=argparse.FileType("wb"),
+                         default="fwupd.bin",
+                         help="The binary file where to write the binary metadata")
+
+    # BINPARSE
+    binparse = subp.add_parser("binparse",
+                               help="Parse binary data and generates a JSON metadata file")
+    binparse.add_argument("binfile", type=argparse.FileType("rb"),
+                          help="The binary file where to read the metadata from")
+    binparse.add_argument("--display", "-v", action="store_true",
+                          help="Display the content of the binary metadata after creation")
+    binparse.add_argument("--jsonfile", "-j", type=argparse.FileType("w"),
+                          default="fwupd.json",
+                          help="The JSON file where to write the generated JSON metadata")
+
+    # DUMP
+    dump = subp.add_parser("dump",
+                           help="Read a binary metadata file and prints its data")
+    dump.add_argument("binfile", type=argparse.FileType("rb"),
+                      help="The binary file where to read the metadata from")
+
+    # TEST
+    test = subp.add_parser("test",
+                           help="Perform validation tests on the tool")
+    test.add_argument("--number", "-n", type=int, default=-1,
+                      help="The test nb to perform (default: all)")
+
+    args = parser.parse_args()
+
+    # Dispatch commands
+    if args.cmd == "dummy":
+        cli_dummy(args)
+    elif args.cmd == "jsonparse":
+        cli_jsonparse(args)
+    elif args.cmd == "binparse":
+        cli_binparse(args)
+    elif args.cmd == "dump":
+        cli_dump(args)
+    elif args.cmd == "test":
+        cli_test(args)
+    else:
+        # If no command passed, considered as faulty, print help
+        parser.print_help()
+
+if __name__ == "__main__":
+    cli()
diff --git a/tools/fwu_gen_metadata/src/metadata.py b/tools/fwu_gen_metadata/src/metadata.py
new file mode 100644
index 000000000..aa31f35ad
--- /dev/null
+++ b/tools/fwu_gen_metadata/src/metadata.py
@@ -0,0 +1,102 @@
+# Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+#
+# SPDX-License-Identifier: BSD-3-Clause
+
+"""
+    metadata.py
+        Manage Python dict formatted fwu_metadata
+"""
+import uuid
+
+def create_dummy_metadata(nb_fw_img, nb_fw_banks):
+    """
+        This function creates a Python dict containing dummy metadata
+        Used for testing or for placeholding
+    """
+    data = {
+        "metadata": {
+            "version": 0,
+            "active_index": 1,
+            "previous_active_index": 0,
+            "img_entry": {}
+        },
+        "uuids": {
+            "locations": {
+                "sda": str(uuid.uuid4()),
+            },
+            "entries": {},
+        },
+        "configs": {
+            "nb_fw_img": nb_fw_img,
+            "nb_fw_banks": nb_fw_banks
+        }
+    }
+
+    entries = {}
+    for nimg in range(nb_fw_img):
+        banks = {}
+        for nbnk in range(nb_fw_banks):
+            entry_name = "img_" + str(nimg) + "_bank_" + str(nbnk)
+            banks[entry_name] = {"accepted": True,
+                                 "reserved": 0}
+            data["uuids"]["entries"][entry_name] = str(uuid.uuid4())
+
+        entries["img_" + str(nimg)] = {
+            "location": "sda",
+            "img_bank_info": banks
+        }
+        data["uuids"]["entries"]["img_" + str(nimg)] = str(uuid.uuid4())
+    data["metadata"]["img_entry"] = entries
+    return data
+
+def __check_md(res, cond, msg):
+    """
+        Helper function used to validate metadata.
+        If cond is false, return False, and display message
+    """
+    if not cond:
+        print("Metadata validation failed: '{}'".format(msg))
+        return False
+    return res
+
+def validate_metadata(metadata):
+    """
+        Validate content of a Python dict metadata
+        Passes through all the data, display errors if any,
+        then return if errors got encountered
+    """
+    res = True
+
+    for key in ["metadata", "uuids", "configs"]:
+        res = __check_md(res, key in metadata.keys(),
+                         "Key missing: {}".format(key))
+    for conf in ["nb_fw_img", "nb_fw_banks"]:
+        res = __check_md(res, conf in metadata["configs"].keys(), "Config missing: {}".format(conf))
+
+    res = __check_md(res, "locations" in metadata["uuids"].keys(), "UUID type location missing")
+    res = __check_md(res, "entries" in metadata["uuids"].keys(), "UUID type entries missing")
+    res = __check_md(res,
+                     len(metadata["metadata"]["img_entry"].keys()) ==
+                     metadata["configs"]["nb_fw_img"],
+                     "Wrong number of firmware images entries")
+
+    for iname, img in metadata["metadata"]["img_entry"].items():
+        res = __check_md(res, iname in metadata["uuids"]["entries"].keys(),
+                         "Image {} UUID not known".format(iname))
+
+        res = __check_md(res,
+                         img["location"] in metadata["uuids"]["locations"].keys(),
+                         "Location {} UUID not known".format(img["location"]))
+
+        res = __check_md(res,
+                         len(metadata["metadata"]["img_entry"] [iname]["img_bank_info"].keys()) ==
+                         metadata["configs"]["nb_fw_banks"],
+                         "Wrong number of banks for image {}".format(iname))
+
+        for bname, _ in metadata["metadata"]["img_entry"][iname]["img_bank_info"].items():
+            res = __check_md(res, bname in metadata["uuids"]["entries"],
+                             "Bank {} UUID not known".format(bname))
+            res = __check_md(res, iname + "_bank_" in bname,
+                             "Bank name wrongly named")
+
+    return res
diff --git a/tools/fwu_gen_metadata/src/structs.py b/tools/fwu_gen_metadata/src/structs.py
new file mode 100644
index 000000000..0e58bbecd
--- /dev/null
+++ b/tools/fwu_gen_metadata/src/structs.py
@@ -0,0 +1,262 @@
+# Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+#
+# SPDX-License-Identifier: BSD-3-Clause
+
+"""
+    structs.py
+        Manage C-style struct formatted fwu_metadata
+"""
+
+import binascii
+
+from ctypes import Structure, c_uint32, c_uint16, c_uint8, Array
+
+from src.uuid_t import uuid_t, get_uuids, uuid_t_from_str
+from src.utils import get_template_location_key
+
+# IMAGE BANK
+
+class image_bank_info(Structure):
+    """
+        Image bank C struct
+    """
+    _fields_ = [
+        ("img_uuid", uuid_t),
+        ("accepted", c_uint32),
+        ("reserved", c_uint32),
+    ]
+
+    def from_metadata(self, bank_name, bank, uuids):
+        """
+            Use Python-dict metadata to generate the Python / C-struct object
+        """
+        self.img_uuid = uuid_t_from_str(get_uuids(uuids["entries"], bank_name))
+        self.accepted = bank["accepted"]
+        self.reserved = bank.get("reserved", 0) #default value 0 if not in json
+
+    def display(self, buff):
+        """
+            Helper function to render the data of the bank in a buffer
+        """
+        buff += "\t\t  Image UUID: {}\n".format(str(self.img_uuid))
+        buff += "\t\t  Accepted: {}\n".format(self.accepted)
+        buff += "\t\t  Reserved: {}\n".format(self.reserved)
+        return buff
+
+    def to_dict(self, bankname, bank, uuids):
+        """
+            Helper function to add the data contained into dicts
+        """
+        uuids["entries"][bankname] = str(self.img_uuid)
+        bank["accepted"] = bool(self.accepted)
+        bank["reserved"] = self.reserved
+
+# IMAGE ENTRY
+def get_struct_imgentry(nb_fw_banks):
+    """
+        As the structure depend on a variable parameter, the Python class is
+        generated at runtime, allowing to not rely on global variables
+    """
+    class image_entry(Structure):
+        """
+            Image entry C struct
+        """
+        _fields_ = [
+            ("img_type_uuid", uuid_t),
+            ("location_uuid", uuid_t),
+            ("img_bank_info", image_bank_info * nb_fw_banks),
+        ]
+
+        def from_metadata(self, img_name, entry, uuids):
+            """
+                Generate this Python / C-struct object from Python dict
+                metadata
+            """
+            self.img_type_uuid = uuid_t_from_str(
+                get_uuids(uuids["entries"], img_name))
+            self.location_uuid = uuid_t_from_str(get_uuids(uuids["locations"], entry["location"]))
+            for n, (bank_name, bank) in enumerate(entry["img_bank_info"].items()):
+                self.img_bank_info[n].from_metadata(bank_name, bank, uuids)
+
+        def display(self, buff):
+            """
+                Render the data contained inside a buffer
+            """
+            buff += "\t  Image type UUID: {}\n".format(str(self.img_type_uuid))
+            buff += "\t  Location UUID: {}\n".format(str(self.location_uuid))
+            buff += "\t  --- Banks ---\n"
+            for n, bank in enumerate(self.img_bank_info):
+                buff += "\t\tBank {}\n".format(n)
+                buff = bank.display(buff)
+            return buff
+
+        def to_dict(self, imgname, entry, uuids, imgkeys, loc_uuids):
+            """
+                Helper function to add this struct's data into Python dict
+                metadata
+            """
+            uuids["entries"][imgname] = str(self.img_type_uuid)
+            location_uuid_str = str(self.location_uuid)
+            loc_key = get_template_location_key(loc_uuids, location_uuid_str)
+            entry["location"] = loc_key
+            uuids["locations"][loc_key] = location_uuid_str
+            banks = {}
+            for b, bank in enumerate(self.img_bank_info):
+                bname = imgname + "_bank_" + str(b)
+                banks[bname] = {}
+                bank.to_dict(bname, banks[bname], uuids)
+            entry["img_bank_info"] = banks
+
+    return image_entry
+
+# FWU-Metadata struct creation
+def generate_fwu_metadata(nb_fw_img, nb_fw_banks):
+    """
+        Generate an empty FWU-Metadata object from the given parameters
+    """
+    class fwu_metadata(Structure):
+        """
+            FWU Metadata C struct (parent struct)
+        """
+        _fields_ = [
+            ("crc_32", c_uint32),
+            ("version", c_uint32),
+            ("active_index", c_uint32),
+            ("previous_active_index", c_uint32),
+            ("img_entry", get_struct_imgentry(nb_fw_banks) * nb_fw_img)
+        ]
+
+        def update_crc32(self):
+            """
+                Compute and update the CRC32 from the data contained
+            """
+            self.crc_32 = binascii.crc32(bytearray(self)[4:])
+
+        def from_metadata(self, metadata, uuids):
+            """
+                Update the contained metadata from given Python dict
+            """
+            self.version = metadata["version"]
+            self.active_index = metadata["active_index"]
+            self.previous_active_index = metadata["previous_active_index"]
+            for n, (img_name, img) in enumerate(metadata["img_entry"].items()):
+                self.img_entry[n].from_metadata(img_name, img, uuids)
+            self.update_crc32()
+
+        def display(self):
+            """
+                Prints a text-rendered display of the data contained
+            """
+            buff = "METADATA\n"
+            buff += "  CRC32: {}\n".format(self.crc_32)
+            buff += "  Version: {}\n".format(self.version)
+            buff += "  Active index: {}\n".format(self.active_index)
+            buff += "  Previous active index: {}\n".format(
+                self.previous_active_index)
+            buff += "  --- Image entries ---\n"
+            for n, img in enumerate(self.img_entry):
+                buff += "\tEntry {}\n".format(n)
+                buff = img.display(buff)
+            print(buff)
+
+        def to_dict(self, metadata, uuids, imgkeys, loc_uuids):
+            """
+                Pass the data contained in this object into Python dicts
+            """
+            metadata["crc_32"] = self.crc_32
+            metadata["version"] = self.version
+            metadata["active_index"] = self.active_index
+            metadata["previous_active_index"] = self.previous_active_index
+            entries = {}
+            for n, img in enumerate(self.img_entry):
+                iname = imgkeys[n]
+                entries[iname] = {}
+                img.to_dict(iname, entries[iname], uuids, imgkeys, loc_uuids)
+            metadata["img_entry"] = entries
+
+    return fwu_metadata()
+
+def fwupd_from_dict(data):
+    """
+        Return a fwu_metadata object from a complete Python dict as saved in
+        the JSON file
+    """
+    fwupd = generate_fwu_metadata(
+        data["configs"]["nb_fw_img"],
+        data["configs"]["nb_fw_banks"])
+    fwupd.from_metadata(data["metadata"], data["uuids"])
+    return fwupd
+
+def fwupd_to_dict(fwupd, nb_fw_imgs, nb_banks, images_keys, loc_uuids):
+    """
+        Create a Python dict containing all the information contained in a
+        fwu_metadata object
+    """
+    data = {"metadata": {}, "uuids": {"locations": {}, "entries": {}},
+            "configs": {
+                "nb_fw_img": nb_fw_imgs,
+                "nb_fw_banks": nb_banks
+            },
+           }
+    images_keys += ["img_" + str(n) for n in range(max(0, nb_fw_imgs - len(images_keys)))]
+
+    fwupd.to_dict(data["metadata"], data["uuids"], images_keys, loc_uuids)
+    return data
+
+def __check_same(res, name, mdel, binel):
+    """
+        Helper function for binary metadata cross-validation with JSON
+
+        If @mdel (JSON) and @binel (Binary) are not the same, return False
+            and display a formatted error with the given @name.
+        Else return @res
+    """
+    if str(mdel) != str(binel):
+        print("Element '{}' are not the same in metadata and binary data".format(name))
+        return False
+    else:
+        return res
+
+def validate_fwupd_and_dict(md, fwupd):
+    """
+        Validation function for binary + JSON metadata
+        Ensure the data of the both formats are the same
+
+        Do not check CRC32
+    """
+    res = True
+
+    # Check elements of fwu_metadata struct
+    for key in ["version", "active_index", "previous_active_index"]:
+        res = __check_same(res, key, md["metadata"][key], getattr(fwupd, key))
+
+    # Check elements in each image entry
+    for n, (img_name, img) in enumerate(md["metadata"]["img_entry"].items()):
+        entry = fwupd.img_entry[n]
+
+        res = __check_same(res, "Image {} type UUID".format(img_name),
+                           md["uuids"]["entries"][img_name],
+                           entry.img_type_uuid)
+
+        res = __check_same(res, "Location UUID",
+                           md["uuids"]["locations"][img["location"]],
+                           entry.location_uuid)
+
+        # Check elements in each banks of image entry
+        for b, (bname, bank) in enumerate(img["img_bank_info"].items()):
+            fwbank = entry.img_bank_info[b]
+            res = __check_same(res, "Image {} Bank {} UUID".format(
+                                                            img_name, b),
+                               md["uuids"]["entries"][bname],
+                               fwbank.img_uuid)
+
+            res = __check_same(res, "Image {} Bank {} Accepted".format(
+                                                                img_name, b),
+                               bank["accepted"],
+                               bool(fwbank.accepted))
+
+            res = __check_same(res, "Image {} Bank {} Reserved field".format(
+                                                                img_name, b),
+                               bank["reserved"],
+                               fwbank.reserved)
+    return res
diff --git a/tools/fwu_gen_metadata/src/utils.py b/tools/fwu_gen_metadata/src/utils.py
new file mode 100644
index 000000000..e994e9a38
--- /dev/null
+++ b/tools/fwu_gen_metadata/src/utils.py
@@ -0,0 +1,69 @@
+# Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+#
+# SPDX-License-Identifier: BSD-3-Clause
+
+"""
+    utils.py
+        Useful functions for the whole project
+"""
+from ctypes import c_uint8
+
+# Number manipulation
+def uint8array_to_number(uint8array):
+    """ Convert array of uint8_t into a single Python number """
+    return sum([x << (i*8) for i, x in enumerate(reversed(uint8array))])
+
+def number_to_uint8array(number, array_length):
+    """ Convert a single Python number into an array of uint8_t """
+    uint8array = c_uint8 * array_length
+    array = [(number & (0xff << (n*8))) >> (n*8)
+        for n in reversed(range(array_length))
+    ]
+    return uint8array(*array)
+
+def test_number_to_array(args):
+    """ Test back and forth conversion works for our use case"""
+    numbers = [0x42053497, 0x45]
+    for number in numbers:
+        a = number_to_uint8array(number, 4)
+        n = uint8array_to_number(a)
+        print_and_assert(number, n)
+
+# Default values creation
+def get_template_location_key(locations, uuid):
+    """
+        Get the location key of the given location.
+        If it doesn't exist, generate one from the UUID
+    """
+    if uuid in locations.values():
+        return [key for key, val in locations.items() if val == uuid][0]
+    else:
+        key = "loc_" + uuid.replace("-", "_")
+        locations[key] = uuid
+        return key
+
+def test_template_location_key(args):
+    """ Test location key getter works well """
+    print_and_assert(get_template_location_key({"sda": "uuid"}, "uuid"),
+                     "sda")
+    print_and_assert(get_template_location_key({"sda": "uuid"}, "new"),
+                     "loc_new")
+    print_and_assert(get_template_location_key({"sda": "uuid"}, "sda-2"),
+                     "loc_sda_2")
+
+# Testing utils
+def print_and_assert(el1, el2):
+    """ Print the two values to test, then assert their equality"""
+    print(el1, "==", el2)
+    assert el1 == el2
+
+def test_utils(args):
+    all_tests = {
+        "Number to array": test_number_to_array,
+        "Template location key": test_template_location_key
+    }
+
+    for (key, test) in all_tests.items():
+        print("--- Test " + key)
+        test(args)
+        print("---\n")
diff --git a/tools/fwu_gen_metadata/src/uuid_t.py b/tools/fwu_gen_metadata/src/uuid_t.py
new file mode 100644
index 000000000..8f9a891af
--- /dev/null
+++ b/tools/fwu_gen_metadata/src/uuid_t.py
@@ -0,0 +1,79 @@
+# Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+#
+# SPDX-License-Identifier: BSD-3-Clause
+
+import uuid
+from ctypes import Structure, c_uint32, c_uint16, c_uint8, Array
+
+from src.utils import uint8array_to_number, number_to_uint8array
+from src.utils import print_and_assert
+
+UUID_NODE_LEN = 6
+UUID_STR_LEN = 24 + (UUID_NODE_LEN*2)
+
+# UUIDS
+
+class uuid_t(Structure):
+    """
+        C-style struct for the UUID data
+    """
+    _fields_ = [
+        ("time_low", c_uint32),
+        ("time_mid", c_uint16),
+        ("time_hi_and_version", c_uint16),
+        ("clock_seq_hi_and_reserved", c_uint8),
+        ("clock_seq_low", c_uint8),
+        ("node", c_uint8 * UUID_NODE_LEN)
+    ]
+
+    def to_uuid_class(self):
+        """
+            Helper function to convert the Python / C struct into the class
+                UUID from the library uuid, much easier to use.
+        """
+        return uuid.UUID(fields=(
+            self.time_low, self.time_mid, self.time_hi_and_version,
+            self.clock_seq_hi_and_reserved, self.clock_seq_low,
+            uint8array_to_number(self.node)))
+
+    def __str__(self):
+        """ Display this class as a normalized UUID string """
+        return self.to_uuid_class().__str__()
+
+def uuid_t_from_str(uuid_str):
+    """
+        Generate a Python / C-struct uuid_t class from a normalized uuid string
+    """
+    if len(uuid_str) != UUID_STR_LEN:
+        raise Exception("Wrong formatted UUID str: {}".format(uuid_str))
+    obj = uuid.UUID(uuid_str)
+    return uuid_t(
+        obj.time_low,
+        obj.time_mid,
+        obj.time_hi_version,
+        obj.clock_seq_hi_variant,
+        obj.clock_seq_low,
+        number_to_uint8array(obj.node, UUID_NODE_LEN))
+
+def get_uuids(uuids, key):
+    """
+        Get the UUID of a certain key, generate a new one if none is
+        found for the key
+    """
+    # TODO   Is there a context in which auto-generation of missing UUID
+    #           is not desirable ?
+    if key not in uuids.keys():
+        uuids[key] = str(uuid.uuid4())
+    return uuids[key]
+
+def validate_uuid(uuid_str):
+    try:
+        uuid.UUID(uuid_str)
+        return True
+    except ValueError:
+        return False
+
+def test_uuids(args):
+    uuid_str = "737d3401-64c1-4584-a40d-29f2238c82cf"
+    uuid_t = uuid_t_from_str(uuid_str)
+    print_and_assert(str(uuid_t), uuid_str)
diff --git a/tools/fwu_gen_metadata/tests/testall.sh b/tools/fwu_gen_metadata/tests/testall.sh
new file mode 100755
index 000000000..7b3050d3f
--- /dev/null
+++ b/tools/fwu_gen_metadata/tests/testall.sh
@@ -0,0 +1,21 @@
+#!/bin/bash
+
+VERBOSE=0
+SEPARATOR="\033[94m-------------------------------------------------------------------------\033[0m"
+if [ $VERBOSE -eq 1 ]; then
+	set -eux
+	OPTS=-v
+else
+	set -e
+	OPTS=
+fi
+
+rm -f dummy.bin dummy.json a.bin a.json
+
+../fwumd_tool.py dummy $OPTS
+echo -e "$SEPARATOR"
+../fwumd_tool.py jsonparse $OPTS dummy.json -b a.bin
+echo -e "$SEPARATOR"
+../fwumd_tool.py binparse $OPTS dummy.bin -j a.json
+echo -e "$SEPARATOR"
+../fwumd_tool.py test $OPTS
diff --git a/tools/fwu_gen_metadata/tests/validate_stable.sh b/tools/fwu_gen_metadata/tests/validate_stable.sh
new file mode 100755
index 000000000..957a833b6
--- /dev/null
+++ b/tools/fwu_gen_metadata/tests/validate_stable.sh
@@ -0,0 +1,8 @@
+#!/bin/bash
+
+set -e
+rm -f dummy*
+../fwumd_tool.py dummy
+../fwumd_tool.py binparse dummy.bin -j dummy2.json
+../fwumd_tool.py jsonparse dummy2.json -b dummy2.bin
+shasum dummy*.bin
diff --git a/tools/st/plat_fiptool/plat_def_uuid_config.c b/tools/st/plat_fiptool/plat_def_uuid_config.c
new file mode 100644
index 000000000..8bf104a5c
--- /dev/null
+++ b/tools/st/plat_fiptool/plat_def_uuid_config.c
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stddef.h>
+
+#include <firmware_image_package.h>
+
+#include "tbbr_config.h"
+
+toc_entry_t plat_def_toc_entries[] = {
+	{
+		.name = "DDR_FW",
+		.uuid = UUID_DDR_FW,
+		.cmdline_name = "ddr-fw"
+	}
+};
+
diff --git a/tools/st/plat_fiptool/plat_fiptool.mk b/tools/st/plat_fiptool/plat_fiptool.mk
new file mode 100644
index 000000000..747c64d8d
--- /dev/null
+++ b/tools/st/plat_fiptool/plat_fiptool.mk
@@ -0,0 +1,25 @@
+#
+# Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+# Name of the platform defined source file name,
+# which contains platform defined UUID entries populated
+# in the plat_def_toc_entries[].
+PLAT_DEF_UUID_CONFIG_FILE_NAME	:= plat_def_uuid_config
+
+PLAT_DEF_UUID_CONFIG_FILE_PATH := ../st/plat_fiptool
+
+PLAT_DEF_UUID := yes
+
+INCLUDE_PATHS +=  -I../../plat/st/stm32mp2/include/ \
+		  -I./
+
+ifeq (${PLAT_DEF_UUID},yes)
+HOSTCCFLAGS += -DPLAT_DEF_FIP_UUID
+PLAT_OBJECTS += ${PLAT_DEF_UUID_CONFIG_FILE_PATH}/${PLAT_DEF_UUID_CONFIG_FILE_NAME}.o
+endif
+
+OBJECTS += ${PLAT_OBJECTS}
+
diff --git a/tools/stm32image/stm32image.c b/tools/stm32image/stm32image.c
index fb1dee072..dd2df1253 100644
--- a/tools/stm32image/stm32image.c
+++ b/tools/stm32image/stm32image.c
@@ -22,16 +22,16 @@
 #define VER_MINOR		1
 #define VER_VARIANT		0
 #define HEADER_VERSION_V1	0x1
-#define TF_BINARY_TYPE		0x10
+#define HEADER_VERSION_V2	0x2
+#define PADDING_HEADER_MAGIC	__be32_to_cpu(0x5354FFFF)
+#define PADDING_HEADER_FLAG	(1 << 31)
+#define PADDING_HEADER_LENGTH	0x180
 
-/* Default option : bit0 => no signature */
-#define HEADER_DEFAULT_OPTION	(__cpu_to_le32(0x00000001))
-
-struct stm32_header {
+struct stm32_header_v1 {
 	uint32_t magic_number;
 	uint8_t image_signature[64];
 	uint32_t image_checksum;
-	uint8_t  header_version[4];
+	uint8_t header_version[4];
 	uint32_t image_length;
 	uint32_t image_entry_point;
 	uint32_t reserved1;
@@ -45,31 +45,50 @@ struct stm32_header {
 	uint8_t binary_type;
 };
 
-static void stm32image_default_header(struct stm32_header *ptr)
+struct stm32_header_v2 {
+	uint32_t magic_number;
+	uint8_t image_signature[64];
+	uint32_t image_checksum;
+	uint8_t header_version[4];
+	uint32_t image_length;
+	uint32_t image_entry_point;
+	uint32_t reserved1;
+	uint32_t load_address;
+	uint32_t reserved2;
+	uint32_t version_number;
+	uint32_t extension_flags;
+	uint32_t extension_headers_length;
+	uint32_t binary_type;
+	uint8_t padding[16];
+	uint32_t extension_header_type;
+	uint32_t extension_header_length;
+	uint8_t extension_padding[376];
+};
+
+static void stm32image_default_header(void *ptr)
 {
-	if (!ptr) {
+	struct stm32_header_v1 *header = (struct stm32_header_v1 *)ptr;
+
+	if (!header) {
 		return;
 	}
 
-	ptr->magic_number = HEADER_MAGIC;
-	ptr->option_flags = HEADER_DEFAULT_OPTION;
-	ptr->ecdsa_algorithm = __cpu_to_le32(1);
-	ptr->version_number = __cpu_to_le32(0);
-	ptr->binary_type = TF_BINARY_TYPE;
+	header->magic_number = HEADER_MAGIC;
+	header->version_number = __cpu_to_le32(0);
 }
 
-static uint32_t stm32image_checksum(void *start, uint32_t len)
+static uint32_t stm32image_checksum(void *start, uint32_t len,
+				    uint32_t header_size)
 {
 	uint32_t csum = 0;
-	uint32_t hdr_len = sizeof(struct stm32_header);
 	uint8_t *p;
 
-	if (len < hdr_len) {
+	if (len < header_size) {
 		return 0;
 	}
 
-	p = (unsigned char *)start + hdr_len;
-	len -= hdr_len;
+	p = (unsigned char *)start + header_size;
+	len -= header_size;
 
 	while (len > 0) {
 		csum += *p;
@@ -82,7 +101,8 @@ static uint32_t stm32image_checksum(void *start, uint32_t len)
 
 static void stm32image_print_header(const void *ptr)
 {
-	struct stm32_header *stm32hdr = (struct stm32_header *)ptr;
+	struct stm32_header_v1 *stm32hdr = (struct stm32_header_v1 *)ptr;
+	struct stm32_header_v2 *stm32hdr_v2 = (struct stm32_header_v2 *)ptr;
 
 	printf("Image Type   : ST Microelectronics STM32 V%d.%d\n",
 	       stm32hdr->header_version[VER_MAJOR],
@@ -95,40 +115,87 @@ static void stm32image_print_header(const void *ptr)
 	       __le32_to_cpu(stm32hdr->image_entry_point));
 	printf("Checksum     : 0x%08x\n",
 	       __le32_to_cpu(stm32hdr->image_checksum));
-	printf("Option     : 0x%08x\n",
-	       __le32_to_cpu(stm32hdr->option_flags));
-	printf("Version	   : 0x%08x\n",
+
+	switch (stm32hdr->header_version[VER_MAJOR]) {
+	case HEADER_VERSION_V1:
+		printf("Option     : 0x%08x\n",
+		       __le32_to_cpu(stm32hdr->option_flags));
+		break;
+
+	case HEADER_VERSION_V2:
+		printf("Extension    : 0x%08x\n",
+		       __le32_to_cpu(stm32hdr_v2->extension_flags));
+		break;
+
+	default:
+		printf("Incorrect header version\n");
+	}
+
+	printf("Version	     : 0x%08x\n",
 	       __le32_to_cpu(stm32hdr->version_number));
 }
 
-static void stm32image_set_header(void *ptr, struct stat *sbuf, int ifd,
-				  uint32_t loadaddr, uint32_t ep, uint32_t ver,
-				  uint32_t major, uint32_t minor)
+static int stm32image_set_header(void *ptr, struct stat *sbuf, int ifd,
+				 uint32_t loadaddr, uint32_t ep, uint32_t ver,
+				 uint32_t major, uint32_t minor,
+				 uint32_t binary_type, uint32_t header_size)
 {
-	struct stm32_header *stm32hdr = (struct stm32_header *)ptr;
+	struct stm32_header_v1 *stm32hdr = (struct stm32_header_v1 *)ptr;
+	struct stm32_header_v2 *stm32hdr_v2 = (struct stm32_header_v2 *)ptr;
+	uint32_t ext_size = 0U;
+	uint32_t ext_flags = 0U;
 
-	stm32image_default_header(stm32hdr);
+	stm32image_default_header(ptr);
 
 	stm32hdr->header_version[VER_MAJOR] = major;
 	stm32hdr->header_version[VER_MINOR] = minor;
 	stm32hdr->load_address = __cpu_to_le32(loadaddr);
 	stm32hdr->image_entry_point = __cpu_to_le32(ep);
 	stm32hdr->image_length = __cpu_to_le32((uint32_t)sbuf->st_size -
-					     sizeof(struct stm32_header));
+					       header_size);
 	stm32hdr->image_checksum =
-		__cpu_to_le32(stm32image_checksum(ptr, sbuf->st_size));
+		__cpu_to_le32(stm32image_checksum(ptr, sbuf->st_size,
+						  header_size));
+
+	switch (stm32hdr->header_version[VER_MAJOR]) {
+	case HEADER_VERSION_V1:
+		/* Default option for header v1 : bit0 => no signature */
+		stm32hdr->option_flags = __cpu_to_le32(0x00000001);
+		stm32hdr->ecdsa_algorithm = __cpu_to_le32(1);
+		stm32hdr->binary_type = (uint8_t)binary_type;
+		break;
+
+	case HEADER_VERSION_V2:
+		stm32hdr_v2->binary_type = binary_type;
+		ext_size += PADDING_HEADER_LENGTH;
+		ext_flags |= PADDING_HEADER_FLAG;
+		stm32hdr_v2->extension_flags =
+			__cpu_to_le32(ext_flags);
+		stm32hdr_v2->extension_headers_length =
+			__cpu_to_le32(ext_size);
+		stm32hdr_v2->extension_header_type = PADDING_HEADER_MAGIC;
+		stm32hdr_v2->extension_header_length =
+			__cpu_to_le32(PADDING_HEADER_LENGTH);
+		break;
+
+	default:
+		return -1;
+	}
+
 	stm32hdr->version_number = __cpu_to_le32(ver);
+
+	return 0;
 }
 
 static int stm32image_create_header_file(char *srcname, char *destname,
 					 uint32_t loadaddr, uint32_t entry,
 					 uint32_t version, uint32_t major,
-					 uint32_t minor)
+					 uint32_t minor, uint32_t binary_type)
 {
-	int src_fd, dest_fd;
+	int src_fd, dest_fd, header_size;
 	struct stat sbuf;
 	unsigned char *ptr;
-	struct stm32_header stm32image_header;
+	void *stm32image_header;
 
 	dest_fd = open(destname, O_RDWR | O_CREAT | O_TRUNC | O_APPEND, 0666);
 	if (dest_fd == -1) {
@@ -154,15 +221,32 @@ static int stm32image_create_header_file(char *srcname, char *destname,
 		return -1;
 	}
 
-	memset(&stm32image_header, 0, sizeof(struct stm32_header));
+	switch (major) {
+	case HEADER_VERSION_V1:
+		stm32image_header = malloc(sizeof(struct stm32_header_v1));
+		header_size = sizeof(struct stm32_header_v1);
+		break;
+
+	case HEADER_VERSION_V2:
+		stm32image_header = malloc(sizeof(struct stm32_header_v2));
+		header_size = sizeof(struct stm32_header_v2);
+		break;
 
-	if (write(dest_fd, &stm32image_header, sizeof(struct stm32_header)) !=
-	    sizeof(struct stm32_header)) {
+	default:
+		return -1;
+	}
+
+	memset(stm32image_header, 0, header_size);
+	if (write(dest_fd, stm32image_header, header_size) !=
+	    header_size) {
 		fprintf(stderr, "Write error %s: %s\n", destname,
 			strerror(errno));
+		free(stm32image_header);
 		return -1;
 	}
 
+	free(stm32image_header);
+
 	if (write(dest_fd, ptr, sbuf.st_size) != sbuf.st_size) {
 		fprintf(stderr, "Write error on %s: %s\n", destname,
 			strerror(errno));
@@ -184,8 +268,11 @@ static int stm32image_create_header_file(char *srcname, char *destname,
 		return -1;
 	}
 
-	stm32image_set_header(ptr, &sbuf, dest_fd, loadaddr, entry, version,
-			      major, minor);
+	if (stm32image_set_header(ptr, &sbuf, dest_fd, loadaddr,
+				  entry, version, major, minor,
+				  binary_type, header_size) != 0) {
+		return -1;
+	}
 
 	stm32image_print_header(ptr);
 
@@ -196,13 +283,22 @@ static int stm32image_create_header_file(char *srcname, char *destname,
 
 int main(int argc, char *argv[])
 {
-	int opt, loadaddr = -1, entry = -1, err = 0, version = 0;
-	int major = HEADER_VERSION_V1;
+	int opt;
+	int loadaddr = -1;
+	int entry = -1;
+	int err = 0;
+	int version = 0;
+	int binary_type = -1;
+	int major = HEADER_VERSION_V2;
 	int minor = 0;
-	char *dest = NULL, *src = NULL;
+	char *dest = NULL;
+	char *src = NULL;
 
-	while ((opt = getopt(argc, argv, ":s:d:l:e:v:m:n:")) != -1) {
+	while ((opt = getopt(argc, argv, ":b:s:d:l:e:v:m:n:")) != -1) {
 		switch (opt) {
+		case 'b':
+			binary_type = strtol(optarg, NULL, 0);
+			break;
 		case 's':
 			src = optarg;
 			break;
@@ -226,7 +322,7 @@ int main(int argc, char *argv[])
 			break;
 		default:
 			fprintf(stderr,
-				"Usage : %s [-s srcfile] [-d destfile] [-l loadaddr] [-e entry_point] [-m major] [-n minor]\n",
+				"Usage : %s [-s srcfile] [-d destfile] [-l loadaddr] [-e entry_point] [-m major] [-n minor] [-b binary_type]\n",
 					argv[0]);
 			return -1;
 		}
@@ -252,8 +348,14 @@ int main(int argc, char *argv[])
 		return -1;
 	}
 
+	if (binary_type == -1) {
+		fprintf(stderr, "Missing -b option\n");
+		return -1;
+	}
+
 	err = stm32image_create_header_file(src, dest, loadaddr,
-					    entry, version, major, minor);
+					    entry, version, major, minor,
+					    binary_type);
 
 	return err;
 }
-- 
2.25.1

